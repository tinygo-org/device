// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from ATSAMA5D35.svd, see https://github.com/posborne/cmsis-svd/tree/master/data/Atmel

//go:build sam && atsama5d35
// +build sam,atsama5d35

// Atmel ATSAMA5D35 device: ARM Cortex-A5 processor-based embedded MPU, 536MHz, Linux support, FPU, dual Ethernet, dual CAN, security (refer to http://www.atmel.com/devices/SAMA5D35.aspx for more)
//

package sam

import (
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device = "ATSAMA5D35"
)

// Interrupt numbers.
const (
	// Advanced Interrupt Controller
	IRQ_FIQ = 0

	// Power Management Controller
	IRQ_PMC = 1

	// Debug Unit
	IRQ_DBGU = 2

	// Parallel Input/Output Controller A
	IRQ_PIOA = 6

	// Parallel Input/Output Controller B
	IRQ_PIOB = 7

	// Parallel Input/Output Controller C
	IRQ_PIOC = 8

	// Parallel Input/Output Controller D
	IRQ_PIOD = 9

	// Parallel Input/Output Controller E
	IRQ_PIOE = 10

	// Software Modem Device
	IRQ_SMD = 11

	// Universal Synchronous Asynchronous Receiver Transmitter 0
	IRQ_USART0 = 12

	// Universal Synchronous Asynchronous Receiver Transmitter 1
	IRQ_USART1 = 13

	// Universal Synchronous Asynchronous Receiver Transmitter 2
	IRQ_USART2 = 14

	// Universal Synchronous Asynchronous Receiver Transmitter 3
	IRQ_USART3 = 15

	// Universal Asynchronous Receiver Transmitter 0
	IRQ_UART0 = 16

	// Universal Asynchronous Receiver Transmitter 1
	IRQ_UART1 = 17

	// Two-wire Interface 0
	IRQ_TWI0 = 18

	// Two-wire Interface 1
	IRQ_TWI1 = 19

	// Two-wire Interface 2
	IRQ_TWI2 = 20

	// High Speed MultiMedia Card Interface 0
	IRQ_HSMCI0 = 21

	// High Speed MultiMedia Card Interface 1
	IRQ_HSMCI1 = 22

	// High Speed MultiMedia Card Interface 2
	IRQ_HSMCI2 = 23

	// Serial Peripheral Interface 0
	IRQ_SPI0 = 24

	// Serial Peripheral Interface 1
	IRQ_SPI1 = 25

	// Timer Counter 0
	IRQ_TC0 = 26

	// Timer Counter 0
	IRQ_TC1 = 27

	// Pulse Width Modulation Controller
	IRQ_PWM = 28

	// Analog-to-Digital Converter
	IRQ_ADC = 29

	// DMA Controller 0
	IRQ_DMAC0 = 30

	// DMA Controller 1
	IRQ_DMAC1 = 31

	// USB High Speed Device Port
	IRQ_UDPHS = 33

	// Gigabit Ethernet MAC
	IRQ_GMAC = 34

	// Ethernet MAC 10/100
	IRQ_EMAC = 35

	// Image Sensor Interface
	IRQ_ISI = 37

	// Synchronous Serial Controller 0
	IRQ_SSC0 = 38

	// Synchronous Serial Controller 1
	IRQ_SSC1 = 39

	// Controller Area Network 0
	IRQ_CAN0 = 40

	// Controller Area Network 1
	IRQ_CAN1 = 41

	// True Random Number Generator
	IRQ_TRNG = 45

	// Advanced Interrupt Controller
	IRQ_IRQ = 47

	// Fuse Controller
	IRQ_FUSE = 48

	// Highest interrupt number on this device.
	IRQ_max = 48
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int)

//export FIQ_IRQHandler
func interruptFIQ() {
	callHandlers(IRQ_FIQ)
}

//export PMC_IRQHandler
func interruptPMC() {
	callHandlers(IRQ_PMC)
}

//export DBGU_IRQHandler
func interruptDBGU() {
	callHandlers(IRQ_DBGU)
}

//export PIOA_IRQHandler
func interruptPIOA() {
	callHandlers(IRQ_PIOA)
}

//export PIOB_IRQHandler
func interruptPIOB() {
	callHandlers(IRQ_PIOB)
}

//export PIOC_IRQHandler
func interruptPIOC() {
	callHandlers(IRQ_PIOC)
}

//export PIOD_IRQHandler
func interruptPIOD() {
	callHandlers(IRQ_PIOD)
}

//export PIOE_IRQHandler
func interruptPIOE() {
	callHandlers(IRQ_PIOE)
}

//export SMD_IRQHandler
func interruptSMD() {
	callHandlers(IRQ_SMD)
}

//export USART0_IRQHandler
func interruptUSART0() {
	callHandlers(IRQ_USART0)
}

//export USART1_IRQHandler
func interruptUSART1() {
	callHandlers(IRQ_USART1)
}

//export USART2_IRQHandler
func interruptUSART2() {
	callHandlers(IRQ_USART2)
}

//export USART3_IRQHandler
func interruptUSART3() {
	callHandlers(IRQ_USART3)
}

//export UART0_IRQHandler
func interruptUART0() {
	callHandlers(IRQ_UART0)
}

//export UART1_IRQHandler
func interruptUART1() {
	callHandlers(IRQ_UART1)
}

//export TWI0_IRQHandler
func interruptTWI0() {
	callHandlers(IRQ_TWI0)
}

//export TWI1_IRQHandler
func interruptTWI1() {
	callHandlers(IRQ_TWI1)
}

//export TWI2_IRQHandler
func interruptTWI2() {
	callHandlers(IRQ_TWI2)
}

//export HSMCI0_IRQHandler
func interruptHSMCI0() {
	callHandlers(IRQ_HSMCI0)
}

//export HSMCI1_IRQHandler
func interruptHSMCI1() {
	callHandlers(IRQ_HSMCI1)
}

//export HSMCI2_IRQHandler
func interruptHSMCI2() {
	callHandlers(IRQ_HSMCI2)
}

//export SPI0_IRQHandler
func interruptSPI0() {
	callHandlers(IRQ_SPI0)
}

//export SPI1_IRQHandler
func interruptSPI1() {
	callHandlers(IRQ_SPI1)
}

//export TC0_IRQHandler
func interruptTC0() {
	callHandlers(IRQ_TC0)
}

//export TC1_IRQHandler
func interruptTC1() {
	callHandlers(IRQ_TC1)
}

//export PWM_IRQHandler
func interruptPWM() {
	callHandlers(IRQ_PWM)
}

//export ADC_IRQHandler
func interruptADC() {
	callHandlers(IRQ_ADC)
}

//export DMAC0_IRQHandler
func interruptDMAC0() {
	callHandlers(IRQ_DMAC0)
}

//export DMAC1_IRQHandler
func interruptDMAC1() {
	callHandlers(IRQ_DMAC1)
}

//export UDPHS_IRQHandler
func interruptUDPHS() {
	callHandlers(IRQ_UDPHS)
}

//export GMAC_IRQHandler
func interruptGMAC() {
	callHandlers(IRQ_GMAC)
}

//export EMAC_IRQHandler
func interruptEMAC() {
	callHandlers(IRQ_EMAC)
}

//export ISI_IRQHandler
func interruptISI() {
	callHandlers(IRQ_ISI)
}

//export SSC0_IRQHandler
func interruptSSC0() {
	callHandlers(IRQ_SSC0)
}

//export SSC1_IRQHandler
func interruptSSC1() {
	callHandlers(IRQ_SSC1)
}

//export CAN0_IRQHandler
func interruptCAN0() {
	callHandlers(IRQ_CAN0)
}

//export CAN1_IRQHandler
func interruptCAN1() {
	callHandlers(IRQ_CAN1)
}

//export TRNG_IRQHandler
func interruptTRNG() {
	callHandlers(IRQ_TRNG)
}

//export IRQ_IRQHandler
func interruptIRQ() {
	callHandlers(IRQ_IRQ)
}

//export FUSE_IRQHandler
func interruptFUSE() {
	callHandlers(IRQ_FUSE)
}

// Peripherals.
var (
	// Software Modem Device
	SMD = (*SMD_Type)(unsafe.Pointer(uintptr(0x400000)))

	// AXI Matrix
	AXIMX = (*AXIMX_Type)(unsafe.Pointer(uintptr(0x800000)))

	// High Speed MultiMedia Card Interface 0
	HSMCI0 = (*HSMCI_Type)(unsafe.Pointer(uintptr(0xf0000000)))

	// Serial Peripheral Interface 0
	SPI0 = (*SPI_Type)(unsafe.Pointer(uintptr(0xf0004000)))

	// Synchronous Serial Controller 0
	SSC0 = (*SSC_Type)(unsafe.Pointer(uintptr(0xf0008000)))

	// Controller Area Network 0
	CAN0 = (*CAN_Type)(unsafe.Pointer(uintptr(0xf000c000)))

	// Timer Counter 0
	TC0 = (*TC_Type)(unsafe.Pointer(uintptr(0xf0010000)))

	// Two-wire Interface 0
	TWI0 = (*TWI_Type)(unsafe.Pointer(uintptr(0xf0014000)))

	// Two-wire Interface 1
	TWI1 = (*TWI_Type)(unsafe.Pointer(uintptr(0xf0018000)))

	// Universal Synchronous Asynchronous Receiver Transmitter 0
	USART0 = (*USART_Type)(unsafe.Pointer(uintptr(0xf001c000)))

	// Universal Synchronous Asynchronous Receiver Transmitter 1
	USART1 = (*USART_Type)(unsafe.Pointer(uintptr(0xf0020000)))

	// Universal Asynchronous Receiver Transmitter 0
	UART0 = (*UART_Type)(unsafe.Pointer(uintptr(0xf0024000)))

	// Gigabit Ethernet MAC
	GMAC = (*GMAC_Type)(unsafe.Pointer(uintptr(0xf0028000)))

	// Pulse Width Modulation Controller
	PWM = (*PWM_Type)(unsafe.Pointer(uintptr(0xf002c000)))

	// Image Sensor Interface
	ISI = (*ISI_Type)(unsafe.Pointer(uintptr(0xf0034000)))

	// Special Function Registers
	SFR = (*SFR_Type)(unsafe.Pointer(uintptr(0xf0038000)))

	// High Speed MultiMedia Card Interface 1
	HSMCI1 = (*HSMCI_Type)(unsafe.Pointer(uintptr(0xf8000000)))

	// High Speed MultiMedia Card Interface 2
	HSMCI2 = (*HSMCI_Type)(unsafe.Pointer(uintptr(0xf8004000)))

	// Serial Peripheral Interface 1
	SPI1 = (*SPI_Type)(unsafe.Pointer(uintptr(0xf8008000)))

	// Synchronous Serial Controller 1
	SSC1 = (*SSC_Type)(unsafe.Pointer(uintptr(0xf800c000)))

	// Controller Area Network 1
	CAN1 = (*CAN_Type)(unsafe.Pointer(uintptr(0xf8010000)))

	// Timer Counter 1
	TC1 = (*TC_Type)(unsafe.Pointer(uintptr(0xf8014000)))

	// Analog-to-Digital Converter
	ADC = (*ADC_Type)(unsafe.Pointer(uintptr(0xf8018000)))

	// Two-wire Interface 2
	TWI2 = (*TWI_Type)(unsafe.Pointer(uintptr(0xf801c000)))

	// Universal Synchronous Asynchronous Receiver Transmitter 2
	USART2 = (*USART_Type)(unsafe.Pointer(uintptr(0xf8020000)))

	// Universal Synchronous Asynchronous Receiver Transmitter 3
	USART3 = (*USART_Type)(unsafe.Pointer(uintptr(0xf8024000)))

	// Universal Asynchronous Receiver Transmitter 1
	UART1 = (*UART_Type)(unsafe.Pointer(uintptr(0xf8028000)))

	// Ethernet MAC 10/100
	EMAC = (*EMAC_Type)(unsafe.Pointer(uintptr(0xf802c000)))

	// USB High Speed Device Port
	UDPHS = (*UDPHS_Type)(unsafe.Pointer(uintptr(0xf8030000)))

	// True Random Number Generator
	TRNG = (*TRNG_Type)(unsafe.Pointer(uintptr(0xf8040000)))

	// Fuse Controller
	FUSE = (*FUSE_Type)(unsafe.Pointer(uintptr(0xffffe400)))

	// DMA Controller 0
	DMAC0 = (*DMAC_Type)(unsafe.Pointer(uintptr(0xffffe600)))

	// DMA Controller 1
	DMAC1 = (*DMAC_Type)(unsafe.Pointer(uintptr(0xffffe800)))

	// AHB Multi-port DDR-SDRAM Controller
	MPDDRC = (*EBI_Type)(unsafe.Pointer(uintptr(0xffffea00)))

	// AHB Bus Matrix
	MATRIX = (*MATRIX_Type)(unsafe.Pointer(uintptr(0xffffec00)))

	// Debug Unit
	DBGU = (*DBGU_Type)(unsafe.Pointer(uintptr(0xffffee00)))

	// Advanced Interrupt Controller
	AIC = (*AIC_Type)(unsafe.Pointer(uintptr(0xfffff000)))

	// Parallel Input/Output Controller A
	PIOA = (*PIO_Type)(unsafe.Pointer(uintptr(0xfffff200)))

	// Parallel Input/Output Controller B
	PIOB = (*PIO_Type)(unsafe.Pointer(uintptr(0xfffff400)))

	// Parallel Input/Output Controller C
	PIOC = (*PIO_Type)(unsafe.Pointer(uintptr(0xfffff600)))

	// Parallel Input/Output Controller D
	PIOD = (*PIO_Type)(unsafe.Pointer(uintptr(0xfffff800)))

	// Parallel Input/Output Controller E
	PIOE = (*PIO_Type)(unsafe.Pointer(uintptr(0xfffffa00)))

	// Power Management Controller
	PMC = (*PMC_Type)(unsafe.Pointer(uintptr(0xfffffc00)))

	// Reset Controller
	RSTC = (*SYSC_Type)(unsafe.Pointer(uintptr(0xfffffe00)))

	// Shutdown Controller
	SHDWC = (*SYSC_Type)(unsafe.Pointer(uintptr(0xfffffe10)))

	// Periodic Interval Timer
	PIT = (*SYSC_Type)(unsafe.Pointer(uintptr(0xfffffe30)))

	// Watchdog Timer
	WDT = (*SYSC_Type)(unsafe.Pointer(uintptr(0xfffffe40)))

	// Slow Clock Controller
	SCKC = (*SYSC_Type)(unsafe.Pointer(uintptr(0xfffffe50)))

	// Boot Sequence Controller
	BSC = (*SYSC_Type)(unsafe.Pointer(uintptr(0xfffffe54)))

	// General Purpose Backup Register
	GPBR = (*SYSC_Type)(unsafe.Pointer(uintptr(0xfffffe60)))

	// Real-time Clock
	RTC = (*SYSC_Type)(unsafe.Pointer(uintptr(0xfffffeb0)))
)

// Software Modem Device
type SMD_Type struct {
}

// AXI Matrix
type AXIMX_Type struct {
	REMAP               volatile.Register32 // 0x0
	_                   [8140]byte
	PERIPH_ID4          volatile.Register32    // 0x1FD0
	PERIPH_ID5          volatile.Register32    // 0x1FD4
	PERIPH_ID6          volatile.Register32    // 0x1FD8
	PERIPH_ID7          volatile.Register32    // 0x1FDC
	PERIPH_ID0          volatile.Register32    // 0x1FE0
	PERIPH_ID1          volatile.Register32    // 0x1FE4
	PERIPH_ID2          volatile.Register32    // 0x1FE8
	PERIPH_ID3          volatile.Register32    // 0x1FEC
	COMP_ID             [4]volatile.Register32 // 0x1FF0
	_                   [12296]byte
	AMIB3_FN_MOD_BM_ISS volatile.Register32 // 0x5008
	_                   [24]byte
	AMIB3_FN_MOD2       volatile.Register32 // 0x5024
	_                   [250072]byte
	ASIB0_READ_QOS      volatile.Register32 // 0x42100
	ASIB0_WRITE_QOS     volatile.Register32 // 0x42104
	_                   [3872]byte
	ASIB1_FN_MOD_AHB    volatile.Register32 // 0x43028
	_                   [212]byte
	ASIB1_READ_QOS      volatile.Register32 // 0x43100
	ASIB1_WRITE_QOS     volatile.Register32 // 0x43104
	ASIB1_FN_MOD        volatile.Register32 // 0x43108
}

// AXIMX.REMAP: Remap Register
func (o *AXIMX_Type) SetREMAP_REMAP0(value uint32) {
	volatile.StoreUint32(&o.REMAP.Reg, volatile.LoadUint32(&o.REMAP.Reg)&^(0x1)|value)
}
func (o *AXIMX_Type) GetREMAP_REMAP0() uint32 {
	return volatile.LoadUint32(&o.REMAP.Reg) & 0x1
}
func (o *AXIMX_Type) SetREMAP_REMAP1(value uint32) {
	volatile.StoreUint32(&o.REMAP.Reg, volatile.LoadUint32(&o.REMAP.Reg)&^(0x2)|value<<1)
}
func (o *AXIMX_Type) GetREMAP_REMAP1() uint32 {
	return (volatile.LoadUint32(&o.REMAP.Reg) & 0x2) >> 1
}

// AXIMX.PERIPH_ID4: Peripheral ID Register 4
func (o *AXIMX_Type) SetPERIPH_ID4_ID(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID4.Reg, volatile.LoadUint32(&o.PERIPH_ID4.Reg)&^(0xff)|value)
}
func (o *AXIMX_Type) GetPERIPH_ID4_ID() uint32 {
	return volatile.LoadUint32(&o.PERIPH_ID4.Reg) & 0xff
}

// AXIMX.PERIPH_ID5: Peripheral ID Register 5
func (o *AXIMX_Type) SetPERIPH_ID5_ID(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID5.Reg, volatile.LoadUint32(&o.PERIPH_ID5.Reg)&^(0xff)|value)
}
func (o *AXIMX_Type) GetPERIPH_ID5_ID() uint32 {
	return volatile.LoadUint32(&o.PERIPH_ID5.Reg) & 0xff
}

// AXIMX.PERIPH_ID6: Peripheral ID Register 6
func (o *AXIMX_Type) SetPERIPH_ID6_ID(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID6.Reg, volatile.LoadUint32(&o.PERIPH_ID6.Reg)&^(0xff)|value)
}
func (o *AXIMX_Type) GetPERIPH_ID6_ID() uint32 {
	return volatile.LoadUint32(&o.PERIPH_ID6.Reg) & 0xff
}

// AXIMX.PERIPH_ID7: Peripheral ID Register 7
func (o *AXIMX_Type) SetPERIPH_ID7_ID(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID7.Reg, volatile.LoadUint32(&o.PERIPH_ID7.Reg)&^(0xff)|value)
}
func (o *AXIMX_Type) GetPERIPH_ID7_ID() uint32 {
	return volatile.LoadUint32(&o.PERIPH_ID7.Reg) & 0xff
}

// AXIMX.PERIPH_ID0: Peripheral ID Register 0
func (o *AXIMX_Type) SetPERIPH_ID0_ID(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID0.Reg, volatile.LoadUint32(&o.PERIPH_ID0.Reg)&^(0xff)|value)
}
func (o *AXIMX_Type) GetPERIPH_ID0_ID() uint32 {
	return volatile.LoadUint32(&o.PERIPH_ID0.Reg) & 0xff
}

// AXIMX.PERIPH_ID1: Peripheral ID Register 1
func (o *AXIMX_Type) SetPERIPH_ID1_ID(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID1.Reg, volatile.LoadUint32(&o.PERIPH_ID1.Reg)&^(0xff)|value)
}
func (o *AXIMX_Type) GetPERIPH_ID1_ID() uint32 {
	return volatile.LoadUint32(&o.PERIPH_ID1.Reg) & 0xff
}

// AXIMX.PERIPH_ID2: Peripheral ID Register 2
func (o *AXIMX_Type) SetPERIPH_ID2_ID(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID2.Reg, volatile.LoadUint32(&o.PERIPH_ID2.Reg)&^(0xff)|value)
}
func (o *AXIMX_Type) GetPERIPH_ID2_ID() uint32 {
	return volatile.LoadUint32(&o.PERIPH_ID2.Reg) & 0xff
}

// AXIMX.PERIPH_ID3: Peripheral ID Register 3
func (o *AXIMX_Type) SetPERIPH_ID3_ID(value uint32) {
	volatile.StoreUint32(&o.PERIPH_ID3.Reg, volatile.LoadUint32(&o.PERIPH_ID3.Reg)&^(0xff)|value)
}
func (o *AXIMX_Type) GetPERIPH_ID3_ID() uint32 {
	return volatile.LoadUint32(&o.PERIPH_ID3.Reg) & 0xff
}

// AXIMX.COMP_ID: Component ID Register
func (o *AXIMX_Type) SetCOMP_ID_ID(idx int, value uint32) {
	volatile.StoreUint32(&o.COMP_ID[idx].Reg, volatile.LoadUint32(&o.COMP_ID[idx].Reg)&^(0xff)|value)
}
func (o *AXIMX_Type) GetCOMP_ID_ID(idx int) uint32 {
	return volatile.LoadUint32(&o.COMP_ID[idx].Reg) & 0xff
}

// AXIMX.AMIB3_FN_MOD_BM_ISS: AMIB3 Bus Matrix Functionality Modification Register
func (o *AXIMX_Type) SetAMIB3_FN_MOD_BM_ISS_RD_ISS(value uint32) {
	volatile.StoreUint32(&o.AMIB3_FN_MOD_BM_ISS.Reg, volatile.LoadUint32(&o.AMIB3_FN_MOD_BM_ISS.Reg)&^(0x1)|value)
}
func (o *AXIMX_Type) GetAMIB3_FN_MOD_BM_ISS_RD_ISS() uint32 {
	return volatile.LoadUint32(&o.AMIB3_FN_MOD_BM_ISS.Reg) & 0x1
}
func (o *AXIMX_Type) SetAMIB3_FN_MOD_BM_ISS_WR_ISS(value uint32) {
	volatile.StoreUint32(&o.AMIB3_FN_MOD_BM_ISS.Reg, volatile.LoadUint32(&o.AMIB3_FN_MOD_BM_ISS.Reg)&^(0x2)|value<<1)
}
func (o *AXIMX_Type) GetAMIB3_FN_MOD_BM_ISS_WR_ISS() uint32 {
	return (volatile.LoadUint32(&o.AMIB3_FN_MOD_BM_ISS.Reg) & 0x2) >> 1
}

// AXIMX.AMIB3_FN_MOD2: AMIB3 Bypass Merge
func (o *AXIMX_Type) SetAMIB3_FN_MOD2_BP_MRG(value uint32) {
	volatile.StoreUint32(&o.AMIB3_FN_MOD2.Reg, volatile.LoadUint32(&o.AMIB3_FN_MOD2.Reg)&^(0x1)|value)
}
func (o *AXIMX_Type) GetAMIB3_FN_MOD2_BP_MRG() uint32 {
	return volatile.LoadUint32(&o.AMIB3_FN_MOD2.Reg) & 0x1
}

// AXIMX.ASIB0_READ_QOS: ASIB0 Read Channel QoS Register
func (o *AXIMX_Type) SetASIB0_READ_QOS_RD_QOS(value uint32) {
	volatile.StoreUint32(&o.ASIB0_READ_QOS.Reg, volatile.LoadUint32(&o.ASIB0_READ_QOS.Reg)&^(0xf)|value)
}
func (o *AXIMX_Type) GetASIB0_READ_QOS_RD_QOS() uint32 {
	return volatile.LoadUint32(&o.ASIB0_READ_QOS.Reg) & 0xf
}

// AXIMX.ASIB0_WRITE_QOS: ASIB0 Write Channel QoS Register
func (o *AXIMX_Type) SetASIB0_WRITE_QOS_WR_QOS(value uint32) {
	volatile.StoreUint32(&o.ASIB0_WRITE_QOS.Reg, volatile.LoadUint32(&o.ASIB0_WRITE_QOS.Reg)&^(0xf)|value)
}
func (o *AXIMX_Type) GetASIB0_WRITE_QOS_WR_QOS() uint32 {
	return volatile.LoadUint32(&o.ASIB0_WRITE_QOS.Reg) & 0xf
}

// AXIMX.ASIB1_FN_MOD_AHB: ASIB1 AHB Functionality Modification Register
func (o *AXIMX_Type) SetASIB1_FN_MOD_AHB_RD_INCR_OVR(value uint32) {
	volatile.StoreUint32(&o.ASIB1_FN_MOD_AHB.Reg, volatile.LoadUint32(&o.ASIB1_FN_MOD_AHB.Reg)&^(0x1)|value)
}
func (o *AXIMX_Type) GetASIB1_FN_MOD_AHB_RD_INCR_OVR() uint32 {
	return volatile.LoadUint32(&o.ASIB1_FN_MOD_AHB.Reg) & 0x1
}
func (o *AXIMX_Type) SetASIB1_FN_MOD_AHB_WR_INCR_OVR(value uint32) {
	volatile.StoreUint32(&o.ASIB1_FN_MOD_AHB.Reg, volatile.LoadUint32(&o.ASIB1_FN_MOD_AHB.Reg)&^(0x2)|value<<1)
}
func (o *AXIMX_Type) GetASIB1_FN_MOD_AHB_WR_INCR_OVR() uint32 {
	return (volatile.LoadUint32(&o.ASIB1_FN_MOD_AHB.Reg) & 0x2) >> 1
}
func (o *AXIMX_Type) SetASIB1_FN_MOD_AHB_LOCK_OVR(value uint32) {
	volatile.StoreUint32(&o.ASIB1_FN_MOD_AHB.Reg, volatile.LoadUint32(&o.ASIB1_FN_MOD_AHB.Reg)&^(0x4)|value<<2)
}
func (o *AXIMX_Type) GetASIB1_FN_MOD_AHB_LOCK_OVR() uint32 {
	return (volatile.LoadUint32(&o.ASIB1_FN_MOD_AHB.Reg) & 0x4) >> 2
}

// AXIMX.ASIB1_READ_QOS: ASIB1 Read Channel QoS Register
func (o *AXIMX_Type) SetASIB1_READ_QOS_RD_QOS(value uint32) {
	volatile.StoreUint32(&o.ASIB1_READ_QOS.Reg, volatile.LoadUint32(&o.ASIB1_READ_QOS.Reg)&^(0xf)|value)
}
func (o *AXIMX_Type) GetASIB1_READ_QOS_RD_QOS() uint32 {
	return volatile.LoadUint32(&o.ASIB1_READ_QOS.Reg) & 0xf
}

// AXIMX.ASIB1_WRITE_QOS: ASIB1 Write Channel QoS Register
func (o *AXIMX_Type) SetASIB1_WRITE_QOS_WR_QOS(value uint32) {
	volatile.StoreUint32(&o.ASIB1_WRITE_QOS.Reg, volatile.LoadUint32(&o.ASIB1_WRITE_QOS.Reg)&^(0xf)|value)
}
func (o *AXIMX_Type) GetASIB1_WRITE_QOS_WR_QOS() uint32 {
	return volatile.LoadUint32(&o.ASIB1_WRITE_QOS.Reg) & 0xf
}

// AXIMX.ASIB1_FN_MOD: ASIB1 Issuing Functionality Modification Register
func (o *AXIMX_Type) SetASIB1_FN_MOD_RD_ISS(value uint32) {
	volatile.StoreUint32(&o.ASIB1_FN_MOD.Reg, volatile.LoadUint32(&o.ASIB1_FN_MOD.Reg)&^(0x1)|value)
}
func (o *AXIMX_Type) GetASIB1_FN_MOD_RD_ISS() uint32 {
	return volatile.LoadUint32(&o.ASIB1_FN_MOD.Reg) & 0x1
}
func (o *AXIMX_Type) SetASIB1_FN_MOD_WR_ISS(value uint32) {
	volatile.StoreUint32(&o.ASIB1_FN_MOD.Reg, volatile.LoadUint32(&o.ASIB1_FN_MOD.Reg)&^(0x2)|value<<1)
}
func (o *AXIMX_Type) GetASIB1_FN_MOD_WR_ISS() uint32 {
	return (volatile.LoadUint32(&o.ASIB1_FN_MOD.Reg) & 0x2) >> 1
}

// High Speed MultiMedia Card Interface 0
type HSMCI_Type struct {
	CR    volatile.Register32    // 0x0
	MR    volatile.Register32    // 0x4
	DTOR  volatile.Register32    // 0x8
	SDCR  volatile.Register32    // 0xC
	ARGR  volatile.Register32    // 0x10
	CMDR  volatile.Register32    // 0x14
	BLKR  volatile.Register32    // 0x18
	CSTOR volatile.Register32    // 0x1C
	RSPR  [4]volatile.Register32 // 0x20
	RDR   volatile.Register32    // 0x30
	TDR   volatile.Register32    // 0x34
	_     [8]byte
	SR    volatile.Register32 // 0x40
	IER   volatile.Register32 // 0x44
	IDR   volatile.Register32 // 0x48
	IMR   volatile.Register32 // 0x4C
	DMA   volatile.Register32 // 0x50
	CFG   volatile.Register32 // 0x54
	_     [140]byte
	WPMR  volatile.Register32 // 0xE4
	WPSR  volatile.Register32 // 0xE8
	_     [276]byte
	FIFO  [256]volatile.Register32 // 0x200
}

// HSMCI.CR: Control Register
func (o *HSMCI_Type) SetCR_MCIEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *HSMCI_Type) GetCR_MCIEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *HSMCI_Type) SetCR_MCIDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *HSMCI_Type) GetCR_MCIDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *HSMCI_Type) SetCR_PWSEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *HSMCI_Type) GetCR_PWSEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *HSMCI_Type) SetCR_PWSDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *HSMCI_Type) GetCR_PWSDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *HSMCI_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *HSMCI_Type) GetCR_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}

// HSMCI.MR: Mode Register
func (o *HSMCI_Type) SetMR_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xff)|value)
}
func (o *HSMCI_Type) GetMR_CLKDIV() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0xff
}
func (o *HSMCI_Type) SetMR_PWSDIV(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x700)|value<<8)
}
func (o *HSMCI_Type) GetMR_PWSDIV() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x700) >> 8
}
func (o *HSMCI_Type) SetMR_RDPROOF(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x800)|value<<11)
}
func (o *HSMCI_Type) GetMR_RDPROOF() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x800) >> 11
}
func (o *HSMCI_Type) SetMR_WRPROOF(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetMR_WRPROOF() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x1000) >> 12
}
func (o *HSMCI_Type) SetMR_FBYTE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x2000)|value<<13)
}
func (o *HSMCI_Type) GetMR_FBYTE() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x2000) >> 13
}
func (o *HSMCI_Type) SetMR_PADV(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x4000)|value<<14)
}
func (o *HSMCI_Type) GetMR_PADV() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x4000) >> 14
}
func (o *HSMCI_Type) SetMR_CLKODD(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10000)|value<<16)
}
func (o *HSMCI_Type) GetMR_CLKODD() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10000) >> 16
}

// HSMCI.DTOR: Data Timeout Register
func (o *HSMCI_Type) SetDTOR_DTOCYC(value uint32) {
	volatile.StoreUint32(&o.DTOR.Reg, volatile.LoadUint32(&o.DTOR.Reg)&^(0xf)|value)
}
func (o *HSMCI_Type) GetDTOR_DTOCYC() uint32 {
	return volatile.LoadUint32(&o.DTOR.Reg) & 0xf
}
func (o *HSMCI_Type) SetDTOR_DTOMUL(value uint32) {
	volatile.StoreUint32(&o.DTOR.Reg, volatile.LoadUint32(&o.DTOR.Reg)&^(0x70)|value<<4)
}
func (o *HSMCI_Type) GetDTOR_DTOMUL() uint32 {
	return (volatile.LoadUint32(&o.DTOR.Reg) & 0x70) >> 4
}

// HSMCI.SDCR: SD/SDIO Card Register
func (o *HSMCI_Type) SetSDCR_SDCSEL(value uint32) {
	volatile.StoreUint32(&o.SDCR.Reg, volatile.LoadUint32(&o.SDCR.Reg)&^(0x3)|value)
}
func (o *HSMCI_Type) GetSDCR_SDCSEL() uint32 {
	return volatile.LoadUint32(&o.SDCR.Reg) & 0x3
}
func (o *HSMCI_Type) SetSDCR_SDCBUS(value uint32) {
	volatile.StoreUint32(&o.SDCR.Reg, volatile.LoadUint32(&o.SDCR.Reg)&^(0xc0)|value<<6)
}
func (o *HSMCI_Type) GetSDCR_SDCBUS() uint32 {
	return (volatile.LoadUint32(&o.SDCR.Reg) & 0xc0) >> 6
}

// HSMCI.ARGR: Argument Register
func (o *HSMCI_Type) SetARGR(value uint32) {
	volatile.StoreUint32(&o.ARGR.Reg, value)
}
func (o *HSMCI_Type) GetARGR() uint32 {
	return volatile.LoadUint32(&o.ARGR.Reg)
}

// HSMCI.CMDR: Command Register
func (o *HSMCI_Type) SetCMDR_CMDNB(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x3f)|value)
}
func (o *HSMCI_Type) GetCMDR_CMDNB() uint32 {
	return volatile.LoadUint32(&o.CMDR.Reg) & 0x3f
}
func (o *HSMCI_Type) SetCMDR_RSPTYP(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0xc0)|value<<6)
}
func (o *HSMCI_Type) GetCMDR_RSPTYP() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0xc0) >> 6
}
func (o *HSMCI_Type) SetCMDR_SPCMD(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x700)|value<<8)
}
func (o *HSMCI_Type) GetCMDR_SPCMD() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x700) >> 8
}
func (o *HSMCI_Type) SetCMDR_OPDCMD(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x800)|value<<11)
}
func (o *HSMCI_Type) GetCMDR_OPDCMD() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x800) >> 11
}
func (o *HSMCI_Type) SetCMDR_MAXLAT(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetCMDR_MAXLAT() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x1000) >> 12
}
func (o *HSMCI_Type) SetCMDR_TRCMD(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x30000)|value<<16)
}
func (o *HSMCI_Type) GetCMDR_TRCMD() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x30000) >> 16
}
func (o *HSMCI_Type) SetCMDR_TRDIR(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x40000)|value<<18)
}
func (o *HSMCI_Type) GetCMDR_TRDIR() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x40000) >> 18
}
func (o *HSMCI_Type) SetCMDR_TRTYP(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x380000)|value<<19)
}
func (o *HSMCI_Type) GetCMDR_TRTYP() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x380000) >> 19
}
func (o *HSMCI_Type) SetCMDR_IOSPCMD(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x3000000)|value<<24)
}
func (o *HSMCI_Type) GetCMDR_IOSPCMD() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x3000000) >> 24
}
func (o *HSMCI_Type) SetCMDR_ATACS(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x4000000)|value<<26)
}
func (o *HSMCI_Type) GetCMDR_ATACS() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x4000000) >> 26
}
func (o *HSMCI_Type) SetCMDR_BOOT_ACK(value uint32) {
	volatile.StoreUint32(&o.CMDR.Reg, volatile.LoadUint32(&o.CMDR.Reg)&^(0x8000000)|value<<27)
}
func (o *HSMCI_Type) GetCMDR_BOOT_ACK() uint32 {
	return (volatile.LoadUint32(&o.CMDR.Reg) & 0x8000000) >> 27
}

// HSMCI.BLKR: Block Register
func (o *HSMCI_Type) SetBLKR_BCNT(value uint32) {
	volatile.StoreUint32(&o.BLKR.Reg, volatile.LoadUint32(&o.BLKR.Reg)&^(0xffff)|value)
}
func (o *HSMCI_Type) GetBLKR_BCNT() uint32 {
	return volatile.LoadUint32(&o.BLKR.Reg) & 0xffff
}
func (o *HSMCI_Type) SetBLKR_BLKLEN(value uint32) {
	volatile.StoreUint32(&o.BLKR.Reg, volatile.LoadUint32(&o.BLKR.Reg)&^(0xffff0000)|value<<16)
}
func (o *HSMCI_Type) GetBLKR_BLKLEN() uint32 {
	return (volatile.LoadUint32(&o.BLKR.Reg) & 0xffff0000) >> 16
}

// HSMCI.CSTOR: Completion Signal Timeout Register
func (o *HSMCI_Type) SetCSTOR_CSTOCYC(value uint32) {
	volatile.StoreUint32(&o.CSTOR.Reg, volatile.LoadUint32(&o.CSTOR.Reg)&^(0xf)|value)
}
func (o *HSMCI_Type) GetCSTOR_CSTOCYC() uint32 {
	return volatile.LoadUint32(&o.CSTOR.Reg) & 0xf
}
func (o *HSMCI_Type) SetCSTOR_CSTOMUL(value uint32) {
	volatile.StoreUint32(&o.CSTOR.Reg, volatile.LoadUint32(&o.CSTOR.Reg)&^(0x70)|value<<4)
}
func (o *HSMCI_Type) GetCSTOR_CSTOMUL() uint32 {
	return (volatile.LoadUint32(&o.CSTOR.Reg) & 0x70) >> 4
}

// HSMCI.RSPR: Response Register
func (o *HSMCI_Type) SetRSPR(idx int, value uint32) {
	volatile.StoreUint32(&o.RSPR[idx].Reg, value)
}
func (o *HSMCI_Type) GetRSPR(idx int) uint32 {
	return volatile.LoadUint32(&o.RSPR[idx].Reg)
}

// HSMCI.RDR: Receive Data Register
func (o *HSMCI_Type) SetRDR(value uint32) {
	volatile.StoreUint32(&o.RDR.Reg, value)
}
func (o *HSMCI_Type) GetRDR() uint32 {
	return volatile.LoadUint32(&o.RDR.Reg)
}

// HSMCI.TDR: Transmit Data Register
func (o *HSMCI_Type) SetTDR(value uint32) {
	volatile.StoreUint32(&o.TDR.Reg, value)
}
func (o *HSMCI_Type) GetTDR() uint32 {
	return volatile.LoadUint32(&o.TDR.Reg)
}

// HSMCI.SR: Status Register
func (o *HSMCI_Type) SetSR_CMDRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *HSMCI_Type) GetSR_CMDRDY() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *HSMCI_Type) SetSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *HSMCI_Type) GetSR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *HSMCI_Type) SetSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *HSMCI_Type) GetSR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *HSMCI_Type) SetSR_BLKE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *HSMCI_Type) GetSR_BLKE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *HSMCI_Type) SetSR_DTIP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *HSMCI_Type) GetSR_DTIP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *HSMCI_Type) SetSR_NOTBUSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *HSMCI_Type) GetSR_NOTBUSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *HSMCI_Type) SetSR_SDIOIRQA(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *HSMCI_Type) GetSR_SDIOIRQA() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *HSMCI_Type) SetSR_SDIOWAIT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetSR_SDIOWAIT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000) >> 12
}
func (o *HSMCI_Type) SetSR_CSRCV(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000)|value<<13)
}
func (o *HSMCI_Type) GetSR_CSRCV() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000) >> 13
}
func (o *HSMCI_Type) SetSR_RINDE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *HSMCI_Type) GetSR_RINDE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *HSMCI_Type) SetSR_RDIRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *HSMCI_Type) GetSR_RDIRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}
func (o *HSMCI_Type) SetSR_RCRCE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000)|value<<18)
}
func (o *HSMCI_Type) GetSR_RCRCE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000) >> 18
}
func (o *HSMCI_Type) SetSR_RENDE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000)|value<<19)
}
func (o *HSMCI_Type) GetSR_RENDE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000) >> 19
}
func (o *HSMCI_Type) SetSR_RTOE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100000)|value<<20)
}
func (o *HSMCI_Type) GetSR_RTOE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100000) >> 20
}
func (o *HSMCI_Type) SetSR_DCRCE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200000)|value<<21)
}
func (o *HSMCI_Type) GetSR_DCRCE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200000) >> 21
}
func (o *HSMCI_Type) SetSR_DTOE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400000)|value<<22)
}
func (o *HSMCI_Type) GetSR_DTOE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400000) >> 22
}
func (o *HSMCI_Type) SetSR_CSTOE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800000)|value<<23)
}
func (o *HSMCI_Type) GetSR_CSTOE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800000) >> 23
}
func (o *HSMCI_Type) SetSR_BLKOVRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000000)|value<<24)
}
func (o *HSMCI_Type) GetSR_BLKOVRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000000) >> 24
}
func (o *HSMCI_Type) SetSR_DMADONE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000000)|value<<25)
}
func (o *HSMCI_Type) GetSR_DMADONE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000000) >> 25
}
func (o *HSMCI_Type) SetSR_FIFOEMPTY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000000)|value<<26)
}
func (o *HSMCI_Type) GetSR_FIFOEMPTY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000000) >> 26
}
func (o *HSMCI_Type) SetSR_XFRDONE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000000)|value<<27)
}
func (o *HSMCI_Type) GetSR_XFRDONE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000000) >> 27
}
func (o *HSMCI_Type) SetSR_ACKRCV(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000000)|value<<28)
}
func (o *HSMCI_Type) GetSR_ACKRCV() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000000) >> 28
}
func (o *HSMCI_Type) SetSR_ACKRCVE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000000)|value<<29)
}
func (o *HSMCI_Type) GetSR_ACKRCVE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000000) >> 29
}
func (o *HSMCI_Type) SetSR_OVRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000000)|value<<30)
}
func (o *HSMCI_Type) GetSR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000000) >> 30
}
func (o *HSMCI_Type) SetSR_UNRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000000)|value<<31)
}
func (o *HSMCI_Type) GetSR_UNRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000000) >> 31
}

// HSMCI.IER: Interrupt Enable Register
func (o *HSMCI_Type) SetIER_CMDRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *HSMCI_Type) GetIER_CMDRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *HSMCI_Type) SetIER_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *HSMCI_Type) GetIER_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *HSMCI_Type) SetIER_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *HSMCI_Type) GetIER_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *HSMCI_Type) SetIER_BLKE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *HSMCI_Type) GetIER_BLKE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *HSMCI_Type) SetIER_DTIP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *HSMCI_Type) GetIER_DTIP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *HSMCI_Type) SetIER_NOTBUSY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *HSMCI_Type) GetIER_NOTBUSY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *HSMCI_Type) SetIER_SDIOIRQA(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *HSMCI_Type) GetIER_SDIOIRQA() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *HSMCI_Type) SetIER_SDIOWAIT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetIER_SDIOWAIT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000) >> 12
}
func (o *HSMCI_Type) SetIER_CSRCV(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000)|value<<13)
}
func (o *HSMCI_Type) GetIER_CSRCV() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000) >> 13
}
func (o *HSMCI_Type) SetIER_RINDE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000)|value<<16)
}
func (o *HSMCI_Type) GetIER_RINDE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000) >> 16
}
func (o *HSMCI_Type) SetIER_RDIRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000)|value<<17)
}
func (o *HSMCI_Type) GetIER_RDIRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000) >> 17
}
func (o *HSMCI_Type) SetIER_RCRCE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000)|value<<18)
}
func (o *HSMCI_Type) GetIER_RCRCE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000) >> 18
}
func (o *HSMCI_Type) SetIER_RENDE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000)|value<<19)
}
func (o *HSMCI_Type) GetIER_RENDE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000) >> 19
}
func (o *HSMCI_Type) SetIER_RTOE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100000)|value<<20)
}
func (o *HSMCI_Type) GetIER_RTOE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100000) >> 20
}
func (o *HSMCI_Type) SetIER_DCRCE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200000)|value<<21)
}
func (o *HSMCI_Type) GetIER_DCRCE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200000) >> 21
}
func (o *HSMCI_Type) SetIER_DTOE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400000)|value<<22)
}
func (o *HSMCI_Type) GetIER_DTOE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400000) >> 22
}
func (o *HSMCI_Type) SetIER_CSTOE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800000)|value<<23)
}
func (o *HSMCI_Type) GetIER_CSTOE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800000) >> 23
}
func (o *HSMCI_Type) SetIER_BLKOVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *HSMCI_Type) GetIER_BLKOVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}
func (o *HSMCI_Type) SetIER_DMADONE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000000)|value<<25)
}
func (o *HSMCI_Type) GetIER_DMADONE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000000) >> 25
}
func (o *HSMCI_Type) SetIER_FIFOEMPTY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000000)|value<<26)
}
func (o *HSMCI_Type) GetIER_FIFOEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000000) >> 26
}
func (o *HSMCI_Type) SetIER_XFRDONE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8000000)|value<<27)
}
func (o *HSMCI_Type) GetIER_XFRDONE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8000000) >> 27
}
func (o *HSMCI_Type) SetIER_ACKRCV(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000000)|value<<28)
}
func (o *HSMCI_Type) GetIER_ACKRCV() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000000) >> 28
}
func (o *HSMCI_Type) SetIER_ACKRCVE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000000)|value<<29)
}
func (o *HSMCI_Type) GetIER_ACKRCVE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000000) >> 29
}
func (o *HSMCI_Type) SetIER_OVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000000)|value<<30)
}
func (o *HSMCI_Type) GetIER_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000000) >> 30
}
func (o *HSMCI_Type) SetIER_UNRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000000)|value<<31)
}
func (o *HSMCI_Type) GetIER_UNRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000000) >> 31
}

// HSMCI.IDR: Interrupt Disable Register
func (o *HSMCI_Type) SetIDR_CMDRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *HSMCI_Type) GetIDR_CMDRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *HSMCI_Type) SetIDR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *HSMCI_Type) GetIDR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *HSMCI_Type) SetIDR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *HSMCI_Type) GetIDR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *HSMCI_Type) SetIDR_BLKE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *HSMCI_Type) GetIDR_BLKE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *HSMCI_Type) SetIDR_DTIP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *HSMCI_Type) GetIDR_DTIP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *HSMCI_Type) SetIDR_NOTBUSY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *HSMCI_Type) GetIDR_NOTBUSY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *HSMCI_Type) SetIDR_SDIOIRQA(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *HSMCI_Type) GetIDR_SDIOIRQA() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *HSMCI_Type) SetIDR_SDIOWAIT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetIDR_SDIOWAIT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000) >> 12
}
func (o *HSMCI_Type) SetIDR_CSRCV(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *HSMCI_Type) GetIDR_CSRCV() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}
func (o *HSMCI_Type) SetIDR_RINDE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000)|value<<16)
}
func (o *HSMCI_Type) GetIDR_RINDE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000) >> 16
}
func (o *HSMCI_Type) SetIDR_RDIRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000)|value<<17)
}
func (o *HSMCI_Type) GetIDR_RDIRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000) >> 17
}
func (o *HSMCI_Type) SetIDR_RCRCE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000)|value<<18)
}
func (o *HSMCI_Type) GetIDR_RCRCE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000) >> 18
}
func (o *HSMCI_Type) SetIDR_RENDE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000)|value<<19)
}
func (o *HSMCI_Type) GetIDR_RENDE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000) >> 19
}
func (o *HSMCI_Type) SetIDR_RTOE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100000)|value<<20)
}
func (o *HSMCI_Type) GetIDR_RTOE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100000) >> 20
}
func (o *HSMCI_Type) SetIDR_DCRCE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200000)|value<<21)
}
func (o *HSMCI_Type) GetIDR_DCRCE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200000) >> 21
}
func (o *HSMCI_Type) SetIDR_DTOE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400000)|value<<22)
}
func (o *HSMCI_Type) GetIDR_DTOE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400000) >> 22
}
func (o *HSMCI_Type) SetIDR_CSTOE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800000)|value<<23)
}
func (o *HSMCI_Type) GetIDR_CSTOE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800000) >> 23
}
func (o *HSMCI_Type) SetIDR_BLKOVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *HSMCI_Type) GetIDR_BLKOVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}
func (o *HSMCI_Type) SetIDR_DMADONE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000000)|value<<25)
}
func (o *HSMCI_Type) GetIDR_DMADONE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000000) >> 25
}
func (o *HSMCI_Type) SetIDR_FIFOEMPTY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000000)|value<<26)
}
func (o *HSMCI_Type) GetIDR_FIFOEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000000) >> 26
}
func (o *HSMCI_Type) SetIDR_XFRDONE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000000)|value<<27)
}
func (o *HSMCI_Type) GetIDR_XFRDONE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000000) >> 27
}
func (o *HSMCI_Type) SetIDR_ACKRCV(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000000)|value<<28)
}
func (o *HSMCI_Type) GetIDR_ACKRCV() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000000) >> 28
}
func (o *HSMCI_Type) SetIDR_ACKRCVE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000000)|value<<29)
}
func (o *HSMCI_Type) GetIDR_ACKRCVE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000000) >> 29
}
func (o *HSMCI_Type) SetIDR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000000)|value<<30)
}
func (o *HSMCI_Type) GetIDR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000000) >> 30
}
func (o *HSMCI_Type) SetIDR_UNRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000000)|value<<31)
}
func (o *HSMCI_Type) GetIDR_UNRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000000) >> 31
}

// HSMCI.IMR: Interrupt Mask Register
func (o *HSMCI_Type) SetIMR_CMDRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *HSMCI_Type) GetIMR_CMDRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *HSMCI_Type) SetIMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *HSMCI_Type) GetIMR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *HSMCI_Type) SetIMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *HSMCI_Type) GetIMR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *HSMCI_Type) SetIMR_BLKE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *HSMCI_Type) GetIMR_BLKE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *HSMCI_Type) SetIMR_DTIP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *HSMCI_Type) GetIMR_DTIP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *HSMCI_Type) SetIMR_NOTBUSY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *HSMCI_Type) GetIMR_NOTBUSY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *HSMCI_Type) SetIMR_SDIOIRQA(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *HSMCI_Type) GetIMR_SDIOIRQA() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *HSMCI_Type) SetIMR_SDIOWAIT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetIMR_SDIOWAIT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000) >> 12
}
func (o *HSMCI_Type) SetIMR_CSRCV(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000)|value<<13)
}
func (o *HSMCI_Type) GetIMR_CSRCV() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000) >> 13
}
func (o *HSMCI_Type) SetIMR_RINDE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000)|value<<16)
}
func (o *HSMCI_Type) GetIMR_RINDE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000) >> 16
}
func (o *HSMCI_Type) SetIMR_RDIRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000)|value<<17)
}
func (o *HSMCI_Type) GetIMR_RDIRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000) >> 17
}
func (o *HSMCI_Type) SetIMR_RCRCE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000)|value<<18)
}
func (o *HSMCI_Type) GetIMR_RCRCE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000) >> 18
}
func (o *HSMCI_Type) SetIMR_RENDE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000)|value<<19)
}
func (o *HSMCI_Type) GetIMR_RENDE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000) >> 19
}
func (o *HSMCI_Type) SetIMR_RTOE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100000)|value<<20)
}
func (o *HSMCI_Type) GetIMR_RTOE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100000) >> 20
}
func (o *HSMCI_Type) SetIMR_DCRCE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200000)|value<<21)
}
func (o *HSMCI_Type) GetIMR_DCRCE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200000) >> 21
}
func (o *HSMCI_Type) SetIMR_DTOE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400000)|value<<22)
}
func (o *HSMCI_Type) GetIMR_DTOE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400000) >> 22
}
func (o *HSMCI_Type) SetIMR_CSTOE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800000)|value<<23)
}
func (o *HSMCI_Type) GetIMR_CSTOE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800000) >> 23
}
func (o *HSMCI_Type) SetIMR_BLKOVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *HSMCI_Type) GetIMR_BLKOVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}
func (o *HSMCI_Type) SetIMR_DMADONE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000000)|value<<25)
}
func (o *HSMCI_Type) GetIMR_DMADONE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000000) >> 25
}
func (o *HSMCI_Type) SetIMR_FIFOEMPTY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000000)|value<<26)
}
func (o *HSMCI_Type) GetIMR_FIFOEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000000) >> 26
}
func (o *HSMCI_Type) SetIMR_XFRDONE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000000)|value<<27)
}
func (o *HSMCI_Type) GetIMR_XFRDONE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000000) >> 27
}
func (o *HSMCI_Type) SetIMR_ACKRCV(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000000)|value<<28)
}
func (o *HSMCI_Type) GetIMR_ACKRCV() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000000) >> 28
}
func (o *HSMCI_Type) SetIMR_ACKRCVE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000000)|value<<29)
}
func (o *HSMCI_Type) GetIMR_ACKRCVE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000000) >> 29
}
func (o *HSMCI_Type) SetIMR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000000)|value<<30)
}
func (o *HSMCI_Type) GetIMR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000000) >> 30
}
func (o *HSMCI_Type) SetIMR_UNRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000000)|value<<31)
}
func (o *HSMCI_Type) GetIMR_UNRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000000) >> 31
}

// HSMCI.DMA: DMA Configuration Register
func (o *HSMCI_Type) SetDMA_OFFSET(value uint32) {
	volatile.StoreUint32(&o.DMA.Reg, volatile.LoadUint32(&o.DMA.Reg)&^(0x3)|value)
}
func (o *HSMCI_Type) GetDMA_OFFSET() uint32 {
	return volatile.LoadUint32(&o.DMA.Reg) & 0x3
}
func (o *HSMCI_Type) SetDMA_CHKSIZE(value uint32) {
	volatile.StoreUint32(&o.DMA.Reg, volatile.LoadUint32(&o.DMA.Reg)&^(0x70)|value<<4)
}
func (o *HSMCI_Type) GetDMA_CHKSIZE() uint32 {
	return (volatile.LoadUint32(&o.DMA.Reg) & 0x70) >> 4
}
func (o *HSMCI_Type) SetDMA_DMAEN(value uint32) {
	volatile.StoreUint32(&o.DMA.Reg, volatile.LoadUint32(&o.DMA.Reg)&^(0x100)|value<<8)
}
func (o *HSMCI_Type) GetDMA_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.DMA.Reg) & 0x100) >> 8
}
func (o *HSMCI_Type) SetDMA_ROPT(value uint32) {
	volatile.StoreUint32(&o.DMA.Reg, volatile.LoadUint32(&o.DMA.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetDMA_ROPT() uint32 {
	return (volatile.LoadUint32(&o.DMA.Reg) & 0x1000) >> 12
}

// HSMCI.CFG: Configuration Register
func (o *HSMCI_Type) SetCFG_FIFOMODE(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x1)|value)
}
func (o *HSMCI_Type) GetCFG_FIFOMODE() uint32 {
	return volatile.LoadUint32(&o.CFG.Reg) & 0x1
}
func (o *HSMCI_Type) SetCFG_FERRCTRL(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x10)|value<<4)
}
func (o *HSMCI_Type) GetCFG_FERRCTRL() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x10) >> 4
}
func (o *HSMCI_Type) SetCFG_HSMODE(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x100)|value<<8)
}
func (o *HSMCI_Type) GetCFG_HSMODE() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x100) >> 8
}
func (o *HSMCI_Type) SetCFG_LSYNC(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x1000)|value<<12)
}
func (o *HSMCI_Type) GetCFG_LSYNC() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x1000) >> 12
}

// HSMCI.WPMR: Write Protection Mode Register
func (o *HSMCI_Type) SetWPMR_WP_EN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *HSMCI_Type) GetWPMR_WP_EN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *HSMCI_Type) SetWPMR_WP_KEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *HSMCI_Type) GetWPMR_WP_KEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// HSMCI.WPSR: Write Protection Status Register
func (o *HSMCI_Type) SetWPSR_WP_VS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xf)|value)
}
func (o *HSMCI_Type) GetWPSR_WP_VS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0xf
}
func (o *HSMCI_Type) SetWPSR_WP_VSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *HSMCI_Type) GetWPSR_WP_VSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// HSMCI.FIFO: FIFO Memory Aperture0
func (o *HSMCI_Type) SetFIFO(idx int, value uint32) {
	volatile.StoreUint32(&o.FIFO[idx].Reg, value)
}
func (o *HSMCI_Type) GetFIFO(idx int) uint32 {
	return volatile.LoadUint32(&o.FIFO[idx].Reg)
}

// Serial Peripheral Interface 0
type SPI_Type struct {
	CR   volatile.Register32 // 0x0
	MR   volatile.Register32 // 0x4
	RDR  volatile.Register32 // 0x8
	TDR  volatile.Register32 // 0xC
	SR   volatile.Register32 // 0x10
	IER  volatile.Register32 // 0x14
	IDR  volatile.Register32 // 0x18
	IMR  volatile.Register32 // 0x1C
	_    [16]byte
	CSR  [4]volatile.Register32 // 0x30
	_    [164]byte
	WPMR volatile.Register32 // 0xE4
	WPSR volatile.Register32 // 0xE8
}

// SPI.CR: Control Register
func (o *SPI_Type) SetCR_SPIEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetCR_SPIEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *SPI_Type) SetCR_SPIDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetCR_SPIDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetCR_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetCR_LASTXFER(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI_Type) GetCR_LASTXFER() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000000) >> 24
}

// SPI.MR: Mode Register
func (o *SPI_Type) SetMR_MSTR(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetMR_MSTR() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x1
}
func (o *SPI_Type) SetMR_PS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetMR_PS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetMR_PCSDEC(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetMR_PCSDEC() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetMR_MODFDIS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetMR_MODFDIS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetMR_WDRBT(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetMR_WDRBT() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetMR_LLB(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetMR_LLB() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetMR_PCS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf0000)|value<<16)
}
func (o *SPI_Type) GetMR_PCS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf0000) >> 16
}
func (o *SPI_Type) SetMR_DLYBCS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xff000000)|value<<24)
}
func (o *SPI_Type) GetMR_DLYBCS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xff000000) >> 24
}

// SPI.RDR: Receive Data Register
func (o *SPI_Type) SetRDR_RD(value uint32) {
	volatile.StoreUint32(&o.RDR.Reg, volatile.LoadUint32(&o.RDR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetRDR_RD() uint32 {
	return volatile.LoadUint32(&o.RDR.Reg) & 0xffff
}
func (o *SPI_Type) SetRDR_PCS(value uint32) {
	volatile.StoreUint32(&o.RDR.Reg, volatile.LoadUint32(&o.RDR.Reg)&^(0xf0000)|value<<16)
}
func (o *SPI_Type) GetRDR_PCS() uint32 {
	return (volatile.LoadUint32(&o.RDR.Reg) & 0xf0000) >> 16
}

// SPI.TDR: Transmit Data Register
func (o *SPI_Type) SetTDR_TD(value uint32) {
	volatile.StoreUint32(&o.TDR.Reg, volatile.LoadUint32(&o.TDR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetTDR_TD() uint32 {
	return volatile.LoadUint32(&o.TDR.Reg) & 0xffff
}
func (o *SPI_Type) SetTDR_PCS(value uint32) {
	volatile.StoreUint32(&o.TDR.Reg, volatile.LoadUint32(&o.TDR.Reg)&^(0xf0000)|value<<16)
}
func (o *SPI_Type) GetTDR_PCS() uint32 {
	return (volatile.LoadUint32(&o.TDR.Reg) & 0xf0000) >> 16
}
func (o *SPI_Type) SetTDR_LASTXFER(value uint32) {
	volatile.StoreUint32(&o.TDR.Reg, volatile.LoadUint32(&o.TDR.Reg)&^(0x1000000)|value<<24)
}
func (o *SPI_Type) GetTDR_LASTXFER() uint32 {
	return (volatile.LoadUint32(&o.TDR.Reg) & 0x1000000) >> 24
}

// SPI.SR: Status Register
func (o *SPI_Type) SetSR_RDRF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetSR_RDRF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *SPI_Type) SetSR_TDRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetSR_TDRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetSR_MODF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetSR_MODF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetSR_OVRES(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetSR_OVRES() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetSR_NSSR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetSR_NSSR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetSR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetSR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetSR_UNDES(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetSR_UNDES() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetSR_SPIENS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *SPI_Type) GetSR_SPIENS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}

// SPI.IER: Interrupt Enable Register
func (o *SPI_Type) SetIER_RDRF(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetIER_RDRF() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *SPI_Type) SetIER_TDRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetIER_TDRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetIER_MODF(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetIER_MODF() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetIER_OVRES(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetIER_OVRES() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetIER_NSSR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetIER_NSSR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetIER_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetIER_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetIER_UNDES(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetIER_UNDES() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}

// SPI.IDR: Interrupt Disable Register
func (o *SPI_Type) SetIDR_RDRF(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetIDR_RDRF() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *SPI_Type) SetIDR_TDRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetIDR_TDRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetIDR_MODF(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetIDR_MODF() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetIDR_OVRES(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetIDR_OVRES() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetIDR_NSSR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetIDR_NSSR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetIDR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetIDR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetIDR_UNDES(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetIDR_UNDES() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}

// SPI.IMR: Interrupt Mask Register
func (o *SPI_Type) SetIMR_RDRF(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetIMR_RDRF() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *SPI_Type) SetIMR_TDRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetIMR_TDRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetIMR_MODF(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetIMR_MODF() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetIMR_OVRES(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetIMR_OVRES() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetIMR_NSSR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetIMR_NSSR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetIMR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetIMR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetIMR_UNDES(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetIMR_UNDES() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}

// SPI.CSR: Chip Select Register
func (o *SPI_Type) SetCSR_CPOL(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetCSR_CPOL(idx int) uint32 {
	return volatile.LoadUint32(&o.CSR[idx].Reg) & 0x1
}
func (o *SPI_Type) SetCSR_NCPHA(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetCSR_NCPHA(idx int) uint32 {
	return (volatile.LoadUint32(&o.CSR[idx].Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetCSR_CSNAAT(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetCSR_CSNAAT(idx int) uint32 {
	return (volatile.LoadUint32(&o.CSR[idx].Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetCSR_CSAAT(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetCSR_CSAAT(idx int) uint32 {
	return (volatile.LoadUint32(&o.CSR[idx].Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetCSR_BITS(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0xf0)|value<<4)
}
func (o *SPI_Type) GetCSR_BITS(idx int) uint32 {
	return (volatile.LoadUint32(&o.CSR[idx].Reg) & 0xf0) >> 4
}
func (o *SPI_Type) SetCSR_SCBR(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0xff00)|value<<8)
}
func (o *SPI_Type) GetCSR_SCBR(idx int) uint32 {
	return (volatile.LoadUint32(&o.CSR[idx].Reg) & 0xff00) >> 8
}
func (o *SPI_Type) SetCSR_DLYBS(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0xff0000)|value<<16)
}
func (o *SPI_Type) GetCSR_DLYBS(idx int) uint32 {
	return (volatile.LoadUint32(&o.CSR[idx].Reg) & 0xff0000) >> 16
}
func (o *SPI_Type) SetCSR_DLYBCT(idx int, value uint32) {
	volatile.StoreUint32(&o.CSR[idx].Reg, volatile.LoadUint32(&o.CSR[idx].Reg)&^(0xff000000)|value<<24)
}
func (o *SPI_Type) GetCSR_DLYBCT(idx int) uint32 {
	return (volatile.LoadUint32(&o.CSR[idx].Reg) & 0xff000000) >> 24
}

// SPI.WPMR: Write Protection Control Register
func (o *SPI_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *SPI_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *SPI_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// SPI.WPSR: Write Protection Status Register
func (o *SPI_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *SPI_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xff00)|value<<8)
}
func (o *SPI_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xff00) >> 8
}

// Synchronous Serial Controller 0
type SSC_Type struct {
	CR   volatile.Register32 // 0x0
	CMR  volatile.Register32 // 0x4
	_    [8]byte
	RCMR volatile.Register32 // 0x10
	RFMR volatile.Register32 // 0x14
	TCMR volatile.Register32 // 0x18
	TFMR volatile.Register32 // 0x1C
	RHR  volatile.Register32 // 0x20
	THR  volatile.Register32 // 0x24
	_    [8]byte
	RSHR volatile.Register32 // 0x30
	TSHR volatile.Register32 // 0x34
	RC0R volatile.Register32 // 0x38
	RC1R volatile.Register32 // 0x3C
	SR   volatile.Register32 // 0x40
	IER  volatile.Register32 // 0x44
	IDR  volatile.Register32 // 0x48
	IMR  volatile.Register32 // 0x4C
	_    [148]byte
	WPMR volatile.Register32 // 0xE4
	WPSR volatile.Register32 // 0xE8
}

// SSC.CR: Control Register
func (o *SSC_Type) SetCR_RXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetCR_RXEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *SSC_Type) SetCR_RXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *SSC_Type) GetCR_RXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *SSC_Type) SetCR_TXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *SSC_Type) GetCR_TXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *SSC_Type) SetCR_TXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *SSC_Type) GetCR_TXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *SSC_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *SSC_Type) GetCR_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}

// SSC.CMR: Clock Mode Register
func (o *SSC_Type) SetCMR_DIV(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0xfff)|value)
}
func (o *SSC_Type) GetCMR_DIV() uint32 {
	return volatile.LoadUint32(&o.CMR.Reg) & 0xfff
}

// SSC.RCMR: Receive Clock Mode Register
func (o *SSC_Type) SetRCMR_CKS(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0x3)|value)
}
func (o *SSC_Type) GetRCMR_CKS() uint32 {
	return volatile.LoadUint32(&o.RCMR.Reg) & 0x3
}
func (o *SSC_Type) SetRCMR_CKO(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0x1c)|value<<2)
}
func (o *SSC_Type) GetRCMR_CKO() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0x1c) >> 2
}
func (o *SSC_Type) SetRCMR_CKI(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetRCMR_CKI() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetRCMR_CKG(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0xc0)|value<<6)
}
func (o *SSC_Type) GetRCMR_CKG() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0xc0) >> 6
}
func (o *SSC_Type) SetRCMR_START(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0xf00)|value<<8)
}
func (o *SSC_Type) GetRCMR_START() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0xf00) >> 8
}
func (o *SSC_Type) SetRCMR_STOP(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0x1000)|value<<12)
}
func (o *SSC_Type) GetRCMR_STOP() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0x1000) >> 12
}
func (o *SSC_Type) SetRCMR_STTDLY(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0xff0000)|value<<16)
}
func (o *SSC_Type) GetRCMR_STTDLY() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0xff0000) >> 16
}
func (o *SSC_Type) SetRCMR_PERIOD(value uint32) {
	volatile.StoreUint32(&o.RCMR.Reg, volatile.LoadUint32(&o.RCMR.Reg)&^(0xff000000)|value<<24)
}
func (o *SSC_Type) GetRCMR_PERIOD() uint32 {
	return (volatile.LoadUint32(&o.RCMR.Reg) & 0xff000000) >> 24
}

// SSC.RFMR: Receive Frame Mode Register
func (o *SSC_Type) SetRFMR_DATLEN(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0x1f)|value)
}
func (o *SSC_Type) GetRFMR_DATLEN() uint32 {
	return volatile.LoadUint32(&o.RFMR.Reg) & 0x1f
}
func (o *SSC_Type) SetRFMR_LOOP(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetRFMR_LOOP() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetRFMR_MSBF(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0x80)|value<<7)
}
func (o *SSC_Type) GetRFMR_MSBF() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0x80) >> 7
}
func (o *SSC_Type) SetRFMR_DATNB(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0xf00)|value<<8)
}
func (o *SSC_Type) GetRFMR_DATNB() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0xf00) >> 8
}
func (o *SSC_Type) SetRFMR_FSLEN(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0xf0000)|value<<16)
}
func (o *SSC_Type) GetRFMR_FSLEN() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0xf0000) >> 16
}
func (o *SSC_Type) SetRFMR_FSOS(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0x700000)|value<<20)
}
func (o *SSC_Type) GetRFMR_FSOS() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0x700000) >> 20
}
func (o *SSC_Type) SetRFMR_FSEDGE(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0x1000000)|value<<24)
}
func (o *SSC_Type) GetRFMR_FSEDGE() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0x1000000) >> 24
}
func (o *SSC_Type) SetRFMR_FSLEN_EXT(value uint32) {
	volatile.StoreUint32(&o.RFMR.Reg, volatile.LoadUint32(&o.RFMR.Reg)&^(0xf0000000)|value<<28)
}
func (o *SSC_Type) GetRFMR_FSLEN_EXT() uint32 {
	return (volatile.LoadUint32(&o.RFMR.Reg) & 0xf0000000) >> 28
}

// SSC.TCMR: Transmit Clock Mode Register
func (o *SSC_Type) SetTCMR_CKS(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0x3)|value)
}
func (o *SSC_Type) GetTCMR_CKS() uint32 {
	return volatile.LoadUint32(&o.TCMR.Reg) & 0x3
}
func (o *SSC_Type) SetTCMR_CKO(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0x1c)|value<<2)
}
func (o *SSC_Type) GetTCMR_CKO() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0x1c) >> 2
}
func (o *SSC_Type) SetTCMR_CKI(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetTCMR_CKI() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetTCMR_CKG(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0xc0)|value<<6)
}
func (o *SSC_Type) GetTCMR_CKG() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0xc0) >> 6
}
func (o *SSC_Type) SetTCMR_START(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0xf00)|value<<8)
}
func (o *SSC_Type) GetTCMR_START() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0xf00) >> 8
}
func (o *SSC_Type) SetTCMR_STTDLY(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0xff0000)|value<<16)
}
func (o *SSC_Type) GetTCMR_STTDLY() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0xff0000) >> 16
}
func (o *SSC_Type) SetTCMR_PERIOD(value uint32) {
	volatile.StoreUint32(&o.TCMR.Reg, volatile.LoadUint32(&o.TCMR.Reg)&^(0xff000000)|value<<24)
}
func (o *SSC_Type) GetTCMR_PERIOD() uint32 {
	return (volatile.LoadUint32(&o.TCMR.Reg) & 0xff000000) >> 24
}

// SSC.TFMR: Transmit Frame Mode Register
func (o *SSC_Type) SetTFMR_DATLEN(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x1f)|value)
}
func (o *SSC_Type) GetTFMR_DATLEN() uint32 {
	return volatile.LoadUint32(&o.TFMR.Reg) & 0x1f
}
func (o *SSC_Type) SetTFMR_DATDEF(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetTFMR_DATDEF() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetTFMR_MSBF(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x80)|value<<7)
}
func (o *SSC_Type) GetTFMR_MSBF() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0x80) >> 7
}
func (o *SSC_Type) SetTFMR_DATNB(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0xf00)|value<<8)
}
func (o *SSC_Type) GetTFMR_DATNB() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0xf00) >> 8
}
func (o *SSC_Type) SetTFMR_FSLEN(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0xf0000)|value<<16)
}
func (o *SSC_Type) GetTFMR_FSLEN() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0xf0000) >> 16
}
func (o *SSC_Type) SetTFMR_FSOS(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x700000)|value<<20)
}
func (o *SSC_Type) GetTFMR_FSOS() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0x700000) >> 20
}
func (o *SSC_Type) SetTFMR_FSDEN(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x800000)|value<<23)
}
func (o *SSC_Type) GetTFMR_FSDEN() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0x800000) >> 23
}
func (o *SSC_Type) SetTFMR_FSEDGE(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0x1000000)|value<<24)
}
func (o *SSC_Type) GetTFMR_FSEDGE() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0x1000000) >> 24
}
func (o *SSC_Type) SetTFMR_FSLEN_EXT(value uint32) {
	volatile.StoreUint32(&o.TFMR.Reg, volatile.LoadUint32(&o.TFMR.Reg)&^(0xf0000000)|value<<28)
}
func (o *SSC_Type) GetTFMR_FSLEN_EXT() uint32 {
	return (volatile.LoadUint32(&o.TFMR.Reg) & 0xf0000000) >> 28
}

// SSC.RHR: Receive Holding Register
func (o *SSC_Type) SetRHR(value uint32) {
	volatile.StoreUint32(&o.RHR.Reg, value)
}
func (o *SSC_Type) GetRHR() uint32 {
	return volatile.LoadUint32(&o.RHR.Reg)
}

// SSC.THR: Transmit Holding Register
func (o *SSC_Type) SetTHR(value uint32) {
	volatile.StoreUint32(&o.THR.Reg, value)
}
func (o *SSC_Type) GetTHR() uint32 {
	return volatile.LoadUint32(&o.THR.Reg)
}

// SSC.RSHR: Receive Sync. Holding Register
func (o *SSC_Type) SetRSHR_RSDAT(value uint32) {
	volatile.StoreUint32(&o.RSHR.Reg, volatile.LoadUint32(&o.RSHR.Reg)&^(0xffff)|value)
}
func (o *SSC_Type) GetRSHR_RSDAT() uint32 {
	return volatile.LoadUint32(&o.RSHR.Reg) & 0xffff
}

// SSC.TSHR: Transmit Sync. Holding Register
func (o *SSC_Type) SetTSHR_TSDAT(value uint32) {
	volatile.StoreUint32(&o.TSHR.Reg, volatile.LoadUint32(&o.TSHR.Reg)&^(0xffff)|value)
}
func (o *SSC_Type) GetTSHR_TSDAT() uint32 {
	return volatile.LoadUint32(&o.TSHR.Reg) & 0xffff
}

// SSC.RC0R: Receive Compare 0 Register
func (o *SSC_Type) SetRC0R_CP0(value uint32) {
	volatile.StoreUint32(&o.RC0R.Reg, volatile.LoadUint32(&o.RC0R.Reg)&^(0xffff)|value)
}
func (o *SSC_Type) GetRC0R_CP0() uint32 {
	return volatile.LoadUint32(&o.RC0R.Reg) & 0xffff
}

// SSC.RC1R: Receive Compare 1 Register
func (o *SSC_Type) SetRC1R_CP1(value uint32) {
	volatile.StoreUint32(&o.RC1R.Reg, volatile.LoadUint32(&o.RC1R.Reg)&^(0xffff)|value)
}
func (o *SSC_Type) GetRC1R_CP1() uint32 {
	return volatile.LoadUint32(&o.RC1R.Reg) & 0xffff
}

// SSC.SR: Status Register
func (o *SSC_Type) SetSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetSR_TXRDY() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *SSC_Type) SetSR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *SSC_Type) GetSR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *SSC_Type) SetSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *SSC_Type) GetSR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *SSC_Type) SetSR_OVRUN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetSR_OVRUN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetSR_CP0(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *SSC_Type) GetSR_CP0() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *SSC_Type) SetSR_CP1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *SSC_Type) GetSR_CP1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *SSC_Type) SetSR_TXSYN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *SSC_Type) GetSR_TXSYN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *SSC_Type) SetSR_RXSYN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800)|value<<11)
}
func (o *SSC_Type) GetSR_RXSYN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800) >> 11
}
func (o *SSC_Type) SetSR_TXEN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *SSC_Type) GetSR_TXEN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *SSC_Type) SetSR_RXEN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *SSC_Type) GetSR_RXEN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}

// SSC.IER: Interrupt Enable Register
func (o *SSC_Type) SetIER_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetIER_TXRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *SSC_Type) SetIER_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *SSC_Type) GetIER_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *SSC_Type) SetIER_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *SSC_Type) GetIER_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *SSC_Type) SetIER_OVRUN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetIER_OVRUN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetIER_CP0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *SSC_Type) GetIER_CP0() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *SSC_Type) SetIER_CP1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *SSC_Type) GetIER_CP1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *SSC_Type) SetIER_TXSYN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *SSC_Type) GetIER_TXSYN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *SSC_Type) SetIER_RXSYN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *SSC_Type) GetIER_RXSYN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}

// SSC.IDR: Interrupt Disable Register
func (o *SSC_Type) SetIDR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetIDR_TXRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *SSC_Type) SetIDR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *SSC_Type) GetIDR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *SSC_Type) SetIDR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *SSC_Type) GetIDR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *SSC_Type) SetIDR_OVRUN(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetIDR_OVRUN() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetIDR_CP0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *SSC_Type) GetIDR_CP0() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *SSC_Type) SetIDR_CP1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *SSC_Type) GetIDR_CP1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *SSC_Type) SetIDR_TXSYN(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *SSC_Type) GetIDR_TXSYN() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *SSC_Type) SetIDR_RXSYN(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *SSC_Type) GetIDR_RXSYN() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}

// SSC.IMR: Interrupt Mask Register
func (o *SSC_Type) SetIMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetIMR_TXRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *SSC_Type) SetIMR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *SSC_Type) GetIMR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *SSC_Type) SetIMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *SSC_Type) GetIMR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *SSC_Type) SetIMR_OVRUN(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *SSC_Type) GetIMR_OVRUN() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *SSC_Type) SetIMR_CP0(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *SSC_Type) GetIMR_CP0() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *SSC_Type) SetIMR_CP1(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *SSC_Type) GetIMR_CP1() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *SSC_Type) SetIMR_TXSYN(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *SSC_Type) GetIMR_TXSYN() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *SSC_Type) SetIMR_RXSYN(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *SSC_Type) GetIMR_RXSYN() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}

// SSC.WPMR: Write Protect Mode Register
func (o *SSC_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *SSC_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *SSC_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *SSC_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// Controller Area Network 0
type CAN_Type struct {
	MR      volatile.Register32 // 0x0
	IER     volatile.Register32 // 0x4
	IDR     volatile.Register32 // 0x8
	IMR     volatile.Register32 // 0xC
	SR      volatile.Register32 // 0x10
	BR      volatile.Register32 // 0x14
	TIM     volatile.Register32 // 0x18
	TIMESTP volatile.Register32 // 0x1C
	ECR     volatile.Register32 // 0x20
	TCR     volatile.Register32 // 0x24
	ACR     volatile.Register32 // 0x28
	_       [184]byte
	WPMR    volatile.Register32 // 0xE4
	WPSR    volatile.Register32 // 0xE8
	_       [276]byte
	MMR0    volatile.Register32 // 0x200
	MAM0    volatile.Register32 // 0x204
	MID0    volatile.Register32 // 0x208
	MFID0   volatile.Register32 // 0x20C
	MSR0    volatile.Register32 // 0x210
	MDL0    volatile.Register32 // 0x214
	MDH0    volatile.Register32 // 0x218
	MCR0    volatile.Register32 // 0x21C
	MMR1    volatile.Register32 // 0x220
	MAM1    volatile.Register32 // 0x224
	MID1    volatile.Register32 // 0x228
	MFID1   volatile.Register32 // 0x22C
	MSR1    volatile.Register32 // 0x230
	MDL1    volatile.Register32 // 0x234
	MDH1    volatile.Register32 // 0x238
	MCR1    volatile.Register32 // 0x23C
	MMR2    volatile.Register32 // 0x240
	MAM2    volatile.Register32 // 0x244
	MID2    volatile.Register32 // 0x248
	MFID2   volatile.Register32 // 0x24C
	MSR2    volatile.Register32 // 0x250
	MDL2    volatile.Register32 // 0x254
	MDH2    volatile.Register32 // 0x258
	MCR2    volatile.Register32 // 0x25C
	MMR3    volatile.Register32 // 0x260
	MAM3    volatile.Register32 // 0x264
	MID3    volatile.Register32 // 0x268
	MFID3   volatile.Register32 // 0x26C
	MSR3    volatile.Register32 // 0x270
	MDL3    volatile.Register32 // 0x274
	MDH3    volatile.Register32 // 0x278
	MCR3    volatile.Register32 // 0x27C
	MMR4    volatile.Register32 // 0x280
	MAM4    volatile.Register32 // 0x284
	MID4    volatile.Register32 // 0x288
	MFID4   volatile.Register32 // 0x28C
	MSR4    volatile.Register32 // 0x290
	MDL4    volatile.Register32 // 0x294
	MDH4    volatile.Register32 // 0x298
	MCR4    volatile.Register32 // 0x29C
	MMR5    volatile.Register32 // 0x2A0
	MAM5    volatile.Register32 // 0x2A4
	MID5    volatile.Register32 // 0x2A8
	MFID5   volatile.Register32 // 0x2AC
	MSR5    volatile.Register32 // 0x2B0
	MDL5    volatile.Register32 // 0x2B4
	MDH5    volatile.Register32 // 0x2B8
	MCR5    volatile.Register32 // 0x2BC
	MMR6    volatile.Register32 // 0x2C0
	MAM6    volatile.Register32 // 0x2C4
	MID6    volatile.Register32 // 0x2C8
	MFID6   volatile.Register32 // 0x2CC
	MSR6    volatile.Register32 // 0x2D0
	MDL6    volatile.Register32 // 0x2D4
	MDH6    volatile.Register32 // 0x2D8
	MCR6    volatile.Register32 // 0x2DC
	MMR7    volatile.Register32 // 0x2E0
	MAM7    volatile.Register32 // 0x2E4
	MID7    volatile.Register32 // 0x2E8
	MFID7   volatile.Register32 // 0x2EC
	MSR7    volatile.Register32 // 0x2F0
	MDL7    volatile.Register32 // 0x2F4
	MDH7    volatile.Register32 // 0x2F8
	MCR7    volatile.Register32 // 0x2FC
}

// CAN.MR: Mode Register
func (o *CAN_Type) SetMR_CANEN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetMR_CANEN() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x1
}
func (o *CAN_Type) SetMR_LPM(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetMR_LPM() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetMR_ABM(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetMR_ABM() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetMR_OVL(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetMR_OVL() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetMR_TEOF(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetMR_TEOF() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetMR_TTM(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetMR_TTM() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetMR_TIMFRZ(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetMR_TIMFRZ() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetMR_DRPT(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetMR_DRPT() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x80) >> 7
}

// CAN.IER: Interrupt Enable Register
func (o *CAN_Type) SetIER_MB0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetIER_MB0() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *CAN_Type) SetIER_MB1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetIER_MB1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetIER_MB2(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetIER_MB2() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetIER_MB3(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetIER_MB3() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetIER_MB4(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetIER_MB4() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetIER_MB5(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetIER_MB5() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetIER_MB6(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetIER_MB6() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetIER_MB7(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetIER_MB7() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetIER_ERRA(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetIER_ERRA() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetIER_WARN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetIER_WARN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetIER_ERRP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetIER_ERRP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetIER_BOFF(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetIER_BOFF() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetIER_SLEEP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetIER_SLEEP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetIER_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetIER_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetIER_TOVF(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetIER_TOVF() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetIER_TSTP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetIER_TSTP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetIER_CERR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetIER_CERR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetIER_SERR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetIER_SERR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetIER_AERR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetIER_AERR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetIER_FERR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetIER_FERR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetIER_BERR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetIER_BERR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000000) >> 28
}

// CAN.IDR: Interrupt Disable Register
func (o *CAN_Type) SetIDR_MB0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetIDR_MB0() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *CAN_Type) SetIDR_MB1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetIDR_MB1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetIDR_MB2(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetIDR_MB2() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetIDR_MB3(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetIDR_MB3() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetIDR_MB4(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetIDR_MB4() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetIDR_MB5(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetIDR_MB5() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetIDR_MB6(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetIDR_MB6() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetIDR_MB7(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetIDR_MB7() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetIDR_ERRA(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetIDR_ERRA() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetIDR_WARN(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetIDR_WARN() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetIDR_ERRP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetIDR_ERRP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetIDR_BOFF(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetIDR_BOFF() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetIDR_SLEEP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetIDR_SLEEP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetIDR_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetIDR_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetIDR_TOVF(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetIDR_TOVF() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetIDR_TSTP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetIDR_TSTP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetIDR_CERR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetIDR_CERR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetIDR_SERR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetIDR_SERR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetIDR_AERR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetIDR_AERR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetIDR_FERR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetIDR_FERR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetIDR_BERR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetIDR_BERR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000000) >> 28
}

// CAN.IMR: Interrupt Mask Register
func (o *CAN_Type) SetIMR_MB0(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetIMR_MB0() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *CAN_Type) SetIMR_MB1(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetIMR_MB1() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetIMR_MB2(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetIMR_MB2() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetIMR_MB3(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetIMR_MB3() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetIMR_MB4(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetIMR_MB4() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetIMR_MB5(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetIMR_MB5() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetIMR_MB6(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetIMR_MB6() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetIMR_MB7(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetIMR_MB7() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetIMR_ERRA(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetIMR_ERRA() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetIMR_WARN(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetIMR_WARN() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetIMR_ERRP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetIMR_ERRP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetIMR_BOFF(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetIMR_BOFF() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetIMR_SLEEP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetIMR_SLEEP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetIMR_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetIMR_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetIMR_TOVF(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetIMR_TOVF() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetIMR_TSTP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetIMR_TSTP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetIMR_CERR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetIMR_CERR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetIMR_SERR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetIMR_SERR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetIMR_AERR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetIMR_AERR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetIMR_FERR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetIMR_FERR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetIMR_BERR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetIMR_BERR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000000) >> 28
}

// CAN.SR: Status Register
func (o *CAN_Type) SetSR_MB0(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetSR_MB0() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *CAN_Type) SetSR_MB1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetSR_MB1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetSR_MB2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetSR_MB2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetSR_MB3(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetSR_MB3() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetSR_MB4(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetSR_MB4() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetSR_MB5(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetSR_MB5() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetSR_MB6(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetSR_MB6() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetSR_MB7(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetSR_MB7() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetSR_ERRA(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetSR_ERRA() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetSR_WARN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetSR_WARN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetSR_ERRP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetSR_ERRP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetSR_BOFF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetSR_BOFF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetSR_SLEEP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetSR_SLEEP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetSR_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetSR_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetSR_TOVF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetSR_TOVF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetSR_TSTP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetSR_TSTP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetSR_CERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetSR_CERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetSR_SERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetSR_SERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetSR_AERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetSR_AERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetSR_FERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetSR_FERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetSR_BERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetSR_BERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetSR_RBSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetSR_RBSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetSR_TBSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetSR_TBSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetSR_OVLSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetSR_OVLSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000000) >> 31
}

// CAN.BR: Baudrate Register
func (o *CAN_Type) SetBR_PHASE2(value uint32) {
	volatile.StoreUint32(&o.BR.Reg, volatile.LoadUint32(&o.BR.Reg)&^(0x7)|value)
}
func (o *CAN_Type) GetBR_PHASE2() uint32 {
	return volatile.LoadUint32(&o.BR.Reg) & 0x7
}
func (o *CAN_Type) SetBR_PHASE1(value uint32) {
	volatile.StoreUint32(&o.BR.Reg, volatile.LoadUint32(&o.BR.Reg)&^(0x70)|value<<4)
}
func (o *CAN_Type) GetBR_PHASE1() uint32 {
	return (volatile.LoadUint32(&o.BR.Reg) & 0x70) >> 4
}
func (o *CAN_Type) SetBR_PROPAG(value uint32) {
	volatile.StoreUint32(&o.BR.Reg, volatile.LoadUint32(&o.BR.Reg)&^(0x700)|value<<8)
}
func (o *CAN_Type) GetBR_PROPAG() uint32 {
	return (volatile.LoadUint32(&o.BR.Reg) & 0x700) >> 8
}
func (o *CAN_Type) SetBR_SJW(value uint32) {
	volatile.StoreUint32(&o.BR.Reg, volatile.LoadUint32(&o.BR.Reg)&^(0x3000)|value<<12)
}
func (o *CAN_Type) GetBR_SJW() uint32 {
	return (volatile.LoadUint32(&o.BR.Reg) & 0x3000) >> 12
}
func (o *CAN_Type) SetBR_BRP(value uint32) {
	volatile.StoreUint32(&o.BR.Reg, volatile.LoadUint32(&o.BR.Reg)&^(0x7f0000)|value<<16)
}
func (o *CAN_Type) GetBR_BRP() uint32 {
	return (volatile.LoadUint32(&o.BR.Reg) & 0x7f0000) >> 16
}
func (o *CAN_Type) SetBR_SMP(value uint32) {
	volatile.StoreUint32(&o.BR.Reg, volatile.LoadUint32(&o.BR.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetBR_SMP() uint32 {
	return (volatile.LoadUint32(&o.BR.Reg) & 0x1000000) >> 24
}

// CAN.TIM: Timer Register
func (o *CAN_Type) SetTIM_TIMER(value uint32) {
	volatile.StoreUint32(&o.TIM.Reg, volatile.LoadUint32(&o.TIM.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetTIM_TIMER() uint32 {
	return volatile.LoadUint32(&o.TIM.Reg) & 0xffff
}

// CAN.TIMESTP: Timestamp Register
func (o *CAN_Type) SetTIMESTP_MTIMESTAMP(value uint32) {
	volatile.StoreUint32(&o.TIMESTP.Reg, volatile.LoadUint32(&o.TIMESTP.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetTIMESTP_MTIMESTAMP() uint32 {
	return volatile.LoadUint32(&o.TIMESTP.Reg) & 0xffff
}

// CAN.ECR: Error Counter Register
func (o *CAN_Type) SetECR_REC(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetECR_REC() uint32 {
	return volatile.LoadUint32(&o.ECR.Reg) & 0xff
}
func (o *CAN_Type) SetECR_TEC(value uint32) {
	volatile.StoreUint32(&o.ECR.Reg, volatile.LoadUint32(&o.ECR.Reg)&^(0x1ff0000)|value<<16)
}
func (o *CAN_Type) GetECR_TEC() uint32 {
	return (volatile.LoadUint32(&o.ECR.Reg) & 0x1ff0000) >> 16
}

// CAN.TCR: Transfer Command Register
func (o *CAN_Type) SetTCR_MB0(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetTCR_MB0() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0x1
}
func (o *CAN_Type) SetTCR_MB1(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetTCR_MB1() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetTCR_MB2(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetTCR_MB2() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetTCR_MB3(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetTCR_MB3() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetTCR_MB4(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetTCR_MB4() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetTCR_MB5(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetTCR_MB5() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetTCR_MB6(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetTCR_MB6() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetTCR_MB7(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetTCR_MB7() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetTCR_TIMRST(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetTCR_TIMRST() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x80000000) >> 31
}

// CAN.ACR: Abort Command Register
func (o *CAN_Type) SetACR_MB0(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetACR_MB0() uint32 {
	return volatile.LoadUint32(&o.ACR.Reg) & 0x1
}
func (o *CAN_Type) SetACR_MB1(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetACR_MB1() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetACR_MB2(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetACR_MB2() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetACR_MB3(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetACR_MB3() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetACR_MB4(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetACR_MB4() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetACR_MB5(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetACR_MB5() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetACR_MB6(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetACR_MB6() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetACR_MB7(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetACR_MB7() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x80) >> 7
}

// CAN.WPMR: Write Protect Mode Register
func (o *CAN_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *CAN_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *CAN_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// CAN.WPSR: Write Protect Status Register
func (o *CAN_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *CAN_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xff00) >> 8
}

// CAN.MMR0: Mailbox Mode Register (MB = 0)
func (o *CAN_Type) SetMMR0_MTIMEMARK(value uint32) {
	volatile.StoreUint32(&o.MMR0.Reg, volatile.LoadUint32(&o.MMR0.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetMMR0_MTIMEMARK() uint32 {
	return volatile.LoadUint32(&o.MMR0.Reg) & 0xffff
}
func (o *CAN_Type) SetMMR0_PRIOR(value uint32) {
	volatile.StoreUint32(&o.MMR0.Reg, volatile.LoadUint32(&o.MMR0.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMMR0_PRIOR() uint32 {
	return (volatile.LoadUint32(&o.MMR0.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMMR0_MOT(value uint32) {
	volatile.StoreUint32(&o.MMR0.Reg, volatile.LoadUint32(&o.MMR0.Reg)&^(0x7000000)|value<<24)
}
func (o *CAN_Type) GetMMR0_MOT() uint32 {
	return (volatile.LoadUint32(&o.MMR0.Reg) & 0x7000000) >> 24
}

// CAN.MAM0: Mailbox Acceptance Mask Register (MB = 0)
func (o *CAN_Type) SetMAM0_MIDvB(value uint32) {
	volatile.StoreUint32(&o.MAM0.Reg, volatile.LoadUint32(&o.MAM0.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetMAM0_MIDvB() uint32 {
	return volatile.LoadUint32(&o.MAM0.Reg) & 0x3ffff
}
func (o *CAN_Type) SetMAM0_MIDvA(value uint32) {
	volatile.StoreUint32(&o.MAM0.Reg, volatile.LoadUint32(&o.MAM0.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetMAM0_MIDvA() uint32 {
	return (volatile.LoadUint32(&o.MAM0.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetMAM0_MIDE(value uint32) {
	volatile.StoreUint32(&o.MAM0.Reg, volatile.LoadUint32(&o.MAM0.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetMAM0_MIDE() uint32 {
	return (volatile.LoadUint32(&o.MAM0.Reg) & 0x20000000) >> 29
}

// CAN.MID0: Mailbox ID Register (MB = 0)
func (o *CAN_Type) SetMID0_MIDvB(value uint32) {
	volatile.StoreUint32(&o.MID0.Reg, volatile.LoadUint32(&o.MID0.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetMID0_MIDvB() uint32 {
	return volatile.LoadUint32(&o.MID0.Reg) & 0x3ffff
}
func (o *CAN_Type) SetMID0_MIDvA(value uint32) {
	volatile.StoreUint32(&o.MID0.Reg, volatile.LoadUint32(&o.MID0.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetMID0_MIDvA() uint32 {
	return (volatile.LoadUint32(&o.MID0.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetMID0_MIDE(value uint32) {
	volatile.StoreUint32(&o.MID0.Reg, volatile.LoadUint32(&o.MID0.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetMID0_MIDE() uint32 {
	return (volatile.LoadUint32(&o.MID0.Reg) & 0x20000000) >> 29
}

// CAN.MFID0: Mailbox Family ID Register (MB = 0)
func (o *CAN_Type) SetMFID0_MFID(value uint32) {
	volatile.StoreUint32(&o.MFID0.Reg, volatile.LoadUint32(&o.MFID0.Reg)&^(0x1fffffff)|value)
}
func (o *CAN_Type) GetMFID0_MFID() uint32 {
	return volatile.LoadUint32(&o.MFID0.Reg) & 0x1fffffff
}

// CAN.MSR0: Mailbox Status Register (MB = 0)
func (o *CAN_Type) SetMSR0_MTIMESTAMP(value uint32) {
	volatile.StoreUint32(&o.MSR0.Reg, volatile.LoadUint32(&o.MSR0.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetMSR0_MTIMESTAMP() uint32 {
	return volatile.LoadUint32(&o.MSR0.Reg) & 0xffff
}
func (o *CAN_Type) SetMSR0_MDLC(value uint32) {
	volatile.StoreUint32(&o.MSR0.Reg, volatile.LoadUint32(&o.MSR0.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMSR0_MDLC() uint32 {
	return (volatile.LoadUint32(&o.MSR0.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMSR0_MRTR(value uint32) {
	volatile.StoreUint32(&o.MSR0.Reg, volatile.LoadUint32(&o.MSR0.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetMSR0_MRTR() uint32 {
	return (volatile.LoadUint32(&o.MSR0.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetMSR0_MABT(value uint32) {
	volatile.StoreUint32(&o.MSR0.Reg, volatile.LoadUint32(&o.MSR0.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetMSR0_MABT() uint32 {
	return (volatile.LoadUint32(&o.MSR0.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetMSR0_MRDY(value uint32) {
	volatile.StoreUint32(&o.MSR0.Reg, volatile.LoadUint32(&o.MSR0.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetMSR0_MRDY() uint32 {
	return (volatile.LoadUint32(&o.MSR0.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetMSR0_MMI(value uint32) {
	volatile.StoreUint32(&o.MSR0.Reg, volatile.LoadUint32(&o.MSR0.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetMSR0_MMI() uint32 {
	return (volatile.LoadUint32(&o.MSR0.Reg) & 0x1000000) >> 24
}

// CAN.MDL0: Mailbox Data Low Register (MB = 0)
func (o *CAN_Type) SetMDL0(value uint32) {
	volatile.StoreUint32(&o.MDL0.Reg, value)
}
func (o *CAN_Type) GetMDL0() uint32 {
	return volatile.LoadUint32(&o.MDL0.Reg)
}

// CAN.MDH0: Mailbox Data High Register (MB = 0)
func (o *CAN_Type) SetMDH0(value uint32) {
	volatile.StoreUint32(&o.MDH0.Reg, value)
}
func (o *CAN_Type) GetMDH0() uint32 {
	return volatile.LoadUint32(&o.MDH0.Reg)
}

// CAN.MCR0: Mailbox Control Register (MB = 0)
func (o *CAN_Type) SetMCR0_MDLC(value uint32) {
	volatile.StoreUint32(&o.MCR0.Reg, volatile.LoadUint32(&o.MCR0.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMCR0_MDLC() uint32 {
	return (volatile.LoadUint32(&o.MCR0.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMCR0_MRTR(value uint32) {
	volatile.StoreUint32(&o.MCR0.Reg, volatile.LoadUint32(&o.MCR0.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetMCR0_MRTR() uint32 {
	return (volatile.LoadUint32(&o.MCR0.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetMCR0_MACR(value uint32) {
	volatile.StoreUint32(&o.MCR0.Reg, volatile.LoadUint32(&o.MCR0.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetMCR0_MACR() uint32 {
	return (volatile.LoadUint32(&o.MCR0.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetMCR0_MTCR(value uint32) {
	volatile.StoreUint32(&o.MCR0.Reg, volatile.LoadUint32(&o.MCR0.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetMCR0_MTCR() uint32 {
	return (volatile.LoadUint32(&o.MCR0.Reg) & 0x800000) >> 23
}

// CAN.MMR1: Mailbox Mode Register (MB = 1)
func (o *CAN_Type) SetMMR1_MTIMEMARK(value uint32) {
	volatile.StoreUint32(&o.MMR1.Reg, volatile.LoadUint32(&o.MMR1.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetMMR1_MTIMEMARK() uint32 {
	return volatile.LoadUint32(&o.MMR1.Reg) & 0xffff
}
func (o *CAN_Type) SetMMR1_PRIOR(value uint32) {
	volatile.StoreUint32(&o.MMR1.Reg, volatile.LoadUint32(&o.MMR1.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMMR1_PRIOR() uint32 {
	return (volatile.LoadUint32(&o.MMR1.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMMR1_MOT(value uint32) {
	volatile.StoreUint32(&o.MMR1.Reg, volatile.LoadUint32(&o.MMR1.Reg)&^(0x7000000)|value<<24)
}
func (o *CAN_Type) GetMMR1_MOT() uint32 {
	return (volatile.LoadUint32(&o.MMR1.Reg) & 0x7000000) >> 24
}

// CAN.MAM1: Mailbox Acceptance Mask Register (MB = 1)
func (o *CAN_Type) SetMAM1_MIDvB(value uint32) {
	volatile.StoreUint32(&o.MAM1.Reg, volatile.LoadUint32(&o.MAM1.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetMAM1_MIDvB() uint32 {
	return volatile.LoadUint32(&o.MAM1.Reg) & 0x3ffff
}
func (o *CAN_Type) SetMAM1_MIDvA(value uint32) {
	volatile.StoreUint32(&o.MAM1.Reg, volatile.LoadUint32(&o.MAM1.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetMAM1_MIDvA() uint32 {
	return (volatile.LoadUint32(&o.MAM1.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetMAM1_MIDE(value uint32) {
	volatile.StoreUint32(&o.MAM1.Reg, volatile.LoadUint32(&o.MAM1.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetMAM1_MIDE() uint32 {
	return (volatile.LoadUint32(&o.MAM1.Reg) & 0x20000000) >> 29
}

// CAN.MID1: Mailbox ID Register (MB = 1)
func (o *CAN_Type) SetMID1_MIDvB(value uint32) {
	volatile.StoreUint32(&o.MID1.Reg, volatile.LoadUint32(&o.MID1.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetMID1_MIDvB() uint32 {
	return volatile.LoadUint32(&o.MID1.Reg) & 0x3ffff
}
func (o *CAN_Type) SetMID1_MIDvA(value uint32) {
	volatile.StoreUint32(&o.MID1.Reg, volatile.LoadUint32(&o.MID1.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetMID1_MIDvA() uint32 {
	return (volatile.LoadUint32(&o.MID1.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetMID1_MIDE(value uint32) {
	volatile.StoreUint32(&o.MID1.Reg, volatile.LoadUint32(&o.MID1.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetMID1_MIDE() uint32 {
	return (volatile.LoadUint32(&o.MID1.Reg) & 0x20000000) >> 29
}

// CAN.MFID1: Mailbox Family ID Register (MB = 1)
func (o *CAN_Type) SetMFID1_MFID(value uint32) {
	volatile.StoreUint32(&o.MFID1.Reg, volatile.LoadUint32(&o.MFID1.Reg)&^(0x1fffffff)|value)
}
func (o *CAN_Type) GetMFID1_MFID() uint32 {
	return volatile.LoadUint32(&o.MFID1.Reg) & 0x1fffffff
}

// CAN.MSR1: Mailbox Status Register (MB = 1)
func (o *CAN_Type) SetMSR1_MTIMESTAMP(value uint32) {
	volatile.StoreUint32(&o.MSR1.Reg, volatile.LoadUint32(&o.MSR1.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetMSR1_MTIMESTAMP() uint32 {
	return volatile.LoadUint32(&o.MSR1.Reg) & 0xffff
}
func (o *CAN_Type) SetMSR1_MDLC(value uint32) {
	volatile.StoreUint32(&o.MSR1.Reg, volatile.LoadUint32(&o.MSR1.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMSR1_MDLC() uint32 {
	return (volatile.LoadUint32(&o.MSR1.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMSR1_MRTR(value uint32) {
	volatile.StoreUint32(&o.MSR1.Reg, volatile.LoadUint32(&o.MSR1.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetMSR1_MRTR() uint32 {
	return (volatile.LoadUint32(&o.MSR1.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetMSR1_MABT(value uint32) {
	volatile.StoreUint32(&o.MSR1.Reg, volatile.LoadUint32(&o.MSR1.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetMSR1_MABT() uint32 {
	return (volatile.LoadUint32(&o.MSR1.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetMSR1_MRDY(value uint32) {
	volatile.StoreUint32(&o.MSR1.Reg, volatile.LoadUint32(&o.MSR1.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetMSR1_MRDY() uint32 {
	return (volatile.LoadUint32(&o.MSR1.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetMSR1_MMI(value uint32) {
	volatile.StoreUint32(&o.MSR1.Reg, volatile.LoadUint32(&o.MSR1.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetMSR1_MMI() uint32 {
	return (volatile.LoadUint32(&o.MSR1.Reg) & 0x1000000) >> 24
}

// CAN.MDL1: Mailbox Data Low Register (MB = 1)
func (o *CAN_Type) SetMDL1(value uint32) {
	volatile.StoreUint32(&o.MDL1.Reg, value)
}
func (o *CAN_Type) GetMDL1() uint32 {
	return volatile.LoadUint32(&o.MDL1.Reg)
}

// CAN.MDH1: Mailbox Data High Register (MB = 1)
func (o *CAN_Type) SetMDH1(value uint32) {
	volatile.StoreUint32(&o.MDH1.Reg, value)
}
func (o *CAN_Type) GetMDH1() uint32 {
	return volatile.LoadUint32(&o.MDH1.Reg)
}

// CAN.MCR1: Mailbox Control Register (MB = 1)
func (o *CAN_Type) SetMCR1_MDLC(value uint32) {
	volatile.StoreUint32(&o.MCR1.Reg, volatile.LoadUint32(&o.MCR1.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMCR1_MDLC() uint32 {
	return (volatile.LoadUint32(&o.MCR1.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMCR1_MRTR(value uint32) {
	volatile.StoreUint32(&o.MCR1.Reg, volatile.LoadUint32(&o.MCR1.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetMCR1_MRTR() uint32 {
	return (volatile.LoadUint32(&o.MCR1.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetMCR1_MACR(value uint32) {
	volatile.StoreUint32(&o.MCR1.Reg, volatile.LoadUint32(&o.MCR1.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetMCR1_MACR() uint32 {
	return (volatile.LoadUint32(&o.MCR1.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetMCR1_MTCR(value uint32) {
	volatile.StoreUint32(&o.MCR1.Reg, volatile.LoadUint32(&o.MCR1.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetMCR1_MTCR() uint32 {
	return (volatile.LoadUint32(&o.MCR1.Reg) & 0x800000) >> 23
}

// CAN.MMR2: Mailbox Mode Register (MB = 2)
func (o *CAN_Type) SetMMR2_MTIMEMARK(value uint32) {
	volatile.StoreUint32(&o.MMR2.Reg, volatile.LoadUint32(&o.MMR2.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetMMR2_MTIMEMARK() uint32 {
	return volatile.LoadUint32(&o.MMR2.Reg) & 0xffff
}
func (o *CAN_Type) SetMMR2_PRIOR(value uint32) {
	volatile.StoreUint32(&o.MMR2.Reg, volatile.LoadUint32(&o.MMR2.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMMR2_PRIOR() uint32 {
	return (volatile.LoadUint32(&o.MMR2.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMMR2_MOT(value uint32) {
	volatile.StoreUint32(&o.MMR2.Reg, volatile.LoadUint32(&o.MMR2.Reg)&^(0x7000000)|value<<24)
}
func (o *CAN_Type) GetMMR2_MOT() uint32 {
	return (volatile.LoadUint32(&o.MMR2.Reg) & 0x7000000) >> 24
}

// CAN.MAM2: Mailbox Acceptance Mask Register (MB = 2)
func (o *CAN_Type) SetMAM2_MIDvB(value uint32) {
	volatile.StoreUint32(&o.MAM2.Reg, volatile.LoadUint32(&o.MAM2.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetMAM2_MIDvB() uint32 {
	return volatile.LoadUint32(&o.MAM2.Reg) & 0x3ffff
}
func (o *CAN_Type) SetMAM2_MIDvA(value uint32) {
	volatile.StoreUint32(&o.MAM2.Reg, volatile.LoadUint32(&o.MAM2.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetMAM2_MIDvA() uint32 {
	return (volatile.LoadUint32(&o.MAM2.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetMAM2_MIDE(value uint32) {
	volatile.StoreUint32(&o.MAM2.Reg, volatile.LoadUint32(&o.MAM2.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetMAM2_MIDE() uint32 {
	return (volatile.LoadUint32(&o.MAM2.Reg) & 0x20000000) >> 29
}

// CAN.MID2: Mailbox ID Register (MB = 2)
func (o *CAN_Type) SetMID2_MIDvB(value uint32) {
	volatile.StoreUint32(&o.MID2.Reg, volatile.LoadUint32(&o.MID2.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetMID2_MIDvB() uint32 {
	return volatile.LoadUint32(&o.MID2.Reg) & 0x3ffff
}
func (o *CAN_Type) SetMID2_MIDvA(value uint32) {
	volatile.StoreUint32(&o.MID2.Reg, volatile.LoadUint32(&o.MID2.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetMID2_MIDvA() uint32 {
	return (volatile.LoadUint32(&o.MID2.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetMID2_MIDE(value uint32) {
	volatile.StoreUint32(&o.MID2.Reg, volatile.LoadUint32(&o.MID2.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetMID2_MIDE() uint32 {
	return (volatile.LoadUint32(&o.MID2.Reg) & 0x20000000) >> 29
}

// CAN.MFID2: Mailbox Family ID Register (MB = 2)
func (o *CAN_Type) SetMFID2_MFID(value uint32) {
	volatile.StoreUint32(&o.MFID2.Reg, volatile.LoadUint32(&o.MFID2.Reg)&^(0x1fffffff)|value)
}
func (o *CAN_Type) GetMFID2_MFID() uint32 {
	return volatile.LoadUint32(&o.MFID2.Reg) & 0x1fffffff
}

// CAN.MSR2: Mailbox Status Register (MB = 2)
func (o *CAN_Type) SetMSR2_MTIMESTAMP(value uint32) {
	volatile.StoreUint32(&o.MSR2.Reg, volatile.LoadUint32(&o.MSR2.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetMSR2_MTIMESTAMP() uint32 {
	return volatile.LoadUint32(&o.MSR2.Reg) & 0xffff
}
func (o *CAN_Type) SetMSR2_MDLC(value uint32) {
	volatile.StoreUint32(&o.MSR2.Reg, volatile.LoadUint32(&o.MSR2.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMSR2_MDLC() uint32 {
	return (volatile.LoadUint32(&o.MSR2.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMSR2_MRTR(value uint32) {
	volatile.StoreUint32(&o.MSR2.Reg, volatile.LoadUint32(&o.MSR2.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetMSR2_MRTR() uint32 {
	return (volatile.LoadUint32(&o.MSR2.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetMSR2_MABT(value uint32) {
	volatile.StoreUint32(&o.MSR2.Reg, volatile.LoadUint32(&o.MSR2.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetMSR2_MABT() uint32 {
	return (volatile.LoadUint32(&o.MSR2.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetMSR2_MRDY(value uint32) {
	volatile.StoreUint32(&o.MSR2.Reg, volatile.LoadUint32(&o.MSR2.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetMSR2_MRDY() uint32 {
	return (volatile.LoadUint32(&o.MSR2.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetMSR2_MMI(value uint32) {
	volatile.StoreUint32(&o.MSR2.Reg, volatile.LoadUint32(&o.MSR2.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetMSR2_MMI() uint32 {
	return (volatile.LoadUint32(&o.MSR2.Reg) & 0x1000000) >> 24
}

// CAN.MDL2: Mailbox Data Low Register (MB = 2)
func (o *CAN_Type) SetMDL2(value uint32) {
	volatile.StoreUint32(&o.MDL2.Reg, value)
}
func (o *CAN_Type) GetMDL2() uint32 {
	return volatile.LoadUint32(&o.MDL2.Reg)
}

// CAN.MDH2: Mailbox Data High Register (MB = 2)
func (o *CAN_Type) SetMDH2(value uint32) {
	volatile.StoreUint32(&o.MDH2.Reg, value)
}
func (o *CAN_Type) GetMDH2() uint32 {
	return volatile.LoadUint32(&o.MDH2.Reg)
}

// CAN.MCR2: Mailbox Control Register (MB = 2)
func (o *CAN_Type) SetMCR2_MDLC(value uint32) {
	volatile.StoreUint32(&o.MCR2.Reg, volatile.LoadUint32(&o.MCR2.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMCR2_MDLC() uint32 {
	return (volatile.LoadUint32(&o.MCR2.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMCR2_MRTR(value uint32) {
	volatile.StoreUint32(&o.MCR2.Reg, volatile.LoadUint32(&o.MCR2.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetMCR2_MRTR() uint32 {
	return (volatile.LoadUint32(&o.MCR2.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetMCR2_MACR(value uint32) {
	volatile.StoreUint32(&o.MCR2.Reg, volatile.LoadUint32(&o.MCR2.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetMCR2_MACR() uint32 {
	return (volatile.LoadUint32(&o.MCR2.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetMCR2_MTCR(value uint32) {
	volatile.StoreUint32(&o.MCR2.Reg, volatile.LoadUint32(&o.MCR2.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetMCR2_MTCR() uint32 {
	return (volatile.LoadUint32(&o.MCR2.Reg) & 0x800000) >> 23
}

// CAN.MMR3: Mailbox Mode Register (MB = 3)
func (o *CAN_Type) SetMMR3_MTIMEMARK(value uint32) {
	volatile.StoreUint32(&o.MMR3.Reg, volatile.LoadUint32(&o.MMR3.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetMMR3_MTIMEMARK() uint32 {
	return volatile.LoadUint32(&o.MMR3.Reg) & 0xffff
}
func (o *CAN_Type) SetMMR3_PRIOR(value uint32) {
	volatile.StoreUint32(&o.MMR3.Reg, volatile.LoadUint32(&o.MMR3.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMMR3_PRIOR() uint32 {
	return (volatile.LoadUint32(&o.MMR3.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMMR3_MOT(value uint32) {
	volatile.StoreUint32(&o.MMR3.Reg, volatile.LoadUint32(&o.MMR3.Reg)&^(0x7000000)|value<<24)
}
func (o *CAN_Type) GetMMR3_MOT() uint32 {
	return (volatile.LoadUint32(&o.MMR3.Reg) & 0x7000000) >> 24
}

// CAN.MAM3: Mailbox Acceptance Mask Register (MB = 3)
func (o *CAN_Type) SetMAM3_MIDvB(value uint32) {
	volatile.StoreUint32(&o.MAM3.Reg, volatile.LoadUint32(&o.MAM3.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetMAM3_MIDvB() uint32 {
	return volatile.LoadUint32(&o.MAM3.Reg) & 0x3ffff
}
func (o *CAN_Type) SetMAM3_MIDvA(value uint32) {
	volatile.StoreUint32(&o.MAM3.Reg, volatile.LoadUint32(&o.MAM3.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetMAM3_MIDvA() uint32 {
	return (volatile.LoadUint32(&o.MAM3.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetMAM3_MIDE(value uint32) {
	volatile.StoreUint32(&o.MAM3.Reg, volatile.LoadUint32(&o.MAM3.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetMAM3_MIDE() uint32 {
	return (volatile.LoadUint32(&o.MAM3.Reg) & 0x20000000) >> 29
}

// CAN.MID3: Mailbox ID Register (MB = 3)
func (o *CAN_Type) SetMID3_MIDvB(value uint32) {
	volatile.StoreUint32(&o.MID3.Reg, volatile.LoadUint32(&o.MID3.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetMID3_MIDvB() uint32 {
	return volatile.LoadUint32(&o.MID3.Reg) & 0x3ffff
}
func (o *CAN_Type) SetMID3_MIDvA(value uint32) {
	volatile.StoreUint32(&o.MID3.Reg, volatile.LoadUint32(&o.MID3.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetMID3_MIDvA() uint32 {
	return (volatile.LoadUint32(&o.MID3.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetMID3_MIDE(value uint32) {
	volatile.StoreUint32(&o.MID3.Reg, volatile.LoadUint32(&o.MID3.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetMID3_MIDE() uint32 {
	return (volatile.LoadUint32(&o.MID3.Reg) & 0x20000000) >> 29
}

// CAN.MFID3: Mailbox Family ID Register (MB = 3)
func (o *CAN_Type) SetMFID3_MFID(value uint32) {
	volatile.StoreUint32(&o.MFID3.Reg, volatile.LoadUint32(&o.MFID3.Reg)&^(0x1fffffff)|value)
}
func (o *CAN_Type) GetMFID3_MFID() uint32 {
	return volatile.LoadUint32(&o.MFID3.Reg) & 0x1fffffff
}

// CAN.MSR3: Mailbox Status Register (MB = 3)
func (o *CAN_Type) SetMSR3_MTIMESTAMP(value uint32) {
	volatile.StoreUint32(&o.MSR3.Reg, volatile.LoadUint32(&o.MSR3.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetMSR3_MTIMESTAMP() uint32 {
	return volatile.LoadUint32(&o.MSR3.Reg) & 0xffff
}
func (o *CAN_Type) SetMSR3_MDLC(value uint32) {
	volatile.StoreUint32(&o.MSR3.Reg, volatile.LoadUint32(&o.MSR3.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMSR3_MDLC() uint32 {
	return (volatile.LoadUint32(&o.MSR3.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMSR3_MRTR(value uint32) {
	volatile.StoreUint32(&o.MSR3.Reg, volatile.LoadUint32(&o.MSR3.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetMSR3_MRTR() uint32 {
	return (volatile.LoadUint32(&o.MSR3.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetMSR3_MABT(value uint32) {
	volatile.StoreUint32(&o.MSR3.Reg, volatile.LoadUint32(&o.MSR3.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetMSR3_MABT() uint32 {
	return (volatile.LoadUint32(&o.MSR3.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetMSR3_MRDY(value uint32) {
	volatile.StoreUint32(&o.MSR3.Reg, volatile.LoadUint32(&o.MSR3.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetMSR3_MRDY() uint32 {
	return (volatile.LoadUint32(&o.MSR3.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetMSR3_MMI(value uint32) {
	volatile.StoreUint32(&o.MSR3.Reg, volatile.LoadUint32(&o.MSR3.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetMSR3_MMI() uint32 {
	return (volatile.LoadUint32(&o.MSR3.Reg) & 0x1000000) >> 24
}

// CAN.MDL3: Mailbox Data Low Register (MB = 3)
func (o *CAN_Type) SetMDL3(value uint32) {
	volatile.StoreUint32(&o.MDL3.Reg, value)
}
func (o *CAN_Type) GetMDL3() uint32 {
	return volatile.LoadUint32(&o.MDL3.Reg)
}

// CAN.MDH3: Mailbox Data High Register (MB = 3)
func (o *CAN_Type) SetMDH3(value uint32) {
	volatile.StoreUint32(&o.MDH3.Reg, value)
}
func (o *CAN_Type) GetMDH3() uint32 {
	return volatile.LoadUint32(&o.MDH3.Reg)
}

// CAN.MCR3: Mailbox Control Register (MB = 3)
func (o *CAN_Type) SetMCR3_MDLC(value uint32) {
	volatile.StoreUint32(&o.MCR3.Reg, volatile.LoadUint32(&o.MCR3.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMCR3_MDLC() uint32 {
	return (volatile.LoadUint32(&o.MCR3.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMCR3_MRTR(value uint32) {
	volatile.StoreUint32(&o.MCR3.Reg, volatile.LoadUint32(&o.MCR3.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetMCR3_MRTR() uint32 {
	return (volatile.LoadUint32(&o.MCR3.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetMCR3_MACR(value uint32) {
	volatile.StoreUint32(&o.MCR3.Reg, volatile.LoadUint32(&o.MCR3.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetMCR3_MACR() uint32 {
	return (volatile.LoadUint32(&o.MCR3.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetMCR3_MTCR(value uint32) {
	volatile.StoreUint32(&o.MCR3.Reg, volatile.LoadUint32(&o.MCR3.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetMCR3_MTCR() uint32 {
	return (volatile.LoadUint32(&o.MCR3.Reg) & 0x800000) >> 23
}

// CAN.MMR4: Mailbox Mode Register (MB = 4)
func (o *CAN_Type) SetMMR4_MTIMEMARK(value uint32) {
	volatile.StoreUint32(&o.MMR4.Reg, volatile.LoadUint32(&o.MMR4.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetMMR4_MTIMEMARK() uint32 {
	return volatile.LoadUint32(&o.MMR4.Reg) & 0xffff
}
func (o *CAN_Type) SetMMR4_PRIOR(value uint32) {
	volatile.StoreUint32(&o.MMR4.Reg, volatile.LoadUint32(&o.MMR4.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMMR4_PRIOR() uint32 {
	return (volatile.LoadUint32(&o.MMR4.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMMR4_MOT(value uint32) {
	volatile.StoreUint32(&o.MMR4.Reg, volatile.LoadUint32(&o.MMR4.Reg)&^(0x7000000)|value<<24)
}
func (o *CAN_Type) GetMMR4_MOT() uint32 {
	return (volatile.LoadUint32(&o.MMR4.Reg) & 0x7000000) >> 24
}

// CAN.MAM4: Mailbox Acceptance Mask Register (MB = 4)
func (o *CAN_Type) SetMAM4_MIDvB(value uint32) {
	volatile.StoreUint32(&o.MAM4.Reg, volatile.LoadUint32(&o.MAM4.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetMAM4_MIDvB() uint32 {
	return volatile.LoadUint32(&o.MAM4.Reg) & 0x3ffff
}
func (o *CAN_Type) SetMAM4_MIDvA(value uint32) {
	volatile.StoreUint32(&o.MAM4.Reg, volatile.LoadUint32(&o.MAM4.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetMAM4_MIDvA() uint32 {
	return (volatile.LoadUint32(&o.MAM4.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetMAM4_MIDE(value uint32) {
	volatile.StoreUint32(&o.MAM4.Reg, volatile.LoadUint32(&o.MAM4.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetMAM4_MIDE() uint32 {
	return (volatile.LoadUint32(&o.MAM4.Reg) & 0x20000000) >> 29
}

// CAN.MID4: Mailbox ID Register (MB = 4)
func (o *CAN_Type) SetMID4_MIDvB(value uint32) {
	volatile.StoreUint32(&o.MID4.Reg, volatile.LoadUint32(&o.MID4.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetMID4_MIDvB() uint32 {
	return volatile.LoadUint32(&o.MID4.Reg) & 0x3ffff
}
func (o *CAN_Type) SetMID4_MIDvA(value uint32) {
	volatile.StoreUint32(&o.MID4.Reg, volatile.LoadUint32(&o.MID4.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetMID4_MIDvA() uint32 {
	return (volatile.LoadUint32(&o.MID4.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetMID4_MIDE(value uint32) {
	volatile.StoreUint32(&o.MID4.Reg, volatile.LoadUint32(&o.MID4.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetMID4_MIDE() uint32 {
	return (volatile.LoadUint32(&o.MID4.Reg) & 0x20000000) >> 29
}

// CAN.MFID4: Mailbox Family ID Register (MB = 4)
func (o *CAN_Type) SetMFID4_MFID(value uint32) {
	volatile.StoreUint32(&o.MFID4.Reg, volatile.LoadUint32(&o.MFID4.Reg)&^(0x1fffffff)|value)
}
func (o *CAN_Type) GetMFID4_MFID() uint32 {
	return volatile.LoadUint32(&o.MFID4.Reg) & 0x1fffffff
}

// CAN.MSR4: Mailbox Status Register (MB = 4)
func (o *CAN_Type) SetMSR4_MTIMESTAMP(value uint32) {
	volatile.StoreUint32(&o.MSR4.Reg, volatile.LoadUint32(&o.MSR4.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetMSR4_MTIMESTAMP() uint32 {
	return volatile.LoadUint32(&o.MSR4.Reg) & 0xffff
}
func (o *CAN_Type) SetMSR4_MDLC(value uint32) {
	volatile.StoreUint32(&o.MSR4.Reg, volatile.LoadUint32(&o.MSR4.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMSR4_MDLC() uint32 {
	return (volatile.LoadUint32(&o.MSR4.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMSR4_MRTR(value uint32) {
	volatile.StoreUint32(&o.MSR4.Reg, volatile.LoadUint32(&o.MSR4.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetMSR4_MRTR() uint32 {
	return (volatile.LoadUint32(&o.MSR4.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetMSR4_MABT(value uint32) {
	volatile.StoreUint32(&o.MSR4.Reg, volatile.LoadUint32(&o.MSR4.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetMSR4_MABT() uint32 {
	return (volatile.LoadUint32(&o.MSR4.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetMSR4_MRDY(value uint32) {
	volatile.StoreUint32(&o.MSR4.Reg, volatile.LoadUint32(&o.MSR4.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetMSR4_MRDY() uint32 {
	return (volatile.LoadUint32(&o.MSR4.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetMSR4_MMI(value uint32) {
	volatile.StoreUint32(&o.MSR4.Reg, volatile.LoadUint32(&o.MSR4.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetMSR4_MMI() uint32 {
	return (volatile.LoadUint32(&o.MSR4.Reg) & 0x1000000) >> 24
}

// CAN.MDL4: Mailbox Data Low Register (MB = 4)
func (o *CAN_Type) SetMDL4(value uint32) {
	volatile.StoreUint32(&o.MDL4.Reg, value)
}
func (o *CAN_Type) GetMDL4() uint32 {
	return volatile.LoadUint32(&o.MDL4.Reg)
}

// CAN.MDH4: Mailbox Data High Register (MB = 4)
func (o *CAN_Type) SetMDH4(value uint32) {
	volatile.StoreUint32(&o.MDH4.Reg, value)
}
func (o *CAN_Type) GetMDH4() uint32 {
	return volatile.LoadUint32(&o.MDH4.Reg)
}

// CAN.MCR4: Mailbox Control Register (MB = 4)
func (o *CAN_Type) SetMCR4_MDLC(value uint32) {
	volatile.StoreUint32(&o.MCR4.Reg, volatile.LoadUint32(&o.MCR4.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMCR4_MDLC() uint32 {
	return (volatile.LoadUint32(&o.MCR4.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMCR4_MRTR(value uint32) {
	volatile.StoreUint32(&o.MCR4.Reg, volatile.LoadUint32(&o.MCR4.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetMCR4_MRTR() uint32 {
	return (volatile.LoadUint32(&o.MCR4.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetMCR4_MACR(value uint32) {
	volatile.StoreUint32(&o.MCR4.Reg, volatile.LoadUint32(&o.MCR4.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetMCR4_MACR() uint32 {
	return (volatile.LoadUint32(&o.MCR4.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetMCR4_MTCR(value uint32) {
	volatile.StoreUint32(&o.MCR4.Reg, volatile.LoadUint32(&o.MCR4.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetMCR4_MTCR() uint32 {
	return (volatile.LoadUint32(&o.MCR4.Reg) & 0x800000) >> 23
}

// CAN.MMR5: Mailbox Mode Register (MB = 5)
func (o *CAN_Type) SetMMR5_MTIMEMARK(value uint32) {
	volatile.StoreUint32(&o.MMR5.Reg, volatile.LoadUint32(&o.MMR5.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetMMR5_MTIMEMARK() uint32 {
	return volatile.LoadUint32(&o.MMR5.Reg) & 0xffff
}
func (o *CAN_Type) SetMMR5_PRIOR(value uint32) {
	volatile.StoreUint32(&o.MMR5.Reg, volatile.LoadUint32(&o.MMR5.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMMR5_PRIOR() uint32 {
	return (volatile.LoadUint32(&o.MMR5.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMMR5_MOT(value uint32) {
	volatile.StoreUint32(&o.MMR5.Reg, volatile.LoadUint32(&o.MMR5.Reg)&^(0x7000000)|value<<24)
}
func (o *CAN_Type) GetMMR5_MOT() uint32 {
	return (volatile.LoadUint32(&o.MMR5.Reg) & 0x7000000) >> 24
}

// CAN.MAM5: Mailbox Acceptance Mask Register (MB = 5)
func (o *CAN_Type) SetMAM5_MIDvB(value uint32) {
	volatile.StoreUint32(&o.MAM5.Reg, volatile.LoadUint32(&o.MAM5.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetMAM5_MIDvB() uint32 {
	return volatile.LoadUint32(&o.MAM5.Reg) & 0x3ffff
}
func (o *CAN_Type) SetMAM5_MIDvA(value uint32) {
	volatile.StoreUint32(&o.MAM5.Reg, volatile.LoadUint32(&o.MAM5.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetMAM5_MIDvA() uint32 {
	return (volatile.LoadUint32(&o.MAM5.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetMAM5_MIDE(value uint32) {
	volatile.StoreUint32(&o.MAM5.Reg, volatile.LoadUint32(&o.MAM5.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetMAM5_MIDE() uint32 {
	return (volatile.LoadUint32(&o.MAM5.Reg) & 0x20000000) >> 29
}

// CAN.MID5: Mailbox ID Register (MB = 5)
func (o *CAN_Type) SetMID5_MIDvB(value uint32) {
	volatile.StoreUint32(&o.MID5.Reg, volatile.LoadUint32(&o.MID5.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetMID5_MIDvB() uint32 {
	return volatile.LoadUint32(&o.MID5.Reg) & 0x3ffff
}
func (o *CAN_Type) SetMID5_MIDvA(value uint32) {
	volatile.StoreUint32(&o.MID5.Reg, volatile.LoadUint32(&o.MID5.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetMID5_MIDvA() uint32 {
	return (volatile.LoadUint32(&o.MID5.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetMID5_MIDE(value uint32) {
	volatile.StoreUint32(&o.MID5.Reg, volatile.LoadUint32(&o.MID5.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetMID5_MIDE() uint32 {
	return (volatile.LoadUint32(&o.MID5.Reg) & 0x20000000) >> 29
}

// CAN.MFID5: Mailbox Family ID Register (MB = 5)
func (o *CAN_Type) SetMFID5_MFID(value uint32) {
	volatile.StoreUint32(&o.MFID5.Reg, volatile.LoadUint32(&o.MFID5.Reg)&^(0x1fffffff)|value)
}
func (o *CAN_Type) GetMFID5_MFID() uint32 {
	return volatile.LoadUint32(&o.MFID5.Reg) & 0x1fffffff
}

// CAN.MSR5: Mailbox Status Register (MB = 5)
func (o *CAN_Type) SetMSR5_MTIMESTAMP(value uint32) {
	volatile.StoreUint32(&o.MSR5.Reg, volatile.LoadUint32(&o.MSR5.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetMSR5_MTIMESTAMP() uint32 {
	return volatile.LoadUint32(&o.MSR5.Reg) & 0xffff
}
func (o *CAN_Type) SetMSR5_MDLC(value uint32) {
	volatile.StoreUint32(&o.MSR5.Reg, volatile.LoadUint32(&o.MSR5.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMSR5_MDLC() uint32 {
	return (volatile.LoadUint32(&o.MSR5.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMSR5_MRTR(value uint32) {
	volatile.StoreUint32(&o.MSR5.Reg, volatile.LoadUint32(&o.MSR5.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetMSR5_MRTR() uint32 {
	return (volatile.LoadUint32(&o.MSR5.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetMSR5_MABT(value uint32) {
	volatile.StoreUint32(&o.MSR5.Reg, volatile.LoadUint32(&o.MSR5.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetMSR5_MABT() uint32 {
	return (volatile.LoadUint32(&o.MSR5.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetMSR5_MRDY(value uint32) {
	volatile.StoreUint32(&o.MSR5.Reg, volatile.LoadUint32(&o.MSR5.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetMSR5_MRDY() uint32 {
	return (volatile.LoadUint32(&o.MSR5.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetMSR5_MMI(value uint32) {
	volatile.StoreUint32(&o.MSR5.Reg, volatile.LoadUint32(&o.MSR5.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetMSR5_MMI() uint32 {
	return (volatile.LoadUint32(&o.MSR5.Reg) & 0x1000000) >> 24
}

// CAN.MDL5: Mailbox Data Low Register (MB = 5)
func (o *CAN_Type) SetMDL5(value uint32) {
	volatile.StoreUint32(&o.MDL5.Reg, value)
}
func (o *CAN_Type) GetMDL5() uint32 {
	return volatile.LoadUint32(&o.MDL5.Reg)
}

// CAN.MDH5: Mailbox Data High Register (MB = 5)
func (o *CAN_Type) SetMDH5(value uint32) {
	volatile.StoreUint32(&o.MDH5.Reg, value)
}
func (o *CAN_Type) GetMDH5() uint32 {
	return volatile.LoadUint32(&o.MDH5.Reg)
}

// CAN.MCR5: Mailbox Control Register (MB = 5)
func (o *CAN_Type) SetMCR5_MDLC(value uint32) {
	volatile.StoreUint32(&o.MCR5.Reg, volatile.LoadUint32(&o.MCR5.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMCR5_MDLC() uint32 {
	return (volatile.LoadUint32(&o.MCR5.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMCR5_MRTR(value uint32) {
	volatile.StoreUint32(&o.MCR5.Reg, volatile.LoadUint32(&o.MCR5.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetMCR5_MRTR() uint32 {
	return (volatile.LoadUint32(&o.MCR5.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetMCR5_MACR(value uint32) {
	volatile.StoreUint32(&o.MCR5.Reg, volatile.LoadUint32(&o.MCR5.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetMCR5_MACR() uint32 {
	return (volatile.LoadUint32(&o.MCR5.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetMCR5_MTCR(value uint32) {
	volatile.StoreUint32(&o.MCR5.Reg, volatile.LoadUint32(&o.MCR5.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetMCR5_MTCR() uint32 {
	return (volatile.LoadUint32(&o.MCR5.Reg) & 0x800000) >> 23
}

// CAN.MMR6: Mailbox Mode Register (MB = 6)
func (o *CAN_Type) SetMMR6_MTIMEMARK(value uint32) {
	volatile.StoreUint32(&o.MMR6.Reg, volatile.LoadUint32(&o.MMR6.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetMMR6_MTIMEMARK() uint32 {
	return volatile.LoadUint32(&o.MMR6.Reg) & 0xffff
}
func (o *CAN_Type) SetMMR6_PRIOR(value uint32) {
	volatile.StoreUint32(&o.MMR6.Reg, volatile.LoadUint32(&o.MMR6.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMMR6_PRIOR() uint32 {
	return (volatile.LoadUint32(&o.MMR6.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMMR6_MOT(value uint32) {
	volatile.StoreUint32(&o.MMR6.Reg, volatile.LoadUint32(&o.MMR6.Reg)&^(0x7000000)|value<<24)
}
func (o *CAN_Type) GetMMR6_MOT() uint32 {
	return (volatile.LoadUint32(&o.MMR6.Reg) & 0x7000000) >> 24
}

// CAN.MAM6: Mailbox Acceptance Mask Register (MB = 6)
func (o *CAN_Type) SetMAM6_MIDvB(value uint32) {
	volatile.StoreUint32(&o.MAM6.Reg, volatile.LoadUint32(&o.MAM6.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetMAM6_MIDvB() uint32 {
	return volatile.LoadUint32(&o.MAM6.Reg) & 0x3ffff
}
func (o *CAN_Type) SetMAM6_MIDvA(value uint32) {
	volatile.StoreUint32(&o.MAM6.Reg, volatile.LoadUint32(&o.MAM6.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetMAM6_MIDvA() uint32 {
	return (volatile.LoadUint32(&o.MAM6.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetMAM6_MIDE(value uint32) {
	volatile.StoreUint32(&o.MAM6.Reg, volatile.LoadUint32(&o.MAM6.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetMAM6_MIDE() uint32 {
	return (volatile.LoadUint32(&o.MAM6.Reg) & 0x20000000) >> 29
}

// CAN.MID6: Mailbox ID Register (MB = 6)
func (o *CAN_Type) SetMID6_MIDvB(value uint32) {
	volatile.StoreUint32(&o.MID6.Reg, volatile.LoadUint32(&o.MID6.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetMID6_MIDvB() uint32 {
	return volatile.LoadUint32(&o.MID6.Reg) & 0x3ffff
}
func (o *CAN_Type) SetMID6_MIDvA(value uint32) {
	volatile.StoreUint32(&o.MID6.Reg, volatile.LoadUint32(&o.MID6.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetMID6_MIDvA() uint32 {
	return (volatile.LoadUint32(&o.MID6.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetMID6_MIDE(value uint32) {
	volatile.StoreUint32(&o.MID6.Reg, volatile.LoadUint32(&o.MID6.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetMID6_MIDE() uint32 {
	return (volatile.LoadUint32(&o.MID6.Reg) & 0x20000000) >> 29
}

// CAN.MFID6: Mailbox Family ID Register (MB = 6)
func (o *CAN_Type) SetMFID6_MFID(value uint32) {
	volatile.StoreUint32(&o.MFID6.Reg, volatile.LoadUint32(&o.MFID6.Reg)&^(0x1fffffff)|value)
}
func (o *CAN_Type) GetMFID6_MFID() uint32 {
	return volatile.LoadUint32(&o.MFID6.Reg) & 0x1fffffff
}

// CAN.MSR6: Mailbox Status Register (MB = 6)
func (o *CAN_Type) SetMSR6_MTIMESTAMP(value uint32) {
	volatile.StoreUint32(&o.MSR6.Reg, volatile.LoadUint32(&o.MSR6.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetMSR6_MTIMESTAMP() uint32 {
	return volatile.LoadUint32(&o.MSR6.Reg) & 0xffff
}
func (o *CAN_Type) SetMSR6_MDLC(value uint32) {
	volatile.StoreUint32(&o.MSR6.Reg, volatile.LoadUint32(&o.MSR6.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMSR6_MDLC() uint32 {
	return (volatile.LoadUint32(&o.MSR6.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMSR6_MRTR(value uint32) {
	volatile.StoreUint32(&o.MSR6.Reg, volatile.LoadUint32(&o.MSR6.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetMSR6_MRTR() uint32 {
	return (volatile.LoadUint32(&o.MSR6.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetMSR6_MABT(value uint32) {
	volatile.StoreUint32(&o.MSR6.Reg, volatile.LoadUint32(&o.MSR6.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetMSR6_MABT() uint32 {
	return (volatile.LoadUint32(&o.MSR6.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetMSR6_MRDY(value uint32) {
	volatile.StoreUint32(&o.MSR6.Reg, volatile.LoadUint32(&o.MSR6.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetMSR6_MRDY() uint32 {
	return (volatile.LoadUint32(&o.MSR6.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetMSR6_MMI(value uint32) {
	volatile.StoreUint32(&o.MSR6.Reg, volatile.LoadUint32(&o.MSR6.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetMSR6_MMI() uint32 {
	return (volatile.LoadUint32(&o.MSR6.Reg) & 0x1000000) >> 24
}

// CAN.MDL6: Mailbox Data Low Register (MB = 6)
func (o *CAN_Type) SetMDL6(value uint32) {
	volatile.StoreUint32(&o.MDL6.Reg, value)
}
func (o *CAN_Type) GetMDL6() uint32 {
	return volatile.LoadUint32(&o.MDL6.Reg)
}

// CAN.MDH6: Mailbox Data High Register (MB = 6)
func (o *CAN_Type) SetMDH6(value uint32) {
	volatile.StoreUint32(&o.MDH6.Reg, value)
}
func (o *CAN_Type) GetMDH6() uint32 {
	return volatile.LoadUint32(&o.MDH6.Reg)
}

// CAN.MCR6: Mailbox Control Register (MB = 6)
func (o *CAN_Type) SetMCR6_MDLC(value uint32) {
	volatile.StoreUint32(&o.MCR6.Reg, volatile.LoadUint32(&o.MCR6.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMCR6_MDLC() uint32 {
	return (volatile.LoadUint32(&o.MCR6.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMCR6_MRTR(value uint32) {
	volatile.StoreUint32(&o.MCR6.Reg, volatile.LoadUint32(&o.MCR6.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetMCR6_MRTR() uint32 {
	return (volatile.LoadUint32(&o.MCR6.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetMCR6_MACR(value uint32) {
	volatile.StoreUint32(&o.MCR6.Reg, volatile.LoadUint32(&o.MCR6.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetMCR6_MACR() uint32 {
	return (volatile.LoadUint32(&o.MCR6.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetMCR6_MTCR(value uint32) {
	volatile.StoreUint32(&o.MCR6.Reg, volatile.LoadUint32(&o.MCR6.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetMCR6_MTCR() uint32 {
	return (volatile.LoadUint32(&o.MCR6.Reg) & 0x800000) >> 23
}

// CAN.MMR7: Mailbox Mode Register (MB = 7)
func (o *CAN_Type) SetMMR7_MTIMEMARK(value uint32) {
	volatile.StoreUint32(&o.MMR7.Reg, volatile.LoadUint32(&o.MMR7.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetMMR7_MTIMEMARK() uint32 {
	return volatile.LoadUint32(&o.MMR7.Reg) & 0xffff
}
func (o *CAN_Type) SetMMR7_PRIOR(value uint32) {
	volatile.StoreUint32(&o.MMR7.Reg, volatile.LoadUint32(&o.MMR7.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMMR7_PRIOR() uint32 {
	return (volatile.LoadUint32(&o.MMR7.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMMR7_MOT(value uint32) {
	volatile.StoreUint32(&o.MMR7.Reg, volatile.LoadUint32(&o.MMR7.Reg)&^(0x7000000)|value<<24)
}
func (o *CAN_Type) GetMMR7_MOT() uint32 {
	return (volatile.LoadUint32(&o.MMR7.Reg) & 0x7000000) >> 24
}

// CAN.MAM7: Mailbox Acceptance Mask Register (MB = 7)
func (o *CAN_Type) SetMAM7_MIDvB(value uint32) {
	volatile.StoreUint32(&o.MAM7.Reg, volatile.LoadUint32(&o.MAM7.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetMAM7_MIDvB() uint32 {
	return volatile.LoadUint32(&o.MAM7.Reg) & 0x3ffff
}
func (o *CAN_Type) SetMAM7_MIDvA(value uint32) {
	volatile.StoreUint32(&o.MAM7.Reg, volatile.LoadUint32(&o.MAM7.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetMAM7_MIDvA() uint32 {
	return (volatile.LoadUint32(&o.MAM7.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetMAM7_MIDE(value uint32) {
	volatile.StoreUint32(&o.MAM7.Reg, volatile.LoadUint32(&o.MAM7.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetMAM7_MIDE() uint32 {
	return (volatile.LoadUint32(&o.MAM7.Reg) & 0x20000000) >> 29
}

// CAN.MID7: Mailbox ID Register (MB = 7)
func (o *CAN_Type) SetMID7_MIDvB(value uint32) {
	volatile.StoreUint32(&o.MID7.Reg, volatile.LoadUint32(&o.MID7.Reg)&^(0x3ffff)|value)
}
func (o *CAN_Type) GetMID7_MIDvB() uint32 {
	return volatile.LoadUint32(&o.MID7.Reg) & 0x3ffff
}
func (o *CAN_Type) SetMID7_MIDvA(value uint32) {
	volatile.StoreUint32(&o.MID7.Reg, volatile.LoadUint32(&o.MID7.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN_Type) GetMID7_MIDvA() uint32 {
	return (volatile.LoadUint32(&o.MID7.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN_Type) SetMID7_MIDE(value uint32) {
	volatile.StoreUint32(&o.MID7.Reg, volatile.LoadUint32(&o.MID7.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetMID7_MIDE() uint32 {
	return (volatile.LoadUint32(&o.MID7.Reg) & 0x20000000) >> 29
}

// CAN.MFID7: Mailbox Family ID Register (MB = 7)
func (o *CAN_Type) SetMFID7_MFID(value uint32) {
	volatile.StoreUint32(&o.MFID7.Reg, volatile.LoadUint32(&o.MFID7.Reg)&^(0x1fffffff)|value)
}
func (o *CAN_Type) GetMFID7_MFID() uint32 {
	return volatile.LoadUint32(&o.MFID7.Reg) & 0x1fffffff
}

// CAN.MSR7: Mailbox Status Register (MB = 7)
func (o *CAN_Type) SetMSR7_MTIMESTAMP(value uint32) {
	volatile.StoreUint32(&o.MSR7.Reg, volatile.LoadUint32(&o.MSR7.Reg)&^(0xffff)|value)
}
func (o *CAN_Type) GetMSR7_MTIMESTAMP() uint32 {
	return volatile.LoadUint32(&o.MSR7.Reg) & 0xffff
}
func (o *CAN_Type) SetMSR7_MDLC(value uint32) {
	volatile.StoreUint32(&o.MSR7.Reg, volatile.LoadUint32(&o.MSR7.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMSR7_MDLC() uint32 {
	return (volatile.LoadUint32(&o.MSR7.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMSR7_MRTR(value uint32) {
	volatile.StoreUint32(&o.MSR7.Reg, volatile.LoadUint32(&o.MSR7.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetMSR7_MRTR() uint32 {
	return (volatile.LoadUint32(&o.MSR7.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetMSR7_MABT(value uint32) {
	volatile.StoreUint32(&o.MSR7.Reg, volatile.LoadUint32(&o.MSR7.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetMSR7_MABT() uint32 {
	return (volatile.LoadUint32(&o.MSR7.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetMSR7_MRDY(value uint32) {
	volatile.StoreUint32(&o.MSR7.Reg, volatile.LoadUint32(&o.MSR7.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetMSR7_MRDY() uint32 {
	return (volatile.LoadUint32(&o.MSR7.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetMSR7_MMI(value uint32) {
	volatile.StoreUint32(&o.MSR7.Reg, volatile.LoadUint32(&o.MSR7.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetMSR7_MMI() uint32 {
	return (volatile.LoadUint32(&o.MSR7.Reg) & 0x1000000) >> 24
}

// CAN.MDL7: Mailbox Data Low Register (MB = 7)
func (o *CAN_Type) SetMDL7(value uint32) {
	volatile.StoreUint32(&o.MDL7.Reg, value)
}
func (o *CAN_Type) GetMDL7() uint32 {
	return volatile.LoadUint32(&o.MDL7.Reg)
}

// CAN.MDH7: Mailbox Data High Register (MB = 7)
func (o *CAN_Type) SetMDH7(value uint32) {
	volatile.StoreUint32(&o.MDH7.Reg, value)
}
func (o *CAN_Type) GetMDH7() uint32 {
	return volatile.LoadUint32(&o.MDH7.Reg)
}

// CAN.MCR7: Mailbox Control Register (MB = 7)
func (o *CAN_Type) SetMCR7_MDLC(value uint32) {
	volatile.StoreUint32(&o.MCR7.Reg, volatile.LoadUint32(&o.MCR7.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetMCR7_MDLC() uint32 {
	return (volatile.LoadUint32(&o.MCR7.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetMCR7_MRTR(value uint32) {
	volatile.StoreUint32(&o.MCR7.Reg, volatile.LoadUint32(&o.MCR7.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetMCR7_MRTR() uint32 {
	return (volatile.LoadUint32(&o.MCR7.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetMCR7_MACR(value uint32) {
	volatile.StoreUint32(&o.MCR7.Reg, volatile.LoadUint32(&o.MCR7.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetMCR7_MACR() uint32 {
	return (volatile.LoadUint32(&o.MCR7.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetMCR7_MTCR(value uint32) {
	volatile.StoreUint32(&o.MCR7.Reg, volatile.LoadUint32(&o.MCR7.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetMCR7_MTCR() uint32 {
	return (volatile.LoadUint32(&o.MCR7.Reg) & 0x800000) >> 23
}

// Timer Counter 0
type TC_Type struct {
	CCR0  volatile.Register32 // 0x0
	CMR0  volatile.Register32 // 0x4
	SMMR0 volatile.Register32 // 0x8
	RAB0  volatile.Register32 // 0xC
	CV0   volatile.Register32 // 0x10
	RA0   volatile.Register32 // 0x14
	RB0   volatile.Register32 // 0x18
	RC0   volatile.Register32 // 0x1C
	SR0   volatile.Register32 // 0x20
	IER0  volatile.Register32 // 0x24
	IDR0  volatile.Register32 // 0x28
	IMR0  volatile.Register32 // 0x2C
	_     [16]byte
	CCR1  volatile.Register32 // 0x40
	CMR1  volatile.Register32 // 0x44
	SMMR1 volatile.Register32 // 0x48
	RAB1  volatile.Register32 // 0x4C
	CV1   volatile.Register32 // 0x50
	RA1   volatile.Register32 // 0x54
	RB1   volatile.Register32 // 0x58
	RC1   volatile.Register32 // 0x5C
	SR1   volatile.Register32 // 0x60
	IER1  volatile.Register32 // 0x64
	IDR1  volatile.Register32 // 0x68
	IMR1  volatile.Register32 // 0x6C
	_     [16]byte
	CCR2  volatile.Register32 // 0x80
	CMR2  volatile.Register32 // 0x84
	SMMR2 volatile.Register32 // 0x88
	RAB2  volatile.Register32 // 0x8C
	CV2   volatile.Register32 // 0x90
	RA2   volatile.Register32 // 0x94
	RB2   volatile.Register32 // 0x98
	RC2   volatile.Register32 // 0x9C
	SR2   volatile.Register32 // 0xA0
	IER2  volatile.Register32 // 0xA4
	IDR2  volatile.Register32 // 0xA8
	IMR2  volatile.Register32 // 0xAC
	_     [16]byte
	BCR   volatile.Register32 // 0xC0
	BMR   volatile.Register32 // 0xC4
	QIER  volatile.Register32 // 0xC8
	QIDR  volatile.Register32 // 0xCC
	QIMR  volatile.Register32 // 0xD0
	QISR  volatile.Register32 // 0xD4
	_     [12]byte
	WPMR  volatile.Register32 // 0xE4
}

// TC.CCR0: Channel Control Register (channel = 0)
func (o *TC_Type) SetCCR0_CLKEN(value uint32) {
	volatile.StoreUint32(&o.CCR0.Reg, volatile.LoadUint32(&o.CCR0.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetCCR0_CLKEN() uint32 {
	return volatile.LoadUint32(&o.CCR0.Reg) & 0x1
}
func (o *TC_Type) SetCCR0_CLKDIS(value uint32) {
	volatile.StoreUint32(&o.CCR0.Reg, volatile.LoadUint32(&o.CCR0.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetCCR0_CLKDIS() uint32 {
	return (volatile.LoadUint32(&o.CCR0.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetCCR0_SWTRG(value uint32) {
	volatile.StoreUint32(&o.CCR0.Reg, volatile.LoadUint32(&o.CCR0.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetCCR0_SWTRG() uint32 {
	return (volatile.LoadUint32(&o.CCR0.Reg) & 0x4) >> 2
}

// TC.CMR0: Channel Mode Register (channel = 0)
func (o *TC_Type) SetCMR0_TCCLKS(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x7)|value)
}
func (o *TC_Type) GetCMR0_TCCLKS() uint32 {
	return volatile.LoadUint32(&o.CMR0.Reg) & 0x7
}
func (o *TC_Type) SetCMR0_CLKI(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetCMR0_CLKI() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetCMR0_BURST(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x30)|value<<4)
}
func (o *TC_Type) GetCMR0_BURST() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x30) >> 4
}
func (o *TC_Type) SetCMR0_LDBSTOP(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetCMR0_LDBSTOP() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetCMR0_LDBDIS(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetCMR0_LDBDIS() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x80) >> 7
}
func (o *TC_Type) SetCMR0_ETRGEDG(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x300)|value<<8)
}
func (o *TC_Type) GetCMR0_ETRGEDG() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x300) >> 8
}
func (o *TC_Type) SetCMR0_ABETRG(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x400)|value<<10)
}
func (o *TC_Type) GetCMR0_ABETRG() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x400) >> 10
}
func (o *TC_Type) SetCMR0_CPCTRG(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x4000)|value<<14)
}
func (o *TC_Type) GetCMR0_CPCTRG() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x4000) >> 14
}
func (o *TC_Type) SetCMR0_WAVE(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x8000)|value<<15)
}
func (o *TC_Type) GetCMR0_WAVE() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x8000) >> 15
}
func (o *TC_Type) SetCMR0_LDRA(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x30000)|value<<16)
}
func (o *TC_Type) GetCMR0_LDRA() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x30000) >> 16
}
func (o *TC_Type) SetCMR0_LDRB(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0xc0000)|value<<18)
}
func (o *TC_Type) GetCMR0_LDRB() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0xc0000) >> 18
}

// TC.SMMR0: Stepper Motor Mode Register (channel = 0)
func (o *TC_Type) SetSMMR0_GCEN(value uint32) {
	volatile.StoreUint32(&o.SMMR0.Reg, volatile.LoadUint32(&o.SMMR0.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetSMMR0_GCEN() uint32 {
	return volatile.LoadUint32(&o.SMMR0.Reg) & 0x1
}
func (o *TC_Type) SetSMMR0_DOWN(value uint32) {
	volatile.StoreUint32(&o.SMMR0.Reg, volatile.LoadUint32(&o.SMMR0.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetSMMR0_DOWN() uint32 {
	return (volatile.LoadUint32(&o.SMMR0.Reg) & 0x2) >> 1
}

// TC.RAB0: Register AB (channel = 0)
func (o *TC_Type) SetRAB0(value uint32) {
	volatile.StoreUint32(&o.RAB0.Reg, value)
}
func (o *TC_Type) GetRAB0() uint32 {
	return volatile.LoadUint32(&o.RAB0.Reg)
}

// TC.CV0: Counter Value (channel = 0)
func (o *TC_Type) SetCV0(value uint32) {
	volatile.StoreUint32(&o.CV0.Reg, value)
}
func (o *TC_Type) GetCV0() uint32 {
	return volatile.LoadUint32(&o.CV0.Reg)
}

// TC.RA0: Register A (channel = 0)
func (o *TC_Type) SetRA0(value uint32) {
	volatile.StoreUint32(&o.RA0.Reg, value)
}
func (o *TC_Type) GetRA0() uint32 {
	return volatile.LoadUint32(&o.RA0.Reg)
}

// TC.RB0: Register B (channel = 0)
func (o *TC_Type) SetRB0(value uint32) {
	volatile.StoreUint32(&o.RB0.Reg, value)
}
func (o *TC_Type) GetRB0() uint32 {
	return volatile.LoadUint32(&o.RB0.Reg)
}

// TC.RC0: Register C (channel = 0)
func (o *TC_Type) SetRC0(value uint32) {
	volatile.StoreUint32(&o.RC0.Reg, value)
}
func (o *TC_Type) GetRC0() uint32 {
	return volatile.LoadUint32(&o.RC0.Reg)
}

// TC.SR0: Status Register (channel = 0)
func (o *TC_Type) SetSR0_COVFS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetSR0_COVFS() uint32 {
	return volatile.LoadUint32(&o.SR0.Reg) & 0x1
}
func (o *TC_Type) SetSR0_LOVRS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetSR0_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetSR0_CPAS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetSR0_CPAS() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetSR0_CPBS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetSR0_CPBS() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetSR0_CPCS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetSR0_CPCS() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetSR0_LDRAS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetSR0_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetSR0_LDRBS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetSR0_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetSR0_ETRGS(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetSR0_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x80) >> 7
}
func (o *TC_Type) SetSR0_CLKSTA(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x10000)|value<<16)
}
func (o *TC_Type) GetSR0_CLKSTA() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x10000) >> 16
}
func (o *TC_Type) SetSR0_MTIOA(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x20000)|value<<17)
}
func (o *TC_Type) GetSR0_MTIOA() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x20000) >> 17
}
func (o *TC_Type) SetSR0_MTIOB(value uint32) {
	volatile.StoreUint32(&o.SR0.Reg, volatile.LoadUint32(&o.SR0.Reg)&^(0x40000)|value<<18)
}
func (o *TC_Type) GetSR0_MTIOB() uint32 {
	return (volatile.LoadUint32(&o.SR0.Reg) & 0x40000) >> 18
}

// TC.IER0: Interrupt Enable Register (channel = 0)
func (o *TC_Type) SetIER0_COVFS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIER0_COVFS() uint32 {
	return volatile.LoadUint32(&o.IER0.Reg) & 0x1
}
func (o *TC_Type) SetIER0_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIER0_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIER0_CPAS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIER0_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIER0_CPBS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIER0_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIER0_CPCS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIER0_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIER0_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIER0_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIER0_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIER0_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIER0_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIER0_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x80) >> 7
}

// TC.IDR0: Interrupt Disable Register (channel = 0)
func (o *TC_Type) SetIDR0_COVFS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIDR0_COVFS() uint32 {
	return volatile.LoadUint32(&o.IDR0.Reg) & 0x1
}
func (o *TC_Type) SetIDR0_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIDR0_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IDR0.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIDR0_CPAS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIDR0_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IDR0.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIDR0_CPBS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIDR0_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IDR0.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIDR0_CPCS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIDR0_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IDR0.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIDR0_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIDR0_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IDR0.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIDR0_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIDR0_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IDR0.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIDR0_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IDR0.Reg, volatile.LoadUint32(&o.IDR0.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIDR0_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IDR0.Reg) & 0x80) >> 7
}

// TC.IMR0: Interrupt Mask Register (channel = 0)
func (o *TC_Type) SetIMR0_COVFS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIMR0_COVFS() uint32 {
	return volatile.LoadUint32(&o.IMR0.Reg) & 0x1
}
func (o *TC_Type) SetIMR0_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIMR0_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IMR0.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIMR0_CPAS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIMR0_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IMR0.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIMR0_CPBS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIMR0_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IMR0.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIMR0_CPCS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIMR0_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IMR0.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIMR0_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIMR0_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IMR0.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIMR0_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIMR0_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IMR0.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIMR0_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IMR0.Reg, volatile.LoadUint32(&o.IMR0.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIMR0_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IMR0.Reg) & 0x80) >> 7
}

// TC.CCR1: Channel Control Register (channel = 1)
func (o *TC_Type) SetCCR1_CLKEN(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetCCR1_CLKEN() uint32 {
	return volatile.LoadUint32(&o.CCR1.Reg) & 0x1
}
func (o *TC_Type) SetCCR1_CLKDIS(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetCCR1_CLKDIS() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetCCR1_SWTRG(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetCCR1_SWTRG() uint32 {
	return (volatile.LoadUint32(&o.CCR1.Reg) & 0x4) >> 2
}

// TC.CMR1: Channel Mode Register (channel = 1)
func (o *TC_Type) SetCMR1_TCCLKS(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x7)|value)
}
func (o *TC_Type) GetCMR1_TCCLKS() uint32 {
	return volatile.LoadUint32(&o.CMR1.Reg) & 0x7
}
func (o *TC_Type) SetCMR1_CLKI(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetCMR1_CLKI() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetCMR1_BURST(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x30)|value<<4)
}
func (o *TC_Type) GetCMR1_BURST() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x30) >> 4
}
func (o *TC_Type) SetCMR1_LDBSTOP(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetCMR1_LDBSTOP() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetCMR1_LDBDIS(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetCMR1_LDBDIS() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x80) >> 7
}
func (o *TC_Type) SetCMR1_ETRGEDG(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x300)|value<<8)
}
func (o *TC_Type) GetCMR1_ETRGEDG() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x300) >> 8
}
func (o *TC_Type) SetCMR1_ABETRG(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x400)|value<<10)
}
func (o *TC_Type) GetCMR1_ABETRG() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x400) >> 10
}
func (o *TC_Type) SetCMR1_CPCTRG(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x4000)|value<<14)
}
func (o *TC_Type) GetCMR1_CPCTRG() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x4000) >> 14
}
func (o *TC_Type) SetCMR1_WAVE(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x8000)|value<<15)
}
func (o *TC_Type) GetCMR1_WAVE() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x8000) >> 15
}
func (o *TC_Type) SetCMR1_LDRA(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x30000)|value<<16)
}
func (o *TC_Type) GetCMR1_LDRA() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x30000) >> 16
}
func (o *TC_Type) SetCMR1_LDRB(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0xc0000)|value<<18)
}
func (o *TC_Type) GetCMR1_LDRB() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0xc0000) >> 18
}

// TC.SMMR1: Stepper Motor Mode Register (channel = 1)
func (o *TC_Type) SetSMMR1_GCEN(value uint32) {
	volatile.StoreUint32(&o.SMMR1.Reg, volatile.LoadUint32(&o.SMMR1.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetSMMR1_GCEN() uint32 {
	return volatile.LoadUint32(&o.SMMR1.Reg) & 0x1
}
func (o *TC_Type) SetSMMR1_DOWN(value uint32) {
	volatile.StoreUint32(&o.SMMR1.Reg, volatile.LoadUint32(&o.SMMR1.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetSMMR1_DOWN() uint32 {
	return (volatile.LoadUint32(&o.SMMR1.Reg) & 0x2) >> 1
}

// TC.RAB1: Register AB (channel = 1)
func (o *TC_Type) SetRAB1(value uint32) {
	volatile.StoreUint32(&o.RAB1.Reg, value)
}
func (o *TC_Type) GetRAB1() uint32 {
	return volatile.LoadUint32(&o.RAB1.Reg)
}

// TC.CV1: Counter Value (channel = 1)
func (o *TC_Type) SetCV1(value uint32) {
	volatile.StoreUint32(&o.CV1.Reg, value)
}
func (o *TC_Type) GetCV1() uint32 {
	return volatile.LoadUint32(&o.CV1.Reg)
}

// TC.RA1: Register A (channel = 1)
func (o *TC_Type) SetRA1(value uint32) {
	volatile.StoreUint32(&o.RA1.Reg, value)
}
func (o *TC_Type) GetRA1() uint32 {
	return volatile.LoadUint32(&o.RA1.Reg)
}

// TC.RB1: Register B (channel = 1)
func (o *TC_Type) SetRB1(value uint32) {
	volatile.StoreUint32(&o.RB1.Reg, value)
}
func (o *TC_Type) GetRB1() uint32 {
	return volatile.LoadUint32(&o.RB1.Reg)
}

// TC.RC1: Register C (channel = 1)
func (o *TC_Type) SetRC1(value uint32) {
	volatile.StoreUint32(&o.RC1.Reg, value)
}
func (o *TC_Type) GetRC1() uint32 {
	return volatile.LoadUint32(&o.RC1.Reg)
}

// TC.SR1: Status Register (channel = 1)
func (o *TC_Type) SetSR1_COVFS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetSR1_COVFS() uint32 {
	return volatile.LoadUint32(&o.SR1.Reg) & 0x1
}
func (o *TC_Type) SetSR1_LOVRS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetSR1_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetSR1_CPAS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetSR1_CPAS() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetSR1_CPBS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetSR1_CPBS() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetSR1_CPCS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetSR1_CPCS() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetSR1_LDRAS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetSR1_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetSR1_LDRBS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetSR1_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetSR1_ETRGS(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetSR1_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x80) >> 7
}
func (o *TC_Type) SetSR1_CLKSTA(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x10000)|value<<16)
}
func (o *TC_Type) GetSR1_CLKSTA() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x10000) >> 16
}
func (o *TC_Type) SetSR1_MTIOA(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x20000)|value<<17)
}
func (o *TC_Type) GetSR1_MTIOA() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x20000) >> 17
}
func (o *TC_Type) SetSR1_MTIOB(value uint32) {
	volatile.StoreUint32(&o.SR1.Reg, volatile.LoadUint32(&o.SR1.Reg)&^(0x40000)|value<<18)
}
func (o *TC_Type) GetSR1_MTIOB() uint32 {
	return (volatile.LoadUint32(&o.SR1.Reg) & 0x40000) >> 18
}

// TC.IER1: Interrupt Enable Register (channel = 1)
func (o *TC_Type) SetIER1_COVFS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIER1_COVFS() uint32 {
	return volatile.LoadUint32(&o.IER1.Reg) & 0x1
}
func (o *TC_Type) SetIER1_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIER1_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIER1_CPAS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIER1_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIER1_CPBS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIER1_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIER1_CPCS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIER1_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIER1_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIER1_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIER1_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIER1_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIER1_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIER1_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x80) >> 7
}

// TC.IDR1: Interrupt Disable Register (channel = 1)
func (o *TC_Type) SetIDR1_COVFS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIDR1_COVFS() uint32 {
	return volatile.LoadUint32(&o.IDR1.Reg) & 0x1
}
func (o *TC_Type) SetIDR1_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIDR1_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIDR1_CPAS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIDR1_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIDR1_CPBS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIDR1_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIDR1_CPCS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIDR1_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIDR1_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIDR1_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIDR1_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIDR1_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIDR1_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIDR1_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x80) >> 7
}

// TC.IMR1: Interrupt Mask Register (channel = 1)
func (o *TC_Type) SetIMR1_COVFS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIMR1_COVFS() uint32 {
	return volatile.LoadUint32(&o.IMR1.Reg) & 0x1
}
func (o *TC_Type) SetIMR1_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIMR1_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIMR1_CPAS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIMR1_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIMR1_CPBS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIMR1_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIMR1_CPCS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIMR1_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIMR1_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIMR1_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIMR1_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIMR1_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIMR1_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIMR1_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x80) >> 7
}

// TC.CCR2: Channel Control Register (channel = 2)
func (o *TC_Type) SetCCR2_CLKEN(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetCCR2_CLKEN() uint32 {
	return volatile.LoadUint32(&o.CCR2.Reg) & 0x1
}
func (o *TC_Type) SetCCR2_CLKDIS(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetCCR2_CLKDIS() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetCCR2_SWTRG(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetCCR2_SWTRG() uint32 {
	return (volatile.LoadUint32(&o.CCR2.Reg) & 0x4) >> 2
}

// TC.CMR2: Channel Mode Register (channel = 2)
func (o *TC_Type) SetCMR2_TCCLKS(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x7)|value)
}
func (o *TC_Type) GetCMR2_TCCLKS() uint32 {
	return volatile.LoadUint32(&o.CMR2.Reg) & 0x7
}
func (o *TC_Type) SetCMR2_CLKI(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetCMR2_CLKI() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetCMR2_BURST(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x30)|value<<4)
}
func (o *TC_Type) GetCMR2_BURST() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x30) >> 4
}
func (o *TC_Type) SetCMR2_LDBSTOP(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetCMR2_LDBSTOP() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetCMR2_LDBDIS(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetCMR2_LDBDIS() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x80) >> 7
}
func (o *TC_Type) SetCMR2_ETRGEDG(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x300)|value<<8)
}
func (o *TC_Type) GetCMR2_ETRGEDG() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x300) >> 8
}
func (o *TC_Type) SetCMR2_ABETRG(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x400)|value<<10)
}
func (o *TC_Type) GetCMR2_ABETRG() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x400) >> 10
}
func (o *TC_Type) SetCMR2_CPCTRG(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x4000)|value<<14)
}
func (o *TC_Type) GetCMR2_CPCTRG() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x4000) >> 14
}
func (o *TC_Type) SetCMR2_WAVE(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x8000)|value<<15)
}
func (o *TC_Type) GetCMR2_WAVE() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x8000) >> 15
}
func (o *TC_Type) SetCMR2_LDRA(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x30000)|value<<16)
}
func (o *TC_Type) GetCMR2_LDRA() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x30000) >> 16
}
func (o *TC_Type) SetCMR2_LDRB(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0xc0000)|value<<18)
}
func (o *TC_Type) GetCMR2_LDRB() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0xc0000) >> 18
}

// TC.SMMR2: Stepper Motor Mode Register (channel = 2)
func (o *TC_Type) SetSMMR2_GCEN(value uint32) {
	volatile.StoreUint32(&o.SMMR2.Reg, volatile.LoadUint32(&o.SMMR2.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetSMMR2_GCEN() uint32 {
	return volatile.LoadUint32(&o.SMMR2.Reg) & 0x1
}
func (o *TC_Type) SetSMMR2_DOWN(value uint32) {
	volatile.StoreUint32(&o.SMMR2.Reg, volatile.LoadUint32(&o.SMMR2.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetSMMR2_DOWN() uint32 {
	return (volatile.LoadUint32(&o.SMMR2.Reg) & 0x2) >> 1
}

// TC.RAB2: Register AB (channel = 2)
func (o *TC_Type) SetRAB2(value uint32) {
	volatile.StoreUint32(&o.RAB2.Reg, value)
}
func (o *TC_Type) GetRAB2() uint32 {
	return volatile.LoadUint32(&o.RAB2.Reg)
}

// TC.CV2: Counter Value (channel = 2)
func (o *TC_Type) SetCV2(value uint32) {
	volatile.StoreUint32(&o.CV2.Reg, value)
}
func (o *TC_Type) GetCV2() uint32 {
	return volatile.LoadUint32(&o.CV2.Reg)
}

// TC.RA2: Register A (channel = 2)
func (o *TC_Type) SetRA2(value uint32) {
	volatile.StoreUint32(&o.RA2.Reg, value)
}
func (o *TC_Type) GetRA2() uint32 {
	return volatile.LoadUint32(&o.RA2.Reg)
}

// TC.RB2: Register B (channel = 2)
func (o *TC_Type) SetRB2(value uint32) {
	volatile.StoreUint32(&o.RB2.Reg, value)
}
func (o *TC_Type) GetRB2() uint32 {
	return volatile.LoadUint32(&o.RB2.Reg)
}

// TC.RC2: Register C (channel = 2)
func (o *TC_Type) SetRC2(value uint32) {
	volatile.StoreUint32(&o.RC2.Reg, value)
}
func (o *TC_Type) GetRC2() uint32 {
	return volatile.LoadUint32(&o.RC2.Reg)
}

// TC.SR2: Status Register (channel = 2)
func (o *TC_Type) SetSR2_COVFS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetSR2_COVFS() uint32 {
	return volatile.LoadUint32(&o.SR2.Reg) & 0x1
}
func (o *TC_Type) SetSR2_LOVRS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetSR2_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetSR2_CPAS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetSR2_CPAS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetSR2_CPBS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetSR2_CPBS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetSR2_CPCS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetSR2_CPCS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetSR2_LDRAS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetSR2_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetSR2_LDRBS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetSR2_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetSR2_ETRGS(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetSR2_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x80) >> 7
}
func (o *TC_Type) SetSR2_CLKSTA(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x10000)|value<<16)
}
func (o *TC_Type) GetSR2_CLKSTA() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x10000) >> 16
}
func (o *TC_Type) SetSR2_MTIOA(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x20000)|value<<17)
}
func (o *TC_Type) GetSR2_MTIOA() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x20000) >> 17
}
func (o *TC_Type) SetSR2_MTIOB(value uint32) {
	volatile.StoreUint32(&o.SR2.Reg, volatile.LoadUint32(&o.SR2.Reg)&^(0x40000)|value<<18)
}
func (o *TC_Type) GetSR2_MTIOB() uint32 {
	return (volatile.LoadUint32(&o.SR2.Reg) & 0x40000) >> 18
}

// TC.IER2: Interrupt Enable Register (channel = 2)
func (o *TC_Type) SetIER2_COVFS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIER2_COVFS() uint32 {
	return volatile.LoadUint32(&o.IER2.Reg) & 0x1
}
func (o *TC_Type) SetIER2_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIER2_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIER2_CPAS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIER2_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIER2_CPBS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIER2_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIER2_CPCS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIER2_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIER2_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIER2_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIER2_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIER2_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIER2_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIER2_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x80) >> 7
}

// TC.IDR2: Interrupt Disable Register (channel = 2)
func (o *TC_Type) SetIDR2_COVFS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIDR2_COVFS() uint32 {
	return volatile.LoadUint32(&o.IDR2.Reg) & 0x1
}
func (o *TC_Type) SetIDR2_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIDR2_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIDR2_CPAS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIDR2_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIDR2_CPBS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIDR2_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIDR2_CPCS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIDR2_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIDR2_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIDR2_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIDR2_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIDR2_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIDR2_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIDR2_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x80) >> 7
}

// TC.IMR2: Interrupt Mask Register (channel = 2)
func (o *TC_Type) SetIMR2_COVFS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetIMR2_COVFS() uint32 {
	return volatile.LoadUint32(&o.IMR2.Reg) & 0x1
}
func (o *TC_Type) SetIMR2_LOVRS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetIMR2_LOVRS() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetIMR2_CPAS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetIMR2_CPAS() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetIMR2_CPBS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x8)|value<<3)
}
func (o *TC_Type) GetIMR2_CPBS() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x8) >> 3
}
func (o *TC_Type) SetIMR2_CPCS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x10)|value<<4)
}
func (o *TC_Type) GetIMR2_CPCS() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x10) >> 4
}
func (o *TC_Type) SetIMR2_LDRAS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x20)|value<<5)
}
func (o *TC_Type) GetIMR2_LDRAS() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x20) >> 5
}
func (o *TC_Type) SetIMR2_LDRBS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x40)|value<<6)
}
func (o *TC_Type) GetIMR2_LDRBS() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x40) >> 6
}
func (o *TC_Type) SetIMR2_ETRGS(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x80)|value<<7)
}
func (o *TC_Type) GetIMR2_ETRGS() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x80) >> 7
}

// TC.BCR: Block Control Register
func (o *TC_Type) SetBCR_SYNC(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetBCR_SYNC() uint32 {
	return volatile.LoadUint32(&o.BCR.Reg) & 0x1
}

// TC.BMR: Block Mode Register
func (o *TC_Type) SetBMR_TC0XC0S(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x3)|value)
}
func (o *TC_Type) GetBMR_TC0XC0S() uint32 {
	return volatile.LoadUint32(&o.BMR.Reg) & 0x3
}
func (o *TC_Type) SetBMR_TC1XC1S(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0xc)|value<<2)
}
func (o *TC_Type) GetBMR_TC1XC1S() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0xc) >> 2
}
func (o *TC_Type) SetBMR_TC2XC2S(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x30)|value<<4)
}
func (o *TC_Type) GetBMR_TC2XC2S() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x30) >> 4
}
func (o *TC_Type) SetBMR_QDEN(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x100)|value<<8)
}
func (o *TC_Type) GetBMR_QDEN() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x100) >> 8
}
func (o *TC_Type) SetBMR_POSEN(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x200)|value<<9)
}
func (o *TC_Type) GetBMR_POSEN() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x200) >> 9
}
func (o *TC_Type) SetBMR_SPEEDEN(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x400)|value<<10)
}
func (o *TC_Type) GetBMR_SPEEDEN() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x400) >> 10
}
func (o *TC_Type) SetBMR_QDTRANS(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x800)|value<<11)
}
func (o *TC_Type) GetBMR_QDTRANS() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x800) >> 11
}
func (o *TC_Type) SetBMR_EDGPHA(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x1000)|value<<12)
}
func (o *TC_Type) GetBMR_EDGPHA() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x1000) >> 12
}
func (o *TC_Type) SetBMR_INVA(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x2000)|value<<13)
}
func (o *TC_Type) GetBMR_INVA() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x2000) >> 13
}
func (o *TC_Type) SetBMR_INVB(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x4000)|value<<14)
}
func (o *TC_Type) GetBMR_INVB() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x4000) >> 14
}
func (o *TC_Type) SetBMR_INVIDX(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x8000)|value<<15)
}
func (o *TC_Type) GetBMR_INVIDX() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x8000) >> 15
}
func (o *TC_Type) SetBMR_SWAP(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x10000)|value<<16)
}
func (o *TC_Type) GetBMR_SWAP() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x10000) >> 16
}
func (o *TC_Type) SetBMR_IDXPHB(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x20000)|value<<17)
}
func (o *TC_Type) GetBMR_IDXPHB() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x20000) >> 17
}
func (o *TC_Type) SetBMR_FILTER(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x80000)|value<<19)
}
func (o *TC_Type) GetBMR_FILTER() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x80000) >> 19
}
func (o *TC_Type) SetBMR_MAXFILT(value uint32) {
	volatile.StoreUint32(&o.BMR.Reg, volatile.LoadUint32(&o.BMR.Reg)&^(0x3f00000)|value<<20)
}
func (o *TC_Type) GetBMR_MAXFILT() uint32 {
	return (volatile.LoadUint32(&o.BMR.Reg) & 0x3f00000) >> 20
}

// TC.QIER: QDEC Interrupt Enable Register
func (o *TC_Type) SetQIER_IDX(value uint32) {
	volatile.StoreUint32(&o.QIER.Reg, volatile.LoadUint32(&o.QIER.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetQIER_IDX() uint32 {
	return volatile.LoadUint32(&o.QIER.Reg) & 0x1
}
func (o *TC_Type) SetQIER_DIRCHG(value uint32) {
	volatile.StoreUint32(&o.QIER.Reg, volatile.LoadUint32(&o.QIER.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetQIER_DIRCHG() uint32 {
	return (volatile.LoadUint32(&o.QIER.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetQIER_QERR(value uint32) {
	volatile.StoreUint32(&o.QIER.Reg, volatile.LoadUint32(&o.QIER.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetQIER_QERR() uint32 {
	return (volatile.LoadUint32(&o.QIER.Reg) & 0x4) >> 2
}

// TC.QIDR: QDEC Interrupt Disable Register
func (o *TC_Type) SetQIDR_IDX(value uint32) {
	volatile.StoreUint32(&o.QIDR.Reg, volatile.LoadUint32(&o.QIDR.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetQIDR_IDX() uint32 {
	return volatile.LoadUint32(&o.QIDR.Reg) & 0x1
}
func (o *TC_Type) SetQIDR_DIRCHG(value uint32) {
	volatile.StoreUint32(&o.QIDR.Reg, volatile.LoadUint32(&o.QIDR.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetQIDR_DIRCHG() uint32 {
	return (volatile.LoadUint32(&o.QIDR.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetQIDR_QERR(value uint32) {
	volatile.StoreUint32(&o.QIDR.Reg, volatile.LoadUint32(&o.QIDR.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetQIDR_QERR() uint32 {
	return (volatile.LoadUint32(&o.QIDR.Reg) & 0x4) >> 2
}

// TC.QIMR: QDEC Interrupt Mask Register
func (o *TC_Type) SetQIMR_IDX(value uint32) {
	volatile.StoreUint32(&o.QIMR.Reg, volatile.LoadUint32(&o.QIMR.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetQIMR_IDX() uint32 {
	return volatile.LoadUint32(&o.QIMR.Reg) & 0x1
}
func (o *TC_Type) SetQIMR_DIRCHG(value uint32) {
	volatile.StoreUint32(&o.QIMR.Reg, volatile.LoadUint32(&o.QIMR.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetQIMR_DIRCHG() uint32 {
	return (volatile.LoadUint32(&o.QIMR.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetQIMR_QERR(value uint32) {
	volatile.StoreUint32(&o.QIMR.Reg, volatile.LoadUint32(&o.QIMR.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetQIMR_QERR() uint32 {
	return (volatile.LoadUint32(&o.QIMR.Reg) & 0x4) >> 2
}

// TC.QISR: QDEC Interrupt Status Register
func (o *TC_Type) SetQISR_IDX(value uint32) {
	volatile.StoreUint32(&o.QISR.Reg, volatile.LoadUint32(&o.QISR.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetQISR_IDX() uint32 {
	return volatile.LoadUint32(&o.QISR.Reg) & 0x1
}
func (o *TC_Type) SetQISR_DIRCHG(value uint32) {
	volatile.StoreUint32(&o.QISR.Reg, volatile.LoadUint32(&o.QISR.Reg)&^(0x2)|value<<1)
}
func (o *TC_Type) GetQISR_DIRCHG() uint32 {
	return (volatile.LoadUint32(&o.QISR.Reg) & 0x2) >> 1
}
func (o *TC_Type) SetQISR_QERR(value uint32) {
	volatile.StoreUint32(&o.QISR.Reg, volatile.LoadUint32(&o.QISR.Reg)&^(0x4)|value<<2)
}
func (o *TC_Type) GetQISR_QERR() uint32 {
	return (volatile.LoadUint32(&o.QISR.Reg) & 0x4) >> 2
}
func (o *TC_Type) SetQISR_DIR(value uint32) {
	volatile.StoreUint32(&o.QISR.Reg, volatile.LoadUint32(&o.QISR.Reg)&^(0x100)|value<<8)
}
func (o *TC_Type) GetQISR_DIR() uint32 {
	return (volatile.LoadUint32(&o.QISR.Reg) & 0x100) >> 8
}

// TC.WPMR: Write Protect Mode Register
func (o *TC_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *TC_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *TC_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *TC_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// Two-wire Interface 0
type TWI_Type struct {
	CR           volatile.Register32 // 0x0
	MMR          volatile.Register32 // 0x4
	SMR          volatile.Register32 // 0x8
	IADR         volatile.Register32 // 0xC
	CWGR         volatile.Register32 // 0x10
	_            [12]byte
	SR           volatile.Register32 // 0x20
	IER          volatile.Register32 // 0x24
	IDR          volatile.Register32 // 0x28
	IMR          volatile.Register32 // 0x2C
	RHR          volatile.Register32 // 0x30
	THR          volatile.Register32 // 0x34
	_            [172]byte
	WPROT_MODE   volatile.Register32 // 0xE4
	WPROT_STATUS volatile.Register32 // 0xE8
}

// TWI.CR: Control Register
func (o *TWI_Type) SetCR_START(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetCR_START() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *TWI_Type) SetCR_STOP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetCR_STOP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *TWI_Type) SetCR_MSEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *TWI_Type) GetCR_MSEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *TWI_Type) SetCR_MSDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *TWI_Type) GetCR_MSDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *TWI_Type) SetCR_SVEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *TWI_Type) GetCR_SVEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *TWI_Type) SetCR_SVDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *TWI_Type) GetCR_SVDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *TWI_Type) SetCR_QUICK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *TWI_Type) GetCR_QUICK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *TWI_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *TWI_Type) GetCR_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}

// TWI.MMR: Master Mode Register
func (o *TWI_Type) SetMMR_IADRSZ(value uint32) {
	volatile.StoreUint32(&o.MMR.Reg, volatile.LoadUint32(&o.MMR.Reg)&^(0x300)|value<<8)
}
func (o *TWI_Type) GetMMR_IADRSZ() uint32 {
	return (volatile.LoadUint32(&o.MMR.Reg) & 0x300) >> 8
}
func (o *TWI_Type) SetMMR_MREAD(value uint32) {
	volatile.StoreUint32(&o.MMR.Reg, volatile.LoadUint32(&o.MMR.Reg)&^(0x1000)|value<<12)
}
func (o *TWI_Type) GetMMR_MREAD() uint32 {
	return (volatile.LoadUint32(&o.MMR.Reg) & 0x1000) >> 12
}
func (o *TWI_Type) SetMMR_DADR(value uint32) {
	volatile.StoreUint32(&o.MMR.Reg, volatile.LoadUint32(&o.MMR.Reg)&^(0x7f0000)|value<<16)
}
func (o *TWI_Type) GetMMR_DADR() uint32 {
	return (volatile.LoadUint32(&o.MMR.Reg) & 0x7f0000) >> 16
}

// TWI.SMR: Slave Mode Register
func (o *TWI_Type) SetSMR_SADR(value uint32) {
	volatile.StoreUint32(&o.SMR.Reg, volatile.LoadUint32(&o.SMR.Reg)&^(0x7f0000)|value<<16)
}
func (o *TWI_Type) GetSMR_SADR() uint32 {
	return (volatile.LoadUint32(&o.SMR.Reg) & 0x7f0000) >> 16
}

// TWI.IADR: Internal Address Register
func (o *TWI_Type) SetIADR(value uint32) {
	volatile.StoreUint32(&o.IADR.Reg, volatile.LoadUint32(&o.IADR.Reg)&^(0xffffff)|value)
}
func (o *TWI_Type) GetIADR() uint32 {
	return volatile.LoadUint32(&o.IADR.Reg) & 0xffffff
}

// TWI.CWGR: Clock Waveform Generator Register
func (o *TWI_Type) SetCWGR_CLDIV(value uint32) {
	volatile.StoreUint32(&o.CWGR.Reg, volatile.LoadUint32(&o.CWGR.Reg)&^(0xff)|value)
}
func (o *TWI_Type) GetCWGR_CLDIV() uint32 {
	return volatile.LoadUint32(&o.CWGR.Reg) & 0xff
}
func (o *TWI_Type) SetCWGR_CHDIV(value uint32) {
	volatile.StoreUint32(&o.CWGR.Reg, volatile.LoadUint32(&o.CWGR.Reg)&^(0xff00)|value<<8)
}
func (o *TWI_Type) GetCWGR_CHDIV() uint32 {
	return (volatile.LoadUint32(&o.CWGR.Reg) & 0xff00) >> 8
}
func (o *TWI_Type) SetCWGR_CKDIV(value uint32) {
	volatile.StoreUint32(&o.CWGR.Reg, volatile.LoadUint32(&o.CWGR.Reg)&^(0x70000)|value<<16)
}
func (o *TWI_Type) GetCWGR_CKDIV() uint32 {
	return (volatile.LoadUint32(&o.CWGR.Reg) & 0x70000) >> 16
}

// TWI.SR: Status Register
func (o *TWI_Type) SetSR_TXCOMP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetSR_TXCOMP() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *TWI_Type) SetSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetSR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *TWI_Type) SetSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *TWI_Type) GetSR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *TWI_Type) SetSR_SVREAD(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *TWI_Type) GetSR_SVREAD() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *TWI_Type) SetSR_SVACC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *TWI_Type) GetSR_SVACC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *TWI_Type) SetSR_GACC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *TWI_Type) GetSR_GACC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *TWI_Type) SetSR_OVRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *TWI_Type) GetSR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *TWI_Type) SetSR_NACK(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *TWI_Type) GetSR_NACK() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *TWI_Type) SetSR_ARBLST(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *TWI_Type) GetSR_ARBLST() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *TWI_Type) SetSR_SCLWS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *TWI_Type) GetSR_SCLWS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *TWI_Type) SetSR_EOSACC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800)|value<<11)
}
func (o *TWI_Type) GetSR_EOSACC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800) >> 11
}

// TWI.IER: Interrupt Enable Register
func (o *TWI_Type) SetIER_TXCOMP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetIER_TXCOMP() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *TWI_Type) SetIER_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetIER_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *TWI_Type) SetIER_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *TWI_Type) GetIER_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *TWI_Type) SetIER_SVACC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *TWI_Type) GetIER_SVACC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *TWI_Type) SetIER_GACC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *TWI_Type) GetIER_GACC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *TWI_Type) SetIER_OVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *TWI_Type) GetIER_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *TWI_Type) SetIER_NACK(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *TWI_Type) GetIER_NACK() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *TWI_Type) SetIER_ARBLST(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *TWI_Type) GetIER_ARBLST() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *TWI_Type) SetIER_SCL_WS(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *TWI_Type) GetIER_SCL_WS() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *TWI_Type) SetIER_EOSACC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *TWI_Type) GetIER_EOSACC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}

// TWI.IDR: Interrupt Disable Register
func (o *TWI_Type) SetIDR_TXCOMP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetIDR_TXCOMP() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *TWI_Type) SetIDR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetIDR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *TWI_Type) SetIDR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *TWI_Type) GetIDR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *TWI_Type) SetIDR_SVACC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *TWI_Type) GetIDR_SVACC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *TWI_Type) SetIDR_GACC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *TWI_Type) GetIDR_GACC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *TWI_Type) SetIDR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *TWI_Type) GetIDR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *TWI_Type) SetIDR_NACK(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *TWI_Type) GetIDR_NACK() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *TWI_Type) SetIDR_ARBLST(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *TWI_Type) GetIDR_ARBLST() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *TWI_Type) SetIDR_SCL_WS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *TWI_Type) GetIDR_SCL_WS() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *TWI_Type) SetIDR_EOSACC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *TWI_Type) GetIDR_EOSACC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}

// TWI.IMR: Interrupt Mask Register
func (o *TWI_Type) SetIMR_TXCOMP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetIMR_TXCOMP() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *TWI_Type) SetIMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *TWI_Type) GetIMR_RXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *TWI_Type) SetIMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *TWI_Type) GetIMR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *TWI_Type) SetIMR_SVACC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *TWI_Type) GetIMR_SVACC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *TWI_Type) SetIMR_GACC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *TWI_Type) GetIMR_GACC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *TWI_Type) SetIMR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *TWI_Type) GetIMR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *TWI_Type) SetIMR_NACK(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *TWI_Type) GetIMR_NACK() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *TWI_Type) SetIMR_ARBLST(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *TWI_Type) GetIMR_ARBLST() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *TWI_Type) SetIMR_SCL_WS(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *TWI_Type) GetIMR_SCL_WS() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *TWI_Type) SetIMR_EOSACC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *TWI_Type) GetIMR_EOSACC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}

// TWI.RHR: Receive Holding Register
func (o *TWI_Type) SetRHR_RXDATA(value uint32) {
	volatile.StoreUint32(&o.RHR.Reg, volatile.LoadUint32(&o.RHR.Reg)&^(0xff)|value)
}
func (o *TWI_Type) GetRHR_RXDATA() uint32 {
	return volatile.LoadUint32(&o.RHR.Reg) & 0xff
}

// TWI.THR: Transmit Holding Register
func (o *TWI_Type) SetTHR_TXDATA(value uint32) {
	volatile.StoreUint32(&o.THR.Reg, volatile.LoadUint32(&o.THR.Reg)&^(0xff)|value)
}
func (o *TWI_Type) GetTHR_TXDATA() uint32 {
	return volatile.LoadUint32(&o.THR.Reg) & 0xff
}

// TWI.WPROT_MODE: Protection Mode Register
func (o *TWI_Type) SetWPROT_MODE_WPROT(value uint32) {
	volatile.StoreUint32(&o.WPROT_MODE.Reg, volatile.LoadUint32(&o.WPROT_MODE.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetWPROT_MODE_WPROT() uint32 {
	return volatile.LoadUint32(&o.WPROT_MODE.Reg) & 0x1
}
func (o *TWI_Type) SetWPROT_MODE_SECURITY_CODE(value uint32) {
	volatile.StoreUint32(&o.WPROT_MODE.Reg, volatile.LoadUint32(&o.WPROT_MODE.Reg)&^(0xffffff00)|value<<8)
}
func (o *TWI_Type) GetWPROT_MODE_SECURITY_CODE() uint32 {
	return (volatile.LoadUint32(&o.WPROT_MODE.Reg) & 0xffffff00) >> 8
}

// TWI.WPROT_STATUS: Protection Status Register
func (o *TWI_Type) SetWPROT_STATUS_WPROTERR(value uint32) {
	volatile.StoreUint32(&o.WPROT_STATUS.Reg, volatile.LoadUint32(&o.WPROT_STATUS.Reg)&^(0x1)|value)
}
func (o *TWI_Type) GetWPROT_STATUS_WPROTERR() uint32 {
	return volatile.LoadUint32(&o.WPROT_STATUS.Reg) & 0x1
}
func (o *TWI_Type) SetWPROT_STATUS_WPROTADDR(value uint32) {
	volatile.StoreUint32(&o.WPROT_STATUS.Reg, volatile.LoadUint32(&o.WPROT_STATUS.Reg)&^(0xffffff00)|value<<8)
}
func (o *TWI_Type) GetWPROT_STATUS_WPROTADDR() uint32 {
	return (volatile.LoadUint32(&o.WPROT_STATUS.Reg) & 0xffffff00) >> 8
}

// Universal Synchronous Asynchronous Receiver Transmitter 0
type USART_Type struct {
	CR   volatile.Register32 // 0x0
	MR   volatile.Register32 // 0x4
	IER  volatile.Register32 // 0x8
	IDR  volatile.Register32 // 0xC
	IMR  volatile.Register32 // 0x10
	CSR  volatile.Register32 // 0x14
	RHR  volatile.Register32 // 0x18
	THR  volatile.Register32 // 0x1C
	BRGR volatile.Register32 // 0x20
	RTOR volatile.Register32 // 0x24
	TTGR volatile.Register32 // 0x28
	_    [20]byte
	FIDI volatile.Register32 // 0x40
	NER  volatile.Register32 // 0x44
	_    [4]byte
	IF   volatile.Register32 // 0x4C
	MAN  volatile.Register32 // 0x50
	_    [144]byte
	WPMR volatile.Register32 // 0xE4
	WPSR volatile.Register32 // 0xE8
}

// USART.CR: Control Register
func (o *USART_Type) SetCR_RSTRX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetCR_RSTRX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetCR_RSTTX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetCR_RSTTX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetCR_RXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetCR_RXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetCR_RXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetCR_RXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetCR_TXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCR_TXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCR_TXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetCR_TXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetCR_RSTSTA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCR_RSTSTA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCR_STTBRK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCR_STTBRK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCR_STPBRK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCR_STPBRK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCR_STTTO(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetCR_STTTO() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetCR_SENDA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetCR_SENDA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetCR_RSTIT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetCR_RSTIT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetCR_RSTNACK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetCR_RSTNACK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetCR_RETTO(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetCR_RETTO() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetCR_RTSEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetCR_RTSEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetCR_RTSDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetCR_RTSDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}

// USART.MR: Mode Register
func (o *USART_Type) SetMR_USART_MODE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf)|value)
}
func (o *USART_Type) GetMR_USART_MODE() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0xf
}
func (o *USART_Type) SetMR_USCLKS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x30)|value<<4)
}
func (o *USART_Type) GetMR_USCLKS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x30) >> 4
}
func (o *USART_Type) SetMR_CHRL(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xc0)|value<<6)
}
func (o *USART_Type) GetMR_CHRL() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xc0) >> 6
}
func (o *USART_Type) SetMR_SYNC(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetMR_SYNC() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetMR_PAR(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xe00)|value<<9)
}
func (o *USART_Type) GetMR_PAR() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xe00) >> 9
}
func (o *USART_Type) SetMR_NBSTOP(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x3000)|value<<12)
}
func (o *USART_Type) GetMR_NBSTOP() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x3000) >> 12
}
func (o *USART_Type) SetMR_CHMODE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xc000)|value<<14)
}
func (o *USART_Type) GetMR_CHMODE() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xc000) >> 14
}
func (o *USART_Type) SetMR_MSBF(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetMR_MSBF() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10000) >> 16
}
func (o *USART_Type) SetMR_MODE9(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetMR_MODE9() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetMR_CLKO(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetMR_CLKO() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetMR_OVER(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetMR_OVER() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetMR_INACK(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x100000)|value<<20)
}
func (o *USART_Type) GetMR_INACK() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x100000) >> 20
}
func (o *USART_Type) SetMR_DSNACK(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x200000)|value<<21)
}
func (o *USART_Type) GetMR_DSNACK() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x200000) >> 21
}
func (o *USART_Type) SetMR_VAR_SYNC(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x400000)|value<<22)
}
func (o *USART_Type) GetMR_VAR_SYNC() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x400000) >> 22
}
func (o *USART_Type) SetMR_INVDATA(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x800000)|value<<23)
}
func (o *USART_Type) GetMR_INVDATA() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x800000) >> 23
}
func (o *USART_Type) SetMR_MAX_ITERATION(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x7000000)|value<<24)
}
func (o *USART_Type) GetMR_MAX_ITERATION() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x7000000) >> 24
}
func (o *USART_Type) SetMR_FILTER(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x10000000)|value<<28)
}
func (o *USART_Type) GetMR_FILTER() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x10000000) >> 28
}
func (o *USART_Type) SetMR_MAN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x20000000)|value<<29)
}
func (o *USART_Type) GetMR_MAN() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x20000000) >> 29
}
func (o *USART_Type) SetMR_MODSYNC(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x40000000)|value<<30)
}
func (o *USART_Type) GetMR_MODSYNC() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x40000000) >> 30
}
func (o *USART_Type) SetMR_ONEBIT(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x80000000)|value<<31)
}
func (o *USART_Type) GetMR_ONEBIT() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x80000000) >> 31
}

// USART.IER: Interrupt Enable Register
func (o *USART_Type) SetIER_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetIER_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *USART_Type) SetIER_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetIER_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetIER_RXBRK(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetIER_RXBRK() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetIER_OVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetIER_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetIER_FRAME(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetIER_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetIER_PARE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetIER_PARE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetIER_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetIER_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetIER_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetIER_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetIER_ITER(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetIER_ITER() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetIER_NACK(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetIER_NACK() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetIER_CTSIC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetIER_CTSIC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetIER_MANE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *USART_Type) GetIER_MANE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}

// USART.IDR: Interrupt Disable Register
func (o *USART_Type) SetIDR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetIDR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *USART_Type) SetIDR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetIDR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetIDR_RXBRK(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetIDR_RXBRK() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetIDR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetIDR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetIDR_FRAME(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetIDR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetIDR_PARE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetIDR_PARE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetIDR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetIDR_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetIDR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetIDR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetIDR_ITER(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetIDR_ITER() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetIDR_NACK(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetIDR_NACK() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetIDR_CTSIC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetIDR_CTSIC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetIDR_MANE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *USART_Type) GetIDR_MANE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}

// USART.IMR: Interrupt Mask Register
func (o *USART_Type) SetIMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetIMR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *USART_Type) SetIMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetIMR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetIMR_RXBRK(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetIMR_RXBRK() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetIMR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetIMR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetIMR_FRAME(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetIMR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetIMR_PARE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetIMR_PARE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetIMR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetIMR_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetIMR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetIMR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetIMR_ITER(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetIMR_ITER() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetIMR_NACK(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetIMR_NACK() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetIMR_CTSIC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetIMR_CTSIC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetIMR_MANE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *USART_Type) GetIMR_MANE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}

// USART.CSR: Channel Status Register
func (o *USART_Type) SetCSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetCSR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}
func (o *USART_Type) SetCSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetCSR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetCSR_RXBRK(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetCSR_RXBRK() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetCSR_OVRE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetCSR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetCSR_FRAME(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCSR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCSR_PARE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetCSR_PARE() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetCSR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCSR_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCSR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCSR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCSR_ITER(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCSR_ITER() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCSR_NACK(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetCSR_NACK() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetCSR_CTSIC(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetCSR_CTSIC() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetCSR_CTS(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x800000)|value<<23)
}
func (o *USART_Type) GetCSR_CTS() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x800000) >> 23
}
func (o *USART_Type) SetCSR_MANERR(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1000000)|value<<24)
}
func (o *USART_Type) GetCSR_MANERR() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x1000000) >> 24
}

// USART.RHR: Receiver Holding Register
func (o *USART_Type) SetRHR_RXCHR(value uint32) {
	volatile.StoreUint32(&o.RHR.Reg, volatile.LoadUint32(&o.RHR.Reg)&^(0x1ff)|value)
}
func (o *USART_Type) GetRHR_RXCHR() uint32 {
	return volatile.LoadUint32(&o.RHR.Reg) & 0x1ff
}
func (o *USART_Type) SetRHR_RXSYNH(value uint32) {
	volatile.StoreUint32(&o.RHR.Reg, volatile.LoadUint32(&o.RHR.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetRHR_RXSYNH() uint32 {
	return (volatile.LoadUint32(&o.RHR.Reg) & 0x8000) >> 15
}

// USART.THR: Transmitter Holding Register
func (o *USART_Type) SetTHR_TXCHR(value uint32) {
	volatile.StoreUint32(&o.THR.Reg, volatile.LoadUint32(&o.THR.Reg)&^(0x1ff)|value)
}
func (o *USART_Type) GetTHR_TXCHR() uint32 {
	return volatile.LoadUint32(&o.THR.Reg) & 0x1ff
}
func (o *USART_Type) SetTHR_TXSYNH(value uint32) {
	volatile.StoreUint32(&o.THR.Reg, volatile.LoadUint32(&o.THR.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetTHR_TXSYNH() uint32 {
	return (volatile.LoadUint32(&o.THR.Reg) & 0x8000) >> 15
}

// USART.BRGR: Baud Rate Generator Register
func (o *USART_Type) SetBRGR_CD(value uint32) {
	volatile.StoreUint32(&o.BRGR.Reg, volatile.LoadUint32(&o.BRGR.Reg)&^(0xffff)|value)
}
func (o *USART_Type) GetBRGR_CD() uint32 {
	return volatile.LoadUint32(&o.BRGR.Reg) & 0xffff
}
func (o *USART_Type) SetBRGR_FP(value uint32) {
	volatile.StoreUint32(&o.BRGR.Reg, volatile.LoadUint32(&o.BRGR.Reg)&^(0x70000)|value<<16)
}
func (o *USART_Type) GetBRGR_FP() uint32 {
	return (volatile.LoadUint32(&o.BRGR.Reg) & 0x70000) >> 16
}

// USART.RTOR: Receiver Time-out Register
func (o *USART_Type) SetRTOR_TO(value uint32) {
	volatile.StoreUint32(&o.RTOR.Reg, volatile.LoadUint32(&o.RTOR.Reg)&^(0xffff)|value)
}
func (o *USART_Type) GetRTOR_TO() uint32 {
	return volatile.LoadUint32(&o.RTOR.Reg) & 0xffff
}

// USART.TTGR: Transmitter Timeguard Register
func (o *USART_Type) SetTTGR_TG(value uint32) {
	volatile.StoreUint32(&o.TTGR.Reg, volatile.LoadUint32(&o.TTGR.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetTTGR_TG() uint32 {
	return volatile.LoadUint32(&o.TTGR.Reg) & 0xff
}

// USART.FIDI: FI DI Ratio Register
func (o *USART_Type) SetFIDI_FI_DI_RATIO(value uint32) {
	volatile.StoreUint32(&o.FIDI.Reg, volatile.LoadUint32(&o.FIDI.Reg)&^(0x7ff)|value)
}
func (o *USART_Type) GetFIDI_FI_DI_RATIO() uint32 {
	return volatile.LoadUint32(&o.FIDI.Reg) & 0x7ff
}

// USART.NER: Number of Errors Register
func (o *USART_Type) SetNER_NB_ERRORS(value uint32) {
	volatile.StoreUint32(&o.NER.Reg, volatile.LoadUint32(&o.NER.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetNER_NB_ERRORS() uint32 {
	return volatile.LoadUint32(&o.NER.Reg) & 0xff
}

// USART.IF: IrDA Filter Register
func (o *USART_Type) SetIF_IRDA_FILTER(value uint32) {
	volatile.StoreUint32(&o.IF.Reg, volatile.LoadUint32(&o.IF.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetIF_IRDA_FILTER() uint32 {
	return volatile.LoadUint32(&o.IF.Reg) & 0xff
}

// USART.MAN: Manchester Encoder Decoder Register
func (o *USART_Type) SetMAN_TX_PL(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0xf)|value)
}
func (o *USART_Type) GetMAN_TX_PL() uint32 {
	return volatile.LoadUint32(&o.MAN.Reg) & 0xf
}
func (o *USART_Type) SetMAN_TX_PP(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x300)|value<<8)
}
func (o *USART_Type) GetMAN_TX_PP() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x300) >> 8
}
func (o *USART_Type) SetMAN_TX_MPOL(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetMAN_TX_MPOL() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetMAN_RX_PL(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0xf0000)|value<<16)
}
func (o *USART_Type) GetMAN_RX_PL() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0xf0000) >> 16
}
func (o *USART_Type) SetMAN_RX_PP(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x3000000)|value<<24)
}
func (o *USART_Type) GetMAN_RX_PP() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x3000000) >> 24
}
func (o *USART_Type) SetMAN_RX_MPOL(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x10000000)|value<<28)
}
func (o *USART_Type) GetMAN_RX_MPOL() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x10000000) >> 28
}
func (o *USART_Type) SetMAN_ONE(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x20000000)|value<<29)
}
func (o *USART_Type) GetMAN_ONE() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x20000000) >> 29
}
func (o *USART_Type) SetMAN_DRIFT(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x40000000)|value<<30)
}
func (o *USART_Type) GetMAN_DRIFT() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x40000000) >> 30
}

// USART.WPMR: Write Protect Mode Register
func (o *USART_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *USART_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *USART_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// USART.WPSR: Write Protect Status Register
func (o *USART_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *USART_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *USART_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// Universal Asynchronous Receiver Transmitter 0
type UART_Type struct {
	CR   volatile.Register32 // 0x0
	MR   volatile.Register32 // 0x4
	IER  volatile.Register32 // 0x8
	IDR  volatile.Register32 // 0xC
	IMR  volatile.Register32 // 0x10
	SR   volatile.Register32 // 0x14
	RHR  volatile.Register32 // 0x18
	THR  volatile.Register32 // 0x1C
	BRGR volatile.Register32 // 0x20
}

// UART.CR: Control Register
func (o *UART_Type) SetCR_RSTRX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetCR_RSTRX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetCR_RSTTX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetCR_RSTTX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetCR_RXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetCR_RXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetCR_RXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetCR_RXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetCR_TXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetCR_TXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetCR_TXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetCR_TXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetCR_RSTSTA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *UART_Type) GetCR_RSTSTA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}

// UART.MR: Mode Register
func (o *UART_Type) SetMR_PAR(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xe00)|value<<9)
}
func (o *UART_Type) GetMR_PAR() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xe00) >> 9
}
func (o *UART_Type) SetMR_CHMODE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xc000)|value<<14)
}
func (o *UART_Type) GetMR_CHMODE() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xc000) >> 14
}

// UART.IER: Interrupt Enable Register
func (o *UART_Type) SetIER_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetIER_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *UART_Type) SetIER_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetIER_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetIER_OVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetIER_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetIER_FRAME(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetIER_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetIER_PARE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetIER_PARE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetIER_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetIER_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}

// UART.IDR: Interrupt Disable Register
func (o *UART_Type) SetIDR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetIDR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *UART_Type) SetIDR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetIDR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetIDR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetIDR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetIDR_FRAME(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetIDR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetIDR_PARE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetIDR_PARE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetIDR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetIDR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}

// UART.IMR: Interrupt Mask Register
func (o *UART_Type) SetIMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetIMR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *UART_Type) SetIMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetIMR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetIMR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetIMR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetIMR_FRAME(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetIMR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetIMR_PARE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetIMR_PARE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetIMR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetIMR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}

// UART.SR: Status Register
func (o *UART_Type) SetSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetSR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *UART_Type) SetSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetSR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetSR_OVRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetSR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetSR_FRAME(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetSR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetSR_PARE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetSR_PARE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetSR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetSR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}

// UART.RHR: Receive Holding Register
func (o *UART_Type) SetRHR_RXCHR(value uint32) {
	volatile.StoreUint32(&o.RHR.Reg, volatile.LoadUint32(&o.RHR.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetRHR_RXCHR() uint32 {
	return volatile.LoadUint32(&o.RHR.Reg) & 0xff
}

// UART.THR: Transmit Holding Register
func (o *UART_Type) SetTHR_TXCHR(value uint32) {
	volatile.StoreUint32(&o.THR.Reg, volatile.LoadUint32(&o.THR.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetTHR_TXCHR() uint32 {
	return volatile.LoadUint32(&o.THR.Reg) & 0xff
}

// UART.BRGR: Baud Rate Generator Register
func (o *UART_Type) SetBRGR_CD(value uint32) {
	volatile.StoreUint32(&o.BRGR.Reg, volatile.LoadUint32(&o.BRGR.Reg)&^(0xffff)|value)
}
func (o *UART_Type) GetBRGR_CD() uint32 {
	return volatile.LoadUint32(&o.BRGR.Reg) & 0xffff
}

// Gigabit Ethernet MAC
type GMAC_Type struct {
	NCR       volatile.Register32 // 0x0
	NCFGR     volatile.Register32 // 0x4
	NSR       volatile.Register32 // 0x8
	UR        volatile.Register32 // 0xC
	DCFGR     volatile.Register32 // 0x10
	TSR       volatile.Register32 // 0x14
	RBQB      volatile.Register32 // 0x18
	TBQB      volatile.Register32 // 0x1C
	RSR       volatile.Register32 // 0x20
	ISR       volatile.Register32 // 0x24
	IER       volatile.Register32 // 0x28
	IDR       volatile.Register32 // 0x2C
	IMR       volatile.Register32 // 0x30
	MAN       volatile.Register32 // 0x34
	RPQ       volatile.Register32 // 0x38
	TPQ       volatile.Register32 // 0x3C
	TPSF      volatile.Register32 // 0x40
	RPSF      volatile.Register32 // 0x44
	_         [56]byte
	HRB       volatile.Register32    // 0x80
	HRT       volatile.Register32    // 0x84
	SAB1      volatile.Register32    // 0x88
	SAT1      volatile.Register32    // 0x8C
	SAB2      volatile.Register32    // 0x90
	SAT2      volatile.Register32    // 0x94
	SAB3      volatile.Register32    // 0x98
	SAT3      volatile.Register32    // 0x9C
	SAB4      volatile.Register32    // 0xA0
	SAT4      volatile.Register32    // 0xA4
	TIDM      [4]volatile.Register32 // 0xA8
	WOL       volatile.Register32    // 0xB8
	IPGS      volatile.Register32    // 0xBC
	SVLAN     volatile.Register32    // 0xC0
	TPFCP     volatile.Register32    // 0xC4
	SAMB1     volatile.Register32    // 0xC8
	SAMT1     volatile.Register32    // 0xCC
	_         [48]byte
	OTLO      volatile.Register32 // 0x100
	OTHI      volatile.Register32 // 0x104
	FT        volatile.Register32 // 0x108
	BCFT      volatile.Register32 // 0x10C
	MFT       volatile.Register32 // 0x110
	PFT       volatile.Register32 // 0x114
	BFT64     volatile.Register32 // 0x118
	TBFT127   volatile.Register32 // 0x11C
	TBFT255   volatile.Register32 // 0x120
	TBFT511   volatile.Register32 // 0x124
	TBFT1023  volatile.Register32 // 0x128
	TBFT1518  volatile.Register32 // 0x12C
	GTBFT1518 volatile.Register32 // 0x130
	TUR       volatile.Register32 // 0x134
	SCF       volatile.Register32 // 0x138
	MCF       volatile.Register32 // 0x13C
	EC        volatile.Register32 // 0x140
	LC        volatile.Register32 // 0x144
	DTF       volatile.Register32 // 0x148
	CSE       volatile.Register32 // 0x14C
	ORLO      volatile.Register32 // 0x150
	ORHI      volatile.Register32 // 0x154
	FR        volatile.Register32 // 0x158
	BCFR      volatile.Register32 // 0x15C
	MFR       volatile.Register32 // 0x160
	PFR       volatile.Register32 // 0x164
	BFR64     volatile.Register32 // 0x168
	TBFR127   volatile.Register32 // 0x16C
	TBFR255   volatile.Register32 // 0x170
	TBFR511   volatile.Register32 // 0x174
	TBFR1023  volatile.Register32 // 0x178
	TBFR1518  volatile.Register32 // 0x17C
	TMXBFR    volatile.Register32 // 0x180
	UFR       volatile.Register32 // 0x184
	OFR       volatile.Register32 // 0x188
	JR        volatile.Register32 // 0x18C
	FCSE      volatile.Register32 // 0x190
	LFFE      volatile.Register32 // 0x194
	RSE       volatile.Register32 // 0x198
	AE        volatile.Register32 // 0x19C
	RRE       volatile.Register32 // 0x1A0
	ROE       volatile.Register32 // 0x1A4
	IHCE      volatile.Register32 // 0x1A8
	TCE       volatile.Register32 // 0x1AC
	UCE       volatile.Register32 // 0x1B0
	_         [20]byte
	TSSS      volatile.Register32 // 0x1C8
	TSSN      volatile.Register32 // 0x1CC
	TS        volatile.Register32 // 0x1D0
	TN        volatile.Register32 // 0x1D4
	TA        volatile.Register32 // 0x1D8
	TI        volatile.Register32 // 0x1DC
	EFTS      volatile.Register32 // 0x1E0
	EFTN      volatile.Register32 // 0x1E4
	EFRS      volatile.Register32 // 0x1E8
	EFRN      volatile.Register32 // 0x1EC
	PEFTS     volatile.Register32 // 0x1F0
	PEFTN     volatile.Register32 // 0x1F4
	PEFRS     volatile.Register32 // 0x1F8
	PEFRN     volatile.Register32 // 0x1FC
	_         [512]byte
	ISRPQ     [7]volatile.Register32 // 0x400
	_         [36]byte
	TBQBAPQ   [7]volatile.Register32 // 0x440
	_         [36]byte
	RBQBAPQ   [7]volatile.Register32 // 0x480
	_         [4]byte
	RBSRPQ    [7]volatile.Register32 // 0x4A0
	_         [68]byte
	ST1RPQ    [16]volatile.Register32 // 0x500
	ST2RPQ    [16]volatile.Register32 // 0x540
	_         [128]byte
	IERPQ     [7]volatile.Register32 // 0x600
	_         [4]byte
	IDRPQ     [7]volatile.Register32 // 0x620
	_         [4]byte
	IMRPQ     [7]volatile.Register32 // 0x640
}

// GMAC.NCR: Network Control Register
func (o *GMAC_Type) SetNCR_LB(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetNCR_LB() uint32 {
	return volatile.LoadUint32(&o.NCR.Reg) & 0x1
}
func (o *GMAC_Type) SetNCR_LBL(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetNCR_LBL() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetNCR_RXEN(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetNCR_RXEN() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetNCR_TXEN(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetNCR_TXEN() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x8) >> 3
}
func (o *GMAC_Type) SetNCR_MPE(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x10)|value<<4)
}
func (o *GMAC_Type) GetNCR_MPE() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x10) >> 4
}
func (o *GMAC_Type) SetNCR_CLRSTAT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetNCR_CLRSTAT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetNCR_INCSTAT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetNCR_INCSTAT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetNCR_WESTAT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetNCR_WESTAT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetNCR_BP(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x100)|value<<8)
}
func (o *GMAC_Type) GetNCR_BP() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x100) >> 8
}
func (o *GMAC_Type) SetNCR_TSTART(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x200)|value<<9)
}
func (o *GMAC_Type) GetNCR_TSTART() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x200) >> 9
}
func (o *GMAC_Type) SetNCR_THALT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetNCR_THALT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetNCR_TXPF(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetNCR_TXPF() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x800) >> 11
}
func (o *GMAC_Type) SetNCR_TXZQPF(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x1000)|value<<12)
}
func (o *GMAC_Type) GetNCR_TXZQPF() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x1000) >> 12
}
func (o *GMAC_Type) SetNCR_RDS(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x4000)|value<<14)
}
func (o *GMAC_Type) GetNCR_RDS() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x4000) >> 14
}
func (o *GMAC_Type) SetNCR_SRTSM(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x8000)|value<<15)
}
func (o *GMAC_Type) GetNCR_SRTSM() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x8000) >> 15
}
func (o *GMAC_Type) SetNCR_ENPBPR(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x10000)|value<<16)
}
func (o *GMAC_Type) GetNCR_ENPBPR() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x10000) >> 16
}
func (o *GMAC_Type) SetNCR_TXPBPF(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x20000)|value<<17)
}
func (o *GMAC_Type) GetNCR_TXPBPF() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x20000) >> 17
}
func (o *GMAC_Type) SetNCR_FNP(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x40000)|value<<18)
}
func (o *GMAC_Type) GetNCR_FNP() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x40000) >> 18
}

// GMAC.NCFGR: Network Configuration Register
func (o *GMAC_Type) SetNCFGR_SPD(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetNCFGR_SPD() uint32 {
	return volatile.LoadUint32(&o.NCFGR.Reg) & 0x1
}
func (o *GMAC_Type) SetNCFGR_FD(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetNCFGR_FD() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetNCFGR_DNVLAN(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetNCFGR_DNVLAN() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetNCFGR_JFRAME(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetNCFGR_JFRAME() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x8) >> 3
}
func (o *GMAC_Type) SetNCFGR_CAF(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x10)|value<<4)
}
func (o *GMAC_Type) GetNCFGR_CAF() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x10) >> 4
}
func (o *GMAC_Type) SetNCFGR_NBC(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetNCFGR_NBC() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetNCFGR_MTIHEN(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetNCFGR_MTIHEN() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetNCFGR_UNIHEN(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetNCFGR_UNIHEN() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetNCFGR_MAXFS(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x100)|value<<8)
}
func (o *GMAC_Type) GetNCFGR_MAXFS() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x100) >> 8
}
func (o *GMAC_Type) SetNCFGR_GBE(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetNCFGR_GBE() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetNCFGR_PIS(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetNCFGR_PIS() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x800) >> 11
}
func (o *GMAC_Type) SetNCFGR_RTY(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x1000)|value<<12)
}
func (o *GMAC_Type) GetNCFGR_RTY() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x1000) >> 12
}
func (o *GMAC_Type) SetNCFGR_PEN(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x2000)|value<<13)
}
func (o *GMAC_Type) GetNCFGR_PEN() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x2000) >> 13
}
func (o *GMAC_Type) SetNCFGR_RXBUFO(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0xc000)|value<<14)
}
func (o *GMAC_Type) GetNCFGR_RXBUFO() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0xc000) >> 14
}
func (o *GMAC_Type) SetNCFGR_LFERD(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x10000)|value<<16)
}
func (o *GMAC_Type) GetNCFGR_LFERD() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x10000) >> 16
}
func (o *GMAC_Type) SetNCFGR_RFCS(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x20000)|value<<17)
}
func (o *GMAC_Type) GetNCFGR_RFCS() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x20000) >> 17
}
func (o *GMAC_Type) SetNCFGR_CLK(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x1c0000)|value<<18)
}
func (o *GMAC_Type) GetNCFGR_CLK() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x1c0000) >> 18
}
func (o *GMAC_Type) SetNCFGR_DBW(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x600000)|value<<21)
}
func (o *GMAC_Type) GetNCFGR_DBW() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x600000) >> 21
}
func (o *GMAC_Type) SetNCFGR_DCPF(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x800000)|value<<23)
}
func (o *GMAC_Type) GetNCFGR_DCPF() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x800000) >> 23
}
func (o *GMAC_Type) SetNCFGR_RXCOEN(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x1000000)|value<<24)
}
func (o *GMAC_Type) GetNCFGR_RXCOEN() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x1000000) >> 24
}
func (o *GMAC_Type) SetNCFGR_EFRHD(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x2000000)|value<<25)
}
func (o *GMAC_Type) GetNCFGR_EFRHD() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x2000000) >> 25
}
func (o *GMAC_Type) SetNCFGR_IRXFCS(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x4000000)|value<<26)
}
func (o *GMAC_Type) GetNCFGR_IRXFCS() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x4000000) >> 26
}
func (o *GMAC_Type) SetNCFGR_IPGSEN(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x10000000)|value<<28)
}
func (o *GMAC_Type) GetNCFGR_IPGSEN() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x10000000) >> 28
}
func (o *GMAC_Type) SetNCFGR_RXBP(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x20000000)|value<<29)
}
func (o *GMAC_Type) GetNCFGR_RXBP() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x20000000) >> 29
}
func (o *GMAC_Type) SetNCFGR_IRXER(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x40000000)|value<<30)
}
func (o *GMAC_Type) GetNCFGR_IRXER() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x40000000) >> 30
}

// GMAC.NSR: Network Status Register
func (o *GMAC_Type) SetNSR_MDIO(value uint32) {
	volatile.StoreUint32(&o.NSR.Reg, volatile.LoadUint32(&o.NSR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetNSR_MDIO() uint32 {
	return (volatile.LoadUint32(&o.NSR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetNSR_IDLE(value uint32) {
	volatile.StoreUint32(&o.NSR.Reg, volatile.LoadUint32(&o.NSR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetNSR_IDLE() uint32 {
	return (volatile.LoadUint32(&o.NSR.Reg) & 0x4) >> 2
}

// GMAC.UR: User Register
func (o *GMAC_Type) SetUR_RGMII(value uint32) {
	volatile.StoreUint32(&o.UR.Reg, volatile.LoadUint32(&o.UR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetUR_RGMII() uint32 {
	return volatile.LoadUint32(&o.UR.Reg) & 0x1
}
func (o *GMAC_Type) SetUR_HDFC(value uint32) {
	volatile.StoreUint32(&o.UR.Reg, volatile.LoadUint32(&o.UR.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetUR_HDFC() uint32 {
	return (volatile.LoadUint32(&o.UR.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetUR_BPDG(value uint32) {
	volatile.StoreUint32(&o.UR.Reg, volatile.LoadUint32(&o.UR.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetUR_BPDG() uint32 {
	return (volatile.LoadUint32(&o.UR.Reg) & 0x80) >> 7
}

// GMAC.DCFGR: DMA Configuration Register
func (o *GMAC_Type) SetDCFGR_FBLDO(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0x1f)|value)
}
func (o *GMAC_Type) GetDCFGR_FBLDO() uint32 {
	return volatile.LoadUint32(&o.DCFGR.Reg) & 0x1f
}
func (o *GMAC_Type) SetDCFGR_ESMA(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetDCFGR_ESMA() uint32 {
	return (volatile.LoadUint32(&o.DCFGR.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetDCFGR_ESPA(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetDCFGR_ESPA() uint32 {
	return (volatile.LoadUint32(&o.DCFGR.Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetDCFGR_RXBMS(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0x300)|value<<8)
}
func (o *GMAC_Type) GetDCFGR_RXBMS() uint32 {
	return (volatile.LoadUint32(&o.DCFGR.Reg) & 0x300) >> 8
}
func (o *GMAC_Type) SetDCFGR_TXPBMS(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetDCFGR_TXPBMS() uint32 {
	return (volatile.LoadUint32(&o.DCFGR.Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetDCFGR_TXCOEN(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetDCFGR_TXCOEN() uint32 {
	return (volatile.LoadUint32(&o.DCFGR.Reg) & 0x800) >> 11
}
func (o *GMAC_Type) SetDCFGR_DRBS(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0xff0000)|value<<16)
}
func (o *GMAC_Type) GetDCFGR_DRBS() uint32 {
	return (volatile.LoadUint32(&o.DCFGR.Reg) & 0xff0000) >> 16
}
func (o *GMAC_Type) SetDCFGR_DDRP(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0x1000000)|value<<24)
}
func (o *GMAC_Type) GetDCFGR_DDRP() uint32 {
	return (volatile.LoadUint32(&o.DCFGR.Reg) & 0x1000000) >> 24
}

// GMAC.TSR: Transmit Status Register
func (o *GMAC_Type) SetTSR_UBR(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetTSR_UBR() uint32 {
	return volatile.LoadUint32(&o.TSR.Reg) & 0x1
}
func (o *GMAC_Type) SetTSR_COL(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetTSR_COL() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetTSR_RLE(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetTSR_RLE() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetTSR_TXGO(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetTSR_TXGO() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x8) >> 3
}
func (o *GMAC_Type) SetTSR_TFC(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x10)|value<<4)
}
func (o *GMAC_Type) GetTSR_TFC() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x10) >> 4
}
func (o *GMAC_Type) SetTSR_TXCOMP(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetTSR_TXCOMP() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetTSR_UND(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetTSR_UND() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetTSR_LCO(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetTSR_LCO() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetTSR_HRESP(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x100)|value<<8)
}
func (o *GMAC_Type) GetTSR_HRESP() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x100) >> 8
}

// GMAC.RBQB: Receive Buffer Queue Base Address
func (o *GMAC_Type) SetRBQB_ADDR(value uint32) {
	volatile.StoreUint32(&o.RBQB.Reg, volatile.LoadUint32(&o.RBQB.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GMAC_Type) GetRBQB_ADDR() uint32 {
	return (volatile.LoadUint32(&o.RBQB.Reg) & 0xfffffffc) >> 2
}

// GMAC.TBQB: Transmit Buffer Queue Base Address
func (o *GMAC_Type) SetTBQB_ADDR(value uint32) {
	volatile.StoreUint32(&o.TBQB.Reg, volatile.LoadUint32(&o.TBQB.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GMAC_Type) GetTBQB_ADDR() uint32 {
	return (volatile.LoadUint32(&o.TBQB.Reg) & 0xfffffffc) >> 2
}

// GMAC.RSR: Receive Status Register
func (o *GMAC_Type) SetRSR_BNA(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetRSR_BNA() uint32 {
	return volatile.LoadUint32(&o.RSR.Reg) & 0x1
}
func (o *GMAC_Type) SetRSR_REC(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetRSR_REC() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetRSR_RXOVR(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetRSR_RXOVR() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetRSR_HNO(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetRSR_HNO() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x8) >> 3
}

// GMAC.ISR: Interrupt Status Register
func (o *GMAC_Type) SetISR_MFS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetISR_MFS() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *GMAC_Type) SetISR_RCOMP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetISR_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetISR_RXUBR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetISR_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetISR_TXUBR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetISR_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *GMAC_Type) SetISR_TUR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *GMAC_Type) GetISR_TUR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *GMAC_Type) SetISR_RLEX(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetISR_RLEX() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetISR_TFC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetISR_TFC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetISR_TCOMP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetISR_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetISR_ROVR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetISR_ROVR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetISR_HRESP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetISR_HRESP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *GMAC_Type) SetISR_PFNZ(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *GMAC_Type) GetISR_PFNZ() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *GMAC_Type) SetISR_PTZ(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *GMAC_Type) GetISR_PTZ() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *GMAC_Type) SetISR_PFTR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000)|value<<14)
}
func (o *GMAC_Type) GetISR_PFTR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000) >> 14
}
func (o *GMAC_Type) SetISR_EXINT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *GMAC_Type) GetISR_EXINT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *GMAC_Type) SetISR_DRQFR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000)|value<<18)
}
func (o *GMAC_Type) GetISR_DRQFR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000) >> 18
}
func (o *GMAC_Type) SetISR_SFR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000)|value<<19)
}
func (o *GMAC_Type) GetISR_SFR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000) >> 19
}
func (o *GMAC_Type) SetISR_DRQFT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100000)|value<<20)
}
func (o *GMAC_Type) GetISR_DRQFT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100000) >> 20
}
func (o *GMAC_Type) SetISR_SFT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200000)|value<<21)
}
func (o *GMAC_Type) GetISR_SFT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200000) >> 21
}
func (o *GMAC_Type) SetISR_PDRQFR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400000)|value<<22)
}
func (o *GMAC_Type) GetISR_PDRQFR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400000) >> 22
}
func (o *GMAC_Type) SetISR_PDRSFR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800000)|value<<23)
}
func (o *GMAC_Type) GetISR_PDRSFR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800000) >> 23
}
func (o *GMAC_Type) SetISR_PDRQFT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000000)|value<<24)
}
func (o *GMAC_Type) GetISR_PDRQFT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000000) >> 24
}
func (o *GMAC_Type) SetISR_PDRSFT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000000)|value<<25)
}
func (o *GMAC_Type) GetISR_PDRSFT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000000) >> 25
}
func (o *GMAC_Type) SetISR_SRI(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000000)|value<<26)
}
func (o *GMAC_Type) GetISR_SRI() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000000) >> 26
}
func (o *GMAC_Type) SetISR_WOL(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000000)|value<<28)
}
func (o *GMAC_Type) GetISR_WOL() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000000) >> 28
}

// GMAC.IER: Interrupt Enable Register
func (o *GMAC_Type) SetIER_MFS(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetIER_MFS() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *GMAC_Type) SetIER_RCOMP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetIER_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetIER_RXUBR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetIER_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetIER_TXUBR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetIER_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *GMAC_Type) SetIER_TUR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *GMAC_Type) GetIER_TUR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *GMAC_Type) SetIER_RLEX(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetIER_RLEX() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetIER_TFC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetIER_TFC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetIER_TCOMP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetIER_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetIER_ROVR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetIER_ROVR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetIER_HRESP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetIER_HRESP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *GMAC_Type) SetIER_PFNZ(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000)|value<<12)
}
func (o *GMAC_Type) GetIER_PFNZ() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000) >> 12
}
func (o *GMAC_Type) SetIER_PTZ(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000)|value<<13)
}
func (o *GMAC_Type) GetIER_PTZ() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000) >> 13
}
func (o *GMAC_Type) SetIER_PFTR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000)|value<<14)
}
func (o *GMAC_Type) GetIER_PFTR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000) >> 14
}
func (o *GMAC_Type) SetIER_EXINT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8000)|value<<15)
}
func (o *GMAC_Type) GetIER_EXINT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8000) >> 15
}
func (o *GMAC_Type) SetIER_DRQFR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000)|value<<18)
}
func (o *GMAC_Type) GetIER_DRQFR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000) >> 18
}
func (o *GMAC_Type) SetIER_SFR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000)|value<<19)
}
func (o *GMAC_Type) GetIER_SFR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000) >> 19
}
func (o *GMAC_Type) SetIER_DRQFT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100000)|value<<20)
}
func (o *GMAC_Type) GetIER_DRQFT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100000) >> 20
}
func (o *GMAC_Type) SetIER_SFT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200000)|value<<21)
}
func (o *GMAC_Type) GetIER_SFT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200000) >> 21
}
func (o *GMAC_Type) SetIER_PDRQFR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400000)|value<<22)
}
func (o *GMAC_Type) GetIER_PDRQFR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400000) >> 22
}
func (o *GMAC_Type) SetIER_PDRSFR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800000)|value<<23)
}
func (o *GMAC_Type) GetIER_PDRSFR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800000) >> 23
}
func (o *GMAC_Type) SetIER_PDRQFT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *GMAC_Type) GetIER_PDRQFT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}
func (o *GMAC_Type) SetIER_PDRSFT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000000)|value<<25)
}
func (o *GMAC_Type) GetIER_PDRSFT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000000) >> 25
}
func (o *GMAC_Type) SetIER_SRI(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000000)|value<<26)
}
func (o *GMAC_Type) GetIER_SRI() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000000) >> 26
}
func (o *GMAC_Type) SetIER_WOL(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000000)|value<<28)
}
func (o *GMAC_Type) GetIER_WOL() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000000) >> 28
}

// GMAC.IDR: Interrupt Disable Register
func (o *GMAC_Type) SetIDR_MFS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetIDR_MFS() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *GMAC_Type) SetIDR_RCOMP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetIDR_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetIDR_RXUBR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetIDR_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetIDR_TXUBR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetIDR_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *GMAC_Type) SetIDR_TUR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *GMAC_Type) GetIDR_TUR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *GMAC_Type) SetIDR_RLEX(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetIDR_RLEX() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetIDR_TFC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetIDR_TFC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetIDR_TCOMP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetIDR_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetIDR_ROVR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetIDR_ROVR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetIDR_HRESP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetIDR_HRESP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *GMAC_Type) SetIDR_PFNZ(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000)|value<<12)
}
func (o *GMAC_Type) GetIDR_PFNZ() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000) >> 12
}
func (o *GMAC_Type) SetIDR_PTZ(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *GMAC_Type) GetIDR_PTZ() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}
func (o *GMAC_Type) SetIDR_PFTR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000)|value<<14)
}
func (o *GMAC_Type) GetIDR_PFTR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000) >> 14
}
func (o *GMAC_Type) SetIDR_EXINT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000)|value<<15)
}
func (o *GMAC_Type) GetIDR_EXINT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000) >> 15
}
func (o *GMAC_Type) SetIDR_DRQFR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000)|value<<18)
}
func (o *GMAC_Type) GetIDR_DRQFR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000) >> 18
}
func (o *GMAC_Type) SetIDR_SFR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000)|value<<19)
}
func (o *GMAC_Type) GetIDR_SFR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000) >> 19
}
func (o *GMAC_Type) SetIDR_DRQFT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100000)|value<<20)
}
func (o *GMAC_Type) GetIDR_DRQFT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100000) >> 20
}
func (o *GMAC_Type) SetIDR_SFT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200000)|value<<21)
}
func (o *GMAC_Type) GetIDR_SFT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200000) >> 21
}
func (o *GMAC_Type) SetIDR_PDRQFR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400000)|value<<22)
}
func (o *GMAC_Type) GetIDR_PDRQFR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400000) >> 22
}
func (o *GMAC_Type) SetIDR_PDRSFR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800000)|value<<23)
}
func (o *GMAC_Type) GetIDR_PDRSFR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800000) >> 23
}
func (o *GMAC_Type) SetIDR_PDRQFT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *GMAC_Type) GetIDR_PDRQFT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}
func (o *GMAC_Type) SetIDR_PDRSFT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000000)|value<<25)
}
func (o *GMAC_Type) GetIDR_PDRSFT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000000) >> 25
}
func (o *GMAC_Type) SetIDR_SRI(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000000)|value<<26)
}
func (o *GMAC_Type) GetIDR_SRI() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000000) >> 26
}
func (o *GMAC_Type) SetIDR_WOL(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000000)|value<<28)
}
func (o *GMAC_Type) GetIDR_WOL() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000000) >> 28
}

// GMAC.IMR: Interrupt Mask Register
func (o *GMAC_Type) SetIMR_MFS(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetIMR_MFS() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *GMAC_Type) SetIMR_RCOMP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetIMR_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetIMR_RXUBR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetIMR_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetIMR_TXUBR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetIMR_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *GMAC_Type) SetIMR_TUR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *GMAC_Type) GetIMR_TUR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *GMAC_Type) SetIMR_RLEX(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetIMR_RLEX() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetIMR_TFC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetIMR_TFC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetIMR_TCOMP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetIMR_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetIMR_ROVR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetIMR_ROVR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetIMR_HRESP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetIMR_HRESP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}
func (o *GMAC_Type) SetIMR_PFNZ(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000)|value<<12)
}
func (o *GMAC_Type) GetIMR_PFNZ() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000) >> 12
}
func (o *GMAC_Type) SetIMR_PTZ(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000)|value<<13)
}
func (o *GMAC_Type) GetIMR_PTZ() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000) >> 13
}
func (o *GMAC_Type) SetIMR_PFTR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000)|value<<14)
}
func (o *GMAC_Type) GetIMR_PFTR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000) >> 14
}
func (o *GMAC_Type) SetIMR_EXINT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000)|value<<15)
}
func (o *GMAC_Type) GetIMR_EXINT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000) >> 15
}
func (o *GMAC_Type) SetIMR_DRQFR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000)|value<<18)
}
func (o *GMAC_Type) GetIMR_DRQFR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000) >> 18
}
func (o *GMAC_Type) SetIMR_SFR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000)|value<<19)
}
func (o *GMAC_Type) GetIMR_SFR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000) >> 19
}
func (o *GMAC_Type) SetIMR_DRQFT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100000)|value<<20)
}
func (o *GMAC_Type) GetIMR_DRQFT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100000) >> 20
}
func (o *GMAC_Type) SetIMR_SFT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200000)|value<<21)
}
func (o *GMAC_Type) GetIMR_SFT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200000) >> 21
}
func (o *GMAC_Type) SetIMR_PDRQFR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400000)|value<<22)
}
func (o *GMAC_Type) GetIMR_PDRQFR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400000) >> 22
}
func (o *GMAC_Type) SetIMR_PDRSFR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800000)|value<<23)
}
func (o *GMAC_Type) GetIMR_PDRSFR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800000) >> 23
}
func (o *GMAC_Type) SetIMR_PDRQFT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *GMAC_Type) GetIMR_PDRQFT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}
func (o *GMAC_Type) SetIMR_PDRSFT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000000)|value<<25)
}
func (o *GMAC_Type) GetIMR_PDRSFT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000000) >> 25
}

// GMAC.MAN: PHY Maintenance Register
func (o *GMAC_Type) SetMAN_DATA(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetMAN_DATA() uint32 {
	return volatile.LoadUint32(&o.MAN.Reg) & 0xffff
}
func (o *GMAC_Type) SetMAN_WTN(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x30000)|value<<16)
}
func (o *GMAC_Type) GetMAN_WTN() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x30000) >> 16
}
func (o *GMAC_Type) SetMAN_REGA(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x7c0000)|value<<18)
}
func (o *GMAC_Type) GetMAN_REGA() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x7c0000) >> 18
}
func (o *GMAC_Type) SetMAN_PHYA(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0xf800000)|value<<23)
}
func (o *GMAC_Type) GetMAN_PHYA() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0xf800000) >> 23
}
func (o *GMAC_Type) SetMAN_OP(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x30000000)|value<<28)
}
func (o *GMAC_Type) GetMAN_OP() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x30000000) >> 28
}
func (o *GMAC_Type) SetMAN_CLTTO(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x40000000)|value<<30)
}
func (o *GMAC_Type) GetMAN_CLTTO() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x40000000) >> 30
}
func (o *GMAC_Type) SetMAN_WZO(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x80000000)|value<<31)
}
func (o *GMAC_Type) GetMAN_WZO() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x80000000) >> 31
}

// GMAC.RPQ: Received Pause Quantum Register
func (o *GMAC_Type) SetRPQ(value uint32) {
	volatile.StoreUint32(&o.RPQ.Reg, volatile.LoadUint32(&o.RPQ.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetRPQ() uint32 {
	return volatile.LoadUint32(&o.RPQ.Reg) & 0xffff
}

// GMAC.TPQ: Transmit Pause Quantum Register
func (o *GMAC_Type) SetTPQ(value uint32) {
	volatile.StoreUint32(&o.TPQ.Reg, volatile.LoadUint32(&o.TPQ.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetTPQ() uint32 {
	return volatile.LoadUint32(&o.TPQ.Reg) & 0xffff
}

// GMAC.TPSF: TX Partial Store and Forward Register
func (o *GMAC_Type) SetTPSF_TPB1ADR(value uint32) {
	volatile.StoreUint32(&o.TPSF.Reg, volatile.LoadUint32(&o.TPSF.Reg)&^(0xfff)|value)
}
func (o *GMAC_Type) GetTPSF_TPB1ADR() uint32 {
	return volatile.LoadUint32(&o.TPSF.Reg) & 0xfff
}
func (o *GMAC_Type) SetTPSF_ENTXP(value uint32) {
	volatile.StoreUint32(&o.TPSF.Reg, volatile.LoadUint32(&o.TPSF.Reg)&^(0x80000000)|value<<31)
}
func (o *GMAC_Type) GetTPSF_ENTXP() uint32 {
	return (volatile.LoadUint32(&o.TPSF.Reg) & 0x80000000) >> 31
}

// GMAC.RPSF: RX Partial Store and Forward Register
func (o *GMAC_Type) SetRPSF_RPB1ADR(value uint32) {
	volatile.StoreUint32(&o.RPSF.Reg, volatile.LoadUint32(&o.RPSF.Reg)&^(0xfff)|value)
}
func (o *GMAC_Type) GetRPSF_RPB1ADR() uint32 {
	return volatile.LoadUint32(&o.RPSF.Reg) & 0xfff
}
func (o *GMAC_Type) SetRPSF_ENRXP(value uint32) {
	volatile.StoreUint32(&o.RPSF.Reg, volatile.LoadUint32(&o.RPSF.Reg)&^(0x80000000)|value<<31)
}
func (o *GMAC_Type) GetRPSF_ENRXP() uint32 {
	return (volatile.LoadUint32(&o.RPSF.Reg) & 0x80000000) >> 31
}

// GMAC.HRB: Hash Register Bottom [31:0]
func (o *GMAC_Type) SetHRB(value uint32) {
	volatile.StoreUint32(&o.HRB.Reg, value)
}
func (o *GMAC_Type) GetHRB() uint32 {
	return volatile.LoadUint32(&o.HRB.Reg)
}

// GMAC.HRT: Hash Register Top [63:32]
func (o *GMAC_Type) SetHRT(value uint32) {
	volatile.StoreUint32(&o.HRT.Reg, value)
}
func (o *GMAC_Type) GetHRT() uint32 {
	return volatile.LoadUint32(&o.HRT.Reg)
}

// GMAC.SAB1: Specific Address 1 Bottom [31:0] Register
func (o *GMAC_Type) SetSAB1(value uint32) {
	volatile.StoreUint32(&o.SAB1.Reg, value)
}
func (o *GMAC_Type) GetSAB1() uint32 {
	return volatile.LoadUint32(&o.SAB1.Reg)
}

// GMAC.SAT1: Specific Address 1 Top [47:32] Register
func (o *GMAC_Type) SetSAT1_ADDR(value uint32) {
	volatile.StoreUint32(&o.SAT1.Reg, volatile.LoadUint32(&o.SAT1.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetSAT1_ADDR() uint32 {
	return volatile.LoadUint32(&o.SAT1.Reg) & 0xffff
}

// GMAC.SAB2: Specific Address 2 Bottom [31:0] Register
func (o *GMAC_Type) SetSAB2(value uint32) {
	volatile.StoreUint32(&o.SAB2.Reg, value)
}
func (o *GMAC_Type) GetSAB2() uint32 {
	return volatile.LoadUint32(&o.SAB2.Reg)
}

// GMAC.SAT2: Specific Address 2 Top [47:32] Register
func (o *GMAC_Type) SetSAT2_ADDR(value uint32) {
	volatile.StoreUint32(&o.SAT2.Reg, volatile.LoadUint32(&o.SAT2.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetSAT2_ADDR() uint32 {
	return volatile.LoadUint32(&o.SAT2.Reg) & 0xffff
}

// GMAC.SAB3: Specific Address 3 Bottom [31:0] Register
func (o *GMAC_Type) SetSAB3(value uint32) {
	volatile.StoreUint32(&o.SAB3.Reg, value)
}
func (o *GMAC_Type) GetSAB3() uint32 {
	return volatile.LoadUint32(&o.SAB3.Reg)
}

// GMAC.SAT3: Specific Address 3 Top [47:32] Register
func (o *GMAC_Type) SetSAT3_ADDR(value uint32) {
	volatile.StoreUint32(&o.SAT3.Reg, volatile.LoadUint32(&o.SAT3.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetSAT3_ADDR() uint32 {
	return volatile.LoadUint32(&o.SAT3.Reg) & 0xffff
}

// GMAC.SAB4: Specific Address 4 Bottom [31:0] Register
func (o *GMAC_Type) SetSAB4(value uint32) {
	volatile.StoreUint32(&o.SAB4.Reg, value)
}
func (o *GMAC_Type) GetSAB4() uint32 {
	return volatile.LoadUint32(&o.SAB4.Reg)
}

// GMAC.SAT4: Specific Address 4 Top [47:32] Register
func (o *GMAC_Type) SetSAT4_ADDR(value uint32) {
	volatile.StoreUint32(&o.SAT4.Reg, volatile.LoadUint32(&o.SAT4.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetSAT4_ADDR() uint32 {
	return volatile.LoadUint32(&o.SAT4.Reg) & 0xffff
}

// GMAC.TIDM: Type ID Match 1 Register
func (o *GMAC_Type) SetTIDM_TID(idx int, value uint32) {
	volatile.StoreUint32(&o.TIDM[idx].Reg, volatile.LoadUint32(&o.TIDM[idx].Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetTIDM_TID(idx int) uint32 {
	return volatile.LoadUint32(&o.TIDM[idx].Reg) & 0xffff
}

// GMAC.WOL: Wake on LAN Register
func (o *GMAC_Type) SetWOL_IP(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetWOL_IP() uint32 {
	return volatile.LoadUint32(&o.WOL.Reg) & 0xffff
}
func (o *GMAC_Type) SetWOL_MAG(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0x10000)|value<<16)
}
func (o *GMAC_Type) GetWOL_MAG() uint32 {
	return (volatile.LoadUint32(&o.WOL.Reg) & 0x10000) >> 16
}
func (o *GMAC_Type) SetWOL_ARP(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0x20000)|value<<17)
}
func (o *GMAC_Type) GetWOL_ARP() uint32 {
	return (volatile.LoadUint32(&o.WOL.Reg) & 0x20000) >> 17
}
func (o *GMAC_Type) SetWOL_SA1(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0x40000)|value<<18)
}
func (o *GMAC_Type) GetWOL_SA1() uint32 {
	return (volatile.LoadUint32(&o.WOL.Reg) & 0x40000) >> 18
}
func (o *GMAC_Type) SetWOL_MTI(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0x80000)|value<<19)
}
func (o *GMAC_Type) GetWOL_MTI() uint32 {
	return (volatile.LoadUint32(&o.WOL.Reg) & 0x80000) >> 19
}

// GMAC.IPGS: IPG Stretch Register
func (o *GMAC_Type) SetIPGS_FL(value uint32) {
	volatile.StoreUint32(&o.IPGS.Reg, volatile.LoadUint32(&o.IPGS.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetIPGS_FL() uint32 {
	return volatile.LoadUint32(&o.IPGS.Reg) & 0xffff
}

// GMAC.SVLAN: Stacked VLAN Register
func (o *GMAC_Type) SetSVLAN_VLAN_TYPE(value uint32) {
	volatile.StoreUint32(&o.SVLAN.Reg, volatile.LoadUint32(&o.SVLAN.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetSVLAN_VLAN_TYPE() uint32 {
	return volatile.LoadUint32(&o.SVLAN.Reg) & 0xffff
}
func (o *GMAC_Type) SetSVLAN_ESVLAN(value uint32) {
	volatile.StoreUint32(&o.SVLAN.Reg, volatile.LoadUint32(&o.SVLAN.Reg)&^(0x80000000)|value<<31)
}
func (o *GMAC_Type) GetSVLAN_ESVLAN() uint32 {
	return (volatile.LoadUint32(&o.SVLAN.Reg) & 0x80000000) >> 31
}

// GMAC.TPFCP: Transmit PFC Pause Register
func (o *GMAC_Type) SetTPFCP_PEV(value uint32) {
	volatile.StoreUint32(&o.TPFCP.Reg, volatile.LoadUint32(&o.TPFCP.Reg)&^(0xff)|value)
}
func (o *GMAC_Type) GetTPFCP_PEV() uint32 {
	return volatile.LoadUint32(&o.TPFCP.Reg) & 0xff
}
func (o *GMAC_Type) SetTPFCP_PQ(value uint32) {
	volatile.StoreUint32(&o.TPFCP.Reg, volatile.LoadUint32(&o.TPFCP.Reg)&^(0xff00)|value<<8)
}
func (o *GMAC_Type) GetTPFCP_PQ() uint32 {
	return (volatile.LoadUint32(&o.TPFCP.Reg) & 0xff00) >> 8
}

// GMAC.SAMB1: Specific Address 1 Mask Bottom [31:0] Register
func (o *GMAC_Type) SetSAMB1(value uint32) {
	volatile.StoreUint32(&o.SAMB1.Reg, value)
}
func (o *GMAC_Type) GetSAMB1() uint32 {
	return volatile.LoadUint32(&o.SAMB1.Reg)
}

// GMAC.SAMT1: Specific Address 1 Mask Top [47:32] Register
func (o *GMAC_Type) SetSAMT1_ADDR(value uint32) {
	volatile.StoreUint32(&o.SAMT1.Reg, volatile.LoadUint32(&o.SAMT1.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetSAMT1_ADDR() uint32 {
	return volatile.LoadUint32(&o.SAMT1.Reg) & 0xffff
}

// GMAC.OTLO: Octets Transmitted [31:0] Register
func (o *GMAC_Type) SetOTLO(value uint32) {
	volatile.StoreUint32(&o.OTLO.Reg, value)
}
func (o *GMAC_Type) GetOTLO() uint32 {
	return volatile.LoadUint32(&o.OTLO.Reg)
}

// GMAC.OTHI: Octets Transmitted [47:32] Register
func (o *GMAC_Type) SetOTHI_TXO(value uint32) {
	volatile.StoreUint32(&o.OTHI.Reg, volatile.LoadUint32(&o.OTHI.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetOTHI_TXO() uint32 {
	return volatile.LoadUint32(&o.OTHI.Reg) & 0xffff
}

// GMAC.FT: Frames Transmitted Register
func (o *GMAC_Type) SetFT(value uint32) {
	volatile.StoreUint32(&o.FT.Reg, value)
}
func (o *GMAC_Type) GetFT() uint32 {
	return volatile.LoadUint32(&o.FT.Reg)
}

// GMAC.BCFT: Broadcast Frames Transmitted Register
func (o *GMAC_Type) SetBCFT(value uint32) {
	volatile.StoreUint32(&o.BCFT.Reg, value)
}
func (o *GMAC_Type) GetBCFT() uint32 {
	return volatile.LoadUint32(&o.BCFT.Reg)
}

// GMAC.MFT: Multicast Frames Transmitted Register
func (o *GMAC_Type) SetMFT(value uint32) {
	volatile.StoreUint32(&o.MFT.Reg, value)
}
func (o *GMAC_Type) GetMFT() uint32 {
	return volatile.LoadUint32(&o.MFT.Reg)
}

// GMAC.PFT: Pause Frames Transmitted Register
func (o *GMAC_Type) SetPFT_PFTX(value uint32) {
	volatile.StoreUint32(&o.PFT.Reg, volatile.LoadUint32(&o.PFT.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetPFT_PFTX() uint32 {
	return volatile.LoadUint32(&o.PFT.Reg) & 0xffff
}

// GMAC.BFT64: 64 Byte Frames Transmitted Register
func (o *GMAC_Type) SetBFT64(value uint32) {
	volatile.StoreUint32(&o.BFT64.Reg, value)
}
func (o *GMAC_Type) GetBFT64() uint32 {
	return volatile.LoadUint32(&o.BFT64.Reg)
}

// GMAC.TBFT127: 65 to 127 Byte Frames Transmitted Register
func (o *GMAC_Type) SetTBFT127(value uint32) {
	volatile.StoreUint32(&o.TBFT127.Reg, value)
}
func (o *GMAC_Type) GetTBFT127() uint32 {
	return volatile.LoadUint32(&o.TBFT127.Reg)
}

// GMAC.TBFT255: 128 to 255 Byte Frames Transmitted Register
func (o *GMAC_Type) SetTBFT255(value uint32) {
	volatile.StoreUint32(&o.TBFT255.Reg, value)
}
func (o *GMAC_Type) GetTBFT255() uint32 {
	return volatile.LoadUint32(&o.TBFT255.Reg)
}

// GMAC.TBFT511: 256 to 511 Byte Frames Transmitted Register
func (o *GMAC_Type) SetTBFT511(value uint32) {
	volatile.StoreUint32(&o.TBFT511.Reg, value)
}
func (o *GMAC_Type) GetTBFT511() uint32 {
	return volatile.LoadUint32(&o.TBFT511.Reg)
}

// GMAC.TBFT1023: 512 to 1023 Byte Frames Transmitted Register
func (o *GMAC_Type) SetTBFT1023(value uint32) {
	volatile.StoreUint32(&o.TBFT1023.Reg, value)
}
func (o *GMAC_Type) GetTBFT1023() uint32 {
	return volatile.LoadUint32(&o.TBFT1023.Reg)
}

// GMAC.TBFT1518: 1024 to 1518 Byte Frames Transmitted Register
func (o *GMAC_Type) SetTBFT1518(value uint32) {
	volatile.StoreUint32(&o.TBFT1518.Reg, value)
}
func (o *GMAC_Type) GetTBFT1518() uint32 {
	return volatile.LoadUint32(&o.TBFT1518.Reg)
}

// GMAC.GTBFT1518: Greater Than 1518 Byte Frames Transmitted Register
func (o *GMAC_Type) SetGTBFT1518(value uint32) {
	volatile.StoreUint32(&o.GTBFT1518.Reg, value)
}
func (o *GMAC_Type) GetGTBFT1518() uint32 {
	return volatile.LoadUint32(&o.GTBFT1518.Reg)
}

// GMAC.TUR: Transmit Under Runs Register
func (o *GMAC_Type) SetTUR_TXUNR(value uint32) {
	volatile.StoreUint32(&o.TUR.Reg, volatile.LoadUint32(&o.TUR.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetTUR_TXUNR() uint32 {
	return volatile.LoadUint32(&o.TUR.Reg) & 0x3ff
}

// GMAC.SCF: Single Collision Frames Register
func (o *GMAC_Type) SetSCF_SCOL(value uint32) {
	volatile.StoreUint32(&o.SCF.Reg, volatile.LoadUint32(&o.SCF.Reg)&^(0x3ffff)|value)
}
func (o *GMAC_Type) GetSCF_SCOL() uint32 {
	return volatile.LoadUint32(&o.SCF.Reg) & 0x3ffff
}

// GMAC.MCF: Multiple Collision Frames Register
func (o *GMAC_Type) SetMCF_MCOL(value uint32) {
	volatile.StoreUint32(&o.MCF.Reg, volatile.LoadUint32(&o.MCF.Reg)&^(0x3ffff)|value)
}
func (o *GMAC_Type) GetMCF_MCOL() uint32 {
	return volatile.LoadUint32(&o.MCF.Reg) & 0x3ffff
}

// GMAC.EC: Excessive Collisions Register
func (o *GMAC_Type) SetEC_XCOL(value uint32) {
	volatile.StoreUint32(&o.EC.Reg, volatile.LoadUint32(&o.EC.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetEC_XCOL() uint32 {
	return volatile.LoadUint32(&o.EC.Reg) & 0x3ff
}

// GMAC.LC: Late Collisions Register
func (o *GMAC_Type) SetLC_LCOL(value uint32) {
	volatile.StoreUint32(&o.LC.Reg, volatile.LoadUint32(&o.LC.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetLC_LCOL() uint32 {
	return volatile.LoadUint32(&o.LC.Reg) & 0x3ff
}

// GMAC.DTF: Deferred Transmission Frames Register
func (o *GMAC_Type) SetDTF_DEFT(value uint32) {
	volatile.StoreUint32(&o.DTF.Reg, volatile.LoadUint32(&o.DTF.Reg)&^(0x3ffff)|value)
}
func (o *GMAC_Type) GetDTF_DEFT() uint32 {
	return volatile.LoadUint32(&o.DTF.Reg) & 0x3ffff
}

// GMAC.CSE: Carrier Sense Errors Register
func (o *GMAC_Type) SetCSE_CSR(value uint32) {
	volatile.StoreUint32(&o.CSE.Reg, volatile.LoadUint32(&o.CSE.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetCSE_CSR() uint32 {
	return volatile.LoadUint32(&o.CSE.Reg) & 0x3ff
}

// GMAC.ORLO: Octets Received [31:0] Received
func (o *GMAC_Type) SetORLO(value uint32) {
	volatile.StoreUint32(&o.ORLO.Reg, value)
}
func (o *GMAC_Type) GetORLO() uint32 {
	return volatile.LoadUint32(&o.ORLO.Reg)
}

// GMAC.ORHI: Octets Received [47:32] Received
func (o *GMAC_Type) SetORHI_RXO(value uint32) {
	volatile.StoreUint32(&o.ORHI.Reg, volatile.LoadUint32(&o.ORHI.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetORHI_RXO() uint32 {
	return volatile.LoadUint32(&o.ORHI.Reg) & 0xffff
}

// GMAC.FR: Frames Received Register
func (o *GMAC_Type) SetFR(value uint32) {
	volatile.StoreUint32(&o.FR.Reg, value)
}
func (o *GMAC_Type) GetFR() uint32 {
	return volatile.LoadUint32(&o.FR.Reg)
}

// GMAC.BCFR: Broadcast Frames Received Register
func (o *GMAC_Type) SetBCFR(value uint32) {
	volatile.StoreUint32(&o.BCFR.Reg, value)
}
func (o *GMAC_Type) GetBCFR() uint32 {
	return volatile.LoadUint32(&o.BCFR.Reg)
}

// GMAC.MFR: Multicast Frames Received Register
func (o *GMAC_Type) SetMFR(value uint32) {
	volatile.StoreUint32(&o.MFR.Reg, value)
}
func (o *GMAC_Type) GetMFR() uint32 {
	return volatile.LoadUint32(&o.MFR.Reg)
}

// GMAC.PFR: Pause Frames Received Register
func (o *GMAC_Type) SetPFR_PFRX(value uint32) {
	volatile.StoreUint32(&o.PFR.Reg, volatile.LoadUint32(&o.PFR.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetPFR_PFRX() uint32 {
	return volatile.LoadUint32(&o.PFR.Reg) & 0xffff
}

// GMAC.BFR64: 64 Byte Frames Received Register
func (o *GMAC_Type) SetBFR64(value uint32) {
	volatile.StoreUint32(&o.BFR64.Reg, value)
}
func (o *GMAC_Type) GetBFR64() uint32 {
	return volatile.LoadUint32(&o.BFR64.Reg)
}

// GMAC.TBFR127: 65 to 127 Byte Frames Received Register
func (o *GMAC_Type) SetTBFR127(value uint32) {
	volatile.StoreUint32(&o.TBFR127.Reg, value)
}
func (o *GMAC_Type) GetTBFR127() uint32 {
	return volatile.LoadUint32(&o.TBFR127.Reg)
}

// GMAC.TBFR255: 128 to 255 Byte Frames Received Register
func (o *GMAC_Type) SetTBFR255(value uint32) {
	volatile.StoreUint32(&o.TBFR255.Reg, value)
}
func (o *GMAC_Type) GetTBFR255() uint32 {
	return volatile.LoadUint32(&o.TBFR255.Reg)
}

// GMAC.TBFR511: 256 to 511Byte Frames Received Register
func (o *GMAC_Type) SetTBFR511(value uint32) {
	volatile.StoreUint32(&o.TBFR511.Reg, value)
}
func (o *GMAC_Type) GetTBFR511() uint32 {
	return volatile.LoadUint32(&o.TBFR511.Reg)
}

// GMAC.TBFR1023: 512 to 1023 Byte Frames Received Register
func (o *GMAC_Type) SetTBFR1023(value uint32) {
	volatile.StoreUint32(&o.TBFR1023.Reg, value)
}
func (o *GMAC_Type) GetTBFR1023() uint32 {
	return volatile.LoadUint32(&o.TBFR1023.Reg)
}

// GMAC.TBFR1518: 1024 to 1518 Byte Frames Received Register
func (o *GMAC_Type) SetTBFR1518(value uint32) {
	volatile.StoreUint32(&o.TBFR1518.Reg, value)
}
func (o *GMAC_Type) GetTBFR1518() uint32 {
	return volatile.LoadUint32(&o.TBFR1518.Reg)
}

// GMAC.TMXBFR: 1519 to Maximum Byte Frames Received Register
func (o *GMAC_Type) SetTMXBFR(value uint32) {
	volatile.StoreUint32(&o.TMXBFR.Reg, value)
}
func (o *GMAC_Type) GetTMXBFR() uint32 {
	return volatile.LoadUint32(&o.TMXBFR.Reg)
}

// GMAC.UFR: Undersize Frames Received Register
func (o *GMAC_Type) SetUFR_UFRX(value uint32) {
	volatile.StoreUint32(&o.UFR.Reg, volatile.LoadUint32(&o.UFR.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetUFR_UFRX() uint32 {
	return volatile.LoadUint32(&o.UFR.Reg) & 0x3ff
}

// GMAC.OFR: Oversize Frames Received Register
func (o *GMAC_Type) SetOFR_OFRX(value uint32) {
	volatile.StoreUint32(&o.OFR.Reg, volatile.LoadUint32(&o.OFR.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetOFR_OFRX() uint32 {
	return volatile.LoadUint32(&o.OFR.Reg) & 0x3ff
}

// GMAC.JR: Jabbers Received Register
func (o *GMAC_Type) SetJR_JRX(value uint32) {
	volatile.StoreUint32(&o.JR.Reg, volatile.LoadUint32(&o.JR.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetJR_JRX() uint32 {
	return volatile.LoadUint32(&o.JR.Reg) & 0x3ff
}

// GMAC.FCSE: Frame Check Sequence Errors Register
func (o *GMAC_Type) SetFCSE_FCKR(value uint32) {
	volatile.StoreUint32(&o.FCSE.Reg, volatile.LoadUint32(&o.FCSE.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetFCSE_FCKR() uint32 {
	return volatile.LoadUint32(&o.FCSE.Reg) & 0x3ff
}

// GMAC.LFFE: Length Field Frame Errors Register
func (o *GMAC_Type) SetLFFE_LFER(value uint32) {
	volatile.StoreUint32(&o.LFFE.Reg, volatile.LoadUint32(&o.LFFE.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetLFFE_LFER() uint32 {
	return volatile.LoadUint32(&o.LFFE.Reg) & 0x3ff
}

// GMAC.RSE: Receive Symbol Errors Register
func (o *GMAC_Type) SetRSE_RXSE(value uint32) {
	volatile.StoreUint32(&o.RSE.Reg, volatile.LoadUint32(&o.RSE.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetRSE_RXSE() uint32 {
	return volatile.LoadUint32(&o.RSE.Reg) & 0x3ff
}

// GMAC.AE: Alignment Errors Register
func (o *GMAC_Type) SetAE_AER(value uint32) {
	volatile.StoreUint32(&o.AE.Reg, volatile.LoadUint32(&o.AE.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetAE_AER() uint32 {
	return volatile.LoadUint32(&o.AE.Reg) & 0x3ff
}

// GMAC.RRE: Receive Resource Errors Register
func (o *GMAC_Type) SetRRE_RXRER(value uint32) {
	volatile.StoreUint32(&o.RRE.Reg, volatile.LoadUint32(&o.RRE.Reg)&^(0x3ffff)|value)
}
func (o *GMAC_Type) GetRRE_RXRER() uint32 {
	return volatile.LoadUint32(&o.RRE.Reg) & 0x3ffff
}

// GMAC.ROE: Receive Overrun Register
func (o *GMAC_Type) SetROE_RXOVR(value uint32) {
	volatile.StoreUint32(&o.ROE.Reg, volatile.LoadUint32(&o.ROE.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetROE_RXOVR() uint32 {
	return volatile.LoadUint32(&o.ROE.Reg) & 0x3ff
}

// GMAC.IHCE: IP Header Checksum Errors Register
func (o *GMAC_Type) SetIHCE_HCKER(value uint32) {
	volatile.StoreUint32(&o.IHCE.Reg, volatile.LoadUint32(&o.IHCE.Reg)&^(0xff)|value)
}
func (o *GMAC_Type) GetIHCE_HCKER() uint32 {
	return volatile.LoadUint32(&o.IHCE.Reg) & 0xff
}

// GMAC.TCE: TCP Checksum Errors Register
func (o *GMAC_Type) SetTCE_TCKER(value uint32) {
	volatile.StoreUint32(&o.TCE.Reg, volatile.LoadUint32(&o.TCE.Reg)&^(0xff)|value)
}
func (o *GMAC_Type) GetTCE_TCKER() uint32 {
	return volatile.LoadUint32(&o.TCE.Reg) & 0xff
}

// GMAC.UCE: UDP Checksum Errors Register
func (o *GMAC_Type) SetUCE_UCKER(value uint32) {
	volatile.StoreUint32(&o.UCE.Reg, volatile.LoadUint32(&o.UCE.Reg)&^(0xff)|value)
}
func (o *GMAC_Type) GetUCE_UCKER() uint32 {
	return volatile.LoadUint32(&o.UCE.Reg) & 0xff
}

// GMAC.TSSS: 1588 Timer Sync Strobe Seconds Register
func (o *GMAC_Type) SetTSSS(value uint32) {
	volatile.StoreUint32(&o.TSSS.Reg, value)
}
func (o *GMAC_Type) GetTSSS() uint32 {
	return volatile.LoadUint32(&o.TSSS.Reg)
}

// GMAC.TSSN: 1588 Timer Sync Strobe Nanoseconds Register
func (o *GMAC_Type) SetTSSN_VTN(value uint32) {
	volatile.StoreUint32(&o.TSSN.Reg, volatile.LoadUint32(&o.TSSN.Reg)&^(0x3fffffff)|value)
}
func (o *GMAC_Type) GetTSSN_VTN() uint32 {
	return volatile.LoadUint32(&o.TSSN.Reg) & 0x3fffffff
}

// GMAC.TS: 1588 Timer Seconds Register
func (o *GMAC_Type) SetTS(value uint32) {
	volatile.StoreUint32(&o.TS.Reg, value)
}
func (o *GMAC_Type) GetTS() uint32 {
	return volatile.LoadUint32(&o.TS.Reg)
}

// GMAC.TN: 1588 Timer Nanoseconds Register
func (o *GMAC_Type) SetTN_TNS(value uint32) {
	volatile.StoreUint32(&o.TN.Reg, volatile.LoadUint32(&o.TN.Reg)&^(0x3fffffff)|value)
}
func (o *GMAC_Type) GetTN_TNS() uint32 {
	return volatile.LoadUint32(&o.TN.Reg) & 0x3fffffff
}

// GMAC.TA: 1588 Timer Adjust Register
func (o *GMAC_Type) SetTA_ITDT(value uint32) {
	volatile.StoreUint32(&o.TA.Reg, volatile.LoadUint32(&o.TA.Reg)&^(0x3fffffff)|value)
}
func (o *GMAC_Type) GetTA_ITDT() uint32 {
	return volatile.LoadUint32(&o.TA.Reg) & 0x3fffffff
}
func (o *GMAC_Type) SetTA_ADJ(value uint32) {
	volatile.StoreUint32(&o.TA.Reg, volatile.LoadUint32(&o.TA.Reg)&^(0x80000000)|value<<31)
}
func (o *GMAC_Type) GetTA_ADJ() uint32 {
	return (volatile.LoadUint32(&o.TA.Reg) & 0x80000000) >> 31
}

// GMAC.TI: 1588 Timer Increment Register
func (o *GMAC_Type) SetTI_CNS(value uint32) {
	volatile.StoreUint32(&o.TI.Reg, volatile.LoadUint32(&o.TI.Reg)&^(0xff)|value)
}
func (o *GMAC_Type) GetTI_CNS() uint32 {
	return volatile.LoadUint32(&o.TI.Reg) & 0xff
}
func (o *GMAC_Type) SetTI_ACNS(value uint32) {
	volatile.StoreUint32(&o.TI.Reg, volatile.LoadUint32(&o.TI.Reg)&^(0xff00)|value<<8)
}
func (o *GMAC_Type) GetTI_ACNS() uint32 {
	return (volatile.LoadUint32(&o.TI.Reg) & 0xff00) >> 8
}
func (o *GMAC_Type) SetTI_NIT(value uint32) {
	volatile.StoreUint32(&o.TI.Reg, volatile.LoadUint32(&o.TI.Reg)&^(0xff0000)|value<<16)
}
func (o *GMAC_Type) GetTI_NIT() uint32 {
	return (volatile.LoadUint32(&o.TI.Reg) & 0xff0000) >> 16
}

// GMAC.EFTS: PTP Event Frame Transmitted Seconds
func (o *GMAC_Type) SetEFTS(value uint32) {
	volatile.StoreUint32(&o.EFTS.Reg, value)
}
func (o *GMAC_Type) GetEFTS() uint32 {
	return volatile.LoadUint32(&o.EFTS.Reg)
}

// GMAC.EFTN: PTP Event Frame Transmitted Nanoseconds
func (o *GMAC_Type) SetEFTN_RUD(value uint32) {
	volatile.StoreUint32(&o.EFTN.Reg, volatile.LoadUint32(&o.EFTN.Reg)&^(0x3fffffff)|value)
}
func (o *GMAC_Type) GetEFTN_RUD() uint32 {
	return volatile.LoadUint32(&o.EFTN.Reg) & 0x3fffffff
}

// GMAC.EFRS: PTP Event Frame Received Seconds
func (o *GMAC_Type) SetEFRS(value uint32) {
	volatile.StoreUint32(&o.EFRS.Reg, value)
}
func (o *GMAC_Type) GetEFRS() uint32 {
	return volatile.LoadUint32(&o.EFRS.Reg)
}

// GMAC.EFRN: PTP Event Frame Received Nanoseconds
func (o *GMAC_Type) SetEFRN_RUD(value uint32) {
	volatile.StoreUint32(&o.EFRN.Reg, volatile.LoadUint32(&o.EFRN.Reg)&^(0x3fffffff)|value)
}
func (o *GMAC_Type) GetEFRN_RUD() uint32 {
	return volatile.LoadUint32(&o.EFRN.Reg) & 0x3fffffff
}

// GMAC.PEFTS: PTP Peer Event Frame Transmitted Seconds
func (o *GMAC_Type) SetPEFTS(value uint32) {
	volatile.StoreUint32(&o.PEFTS.Reg, value)
}
func (o *GMAC_Type) GetPEFTS() uint32 {
	return volatile.LoadUint32(&o.PEFTS.Reg)
}

// GMAC.PEFTN: PTP Peer Event Frame Transmitted Nanoseconds
func (o *GMAC_Type) SetPEFTN_RUD(value uint32) {
	volatile.StoreUint32(&o.PEFTN.Reg, volatile.LoadUint32(&o.PEFTN.Reg)&^(0x3fffffff)|value)
}
func (o *GMAC_Type) GetPEFTN_RUD() uint32 {
	return volatile.LoadUint32(&o.PEFTN.Reg) & 0x3fffffff
}

// GMAC.PEFRS: PTP Peer Event Frame Received Seconds
func (o *GMAC_Type) SetPEFRS(value uint32) {
	volatile.StoreUint32(&o.PEFRS.Reg, value)
}
func (o *GMAC_Type) GetPEFRS() uint32 {
	return volatile.LoadUint32(&o.PEFRS.Reg)
}

// GMAC.PEFRN: PTP Peer Event Frame Received Nanoseconds
func (o *GMAC_Type) SetPEFRN_RUD(value uint32) {
	volatile.StoreUint32(&o.PEFRN.Reg, volatile.LoadUint32(&o.PEFRN.Reg)&^(0x3fffffff)|value)
}
func (o *GMAC_Type) GetPEFRN_RUD() uint32 {
	return volatile.LoadUint32(&o.PEFRN.Reg) & 0x3fffffff
}

// GMAC.ISRPQ: Interrupt Status Register Priority Queue
func (o *GMAC_Type) SetISRPQ_RCOMP(idx int, value uint32) {
	volatile.StoreUint32(&o.ISRPQ[idx].Reg, volatile.LoadUint32(&o.ISRPQ[idx].Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetISRPQ_RCOMP(idx int) uint32 {
	return (volatile.LoadUint32(&o.ISRPQ[idx].Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetISRPQ_RXUBR(idx int, value uint32) {
	volatile.StoreUint32(&o.ISRPQ[idx].Reg, volatile.LoadUint32(&o.ISRPQ[idx].Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetISRPQ_RXUBR(idx int) uint32 {
	return (volatile.LoadUint32(&o.ISRPQ[idx].Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetISRPQ_RLEX(idx int, value uint32) {
	volatile.StoreUint32(&o.ISRPQ[idx].Reg, volatile.LoadUint32(&o.ISRPQ[idx].Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetISRPQ_RLEX(idx int) uint32 {
	return (volatile.LoadUint32(&o.ISRPQ[idx].Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetISRPQ_TFC(idx int, value uint32) {
	volatile.StoreUint32(&o.ISRPQ[idx].Reg, volatile.LoadUint32(&o.ISRPQ[idx].Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetISRPQ_TFC(idx int) uint32 {
	return (volatile.LoadUint32(&o.ISRPQ[idx].Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetISRPQ_TCOMP(idx int, value uint32) {
	volatile.StoreUint32(&o.ISRPQ[idx].Reg, volatile.LoadUint32(&o.ISRPQ[idx].Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetISRPQ_TCOMP(idx int) uint32 {
	return (volatile.LoadUint32(&o.ISRPQ[idx].Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetISRPQ_ROVR(idx int, value uint32) {
	volatile.StoreUint32(&o.ISRPQ[idx].Reg, volatile.LoadUint32(&o.ISRPQ[idx].Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetISRPQ_ROVR(idx int) uint32 {
	return (volatile.LoadUint32(&o.ISRPQ[idx].Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetISRPQ_HRESP(idx int, value uint32) {
	volatile.StoreUint32(&o.ISRPQ[idx].Reg, volatile.LoadUint32(&o.ISRPQ[idx].Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetISRPQ_HRESP(idx int) uint32 {
	return (volatile.LoadUint32(&o.ISRPQ[idx].Reg) & 0x800) >> 11
}

// GMAC.TBQBAPQ: Transmit Buffer Queue Base Address Priority Queue
func (o *GMAC_Type) SetTBQBAPQ_TXBQBA(idx int, value uint32) {
	volatile.StoreUint32(&o.TBQBAPQ[idx].Reg, volatile.LoadUint32(&o.TBQBAPQ[idx].Reg)&^(0xfc)|value<<2)
}
func (o *GMAC_Type) GetTBQBAPQ_TXBQBA(idx int) uint32 {
	return (volatile.LoadUint32(&o.TBQBAPQ[idx].Reg) & 0xfc) >> 2
}

// GMAC.RBQBAPQ: Receive Buffer Queue Base Address Priority Queue
func (o *GMAC_Type) SetRBQBAPQ_RXBQBA(idx int, value uint32) {
	volatile.StoreUint32(&o.RBQBAPQ[idx].Reg, volatile.LoadUint32(&o.RBQBAPQ[idx].Reg)&^(0xfc)|value<<2)
}
func (o *GMAC_Type) GetRBQBAPQ_RXBQBA(idx int) uint32 {
	return (volatile.LoadUint32(&o.RBQBAPQ[idx].Reg) & 0xfc) >> 2
}

// GMAC.RBSRPQ: Receive Buffer Size Register Priority Queue
func (o *GMAC_Type) SetRBSRPQ_RBS(idx int, value uint32) {
	volatile.StoreUint32(&o.RBSRPQ[idx].Reg, volatile.LoadUint32(&o.RBSRPQ[idx].Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetRBSRPQ_RBS(idx int) uint32 {
	return volatile.LoadUint32(&o.RBSRPQ[idx].Reg) & 0xffff
}

// GMAC.ST1RPQ: Screening Type1 Register Priority Queue
func (o *GMAC_Type) SetST1RPQ_QNB(idx int, value uint32) {
	volatile.StoreUint32(&o.ST1RPQ[idx].Reg, volatile.LoadUint32(&o.ST1RPQ[idx].Reg)&^(0xf)|value)
}
func (o *GMAC_Type) GetST1RPQ_QNB(idx int) uint32 {
	return volatile.LoadUint32(&o.ST1RPQ[idx].Reg) & 0xf
}
func (o *GMAC_Type) SetST1RPQ_DSTCM(idx int, value uint32) {
	volatile.StoreUint32(&o.ST1RPQ[idx].Reg, volatile.LoadUint32(&o.ST1RPQ[idx].Reg)&^(0xff0)|value<<4)
}
func (o *GMAC_Type) GetST1RPQ_DSTCM(idx int) uint32 {
	return (volatile.LoadUint32(&o.ST1RPQ[idx].Reg) & 0xff0) >> 4
}
func (o *GMAC_Type) SetST1RPQ_UDPM(idx int, value uint32) {
	volatile.StoreUint32(&o.ST1RPQ[idx].Reg, volatile.LoadUint32(&o.ST1RPQ[idx].Reg)&^(0xffff000)|value<<12)
}
func (o *GMAC_Type) GetST1RPQ_UDPM(idx int) uint32 {
	return (volatile.LoadUint32(&o.ST1RPQ[idx].Reg) & 0xffff000) >> 12
}
func (o *GMAC_Type) SetST1RPQ_DSTCE(idx int, value uint32) {
	volatile.StoreUint32(&o.ST1RPQ[idx].Reg, volatile.LoadUint32(&o.ST1RPQ[idx].Reg)&^(0x10000000)|value<<28)
}
func (o *GMAC_Type) GetST1RPQ_DSTCE(idx int) uint32 {
	return (volatile.LoadUint32(&o.ST1RPQ[idx].Reg) & 0x10000000) >> 28
}
func (o *GMAC_Type) SetST1RPQ_UDPE(idx int, value uint32) {
	volatile.StoreUint32(&o.ST1RPQ[idx].Reg, volatile.LoadUint32(&o.ST1RPQ[idx].Reg)&^(0x20000000)|value<<29)
}
func (o *GMAC_Type) GetST1RPQ_UDPE(idx int) uint32 {
	return (volatile.LoadUint32(&o.ST1RPQ[idx].Reg) & 0x20000000) >> 29
}

// GMAC.ST2RPQ: Screening Type2 Register Priority Queue
func (o *GMAC_Type) SetST2RPQ_QNB(idx int, value uint32) {
	volatile.StoreUint32(&o.ST2RPQ[idx].Reg, volatile.LoadUint32(&o.ST2RPQ[idx].Reg)&^(0xf)|value)
}
func (o *GMAC_Type) GetST2RPQ_QNB(idx int) uint32 {
	return volatile.LoadUint32(&o.ST2RPQ[idx].Reg) & 0xf
}
func (o *GMAC_Type) SetST2RPQ_VLANP(idx int, value uint32) {
	volatile.StoreUint32(&o.ST2RPQ[idx].Reg, volatile.LoadUint32(&o.ST2RPQ[idx].Reg)&^(0xf0)|value<<4)
}
func (o *GMAC_Type) GetST2RPQ_VLANP(idx int) uint32 {
	return (volatile.LoadUint32(&o.ST2RPQ[idx].Reg) & 0xf0) >> 4
}
func (o *GMAC_Type) SetST2RPQ_VLANE(idx int, value uint32) {
	volatile.StoreUint32(&o.ST2RPQ[idx].Reg, volatile.LoadUint32(&o.ST2RPQ[idx].Reg)&^(0x100)|value<<8)
}
func (o *GMAC_Type) GetST2RPQ_VLANE(idx int) uint32 {
	return (volatile.LoadUint32(&o.ST2RPQ[idx].Reg) & 0x100) >> 8
}

// GMAC.IERPQ: Interrupt Enable Register Priority Queue
func (o *GMAC_Type) SetIERPQ_RCOMP(idx int, value uint32) {
	volatile.StoreUint32(&o.IERPQ[idx].Reg, volatile.LoadUint32(&o.IERPQ[idx].Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetIERPQ_RCOMP(idx int) uint32 {
	return (volatile.LoadUint32(&o.IERPQ[idx].Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetIERPQ_RXUBR(idx int, value uint32) {
	volatile.StoreUint32(&o.IERPQ[idx].Reg, volatile.LoadUint32(&o.IERPQ[idx].Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetIERPQ_RXUBR(idx int) uint32 {
	return (volatile.LoadUint32(&o.IERPQ[idx].Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetIERPQ_RLEX(idx int, value uint32) {
	volatile.StoreUint32(&o.IERPQ[idx].Reg, volatile.LoadUint32(&o.IERPQ[idx].Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetIERPQ_RLEX(idx int) uint32 {
	return (volatile.LoadUint32(&o.IERPQ[idx].Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetIERPQ_TFC(idx int, value uint32) {
	volatile.StoreUint32(&o.IERPQ[idx].Reg, volatile.LoadUint32(&o.IERPQ[idx].Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetIERPQ_TFC(idx int) uint32 {
	return (volatile.LoadUint32(&o.IERPQ[idx].Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetIERPQ_TCOMP(idx int, value uint32) {
	volatile.StoreUint32(&o.IERPQ[idx].Reg, volatile.LoadUint32(&o.IERPQ[idx].Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetIERPQ_TCOMP(idx int) uint32 {
	return (volatile.LoadUint32(&o.IERPQ[idx].Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetIERPQ_ROVR(idx int, value uint32) {
	volatile.StoreUint32(&o.IERPQ[idx].Reg, volatile.LoadUint32(&o.IERPQ[idx].Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetIERPQ_ROVR(idx int) uint32 {
	return (volatile.LoadUint32(&o.IERPQ[idx].Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetIERPQ_HRESP(idx int, value uint32) {
	volatile.StoreUint32(&o.IERPQ[idx].Reg, volatile.LoadUint32(&o.IERPQ[idx].Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetIERPQ_HRESP(idx int) uint32 {
	return (volatile.LoadUint32(&o.IERPQ[idx].Reg) & 0x800) >> 11
}

// GMAC.IDRPQ: Interrupt Disable Register Priority Queue
func (o *GMAC_Type) SetIDRPQ_RCOMP(idx int, value uint32) {
	volatile.StoreUint32(&o.IDRPQ[idx].Reg, volatile.LoadUint32(&o.IDRPQ[idx].Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetIDRPQ_RCOMP(idx int) uint32 {
	return (volatile.LoadUint32(&o.IDRPQ[idx].Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetIDRPQ_RXUBR(idx int, value uint32) {
	volatile.StoreUint32(&o.IDRPQ[idx].Reg, volatile.LoadUint32(&o.IDRPQ[idx].Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetIDRPQ_RXUBR(idx int) uint32 {
	return (volatile.LoadUint32(&o.IDRPQ[idx].Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetIDRPQ_RLEX(idx int, value uint32) {
	volatile.StoreUint32(&o.IDRPQ[idx].Reg, volatile.LoadUint32(&o.IDRPQ[idx].Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetIDRPQ_RLEX(idx int) uint32 {
	return (volatile.LoadUint32(&o.IDRPQ[idx].Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetIDRPQ_TFC(idx int, value uint32) {
	volatile.StoreUint32(&o.IDRPQ[idx].Reg, volatile.LoadUint32(&o.IDRPQ[idx].Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetIDRPQ_TFC(idx int) uint32 {
	return (volatile.LoadUint32(&o.IDRPQ[idx].Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetIDRPQ_TCOMP(idx int, value uint32) {
	volatile.StoreUint32(&o.IDRPQ[idx].Reg, volatile.LoadUint32(&o.IDRPQ[idx].Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetIDRPQ_TCOMP(idx int) uint32 {
	return (volatile.LoadUint32(&o.IDRPQ[idx].Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetIDRPQ_ROVR(idx int, value uint32) {
	volatile.StoreUint32(&o.IDRPQ[idx].Reg, volatile.LoadUint32(&o.IDRPQ[idx].Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetIDRPQ_ROVR(idx int) uint32 {
	return (volatile.LoadUint32(&o.IDRPQ[idx].Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetIDRPQ_HRESP(idx int, value uint32) {
	volatile.StoreUint32(&o.IDRPQ[idx].Reg, volatile.LoadUint32(&o.IDRPQ[idx].Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetIDRPQ_HRESP(idx int) uint32 {
	return (volatile.LoadUint32(&o.IDRPQ[idx].Reg) & 0x800) >> 11
}

// GMAC.IMRPQ: Interrupt Mask Register Priority Queue
func (o *GMAC_Type) SetIMRPQ_RCOMP(idx int, value uint32) {
	volatile.StoreUint32(&o.IMRPQ[idx].Reg, volatile.LoadUint32(&o.IMRPQ[idx].Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetIMRPQ_RCOMP(idx int) uint32 {
	return (volatile.LoadUint32(&o.IMRPQ[idx].Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetIMRPQ_RXUBR(idx int, value uint32) {
	volatile.StoreUint32(&o.IMRPQ[idx].Reg, volatile.LoadUint32(&o.IMRPQ[idx].Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetIMRPQ_RXUBR(idx int) uint32 {
	return (volatile.LoadUint32(&o.IMRPQ[idx].Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetIMRPQ_RLEX(idx int, value uint32) {
	volatile.StoreUint32(&o.IMRPQ[idx].Reg, volatile.LoadUint32(&o.IMRPQ[idx].Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetIMRPQ_RLEX(idx int) uint32 {
	return (volatile.LoadUint32(&o.IMRPQ[idx].Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetIMRPQ_AHB(idx int, value uint32) {
	volatile.StoreUint32(&o.IMRPQ[idx].Reg, volatile.LoadUint32(&o.IMRPQ[idx].Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetIMRPQ_AHB(idx int) uint32 {
	return (volatile.LoadUint32(&o.IMRPQ[idx].Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetIMRPQ_TCOMP(idx int, value uint32) {
	volatile.StoreUint32(&o.IMRPQ[idx].Reg, volatile.LoadUint32(&o.IMRPQ[idx].Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetIMRPQ_TCOMP(idx int) uint32 {
	return (volatile.LoadUint32(&o.IMRPQ[idx].Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetIMRPQ_ROVR(idx int, value uint32) {
	volatile.StoreUint32(&o.IMRPQ[idx].Reg, volatile.LoadUint32(&o.IMRPQ[idx].Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetIMRPQ_ROVR(idx int) uint32 {
	return (volatile.LoadUint32(&o.IMRPQ[idx].Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetIMRPQ_HRESP(idx int, value uint32) {
	volatile.StoreUint32(&o.IMRPQ[idx].Reg, volatile.LoadUint32(&o.IMRPQ[idx].Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetIMRPQ_HRESP(idx int) uint32 {
	return (volatile.LoadUint32(&o.IMRPQ[idx].Reg) & 0x800) >> 11
}

// Pulse Width Modulation Controller
type PWM_Type struct {
	CLK      volatile.Register32 // 0x0
	ENA      volatile.Register32 // 0x4
	DIS      volatile.Register32 // 0x8
	SR       volatile.Register32 // 0xC
	IER1     volatile.Register32 // 0x10
	IDR1     volatile.Register32 // 0x14
	IMR1     volatile.Register32 // 0x18
	ISR1     volatile.Register32 // 0x1C
	SCM      volatile.Register32 // 0x20
	_        [4]byte
	SCUC     volatile.Register32 // 0x28
	SCUP     volatile.Register32 // 0x2C
	SCUPUPD  volatile.Register32 // 0x30
	IER2     volatile.Register32 // 0x34
	IDR2     volatile.Register32 // 0x38
	IMR2     volatile.Register32 // 0x3C
	ISR2     volatile.Register32 // 0x40
	OOV      volatile.Register32 // 0x44
	OS       volatile.Register32 // 0x48
	OSS      volatile.Register32 // 0x4C
	OSC      volatile.Register32 // 0x50
	OSSUPD   volatile.Register32 // 0x54
	OSCUPD   volatile.Register32 // 0x58
	FMR      volatile.Register32 // 0x5C
	FSR      volatile.Register32 // 0x60
	FCR      volatile.Register32 // 0x64
	FPV      volatile.Register32 // 0x68
	FPE      volatile.Register32 // 0x6C
	_        [12]byte
	ELMR     [2]volatile.Register32 // 0x7C
	_        [44]byte
	SMMR     volatile.Register32 // 0xB0
	_        [48]byte
	WPCR     volatile.Register32 // 0xE4
	WPSR     volatile.Register32 // 0xE8
	_        [68]byte
	CMPV0    volatile.Register32 // 0x130
	CMPVUPD0 volatile.Register32 // 0x134
	CMPM0    volatile.Register32 // 0x138
	CMPMUPD0 volatile.Register32 // 0x13C
	CMPV1    volatile.Register32 // 0x140
	CMPVUPD1 volatile.Register32 // 0x144
	CMPM1    volatile.Register32 // 0x148
	CMPMUPD1 volatile.Register32 // 0x14C
	CMPV2    volatile.Register32 // 0x150
	CMPVUPD2 volatile.Register32 // 0x154
	CMPM2    volatile.Register32 // 0x158
	CMPMUPD2 volatile.Register32 // 0x15C
	CMPV3    volatile.Register32 // 0x160
	CMPVUPD3 volatile.Register32 // 0x164
	CMPM3    volatile.Register32 // 0x168
	CMPMUPD3 volatile.Register32 // 0x16C
	CMPV4    volatile.Register32 // 0x170
	CMPVUPD4 volatile.Register32 // 0x174
	CMPM4    volatile.Register32 // 0x178
	CMPMUPD4 volatile.Register32 // 0x17C
	CMPV5    volatile.Register32 // 0x180
	CMPVUPD5 volatile.Register32 // 0x184
	CMPM5    volatile.Register32 // 0x188
	CMPMUPD5 volatile.Register32 // 0x18C
	CMPV6    volatile.Register32 // 0x190
	CMPVUPD6 volatile.Register32 // 0x194
	CMPM6    volatile.Register32 // 0x198
	CMPMUPD6 volatile.Register32 // 0x19C
	CMPV7    volatile.Register32 // 0x1A0
	CMPVUPD7 volatile.Register32 // 0x1A4
	CMPM7    volatile.Register32 // 0x1A8
	CMPMUPD7 volatile.Register32 // 0x1AC
	_        [80]byte
	CMR0     volatile.Register32 // 0x200
	CDTY0    volatile.Register32 // 0x204
	CDTYUPD0 volatile.Register32 // 0x208
	CPRD0    volatile.Register32 // 0x20C
	CPRDUPD0 volatile.Register32 // 0x210
	CCNT0    volatile.Register32 // 0x214
	DT0      volatile.Register32 // 0x218
	DTUPD0   volatile.Register32 // 0x21C
	CMR1     volatile.Register32 // 0x220
	CDTY1    volatile.Register32 // 0x224
	CDTYUPD1 volatile.Register32 // 0x228
	CPRD1    volatile.Register32 // 0x22C
	CPRDUPD1 volatile.Register32 // 0x230
	CCNT1    volatile.Register32 // 0x234
	DT1      volatile.Register32 // 0x238
	DTUPD1   volatile.Register32 // 0x23C
	CMR2     volatile.Register32 // 0x240
	CDTY2    volatile.Register32 // 0x244
	CDTYUPD2 volatile.Register32 // 0x248
	CPRD2    volatile.Register32 // 0x24C
	CPRDUPD2 volatile.Register32 // 0x250
	CCNT2    volatile.Register32 // 0x254
	DT2      volatile.Register32 // 0x258
	DTUPD2   volatile.Register32 // 0x25C
	CMR3     volatile.Register32 // 0x260
	CDTY3    volatile.Register32 // 0x264
	CDTYUPD3 volatile.Register32 // 0x268
	CPRD3    volatile.Register32 // 0x26C
	CPRDUPD3 volatile.Register32 // 0x270
	CCNT3    volatile.Register32 // 0x274
	DT3      volatile.Register32 // 0x278
	DTUPD3   volatile.Register32 // 0x27C
}

// PWM.CLK: PWM Clock Register
func (o *PWM_Type) SetCLK_DIVA(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetCLK_DIVA() uint32 {
	return volatile.LoadUint32(&o.CLK.Reg) & 0xff
}
func (o *PWM_Type) SetCLK_PREA(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCLK_PREA() uint32 {
	return (volatile.LoadUint32(&o.CLK.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCLK_DIVB(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0xff0000)|value<<16)
}
func (o *PWM_Type) GetCLK_DIVB() uint32 {
	return (volatile.LoadUint32(&o.CLK.Reg) & 0xff0000) >> 16
}
func (o *PWM_Type) SetCLK_PREB(value uint32) {
	volatile.StoreUint32(&o.CLK.Reg, volatile.LoadUint32(&o.CLK.Reg)&^(0xf000000)|value<<24)
}
func (o *PWM_Type) GetCLK_PREB() uint32 {
	return (volatile.LoadUint32(&o.CLK.Reg) & 0xf000000) >> 24
}

// PWM.ENA: PWM Enable Register
func (o *PWM_Type) SetENA_CHID0(value uint32) {
	volatile.StoreUint32(&o.ENA.Reg, volatile.LoadUint32(&o.ENA.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetENA_CHID0() uint32 {
	return volatile.LoadUint32(&o.ENA.Reg) & 0x1
}
func (o *PWM_Type) SetENA_CHID1(value uint32) {
	volatile.StoreUint32(&o.ENA.Reg, volatile.LoadUint32(&o.ENA.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetENA_CHID1() uint32 {
	return (volatile.LoadUint32(&o.ENA.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetENA_CHID2(value uint32) {
	volatile.StoreUint32(&o.ENA.Reg, volatile.LoadUint32(&o.ENA.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetENA_CHID2() uint32 {
	return (volatile.LoadUint32(&o.ENA.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetENA_CHID3(value uint32) {
	volatile.StoreUint32(&o.ENA.Reg, volatile.LoadUint32(&o.ENA.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetENA_CHID3() uint32 {
	return (volatile.LoadUint32(&o.ENA.Reg) & 0x8) >> 3
}

// PWM.DIS: PWM Disable Register
func (o *PWM_Type) SetDIS_CHID0(value uint32) {
	volatile.StoreUint32(&o.DIS.Reg, volatile.LoadUint32(&o.DIS.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetDIS_CHID0() uint32 {
	return volatile.LoadUint32(&o.DIS.Reg) & 0x1
}
func (o *PWM_Type) SetDIS_CHID1(value uint32) {
	volatile.StoreUint32(&o.DIS.Reg, volatile.LoadUint32(&o.DIS.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetDIS_CHID1() uint32 {
	return (volatile.LoadUint32(&o.DIS.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetDIS_CHID2(value uint32) {
	volatile.StoreUint32(&o.DIS.Reg, volatile.LoadUint32(&o.DIS.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetDIS_CHID2() uint32 {
	return (volatile.LoadUint32(&o.DIS.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetDIS_CHID3(value uint32) {
	volatile.StoreUint32(&o.DIS.Reg, volatile.LoadUint32(&o.DIS.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetDIS_CHID3() uint32 {
	return (volatile.LoadUint32(&o.DIS.Reg) & 0x8) >> 3
}

// PWM.SR: PWM Status Register
func (o *PWM_Type) SetSR_CHID0(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSR_CHID0() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *PWM_Type) SetSR_CHID1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSR_CHID1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSR_CHID2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSR_CHID2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSR_CHID3(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetSR_CHID3() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}

// PWM.IER1: PWM Interrupt Enable Register 1
func (o *PWM_Type) SetIER1_CHID0(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetIER1_CHID0() uint32 {
	return volatile.LoadUint32(&o.IER1.Reg) & 0x1
}
func (o *PWM_Type) SetIER1_CHID1(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetIER1_CHID1() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetIER1_CHID2(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetIER1_CHID2() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetIER1_CHID3(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetIER1_CHID3() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetIER1_FCHID0(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetIER1_FCHID0() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetIER1_FCHID1(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetIER1_FCHID1() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetIER1_FCHID2(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetIER1_FCHID2() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetIER1_FCHID3(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetIER1_FCHID3() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x80000) >> 19
}

// PWM.IDR1: PWM Interrupt Disable Register 1
func (o *PWM_Type) SetIDR1_CHID0(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetIDR1_CHID0() uint32 {
	return volatile.LoadUint32(&o.IDR1.Reg) & 0x1
}
func (o *PWM_Type) SetIDR1_CHID1(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetIDR1_CHID1() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetIDR1_CHID2(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetIDR1_CHID2() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetIDR1_CHID3(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetIDR1_CHID3() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetIDR1_FCHID0(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetIDR1_FCHID0() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetIDR1_FCHID1(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetIDR1_FCHID1() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetIDR1_FCHID2(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetIDR1_FCHID2() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetIDR1_FCHID3(value uint32) {
	volatile.StoreUint32(&o.IDR1.Reg, volatile.LoadUint32(&o.IDR1.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetIDR1_FCHID3() uint32 {
	return (volatile.LoadUint32(&o.IDR1.Reg) & 0x80000) >> 19
}

// PWM.IMR1: PWM Interrupt Mask Register 1
func (o *PWM_Type) SetIMR1_CHID0(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetIMR1_CHID0() uint32 {
	return volatile.LoadUint32(&o.IMR1.Reg) & 0x1
}
func (o *PWM_Type) SetIMR1_CHID1(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetIMR1_CHID1() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetIMR1_CHID2(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetIMR1_CHID2() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetIMR1_CHID3(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetIMR1_CHID3() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetIMR1_FCHID0(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetIMR1_FCHID0() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetIMR1_FCHID1(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetIMR1_FCHID1() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetIMR1_FCHID2(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetIMR1_FCHID2() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetIMR1_FCHID3(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, volatile.LoadUint32(&o.IMR1.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetIMR1_FCHID3() uint32 {
	return (volatile.LoadUint32(&o.IMR1.Reg) & 0x80000) >> 19
}

// PWM.ISR1: PWM Interrupt Status Register 1
func (o *PWM_Type) SetISR1_CHID0(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetISR1_CHID0() uint32 {
	return volatile.LoadUint32(&o.ISR1.Reg) & 0x1
}
func (o *PWM_Type) SetISR1_CHID1(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetISR1_CHID1() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetISR1_CHID2(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetISR1_CHID2() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetISR1_CHID3(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetISR1_CHID3() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetISR1_FCHID0(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetISR1_FCHID0() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetISR1_FCHID1(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetISR1_FCHID1() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetISR1_FCHID2(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetISR1_FCHID2() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetISR1_FCHID3(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetISR1_FCHID3() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x80000) >> 19
}

// PWM.SCM: PWM Sync Channels Mode Register
func (o *PWM_Type) SetSCM_SYNC0(value uint32) {
	volatile.StoreUint32(&o.SCM.Reg, volatile.LoadUint32(&o.SCM.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSCM_SYNC0() uint32 {
	return volatile.LoadUint32(&o.SCM.Reg) & 0x1
}
func (o *PWM_Type) SetSCM_SYNC1(value uint32) {
	volatile.StoreUint32(&o.SCM.Reg, volatile.LoadUint32(&o.SCM.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSCM_SYNC1() uint32 {
	return (volatile.LoadUint32(&o.SCM.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSCM_SYNC2(value uint32) {
	volatile.StoreUint32(&o.SCM.Reg, volatile.LoadUint32(&o.SCM.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSCM_SYNC2() uint32 {
	return (volatile.LoadUint32(&o.SCM.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSCM_SYNC3(value uint32) {
	volatile.StoreUint32(&o.SCM.Reg, volatile.LoadUint32(&o.SCM.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetSCM_SYNC3() uint32 {
	return (volatile.LoadUint32(&o.SCM.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetSCM_UPDM(value uint32) {
	volatile.StoreUint32(&o.SCM.Reg, volatile.LoadUint32(&o.SCM.Reg)&^(0x30000)|value<<16)
}
func (o *PWM_Type) GetSCM_UPDM() uint32 {
	return (volatile.LoadUint32(&o.SCM.Reg) & 0x30000) >> 16
}

// PWM.SCUC: PWM Sync Channels Update Control Register
func (o *PWM_Type) SetSCUC_UPDULOCK(value uint32) {
	volatile.StoreUint32(&o.SCUC.Reg, volatile.LoadUint32(&o.SCUC.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSCUC_UPDULOCK() uint32 {
	return volatile.LoadUint32(&o.SCUC.Reg) & 0x1
}

// PWM.SCUP: PWM Sync Channels Update Period Register
func (o *PWM_Type) SetSCUP_UPR(value uint32) {
	volatile.StoreUint32(&o.SCUP.Reg, volatile.LoadUint32(&o.SCUP.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSCUP_UPR() uint32 {
	return volatile.LoadUint32(&o.SCUP.Reg) & 0xf
}
func (o *PWM_Type) SetSCUP_UPRCNT(value uint32) {
	volatile.StoreUint32(&o.SCUP.Reg, volatile.LoadUint32(&o.SCUP.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetSCUP_UPRCNT() uint32 {
	return (volatile.LoadUint32(&o.SCUP.Reg) & 0xf0) >> 4
}

// PWM.SCUPUPD: PWM Sync Channels Update Period Update Register
func (o *PWM_Type) SetSCUPUPD_UPRUPD(value uint32) {
	volatile.StoreUint32(&o.SCUPUPD.Reg, volatile.LoadUint32(&o.SCUPUPD.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSCUPUPD_UPRUPD() uint32 {
	return volatile.LoadUint32(&o.SCUPUPD.Reg) & 0xf
}

// PWM.IER2: PWM Interrupt Enable Register 2
func (o *PWM_Type) SetIER2_WRDY(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetIER2_WRDY() uint32 {
	return volatile.LoadUint32(&o.IER2.Reg) & 0x1
}
func (o *PWM_Type) SetIER2_UNRE(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetIER2_UNRE() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetIER2_CMPM0(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetIER2_CMPM0() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetIER2_CMPM1(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetIER2_CMPM1() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetIER2_CMPM2(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetIER2_CMPM2() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetIER2_CMPM3(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetIER2_CMPM3() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetIER2_CMPM4(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetIER2_CMPM4() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetIER2_CMPM5(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetIER2_CMPM5() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetIER2_CMPM6(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetIER2_CMPM6() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetIER2_CMPM7(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetIER2_CMPM7() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x8000) >> 15
}
func (o *PWM_Type) SetIER2_CMPU0(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetIER2_CMPU0() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetIER2_CMPU1(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetIER2_CMPU1() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetIER2_CMPU2(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetIER2_CMPU2() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetIER2_CMPU3(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetIER2_CMPU3() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x80000) >> 19
}
func (o *PWM_Type) SetIER2_CMPU4(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x100000)|value<<20)
}
func (o *PWM_Type) GetIER2_CMPU4() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x100000) >> 20
}
func (o *PWM_Type) SetIER2_CMPU5(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x200000)|value<<21)
}
func (o *PWM_Type) GetIER2_CMPU5() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x200000) >> 21
}
func (o *PWM_Type) SetIER2_CMPU6(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x400000)|value<<22)
}
func (o *PWM_Type) GetIER2_CMPU6() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x400000) >> 22
}
func (o *PWM_Type) SetIER2_CMPU7(value uint32) {
	volatile.StoreUint32(&o.IER2.Reg, volatile.LoadUint32(&o.IER2.Reg)&^(0x800000)|value<<23)
}
func (o *PWM_Type) GetIER2_CMPU7() uint32 {
	return (volatile.LoadUint32(&o.IER2.Reg) & 0x800000) >> 23
}

// PWM.IDR2: PWM Interrupt Disable Register 2
func (o *PWM_Type) SetIDR2_WRDY(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetIDR2_WRDY() uint32 {
	return volatile.LoadUint32(&o.IDR2.Reg) & 0x1
}
func (o *PWM_Type) SetIDR2_UNRE(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetIDR2_UNRE() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetIDR2_CMPM0(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetIDR2_CMPM0() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetIDR2_CMPM1(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetIDR2_CMPM1() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetIDR2_CMPM2(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetIDR2_CMPM2() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetIDR2_CMPM3(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetIDR2_CMPM3() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetIDR2_CMPM4(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetIDR2_CMPM4() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetIDR2_CMPM5(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetIDR2_CMPM5() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetIDR2_CMPM6(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetIDR2_CMPM6() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetIDR2_CMPM7(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetIDR2_CMPM7() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x8000) >> 15
}
func (o *PWM_Type) SetIDR2_CMPU0(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetIDR2_CMPU0() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetIDR2_CMPU1(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetIDR2_CMPU1() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetIDR2_CMPU2(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetIDR2_CMPU2() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetIDR2_CMPU3(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetIDR2_CMPU3() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x80000) >> 19
}
func (o *PWM_Type) SetIDR2_CMPU4(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x100000)|value<<20)
}
func (o *PWM_Type) GetIDR2_CMPU4() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x100000) >> 20
}
func (o *PWM_Type) SetIDR2_CMPU5(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x200000)|value<<21)
}
func (o *PWM_Type) GetIDR2_CMPU5() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x200000) >> 21
}
func (o *PWM_Type) SetIDR2_CMPU6(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x400000)|value<<22)
}
func (o *PWM_Type) GetIDR2_CMPU6() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x400000) >> 22
}
func (o *PWM_Type) SetIDR2_CMPU7(value uint32) {
	volatile.StoreUint32(&o.IDR2.Reg, volatile.LoadUint32(&o.IDR2.Reg)&^(0x800000)|value<<23)
}
func (o *PWM_Type) GetIDR2_CMPU7() uint32 {
	return (volatile.LoadUint32(&o.IDR2.Reg) & 0x800000) >> 23
}

// PWM.IMR2: PWM Interrupt Mask Register 2
func (o *PWM_Type) SetIMR2_WRDY(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetIMR2_WRDY() uint32 {
	return volatile.LoadUint32(&o.IMR2.Reg) & 0x1
}
func (o *PWM_Type) SetIMR2_UNRE(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetIMR2_UNRE() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetIMR2_CMPM0(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetIMR2_CMPM0() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetIMR2_CMPM1(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetIMR2_CMPM1() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetIMR2_CMPM2(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetIMR2_CMPM2() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetIMR2_CMPM3(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetIMR2_CMPM3() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetIMR2_CMPM4(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetIMR2_CMPM4() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetIMR2_CMPM5(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetIMR2_CMPM5() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetIMR2_CMPM6(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetIMR2_CMPM6() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetIMR2_CMPM7(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetIMR2_CMPM7() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x8000) >> 15
}
func (o *PWM_Type) SetIMR2_CMPU0(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetIMR2_CMPU0() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetIMR2_CMPU1(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetIMR2_CMPU1() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetIMR2_CMPU2(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetIMR2_CMPU2() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetIMR2_CMPU3(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetIMR2_CMPU3() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x80000) >> 19
}
func (o *PWM_Type) SetIMR2_CMPU4(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x100000)|value<<20)
}
func (o *PWM_Type) GetIMR2_CMPU4() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x100000) >> 20
}
func (o *PWM_Type) SetIMR2_CMPU5(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x200000)|value<<21)
}
func (o *PWM_Type) GetIMR2_CMPU5() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x200000) >> 21
}
func (o *PWM_Type) SetIMR2_CMPU6(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x400000)|value<<22)
}
func (o *PWM_Type) GetIMR2_CMPU6() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x400000) >> 22
}
func (o *PWM_Type) SetIMR2_CMPU7(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, volatile.LoadUint32(&o.IMR2.Reg)&^(0x800000)|value<<23)
}
func (o *PWM_Type) GetIMR2_CMPU7() uint32 {
	return (volatile.LoadUint32(&o.IMR2.Reg) & 0x800000) >> 23
}

// PWM.ISR2: PWM Interrupt Status Register 2
func (o *PWM_Type) SetISR2_WRDY(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetISR2_WRDY() uint32 {
	return volatile.LoadUint32(&o.ISR2.Reg) & 0x1
}
func (o *PWM_Type) SetISR2_UNRE(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetISR2_UNRE() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetISR2_CMPM0(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetISR2_CMPM0() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetISR2_CMPM1(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetISR2_CMPM1() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetISR2_CMPM2(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetISR2_CMPM2() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetISR2_CMPM3(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetISR2_CMPM3() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetISR2_CMPM4(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetISR2_CMPM4() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetISR2_CMPM5(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetISR2_CMPM5() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetISR2_CMPM6(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetISR2_CMPM6() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetISR2_CMPM7(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetISR2_CMPM7() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x8000) >> 15
}
func (o *PWM_Type) SetISR2_CMPU0(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetISR2_CMPU0() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetISR2_CMPU1(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetISR2_CMPU1() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetISR2_CMPU2(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetISR2_CMPU2() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetISR2_CMPU3(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetISR2_CMPU3() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x80000) >> 19
}
func (o *PWM_Type) SetISR2_CMPU4(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x100000)|value<<20)
}
func (o *PWM_Type) GetISR2_CMPU4() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x100000) >> 20
}
func (o *PWM_Type) SetISR2_CMPU5(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x200000)|value<<21)
}
func (o *PWM_Type) GetISR2_CMPU5() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x200000) >> 21
}
func (o *PWM_Type) SetISR2_CMPU6(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x400000)|value<<22)
}
func (o *PWM_Type) GetISR2_CMPU6() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x400000) >> 22
}
func (o *PWM_Type) SetISR2_CMPU7(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, volatile.LoadUint32(&o.ISR2.Reg)&^(0x800000)|value<<23)
}
func (o *PWM_Type) GetISR2_CMPU7() uint32 {
	return (volatile.LoadUint32(&o.ISR2.Reg) & 0x800000) >> 23
}

// PWM.OOV: PWM Output Override Value Register
func (o *PWM_Type) SetOOV_OOVH0(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetOOV_OOVH0() uint32 {
	return volatile.LoadUint32(&o.OOV.Reg) & 0x1
}
func (o *PWM_Type) SetOOV_OOVH1(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetOOV_OOVH1() uint32 {
	return (volatile.LoadUint32(&o.OOV.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetOOV_OOVH2(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetOOV_OOVH2() uint32 {
	return (volatile.LoadUint32(&o.OOV.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetOOV_OOVH3(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetOOV_OOVH3() uint32 {
	return (volatile.LoadUint32(&o.OOV.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetOOV_OOVL0(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetOOV_OOVL0() uint32 {
	return (volatile.LoadUint32(&o.OOV.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetOOV_OOVL1(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetOOV_OOVL1() uint32 {
	return (volatile.LoadUint32(&o.OOV.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetOOV_OOVL2(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetOOV_OOVL2() uint32 {
	return (volatile.LoadUint32(&o.OOV.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetOOV_OOVL3(value uint32) {
	volatile.StoreUint32(&o.OOV.Reg, volatile.LoadUint32(&o.OOV.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetOOV_OOVL3() uint32 {
	return (volatile.LoadUint32(&o.OOV.Reg) & 0x80000) >> 19
}

// PWM.OS: PWM Output Selection Register
func (o *PWM_Type) SetOS_OSH0(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetOS_OSH0() uint32 {
	return volatile.LoadUint32(&o.OS.Reg) & 0x1
}
func (o *PWM_Type) SetOS_OSH1(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetOS_OSH1() uint32 {
	return (volatile.LoadUint32(&o.OS.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetOS_OSH2(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetOS_OSH2() uint32 {
	return (volatile.LoadUint32(&o.OS.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetOS_OSH3(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetOS_OSH3() uint32 {
	return (volatile.LoadUint32(&o.OS.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetOS_OSL0(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetOS_OSL0() uint32 {
	return (volatile.LoadUint32(&o.OS.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetOS_OSL1(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetOS_OSL1() uint32 {
	return (volatile.LoadUint32(&o.OS.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetOS_OSL2(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetOS_OSL2() uint32 {
	return (volatile.LoadUint32(&o.OS.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetOS_OSL3(value uint32) {
	volatile.StoreUint32(&o.OS.Reg, volatile.LoadUint32(&o.OS.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetOS_OSL3() uint32 {
	return (volatile.LoadUint32(&o.OS.Reg) & 0x80000) >> 19
}

// PWM.OSS: PWM Output Selection Set Register
func (o *PWM_Type) SetOSS_OSSH0(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetOSS_OSSH0() uint32 {
	return volatile.LoadUint32(&o.OSS.Reg) & 0x1
}
func (o *PWM_Type) SetOSS_OSSH1(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetOSS_OSSH1() uint32 {
	return (volatile.LoadUint32(&o.OSS.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetOSS_OSSH2(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetOSS_OSSH2() uint32 {
	return (volatile.LoadUint32(&o.OSS.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetOSS_OSSH3(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetOSS_OSSH3() uint32 {
	return (volatile.LoadUint32(&o.OSS.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetOSS_OSSL0(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetOSS_OSSL0() uint32 {
	return (volatile.LoadUint32(&o.OSS.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetOSS_OSSL1(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetOSS_OSSL1() uint32 {
	return (volatile.LoadUint32(&o.OSS.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetOSS_OSSL2(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetOSS_OSSL2() uint32 {
	return (volatile.LoadUint32(&o.OSS.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetOSS_OSSL3(value uint32) {
	volatile.StoreUint32(&o.OSS.Reg, volatile.LoadUint32(&o.OSS.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetOSS_OSSL3() uint32 {
	return (volatile.LoadUint32(&o.OSS.Reg) & 0x80000) >> 19
}

// PWM.OSC: PWM Output Selection Clear Register
func (o *PWM_Type) SetOSC_OSCH0(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetOSC_OSCH0() uint32 {
	return volatile.LoadUint32(&o.OSC.Reg) & 0x1
}
func (o *PWM_Type) SetOSC_OSCH1(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetOSC_OSCH1() uint32 {
	return (volatile.LoadUint32(&o.OSC.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetOSC_OSCH2(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetOSC_OSCH2() uint32 {
	return (volatile.LoadUint32(&o.OSC.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetOSC_OSCH3(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetOSC_OSCH3() uint32 {
	return (volatile.LoadUint32(&o.OSC.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetOSC_OSCL0(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetOSC_OSCL0() uint32 {
	return (volatile.LoadUint32(&o.OSC.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetOSC_OSCL1(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetOSC_OSCL1() uint32 {
	return (volatile.LoadUint32(&o.OSC.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetOSC_OSCL2(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetOSC_OSCL2() uint32 {
	return (volatile.LoadUint32(&o.OSC.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetOSC_OSCL3(value uint32) {
	volatile.StoreUint32(&o.OSC.Reg, volatile.LoadUint32(&o.OSC.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetOSC_OSCL3() uint32 {
	return (volatile.LoadUint32(&o.OSC.Reg) & 0x80000) >> 19
}

// PWM.OSSUPD: PWM Output Selection Set Update Register
func (o *PWM_Type) SetOSSUPD_OSSUPH0(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetOSSUPD_OSSUPH0() uint32 {
	return volatile.LoadUint32(&o.OSSUPD.Reg) & 0x1
}
func (o *PWM_Type) SetOSSUPD_OSSUPH1(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetOSSUPD_OSSUPH1() uint32 {
	return (volatile.LoadUint32(&o.OSSUPD.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetOSSUPD_OSSUPH2(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetOSSUPD_OSSUPH2() uint32 {
	return (volatile.LoadUint32(&o.OSSUPD.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetOSSUPD_OSSUPH3(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetOSSUPD_OSSUPH3() uint32 {
	return (volatile.LoadUint32(&o.OSSUPD.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetOSSUPD_OSSUPL0(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetOSSUPD_OSSUPL0() uint32 {
	return (volatile.LoadUint32(&o.OSSUPD.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetOSSUPD_OSSUPL1(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetOSSUPD_OSSUPL1() uint32 {
	return (volatile.LoadUint32(&o.OSSUPD.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetOSSUPD_OSSUPL2(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetOSSUPD_OSSUPL2() uint32 {
	return (volatile.LoadUint32(&o.OSSUPD.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetOSSUPD_OSSUPL3(value uint32) {
	volatile.StoreUint32(&o.OSSUPD.Reg, volatile.LoadUint32(&o.OSSUPD.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetOSSUPD_OSSUPL3() uint32 {
	return (volatile.LoadUint32(&o.OSSUPD.Reg) & 0x80000) >> 19
}

// PWM.OSCUPD: PWM Output Selection Clear Update Register
func (o *PWM_Type) SetOSCUPD_OSCUPH0(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetOSCUPD_OSCUPH0() uint32 {
	return volatile.LoadUint32(&o.OSCUPD.Reg) & 0x1
}
func (o *PWM_Type) SetOSCUPD_OSCUPH1(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetOSCUPD_OSCUPH1() uint32 {
	return (volatile.LoadUint32(&o.OSCUPD.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetOSCUPD_OSCUPH2(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetOSCUPD_OSCUPH2() uint32 {
	return (volatile.LoadUint32(&o.OSCUPD.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetOSCUPD_OSCUPH3(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetOSCUPD_OSCUPH3() uint32 {
	return (volatile.LoadUint32(&o.OSCUPD.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetOSCUPD_OSCUPL0(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetOSCUPD_OSCUPL0() uint32 {
	return (volatile.LoadUint32(&o.OSCUPD.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetOSCUPD_OSCUPL1(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetOSCUPD_OSCUPL1() uint32 {
	return (volatile.LoadUint32(&o.OSCUPD.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetOSCUPD_OSCUPL2(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetOSCUPD_OSCUPL2() uint32 {
	return (volatile.LoadUint32(&o.OSCUPD.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetOSCUPD_OSCUPL3(value uint32) {
	volatile.StoreUint32(&o.OSCUPD.Reg, volatile.LoadUint32(&o.OSCUPD.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetOSCUPD_OSCUPL3() uint32 {
	return (volatile.LoadUint32(&o.OSCUPD.Reg) & 0x80000) >> 19
}

// PWM.FMR: PWM Fault Mode Register
func (o *PWM_Type) SetFMR_FPOL(value uint32) {
	volatile.StoreUint32(&o.FMR.Reg, volatile.LoadUint32(&o.FMR.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetFMR_FPOL() uint32 {
	return volatile.LoadUint32(&o.FMR.Reg) & 0xff
}
func (o *PWM_Type) SetFMR_FMOD(value uint32) {
	volatile.StoreUint32(&o.FMR.Reg, volatile.LoadUint32(&o.FMR.Reg)&^(0xff00)|value<<8)
}
func (o *PWM_Type) GetFMR_FMOD() uint32 {
	return (volatile.LoadUint32(&o.FMR.Reg) & 0xff00) >> 8
}
func (o *PWM_Type) SetFMR_FFIL(value uint32) {
	volatile.StoreUint32(&o.FMR.Reg, volatile.LoadUint32(&o.FMR.Reg)&^(0xff0000)|value<<16)
}
func (o *PWM_Type) GetFMR_FFIL() uint32 {
	return (volatile.LoadUint32(&o.FMR.Reg) & 0xff0000) >> 16
}

// PWM.FSR: PWM Fault Status Register
func (o *PWM_Type) SetFSR_FIV(value uint32) {
	volatile.StoreUint32(&o.FSR.Reg, volatile.LoadUint32(&o.FSR.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetFSR_FIV() uint32 {
	return volatile.LoadUint32(&o.FSR.Reg) & 0xff
}
func (o *PWM_Type) SetFSR_FS(value uint32) {
	volatile.StoreUint32(&o.FSR.Reg, volatile.LoadUint32(&o.FSR.Reg)&^(0xff00)|value<<8)
}
func (o *PWM_Type) GetFSR_FS() uint32 {
	return (volatile.LoadUint32(&o.FSR.Reg) & 0xff00) >> 8
}

// PWM.FCR: PWM Fault Clear Register
func (o *PWM_Type) SetFCR_FCLR(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetFCR_FCLR() uint32 {
	return volatile.LoadUint32(&o.FCR.Reg) & 0xff
}

// PWM.FPV: PWM Fault Protection Value Register
func (o *PWM_Type) SetFPV_FPVH0(value uint32) {
	volatile.StoreUint32(&o.FPV.Reg, volatile.LoadUint32(&o.FPV.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetFPV_FPVH0() uint32 {
	return volatile.LoadUint32(&o.FPV.Reg) & 0x1
}
func (o *PWM_Type) SetFPV_FPVH1(value uint32) {
	volatile.StoreUint32(&o.FPV.Reg, volatile.LoadUint32(&o.FPV.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetFPV_FPVH1() uint32 {
	return (volatile.LoadUint32(&o.FPV.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetFPV_FPVH2(value uint32) {
	volatile.StoreUint32(&o.FPV.Reg, volatile.LoadUint32(&o.FPV.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetFPV_FPVH2() uint32 {
	return (volatile.LoadUint32(&o.FPV.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetFPV_FPVH3(value uint32) {
	volatile.StoreUint32(&o.FPV.Reg, volatile.LoadUint32(&o.FPV.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetFPV_FPVH3() uint32 {
	return (volatile.LoadUint32(&o.FPV.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetFPV_FPVL0(value uint32) {
	volatile.StoreUint32(&o.FPV.Reg, volatile.LoadUint32(&o.FPV.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetFPV_FPVL0() uint32 {
	return (volatile.LoadUint32(&o.FPV.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetFPV_FPVL1(value uint32) {
	volatile.StoreUint32(&o.FPV.Reg, volatile.LoadUint32(&o.FPV.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetFPV_FPVL1() uint32 {
	return (volatile.LoadUint32(&o.FPV.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetFPV_FPVL2(value uint32) {
	volatile.StoreUint32(&o.FPV.Reg, volatile.LoadUint32(&o.FPV.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetFPV_FPVL2() uint32 {
	return (volatile.LoadUint32(&o.FPV.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetFPV_FPVL3(value uint32) {
	volatile.StoreUint32(&o.FPV.Reg, volatile.LoadUint32(&o.FPV.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetFPV_FPVL3() uint32 {
	return (volatile.LoadUint32(&o.FPV.Reg) & 0x80000) >> 19
}

// PWM.FPE: PWM Fault Protection Enable Register
func (o *PWM_Type) SetFPE_FPE0(value uint32) {
	volatile.StoreUint32(&o.FPE.Reg, volatile.LoadUint32(&o.FPE.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetFPE_FPE0() uint32 {
	return volatile.LoadUint32(&o.FPE.Reg) & 0xff
}
func (o *PWM_Type) SetFPE_FPE1(value uint32) {
	volatile.StoreUint32(&o.FPE.Reg, volatile.LoadUint32(&o.FPE.Reg)&^(0xff00)|value<<8)
}
func (o *PWM_Type) GetFPE_FPE1() uint32 {
	return (volatile.LoadUint32(&o.FPE.Reg) & 0xff00) >> 8
}
func (o *PWM_Type) SetFPE_FPE2(value uint32) {
	volatile.StoreUint32(&o.FPE.Reg, volatile.LoadUint32(&o.FPE.Reg)&^(0xff0000)|value<<16)
}
func (o *PWM_Type) GetFPE_FPE2() uint32 {
	return (volatile.LoadUint32(&o.FPE.Reg) & 0xff0000) >> 16
}
func (o *PWM_Type) SetFPE_FPE3(value uint32) {
	volatile.StoreUint32(&o.FPE.Reg, volatile.LoadUint32(&o.FPE.Reg)&^(0xff000000)|value<<24)
}
func (o *PWM_Type) GetFPE_FPE3() uint32 {
	return (volatile.LoadUint32(&o.FPE.Reg) & 0xff000000) >> 24
}

// PWM.ELMR: PWM Event Line 0 Mode Register
func (o *PWM_Type) SetELMR_CSEL0(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetELMR_CSEL0(idx int) uint32 {
	return volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x1
}
func (o *PWM_Type) SetELMR_CSEL1(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetELMR_CSEL1(idx int) uint32 {
	return (volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetELMR_CSEL2(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetELMR_CSEL2(idx int) uint32 {
	return (volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetELMR_CSEL3(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetELMR_CSEL3(idx int) uint32 {
	return (volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetELMR_CSEL4(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetELMR_CSEL4(idx int) uint32 {
	return (volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetELMR_CSEL5(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetELMR_CSEL5(idx int) uint32 {
	return (volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetELMR_CSEL6(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetELMR_CSEL6(idx int) uint32 {
	return (volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetELMR_CSEL7(idx int, value uint32) {
	volatile.StoreUint32(&o.ELMR[idx].Reg, volatile.LoadUint32(&o.ELMR[idx].Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetELMR_CSEL7(idx int) uint32 {
	return (volatile.LoadUint32(&o.ELMR[idx].Reg) & 0x80) >> 7
}

// PWM.SMMR: PWM Stepper Motor Mode Register
func (o *PWM_Type) SetSMMR_GCEN0(value uint32) {
	volatile.StoreUint32(&o.SMMR.Reg, volatile.LoadUint32(&o.SMMR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSMMR_GCEN0() uint32 {
	return volatile.LoadUint32(&o.SMMR.Reg) & 0x1
}
func (o *PWM_Type) SetSMMR_GCEN1(value uint32) {
	volatile.StoreUint32(&o.SMMR.Reg, volatile.LoadUint32(&o.SMMR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSMMR_GCEN1() uint32 {
	return (volatile.LoadUint32(&o.SMMR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSMMR_DOWN0(value uint32) {
	volatile.StoreUint32(&o.SMMR.Reg, volatile.LoadUint32(&o.SMMR.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetSMMR_DOWN0() uint32 {
	return (volatile.LoadUint32(&o.SMMR.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetSMMR_DOWN1(value uint32) {
	volatile.StoreUint32(&o.SMMR.Reg, volatile.LoadUint32(&o.SMMR.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetSMMR_DOWN1() uint32 {
	return (volatile.LoadUint32(&o.SMMR.Reg) & 0x20000) >> 17
}

// PWM.WPCR: PWM Write Protect Control Register
func (o *PWM_Type) SetWPCR_WPCMD(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x3)|value)
}
func (o *PWM_Type) GetWPCR_WPCMD() uint32 {
	return volatile.LoadUint32(&o.WPCR.Reg) & 0x3
}
func (o *PWM_Type) SetWPCR_WPRG0(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetWPCR_WPRG0() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetWPCR_WPRG1(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetWPCR_WPRG1() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetWPCR_WPRG2(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetWPCR_WPRG2() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetWPCR_WPRG3(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetWPCR_WPRG3() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetWPCR_WPRG4(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetWPCR_WPRG4() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetWPCR_WPRG5(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetWPCR_WPRG5() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetWPCR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *PWM_Type) GetWPCR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0xffffff00) >> 8
}

// PWM.WPSR: PWM Write Protect Status Register
func (o *PWM_Type) SetWPSR_WPSWS0(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetWPSR_WPSWS0() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *PWM_Type) SetWPSR_WPSWS1(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetWPSR_WPSWS1() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetWPSR_WPSWS2(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetWPSR_WPSWS2() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetWPSR_WPSWS3(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetWPSR_WPSWS3() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetWPSR_WPSWS4(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetWPSR_WPSWS4() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetWPSR_WPSWS5(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetWPSR_WPSWS5() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetWPSR_WPVS() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetWPSR_WPHWS0(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetWPSR_WPHWS0() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetWPSR_WPHWS1(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetWPSR_WPHWS1() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetWPSR_WPHWS2(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetWPSR_WPHWS2() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetWPSR_WPHWS3(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetWPSR_WPHWS3() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetWPSR_WPHWS4(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetWPSR_WPHWS4() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetWPSR_WPHWS5(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetWPSR_WPHWS5() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff0000) >> 16
}

// PWM.CMPV0: PWM Comparison 0 Value Register
func (o *PWM_Type) SetCMPV0_CV(value uint32) {
	volatile.StoreUint32(&o.CMPV0.Reg, volatile.LoadUint32(&o.CMPV0.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPV0_CV() uint32 {
	return volatile.LoadUint32(&o.CMPV0.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPV0_CVM(value uint32) {
	volatile.StoreUint32(&o.CMPV0.Reg, volatile.LoadUint32(&o.CMPV0.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPV0_CVM() uint32 {
	return (volatile.LoadUint32(&o.CMPV0.Reg) & 0x1000000) >> 24
}

// PWM.CMPVUPD0: PWM Comparison 0 Value Update Register
func (o *PWM_Type) SetCMPVUPD0_CVUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD0.Reg, volatile.LoadUint32(&o.CMPVUPD0.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPVUPD0_CVUPD() uint32 {
	return volatile.LoadUint32(&o.CMPVUPD0.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPVUPD0_CVMUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD0.Reg, volatile.LoadUint32(&o.CMPVUPD0.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPVUPD0_CVMUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPVUPD0.Reg) & 0x1000000) >> 24
}

// PWM.CMPM0: PWM Comparison 0 Mode Register
func (o *PWM_Type) SetCMPM0_CEN(value uint32) {
	volatile.StoreUint32(&o.CMPM0.Reg, volatile.LoadUint32(&o.CMPM0.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPM0_CEN() uint32 {
	return volatile.LoadUint32(&o.CMPM0.Reg) & 0x1
}
func (o *PWM_Type) SetCMPM0_CTR(value uint32) {
	volatile.StoreUint32(&o.CMPM0.Reg, volatile.LoadUint32(&o.CMPM0.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPM0_CTR() uint32 {
	return (volatile.LoadUint32(&o.CMPM0.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPM0_CPR(value uint32) {
	volatile.StoreUint32(&o.CMPM0.Reg, volatile.LoadUint32(&o.CMPM0.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPM0_CPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM0.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPM0_CPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM0.Reg, volatile.LoadUint32(&o.CMPM0.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetCMPM0_CPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM0.Reg) & 0xf000) >> 12
}
func (o *PWM_Type) SetCMPM0_CUPR(value uint32) {
	volatile.StoreUint32(&o.CMPM0.Reg, volatile.LoadUint32(&o.CMPM0.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPM0_CUPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM0.Reg) & 0xf0000) >> 16
}
func (o *PWM_Type) SetCMPM0_CUPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM0.Reg, volatile.LoadUint32(&o.CMPM0.Reg)&^(0xf00000)|value<<20)
}
func (o *PWM_Type) GetCMPM0_CUPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM0.Reg) & 0xf00000) >> 20
}

// PWM.CMPMUPD0: PWM Comparison 0 Mode Update Register
func (o *PWM_Type) SetCMPMUPD0_CENUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD0.Reg, volatile.LoadUint32(&o.CMPMUPD0.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPMUPD0_CENUPD() uint32 {
	return volatile.LoadUint32(&o.CMPMUPD0.Reg) & 0x1
}
func (o *PWM_Type) SetCMPMUPD0_CTRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD0.Reg, volatile.LoadUint32(&o.CMPMUPD0.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPMUPD0_CTRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD0.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPMUPD0_CPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD0.Reg, volatile.LoadUint32(&o.CMPMUPD0.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPMUPD0_CPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD0.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPMUPD0_CUPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD0.Reg, volatile.LoadUint32(&o.CMPMUPD0.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPMUPD0_CUPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD0.Reg) & 0xf0000) >> 16
}

// PWM.CMPV1: PWM Comparison 1 Value Register
func (o *PWM_Type) SetCMPV1_CV(value uint32) {
	volatile.StoreUint32(&o.CMPV1.Reg, volatile.LoadUint32(&o.CMPV1.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPV1_CV() uint32 {
	return volatile.LoadUint32(&o.CMPV1.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPV1_CVM(value uint32) {
	volatile.StoreUint32(&o.CMPV1.Reg, volatile.LoadUint32(&o.CMPV1.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPV1_CVM() uint32 {
	return (volatile.LoadUint32(&o.CMPV1.Reg) & 0x1000000) >> 24
}

// PWM.CMPVUPD1: PWM Comparison 1 Value Update Register
func (o *PWM_Type) SetCMPVUPD1_CVUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD1.Reg, volatile.LoadUint32(&o.CMPVUPD1.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPVUPD1_CVUPD() uint32 {
	return volatile.LoadUint32(&o.CMPVUPD1.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPVUPD1_CVMUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD1.Reg, volatile.LoadUint32(&o.CMPVUPD1.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPVUPD1_CVMUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPVUPD1.Reg) & 0x1000000) >> 24
}

// PWM.CMPM1: PWM Comparison 1 Mode Register
func (o *PWM_Type) SetCMPM1_CEN(value uint32) {
	volatile.StoreUint32(&o.CMPM1.Reg, volatile.LoadUint32(&o.CMPM1.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPM1_CEN() uint32 {
	return volatile.LoadUint32(&o.CMPM1.Reg) & 0x1
}
func (o *PWM_Type) SetCMPM1_CTR(value uint32) {
	volatile.StoreUint32(&o.CMPM1.Reg, volatile.LoadUint32(&o.CMPM1.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPM1_CTR() uint32 {
	return (volatile.LoadUint32(&o.CMPM1.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPM1_CPR(value uint32) {
	volatile.StoreUint32(&o.CMPM1.Reg, volatile.LoadUint32(&o.CMPM1.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPM1_CPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM1.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPM1_CPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM1.Reg, volatile.LoadUint32(&o.CMPM1.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetCMPM1_CPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM1.Reg) & 0xf000) >> 12
}
func (o *PWM_Type) SetCMPM1_CUPR(value uint32) {
	volatile.StoreUint32(&o.CMPM1.Reg, volatile.LoadUint32(&o.CMPM1.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPM1_CUPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM1.Reg) & 0xf0000) >> 16
}
func (o *PWM_Type) SetCMPM1_CUPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM1.Reg, volatile.LoadUint32(&o.CMPM1.Reg)&^(0xf00000)|value<<20)
}
func (o *PWM_Type) GetCMPM1_CUPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM1.Reg) & 0xf00000) >> 20
}

// PWM.CMPMUPD1: PWM Comparison 1 Mode Update Register
func (o *PWM_Type) SetCMPMUPD1_CENUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD1.Reg, volatile.LoadUint32(&o.CMPMUPD1.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPMUPD1_CENUPD() uint32 {
	return volatile.LoadUint32(&o.CMPMUPD1.Reg) & 0x1
}
func (o *PWM_Type) SetCMPMUPD1_CTRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD1.Reg, volatile.LoadUint32(&o.CMPMUPD1.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPMUPD1_CTRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD1.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPMUPD1_CPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD1.Reg, volatile.LoadUint32(&o.CMPMUPD1.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPMUPD1_CPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD1.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPMUPD1_CUPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD1.Reg, volatile.LoadUint32(&o.CMPMUPD1.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPMUPD1_CUPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD1.Reg) & 0xf0000) >> 16
}

// PWM.CMPV2: PWM Comparison 2 Value Register
func (o *PWM_Type) SetCMPV2_CV(value uint32) {
	volatile.StoreUint32(&o.CMPV2.Reg, volatile.LoadUint32(&o.CMPV2.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPV2_CV() uint32 {
	return volatile.LoadUint32(&o.CMPV2.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPV2_CVM(value uint32) {
	volatile.StoreUint32(&o.CMPV2.Reg, volatile.LoadUint32(&o.CMPV2.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPV2_CVM() uint32 {
	return (volatile.LoadUint32(&o.CMPV2.Reg) & 0x1000000) >> 24
}

// PWM.CMPVUPD2: PWM Comparison 2 Value Update Register
func (o *PWM_Type) SetCMPVUPD2_CVUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD2.Reg, volatile.LoadUint32(&o.CMPVUPD2.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPVUPD2_CVUPD() uint32 {
	return volatile.LoadUint32(&o.CMPVUPD2.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPVUPD2_CVMUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD2.Reg, volatile.LoadUint32(&o.CMPVUPD2.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPVUPD2_CVMUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPVUPD2.Reg) & 0x1000000) >> 24
}

// PWM.CMPM2: PWM Comparison 2 Mode Register
func (o *PWM_Type) SetCMPM2_CEN(value uint32) {
	volatile.StoreUint32(&o.CMPM2.Reg, volatile.LoadUint32(&o.CMPM2.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPM2_CEN() uint32 {
	return volatile.LoadUint32(&o.CMPM2.Reg) & 0x1
}
func (o *PWM_Type) SetCMPM2_CTR(value uint32) {
	volatile.StoreUint32(&o.CMPM2.Reg, volatile.LoadUint32(&o.CMPM2.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPM2_CTR() uint32 {
	return (volatile.LoadUint32(&o.CMPM2.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPM2_CPR(value uint32) {
	volatile.StoreUint32(&o.CMPM2.Reg, volatile.LoadUint32(&o.CMPM2.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPM2_CPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM2.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPM2_CPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM2.Reg, volatile.LoadUint32(&o.CMPM2.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetCMPM2_CPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM2.Reg) & 0xf000) >> 12
}
func (o *PWM_Type) SetCMPM2_CUPR(value uint32) {
	volatile.StoreUint32(&o.CMPM2.Reg, volatile.LoadUint32(&o.CMPM2.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPM2_CUPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM2.Reg) & 0xf0000) >> 16
}
func (o *PWM_Type) SetCMPM2_CUPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM2.Reg, volatile.LoadUint32(&o.CMPM2.Reg)&^(0xf00000)|value<<20)
}
func (o *PWM_Type) GetCMPM2_CUPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM2.Reg) & 0xf00000) >> 20
}

// PWM.CMPMUPD2: PWM Comparison 2 Mode Update Register
func (o *PWM_Type) SetCMPMUPD2_CENUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD2.Reg, volatile.LoadUint32(&o.CMPMUPD2.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPMUPD2_CENUPD() uint32 {
	return volatile.LoadUint32(&o.CMPMUPD2.Reg) & 0x1
}
func (o *PWM_Type) SetCMPMUPD2_CTRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD2.Reg, volatile.LoadUint32(&o.CMPMUPD2.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPMUPD2_CTRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD2.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPMUPD2_CPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD2.Reg, volatile.LoadUint32(&o.CMPMUPD2.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPMUPD2_CPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD2.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPMUPD2_CUPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD2.Reg, volatile.LoadUint32(&o.CMPMUPD2.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPMUPD2_CUPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD2.Reg) & 0xf0000) >> 16
}

// PWM.CMPV3: PWM Comparison 3 Value Register
func (o *PWM_Type) SetCMPV3_CV(value uint32) {
	volatile.StoreUint32(&o.CMPV3.Reg, volatile.LoadUint32(&o.CMPV3.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPV3_CV() uint32 {
	return volatile.LoadUint32(&o.CMPV3.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPV3_CVM(value uint32) {
	volatile.StoreUint32(&o.CMPV3.Reg, volatile.LoadUint32(&o.CMPV3.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPV3_CVM() uint32 {
	return (volatile.LoadUint32(&o.CMPV3.Reg) & 0x1000000) >> 24
}

// PWM.CMPVUPD3: PWM Comparison 3 Value Update Register
func (o *PWM_Type) SetCMPVUPD3_CVUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD3.Reg, volatile.LoadUint32(&o.CMPVUPD3.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPVUPD3_CVUPD() uint32 {
	return volatile.LoadUint32(&o.CMPVUPD3.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPVUPD3_CVMUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD3.Reg, volatile.LoadUint32(&o.CMPVUPD3.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPVUPD3_CVMUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPVUPD3.Reg) & 0x1000000) >> 24
}

// PWM.CMPM3: PWM Comparison 3 Mode Register
func (o *PWM_Type) SetCMPM3_CEN(value uint32) {
	volatile.StoreUint32(&o.CMPM3.Reg, volatile.LoadUint32(&o.CMPM3.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPM3_CEN() uint32 {
	return volatile.LoadUint32(&o.CMPM3.Reg) & 0x1
}
func (o *PWM_Type) SetCMPM3_CTR(value uint32) {
	volatile.StoreUint32(&o.CMPM3.Reg, volatile.LoadUint32(&o.CMPM3.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPM3_CTR() uint32 {
	return (volatile.LoadUint32(&o.CMPM3.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPM3_CPR(value uint32) {
	volatile.StoreUint32(&o.CMPM3.Reg, volatile.LoadUint32(&o.CMPM3.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPM3_CPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM3.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPM3_CPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM3.Reg, volatile.LoadUint32(&o.CMPM3.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetCMPM3_CPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM3.Reg) & 0xf000) >> 12
}
func (o *PWM_Type) SetCMPM3_CUPR(value uint32) {
	volatile.StoreUint32(&o.CMPM3.Reg, volatile.LoadUint32(&o.CMPM3.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPM3_CUPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM3.Reg) & 0xf0000) >> 16
}
func (o *PWM_Type) SetCMPM3_CUPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM3.Reg, volatile.LoadUint32(&o.CMPM3.Reg)&^(0xf00000)|value<<20)
}
func (o *PWM_Type) GetCMPM3_CUPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM3.Reg) & 0xf00000) >> 20
}

// PWM.CMPMUPD3: PWM Comparison 3 Mode Update Register
func (o *PWM_Type) SetCMPMUPD3_CENUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD3.Reg, volatile.LoadUint32(&o.CMPMUPD3.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPMUPD3_CENUPD() uint32 {
	return volatile.LoadUint32(&o.CMPMUPD3.Reg) & 0x1
}
func (o *PWM_Type) SetCMPMUPD3_CTRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD3.Reg, volatile.LoadUint32(&o.CMPMUPD3.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPMUPD3_CTRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD3.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPMUPD3_CPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD3.Reg, volatile.LoadUint32(&o.CMPMUPD3.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPMUPD3_CPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD3.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPMUPD3_CUPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD3.Reg, volatile.LoadUint32(&o.CMPMUPD3.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPMUPD3_CUPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD3.Reg) & 0xf0000) >> 16
}

// PWM.CMPV4: PWM Comparison 4 Value Register
func (o *PWM_Type) SetCMPV4_CV(value uint32) {
	volatile.StoreUint32(&o.CMPV4.Reg, volatile.LoadUint32(&o.CMPV4.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPV4_CV() uint32 {
	return volatile.LoadUint32(&o.CMPV4.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPV4_CVM(value uint32) {
	volatile.StoreUint32(&o.CMPV4.Reg, volatile.LoadUint32(&o.CMPV4.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPV4_CVM() uint32 {
	return (volatile.LoadUint32(&o.CMPV4.Reg) & 0x1000000) >> 24
}

// PWM.CMPVUPD4: PWM Comparison 4 Value Update Register
func (o *PWM_Type) SetCMPVUPD4_CVUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD4.Reg, volatile.LoadUint32(&o.CMPVUPD4.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPVUPD4_CVUPD() uint32 {
	return volatile.LoadUint32(&o.CMPVUPD4.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPVUPD4_CVMUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD4.Reg, volatile.LoadUint32(&o.CMPVUPD4.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPVUPD4_CVMUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPVUPD4.Reg) & 0x1000000) >> 24
}

// PWM.CMPM4: PWM Comparison 4 Mode Register
func (o *PWM_Type) SetCMPM4_CEN(value uint32) {
	volatile.StoreUint32(&o.CMPM4.Reg, volatile.LoadUint32(&o.CMPM4.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPM4_CEN() uint32 {
	return volatile.LoadUint32(&o.CMPM4.Reg) & 0x1
}
func (o *PWM_Type) SetCMPM4_CTR(value uint32) {
	volatile.StoreUint32(&o.CMPM4.Reg, volatile.LoadUint32(&o.CMPM4.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPM4_CTR() uint32 {
	return (volatile.LoadUint32(&o.CMPM4.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPM4_CPR(value uint32) {
	volatile.StoreUint32(&o.CMPM4.Reg, volatile.LoadUint32(&o.CMPM4.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPM4_CPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM4.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPM4_CPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM4.Reg, volatile.LoadUint32(&o.CMPM4.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetCMPM4_CPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM4.Reg) & 0xf000) >> 12
}
func (o *PWM_Type) SetCMPM4_CUPR(value uint32) {
	volatile.StoreUint32(&o.CMPM4.Reg, volatile.LoadUint32(&o.CMPM4.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPM4_CUPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM4.Reg) & 0xf0000) >> 16
}
func (o *PWM_Type) SetCMPM4_CUPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM4.Reg, volatile.LoadUint32(&o.CMPM4.Reg)&^(0xf00000)|value<<20)
}
func (o *PWM_Type) GetCMPM4_CUPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM4.Reg) & 0xf00000) >> 20
}

// PWM.CMPMUPD4: PWM Comparison 4 Mode Update Register
func (o *PWM_Type) SetCMPMUPD4_CENUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD4.Reg, volatile.LoadUint32(&o.CMPMUPD4.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPMUPD4_CENUPD() uint32 {
	return volatile.LoadUint32(&o.CMPMUPD4.Reg) & 0x1
}
func (o *PWM_Type) SetCMPMUPD4_CTRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD4.Reg, volatile.LoadUint32(&o.CMPMUPD4.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPMUPD4_CTRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD4.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPMUPD4_CPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD4.Reg, volatile.LoadUint32(&o.CMPMUPD4.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPMUPD4_CPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD4.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPMUPD4_CUPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD4.Reg, volatile.LoadUint32(&o.CMPMUPD4.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPMUPD4_CUPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD4.Reg) & 0xf0000) >> 16
}

// PWM.CMPV5: PWM Comparison 5 Value Register
func (o *PWM_Type) SetCMPV5_CV(value uint32) {
	volatile.StoreUint32(&o.CMPV5.Reg, volatile.LoadUint32(&o.CMPV5.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPV5_CV() uint32 {
	return volatile.LoadUint32(&o.CMPV5.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPV5_CVM(value uint32) {
	volatile.StoreUint32(&o.CMPV5.Reg, volatile.LoadUint32(&o.CMPV5.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPV5_CVM() uint32 {
	return (volatile.LoadUint32(&o.CMPV5.Reg) & 0x1000000) >> 24
}

// PWM.CMPVUPD5: PWM Comparison 5 Value Update Register
func (o *PWM_Type) SetCMPVUPD5_CVUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD5.Reg, volatile.LoadUint32(&o.CMPVUPD5.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPVUPD5_CVUPD() uint32 {
	return volatile.LoadUint32(&o.CMPVUPD5.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPVUPD5_CVMUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD5.Reg, volatile.LoadUint32(&o.CMPVUPD5.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPVUPD5_CVMUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPVUPD5.Reg) & 0x1000000) >> 24
}

// PWM.CMPM5: PWM Comparison 5 Mode Register
func (o *PWM_Type) SetCMPM5_CEN(value uint32) {
	volatile.StoreUint32(&o.CMPM5.Reg, volatile.LoadUint32(&o.CMPM5.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPM5_CEN() uint32 {
	return volatile.LoadUint32(&o.CMPM5.Reg) & 0x1
}
func (o *PWM_Type) SetCMPM5_CTR(value uint32) {
	volatile.StoreUint32(&o.CMPM5.Reg, volatile.LoadUint32(&o.CMPM5.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPM5_CTR() uint32 {
	return (volatile.LoadUint32(&o.CMPM5.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPM5_CPR(value uint32) {
	volatile.StoreUint32(&o.CMPM5.Reg, volatile.LoadUint32(&o.CMPM5.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPM5_CPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM5.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPM5_CPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM5.Reg, volatile.LoadUint32(&o.CMPM5.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetCMPM5_CPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM5.Reg) & 0xf000) >> 12
}
func (o *PWM_Type) SetCMPM5_CUPR(value uint32) {
	volatile.StoreUint32(&o.CMPM5.Reg, volatile.LoadUint32(&o.CMPM5.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPM5_CUPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM5.Reg) & 0xf0000) >> 16
}
func (o *PWM_Type) SetCMPM5_CUPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM5.Reg, volatile.LoadUint32(&o.CMPM5.Reg)&^(0xf00000)|value<<20)
}
func (o *PWM_Type) GetCMPM5_CUPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM5.Reg) & 0xf00000) >> 20
}

// PWM.CMPMUPD5: PWM Comparison 5 Mode Update Register
func (o *PWM_Type) SetCMPMUPD5_CENUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD5.Reg, volatile.LoadUint32(&o.CMPMUPD5.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPMUPD5_CENUPD() uint32 {
	return volatile.LoadUint32(&o.CMPMUPD5.Reg) & 0x1
}
func (o *PWM_Type) SetCMPMUPD5_CTRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD5.Reg, volatile.LoadUint32(&o.CMPMUPD5.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPMUPD5_CTRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD5.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPMUPD5_CPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD5.Reg, volatile.LoadUint32(&o.CMPMUPD5.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPMUPD5_CPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD5.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPMUPD5_CUPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD5.Reg, volatile.LoadUint32(&o.CMPMUPD5.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPMUPD5_CUPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD5.Reg) & 0xf0000) >> 16
}

// PWM.CMPV6: PWM Comparison 6 Value Register
func (o *PWM_Type) SetCMPV6_CV(value uint32) {
	volatile.StoreUint32(&o.CMPV6.Reg, volatile.LoadUint32(&o.CMPV6.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPV6_CV() uint32 {
	return volatile.LoadUint32(&o.CMPV6.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPV6_CVM(value uint32) {
	volatile.StoreUint32(&o.CMPV6.Reg, volatile.LoadUint32(&o.CMPV6.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPV6_CVM() uint32 {
	return (volatile.LoadUint32(&o.CMPV6.Reg) & 0x1000000) >> 24
}

// PWM.CMPVUPD6: PWM Comparison 6 Value Update Register
func (o *PWM_Type) SetCMPVUPD6_CVUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD6.Reg, volatile.LoadUint32(&o.CMPVUPD6.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPVUPD6_CVUPD() uint32 {
	return volatile.LoadUint32(&o.CMPVUPD6.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPVUPD6_CVMUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD6.Reg, volatile.LoadUint32(&o.CMPVUPD6.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPVUPD6_CVMUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPVUPD6.Reg) & 0x1000000) >> 24
}

// PWM.CMPM6: PWM Comparison 6 Mode Register
func (o *PWM_Type) SetCMPM6_CEN(value uint32) {
	volatile.StoreUint32(&o.CMPM6.Reg, volatile.LoadUint32(&o.CMPM6.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPM6_CEN() uint32 {
	return volatile.LoadUint32(&o.CMPM6.Reg) & 0x1
}
func (o *PWM_Type) SetCMPM6_CTR(value uint32) {
	volatile.StoreUint32(&o.CMPM6.Reg, volatile.LoadUint32(&o.CMPM6.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPM6_CTR() uint32 {
	return (volatile.LoadUint32(&o.CMPM6.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPM6_CPR(value uint32) {
	volatile.StoreUint32(&o.CMPM6.Reg, volatile.LoadUint32(&o.CMPM6.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPM6_CPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM6.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPM6_CPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM6.Reg, volatile.LoadUint32(&o.CMPM6.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetCMPM6_CPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM6.Reg) & 0xf000) >> 12
}
func (o *PWM_Type) SetCMPM6_CUPR(value uint32) {
	volatile.StoreUint32(&o.CMPM6.Reg, volatile.LoadUint32(&o.CMPM6.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPM6_CUPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM6.Reg) & 0xf0000) >> 16
}
func (o *PWM_Type) SetCMPM6_CUPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM6.Reg, volatile.LoadUint32(&o.CMPM6.Reg)&^(0xf00000)|value<<20)
}
func (o *PWM_Type) GetCMPM6_CUPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM6.Reg) & 0xf00000) >> 20
}

// PWM.CMPMUPD6: PWM Comparison 6 Mode Update Register
func (o *PWM_Type) SetCMPMUPD6_CENUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD6.Reg, volatile.LoadUint32(&o.CMPMUPD6.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPMUPD6_CENUPD() uint32 {
	return volatile.LoadUint32(&o.CMPMUPD6.Reg) & 0x1
}
func (o *PWM_Type) SetCMPMUPD6_CTRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD6.Reg, volatile.LoadUint32(&o.CMPMUPD6.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPMUPD6_CTRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD6.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPMUPD6_CPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD6.Reg, volatile.LoadUint32(&o.CMPMUPD6.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPMUPD6_CPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD6.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPMUPD6_CUPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD6.Reg, volatile.LoadUint32(&o.CMPMUPD6.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPMUPD6_CUPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD6.Reg) & 0xf0000) >> 16
}

// PWM.CMPV7: PWM Comparison 7 Value Register
func (o *PWM_Type) SetCMPV7_CV(value uint32) {
	volatile.StoreUint32(&o.CMPV7.Reg, volatile.LoadUint32(&o.CMPV7.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPV7_CV() uint32 {
	return volatile.LoadUint32(&o.CMPV7.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPV7_CVM(value uint32) {
	volatile.StoreUint32(&o.CMPV7.Reg, volatile.LoadUint32(&o.CMPV7.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPV7_CVM() uint32 {
	return (volatile.LoadUint32(&o.CMPV7.Reg) & 0x1000000) >> 24
}

// PWM.CMPVUPD7: PWM Comparison 7 Value Update Register
func (o *PWM_Type) SetCMPVUPD7_CVUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD7.Reg, volatile.LoadUint32(&o.CMPVUPD7.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCMPVUPD7_CVUPD() uint32 {
	return volatile.LoadUint32(&o.CMPVUPD7.Reg) & 0xffffff
}
func (o *PWM_Type) SetCMPVUPD7_CVMUPD(value uint32) {
	volatile.StoreUint32(&o.CMPVUPD7.Reg, volatile.LoadUint32(&o.CMPVUPD7.Reg)&^(0x1000000)|value<<24)
}
func (o *PWM_Type) GetCMPVUPD7_CVMUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPVUPD7.Reg) & 0x1000000) >> 24
}

// PWM.CMPM7: PWM Comparison 7 Mode Register
func (o *PWM_Type) SetCMPM7_CEN(value uint32) {
	volatile.StoreUint32(&o.CMPM7.Reg, volatile.LoadUint32(&o.CMPM7.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPM7_CEN() uint32 {
	return volatile.LoadUint32(&o.CMPM7.Reg) & 0x1
}
func (o *PWM_Type) SetCMPM7_CTR(value uint32) {
	volatile.StoreUint32(&o.CMPM7.Reg, volatile.LoadUint32(&o.CMPM7.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPM7_CTR() uint32 {
	return (volatile.LoadUint32(&o.CMPM7.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPM7_CPR(value uint32) {
	volatile.StoreUint32(&o.CMPM7.Reg, volatile.LoadUint32(&o.CMPM7.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPM7_CPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM7.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPM7_CPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM7.Reg, volatile.LoadUint32(&o.CMPM7.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetCMPM7_CPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM7.Reg) & 0xf000) >> 12
}
func (o *PWM_Type) SetCMPM7_CUPR(value uint32) {
	volatile.StoreUint32(&o.CMPM7.Reg, volatile.LoadUint32(&o.CMPM7.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPM7_CUPR() uint32 {
	return (volatile.LoadUint32(&o.CMPM7.Reg) & 0xf0000) >> 16
}
func (o *PWM_Type) SetCMPM7_CUPRCNT(value uint32) {
	volatile.StoreUint32(&o.CMPM7.Reg, volatile.LoadUint32(&o.CMPM7.Reg)&^(0xf00000)|value<<20)
}
func (o *PWM_Type) GetCMPM7_CUPRCNT() uint32 {
	return (volatile.LoadUint32(&o.CMPM7.Reg) & 0xf00000) >> 20
}

// PWM.CMPMUPD7: PWM Comparison 7 Mode Update Register
func (o *PWM_Type) SetCMPMUPD7_CENUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD7.Reg, volatile.LoadUint32(&o.CMPMUPD7.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCMPMUPD7_CENUPD() uint32 {
	return volatile.LoadUint32(&o.CMPMUPD7.Reg) & 0x1
}
func (o *PWM_Type) SetCMPMUPD7_CTRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD7.Reg, volatile.LoadUint32(&o.CMPMUPD7.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetCMPMUPD7_CTRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD7.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetCMPMUPD7_CPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD7.Reg, volatile.LoadUint32(&o.CMPMUPD7.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetCMPMUPD7_CPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD7.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetCMPMUPD7_CUPRUPD(value uint32) {
	volatile.StoreUint32(&o.CMPMUPD7.Reg, volatile.LoadUint32(&o.CMPMUPD7.Reg)&^(0xf0000)|value<<16)
}
func (o *PWM_Type) GetCMPMUPD7_CUPRUPD() uint32 {
	return (volatile.LoadUint32(&o.CMPMUPD7.Reg) & 0xf0000) >> 16
}

// PWM.CMR0: PWM Channel Mode Register (ch_num = 0)
func (o *PWM_Type) SetCMR0_CPRE(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetCMR0_CPRE() uint32 {
	return volatile.LoadUint32(&o.CMR0.Reg) & 0xf
}
func (o *PWM_Type) SetCMR0_CALG(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetCMR0_CALG() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetCMR0_CPOL(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetCMR0_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetCMR0_CES(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetCMR0_CES() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetCMR0_DTE(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetCMR0_DTE() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetCMR0_DTHI(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetCMR0_DTHI() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetCMR0_DTLI(value uint32) {
	volatile.StoreUint32(&o.CMR0.Reg, volatile.LoadUint32(&o.CMR0.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetCMR0_DTLI() uint32 {
	return (volatile.LoadUint32(&o.CMR0.Reg) & 0x40000) >> 18
}

// PWM.CDTY0: PWM Channel Duty Cycle Register (ch_num = 0)
func (o *PWM_Type) SetCDTY0_CDTY(value uint32) {
	volatile.StoreUint32(&o.CDTY0.Reg, volatile.LoadUint32(&o.CDTY0.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCDTY0_CDTY() uint32 {
	return volatile.LoadUint32(&o.CDTY0.Reg) & 0xffffff
}

// PWM.CDTYUPD0: PWM Channel Duty Cycle Update Register (ch_num = 0)
func (o *PWM_Type) SetCDTYUPD0_CDTYUPD(value uint32) {
	volatile.StoreUint32(&o.CDTYUPD0.Reg, volatile.LoadUint32(&o.CDTYUPD0.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCDTYUPD0_CDTYUPD() uint32 {
	return volatile.LoadUint32(&o.CDTYUPD0.Reg) & 0xffffff
}

// PWM.CPRD0: PWM Channel Period Register (ch_num = 0)
func (o *PWM_Type) SetCPRD0_CPRD(value uint32) {
	volatile.StoreUint32(&o.CPRD0.Reg, volatile.LoadUint32(&o.CPRD0.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCPRD0_CPRD() uint32 {
	return volatile.LoadUint32(&o.CPRD0.Reg) & 0xffffff
}

// PWM.CPRDUPD0: PWM Channel Period Update Register (ch_num = 0)
func (o *PWM_Type) SetCPRDUPD0_CPRDUPD(value uint32) {
	volatile.StoreUint32(&o.CPRDUPD0.Reg, volatile.LoadUint32(&o.CPRDUPD0.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCPRDUPD0_CPRDUPD() uint32 {
	return volatile.LoadUint32(&o.CPRDUPD0.Reg) & 0xffffff
}

// PWM.CCNT0: PWM Channel Counter Register (ch_num = 0)
func (o *PWM_Type) SetCCNT0_CNT(value uint32) {
	volatile.StoreUint32(&o.CCNT0.Reg, volatile.LoadUint32(&o.CCNT0.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCCNT0_CNT() uint32 {
	return volatile.LoadUint32(&o.CCNT0.Reg) & 0xffffff
}

// PWM.DT0: PWM Channel Dead Time Register (ch_num = 0)
func (o *PWM_Type) SetDT0_DTH(value uint32) {
	volatile.StoreUint32(&o.DT0.Reg, volatile.LoadUint32(&o.DT0.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetDT0_DTH() uint32 {
	return volatile.LoadUint32(&o.DT0.Reg) & 0xffff
}
func (o *PWM_Type) SetDT0_DTL(value uint32) {
	volatile.StoreUint32(&o.DT0.Reg, volatile.LoadUint32(&o.DT0.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetDT0_DTL() uint32 {
	return (volatile.LoadUint32(&o.DT0.Reg) & 0xffff0000) >> 16
}

// PWM.DTUPD0: PWM Channel Dead Time Update Register (ch_num = 0)
func (o *PWM_Type) SetDTUPD0_DTHUPD(value uint32) {
	volatile.StoreUint32(&o.DTUPD0.Reg, volatile.LoadUint32(&o.DTUPD0.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetDTUPD0_DTHUPD() uint32 {
	return volatile.LoadUint32(&o.DTUPD0.Reg) & 0xffff
}
func (o *PWM_Type) SetDTUPD0_DTLUPD(value uint32) {
	volatile.StoreUint32(&o.DTUPD0.Reg, volatile.LoadUint32(&o.DTUPD0.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetDTUPD0_DTLUPD() uint32 {
	return (volatile.LoadUint32(&o.DTUPD0.Reg) & 0xffff0000) >> 16
}

// PWM.CMR1: PWM Channel Mode Register (ch_num = 1)
func (o *PWM_Type) SetCMR1_CPRE(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetCMR1_CPRE() uint32 {
	return volatile.LoadUint32(&o.CMR1.Reg) & 0xf
}
func (o *PWM_Type) SetCMR1_CALG(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetCMR1_CALG() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetCMR1_CPOL(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetCMR1_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetCMR1_CES(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetCMR1_CES() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetCMR1_DTE(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetCMR1_DTE() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetCMR1_DTHI(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetCMR1_DTHI() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetCMR1_DTLI(value uint32) {
	volatile.StoreUint32(&o.CMR1.Reg, volatile.LoadUint32(&o.CMR1.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetCMR1_DTLI() uint32 {
	return (volatile.LoadUint32(&o.CMR1.Reg) & 0x40000) >> 18
}

// PWM.CDTY1: PWM Channel Duty Cycle Register (ch_num = 1)
func (o *PWM_Type) SetCDTY1_CDTY(value uint32) {
	volatile.StoreUint32(&o.CDTY1.Reg, volatile.LoadUint32(&o.CDTY1.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCDTY1_CDTY() uint32 {
	return volatile.LoadUint32(&o.CDTY1.Reg) & 0xffffff
}

// PWM.CDTYUPD1: PWM Channel Duty Cycle Update Register (ch_num = 1)
func (o *PWM_Type) SetCDTYUPD1_CDTYUPD(value uint32) {
	volatile.StoreUint32(&o.CDTYUPD1.Reg, volatile.LoadUint32(&o.CDTYUPD1.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCDTYUPD1_CDTYUPD() uint32 {
	return volatile.LoadUint32(&o.CDTYUPD1.Reg) & 0xffffff
}

// PWM.CPRD1: PWM Channel Period Register (ch_num = 1)
func (o *PWM_Type) SetCPRD1_CPRD(value uint32) {
	volatile.StoreUint32(&o.CPRD1.Reg, volatile.LoadUint32(&o.CPRD1.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCPRD1_CPRD() uint32 {
	return volatile.LoadUint32(&o.CPRD1.Reg) & 0xffffff
}

// PWM.CPRDUPD1: PWM Channel Period Update Register (ch_num = 1)
func (o *PWM_Type) SetCPRDUPD1_CPRDUPD(value uint32) {
	volatile.StoreUint32(&o.CPRDUPD1.Reg, volatile.LoadUint32(&o.CPRDUPD1.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCPRDUPD1_CPRDUPD() uint32 {
	return volatile.LoadUint32(&o.CPRDUPD1.Reg) & 0xffffff
}

// PWM.CCNT1: PWM Channel Counter Register (ch_num = 1)
func (o *PWM_Type) SetCCNT1_CNT(value uint32) {
	volatile.StoreUint32(&o.CCNT1.Reg, volatile.LoadUint32(&o.CCNT1.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCCNT1_CNT() uint32 {
	return volatile.LoadUint32(&o.CCNT1.Reg) & 0xffffff
}

// PWM.DT1: PWM Channel Dead Time Register (ch_num = 1)
func (o *PWM_Type) SetDT1_DTH(value uint32) {
	volatile.StoreUint32(&o.DT1.Reg, volatile.LoadUint32(&o.DT1.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetDT1_DTH() uint32 {
	return volatile.LoadUint32(&o.DT1.Reg) & 0xffff
}
func (o *PWM_Type) SetDT1_DTL(value uint32) {
	volatile.StoreUint32(&o.DT1.Reg, volatile.LoadUint32(&o.DT1.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetDT1_DTL() uint32 {
	return (volatile.LoadUint32(&o.DT1.Reg) & 0xffff0000) >> 16
}

// PWM.DTUPD1: PWM Channel Dead Time Update Register (ch_num = 1)
func (o *PWM_Type) SetDTUPD1_DTHUPD(value uint32) {
	volatile.StoreUint32(&o.DTUPD1.Reg, volatile.LoadUint32(&o.DTUPD1.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetDTUPD1_DTHUPD() uint32 {
	return volatile.LoadUint32(&o.DTUPD1.Reg) & 0xffff
}
func (o *PWM_Type) SetDTUPD1_DTLUPD(value uint32) {
	volatile.StoreUint32(&o.DTUPD1.Reg, volatile.LoadUint32(&o.DTUPD1.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetDTUPD1_DTLUPD() uint32 {
	return (volatile.LoadUint32(&o.DTUPD1.Reg) & 0xffff0000) >> 16
}

// PWM.CMR2: PWM Channel Mode Register (ch_num = 2)
func (o *PWM_Type) SetCMR2_CPRE(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetCMR2_CPRE() uint32 {
	return volatile.LoadUint32(&o.CMR2.Reg) & 0xf
}
func (o *PWM_Type) SetCMR2_CALG(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetCMR2_CALG() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetCMR2_CPOL(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetCMR2_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetCMR2_CES(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetCMR2_CES() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetCMR2_DTE(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetCMR2_DTE() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetCMR2_DTHI(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetCMR2_DTHI() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetCMR2_DTLI(value uint32) {
	volatile.StoreUint32(&o.CMR2.Reg, volatile.LoadUint32(&o.CMR2.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetCMR2_DTLI() uint32 {
	return (volatile.LoadUint32(&o.CMR2.Reg) & 0x40000) >> 18
}

// PWM.CDTY2: PWM Channel Duty Cycle Register (ch_num = 2)
func (o *PWM_Type) SetCDTY2_CDTY(value uint32) {
	volatile.StoreUint32(&o.CDTY2.Reg, volatile.LoadUint32(&o.CDTY2.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCDTY2_CDTY() uint32 {
	return volatile.LoadUint32(&o.CDTY2.Reg) & 0xffffff
}

// PWM.CDTYUPD2: PWM Channel Duty Cycle Update Register (ch_num = 2)
func (o *PWM_Type) SetCDTYUPD2_CDTYUPD(value uint32) {
	volatile.StoreUint32(&o.CDTYUPD2.Reg, volatile.LoadUint32(&o.CDTYUPD2.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCDTYUPD2_CDTYUPD() uint32 {
	return volatile.LoadUint32(&o.CDTYUPD2.Reg) & 0xffffff
}

// PWM.CPRD2: PWM Channel Period Register (ch_num = 2)
func (o *PWM_Type) SetCPRD2_CPRD(value uint32) {
	volatile.StoreUint32(&o.CPRD2.Reg, volatile.LoadUint32(&o.CPRD2.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCPRD2_CPRD() uint32 {
	return volatile.LoadUint32(&o.CPRD2.Reg) & 0xffffff
}

// PWM.CPRDUPD2: PWM Channel Period Update Register (ch_num = 2)
func (o *PWM_Type) SetCPRDUPD2_CPRDUPD(value uint32) {
	volatile.StoreUint32(&o.CPRDUPD2.Reg, volatile.LoadUint32(&o.CPRDUPD2.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCPRDUPD2_CPRDUPD() uint32 {
	return volatile.LoadUint32(&o.CPRDUPD2.Reg) & 0xffffff
}

// PWM.CCNT2: PWM Channel Counter Register (ch_num = 2)
func (o *PWM_Type) SetCCNT2_CNT(value uint32) {
	volatile.StoreUint32(&o.CCNT2.Reg, volatile.LoadUint32(&o.CCNT2.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCCNT2_CNT() uint32 {
	return volatile.LoadUint32(&o.CCNT2.Reg) & 0xffffff
}

// PWM.DT2: PWM Channel Dead Time Register (ch_num = 2)
func (o *PWM_Type) SetDT2_DTH(value uint32) {
	volatile.StoreUint32(&o.DT2.Reg, volatile.LoadUint32(&o.DT2.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetDT2_DTH() uint32 {
	return volatile.LoadUint32(&o.DT2.Reg) & 0xffff
}
func (o *PWM_Type) SetDT2_DTL(value uint32) {
	volatile.StoreUint32(&o.DT2.Reg, volatile.LoadUint32(&o.DT2.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetDT2_DTL() uint32 {
	return (volatile.LoadUint32(&o.DT2.Reg) & 0xffff0000) >> 16
}

// PWM.DTUPD2: PWM Channel Dead Time Update Register (ch_num = 2)
func (o *PWM_Type) SetDTUPD2_DTHUPD(value uint32) {
	volatile.StoreUint32(&o.DTUPD2.Reg, volatile.LoadUint32(&o.DTUPD2.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetDTUPD2_DTHUPD() uint32 {
	return volatile.LoadUint32(&o.DTUPD2.Reg) & 0xffff
}
func (o *PWM_Type) SetDTUPD2_DTLUPD(value uint32) {
	volatile.StoreUint32(&o.DTUPD2.Reg, volatile.LoadUint32(&o.DTUPD2.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetDTUPD2_DTLUPD() uint32 {
	return (volatile.LoadUint32(&o.DTUPD2.Reg) & 0xffff0000) >> 16
}

// PWM.CMR3: PWM Channel Mode Register (ch_num = 3)
func (o *PWM_Type) SetCMR3_CPRE(value uint32) {
	volatile.StoreUint32(&o.CMR3.Reg, volatile.LoadUint32(&o.CMR3.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetCMR3_CPRE() uint32 {
	return volatile.LoadUint32(&o.CMR3.Reg) & 0xf
}
func (o *PWM_Type) SetCMR3_CALG(value uint32) {
	volatile.StoreUint32(&o.CMR3.Reg, volatile.LoadUint32(&o.CMR3.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetCMR3_CALG() uint32 {
	return (volatile.LoadUint32(&o.CMR3.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetCMR3_CPOL(value uint32) {
	volatile.StoreUint32(&o.CMR3.Reg, volatile.LoadUint32(&o.CMR3.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetCMR3_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CMR3.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetCMR3_CES(value uint32) {
	volatile.StoreUint32(&o.CMR3.Reg, volatile.LoadUint32(&o.CMR3.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetCMR3_CES() uint32 {
	return (volatile.LoadUint32(&o.CMR3.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetCMR3_DTE(value uint32) {
	volatile.StoreUint32(&o.CMR3.Reg, volatile.LoadUint32(&o.CMR3.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetCMR3_DTE() uint32 {
	return (volatile.LoadUint32(&o.CMR3.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetCMR3_DTHI(value uint32) {
	volatile.StoreUint32(&o.CMR3.Reg, volatile.LoadUint32(&o.CMR3.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetCMR3_DTHI() uint32 {
	return (volatile.LoadUint32(&o.CMR3.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetCMR3_DTLI(value uint32) {
	volatile.StoreUint32(&o.CMR3.Reg, volatile.LoadUint32(&o.CMR3.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetCMR3_DTLI() uint32 {
	return (volatile.LoadUint32(&o.CMR3.Reg) & 0x40000) >> 18
}

// PWM.CDTY3: PWM Channel Duty Cycle Register (ch_num = 3)
func (o *PWM_Type) SetCDTY3_CDTY(value uint32) {
	volatile.StoreUint32(&o.CDTY3.Reg, volatile.LoadUint32(&o.CDTY3.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCDTY3_CDTY() uint32 {
	return volatile.LoadUint32(&o.CDTY3.Reg) & 0xffffff
}

// PWM.CDTYUPD3: PWM Channel Duty Cycle Update Register (ch_num = 3)
func (o *PWM_Type) SetCDTYUPD3_CDTYUPD(value uint32) {
	volatile.StoreUint32(&o.CDTYUPD3.Reg, volatile.LoadUint32(&o.CDTYUPD3.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCDTYUPD3_CDTYUPD() uint32 {
	return volatile.LoadUint32(&o.CDTYUPD3.Reg) & 0xffffff
}

// PWM.CPRD3: PWM Channel Period Register (ch_num = 3)
func (o *PWM_Type) SetCPRD3_CPRD(value uint32) {
	volatile.StoreUint32(&o.CPRD3.Reg, volatile.LoadUint32(&o.CPRD3.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCPRD3_CPRD() uint32 {
	return volatile.LoadUint32(&o.CPRD3.Reg) & 0xffffff
}

// PWM.CPRDUPD3: PWM Channel Period Update Register (ch_num = 3)
func (o *PWM_Type) SetCPRDUPD3_CPRDUPD(value uint32) {
	volatile.StoreUint32(&o.CPRDUPD3.Reg, volatile.LoadUint32(&o.CPRDUPD3.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCPRDUPD3_CPRDUPD() uint32 {
	return volatile.LoadUint32(&o.CPRDUPD3.Reg) & 0xffffff
}

// PWM.CCNT3: PWM Channel Counter Register (ch_num = 3)
func (o *PWM_Type) SetCCNT3_CNT(value uint32) {
	volatile.StoreUint32(&o.CCNT3.Reg, volatile.LoadUint32(&o.CCNT3.Reg)&^(0xffffff)|value)
}
func (o *PWM_Type) GetCCNT3_CNT() uint32 {
	return volatile.LoadUint32(&o.CCNT3.Reg) & 0xffffff
}

// PWM.DT3: PWM Channel Dead Time Register (ch_num = 3)
func (o *PWM_Type) SetDT3_DTH(value uint32) {
	volatile.StoreUint32(&o.DT3.Reg, volatile.LoadUint32(&o.DT3.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetDT3_DTH() uint32 {
	return volatile.LoadUint32(&o.DT3.Reg) & 0xffff
}
func (o *PWM_Type) SetDT3_DTL(value uint32) {
	volatile.StoreUint32(&o.DT3.Reg, volatile.LoadUint32(&o.DT3.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetDT3_DTL() uint32 {
	return (volatile.LoadUint32(&o.DT3.Reg) & 0xffff0000) >> 16
}

// PWM.DTUPD3: PWM Channel Dead Time Update Register (ch_num = 3)
func (o *PWM_Type) SetDTUPD3_DTHUPD(value uint32) {
	volatile.StoreUint32(&o.DTUPD3.Reg, volatile.LoadUint32(&o.DTUPD3.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetDTUPD3_DTHUPD() uint32 {
	return volatile.LoadUint32(&o.DTUPD3.Reg) & 0xffff
}
func (o *PWM_Type) SetDTUPD3_DTLUPD(value uint32) {
	volatile.StoreUint32(&o.DTUPD3.Reg, volatile.LoadUint32(&o.DTUPD3.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetDTUPD3_DTLUPD() uint32 {
	return (volatile.LoadUint32(&o.DTUPD3.Reg) & 0xffff0000) >> 16
}

// Image Sensor Interface
type ISI_Type struct {
	CFG1       volatile.Register32 // 0x0
	CFG2       volatile.Register32 // 0x4
	PSIZE      volatile.Register32 // 0x8
	PDECF      volatile.Register32 // 0xC
	Y2R_SET0   volatile.Register32 // 0x10
	Y2R_SET1   volatile.Register32 // 0x14
	R2Y_SET0   volatile.Register32 // 0x18
	R2Y_SET1   volatile.Register32 // 0x1C
	R2Y_SET2   volatile.Register32 // 0x20
	CR         volatile.Register32 // 0x24
	SR         volatile.Register32 // 0x28
	IER        volatile.Register32 // 0x2C
	IDR        volatile.Register32 // 0x30
	IMR        volatile.Register32 // 0x34
	DMA_CHER   volatile.Register32 // 0x38
	DMA_CHDR   volatile.Register32 // 0x3C
	DMA_CHSR   volatile.Register32 // 0x40
	DMA_P_ADDR volatile.Register32 // 0x44
	DMA_P_CTRL volatile.Register32 // 0x48
	DMA_P_DSCR volatile.Register32 // 0x4C
	DMA_C_ADDR volatile.Register32 // 0x50
	DMA_C_CTRL volatile.Register32 // 0x54
	DMA_C_DSCR volatile.Register32 // 0x58
	_          [136]byte
	WPCR       volatile.Register32 // 0xE4
	WPSR       volatile.Register32 // 0xE8
}

// ISI.CFG1: ISI Configuration 1 Register
func (o *ISI_Type) SetCFG1_HSYNC_POL(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetCFG1_HSYNC_POL() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetCFG1_VSYNC_POL(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x8)|value<<3)
}
func (o *ISI_Type) GetCFG1_VSYNC_POL() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x8) >> 3
}
func (o *ISI_Type) SetCFG1_PIXCLK_POL(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x10)|value<<4)
}
func (o *ISI_Type) GetCFG1_PIXCLK_POL() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x10) >> 4
}
func (o *ISI_Type) SetCFG1_EMB_SYNC(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x40)|value<<6)
}
func (o *ISI_Type) GetCFG1_EMB_SYNC() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x40) >> 6
}
func (o *ISI_Type) SetCFG1_CRC_SYNC(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x80)|value<<7)
}
func (o *ISI_Type) GetCFG1_CRC_SYNC() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x80) >> 7
}
func (o *ISI_Type) SetCFG1_FRATE(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x700)|value<<8)
}
func (o *ISI_Type) GetCFG1_FRATE() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x700) >> 8
}
func (o *ISI_Type) SetCFG1_DISCR(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x800)|value<<11)
}
func (o *ISI_Type) GetCFG1_DISCR() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x800) >> 11
}
func (o *ISI_Type) SetCFG1_FULL(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x1000)|value<<12)
}
func (o *ISI_Type) GetCFG1_FULL() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x1000) >> 12
}
func (o *ISI_Type) SetCFG1_THMASK(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x6000)|value<<13)
}
func (o *ISI_Type) GetCFG1_THMASK() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x6000) >> 13
}
func (o *ISI_Type) SetCFG1_SLD(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0xff0000)|value<<16)
}
func (o *ISI_Type) GetCFG1_SLD() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0xff0000) >> 16
}
func (o *ISI_Type) SetCFG1_SFD(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0xff000000)|value<<24)
}
func (o *ISI_Type) GetCFG1_SFD() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0xff000000) >> 24
}

// ISI.CFG2: ISI Configuration 2 Register
func (o *ISI_Type) SetCFG2_IM_VSIZE(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x7ff)|value)
}
func (o *ISI_Type) GetCFG2_IM_VSIZE() uint32 {
	return volatile.LoadUint32(&o.CFG2.Reg) & 0x7ff
}
func (o *ISI_Type) SetCFG2_GS_MODE(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x800)|value<<11)
}
func (o *ISI_Type) GetCFG2_GS_MODE() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x800) >> 11
}
func (o *ISI_Type) SetCFG2_RGB_MODE(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x1000)|value<<12)
}
func (o *ISI_Type) GetCFG2_RGB_MODE() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x1000) >> 12
}
func (o *ISI_Type) SetCFG2_GRAYSCALE(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x2000)|value<<13)
}
func (o *ISI_Type) GetCFG2_GRAYSCALE() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x2000) >> 13
}
func (o *ISI_Type) SetCFG2_RGB_SWAP(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x4000)|value<<14)
}
func (o *ISI_Type) GetCFG2_RGB_SWAP() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x4000) >> 14
}
func (o *ISI_Type) SetCFG2_COL_SPACE(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x8000)|value<<15)
}
func (o *ISI_Type) GetCFG2_COL_SPACE() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x8000) >> 15
}
func (o *ISI_Type) SetCFG2_IM_HSIZE(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x7ff0000)|value<<16)
}
func (o *ISI_Type) GetCFG2_IM_HSIZE() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x7ff0000) >> 16
}
func (o *ISI_Type) SetCFG2_YCC_SWAP(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x30000000)|value<<28)
}
func (o *ISI_Type) GetCFG2_YCC_SWAP() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x30000000) >> 28
}
func (o *ISI_Type) SetCFG2_RGB_CFG(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0xc0000000)|value<<30)
}
func (o *ISI_Type) GetCFG2_RGB_CFG() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0xc0000000) >> 30
}

// ISI.PSIZE: ISI Preview Size Register
func (o *ISI_Type) SetPSIZE_PREV_VSIZE(value uint32) {
	volatile.StoreUint32(&o.PSIZE.Reg, volatile.LoadUint32(&o.PSIZE.Reg)&^(0x3ff)|value)
}
func (o *ISI_Type) GetPSIZE_PREV_VSIZE() uint32 {
	return volatile.LoadUint32(&o.PSIZE.Reg) & 0x3ff
}
func (o *ISI_Type) SetPSIZE_PREV_HSIZE(value uint32) {
	volatile.StoreUint32(&o.PSIZE.Reg, volatile.LoadUint32(&o.PSIZE.Reg)&^(0x3ff0000)|value<<16)
}
func (o *ISI_Type) GetPSIZE_PREV_HSIZE() uint32 {
	return (volatile.LoadUint32(&o.PSIZE.Reg) & 0x3ff0000) >> 16
}

// ISI.PDECF: ISI Preview Decimation Factor Register
func (o *ISI_Type) SetPDECF_DEC_FACTOR(value uint32) {
	volatile.StoreUint32(&o.PDECF.Reg, volatile.LoadUint32(&o.PDECF.Reg)&^(0xff)|value)
}
func (o *ISI_Type) GetPDECF_DEC_FACTOR() uint32 {
	return volatile.LoadUint32(&o.PDECF.Reg) & 0xff
}

// ISI.Y2R_SET0: ISI CSC YCrCb To RGB Set 0 Register
func (o *ISI_Type) SetY2R_SET0_C0(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET0.Reg, volatile.LoadUint32(&o.Y2R_SET0.Reg)&^(0xff)|value)
}
func (o *ISI_Type) GetY2R_SET0_C0() uint32 {
	return volatile.LoadUint32(&o.Y2R_SET0.Reg) & 0xff
}
func (o *ISI_Type) SetY2R_SET0_C1(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET0.Reg, volatile.LoadUint32(&o.Y2R_SET0.Reg)&^(0xff00)|value<<8)
}
func (o *ISI_Type) GetY2R_SET0_C1() uint32 {
	return (volatile.LoadUint32(&o.Y2R_SET0.Reg) & 0xff00) >> 8
}
func (o *ISI_Type) SetY2R_SET0_C2(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET0.Reg, volatile.LoadUint32(&o.Y2R_SET0.Reg)&^(0xff0000)|value<<16)
}
func (o *ISI_Type) GetY2R_SET0_C2() uint32 {
	return (volatile.LoadUint32(&o.Y2R_SET0.Reg) & 0xff0000) >> 16
}
func (o *ISI_Type) SetY2R_SET0_C3(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET0.Reg, volatile.LoadUint32(&o.Y2R_SET0.Reg)&^(0xff000000)|value<<24)
}
func (o *ISI_Type) GetY2R_SET0_C3() uint32 {
	return (volatile.LoadUint32(&o.Y2R_SET0.Reg) & 0xff000000) >> 24
}

// ISI.Y2R_SET1: ISI CSC YCrCb To RGB Set 1 Register
func (o *ISI_Type) SetY2R_SET1_C4(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET1.Reg, volatile.LoadUint32(&o.Y2R_SET1.Reg)&^(0x1ff)|value)
}
func (o *ISI_Type) GetY2R_SET1_C4() uint32 {
	return volatile.LoadUint32(&o.Y2R_SET1.Reg) & 0x1ff
}
func (o *ISI_Type) SetY2R_SET1_Yoff(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET1.Reg, volatile.LoadUint32(&o.Y2R_SET1.Reg)&^(0x1000)|value<<12)
}
func (o *ISI_Type) GetY2R_SET1_Yoff() uint32 {
	return (volatile.LoadUint32(&o.Y2R_SET1.Reg) & 0x1000) >> 12
}
func (o *ISI_Type) SetY2R_SET1_Croff(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET1.Reg, volatile.LoadUint32(&o.Y2R_SET1.Reg)&^(0x2000)|value<<13)
}
func (o *ISI_Type) GetY2R_SET1_Croff() uint32 {
	return (volatile.LoadUint32(&o.Y2R_SET1.Reg) & 0x2000) >> 13
}
func (o *ISI_Type) SetY2R_SET1_Cboff(value uint32) {
	volatile.StoreUint32(&o.Y2R_SET1.Reg, volatile.LoadUint32(&o.Y2R_SET1.Reg)&^(0x4000)|value<<14)
}
func (o *ISI_Type) GetY2R_SET1_Cboff() uint32 {
	return (volatile.LoadUint32(&o.Y2R_SET1.Reg) & 0x4000) >> 14
}

// ISI.R2Y_SET0: ISI CSC RGB To YCrCb Set 0 Register
func (o *ISI_Type) SetR2Y_SET0_C0(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET0.Reg, volatile.LoadUint32(&o.R2Y_SET0.Reg)&^(0x7f)|value)
}
func (o *ISI_Type) GetR2Y_SET0_C0() uint32 {
	return volatile.LoadUint32(&o.R2Y_SET0.Reg) & 0x7f
}
func (o *ISI_Type) SetR2Y_SET0_C1(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET0.Reg, volatile.LoadUint32(&o.R2Y_SET0.Reg)&^(0x7f00)|value<<8)
}
func (o *ISI_Type) GetR2Y_SET0_C1() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET0.Reg) & 0x7f00) >> 8
}
func (o *ISI_Type) SetR2Y_SET0_C2(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET0.Reg, volatile.LoadUint32(&o.R2Y_SET0.Reg)&^(0x7f0000)|value<<16)
}
func (o *ISI_Type) GetR2Y_SET0_C2() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET0.Reg) & 0x7f0000) >> 16
}
func (o *ISI_Type) SetR2Y_SET0_Roff(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET0.Reg, volatile.LoadUint32(&o.R2Y_SET0.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetR2Y_SET0_Roff() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET0.Reg) & 0x1000000) >> 24
}

// ISI.R2Y_SET1: ISI CSC RGB To YCrCb Set 1 Register
func (o *ISI_Type) SetR2Y_SET1_C3(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET1.Reg, volatile.LoadUint32(&o.R2Y_SET1.Reg)&^(0x7f)|value)
}
func (o *ISI_Type) GetR2Y_SET1_C3() uint32 {
	return volatile.LoadUint32(&o.R2Y_SET1.Reg) & 0x7f
}
func (o *ISI_Type) SetR2Y_SET1_C4(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET1.Reg, volatile.LoadUint32(&o.R2Y_SET1.Reg)&^(0x7f00)|value<<8)
}
func (o *ISI_Type) GetR2Y_SET1_C4() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET1.Reg) & 0x7f00) >> 8
}
func (o *ISI_Type) SetR2Y_SET1_C5(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET1.Reg, volatile.LoadUint32(&o.R2Y_SET1.Reg)&^(0x7f0000)|value<<16)
}
func (o *ISI_Type) GetR2Y_SET1_C5() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET1.Reg) & 0x7f0000) >> 16
}
func (o *ISI_Type) SetR2Y_SET1_Goff(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET1.Reg, volatile.LoadUint32(&o.R2Y_SET1.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetR2Y_SET1_Goff() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET1.Reg) & 0x1000000) >> 24
}

// ISI.R2Y_SET2: ISI CSC RGB To YCrCb Set 2 Register
func (o *ISI_Type) SetR2Y_SET2_C6(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET2.Reg, volatile.LoadUint32(&o.R2Y_SET2.Reg)&^(0x7f)|value)
}
func (o *ISI_Type) GetR2Y_SET2_C6() uint32 {
	return volatile.LoadUint32(&o.R2Y_SET2.Reg) & 0x7f
}
func (o *ISI_Type) SetR2Y_SET2_C7(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET2.Reg, volatile.LoadUint32(&o.R2Y_SET2.Reg)&^(0x7f00)|value<<8)
}
func (o *ISI_Type) GetR2Y_SET2_C7() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET2.Reg) & 0x7f00) >> 8
}
func (o *ISI_Type) SetR2Y_SET2_C8(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET2.Reg, volatile.LoadUint32(&o.R2Y_SET2.Reg)&^(0x7f0000)|value<<16)
}
func (o *ISI_Type) GetR2Y_SET2_C8() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET2.Reg) & 0x7f0000) >> 16
}
func (o *ISI_Type) SetR2Y_SET2_Boff(value uint32) {
	volatile.StoreUint32(&o.R2Y_SET2.Reg, volatile.LoadUint32(&o.R2Y_SET2.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetR2Y_SET2_Boff() uint32 {
	return (volatile.LoadUint32(&o.R2Y_SET2.Reg) & 0x1000000) >> 24
}

// ISI.CR: ISI Control Register
func (o *ISI_Type) SetCR_ISI_EN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetCR_ISI_EN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *ISI_Type) SetCR_ISI_DIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetCR_ISI_DIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetCR_ISI_SRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetCR_ISI_SRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetCR_ISI_CDC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *ISI_Type) GetCR_ISI_CDC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}

// ISI.SR: ISI Status Register
func (o *ISI_Type) SetSR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetSR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *ISI_Type) SetSR_DIS_DONE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetSR_DIS_DONE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetSR_SRST(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetSR_SRST() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetSR_CDC_PND(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *ISI_Type) GetSR_CDC_PND() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *ISI_Type) SetSR_VSYNC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *ISI_Type) GetSR_VSYNC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *ISI_Type) SetSR_PXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *ISI_Type) GetSR_PXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *ISI_Type) SetSR_CXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *ISI_Type) GetSR_CXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}
func (o *ISI_Type) SetSR_SIP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000)|value<<19)
}
func (o *ISI_Type) GetSR_SIP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000) >> 19
}
func (o *ISI_Type) SetSR_P_OVR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetSR_P_OVR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000000) >> 24
}
func (o *ISI_Type) SetSR_C_OVR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000000)|value<<25)
}
func (o *ISI_Type) GetSR_C_OVR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000000) >> 25
}
func (o *ISI_Type) SetSR_CRC_ERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000000)|value<<26)
}
func (o *ISI_Type) GetSR_CRC_ERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000000) >> 26
}
func (o *ISI_Type) SetSR_FR_OVR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000000)|value<<27)
}
func (o *ISI_Type) GetSR_FR_OVR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000000) >> 27
}

// ISI.IER: ISI Interrupt Enable Register
func (o *ISI_Type) SetIER_DIS_DONE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetIER_DIS_DONE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetIER_SRST(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetIER_SRST() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetIER_VSYNC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *ISI_Type) GetIER_VSYNC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *ISI_Type) SetIER_PXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000)|value<<16)
}
func (o *ISI_Type) GetIER_PXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000) >> 16
}
func (o *ISI_Type) SetIER_CXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000)|value<<17)
}
func (o *ISI_Type) GetIER_CXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000) >> 17
}
func (o *ISI_Type) SetIER_P_OVR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetIER_P_OVR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}
func (o *ISI_Type) SetIER_C_OVR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000000)|value<<25)
}
func (o *ISI_Type) GetIER_C_OVR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000000) >> 25
}
func (o *ISI_Type) SetIER_CRC_ERR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000000)|value<<26)
}
func (o *ISI_Type) GetIER_CRC_ERR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000000) >> 26
}
func (o *ISI_Type) SetIER_FR_OVR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8000000)|value<<27)
}
func (o *ISI_Type) GetIER_FR_OVR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8000000) >> 27
}

// ISI.IDR: ISI Interrupt Disable Register
func (o *ISI_Type) SetIDR_DIS_DONE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetIDR_DIS_DONE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetIDR_SRST(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetIDR_SRST() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetIDR_VSYNC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *ISI_Type) GetIDR_VSYNC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *ISI_Type) SetIDR_PXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000)|value<<16)
}
func (o *ISI_Type) GetIDR_PXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000) >> 16
}
func (o *ISI_Type) SetIDR_CXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000)|value<<17)
}
func (o *ISI_Type) GetIDR_CXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000) >> 17
}
func (o *ISI_Type) SetIDR_P_OVR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetIDR_P_OVR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}
func (o *ISI_Type) SetIDR_C_OVR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000000)|value<<25)
}
func (o *ISI_Type) GetIDR_C_OVR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000000) >> 25
}
func (o *ISI_Type) SetIDR_CRC_ERR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000000)|value<<26)
}
func (o *ISI_Type) GetIDR_CRC_ERR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000000) >> 26
}
func (o *ISI_Type) SetIDR_FR_OVR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000000)|value<<27)
}
func (o *ISI_Type) GetIDR_FR_OVR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000000) >> 27
}

// ISI.IMR: ISI Interrupt Mask Register
func (o *ISI_Type) SetIMR_DIS_DONE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetIMR_DIS_DONE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetIMR_SRST(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetIMR_SRST() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetIMR_VSYNC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *ISI_Type) GetIMR_VSYNC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *ISI_Type) SetIMR_PXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000)|value<<16)
}
func (o *ISI_Type) GetIMR_PXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000) >> 16
}
func (o *ISI_Type) SetIMR_CXFR_DONE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000)|value<<17)
}
func (o *ISI_Type) GetIMR_CXFR_DONE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000) >> 17
}
func (o *ISI_Type) SetIMR_P_OVR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *ISI_Type) GetIMR_P_OVR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}
func (o *ISI_Type) SetIMR_C_OVR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000000)|value<<25)
}
func (o *ISI_Type) GetIMR_C_OVR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000000) >> 25
}
func (o *ISI_Type) SetIMR_CRC_ERR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000000)|value<<26)
}
func (o *ISI_Type) GetIMR_CRC_ERR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000000) >> 26
}
func (o *ISI_Type) SetIMR_FR_OVR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000000)|value<<27)
}
func (o *ISI_Type) GetIMR_FR_OVR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000000) >> 27
}

// ISI.DMA_CHER: DMA Channel Enable Register
func (o *ISI_Type) SetDMA_CHER_P_CH_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_CHER.Reg, volatile.LoadUint32(&o.DMA_CHER.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetDMA_CHER_P_CH_EN() uint32 {
	return volatile.LoadUint32(&o.DMA_CHER.Reg) & 0x1
}
func (o *ISI_Type) SetDMA_CHER_C_CH_EN(value uint32) {
	volatile.StoreUint32(&o.DMA_CHER.Reg, volatile.LoadUint32(&o.DMA_CHER.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetDMA_CHER_C_CH_EN() uint32 {
	return (volatile.LoadUint32(&o.DMA_CHER.Reg) & 0x2) >> 1
}

// ISI.DMA_CHDR: DMA Channel Disable Register
func (o *ISI_Type) SetDMA_CHDR_P_CH_DIS(value uint32) {
	volatile.StoreUint32(&o.DMA_CHDR.Reg, volatile.LoadUint32(&o.DMA_CHDR.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetDMA_CHDR_P_CH_DIS() uint32 {
	return volatile.LoadUint32(&o.DMA_CHDR.Reg) & 0x1
}
func (o *ISI_Type) SetDMA_CHDR_C_CH_DIS(value uint32) {
	volatile.StoreUint32(&o.DMA_CHDR.Reg, volatile.LoadUint32(&o.DMA_CHDR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetDMA_CHDR_C_CH_DIS() uint32 {
	return (volatile.LoadUint32(&o.DMA_CHDR.Reg) & 0x2) >> 1
}

// ISI.DMA_CHSR: DMA Channel Status Register
func (o *ISI_Type) SetDMA_CHSR_P_CH_S(value uint32) {
	volatile.StoreUint32(&o.DMA_CHSR.Reg, volatile.LoadUint32(&o.DMA_CHSR.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetDMA_CHSR_P_CH_S() uint32 {
	return volatile.LoadUint32(&o.DMA_CHSR.Reg) & 0x1
}
func (o *ISI_Type) SetDMA_CHSR_C_CH_S(value uint32) {
	volatile.StoreUint32(&o.DMA_CHSR.Reg, volatile.LoadUint32(&o.DMA_CHSR.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetDMA_CHSR_C_CH_S() uint32 {
	return (volatile.LoadUint32(&o.DMA_CHSR.Reg) & 0x2) >> 1
}

// ISI.DMA_P_ADDR: DMA Preview Base Address Register
func (o *ISI_Type) SetDMA_P_ADDR_P_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_P_ADDR.Reg, volatile.LoadUint32(&o.DMA_P_ADDR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *ISI_Type) GetDMA_P_ADDR_P_ADDR() uint32 {
	return (volatile.LoadUint32(&o.DMA_P_ADDR.Reg) & 0xfffffffc) >> 2
}

// ISI.DMA_P_CTRL: DMA Preview Control Register
func (o *ISI_Type) SetDMA_P_CTRL_P_FETCH(value uint32) {
	volatile.StoreUint32(&o.DMA_P_CTRL.Reg, volatile.LoadUint32(&o.DMA_P_CTRL.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetDMA_P_CTRL_P_FETCH() uint32 {
	return volatile.LoadUint32(&o.DMA_P_CTRL.Reg) & 0x1
}
func (o *ISI_Type) SetDMA_P_CTRL_P_WB(value uint32) {
	volatile.StoreUint32(&o.DMA_P_CTRL.Reg, volatile.LoadUint32(&o.DMA_P_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetDMA_P_CTRL_P_WB() uint32 {
	return (volatile.LoadUint32(&o.DMA_P_CTRL.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetDMA_P_CTRL_P_IEN(value uint32) {
	volatile.StoreUint32(&o.DMA_P_CTRL.Reg, volatile.LoadUint32(&o.DMA_P_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetDMA_P_CTRL_P_IEN() uint32 {
	return (volatile.LoadUint32(&o.DMA_P_CTRL.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetDMA_P_CTRL_P_DONE(value uint32) {
	volatile.StoreUint32(&o.DMA_P_CTRL.Reg, volatile.LoadUint32(&o.DMA_P_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *ISI_Type) GetDMA_P_CTRL_P_DONE() uint32 {
	return (volatile.LoadUint32(&o.DMA_P_CTRL.Reg) & 0x8) >> 3
}

// ISI.DMA_P_DSCR: DMA Preview Descriptor Address Register
func (o *ISI_Type) SetDMA_P_DSCR_P_DSCR(value uint32) {
	volatile.StoreUint32(&o.DMA_P_DSCR.Reg, volatile.LoadUint32(&o.DMA_P_DSCR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *ISI_Type) GetDMA_P_DSCR_P_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DMA_P_DSCR.Reg) & 0xfffffffc) >> 2
}

// ISI.DMA_C_ADDR: DMA Codec Base Address Register
func (o *ISI_Type) SetDMA_C_ADDR_C_ADDR(value uint32) {
	volatile.StoreUint32(&o.DMA_C_ADDR.Reg, volatile.LoadUint32(&o.DMA_C_ADDR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *ISI_Type) GetDMA_C_ADDR_C_ADDR() uint32 {
	return (volatile.LoadUint32(&o.DMA_C_ADDR.Reg) & 0xfffffffc) >> 2
}

// ISI.DMA_C_CTRL: DMA Codec Control Register
func (o *ISI_Type) SetDMA_C_CTRL_C_FETCH(value uint32) {
	volatile.StoreUint32(&o.DMA_C_CTRL.Reg, volatile.LoadUint32(&o.DMA_C_CTRL.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetDMA_C_CTRL_C_FETCH() uint32 {
	return volatile.LoadUint32(&o.DMA_C_CTRL.Reg) & 0x1
}
func (o *ISI_Type) SetDMA_C_CTRL_C_WB(value uint32) {
	volatile.StoreUint32(&o.DMA_C_CTRL.Reg, volatile.LoadUint32(&o.DMA_C_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *ISI_Type) GetDMA_C_CTRL_C_WB() uint32 {
	return (volatile.LoadUint32(&o.DMA_C_CTRL.Reg) & 0x2) >> 1
}
func (o *ISI_Type) SetDMA_C_CTRL_C_IEN(value uint32) {
	volatile.StoreUint32(&o.DMA_C_CTRL.Reg, volatile.LoadUint32(&o.DMA_C_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *ISI_Type) GetDMA_C_CTRL_C_IEN() uint32 {
	return (volatile.LoadUint32(&o.DMA_C_CTRL.Reg) & 0x4) >> 2
}
func (o *ISI_Type) SetDMA_C_CTRL_C_DONE(value uint32) {
	volatile.StoreUint32(&o.DMA_C_CTRL.Reg, volatile.LoadUint32(&o.DMA_C_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *ISI_Type) GetDMA_C_CTRL_C_DONE() uint32 {
	return (volatile.LoadUint32(&o.DMA_C_CTRL.Reg) & 0x8) >> 3
}

// ISI.DMA_C_DSCR: DMA Codec Descriptor Address Register
func (o *ISI_Type) SetDMA_C_DSCR_C_DSCR(value uint32) {
	volatile.StoreUint32(&o.DMA_C_DSCR.Reg, volatile.LoadUint32(&o.DMA_C_DSCR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *ISI_Type) GetDMA_C_DSCR_C_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DMA_C_DSCR.Reg) & 0xfffffffc) >> 2
}

// ISI.WPCR: Write Protection Control Register
func (o *ISI_Type) SetWPCR_WP_EN(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x1)|value)
}
func (o *ISI_Type) GetWPCR_WP_EN() uint32 {
	return volatile.LoadUint32(&o.WPCR.Reg) & 0x1
}
func (o *ISI_Type) SetWPCR_WP_KEY(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *ISI_Type) GetWPCR_WP_KEY() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0xffffff00) >> 8
}

// ISI.WPSR: Write Protection Status Register
func (o *ISI_Type) SetWPSR_WP_VS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xf)|value)
}
func (o *ISI_Type) GetWPSR_WP_VS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0xf
}
func (o *ISI_Type) SetWPSR_WP_VSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *ISI_Type) GetWPSR_WP_VSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// Special Function Registers
type SFR_Type struct {
	_          [16]byte
	OHCIICR    volatile.Register32 // 0x10
	OHCIISR    volatile.Register32 // 0x14
	_          [8]byte
	AHB        volatile.Register32 // 0x20
	BRIDGE     volatile.Register32 // 0x24
	SECURE     volatile.Register32 // 0x28
	_          [4]byte
	UTMICKTRIM volatile.Register32 // 0x30
	UTMIHSTRIM volatile.Register32 // 0x34
	UTMIFSTRIM volatile.Register32 // 0x38
	UTMISWAP   volatile.Register32 // 0x3C
	EBICFG     volatile.Register32 // 0x40
}

// SFR.OHCIICR: OHCI Interrupt Configuration Register
func (o *SFR_Type) SetOHCIICR_RES0(value uint32) {
	volatile.StoreUint32(&o.OHCIICR.Reg, volatile.LoadUint32(&o.OHCIICR.Reg)&^(0x1)|value)
}
func (o *SFR_Type) GetOHCIICR_RES0() uint32 {
	return volatile.LoadUint32(&o.OHCIICR.Reg) & 0x1
}
func (o *SFR_Type) SetOHCIICR_RES1(value uint32) {
	volatile.StoreUint32(&o.OHCIICR.Reg, volatile.LoadUint32(&o.OHCIICR.Reg)&^(0x2)|value<<1)
}
func (o *SFR_Type) GetOHCIICR_RES1() uint32 {
	return (volatile.LoadUint32(&o.OHCIICR.Reg) & 0x2) >> 1
}
func (o *SFR_Type) SetOHCIICR_RES2(value uint32) {
	volatile.StoreUint32(&o.OHCIICR.Reg, volatile.LoadUint32(&o.OHCIICR.Reg)&^(0x4)|value<<2)
}
func (o *SFR_Type) GetOHCIICR_RES2() uint32 {
	return (volatile.LoadUint32(&o.OHCIICR.Reg) & 0x4) >> 2
}
func (o *SFR_Type) SetOHCIICR_ARIE(value uint32) {
	volatile.StoreUint32(&o.OHCIICR.Reg, volatile.LoadUint32(&o.OHCIICR.Reg)&^(0x10)|value<<4)
}
func (o *SFR_Type) GetOHCIICR_ARIE() uint32 {
	return (volatile.LoadUint32(&o.OHCIICR.Reg) & 0x10) >> 4
}
func (o *SFR_Type) SetOHCIICR_APPSTART(value uint32) {
	volatile.StoreUint32(&o.OHCIICR.Reg, volatile.LoadUint32(&o.OHCIICR.Reg)&^(0x20)|value<<5)
}
func (o *SFR_Type) GetOHCIICR_APPSTART() uint32 {
	return (volatile.LoadUint32(&o.OHCIICR.Reg) & 0x20) >> 5
}
func (o *SFR_Type) SetOHCIICR_UDPPUDIS(value uint32) {
	volatile.StoreUint32(&o.OHCIICR.Reg, volatile.LoadUint32(&o.OHCIICR.Reg)&^(0x800000)|value<<23)
}
func (o *SFR_Type) GetOHCIICR_UDPPUDIS() uint32 {
	return (volatile.LoadUint32(&o.OHCIICR.Reg) & 0x800000) >> 23
}

// SFR.OHCIISR: OHCI Interrupt Status Register
func (o *SFR_Type) SetOHCIISR_RIS0(value uint32) {
	volatile.StoreUint32(&o.OHCIISR.Reg, volatile.LoadUint32(&o.OHCIISR.Reg)&^(0x1)|value)
}
func (o *SFR_Type) GetOHCIISR_RIS0() uint32 {
	return volatile.LoadUint32(&o.OHCIISR.Reg) & 0x1
}
func (o *SFR_Type) SetOHCIISR_RIS1(value uint32) {
	volatile.StoreUint32(&o.OHCIISR.Reg, volatile.LoadUint32(&o.OHCIISR.Reg)&^(0x2)|value<<1)
}
func (o *SFR_Type) GetOHCIISR_RIS1() uint32 {
	return (volatile.LoadUint32(&o.OHCIISR.Reg) & 0x2) >> 1
}
func (o *SFR_Type) SetOHCIISR_RIS2(value uint32) {
	volatile.StoreUint32(&o.OHCIISR.Reg, volatile.LoadUint32(&o.OHCIISR.Reg)&^(0x4)|value<<2)
}
func (o *SFR_Type) GetOHCIISR_RIS2() uint32 {
	return (volatile.LoadUint32(&o.OHCIISR.Reg) & 0x4) >> 2
}

// SFR.AHB: AHB Configuration Register
func (o *SFR_Type) SetAHB_PFETCH10(value uint32) {
	volatile.StoreUint32(&o.AHB.Reg, volatile.LoadUint32(&o.AHB.Reg)&^(0x400)|value<<10)
}
func (o *SFR_Type) GetAHB_PFETCH10() uint32 {
	return (volatile.LoadUint32(&o.AHB.Reg) & 0x400) >> 10
}
func (o *SFR_Type) SetAHB_PFETCH11(value uint32) {
	volatile.StoreUint32(&o.AHB.Reg, volatile.LoadUint32(&o.AHB.Reg)&^(0x800)|value<<11)
}
func (o *SFR_Type) GetAHB_PFETCH11() uint32 {
	return (volatile.LoadUint32(&o.AHB.Reg) & 0x800) >> 11
}
func (o *SFR_Type) SetAHB_PFETCH12(value uint32) {
	volatile.StoreUint32(&o.AHB.Reg, volatile.LoadUint32(&o.AHB.Reg)&^(0x1000)|value<<12)
}
func (o *SFR_Type) GetAHB_PFETCH12() uint32 {
	return (volatile.LoadUint32(&o.AHB.Reg) & 0x1000) >> 12
}
func (o *SFR_Type) SetAHB_PFETCH13(value uint32) {
	volatile.StoreUint32(&o.AHB.Reg, volatile.LoadUint32(&o.AHB.Reg)&^(0x2000)|value<<13)
}
func (o *SFR_Type) GetAHB_PFETCH13() uint32 {
	return (volatile.LoadUint32(&o.AHB.Reg) & 0x2000) >> 13
}
func (o *SFR_Type) SetAHB_PFETCH14(value uint32) {
	volatile.StoreUint32(&o.AHB.Reg, volatile.LoadUint32(&o.AHB.Reg)&^(0x4000)|value<<14)
}
func (o *SFR_Type) GetAHB_PFETCH14() uint32 {
	return (volatile.LoadUint32(&o.AHB.Reg) & 0x4000) >> 14
}
func (o *SFR_Type) SetAHB_DLBOPT10(value uint32) {
	volatile.StoreUint32(&o.AHB.Reg, volatile.LoadUint32(&o.AHB.Reg)&^(0x4000000)|value<<26)
}
func (o *SFR_Type) GetAHB_DLBOPT10() uint32 {
	return (volatile.LoadUint32(&o.AHB.Reg) & 0x4000000) >> 26
}
func (o *SFR_Type) SetAHB_DLBOPT11(value uint32) {
	volatile.StoreUint32(&o.AHB.Reg, volatile.LoadUint32(&o.AHB.Reg)&^(0x8000000)|value<<27)
}
func (o *SFR_Type) GetAHB_DLBOPT11() uint32 {
	return (volatile.LoadUint32(&o.AHB.Reg) & 0x8000000) >> 27
}
func (o *SFR_Type) SetAHB_DLBOPT12(value uint32) {
	volatile.StoreUint32(&o.AHB.Reg, volatile.LoadUint32(&o.AHB.Reg)&^(0x10000000)|value<<28)
}
func (o *SFR_Type) GetAHB_DLBOPT12() uint32 {
	return (volatile.LoadUint32(&o.AHB.Reg) & 0x10000000) >> 28
}
func (o *SFR_Type) SetAHB_DLBOPT13(value uint32) {
	volatile.StoreUint32(&o.AHB.Reg, volatile.LoadUint32(&o.AHB.Reg)&^(0x20000000)|value<<29)
}
func (o *SFR_Type) GetAHB_DLBOPT13() uint32 {
	return (volatile.LoadUint32(&o.AHB.Reg) & 0x20000000) >> 29
}
func (o *SFR_Type) SetAHB_DLBOPT14(value uint32) {
	volatile.StoreUint32(&o.AHB.Reg, volatile.LoadUint32(&o.AHB.Reg)&^(0x40000000)|value<<30)
}
func (o *SFR_Type) GetAHB_DLBOPT14() uint32 {
	return (volatile.LoadUint32(&o.AHB.Reg) & 0x40000000) >> 30
}

// SFR.BRIDGE: Bridge Configuration Register
func (o *SFR_Type) SetBRIDGE_APBTURBO(value uint32) {
	volatile.StoreUint32(&o.BRIDGE.Reg, volatile.LoadUint32(&o.BRIDGE.Reg)&^(0x1)|value)
}
func (o *SFR_Type) GetBRIDGE_APBTURBO() uint32 {
	return volatile.LoadUint32(&o.BRIDGE.Reg) & 0x1
}
func (o *SFR_Type) SetBRIDGE_AXI2AHBSEL(value uint32) {
	volatile.StoreUint32(&o.BRIDGE.Reg, volatile.LoadUint32(&o.BRIDGE.Reg)&^(0x100)|value<<8)
}
func (o *SFR_Type) GetBRIDGE_AXI2AHBSEL() uint32 {
	return (volatile.LoadUint32(&o.BRIDGE.Reg) & 0x100) >> 8
}

// SFR.SECURE: Security Configuration Register
func (o *SFR_Type) SetSECURE_ROM(value uint32) {
	volatile.StoreUint32(&o.SECURE.Reg, volatile.LoadUint32(&o.SECURE.Reg)&^(0x1)|value)
}
func (o *SFR_Type) GetSECURE_ROM() uint32 {
	return volatile.LoadUint32(&o.SECURE.Reg) & 0x1
}
func (o *SFR_Type) SetSECURE_FUSE(value uint32) {
	volatile.StoreUint32(&o.SECURE.Reg, volatile.LoadUint32(&o.SECURE.Reg)&^(0x100)|value<<8)
}
func (o *SFR_Type) GetSECURE_FUSE() uint32 {
	return (volatile.LoadUint32(&o.SECURE.Reg) & 0x100) >> 8
}

// SFR.UTMICKTRIM: UTMI Clock Trimming Register
func (o *SFR_Type) SetUTMICKTRIM_FREQ(value uint32) {
	volatile.StoreUint32(&o.UTMICKTRIM.Reg, volatile.LoadUint32(&o.UTMICKTRIM.Reg)&^(0x3)|value)
}
func (o *SFR_Type) GetUTMICKTRIM_FREQ() uint32 {
	return volatile.LoadUint32(&o.UTMICKTRIM.Reg) & 0x3
}
func (o *SFR_Type) SetUTMICKTRIM_VBG(value uint32) {
	volatile.StoreUint32(&o.UTMICKTRIM.Reg, volatile.LoadUint32(&o.UTMICKTRIM.Reg)&^(0xf0000)|value<<16)
}
func (o *SFR_Type) GetUTMICKTRIM_VBG() uint32 {
	return (volatile.LoadUint32(&o.UTMICKTRIM.Reg) & 0xf0000) >> 16
}

// SFR.UTMIHSTRIM: UTMI High Speed Trimming Register
func (o *SFR_Type) SetUTMIHSTRIM_SQUELCH(value uint32) {
	volatile.StoreUint32(&o.UTMIHSTRIM.Reg, volatile.LoadUint32(&o.UTMIHSTRIM.Reg)&^(0x7)|value)
}
func (o *SFR_Type) GetUTMIHSTRIM_SQUELCH() uint32 {
	return volatile.LoadUint32(&o.UTMIHSTRIM.Reg) & 0x7
}
func (o *SFR_Type) SetUTMIHSTRIM_DISC(value uint32) {
	volatile.StoreUint32(&o.UTMIHSTRIM.Reg, volatile.LoadUint32(&o.UTMIHSTRIM.Reg)&^(0x70)|value<<4)
}
func (o *SFR_Type) GetUTMIHSTRIM_DISC() uint32 {
	return (volatile.LoadUint32(&o.UTMIHSTRIM.Reg) & 0x70) >> 4
}
func (o *SFR_Type) SetUTMIHSTRIM_SLOPE0(value uint32) {
	volatile.StoreUint32(&o.UTMIHSTRIM.Reg, volatile.LoadUint32(&o.UTMIHSTRIM.Reg)&^(0x700)|value<<8)
}
func (o *SFR_Type) GetUTMIHSTRIM_SLOPE0() uint32 {
	return (volatile.LoadUint32(&o.UTMIHSTRIM.Reg) & 0x700) >> 8
}
func (o *SFR_Type) SetUTMIHSTRIM_SLOPE1(value uint32) {
	volatile.StoreUint32(&o.UTMIHSTRIM.Reg, volatile.LoadUint32(&o.UTMIHSTRIM.Reg)&^(0x7000)|value<<12)
}
func (o *SFR_Type) GetUTMIHSTRIM_SLOPE1() uint32 {
	return (volatile.LoadUint32(&o.UTMIHSTRIM.Reg) & 0x7000) >> 12
}
func (o *SFR_Type) SetUTMIHSTRIM_SLOPE2(value uint32) {
	volatile.StoreUint32(&o.UTMIHSTRIM.Reg, volatile.LoadUint32(&o.UTMIHSTRIM.Reg)&^(0x70000)|value<<16)
}
func (o *SFR_Type) GetUTMIHSTRIM_SLOPE2() uint32 {
	return (volatile.LoadUint32(&o.UTMIHSTRIM.Reg) & 0x70000) >> 16
}

// SFR.UTMIFSTRIM: UTMI Full Speed Trimming Register
func (o *SFR_Type) SetUTMIFSTRIM_RISE(value uint32) {
	volatile.StoreUint32(&o.UTMIFSTRIM.Reg, volatile.LoadUint32(&o.UTMIFSTRIM.Reg)&^(0x7)|value)
}
func (o *SFR_Type) GetUTMIFSTRIM_RISE() uint32 {
	return volatile.LoadUint32(&o.UTMIFSTRIM.Reg) & 0x7
}
func (o *SFR_Type) SetUTMIFSTRIM_FALL(value uint32) {
	volatile.StoreUint32(&o.UTMIFSTRIM.Reg, volatile.LoadUint32(&o.UTMIFSTRIM.Reg)&^(0x70)|value<<4)
}
func (o *SFR_Type) GetUTMIFSTRIM_FALL() uint32 {
	return (volatile.LoadUint32(&o.UTMIFSTRIM.Reg) & 0x70) >> 4
}
func (o *SFR_Type) SetUTMIFSTRIM_XCVR(value uint32) {
	volatile.StoreUint32(&o.UTMIFSTRIM.Reg, volatile.LoadUint32(&o.UTMIFSTRIM.Reg)&^(0x300)|value<<8)
}
func (o *SFR_Type) GetUTMIFSTRIM_XCVR() uint32 {
	return (volatile.LoadUint32(&o.UTMIFSTRIM.Reg) & 0x300) >> 8
}
func (o *SFR_Type) SetUTMIFSTRIM_ZN(value uint32) {
	volatile.StoreUint32(&o.UTMIFSTRIM.Reg, volatile.LoadUint32(&o.UTMIFSTRIM.Reg)&^(0x70000)|value<<16)
}
func (o *SFR_Type) GetUTMIFSTRIM_ZN() uint32 {
	return (volatile.LoadUint32(&o.UTMIFSTRIM.Reg) & 0x70000) >> 16
}
func (o *SFR_Type) SetUTMIFSTRIM_ZP(value uint32) {
	volatile.StoreUint32(&o.UTMIFSTRIM.Reg, volatile.LoadUint32(&o.UTMIFSTRIM.Reg)&^(0x700000)|value<<20)
}
func (o *SFR_Type) GetUTMIFSTRIM_ZP() uint32 {
	return (volatile.LoadUint32(&o.UTMIFSTRIM.Reg) & 0x700000) >> 20
}

// SFR.UTMISWAP: UTMI DP/DM Pin Swapping Register
func (o *SFR_Type) SetUTMISWAP_PORT0(value uint32) {
	volatile.StoreUint32(&o.UTMISWAP.Reg, volatile.LoadUint32(&o.UTMISWAP.Reg)&^(0x1)|value)
}
func (o *SFR_Type) GetUTMISWAP_PORT0() uint32 {
	return volatile.LoadUint32(&o.UTMISWAP.Reg) & 0x1
}
func (o *SFR_Type) SetUTMISWAP_PORT1(value uint32) {
	volatile.StoreUint32(&o.UTMISWAP.Reg, volatile.LoadUint32(&o.UTMISWAP.Reg)&^(0x2)|value<<1)
}
func (o *SFR_Type) GetUTMISWAP_PORT1() uint32 {
	return (volatile.LoadUint32(&o.UTMISWAP.Reg) & 0x2) >> 1
}
func (o *SFR_Type) SetUTMISWAP_PORT2(value uint32) {
	volatile.StoreUint32(&o.UTMISWAP.Reg, volatile.LoadUint32(&o.UTMISWAP.Reg)&^(0x4)|value<<2)
}
func (o *SFR_Type) GetUTMISWAP_PORT2() uint32 {
	return (volatile.LoadUint32(&o.UTMISWAP.Reg) & 0x4) >> 2
}

// SFR.EBICFG: EBI Configuration Register
func (o *SFR_Type) SetEBICFG_DRIVE0(value uint32) {
	volatile.StoreUint32(&o.EBICFG.Reg, volatile.LoadUint32(&o.EBICFG.Reg)&^(0x3)|value)
}
func (o *SFR_Type) GetEBICFG_DRIVE0() uint32 {
	return volatile.LoadUint32(&o.EBICFG.Reg) & 0x3
}
func (o *SFR_Type) SetEBICFG_PULL0(value uint32) {
	volatile.StoreUint32(&o.EBICFG.Reg, volatile.LoadUint32(&o.EBICFG.Reg)&^(0xc)|value<<2)
}
func (o *SFR_Type) GetEBICFG_PULL0() uint32 {
	return (volatile.LoadUint32(&o.EBICFG.Reg) & 0xc) >> 2
}
func (o *SFR_Type) SetEBICFG_SCH0(value uint32) {
	volatile.StoreUint32(&o.EBICFG.Reg, volatile.LoadUint32(&o.EBICFG.Reg)&^(0x10)|value<<4)
}
func (o *SFR_Type) GetEBICFG_SCH0() uint32 {
	return (volatile.LoadUint32(&o.EBICFG.Reg) & 0x10) >> 4
}
func (o *SFR_Type) SetEBICFG_DRIVE1(value uint32) {
	volatile.StoreUint32(&o.EBICFG.Reg, volatile.LoadUint32(&o.EBICFG.Reg)&^(0x300)|value<<8)
}
func (o *SFR_Type) GetEBICFG_DRIVE1() uint32 {
	return (volatile.LoadUint32(&o.EBICFG.Reg) & 0x300) >> 8
}
func (o *SFR_Type) SetEBICFG_PULL1(value uint32) {
	volatile.StoreUint32(&o.EBICFG.Reg, volatile.LoadUint32(&o.EBICFG.Reg)&^(0xc00)|value<<10)
}
func (o *SFR_Type) GetEBICFG_PULL1() uint32 {
	return (volatile.LoadUint32(&o.EBICFG.Reg) & 0xc00) >> 10
}
func (o *SFR_Type) SetEBICFG_SCH1(value uint32) {
	volatile.StoreUint32(&o.EBICFG.Reg, volatile.LoadUint32(&o.EBICFG.Reg)&^(0x1000)|value<<12)
}
func (o *SFR_Type) GetEBICFG_SCH1() uint32 {
	return (volatile.LoadUint32(&o.EBICFG.Reg) & 0x1000) >> 12
}
func (o *SFR_Type) SetEBICFG_BMS(value uint32) {
	volatile.StoreUint32(&o.EBICFG.Reg, volatile.LoadUint32(&o.EBICFG.Reg)&^(0x10000)|value<<16)
}
func (o *SFR_Type) GetEBICFG_BMS() uint32 {
	return (volatile.LoadUint32(&o.EBICFG.Reg) & 0x10000) >> 16
}

// Analog-to-Digital Converter
type ADC_Type struct {
	CR     volatile.Register32 // 0x0
	MR     volatile.Register32 // 0x4
	SEQR1  volatile.Register32 // 0x8
	SEQR2  volatile.Register32 // 0xC
	CHER   volatile.Register32 // 0x10
	CHDR   volatile.Register32 // 0x14
	CHSR   volatile.Register32 // 0x18
	_      [4]byte
	LCDR   volatile.Register32 // 0x20
	IER    volatile.Register32 // 0x24
	IDR    volatile.Register32 // 0x28
	IMR    volatile.Register32 // 0x2C
	ISR    volatile.Register32 // 0x30
	_      [8]byte
	OVER   volatile.Register32     // 0x3C
	EMR    volatile.Register32     // 0x40
	CWR    volatile.Register32     // 0x44
	CGR    volatile.Register32     // 0x48
	COR    volatile.Register32     // 0x4C
	CDR    [12]volatile.Register32 // 0x50
	_      [20]byte
	ACR    volatile.Register32 // 0x94
	_      [24]byte
	TSMR   volatile.Register32 // 0xB0
	XPOSR  volatile.Register32 // 0xB4
	YPOSR  volatile.Register32 // 0xB8
	PRESSR volatile.Register32 // 0xBC
	TRGR   volatile.Register32 // 0xC0
	_      [32]byte
	WPMR   volatile.Register32 // 0xE4
	WPSR   volatile.Register32 // 0xE8
}

// ADC.CR: Control Register
func (o *ADC_Type) SetCR_SWRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCR_SWRST() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *ADC_Type) SetCR_START(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCR_START() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCR_TSCALIB(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetCR_TSCALIB() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetCR_AUTOCAL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetCR_AUTOCAL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}

// ADC.MR: Mode Register
func (o *ADC_Type) SetMR_TRGSEL(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xe)|value<<1)
}
func (o *ADC_Type) GetMR_TRGSEL() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xe) >> 1
}
func (o *ADC_Type) SetMR_SLEEP(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetMR_SLEEP() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetMR_FWUP(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetMR_FWUP() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetMR_PRESCAL(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xff00)|value<<8)
}
func (o *ADC_Type) GetMR_PRESCAL() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xff00) >> 8
}
func (o *ADC_Type) SetMR_STARTUP(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_Type) GetMR_STARTUP() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf0000) >> 16
}
func (o *ADC_Type) SetMR_SETTLING(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x300000)|value<<20)
}
func (o *ADC_Type) GetMR_SETTLING() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x300000) >> 20
}
func (o *ADC_Type) SetMR_ANACH(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_Type) GetMR_ANACH() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x800000) >> 23
}
func (o *ADC_Type) SetMR_TRACKTIM(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf000000)|value<<24)
}
func (o *ADC_Type) GetMR_TRACKTIM() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf000000) >> 24
}
func (o *ADC_Type) SetMR_USEQ(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetMR_USEQ() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x80000000) >> 31
}

// ADC.SEQR1: Channel Sequence Register 1
func (o *ADC_Type) SetSEQR1_USCH1(value uint32) {
	volatile.StoreUint32(&o.SEQR1.Reg, volatile.LoadUint32(&o.SEQR1.Reg)&^(0xf)|value)
}
func (o *ADC_Type) GetSEQR1_USCH1() uint32 {
	return volatile.LoadUint32(&o.SEQR1.Reg) & 0xf
}
func (o *ADC_Type) SetSEQR1_USCH2(value uint32) {
	volatile.StoreUint32(&o.SEQR1.Reg, volatile.LoadUint32(&o.SEQR1.Reg)&^(0xf0)|value<<4)
}
func (o *ADC_Type) GetSEQR1_USCH2() uint32 {
	return (volatile.LoadUint32(&o.SEQR1.Reg) & 0xf0) >> 4
}
func (o *ADC_Type) SetSEQR1_USCH3(value uint32) {
	volatile.StoreUint32(&o.SEQR1.Reg, volatile.LoadUint32(&o.SEQR1.Reg)&^(0xf00)|value<<8)
}
func (o *ADC_Type) GetSEQR1_USCH3() uint32 {
	return (volatile.LoadUint32(&o.SEQR1.Reg) & 0xf00) >> 8
}
func (o *ADC_Type) SetSEQR1_USCH4(value uint32) {
	volatile.StoreUint32(&o.SEQR1.Reg, volatile.LoadUint32(&o.SEQR1.Reg)&^(0xf000)|value<<12)
}
func (o *ADC_Type) GetSEQR1_USCH4() uint32 {
	return (volatile.LoadUint32(&o.SEQR1.Reg) & 0xf000) >> 12
}
func (o *ADC_Type) SetSEQR1_USCH5(value uint32) {
	volatile.StoreUint32(&o.SEQR1.Reg, volatile.LoadUint32(&o.SEQR1.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_Type) GetSEQR1_USCH5() uint32 {
	return (volatile.LoadUint32(&o.SEQR1.Reg) & 0xf0000) >> 16
}
func (o *ADC_Type) SetSEQR1_USCH6(value uint32) {
	volatile.StoreUint32(&o.SEQR1.Reg, volatile.LoadUint32(&o.SEQR1.Reg)&^(0xf00000)|value<<20)
}
func (o *ADC_Type) GetSEQR1_USCH6() uint32 {
	return (volatile.LoadUint32(&o.SEQR1.Reg) & 0xf00000) >> 20
}
func (o *ADC_Type) SetSEQR1_USCH7(value uint32) {
	volatile.StoreUint32(&o.SEQR1.Reg, volatile.LoadUint32(&o.SEQR1.Reg)&^(0xf000000)|value<<24)
}
func (o *ADC_Type) GetSEQR1_USCH7() uint32 {
	return (volatile.LoadUint32(&o.SEQR1.Reg) & 0xf000000) >> 24
}
func (o *ADC_Type) SetSEQR1_USCH8(value uint32) {
	volatile.StoreUint32(&o.SEQR1.Reg, volatile.LoadUint32(&o.SEQR1.Reg)&^(0xf0000000)|value<<28)
}
func (o *ADC_Type) GetSEQR1_USCH8() uint32 {
	return (volatile.LoadUint32(&o.SEQR1.Reg) & 0xf0000000) >> 28
}

// ADC.SEQR2: Channel Sequence Register 2
func (o *ADC_Type) SetSEQR2_USCH9(value uint32) {
	volatile.StoreUint32(&o.SEQR2.Reg, volatile.LoadUint32(&o.SEQR2.Reg)&^(0xf)|value)
}
func (o *ADC_Type) GetSEQR2_USCH9() uint32 {
	return volatile.LoadUint32(&o.SEQR2.Reg) & 0xf
}
func (o *ADC_Type) SetSEQR2_USCH10(value uint32) {
	volatile.StoreUint32(&o.SEQR2.Reg, volatile.LoadUint32(&o.SEQR2.Reg)&^(0xf0)|value<<4)
}
func (o *ADC_Type) GetSEQR2_USCH10() uint32 {
	return (volatile.LoadUint32(&o.SEQR2.Reg) & 0xf0) >> 4
}
func (o *ADC_Type) SetSEQR2_USCH11(value uint32) {
	volatile.StoreUint32(&o.SEQR2.Reg, volatile.LoadUint32(&o.SEQR2.Reg)&^(0xf00)|value<<8)
}
func (o *ADC_Type) GetSEQR2_USCH11() uint32 {
	return (volatile.LoadUint32(&o.SEQR2.Reg) & 0xf00) >> 8
}

// ADC.CHER: Channel Enable Register
func (o *ADC_Type) SetCHER_CH0(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCHER_CH0() uint32 {
	return volatile.LoadUint32(&o.CHER.Reg) & 0x1
}
func (o *ADC_Type) SetCHER_CH1(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCHER_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCHER_CH2(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetCHER_CH2() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetCHER_CH3(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetCHER_CH3() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetCHER_CH4(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetCHER_CH4() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetCHER_CH5(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetCHER_CH5() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetCHER_CH6(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetCHER_CH6() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetCHER_CH7(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetCHER_CH7() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetCHER_CH8(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetCHER_CH8() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetCHER_CH9(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetCHER_CH9() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetCHER_CH10(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetCHER_CH10() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetCHER_CH11(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetCHER_CH11() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x800) >> 11
}

// ADC.CHDR: Channel Disable Register
func (o *ADC_Type) SetCHDR_CH0(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCHDR_CH0() uint32 {
	return volatile.LoadUint32(&o.CHDR.Reg) & 0x1
}
func (o *ADC_Type) SetCHDR_CH1(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCHDR_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCHDR_CH2(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetCHDR_CH2() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetCHDR_CH3(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetCHDR_CH3() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetCHDR_CH4(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetCHDR_CH4() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetCHDR_CH5(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetCHDR_CH5() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetCHDR_CH6(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetCHDR_CH6() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetCHDR_CH7(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetCHDR_CH7() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetCHDR_CH8(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetCHDR_CH8() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetCHDR_CH9(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetCHDR_CH9() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetCHDR_CH10(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetCHDR_CH10() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetCHDR_CH11(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetCHDR_CH11() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x800) >> 11
}

// ADC.CHSR: Channel Status Register
func (o *ADC_Type) SetCHSR_CH0(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCHSR_CH0() uint32 {
	return volatile.LoadUint32(&o.CHSR.Reg) & 0x1
}
func (o *ADC_Type) SetCHSR_CH1(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCHSR_CH1() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCHSR_CH2(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetCHSR_CH2() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetCHSR_CH3(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetCHSR_CH3() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetCHSR_CH4(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetCHSR_CH4() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetCHSR_CH5(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetCHSR_CH5() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetCHSR_CH6(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetCHSR_CH6() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetCHSR_CH7(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetCHSR_CH7() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetCHSR_CH8(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetCHSR_CH8() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetCHSR_CH9(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetCHSR_CH9() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetCHSR_CH10(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetCHSR_CH10() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetCHSR_CH11(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetCHSR_CH11() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x800) >> 11
}

// ADC.LCDR: Last Converted Data Register
func (o *ADC_Type) SetLCDR_LDATA(value uint32) {
	volatile.StoreUint32(&o.LCDR.Reg, volatile.LoadUint32(&o.LCDR.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetLCDR_LDATA() uint32 {
	return volatile.LoadUint32(&o.LCDR.Reg) & 0xfff
}
func (o *ADC_Type) SetLCDR_CHNB(value uint32) {
	volatile.StoreUint32(&o.LCDR.Reg, volatile.LoadUint32(&o.LCDR.Reg)&^(0xf000)|value<<12)
}
func (o *ADC_Type) GetLCDR_CHNB() uint32 {
	return (volatile.LoadUint32(&o.LCDR.Reg) & 0xf000) >> 12
}

// ADC.IER: Interrupt Enable Register
func (o *ADC_Type) SetIER_EOC0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetIER_EOC0() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *ADC_Type) SetIER_EOC1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetIER_EOC1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetIER_EOC2(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetIER_EOC2() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetIER_EOC3(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetIER_EOC3() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetIER_EOC4(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetIER_EOC4() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetIER_EOC5(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetIER_EOC5() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetIER_EOC6(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetIER_EOC6() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetIER_EOC7(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetIER_EOC7() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetIER_EOC8(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetIER_EOC8() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetIER_EOC9(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetIER_EOC9() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetIER_EOC10(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetIER_EOC10() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetIER_EOC11(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetIER_EOC11() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetIER_XRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100000)|value<<20)
}
func (o *ADC_Type) GetIER_XRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100000) >> 20
}
func (o *ADC_Type) SetIER_YRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200000)|value<<21)
}
func (o *ADC_Type) GetIER_YRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200000) >> 21
}
func (o *ADC_Type) SetIER_PRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_Type) GetIER_PRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400000) >> 22
}
func (o *ADC_Type) SetIER_EOCAL(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_Type) GetIER_EOCAL() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800000) >> 23
}
func (o *ADC_Type) SetIER_DRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *ADC_Type) GetIER_DRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}
func (o *ADC_Type) SetIER_GOVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000000)|value<<25)
}
func (o *ADC_Type) GetIER_GOVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000000) >> 25
}
func (o *ADC_Type) SetIER_COMPE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000000)|value<<26)
}
func (o *ADC_Type) GetIER_COMPE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000000) >> 26
}
func (o *ADC_Type) SetIER_PEN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000000)|value<<29)
}
func (o *ADC_Type) GetIER_PEN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000000) >> 29
}
func (o *ADC_Type) SetIER_NOPEN(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetIER_NOPEN() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000000) >> 30
}

// ADC.IDR: Interrupt Disable Register
func (o *ADC_Type) SetIDR_EOC0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetIDR_EOC0() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *ADC_Type) SetIDR_EOC1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetIDR_EOC1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetIDR_EOC2(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetIDR_EOC2() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetIDR_EOC3(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetIDR_EOC3() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetIDR_EOC4(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetIDR_EOC4() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetIDR_EOC5(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetIDR_EOC5() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetIDR_EOC6(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetIDR_EOC6() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetIDR_EOC7(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetIDR_EOC7() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetIDR_EOC8(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetIDR_EOC8() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetIDR_EOC9(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetIDR_EOC9() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetIDR_EOC10(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetIDR_EOC10() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetIDR_EOC11(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetIDR_EOC11() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetIDR_XRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100000)|value<<20)
}
func (o *ADC_Type) GetIDR_XRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100000) >> 20
}
func (o *ADC_Type) SetIDR_YRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200000)|value<<21)
}
func (o *ADC_Type) GetIDR_YRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200000) >> 21
}
func (o *ADC_Type) SetIDR_PRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_Type) GetIDR_PRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400000) >> 22
}
func (o *ADC_Type) SetIDR_EOCAL(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_Type) GetIDR_EOCAL() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800000) >> 23
}
func (o *ADC_Type) SetIDR_DRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *ADC_Type) GetIDR_DRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}
func (o *ADC_Type) SetIDR_GOVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000000)|value<<25)
}
func (o *ADC_Type) GetIDR_GOVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000000) >> 25
}
func (o *ADC_Type) SetIDR_COMPE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000000)|value<<26)
}
func (o *ADC_Type) GetIDR_COMPE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000000) >> 26
}
func (o *ADC_Type) SetIDR_PEN(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000000)|value<<29)
}
func (o *ADC_Type) GetIDR_PEN() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000000) >> 29
}
func (o *ADC_Type) SetIDR_NOPEN(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetIDR_NOPEN() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000000) >> 30
}

// ADC.IMR: Interrupt Mask Register
func (o *ADC_Type) SetIMR_EOC0(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetIMR_EOC0() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *ADC_Type) SetIMR_EOC1(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetIMR_EOC1() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetIMR_EOC2(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetIMR_EOC2() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetIMR_EOC3(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetIMR_EOC3() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetIMR_EOC4(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetIMR_EOC4() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetIMR_EOC5(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetIMR_EOC5() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetIMR_EOC6(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetIMR_EOC6() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetIMR_EOC7(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetIMR_EOC7() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetIMR_EOC8(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetIMR_EOC8() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetIMR_EOC9(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetIMR_EOC9() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetIMR_EOC10(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetIMR_EOC10() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetIMR_EOC11(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetIMR_EOC11() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetIMR_XRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100000)|value<<20)
}
func (o *ADC_Type) GetIMR_XRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100000) >> 20
}
func (o *ADC_Type) SetIMR_YRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200000)|value<<21)
}
func (o *ADC_Type) GetIMR_YRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200000) >> 21
}
func (o *ADC_Type) SetIMR_PRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_Type) GetIMR_PRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400000) >> 22
}
func (o *ADC_Type) SetIMR_EOCAL(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_Type) GetIMR_EOCAL() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800000) >> 23
}
func (o *ADC_Type) SetIMR_DRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *ADC_Type) GetIMR_DRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}
func (o *ADC_Type) SetIMR_GOVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000000)|value<<25)
}
func (o *ADC_Type) GetIMR_GOVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000000) >> 25
}
func (o *ADC_Type) SetIMR_COMPE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000000)|value<<26)
}
func (o *ADC_Type) GetIMR_COMPE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000000) >> 26
}
func (o *ADC_Type) SetIMR_PEN(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000000)|value<<29)
}
func (o *ADC_Type) GetIMR_PEN() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000000) >> 29
}
func (o *ADC_Type) SetIMR_NOPEN(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetIMR_NOPEN() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000000) >> 30
}

// ADC.ISR: Interrupt Status Register
func (o *ADC_Type) SetISR_EOC0(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetISR_EOC0() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *ADC_Type) SetISR_EOC1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetISR_EOC1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetISR_EOC2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetISR_EOC2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetISR_EOC3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetISR_EOC3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetISR_EOC4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetISR_EOC4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetISR_EOC5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetISR_EOC5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetISR_EOC6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetISR_EOC6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetISR_EOC7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetISR_EOC7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetISR_EOC8(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetISR_EOC8() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetISR_EOC9(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetISR_EOC9() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetISR_EOC10(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetISR_EOC10() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetISR_EOC11(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetISR_EOC11() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetISR_XRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100000)|value<<20)
}
func (o *ADC_Type) GetISR_XRDY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100000) >> 20
}
func (o *ADC_Type) SetISR_YRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200000)|value<<21)
}
func (o *ADC_Type) GetISR_YRDY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200000) >> 21
}
func (o *ADC_Type) SetISR_PRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_Type) GetISR_PRDY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400000) >> 22
}
func (o *ADC_Type) SetISR_EOCAL(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_Type) GetISR_EOCAL() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800000) >> 23
}
func (o *ADC_Type) SetISR_DRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000000)|value<<24)
}
func (o *ADC_Type) GetISR_DRDY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000000) >> 24
}
func (o *ADC_Type) SetISR_GOVRE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000000)|value<<25)
}
func (o *ADC_Type) GetISR_GOVRE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000000) >> 25
}
func (o *ADC_Type) SetISR_COMPE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000000)|value<<26)
}
func (o *ADC_Type) GetISR_COMPE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000000) >> 26
}
func (o *ADC_Type) SetISR_PEN(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000000)|value<<29)
}
func (o *ADC_Type) GetISR_PEN() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000000) >> 29
}
func (o *ADC_Type) SetISR_NOPEN(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetISR_NOPEN() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000000) >> 30
}
func (o *ADC_Type) SetISR_PENS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetISR_PENS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000000) >> 31
}

// ADC.OVER: Overrun Status Register
func (o *ADC_Type) SetOVER_OVRE0(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetOVER_OVRE0() uint32 {
	return volatile.LoadUint32(&o.OVER.Reg) & 0x1
}
func (o *ADC_Type) SetOVER_OVRE1(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetOVER_OVRE1() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetOVER_OVRE2(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetOVER_OVRE2() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetOVER_OVRE3(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetOVER_OVRE3() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetOVER_OVRE4(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetOVER_OVRE4() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetOVER_OVRE5(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetOVER_OVRE5() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetOVER_OVRE6(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetOVER_OVRE6() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetOVER_OVRE7(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetOVER_OVRE7() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetOVER_OVRE8(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetOVER_OVRE8() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetOVER_OVRE9(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetOVER_OVRE9() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetOVER_OVRE10(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetOVER_OVRE10() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetOVER_OVRE11(value uint32) {
	volatile.StoreUint32(&o.OVER.Reg, volatile.LoadUint32(&o.OVER.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetOVER_OVRE11() uint32 {
	return (volatile.LoadUint32(&o.OVER.Reg) & 0x800) >> 11
}

// ADC.EMR: Extended Mode Register
func (o *ADC_Type) SetEMR_CMPMODE(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x3)|value)
}
func (o *ADC_Type) GetEMR_CMPMODE() uint32 {
	return volatile.LoadUint32(&o.EMR.Reg) & 0x3
}
func (o *ADC_Type) SetEMR_CMPSEL(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0xf0)|value<<4)
}
func (o *ADC_Type) GetEMR_CMPSEL() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0xf0) >> 4
}
func (o *ADC_Type) SetEMR_CMPALL(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetEMR_CMPALL() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetEMR_CMPFILTER(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x3000)|value<<12)
}
func (o *ADC_Type) GetEMR_CMPFILTER() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x3000) >> 12
}
func (o *ADC_Type) SetEMR_TAG(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x1000000)|value<<24)
}
func (o *ADC_Type) GetEMR_TAG() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x1000000) >> 24
}

// ADC.CWR: Compare Window Register
func (o *ADC_Type) SetCWR_LOWTHRES(value uint32) {
	volatile.StoreUint32(&o.CWR.Reg, volatile.LoadUint32(&o.CWR.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetCWR_LOWTHRES() uint32 {
	return volatile.LoadUint32(&o.CWR.Reg) & 0xfff
}
func (o *ADC_Type) SetCWR_HIGHTHRES(value uint32) {
	volatile.StoreUint32(&o.CWR.Reg, volatile.LoadUint32(&o.CWR.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_Type) GetCWR_HIGHTHRES() uint32 {
	return (volatile.LoadUint32(&o.CWR.Reg) & 0xfff0000) >> 16
}

// ADC.CGR: Channel Gain Register
func (o *ADC_Type) SetCGR_GAIN0(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0x3)|value)
}
func (o *ADC_Type) GetCGR_GAIN0() uint32 {
	return volatile.LoadUint32(&o.CGR.Reg) & 0x3
}
func (o *ADC_Type) SetCGR_GAIN1(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0xc)|value<<2)
}
func (o *ADC_Type) GetCGR_GAIN1() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0xc) >> 2
}
func (o *ADC_Type) SetCGR_GAIN2(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0x30)|value<<4)
}
func (o *ADC_Type) GetCGR_GAIN2() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0x30) >> 4
}
func (o *ADC_Type) SetCGR_GAIN3(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0xc0)|value<<6)
}
func (o *ADC_Type) GetCGR_GAIN3() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0xc0) >> 6
}
func (o *ADC_Type) SetCGR_GAIN4(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0x300)|value<<8)
}
func (o *ADC_Type) GetCGR_GAIN4() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0x300) >> 8
}
func (o *ADC_Type) SetCGR_GAIN5(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0xc00)|value<<10)
}
func (o *ADC_Type) GetCGR_GAIN5() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0xc00) >> 10
}
func (o *ADC_Type) SetCGR_GAIN6(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0x3000)|value<<12)
}
func (o *ADC_Type) GetCGR_GAIN6() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0x3000) >> 12
}
func (o *ADC_Type) SetCGR_GAIN7(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0xc000)|value<<14)
}
func (o *ADC_Type) GetCGR_GAIN7() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0xc000) >> 14
}
func (o *ADC_Type) SetCGR_GAIN8(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0x30000)|value<<16)
}
func (o *ADC_Type) GetCGR_GAIN8() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0x30000) >> 16
}
func (o *ADC_Type) SetCGR_GAIN9(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0xc0000)|value<<18)
}
func (o *ADC_Type) GetCGR_GAIN9() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0xc0000) >> 18
}
func (o *ADC_Type) SetCGR_GAIN10(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0x300000)|value<<20)
}
func (o *ADC_Type) GetCGR_GAIN10() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0x300000) >> 20
}
func (o *ADC_Type) SetCGR_GAIN11(value uint32) {
	volatile.StoreUint32(&o.CGR.Reg, volatile.LoadUint32(&o.CGR.Reg)&^(0xc00000)|value<<22)
}
func (o *ADC_Type) GetCGR_GAIN11() uint32 {
	return (volatile.LoadUint32(&o.CGR.Reg) & 0xc00000) >> 22
}

// ADC.COR: Channel Offset Register
func (o *ADC_Type) SetCOR_OFF0(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCOR_OFF0() uint32 {
	return volatile.LoadUint32(&o.COR.Reg) & 0x1
}
func (o *ADC_Type) SetCOR_OFF1(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCOR_OFF1() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCOR_OFF2(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetCOR_OFF2() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetCOR_OFF3(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetCOR_OFF3() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetCOR_OFF4(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetCOR_OFF4() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetCOR_OFF5(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetCOR_OFF5() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetCOR_OFF6(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetCOR_OFF6() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetCOR_OFF7(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetCOR_OFF7() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetCOR_OFF8(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetCOR_OFF8() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetCOR_OFF9(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetCOR_OFF9() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetCOR_OFF10(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetCOR_OFF10() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetCOR_OFF11(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetCOR_OFF11() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetCOR_DIFF0(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_Type) GetCOR_DIFF0() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x10000) >> 16
}
func (o *ADC_Type) SetCOR_DIFF1(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x20000)|value<<17)
}
func (o *ADC_Type) GetCOR_DIFF1() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x20000) >> 17
}
func (o *ADC_Type) SetCOR_DIFF2(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x40000)|value<<18)
}
func (o *ADC_Type) GetCOR_DIFF2() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x40000) >> 18
}
func (o *ADC_Type) SetCOR_DIFF3(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x80000)|value<<19)
}
func (o *ADC_Type) GetCOR_DIFF3() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x80000) >> 19
}
func (o *ADC_Type) SetCOR_DIFF4(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x100000)|value<<20)
}
func (o *ADC_Type) GetCOR_DIFF4() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x100000) >> 20
}
func (o *ADC_Type) SetCOR_DIFF5(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x200000)|value<<21)
}
func (o *ADC_Type) GetCOR_DIFF5() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x200000) >> 21
}
func (o *ADC_Type) SetCOR_DIFF6(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_Type) GetCOR_DIFF6() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x400000) >> 22
}
func (o *ADC_Type) SetCOR_DIFF7(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_Type) GetCOR_DIFF7() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x800000) >> 23
}
func (o *ADC_Type) SetCOR_DIFF8(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x1000000)|value<<24)
}
func (o *ADC_Type) GetCOR_DIFF8() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x1000000) >> 24
}
func (o *ADC_Type) SetCOR_DIFF9(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x2000000)|value<<25)
}
func (o *ADC_Type) GetCOR_DIFF9() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x2000000) >> 25
}
func (o *ADC_Type) SetCOR_DIFF10(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x4000000)|value<<26)
}
func (o *ADC_Type) GetCOR_DIFF10() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x4000000) >> 26
}
func (o *ADC_Type) SetCOR_DIFF11(value uint32) {
	volatile.StoreUint32(&o.COR.Reg, volatile.LoadUint32(&o.COR.Reg)&^(0x8000000)|value<<27)
}
func (o *ADC_Type) GetCOR_DIFF11() uint32 {
	return (volatile.LoadUint32(&o.COR.Reg) & 0x8000000) >> 27
}

// ADC.CDR: Channel Data Register
func (o *ADC_Type) SetCDR_DATA(idx int, value uint32) {
	volatile.StoreUint32(&o.CDR[idx].Reg, volatile.LoadUint32(&o.CDR[idx].Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetCDR_DATA(idx int) uint32 {
	return volatile.LoadUint32(&o.CDR[idx].Reg) & 0xfff
}

// ADC.ACR: Analog Control Register
func (o *ADC_Type) SetACR_PENDETSENS(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x3)|value)
}
func (o *ADC_Type) GetACR_PENDETSENS() uint32 {
	return volatile.LoadUint32(&o.ACR.Reg) & 0x3
}

// ADC.TSMR: Touchscreen Mode Register
func (o *ADC_Type) SetTSMR_TSMODE(value uint32) {
	volatile.StoreUint32(&o.TSMR.Reg, volatile.LoadUint32(&o.TSMR.Reg)&^(0x3)|value)
}
func (o *ADC_Type) GetTSMR_TSMODE() uint32 {
	return volatile.LoadUint32(&o.TSMR.Reg) & 0x3
}
func (o *ADC_Type) SetTSMR_TSAV(value uint32) {
	volatile.StoreUint32(&o.TSMR.Reg, volatile.LoadUint32(&o.TSMR.Reg)&^(0x30)|value<<4)
}
func (o *ADC_Type) GetTSMR_TSAV() uint32 {
	return (volatile.LoadUint32(&o.TSMR.Reg) & 0x30) >> 4
}
func (o *ADC_Type) SetTSMR_TSFREQ(value uint32) {
	volatile.StoreUint32(&o.TSMR.Reg, volatile.LoadUint32(&o.TSMR.Reg)&^(0xf00)|value<<8)
}
func (o *ADC_Type) GetTSMR_TSFREQ() uint32 {
	return (volatile.LoadUint32(&o.TSMR.Reg) & 0xf00) >> 8
}
func (o *ADC_Type) SetTSMR_TSSCTIM(value uint32) {
	volatile.StoreUint32(&o.TSMR.Reg, volatile.LoadUint32(&o.TSMR.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_Type) GetTSMR_TSSCTIM() uint32 {
	return (volatile.LoadUint32(&o.TSMR.Reg) & 0xf0000) >> 16
}
func (o *ADC_Type) SetTSMR_NOTSDMA(value uint32) {
	volatile.StoreUint32(&o.TSMR.Reg, volatile.LoadUint32(&o.TSMR.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_Type) GetTSMR_NOTSDMA() uint32 {
	return (volatile.LoadUint32(&o.TSMR.Reg) & 0x400000) >> 22
}
func (o *ADC_Type) SetTSMR_PENDET(value uint32) {
	volatile.StoreUint32(&o.TSMR.Reg, volatile.LoadUint32(&o.TSMR.Reg)&^(0x1000000)|value<<24)
}
func (o *ADC_Type) GetTSMR_PENDET() uint32 {
	return (volatile.LoadUint32(&o.TSMR.Reg) & 0x1000000) >> 24
}
func (o *ADC_Type) SetTSMR_PENDBC(value uint32) {
	volatile.StoreUint32(&o.TSMR.Reg, volatile.LoadUint32(&o.TSMR.Reg)&^(0xf0000000)|value<<28)
}
func (o *ADC_Type) GetTSMR_PENDBC() uint32 {
	return (volatile.LoadUint32(&o.TSMR.Reg) & 0xf0000000) >> 28
}

// ADC.XPOSR: Touchscreen X Position Register
func (o *ADC_Type) SetXPOSR_XPOS(value uint32) {
	volatile.StoreUint32(&o.XPOSR.Reg, volatile.LoadUint32(&o.XPOSR.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetXPOSR_XPOS() uint32 {
	return volatile.LoadUint32(&o.XPOSR.Reg) & 0xfff
}
func (o *ADC_Type) SetXPOSR_XSCALE(value uint32) {
	volatile.StoreUint32(&o.XPOSR.Reg, volatile.LoadUint32(&o.XPOSR.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_Type) GetXPOSR_XSCALE() uint32 {
	return (volatile.LoadUint32(&o.XPOSR.Reg) & 0xfff0000) >> 16
}

// ADC.YPOSR: Touchscreen Y Position Register
func (o *ADC_Type) SetYPOSR_YPOS(value uint32) {
	volatile.StoreUint32(&o.YPOSR.Reg, volatile.LoadUint32(&o.YPOSR.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetYPOSR_YPOS() uint32 {
	return volatile.LoadUint32(&o.YPOSR.Reg) & 0xfff
}
func (o *ADC_Type) SetYPOSR_YSCALE(value uint32) {
	volatile.StoreUint32(&o.YPOSR.Reg, volatile.LoadUint32(&o.YPOSR.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_Type) GetYPOSR_YSCALE() uint32 {
	return (volatile.LoadUint32(&o.YPOSR.Reg) & 0xfff0000) >> 16
}

// ADC.PRESSR: Touchscreen Pressure Register
func (o *ADC_Type) SetPRESSR_Z1(value uint32) {
	volatile.StoreUint32(&o.PRESSR.Reg, volatile.LoadUint32(&o.PRESSR.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetPRESSR_Z1() uint32 {
	return volatile.LoadUint32(&o.PRESSR.Reg) & 0xfff
}
func (o *ADC_Type) SetPRESSR_Z2(value uint32) {
	volatile.StoreUint32(&o.PRESSR.Reg, volatile.LoadUint32(&o.PRESSR.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_Type) GetPRESSR_Z2() uint32 {
	return (volatile.LoadUint32(&o.PRESSR.Reg) & 0xfff0000) >> 16
}

// ADC.TRGR: Trigger Register
func (o *ADC_Type) SetTRGR_TRGMOD(value uint32) {
	volatile.StoreUint32(&o.TRGR.Reg, volatile.LoadUint32(&o.TRGR.Reg)&^(0x7)|value)
}
func (o *ADC_Type) GetTRGR_TRGMOD() uint32 {
	return volatile.LoadUint32(&o.TRGR.Reg) & 0x7
}
func (o *ADC_Type) SetTRGR_TRGPER(value uint32) {
	volatile.StoreUint32(&o.TRGR.Reg, volatile.LoadUint32(&o.TRGR.Reg)&^(0xffff0000)|value<<16)
}
func (o *ADC_Type) GetTRGR_TRGPER() uint32 {
	return (volatile.LoadUint32(&o.TRGR.Reg) & 0xffff0000) >> 16
}

// ADC.WPMR: Write Protect Mode Register
func (o *ADC_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *ADC_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *ADC_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// ADC.WPSR: Write Protect Status Register
func (o *ADC_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *ADC_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *ADC_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// Ethernet MAC 10/100
type EMAC_Type struct {
	NCR   volatile.Register32 // 0x0
	NCFGR volatile.Register32 // 0x4
	NSR   volatile.Register32 // 0x8
	_     [8]byte
	TSR   volatile.Register32 // 0x14
	RBQP  volatile.Register32 // 0x18
	TBQP  volatile.Register32 // 0x1C
	RSR   volatile.Register32 // 0x20
	ISR   volatile.Register32 // 0x24
	IER   volatile.Register32 // 0x28
	IDR   volatile.Register32 // 0x2C
	IMR   volatile.Register32 // 0x30
	MAN   volatile.Register32 // 0x34
	PTR   volatile.Register32 // 0x38
	PFR   volatile.Register32 // 0x3C
	FTO   volatile.Register32 // 0x40
	SCF   volatile.Register32 // 0x44
	MCF   volatile.Register32 // 0x48
	FRO   volatile.Register32 // 0x4C
	FCSE  volatile.Register32 // 0x50
	ALE   volatile.Register32 // 0x54
	DTF   volatile.Register32 // 0x58
	LCOL  volatile.Register32 // 0x5C
	ECOL  volatile.Register32 // 0x60
	TUND  volatile.Register32 // 0x64
	CSE   volatile.Register32 // 0x68
	RRE   volatile.Register32 // 0x6C
	ROV   volatile.Register32 // 0x70
	RSE   volatile.Register32 // 0x74
	ELE   volatile.Register32 // 0x78
	RJA   volatile.Register32 // 0x7C
	USF   volatile.Register32 // 0x80
	STE   volatile.Register32 // 0x84
	RLE   volatile.Register32 // 0x88
	_     [4]byte
	HRB   volatile.Register32 // 0x90
	HRT   volatile.Register32 // 0x94
	SA1B  volatile.Register32 // 0x98
	SA1T  volatile.Register32 // 0x9C
	SA2B  volatile.Register32 // 0xA0
	SA2T  volatile.Register32 // 0xA4
	SA3B  volatile.Register32 // 0xA8
	SA3T  volatile.Register32 // 0xAC
	SA4B  volatile.Register32 // 0xB0
	SA4T  volatile.Register32 // 0xB4
	TID   volatile.Register32 // 0xB8
	_     [4]byte
	USRIO volatile.Register32 // 0xC0
	WOL   volatile.Register32 // 0xC4
}

// EMAC.NCR: Network Control Register
func (o *EMAC_Type) SetNCR_LB(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetNCR_LB() uint32 {
	return volatile.LoadUint32(&o.NCR.Reg) & 0x1
}
func (o *EMAC_Type) SetNCR_LLB(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetNCR_LLB() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetNCR_RE(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetNCR_RE() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x4) >> 2
}
func (o *EMAC_Type) SetNCR_TE(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x8)|value<<3)
}
func (o *EMAC_Type) GetNCR_TE() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x8) >> 3
}
func (o *EMAC_Type) SetNCR_MPE(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x10)|value<<4)
}
func (o *EMAC_Type) GetNCR_MPE() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x10) >> 4
}
func (o *EMAC_Type) SetNCR_CLRSTAT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x20)|value<<5)
}
func (o *EMAC_Type) GetNCR_CLRSTAT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x20) >> 5
}
func (o *EMAC_Type) SetNCR_INCSTAT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x40)|value<<6)
}
func (o *EMAC_Type) GetNCR_INCSTAT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x40) >> 6
}
func (o *EMAC_Type) SetNCR_WESTAT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x80)|value<<7)
}
func (o *EMAC_Type) GetNCR_WESTAT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x80) >> 7
}
func (o *EMAC_Type) SetNCR_BP(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x100)|value<<8)
}
func (o *EMAC_Type) GetNCR_BP() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x100) >> 8
}
func (o *EMAC_Type) SetNCR_TSTART(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x200)|value<<9)
}
func (o *EMAC_Type) GetNCR_TSTART() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x200) >> 9
}
func (o *EMAC_Type) SetNCR_THALT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x400)|value<<10)
}
func (o *EMAC_Type) GetNCR_THALT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x400) >> 10
}

// EMAC.NCFGR: Network Configuration Register
func (o *EMAC_Type) SetNCFGR_SPD(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetNCFGR_SPD() uint32 {
	return volatile.LoadUint32(&o.NCFGR.Reg) & 0x1
}
func (o *EMAC_Type) SetNCFGR_FD(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetNCFGR_FD() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetNCFGR_JFRAME(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x8)|value<<3)
}
func (o *EMAC_Type) GetNCFGR_JFRAME() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x8) >> 3
}
func (o *EMAC_Type) SetNCFGR_CAF(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x10)|value<<4)
}
func (o *EMAC_Type) GetNCFGR_CAF() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x10) >> 4
}
func (o *EMAC_Type) SetNCFGR_NBC(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x20)|value<<5)
}
func (o *EMAC_Type) GetNCFGR_NBC() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x20) >> 5
}
func (o *EMAC_Type) SetNCFGR_MTI(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x40)|value<<6)
}
func (o *EMAC_Type) GetNCFGR_MTI() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x40) >> 6
}
func (o *EMAC_Type) SetNCFGR_UNI(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x80)|value<<7)
}
func (o *EMAC_Type) GetNCFGR_UNI() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x80) >> 7
}
func (o *EMAC_Type) SetNCFGR_BIG(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x100)|value<<8)
}
func (o *EMAC_Type) GetNCFGR_BIG() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x100) >> 8
}
func (o *EMAC_Type) SetNCFGR_CLK(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0xc00)|value<<10)
}
func (o *EMAC_Type) GetNCFGR_CLK() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0xc00) >> 10
}
func (o *EMAC_Type) SetNCFGR_RTY(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x1000)|value<<12)
}
func (o *EMAC_Type) GetNCFGR_RTY() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x1000) >> 12
}
func (o *EMAC_Type) SetNCFGR_PAE(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x2000)|value<<13)
}
func (o *EMAC_Type) GetNCFGR_PAE() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x2000) >> 13
}
func (o *EMAC_Type) SetNCFGR_RBOF(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0xc000)|value<<14)
}
func (o *EMAC_Type) GetNCFGR_RBOF() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0xc000) >> 14
}
func (o *EMAC_Type) SetNCFGR_RLCE(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x10000)|value<<16)
}
func (o *EMAC_Type) GetNCFGR_RLCE() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x10000) >> 16
}
func (o *EMAC_Type) SetNCFGR_DRFCS(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x20000)|value<<17)
}
func (o *EMAC_Type) GetNCFGR_DRFCS() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x20000) >> 17
}
func (o *EMAC_Type) SetNCFGR_EFRHD(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x40000)|value<<18)
}
func (o *EMAC_Type) GetNCFGR_EFRHD() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x40000) >> 18
}
func (o *EMAC_Type) SetNCFGR_IRXFCS(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x80000)|value<<19)
}
func (o *EMAC_Type) GetNCFGR_IRXFCS() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x80000) >> 19
}

// EMAC.NSR: Network Status Register
func (o *EMAC_Type) SetNSR_MDIO(value uint32) {
	volatile.StoreUint32(&o.NSR.Reg, volatile.LoadUint32(&o.NSR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetNSR_MDIO() uint32 {
	return (volatile.LoadUint32(&o.NSR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetNSR_IDLE(value uint32) {
	volatile.StoreUint32(&o.NSR.Reg, volatile.LoadUint32(&o.NSR.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetNSR_IDLE() uint32 {
	return (volatile.LoadUint32(&o.NSR.Reg) & 0x4) >> 2
}

// EMAC.TSR: Transmit Status Register
func (o *EMAC_Type) SetTSR_UBR(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetTSR_UBR() uint32 {
	return volatile.LoadUint32(&o.TSR.Reg) & 0x1
}
func (o *EMAC_Type) SetTSR_COL(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetTSR_COL() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetTSR_RLES(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetTSR_RLES() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x4) >> 2
}
func (o *EMAC_Type) SetTSR_TGO(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x8)|value<<3)
}
func (o *EMAC_Type) GetTSR_TGO() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x8) >> 3
}
func (o *EMAC_Type) SetTSR_BEX(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x10)|value<<4)
}
func (o *EMAC_Type) GetTSR_BEX() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x10) >> 4
}
func (o *EMAC_Type) SetTSR_COMP(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x20)|value<<5)
}
func (o *EMAC_Type) GetTSR_COMP() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x20) >> 5
}
func (o *EMAC_Type) SetTSR_UND(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x40)|value<<6)
}
func (o *EMAC_Type) GetTSR_UND() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x40) >> 6
}

// EMAC.RBQP: Receive Buffer Queue Pointer Register
func (o *EMAC_Type) SetRBQP_ADDR(value uint32) {
	volatile.StoreUint32(&o.RBQP.Reg, volatile.LoadUint32(&o.RBQP.Reg)&^(0xfffffffc)|value<<2)
}
func (o *EMAC_Type) GetRBQP_ADDR() uint32 {
	return (volatile.LoadUint32(&o.RBQP.Reg) & 0xfffffffc) >> 2
}

// EMAC.TBQP: Transmit Buffer Queue Pointer Register
func (o *EMAC_Type) SetTBQP_ADDR(value uint32) {
	volatile.StoreUint32(&o.TBQP.Reg, volatile.LoadUint32(&o.TBQP.Reg)&^(0xfffffffc)|value<<2)
}
func (o *EMAC_Type) GetTBQP_ADDR() uint32 {
	return (volatile.LoadUint32(&o.TBQP.Reg) & 0xfffffffc) >> 2
}

// EMAC.RSR: Receive Status Register
func (o *EMAC_Type) SetRSR_BNA(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetRSR_BNA() uint32 {
	return volatile.LoadUint32(&o.RSR.Reg) & 0x1
}
func (o *EMAC_Type) SetRSR_REC(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetRSR_REC() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetRSR_OVR(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetRSR_OVR() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x4) >> 2
}

// EMAC.ISR: Interrupt Status Register
func (o *EMAC_Type) SetISR_MFD(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetISR_MFD() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *EMAC_Type) SetISR_RCOMP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetISR_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetISR_RXUBR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetISR_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *EMAC_Type) SetISR_TXUBR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *EMAC_Type) GetISR_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *EMAC_Type) SetISR_TUND(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *EMAC_Type) GetISR_TUND() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *EMAC_Type) SetISR_RLEX(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *EMAC_Type) GetISR_RLEX() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *EMAC_Type) SetISR_TXERR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *EMAC_Type) GetISR_TXERR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *EMAC_Type) SetISR_TCOMP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *EMAC_Type) GetISR_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *EMAC_Type) SetISR_ROVR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *EMAC_Type) GetISR_ROVR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *EMAC_Type) SetISR_HRESP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *EMAC_Type) GetISR_HRESP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *EMAC_Type) SetISR_PFRE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *EMAC_Type) GetISR_PFRE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *EMAC_Type) SetISR_PTZ(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *EMAC_Type) GetISR_PTZ() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *EMAC_Type) SetISR_WOL(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000)|value<<14)
}
func (o *EMAC_Type) GetISR_WOL() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000) >> 14
}

// EMAC.IER: Interrupt Enable Register
func (o *EMAC_Type) SetIER_MFD(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetIER_MFD() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *EMAC_Type) SetIER_RCOMP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetIER_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetIER_RXUBR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetIER_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *EMAC_Type) SetIER_TXUBR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *EMAC_Type) GetIER_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *EMAC_Type) SetIER_TUND(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *EMAC_Type) GetIER_TUND() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *EMAC_Type) SetIER_RLE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *EMAC_Type) GetIER_RLE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *EMAC_Type) SetIER_TXERR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *EMAC_Type) GetIER_TXERR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *EMAC_Type) SetIER_TCOMP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *EMAC_Type) GetIER_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *EMAC_Type) SetIER_ROVR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *EMAC_Type) GetIER_ROVR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *EMAC_Type) SetIER_HRESP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *EMAC_Type) GetIER_HRESP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *EMAC_Type) SetIER_PFR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000)|value<<12)
}
func (o *EMAC_Type) GetIER_PFR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000) >> 12
}
func (o *EMAC_Type) SetIER_PTZ(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000)|value<<13)
}
func (o *EMAC_Type) GetIER_PTZ() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000) >> 13
}
func (o *EMAC_Type) SetIER_WOL(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000)|value<<14)
}
func (o *EMAC_Type) GetIER_WOL() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000) >> 14
}

// EMAC.IDR: Interrupt Disable Register
func (o *EMAC_Type) SetIDR_MFD(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetIDR_MFD() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *EMAC_Type) SetIDR_RCOMP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetIDR_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetIDR_RXUBR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetIDR_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *EMAC_Type) SetIDR_TXUBR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *EMAC_Type) GetIDR_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *EMAC_Type) SetIDR_TUND(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *EMAC_Type) GetIDR_TUND() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *EMAC_Type) SetIDR_RLE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *EMAC_Type) GetIDR_RLE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *EMAC_Type) SetIDR_TXERR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *EMAC_Type) GetIDR_TXERR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *EMAC_Type) SetIDR_TCOMP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *EMAC_Type) GetIDR_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *EMAC_Type) SetIDR_ROVR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *EMAC_Type) GetIDR_ROVR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *EMAC_Type) SetIDR_HRESP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *EMAC_Type) GetIDR_HRESP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *EMAC_Type) SetIDR_PFR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000)|value<<12)
}
func (o *EMAC_Type) GetIDR_PFR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000) >> 12
}
func (o *EMAC_Type) SetIDR_PTZ(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *EMAC_Type) GetIDR_PTZ() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}
func (o *EMAC_Type) SetIDR_WOL(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000)|value<<14)
}
func (o *EMAC_Type) GetIDR_WOL() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000) >> 14
}

// EMAC.IMR: Interrupt Mask Register
func (o *EMAC_Type) SetIMR_MFD(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetIMR_MFD() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *EMAC_Type) SetIMR_RCOMP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetIMR_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *EMAC_Type) SetIMR_RXUBR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *EMAC_Type) GetIMR_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *EMAC_Type) SetIMR_TXUBR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *EMAC_Type) GetIMR_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *EMAC_Type) SetIMR_TUND(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *EMAC_Type) GetIMR_TUND() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *EMAC_Type) SetIMR_RLE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *EMAC_Type) GetIMR_RLE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *EMAC_Type) SetIMR_TXERR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *EMAC_Type) GetIMR_TXERR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *EMAC_Type) SetIMR_TCOMP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *EMAC_Type) GetIMR_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *EMAC_Type) SetIMR_ROVR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *EMAC_Type) GetIMR_ROVR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *EMAC_Type) SetIMR_HRESP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *EMAC_Type) GetIMR_HRESP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}
func (o *EMAC_Type) SetIMR_PFR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000)|value<<12)
}
func (o *EMAC_Type) GetIMR_PFR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000) >> 12
}
func (o *EMAC_Type) SetIMR_PTZ(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000)|value<<13)
}
func (o *EMAC_Type) GetIMR_PTZ() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000) >> 13
}
func (o *EMAC_Type) SetIMR_WOL(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000)|value<<14)
}
func (o *EMAC_Type) GetIMR_WOL() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000) >> 14
}

// EMAC.MAN: Phy Maintenance Register
func (o *EMAC_Type) SetMAN_DATA(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetMAN_DATA() uint32 {
	return volatile.LoadUint32(&o.MAN.Reg) & 0xffff
}
func (o *EMAC_Type) SetMAN_CODE(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x30000)|value<<16)
}
func (o *EMAC_Type) GetMAN_CODE() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x30000) >> 16
}
func (o *EMAC_Type) SetMAN_REGA(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x7c0000)|value<<18)
}
func (o *EMAC_Type) GetMAN_REGA() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x7c0000) >> 18
}
func (o *EMAC_Type) SetMAN_PHYA(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0xf800000)|value<<23)
}
func (o *EMAC_Type) GetMAN_PHYA() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0xf800000) >> 23
}
func (o *EMAC_Type) SetMAN_RW(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x30000000)|value<<28)
}
func (o *EMAC_Type) GetMAN_RW() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x30000000) >> 28
}
func (o *EMAC_Type) SetMAN_SOF(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0xc0000000)|value<<30)
}
func (o *EMAC_Type) GetMAN_SOF() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0xc0000000) >> 30
}

// EMAC.PTR: Pause Time Register
func (o *EMAC_Type) SetPTR_PTIME(value uint32) {
	volatile.StoreUint32(&o.PTR.Reg, volatile.LoadUint32(&o.PTR.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetPTR_PTIME() uint32 {
	return volatile.LoadUint32(&o.PTR.Reg) & 0xffff
}

// EMAC.PFR: Pause Frames Received Register
func (o *EMAC_Type) SetPFR_FROK(value uint32) {
	volatile.StoreUint32(&o.PFR.Reg, volatile.LoadUint32(&o.PFR.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetPFR_FROK() uint32 {
	return volatile.LoadUint32(&o.PFR.Reg) & 0xffff
}

// EMAC.FTO: Frames Transmitted Ok Register
func (o *EMAC_Type) SetFTO_FTOK(value uint32) {
	volatile.StoreUint32(&o.FTO.Reg, volatile.LoadUint32(&o.FTO.Reg)&^(0xffffff)|value)
}
func (o *EMAC_Type) GetFTO_FTOK() uint32 {
	return volatile.LoadUint32(&o.FTO.Reg) & 0xffffff
}

// EMAC.SCF: Single Collision Frames Register
func (o *EMAC_Type) SetSCF(value uint32) {
	volatile.StoreUint32(&o.SCF.Reg, volatile.LoadUint32(&o.SCF.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetSCF() uint32 {
	return volatile.LoadUint32(&o.SCF.Reg) & 0xffff
}

// EMAC.MCF: Multiple Collision Frames Register
func (o *EMAC_Type) SetMCF(value uint32) {
	volatile.StoreUint32(&o.MCF.Reg, volatile.LoadUint32(&o.MCF.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetMCF() uint32 {
	return volatile.LoadUint32(&o.MCF.Reg) & 0xffff
}

// EMAC.FRO: Frames Received Ok Register
func (o *EMAC_Type) SetFRO_FROK(value uint32) {
	volatile.StoreUint32(&o.FRO.Reg, volatile.LoadUint32(&o.FRO.Reg)&^(0xffffff)|value)
}
func (o *EMAC_Type) GetFRO_FROK() uint32 {
	return volatile.LoadUint32(&o.FRO.Reg) & 0xffffff
}

// EMAC.FCSE: Frame Check Sequence Errors Register
func (o *EMAC_Type) SetFCSE(value uint32) {
	volatile.StoreUint32(&o.FCSE.Reg, volatile.LoadUint32(&o.FCSE.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetFCSE() uint32 {
	return volatile.LoadUint32(&o.FCSE.Reg) & 0xff
}

// EMAC.ALE: Alignment Errors Register
func (o *EMAC_Type) SetALE(value uint32) {
	volatile.StoreUint32(&o.ALE.Reg, volatile.LoadUint32(&o.ALE.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetALE() uint32 {
	return volatile.LoadUint32(&o.ALE.Reg) & 0xff
}

// EMAC.DTF: Deferred Transmission Frames Register
func (o *EMAC_Type) SetDTF(value uint32) {
	volatile.StoreUint32(&o.DTF.Reg, volatile.LoadUint32(&o.DTF.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetDTF() uint32 {
	return volatile.LoadUint32(&o.DTF.Reg) & 0xffff
}

// EMAC.LCOL: Late Collisions Register
func (o *EMAC_Type) SetLCOL(value uint32) {
	volatile.StoreUint32(&o.LCOL.Reg, volatile.LoadUint32(&o.LCOL.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetLCOL() uint32 {
	return volatile.LoadUint32(&o.LCOL.Reg) & 0xff
}

// EMAC.ECOL: Excessive Collisions Register
func (o *EMAC_Type) SetECOL_EXCOL(value uint32) {
	volatile.StoreUint32(&o.ECOL.Reg, volatile.LoadUint32(&o.ECOL.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetECOL_EXCOL() uint32 {
	return volatile.LoadUint32(&o.ECOL.Reg) & 0xff
}

// EMAC.TUND: Transmit Underrun Errors Register
func (o *EMAC_Type) SetTUND(value uint32) {
	volatile.StoreUint32(&o.TUND.Reg, volatile.LoadUint32(&o.TUND.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetTUND() uint32 {
	return volatile.LoadUint32(&o.TUND.Reg) & 0xff
}

// EMAC.CSE: Carrier Sense Errors Register
func (o *EMAC_Type) SetCSE(value uint32) {
	volatile.StoreUint32(&o.CSE.Reg, volatile.LoadUint32(&o.CSE.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetCSE() uint32 {
	return volatile.LoadUint32(&o.CSE.Reg) & 0xff
}

// EMAC.RRE: Receive Resource Errors Register
func (o *EMAC_Type) SetRRE(value uint32) {
	volatile.StoreUint32(&o.RRE.Reg, volatile.LoadUint32(&o.RRE.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetRRE() uint32 {
	return volatile.LoadUint32(&o.RRE.Reg) & 0xffff
}

// EMAC.ROV: Receive Overrun Errors Register
func (o *EMAC_Type) SetROV_ROVR(value uint32) {
	volatile.StoreUint32(&o.ROV.Reg, volatile.LoadUint32(&o.ROV.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetROV_ROVR() uint32 {
	return volatile.LoadUint32(&o.ROV.Reg) & 0xff
}

// EMAC.RSE: Receive Symbol Errors Register
func (o *EMAC_Type) SetRSE(value uint32) {
	volatile.StoreUint32(&o.RSE.Reg, volatile.LoadUint32(&o.RSE.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetRSE() uint32 {
	return volatile.LoadUint32(&o.RSE.Reg) & 0xff
}

// EMAC.ELE: Excessive Length Errors Register
func (o *EMAC_Type) SetELE_EXL(value uint32) {
	volatile.StoreUint32(&o.ELE.Reg, volatile.LoadUint32(&o.ELE.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetELE_EXL() uint32 {
	return volatile.LoadUint32(&o.ELE.Reg) & 0xff
}

// EMAC.RJA: Receive Jabbers Register
func (o *EMAC_Type) SetRJA_RJB(value uint32) {
	volatile.StoreUint32(&o.RJA.Reg, volatile.LoadUint32(&o.RJA.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetRJA_RJB() uint32 {
	return volatile.LoadUint32(&o.RJA.Reg) & 0xff
}

// EMAC.USF: Undersize Frames Register
func (o *EMAC_Type) SetUSF(value uint32) {
	volatile.StoreUint32(&o.USF.Reg, volatile.LoadUint32(&o.USF.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetUSF() uint32 {
	return volatile.LoadUint32(&o.USF.Reg) & 0xff
}

// EMAC.STE: SQE Test Errors Register
func (o *EMAC_Type) SetSTE_SQER(value uint32) {
	volatile.StoreUint32(&o.STE.Reg, volatile.LoadUint32(&o.STE.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetSTE_SQER() uint32 {
	return volatile.LoadUint32(&o.STE.Reg) & 0xff
}

// EMAC.RLE: Received Length Field Mismatch Register
func (o *EMAC_Type) SetRLE_RLFM(value uint32) {
	volatile.StoreUint32(&o.RLE.Reg, volatile.LoadUint32(&o.RLE.Reg)&^(0xff)|value)
}
func (o *EMAC_Type) GetRLE_RLFM() uint32 {
	return volatile.LoadUint32(&o.RLE.Reg) & 0xff
}

// EMAC.HRB: Hash Register Bottom [31:0] Register
func (o *EMAC_Type) SetHRB(value uint32) {
	volatile.StoreUint32(&o.HRB.Reg, value)
}
func (o *EMAC_Type) GetHRB() uint32 {
	return volatile.LoadUint32(&o.HRB.Reg)
}

// EMAC.HRT: Hash Register Top [63:32] Register
func (o *EMAC_Type) SetHRT(value uint32) {
	volatile.StoreUint32(&o.HRT.Reg, value)
}
func (o *EMAC_Type) GetHRT() uint32 {
	return volatile.LoadUint32(&o.HRT.Reg)
}

// EMAC.SA1B: Specific Address 1 Bottom Register
func (o *EMAC_Type) SetSA1B(value uint32) {
	volatile.StoreUint32(&o.SA1B.Reg, value)
}
func (o *EMAC_Type) GetSA1B() uint32 {
	return volatile.LoadUint32(&o.SA1B.Reg)
}

// EMAC.SA1T: Specific Address 1 Top Register
func (o *EMAC_Type) SetSA1T_ADDR(value uint32) {
	volatile.StoreUint32(&o.SA1T.Reg, volatile.LoadUint32(&o.SA1T.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetSA1T_ADDR() uint32 {
	return volatile.LoadUint32(&o.SA1T.Reg) & 0xffff
}

// EMAC.SA2B: Specific Address 2 Bottom Register
func (o *EMAC_Type) SetSA2B(value uint32) {
	volatile.StoreUint32(&o.SA2B.Reg, value)
}
func (o *EMAC_Type) GetSA2B() uint32 {
	return volatile.LoadUint32(&o.SA2B.Reg)
}

// EMAC.SA2T: Specific Address 2 Top Register
func (o *EMAC_Type) SetSA2T_ADDR(value uint32) {
	volatile.StoreUint32(&o.SA2T.Reg, volatile.LoadUint32(&o.SA2T.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetSA2T_ADDR() uint32 {
	return volatile.LoadUint32(&o.SA2T.Reg) & 0xffff
}

// EMAC.SA3B: Specific Address 3 Bottom Register
func (o *EMAC_Type) SetSA3B(value uint32) {
	volatile.StoreUint32(&o.SA3B.Reg, value)
}
func (o *EMAC_Type) GetSA3B() uint32 {
	return volatile.LoadUint32(&o.SA3B.Reg)
}

// EMAC.SA3T: Specific Address 3 Top Register
func (o *EMAC_Type) SetSA3T_ADDR(value uint32) {
	volatile.StoreUint32(&o.SA3T.Reg, volatile.LoadUint32(&o.SA3T.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetSA3T_ADDR() uint32 {
	return volatile.LoadUint32(&o.SA3T.Reg) & 0xffff
}

// EMAC.SA4B: Specific Address 4 Bottom Register
func (o *EMAC_Type) SetSA4B(value uint32) {
	volatile.StoreUint32(&o.SA4B.Reg, value)
}
func (o *EMAC_Type) GetSA4B() uint32 {
	return volatile.LoadUint32(&o.SA4B.Reg)
}

// EMAC.SA4T: Specific Address 4 Top Register
func (o *EMAC_Type) SetSA4T_ADDR(value uint32) {
	volatile.StoreUint32(&o.SA4T.Reg, volatile.LoadUint32(&o.SA4T.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetSA4T_ADDR() uint32 {
	return volatile.LoadUint32(&o.SA4T.Reg) & 0xffff
}

// EMAC.TID: Type ID Checking Register
func (o *EMAC_Type) SetTID(value uint32) {
	volatile.StoreUint32(&o.TID.Reg, volatile.LoadUint32(&o.TID.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetTID() uint32 {
	return volatile.LoadUint32(&o.TID.Reg) & 0xffff
}

// EMAC.USRIO: User Input/Output Register
func (o *EMAC_Type) SetUSRIO_RMII(value uint32) {
	volatile.StoreUint32(&o.USRIO.Reg, volatile.LoadUint32(&o.USRIO.Reg)&^(0x1)|value)
}
func (o *EMAC_Type) GetUSRIO_RMII() uint32 {
	return volatile.LoadUint32(&o.USRIO.Reg) & 0x1
}
func (o *EMAC_Type) SetUSRIO_CLKEN(value uint32) {
	volatile.StoreUint32(&o.USRIO.Reg, volatile.LoadUint32(&o.USRIO.Reg)&^(0x2)|value<<1)
}
func (o *EMAC_Type) GetUSRIO_CLKEN() uint32 {
	return (volatile.LoadUint32(&o.USRIO.Reg) & 0x2) >> 1
}

// EMAC.WOL: Wake on LAN Register
func (o *EMAC_Type) SetWOL_IP(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0xffff)|value)
}
func (o *EMAC_Type) GetWOL_IP() uint32 {
	return volatile.LoadUint32(&o.WOL.Reg) & 0xffff
}
func (o *EMAC_Type) SetWOL_MAG(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0x10000)|value<<16)
}
func (o *EMAC_Type) GetWOL_MAG() uint32 {
	return (volatile.LoadUint32(&o.WOL.Reg) & 0x10000) >> 16
}
func (o *EMAC_Type) SetWOL_ARP(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0x20000)|value<<17)
}
func (o *EMAC_Type) GetWOL_ARP() uint32 {
	return (volatile.LoadUint32(&o.WOL.Reg) & 0x20000) >> 17
}
func (o *EMAC_Type) SetWOL_SA1(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0x40000)|value<<18)
}
func (o *EMAC_Type) GetWOL_SA1() uint32 {
	return (volatile.LoadUint32(&o.WOL.Reg) & 0x40000) >> 18
}
func (o *EMAC_Type) SetWOL_MTI(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0x80000)|value<<19)
}
func (o *EMAC_Type) GetWOL_MTI() uint32 {
	return (volatile.LoadUint32(&o.WOL.Reg) & 0x80000) >> 19
}

// USB High Speed Device Port
type UDPHS_Type struct {
	CTRL        volatile.Register32 // 0x0
	FNUM        volatile.Register32 // 0x4
	_           [8]byte
	IEN         volatile.Register32 // 0x10
	INTSTA      volatile.Register32 // 0x14
	CLRINT      volatile.Register32 // 0x18
	EPTRST      volatile.Register32 // 0x1C
	_           [192]byte
	TST         volatile.Register32 // 0xE0
	_           [28]byte
	EPTCFG0     volatile.Register32 // 0x100
	EPTCTLENB0  volatile.Register32 // 0x104
	EPTCTLDIS0  volatile.Register32 // 0x108
	EPTCTL0     volatile.Register32 // 0x10C
	_           [4]byte
	EPTSETSTA0  volatile.Register32 // 0x114
	EPTCLRSTA0  volatile.Register32 // 0x118
	EPTSTA0     volatile.Register32 // 0x11C
	EPTCFG1     volatile.Register32 // 0x120
	EPTCTLENB1  volatile.Register32 // 0x124
	EPTCTLDIS1  volatile.Register32 // 0x128
	EPTCTL1     volatile.Register32 // 0x12C
	_           [4]byte
	EPTSETSTA1  volatile.Register32 // 0x134
	EPTCLRSTA1  volatile.Register32 // 0x138
	EPTSTA1     volatile.Register32 // 0x13C
	EPTCFG2     volatile.Register32 // 0x140
	EPTCTLENB2  volatile.Register32 // 0x144
	EPTCTLDIS2  volatile.Register32 // 0x148
	EPTCTL2     volatile.Register32 // 0x14C
	_           [4]byte
	EPTSETSTA2  volatile.Register32 // 0x154
	EPTCLRSTA2  volatile.Register32 // 0x158
	EPTSTA2     volatile.Register32 // 0x15C
	EPTCFG3     volatile.Register32 // 0x160
	EPTCTLENB3  volatile.Register32 // 0x164
	EPTCTLDIS3  volatile.Register32 // 0x168
	EPTCTL3     volatile.Register32 // 0x16C
	_           [4]byte
	EPTSETSTA3  volatile.Register32 // 0x174
	EPTCLRSTA3  volatile.Register32 // 0x178
	EPTSTA3     volatile.Register32 // 0x17C
	EPTCFG4     volatile.Register32 // 0x180
	EPTCTLENB4  volatile.Register32 // 0x184
	EPTCTLDIS4  volatile.Register32 // 0x188
	EPTCTL4     volatile.Register32 // 0x18C
	_           [4]byte
	EPTSETSTA4  volatile.Register32 // 0x194
	EPTCLRSTA4  volatile.Register32 // 0x198
	EPTSTA4     volatile.Register32 // 0x19C
	EPTCFG5     volatile.Register32 // 0x1A0
	EPTCTLENB5  volatile.Register32 // 0x1A4
	EPTCTLDIS5  volatile.Register32 // 0x1A8
	EPTCTL5     volatile.Register32 // 0x1AC
	_           [4]byte
	EPTSETSTA5  volatile.Register32 // 0x1B4
	EPTCLRSTA5  volatile.Register32 // 0x1B8
	EPTSTA5     volatile.Register32 // 0x1BC
	EPTCFG6     volatile.Register32 // 0x1C0
	EPTCTLENB6  volatile.Register32 // 0x1C4
	EPTCTLDIS6  volatile.Register32 // 0x1C8
	EPTCTL6     volatile.Register32 // 0x1CC
	_           [4]byte
	EPTSETSTA6  volatile.Register32 // 0x1D4
	EPTCLRSTA6  volatile.Register32 // 0x1D8
	EPTSTA6     volatile.Register32 // 0x1DC
	EPTCFG7     volatile.Register32 // 0x1E0
	EPTCTLENB7  volatile.Register32 // 0x1E4
	EPTCTLDIS7  volatile.Register32 // 0x1E8
	EPTCTL7     volatile.Register32 // 0x1EC
	_           [4]byte
	EPTSETSTA7  volatile.Register32 // 0x1F4
	EPTCLRSTA7  volatile.Register32 // 0x1F8
	EPTSTA7     volatile.Register32 // 0x1FC
	EPTCFG8     volatile.Register32 // 0x200
	EPTCTLENB8  volatile.Register32 // 0x204
	EPTCTLDIS8  volatile.Register32 // 0x208
	EPTCTL8     volatile.Register32 // 0x20C
	_           [4]byte
	EPTSETSTA8  volatile.Register32 // 0x214
	EPTCLRSTA8  volatile.Register32 // 0x218
	EPTSTA8     volatile.Register32 // 0x21C
	EPTCFG9     volatile.Register32 // 0x220
	EPTCTLENB9  volatile.Register32 // 0x224
	EPTCTLDIS9  volatile.Register32 // 0x228
	EPTCTL9     volatile.Register32 // 0x22C
	_           [4]byte
	EPTSETSTA9  volatile.Register32 // 0x234
	EPTCLRSTA9  volatile.Register32 // 0x238
	EPTSTA9     volatile.Register32 // 0x23C
	EPTCFG10    volatile.Register32 // 0x240
	EPTCTLENB10 volatile.Register32 // 0x244
	EPTCTLDIS10 volatile.Register32 // 0x248
	EPTCTL10    volatile.Register32 // 0x24C
	_           [4]byte
	EPTSETSTA10 volatile.Register32 // 0x254
	EPTCLRSTA10 volatile.Register32 // 0x258
	EPTSTA10    volatile.Register32 // 0x25C
	EPTCFG11    volatile.Register32 // 0x260
	EPTCTLENB11 volatile.Register32 // 0x264
	EPTCTLDIS11 volatile.Register32 // 0x268
	EPTCTL11    volatile.Register32 // 0x26C
	_           [4]byte
	EPTSETSTA11 volatile.Register32 // 0x274
	EPTCLRSTA11 volatile.Register32 // 0x278
	EPTSTA11    volatile.Register32 // 0x27C
	EPTCFG12    volatile.Register32 // 0x280
	EPTCTLENB12 volatile.Register32 // 0x284
	EPTCTLDIS12 volatile.Register32 // 0x288
	EPTCTL12    volatile.Register32 // 0x28C
	_           [4]byte
	EPTSETSTA12 volatile.Register32 // 0x294
	EPTCLRSTA12 volatile.Register32 // 0x298
	EPTSTA12    volatile.Register32 // 0x29C
	EPTCFG13    volatile.Register32 // 0x2A0
	EPTCTLENB13 volatile.Register32 // 0x2A4
	EPTCTLDIS13 volatile.Register32 // 0x2A8
	EPTCTL13    volatile.Register32 // 0x2AC
	_           [4]byte
	EPTSETSTA13 volatile.Register32 // 0x2B4
	EPTCLRSTA13 volatile.Register32 // 0x2B8
	EPTSTA13    volatile.Register32 // 0x2BC
	EPTCFG14    volatile.Register32 // 0x2C0
	EPTCTLENB14 volatile.Register32 // 0x2C4
	EPTCTLDIS14 volatile.Register32 // 0x2C8
	EPTCTL14    volatile.Register32 // 0x2CC
	_           [4]byte
	EPTSETSTA14 volatile.Register32 // 0x2D4
	EPTCLRSTA14 volatile.Register32 // 0x2D8
	EPTSTA14    volatile.Register32 // 0x2DC
	EPTCFG15    volatile.Register32 // 0x2E0
	EPTCTLENB15 volatile.Register32 // 0x2E4
	EPTCTLDIS15 volatile.Register32 // 0x2E8
	EPTCTL15    volatile.Register32 // 0x2EC
	_           [4]byte
	EPTSETSTA15 volatile.Register32 // 0x2F4
	EPTCLRSTA15 volatile.Register32 // 0x2F8
	EPTSTA15    volatile.Register32 // 0x2FC
	DMANXTDSC0  volatile.Register32 // 0x300
	DMAADDRESS0 volatile.Register32 // 0x304
	DMACONTROL0 volatile.Register32 // 0x308
	DMASTATUS0  volatile.Register32 // 0x30C
	DMANXTDSC1  volatile.Register32 // 0x310
	DMAADDRESS1 volatile.Register32 // 0x314
	DMACONTROL1 volatile.Register32 // 0x318
	DMASTATUS1  volatile.Register32 // 0x31C
	DMANXTDSC2  volatile.Register32 // 0x320
	DMAADDRESS2 volatile.Register32 // 0x324
	DMACONTROL2 volatile.Register32 // 0x328
	DMASTATUS2  volatile.Register32 // 0x32C
	DMANXTDSC3  volatile.Register32 // 0x330
	DMAADDRESS3 volatile.Register32 // 0x334
	DMACONTROL3 volatile.Register32 // 0x338
	DMASTATUS3  volatile.Register32 // 0x33C
	DMANXTDSC4  volatile.Register32 // 0x340
	DMAADDRESS4 volatile.Register32 // 0x344
	DMACONTROL4 volatile.Register32 // 0x348
	DMASTATUS4  volatile.Register32 // 0x34C
	DMANXTDSC5  volatile.Register32 // 0x350
	DMAADDRESS5 volatile.Register32 // 0x354
	DMACONTROL5 volatile.Register32 // 0x358
	DMASTATUS5  volatile.Register32 // 0x35C
	DMANXTDSC6  volatile.Register32 // 0x360
	DMAADDRESS6 volatile.Register32 // 0x364
	DMACONTROL6 volatile.Register32 // 0x368
	DMASTATUS6  volatile.Register32 // 0x36C
}

// UDPHS.CTRL: UDPHS Control Register
func (o *UDPHS_Type) SetCTRL_DEV_ADDR(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x7f)|value)
}
func (o *UDPHS_Type) GetCTRL_DEV_ADDR() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x7f
}
func (o *UDPHS_Type) SetCTRL_FADDR_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetCTRL_FADDR_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetCTRL_EN_UDPHS(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetCTRL_EN_UDPHS() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetCTRL_DETACH(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetCTRL_DETACH() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetCTRL_REWAKEUP(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetCTRL_REWAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetCTRL_PULLD_DIS(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetCTRL_PULLD_DIS() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x800) >> 11
}

// UDPHS.FNUM: UDPHS Frame Number Register
func (o *UDPHS_Type) SetFNUM_MICRO_FRAME_NUM(value uint32) {
	volatile.StoreUint32(&o.FNUM.Reg, volatile.LoadUint32(&o.FNUM.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetFNUM_MICRO_FRAME_NUM() uint32 {
	return volatile.LoadUint32(&o.FNUM.Reg) & 0x7
}
func (o *UDPHS_Type) SetFNUM_FRAME_NUMBER(value uint32) {
	volatile.StoreUint32(&o.FNUM.Reg, volatile.LoadUint32(&o.FNUM.Reg)&^(0x3ff8)|value<<3)
}
func (o *UDPHS_Type) GetFNUM_FRAME_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.FNUM.Reg) & 0x3ff8) >> 3
}
func (o *UDPHS_Type) SetFNUM_FNUM_ERR(value uint32) {
	volatile.StoreUint32(&o.FNUM.Reg, volatile.LoadUint32(&o.FNUM.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetFNUM_FNUM_ERR() uint32 {
	return (volatile.LoadUint32(&o.FNUM.Reg) & 0x80000000) >> 31
}

// UDPHS.IEN: UDPHS Interrupt Enable Register
func (o *UDPHS_Type) SetIEN_DET_SUSPD(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetIEN_DET_SUSPD() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetIEN_MICRO_SOF(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetIEN_MICRO_SOF() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetIEN_INT_SOF(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetIEN_INT_SOF() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetIEN_ENDRESET(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetIEN_ENDRESET() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetIEN_WAKE_UP(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetIEN_WAKE_UP() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetIEN_ENDOFRSM(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetIEN_ENDOFRSM() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetIEN_UPSTR_RES(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetIEN_UPSTR_RES() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetIEN_EPT_0(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetIEN_EPT_0() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetIEN_EPT_1(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetIEN_EPT_1() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetIEN_EPT_2(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetIEN_EPT_2() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetIEN_EPT_3(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetIEN_EPT_3() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetIEN_EPT_4(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetIEN_EPT_4() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetIEN_EPT_5(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetIEN_EPT_5() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetIEN_EPT_6(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetIEN_EPT_6() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetIEN_EPT_7(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetIEN_EPT_7() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetIEN_EPT_8(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x10000)|value<<16)
}
func (o *UDPHS_Type) GetIEN_EPT_8() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x10000) >> 16
}
func (o *UDPHS_Type) SetIEN_EPT_9(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x20000)|value<<17)
}
func (o *UDPHS_Type) GetIEN_EPT_9() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x20000) >> 17
}
func (o *UDPHS_Type) SetIEN_EPT_10(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetIEN_EPT_10() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetIEN_EPT_11(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x80000)|value<<19)
}
func (o *UDPHS_Type) GetIEN_EPT_11() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x80000) >> 19
}
func (o *UDPHS_Type) SetIEN_EPT_12(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x100000)|value<<20)
}
func (o *UDPHS_Type) GetIEN_EPT_12() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x100000) >> 20
}
func (o *UDPHS_Type) SetIEN_EPT_13(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x200000)|value<<21)
}
func (o *UDPHS_Type) GetIEN_EPT_13() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x200000) >> 21
}
func (o *UDPHS_Type) SetIEN_EPT_14(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x400000)|value<<22)
}
func (o *UDPHS_Type) GetIEN_EPT_14() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x400000) >> 22
}
func (o *UDPHS_Type) SetIEN_EPT_15(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x800000)|value<<23)
}
func (o *UDPHS_Type) GetIEN_EPT_15() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x800000) >> 23
}
func (o *UDPHS_Type) SetIEN_DMA_1(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x2000000)|value<<25)
}
func (o *UDPHS_Type) GetIEN_DMA_1() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x2000000) >> 25
}
func (o *UDPHS_Type) SetIEN_DMA_2(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x4000000)|value<<26)
}
func (o *UDPHS_Type) GetIEN_DMA_2() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x4000000) >> 26
}
func (o *UDPHS_Type) SetIEN_DMA_3(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x8000000)|value<<27)
}
func (o *UDPHS_Type) GetIEN_DMA_3() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x8000000) >> 27
}
func (o *UDPHS_Type) SetIEN_DMA_4(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x10000000)|value<<28)
}
func (o *UDPHS_Type) GetIEN_DMA_4() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x10000000) >> 28
}
func (o *UDPHS_Type) SetIEN_DMA_5(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x20000000)|value<<29)
}
func (o *UDPHS_Type) GetIEN_DMA_5() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x20000000) >> 29
}
func (o *UDPHS_Type) SetIEN_DMA_6(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x40000000)|value<<30)
}
func (o *UDPHS_Type) GetIEN_DMA_6() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x40000000) >> 30
}
func (o *UDPHS_Type) SetIEN_DMA_7(value uint32) {
	volatile.StoreUint32(&o.IEN.Reg, volatile.LoadUint32(&o.IEN.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetIEN_DMA_7() uint32 {
	return (volatile.LoadUint32(&o.IEN.Reg) & 0x80000000) >> 31
}

// UDPHS.INTSTA: UDPHS Interrupt Status Register
func (o *UDPHS_Type) SetINTSTA_SPEED(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetINTSTA_SPEED() uint32 {
	return volatile.LoadUint32(&o.INTSTA.Reg) & 0x1
}
func (o *UDPHS_Type) SetINTSTA_DET_SUSPD(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetINTSTA_DET_SUSPD() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetINTSTA_MICRO_SOF(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetINTSTA_MICRO_SOF() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetINTSTA_INT_SOF(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetINTSTA_INT_SOF() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetINTSTA_ENDRESET(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetINTSTA_ENDRESET() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetINTSTA_WAKE_UP(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetINTSTA_WAKE_UP() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetINTSTA_ENDOFRSM(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetINTSTA_ENDOFRSM() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetINTSTA_UPSTR_RES(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetINTSTA_UPSTR_RES() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetINTSTA_EPT_0(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetINTSTA_EPT_0() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetINTSTA_EPT_1(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetINTSTA_EPT_1() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetINTSTA_EPT_2(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetINTSTA_EPT_2() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetINTSTA_EPT_3(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetINTSTA_EPT_3() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetINTSTA_EPT_4(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetINTSTA_EPT_4() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetINTSTA_EPT_5(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetINTSTA_EPT_5() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetINTSTA_EPT_6(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetINTSTA_EPT_6() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetINTSTA_EPT_7(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetINTSTA_EPT_7() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetINTSTA_EPT_8(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x10000)|value<<16)
}
func (o *UDPHS_Type) GetINTSTA_EPT_8() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x10000) >> 16
}
func (o *UDPHS_Type) SetINTSTA_EPT_9(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x20000)|value<<17)
}
func (o *UDPHS_Type) GetINTSTA_EPT_9() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x20000) >> 17
}
func (o *UDPHS_Type) SetINTSTA_EPT_10(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetINTSTA_EPT_10() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetINTSTA_EPT_11(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x80000)|value<<19)
}
func (o *UDPHS_Type) GetINTSTA_EPT_11() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x80000) >> 19
}
func (o *UDPHS_Type) SetINTSTA_EPT_12(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x100000)|value<<20)
}
func (o *UDPHS_Type) GetINTSTA_EPT_12() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x100000) >> 20
}
func (o *UDPHS_Type) SetINTSTA_EPT_13(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x200000)|value<<21)
}
func (o *UDPHS_Type) GetINTSTA_EPT_13() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x200000) >> 21
}
func (o *UDPHS_Type) SetINTSTA_EPT_14(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x400000)|value<<22)
}
func (o *UDPHS_Type) GetINTSTA_EPT_14() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x400000) >> 22
}
func (o *UDPHS_Type) SetINTSTA_EPT_15(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x800000)|value<<23)
}
func (o *UDPHS_Type) GetINTSTA_EPT_15() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x800000) >> 23
}
func (o *UDPHS_Type) SetINTSTA_DMA_1(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x2000000)|value<<25)
}
func (o *UDPHS_Type) GetINTSTA_DMA_1() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x2000000) >> 25
}
func (o *UDPHS_Type) SetINTSTA_DMA_2(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x4000000)|value<<26)
}
func (o *UDPHS_Type) GetINTSTA_DMA_2() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x4000000) >> 26
}
func (o *UDPHS_Type) SetINTSTA_DMA_3(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x8000000)|value<<27)
}
func (o *UDPHS_Type) GetINTSTA_DMA_3() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x8000000) >> 27
}
func (o *UDPHS_Type) SetINTSTA_DMA_4(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x10000000)|value<<28)
}
func (o *UDPHS_Type) GetINTSTA_DMA_4() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x10000000) >> 28
}
func (o *UDPHS_Type) SetINTSTA_DMA_5(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x20000000)|value<<29)
}
func (o *UDPHS_Type) GetINTSTA_DMA_5() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x20000000) >> 29
}
func (o *UDPHS_Type) SetINTSTA_DMA_6(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x40000000)|value<<30)
}
func (o *UDPHS_Type) GetINTSTA_DMA_6() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x40000000) >> 30
}
func (o *UDPHS_Type) SetINTSTA_DMA_7(value uint32) {
	volatile.StoreUint32(&o.INTSTA.Reg, volatile.LoadUint32(&o.INTSTA.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetINTSTA_DMA_7() uint32 {
	return (volatile.LoadUint32(&o.INTSTA.Reg) & 0x80000000) >> 31
}

// UDPHS.CLRINT: UDPHS Clear Interrupt Register
func (o *UDPHS_Type) SetCLRINT_DET_SUSPD(value uint32) {
	volatile.StoreUint32(&o.CLRINT.Reg, volatile.LoadUint32(&o.CLRINT.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetCLRINT_DET_SUSPD() uint32 {
	return (volatile.LoadUint32(&o.CLRINT.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetCLRINT_MICRO_SOF(value uint32) {
	volatile.StoreUint32(&o.CLRINT.Reg, volatile.LoadUint32(&o.CLRINT.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetCLRINT_MICRO_SOF() uint32 {
	return (volatile.LoadUint32(&o.CLRINT.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetCLRINT_INT_SOF(value uint32) {
	volatile.StoreUint32(&o.CLRINT.Reg, volatile.LoadUint32(&o.CLRINT.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetCLRINT_INT_SOF() uint32 {
	return (volatile.LoadUint32(&o.CLRINT.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetCLRINT_ENDRESET(value uint32) {
	volatile.StoreUint32(&o.CLRINT.Reg, volatile.LoadUint32(&o.CLRINT.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetCLRINT_ENDRESET() uint32 {
	return (volatile.LoadUint32(&o.CLRINT.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetCLRINT_WAKE_UP(value uint32) {
	volatile.StoreUint32(&o.CLRINT.Reg, volatile.LoadUint32(&o.CLRINT.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetCLRINT_WAKE_UP() uint32 {
	return (volatile.LoadUint32(&o.CLRINT.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetCLRINT_ENDOFRSM(value uint32) {
	volatile.StoreUint32(&o.CLRINT.Reg, volatile.LoadUint32(&o.CLRINT.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetCLRINT_ENDOFRSM() uint32 {
	return (volatile.LoadUint32(&o.CLRINT.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetCLRINT_UPSTR_RES(value uint32) {
	volatile.StoreUint32(&o.CLRINT.Reg, volatile.LoadUint32(&o.CLRINT.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetCLRINT_UPSTR_RES() uint32 {
	return (volatile.LoadUint32(&o.CLRINT.Reg) & 0x80) >> 7
}

// UDPHS.EPTRST: UDPHS Endpoints Reset Register
func (o *UDPHS_Type) SetEPTRST_EPT_0(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTRST_EPT_0() uint32 {
	return volatile.LoadUint32(&o.EPTRST.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTRST_EPT_1(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTRST_EPT_1() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTRST_EPT_2(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetEPTRST_EPT_2() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetEPTRST_EPT_3(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTRST_EPT_3() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTRST_EPT_4(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTRST_EPT_4() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTRST_EPT_5(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTRST_EPT_5() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTRST_EPT_6(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTRST_EPT_6() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTRST_EPT_7(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetEPTRST_EPT_7() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetEPTRST_EPT_8(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTRST_EPT_8() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTRST_EPT_9(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTRST_EPT_9() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTRST_EPT_10(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTRST_EPT_10() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTRST_EPT_11(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTRST_EPT_11() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTRST_EPT_12(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTRST_EPT_12() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTRST_EPT_13(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTRST_EPT_13() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTRST_EPT_14(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTRST_EPT_14() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTRST_EPT_15(value uint32) {
	volatile.StoreUint32(&o.EPTRST.Reg, volatile.LoadUint32(&o.EPTRST.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTRST_EPT_15() uint32 {
	return (volatile.LoadUint32(&o.EPTRST.Reg) & 0x8000) >> 15
}

// UDPHS.TST: UDPHS Test Register
func (o *UDPHS_Type) SetTST_SPEED_CFG(value uint32) {
	volatile.StoreUint32(&o.TST.Reg, volatile.LoadUint32(&o.TST.Reg)&^(0x3)|value)
}
func (o *UDPHS_Type) GetTST_SPEED_CFG() uint32 {
	return volatile.LoadUint32(&o.TST.Reg) & 0x3
}
func (o *UDPHS_Type) SetTST_TST_J(value uint32) {
	volatile.StoreUint32(&o.TST.Reg, volatile.LoadUint32(&o.TST.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetTST_TST_J() uint32 {
	return (volatile.LoadUint32(&o.TST.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetTST_TST_K(value uint32) {
	volatile.StoreUint32(&o.TST.Reg, volatile.LoadUint32(&o.TST.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetTST_TST_K() uint32 {
	return (volatile.LoadUint32(&o.TST.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetTST_TST_PKT(value uint32) {
	volatile.StoreUint32(&o.TST.Reg, volatile.LoadUint32(&o.TST.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetTST_TST_PKT() uint32 {
	return (volatile.LoadUint32(&o.TST.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetTST_OPMODE2(value uint32) {
	volatile.StoreUint32(&o.TST.Reg, volatile.LoadUint32(&o.TST.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetTST_OPMODE2() uint32 {
	return (volatile.LoadUint32(&o.TST.Reg) & 0x20) >> 5
}

// UDPHS.EPTCFG0: UDPHS Endpoint Configuration Register (endpoint = 0)
func (o *UDPHS_Type) SetEPTCFG0_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG0.Reg, volatile.LoadUint32(&o.EPTCFG0.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG0_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG0.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG0_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG0.Reg, volatile.LoadUint32(&o.EPTCFG0.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG0_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG0.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG0_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG0.Reg, volatile.LoadUint32(&o.EPTCFG0.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG0_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG0.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG0_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG0.Reg, volatile.LoadUint32(&o.EPTCFG0.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG0_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG0.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG0_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG0.Reg, volatile.LoadUint32(&o.EPTCFG0.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG0_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG0.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG0_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG0.Reg, volatile.LoadUint32(&o.EPTCFG0.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG0_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG0.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB0: UDPHS Endpoint Control Enable Register (endpoint = 0)
func (o *UDPHS_Type) SetEPTCTLENB0_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB0_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB0_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB0_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB0_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB0_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB0_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB0_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB0_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB0_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB0_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB0_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB0_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB0_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB0_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB0_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB0_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB0_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB0_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB0_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB0_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB0_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB0_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB0_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB0_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB0_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB0_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB0.Reg, volatile.LoadUint32(&o.EPTCTLENB0.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB0_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB0.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS0: UDPHS Endpoint Control Disable Register (endpoint = 0)
func (o *UDPHS_Type) SetEPTCTLDIS0_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS0_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS0_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS0_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS0_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS0_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS0_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS0_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS0_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS0_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS0_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS0_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS0_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS0_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS0.Reg, volatile.LoadUint32(&o.EPTCTLDIS0.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS0_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS0.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL0: UDPHS Endpoint Control Register (endpoint = 0)
func (o *UDPHS_Type) SetEPTCTL0_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL0_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL0_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL0_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL0_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL0_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL0_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL0_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL0_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL0_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL0_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL0_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL0_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL0_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL0_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL0_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL0_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL0_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL0_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL0_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL0_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL0_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL0_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL0_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL0_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL0_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL0_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL0.Reg, volatile.LoadUint32(&o.EPTCTL0.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL0_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL0.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA0: UDPHS Endpoint Set Status Register (endpoint = 0)
func (o *UDPHS_Type) SetEPTSETSTA0_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA0.Reg, volatile.LoadUint32(&o.EPTSETSTA0.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA0_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA0.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA0_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA0.Reg, volatile.LoadUint32(&o.EPTSETSTA0.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA0_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA0.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA0_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA0.Reg, volatile.LoadUint32(&o.EPTSETSTA0.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA0_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA0.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA0: UDPHS Endpoint Clear Status Register (endpoint = 0)
func (o *UDPHS_Type) SetEPTCLRSTA0_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA0_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA0_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA0_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA0_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA0_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA0_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA0_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA0.Reg, volatile.LoadUint32(&o.EPTCLRSTA0.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA0_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA0.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA0: UDPHS Endpoint Status Register (endpoint = 0)
func (o *UDPHS_Type) SetEPTSTA0_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA0_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA0_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA0_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA0_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA0_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA0_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA0_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA0_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA0_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA0_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA0_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA0_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA0_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA0_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA0_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA0_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA0_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA0_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA0_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA0_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA0_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA0_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA0_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA0_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA0_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA0_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA0.Reg, volatile.LoadUint32(&o.EPTSTA0.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA0_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA0.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG1: UDPHS Endpoint Configuration Register (endpoint = 1)
func (o *UDPHS_Type) SetEPTCFG1_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG1.Reg, volatile.LoadUint32(&o.EPTCFG1.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG1_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG1.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG1_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG1.Reg, volatile.LoadUint32(&o.EPTCFG1.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG1_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG1.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG1_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG1.Reg, volatile.LoadUint32(&o.EPTCFG1.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG1_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG1.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG1_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG1.Reg, volatile.LoadUint32(&o.EPTCFG1.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG1_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG1.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG1_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG1.Reg, volatile.LoadUint32(&o.EPTCFG1.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG1_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG1.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG1_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG1.Reg, volatile.LoadUint32(&o.EPTCFG1.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG1_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG1.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB1: UDPHS Endpoint Control Enable Register (endpoint = 1)
func (o *UDPHS_Type) SetEPTCTLENB1_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB1_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB1_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB1_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB1_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB1_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB1_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB1_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB1_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB1_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB1_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB1_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB1_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB1_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB1_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB1_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB1_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB1_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB1_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB1_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB1_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB1_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB1_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB1_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB1_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB1_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB1_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB1.Reg, volatile.LoadUint32(&o.EPTCTLENB1.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB1_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB1.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS1: UDPHS Endpoint Control Disable Register (endpoint = 1)
func (o *UDPHS_Type) SetEPTCTLDIS1_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS1_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS1_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS1_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS1_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS1_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS1_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS1_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS1_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS1_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS1_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS1_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS1_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS1_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS1.Reg, volatile.LoadUint32(&o.EPTCTLDIS1.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS1_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS1.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL1: UDPHS Endpoint Control Register (endpoint = 1)
func (o *UDPHS_Type) SetEPTCTL1_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL1_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL1_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL1_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL1_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL1_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL1_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL1_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL1_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL1_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL1_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL1_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL1_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL1_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL1_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL1_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL1_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL1_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL1_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL1_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL1_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL1_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL1_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL1_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL1_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL1_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL1_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL1.Reg, volatile.LoadUint32(&o.EPTCTL1.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL1_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL1.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA1: UDPHS Endpoint Set Status Register (endpoint = 1)
func (o *UDPHS_Type) SetEPTSETSTA1_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA1.Reg, volatile.LoadUint32(&o.EPTSETSTA1.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA1_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA1.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA1_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA1.Reg, volatile.LoadUint32(&o.EPTSETSTA1.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA1_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA1.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA1_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA1.Reg, volatile.LoadUint32(&o.EPTSETSTA1.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA1_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA1.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA1: UDPHS Endpoint Clear Status Register (endpoint = 1)
func (o *UDPHS_Type) SetEPTCLRSTA1_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA1_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA1_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA1_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA1_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA1_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA1_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA1_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA1.Reg, volatile.LoadUint32(&o.EPTCLRSTA1.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA1_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA1.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA1: UDPHS Endpoint Status Register (endpoint = 1)
func (o *UDPHS_Type) SetEPTSTA1_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA1_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA1_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA1_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA1_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA1_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA1_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA1_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA1_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA1_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA1_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA1_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA1_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA1_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA1_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA1_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA1_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA1_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA1_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA1_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA1_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA1_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA1_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA1_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA1_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA1_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA1_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA1.Reg, volatile.LoadUint32(&o.EPTSTA1.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA1_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA1.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG2: UDPHS Endpoint Configuration Register (endpoint = 2)
func (o *UDPHS_Type) SetEPTCFG2_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG2.Reg, volatile.LoadUint32(&o.EPTCFG2.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG2_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG2.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG2_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG2.Reg, volatile.LoadUint32(&o.EPTCFG2.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG2_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG2.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG2_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG2.Reg, volatile.LoadUint32(&o.EPTCFG2.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG2_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG2.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG2_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG2.Reg, volatile.LoadUint32(&o.EPTCFG2.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG2_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG2.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG2_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG2.Reg, volatile.LoadUint32(&o.EPTCFG2.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG2_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG2.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG2_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG2.Reg, volatile.LoadUint32(&o.EPTCFG2.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG2_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG2.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB2: UDPHS Endpoint Control Enable Register (endpoint = 2)
func (o *UDPHS_Type) SetEPTCTLENB2_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB2_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB2_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB2_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB2_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB2_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB2_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB2_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB2_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB2_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB2_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB2_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB2_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB2_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB2_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB2_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB2_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB2_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB2_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB2_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB2_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB2_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB2_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB2_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB2_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB2_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB2_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB2.Reg, volatile.LoadUint32(&o.EPTCTLENB2.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB2_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB2.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS2: UDPHS Endpoint Control Disable Register (endpoint = 2)
func (o *UDPHS_Type) SetEPTCTLDIS2_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS2_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS2_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS2_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS2_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS2_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS2_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS2_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS2_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS2_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS2_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS2_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS2_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS2_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS2.Reg, volatile.LoadUint32(&o.EPTCTLDIS2.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS2_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS2.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL2: UDPHS Endpoint Control Register (endpoint = 2)
func (o *UDPHS_Type) SetEPTCTL2_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL2_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL2_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL2_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL2_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL2_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL2_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL2_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL2_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL2_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL2_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL2_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL2_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL2_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL2_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL2_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL2_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL2_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL2_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL2_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL2_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL2_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL2_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL2_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL2_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL2_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL2_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL2.Reg, volatile.LoadUint32(&o.EPTCTL2.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL2_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL2.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA2: UDPHS Endpoint Set Status Register (endpoint = 2)
func (o *UDPHS_Type) SetEPTSETSTA2_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA2.Reg, volatile.LoadUint32(&o.EPTSETSTA2.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA2_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA2.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA2_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA2.Reg, volatile.LoadUint32(&o.EPTSETSTA2.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA2_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA2.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA2_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA2.Reg, volatile.LoadUint32(&o.EPTSETSTA2.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA2_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA2.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA2: UDPHS Endpoint Clear Status Register (endpoint = 2)
func (o *UDPHS_Type) SetEPTCLRSTA2_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA2_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA2_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA2_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA2_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA2_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA2_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA2_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA2.Reg, volatile.LoadUint32(&o.EPTCLRSTA2.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA2_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA2.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA2: UDPHS Endpoint Status Register (endpoint = 2)
func (o *UDPHS_Type) SetEPTSTA2_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA2_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA2_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA2_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA2_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA2_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA2_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA2_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA2_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA2_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA2_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA2_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA2_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA2_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA2_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA2_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA2_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA2_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA2_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA2_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA2_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA2_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA2_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA2_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA2_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA2_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA2_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA2.Reg, volatile.LoadUint32(&o.EPTSTA2.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA2_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA2.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG3: UDPHS Endpoint Configuration Register (endpoint = 3)
func (o *UDPHS_Type) SetEPTCFG3_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG3.Reg, volatile.LoadUint32(&o.EPTCFG3.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG3_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG3.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG3_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG3.Reg, volatile.LoadUint32(&o.EPTCFG3.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG3_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG3.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG3_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG3.Reg, volatile.LoadUint32(&o.EPTCFG3.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG3_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG3.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG3_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG3.Reg, volatile.LoadUint32(&o.EPTCFG3.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG3_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG3.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG3_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG3.Reg, volatile.LoadUint32(&o.EPTCFG3.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG3_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG3.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG3_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG3.Reg, volatile.LoadUint32(&o.EPTCFG3.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG3_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG3.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB3: UDPHS Endpoint Control Enable Register (endpoint = 3)
func (o *UDPHS_Type) SetEPTCTLENB3_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB3_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB3_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB3_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB3_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB3_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB3_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB3_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB3_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB3_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB3_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB3_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB3_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB3_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB3_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB3_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB3_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB3_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB3_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB3_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB3_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB3_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB3_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB3_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB3_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB3_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB3_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB3.Reg, volatile.LoadUint32(&o.EPTCTLENB3.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB3_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB3.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS3: UDPHS Endpoint Control Disable Register (endpoint = 3)
func (o *UDPHS_Type) SetEPTCTLDIS3_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS3_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS3_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS3_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS3_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS3_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS3_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS3_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS3_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS3_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS3_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS3_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS3_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS3_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS3.Reg, volatile.LoadUint32(&o.EPTCTLDIS3.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS3_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS3.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL3: UDPHS Endpoint Control Register (endpoint = 3)
func (o *UDPHS_Type) SetEPTCTL3_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL3_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL3_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL3_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL3_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL3_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL3_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL3_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL3_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL3_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL3_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL3_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL3_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL3_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL3_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL3_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL3_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL3_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL3_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL3_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL3_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL3_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL3_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL3_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL3_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL3_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL3_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL3.Reg, volatile.LoadUint32(&o.EPTCTL3.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL3_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL3.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA3: UDPHS Endpoint Set Status Register (endpoint = 3)
func (o *UDPHS_Type) SetEPTSETSTA3_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA3.Reg, volatile.LoadUint32(&o.EPTSETSTA3.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA3_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA3.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA3_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA3.Reg, volatile.LoadUint32(&o.EPTSETSTA3.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA3_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA3.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA3_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA3.Reg, volatile.LoadUint32(&o.EPTSETSTA3.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA3_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA3.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA3: UDPHS Endpoint Clear Status Register (endpoint = 3)
func (o *UDPHS_Type) SetEPTCLRSTA3_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA3_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA3_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA3_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA3_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA3_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA3_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA3_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA3.Reg, volatile.LoadUint32(&o.EPTCLRSTA3.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA3_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA3.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA3: UDPHS Endpoint Status Register (endpoint = 3)
func (o *UDPHS_Type) SetEPTSTA3_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA3_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA3_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA3_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA3_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA3_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA3_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA3_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA3_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA3_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA3_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA3_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA3_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA3_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA3_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA3_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA3_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA3_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA3_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA3_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA3_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA3_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA3_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA3_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA3_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA3_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA3_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA3.Reg, volatile.LoadUint32(&o.EPTSTA3.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA3_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA3.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG4: UDPHS Endpoint Configuration Register (endpoint = 4)
func (o *UDPHS_Type) SetEPTCFG4_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG4.Reg, volatile.LoadUint32(&o.EPTCFG4.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG4_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG4.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG4_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG4.Reg, volatile.LoadUint32(&o.EPTCFG4.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG4_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG4.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG4_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG4.Reg, volatile.LoadUint32(&o.EPTCFG4.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG4_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG4.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG4_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG4.Reg, volatile.LoadUint32(&o.EPTCFG4.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG4_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG4.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG4_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG4.Reg, volatile.LoadUint32(&o.EPTCFG4.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG4_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG4.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG4_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG4.Reg, volatile.LoadUint32(&o.EPTCFG4.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG4_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG4.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB4: UDPHS Endpoint Control Enable Register (endpoint = 4)
func (o *UDPHS_Type) SetEPTCTLENB4_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB4_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB4_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB4_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB4_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB4_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB4_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB4_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB4_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB4_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB4_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB4_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB4_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB4_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB4_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB4_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB4_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB4_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB4_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB4_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB4_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB4_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB4_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB4_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB4_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB4_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB4_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB4.Reg, volatile.LoadUint32(&o.EPTCTLENB4.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB4_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB4.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS4: UDPHS Endpoint Control Disable Register (endpoint = 4)
func (o *UDPHS_Type) SetEPTCTLDIS4_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS4_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS4_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS4_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS4_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS4_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS4_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS4_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS4_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS4_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS4_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS4_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS4_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS4_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS4.Reg, volatile.LoadUint32(&o.EPTCTLDIS4.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS4_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS4.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL4: UDPHS Endpoint Control Register (endpoint = 4)
func (o *UDPHS_Type) SetEPTCTL4_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL4_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL4_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL4_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL4_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL4_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL4_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL4_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL4_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL4_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL4_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL4_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL4_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL4_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL4_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL4_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL4_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL4_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL4_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL4_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL4_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL4_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL4_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL4_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL4_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL4_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL4_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL4.Reg, volatile.LoadUint32(&o.EPTCTL4.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL4_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL4.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA4: UDPHS Endpoint Set Status Register (endpoint = 4)
func (o *UDPHS_Type) SetEPTSETSTA4_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA4.Reg, volatile.LoadUint32(&o.EPTSETSTA4.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA4_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA4.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA4_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA4.Reg, volatile.LoadUint32(&o.EPTSETSTA4.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA4_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA4.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA4_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA4.Reg, volatile.LoadUint32(&o.EPTSETSTA4.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA4_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA4.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA4: UDPHS Endpoint Clear Status Register (endpoint = 4)
func (o *UDPHS_Type) SetEPTCLRSTA4_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA4_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA4_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA4_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA4_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA4_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA4_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA4_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA4.Reg, volatile.LoadUint32(&o.EPTCLRSTA4.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA4_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA4.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA4: UDPHS Endpoint Status Register (endpoint = 4)
func (o *UDPHS_Type) SetEPTSTA4_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA4_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA4_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA4_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA4_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA4_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA4_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA4_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA4_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA4_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA4_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA4_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA4_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA4_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA4_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA4_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA4_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA4_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA4_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA4_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA4_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA4_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA4_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA4_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA4_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA4_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA4_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA4.Reg, volatile.LoadUint32(&o.EPTSTA4.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA4_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA4.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG5: UDPHS Endpoint Configuration Register (endpoint = 5)
func (o *UDPHS_Type) SetEPTCFG5_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG5.Reg, volatile.LoadUint32(&o.EPTCFG5.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG5_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG5.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG5_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG5.Reg, volatile.LoadUint32(&o.EPTCFG5.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG5_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG5.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG5_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG5.Reg, volatile.LoadUint32(&o.EPTCFG5.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG5_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG5.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG5_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG5.Reg, volatile.LoadUint32(&o.EPTCFG5.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG5_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG5.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG5_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG5.Reg, volatile.LoadUint32(&o.EPTCFG5.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG5_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG5.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG5_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG5.Reg, volatile.LoadUint32(&o.EPTCFG5.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG5_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG5.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB5: UDPHS Endpoint Control Enable Register (endpoint = 5)
func (o *UDPHS_Type) SetEPTCTLENB5_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB5_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB5_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB5_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB5_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB5_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB5_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB5_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB5_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB5_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB5_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB5_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB5_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB5_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB5_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB5_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB5_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB5_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB5_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB5_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB5_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB5_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB5_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB5_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB5_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB5_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB5_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB5.Reg, volatile.LoadUint32(&o.EPTCTLENB5.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB5_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB5.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS5: UDPHS Endpoint Control Disable Register (endpoint = 5)
func (o *UDPHS_Type) SetEPTCTLDIS5_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS5_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS5_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS5_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS5_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS5_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS5_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS5_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS5_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS5_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS5_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS5_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS5_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS5_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS5.Reg, volatile.LoadUint32(&o.EPTCTLDIS5.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS5_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS5.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL5: UDPHS Endpoint Control Register (endpoint = 5)
func (o *UDPHS_Type) SetEPTCTL5_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL5_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL5_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL5_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL5_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL5_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL5_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL5_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL5_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL5_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL5_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL5_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL5_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL5_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL5_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL5_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL5_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL5_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL5_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL5_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL5_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL5_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL5_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL5_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL5_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL5_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL5_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL5.Reg, volatile.LoadUint32(&o.EPTCTL5.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL5_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL5.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA5: UDPHS Endpoint Set Status Register (endpoint = 5)
func (o *UDPHS_Type) SetEPTSETSTA5_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA5.Reg, volatile.LoadUint32(&o.EPTSETSTA5.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA5_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA5.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA5_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA5.Reg, volatile.LoadUint32(&o.EPTSETSTA5.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA5_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA5.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA5_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA5.Reg, volatile.LoadUint32(&o.EPTSETSTA5.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA5_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA5.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA5: UDPHS Endpoint Clear Status Register (endpoint = 5)
func (o *UDPHS_Type) SetEPTCLRSTA5_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA5_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA5_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA5_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA5_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA5_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA5_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA5_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA5.Reg, volatile.LoadUint32(&o.EPTCLRSTA5.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA5_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA5.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA5: UDPHS Endpoint Status Register (endpoint = 5)
func (o *UDPHS_Type) SetEPTSTA5_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA5_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA5_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA5_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA5_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA5_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA5_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA5_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA5_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA5_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA5_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA5_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA5_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA5_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA5_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA5_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA5_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA5_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA5_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA5_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA5_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA5_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA5_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA5_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA5_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA5_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA5_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA5.Reg, volatile.LoadUint32(&o.EPTSTA5.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA5_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA5.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG6: UDPHS Endpoint Configuration Register (endpoint = 6)
func (o *UDPHS_Type) SetEPTCFG6_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG6.Reg, volatile.LoadUint32(&o.EPTCFG6.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG6_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG6.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG6_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG6.Reg, volatile.LoadUint32(&o.EPTCFG6.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG6_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG6.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG6_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG6.Reg, volatile.LoadUint32(&o.EPTCFG6.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG6_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG6.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG6_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG6.Reg, volatile.LoadUint32(&o.EPTCFG6.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG6_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG6.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG6_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG6.Reg, volatile.LoadUint32(&o.EPTCFG6.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG6_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG6.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG6_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG6.Reg, volatile.LoadUint32(&o.EPTCFG6.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG6_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG6.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB6: UDPHS Endpoint Control Enable Register (endpoint = 6)
func (o *UDPHS_Type) SetEPTCTLENB6_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB6_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB6_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB6_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB6_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB6_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB6_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB6_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB6_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB6_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB6_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB6_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB6_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB6_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB6_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB6_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB6_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB6_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB6_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB6_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB6_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB6_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB6_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB6_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB6_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB6_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB6_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB6.Reg, volatile.LoadUint32(&o.EPTCTLENB6.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB6_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB6.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS6: UDPHS Endpoint Control Disable Register (endpoint = 6)
func (o *UDPHS_Type) SetEPTCTLDIS6_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS6_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS6_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS6_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS6_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS6_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS6_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS6_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS6_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS6_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS6_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS6_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS6_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS6_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS6.Reg, volatile.LoadUint32(&o.EPTCTLDIS6.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS6_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS6.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL6: UDPHS Endpoint Control Register (endpoint = 6)
func (o *UDPHS_Type) SetEPTCTL6_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL6_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL6_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL6_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL6_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL6_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL6_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL6_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL6_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL6_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL6_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL6_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL6_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL6_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL6_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL6_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL6_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL6_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL6_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL6_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL6_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL6_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL6_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL6_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL6_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL6_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL6_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL6.Reg, volatile.LoadUint32(&o.EPTCTL6.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL6_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL6.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA6: UDPHS Endpoint Set Status Register (endpoint = 6)
func (o *UDPHS_Type) SetEPTSETSTA6_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA6.Reg, volatile.LoadUint32(&o.EPTSETSTA6.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA6_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA6.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA6_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA6.Reg, volatile.LoadUint32(&o.EPTSETSTA6.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA6_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA6.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA6_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA6.Reg, volatile.LoadUint32(&o.EPTSETSTA6.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA6_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA6.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA6: UDPHS Endpoint Clear Status Register (endpoint = 6)
func (o *UDPHS_Type) SetEPTCLRSTA6_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA6_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA6_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA6_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA6_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA6_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA6_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA6_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA6.Reg, volatile.LoadUint32(&o.EPTCLRSTA6.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA6_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA6.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA6: UDPHS Endpoint Status Register (endpoint = 6)
func (o *UDPHS_Type) SetEPTSTA6_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA6_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA6_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA6_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA6_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA6_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA6_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA6_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA6_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA6_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA6_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA6_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA6_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA6_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA6_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA6_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA6_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA6_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA6_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA6_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA6_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA6_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA6_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA6_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA6_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA6_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA6_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA6.Reg, volatile.LoadUint32(&o.EPTSTA6.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA6_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA6.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG7: UDPHS Endpoint Configuration Register (endpoint = 7)
func (o *UDPHS_Type) SetEPTCFG7_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG7.Reg, volatile.LoadUint32(&o.EPTCFG7.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG7_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG7.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG7_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG7.Reg, volatile.LoadUint32(&o.EPTCFG7.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG7_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG7.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG7_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG7.Reg, volatile.LoadUint32(&o.EPTCFG7.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG7_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG7.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG7_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG7.Reg, volatile.LoadUint32(&o.EPTCFG7.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG7_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG7.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG7_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG7.Reg, volatile.LoadUint32(&o.EPTCFG7.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG7_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG7.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG7_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG7.Reg, volatile.LoadUint32(&o.EPTCFG7.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG7_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG7.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB7: UDPHS Endpoint Control Enable Register (endpoint = 7)
func (o *UDPHS_Type) SetEPTCTLENB7_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB7_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB7_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB7_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB7_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB7_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB7_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB7_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB7_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB7_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB7_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB7_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB7_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB7_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB7_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB7_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB7_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB7_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB7_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB7_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB7_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB7_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB7_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB7_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB7_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB7_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB7_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB7.Reg, volatile.LoadUint32(&o.EPTCTLENB7.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB7_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB7.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS7: UDPHS Endpoint Control Disable Register (endpoint = 7)
func (o *UDPHS_Type) SetEPTCTLDIS7_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS7_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS7_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS7_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS7_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS7_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS7_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS7_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS7_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS7_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS7_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS7_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS7_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS7_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS7.Reg, volatile.LoadUint32(&o.EPTCTLDIS7.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS7_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS7.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL7: UDPHS Endpoint Control Register (endpoint = 7)
func (o *UDPHS_Type) SetEPTCTL7_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL7_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL7_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL7_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL7_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL7_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL7_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL7_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL7_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL7_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL7_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL7_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL7_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL7_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL7_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL7_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL7_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL7_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL7_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL7_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL7_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL7_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL7_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL7_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL7_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL7_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL7_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL7.Reg, volatile.LoadUint32(&o.EPTCTL7.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL7_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL7.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA7: UDPHS Endpoint Set Status Register (endpoint = 7)
func (o *UDPHS_Type) SetEPTSETSTA7_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA7.Reg, volatile.LoadUint32(&o.EPTSETSTA7.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA7_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA7.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA7_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA7.Reg, volatile.LoadUint32(&o.EPTSETSTA7.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA7_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA7.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA7_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA7.Reg, volatile.LoadUint32(&o.EPTSETSTA7.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA7_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA7.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA7: UDPHS Endpoint Clear Status Register (endpoint = 7)
func (o *UDPHS_Type) SetEPTCLRSTA7_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA7.Reg, volatile.LoadUint32(&o.EPTCLRSTA7.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA7_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA7.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA7_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA7.Reg, volatile.LoadUint32(&o.EPTCLRSTA7.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA7_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA7.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA7_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA7.Reg, volatile.LoadUint32(&o.EPTCLRSTA7.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA7_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA7.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA7_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA7.Reg, volatile.LoadUint32(&o.EPTCLRSTA7.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA7_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA7.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA7_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA7.Reg, volatile.LoadUint32(&o.EPTCLRSTA7.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA7_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA7.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA7_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA7.Reg, volatile.LoadUint32(&o.EPTCLRSTA7.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA7_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA7.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA7_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA7.Reg, volatile.LoadUint32(&o.EPTCLRSTA7.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA7_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA7.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA7_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA7.Reg, volatile.LoadUint32(&o.EPTCLRSTA7.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA7_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA7.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA7: UDPHS Endpoint Status Register (endpoint = 7)
func (o *UDPHS_Type) SetEPTSTA7_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA7_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA7_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA7_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA7_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA7_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA7_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA7_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA7_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA7_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA7_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA7_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA7_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA7_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA7_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA7_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA7_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA7_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA7_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA7_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA7_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA7_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA7_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA7_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA7_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA7_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA7_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA7.Reg, volatile.LoadUint32(&o.EPTSTA7.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA7_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA7.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG8: UDPHS Endpoint Configuration Register (endpoint = 8)
func (o *UDPHS_Type) SetEPTCFG8_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG8.Reg, volatile.LoadUint32(&o.EPTCFG8.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG8_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG8.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG8_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG8.Reg, volatile.LoadUint32(&o.EPTCFG8.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG8_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG8.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG8_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG8.Reg, volatile.LoadUint32(&o.EPTCFG8.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG8_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG8.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG8_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG8.Reg, volatile.LoadUint32(&o.EPTCFG8.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG8_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG8.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG8_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG8.Reg, volatile.LoadUint32(&o.EPTCFG8.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG8_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG8.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG8_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG8.Reg, volatile.LoadUint32(&o.EPTCFG8.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG8_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG8.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB8: UDPHS Endpoint Control Enable Register (endpoint = 8)
func (o *UDPHS_Type) SetEPTCTLENB8_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB8_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB8_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB8_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB8_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB8_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB8_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB8_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB8_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB8_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB8_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB8_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB8_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB8_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB8_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB8_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB8_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB8_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB8_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB8_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB8_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB8_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB8_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB8_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB8_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB8_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB8_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB8.Reg, volatile.LoadUint32(&o.EPTCTLENB8.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB8_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB8.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS8: UDPHS Endpoint Control Disable Register (endpoint = 8)
func (o *UDPHS_Type) SetEPTCTLDIS8_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS8_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS8_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS8_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS8_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS8_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS8_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS8_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS8_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS8_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS8_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS8_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS8_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS8_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS8.Reg, volatile.LoadUint32(&o.EPTCTLDIS8.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS8_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS8.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL8: UDPHS Endpoint Control Register (endpoint = 8)
func (o *UDPHS_Type) SetEPTCTL8_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL8_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL8_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL8_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL8_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL8_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL8_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL8_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL8_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL8_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL8_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL8_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL8_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL8_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL8_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL8_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL8_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL8_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL8_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL8_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL8_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL8_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL8_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL8_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL8_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL8_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL8_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL8.Reg, volatile.LoadUint32(&o.EPTCTL8.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL8_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL8.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA8: UDPHS Endpoint Set Status Register (endpoint = 8)
func (o *UDPHS_Type) SetEPTSETSTA8_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA8.Reg, volatile.LoadUint32(&o.EPTSETSTA8.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA8_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA8.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA8_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA8.Reg, volatile.LoadUint32(&o.EPTSETSTA8.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA8_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA8.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA8_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA8.Reg, volatile.LoadUint32(&o.EPTSETSTA8.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA8_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA8.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA8: UDPHS Endpoint Clear Status Register (endpoint = 8)
func (o *UDPHS_Type) SetEPTCLRSTA8_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA8.Reg, volatile.LoadUint32(&o.EPTCLRSTA8.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA8_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA8.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA8_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA8.Reg, volatile.LoadUint32(&o.EPTCLRSTA8.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA8_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA8.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA8_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA8.Reg, volatile.LoadUint32(&o.EPTCLRSTA8.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA8_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA8.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA8_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA8.Reg, volatile.LoadUint32(&o.EPTCLRSTA8.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA8_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA8.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA8_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA8.Reg, volatile.LoadUint32(&o.EPTCLRSTA8.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA8_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA8.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA8_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA8.Reg, volatile.LoadUint32(&o.EPTCLRSTA8.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA8_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA8.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA8_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA8.Reg, volatile.LoadUint32(&o.EPTCLRSTA8.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA8_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA8.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA8_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA8.Reg, volatile.LoadUint32(&o.EPTCLRSTA8.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA8_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA8.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA8: UDPHS Endpoint Status Register (endpoint = 8)
func (o *UDPHS_Type) SetEPTSTA8_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA8_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA8_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA8_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA8_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA8_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA8_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA8_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA8_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA8_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA8_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA8_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA8_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA8_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA8_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA8_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA8_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA8_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA8_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA8_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA8_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA8_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA8_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA8_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA8_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA8_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA8_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA8.Reg, volatile.LoadUint32(&o.EPTSTA8.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA8_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA8.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG9: UDPHS Endpoint Configuration Register (endpoint = 9)
func (o *UDPHS_Type) SetEPTCFG9_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG9.Reg, volatile.LoadUint32(&o.EPTCFG9.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG9_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG9.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG9_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG9.Reg, volatile.LoadUint32(&o.EPTCFG9.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG9_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG9.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG9_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG9.Reg, volatile.LoadUint32(&o.EPTCFG9.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG9_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG9.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG9_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG9.Reg, volatile.LoadUint32(&o.EPTCFG9.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG9_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG9.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG9_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG9.Reg, volatile.LoadUint32(&o.EPTCFG9.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG9_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG9.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG9_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG9.Reg, volatile.LoadUint32(&o.EPTCFG9.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG9_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG9.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB9: UDPHS Endpoint Control Enable Register (endpoint = 9)
func (o *UDPHS_Type) SetEPTCTLENB9_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB9_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB9_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB9_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB9_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB9_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB9_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB9_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB9_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB9_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB9_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB9_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB9_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB9_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB9_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB9_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB9_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB9_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB9_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB9_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB9_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB9_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB9_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB9_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB9_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB9_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB9_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB9.Reg, volatile.LoadUint32(&o.EPTCTLENB9.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB9_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB9.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS9: UDPHS Endpoint Control Disable Register (endpoint = 9)
func (o *UDPHS_Type) SetEPTCTLDIS9_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS9_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS9_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS9_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS9_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS9_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS9_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS9_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS9_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS9_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS9_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS9_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS9_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS9_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS9.Reg, volatile.LoadUint32(&o.EPTCTLDIS9.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS9_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS9.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL9: UDPHS Endpoint Control Register (endpoint = 9)
func (o *UDPHS_Type) SetEPTCTL9_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL9_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL9_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL9_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL9_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL9_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL9_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL9_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL9_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL9_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL9_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL9_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL9_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL9_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL9_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL9_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL9_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL9_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL9_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL9_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL9_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL9_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL9_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL9_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL9_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL9_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL9_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL9.Reg, volatile.LoadUint32(&o.EPTCTL9.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL9_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL9.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA9: UDPHS Endpoint Set Status Register (endpoint = 9)
func (o *UDPHS_Type) SetEPTSETSTA9_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA9.Reg, volatile.LoadUint32(&o.EPTSETSTA9.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA9_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA9.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA9_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA9.Reg, volatile.LoadUint32(&o.EPTSETSTA9.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA9_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA9.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA9_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA9.Reg, volatile.LoadUint32(&o.EPTSETSTA9.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA9_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA9.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA9: UDPHS Endpoint Clear Status Register (endpoint = 9)
func (o *UDPHS_Type) SetEPTCLRSTA9_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA9.Reg, volatile.LoadUint32(&o.EPTCLRSTA9.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA9_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA9.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA9_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA9.Reg, volatile.LoadUint32(&o.EPTCLRSTA9.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA9_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA9.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA9_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA9.Reg, volatile.LoadUint32(&o.EPTCLRSTA9.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA9_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA9.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA9_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA9.Reg, volatile.LoadUint32(&o.EPTCLRSTA9.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA9_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA9.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA9_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA9.Reg, volatile.LoadUint32(&o.EPTCLRSTA9.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA9_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA9.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA9_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA9.Reg, volatile.LoadUint32(&o.EPTCLRSTA9.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA9_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA9.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA9_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA9.Reg, volatile.LoadUint32(&o.EPTCLRSTA9.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA9_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA9.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA9_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA9.Reg, volatile.LoadUint32(&o.EPTCLRSTA9.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA9_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA9.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA9: UDPHS Endpoint Status Register (endpoint = 9)
func (o *UDPHS_Type) SetEPTSTA9_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA9_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA9_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA9_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA9_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA9_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA9_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA9_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA9_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA9_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA9_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA9_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA9_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA9_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA9_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA9_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA9_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA9_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA9_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA9_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA9_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA9_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA9_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA9_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA9_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA9_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA9_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA9.Reg, volatile.LoadUint32(&o.EPTSTA9.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA9_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA9.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG10: UDPHS Endpoint Configuration Register (endpoint = 10)
func (o *UDPHS_Type) SetEPTCFG10_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG10.Reg, volatile.LoadUint32(&o.EPTCFG10.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG10_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG10.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG10_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG10.Reg, volatile.LoadUint32(&o.EPTCFG10.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG10_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG10.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG10_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG10.Reg, volatile.LoadUint32(&o.EPTCFG10.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG10_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG10.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG10_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG10.Reg, volatile.LoadUint32(&o.EPTCFG10.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG10_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG10.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG10_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG10.Reg, volatile.LoadUint32(&o.EPTCFG10.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG10_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG10.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG10_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG10.Reg, volatile.LoadUint32(&o.EPTCFG10.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG10_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG10.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB10: UDPHS Endpoint Control Enable Register (endpoint = 10)
func (o *UDPHS_Type) SetEPTCTLENB10_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB10_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB10_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB10_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB10_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB10_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB10_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB10_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB10_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB10_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB10_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB10_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB10_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB10_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB10_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB10_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB10_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB10_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB10_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB10_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB10_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB10_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB10_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB10_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB10_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB10_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB10_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB10.Reg, volatile.LoadUint32(&o.EPTCTLENB10.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB10_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB10.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS10: UDPHS Endpoint Control Disable Register (endpoint = 10)
func (o *UDPHS_Type) SetEPTCTLDIS10_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS10_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS10_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS10_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS10_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS10_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS10_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS10_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS10_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS10_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS10_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS10_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS10_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS10_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS10.Reg, volatile.LoadUint32(&o.EPTCTLDIS10.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS10_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS10.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL10: UDPHS Endpoint Control Register (endpoint = 10)
func (o *UDPHS_Type) SetEPTCTL10_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL10_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL10_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL10_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL10_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL10_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL10_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL10_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL10_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL10_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL10_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL10_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL10_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL10_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL10_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL10_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL10_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL10_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL10_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL10_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL10_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL10_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL10_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL10_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL10_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL10_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL10_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL10.Reg, volatile.LoadUint32(&o.EPTCTL10.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL10_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL10.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA10: UDPHS Endpoint Set Status Register (endpoint = 10)
func (o *UDPHS_Type) SetEPTSETSTA10_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA10.Reg, volatile.LoadUint32(&o.EPTSETSTA10.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA10_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA10.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA10_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA10.Reg, volatile.LoadUint32(&o.EPTSETSTA10.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA10_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA10.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA10_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA10.Reg, volatile.LoadUint32(&o.EPTSETSTA10.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA10_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA10.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA10: UDPHS Endpoint Clear Status Register (endpoint = 10)
func (o *UDPHS_Type) SetEPTCLRSTA10_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA10.Reg, volatile.LoadUint32(&o.EPTCLRSTA10.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA10_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA10.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA10_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA10.Reg, volatile.LoadUint32(&o.EPTCLRSTA10.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA10_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA10.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA10_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA10.Reg, volatile.LoadUint32(&o.EPTCLRSTA10.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA10_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA10.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA10_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA10.Reg, volatile.LoadUint32(&o.EPTCLRSTA10.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA10_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA10.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA10_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA10.Reg, volatile.LoadUint32(&o.EPTCLRSTA10.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA10_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA10.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA10_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA10.Reg, volatile.LoadUint32(&o.EPTCLRSTA10.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA10_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA10.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA10_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA10.Reg, volatile.LoadUint32(&o.EPTCLRSTA10.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA10_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA10.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA10_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA10.Reg, volatile.LoadUint32(&o.EPTCLRSTA10.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA10_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA10.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA10: UDPHS Endpoint Status Register (endpoint = 10)
func (o *UDPHS_Type) SetEPTSTA10_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA10_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA10_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA10_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA10_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA10_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA10_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA10_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA10_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA10_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA10_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA10_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA10_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA10_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA10_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA10_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA10_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA10_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA10_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA10_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA10_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA10_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA10_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA10_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA10_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA10_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA10_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA10.Reg, volatile.LoadUint32(&o.EPTSTA10.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA10_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA10.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG11: UDPHS Endpoint Configuration Register (endpoint = 11)
func (o *UDPHS_Type) SetEPTCFG11_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG11.Reg, volatile.LoadUint32(&o.EPTCFG11.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG11_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG11.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG11_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG11.Reg, volatile.LoadUint32(&o.EPTCFG11.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG11_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG11.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG11_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG11.Reg, volatile.LoadUint32(&o.EPTCFG11.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG11_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG11.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG11_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG11.Reg, volatile.LoadUint32(&o.EPTCFG11.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG11_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG11.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG11_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG11.Reg, volatile.LoadUint32(&o.EPTCFG11.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG11_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG11.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG11_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG11.Reg, volatile.LoadUint32(&o.EPTCFG11.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG11_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG11.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB11: UDPHS Endpoint Control Enable Register (endpoint = 11)
func (o *UDPHS_Type) SetEPTCTLENB11_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB11_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB11_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB11_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB11_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB11_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB11_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB11_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB11_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB11_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB11_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB11_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB11_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB11_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB11_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB11_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB11_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB11_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB11_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB11_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB11_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB11_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB11_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB11_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB11_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB11_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB11_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB11.Reg, volatile.LoadUint32(&o.EPTCTLENB11.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB11_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB11.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS11: UDPHS Endpoint Control Disable Register (endpoint = 11)
func (o *UDPHS_Type) SetEPTCTLDIS11_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS11_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS11_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS11_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS11_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS11_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS11_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS11_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS11_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS11_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS11_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS11_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS11_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS11_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS11.Reg, volatile.LoadUint32(&o.EPTCTLDIS11.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS11_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS11.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL11: UDPHS Endpoint Control Register (endpoint = 11)
func (o *UDPHS_Type) SetEPTCTL11_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL11_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL11_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL11_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL11_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL11_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL11_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL11_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL11_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL11_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL11_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL11_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL11_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL11_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL11_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL11_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL11_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL11_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL11_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL11_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL11_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL11_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL11_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL11_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL11_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL11_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL11_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL11.Reg, volatile.LoadUint32(&o.EPTCTL11.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL11_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL11.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA11: UDPHS Endpoint Set Status Register (endpoint = 11)
func (o *UDPHS_Type) SetEPTSETSTA11_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA11.Reg, volatile.LoadUint32(&o.EPTSETSTA11.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA11_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA11.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA11_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA11.Reg, volatile.LoadUint32(&o.EPTSETSTA11.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA11_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA11.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA11_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA11.Reg, volatile.LoadUint32(&o.EPTSETSTA11.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA11_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA11.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA11: UDPHS Endpoint Clear Status Register (endpoint = 11)
func (o *UDPHS_Type) SetEPTCLRSTA11_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA11.Reg, volatile.LoadUint32(&o.EPTCLRSTA11.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA11_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA11.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA11_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA11.Reg, volatile.LoadUint32(&o.EPTCLRSTA11.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA11_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA11.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA11_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA11.Reg, volatile.LoadUint32(&o.EPTCLRSTA11.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA11_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA11.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA11_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA11.Reg, volatile.LoadUint32(&o.EPTCLRSTA11.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA11_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA11.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA11_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA11.Reg, volatile.LoadUint32(&o.EPTCLRSTA11.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA11_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA11.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA11_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA11.Reg, volatile.LoadUint32(&o.EPTCLRSTA11.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA11_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA11.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA11_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA11.Reg, volatile.LoadUint32(&o.EPTCLRSTA11.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA11_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA11.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA11_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA11.Reg, volatile.LoadUint32(&o.EPTCLRSTA11.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA11_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA11.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA11: UDPHS Endpoint Status Register (endpoint = 11)
func (o *UDPHS_Type) SetEPTSTA11_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA11_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA11_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA11_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA11_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA11_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA11_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA11_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA11_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA11_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA11_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA11_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA11_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA11_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA11_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA11_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA11_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA11_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA11_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA11_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA11_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA11_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA11_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA11_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA11_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA11_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA11_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA11.Reg, volatile.LoadUint32(&o.EPTSTA11.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA11_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA11.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG12: UDPHS Endpoint Configuration Register (endpoint = 12)
func (o *UDPHS_Type) SetEPTCFG12_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG12.Reg, volatile.LoadUint32(&o.EPTCFG12.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG12_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG12.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG12_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG12.Reg, volatile.LoadUint32(&o.EPTCFG12.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG12_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG12.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG12_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG12.Reg, volatile.LoadUint32(&o.EPTCFG12.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG12_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG12.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG12_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG12.Reg, volatile.LoadUint32(&o.EPTCFG12.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG12_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG12.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG12_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG12.Reg, volatile.LoadUint32(&o.EPTCFG12.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG12_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG12.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG12_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG12.Reg, volatile.LoadUint32(&o.EPTCFG12.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG12_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG12.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB12: UDPHS Endpoint Control Enable Register (endpoint = 12)
func (o *UDPHS_Type) SetEPTCTLENB12_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB12_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB12_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB12_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB12_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB12_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB12_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB12_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB12_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB12_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB12_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB12_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB12_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB12_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB12_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB12_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB12_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB12_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB12_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB12_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB12_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB12_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB12_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB12_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB12_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB12_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB12_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB12.Reg, volatile.LoadUint32(&o.EPTCTLENB12.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB12_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB12.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS12: UDPHS Endpoint Control Disable Register (endpoint = 12)
func (o *UDPHS_Type) SetEPTCTLDIS12_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS12_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS12_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS12_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS12_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS12_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS12_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS12_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS12_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS12_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS12_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS12_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS12_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS12_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS12.Reg, volatile.LoadUint32(&o.EPTCTLDIS12.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS12_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS12.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL12: UDPHS Endpoint Control Register (endpoint = 12)
func (o *UDPHS_Type) SetEPTCTL12_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL12_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL12_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL12_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL12_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL12_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL12_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL12_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL12_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL12_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL12_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL12_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL12_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL12_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL12_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL12_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL12_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL12_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL12_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL12_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL12_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL12_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL12_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL12_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL12_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL12_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL12_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL12.Reg, volatile.LoadUint32(&o.EPTCTL12.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL12_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL12.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA12: UDPHS Endpoint Set Status Register (endpoint = 12)
func (o *UDPHS_Type) SetEPTSETSTA12_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA12.Reg, volatile.LoadUint32(&o.EPTSETSTA12.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA12_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA12.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA12_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA12.Reg, volatile.LoadUint32(&o.EPTSETSTA12.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA12_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA12.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA12_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA12.Reg, volatile.LoadUint32(&o.EPTSETSTA12.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA12_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA12.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA12: UDPHS Endpoint Clear Status Register (endpoint = 12)
func (o *UDPHS_Type) SetEPTCLRSTA12_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA12.Reg, volatile.LoadUint32(&o.EPTCLRSTA12.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA12_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA12.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA12_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA12.Reg, volatile.LoadUint32(&o.EPTCLRSTA12.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA12_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA12.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA12_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA12.Reg, volatile.LoadUint32(&o.EPTCLRSTA12.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA12_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA12.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA12_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA12.Reg, volatile.LoadUint32(&o.EPTCLRSTA12.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA12_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA12.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA12_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA12.Reg, volatile.LoadUint32(&o.EPTCLRSTA12.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA12_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA12.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA12_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA12.Reg, volatile.LoadUint32(&o.EPTCLRSTA12.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA12_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA12.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA12_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA12.Reg, volatile.LoadUint32(&o.EPTCLRSTA12.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA12_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA12.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA12_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA12.Reg, volatile.LoadUint32(&o.EPTCLRSTA12.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA12_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA12.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA12: UDPHS Endpoint Status Register (endpoint = 12)
func (o *UDPHS_Type) SetEPTSTA12_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA12_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA12_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA12_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA12_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA12_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA12_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA12_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA12_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA12_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA12_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA12_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA12_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA12_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA12_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA12_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA12_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA12_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA12_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA12_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA12_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA12_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA12_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA12_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA12_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA12_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA12_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA12.Reg, volatile.LoadUint32(&o.EPTSTA12.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA12_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA12.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG13: UDPHS Endpoint Configuration Register (endpoint = 13)
func (o *UDPHS_Type) SetEPTCFG13_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG13.Reg, volatile.LoadUint32(&o.EPTCFG13.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG13_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG13.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG13_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG13.Reg, volatile.LoadUint32(&o.EPTCFG13.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG13_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG13.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG13_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG13.Reg, volatile.LoadUint32(&o.EPTCFG13.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG13_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG13.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG13_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG13.Reg, volatile.LoadUint32(&o.EPTCFG13.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG13_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG13.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG13_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG13.Reg, volatile.LoadUint32(&o.EPTCFG13.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG13_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG13.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG13_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG13.Reg, volatile.LoadUint32(&o.EPTCFG13.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG13_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG13.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB13: UDPHS Endpoint Control Enable Register (endpoint = 13)
func (o *UDPHS_Type) SetEPTCTLENB13_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB13_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB13_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB13_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB13_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB13_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB13_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB13_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB13_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB13_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB13_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB13_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB13_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB13_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB13_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB13_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB13_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB13_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB13_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB13_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB13_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB13_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB13_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB13_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB13_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB13_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB13_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB13.Reg, volatile.LoadUint32(&o.EPTCTLENB13.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB13_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB13.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS13: UDPHS Endpoint Control Disable Register (endpoint = 13)
func (o *UDPHS_Type) SetEPTCTLDIS13_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS13_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS13_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS13_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS13_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS13_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS13_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS13_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS13_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS13_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS13_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS13_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS13_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS13_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS13.Reg, volatile.LoadUint32(&o.EPTCTLDIS13.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS13_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS13.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL13: UDPHS Endpoint Control Register (endpoint = 13)
func (o *UDPHS_Type) SetEPTCTL13_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL13_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL13_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL13_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL13_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL13_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL13_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL13_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL13_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL13_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL13_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL13_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL13_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL13_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL13_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL13_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL13_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL13_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL13_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL13_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL13_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL13_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL13_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL13_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL13_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL13_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL13_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL13.Reg, volatile.LoadUint32(&o.EPTCTL13.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL13_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL13.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA13: UDPHS Endpoint Set Status Register (endpoint = 13)
func (o *UDPHS_Type) SetEPTSETSTA13_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA13.Reg, volatile.LoadUint32(&o.EPTSETSTA13.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA13_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA13.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA13_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA13.Reg, volatile.LoadUint32(&o.EPTSETSTA13.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA13_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA13.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA13_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA13.Reg, volatile.LoadUint32(&o.EPTSETSTA13.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA13_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA13.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA13: UDPHS Endpoint Clear Status Register (endpoint = 13)
func (o *UDPHS_Type) SetEPTCLRSTA13_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA13.Reg, volatile.LoadUint32(&o.EPTCLRSTA13.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA13_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA13.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA13_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA13.Reg, volatile.LoadUint32(&o.EPTCLRSTA13.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA13_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA13.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA13_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA13.Reg, volatile.LoadUint32(&o.EPTCLRSTA13.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA13_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA13.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA13_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA13.Reg, volatile.LoadUint32(&o.EPTCLRSTA13.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA13_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA13.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA13_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA13.Reg, volatile.LoadUint32(&o.EPTCLRSTA13.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA13_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA13.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA13_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA13.Reg, volatile.LoadUint32(&o.EPTCLRSTA13.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA13_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA13.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA13_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA13.Reg, volatile.LoadUint32(&o.EPTCLRSTA13.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA13_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA13.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA13_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA13.Reg, volatile.LoadUint32(&o.EPTCLRSTA13.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA13_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA13.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA13: UDPHS Endpoint Status Register (endpoint = 13)
func (o *UDPHS_Type) SetEPTSTA13_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA13_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA13_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA13_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA13_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA13_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA13_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA13_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA13_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA13_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA13_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA13_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA13_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA13_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA13_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA13_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA13_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA13_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA13_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA13_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA13_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA13_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA13_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA13_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA13_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA13_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA13_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA13.Reg, volatile.LoadUint32(&o.EPTSTA13.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA13_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA13.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG14: UDPHS Endpoint Configuration Register (endpoint = 14)
func (o *UDPHS_Type) SetEPTCFG14_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG14.Reg, volatile.LoadUint32(&o.EPTCFG14.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG14_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG14.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG14_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG14.Reg, volatile.LoadUint32(&o.EPTCFG14.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG14_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG14.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG14_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG14.Reg, volatile.LoadUint32(&o.EPTCFG14.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG14_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG14.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG14_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG14.Reg, volatile.LoadUint32(&o.EPTCFG14.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG14_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG14.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG14_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG14.Reg, volatile.LoadUint32(&o.EPTCFG14.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG14_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG14.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG14_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG14.Reg, volatile.LoadUint32(&o.EPTCFG14.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG14_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG14.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB14: UDPHS Endpoint Control Enable Register (endpoint = 14)
func (o *UDPHS_Type) SetEPTCTLENB14_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB14_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB14_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB14_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB14_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB14_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB14_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB14_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB14_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB14_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB14_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB14_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB14_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB14_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB14_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB14_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB14_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB14_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB14_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB14_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB14_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB14_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB14_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB14_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB14_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB14_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB14_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB14.Reg, volatile.LoadUint32(&o.EPTCTLENB14.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB14_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB14.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS14: UDPHS Endpoint Control Disable Register (endpoint = 14)
func (o *UDPHS_Type) SetEPTCTLDIS14_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS14_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS14_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS14_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS14_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS14_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS14_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS14_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS14_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS14_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS14_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS14_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS14_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS14_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS14.Reg, volatile.LoadUint32(&o.EPTCTLDIS14.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS14_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS14.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL14: UDPHS Endpoint Control Register (endpoint = 14)
func (o *UDPHS_Type) SetEPTCTL14_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL14_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL14_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL14_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL14_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL14_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL14_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL14_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL14_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL14_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL14_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL14_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL14_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL14_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL14_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL14_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL14_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL14_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL14_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL14_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL14_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL14_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL14_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL14_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL14_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL14_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL14_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL14.Reg, volatile.LoadUint32(&o.EPTCTL14.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL14_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL14.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA14: UDPHS Endpoint Set Status Register (endpoint = 14)
func (o *UDPHS_Type) SetEPTSETSTA14_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA14.Reg, volatile.LoadUint32(&o.EPTSETSTA14.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA14_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA14.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA14_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA14.Reg, volatile.LoadUint32(&o.EPTSETSTA14.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA14_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA14.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA14_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA14.Reg, volatile.LoadUint32(&o.EPTSETSTA14.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA14_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA14.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA14: UDPHS Endpoint Clear Status Register (endpoint = 14)
func (o *UDPHS_Type) SetEPTCLRSTA14_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA14.Reg, volatile.LoadUint32(&o.EPTCLRSTA14.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA14_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA14.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA14_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA14.Reg, volatile.LoadUint32(&o.EPTCLRSTA14.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA14_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA14.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA14_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA14.Reg, volatile.LoadUint32(&o.EPTCLRSTA14.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA14_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA14.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA14_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA14.Reg, volatile.LoadUint32(&o.EPTCLRSTA14.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA14_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA14.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA14_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA14.Reg, volatile.LoadUint32(&o.EPTCLRSTA14.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA14_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA14.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA14_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA14.Reg, volatile.LoadUint32(&o.EPTCLRSTA14.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA14_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA14.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA14_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA14.Reg, volatile.LoadUint32(&o.EPTCLRSTA14.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA14_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA14.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA14_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA14.Reg, volatile.LoadUint32(&o.EPTCLRSTA14.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA14_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA14.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA14: UDPHS Endpoint Status Register (endpoint = 14)
func (o *UDPHS_Type) SetEPTSTA14_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA14_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA14_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA14_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA14_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA14_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA14_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA14_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA14_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA14_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA14_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA14_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA14_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA14_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA14_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA14_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA14_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA14_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA14_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA14_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA14_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA14_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA14_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA14_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA14_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA14_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA14_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA14.Reg, volatile.LoadUint32(&o.EPTSTA14.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA14_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA14.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCFG15: UDPHS Endpoint Configuration Register (endpoint = 15)
func (o *UDPHS_Type) SetEPTCFG15_EPT_SIZE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG15.Reg, volatile.LoadUint32(&o.EPTCFG15.Reg)&^(0x7)|value)
}
func (o *UDPHS_Type) GetEPTCFG15_EPT_SIZE() uint32 {
	return volatile.LoadUint32(&o.EPTCFG15.Reg) & 0x7
}
func (o *UDPHS_Type) SetEPTCFG15_EPT_DIR(value uint32) {
	volatile.StoreUint32(&o.EPTCFG15.Reg, volatile.LoadUint32(&o.EPTCFG15.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCFG15_EPT_DIR() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG15.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCFG15_EPT_TYPE(value uint32) {
	volatile.StoreUint32(&o.EPTCFG15.Reg, volatile.LoadUint32(&o.EPTCFG15.Reg)&^(0x30)|value<<4)
}
func (o *UDPHS_Type) GetEPTCFG15_EPT_TYPE() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG15.Reg) & 0x30) >> 4
}
func (o *UDPHS_Type) SetEPTCFG15_BK_NUMBER(value uint32) {
	volatile.StoreUint32(&o.EPTCFG15.Reg, volatile.LoadUint32(&o.EPTCFG15.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTCFG15_BK_NUMBER() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG15.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTCFG15_NB_TRANS(value uint32) {
	volatile.StoreUint32(&o.EPTCFG15.Reg, volatile.LoadUint32(&o.EPTCFG15.Reg)&^(0x300)|value<<8)
}
func (o *UDPHS_Type) GetEPTCFG15_NB_TRANS() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG15.Reg) & 0x300) >> 8
}
func (o *UDPHS_Type) SetEPTCFG15_EPT_MAPD(value uint32) {
	volatile.StoreUint32(&o.EPTCFG15.Reg, volatile.LoadUint32(&o.EPTCFG15.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCFG15_EPT_MAPD() uint32 {
	return (volatile.LoadUint32(&o.EPTCFG15.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLENB15: UDPHS Endpoint Control Enable Register (endpoint = 15)
func (o *UDPHS_Type) SetEPTCTLENB15_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLENB15_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLENB15_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLENB15_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLENB15_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLENB15_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLENB15_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLENB15_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLENB15_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLENB15_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLENB15_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLENB15_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLENB15_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLENB15_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLENB15_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLENB15_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLENB15_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLENB15_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLENB15_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLENB15_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLENB15_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLENB15_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLENB15_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLENB15_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLENB15_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLENB15_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLENB15_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLENB15.Reg, volatile.LoadUint32(&o.EPTCTLENB15.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLENB15_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLENB15.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTLDIS15: UDPHS Endpoint Control Disable Register (endpoint = 15)
func (o *UDPHS_Type) SetEPTCTLDIS15_EPT_DISABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_EPT_DISABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTLDIS15_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTLDIS15_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTLDIS15_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTLDIS15_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTLDIS15_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTLDIS15_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTLDIS15_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTLDIS15_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTLDIS15_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTLDIS15_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTLDIS15_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTLDIS15_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTLDIS15_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTLDIS15.Reg, volatile.LoadUint32(&o.EPTCTLDIS15.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTLDIS15_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTLDIS15.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTCTL15: UDPHS Endpoint Control Register (endpoint = 15)
func (o *UDPHS_Type) SetEPTCTL15_EPT_ENABL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetEPTCTL15_EPT_ENABL() uint32 {
	return volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x1
}
func (o *UDPHS_Type) SetEPTCTL15_AUTO_VALID(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetEPTCTL15_AUTO_VALID() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetEPTCTL15_INTDIS_DMA(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetEPTCTL15_INTDIS_DMA() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetEPTCTL15_NYET_DIS(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetEPTCTL15_NYET_DIS() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetEPTCTL15_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTCTL15_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTCTL15_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCTL15_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCTL15_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCTL15_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCTL15_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTCTL15_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTCTL15_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCTL15_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCTL15_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCTL15_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCTL15_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCTL15_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCTL15_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCTL15_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTCTL15_BUSY_BANK(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x40000)|value<<18)
}
func (o *UDPHS_Type) GetEPTCTL15_BUSY_BANK() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x40000) >> 18
}
func (o *UDPHS_Type) SetEPTCTL15_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTCTL15.Reg, volatile.LoadUint32(&o.EPTCTL15.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTCTL15_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTCTL15.Reg) & 0x80000000) >> 31
}

// UDPHS.EPTSETSTA15: UDPHS Endpoint Set Status Register (endpoint = 15)
func (o *UDPHS_Type) SetEPTSETSTA15_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA15.Reg, volatile.LoadUint32(&o.EPTSETSTA15.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSETSTA15_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA15.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSETSTA15_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA15.Reg, volatile.LoadUint32(&o.EPTSETSTA15.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSETSTA15_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA15.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSETSTA15_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSETSTA15.Reg, volatile.LoadUint32(&o.EPTSETSTA15.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSETSTA15_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSETSTA15.Reg) & 0x800) >> 11
}

// UDPHS.EPTCLRSTA15: UDPHS Endpoint Clear Status Register (endpoint = 15)
func (o *UDPHS_Type) SetEPTCLRSTA15_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA15.Reg, volatile.LoadUint32(&o.EPTCLRSTA15.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTCLRSTA15_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA15.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTCLRSTA15_TOGGLESQ(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA15.Reg, volatile.LoadUint32(&o.EPTCLRSTA15.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetEPTCLRSTA15_TOGGLESQ() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA15.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetEPTCLRSTA15_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA15.Reg, volatile.LoadUint32(&o.EPTCLRSTA15.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTCLRSTA15_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA15.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTCLRSTA15_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA15.Reg, volatile.LoadUint32(&o.EPTCLRSTA15.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTCLRSTA15_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA15.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTCLRSTA15_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA15.Reg, volatile.LoadUint32(&o.EPTCLRSTA15.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTCLRSTA15_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA15.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTCLRSTA15_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA15.Reg, volatile.LoadUint32(&o.EPTCLRSTA15.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTCLRSTA15_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA15.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTCLRSTA15_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA15.Reg, volatile.LoadUint32(&o.EPTCLRSTA15.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTCLRSTA15_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA15.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTCLRSTA15_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTCLRSTA15.Reg, volatile.LoadUint32(&o.EPTCLRSTA15.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTCLRSTA15_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTCLRSTA15.Reg) & 0x8000) >> 15
}

// UDPHS.EPTSTA15: UDPHS Endpoint Status Register (endpoint = 15)
func (o *UDPHS_Type) SetEPTSTA15_FRCESTALL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetEPTSTA15_FRCESTALL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetEPTSTA15_TOGGLESQ_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0xc0)|value<<6)
}
func (o *UDPHS_Type) GetEPTSTA15_TOGGLESQ_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0xc0) >> 6
}
func (o *UDPHS_Type) SetEPTSTA15_ERR_OVFLW(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x100)|value<<8)
}
func (o *UDPHS_Type) GetEPTSTA15_ERR_OVFLW() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x100) >> 8
}
func (o *UDPHS_Type) SetEPTSTA15_RXRDY_TXKL(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x200)|value<<9)
}
func (o *UDPHS_Type) GetEPTSTA15_RXRDY_TXKL() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x200) >> 9
}
func (o *UDPHS_Type) SetEPTSTA15_TX_COMPLT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x400)|value<<10)
}
func (o *UDPHS_Type) GetEPTSTA15_TX_COMPLT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x400) >> 10
}
func (o *UDPHS_Type) SetEPTSTA15_TXRDY(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x800)|value<<11)
}
func (o *UDPHS_Type) GetEPTSTA15_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x800) >> 11
}
func (o *UDPHS_Type) SetEPTSTA15_RX_SETUP(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x1000)|value<<12)
}
func (o *UDPHS_Type) GetEPTSTA15_RX_SETUP() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x1000) >> 12
}
func (o *UDPHS_Type) SetEPTSTA15_STALL_SNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x2000)|value<<13)
}
func (o *UDPHS_Type) GetEPTSTA15_STALL_SNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x2000) >> 13
}
func (o *UDPHS_Type) SetEPTSTA15_NAK_IN(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x4000)|value<<14)
}
func (o *UDPHS_Type) GetEPTSTA15_NAK_IN() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x4000) >> 14
}
func (o *UDPHS_Type) SetEPTSTA15_NAK_OUT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x8000)|value<<15)
}
func (o *UDPHS_Type) GetEPTSTA15_NAK_OUT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x8000) >> 15
}
func (o *UDPHS_Type) SetEPTSTA15_CURBK_CTLDIR(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x30000)|value<<16)
}
func (o *UDPHS_Type) GetEPTSTA15_CURBK_CTLDIR() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x30000) >> 16
}
func (o *UDPHS_Type) SetEPTSTA15_BUSY_BANK_STA(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0xc0000)|value<<18)
}
func (o *UDPHS_Type) GetEPTSTA15_BUSY_BANK_STA() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0xc0000) >> 18
}
func (o *UDPHS_Type) SetEPTSTA15_BYTE_COUNT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x7ff00000)|value<<20)
}
func (o *UDPHS_Type) GetEPTSTA15_BYTE_COUNT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x7ff00000) >> 20
}
func (o *UDPHS_Type) SetEPTSTA15_SHRT_PCKT(value uint32) {
	volatile.StoreUint32(&o.EPTSTA15.Reg, volatile.LoadUint32(&o.EPTSTA15.Reg)&^(0x80000000)|value<<31)
}
func (o *UDPHS_Type) GetEPTSTA15_SHRT_PCKT() uint32 {
	return (volatile.LoadUint32(&o.EPTSTA15.Reg) & 0x80000000) >> 31
}

// UDPHS.DMANXTDSC0: UDPHS DMA Next Descriptor Address Register (channel = 0)
func (o *UDPHS_Type) SetDMANXTDSC0(value uint32) {
	volatile.StoreUint32(&o.DMANXTDSC0.Reg, value)
}
func (o *UDPHS_Type) GetDMANXTDSC0() uint32 {
	return volatile.LoadUint32(&o.DMANXTDSC0.Reg)
}

// UDPHS.DMAADDRESS0: UDPHS DMA Channel Address Register (channel = 0)
func (o *UDPHS_Type) SetDMAADDRESS0(value uint32) {
	volatile.StoreUint32(&o.DMAADDRESS0.Reg, value)
}
func (o *UDPHS_Type) GetDMAADDRESS0() uint32 {
	return volatile.LoadUint32(&o.DMAADDRESS0.Reg)
}

// UDPHS.DMACONTROL0: UDPHS DMA Channel Control Register (channel = 0)
func (o *UDPHS_Type) SetDMACONTROL0_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMACONTROL0_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMACONTROL0_LDNXT_DSC(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMACONTROL0_LDNXT_DSC() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMACONTROL0_END_TR_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetDMACONTROL0_END_TR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetDMACONTROL0_END_B_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetDMACONTROL0_END_B_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetDMACONTROL0_END_TR_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMACONTROL0_END_TR_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMACONTROL0_END_BUFFIT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMACONTROL0_END_BUFFIT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMACONTROL0_DESC_LD_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMACONTROL0_DESC_LD_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMACONTROL0_BURST_LCK(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetDMACONTROL0_BURST_LCK() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetDMACONTROL0_BUFF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL0.Reg, volatile.LoadUint32(&o.DMACONTROL0.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMACONTROL0_BUFF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL0.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMASTATUS0: UDPHS DMA Channel Status Register (channel = 0)
func (o *UDPHS_Type) SetDMASTATUS0_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS0.Reg, volatile.LoadUint32(&o.DMASTATUS0.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMASTATUS0_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMASTATUS0.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMASTATUS0_CHANN_ACT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS0.Reg, volatile.LoadUint32(&o.DMASTATUS0.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMASTATUS0_CHANN_ACT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS0.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMASTATUS0_END_TR_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS0.Reg, volatile.LoadUint32(&o.DMASTATUS0.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMASTATUS0_END_TR_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS0.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMASTATUS0_END_BF_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS0.Reg, volatile.LoadUint32(&o.DMASTATUS0.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMASTATUS0_END_BF_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS0.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMASTATUS0_DESC_LDST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS0.Reg, volatile.LoadUint32(&o.DMASTATUS0.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMASTATUS0_DESC_LDST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS0.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMASTATUS0_BUFF_COUNT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS0.Reg, volatile.LoadUint32(&o.DMASTATUS0.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMASTATUS0_BUFF_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS0.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMANXTDSC1: UDPHS DMA Next Descriptor Address Register (channel = 1)
func (o *UDPHS_Type) SetDMANXTDSC1(value uint32) {
	volatile.StoreUint32(&o.DMANXTDSC1.Reg, value)
}
func (o *UDPHS_Type) GetDMANXTDSC1() uint32 {
	return volatile.LoadUint32(&o.DMANXTDSC1.Reg)
}

// UDPHS.DMAADDRESS1: UDPHS DMA Channel Address Register (channel = 1)
func (o *UDPHS_Type) SetDMAADDRESS1(value uint32) {
	volatile.StoreUint32(&o.DMAADDRESS1.Reg, value)
}
func (o *UDPHS_Type) GetDMAADDRESS1() uint32 {
	return volatile.LoadUint32(&o.DMAADDRESS1.Reg)
}

// UDPHS.DMACONTROL1: UDPHS DMA Channel Control Register (channel = 1)
func (o *UDPHS_Type) SetDMACONTROL1_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMACONTROL1_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMACONTROL1_LDNXT_DSC(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMACONTROL1_LDNXT_DSC() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMACONTROL1_END_TR_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetDMACONTROL1_END_TR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetDMACONTROL1_END_B_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetDMACONTROL1_END_B_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetDMACONTROL1_END_TR_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMACONTROL1_END_TR_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMACONTROL1_END_BUFFIT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMACONTROL1_END_BUFFIT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMACONTROL1_DESC_LD_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMACONTROL1_DESC_LD_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMACONTROL1_BURST_LCK(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetDMACONTROL1_BURST_LCK() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetDMACONTROL1_BUFF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL1.Reg, volatile.LoadUint32(&o.DMACONTROL1.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMACONTROL1_BUFF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL1.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMASTATUS1: UDPHS DMA Channel Status Register (channel = 1)
func (o *UDPHS_Type) SetDMASTATUS1_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS1.Reg, volatile.LoadUint32(&o.DMASTATUS1.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMASTATUS1_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMASTATUS1.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMASTATUS1_CHANN_ACT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS1.Reg, volatile.LoadUint32(&o.DMASTATUS1.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMASTATUS1_CHANN_ACT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS1.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMASTATUS1_END_TR_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS1.Reg, volatile.LoadUint32(&o.DMASTATUS1.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMASTATUS1_END_TR_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS1.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMASTATUS1_END_BF_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS1.Reg, volatile.LoadUint32(&o.DMASTATUS1.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMASTATUS1_END_BF_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS1.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMASTATUS1_DESC_LDST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS1.Reg, volatile.LoadUint32(&o.DMASTATUS1.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMASTATUS1_DESC_LDST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS1.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMASTATUS1_BUFF_COUNT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS1.Reg, volatile.LoadUint32(&o.DMASTATUS1.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMASTATUS1_BUFF_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS1.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMANXTDSC2: UDPHS DMA Next Descriptor Address Register (channel = 2)
func (o *UDPHS_Type) SetDMANXTDSC2(value uint32) {
	volatile.StoreUint32(&o.DMANXTDSC2.Reg, value)
}
func (o *UDPHS_Type) GetDMANXTDSC2() uint32 {
	return volatile.LoadUint32(&o.DMANXTDSC2.Reg)
}

// UDPHS.DMAADDRESS2: UDPHS DMA Channel Address Register (channel = 2)
func (o *UDPHS_Type) SetDMAADDRESS2(value uint32) {
	volatile.StoreUint32(&o.DMAADDRESS2.Reg, value)
}
func (o *UDPHS_Type) GetDMAADDRESS2() uint32 {
	return volatile.LoadUint32(&o.DMAADDRESS2.Reg)
}

// UDPHS.DMACONTROL2: UDPHS DMA Channel Control Register (channel = 2)
func (o *UDPHS_Type) SetDMACONTROL2_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMACONTROL2_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMACONTROL2_LDNXT_DSC(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMACONTROL2_LDNXT_DSC() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMACONTROL2_END_TR_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetDMACONTROL2_END_TR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetDMACONTROL2_END_B_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetDMACONTROL2_END_B_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetDMACONTROL2_END_TR_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMACONTROL2_END_TR_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMACONTROL2_END_BUFFIT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMACONTROL2_END_BUFFIT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMACONTROL2_DESC_LD_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMACONTROL2_DESC_LD_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMACONTROL2_BURST_LCK(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetDMACONTROL2_BURST_LCK() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetDMACONTROL2_BUFF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL2.Reg, volatile.LoadUint32(&o.DMACONTROL2.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMACONTROL2_BUFF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL2.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMASTATUS2: UDPHS DMA Channel Status Register (channel = 2)
func (o *UDPHS_Type) SetDMASTATUS2_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS2.Reg, volatile.LoadUint32(&o.DMASTATUS2.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMASTATUS2_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMASTATUS2.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMASTATUS2_CHANN_ACT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS2.Reg, volatile.LoadUint32(&o.DMASTATUS2.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMASTATUS2_CHANN_ACT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS2.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMASTATUS2_END_TR_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS2.Reg, volatile.LoadUint32(&o.DMASTATUS2.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMASTATUS2_END_TR_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS2.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMASTATUS2_END_BF_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS2.Reg, volatile.LoadUint32(&o.DMASTATUS2.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMASTATUS2_END_BF_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS2.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMASTATUS2_DESC_LDST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS2.Reg, volatile.LoadUint32(&o.DMASTATUS2.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMASTATUS2_DESC_LDST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS2.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMASTATUS2_BUFF_COUNT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS2.Reg, volatile.LoadUint32(&o.DMASTATUS2.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMASTATUS2_BUFF_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS2.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMANXTDSC3: UDPHS DMA Next Descriptor Address Register (channel = 3)
func (o *UDPHS_Type) SetDMANXTDSC3(value uint32) {
	volatile.StoreUint32(&o.DMANXTDSC3.Reg, value)
}
func (o *UDPHS_Type) GetDMANXTDSC3() uint32 {
	return volatile.LoadUint32(&o.DMANXTDSC3.Reg)
}

// UDPHS.DMAADDRESS3: UDPHS DMA Channel Address Register (channel = 3)
func (o *UDPHS_Type) SetDMAADDRESS3(value uint32) {
	volatile.StoreUint32(&o.DMAADDRESS3.Reg, value)
}
func (o *UDPHS_Type) GetDMAADDRESS3() uint32 {
	return volatile.LoadUint32(&o.DMAADDRESS3.Reg)
}

// UDPHS.DMACONTROL3: UDPHS DMA Channel Control Register (channel = 3)
func (o *UDPHS_Type) SetDMACONTROL3_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMACONTROL3_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMACONTROL3_LDNXT_DSC(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMACONTROL3_LDNXT_DSC() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMACONTROL3_END_TR_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetDMACONTROL3_END_TR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetDMACONTROL3_END_B_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetDMACONTROL3_END_B_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetDMACONTROL3_END_TR_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMACONTROL3_END_TR_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMACONTROL3_END_BUFFIT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMACONTROL3_END_BUFFIT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMACONTROL3_DESC_LD_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMACONTROL3_DESC_LD_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMACONTROL3_BURST_LCK(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetDMACONTROL3_BURST_LCK() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetDMACONTROL3_BUFF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL3.Reg, volatile.LoadUint32(&o.DMACONTROL3.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMACONTROL3_BUFF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL3.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMASTATUS3: UDPHS DMA Channel Status Register (channel = 3)
func (o *UDPHS_Type) SetDMASTATUS3_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS3.Reg, volatile.LoadUint32(&o.DMASTATUS3.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMASTATUS3_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMASTATUS3.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMASTATUS3_CHANN_ACT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS3.Reg, volatile.LoadUint32(&o.DMASTATUS3.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMASTATUS3_CHANN_ACT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS3.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMASTATUS3_END_TR_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS3.Reg, volatile.LoadUint32(&o.DMASTATUS3.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMASTATUS3_END_TR_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS3.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMASTATUS3_END_BF_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS3.Reg, volatile.LoadUint32(&o.DMASTATUS3.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMASTATUS3_END_BF_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS3.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMASTATUS3_DESC_LDST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS3.Reg, volatile.LoadUint32(&o.DMASTATUS3.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMASTATUS3_DESC_LDST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS3.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMASTATUS3_BUFF_COUNT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS3.Reg, volatile.LoadUint32(&o.DMASTATUS3.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMASTATUS3_BUFF_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS3.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMANXTDSC4: UDPHS DMA Next Descriptor Address Register (channel = 4)
func (o *UDPHS_Type) SetDMANXTDSC4(value uint32) {
	volatile.StoreUint32(&o.DMANXTDSC4.Reg, value)
}
func (o *UDPHS_Type) GetDMANXTDSC4() uint32 {
	return volatile.LoadUint32(&o.DMANXTDSC4.Reg)
}

// UDPHS.DMAADDRESS4: UDPHS DMA Channel Address Register (channel = 4)
func (o *UDPHS_Type) SetDMAADDRESS4(value uint32) {
	volatile.StoreUint32(&o.DMAADDRESS4.Reg, value)
}
func (o *UDPHS_Type) GetDMAADDRESS4() uint32 {
	return volatile.LoadUint32(&o.DMAADDRESS4.Reg)
}

// UDPHS.DMACONTROL4: UDPHS DMA Channel Control Register (channel = 4)
func (o *UDPHS_Type) SetDMACONTROL4_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMACONTROL4_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMACONTROL4_LDNXT_DSC(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMACONTROL4_LDNXT_DSC() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMACONTROL4_END_TR_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetDMACONTROL4_END_TR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetDMACONTROL4_END_B_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetDMACONTROL4_END_B_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetDMACONTROL4_END_TR_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMACONTROL4_END_TR_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMACONTROL4_END_BUFFIT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMACONTROL4_END_BUFFIT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMACONTROL4_DESC_LD_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMACONTROL4_DESC_LD_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMACONTROL4_BURST_LCK(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetDMACONTROL4_BURST_LCK() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetDMACONTROL4_BUFF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL4.Reg, volatile.LoadUint32(&o.DMACONTROL4.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMACONTROL4_BUFF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL4.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMASTATUS4: UDPHS DMA Channel Status Register (channel = 4)
func (o *UDPHS_Type) SetDMASTATUS4_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS4.Reg, volatile.LoadUint32(&o.DMASTATUS4.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMASTATUS4_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMASTATUS4.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMASTATUS4_CHANN_ACT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS4.Reg, volatile.LoadUint32(&o.DMASTATUS4.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMASTATUS4_CHANN_ACT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS4.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMASTATUS4_END_TR_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS4.Reg, volatile.LoadUint32(&o.DMASTATUS4.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMASTATUS4_END_TR_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS4.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMASTATUS4_END_BF_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS4.Reg, volatile.LoadUint32(&o.DMASTATUS4.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMASTATUS4_END_BF_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS4.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMASTATUS4_DESC_LDST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS4.Reg, volatile.LoadUint32(&o.DMASTATUS4.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMASTATUS4_DESC_LDST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS4.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMASTATUS4_BUFF_COUNT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS4.Reg, volatile.LoadUint32(&o.DMASTATUS4.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMASTATUS4_BUFF_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS4.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMANXTDSC5: UDPHS DMA Next Descriptor Address Register (channel = 5)
func (o *UDPHS_Type) SetDMANXTDSC5(value uint32) {
	volatile.StoreUint32(&o.DMANXTDSC5.Reg, value)
}
func (o *UDPHS_Type) GetDMANXTDSC5() uint32 {
	return volatile.LoadUint32(&o.DMANXTDSC5.Reg)
}

// UDPHS.DMAADDRESS5: UDPHS DMA Channel Address Register (channel = 5)
func (o *UDPHS_Type) SetDMAADDRESS5(value uint32) {
	volatile.StoreUint32(&o.DMAADDRESS5.Reg, value)
}
func (o *UDPHS_Type) GetDMAADDRESS5() uint32 {
	return volatile.LoadUint32(&o.DMAADDRESS5.Reg)
}

// UDPHS.DMACONTROL5: UDPHS DMA Channel Control Register (channel = 5)
func (o *UDPHS_Type) SetDMACONTROL5_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMACONTROL5_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMACONTROL5_LDNXT_DSC(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMACONTROL5_LDNXT_DSC() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMACONTROL5_END_TR_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetDMACONTROL5_END_TR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetDMACONTROL5_END_B_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetDMACONTROL5_END_B_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetDMACONTROL5_END_TR_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMACONTROL5_END_TR_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMACONTROL5_END_BUFFIT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMACONTROL5_END_BUFFIT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMACONTROL5_DESC_LD_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMACONTROL5_DESC_LD_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMACONTROL5_BURST_LCK(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetDMACONTROL5_BURST_LCK() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetDMACONTROL5_BUFF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL5.Reg, volatile.LoadUint32(&o.DMACONTROL5.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMACONTROL5_BUFF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL5.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMASTATUS5: UDPHS DMA Channel Status Register (channel = 5)
func (o *UDPHS_Type) SetDMASTATUS5_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS5.Reg, volatile.LoadUint32(&o.DMASTATUS5.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMASTATUS5_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMASTATUS5.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMASTATUS5_CHANN_ACT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS5.Reg, volatile.LoadUint32(&o.DMASTATUS5.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMASTATUS5_CHANN_ACT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS5.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMASTATUS5_END_TR_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS5.Reg, volatile.LoadUint32(&o.DMASTATUS5.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMASTATUS5_END_TR_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS5.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMASTATUS5_END_BF_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS5.Reg, volatile.LoadUint32(&o.DMASTATUS5.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMASTATUS5_END_BF_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS5.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMASTATUS5_DESC_LDST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS5.Reg, volatile.LoadUint32(&o.DMASTATUS5.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMASTATUS5_DESC_LDST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS5.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMASTATUS5_BUFF_COUNT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS5.Reg, volatile.LoadUint32(&o.DMASTATUS5.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMASTATUS5_BUFF_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS5.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMANXTDSC6: UDPHS DMA Next Descriptor Address Register (channel = 6)
func (o *UDPHS_Type) SetDMANXTDSC6(value uint32) {
	volatile.StoreUint32(&o.DMANXTDSC6.Reg, value)
}
func (o *UDPHS_Type) GetDMANXTDSC6() uint32 {
	return volatile.LoadUint32(&o.DMANXTDSC6.Reg)
}

// UDPHS.DMAADDRESS6: UDPHS DMA Channel Address Register (channel = 6)
func (o *UDPHS_Type) SetDMAADDRESS6(value uint32) {
	volatile.StoreUint32(&o.DMAADDRESS6.Reg, value)
}
func (o *UDPHS_Type) GetDMAADDRESS6() uint32 {
	return volatile.LoadUint32(&o.DMAADDRESS6.Reg)
}

// UDPHS.DMACONTROL6: UDPHS DMA Channel Control Register (channel = 6)
func (o *UDPHS_Type) SetDMACONTROL6_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL6.Reg, volatile.LoadUint32(&o.DMACONTROL6.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMACONTROL6_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMACONTROL6.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMACONTROL6_LDNXT_DSC(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL6.Reg, volatile.LoadUint32(&o.DMACONTROL6.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMACONTROL6_LDNXT_DSC() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL6.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMACONTROL6_END_TR_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL6.Reg, volatile.LoadUint32(&o.DMACONTROL6.Reg)&^(0x4)|value<<2)
}
func (o *UDPHS_Type) GetDMACONTROL6_END_TR_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL6.Reg) & 0x4) >> 2
}
func (o *UDPHS_Type) SetDMACONTROL6_END_B_EN(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL6.Reg, volatile.LoadUint32(&o.DMACONTROL6.Reg)&^(0x8)|value<<3)
}
func (o *UDPHS_Type) GetDMACONTROL6_END_B_EN() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL6.Reg) & 0x8) >> 3
}
func (o *UDPHS_Type) SetDMACONTROL6_END_TR_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL6.Reg, volatile.LoadUint32(&o.DMACONTROL6.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMACONTROL6_END_TR_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL6.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMACONTROL6_END_BUFFIT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL6.Reg, volatile.LoadUint32(&o.DMACONTROL6.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMACONTROL6_END_BUFFIT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL6.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMACONTROL6_DESC_LD_IT(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL6.Reg, volatile.LoadUint32(&o.DMACONTROL6.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMACONTROL6_DESC_LD_IT() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL6.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMACONTROL6_BURST_LCK(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL6.Reg, volatile.LoadUint32(&o.DMACONTROL6.Reg)&^(0x80)|value<<7)
}
func (o *UDPHS_Type) GetDMACONTROL6_BURST_LCK() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL6.Reg) & 0x80) >> 7
}
func (o *UDPHS_Type) SetDMACONTROL6_BUFF_LENGTH(value uint32) {
	volatile.StoreUint32(&o.DMACONTROL6.Reg, volatile.LoadUint32(&o.DMACONTROL6.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMACONTROL6_BUFF_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.DMACONTROL6.Reg) & 0xffff0000) >> 16
}

// UDPHS.DMASTATUS6: UDPHS DMA Channel Status Register (channel = 6)
func (o *UDPHS_Type) SetDMASTATUS6_CHANN_ENB(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS6.Reg, volatile.LoadUint32(&o.DMASTATUS6.Reg)&^(0x1)|value)
}
func (o *UDPHS_Type) GetDMASTATUS6_CHANN_ENB() uint32 {
	return volatile.LoadUint32(&o.DMASTATUS6.Reg) & 0x1
}
func (o *UDPHS_Type) SetDMASTATUS6_CHANN_ACT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS6.Reg, volatile.LoadUint32(&o.DMASTATUS6.Reg)&^(0x2)|value<<1)
}
func (o *UDPHS_Type) GetDMASTATUS6_CHANN_ACT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS6.Reg) & 0x2) >> 1
}
func (o *UDPHS_Type) SetDMASTATUS6_END_TR_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS6.Reg, volatile.LoadUint32(&o.DMASTATUS6.Reg)&^(0x10)|value<<4)
}
func (o *UDPHS_Type) GetDMASTATUS6_END_TR_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS6.Reg) & 0x10) >> 4
}
func (o *UDPHS_Type) SetDMASTATUS6_END_BF_ST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS6.Reg, volatile.LoadUint32(&o.DMASTATUS6.Reg)&^(0x20)|value<<5)
}
func (o *UDPHS_Type) GetDMASTATUS6_END_BF_ST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS6.Reg) & 0x20) >> 5
}
func (o *UDPHS_Type) SetDMASTATUS6_DESC_LDST(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS6.Reg, volatile.LoadUint32(&o.DMASTATUS6.Reg)&^(0x40)|value<<6)
}
func (o *UDPHS_Type) GetDMASTATUS6_DESC_LDST() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS6.Reg) & 0x40) >> 6
}
func (o *UDPHS_Type) SetDMASTATUS6_BUFF_COUNT(value uint32) {
	volatile.StoreUint32(&o.DMASTATUS6.Reg, volatile.LoadUint32(&o.DMASTATUS6.Reg)&^(0xffff0000)|value<<16)
}
func (o *UDPHS_Type) GetDMASTATUS6_BUFF_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DMASTATUS6.Reg) & 0xffff0000) >> 16
}

// True Random Number Generator
type TRNG_Type struct {
	CR    volatile.Register32 // 0x0
	_     [12]byte
	IER   volatile.Register32 // 0x10
	IDR   volatile.Register32 // 0x14
	IMR   volatile.Register32 // 0x18
	ISR   volatile.Register32 // 0x1C
	_     [48]byte
	ODATA volatile.Register32 // 0x50
}

// TRNG.CR: Control Register
func (o *TRNG_Type) SetCR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetCR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *TRNG_Type) SetCR_KEY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xffffff00)|value<<8)
}
func (o *TRNG_Type) GetCR_KEY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xffffff00) >> 8
}

// TRNG.IER: Interrupt Enable Register
func (o *TRNG_Type) SetIER_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetIER_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// TRNG.IDR: Interrupt Disable Register
func (o *TRNG_Type) SetIDR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetIDR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}

// TRNG.IMR: Interrupt Mask Register
func (o *TRNG_Type) SetIMR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetIMR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}

// TRNG.ISR: Interrupt Status Register
func (o *TRNG_Type) SetISR_DATRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetISR_DATRDY() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// TRNG.ODATA: Output Data Register
func (o *TRNG_Type) SetODATA(value uint32) {
	volatile.StoreUint32(&o.ODATA.Reg, value)
}
func (o *TRNG_Type) GetODATA() uint32 {
	return volatile.LoadUint32(&o.ODATA.Reg)
}

// Fuse Controller
type FUSE_Type struct {
	CR volatile.Register32    // 0x0
	MR volatile.Register32    // 0x4
	IR volatile.Register32    // 0x8
	DR volatile.Register32    // 0xC
	SR [8]volatile.Register32 // 0x10
}

// FUSE.CR: Fuse Control Register
func (o *FUSE_Type) SetCR_WRQ(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *FUSE_Type) GetCR_WRQ() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *FUSE_Type) SetCR_RRQ(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *FUSE_Type) GetCR_RRQ() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *FUSE_Type) SetCR_KEY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xff00)|value<<8)
}
func (o *FUSE_Type) GetCR_KEY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xff00) >> 8
}

// FUSE.MR: Fuse Mode Register
func (o *FUSE_Type) SetMR_MSK(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1)|value)
}
func (o *FUSE_Type) GetMR_MSK() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x1
}

// FUSE.IR: Fuse Index Register
func (o *FUSE_Type) SetIR_WS(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x1)|value)
}
func (o *FUSE_Type) GetIR_WS() uint32 {
	return volatile.LoadUint32(&o.IR.Reg) & 0x1
}
func (o *FUSE_Type) SetIR_RS(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x2)|value<<1)
}
func (o *FUSE_Type) GetIR_RS() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x2) >> 1
}
func (o *FUSE_Type) SetIR_WSEL(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0xf00)|value<<8)
}
func (o *FUSE_Type) GetIR_WSEL() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0xf00) >> 8
}

// FUSE.DR: Fuse Data Register
func (o *FUSE_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, value)
}
func (o *FUSE_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg)
}

// FUSE.SR: Fuse Status Register
func (o *FUSE_Type) SetSR(idx int, value uint32) {
	volatile.StoreUint32(&o.SR[idx].Reg, value)
}
func (o *FUSE_Type) GetSR(idx int) uint32 {
	return volatile.LoadUint32(&o.SR[idx].Reg)
}

// DMA Controller 0
type DMAC_Type struct {
	GCFG   volatile.Register32 // 0x0
	EN     volatile.Register32 // 0x4
	SREQ   volatile.Register32 // 0x8
	CREQ   volatile.Register32 // 0xC
	LAST   volatile.Register32 // 0x10
	_      [4]byte
	EBCIER volatile.Register32 // 0x18
	EBCIDR volatile.Register32 // 0x1C
	EBCIMR volatile.Register32 // 0x20
	EBCISR volatile.Register32 // 0x24
	CHER   volatile.Register32 // 0x28
	CHDR   volatile.Register32 // 0x2C
	CHSR   volatile.Register32 // 0x30
	_      [8]byte
	SADDR0 volatile.Register32 // 0x3C
	DADDR0 volatile.Register32 // 0x40
	DSCR0  volatile.Register32 // 0x44
	CTRLA0 volatile.Register32 // 0x48
	CTRLB0 volatile.Register32 // 0x4C
	CFG0   volatile.Register32 // 0x50
	SPIP0  volatile.Register32 // 0x54
	DPIP0  volatile.Register32 // 0x58
	_      [8]byte
	SADDR1 volatile.Register32 // 0x64
	DADDR1 volatile.Register32 // 0x68
	DSCR1  volatile.Register32 // 0x6C
	CTRLA1 volatile.Register32 // 0x70
	CTRLB1 volatile.Register32 // 0x74
	CFG1   volatile.Register32 // 0x78
	SPIP1  volatile.Register32 // 0x7C
	DPIP1  volatile.Register32 // 0x80
	_      [8]byte
	SADDR2 volatile.Register32 // 0x8C
	DADDR2 volatile.Register32 // 0x90
	DSCR2  volatile.Register32 // 0x94
	CTRLA2 volatile.Register32 // 0x98
	CTRLB2 volatile.Register32 // 0x9C
	CFG2   volatile.Register32 // 0xA0
	SPIP2  volatile.Register32 // 0xA4
	DPIP2  volatile.Register32 // 0xA8
	_      [8]byte
	SADDR3 volatile.Register32 // 0xB4
	DADDR3 volatile.Register32 // 0xB8
	DSCR3  volatile.Register32 // 0xBC
	CTRLA3 volatile.Register32 // 0xC0
	CTRLB3 volatile.Register32 // 0xC4
	CFG3   volatile.Register32 // 0xC8
	SPIP3  volatile.Register32 // 0xCC
	DPIP3  volatile.Register32 // 0xD0
	_      [8]byte
	SADDR4 volatile.Register32 // 0xDC
	DADDR4 volatile.Register32 // 0xE0
	DSCR4  volatile.Register32 // 0xE4
	CTRLA4 volatile.Register32 // 0xE8
	CTRLB4 volatile.Register32 // 0xEC
	CFG4   volatile.Register32 // 0xF0
	SPIP4  volatile.Register32 // 0xF4
	DPIP4  volatile.Register32 // 0xF8
	_      [8]byte
	SADDR5 volatile.Register32 // 0x104
	DADDR5 volatile.Register32 // 0x108
	DSCR5  volatile.Register32 // 0x10C
	CTRLA5 volatile.Register32 // 0x110
	CTRLB5 volatile.Register32 // 0x114
	CFG5   volatile.Register32 // 0x118
	SPIP5  volatile.Register32 // 0x11C
	DPIP5  volatile.Register32 // 0x120
	_      [8]byte
	SADDR6 volatile.Register32 // 0x12C
	DADDR6 volatile.Register32 // 0x130
	DSCR6  volatile.Register32 // 0x134
	CTRLA6 volatile.Register32 // 0x138
	CTRLB6 volatile.Register32 // 0x13C
	CFG6   volatile.Register32 // 0x140
	SPIP6  volatile.Register32 // 0x144
	DPIP6  volatile.Register32 // 0x148
	_      [8]byte
	SADDR7 volatile.Register32 // 0x154
	DADDR7 volatile.Register32 // 0x158
	DSCR7  volatile.Register32 // 0x15C
	CTRLA7 volatile.Register32 // 0x160
	CTRLB7 volatile.Register32 // 0x164
	CFG7   volatile.Register32 // 0x168
	SPIP7  volatile.Register32 // 0x16C
	DPIP7  volatile.Register32 // 0x170
	_      [112]byte
	WPMR   volatile.Register32 // 0x1E4
	WPSR   volatile.Register32 // 0x1E8
}

// DMAC.GCFG: DMAC Global Configuration Register
func (o *DMAC_Type) SetGCFG_ARB_CFG(value uint32) {
	volatile.StoreUint32(&o.GCFG.Reg, volatile.LoadUint32(&o.GCFG.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetGCFG_ARB_CFG() uint32 {
	return (volatile.LoadUint32(&o.GCFG.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetGCFG_DICEN(value uint32) {
	volatile.StoreUint32(&o.GCFG.Reg, volatile.LoadUint32(&o.GCFG.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetGCFG_DICEN() uint32 {
	return (volatile.LoadUint32(&o.GCFG.Reg) & 0x100) >> 8
}

// DMAC.EN: DMAC Enable Register
func (o *DMAC_Type) SetEN_ENABLE(value uint32) {
	volatile.StoreUint32(&o.EN.Reg, volatile.LoadUint32(&o.EN.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetEN_ENABLE() uint32 {
	return volatile.LoadUint32(&o.EN.Reg) & 0x1
}

// DMAC.SREQ: DMAC Software Single Request Register
func (o *DMAC_Type) SetSREQ_SSREQ0(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetSREQ_SSREQ0() uint32 {
	return volatile.LoadUint32(&o.SREQ.Reg) & 0x1
}
func (o *DMAC_Type) SetSREQ_DSREQ0(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetSREQ_DSREQ0() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetSREQ_SSREQ1(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetSREQ_SSREQ1() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetSREQ_DSREQ1(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetSREQ_DSREQ1() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetSREQ_SSREQ2(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetSREQ_SSREQ2() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetSREQ_DSREQ2(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetSREQ_DSREQ2() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetSREQ_SSREQ3(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetSREQ_SSREQ3() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetSREQ_DSREQ3(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetSREQ_DSREQ3() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetSREQ_SSREQ4(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetSREQ_SSREQ4() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetSREQ_DSREQ4(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetSREQ_DSREQ4() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetSREQ_SSREQ5(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetSREQ_SSREQ5() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetSREQ_DSREQ5(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetSREQ_DSREQ5() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetSREQ_SSREQ6(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetSREQ_SSREQ6() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetSREQ_DSREQ6(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetSREQ_DSREQ6() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetSREQ_SSREQ7(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetSREQ_SSREQ7() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetSREQ_DSREQ7(value uint32) {
	volatile.StoreUint32(&o.SREQ.Reg, volatile.LoadUint32(&o.SREQ.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetSREQ_DSREQ7() uint32 {
	return (volatile.LoadUint32(&o.SREQ.Reg) & 0x8000) >> 15
}

// DMAC.CREQ: DMAC Software Chunk Transfer Request Register
func (o *DMAC_Type) SetCREQ_SCREQ0(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetCREQ_SCREQ0() uint32 {
	return volatile.LoadUint32(&o.CREQ.Reg) & 0x1
}
func (o *DMAC_Type) SetCREQ_DCREQ0(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetCREQ_DCREQ0() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetCREQ_SCREQ1(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetCREQ_SCREQ1() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetCREQ_DCREQ1(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetCREQ_DCREQ1() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetCREQ_SCREQ2(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetCREQ_SCREQ2() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetCREQ_DCREQ2(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetCREQ_DCREQ2() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetCREQ_SCREQ3(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetCREQ_SCREQ3() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetCREQ_DCREQ3(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetCREQ_DCREQ3() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetCREQ_SCREQ4(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCREQ_SCREQ4() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCREQ_DCREQ4(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCREQ_DCREQ4() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCREQ_SCREQ5(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetCREQ_SCREQ5() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetCREQ_DCREQ5(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetCREQ_DCREQ5() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetCREQ_SCREQ6(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCREQ_SCREQ6() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCREQ_DCREQ6(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCREQ_DCREQ6() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCREQ_SCREQ7(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetCREQ_SCREQ7() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetCREQ_DCREQ7(value uint32) {
	volatile.StoreUint32(&o.CREQ.Reg, volatile.LoadUint32(&o.CREQ.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetCREQ_DCREQ7() uint32 {
	return (volatile.LoadUint32(&o.CREQ.Reg) & 0x8000) >> 15
}

// DMAC.LAST: DMAC Software Last Transfer Flag Register
func (o *DMAC_Type) SetLAST_SLAST0(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetLAST_SLAST0() uint32 {
	return volatile.LoadUint32(&o.LAST.Reg) & 0x1
}
func (o *DMAC_Type) SetLAST_DLAST0(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetLAST_DLAST0() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetLAST_SLAST1(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetLAST_SLAST1() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetLAST_DLAST1(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetLAST_DLAST1() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetLAST_SLAST2(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetLAST_SLAST2() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetLAST_DLAST2(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetLAST_DLAST2() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetLAST_SLAST3(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetLAST_SLAST3() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetLAST_DLAST3(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetLAST_DLAST3() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetLAST_SLAST4(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetLAST_SLAST4() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetLAST_DLAST4(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetLAST_DLAST4() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetLAST_SLAST5(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetLAST_SLAST5() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetLAST_DLAST5(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetLAST_DLAST5() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetLAST_SLAST6(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetLAST_SLAST6() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetLAST_DLAST6(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetLAST_DLAST6() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetLAST_SLAST7(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetLAST_SLAST7() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetLAST_DLAST7(value uint32) {
	volatile.StoreUint32(&o.LAST.Reg, volatile.LoadUint32(&o.LAST.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetLAST_DLAST7() uint32 {
	return (volatile.LoadUint32(&o.LAST.Reg) & 0x8000) >> 15
}

// DMAC.EBCIER: DMAC Error, Chained Buffer Transfer Completed Interrupt and Buffer Transfer Completed Interrupt Enable register.
func (o *DMAC_Type) SetEBCIER_BTC0(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetEBCIER_BTC0() uint32 {
	return volatile.LoadUint32(&o.EBCIER.Reg) & 0x1
}
func (o *DMAC_Type) SetEBCIER_BTC1(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetEBCIER_BTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetEBCIER_BTC2(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetEBCIER_BTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetEBCIER_BTC3(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetEBCIER_BTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetEBCIER_BTC4(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetEBCIER_BTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetEBCIER_BTC5(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetEBCIER_BTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetEBCIER_BTC6(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetEBCIER_BTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetEBCIER_BTC7(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetEBCIER_BTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetEBCIER_CBTC0(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetEBCIER_CBTC0() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetEBCIER_CBTC1(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetEBCIER_CBTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetEBCIER_CBTC2(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetEBCIER_CBTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetEBCIER_CBTC3(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetEBCIER_CBTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetEBCIER_CBTC4(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetEBCIER_CBTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetEBCIER_CBTC5(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetEBCIER_CBTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetEBCIER_CBTC6(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetEBCIER_CBTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetEBCIER_CBTC7(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetEBCIER_CBTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetEBCIER_ERR0(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetEBCIER_ERR0() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetEBCIER_ERR1(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x20000)|value<<17)
}
func (o *DMAC_Type) GetEBCIER_ERR1() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x20000) >> 17
}
func (o *DMAC_Type) SetEBCIER_ERR2(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x40000)|value<<18)
}
func (o *DMAC_Type) GetEBCIER_ERR2() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x40000) >> 18
}
func (o *DMAC_Type) SetEBCIER_ERR3(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x80000)|value<<19)
}
func (o *DMAC_Type) GetEBCIER_ERR3() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x80000) >> 19
}
func (o *DMAC_Type) SetEBCIER_ERR4(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetEBCIER_ERR4() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetEBCIER_ERR5(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetEBCIER_ERR5() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetEBCIER_ERR6(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetEBCIER_ERR6() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetEBCIER_ERR7(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x800000)|value<<23)
}
func (o *DMAC_Type) GetEBCIER_ERR7() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x800000) >> 23
}
func (o *DMAC_Type) SetEBCIER_DICERR0(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x1000000)|value<<24)
}
func (o *DMAC_Type) GetEBCIER_DICERR0() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x1000000) >> 24
}
func (o *DMAC_Type) SetEBCIER_DICERR1(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x2000000)|value<<25)
}
func (o *DMAC_Type) GetEBCIER_DICERR1() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x2000000) >> 25
}
func (o *DMAC_Type) SetEBCIER_DICERR2(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x4000000)|value<<26)
}
func (o *DMAC_Type) GetEBCIER_DICERR2() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x4000000) >> 26
}
func (o *DMAC_Type) SetEBCIER_DICERR3(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x8000000)|value<<27)
}
func (o *DMAC_Type) GetEBCIER_DICERR3() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x8000000) >> 27
}
func (o *DMAC_Type) SetEBCIER_DICERR4(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x10000000)|value<<28)
}
func (o *DMAC_Type) GetEBCIER_DICERR4() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x10000000) >> 28
}
func (o *DMAC_Type) SetEBCIER_DICERR5(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x20000000)|value<<29)
}
func (o *DMAC_Type) GetEBCIER_DICERR5() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x20000000) >> 29
}
func (o *DMAC_Type) SetEBCIER_DICERR6(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetEBCIER_DICERR6() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetEBCIER_DICERR7(value uint32) {
	volatile.StoreUint32(&o.EBCIER.Reg, volatile.LoadUint32(&o.EBCIER.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetEBCIER_DICERR7() uint32 {
	return (volatile.LoadUint32(&o.EBCIER.Reg) & 0x80000000) >> 31
}

// DMAC.EBCIDR: DMAC Error, Chained Buffer Transfer Completed Interrupt and Buffer Transfer Completed Interrupt Disable register.
func (o *DMAC_Type) SetEBCIDR_BTC0(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetEBCIDR_BTC0() uint32 {
	return volatile.LoadUint32(&o.EBCIDR.Reg) & 0x1
}
func (o *DMAC_Type) SetEBCIDR_BTC1(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetEBCIDR_BTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetEBCIDR_BTC2(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetEBCIDR_BTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetEBCIDR_BTC3(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetEBCIDR_BTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetEBCIDR_BTC4(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetEBCIDR_BTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetEBCIDR_BTC5(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetEBCIDR_BTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetEBCIDR_BTC6(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetEBCIDR_BTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetEBCIDR_BTC7(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetEBCIDR_BTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetEBCIDR_CBTC0(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetEBCIDR_CBTC0() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetEBCIDR_CBTC1(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetEBCIDR_CBTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetEBCIDR_CBTC2(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetEBCIDR_CBTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetEBCIDR_CBTC3(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetEBCIDR_CBTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetEBCIDR_CBTC4(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetEBCIDR_CBTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetEBCIDR_CBTC5(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetEBCIDR_CBTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetEBCIDR_CBTC6(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetEBCIDR_CBTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetEBCIDR_CBTC7(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetEBCIDR_CBTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetEBCIDR_ERR0(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetEBCIDR_ERR0() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetEBCIDR_ERR1(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x20000)|value<<17)
}
func (o *DMAC_Type) GetEBCIDR_ERR1() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x20000) >> 17
}
func (o *DMAC_Type) SetEBCIDR_ERR2(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x40000)|value<<18)
}
func (o *DMAC_Type) GetEBCIDR_ERR2() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x40000) >> 18
}
func (o *DMAC_Type) SetEBCIDR_ERR3(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x80000)|value<<19)
}
func (o *DMAC_Type) GetEBCIDR_ERR3() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x80000) >> 19
}
func (o *DMAC_Type) SetEBCIDR_ERR4(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetEBCIDR_ERR4() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetEBCIDR_ERR5(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetEBCIDR_ERR5() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetEBCIDR_ERR6(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetEBCIDR_ERR6() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetEBCIDR_ERR7(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x800000)|value<<23)
}
func (o *DMAC_Type) GetEBCIDR_ERR7() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x800000) >> 23
}
func (o *DMAC_Type) SetEBCIDR_DICERR0(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMAC_Type) GetEBCIDR_DICERR0() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x1000000) >> 24
}
func (o *DMAC_Type) SetEBCIDR_DICERR1(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMAC_Type) GetEBCIDR_DICERR1() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x2000000) >> 25
}
func (o *DMAC_Type) SetEBCIDR_DICERR2(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMAC_Type) GetEBCIDR_DICERR2() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x4000000) >> 26
}
func (o *DMAC_Type) SetEBCIDR_DICERR3(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMAC_Type) GetEBCIDR_DICERR3() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x8000000) >> 27
}
func (o *DMAC_Type) SetEBCIDR_DICERR4(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x10000000)|value<<28)
}
func (o *DMAC_Type) GetEBCIDR_DICERR4() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x10000000) >> 28
}
func (o *DMAC_Type) SetEBCIDR_DICERR5(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x20000000)|value<<29)
}
func (o *DMAC_Type) GetEBCIDR_DICERR5() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x20000000) >> 29
}
func (o *DMAC_Type) SetEBCIDR_DICERR6(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetEBCIDR_DICERR6() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetEBCIDR_DICERR7(value uint32) {
	volatile.StoreUint32(&o.EBCIDR.Reg, volatile.LoadUint32(&o.EBCIDR.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetEBCIDR_DICERR7() uint32 {
	return (volatile.LoadUint32(&o.EBCIDR.Reg) & 0x80000000) >> 31
}

// DMAC.EBCIMR: DMAC Error, Chained Buffer Transfer Completed Interrupt and Buffer transfer completed Mask Register.
func (o *DMAC_Type) SetEBCIMR_BTC0(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetEBCIMR_BTC0() uint32 {
	return volatile.LoadUint32(&o.EBCIMR.Reg) & 0x1
}
func (o *DMAC_Type) SetEBCIMR_BTC1(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetEBCIMR_BTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetEBCIMR_BTC2(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetEBCIMR_BTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetEBCIMR_BTC3(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetEBCIMR_BTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetEBCIMR_BTC4(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetEBCIMR_BTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetEBCIMR_BTC5(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetEBCIMR_BTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetEBCIMR_BTC6(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetEBCIMR_BTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetEBCIMR_BTC7(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetEBCIMR_BTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetEBCIMR_CBTC0(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetEBCIMR_CBTC0() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetEBCIMR_CBTC1(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetEBCIMR_CBTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetEBCIMR_CBTC2(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetEBCIMR_CBTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetEBCIMR_CBTC3(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetEBCIMR_CBTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetEBCIMR_CBTC4(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetEBCIMR_CBTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetEBCIMR_CBTC5(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetEBCIMR_CBTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetEBCIMR_CBTC6(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetEBCIMR_CBTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetEBCIMR_CBTC7(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetEBCIMR_CBTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetEBCIMR_ERR0(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetEBCIMR_ERR0() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetEBCIMR_ERR1(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x20000)|value<<17)
}
func (o *DMAC_Type) GetEBCIMR_ERR1() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x20000) >> 17
}
func (o *DMAC_Type) SetEBCIMR_ERR2(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x40000)|value<<18)
}
func (o *DMAC_Type) GetEBCIMR_ERR2() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x40000) >> 18
}
func (o *DMAC_Type) SetEBCIMR_ERR3(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x80000)|value<<19)
}
func (o *DMAC_Type) GetEBCIMR_ERR3() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x80000) >> 19
}
func (o *DMAC_Type) SetEBCIMR_ERR4(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetEBCIMR_ERR4() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetEBCIMR_ERR5(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetEBCIMR_ERR5() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetEBCIMR_ERR6(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetEBCIMR_ERR6() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetEBCIMR_ERR7(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x800000)|value<<23)
}
func (o *DMAC_Type) GetEBCIMR_ERR7() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x800000) >> 23
}
func (o *DMAC_Type) SetEBCIMR_DICERR0(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMAC_Type) GetEBCIMR_DICERR0() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x1000000) >> 24
}
func (o *DMAC_Type) SetEBCIMR_DICERR1(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMAC_Type) GetEBCIMR_DICERR1() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x2000000) >> 25
}
func (o *DMAC_Type) SetEBCIMR_DICERR2(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMAC_Type) GetEBCIMR_DICERR2() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x4000000) >> 26
}
func (o *DMAC_Type) SetEBCIMR_DICERR3(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMAC_Type) GetEBCIMR_DICERR3() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x8000000) >> 27
}
func (o *DMAC_Type) SetEBCIMR_DICERR4(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x10000000)|value<<28)
}
func (o *DMAC_Type) GetEBCIMR_DICERR4() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x10000000) >> 28
}
func (o *DMAC_Type) SetEBCIMR_DICERR5(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x20000000)|value<<29)
}
func (o *DMAC_Type) GetEBCIMR_DICERR5() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x20000000) >> 29
}
func (o *DMAC_Type) SetEBCIMR_DICERR6(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetEBCIMR_DICERR6() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetEBCIMR_DICERR7(value uint32) {
	volatile.StoreUint32(&o.EBCIMR.Reg, volatile.LoadUint32(&o.EBCIMR.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetEBCIMR_DICERR7() uint32 {
	return (volatile.LoadUint32(&o.EBCIMR.Reg) & 0x80000000) >> 31
}

// DMAC.EBCISR: DMAC Error, Chained Buffer Transfer Completed Interrupt and Buffer transfer completed Status Register.
func (o *DMAC_Type) SetEBCISR_BTC0(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetEBCISR_BTC0() uint32 {
	return volatile.LoadUint32(&o.EBCISR.Reg) & 0x1
}
func (o *DMAC_Type) SetEBCISR_BTC1(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetEBCISR_BTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetEBCISR_BTC2(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetEBCISR_BTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetEBCISR_BTC3(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetEBCISR_BTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetEBCISR_BTC4(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetEBCISR_BTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetEBCISR_BTC5(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetEBCISR_BTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetEBCISR_BTC6(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetEBCISR_BTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetEBCISR_BTC7(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetEBCISR_BTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetEBCISR_CBTC0(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetEBCISR_CBTC0() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetEBCISR_CBTC1(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetEBCISR_CBTC1() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetEBCISR_CBTC2(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetEBCISR_CBTC2() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetEBCISR_CBTC3(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetEBCISR_CBTC3() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetEBCISR_CBTC4(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetEBCISR_CBTC4() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetEBCISR_CBTC5(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetEBCISR_CBTC5() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetEBCISR_CBTC6(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetEBCISR_CBTC6() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetEBCISR_CBTC7(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetEBCISR_CBTC7() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetEBCISR_ERR0(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetEBCISR_ERR0() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetEBCISR_ERR1(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x20000)|value<<17)
}
func (o *DMAC_Type) GetEBCISR_ERR1() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x20000) >> 17
}
func (o *DMAC_Type) SetEBCISR_ERR2(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x40000)|value<<18)
}
func (o *DMAC_Type) GetEBCISR_ERR2() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x40000) >> 18
}
func (o *DMAC_Type) SetEBCISR_ERR3(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x80000)|value<<19)
}
func (o *DMAC_Type) GetEBCISR_ERR3() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x80000) >> 19
}
func (o *DMAC_Type) SetEBCISR_ERR4(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetEBCISR_ERR4() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetEBCISR_ERR5(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetEBCISR_ERR5() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetEBCISR_ERR6(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetEBCISR_ERR6() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetEBCISR_ERR7(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x800000)|value<<23)
}
func (o *DMAC_Type) GetEBCISR_ERR7() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x800000) >> 23
}
func (o *DMAC_Type) SetEBCISR_DICERR0(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMAC_Type) GetEBCISR_DICERR0() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x1000000) >> 24
}
func (o *DMAC_Type) SetEBCISR_DICERR1(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMAC_Type) GetEBCISR_DICERR1() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x2000000) >> 25
}
func (o *DMAC_Type) SetEBCISR_DICERR2(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMAC_Type) GetEBCISR_DICERR2() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x4000000) >> 26
}
func (o *DMAC_Type) SetEBCISR_DICERR3(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMAC_Type) GetEBCISR_DICERR3() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x8000000) >> 27
}
func (o *DMAC_Type) SetEBCISR_DICERR4(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x10000000)|value<<28)
}
func (o *DMAC_Type) GetEBCISR_DICERR4() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x10000000) >> 28
}
func (o *DMAC_Type) SetEBCISR_DICERR5(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x20000000)|value<<29)
}
func (o *DMAC_Type) GetEBCISR_DICERR5() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x20000000) >> 29
}
func (o *DMAC_Type) SetEBCISR_DICERR6(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetEBCISR_DICERR6() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetEBCISR_DICERR7(value uint32) {
	volatile.StoreUint32(&o.EBCISR.Reg, volatile.LoadUint32(&o.EBCISR.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetEBCISR_DICERR7() uint32 {
	return (volatile.LoadUint32(&o.EBCISR.Reg) & 0x80000000) >> 31
}

// DMAC.CHER: DMAC Channel Handler Enable Register
func (o *DMAC_Type) SetCHER_ENA0(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetCHER_ENA0() uint32 {
	return volatile.LoadUint32(&o.CHER.Reg) & 0x1
}
func (o *DMAC_Type) SetCHER_ENA1(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetCHER_ENA1() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetCHER_ENA2(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetCHER_ENA2() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetCHER_ENA3(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetCHER_ENA3() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetCHER_ENA4(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetCHER_ENA4() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetCHER_ENA5(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetCHER_ENA5() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetCHER_ENA6(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetCHER_ENA6() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetCHER_ENA7(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetCHER_ENA7() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetCHER_SUSP0(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCHER_SUSP0() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCHER_SUSP1(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCHER_SUSP1() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCHER_SUSP2(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetCHER_SUSP2() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetCHER_SUSP3(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetCHER_SUSP3() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetCHER_SUSP4(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCHER_SUSP4() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCHER_SUSP5(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCHER_SUSP5() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCHER_SUSP6(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetCHER_SUSP6() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetCHER_SUSP7(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetCHER_SUSP7() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetCHER_KEEP0(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x1000000)|value<<24)
}
func (o *DMAC_Type) GetCHER_KEEP0() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x1000000) >> 24
}
func (o *DMAC_Type) SetCHER_KEEP1(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x2000000)|value<<25)
}
func (o *DMAC_Type) GetCHER_KEEP1() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x2000000) >> 25
}
func (o *DMAC_Type) SetCHER_KEEP2(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x4000000)|value<<26)
}
func (o *DMAC_Type) GetCHER_KEEP2() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x4000000) >> 26
}
func (o *DMAC_Type) SetCHER_KEEP3(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x8000000)|value<<27)
}
func (o *DMAC_Type) GetCHER_KEEP3() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x8000000) >> 27
}
func (o *DMAC_Type) SetCHER_KEEP4(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x10000000)|value<<28)
}
func (o *DMAC_Type) GetCHER_KEEP4() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x10000000) >> 28
}
func (o *DMAC_Type) SetCHER_KEEP5(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x20000000)|value<<29)
}
func (o *DMAC_Type) GetCHER_KEEP5() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x20000000) >> 29
}
func (o *DMAC_Type) SetCHER_KEEP6(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCHER_KEEP6() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCHER_KEEP7(value uint32) {
	volatile.StoreUint32(&o.CHER.Reg, volatile.LoadUint32(&o.CHER.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCHER_KEEP7() uint32 {
	return (volatile.LoadUint32(&o.CHER.Reg) & 0x80000000) >> 31
}

// DMAC.CHDR: DMAC Channel Handler Disable Register
func (o *DMAC_Type) SetCHDR_DIS0(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetCHDR_DIS0() uint32 {
	return volatile.LoadUint32(&o.CHDR.Reg) & 0x1
}
func (o *DMAC_Type) SetCHDR_DIS1(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetCHDR_DIS1() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetCHDR_DIS2(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetCHDR_DIS2() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetCHDR_DIS3(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetCHDR_DIS3() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetCHDR_DIS4(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetCHDR_DIS4() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetCHDR_DIS5(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetCHDR_DIS5() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetCHDR_DIS6(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetCHDR_DIS6() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetCHDR_DIS7(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetCHDR_DIS7() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetCHDR_RES0(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCHDR_RES0() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCHDR_RES1(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCHDR_RES1() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCHDR_RES2(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetCHDR_RES2() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetCHDR_RES3(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetCHDR_RES3() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetCHDR_RES4(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCHDR_RES4() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCHDR_RES5(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCHDR_RES5() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCHDR_RES6(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetCHDR_RES6() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetCHDR_RES7(value uint32) {
	volatile.StoreUint32(&o.CHDR.Reg, volatile.LoadUint32(&o.CHDR.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetCHDR_RES7() uint32 {
	return (volatile.LoadUint32(&o.CHDR.Reg) & 0x8000) >> 15
}

// DMAC.CHSR: DMAC Channel Handler Status Register
func (o *DMAC_Type) SetCHSR_ENA0(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetCHSR_ENA0() uint32 {
	return volatile.LoadUint32(&o.CHSR.Reg) & 0x1
}
func (o *DMAC_Type) SetCHSR_ENA1(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetCHSR_ENA1() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetCHSR_ENA2(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetCHSR_ENA2() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetCHSR_ENA3(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetCHSR_ENA3() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetCHSR_ENA4(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetCHSR_ENA4() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetCHSR_ENA5(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetCHSR_ENA5() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetCHSR_ENA6(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetCHSR_ENA6() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetCHSR_ENA7(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetCHSR_ENA7() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetCHSR_SUSP0(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCHSR_SUSP0() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCHSR_SUSP1(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCHSR_SUSP1() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCHSR_SUSP2(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetCHSR_SUSP2() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetCHSR_SUSP3(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetCHSR_SUSP3() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetCHSR_SUSP4(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCHSR_SUSP4() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCHSR_SUSP5(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCHSR_SUSP5() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCHSR_SUSP6(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetCHSR_SUSP6() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetCHSR_SUSP7(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetCHSR_SUSP7() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetCHSR_EMPT0(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCHSR_EMPT0() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCHSR_EMPT1(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x20000)|value<<17)
}
func (o *DMAC_Type) GetCHSR_EMPT1() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x20000) >> 17
}
func (o *DMAC_Type) SetCHSR_EMPT2(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x40000)|value<<18)
}
func (o *DMAC_Type) GetCHSR_EMPT2() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x40000) >> 18
}
func (o *DMAC_Type) SetCHSR_EMPT3(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x80000)|value<<19)
}
func (o *DMAC_Type) GetCHSR_EMPT3() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x80000) >> 19
}
func (o *DMAC_Type) SetCHSR_EMPT4(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCHSR_EMPT4() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCHSR_EMPT5(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCHSR_EMPT5() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCHSR_EMPT6(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCHSR_EMPT6() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCHSR_EMPT7(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x800000)|value<<23)
}
func (o *DMAC_Type) GetCHSR_EMPT7() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x800000) >> 23
}
func (o *DMAC_Type) SetCHSR_STAL0(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMAC_Type) GetCHSR_STAL0() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x1000000) >> 24
}
func (o *DMAC_Type) SetCHSR_STAL1(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMAC_Type) GetCHSR_STAL1() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x2000000) >> 25
}
func (o *DMAC_Type) SetCHSR_STAL2(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMAC_Type) GetCHSR_STAL2() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x4000000) >> 26
}
func (o *DMAC_Type) SetCHSR_STAL3(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMAC_Type) GetCHSR_STAL3() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x8000000) >> 27
}
func (o *DMAC_Type) SetCHSR_STAL4(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x10000000)|value<<28)
}
func (o *DMAC_Type) GetCHSR_STAL4() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x10000000) >> 28
}
func (o *DMAC_Type) SetCHSR_STAL5(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x20000000)|value<<29)
}
func (o *DMAC_Type) GetCHSR_STAL5() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x20000000) >> 29
}
func (o *DMAC_Type) SetCHSR_STAL6(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCHSR_STAL6() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCHSR_STAL7(value uint32) {
	volatile.StoreUint32(&o.CHSR.Reg, volatile.LoadUint32(&o.CHSR.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCHSR_STAL7() uint32 {
	return (volatile.LoadUint32(&o.CHSR.Reg) & 0x80000000) >> 31
}

// DMAC.SADDR0: DMAC Channel Source Address Register (ch_num = 0)
func (o *DMAC_Type) SetSADDR0(value uint32) {
	volatile.StoreUint32(&o.SADDR0.Reg, value)
}
func (o *DMAC_Type) GetSADDR0() uint32 {
	return volatile.LoadUint32(&o.SADDR0.Reg)
}

// DMAC.DADDR0: DMAC Channel Destination Address Register (ch_num = 0)
func (o *DMAC_Type) SetDADDR0(value uint32) {
	volatile.StoreUint32(&o.DADDR0.Reg, value)
}
func (o *DMAC_Type) GetDADDR0() uint32 {
	return volatile.LoadUint32(&o.DADDR0.Reg)
}

// DMAC.DSCR0: DMAC Channel Descriptor Address Register (ch_num = 0)
func (o *DMAC_Type) SetDSCR0_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR0.Reg, volatile.LoadUint32(&o.DSCR0.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR0_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR0.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR0_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR0.Reg, volatile.LoadUint32(&o.DSCR0.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR0_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR0.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA0: DMAC Channel Control A Register (ch_num = 0)
func (o *DMAC_Type) SetCTRLA0_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA0.Reg, volatile.LoadUint32(&o.CTRLA0.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA0_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA0.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA0_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA0.Reg, volatile.LoadUint32(&o.CTRLA0.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA0_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA0.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA0_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA0.Reg, volatile.LoadUint32(&o.CTRLA0.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA0_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA0.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA0_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA0.Reg, volatile.LoadUint32(&o.CTRLA0.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA0_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA0.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA0_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA0.Reg, volatile.LoadUint32(&o.CTRLA0.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA0_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA0.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA0_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA0.Reg, volatile.LoadUint32(&o.CTRLA0.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA0_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA0.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB0: DMAC Channel Control B Register (ch_num = 0)
func (o *DMAC_Type) SetCTRLB0_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB0_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB0.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB0_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB0_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB0_SRC_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCTRLB0_SRC_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCTRLB0_DST_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCTRLB0_DST_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCTRLB0_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB0_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB0_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB0_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB0_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x600000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB0_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x600000) >> 21
}
func (o *DMAC_Type) SetCTRLB0_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB0_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB0_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB0_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB0_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB0_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB0_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB0.Reg, volatile.LoadUint32(&o.CTRLB0.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB0_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB0.Reg) & 0x80000000) >> 31
}

// DMAC.CFG0: DMAC Channel Configuration Register (ch_num = 0)
func (o *DMAC_Type) SetCFG0_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG0_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG0.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG0_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG0_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG0_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG0_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG0_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG0_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG0_SRC_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0xc00)|value<<10)
}
func (o *DMAC_Type) GetCFG0_SRC_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0xc00) >> 10
}
func (o *DMAC_Type) SetCFG0_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG0_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG0_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG0_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG0_DST_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC_Type) GetCFG0_DST_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0xc000) >> 14
}
func (o *DMAC_Type) SetCFG0_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG0_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG0_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG0_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG0_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG0_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG0_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG0_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG0_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG0_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG0_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG0.Reg, volatile.LoadUint32(&o.CFG0.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG0_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG0.Reg) & 0x30000000) >> 28
}

// DMAC.SPIP0: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 0)
func (o *DMAC_Type) SetSPIP0_SPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.SPIP0.Reg, volatile.LoadUint32(&o.SPIP0.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetSPIP0_SPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.SPIP0.Reg) & 0xffff
}
func (o *DMAC_Type) SetSPIP0_SPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.SPIP0.Reg, volatile.LoadUint32(&o.SPIP0.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetSPIP0_SPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.SPIP0.Reg) & 0x3ff0000) >> 16
}

// DMAC.DPIP0: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 0)
func (o *DMAC_Type) SetDPIP0_DPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.DPIP0.Reg, volatile.LoadUint32(&o.DPIP0.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetDPIP0_DPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.DPIP0.Reg) & 0xffff
}
func (o *DMAC_Type) SetDPIP0_DPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.DPIP0.Reg, volatile.LoadUint32(&o.DPIP0.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetDPIP0_DPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.DPIP0.Reg) & 0x3ff0000) >> 16
}

// DMAC.SADDR1: DMAC Channel Source Address Register (ch_num = 1)
func (o *DMAC_Type) SetSADDR1(value uint32) {
	volatile.StoreUint32(&o.SADDR1.Reg, value)
}
func (o *DMAC_Type) GetSADDR1() uint32 {
	return volatile.LoadUint32(&o.SADDR1.Reg)
}

// DMAC.DADDR1: DMAC Channel Destination Address Register (ch_num = 1)
func (o *DMAC_Type) SetDADDR1(value uint32) {
	volatile.StoreUint32(&o.DADDR1.Reg, value)
}
func (o *DMAC_Type) GetDADDR1() uint32 {
	return volatile.LoadUint32(&o.DADDR1.Reg)
}

// DMAC.DSCR1: DMAC Channel Descriptor Address Register (ch_num = 1)
func (o *DMAC_Type) SetDSCR1_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR1.Reg, volatile.LoadUint32(&o.DSCR1.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR1_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR1.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR1_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR1.Reg, volatile.LoadUint32(&o.DSCR1.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR1_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR1.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA1: DMAC Channel Control A Register (ch_num = 1)
func (o *DMAC_Type) SetCTRLA1_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA1.Reg, volatile.LoadUint32(&o.CTRLA1.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA1_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA1.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA1_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA1.Reg, volatile.LoadUint32(&o.CTRLA1.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA1_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA1.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA1_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA1.Reg, volatile.LoadUint32(&o.CTRLA1.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA1_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA1.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA1_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA1.Reg, volatile.LoadUint32(&o.CTRLA1.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA1_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA1.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA1_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA1.Reg, volatile.LoadUint32(&o.CTRLA1.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA1_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA1.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA1_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA1.Reg, volatile.LoadUint32(&o.CTRLA1.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA1_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA1.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB1: DMAC Channel Control B Register (ch_num = 1)
func (o *DMAC_Type) SetCTRLB1_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB1_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB1.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB1_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB1_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB1_SRC_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCTRLB1_SRC_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCTRLB1_DST_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCTRLB1_DST_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCTRLB1_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB1_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB1_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB1_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB1_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x600000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB1_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x600000) >> 21
}
func (o *DMAC_Type) SetCTRLB1_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB1_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB1_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB1_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB1_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB1_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB1_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB1.Reg, volatile.LoadUint32(&o.CTRLB1.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB1_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB1.Reg) & 0x80000000) >> 31
}

// DMAC.CFG1: DMAC Channel Configuration Register (ch_num = 1)
func (o *DMAC_Type) SetCFG1_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG1_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG1.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG1_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG1_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG1_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG1_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG1_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG1_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG1_SRC_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0xc00)|value<<10)
}
func (o *DMAC_Type) GetCFG1_SRC_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0xc00) >> 10
}
func (o *DMAC_Type) SetCFG1_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG1_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG1_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG1_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG1_DST_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC_Type) GetCFG1_DST_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0xc000) >> 14
}
func (o *DMAC_Type) SetCFG1_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG1_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG1_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG1_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG1_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG1_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG1_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG1_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG1_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG1_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG1_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG1.Reg, volatile.LoadUint32(&o.CFG1.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG1_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG1.Reg) & 0x30000000) >> 28
}

// DMAC.SPIP1: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 1)
func (o *DMAC_Type) SetSPIP1_SPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.SPIP1.Reg, volatile.LoadUint32(&o.SPIP1.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetSPIP1_SPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.SPIP1.Reg) & 0xffff
}
func (o *DMAC_Type) SetSPIP1_SPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.SPIP1.Reg, volatile.LoadUint32(&o.SPIP1.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetSPIP1_SPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.SPIP1.Reg) & 0x3ff0000) >> 16
}

// DMAC.DPIP1: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 1)
func (o *DMAC_Type) SetDPIP1_DPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.DPIP1.Reg, volatile.LoadUint32(&o.DPIP1.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetDPIP1_DPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.DPIP1.Reg) & 0xffff
}
func (o *DMAC_Type) SetDPIP1_DPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.DPIP1.Reg, volatile.LoadUint32(&o.DPIP1.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetDPIP1_DPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.DPIP1.Reg) & 0x3ff0000) >> 16
}

// DMAC.SADDR2: DMAC Channel Source Address Register (ch_num = 2)
func (o *DMAC_Type) SetSADDR2(value uint32) {
	volatile.StoreUint32(&o.SADDR2.Reg, value)
}
func (o *DMAC_Type) GetSADDR2() uint32 {
	return volatile.LoadUint32(&o.SADDR2.Reg)
}

// DMAC.DADDR2: DMAC Channel Destination Address Register (ch_num = 2)
func (o *DMAC_Type) SetDADDR2(value uint32) {
	volatile.StoreUint32(&o.DADDR2.Reg, value)
}
func (o *DMAC_Type) GetDADDR2() uint32 {
	return volatile.LoadUint32(&o.DADDR2.Reg)
}

// DMAC.DSCR2: DMAC Channel Descriptor Address Register (ch_num = 2)
func (o *DMAC_Type) SetDSCR2_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR2.Reg, volatile.LoadUint32(&o.DSCR2.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR2_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR2.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR2_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR2.Reg, volatile.LoadUint32(&o.DSCR2.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR2_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR2.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA2: DMAC Channel Control A Register (ch_num = 2)
func (o *DMAC_Type) SetCTRLA2_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA2.Reg, volatile.LoadUint32(&o.CTRLA2.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA2_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA2.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA2_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA2.Reg, volatile.LoadUint32(&o.CTRLA2.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA2_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA2.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA2_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA2.Reg, volatile.LoadUint32(&o.CTRLA2.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA2_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA2.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA2_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA2.Reg, volatile.LoadUint32(&o.CTRLA2.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA2_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA2.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA2_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA2.Reg, volatile.LoadUint32(&o.CTRLA2.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA2_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA2.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA2_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA2.Reg, volatile.LoadUint32(&o.CTRLA2.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA2_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA2.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB2: DMAC Channel Control B Register (ch_num = 2)
func (o *DMAC_Type) SetCTRLB2_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB2_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB2.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB2_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB2_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB2_SRC_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCTRLB2_SRC_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCTRLB2_DST_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCTRLB2_DST_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCTRLB2_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB2_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB2_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB2_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB2_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x600000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB2_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x600000) >> 21
}
func (o *DMAC_Type) SetCTRLB2_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB2_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB2_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB2_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB2_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB2_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB2_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB2.Reg, volatile.LoadUint32(&o.CTRLB2.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB2_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB2.Reg) & 0x80000000) >> 31
}

// DMAC.CFG2: DMAC Channel Configuration Register (ch_num = 2)
func (o *DMAC_Type) SetCFG2_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG2_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG2.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG2_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG2_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG2_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG2_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG2_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG2_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG2_SRC_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0xc00)|value<<10)
}
func (o *DMAC_Type) GetCFG2_SRC_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0xc00) >> 10
}
func (o *DMAC_Type) SetCFG2_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG2_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG2_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG2_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG2_DST_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC_Type) GetCFG2_DST_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0xc000) >> 14
}
func (o *DMAC_Type) SetCFG2_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG2_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG2_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG2_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG2_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG2_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG2_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG2_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG2_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG2_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG2_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG2.Reg, volatile.LoadUint32(&o.CFG2.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG2_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG2.Reg) & 0x30000000) >> 28
}

// DMAC.SPIP2: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 2)
func (o *DMAC_Type) SetSPIP2_SPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.SPIP2.Reg, volatile.LoadUint32(&o.SPIP2.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetSPIP2_SPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.SPIP2.Reg) & 0xffff
}
func (o *DMAC_Type) SetSPIP2_SPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.SPIP2.Reg, volatile.LoadUint32(&o.SPIP2.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetSPIP2_SPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.SPIP2.Reg) & 0x3ff0000) >> 16
}

// DMAC.DPIP2: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 2)
func (o *DMAC_Type) SetDPIP2_DPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.DPIP2.Reg, volatile.LoadUint32(&o.DPIP2.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetDPIP2_DPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.DPIP2.Reg) & 0xffff
}
func (o *DMAC_Type) SetDPIP2_DPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.DPIP2.Reg, volatile.LoadUint32(&o.DPIP2.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetDPIP2_DPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.DPIP2.Reg) & 0x3ff0000) >> 16
}

// DMAC.SADDR3: DMAC Channel Source Address Register (ch_num = 3)
func (o *DMAC_Type) SetSADDR3(value uint32) {
	volatile.StoreUint32(&o.SADDR3.Reg, value)
}
func (o *DMAC_Type) GetSADDR3() uint32 {
	return volatile.LoadUint32(&o.SADDR3.Reg)
}

// DMAC.DADDR3: DMAC Channel Destination Address Register (ch_num = 3)
func (o *DMAC_Type) SetDADDR3(value uint32) {
	volatile.StoreUint32(&o.DADDR3.Reg, value)
}
func (o *DMAC_Type) GetDADDR3() uint32 {
	return volatile.LoadUint32(&o.DADDR3.Reg)
}

// DMAC.DSCR3: DMAC Channel Descriptor Address Register (ch_num = 3)
func (o *DMAC_Type) SetDSCR3_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR3.Reg, volatile.LoadUint32(&o.DSCR3.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR3_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR3.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR3_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR3.Reg, volatile.LoadUint32(&o.DSCR3.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR3_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR3.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA3: DMAC Channel Control A Register (ch_num = 3)
func (o *DMAC_Type) SetCTRLA3_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA3.Reg, volatile.LoadUint32(&o.CTRLA3.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA3_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA3.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA3_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA3.Reg, volatile.LoadUint32(&o.CTRLA3.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA3_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA3.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA3_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA3.Reg, volatile.LoadUint32(&o.CTRLA3.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA3_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA3.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA3_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA3.Reg, volatile.LoadUint32(&o.CTRLA3.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA3_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA3.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA3_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA3.Reg, volatile.LoadUint32(&o.CTRLA3.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA3_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA3.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA3_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA3.Reg, volatile.LoadUint32(&o.CTRLA3.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA3_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA3.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB3: DMAC Channel Control B Register (ch_num = 3)
func (o *DMAC_Type) SetCTRLB3_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB3_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB3.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB3_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB3_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB3_SRC_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCTRLB3_SRC_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCTRLB3_DST_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCTRLB3_DST_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCTRLB3_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB3_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB3_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB3_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB3_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x600000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB3_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x600000) >> 21
}
func (o *DMAC_Type) SetCTRLB3_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB3_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB3_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB3_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB3_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB3_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB3_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB3.Reg, volatile.LoadUint32(&o.CTRLB3.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB3_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB3.Reg) & 0x80000000) >> 31
}

// DMAC.CFG3: DMAC Channel Configuration Register (ch_num = 3)
func (o *DMAC_Type) SetCFG3_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG3_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG3.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG3_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG3_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG3_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG3_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG3_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG3_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG3_SRC_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0xc00)|value<<10)
}
func (o *DMAC_Type) GetCFG3_SRC_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0xc00) >> 10
}
func (o *DMAC_Type) SetCFG3_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG3_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG3_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG3_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG3_DST_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC_Type) GetCFG3_DST_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0xc000) >> 14
}
func (o *DMAC_Type) SetCFG3_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG3_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG3_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG3_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG3_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG3_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG3_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG3_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG3_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG3_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG3_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG3.Reg, volatile.LoadUint32(&o.CFG3.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG3_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG3.Reg) & 0x30000000) >> 28
}

// DMAC.SPIP3: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 3)
func (o *DMAC_Type) SetSPIP3_SPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.SPIP3.Reg, volatile.LoadUint32(&o.SPIP3.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetSPIP3_SPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.SPIP3.Reg) & 0xffff
}
func (o *DMAC_Type) SetSPIP3_SPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.SPIP3.Reg, volatile.LoadUint32(&o.SPIP3.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetSPIP3_SPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.SPIP3.Reg) & 0x3ff0000) >> 16
}

// DMAC.DPIP3: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 3)
func (o *DMAC_Type) SetDPIP3_DPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.DPIP3.Reg, volatile.LoadUint32(&o.DPIP3.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetDPIP3_DPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.DPIP3.Reg) & 0xffff
}
func (o *DMAC_Type) SetDPIP3_DPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.DPIP3.Reg, volatile.LoadUint32(&o.DPIP3.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetDPIP3_DPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.DPIP3.Reg) & 0x3ff0000) >> 16
}

// DMAC.SADDR4: DMAC Channel Source Address Register (ch_num = 4)
func (o *DMAC_Type) SetSADDR4(value uint32) {
	volatile.StoreUint32(&o.SADDR4.Reg, value)
}
func (o *DMAC_Type) GetSADDR4() uint32 {
	return volatile.LoadUint32(&o.SADDR4.Reg)
}

// DMAC.DADDR4: DMAC Channel Destination Address Register (ch_num = 4)
func (o *DMAC_Type) SetDADDR4(value uint32) {
	volatile.StoreUint32(&o.DADDR4.Reg, value)
}
func (o *DMAC_Type) GetDADDR4() uint32 {
	return volatile.LoadUint32(&o.DADDR4.Reg)
}

// DMAC.DSCR4: DMAC Channel Descriptor Address Register (ch_num = 4)
func (o *DMAC_Type) SetDSCR4_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR4.Reg, volatile.LoadUint32(&o.DSCR4.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR4_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR4.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR4_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR4.Reg, volatile.LoadUint32(&o.DSCR4.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR4_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR4.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA4: DMAC Channel Control A Register (ch_num = 4)
func (o *DMAC_Type) SetCTRLA4_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA4.Reg, volatile.LoadUint32(&o.CTRLA4.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA4_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA4.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA4_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA4.Reg, volatile.LoadUint32(&o.CTRLA4.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA4_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA4.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA4_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA4.Reg, volatile.LoadUint32(&o.CTRLA4.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA4_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA4.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA4_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA4.Reg, volatile.LoadUint32(&o.CTRLA4.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA4_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA4.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA4_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA4.Reg, volatile.LoadUint32(&o.CTRLA4.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA4_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA4.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA4_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA4.Reg, volatile.LoadUint32(&o.CTRLA4.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA4_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA4.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB4: DMAC Channel Control B Register (ch_num = 4)
func (o *DMAC_Type) SetCTRLB4_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB4_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB4.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB4_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB4_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB4_SRC_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCTRLB4_SRC_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCTRLB4_DST_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCTRLB4_DST_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCTRLB4_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB4_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB4_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB4_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB4_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x600000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB4_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x600000) >> 21
}
func (o *DMAC_Type) SetCTRLB4_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB4_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB4_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB4_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB4_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB4_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB4_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB4.Reg, volatile.LoadUint32(&o.CTRLB4.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB4_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB4.Reg) & 0x80000000) >> 31
}

// DMAC.CFG4: DMAC Channel Configuration Register (ch_num = 4)
func (o *DMAC_Type) SetCFG4_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG4_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG4.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG4_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG4_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG4_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG4_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG4_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG4_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG4_SRC_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0xc00)|value<<10)
}
func (o *DMAC_Type) GetCFG4_SRC_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0xc00) >> 10
}
func (o *DMAC_Type) SetCFG4_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG4_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG4_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG4_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG4_DST_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC_Type) GetCFG4_DST_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0xc000) >> 14
}
func (o *DMAC_Type) SetCFG4_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG4_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG4_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG4_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG4_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG4_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG4_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG4_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG4_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG4_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG4_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG4.Reg, volatile.LoadUint32(&o.CFG4.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG4_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG4.Reg) & 0x30000000) >> 28
}

// DMAC.SPIP4: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 4)
func (o *DMAC_Type) SetSPIP4_SPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.SPIP4.Reg, volatile.LoadUint32(&o.SPIP4.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetSPIP4_SPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.SPIP4.Reg) & 0xffff
}
func (o *DMAC_Type) SetSPIP4_SPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.SPIP4.Reg, volatile.LoadUint32(&o.SPIP4.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetSPIP4_SPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.SPIP4.Reg) & 0x3ff0000) >> 16
}

// DMAC.DPIP4: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 4)
func (o *DMAC_Type) SetDPIP4_DPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.DPIP4.Reg, volatile.LoadUint32(&o.DPIP4.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetDPIP4_DPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.DPIP4.Reg) & 0xffff
}
func (o *DMAC_Type) SetDPIP4_DPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.DPIP4.Reg, volatile.LoadUint32(&o.DPIP4.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetDPIP4_DPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.DPIP4.Reg) & 0x3ff0000) >> 16
}

// DMAC.SADDR5: DMAC Channel Source Address Register (ch_num = 5)
func (o *DMAC_Type) SetSADDR5(value uint32) {
	volatile.StoreUint32(&o.SADDR5.Reg, value)
}
func (o *DMAC_Type) GetSADDR5() uint32 {
	return volatile.LoadUint32(&o.SADDR5.Reg)
}

// DMAC.DADDR5: DMAC Channel Destination Address Register (ch_num = 5)
func (o *DMAC_Type) SetDADDR5(value uint32) {
	volatile.StoreUint32(&o.DADDR5.Reg, value)
}
func (o *DMAC_Type) GetDADDR5() uint32 {
	return volatile.LoadUint32(&o.DADDR5.Reg)
}

// DMAC.DSCR5: DMAC Channel Descriptor Address Register (ch_num = 5)
func (o *DMAC_Type) SetDSCR5_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR5.Reg, volatile.LoadUint32(&o.DSCR5.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR5_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR5.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR5_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR5.Reg, volatile.LoadUint32(&o.DSCR5.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR5_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR5.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA5: DMAC Channel Control A Register (ch_num = 5)
func (o *DMAC_Type) SetCTRLA5_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA5.Reg, volatile.LoadUint32(&o.CTRLA5.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA5_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA5.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA5_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA5.Reg, volatile.LoadUint32(&o.CTRLA5.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA5_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA5.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA5_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA5.Reg, volatile.LoadUint32(&o.CTRLA5.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA5_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA5.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA5_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA5.Reg, volatile.LoadUint32(&o.CTRLA5.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA5_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA5.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA5_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA5.Reg, volatile.LoadUint32(&o.CTRLA5.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA5_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA5.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA5_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA5.Reg, volatile.LoadUint32(&o.CTRLA5.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA5_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA5.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB5: DMAC Channel Control B Register (ch_num = 5)
func (o *DMAC_Type) SetCTRLB5_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB5_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB5.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB5_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB5_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB5_SRC_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCTRLB5_SRC_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCTRLB5_DST_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCTRLB5_DST_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCTRLB5_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB5_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB5_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB5_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB5_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x600000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB5_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x600000) >> 21
}
func (o *DMAC_Type) SetCTRLB5_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB5_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB5_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB5_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB5_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB5_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB5_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB5.Reg, volatile.LoadUint32(&o.CTRLB5.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB5_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB5.Reg) & 0x80000000) >> 31
}

// DMAC.CFG5: DMAC Channel Configuration Register (ch_num = 5)
func (o *DMAC_Type) SetCFG5_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG5_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG5.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG5_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG5_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG5_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG5_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG5_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG5_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG5_SRC_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0xc00)|value<<10)
}
func (o *DMAC_Type) GetCFG5_SRC_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0xc00) >> 10
}
func (o *DMAC_Type) SetCFG5_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG5_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG5_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG5_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG5_DST_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC_Type) GetCFG5_DST_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0xc000) >> 14
}
func (o *DMAC_Type) SetCFG5_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG5_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG5_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG5_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG5_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG5_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG5_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG5_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG5_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG5_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG5_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG5.Reg, volatile.LoadUint32(&o.CFG5.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG5_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG5.Reg) & 0x30000000) >> 28
}

// DMAC.SPIP5: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 5)
func (o *DMAC_Type) SetSPIP5_SPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.SPIP5.Reg, volatile.LoadUint32(&o.SPIP5.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetSPIP5_SPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.SPIP5.Reg) & 0xffff
}
func (o *DMAC_Type) SetSPIP5_SPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.SPIP5.Reg, volatile.LoadUint32(&o.SPIP5.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetSPIP5_SPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.SPIP5.Reg) & 0x3ff0000) >> 16
}

// DMAC.DPIP5: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 5)
func (o *DMAC_Type) SetDPIP5_DPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.DPIP5.Reg, volatile.LoadUint32(&o.DPIP5.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetDPIP5_DPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.DPIP5.Reg) & 0xffff
}
func (o *DMAC_Type) SetDPIP5_DPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.DPIP5.Reg, volatile.LoadUint32(&o.DPIP5.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetDPIP5_DPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.DPIP5.Reg) & 0x3ff0000) >> 16
}

// DMAC.SADDR6: DMAC Channel Source Address Register (ch_num = 6)
func (o *DMAC_Type) SetSADDR6(value uint32) {
	volatile.StoreUint32(&o.SADDR6.Reg, value)
}
func (o *DMAC_Type) GetSADDR6() uint32 {
	return volatile.LoadUint32(&o.SADDR6.Reg)
}

// DMAC.DADDR6: DMAC Channel Destination Address Register (ch_num = 6)
func (o *DMAC_Type) SetDADDR6(value uint32) {
	volatile.StoreUint32(&o.DADDR6.Reg, value)
}
func (o *DMAC_Type) GetDADDR6() uint32 {
	return volatile.LoadUint32(&o.DADDR6.Reg)
}

// DMAC.DSCR6: DMAC Channel Descriptor Address Register (ch_num = 6)
func (o *DMAC_Type) SetDSCR6_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR6.Reg, volatile.LoadUint32(&o.DSCR6.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR6_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR6.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR6_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR6.Reg, volatile.LoadUint32(&o.DSCR6.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR6_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR6.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA6: DMAC Channel Control A Register (ch_num = 6)
func (o *DMAC_Type) SetCTRLA6_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA6.Reg, volatile.LoadUint32(&o.CTRLA6.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA6_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA6.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA6_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA6.Reg, volatile.LoadUint32(&o.CTRLA6.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA6_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA6.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA6_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA6.Reg, volatile.LoadUint32(&o.CTRLA6.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA6_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA6.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA6_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA6.Reg, volatile.LoadUint32(&o.CTRLA6.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA6_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA6.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA6_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA6.Reg, volatile.LoadUint32(&o.CTRLA6.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA6_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA6.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA6_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA6.Reg, volatile.LoadUint32(&o.CTRLA6.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA6_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA6.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB6: DMAC Channel Control B Register (ch_num = 6)
func (o *DMAC_Type) SetCTRLB6_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB6_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB6.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB6_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB6_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB6_SRC_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCTRLB6_SRC_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCTRLB6_DST_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCTRLB6_DST_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCTRLB6_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB6_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB6_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB6_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB6_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x600000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB6_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x600000) >> 21
}
func (o *DMAC_Type) SetCTRLB6_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB6_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB6_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB6_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB6_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB6_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB6_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB6.Reg, volatile.LoadUint32(&o.CTRLB6.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB6_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB6.Reg) & 0x80000000) >> 31
}

// DMAC.CFG6: DMAC Channel Configuration Register (ch_num = 6)
func (o *DMAC_Type) SetCFG6_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG6_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG6.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG6_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG6_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG6_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG6_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG6_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG6_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG6_SRC_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0xc00)|value<<10)
}
func (o *DMAC_Type) GetCFG6_SRC_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0xc00) >> 10
}
func (o *DMAC_Type) SetCFG6_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG6_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG6_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG6_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG6_DST_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC_Type) GetCFG6_DST_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0xc000) >> 14
}
func (o *DMAC_Type) SetCFG6_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG6_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG6_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG6_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG6_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG6_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG6_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG6_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG6_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG6_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG6_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG6.Reg, volatile.LoadUint32(&o.CFG6.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG6_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG6.Reg) & 0x30000000) >> 28
}

// DMAC.SPIP6: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 6)
func (o *DMAC_Type) SetSPIP6_SPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.SPIP6.Reg, volatile.LoadUint32(&o.SPIP6.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetSPIP6_SPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.SPIP6.Reg) & 0xffff
}
func (o *DMAC_Type) SetSPIP6_SPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.SPIP6.Reg, volatile.LoadUint32(&o.SPIP6.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetSPIP6_SPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.SPIP6.Reg) & 0x3ff0000) >> 16
}

// DMAC.DPIP6: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 6)
func (o *DMAC_Type) SetDPIP6_DPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.DPIP6.Reg, volatile.LoadUint32(&o.DPIP6.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetDPIP6_DPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.DPIP6.Reg) & 0xffff
}
func (o *DMAC_Type) SetDPIP6_DPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.DPIP6.Reg, volatile.LoadUint32(&o.DPIP6.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetDPIP6_DPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.DPIP6.Reg) & 0x3ff0000) >> 16
}

// DMAC.SADDR7: DMAC Channel Source Address Register (ch_num = 7)
func (o *DMAC_Type) SetSADDR7(value uint32) {
	volatile.StoreUint32(&o.SADDR7.Reg, value)
}
func (o *DMAC_Type) GetSADDR7() uint32 {
	return volatile.LoadUint32(&o.SADDR7.Reg)
}

// DMAC.DADDR7: DMAC Channel Destination Address Register (ch_num = 7)
func (o *DMAC_Type) SetDADDR7(value uint32) {
	volatile.StoreUint32(&o.DADDR7.Reg, value)
}
func (o *DMAC_Type) GetDADDR7() uint32 {
	return volatile.LoadUint32(&o.DADDR7.Reg)
}

// DMAC.DSCR7: DMAC Channel Descriptor Address Register (ch_num = 7)
func (o *DMAC_Type) SetDSCR7_DSCR_IF(value uint32) {
	volatile.StoreUint32(&o.DSCR7.Reg, volatile.LoadUint32(&o.DSCR7.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetDSCR7_DSCR_IF() uint32 {
	return volatile.LoadUint32(&o.DSCR7.Reg) & 0x3
}
func (o *DMAC_Type) SetDSCR7_DSCR(value uint32) {
	volatile.StoreUint32(&o.DSCR7.Reg, volatile.LoadUint32(&o.DSCR7.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DMAC_Type) GetDSCR7_DSCR() uint32 {
	return (volatile.LoadUint32(&o.DSCR7.Reg) & 0xfffffffc) >> 2
}

// DMAC.CTRLA7: DMAC Channel Control A Register (ch_num = 7)
func (o *DMAC_Type) SetCTRLA7_BTSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA7.Reg, volatile.LoadUint32(&o.CTRLA7.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetCTRLA7_BTSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLA7.Reg) & 0xffff
}
func (o *DMAC_Type) SetCTRLA7_SCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA7.Reg, volatile.LoadUint32(&o.CTRLA7.Reg)&^(0x70000)|value<<16)
}
func (o *DMAC_Type) GetCTRLA7_SCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA7.Reg) & 0x70000) >> 16
}
func (o *DMAC_Type) SetCTRLA7_DCSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA7.Reg, volatile.LoadUint32(&o.CTRLA7.Reg)&^(0x700000)|value<<20)
}
func (o *DMAC_Type) GetCTRLA7_DCSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA7.Reg) & 0x700000) >> 20
}
func (o *DMAC_Type) SetCTRLA7_SRC_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA7.Reg, volatile.LoadUint32(&o.CTRLA7.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLA7_SRC_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA7.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLA7_DST_WIDTH(value uint32) {
	volatile.StoreUint32(&o.CTRLA7.Reg, volatile.LoadUint32(&o.CTRLA7.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLA7_DST_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.CTRLA7.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLA7_DONE(value uint32) {
	volatile.StoreUint32(&o.CTRLA7.Reg, volatile.LoadUint32(&o.CTRLA7.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLA7_DONE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA7.Reg) & 0x80000000) >> 31
}

// DMAC.CTRLB7: DMAC Channel Control B Register (ch_num = 7)
func (o *DMAC_Type) SetCTRLB7_SIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCTRLB7_SIF() uint32 {
	return volatile.LoadUint32(&o.CTRLB7.Reg) & 0x3
}
func (o *DMAC_Type) SetCTRLB7_DIF(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_Type) GetCTRLB7_DIF() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x30) >> 4
}
func (o *DMAC_Type) SetCTRLB7_SRC_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCTRLB7_SRC_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCTRLB7_DST_PIP(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCTRLB7_DST_PIP() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCTRLB7_SRC_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCTRLB7_SRC_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCTRLB7_DST_DSCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCTRLB7_DST_DSCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCTRLB7_FC(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x600000)|value<<21)
}
func (o *DMAC_Type) GetCTRLB7_FC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x600000) >> 21
}
func (o *DMAC_Type) SetCTRLB7_SRC_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x3000000)|value<<24)
}
func (o *DMAC_Type) GetCTRLB7_SRC_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x3000000) >> 24
}
func (o *DMAC_Type) SetCTRLB7_DST_INCR(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCTRLB7_DST_INCR() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x30000000) >> 28
}
func (o *DMAC_Type) SetCTRLB7_IEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetCTRLB7_IEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetCTRLB7_AUTO(value uint32) {
	volatile.StoreUint32(&o.CTRLB7.Reg, volatile.LoadUint32(&o.CTRLB7.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetCTRLB7_AUTO() uint32 {
	return (volatile.LoadUint32(&o.CTRLB7.Reg) & 0x80000000) >> 31
}

// DMAC.CFG7: DMAC Channel Configuration Register (ch_num = 7)
func (o *DMAC_Type) SetCFG7_SRC_PER(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0xf)|value)
}
func (o *DMAC_Type) GetCFG7_SRC_PER() uint32 {
	return volatile.LoadUint32(&o.CFG7.Reg) & 0xf
}
func (o *DMAC_Type) SetCFG7_DST_PER(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0xf0)|value<<4)
}
func (o *DMAC_Type) GetCFG7_DST_PER() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0xf0) >> 4
}
func (o *DMAC_Type) SetCFG7_SRC_REP(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCFG7_SRC_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCFG7_SRC_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCFG7_SRC_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCFG7_SRC_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0xc00)|value<<10)
}
func (o *DMAC_Type) GetCFG7_SRC_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0xc00) >> 10
}
func (o *DMAC_Type) SetCFG7_DST_REP(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetCFG7_DST_REP() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetCFG7_DST_H2SEL(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetCFG7_DST_H2SEL() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetCFG7_DST_PER_MSB(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC_Type) GetCFG7_DST_PER_MSB() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0xc000) >> 14
}
func (o *DMAC_Type) SetCFG7_SOD(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetCFG7_SOD() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetCFG7_LOCK_IF(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetCFG7_LOCK_IF() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetCFG7_LOCK_B(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetCFG7_LOCK_B() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetCFG7_LOCK_IF_L(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetCFG7_LOCK_IF_L() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetCFG7_AHB_PROT(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x7000000)|value<<24)
}
func (o *DMAC_Type) GetCFG7_AHB_PROT() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x7000000) >> 24
}
func (o *DMAC_Type) SetCFG7_FIFOCFG(value uint32) {
	volatile.StoreUint32(&o.CFG7.Reg, volatile.LoadUint32(&o.CFG7.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_Type) GetCFG7_FIFOCFG() uint32 {
	return (volatile.LoadUint32(&o.CFG7.Reg) & 0x30000000) >> 28
}

// DMAC.SPIP7: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 7)
func (o *DMAC_Type) SetSPIP7_SPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.SPIP7.Reg, volatile.LoadUint32(&o.SPIP7.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetSPIP7_SPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.SPIP7.Reg) & 0xffff
}
func (o *DMAC_Type) SetSPIP7_SPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.SPIP7.Reg, volatile.LoadUint32(&o.SPIP7.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetSPIP7_SPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.SPIP7.Reg) & 0x3ff0000) >> 16
}

// DMAC.DPIP7: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 7)
func (o *DMAC_Type) SetDPIP7_DPIP_HOLE(value uint32) {
	volatile.StoreUint32(&o.DPIP7.Reg, volatile.LoadUint32(&o.DPIP7.Reg)&^(0xffff)|value)
}
func (o *DMAC_Type) GetDPIP7_DPIP_HOLE() uint32 {
	return volatile.LoadUint32(&o.DPIP7.Reg) & 0xffff
}
func (o *DMAC_Type) SetDPIP7_DPIP_BOUNDARY(value uint32) {
	volatile.StoreUint32(&o.DPIP7.Reg, volatile.LoadUint32(&o.DPIP7.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC_Type) GetDPIP7_DPIP_BOUNDARY() uint32 {
	return (volatile.LoadUint32(&o.DPIP7.Reg) & 0x3ff0000) >> 16
}

// DMAC.WPMR: DMAC Write Protect Mode Register
func (o *DMAC_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *DMAC_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DMAC_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// DMAC.WPSR: DMAC Write Protect Status Register
func (o *DMAC_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *DMAC_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *DMAC_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// AHB Multi-port DDR-SDRAM Controller
type EBI_Type struct {
	MR             volatile.Register32 // 0x0
	RTR            volatile.Register32 // 0x4
	CR             volatile.Register32 // 0x8
	TPR0           volatile.Register32 // 0xC
	TPR1           volatile.Register32 // 0x10
	TPR2           volatile.Register32 // 0x14
	_              [4]byte
	LPR            volatile.Register32 // 0x1C
	MD             volatile.Register32 // 0x20
	HS             volatile.Register32 // 0x24
	LPDDR2_LPR     volatile.Register32 // 0x28
	LPDDR2_CAL_MR4 volatile.Register32 // 0x2C
	LPDDR2_TIM_CAL volatile.Register32 // 0x30
	IO_CALIBR      volatile.Register32 // 0x34
	_              [12]byte
	SAW            [4]volatile.Register32 // 0x44
	_              [32]byte
	DLL_MO         volatile.Register32    // 0x74
	DLL_SOF        volatile.Register32    // 0x78
	DLL_MS         volatile.Register32    // 0x7C
	DLL_SS         [4]volatile.Register32 // 0x80
	_              [84]byte
	WPCR           volatile.Register32 // 0xE4
	WPSR           volatile.Register32 // 0xE8
}

// EBI.MR: MPDDRC Mode Register
func (o *EBI_Type) SetMR_MODE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x7)|value)
}
func (o *EBI_Type) GetMR_MODE() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x7
}
func (o *EBI_Type) SetMR_MRS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xff00)|value<<8)
}
func (o *EBI_Type) GetMR_MRS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xff00) >> 8
}

// EBI.RTR: MPDDRC Refresh Timer Register
func (o *EBI_Type) SetRTR_COUNT(value uint32) {
	volatile.StoreUint32(&o.RTR.Reg, volatile.LoadUint32(&o.RTR.Reg)&^(0xfff)|value)
}
func (o *EBI_Type) GetRTR_COUNT() uint32 {
	return volatile.LoadUint32(&o.RTR.Reg) & 0xfff
}
func (o *EBI_Type) SetRTR_ADJ_REF(value uint32) {
	volatile.StoreUint32(&o.RTR.Reg, volatile.LoadUint32(&o.RTR.Reg)&^(0x10000)|value<<16)
}
func (o *EBI_Type) GetRTR_ADJ_REF() uint32 {
	return (volatile.LoadUint32(&o.RTR.Reg) & 0x10000) >> 16
}
func (o *EBI_Type) SetRTR_REF_PB(value uint32) {
	volatile.StoreUint32(&o.RTR.Reg, volatile.LoadUint32(&o.RTR.Reg)&^(0x20000)|value<<17)
}
func (o *EBI_Type) GetRTR_REF_PB() uint32 {
	return (volatile.LoadUint32(&o.RTR.Reg) & 0x20000) >> 17
}
func (o *EBI_Type) SetRTR_MR4_VALUE(value uint32) {
	volatile.StoreUint32(&o.RTR.Reg, volatile.LoadUint32(&o.RTR.Reg)&^(0x700000)|value<<20)
}
func (o *EBI_Type) GetRTR_MR4_VALUE() uint32 {
	return (volatile.LoadUint32(&o.RTR.Reg) & 0x700000) >> 20
}

// EBI.CR: MPDDRC Configuration Register
func (o *EBI_Type) SetCR_NC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3)|value)
}
func (o *EBI_Type) GetCR_NC() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x3
}
func (o *EBI_Type) SetCR_NR(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc)|value<<2)
}
func (o *EBI_Type) GetCR_NR() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc) >> 2
}
func (o *EBI_Type) SetCR_CAS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x70)|value<<4)
}
func (o *EBI_Type) GetCR_CAS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x70) >> 4
}
func (o *EBI_Type) SetCR_DLL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *EBI_Type) GetCR_DLL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *EBI_Type) SetCR_DIC_DS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *EBI_Type) GetCR_DIC_DS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *EBI_Type) SetCR_DIS_DLL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *EBI_Type) GetCR_DIS_DLL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *EBI_Type) SetCR_ZQ(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc00)|value<<10)
}
func (o *EBI_Type) GetCR_ZQ() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc00) >> 10
}
func (o *EBI_Type) SetCR_OCD(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x7000)|value<<12)
}
func (o *EBI_Type) GetCR_OCD() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x7000) >> 12
}
func (o *EBI_Type) SetCR_DQMS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *EBI_Type) GetCR_DQMS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *EBI_Type) SetCR_ENRDM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *EBI_Type) GetCR_ENRDM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *EBI_Type) SetCR_NB(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100000)|value<<20)
}
func (o *EBI_Type) GetCR_NB() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100000) >> 20
}
func (o *EBI_Type) SetCR_NDQS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200000)|value<<21)
}
func (o *EBI_Type) GetCR_NDQS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200000) >> 21
}
func (o *EBI_Type) SetCR_DECOD(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400000)|value<<22)
}
func (o *EBI_Type) GetCR_DECOD() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400000) >> 22
}
func (o *EBI_Type) SetCR_UNAL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800000)|value<<23)
}
func (o *EBI_Type) GetCR_UNAL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800000) >> 23
}

// EBI.TPR0: MPDDRC Timing Parameter 0 Register
func (o *EBI_Type) SetTPR0_TRAS(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf)|value)
}
func (o *EBI_Type) GetTPR0_TRAS() uint32 {
	return volatile.LoadUint32(&o.TPR0.Reg) & 0xf
}
func (o *EBI_Type) SetTPR0_TRCD(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf0)|value<<4)
}
func (o *EBI_Type) GetTPR0_TRCD() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf0) >> 4
}
func (o *EBI_Type) SetTPR0_TWR(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf00)|value<<8)
}
func (o *EBI_Type) GetTPR0_TWR() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf00) >> 8
}
func (o *EBI_Type) SetTPR0_TRC(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf000)|value<<12)
}
func (o *EBI_Type) GetTPR0_TRC() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf000) >> 12
}
func (o *EBI_Type) SetTPR0_TRP(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf0000)|value<<16)
}
func (o *EBI_Type) GetTPR0_TRP() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf0000) >> 16
}
func (o *EBI_Type) SetTPR0_TRRD(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf00000)|value<<20)
}
func (o *EBI_Type) GetTPR0_TRRD() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf00000) >> 20
}
func (o *EBI_Type) SetTPR0_TWTR(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0x7000000)|value<<24)
}
func (o *EBI_Type) GetTPR0_TWTR() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0x7000000) >> 24
}
func (o *EBI_Type) SetTPR0_RDC_WRRD(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0x8000000)|value<<27)
}
func (o *EBI_Type) GetTPR0_RDC_WRRD() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0x8000000) >> 27
}
func (o *EBI_Type) SetTPR0_TMRD(value uint32) {
	volatile.StoreUint32(&o.TPR0.Reg, volatile.LoadUint32(&o.TPR0.Reg)&^(0xf0000000)|value<<28)
}
func (o *EBI_Type) GetTPR0_TMRD() uint32 {
	return (volatile.LoadUint32(&o.TPR0.Reg) & 0xf0000000) >> 28
}

// EBI.TPR1: MPDDRC Timing Parameter 1 Register
func (o *EBI_Type) SetTPR1_TRFC(value uint32) {
	volatile.StoreUint32(&o.TPR1.Reg, volatile.LoadUint32(&o.TPR1.Reg)&^(0x7f)|value)
}
func (o *EBI_Type) GetTPR1_TRFC() uint32 {
	return volatile.LoadUint32(&o.TPR1.Reg) & 0x7f
}
func (o *EBI_Type) SetTPR1_TXSNR(value uint32) {
	volatile.StoreUint32(&o.TPR1.Reg, volatile.LoadUint32(&o.TPR1.Reg)&^(0xff00)|value<<8)
}
func (o *EBI_Type) GetTPR1_TXSNR() uint32 {
	return (volatile.LoadUint32(&o.TPR1.Reg) & 0xff00) >> 8
}
func (o *EBI_Type) SetTPR1_TXSRD(value uint32) {
	volatile.StoreUint32(&o.TPR1.Reg, volatile.LoadUint32(&o.TPR1.Reg)&^(0xff0000)|value<<16)
}
func (o *EBI_Type) GetTPR1_TXSRD() uint32 {
	return (volatile.LoadUint32(&o.TPR1.Reg) & 0xff0000) >> 16
}
func (o *EBI_Type) SetTPR1_TXP(value uint32) {
	volatile.StoreUint32(&o.TPR1.Reg, volatile.LoadUint32(&o.TPR1.Reg)&^(0xf000000)|value<<24)
}
func (o *EBI_Type) GetTPR1_TXP() uint32 {
	return (volatile.LoadUint32(&o.TPR1.Reg) & 0xf000000) >> 24
}

// EBI.TPR2: MPDDRC Timing Parameter 2 Register
func (o *EBI_Type) SetTPR2_TXARD(value uint32) {
	volatile.StoreUint32(&o.TPR2.Reg, volatile.LoadUint32(&o.TPR2.Reg)&^(0xf)|value)
}
func (o *EBI_Type) GetTPR2_TXARD() uint32 {
	return volatile.LoadUint32(&o.TPR2.Reg) & 0xf
}
func (o *EBI_Type) SetTPR2_TXARDS(value uint32) {
	volatile.StoreUint32(&o.TPR2.Reg, volatile.LoadUint32(&o.TPR2.Reg)&^(0xf0)|value<<4)
}
func (o *EBI_Type) GetTPR2_TXARDS() uint32 {
	return (volatile.LoadUint32(&o.TPR2.Reg) & 0xf0) >> 4
}
func (o *EBI_Type) SetTPR2_TRPA(value uint32) {
	volatile.StoreUint32(&o.TPR2.Reg, volatile.LoadUint32(&o.TPR2.Reg)&^(0xf00)|value<<8)
}
func (o *EBI_Type) GetTPR2_TRPA() uint32 {
	return (volatile.LoadUint32(&o.TPR2.Reg) & 0xf00) >> 8
}
func (o *EBI_Type) SetTPR2_TRTP(value uint32) {
	volatile.StoreUint32(&o.TPR2.Reg, volatile.LoadUint32(&o.TPR2.Reg)&^(0x7000)|value<<12)
}
func (o *EBI_Type) GetTPR2_TRTP() uint32 {
	return (volatile.LoadUint32(&o.TPR2.Reg) & 0x7000) >> 12
}
func (o *EBI_Type) SetTPR2_TFAW(value uint32) {
	volatile.StoreUint32(&o.TPR2.Reg, volatile.LoadUint32(&o.TPR2.Reg)&^(0xf0000)|value<<16)
}
func (o *EBI_Type) GetTPR2_TFAW() uint32 {
	return (volatile.LoadUint32(&o.TPR2.Reg) & 0xf0000) >> 16
}

// EBI.LPR: MPDDRC Low-power Register
func (o *EBI_Type) SetLPR_LPCB(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x3)|value)
}
func (o *EBI_Type) GetLPR_LPCB() uint32 {
	return volatile.LoadUint32(&o.LPR.Reg) & 0x3
}
func (o *EBI_Type) SetLPR_CLK_FR(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x4)|value<<2)
}
func (o *EBI_Type) GetLPR_CLK_FR() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x4) >> 2
}
func (o *EBI_Type) SetLPR_LPDDR2_PWOFF(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x8)|value<<3)
}
func (o *EBI_Type) GetLPR_LPDDR2_PWOFF() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x8) >> 3
}
func (o *EBI_Type) SetLPR_PASR(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x70)|value<<4)
}
func (o *EBI_Type) GetLPR_PASR() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x70) >> 4
}
func (o *EBI_Type) SetLPR_DS(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x700)|value<<8)
}
func (o *EBI_Type) GetLPR_DS() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x700) >> 8
}
func (o *EBI_Type) SetLPR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x3000)|value<<12)
}
func (o *EBI_Type) GetLPR_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x3000) >> 12
}
func (o *EBI_Type) SetLPR_APDE(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x10000)|value<<16)
}
func (o *EBI_Type) GetLPR_APDE() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x10000) >> 16
}
func (o *EBI_Type) SetLPR_UPD_MR(value uint32) {
	volatile.StoreUint32(&o.LPR.Reg, volatile.LoadUint32(&o.LPR.Reg)&^(0x300000)|value<<20)
}
func (o *EBI_Type) GetLPR_UPD_MR() uint32 {
	return (volatile.LoadUint32(&o.LPR.Reg) & 0x300000) >> 20
}

// EBI.MD: MPDDRC Memory Device Register
func (o *EBI_Type) SetMD(value uint32) {
	volatile.StoreUint32(&o.MD.Reg, volatile.LoadUint32(&o.MD.Reg)&^(0x7)|value)
}
func (o *EBI_Type) GetMD() uint32 {
	return volatile.LoadUint32(&o.MD.Reg) & 0x7
}
func (o *EBI_Type) SetMD_DBW(value uint32) {
	volatile.StoreUint32(&o.MD.Reg, volatile.LoadUint32(&o.MD.Reg)&^(0x10)|value<<4)
}
func (o *EBI_Type) GetMD_DBW() uint32 {
	return (volatile.LoadUint32(&o.MD.Reg) & 0x10) >> 4
}

// EBI.HS: MPDDRC High Speed Register
func (o *EBI_Type) SetHS_DIS_ANTICIP_READ(value uint32) {
	volatile.StoreUint32(&o.HS.Reg, volatile.LoadUint32(&o.HS.Reg)&^(0x4)|value<<2)
}
func (o *EBI_Type) GetHS_DIS_ANTICIP_READ() uint32 {
	return (volatile.LoadUint32(&o.HS.Reg) & 0x4) >> 2
}

// EBI.LPDDR2_LPR: MPDDRC LPDDR2 Low-power Register
func (o *EBI_Type) SetLPDDR2_LPR_BK_MASK_PASR(value uint32) {
	volatile.StoreUint32(&o.LPDDR2_LPR.Reg, volatile.LoadUint32(&o.LPDDR2_LPR.Reg)&^(0xff)|value)
}
func (o *EBI_Type) GetLPDDR2_LPR_BK_MASK_PASR() uint32 {
	return volatile.LoadUint32(&o.LPDDR2_LPR.Reg) & 0xff
}
func (o *EBI_Type) SetLPDDR2_LPR_SEG_MASK(value uint32) {
	volatile.StoreUint32(&o.LPDDR2_LPR.Reg, volatile.LoadUint32(&o.LPDDR2_LPR.Reg)&^(0xffff00)|value<<8)
}
func (o *EBI_Type) GetLPDDR2_LPR_SEG_MASK() uint32 {
	return (volatile.LoadUint32(&o.LPDDR2_LPR.Reg) & 0xffff00) >> 8
}
func (o *EBI_Type) SetLPDDR2_LPR_DS(value uint32) {
	volatile.StoreUint32(&o.LPDDR2_LPR.Reg, volatile.LoadUint32(&o.LPDDR2_LPR.Reg)&^(0xf000000)|value<<24)
}
func (o *EBI_Type) GetLPDDR2_LPR_DS() uint32 {
	return (volatile.LoadUint32(&o.LPDDR2_LPR.Reg) & 0xf000000) >> 24
}

// EBI.LPDDR2_CAL_MR4: MPDDRC LPDDR2 Calibration and MR4 Register
func (o *EBI_Type) SetLPDDR2_CAL_MR4_COUNT_CAL(value uint32) {
	volatile.StoreUint32(&o.LPDDR2_CAL_MR4.Reg, volatile.LoadUint32(&o.LPDDR2_CAL_MR4.Reg)&^(0xffff)|value)
}
func (o *EBI_Type) GetLPDDR2_CAL_MR4_COUNT_CAL() uint32 {
	return volatile.LoadUint32(&o.LPDDR2_CAL_MR4.Reg) & 0xffff
}
func (o *EBI_Type) SetLPDDR2_CAL_MR4_MR4_READ(value uint32) {
	volatile.StoreUint32(&o.LPDDR2_CAL_MR4.Reg, volatile.LoadUint32(&o.LPDDR2_CAL_MR4.Reg)&^(0xffff0000)|value<<16)
}
func (o *EBI_Type) GetLPDDR2_CAL_MR4_MR4_READ() uint32 {
	return (volatile.LoadUint32(&o.LPDDR2_CAL_MR4.Reg) & 0xffff0000) >> 16
}

// EBI.LPDDR2_TIM_CAL: MPDDRC LPDDR2 Timing Calibration Register
func (o *EBI_Type) SetLPDDR2_TIM_CAL_ZQCS(value uint32) {
	volatile.StoreUint32(&o.LPDDR2_TIM_CAL.Reg, volatile.LoadUint32(&o.LPDDR2_TIM_CAL.Reg)&^(0xff)|value)
}
func (o *EBI_Type) GetLPDDR2_TIM_CAL_ZQCS() uint32 {
	return volatile.LoadUint32(&o.LPDDR2_TIM_CAL.Reg) & 0xff
}

// EBI.IO_CALIBR: MPDDRC IO Calibration
func (o *EBI_Type) SetIO_CALIBR_RDIV(value uint32) {
	volatile.StoreUint32(&o.IO_CALIBR.Reg, volatile.LoadUint32(&o.IO_CALIBR.Reg)&^(0x7)|value)
}
func (o *EBI_Type) GetIO_CALIBR_RDIV() uint32 {
	return volatile.LoadUint32(&o.IO_CALIBR.Reg) & 0x7
}
func (o *EBI_Type) SetIO_CALIBR_TZQIO(value uint32) {
	volatile.StoreUint32(&o.IO_CALIBR.Reg, volatile.LoadUint32(&o.IO_CALIBR.Reg)&^(0x700)|value<<8)
}
func (o *EBI_Type) GetIO_CALIBR_TZQIO() uint32 {
	return (volatile.LoadUint32(&o.IO_CALIBR.Reg) & 0x700) >> 8
}
func (o *EBI_Type) SetIO_CALIBR_CALCODEP(value uint32) {
	volatile.StoreUint32(&o.IO_CALIBR.Reg, volatile.LoadUint32(&o.IO_CALIBR.Reg)&^(0xf0000)|value<<16)
}
func (o *EBI_Type) GetIO_CALIBR_CALCODEP() uint32 {
	return (volatile.LoadUint32(&o.IO_CALIBR.Reg) & 0xf0000) >> 16
}
func (o *EBI_Type) SetIO_CALIBR_CALCODEN(value uint32) {
	volatile.StoreUint32(&o.IO_CALIBR.Reg, volatile.LoadUint32(&o.IO_CALIBR.Reg)&^(0xf00000)|value<<20)
}
func (o *EBI_Type) GetIO_CALIBR_CALCODEN() uint32 {
	return (volatile.LoadUint32(&o.IO_CALIBR.Reg) & 0xf00000) >> 20
}

// EBI.SAW: MPDDRC Smart Adaptation Wrapper 0 Register
func (o *EBI_Type) SetSAW_FLUSH_MAX(idx int, value uint32) {
	volatile.StoreUint32(&o.SAW[idx].Reg, volatile.LoadUint32(&o.SAW[idx].Reg)&^(0xff)|value)
}
func (o *EBI_Type) GetSAW_FLUSH_MAX(idx int) uint32 {
	return volatile.LoadUint32(&o.SAW[idx].Reg) & 0xff
}
func (o *EBI_Type) SetSAW_INCR_THRESH(idx int, value uint32) {
	volatile.StoreUint32(&o.SAW[idx].Reg, volatile.LoadUint32(&o.SAW[idx].Reg)&^(0x3f00)|value<<8)
}
func (o *EBI_Type) GetSAW_INCR_THRESH(idx int) uint32 {
	return (volatile.LoadUint32(&o.SAW[idx].Reg) & 0x3f00) >> 8
}
func (o *EBI_Type) SetSAW_PFCH_THRESH(idx int, value uint32) {
	volatile.StoreUint32(&o.SAW[idx].Reg, volatile.LoadUint32(&o.SAW[idx].Reg)&^(0x3f0000)|value<<16)
}
func (o *EBI_Type) GetSAW_PFCH_THRESH(idx int) uint32 {
	return (volatile.LoadUint32(&o.SAW[idx].Reg) & 0x3f0000) >> 16
}

// EBI.DLL_MO: MPDDRC DLL Master Offset Register
func (o *EBI_Type) SetDLL_MO_MOFF(value uint32) {
	volatile.StoreUint32(&o.DLL_MO.Reg, volatile.LoadUint32(&o.DLL_MO.Reg)&^(0xf)|value)
}
func (o *EBI_Type) GetDLL_MO_MOFF() uint32 {
	return volatile.LoadUint32(&o.DLL_MO.Reg) & 0xf
}
func (o *EBI_Type) SetDLL_MO_CLK90OFF(value uint32) {
	volatile.StoreUint32(&o.DLL_MO.Reg, volatile.LoadUint32(&o.DLL_MO.Reg)&^(0x1f00)|value<<8)
}
func (o *EBI_Type) GetDLL_MO_CLK90OFF() uint32 {
	return (volatile.LoadUint32(&o.DLL_MO.Reg) & 0x1f00) >> 8
}
func (o *EBI_Type) SetDLL_MO_SELOFF(value uint32) {
	volatile.StoreUint32(&o.DLL_MO.Reg, volatile.LoadUint32(&o.DLL_MO.Reg)&^(0x10000)|value<<16)
}
func (o *EBI_Type) GetDLL_MO_SELOFF() uint32 {
	return (volatile.LoadUint32(&o.DLL_MO.Reg) & 0x10000) >> 16
}

// EBI.DLL_SOF: MPDDRC DLL Slave Offset Register
func (o *EBI_Type) SetDLL_SOF_S0OFF(value uint32) {
	volatile.StoreUint32(&o.DLL_SOF.Reg, volatile.LoadUint32(&o.DLL_SOF.Reg)&^(0x1f)|value)
}
func (o *EBI_Type) GetDLL_SOF_S0OFF() uint32 {
	return volatile.LoadUint32(&o.DLL_SOF.Reg) & 0x1f
}
func (o *EBI_Type) SetDLL_SOF_S1OFF(value uint32) {
	volatile.StoreUint32(&o.DLL_SOF.Reg, volatile.LoadUint32(&o.DLL_SOF.Reg)&^(0x1f00)|value<<8)
}
func (o *EBI_Type) GetDLL_SOF_S1OFF() uint32 {
	return (volatile.LoadUint32(&o.DLL_SOF.Reg) & 0x1f00) >> 8
}
func (o *EBI_Type) SetDLL_SOF_S2OFF(value uint32) {
	volatile.StoreUint32(&o.DLL_SOF.Reg, volatile.LoadUint32(&o.DLL_SOF.Reg)&^(0x1f0000)|value<<16)
}
func (o *EBI_Type) GetDLL_SOF_S2OFF() uint32 {
	return (volatile.LoadUint32(&o.DLL_SOF.Reg) & 0x1f0000) >> 16
}
func (o *EBI_Type) SetDLL_SOF_S3OFF(value uint32) {
	volatile.StoreUint32(&o.DLL_SOF.Reg, volatile.LoadUint32(&o.DLL_SOF.Reg)&^(0x1f000000)|value<<24)
}
func (o *EBI_Type) GetDLL_SOF_S3OFF() uint32 {
	return (volatile.LoadUint32(&o.DLL_SOF.Reg) & 0x1f000000) >> 24
}

// EBI.DLL_MS: MPDDRC DLL Status Master Register
func (o *EBI_Type) SetDLL_MS_MDINC(value uint32) {
	volatile.StoreUint32(&o.DLL_MS.Reg, volatile.LoadUint32(&o.DLL_MS.Reg)&^(0x1)|value)
}
func (o *EBI_Type) GetDLL_MS_MDINC() uint32 {
	return volatile.LoadUint32(&o.DLL_MS.Reg) & 0x1
}
func (o *EBI_Type) SetDLL_MS_MDDEC(value uint32) {
	volatile.StoreUint32(&o.DLL_MS.Reg, volatile.LoadUint32(&o.DLL_MS.Reg)&^(0x2)|value<<1)
}
func (o *EBI_Type) GetDLL_MS_MDDEC() uint32 {
	return (volatile.LoadUint32(&o.DLL_MS.Reg) & 0x2) >> 1
}
func (o *EBI_Type) SetDLL_MS_MDOVF(value uint32) {
	volatile.StoreUint32(&o.DLL_MS.Reg, volatile.LoadUint32(&o.DLL_MS.Reg)&^(0x4)|value<<2)
}
func (o *EBI_Type) GetDLL_MS_MDOVF() uint32 {
	return (volatile.LoadUint32(&o.DLL_MS.Reg) & 0x4) >> 2
}
func (o *EBI_Type) SetDLL_MS_MDVAL(value uint32) {
	volatile.StoreUint32(&o.DLL_MS.Reg, volatile.LoadUint32(&o.DLL_MS.Reg)&^(0xff00)|value<<8)
}
func (o *EBI_Type) GetDLL_MS_MDVAL() uint32 {
	return (volatile.LoadUint32(&o.DLL_MS.Reg) & 0xff00) >> 8
}

// EBI.DLL_SS: MPDDRC DLL Status Slave 0 Register
func (o *EBI_Type) SetDLL_SS_SDCOVF(idx int, value uint32) {
	volatile.StoreUint32(&o.DLL_SS[idx].Reg, volatile.LoadUint32(&o.DLL_SS[idx].Reg)&^(0x1)|value)
}
func (o *EBI_Type) GetDLL_SS_SDCOVF(idx int) uint32 {
	return volatile.LoadUint32(&o.DLL_SS[idx].Reg) & 0x1
}
func (o *EBI_Type) SetDLL_SS_SDCUDF(idx int, value uint32) {
	volatile.StoreUint32(&o.DLL_SS[idx].Reg, volatile.LoadUint32(&o.DLL_SS[idx].Reg)&^(0x2)|value<<1)
}
func (o *EBI_Type) GetDLL_SS_SDCUDF(idx int) uint32 {
	return (volatile.LoadUint32(&o.DLL_SS[idx].Reg) & 0x2) >> 1
}
func (o *EBI_Type) SetDLL_SS_SDERF(idx int, value uint32) {
	volatile.StoreUint32(&o.DLL_SS[idx].Reg, volatile.LoadUint32(&o.DLL_SS[idx].Reg)&^(0x4)|value<<2)
}
func (o *EBI_Type) GetDLL_SS_SDERF(idx int) uint32 {
	return (volatile.LoadUint32(&o.DLL_SS[idx].Reg) & 0x4) >> 2
}
func (o *EBI_Type) SetDLL_SS_SDVAL(idx int, value uint32) {
	volatile.StoreUint32(&o.DLL_SS[idx].Reg, volatile.LoadUint32(&o.DLL_SS[idx].Reg)&^(0xff00)|value<<8)
}
func (o *EBI_Type) GetDLL_SS_SDVAL(idx int) uint32 {
	return (volatile.LoadUint32(&o.DLL_SS[idx].Reg) & 0xff00) >> 8
}
func (o *EBI_Type) SetDLL_SS_SDCVAL(idx int, value uint32) {
	volatile.StoreUint32(&o.DLL_SS[idx].Reg, volatile.LoadUint32(&o.DLL_SS[idx].Reg)&^(0xff0000)|value<<16)
}
func (o *EBI_Type) GetDLL_SS_SDCVAL(idx int) uint32 {
	return (volatile.LoadUint32(&o.DLL_SS[idx].Reg) & 0xff0000) >> 16
}

// EBI.WPCR: MPDDRC Write Protect Control Register
func (o *EBI_Type) SetWPCR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0x1)|value)
}
func (o *EBI_Type) GetWPCR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPCR.Reg) & 0x1
}
func (o *EBI_Type) SetWPCR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPCR.Reg, volatile.LoadUint32(&o.WPCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *EBI_Type) GetWPCR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPCR.Reg) & 0xffffff00) >> 8
}

// EBI.WPSR: MPDDRC Write Protect Status Register
func (o *EBI_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *EBI_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *EBI_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *EBI_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// AHB Bus Matrix
type MATRIX_Type struct {
	MCFG   [16]volatile.Register32 // 0x0
	SCFG   [16]volatile.Register32 // 0x40
	PRAS0  volatile.Register32     // 0x80
	PRBS0  volatile.Register32     // 0x84
	PRAS1  volatile.Register32     // 0x88
	PRBS1  volatile.Register32     // 0x8C
	PRAS2  volatile.Register32     // 0x90
	PRBS2  volatile.Register32     // 0x94
	PRAS3  volatile.Register32     // 0x98
	PRBS3  volatile.Register32     // 0x9C
	PRAS4  volatile.Register32     // 0xA0
	PRBS4  volatile.Register32     // 0xA4
	PRAS5  volatile.Register32     // 0xA8
	PRBS5  volatile.Register32     // 0xAC
	PRAS6  volatile.Register32     // 0xB0
	PRBS6  volatile.Register32     // 0xB4
	PRAS7  volatile.Register32     // 0xB8
	PRBS7  volatile.Register32     // 0xBC
	PRAS8  volatile.Register32     // 0xC0
	PRBS8  volatile.Register32     // 0xC4
	PRAS9  volatile.Register32     // 0xC8
	PRBS9  volatile.Register32     // 0xCC
	PRAS10 volatile.Register32     // 0xD0
	PRBS10 volatile.Register32     // 0xD4
	PRAS11 volatile.Register32     // 0xD8
	PRBS11 volatile.Register32     // 0xDC
	PRAS12 volatile.Register32     // 0xE0
	PRBS12 volatile.Register32     // 0xE4
	PRAS13 volatile.Register32     // 0xE8
	PRBS13 volatile.Register32     // 0xEC
	PRAS14 volatile.Register32     // 0xF0
	PRBS14 volatile.Register32     // 0xF4
	PRAS15 volatile.Register32     // 0xF8
	PRBS15 volatile.Register32     // 0xFC
	MRCR   volatile.Register32     // 0x100
	_      [12]byte
	SFR    [16]volatile.Register32 // 0x110
	_      [148]byte
	WPMR   volatile.Register32 // 0x1E4
	WPSR   volatile.Register32 // 0x1E8
}

// MATRIX.MCFG: Master Configuration Register
func (o *MATRIX_Type) SetMCFG_ULBT(idx int, value uint32) {
	volatile.StoreUint32(&o.MCFG[idx].Reg, volatile.LoadUint32(&o.MCFG[idx].Reg)&^(0x7)|value)
}
func (o *MATRIX_Type) GetMCFG_ULBT(idx int) uint32 {
	return volatile.LoadUint32(&o.MCFG[idx].Reg) & 0x7
}

// MATRIX.SCFG: Slave Configuration Register
func (o *MATRIX_Type) SetSCFG_SLOT_CYCLE(idx int, value uint32) {
	volatile.StoreUint32(&o.SCFG[idx].Reg, volatile.LoadUint32(&o.SCFG[idx].Reg)&^(0x1ff)|value)
}
func (o *MATRIX_Type) GetSCFG_SLOT_CYCLE(idx int) uint32 {
	return volatile.LoadUint32(&o.SCFG[idx].Reg) & 0x1ff
}
func (o *MATRIX_Type) SetSCFG_DEFMSTR_TYPE(idx int, value uint32) {
	volatile.StoreUint32(&o.SCFG[idx].Reg, volatile.LoadUint32(&o.SCFG[idx].Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetSCFG_DEFMSTR_TYPE(idx int) uint32 {
	return (volatile.LoadUint32(&o.SCFG[idx].Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetSCFG_FIXED_DEFMSTR(idx int, value uint32) {
	volatile.StoreUint32(&o.SCFG[idx].Reg, volatile.LoadUint32(&o.SCFG[idx].Reg)&^(0x3c0000)|value<<18)
}
func (o *MATRIX_Type) GetSCFG_FIXED_DEFMSTR(idx int) uint32 {
	return (volatile.LoadUint32(&o.SCFG[idx].Reg) & 0x3c0000) >> 18
}

// MATRIX.PRAS0: Priority Register A for Slave 0
func (o *MATRIX_Type) SetPRAS0_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS0_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS0.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS0_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS0_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS0.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS0_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS0_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS0.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS0_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS0_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS0.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS0_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS0_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS0.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS0_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS0_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS0.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS0_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS0_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS0.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS0_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS0.Reg, volatile.LoadUint32(&o.PRAS0.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS0_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS0.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS0: Priority Register B for Slave 0
func (o *MATRIX_Type) SetPRBS0_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS0.Reg, volatile.LoadUint32(&o.PRBS0.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS0_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS0.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS0_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS0.Reg, volatile.LoadUint32(&o.PRBS0.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS0_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS0.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS0_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS0.Reg, volatile.LoadUint32(&o.PRBS0.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS0_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS0.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS0_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS0.Reg, volatile.LoadUint32(&o.PRBS0.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS0_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS0.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS0_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS0.Reg, volatile.LoadUint32(&o.PRBS0.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS0_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS0.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS0_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS0.Reg, volatile.LoadUint32(&o.PRBS0.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS0_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS0.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS0_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS0.Reg, volatile.LoadUint32(&o.PRBS0.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS0_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS0.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS0_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS0.Reg, volatile.LoadUint32(&o.PRBS0.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS0_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS0.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS1: Priority Register A for Slave 1
func (o *MATRIX_Type) SetPRAS1_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS1_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS1.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS1_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS1_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS1.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS1_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS1_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS1.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS1_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS1_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS1.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS1_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS1_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS1.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS1_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS1_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS1.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS1_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS1_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS1.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS1_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS1.Reg, volatile.LoadUint32(&o.PRAS1.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS1_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS1.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS1: Priority Register B for Slave 1
func (o *MATRIX_Type) SetPRBS1_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS1.Reg, volatile.LoadUint32(&o.PRBS1.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS1_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS1.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS1_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS1.Reg, volatile.LoadUint32(&o.PRBS1.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS1_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS1.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS1_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS1.Reg, volatile.LoadUint32(&o.PRBS1.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS1_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS1.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS1_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS1.Reg, volatile.LoadUint32(&o.PRBS1.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS1_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS1.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS1_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS1.Reg, volatile.LoadUint32(&o.PRBS1.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS1_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS1.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS1_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS1.Reg, volatile.LoadUint32(&o.PRBS1.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS1_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS1.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS1_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS1.Reg, volatile.LoadUint32(&o.PRBS1.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS1_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS1.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS1_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS1.Reg, volatile.LoadUint32(&o.PRBS1.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS1_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS1.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS2: Priority Register A for Slave 2
func (o *MATRIX_Type) SetPRAS2_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS2_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS2.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS2_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS2_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS2.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS2_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS2_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS2.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS2_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS2_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS2.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS2_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS2_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS2.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS2_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS2_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS2.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS2_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS2_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS2.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS2_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS2.Reg, volatile.LoadUint32(&o.PRAS2.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS2_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS2.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS2: Priority Register B for Slave 2
func (o *MATRIX_Type) SetPRBS2_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS2.Reg, volatile.LoadUint32(&o.PRBS2.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS2_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS2.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS2_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS2.Reg, volatile.LoadUint32(&o.PRBS2.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS2_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS2.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS2_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS2.Reg, volatile.LoadUint32(&o.PRBS2.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS2_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS2.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS2_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS2.Reg, volatile.LoadUint32(&o.PRBS2.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS2_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS2.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS2_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS2.Reg, volatile.LoadUint32(&o.PRBS2.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS2_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS2.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS2_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS2.Reg, volatile.LoadUint32(&o.PRBS2.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS2_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS2.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS2_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS2.Reg, volatile.LoadUint32(&o.PRBS2.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS2_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS2.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS2_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS2.Reg, volatile.LoadUint32(&o.PRBS2.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS2_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS2.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS3: Priority Register A for Slave 3
func (o *MATRIX_Type) SetPRAS3_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS3_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS3.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS3_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS3_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS3.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS3_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS3_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS3.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS3_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS3_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS3.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS3_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS3_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS3.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS3_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS3_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS3.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS3_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS3_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS3.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS3_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS3.Reg, volatile.LoadUint32(&o.PRAS3.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS3_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS3.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS3: Priority Register B for Slave 3
func (o *MATRIX_Type) SetPRBS3_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS3.Reg, volatile.LoadUint32(&o.PRBS3.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS3_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS3.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS3_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS3.Reg, volatile.LoadUint32(&o.PRBS3.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS3_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS3.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS3_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS3.Reg, volatile.LoadUint32(&o.PRBS3.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS3_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS3.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS3_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS3.Reg, volatile.LoadUint32(&o.PRBS3.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS3_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS3.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS3_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS3.Reg, volatile.LoadUint32(&o.PRBS3.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS3_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS3.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS3_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS3.Reg, volatile.LoadUint32(&o.PRBS3.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS3_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS3.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS3_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS3.Reg, volatile.LoadUint32(&o.PRBS3.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS3_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS3.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS3_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS3.Reg, volatile.LoadUint32(&o.PRBS3.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS3_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS3.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS4: Priority Register A for Slave 4
func (o *MATRIX_Type) SetPRAS4_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS4_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS4.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS4_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS4_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS4.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS4_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS4_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS4.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS4_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS4_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS4.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS4_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS4_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS4.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS4_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS4_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS4.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS4_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS4_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS4.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS4_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS4.Reg, volatile.LoadUint32(&o.PRAS4.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS4_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS4.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS4: Priority Register B for Slave 4
func (o *MATRIX_Type) SetPRBS4_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS4.Reg, volatile.LoadUint32(&o.PRBS4.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS4_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS4.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS4_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS4.Reg, volatile.LoadUint32(&o.PRBS4.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS4_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS4.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS4_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS4.Reg, volatile.LoadUint32(&o.PRBS4.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS4_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS4.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS4_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS4.Reg, volatile.LoadUint32(&o.PRBS4.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS4_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS4.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS4_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS4.Reg, volatile.LoadUint32(&o.PRBS4.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS4_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS4.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS4_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS4.Reg, volatile.LoadUint32(&o.PRBS4.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS4_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS4.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS4_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS4.Reg, volatile.LoadUint32(&o.PRBS4.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS4_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS4.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS4_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS4.Reg, volatile.LoadUint32(&o.PRBS4.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS4_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS4.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS5: Priority Register A for Slave 5
func (o *MATRIX_Type) SetPRAS5_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS5_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS5.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS5_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS5_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS5.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS5_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS5_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS5.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS5_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS5_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS5.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS5_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS5_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS5.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS5_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS5_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS5.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS5_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS5_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS5.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS5_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS5.Reg, volatile.LoadUint32(&o.PRAS5.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS5_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS5.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS5: Priority Register B for Slave 5
func (o *MATRIX_Type) SetPRBS5_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS5.Reg, volatile.LoadUint32(&o.PRBS5.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS5_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS5.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS5_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS5.Reg, volatile.LoadUint32(&o.PRBS5.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS5_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS5.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS5_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS5.Reg, volatile.LoadUint32(&o.PRBS5.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS5_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS5.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS5_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS5.Reg, volatile.LoadUint32(&o.PRBS5.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS5_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS5.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS5_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS5.Reg, volatile.LoadUint32(&o.PRBS5.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS5_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS5.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS5_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS5.Reg, volatile.LoadUint32(&o.PRBS5.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS5_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS5.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS5_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS5.Reg, volatile.LoadUint32(&o.PRBS5.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS5_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS5.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS5_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS5.Reg, volatile.LoadUint32(&o.PRBS5.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS5_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS5.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS6: Priority Register A for Slave 6
func (o *MATRIX_Type) SetPRAS6_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS6_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS6.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS6_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS6_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS6.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS6_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS6_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS6.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS6_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS6_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS6.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS6_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS6_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS6.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS6_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS6_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS6.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS6_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS6_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS6.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS6_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS6.Reg, volatile.LoadUint32(&o.PRAS6.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS6_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS6.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS6: Priority Register B for Slave 6
func (o *MATRIX_Type) SetPRBS6_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS6.Reg, volatile.LoadUint32(&o.PRBS6.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS6_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS6.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS6_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS6.Reg, volatile.LoadUint32(&o.PRBS6.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS6_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS6.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS6_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS6.Reg, volatile.LoadUint32(&o.PRBS6.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS6_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS6.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS6_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS6.Reg, volatile.LoadUint32(&o.PRBS6.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS6_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS6.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS6_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS6.Reg, volatile.LoadUint32(&o.PRBS6.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS6_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS6.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS6_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS6.Reg, volatile.LoadUint32(&o.PRBS6.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS6_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS6.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS6_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS6.Reg, volatile.LoadUint32(&o.PRBS6.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS6_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS6.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS6_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS6.Reg, volatile.LoadUint32(&o.PRBS6.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS6_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS6.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS7: Priority Register A for Slave 7
func (o *MATRIX_Type) SetPRAS7_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS7_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS7.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS7_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS7_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS7.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS7_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS7_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS7.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS7_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS7_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS7.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS7_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS7_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS7.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS7_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS7_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS7.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS7_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS7_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS7.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS7_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS7.Reg, volatile.LoadUint32(&o.PRAS7.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS7_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS7.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS7: Priority Register B for Slave 7
func (o *MATRIX_Type) SetPRBS7_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS7.Reg, volatile.LoadUint32(&o.PRBS7.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS7_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS7.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS7_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS7.Reg, volatile.LoadUint32(&o.PRBS7.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS7_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS7.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS7_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS7.Reg, volatile.LoadUint32(&o.PRBS7.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS7_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS7.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS7_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS7.Reg, volatile.LoadUint32(&o.PRBS7.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS7_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS7.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS7_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS7.Reg, volatile.LoadUint32(&o.PRBS7.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS7_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS7.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS7_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS7.Reg, volatile.LoadUint32(&o.PRBS7.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS7_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS7.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS7_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS7.Reg, volatile.LoadUint32(&o.PRBS7.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS7_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS7.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS7_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS7.Reg, volatile.LoadUint32(&o.PRBS7.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS7_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS7.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS8: Priority Register A for Slave 8
func (o *MATRIX_Type) SetPRAS8_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS8.Reg, volatile.LoadUint32(&o.PRAS8.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS8_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS8.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS8_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS8.Reg, volatile.LoadUint32(&o.PRAS8.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS8_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS8.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS8_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS8.Reg, volatile.LoadUint32(&o.PRAS8.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS8_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS8.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS8_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS8.Reg, volatile.LoadUint32(&o.PRAS8.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS8_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS8.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS8_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS8.Reg, volatile.LoadUint32(&o.PRAS8.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS8_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS8.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS8_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS8.Reg, volatile.LoadUint32(&o.PRAS8.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS8_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS8.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS8_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS8.Reg, volatile.LoadUint32(&o.PRAS8.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS8_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS8.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS8_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS8.Reg, volatile.LoadUint32(&o.PRAS8.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS8_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS8.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS8: Priority Register B for Slave 8
func (o *MATRIX_Type) SetPRBS8_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS8.Reg, volatile.LoadUint32(&o.PRBS8.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS8_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS8.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS8_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS8.Reg, volatile.LoadUint32(&o.PRBS8.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS8_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS8.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS8_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS8.Reg, volatile.LoadUint32(&o.PRBS8.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS8_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS8.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS8_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS8.Reg, volatile.LoadUint32(&o.PRBS8.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS8_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS8.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS8_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS8.Reg, volatile.LoadUint32(&o.PRBS8.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS8_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS8.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS8_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS8.Reg, volatile.LoadUint32(&o.PRBS8.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS8_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS8.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS8_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS8.Reg, volatile.LoadUint32(&o.PRBS8.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS8_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS8.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS8_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS8.Reg, volatile.LoadUint32(&o.PRBS8.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS8_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS8.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS9: Priority Register A for Slave 9
func (o *MATRIX_Type) SetPRAS9_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS9.Reg, volatile.LoadUint32(&o.PRAS9.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS9_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS9.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS9_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS9.Reg, volatile.LoadUint32(&o.PRAS9.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS9_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS9.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS9_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS9.Reg, volatile.LoadUint32(&o.PRAS9.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS9_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS9.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS9_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS9.Reg, volatile.LoadUint32(&o.PRAS9.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS9_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS9.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS9_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS9.Reg, volatile.LoadUint32(&o.PRAS9.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS9_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS9.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS9_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS9.Reg, volatile.LoadUint32(&o.PRAS9.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS9_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS9.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS9_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS9.Reg, volatile.LoadUint32(&o.PRAS9.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS9_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS9.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS9_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS9.Reg, volatile.LoadUint32(&o.PRAS9.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS9_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS9.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS9: Priority Register B for Slave 9
func (o *MATRIX_Type) SetPRBS9_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS9.Reg, volatile.LoadUint32(&o.PRBS9.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS9_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS9.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS9_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS9.Reg, volatile.LoadUint32(&o.PRBS9.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS9_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS9.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS9_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS9.Reg, volatile.LoadUint32(&o.PRBS9.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS9_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS9.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS9_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS9.Reg, volatile.LoadUint32(&o.PRBS9.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS9_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS9.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS9_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS9.Reg, volatile.LoadUint32(&o.PRBS9.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS9_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS9.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS9_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS9.Reg, volatile.LoadUint32(&o.PRBS9.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS9_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS9.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS9_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS9.Reg, volatile.LoadUint32(&o.PRBS9.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS9_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS9.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS9_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS9.Reg, volatile.LoadUint32(&o.PRBS9.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS9_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS9.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS10: Priority Register A for Slave 10
func (o *MATRIX_Type) SetPRAS10_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS10.Reg, volatile.LoadUint32(&o.PRAS10.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS10_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS10.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS10_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS10.Reg, volatile.LoadUint32(&o.PRAS10.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS10_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS10.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS10_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS10.Reg, volatile.LoadUint32(&o.PRAS10.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS10_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS10.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS10_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS10.Reg, volatile.LoadUint32(&o.PRAS10.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS10_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS10.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS10_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS10.Reg, volatile.LoadUint32(&o.PRAS10.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS10_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS10.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS10_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS10.Reg, volatile.LoadUint32(&o.PRAS10.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS10_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS10.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS10_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS10.Reg, volatile.LoadUint32(&o.PRAS10.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS10_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS10.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS10_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS10.Reg, volatile.LoadUint32(&o.PRAS10.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS10_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS10.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS10: Priority Register B for Slave 10
func (o *MATRIX_Type) SetPRBS10_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS10.Reg, volatile.LoadUint32(&o.PRBS10.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS10_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS10.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS10_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS10.Reg, volatile.LoadUint32(&o.PRBS10.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS10_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS10.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS10_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS10.Reg, volatile.LoadUint32(&o.PRBS10.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS10_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS10.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS10_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS10.Reg, volatile.LoadUint32(&o.PRBS10.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS10_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS10.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS10_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS10.Reg, volatile.LoadUint32(&o.PRBS10.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS10_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS10.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS10_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS10.Reg, volatile.LoadUint32(&o.PRBS10.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS10_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS10.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS10_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS10.Reg, volatile.LoadUint32(&o.PRBS10.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS10_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS10.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS10_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS10.Reg, volatile.LoadUint32(&o.PRBS10.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS10_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS10.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS11: Priority Register A for Slave 11
func (o *MATRIX_Type) SetPRAS11_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS11.Reg, volatile.LoadUint32(&o.PRAS11.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS11_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS11.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS11_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS11.Reg, volatile.LoadUint32(&o.PRAS11.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS11_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS11.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS11_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS11.Reg, volatile.LoadUint32(&o.PRAS11.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS11_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS11.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS11_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS11.Reg, volatile.LoadUint32(&o.PRAS11.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS11_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS11.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS11_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS11.Reg, volatile.LoadUint32(&o.PRAS11.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS11_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS11.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS11_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS11.Reg, volatile.LoadUint32(&o.PRAS11.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS11_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS11.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS11_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS11.Reg, volatile.LoadUint32(&o.PRAS11.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS11_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS11.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS11_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS11.Reg, volatile.LoadUint32(&o.PRAS11.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS11_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS11.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS11: Priority Register B for Slave 11
func (o *MATRIX_Type) SetPRBS11_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS11.Reg, volatile.LoadUint32(&o.PRBS11.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS11_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS11.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS11_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS11.Reg, volatile.LoadUint32(&o.PRBS11.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS11_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS11.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS11_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS11.Reg, volatile.LoadUint32(&o.PRBS11.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS11_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS11.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS11_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS11.Reg, volatile.LoadUint32(&o.PRBS11.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS11_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS11.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS11_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS11.Reg, volatile.LoadUint32(&o.PRBS11.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS11_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS11.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS11_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS11.Reg, volatile.LoadUint32(&o.PRBS11.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS11_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS11.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS11_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS11.Reg, volatile.LoadUint32(&o.PRBS11.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS11_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS11.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS11_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS11.Reg, volatile.LoadUint32(&o.PRBS11.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS11_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS11.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS12: Priority Register A for Slave 12
func (o *MATRIX_Type) SetPRAS12_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS12.Reg, volatile.LoadUint32(&o.PRAS12.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS12_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS12.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS12_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS12.Reg, volatile.LoadUint32(&o.PRAS12.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS12_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS12.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS12_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS12.Reg, volatile.LoadUint32(&o.PRAS12.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS12_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS12.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS12_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS12.Reg, volatile.LoadUint32(&o.PRAS12.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS12_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS12.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS12_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS12.Reg, volatile.LoadUint32(&o.PRAS12.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS12_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS12.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS12_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS12.Reg, volatile.LoadUint32(&o.PRAS12.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS12_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS12.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS12_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS12.Reg, volatile.LoadUint32(&o.PRAS12.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS12_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS12.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS12_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS12.Reg, volatile.LoadUint32(&o.PRAS12.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS12_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS12.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS12: Priority Register B for Slave 12
func (o *MATRIX_Type) SetPRBS12_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS12.Reg, volatile.LoadUint32(&o.PRBS12.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS12_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS12.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS12_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS12.Reg, volatile.LoadUint32(&o.PRBS12.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS12_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS12.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS12_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS12.Reg, volatile.LoadUint32(&o.PRBS12.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS12_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS12.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS12_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS12.Reg, volatile.LoadUint32(&o.PRBS12.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS12_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS12.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS12_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS12.Reg, volatile.LoadUint32(&o.PRBS12.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS12_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS12.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS12_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS12.Reg, volatile.LoadUint32(&o.PRBS12.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS12_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS12.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS12_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS12.Reg, volatile.LoadUint32(&o.PRBS12.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS12_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS12.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS12_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS12.Reg, volatile.LoadUint32(&o.PRBS12.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS12_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS12.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS13: Priority Register A for Slave 13
func (o *MATRIX_Type) SetPRAS13_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS13.Reg, volatile.LoadUint32(&o.PRAS13.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS13_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS13.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS13_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS13.Reg, volatile.LoadUint32(&o.PRAS13.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS13_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS13.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS13_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS13.Reg, volatile.LoadUint32(&o.PRAS13.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS13_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS13.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS13_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS13.Reg, volatile.LoadUint32(&o.PRAS13.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS13_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS13.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS13_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS13.Reg, volatile.LoadUint32(&o.PRAS13.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS13_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS13.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS13_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS13.Reg, volatile.LoadUint32(&o.PRAS13.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS13_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS13.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS13_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS13.Reg, volatile.LoadUint32(&o.PRAS13.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS13_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS13.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS13_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS13.Reg, volatile.LoadUint32(&o.PRAS13.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS13_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS13.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS13: Priority Register B for Slave 13
func (o *MATRIX_Type) SetPRBS13_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS13.Reg, volatile.LoadUint32(&o.PRBS13.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS13_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS13.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS13_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS13.Reg, volatile.LoadUint32(&o.PRBS13.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS13_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS13.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS13_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS13.Reg, volatile.LoadUint32(&o.PRBS13.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS13_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS13.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS13_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS13.Reg, volatile.LoadUint32(&o.PRBS13.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS13_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS13.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS13_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS13.Reg, volatile.LoadUint32(&o.PRBS13.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS13_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS13.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS13_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS13.Reg, volatile.LoadUint32(&o.PRBS13.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS13_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS13.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS13_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS13.Reg, volatile.LoadUint32(&o.PRBS13.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS13_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS13.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS13_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS13.Reg, volatile.LoadUint32(&o.PRBS13.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS13_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS13.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS14: Priority Register A for Slave 14
func (o *MATRIX_Type) SetPRAS14_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS14.Reg, volatile.LoadUint32(&o.PRAS14.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS14_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS14.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS14_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS14.Reg, volatile.LoadUint32(&o.PRAS14.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS14_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS14.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS14_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS14.Reg, volatile.LoadUint32(&o.PRAS14.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS14_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS14.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS14_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS14.Reg, volatile.LoadUint32(&o.PRAS14.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS14_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS14.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS14_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS14.Reg, volatile.LoadUint32(&o.PRAS14.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS14_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS14.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS14_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS14.Reg, volatile.LoadUint32(&o.PRAS14.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS14_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS14.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS14_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS14.Reg, volatile.LoadUint32(&o.PRAS14.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS14_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS14.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS14_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS14.Reg, volatile.LoadUint32(&o.PRAS14.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS14_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS14.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS14: Priority Register B for Slave 14
func (o *MATRIX_Type) SetPRBS14_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS14.Reg, volatile.LoadUint32(&o.PRBS14.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS14_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS14.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS14_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS14.Reg, volatile.LoadUint32(&o.PRBS14.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS14_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS14.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS14_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS14.Reg, volatile.LoadUint32(&o.PRBS14.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS14_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS14.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS14_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS14.Reg, volatile.LoadUint32(&o.PRBS14.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS14_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS14.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS14_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS14.Reg, volatile.LoadUint32(&o.PRBS14.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS14_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS14.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS14_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS14.Reg, volatile.LoadUint32(&o.PRBS14.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS14_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS14.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS14_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS14.Reg, volatile.LoadUint32(&o.PRBS14.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS14_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS14.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS14_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS14.Reg, volatile.LoadUint32(&o.PRBS14.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS14_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS14.Reg) & 0x30000000) >> 28
}

// MATRIX.PRAS15: Priority Register A for Slave 15
func (o *MATRIX_Type) SetPRAS15_M0PR(value uint32) {
	volatile.StoreUint32(&o.PRAS15.Reg, volatile.LoadUint32(&o.PRAS15.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRAS15_M0PR() uint32 {
	return volatile.LoadUint32(&o.PRAS15.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRAS15_M1PR(value uint32) {
	volatile.StoreUint32(&o.PRAS15.Reg, volatile.LoadUint32(&o.PRAS15.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRAS15_M1PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS15.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRAS15_M2PR(value uint32) {
	volatile.StoreUint32(&o.PRAS15.Reg, volatile.LoadUint32(&o.PRAS15.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRAS15_M2PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS15.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRAS15_M3PR(value uint32) {
	volatile.StoreUint32(&o.PRAS15.Reg, volatile.LoadUint32(&o.PRAS15.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRAS15_M3PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS15.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRAS15_M4PR(value uint32) {
	volatile.StoreUint32(&o.PRAS15.Reg, volatile.LoadUint32(&o.PRAS15.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRAS15_M4PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS15.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRAS15_M5PR(value uint32) {
	volatile.StoreUint32(&o.PRAS15.Reg, volatile.LoadUint32(&o.PRAS15.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRAS15_M5PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS15.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRAS15_M6PR(value uint32) {
	volatile.StoreUint32(&o.PRAS15.Reg, volatile.LoadUint32(&o.PRAS15.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRAS15_M6PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS15.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRAS15_M7PR(value uint32) {
	volatile.StoreUint32(&o.PRAS15.Reg, volatile.LoadUint32(&o.PRAS15.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRAS15_M7PR() uint32 {
	return (volatile.LoadUint32(&o.PRAS15.Reg) & 0x30000000) >> 28
}

// MATRIX.PRBS15: Priority Register B for Slave 15
func (o *MATRIX_Type) SetPRBS15_M8PR(value uint32) {
	volatile.StoreUint32(&o.PRBS15.Reg, volatile.LoadUint32(&o.PRBS15.Reg)&^(0x3)|value)
}
func (o *MATRIX_Type) GetPRBS15_M8PR() uint32 {
	return volatile.LoadUint32(&o.PRBS15.Reg) & 0x3
}
func (o *MATRIX_Type) SetPRBS15_M9PR(value uint32) {
	volatile.StoreUint32(&o.PRBS15.Reg, volatile.LoadUint32(&o.PRBS15.Reg)&^(0x30)|value<<4)
}
func (o *MATRIX_Type) GetPRBS15_M9PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS15.Reg) & 0x30) >> 4
}
func (o *MATRIX_Type) SetPRBS15_M10PR(value uint32) {
	volatile.StoreUint32(&o.PRBS15.Reg, volatile.LoadUint32(&o.PRBS15.Reg)&^(0x300)|value<<8)
}
func (o *MATRIX_Type) GetPRBS15_M10PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS15.Reg) & 0x300) >> 8
}
func (o *MATRIX_Type) SetPRBS15_M11PR(value uint32) {
	volatile.StoreUint32(&o.PRBS15.Reg, volatile.LoadUint32(&o.PRBS15.Reg)&^(0x3000)|value<<12)
}
func (o *MATRIX_Type) GetPRBS15_M11PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS15.Reg) & 0x3000) >> 12
}
func (o *MATRIX_Type) SetPRBS15_M12PR(value uint32) {
	volatile.StoreUint32(&o.PRBS15.Reg, volatile.LoadUint32(&o.PRBS15.Reg)&^(0x30000)|value<<16)
}
func (o *MATRIX_Type) GetPRBS15_M12PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS15.Reg) & 0x30000) >> 16
}
func (o *MATRIX_Type) SetPRBS15_M13PR(value uint32) {
	volatile.StoreUint32(&o.PRBS15.Reg, volatile.LoadUint32(&o.PRBS15.Reg)&^(0x300000)|value<<20)
}
func (o *MATRIX_Type) GetPRBS15_M13PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS15.Reg) & 0x300000) >> 20
}
func (o *MATRIX_Type) SetPRBS15_M14PR(value uint32) {
	volatile.StoreUint32(&o.PRBS15.Reg, volatile.LoadUint32(&o.PRBS15.Reg)&^(0x3000000)|value<<24)
}
func (o *MATRIX_Type) GetPRBS15_M14PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS15.Reg) & 0x3000000) >> 24
}
func (o *MATRIX_Type) SetPRBS15_M15PR(value uint32) {
	volatile.StoreUint32(&o.PRBS15.Reg, volatile.LoadUint32(&o.PRBS15.Reg)&^(0x30000000)|value<<28)
}
func (o *MATRIX_Type) GetPRBS15_M15PR() uint32 {
	return (volatile.LoadUint32(&o.PRBS15.Reg) & 0x30000000) >> 28
}

// MATRIX.MRCR: Master Remap Control Register
func (o *MATRIX_Type) SetMRCR_RCB0(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x1)|value)
}
func (o *MATRIX_Type) GetMRCR_RCB0() uint32 {
	return volatile.LoadUint32(&o.MRCR.Reg) & 0x1
}
func (o *MATRIX_Type) SetMRCR_RCB1(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x2)|value<<1)
}
func (o *MATRIX_Type) GetMRCR_RCB1() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x2) >> 1
}
func (o *MATRIX_Type) SetMRCR_RCB2(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x4)|value<<2)
}
func (o *MATRIX_Type) GetMRCR_RCB2() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x4) >> 2
}
func (o *MATRIX_Type) SetMRCR_RCB3(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x8)|value<<3)
}
func (o *MATRIX_Type) GetMRCR_RCB3() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x8) >> 3
}
func (o *MATRIX_Type) SetMRCR_RCB4(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x10)|value<<4)
}
func (o *MATRIX_Type) GetMRCR_RCB4() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x10) >> 4
}
func (o *MATRIX_Type) SetMRCR_RCB5(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x20)|value<<5)
}
func (o *MATRIX_Type) GetMRCR_RCB5() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x20) >> 5
}
func (o *MATRIX_Type) SetMRCR_RCB6(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x40)|value<<6)
}
func (o *MATRIX_Type) GetMRCR_RCB6() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x40) >> 6
}
func (o *MATRIX_Type) SetMRCR_RCB7(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x80)|value<<7)
}
func (o *MATRIX_Type) GetMRCR_RCB7() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x80) >> 7
}
func (o *MATRIX_Type) SetMRCR_RCB8(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x100)|value<<8)
}
func (o *MATRIX_Type) GetMRCR_RCB8() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x100) >> 8
}
func (o *MATRIX_Type) SetMRCR_RCB9(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x200)|value<<9)
}
func (o *MATRIX_Type) GetMRCR_RCB9() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x200) >> 9
}
func (o *MATRIX_Type) SetMRCR_RCB10(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x400)|value<<10)
}
func (o *MATRIX_Type) GetMRCR_RCB10() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x400) >> 10
}
func (o *MATRIX_Type) SetMRCR_RCB11(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x800)|value<<11)
}
func (o *MATRIX_Type) GetMRCR_RCB11() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x800) >> 11
}
func (o *MATRIX_Type) SetMRCR_RCB12(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x1000)|value<<12)
}
func (o *MATRIX_Type) GetMRCR_RCB12() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x1000) >> 12
}
func (o *MATRIX_Type) SetMRCR_RCB13(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x2000)|value<<13)
}
func (o *MATRIX_Type) GetMRCR_RCB13() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x2000) >> 13
}
func (o *MATRIX_Type) SetMRCR_RCB14(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x4000)|value<<14)
}
func (o *MATRIX_Type) GetMRCR_RCB14() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x4000) >> 14
}
func (o *MATRIX_Type) SetMRCR_RCB15(value uint32) {
	volatile.StoreUint32(&o.MRCR.Reg, volatile.LoadUint32(&o.MRCR.Reg)&^(0x8000)|value<<15)
}
func (o *MATRIX_Type) GetMRCR_RCB15() uint32 {
	return (volatile.LoadUint32(&o.MRCR.Reg) & 0x8000) >> 15
}

// MATRIX.SFR: Special Function Register
func (o *MATRIX_Type) SetSFR(idx int, value uint32) {
	volatile.StoreUint32(&o.SFR[idx].Reg, value)
}
func (o *MATRIX_Type) GetSFR(idx int) uint32 {
	return volatile.LoadUint32(&o.SFR[idx].Reg)
}

// MATRIX.WPMR: Write Protect Mode Register
func (o *MATRIX_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *MATRIX_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *MATRIX_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *MATRIX_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// MATRIX.WPSR: Write Protect Status Register
func (o *MATRIX_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *MATRIX_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *MATRIX_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *MATRIX_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// Debug Unit
type DBGU_Type struct {
	CR   volatile.Register32 // 0x0
	MR   volatile.Register32 // 0x4
	IER  volatile.Register32 // 0x8
	IDR  volatile.Register32 // 0xC
	IMR  volatile.Register32 // 0x10
	SR   volatile.Register32 // 0x14
	RHR  volatile.Register32 // 0x18
	THR  volatile.Register32 // 0x1C
	BRGR volatile.Register32 // 0x20
	_    [28]byte
	CIDR volatile.Register32 // 0x40
	EXID volatile.Register32 // 0x44
	FNR  volatile.Register32 // 0x48
}

// DBGU.CR: Control Register
func (o *DBGU_Type) SetCR_RSTRX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *DBGU_Type) GetCR_RSTRX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *DBGU_Type) SetCR_RSTTX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *DBGU_Type) GetCR_RSTTX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *DBGU_Type) SetCR_RXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *DBGU_Type) GetCR_RXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *DBGU_Type) SetCR_RXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *DBGU_Type) GetCR_RXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *DBGU_Type) SetCR_TXEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *DBGU_Type) GetCR_TXEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *DBGU_Type) SetCR_TXDIS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *DBGU_Type) GetCR_TXDIS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *DBGU_Type) SetCR_RSTSTA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *DBGU_Type) GetCR_RSTSTA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}

// DBGU.MR: Mode Register
func (o *DBGU_Type) SetMR_PAR(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xe00)|value<<9)
}
func (o *DBGU_Type) GetMR_PAR() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xe00) >> 9
}
func (o *DBGU_Type) SetMR_CHMODE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xc000)|value<<14)
}
func (o *DBGU_Type) GetMR_CHMODE() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xc000) >> 14
}

// DBGU.IER: Interrupt Enable Register
func (o *DBGU_Type) SetIER_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *DBGU_Type) GetIER_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *DBGU_Type) SetIER_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *DBGU_Type) GetIER_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *DBGU_Type) SetIER_OVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *DBGU_Type) GetIER_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *DBGU_Type) SetIER_FRAME(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *DBGU_Type) GetIER_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *DBGU_Type) SetIER_PARE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *DBGU_Type) GetIER_PARE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *DBGU_Type) SetIER_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *DBGU_Type) GetIER_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *DBGU_Type) SetIER_COMMTX(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000000)|value<<30)
}
func (o *DBGU_Type) GetIER_COMMTX() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000000) >> 30
}
func (o *DBGU_Type) SetIER_COMMRX(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000000)|value<<31)
}
func (o *DBGU_Type) GetIER_COMMRX() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000000) >> 31
}

// DBGU.IDR: Interrupt Disable Register
func (o *DBGU_Type) SetIDR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *DBGU_Type) GetIDR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *DBGU_Type) SetIDR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *DBGU_Type) GetIDR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *DBGU_Type) SetIDR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *DBGU_Type) GetIDR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *DBGU_Type) SetIDR_FRAME(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *DBGU_Type) GetIDR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *DBGU_Type) SetIDR_PARE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *DBGU_Type) GetIDR_PARE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *DBGU_Type) SetIDR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *DBGU_Type) GetIDR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *DBGU_Type) SetIDR_COMMTX(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000000)|value<<30)
}
func (o *DBGU_Type) GetIDR_COMMTX() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000000) >> 30
}
func (o *DBGU_Type) SetIDR_COMMRX(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000000)|value<<31)
}
func (o *DBGU_Type) GetIDR_COMMRX() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000000) >> 31
}

// DBGU.IMR: Interrupt Mask Register
func (o *DBGU_Type) SetIMR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *DBGU_Type) GetIMR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *DBGU_Type) SetIMR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *DBGU_Type) GetIMR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *DBGU_Type) SetIMR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *DBGU_Type) GetIMR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *DBGU_Type) SetIMR_FRAME(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *DBGU_Type) GetIMR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *DBGU_Type) SetIMR_PARE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *DBGU_Type) GetIMR_PARE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *DBGU_Type) SetIMR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *DBGU_Type) GetIMR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *DBGU_Type) SetIMR_COMMTX(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000000)|value<<30)
}
func (o *DBGU_Type) GetIMR_COMMTX() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000000) >> 30
}
func (o *DBGU_Type) SetIMR_COMMRX(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000000)|value<<31)
}
func (o *DBGU_Type) GetIMR_COMMRX() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000000) >> 31
}

// DBGU.SR: Status Register
func (o *DBGU_Type) SetSR_RXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *DBGU_Type) GetSR_RXRDY() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *DBGU_Type) SetSR_TXRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *DBGU_Type) GetSR_TXRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *DBGU_Type) SetSR_OVRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *DBGU_Type) GetSR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *DBGU_Type) SetSR_FRAME(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *DBGU_Type) GetSR_FRAME() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *DBGU_Type) SetSR_PARE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *DBGU_Type) GetSR_PARE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *DBGU_Type) SetSR_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *DBGU_Type) GetSR_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *DBGU_Type) SetSR_COMMTX(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000000)|value<<30)
}
func (o *DBGU_Type) GetSR_COMMTX() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000000) >> 30
}
func (o *DBGU_Type) SetSR_COMMRX(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000000)|value<<31)
}
func (o *DBGU_Type) GetSR_COMMRX() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000000) >> 31
}

// DBGU.RHR: Receive Holding Register
func (o *DBGU_Type) SetRHR_RXCHR(value uint32) {
	volatile.StoreUint32(&o.RHR.Reg, volatile.LoadUint32(&o.RHR.Reg)&^(0xff)|value)
}
func (o *DBGU_Type) GetRHR_RXCHR() uint32 {
	return volatile.LoadUint32(&o.RHR.Reg) & 0xff
}

// DBGU.THR: Transmit Holding Register
func (o *DBGU_Type) SetTHR_TXCHR(value uint32) {
	volatile.StoreUint32(&o.THR.Reg, volatile.LoadUint32(&o.THR.Reg)&^(0xff)|value)
}
func (o *DBGU_Type) GetTHR_TXCHR() uint32 {
	return volatile.LoadUint32(&o.THR.Reg) & 0xff
}

// DBGU.BRGR: Baud Rate Generator Register
func (o *DBGU_Type) SetBRGR_CD(value uint32) {
	volatile.StoreUint32(&o.BRGR.Reg, volatile.LoadUint32(&o.BRGR.Reg)&^(0xffff)|value)
}
func (o *DBGU_Type) GetBRGR_CD() uint32 {
	return volatile.LoadUint32(&o.BRGR.Reg) & 0xffff
}

// DBGU.CIDR: Chip ID Register
func (o *DBGU_Type) SetCIDR_VERSION(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0x1f)|value)
}
func (o *DBGU_Type) GetCIDR_VERSION() uint32 {
	return volatile.LoadUint32(&o.CIDR.Reg) & 0x1f
}
func (o *DBGU_Type) SetCIDR_EPROC(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0xe0)|value<<5)
}
func (o *DBGU_Type) GetCIDR_EPROC() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0xe0) >> 5
}
func (o *DBGU_Type) SetCIDR_NVPSIZ(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0xf00)|value<<8)
}
func (o *DBGU_Type) GetCIDR_NVPSIZ() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0xf00) >> 8
}
func (o *DBGU_Type) SetCIDR_NVPSIZ2(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0xf000)|value<<12)
}
func (o *DBGU_Type) GetCIDR_NVPSIZ2() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0xf000) >> 12
}
func (o *DBGU_Type) SetCIDR_SRAMSIZ(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0xf0000)|value<<16)
}
func (o *DBGU_Type) GetCIDR_SRAMSIZ() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0xf0000) >> 16
}
func (o *DBGU_Type) SetCIDR_ARCH(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0xff00000)|value<<20)
}
func (o *DBGU_Type) GetCIDR_ARCH() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0xff00000) >> 20
}
func (o *DBGU_Type) SetCIDR_NVPTYP(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0x70000000)|value<<28)
}
func (o *DBGU_Type) GetCIDR_NVPTYP() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0x70000000) >> 28
}
func (o *DBGU_Type) SetCIDR_EXT(value uint32) {
	volatile.StoreUint32(&o.CIDR.Reg, volatile.LoadUint32(&o.CIDR.Reg)&^(0x80000000)|value<<31)
}
func (o *DBGU_Type) GetCIDR_EXT() uint32 {
	return (volatile.LoadUint32(&o.CIDR.Reg) & 0x80000000) >> 31
}

// DBGU.EXID: Chip ID Extension Register
func (o *DBGU_Type) SetEXID(value uint32) {
	volatile.StoreUint32(&o.EXID.Reg, value)
}
func (o *DBGU_Type) GetEXID() uint32 {
	return volatile.LoadUint32(&o.EXID.Reg)
}

// DBGU.FNR: Force NTRST Register
func (o *DBGU_Type) SetFNR_FNTRST(value uint32) {
	volatile.StoreUint32(&o.FNR.Reg, volatile.LoadUint32(&o.FNR.Reg)&^(0x1)|value)
}
func (o *DBGU_Type) GetFNR_FNTRST() uint32 {
	return volatile.LoadUint32(&o.FNR.Reg) & 0x1
}

// Advanced Interrupt Controller
type AIC_Type struct {
	SSR   volatile.Register32 // 0x0
	SMR   volatile.Register32 // 0x4
	SVR   volatile.Register32 // 0x8
	_     [4]byte
	IVR   volatile.Register32 // 0x10
	FVR   volatile.Register32 // 0x14
	ISR   volatile.Register32 // 0x18
	_     [4]byte
	IPR0  volatile.Register32 // 0x20
	IPR1  volatile.Register32 // 0x24
	IPR2  volatile.Register32 // 0x28
	IPR3  volatile.Register32 // 0x2C
	IMR   volatile.Register32 // 0x30
	CISR  volatile.Register32 // 0x34
	EOICR volatile.Register32 // 0x38
	SPU   volatile.Register32 // 0x3C
	IECR  volatile.Register32 // 0x40
	IDCR  volatile.Register32 // 0x44
	ICCR  volatile.Register32 // 0x48
	ISCR  volatile.Register32 // 0x4C
	FFER  volatile.Register32 // 0x50
	FFDR  volatile.Register32 // 0x54
	FFSR  volatile.Register32 // 0x58
	_     [16]byte
	DCR   volatile.Register32 // 0x6C
	_     [116]byte
	WPMR  volatile.Register32 // 0xE4
	WPSR  volatile.Register32 // 0xE8
}

// AIC.SSR: Source Select Register
func (o *AIC_Type) SetSSR_INTSEL(value uint32) {
	volatile.StoreUint32(&o.SSR.Reg, volatile.LoadUint32(&o.SSR.Reg)&^(0x7f)|value)
}
func (o *AIC_Type) GetSSR_INTSEL() uint32 {
	return volatile.LoadUint32(&o.SSR.Reg) & 0x7f
}

// AIC.SMR: Source Mode Register
func (o *AIC_Type) SetSMR_PRIOR(value uint32) {
	volatile.StoreUint32(&o.SMR.Reg, volatile.LoadUint32(&o.SMR.Reg)&^(0x7)|value)
}
func (o *AIC_Type) GetSMR_PRIOR() uint32 {
	return volatile.LoadUint32(&o.SMR.Reg) & 0x7
}
func (o *AIC_Type) SetSMR_SRCTYPE(value uint32) {
	volatile.StoreUint32(&o.SMR.Reg, volatile.LoadUint32(&o.SMR.Reg)&^(0x60)|value<<5)
}
func (o *AIC_Type) GetSMR_SRCTYPE() uint32 {
	return (volatile.LoadUint32(&o.SMR.Reg) & 0x60) >> 5
}

// AIC.SVR: Source Vector Register
func (o *AIC_Type) SetSVR(value uint32) {
	volatile.StoreUint32(&o.SVR.Reg, value)
}
func (o *AIC_Type) GetSVR() uint32 {
	return volatile.LoadUint32(&o.SVR.Reg)
}

// AIC.IVR: Interrupt Vector Register
func (o *AIC_Type) SetIVR(value uint32) {
	volatile.StoreUint32(&o.IVR.Reg, value)
}
func (o *AIC_Type) GetIVR() uint32 {
	return volatile.LoadUint32(&o.IVR.Reg)
}

// AIC.FVR: FIQ Interrupt Vector Register
func (o *AIC_Type) SetFVR(value uint32) {
	volatile.StoreUint32(&o.FVR.Reg, value)
}
func (o *AIC_Type) GetFVR() uint32 {
	return volatile.LoadUint32(&o.FVR.Reg)
}

// AIC.ISR: Interrupt Status Register
func (o *AIC_Type) SetISR_IRQID(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x7f)|value)
}
func (o *AIC_Type) GetISR_IRQID() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x7f
}

// AIC.IPR0: Interrupt Pending Register 0
func (o *AIC_Type) SetIPR0_FIQ(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetIPR0_FIQ() uint32 {
	return volatile.LoadUint32(&o.IPR0.Reg) & 0x1
}
func (o *AIC_Type) SetIPR0_SYS(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetIPR0_SYS() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x2) >> 1
}
func (o *AIC_Type) SetIPR0_PID2(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x4)|value<<2)
}
func (o *AIC_Type) GetIPR0_PID2() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x4) >> 2
}
func (o *AIC_Type) SetIPR0_PID3(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x8)|value<<3)
}
func (o *AIC_Type) GetIPR0_PID3() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x8) >> 3
}
func (o *AIC_Type) SetIPR0_PID4(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x10)|value<<4)
}
func (o *AIC_Type) GetIPR0_PID4() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x10) >> 4
}
func (o *AIC_Type) SetIPR0_PID5(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x20)|value<<5)
}
func (o *AIC_Type) GetIPR0_PID5() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x20) >> 5
}
func (o *AIC_Type) SetIPR0_PID6(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x40)|value<<6)
}
func (o *AIC_Type) GetIPR0_PID6() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x40) >> 6
}
func (o *AIC_Type) SetIPR0_PID7(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x80)|value<<7)
}
func (o *AIC_Type) GetIPR0_PID7() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x80) >> 7
}
func (o *AIC_Type) SetIPR0_PID8(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x100)|value<<8)
}
func (o *AIC_Type) GetIPR0_PID8() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x100) >> 8
}
func (o *AIC_Type) SetIPR0_PID9(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x200)|value<<9)
}
func (o *AIC_Type) GetIPR0_PID9() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x200) >> 9
}
func (o *AIC_Type) SetIPR0_PID10(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x400)|value<<10)
}
func (o *AIC_Type) GetIPR0_PID10() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x400) >> 10
}
func (o *AIC_Type) SetIPR0_PID11(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x800)|value<<11)
}
func (o *AIC_Type) GetIPR0_PID11() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x800) >> 11
}
func (o *AIC_Type) SetIPR0_PID12(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x1000)|value<<12)
}
func (o *AIC_Type) GetIPR0_PID12() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x1000) >> 12
}
func (o *AIC_Type) SetIPR0_PID13(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x2000)|value<<13)
}
func (o *AIC_Type) GetIPR0_PID13() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x2000) >> 13
}
func (o *AIC_Type) SetIPR0_PID14(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x4000)|value<<14)
}
func (o *AIC_Type) GetIPR0_PID14() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x4000) >> 14
}
func (o *AIC_Type) SetIPR0_PID15(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x8000)|value<<15)
}
func (o *AIC_Type) GetIPR0_PID15() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x8000) >> 15
}
func (o *AIC_Type) SetIPR0_PID16(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x10000)|value<<16)
}
func (o *AIC_Type) GetIPR0_PID16() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x10000) >> 16
}
func (o *AIC_Type) SetIPR0_PID17(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x20000)|value<<17)
}
func (o *AIC_Type) GetIPR0_PID17() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x20000) >> 17
}
func (o *AIC_Type) SetIPR0_PID18(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x40000)|value<<18)
}
func (o *AIC_Type) GetIPR0_PID18() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x40000) >> 18
}
func (o *AIC_Type) SetIPR0_PID19(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x80000)|value<<19)
}
func (o *AIC_Type) GetIPR0_PID19() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x80000) >> 19
}
func (o *AIC_Type) SetIPR0_PID20(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x100000)|value<<20)
}
func (o *AIC_Type) GetIPR0_PID20() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x100000) >> 20
}
func (o *AIC_Type) SetIPR0_PID21(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x200000)|value<<21)
}
func (o *AIC_Type) GetIPR0_PID21() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x200000) >> 21
}
func (o *AIC_Type) SetIPR0_PID22(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x400000)|value<<22)
}
func (o *AIC_Type) GetIPR0_PID22() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x400000) >> 22
}
func (o *AIC_Type) SetIPR0_PID23(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x800000)|value<<23)
}
func (o *AIC_Type) GetIPR0_PID23() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x800000) >> 23
}
func (o *AIC_Type) SetIPR0_PID24(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x1000000)|value<<24)
}
func (o *AIC_Type) GetIPR0_PID24() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x1000000) >> 24
}
func (o *AIC_Type) SetIPR0_PID25(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x2000000)|value<<25)
}
func (o *AIC_Type) GetIPR0_PID25() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x2000000) >> 25
}
func (o *AIC_Type) SetIPR0_PID26(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x4000000)|value<<26)
}
func (o *AIC_Type) GetIPR0_PID26() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x4000000) >> 26
}
func (o *AIC_Type) SetIPR0_PID27(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x8000000)|value<<27)
}
func (o *AIC_Type) GetIPR0_PID27() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x8000000) >> 27
}
func (o *AIC_Type) SetIPR0_PID28(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x10000000)|value<<28)
}
func (o *AIC_Type) GetIPR0_PID28() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x10000000) >> 28
}
func (o *AIC_Type) SetIPR0_PID29(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x20000000)|value<<29)
}
func (o *AIC_Type) GetIPR0_PID29() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x20000000) >> 29
}
func (o *AIC_Type) SetIPR0_PID30(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x40000000)|value<<30)
}
func (o *AIC_Type) GetIPR0_PID30() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x40000000) >> 30
}
func (o *AIC_Type) SetIPR0_PID31(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0x80000000)|value<<31)
}
func (o *AIC_Type) GetIPR0_PID31() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0x80000000) >> 31
}

// AIC.IPR1: Interrupt Pending Register 1
func (o *AIC_Type) SetIPR1_PID32(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetIPR1_PID32() uint32 {
	return volatile.LoadUint32(&o.IPR1.Reg) & 0x1
}
func (o *AIC_Type) SetIPR1_PID33(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetIPR1_PID33() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x2) >> 1
}
func (o *AIC_Type) SetIPR1_PID34(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x4)|value<<2)
}
func (o *AIC_Type) GetIPR1_PID34() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x4) >> 2
}
func (o *AIC_Type) SetIPR1_PID35(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x8)|value<<3)
}
func (o *AIC_Type) GetIPR1_PID35() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x8) >> 3
}
func (o *AIC_Type) SetIPR1_PID36(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x10)|value<<4)
}
func (o *AIC_Type) GetIPR1_PID36() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x10) >> 4
}
func (o *AIC_Type) SetIPR1_PID37(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x20)|value<<5)
}
func (o *AIC_Type) GetIPR1_PID37() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x20) >> 5
}
func (o *AIC_Type) SetIPR1_PID38(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x40)|value<<6)
}
func (o *AIC_Type) GetIPR1_PID38() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x40) >> 6
}
func (o *AIC_Type) SetIPR1_PID39(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x80)|value<<7)
}
func (o *AIC_Type) GetIPR1_PID39() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x80) >> 7
}
func (o *AIC_Type) SetIPR1_PID40(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x100)|value<<8)
}
func (o *AIC_Type) GetIPR1_PID40() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x100) >> 8
}
func (o *AIC_Type) SetIPR1_PID41(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x200)|value<<9)
}
func (o *AIC_Type) GetIPR1_PID41() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x200) >> 9
}
func (o *AIC_Type) SetIPR1_PID42(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x400)|value<<10)
}
func (o *AIC_Type) GetIPR1_PID42() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x400) >> 10
}
func (o *AIC_Type) SetIPR1_PID43(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x800)|value<<11)
}
func (o *AIC_Type) GetIPR1_PID43() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x800) >> 11
}
func (o *AIC_Type) SetIPR1_PID44(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x1000)|value<<12)
}
func (o *AIC_Type) GetIPR1_PID44() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x1000) >> 12
}
func (o *AIC_Type) SetIPR1_PID45(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x2000)|value<<13)
}
func (o *AIC_Type) GetIPR1_PID45() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x2000) >> 13
}
func (o *AIC_Type) SetIPR1_PID46(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x4000)|value<<14)
}
func (o *AIC_Type) GetIPR1_PID46() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x4000) >> 14
}
func (o *AIC_Type) SetIPR1_PID47(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x8000)|value<<15)
}
func (o *AIC_Type) GetIPR1_PID47() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x8000) >> 15
}
func (o *AIC_Type) SetIPR1_PID48(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x10000)|value<<16)
}
func (o *AIC_Type) GetIPR1_PID48() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x10000) >> 16
}
func (o *AIC_Type) SetIPR1_PID49(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x20000)|value<<17)
}
func (o *AIC_Type) GetIPR1_PID49() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x20000) >> 17
}
func (o *AIC_Type) SetIPR1_PID50(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x40000)|value<<18)
}
func (o *AIC_Type) GetIPR1_PID50() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x40000) >> 18
}
func (o *AIC_Type) SetIPR1_PID51(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x80000)|value<<19)
}
func (o *AIC_Type) GetIPR1_PID51() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x80000) >> 19
}
func (o *AIC_Type) SetIPR1_PID52(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x100000)|value<<20)
}
func (o *AIC_Type) GetIPR1_PID52() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x100000) >> 20
}
func (o *AIC_Type) SetIPR1_PID53(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x200000)|value<<21)
}
func (o *AIC_Type) GetIPR1_PID53() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x200000) >> 21
}
func (o *AIC_Type) SetIPR1_PID54(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x400000)|value<<22)
}
func (o *AIC_Type) GetIPR1_PID54() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x400000) >> 22
}
func (o *AIC_Type) SetIPR1_PID55(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x800000)|value<<23)
}
func (o *AIC_Type) GetIPR1_PID55() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x800000) >> 23
}
func (o *AIC_Type) SetIPR1_PID56(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x1000000)|value<<24)
}
func (o *AIC_Type) GetIPR1_PID56() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x1000000) >> 24
}
func (o *AIC_Type) SetIPR1_PID57(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x2000000)|value<<25)
}
func (o *AIC_Type) GetIPR1_PID57() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x2000000) >> 25
}
func (o *AIC_Type) SetIPR1_PID58(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x4000000)|value<<26)
}
func (o *AIC_Type) GetIPR1_PID58() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x4000000) >> 26
}
func (o *AIC_Type) SetIPR1_PID59(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x8000000)|value<<27)
}
func (o *AIC_Type) GetIPR1_PID59() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x8000000) >> 27
}
func (o *AIC_Type) SetIPR1_PID60(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x10000000)|value<<28)
}
func (o *AIC_Type) GetIPR1_PID60() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x10000000) >> 28
}
func (o *AIC_Type) SetIPR1_PID61(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x20000000)|value<<29)
}
func (o *AIC_Type) GetIPR1_PID61() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x20000000) >> 29
}
func (o *AIC_Type) SetIPR1_PID62(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x40000000)|value<<30)
}
func (o *AIC_Type) GetIPR1_PID62() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x40000000) >> 30
}
func (o *AIC_Type) SetIPR1_PID63(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0x80000000)|value<<31)
}
func (o *AIC_Type) GetIPR1_PID63() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0x80000000) >> 31
}

// AIC.IPR2: Interrupt Pending Register 2
func (o *AIC_Type) SetIPR2_PID64(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetIPR2_PID64() uint32 {
	return volatile.LoadUint32(&o.IPR2.Reg) & 0x1
}
func (o *AIC_Type) SetIPR2_PID65(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetIPR2_PID65() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x2) >> 1
}
func (o *AIC_Type) SetIPR2_PID66(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x4)|value<<2)
}
func (o *AIC_Type) GetIPR2_PID66() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x4) >> 2
}
func (o *AIC_Type) SetIPR2_PID67(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x8)|value<<3)
}
func (o *AIC_Type) GetIPR2_PID67() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x8) >> 3
}
func (o *AIC_Type) SetIPR2_PID68(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x10)|value<<4)
}
func (o *AIC_Type) GetIPR2_PID68() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x10) >> 4
}
func (o *AIC_Type) SetIPR2_PID69(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x20)|value<<5)
}
func (o *AIC_Type) GetIPR2_PID69() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x20) >> 5
}
func (o *AIC_Type) SetIPR2_PID70(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x40)|value<<6)
}
func (o *AIC_Type) GetIPR2_PID70() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x40) >> 6
}
func (o *AIC_Type) SetIPR2_PID71(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x80)|value<<7)
}
func (o *AIC_Type) GetIPR2_PID71() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x80) >> 7
}
func (o *AIC_Type) SetIPR2_PID72(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x100)|value<<8)
}
func (o *AIC_Type) GetIPR2_PID72() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x100) >> 8
}
func (o *AIC_Type) SetIPR2_PID73(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x200)|value<<9)
}
func (o *AIC_Type) GetIPR2_PID73() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x200) >> 9
}
func (o *AIC_Type) SetIPR2_PID74(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x400)|value<<10)
}
func (o *AIC_Type) GetIPR2_PID74() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x400) >> 10
}
func (o *AIC_Type) SetIPR2_PID75(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x800)|value<<11)
}
func (o *AIC_Type) GetIPR2_PID75() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x800) >> 11
}
func (o *AIC_Type) SetIPR2_PID76(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x1000)|value<<12)
}
func (o *AIC_Type) GetIPR2_PID76() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x1000) >> 12
}
func (o *AIC_Type) SetIPR2_PID77(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x2000)|value<<13)
}
func (o *AIC_Type) GetIPR2_PID77() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x2000) >> 13
}
func (o *AIC_Type) SetIPR2_PID78(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x4000)|value<<14)
}
func (o *AIC_Type) GetIPR2_PID78() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x4000) >> 14
}
func (o *AIC_Type) SetIPR2_PID79(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x8000)|value<<15)
}
func (o *AIC_Type) GetIPR2_PID79() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x8000) >> 15
}
func (o *AIC_Type) SetIPR2_PID80(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x10000)|value<<16)
}
func (o *AIC_Type) GetIPR2_PID80() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x10000) >> 16
}
func (o *AIC_Type) SetIPR2_PID81(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x20000)|value<<17)
}
func (o *AIC_Type) GetIPR2_PID81() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x20000) >> 17
}
func (o *AIC_Type) SetIPR2_PID82(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x40000)|value<<18)
}
func (o *AIC_Type) GetIPR2_PID82() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x40000) >> 18
}
func (o *AIC_Type) SetIPR2_PID83(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x80000)|value<<19)
}
func (o *AIC_Type) GetIPR2_PID83() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x80000) >> 19
}
func (o *AIC_Type) SetIPR2_PID84(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x100000)|value<<20)
}
func (o *AIC_Type) GetIPR2_PID84() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x100000) >> 20
}
func (o *AIC_Type) SetIPR2_PID85(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x200000)|value<<21)
}
func (o *AIC_Type) GetIPR2_PID85() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x200000) >> 21
}
func (o *AIC_Type) SetIPR2_PID86(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x400000)|value<<22)
}
func (o *AIC_Type) GetIPR2_PID86() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x400000) >> 22
}
func (o *AIC_Type) SetIPR2_PID87(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x800000)|value<<23)
}
func (o *AIC_Type) GetIPR2_PID87() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x800000) >> 23
}
func (o *AIC_Type) SetIPR2_PID88(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x1000000)|value<<24)
}
func (o *AIC_Type) GetIPR2_PID88() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x1000000) >> 24
}
func (o *AIC_Type) SetIPR2_PID89(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x2000000)|value<<25)
}
func (o *AIC_Type) GetIPR2_PID89() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x2000000) >> 25
}
func (o *AIC_Type) SetIPR2_PID90(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x4000000)|value<<26)
}
func (o *AIC_Type) GetIPR2_PID90() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x4000000) >> 26
}
func (o *AIC_Type) SetIPR2_PID91(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x8000000)|value<<27)
}
func (o *AIC_Type) GetIPR2_PID91() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x8000000) >> 27
}
func (o *AIC_Type) SetIPR2_PID92(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x10000000)|value<<28)
}
func (o *AIC_Type) GetIPR2_PID92() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x10000000) >> 28
}
func (o *AIC_Type) SetIPR2_PID93(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x20000000)|value<<29)
}
func (o *AIC_Type) GetIPR2_PID93() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x20000000) >> 29
}
func (o *AIC_Type) SetIPR2_PID94(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x40000000)|value<<30)
}
func (o *AIC_Type) GetIPR2_PID94() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x40000000) >> 30
}
func (o *AIC_Type) SetIPR2_PID95(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0x80000000)|value<<31)
}
func (o *AIC_Type) GetIPR2_PID95() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0x80000000) >> 31
}

// AIC.IPR3: Interrupt Pending Register 3
func (o *AIC_Type) SetIPR3_PID96(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetIPR3_PID96() uint32 {
	return volatile.LoadUint32(&o.IPR3.Reg) & 0x1
}
func (o *AIC_Type) SetIPR3_PID97(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetIPR3_PID97() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x2) >> 1
}
func (o *AIC_Type) SetIPR3_PID98(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x4)|value<<2)
}
func (o *AIC_Type) GetIPR3_PID98() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x4) >> 2
}
func (o *AIC_Type) SetIPR3_PID99(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x8)|value<<3)
}
func (o *AIC_Type) GetIPR3_PID99() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x8) >> 3
}
func (o *AIC_Type) SetIPR3_PID100(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x10)|value<<4)
}
func (o *AIC_Type) GetIPR3_PID100() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x10) >> 4
}
func (o *AIC_Type) SetIPR3_PID101(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x20)|value<<5)
}
func (o *AIC_Type) GetIPR3_PID101() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x20) >> 5
}
func (o *AIC_Type) SetIPR3_PID102(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x40)|value<<6)
}
func (o *AIC_Type) GetIPR3_PID102() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x40) >> 6
}
func (o *AIC_Type) SetIPR3_PID103(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x80)|value<<7)
}
func (o *AIC_Type) GetIPR3_PID103() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x80) >> 7
}
func (o *AIC_Type) SetIPR3_PID104(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x100)|value<<8)
}
func (o *AIC_Type) GetIPR3_PID104() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x100) >> 8
}
func (o *AIC_Type) SetIPR3_PID105(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x200)|value<<9)
}
func (o *AIC_Type) GetIPR3_PID105() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x200) >> 9
}
func (o *AIC_Type) SetIPR3_PID106(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x400)|value<<10)
}
func (o *AIC_Type) GetIPR3_PID106() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x400) >> 10
}
func (o *AIC_Type) SetIPR3_PID107(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x800)|value<<11)
}
func (o *AIC_Type) GetIPR3_PID107() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x800) >> 11
}
func (o *AIC_Type) SetIPR3_PID108(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x1000)|value<<12)
}
func (o *AIC_Type) GetIPR3_PID108() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x1000) >> 12
}
func (o *AIC_Type) SetIPR3_PID109(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x2000)|value<<13)
}
func (o *AIC_Type) GetIPR3_PID109() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x2000) >> 13
}
func (o *AIC_Type) SetIPR3_PID110(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x4000)|value<<14)
}
func (o *AIC_Type) GetIPR3_PID110() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x4000) >> 14
}
func (o *AIC_Type) SetIPR3_PID111(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x8000)|value<<15)
}
func (o *AIC_Type) GetIPR3_PID111() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x8000) >> 15
}
func (o *AIC_Type) SetIPR3_PID112(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x10000)|value<<16)
}
func (o *AIC_Type) GetIPR3_PID112() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x10000) >> 16
}
func (o *AIC_Type) SetIPR3_PID113(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x20000)|value<<17)
}
func (o *AIC_Type) GetIPR3_PID113() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x20000) >> 17
}
func (o *AIC_Type) SetIPR3_PID114(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x40000)|value<<18)
}
func (o *AIC_Type) GetIPR3_PID114() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x40000) >> 18
}
func (o *AIC_Type) SetIPR3_PID115(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x80000)|value<<19)
}
func (o *AIC_Type) GetIPR3_PID115() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x80000) >> 19
}
func (o *AIC_Type) SetIPR3_PID116(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x100000)|value<<20)
}
func (o *AIC_Type) GetIPR3_PID116() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x100000) >> 20
}
func (o *AIC_Type) SetIPR3_PID117(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x200000)|value<<21)
}
func (o *AIC_Type) GetIPR3_PID117() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x200000) >> 21
}
func (o *AIC_Type) SetIPR3_PID118(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x400000)|value<<22)
}
func (o *AIC_Type) GetIPR3_PID118() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x400000) >> 22
}
func (o *AIC_Type) SetIPR3_PID119(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x800000)|value<<23)
}
func (o *AIC_Type) GetIPR3_PID119() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x800000) >> 23
}
func (o *AIC_Type) SetIPR3_PID120(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x1000000)|value<<24)
}
func (o *AIC_Type) GetIPR3_PID120() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x1000000) >> 24
}
func (o *AIC_Type) SetIPR3_PID121(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x2000000)|value<<25)
}
func (o *AIC_Type) GetIPR3_PID121() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x2000000) >> 25
}
func (o *AIC_Type) SetIPR3_PID122(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x4000000)|value<<26)
}
func (o *AIC_Type) GetIPR3_PID122() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x4000000) >> 26
}
func (o *AIC_Type) SetIPR3_PID123(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x8000000)|value<<27)
}
func (o *AIC_Type) GetIPR3_PID123() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x8000000) >> 27
}
func (o *AIC_Type) SetIPR3_PID124(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x10000000)|value<<28)
}
func (o *AIC_Type) GetIPR3_PID124() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x10000000) >> 28
}
func (o *AIC_Type) SetIPR3_PID125(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x20000000)|value<<29)
}
func (o *AIC_Type) GetIPR3_PID125() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x20000000) >> 29
}
func (o *AIC_Type) SetIPR3_PID126(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x40000000)|value<<30)
}
func (o *AIC_Type) GetIPR3_PID126() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x40000000) >> 30
}
func (o *AIC_Type) SetIPR3_PID127(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0x80000000)|value<<31)
}
func (o *AIC_Type) GetIPR3_PID127() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0x80000000) >> 31
}

// AIC.IMR: Interrupt Mask Register
func (o *AIC_Type) SetIMR_INTM(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetIMR_INTM() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}

// AIC.CISR: Core Interrupt Status Register
func (o *AIC_Type) SetCISR_NFIQ(value uint32) {
	volatile.StoreUint32(&o.CISR.Reg, volatile.LoadUint32(&o.CISR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetCISR_NFIQ() uint32 {
	return volatile.LoadUint32(&o.CISR.Reg) & 0x1
}
func (o *AIC_Type) SetCISR_NIRQ(value uint32) {
	volatile.StoreUint32(&o.CISR.Reg, volatile.LoadUint32(&o.CISR.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetCISR_NIRQ() uint32 {
	return (volatile.LoadUint32(&o.CISR.Reg) & 0x2) >> 1
}

// AIC.EOICR: End of Interrupt Command Register
func (o *AIC_Type) SetEOICR_ENDIT(value uint32) {
	volatile.StoreUint32(&o.EOICR.Reg, volatile.LoadUint32(&o.EOICR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetEOICR_ENDIT() uint32 {
	return volatile.LoadUint32(&o.EOICR.Reg) & 0x1
}

// AIC.SPU: Spurious Interrupt Vector Register
func (o *AIC_Type) SetSPU(value uint32) {
	volatile.StoreUint32(&o.SPU.Reg, value)
}
func (o *AIC_Type) GetSPU() uint32 {
	return volatile.LoadUint32(&o.SPU.Reg)
}

// AIC.IECR: Interrupt Enable Command Register
func (o *AIC_Type) SetIECR_INTEN(value uint32) {
	volatile.StoreUint32(&o.IECR.Reg, volatile.LoadUint32(&o.IECR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetIECR_INTEN() uint32 {
	return volatile.LoadUint32(&o.IECR.Reg) & 0x1
}

// AIC.IDCR: Interrupt Disable Command Register
func (o *AIC_Type) SetIDCR_INTD(value uint32) {
	volatile.StoreUint32(&o.IDCR.Reg, volatile.LoadUint32(&o.IDCR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetIDCR_INTD() uint32 {
	return volatile.LoadUint32(&o.IDCR.Reg) & 0x1
}

// AIC.ICCR: Interrupt Clear Command Register
func (o *AIC_Type) SetICCR_INTCLR(value uint32) {
	volatile.StoreUint32(&o.ICCR.Reg, volatile.LoadUint32(&o.ICCR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetICCR_INTCLR() uint32 {
	return volatile.LoadUint32(&o.ICCR.Reg) & 0x1
}

// AIC.ISCR: Interrupt Set Command Register
func (o *AIC_Type) SetISCR_INTSET(value uint32) {
	volatile.StoreUint32(&o.ISCR.Reg, volatile.LoadUint32(&o.ISCR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetISCR_INTSET() uint32 {
	return volatile.LoadUint32(&o.ISCR.Reg) & 0x1
}

// AIC.FFER: Fast Forcing Enable Register
func (o *AIC_Type) SetFFER_FFEN(value uint32) {
	volatile.StoreUint32(&o.FFER.Reg, volatile.LoadUint32(&o.FFER.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetFFER_FFEN() uint32 {
	return volatile.LoadUint32(&o.FFER.Reg) & 0x1
}

// AIC.FFDR: Fast Forcing Disable Register
func (o *AIC_Type) SetFFDR_FFDIS(value uint32) {
	volatile.StoreUint32(&o.FFDR.Reg, volatile.LoadUint32(&o.FFDR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetFFDR_FFDIS() uint32 {
	return volatile.LoadUint32(&o.FFDR.Reg) & 0x1
}

// AIC.FFSR: Fast Forcing Status Register
func (o *AIC_Type) SetFFSR_FFS(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetFFSR_FFS() uint32 {
	return volatile.LoadUint32(&o.FFSR.Reg) & 0x1
}

// AIC.DCR: Debug Control Register
func (o *AIC_Type) SetDCR_PROT(value uint32) {
	volatile.StoreUint32(&o.DCR.Reg, volatile.LoadUint32(&o.DCR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetDCR_PROT() uint32 {
	return volatile.LoadUint32(&o.DCR.Reg) & 0x1
}
func (o *AIC_Type) SetDCR_GMSK(value uint32) {
	volatile.StoreUint32(&o.DCR.Reg, volatile.LoadUint32(&o.DCR.Reg)&^(0x2)|value<<1)
}
func (o *AIC_Type) GetDCR_GMSK() uint32 {
	return (volatile.LoadUint32(&o.DCR.Reg) & 0x2) >> 1
}

// AIC.WPMR: Write Protect Mode Register
func (o *AIC_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *AIC_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *AIC_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// AIC.WPSR: Write Protect Status Register
func (o *AIC_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *AIC_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *AIC_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *AIC_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// Parallel Input/Output Controller A
type PIO_Type struct {
	PER     volatile.Register32 // 0x0
	PDR     volatile.Register32 // 0x4
	PSR     volatile.Register32 // 0x8
	_       [4]byte
	OER     volatile.Register32 // 0x10
	ODR     volatile.Register32 // 0x14
	OSR     volatile.Register32 // 0x18
	_       [4]byte
	IFER    volatile.Register32 // 0x20
	IFDR    volatile.Register32 // 0x24
	IFSR    volatile.Register32 // 0x28
	_       [4]byte
	SODR    volatile.Register32 // 0x30
	CODR    volatile.Register32 // 0x34
	ODSR    volatile.Register32 // 0x38
	PDSR    volatile.Register32 // 0x3C
	IER     volatile.Register32 // 0x40
	IDR     volatile.Register32 // 0x44
	IMR     volatile.Register32 // 0x48
	ISR     volatile.Register32 // 0x4C
	MDER    volatile.Register32 // 0x50
	MDDR    volatile.Register32 // 0x54
	MDSR    volatile.Register32 // 0x58
	_       [4]byte
	PUDR    volatile.Register32 // 0x60
	PUER    volatile.Register32 // 0x64
	PUSR    volatile.Register32 // 0x68
	_       [4]byte
	ABCDSR  [2]volatile.Register32 // 0x70
	_       [8]byte
	IFSCDR  volatile.Register32 // 0x80
	IFSCER  volatile.Register32 // 0x84
	IFSCSR  volatile.Register32 // 0x88
	SCDR    volatile.Register32 // 0x8C
	PPDDR   volatile.Register32 // 0x90
	PPDER   volatile.Register32 // 0x94
	PPDSR   volatile.Register32 // 0x98
	_       [4]byte
	OWER    volatile.Register32 // 0xA0
	OWDR    volatile.Register32 // 0xA4
	OWSR    volatile.Register32 // 0xA8
	_       [4]byte
	AIMER   volatile.Register32 // 0xB0
	AIMDR   volatile.Register32 // 0xB4
	AIMMR   volatile.Register32 // 0xB8
	_       [4]byte
	ESR     volatile.Register32 // 0xC0
	LSR     volatile.Register32 // 0xC4
	ELSR    volatile.Register32 // 0xC8
	_       [4]byte
	FELLSR  volatile.Register32 // 0xD0
	REHLSR  volatile.Register32 // 0xD4
	FRLHSR  volatile.Register32 // 0xD8
	_       [4]byte
	LOCKSR  volatile.Register32 // 0xE0
	WPMR    volatile.Register32 // 0xE4
	WPSR    volatile.Register32 // 0xE8
	_       [20]byte
	SCHMITT volatile.Register32 // 0x100
	_       [20]byte
	DRIVER1 volatile.Register32 // 0x118
	DRIVER2 volatile.Register32 // 0x11C
}

// PIO.PER: PIO Enable Register
func (o *PIO_Type) SetPER_P0(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPER_P0() uint32 {
	return volatile.LoadUint32(&o.PER.Reg) & 0x1
}
func (o *PIO_Type) SetPER_P1(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPER_P1() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPER_P2(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPER_P2() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPER_P3(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPER_P3() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPER_P4(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPER_P4() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPER_P5(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPER_P5() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPER_P6(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPER_P6() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPER_P7(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPER_P7() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPER_P8(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPER_P8() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPER_P9(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPER_P9() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPER_P10(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPER_P10() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPER_P11(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPER_P11() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPER_P12(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPER_P12() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPER_P13(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPER_P13() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPER_P14(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPER_P14() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPER_P15(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPER_P15() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPER_P16(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPER_P16() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPER_P17(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPER_P17() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPER_P18(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPER_P18() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPER_P19(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPER_P19() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPER_P20(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPER_P20() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPER_P21(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPER_P21() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPER_P22(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPER_P22() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPER_P23(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPER_P23() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPER_P24(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPER_P24() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPER_P25(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPER_P25() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPER_P26(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPER_P26() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPER_P27(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPER_P27() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPER_P28(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPER_P28() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPER_P29(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPER_P29() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPER_P30(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPER_P30() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPER_P31(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPER_P31() uint32 {
	return (volatile.LoadUint32(&o.PER.Reg) & 0x80000000) >> 31
}

// PIO.PDR: PIO Disable Register
func (o *PIO_Type) SetPDR_P0(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPDR_P0() uint32 {
	return volatile.LoadUint32(&o.PDR.Reg) & 0x1
}
func (o *PIO_Type) SetPDR_P1(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPDR_P1() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPDR_P2(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPDR_P2() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPDR_P3(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPDR_P3() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPDR_P4(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPDR_P4() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPDR_P5(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPDR_P5() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPDR_P6(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPDR_P6() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPDR_P7(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPDR_P7() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPDR_P8(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPDR_P8() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPDR_P9(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPDR_P9() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPDR_P10(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPDR_P10() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPDR_P11(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPDR_P11() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPDR_P12(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPDR_P12() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPDR_P13(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPDR_P13() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPDR_P14(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPDR_P14() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPDR_P15(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPDR_P15() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPDR_P16(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPDR_P16() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPDR_P17(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPDR_P17() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPDR_P18(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPDR_P18() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPDR_P19(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPDR_P19() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPDR_P20(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPDR_P20() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPDR_P21(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPDR_P21() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPDR_P22(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPDR_P22() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPDR_P23(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPDR_P23() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPDR_P24(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPDR_P24() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPDR_P25(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPDR_P25() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPDR_P26(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPDR_P26() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPDR_P27(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPDR_P27() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPDR_P28(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPDR_P28() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPDR_P29(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPDR_P29() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPDR_P30(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPDR_P30() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPDR_P31(value uint32) {
	volatile.StoreUint32(&o.PDR.Reg, volatile.LoadUint32(&o.PDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPDR_P31() uint32 {
	return (volatile.LoadUint32(&o.PDR.Reg) & 0x80000000) >> 31
}

// PIO.PSR: PIO Status Register
func (o *PIO_Type) SetPSR_P0(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPSR_P0() uint32 {
	return volatile.LoadUint32(&o.PSR.Reg) & 0x1
}
func (o *PIO_Type) SetPSR_P1(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPSR_P1() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPSR_P2(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPSR_P2() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPSR_P3(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPSR_P3() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPSR_P4(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPSR_P4() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPSR_P5(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPSR_P5() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPSR_P6(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPSR_P6() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPSR_P7(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPSR_P7() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPSR_P8(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPSR_P8() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPSR_P9(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPSR_P9() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPSR_P10(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPSR_P10() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPSR_P11(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPSR_P11() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPSR_P12(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPSR_P12() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPSR_P13(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPSR_P13() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPSR_P14(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPSR_P14() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPSR_P15(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPSR_P15() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPSR_P16(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPSR_P16() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPSR_P17(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPSR_P17() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPSR_P18(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPSR_P18() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPSR_P19(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPSR_P19() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPSR_P20(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPSR_P20() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPSR_P21(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPSR_P21() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPSR_P22(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPSR_P22() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPSR_P23(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPSR_P23() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPSR_P24(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPSR_P24() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPSR_P25(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPSR_P25() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPSR_P26(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPSR_P26() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPSR_P27(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPSR_P27() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPSR_P28(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPSR_P28() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPSR_P29(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPSR_P29() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPSR_P30(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPSR_P30() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPSR_P31(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPSR_P31() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x80000000) >> 31
}

// PIO.OER: Output Enable Register
func (o *PIO_Type) SetOER_P0(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetOER_P0() uint32 {
	return volatile.LoadUint32(&o.OER.Reg) & 0x1
}
func (o *PIO_Type) SetOER_P1(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetOER_P1() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetOER_P2(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetOER_P2() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetOER_P3(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetOER_P3() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetOER_P4(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetOER_P4() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetOER_P5(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetOER_P5() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetOER_P6(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetOER_P6() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetOER_P7(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetOER_P7() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetOER_P8(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetOER_P8() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetOER_P9(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetOER_P9() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetOER_P10(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetOER_P10() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetOER_P11(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetOER_P11() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetOER_P12(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetOER_P12() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetOER_P13(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetOER_P13() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetOER_P14(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetOER_P14() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetOER_P15(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetOER_P15() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetOER_P16(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetOER_P16() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetOER_P17(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetOER_P17() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetOER_P18(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetOER_P18() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetOER_P19(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetOER_P19() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetOER_P20(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetOER_P20() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetOER_P21(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetOER_P21() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetOER_P22(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetOER_P22() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetOER_P23(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetOER_P23() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetOER_P24(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetOER_P24() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetOER_P25(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetOER_P25() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetOER_P26(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetOER_P26() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetOER_P27(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetOER_P27() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetOER_P28(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetOER_P28() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetOER_P29(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetOER_P29() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetOER_P30(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetOER_P30() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetOER_P31(value uint32) {
	volatile.StoreUint32(&o.OER.Reg, volatile.LoadUint32(&o.OER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetOER_P31() uint32 {
	return (volatile.LoadUint32(&o.OER.Reg) & 0x80000000) >> 31
}

// PIO.ODR: Output Disable Register
func (o *PIO_Type) SetODR_P0(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetODR_P0() uint32 {
	return volatile.LoadUint32(&o.ODR.Reg) & 0x1
}
func (o *PIO_Type) SetODR_P1(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetODR_P1() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetODR_P2(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetODR_P2() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetODR_P3(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetODR_P3() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetODR_P4(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetODR_P4() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetODR_P5(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetODR_P5() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetODR_P6(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetODR_P6() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetODR_P7(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetODR_P7() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetODR_P8(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetODR_P8() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetODR_P9(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetODR_P9() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetODR_P10(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetODR_P10() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetODR_P11(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetODR_P11() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetODR_P12(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetODR_P12() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetODR_P13(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetODR_P13() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetODR_P14(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetODR_P14() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetODR_P15(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetODR_P15() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetODR_P16(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetODR_P16() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetODR_P17(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetODR_P17() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetODR_P18(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetODR_P18() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetODR_P19(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetODR_P19() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetODR_P20(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetODR_P20() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetODR_P21(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetODR_P21() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetODR_P22(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetODR_P22() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetODR_P23(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetODR_P23() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetODR_P24(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetODR_P24() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetODR_P25(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetODR_P25() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetODR_P26(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetODR_P26() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetODR_P27(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetODR_P27() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetODR_P28(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetODR_P28() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetODR_P29(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetODR_P29() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetODR_P30(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetODR_P30() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetODR_P31(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetODR_P31() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x80000000) >> 31
}

// PIO.OSR: Output Status Register
func (o *PIO_Type) SetOSR_P0(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetOSR_P0() uint32 {
	return volatile.LoadUint32(&o.OSR.Reg) & 0x1
}
func (o *PIO_Type) SetOSR_P1(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetOSR_P1() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetOSR_P2(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetOSR_P2() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetOSR_P3(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetOSR_P3() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetOSR_P4(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetOSR_P4() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetOSR_P5(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetOSR_P5() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetOSR_P6(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetOSR_P6() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetOSR_P7(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetOSR_P7() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetOSR_P8(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetOSR_P8() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetOSR_P9(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetOSR_P9() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetOSR_P10(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetOSR_P10() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetOSR_P11(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetOSR_P11() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetOSR_P12(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetOSR_P12() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetOSR_P13(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetOSR_P13() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetOSR_P14(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetOSR_P14() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetOSR_P15(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetOSR_P15() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetOSR_P16(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetOSR_P16() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetOSR_P17(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetOSR_P17() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetOSR_P18(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetOSR_P18() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetOSR_P19(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetOSR_P19() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetOSR_P20(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetOSR_P20() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetOSR_P21(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetOSR_P21() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetOSR_P22(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetOSR_P22() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetOSR_P23(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetOSR_P23() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetOSR_P24(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetOSR_P24() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetOSR_P25(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetOSR_P25() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetOSR_P26(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetOSR_P26() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetOSR_P27(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetOSR_P27() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetOSR_P28(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetOSR_P28() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetOSR_P29(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetOSR_P29() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetOSR_P30(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetOSR_P30() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetOSR_P31(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetOSR_P31() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x80000000) >> 31
}

// PIO.IFER: Glitch Input Filter Enable Register
func (o *PIO_Type) SetIFER_P0(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIFER_P0() uint32 {
	return volatile.LoadUint32(&o.IFER.Reg) & 0x1
}
func (o *PIO_Type) SetIFER_P1(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIFER_P1() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIFER_P2(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIFER_P2() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIFER_P3(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIFER_P3() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIFER_P4(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIFER_P4() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIFER_P5(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIFER_P5() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIFER_P6(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIFER_P6() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIFER_P7(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIFER_P7() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIFER_P8(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIFER_P8() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIFER_P9(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIFER_P9() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIFER_P10(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIFER_P10() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIFER_P11(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIFER_P11() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIFER_P12(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIFER_P12() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIFER_P13(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIFER_P13() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIFER_P14(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIFER_P14() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIFER_P15(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIFER_P15() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIFER_P16(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIFER_P16() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIFER_P17(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIFER_P17() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIFER_P18(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIFER_P18() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIFER_P19(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIFER_P19() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIFER_P20(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIFER_P20() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIFER_P21(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIFER_P21() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIFER_P22(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIFER_P22() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIFER_P23(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIFER_P23() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIFER_P24(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIFER_P24() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIFER_P25(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIFER_P25() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIFER_P26(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIFER_P26() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIFER_P27(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIFER_P27() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIFER_P28(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIFER_P28() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIFER_P29(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIFER_P29() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIFER_P30(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIFER_P30() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIFER_P31(value uint32) {
	volatile.StoreUint32(&o.IFER.Reg, volatile.LoadUint32(&o.IFER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIFER_P31() uint32 {
	return (volatile.LoadUint32(&o.IFER.Reg) & 0x80000000) >> 31
}

// PIO.IFDR: Glitch Input Filter Disable Register
func (o *PIO_Type) SetIFDR_P0(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIFDR_P0() uint32 {
	return volatile.LoadUint32(&o.IFDR.Reg) & 0x1
}
func (o *PIO_Type) SetIFDR_P1(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIFDR_P1() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIFDR_P2(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIFDR_P2() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIFDR_P3(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIFDR_P3() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIFDR_P4(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIFDR_P4() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIFDR_P5(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIFDR_P5() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIFDR_P6(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIFDR_P6() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIFDR_P7(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIFDR_P7() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIFDR_P8(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIFDR_P8() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIFDR_P9(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIFDR_P9() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIFDR_P10(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIFDR_P10() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIFDR_P11(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIFDR_P11() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIFDR_P12(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIFDR_P12() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIFDR_P13(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIFDR_P13() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIFDR_P14(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIFDR_P14() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIFDR_P15(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIFDR_P15() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIFDR_P16(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIFDR_P16() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIFDR_P17(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIFDR_P17() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIFDR_P18(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIFDR_P18() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIFDR_P19(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIFDR_P19() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIFDR_P20(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIFDR_P20() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIFDR_P21(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIFDR_P21() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIFDR_P22(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIFDR_P22() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIFDR_P23(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIFDR_P23() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIFDR_P24(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIFDR_P24() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIFDR_P25(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIFDR_P25() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIFDR_P26(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIFDR_P26() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIFDR_P27(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIFDR_P27() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIFDR_P28(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIFDR_P28() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIFDR_P29(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIFDR_P29() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIFDR_P30(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIFDR_P30() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIFDR_P31(value uint32) {
	volatile.StoreUint32(&o.IFDR.Reg, volatile.LoadUint32(&o.IFDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIFDR_P31() uint32 {
	return (volatile.LoadUint32(&o.IFDR.Reg) & 0x80000000) >> 31
}

// PIO.IFSR: Glitch Input Filter Status Register
func (o *PIO_Type) SetIFSR_P0(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIFSR_P0() uint32 {
	return volatile.LoadUint32(&o.IFSR.Reg) & 0x1
}
func (o *PIO_Type) SetIFSR_P1(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIFSR_P1() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIFSR_P2(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIFSR_P2() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIFSR_P3(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIFSR_P3() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIFSR_P4(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIFSR_P4() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIFSR_P5(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIFSR_P5() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIFSR_P6(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIFSR_P6() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIFSR_P7(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIFSR_P7() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIFSR_P8(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIFSR_P8() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIFSR_P9(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIFSR_P9() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIFSR_P10(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIFSR_P10() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIFSR_P11(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIFSR_P11() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIFSR_P12(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIFSR_P12() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIFSR_P13(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIFSR_P13() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIFSR_P14(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIFSR_P14() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIFSR_P15(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIFSR_P15() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIFSR_P16(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIFSR_P16() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIFSR_P17(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIFSR_P17() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIFSR_P18(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIFSR_P18() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIFSR_P19(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIFSR_P19() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIFSR_P20(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIFSR_P20() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIFSR_P21(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIFSR_P21() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIFSR_P22(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIFSR_P22() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIFSR_P23(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIFSR_P23() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIFSR_P24(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIFSR_P24() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIFSR_P25(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIFSR_P25() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIFSR_P26(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIFSR_P26() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIFSR_P27(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIFSR_P27() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIFSR_P28(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIFSR_P28() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIFSR_P29(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIFSR_P29() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIFSR_P30(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIFSR_P30() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIFSR_P31(value uint32) {
	volatile.StoreUint32(&o.IFSR.Reg, volatile.LoadUint32(&o.IFSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIFSR_P31() uint32 {
	return (volatile.LoadUint32(&o.IFSR.Reg) & 0x80000000) >> 31
}

// PIO.SODR: Set Output Data Register
func (o *PIO_Type) SetSODR_P0(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetSODR_P0() uint32 {
	return volatile.LoadUint32(&o.SODR.Reg) & 0x1
}
func (o *PIO_Type) SetSODR_P1(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetSODR_P1() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetSODR_P2(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetSODR_P2() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetSODR_P3(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetSODR_P3() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetSODR_P4(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetSODR_P4() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetSODR_P5(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetSODR_P5() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetSODR_P6(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetSODR_P6() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetSODR_P7(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetSODR_P7() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetSODR_P8(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetSODR_P8() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetSODR_P9(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetSODR_P9() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetSODR_P10(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetSODR_P10() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetSODR_P11(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetSODR_P11() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetSODR_P12(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetSODR_P12() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetSODR_P13(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetSODR_P13() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetSODR_P14(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetSODR_P14() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetSODR_P15(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetSODR_P15() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetSODR_P16(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetSODR_P16() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetSODR_P17(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetSODR_P17() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetSODR_P18(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetSODR_P18() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetSODR_P19(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetSODR_P19() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetSODR_P20(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetSODR_P20() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetSODR_P21(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetSODR_P21() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetSODR_P22(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetSODR_P22() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetSODR_P23(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetSODR_P23() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetSODR_P24(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetSODR_P24() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetSODR_P25(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetSODR_P25() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetSODR_P26(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetSODR_P26() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetSODR_P27(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetSODR_P27() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetSODR_P28(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetSODR_P28() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetSODR_P29(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetSODR_P29() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetSODR_P30(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetSODR_P30() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetSODR_P31(value uint32) {
	volatile.StoreUint32(&o.SODR.Reg, volatile.LoadUint32(&o.SODR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetSODR_P31() uint32 {
	return (volatile.LoadUint32(&o.SODR.Reg) & 0x80000000) >> 31
}

// PIO.CODR: Clear Output Data Register
func (o *PIO_Type) SetCODR_P0(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetCODR_P0() uint32 {
	return volatile.LoadUint32(&o.CODR.Reg) & 0x1
}
func (o *PIO_Type) SetCODR_P1(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetCODR_P1() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetCODR_P2(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetCODR_P2() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetCODR_P3(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetCODR_P3() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetCODR_P4(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetCODR_P4() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetCODR_P5(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetCODR_P5() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetCODR_P6(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetCODR_P6() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetCODR_P7(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetCODR_P7() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetCODR_P8(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetCODR_P8() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetCODR_P9(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetCODR_P9() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetCODR_P10(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetCODR_P10() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetCODR_P11(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetCODR_P11() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetCODR_P12(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetCODR_P12() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetCODR_P13(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetCODR_P13() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetCODR_P14(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetCODR_P14() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetCODR_P15(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetCODR_P15() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetCODR_P16(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetCODR_P16() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetCODR_P17(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetCODR_P17() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetCODR_P18(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetCODR_P18() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetCODR_P19(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetCODR_P19() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetCODR_P20(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetCODR_P20() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetCODR_P21(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetCODR_P21() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetCODR_P22(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetCODR_P22() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetCODR_P23(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetCODR_P23() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetCODR_P24(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetCODR_P24() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetCODR_P25(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetCODR_P25() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetCODR_P26(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetCODR_P26() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetCODR_P27(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetCODR_P27() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetCODR_P28(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetCODR_P28() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetCODR_P29(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetCODR_P29() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetCODR_P30(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetCODR_P30() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetCODR_P31(value uint32) {
	volatile.StoreUint32(&o.CODR.Reg, volatile.LoadUint32(&o.CODR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetCODR_P31() uint32 {
	return (volatile.LoadUint32(&o.CODR.Reg) & 0x80000000) >> 31
}

// PIO.ODSR: Output Data Status Register
func (o *PIO_Type) SetODSR_P0(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetODSR_P0() uint32 {
	return volatile.LoadUint32(&o.ODSR.Reg) & 0x1
}
func (o *PIO_Type) SetODSR_P1(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetODSR_P1() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetODSR_P2(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetODSR_P2() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetODSR_P3(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetODSR_P3() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetODSR_P4(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetODSR_P4() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetODSR_P5(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetODSR_P5() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetODSR_P6(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetODSR_P6() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetODSR_P7(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetODSR_P7() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetODSR_P8(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetODSR_P8() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetODSR_P9(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetODSR_P9() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetODSR_P10(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetODSR_P10() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetODSR_P11(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetODSR_P11() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetODSR_P12(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetODSR_P12() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetODSR_P13(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetODSR_P13() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetODSR_P14(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetODSR_P14() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetODSR_P15(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetODSR_P15() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetODSR_P16(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetODSR_P16() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetODSR_P17(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetODSR_P17() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetODSR_P18(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetODSR_P18() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetODSR_P19(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetODSR_P19() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetODSR_P20(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetODSR_P20() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetODSR_P21(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetODSR_P21() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetODSR_P22(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetODSR_P22() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetODSR_P23(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetODSR_P23() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetODSR_P24(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetODSR_P24() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetODSR_P25(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetODSR_P25() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetODSR_P26(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetODSR_P26() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetODSR_P27(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetODSR_P27() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetODSR_P28(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetODSR_P28() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetODSR_P29(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetODSR_P29() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetODSR_P30(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetODSR_P30() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetODSR_P31(value uint32) {
	volatile.StoreUint32(&o.ODSR.Reg, volatile.LoadUint32(&o.ODSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetODSR_P31() uint32 {
	return (volatile.LoadUint32(&o.ODSR.Reg) & 0x80000000) >> 31
}

// PIO.PDSR: Pin Data Status Register
func (o *PIO_Type) SetPDSR_P0(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPDSR_P0() uint32 {
	return volatile.LoadUint32(&o.PDSR.Reg) & 0x1
}
func (o *PIO_Type) SetPDSR_P1(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPDSR_P1() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPDSR_P2(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPDSR_P2() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPDSR_P3(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPDSR_P3() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPDSR_P4(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPDSR_P4() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPDSR_P5(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPDSR_P5() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPDSR_P6(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPDSR_P6() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPDSR_P7(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPDSR_P7() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPDSR_P8(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPDSR_P8() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPDSR_P9(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPDSR_P9() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPDSR_P10(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPDSR_P10() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPDSR_P11(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPDSR_P11() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPDSR_P12(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPDSR_P12() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPDSR_P13(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPDSR_P13() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPDSR_P14(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPDSR_P14() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPDSR_P15(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPDSR_P15() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPDSR_P16(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPDSR_P16() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPDSR_P17(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPDSR_P17() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPDSR_P18(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPDSR_P18() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPDSR_P19(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPDSR_P19() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPDSR_P20(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPDSR_P20() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPDSR_P21(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPDSR_P21() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPDSR_P22(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPDSR_P22() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPDSR_P23(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPDSR_P23() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPDSR_P24(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPDSR_P24() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPDSR_P25(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPDSR_P25() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPDSR_P26(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPDSR_P26() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPDSR_P27(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPDSR_P27() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPDSR_P28(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPDSR_P28() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPDSR_P29(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPDSR_P29() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPDSR_P30(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPDSR_P30() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPDSR_P31(value uint32) {
	volatile.StoreUint32(&o.PDSR.Reg, volatile.LoadUint32(&o.PDSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPDSR_P31() uint32 {
	return (volatile.LoadUint32(&o.PDSR.Reg) & 0x80000000) >> 31
}

// PIO.IER: Interrupt Enable Register
func (o *PIO_Type) SetIER_P0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIER_P0() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *PIO_Type) SetIER_P1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIER_P1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIER_P2(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIER_P2() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIER_P3(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIER_P3() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIER_P4(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIER_P4() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIER_P5(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIER_P5() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIER_P6(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIER_P6() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIER_P7(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIER_P7() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIER_P8(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIER_P8() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIER_P9(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIER_P9() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIER_P10(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIER_P10() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIER_P11(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIER_P11() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIER_P12(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIER_P12() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIER_P13(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIER_P13() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIER_P14(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIER_P14() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIER_P15(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIER_P15() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIER_P16(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIER_P16() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIER_P17(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIER_P17() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIER_P18(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIER_P18() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIER_P19(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIER_P19() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIER_P20(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIER_P20() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIER_P21(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIER_P21() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIER_P22(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIER_P22() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIER_P23(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIER_P23() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIER_P24(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIER_P24() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIER_P25(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIER_P25() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIER_P26(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIER_P26() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIER_P27(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIER_P27() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIER_P28(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIER_P28() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIER_P29(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIER_P29() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIER_P30(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIER_P30() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIER_P31(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIER_P31() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000000) >> 31
}

// PIO.IDR: Interrupt Disable Register
func (o *PIO_Type) SetIDR_P0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIDR_P0() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *PIO_Type) SetIDR_P1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIDR_P1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIDR_P2(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIDR_P2() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIDR_P3(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIDR_P3() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIDR_P4(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIDR_P4() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIDR_P5(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIDR_P5() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIDR_P6(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIDR_P6() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIDR_P7(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIDR_P7() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIDR_P8(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIDR_P8() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIDR_P9(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIDR_P9() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIDR_P10(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIDR_P10() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIDR_P11(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIDR_P11() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIDR_P12(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIDR_P12() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIDR_P13(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIDR_P13() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIDR_P14(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIDR_P14() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIDR_P15(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIDR_P15() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIDR_P16(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIDR_P16() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIDR_P17(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIDR_P17() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIDR_P18(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIDR_P18() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIDR_P19(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIDR_P19() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIDR_P20(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIDR_P20() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIDR_P21(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIDR_P21() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIDR_P22(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIDR_P22() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIDR_P23(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIDR_P23() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIDR_P24(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIDR_P24() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIDR_P25(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIDR_P25() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIDR_P26(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIDR_P26() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIDR_P27(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIDR_P27() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIDR_P28(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIDR_P28() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIDR_P29(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIDR_P29() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIDR_P30(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIDR_P30() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIDR_P31(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIDR_P31() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000000) >> 31
}

// PIO.IMR: Interrupt Mask Register
func (o *PIO_Type) SetIMR_P0(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIMR_P0() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *PIO_Type) SetIMR_P1(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIMR_P1() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIMR_P2(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIMR_P2() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIMR_P3(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIMR_P3() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIMR_P4(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIMR_P4() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIMR_P5(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIMR_P5() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIMR_P6(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIMR_P6() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIMR_P7(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIMR_P7() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIMR_P8(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIMR_P8() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIMR_P9(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIMR_P9() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIMR_P10(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIMR_P10() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIMR_P11(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIMR_P11() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIMR_P12(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIMR_P12() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIMR_P13(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIMR_P13() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIMR_P14(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIMR_P14() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIMR_P15(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIMR_P15() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIMR_P16(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIMR_P16() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIMR_P17(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIMR_P17() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIMR_P18(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIMR_P18() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIMR_P19(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIMR_P19() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIMR_P20(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIMR_P20() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIMR_P21(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIMR_P21() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIMR_P22(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIMR_P22() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIMR_P23(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIMR_P23() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIMR_P24(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIMR_P24() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIMR_P25(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIMR_P25() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIMR_P26(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIMR_P26() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIMR_P27(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIMR_P27() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIMR_P28(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIMR_P28() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIMR_P29(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIMR_P29() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIMR_P30(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIMR_P30() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIMR_P31(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIMR_P31() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000000) >> 31
}

// PIO.ISR: Interrupt Status Register
func (o *PIO_Type) SetISR_P0(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetISR_P0() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *PIO_Type) SetISR_P1(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetISR_P1() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetISR_P2(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetISR_P2() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetISR_P3(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetISR_P3() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetISR_P4(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetISR_P4() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetISR_P5(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetISR_P5() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetISR_P6(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetISR_P6() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetISR_P7(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetISR_P7() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetISR_P8(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetISR_P8() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetISR_P9(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetISR_P9() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetISR_P10(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetISR_P10() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetISR_P11(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetISR_P11() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetISR_P12(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetISR_P12() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetISR_P13(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetISR_P13() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetISR_P14(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetISR_P14() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetISR_P15(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetISR_P15() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetISR_P16(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetISR_P16() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetISR_P17(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetISR_P17() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetISR_P18(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetISR_P18() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetISR_P19(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetISR_P19() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetISR_P20(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetISR_P20() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetISR_P21(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetISR_P21() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetISR_P22(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetISR_P22() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetISR_P23(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetISR_P23() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetISR_P24(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetISR_P24() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetISR_P25(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetISR_P25() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetISR_P26(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetISR_P26() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetISR_P27(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetISR_P27() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetISR_P28(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetISR_P28() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetISR_P29(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetISR_P29() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetISR_P30(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetISR_P30() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetISR_P31(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetISR_P31() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000000) >> 31
}

// PIO.MDER: Multi-driver Enable Register
func (o *PIO_Type) SetMDER_P0(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetMDER_P0() uint32 {
	return volatile.LoadUint32(&o.MDER.Reg) & 0x1
}
func (o *PIO_Type) SetMDER_P1(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetMDER_P1() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetMDER_P2(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetMDER_P2() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetMDER_P3(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetMDER_P3() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetMDER_P4(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetMDER_P4() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetMDER_P5(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetMDER_P5() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetMDER_P6(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetMDER_P6() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetMDER_P7(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetMDER_P7() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetMDER_P8(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetMDER_P8() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetMDER_P9(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetMDER_P9() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetMDER_P10(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetMDER_P10() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetMDER_P11(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetMDER_P11() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetMDER_P12(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetMDER_P12() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetMDER_P13(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetMDER_P13() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetMDER_P14(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetMDER_P14() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetMDER_P15(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetMDER_P15() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetMDER_P16(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetMDER_P16() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetMDER_P17(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetMDER_P17() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetMDER_P18(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetMDER_P18() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetMDER_P19(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetMDER_P19() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetMDER_P20(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetMDER_P20() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetMDER_P21(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetMDER_P21() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetMDER_P22(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetMDER_P22() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetMDER_P23(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetMDER_P23() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetMDER_P24(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetMDER_P24() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetMDER_P25(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetMDER_P25() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetMDER_P26(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetMDER_P26() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetMDER_P27(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetMDER_P27() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetMDER_P28(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetMDER_P28() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetMDER_P29(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetMDER_P29() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetMDER_P30(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetMDER_P30() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetMDER_P31(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetMDER_P31() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x80000000) >> 31
}

// PIO.MDDR: Multi-driver Disable Register
func (o *PIO_Type) SetMDDR_P0(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetMDDR_P0() uint32 {
	return volatile.LoadUint32(&o.MDDR.Reg) & 0x1
}
func (o *PIO_Type) SetMDDR_P1(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetMDDR_P1() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetMDDR_P2(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetMDDR_P2() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetMDDR_P3(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetMDDR_P3() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetMDDR_P4(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetMDDR_P4() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetMDDR_P5(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetMDDR_P5() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetMDDR_P6(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetMDDR_P6() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetMDDR_P7(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetMDDR_P7() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetMDDR_P8(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetMDDR_P8() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetMDDR_P9(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetMDDR_P9() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetMDDR_P10(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetMDDR_P10() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetMDDR_P11(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetMDDR_P11() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetMDDR_P12(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetMDDR_P12() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetMDDR_P13(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetMDDR_P13() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetMDDR_P14(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetMDDR_P14() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetMDDR_P15(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetMDDR_P15() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetMDDR_P16(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetMDDR_P16() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetMDDR_P17(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetMDDR_P17() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetMDDR_P18(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetMDDR_P18() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetMDDR_P19(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetMDDR_P19() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetMDDR_P20(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetMDDR_P20() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetMDDR_P21(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetMDDR_P21() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetMDDR_P22(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetMDDR_P22() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetMDDR_P23(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetMDDR_P23() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetMDDR_P24(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetMDDR_P24() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetMDDR_P25(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetMDDR_P25() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetMDDR_P26(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetMDDR_P26() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetMDDR_P27(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetMDDR_P27() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetMDDR_P28(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetMDDR_P28() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetMDDR_P29(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetMDDR_P29() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetMDDR_P30(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetMDDR_P30() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetMDDR_P31(value uint32) {
	volatile.StoreUint32(&o.MDDR.Reg, volatile.LoadUint32(&o.MDDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetMDDR_P31() uint32 {
	return (volatile.LoadUint32(&o.MDDR.Reg) & 0x80000000) >> 31
}

// PIO.MDSR: Multi-driver Status Register
func (o *PIO_Type) SetMDSR_P0(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetMDSR_P0() uint32 {
	return volatile.LoadUint32(&o.MDSR.Reg) & 0x1
}
func (o *PIO_Type) SetMDSR_P1(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetMDSR_P1() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetMDSR_P2(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetMDSR_P2() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetMDSR_P3(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetMDSR_P3() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetMDSR_P4(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetMDSR_P4() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetMDSR_P5(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetMDSR_P5() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetMDSR_P6(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetMDSR_P6() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetMDSR_P7(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetMDSR_P7() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetMDSR_P8(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetMDSR_P8() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetMDSR_P9(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetMDSR_P9() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetMDSR_P10(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetMDSR_P10() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetMDSR_P11(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetMDSR_P11() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetMDSR_P12(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetMDSR_P12() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetMDSR_P13(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetMDSR_P13() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetMDSR_P14(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetMDSR_P14() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetMDSR_P15(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetMDSR_P15() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetMDSR_P16(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetMDSR_P16() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetMDSR_P17(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetMDSR_P17() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetMDSR_P18(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetMDSR_P18() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetMDSR_P19(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetMDSR_P19() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetMDSR_P20(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetMDSR_P20() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetMDSR_P21(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetMDSR_P21() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetMDSR_P22(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetMDSR_P22() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetMDSR_P23(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetMDSR_P23() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetMDSR_P24(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetMDSR_P24() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetMDSR_P25(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetMDSR_P25() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetMDSR_P26(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetMDSR_P26() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetMDSR_P27(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetMDSR_P27() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetMDSR_P28(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetMDSR_P28() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetMDSR_P29(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetMDSR_P29() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetMDSR_P30(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetMDSR_P30() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetMDSR_P31(value uint32) {
	volatile.StoreUint32(&o.MDSR.Reg, volatile.LoadUint32(&o.MDSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetMDSR_P31() uint32 {
	return (volatile.LoadUint32(&o.MDSR.Reg) & 0x80000000) >> 31
}

// PIO.PUDR: Pull-up Disable Register
func (o *PIO_Type) SetPUDR_P0(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPUDR_P0() uint32 {
	return volatile.LoadUint32(&o.PUDR.Reg) & 0x1
}
func (o *PIO_Type) SetPUDR_P1(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPUDR_P1() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPUDR_P2(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPUDR_P2() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPUDR_P3(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPUDR_P3() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPUDR_P4(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPUDR_P4() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPUDR_P5(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPUDR_P5() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPUDR_P6(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPUDR_P6() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPUDR_P7(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPUDR_P7() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPUDR_P8(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPUDR_P8() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPUDR_P9(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPUDR_P9() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPUDR_P10(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPUDR_P10() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPUDR_P11(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPUDR_P11() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPUDR_P12(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPUDR_P12() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPUDR_P13(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPUDR_P13() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPUDR_P14(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPUDR_P14() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPUDR_P15(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPUDR_P15() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPUDR_P16(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPUDR_P16() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPUDR_P17(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPUDR_P17() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPUDR_P18(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPUDR_P18() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPUDR_P19(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPUDR_P19() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPUDR_P20(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPUDR_P20() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPUDR_P21(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPUDR_P21() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPUDR_P22(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPUDR_P22() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPUDR_P23(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPUDR_P23() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPUDR_P24(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPUDR_P24() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPUDR_P25(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPUDR_P25() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPUDR_P26(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPUDR_P26() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPUDR_P27(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPUDR_P27() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPUDR_P28(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPUDR_P28() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPUDR_P29(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPUDR_P29() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPUDR_P30(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPUDR_P30() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPUDR_P31(value uint32) {
	volatile.StoreUint32(&o.PUDR.Reg, volatile.LoadUint32(&o.PUDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPUDR_P31() uint32 {
	return (volatile.LoadUint32(&o.PUDR.Reg) & 0x80000000) >> 31
}

// PIO.PUER: Pull-up Enable Register
func (o *PIO_Type) SetPUER_P0(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPUER_P0() uint32 {
	return volatile.LoadUint32(&o.PUER.Reg) & 0x1
}
func (o *PIO_Type) SetPUER_P1(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPUER_P1() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPUER_P2(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPUER_P2() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPUER_P3(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPUER_P3() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPUER_P4(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPUER_P4() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPUER_P5(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPUER_P5() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPUER_P6(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPUER_P6() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPUER_P7(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPUER_P7() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPUER_P8(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPUER_P8() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPUER_P9(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPUER_P9() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPUER_P10(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPUER_P10() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPUER_P11(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPUER_P11() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPUER_P12(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPUER_P12() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPUER_P13(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPUER_P13() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPUER_P14(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPUER_P14() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPUER_P15(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPUER_P15() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPUER_P16(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPUER_P16() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPUER_P17(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPUER_P17() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPUER_P18(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPUER_P18() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPUER_P19(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPUER_P19() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPUER_P20(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPUER_P20() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPUER_P21(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPUER_P21() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPUER_P22(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPUER_P22() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPUER_P23(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPUER_P23() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPUER_P24(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPUER_P24() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPUER_P25(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPUER_P25() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPUER_P26(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPUER_P26() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPUER_P27(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPUER_P27() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPUER_P28(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPUER_P28() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPUER_P29(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPUER_P29() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPUER_P30(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPUER_P30() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPUER_P31(value uint32) {
	volatile.StoreUint32(&o.PUER.Reg, volatile.LoadUint32(&o.PUER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPUER_P31() uint32 {
	return (volatile.LoadUint32(&o.PUER.Reg) & 0x80000000) >> 31
}

// PIO.PUSR: Pad Pull-up Status Register
func (o *PIO_Type) SetPUSR_P0(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPUSR_P0() uint32 {
	return volatile.LoadUint32(&o.PUSR.Reg) & 0x1
}
func (o *PIO_Type) SetPUSR_P1(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPUSR_P1() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPUSR_P2(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPUSR_P2() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPUSR_P3(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPUSR_P3() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPUSR_P4(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPUSR_P4() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPUSR_P5(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPUSR_P5() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPUSR_P6(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPUSR_P6() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPUSR_P7(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPUSR_P7() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPUSR_P8(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPUSR_P8() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPUSR_P9(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPUSR_P9() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPUSR_P10(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPUSR_P10() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPUSR_P11(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPUSR_P11() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPUSR_P12(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPUSR_P12() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPUSR_P13(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPUSR_P13() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPUSR_P14(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPUSR_P14() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPUSR_P15(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPUSR_P15() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPUSR_P16(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPUSR_P16() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPUSR_P17(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPUSR_P17() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPUSR_P18(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPUSR_P18() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPUSR_P19(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPUSR_P19() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPUSR_P20(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPUSR_P20() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPUSR_P21(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPUSR_P21() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPUSR_P22(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPUSR_P22() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPUSR_P23(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPUSR_P23() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPUSR_P24(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPUSR_P24() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPUSR_P25(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPUSR_P25() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPUSR_P26(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPUSR_P26() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPUSR_P27(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPUSR_P27() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPUSR_P28(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPUSR_P28() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPUSR_P29(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPUSR_P29() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPUSR_P30(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPUSR_P30() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPUSR_P31(value uint32) {
	volatile.StoreUint32(&o.PUSR.Reg, volatile.LoadUint32(&o.PUSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPUSR_P31() uint32 {
	return (volatile.LoadUint32(&o.PUSR.Reg) & 0x80000000) >> 31
}

// PIO.ABCDSR: Peripheral Select Register
func (o *PIO_Type) SetABCDSR_P0(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetABCDSR_P0(idx int) uint32 {
	return volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x1
}
func (o *PIO_Type) SetABCDSR_P1(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetABCDSR_P1(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetABCDSR_P2(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetABCDSR_P2(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetABCDSR_P3(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetABCDSR_P3(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetABCDSR_P4(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetABCDSR_P4(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetABCDSR_P5(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetABCDSR_P5(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetABCDSR_P6(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetABCDSR_P6(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetABCDSR_P7(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetABCDSR_P7(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetABCDSR_P8(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetABCDSR_P8(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetABCDSR_P9(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetABCDSR_P9(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetABCDSR_P10(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetABCDSR_P10(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetABCDSR_P11(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetABCDSR_P11(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetABCDSR_P12(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetABCDSR_P12(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetABCDSR_P13(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetABCDSR_P13(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetABCDSR_P14(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetABCDSR_P14(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetABCDSR_P15(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetABCDSR_P15(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetABCDSR_P16(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetABCDSR_P16(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetABCDSR_P17(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetABCDSR_P17(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetABCDSR_P18(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetABCDSR_P18(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetABCDSR_P19(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetABCDSR_P19(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetABCDSR_P20(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetABCDSR_P20(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetABCDSR_P21(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetABCDSR_P21(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetABCDSR_P22(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetABCDSR_P22(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetABCDSR_P23(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetABCDSR_P23(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetABCDSR_P24(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetABCDSR_P24(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetABCDSR_P25(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetABCDSR_P25(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetABCDSR_P26(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetABCDSR_P26(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetABCDSR_P27(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetABCDSR_P27(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetABCDSR_P28(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetABCDSR_P28(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetABCDSR_P29(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetABCDSR_P29(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetABCDSR_P30(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetABCDSR_P30(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetABCDSR_P31(idx int, value uint32) {
	volatile.StoreUint32(&o.ABCDSR[idx].Reg, volatile.LoadUint32(&o.ABCDSR[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetABCDSR_P31(idx int) uint32 {
	return (volatile.LoadUint32(&o.ABCDSR[idx].Reg) & 0x80000000) >> 31
}

// PIO.IFSCDR: Input Filter Slow Clock Disable Register
func (o *PIO_Type) SetIFSCDR_P0(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIFSCDR_P0() uint32 {
	return volatile.LoadUint32(&o.IFSCDR.Reg) & 0x1
}
func (o *PIO_Type) SetIFSCDR_P1(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIFSCDR_P1() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIFSCDR_P2(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIFSCDR_P2() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIFSCDR_P3(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIFSCDR_P3() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIFSCDR_P4(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIFSCDR_P4() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIFSCDR_P5(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIFSCDR_P5() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIFSCDR_P6(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIFSCDR_P6() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIFSCDR_P7(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIFSCDR_P7() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIFSCDR_P8(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIFSCDR_P8() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIFSCDR_P9(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIFSCDR_P9() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIFSCDR_P10(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIFSCDR_P10() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIFSCDR_P11(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIFSCDR_P11() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIFSCDR_P12(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIFSCDR_P12() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIFSCDR_P13(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIFSCDR_P13() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIFSCDR_P14(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIFSCDR_P14() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIFSCDR_P15(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIFSCDR_P15() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIFSCDR_P16(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIFSCDR_P16() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIFSCDR_P17(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIFSCDR_P17() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIFSCDR_P18(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIFSCDR_P18() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIFSCDR_P19(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIFSCDR_P19() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIFSCDR_P20(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIFSCDR_P20() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIFSCDR_P21(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIFSCDR_P21() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIFSCDR_P22(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIFSCDR_P22() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIFSCDR_P23(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIFSCDR_P23() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIFSCDR_P24(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIFSCDR_P24() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIFSCDR_P25(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIFSCDR_P25() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIFSCDR_P26(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIFSCDR_P26() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIFSCDR_P27(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIFSCDR_P27() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIFSCDR_P28(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIFSCDR_P28() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIFSCDR_P29(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIFSCDR_P29() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIFSCDR_P30(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIFSCDR_P30() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIFSCDR_P31(value uint32) {
	volatile.StoreUint32(&o.IFSCDR.Reg, volatile.LoadUint32(&o.IFSCDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIFSCDR_P31() uint32 {
	return (volatile.LoadUint32(&o.IFSCDR.Reg) & 0x80000000) >> 31
}

// PIO.IFSCER: Input Filter Slow Clock Enable Register
func (o *PIO_Type) SetIFSCER_P0(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIFSCER_P0() uint32 {
	return volatile.LoadUint32(&o.IFSCER.Reg) & 0x1
}
func (o *PIO_Type) SetIFSCER_P1(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIFSCER_P1() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIFSCER_P2(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIFSCER_P2() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIFSCER_P3(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIFSCER_P3() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIFSCER_P4(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIFSCER_P4() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIFSCER_P5(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIFSCER_P5() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIFSCER_P6(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIFSCER_P6() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIFSCER_P7(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIFSCER_P7() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIFSCER_P8(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIFSCER_P8() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIFSCER_P9(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIFSCER_P9() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIFSCER_P10(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIFSCER_P10() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIFSCER_P11(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIFSCER_P11() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIFSCER_P12(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIFSCER_P12() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIFSCER_P13(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIFSCER_P13() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIFSCER_P14(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIFSCER_P14() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIFSCER_P15(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIFSCER_P15() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIFSCER_P16(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIFSCER_P16() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIFSCER_P17(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIFSCER_P17() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIFSCER_P18(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIFSCER_P18() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIFSCER_P19(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIFSCER_P19() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIFSCER_P20(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIFSCER_P20() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIFSCER_P21(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIFSCER_P21() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIFSCER_P22(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIFSCER_P22() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIFSCER_P23(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIFSCER_P23() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIFSCER_P24(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIFSCER_P24() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIFSCER_P25(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIFSCER_P25() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIFSCER_P26(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIFSCER_P26() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIFSCER_P27(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIFSCER_P27() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIFSCER_P28(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIFSCER_P28() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIFSCER_P29(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIFSCER_P29() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIFSCER_P30(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIFSCER_P30() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIFSCER_P31(value uint32) {
	volatile.StoreUint32(&o.IFSCER.Reg, volatile.LoadUint32(&o.IFSCER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIFSCER_P31() uint32 {
	return (volatile.LoadUint32(&o.IFSCER.Reg) & 0x80000000) >> 31
}

// PIO.IFSCSR: Input Filter Slow Clock Status Register
func (o *PIO_Type) SetIFSCSR_P0(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetIFSCSR_P0() uint32 {
	return volatile.LoadUint32(&o.IFSCSR.Reg) & 0x1
}
func (o *PIO_Type) SetIFSCSR_P1(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetIFSCSR_P1() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetIFSCSR_P2(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetIFSCSR_P2() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetIFSCSR_P3(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetIFSCSR_P3() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetIFSCSR_P4(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetIFSCSR_P4() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetIFSCSR_P5(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetIFSCSR_P5() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetIFSCSR_P6(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetIFSCSR_P6() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetIFSCSR_P7(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetIFSCSR_P7() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetIFSCSR_P8(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetIFSCSR_P8() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetIFSCSR_P9(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetIFSCSR_P9() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetIFSCSR_P10(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetIFSCSR_P10() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetIFSCSR_P11(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetIFSCSR_P11() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetIFSCSR_P12(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetIFSCSR_P12() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetIFSCSR_P13(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetIFSCSR_P13() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetIFSCSR_P14(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetIFSCSR_P14() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetIFSCSR_P15(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetIFSCSR_P15() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetIFSCSR_P16(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetIFSCSR_P16() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetIFSCSR_P17(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetIFSCSR_P17() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetIFSCSR_P18(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetIFSCSR_P18() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetIFSCSR_P19(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetIFSCSR_P19() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetIFSCSR_P20(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetIFSCSR_P20() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetIFSCSR_P21(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetIFSCSR_P21() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetIFSCSR_P22(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetIFSCSR_P22() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetIFSCSR_P23(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetIFSCSR_P23() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetIFSCSR_P24(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetIFSCSR_P24() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetIFSCSR_P25(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetIFSCSR_P25() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetIFSCSR_P26(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetIFSCSR_P26() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetIFSCSR_P27(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetIFSCSR_P27() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetIFSCSR_P28(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetIFSCSR_P28() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetIFSCSR_P29(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetIFSCSR_P29() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetIFSCSR_P30(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetIFSCSR_P30() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetIFSCSR_P31(value uint32) {
	volatile.StoreUint32(&o.IFSCSR.Reg, volatile.LoadUint32(&o.IFSCSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetIFSCSR_P31() uint32 {
	return (volatile.LoadUint32(&o.IFSCSR.Reg) & 0x80000000) >> 31
}

// PIO.SCDR: Slow Clock Divider Debouncing Register
func (o *PIO_Type) SetSCDR_DIV(value uint32) {
	volatile.StoreUint32(&o.SCDR.Reg, volatile.LoadUint32(&o.SCDR.Reg)&^(0x3fff)|value)
}
func (o *PIO_Type) GetSCDR_DIV() uint32 {
	return volatile.LoadUint32(&o.SCDR.Reg) & 0x3fff
}

// PIO.PPDDR: Pad Pull-down Disable Register
func (o *PIO_Type) SetPPDDR_P0(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPPDDR_P0() uint32 {
	return volatile.LoadUint32(&o.PPDDR.Reg) & 0x1
}
func (o *PIO_Type) SetPPDDR_P1(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPPDDR_P1() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPPDDR_P2(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPPDDR_P2() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPPDDR_P3(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPPDDR_P3() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPPDDR_P4(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPPDDR_P4() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPPDDR_P5(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPPDDR_P5() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPPDDR_P6(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPPDDR_P6() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPPDDR_P7(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPPDDR_P7() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPPDDR_P8(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPPDDR_P8() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPPDDR_P9(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPPDDR_P9() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPPDDR_P10(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPPDDR_P10() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPPDDR_P11(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPPDDR_P11() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPPDDR_P12(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPPDDR_P12() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPPDDR_P13(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPPDDR_P13() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPPDDR_P14(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPPDDR_P14() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPPDDR_P15(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPPDDR_P15() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPPDDR_P16(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPPDDR_P16() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPPDDR_P17(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPPDDR_P17() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPPDDR_P18(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPPDDR_P18() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPPDDR_P19(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPPDDR_P19() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPPDDR_P20(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPPDDR_P20() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPPDDR_P21(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPPDDR_P21() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPPDDR_P22(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPPDDR_P22() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPPDDR_P23(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPPDDR_P23() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPPDDR_P24(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPPDDR_P24() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPPDDR_P25(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPPDDR_P25() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPPDDR_P26(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPPDDR_P26() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPPDDR_P27(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPPDDR_P27() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPPDDR_P28(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPPDDR_P28() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPPDDR_P29(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPPDDR_P29() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPPDDR_P30(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPPDDR_P30() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPPDDR_P31(value uint32) {
	volatile.StoreUint32(&o.PPDDR.Reg, volatile.LoadUint32(&o.PPDDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPPDDR_P31() uint32 {
	return (volatile.LoadUint32(&o.PPDDR.Reg) & 0x80000000) >> 31
}

// PIO.PPDER: Pad Pull-down Enable Register
func (o *PIO_Type) SetPPDER_P0(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPPDER_P0() uint32 {
	return volatile.LoadUint32(&o.PPDER.Reg) & 0x1
}
func (o *PIO_Type) SetPPDER_P1(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPPDER_P1() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPPDER_P2(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPPDER_P2() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPPDER_P3(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPPDER_P3() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPPDER_P4(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPPDER_P4() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPPDER_P5(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPPDER_P5() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPPDER_P6(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPPDER_P6() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPPDER_P7(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPPDER_P7() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPPDER_P8(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPPDER_P8() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPPDER_P9(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPPDER_P9() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPPDER_P10(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPPDER_P10() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPPDER_P11(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPPDER_P11() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPPDER_P12(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPPDER_P12() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPPDER_P13(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPPDER_P13() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPPDER_P14(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPPDER_P14() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPPDER_P15(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPPDER_P15() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPPDER_P16(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPPDER_P16() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPPDER_P17(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPPDER_P17() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPPDER_P18(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPPDER_P18() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPPDER_P19(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPPDER_P19() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPPDER_P20(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPPDER_P20() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPPDER_P21(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPPDER_P21() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPPDER_P22(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPPDER_P22() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPPDER_P23(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPPDER_P23() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPPDER_P24(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPPDER_P24() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPPDER_P25(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPPDER_P25() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPPDER_P26(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPPDER_P26() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPPDER_P27(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPPDER_P27() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPPDER_P28(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPPDER_P28() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPPDER_P29(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPPDER_P29() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPPDER_P30(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPPDER_P30() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPPDER_P31(value uint32) {
	volatile.StoreUint32(&o.PPDER.Reg, volatile.LoadUint32(&o.PPDER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPPDER_P31() uint32 {
	return (volatile.LoadUint32(&o.PPDER.Reg) & 0x80000000) >> 31
}

// PIO.PPDSR: Pad Pull-down Status Register
func (o *PIO_Type) SetPPDSR_P0(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetPPDSR_P0() uint32 {
	return volatile.LoadUint32(&o.PPDSR.Reg) & 0x1
}
func (o *PIO_Type) SetPPDSR_P1(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetPPDSR_P1() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetPPDSR_P2(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetPPDSR_P2() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetPPDSR_P3(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetPPDSR_P3() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetPPDSR_P4(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetPPDSR_P4() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetPPDSR_P5(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetPPDSR_P5() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetPPDSR_P6(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetPPDSR_P6() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetPPDSR_P7(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetPPDSR_P7() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetPPDSR_P8(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetPPDSR_P8() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetPPDSR_P9(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetPPDSR_P9() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetPPDSR_P10(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetPPDSR_P10() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetPPDSR_P11(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetPPDSR_P11() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetPPDSR_P12(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetPPDSR_P12() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetPPDSR_P13(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetPPDSR_P13() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetPPDSR_P14(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetPPDSR_P14() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetPPDSR_P15(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetPPDSR_P15() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetPPDSR_P16(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetPPDSR_P16() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetPPDSR_P17(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetPPDSR_P17() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetPPDSR_P18(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetPPDSR_P18() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetPPDSR_P19(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetPPDSR_P19() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetPPDSR_P20(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetPPDSR_P20() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetPPDSR_P21(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetPPDSR_P21() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetPPDSR_P22(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetPPDSR_P22() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetPPDSR_P23(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetPPDSR_P23() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetPPDSR_P24(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetPPDSR_P24() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetPPDSR_P25(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetPPDSR_P25() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetPPDSR_P26(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetPPDSR_P26() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetPPDSR_P27(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetPPDSR_P27() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetPPDSR_P28(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetPPDSR_P28() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetPPDSR_P29(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetPPDSR_P29() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetPPDSR_P30(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetPPDSR_P30() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetPPDSR_P31(value uint32) {
	volatile.StoreUint32(&o.PPDSR.Reg, volatile.LoadUint32(&o.PPDSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetPPDSR_P31() uint32 {
	return (volatile.LoadUint32(&o.PPDSR.Reg) & 0x80000000) >> 31
}

// PIO.OWER: Output Write Enable
func (o *PIO_Type) SetOWER_P0(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetOWER_P0() uint32 {
	return volatile.LoadUint32(&o.OWER.Reg) & 0x1
}
func (o *PIO_Type) SetOWER_P1(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetOWER_P1() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetOWER_P2(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetOWER_P2() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetOWER_P3(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetOWER_P3() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetOWER_P4(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetOWER_P4() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetOWER_P5(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetOWER_P5() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetOWER_P6(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetOWER_P6() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetOWER_P7(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetOWER_P7() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetOWER_P8(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetOWER_P8() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetOWER_P9(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetOWER_P9() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetOWER_P10(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetOWER_P10() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetOWER_P11(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetOWER_P11() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetOWER_P12(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetOWER_P12() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetOWER_P13(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetOWER_P13() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetOWER_P14(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetOWER_P14() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetOWER_P15(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetOWER_P15() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetOWER_P16(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetOWER_P16() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetOWER_P17(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetOWER_P17() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetOWER_P18(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetOWER_P18() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetOWER_P19(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetOWER_P19() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetOWER_P20(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetOWER_P20() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetOWER_P21(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetOWER_P21() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetOWER_P22(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetOWER_P22() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetOWER_P23(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetOWER_P23() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetOWER_P24(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetOWER_P24() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetOWER_P25(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetOWER_P25() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetOWER_P26(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetOWER_P26() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetOWER_P27(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetOWER_P27() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetOWER_P28(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetOWER_P28() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetOWER_P29(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetOWER_P29() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetOWER_P30(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetOWER_P30() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetOWER_P31(value uint32) {
	volatile.StoreUint32(&o.OWER.Reg, volatile.LoadUint32(&o.OWER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetOWER_P31() uint32 {
	return (volatile.LoadUint32(&o.OWER.Reg) & 0x80000000) >> 31
}

// PIO.OWDR: Output Write Disable
func (o *PIO_Type) SetOWDR_P0(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetOWDR_P0() uint32 {
	return volatile.LoadUint32(&o.OWDR.Reg) & 0x1
}
func (o *PIO_Type) SetOWDR_P1(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetOWDR_P1() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetOWDR_P2(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetOWDR_P2() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetOWDR_P3(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetOWDR_P3() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetOWDR_P4(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetOWDR_P4() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetOWDR_P5(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetOWDR_P5() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetOWDR_P6(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetOWDR_P6() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetOWDR_P7(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetOWDR_P7() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetOWDR_P8(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetOWDR_P8() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetOWDR_P9(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetOWDR_P9() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetOWDR_P10(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetOWDR_P10() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetOWDR_P11(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetOWDR_P11() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetOWDR_P12(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetOWDR_P12() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetOWDR_P13(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetOWDR_P13() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetOWDR_P14(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetOWDR_P14() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetOWDR_P15(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetOWDR_P15() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetOWDR_P16(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetOWDR_P16() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetOWDR_P17(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetOWDR_P17() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetOWDR_P18(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetOWDR_P18() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetOWDR_P19(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetOWDR_P19() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetOWDR_P20(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetOWDR_P20() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetOWDR_P21(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetOWDR_P21() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetOWDR_P22(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetOWDR_P22() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetOWDR_P23(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetOWDR_P23() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetOWDR_P24(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetOWDR_P24() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetOWDR_P25(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetOWDR_P25() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetOWDR_P26(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetOWDR_P26() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetOWDR_P27(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetOWDR_P27() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetOWDR_P28(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetOWDR_P28() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetOWDR_P29(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetOWDR_P29() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetOWDR_P30(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetOWDR_P30() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetOWDR_P31(value uint32) {
	volatile.StoreUint32(&o.OWDR.Reg, volatile.LoadUint32(&o.OWDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetOWDR_P31() uint32 {
	return (volatile.LoadUint32(&o.OWDR.Reg) & 0x80000000) >> 31
}

// PIO.OWSR: Output Write Status Register
func (o *PIO_Type) SetOWSR_P0(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetOWSR_P0() uint32 {
	return volatile.LoadUint32(&o.OWSR.Reg) & 0x1
}
func (o *PIO_Type) SetOWSR_P1(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetOWSR_P1() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetOWSR_P2(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetOWSR_P2() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetOWSR_P3(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetOWSR_P3() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetOWSR_P4(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetOWSR_P4() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetOWSR_P5(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetOWSR_P5() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetOWSR_P6(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetOWSR_P6() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetOWSR_P7(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetOWSR_P7() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetOWSR_P8(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetOWSR_P8() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetOWSR_P9(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetOWSR_P9() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetOWSR_P10(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetOWSR_P10() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetOWSR_P11(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetOWSR_P11() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetOWSR_P12(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetOWSR_P12() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetOWSR_P13(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetOWSR_P13() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetOWSR_P14(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetOWSR_P14() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetOWSR_P15(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetOWSR_P15() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetOWSR_P16(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetOWSR_P16() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetOWSR_P17(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetOWSR_P17() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetOWSR_P18(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetOWSR_P18() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetOWSR_P19(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetOWSR_P19() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetOWSR_P20(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetOWSR_P20() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetOWSR_P21(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetOWSR_P21() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetOWSR_P22(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetOWSR_P22() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetOWSR_P23(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetOWSR_P23() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetOWSR_P24(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetOWSR_P24() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetOWSR_P25(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetOWSR_P25() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetOWSR_P26(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetOWSR_P26() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetOWSR_P27(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetOWSR_P27() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetOWSR_P28(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetOWSR_P28() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetOWSR_P29(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetOWSR_P29() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetOWSR_P30(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetOWSR_P30() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetOWSR_P31(value uint32) {
	volatile.StoreUint32(&o.OWSR.Reg, volatile.LoadUint32(&o.OWSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetOWSR_P31() uint32 {
	return (volatile.LoadUint32(&o.OWSR.Reg) & 0x80000000) >> 31
}

// PIO.AIMER: Additional Interrupt Modes Enable Register
func (o *PIO_Type) SetAIMER_P0(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetAIMER_P0() uint32 {
	return volatile.LoadUint32(&o.AIMER.Reg) & 0x1
}
func (o *PIO_Type) SetAIMER_P1(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetAIMER_P1() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetAIMER_P2(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetAIMER_P2() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetAIMER_P3(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetAIMER_P3() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetAIMER_P4(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetAIMER_P4() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetAIMER_P5(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetAIMER_P5() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetAIMER_P6(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetAIMER_P6() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetAIMER_P7(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetAIMER_P7() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetAIMER_P8(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetAIMER_P8() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetAIMER_P9(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetAIMER_P9() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetAIMER_P10(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetAIMER_P10() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetAIMER_P11(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetAIMER_P11() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetAIMER_P12(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetAIMER_P12() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetAIMER_P13(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetAIMER_P13() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetAIMER_P14(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetAIMER_P14() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetAIMER_P15(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetAIMER_P15() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetAIMER_P16(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetAIMER_P16() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetAIMER_P17(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetAIMER_P17() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetAIMER_P18(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetAIMER_P18() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetAIMER_P19(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetAIMER_P19() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetAIMER_P20(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetAIMER_P20() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetAIMER_P21(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetAIMER_P21() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetAIMER_P22(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetAIMER_P22() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetAIMER_P23(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetAIMER_P23() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetAIMER_P24(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetAIMER_P24() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetAIMER_P25(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetAIMER_P25() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetAIMER_P26(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetAIMER_P26() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetAIMER_P27(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetAIMER_P27() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetAIMER_P28(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetAIMER_P28() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetAIMER_P29(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetAIMER_P29() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetAIMER_P30(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetAIMER_P30() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetAIMER_P31(value uint32) {
	volatile.StoreUint32(&o.AIMER.Reg, volatile.LoadUint32(&o.AIMER.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetAIMER_P31() uint32 {
	return (volatile.LoadUint32(&o.AIMER.Reg) & 0x80000000) >> 31
}

// PIO.AIMDR: Additional Interrupt Modes Disables Register
func (o *PIO_Type) SetAIMDR_P0(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetAIMDR_P0() uint32 {
	return volatile.LoadUint32(&o.AIMDR.Reg) & 0x1
}
func (o *PIO_Type) SetAIMDR_P1(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetAIMDR_P1() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetAIMDR_P2(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetAIMDR_P2() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetAIMDR_P3(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetAIMDR_P3() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetAIMDR_P4(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetAIMDR_P4() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetAIMDR_P5(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetAIMDR_P5() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetAIMDR_P6(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetAIMDR_P6() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetAIMDR_P7(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetAIMDR_P7() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetAIMDR_P8(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetAIMDR_P8() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetAIMDR_P9(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetAIMDR_P9() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetAIMDR_P10(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetAIMDR_P10() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetAIMDR_P11(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetAIMDR_P11() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetAIMDR_P12(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetAIMDR_P12() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetAIMDR_P13(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetAIMDR_P13() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetAIMDR_P14(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetAIMDR_P14() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetAIMDR_P15(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetAIMDR_P15() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetAIMDR_P16(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetAIMDR_P16() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetAIMDR_P17(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetAIMDR_P17() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetAIMDR_P18(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetAIMDR_P18() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetAIMDR_P19(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetAIMDR_P19() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetAIMDR_P20(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetAIMDR_P20() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetAIMDR_P21(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetAIMDR_P21() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetAIMDR_P22(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetAIMDR_P22() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetAIMDR_P23(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetAIMDR_P23() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetAIMDR_P24(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetAIMDR_P24() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetAIMDR_P25(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetAIMDR_P25() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetAIMDR_P26(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetAIMDR_P26() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetAIMDR_P27(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetAIMDR_P27() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetAIMDR_P28(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetAIMDR_P28() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetAIMDR_P29(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetAIMDR_P29() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetAIMDR_P30(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetAIMDR_P30() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetAIMDR_P31(value uint32) {
	volatile.StoreUint32(&o.AIMDR.Reg, volatile.LoadUint32(&o.AIMDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetAIMDR_P31() uint32 {
	return (volatile.LoadUint32(&o.AIMDR.Reg) & 0x80000000) >> 31
}

// PIO.AIMMR: Additional Interrupt Modes Mask Register
func (o *PIO_Type) SetAIMMR_P0(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetAIMMR_P0() uint32 {
	return volatile.LoadUint32(&o.AIMMR.Reg) & 0x1
}
func (o *PIO_Type) SetAIMMR_P1(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetAIMMR_P1() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetAIMMR_P2(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetAIMMR_P2() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetAIMMR_P3(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetAIMMR_P3() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetAIMMR_P4(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetAIMMR_P4() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetAIMMR_P5(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetAIMMR_P5() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetAIMMR_P6(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetAIMMR_P6() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetAIMMR_P7(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetAIMMR_P7() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetAIMMR_P8(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetAIMMR_P8() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetAIMMR_P9(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetAIMMR_P9() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetAIMMR_P10(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetAIMMR_P10() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetAIMMR_P11(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetAIMMR_P11() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetAIMMR_P12(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetAIMMR_P12() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetAIMMR_P13(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetAIMMR_P13() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetAIMMR_P14(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetAIMMR_P14() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetAIMMR_P15(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetAIMMR_P15() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetAIMMR_P16(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetAIMMR_P16() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetAIMMR_P17(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetAIMMR_P17() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetAIMMR_P18(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetAIMMR_P18() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetAIMMR_P19(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetAIMMR_P19() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetAIMMR_P20(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetAIMMR_P20() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetAIMMR_P21(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetAIMMR_P21() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetAIMMR_P22(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetAIMMR_P22() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetAIMMR_P23(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetAIMMR_P23() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetAIMMR_P24(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetAIMMR_P24() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetAIMMR_P25(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetAIMMR_P25() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetAIMMR_P26(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetAIMMR_P26() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetAIMMR_P27(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetAIMMR_P27() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetAIMMR_P28(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetAIMMR_P28() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetAIMMR_P29(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetAIMMR_P29() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetAIMMR_P30(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetAIMMR_P30() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetAIMMR_P31(value uint32) {
	volatile.StoreUint32(&o.AIMMR.Reg, volatile.LoadUint32(&o.AIMMR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetAIMMR_P31() uint32 {
	return (volatile.LoadUint32(&o.AIMMR.Reg) & 0x80000000) >> 31
}

// PIO.ESR: Edge Select Register
func (o *PIO_Type) SetESR_P0(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetESR_P0() uint32 {
	return volatile.LoadUint32(&o.ESR.Reg) & 0x1
}
func (o *PIO_Type) SetESR_P1(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetESR_P1() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetESR_P2(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetESR_P2() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetESR_P3(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetESR_P3() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetESR_P4(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetESR_P4() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetESR_P5(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetESR_P5() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetESR_P6(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetESR_P6() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetESR_P7(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetESR_P7() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetESR_P8(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetESR_P8() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetESR_P9(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetESR_P9() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetESR_P10(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetESR_P10() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetESR_P11(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetESR_P11() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetESR_P12(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetESR_P12() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetESR_P13(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetESR_P13() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetESR_P14(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetESR_P14() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetESR_P15(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetESR_P15() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetESR_P16(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetESR_P16() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetESR_P17(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetESR_P17() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetESR_P18(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetESR_P18() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetESR_P19(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetESR_P19() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetESR_P20(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetESR_P20() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetESR_P21(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetESR_P21() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetESR_P22(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetESR_P22() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetESR_P23(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetESR_P23() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetESR_P24(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetESR_P24() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetESR_P25(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetESR_P25() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetESR_P26(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetESR_P26() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetESR_P27(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetESR_P27() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetESR_P28(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetESR_P28() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetESR_P29(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetESR_P29() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetESR_P30(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetESR_P30() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetESR_P31(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetESR_P31() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x80000000) >> 31
}

// PIO.LSR: Level Select Register
func (o *PIO_Type) SetLSR_P0(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetLSR_P0() uint32 {
	return volatile.LoadUint32(&o.LSR.Reg) & 0x1
}
func (o *PIO_Type) SetLSR_P1(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetLSR_P1() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetLSR_P2(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetLSR_P2() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetLSR_P3(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetLSR_P3() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetLSR_P4(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetLSR_P4() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetLSR_P5(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetLSR_P5() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetLSR_P6(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetLSR_P6() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetLSR_P7(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetLSR_P7() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetLSR_P8(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetLSR_P8() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetLSR_P9(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetLSR_P9() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetLSR_P10(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetLSR_P10() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetLSR_P11(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetLSR_P11() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetLSR_P12(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetLSR_P12() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetLSR_P13(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetLSR_P13() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetLSR_P14(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetLSR_P14() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetLSR_P15(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetLSR_P15() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetLSR_P16(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetLSR_P16() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetLSR_P17(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetLSR_P17() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetLSR_P18(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetLSR_P18() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetLSR_P19(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetLSR_P19() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetLSR_P20(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetLSR_P20() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetLSR_P21(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetLSR_P21() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetLSR_P22(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetLSR_P22() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetLSR_P23(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetLSR_P23() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetLSR_P24(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetLSR_P24() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetLSR_P25(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetLSR_P25() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetLSR_P26(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetLSR_P26() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetLSR_P27(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetLSR_P27() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetLSR_P28(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetLSR_P28() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetLSR_P29(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetLSR_P29() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetLSR_P30(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetLSR_P30() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetLSR_P31(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetLSR_P31() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x80000000) >> 31
}

// PIO.ELSR: Edge/Level Status Register
func (o *PIO_Type) SetELSR_P0(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetELSR_P0() uint32 {
	return volatile.LoadUint32(&o.ELSR.Reg) & 0x1
}
func (o *PIO_Type) SetELSR_P1(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetELSR_P1() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetELSR_P2(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetELSR_P2() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetELSR_P3(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetELSR_P3() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetELSR_P4(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetELSR_P4() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetELSR_P5(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetELSR_P5() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetELSR_P6(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetELSR_P6() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetELSR_P7(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetELSR_P7() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetELSR_P8(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetELSR_P8() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetELSR_P9(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetELSR_P9() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetELSR_P10(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetELSR_P10() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetELSR_P11(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetELSR_P11() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetELSR_P12(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetELSR_P12() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetELSR_P13(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetELSR_P13() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetELSR_P14(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetELSR_P14() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetELSR_P15(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetELSR_P15() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetELSR_P16(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetELSR_P16() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetELSR_P17(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetELSR_P17() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetELSR_P18(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetELSR_P18() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetELSR_P19(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetELSR_P19() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetELSR_P20(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetELSR_P20() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetELSR_P21(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetELSR_P21() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetELSR_P22(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetELSR_P22() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetELSR_P23(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetELSR_P23() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetELSR_P24(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetELSR_P24() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetELSR_P25(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetELSR_P25() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetELSR_P26(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetELSR_P26() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetELSR_P27(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetELSR_P27() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetELSR_P28(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetELSR_P28() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetELSR_P29(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetELSR_P29() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetELSR_P30(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetELSR_P30() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetELSR_P31(value uint32) {
	volatile.StoreUint32(&o.ELSR.Reg, volatile.LoadUint32(&o.ELSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetELSR_P31() uint32 {
	return (volatile.LoadUint32(&o.ELSR.Reg) & 0x80000000) >> 31
}

// PIO.FELLSR: Falling Edge/Low Level Select Register
func (o *PIO_Type) SetFELLSR_P0(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetFELLSR_P0() uint32 {
	return volatile.LoadUint32(&o.FELLSR.Reg) & 0x1
}
func (o *PIO_Type) SetFELLSR_P1(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetFELLSR_P1() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetFELLSR_P2(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetFELLSR_P2() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetFELLSR_P3(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetFELLSR_P3() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetFELLSR_P4(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetFELLSR_P4() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetFELLSR_P5(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetFELLSR_P5() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetFELLSR_P6(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetFELLSR_P6() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetFELLSR_P7(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetFELLSR_P7() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetFELLSR_P8(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetFELLSR_P8() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetFELLSR_P9(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetFELLSR_P9() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetFELLSR_P10(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetFELLSR_P10() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetFELLSR_P11(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetFELLSR_P11() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetFELLSR_P12(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetFELLSR_P12() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetFELLSR_P13(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetFELLSR_P13() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetFELLSR_P14(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetFELLSR_P14() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetFELLSR_P15(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetFELLSR_P15() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetFELLSR_P16(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetFELLSR_P16() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetFELLSR_P17(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetFELLSR_P17() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetFELLSR_P18(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetFELLSR_P18() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetFELLSR_P19(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetFELLSR_P19() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetFELLSR_P20(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetFELLSR_P20() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetFELLSR_P21(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetFELLSR_P21() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetFELLSR_P22(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetFELLSR_P22() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetFELLSR_P23(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetFELLSR_P23() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetFELLSR_P24(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetFELLSR_P24() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetFELLSR_P25(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetFELLSR_P25() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetFELLSR_P26(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetFELLSR_P26() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetFELLSR_P27(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetFELLSR_P27() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetFELLSR_P28(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetFELLSR_P28() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetFELLSR_P29(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetFELLSR_P29() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetFELLSR_P30(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetFELLSR_P30() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetFELLSR_P31(value uint32) {
	volatile.StoreUint32(&o.FELLSR.Reg, volatile.LoadUint32(&o.FELLSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetFELLSR_P31() uint32 {
	return (volatile.LoadUint32(&o.FELLSR.Reg) & 0x80000000) >> 31
}

// PIO.REHLSR: Rising Edge/ High Level Select Register
func (o *PIO_Type) SetREHLSR_P0(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetREHLSR_P0() uint32 {
	return volatile.LoadUint32(&o.REHLSR.Reg) & 0x1
}
func (o *PIO_Type) SetREHLSR_P1(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetREHLSR_P1() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetREHLSR_P2(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetREHLSR_P2() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetREHLSR_P3(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetREHLSR_P3() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetREHLSR_P4(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetREHLSR_P4() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetREHLSR_P5(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetREHLSR_P5() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetREHLSR_P6(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetREHLSR_P6() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetREHLSR_P7(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetREHLSR_P7() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetREHLSR_P8(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetREHLSR_P8() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetREHLSR_P9(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetREHLSR_P9() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetREHLSR_P10(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetREHLSR_P10() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetREHLSR_P11(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetREHLSR_P11() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetREHLSR_P12(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetREHLSR_P12() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetREHLSR_P13(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetREHLSR_P13() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetREHLSR_P14(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetREHLSR_P14() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetREHLSR_P15(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetREHLSR_P15() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetREHLSR_P16(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetREHLSR_P16() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetREHLSR_P17(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetREHLSR_P17() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetREHLSR_P18(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetREHLSR_P18() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetREHLSR_P19(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetREHLSR_P19() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetREHLSR_P20(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetREHLSR_P20() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetREHLSR_P21(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetREHLSR_P21() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetREHLSR_P22(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetREHLSR_P22() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetREHLSR_P23(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetREHLSR_P23() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetREHLSR_P24(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetREHLSR_P24() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetREHLSR_P25(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetREHLSR_P25() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetREHLSR_P26(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetREHLSR_P26() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetREHLSR_P27(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetREHLSR_P27() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetREHLSR_P28(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetREHLSR_P28() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetREHLSR_P29(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetREHLSR_P29() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetREHLSR_P30(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetREHLSR_P30() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetREHLSR_P31(value uint32) {
	volatile.StoreUint32(&o.REHLSR.Reg, volatile.LoadUint32(&o.REHLSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetREHLSR_P31() uint32 {
	return (volatile.LoadUint32(&o.REHLSR.Reg) & 0x80000000) >> 31
}

// PIO.FRLHSR: Fall/Rise - Low/High Status Register
func (o *PIO_Type) SetFRLHSR_P0(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetFRLHSR_P0() uint32 {
	return volatile.LoadUint32(&o.FRLHSR.Reg) & 0x1
}
func (o *PIO_Type) SetFRLHSR_P1(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetFRLHSR_P1() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetFRLHSR_P2(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetFRLHSR_P2() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetFRLHSR_P3(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetFRLHSR_P3() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetFRLHSR_P4(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetFRLHSR_P4() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetFRLHSR_P5(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetFRLHSR_P5() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetFRLHSR_P6(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetFRLHSR_P6() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetFRLHSR_P7(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetFRLHSR_P7() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetFRLHSR_P8(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetFRLHSR_P8() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetFRLHSR_P9(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetFRLHSR_P9() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetFRLHSR_P10(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetFRLHSR_P10() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetFRLHSR_P11(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetFRLHSR_P11() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetFRLHSR_P12(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetFRLHSR_P12() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetFRLHSR_P13(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetFRLHSR_P13() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetFRLHSR_P14(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetFRLHSR_P14() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetFRLHSR_P15(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetFRLHSR_P15() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetFRLHSR_P16(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetFRLHSR_P16() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetFRLHSR_P17(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetFRLHSR_P17() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetFRLHSR_P18(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetFRLHSR_P18() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetFRLHSR_P19(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetFRLHSR_P19() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetFRLHSR_P20(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetFRLHSR_P20() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetFRLHSR_P21(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetFRLHSR_P21() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetFRLHSR_P22(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetFRLHSR_P22() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetFRLHSR_P23(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetFRLHSR_P23() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetFRLHSR_P24(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetFRLHSR_P24() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetFRLHSR_P25(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetFRLHSR_P25() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetFRLHSR_P26(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetFRLHSR_P26() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetFRLHSR_P27(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetFRLHSR_P27() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetFRLHSR_P28(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetFRLHSR_P28() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetFRLHSR_P29(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetFRLHSR_P29() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetFRLHSR_P30(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetFRLHSR_P30() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetFRLHSR_P31(value uint32) {
	volatile.StoreUint32(&o.FRLHSR.Reg, volatile.LoadUint32(&o.FRLHSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetFRLHSR_P31() uint32 {
	return (volatile.LoadUint32(&o.FRLHSR.Reg) & 0x80000000) >> 31
}

// PIO.LOCKSR: Lock Status
func (o *PIO_Type) SetLOCKSR_P0(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetLOCKSR_P0() uint32 {
	return volatile.LoadUint32(&o.LOCKSR.Reg) & 0x1
}
func (o *PIO_Type) SetLOCKSR_P1(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetLOCKSR_P1() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetLOCKSR_P2(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetLOCKSR_P2() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetLOCKSR_P3(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetLOCKSR_P3() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetLOCKSR_P4(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetLOCKSR_P4() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetLOCKSR_P5(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetLOCKSR_P5() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetLOCKSR_P6(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetLOCKSR_P6() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetLOCKSR_P7(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetLOCKSR_P7() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetLOCKSR_P8(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetLOCKSR_P8() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetLOCKSR_P9(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetLOCKSR_P9() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetLOCKSR_P10(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetLOCKSR_P10() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetLOCKSR_P11(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetLOCKSR_P11() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetLOCKSR_P12(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetLOCKSR_P12() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetLOCKSR_P13(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetLOCKSR_P13() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetLOCKSR_P14(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetLOCKSR_P14() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetLOCKSR_P15(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetLOCKSR_P15() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetLOCKSR_P16(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetLOCKSR_P16() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetLOCKSR_P17(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetLOCKSR_P17() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetLOCKSR_P18(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetLOCKSR_P18() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetLOCKSR_P19(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetLOCKSR_P19() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetLOCKSR_P20(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetLOCKSR_P20() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetLOCKSR_P21(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetLOCKSR_P21() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetLOCKSR_P22(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetLOCKSR_P22() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetLOCKSR_P23(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetLOCKSR_P23() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetLOCKSR_P24(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetLOCKSR_P24() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetLOCKSR_P25(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetLOCKSR_P25() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetLOCKSR_P26(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetLOCKSR_P26() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetLOCKSR_P27(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetLOCKSR_P27() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetLOCKSR_P28(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetLOCKSR_P28() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetLOCKSR_P29(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetLOCKSR_P29() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetLOCKSR_P30(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetLOCKSR_P30() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetLOCKSR_P31(value uint32) {
	volatile.StoreUint32(&o.LOCKSR.Reg, volatile.LoadUint32(&o.LOCKSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetLOCKSR_P31() uint32 {
	return (volatile.LoadUint32(&o.LOCKSR.Reg) & 0x80000000) >> 31
}

// PIO.WPMR: Write Protect Mode Register
func (o *PIO_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *PIO_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *PIO_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// PIO.WPSR: Write Protect Status Register
func (o *PIO_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *PIO_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *PIO_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// PIO.SCHMITT: Schmitt Trigger Register
func (o *PIO_Type) SetSCHMITT_SCHMITT0(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x1)|value)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT0() uint32 {
	return volatile.LoadUint32(&o.SCHMITT.Reg) & 0x1
}
func (o *PIO_Type) SetSCHMITT_SCHMITT1(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x2)|value<<1)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT1() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x2) >> 1
}
func (o *PIO_Type) SetSCHMITT_SCHMITT2(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x4)|value<<2)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT2() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x4) >> 2
}
func (o *PIO_Type) SetSCHMITT_SCHMITT3(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x8)|value<<3)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT3() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x8) >> 3
}
func (o *PIO_Type) SetSCHMITT_SCHMITT4(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x10)|value<<4)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT4() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x10) >> 4
}
func (o *PIO_Type) SetSCHMITT_SCHMITT5(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x20)|value<<5)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT5() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x20) >> 5
}
func (o *PIO_Type) SetSCHMITT_SCHMITT6(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x40)|value<<6)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT6() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x40) >> 6
}
func (o *PIO_Type) SetSCHMITT_SCHMITT7(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x80)|value<<7)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT7() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x80) >> 7
}
func (o *PIO_Type) SetSCHMITT_SCHMITT8(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x100)|value<<8)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT8() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x100) >> 8
}
func (o *PIO_Type) SetSCHMITT_SCHMITT9(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x200)|value<<9)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT9() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x200) >> 9
}
func (o *PIO_Type) SetSCHMITT_SCHMITT10(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x400)|value<<10)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT10() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x400) >> 10
}
func (o *PIO_Type) SetSCHMITT_SCHMITT11(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x800)|value<<11)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT11() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x800) >> 11
}
func (o *PIO_Type) SetSCHMITT_SCHMITT12(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x1000)|value<<12)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT12() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x1000) >> 12
}
func (o *PIO_Type) SetSCHMITT_SCHMITT13(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x2000)|value<<13)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT13() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x2000) >> 13
}
func (o *PIO_Type) SetSCHMITT_SCHMITT14(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x4000)|value<<14)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT14() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x4000) >> 14
}
func (o *PIO_Type) SetSCHMITT_SCHMITT15(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x8000)|value<<15)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT15() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x8000) >> 15
}
func (o *PIO_Type) SetSCHMITT_SCHMITT16(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x10000)|value<<16)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT16() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x10000) >> 16
}
func (o *PIO_Type) SetSCHMITT_SCHMITT17(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x20000)|value<<17)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT17() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x20000) >> 17
}
func (o *PIO_Type) SetSCHMITT_SCHMITT18(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x40000)|value<<18)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT18() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x40000) >> 18
}
func (o *PIO_Type) SetSCHMITT_SCHMITT19(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x80000)|value<<19)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT19() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x80000) >> 19
}
func (o *PIO_Type) SetSCHMITT_SCHMITT20(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x100000)|value<<20)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT20() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x100000) >> 20
}
func (o *PIO_Type) SetSCHMITT_SCHMITT21(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x200000)|value<<21)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT21() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x200000) >> 21
}
func (o *PIO_Type) SetSCHMITT_SCHMITT22(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x400000)|value<<22)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT22() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x400000) >> 22
}
func (o *PIO_Type) SetSCHMITT_SCHMITT23(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x800000)|value<<23)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT23() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x800000) >> 23
}
func (o *PIO_Type) SetSCHMITT_SCHMITT24(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x1000000)|value<<24)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT24() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x1000000) >> 24
}
func (o *PIO_Type) SetSCHMITT_SCHMITT25(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x2000000)|value<<25)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT25() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x2000000) >> 25
}
func (o *PIO_Type) SetSCHMITT_SCHMITT26(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x4000000)|value<<26)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT26() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x4000000) >> 26
}
func (o *PIO_Type) SetSCHMITT_SCHMITT27(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x8000000)|value<<27)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT27() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x8000000) >> 27
}
func (o *PIO_Type) SetSCHMITT_SCHMITT28(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x10000000)|value<<28)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT28() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x10000000) >> 28
}
func (o *PIO_Type) SetSCHMITT_SCHMITT29(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT29() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x20000000) >> 29
}
func (o *PIO_Type) SetSCHMITT_SCHMITT30(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT30() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x40000000) >> 30
}
func (o *PIO_Type) SetSCHMITT_SCHMITT31(value uint32) {
	volatile.StoreUint32(&o.SCHMITT.Reg, volatile.LoadUint32(&o.SCHMITT.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO_Type) GetSCHMITT_SCHMITT31() uint32 {
	return (volatile.LoadUint32(&o.SCHMITT.Reg) & 0x80000000) >> 31
}

// PIO.DRIVER1: I/O Drive Register 1
func (o *PIO_Type) SetDRIVER1_LINE0(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0x3)|value)
}
func (o *PIO_Type) GetDRIVER1_LINE0() uint32 {
	return volatile.LoadUint32(&o.DRIVER1.Reg) & 0x3
}
func (o *PIO_Type) SetDRIVER1_LINE1(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0xc)|value<<2)
}
func (o *PIO_Type) GetDRIVER1_LINE1() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0xc) >> 2
}
func (o *PIO_Type) SetDRIVER1_LINE2(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0x30)|value<<4)
}
func (o *PIO_Type) GetDRIVER1_LINE2() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0x30) >> 4
}
func (o *PIO_Type) SetDRIVER1_LINE3(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0xc0)|value<<6)
}
func (o *PIO_Type) GetDRIVER1_LINE3() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0xc0) >> 6
}
func (o *PIO_Type) SetDRIVER1_LINE4(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0x300)|value<<8)
}
func (o *PIO_Type) GetDRIVER1_LINE4() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0x300) >> 8
}
func (o *PIO_Type) SetDRIVER1_LINE5(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0xc00)|value<<10)
}
func (o *PIO_Type) GetDRIVER1_LINE5() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0xc00) >> 10
}
func (o *PIO_Type) SetDRIVER1_LINE6(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0x3000)|value<<12)
}
func (o *PIO_Type) GetDRIVER1_LINE6() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0x3000) >> 12
}
func (o *PIO_Type) SetDRIVER1_LINE7(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0xc000)|value<<14)
}
func (o *PIO_Type) GetDRIVER1_LINE7() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0xc000) >> 14
}
func (o *PIO_Type) SetDRIVER1_LINE8(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0x30000)|value<<16)
}
func (o *PIO_Type) GetDRIVER1_LINE8() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0x30000) >> 16
}
func (o *PIO_Type) SetDRIVER1_LINE9(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0xc0000)|value<<18)
}
func (o *PIO_Type) GetDRIVER1_LINE9() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0xc0000) >> 18
}
func (o *PIO_Type) SetDRIVER1_LINE10(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0x300000)|value<<20)
}
func (o *PIO_Type) GetDRIVER1_LINE10() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0x300000) >> 20
}
func (o *PIO_Type) SetDRIVER1_LINE11(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0xc00000)|value<<22)
}
func (o *PIO_Type) GetDRIVER1_LINE11() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0xc00000) >> 22
}
func (o *PIO_Type) SetDRIVER1_LINE12(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0x3000000)|value<<24)
}
func (o *PIO_Type) GetDRIVER1_LINE12() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0x3000000) >> 24
}
func (o *PIO_Type) SetDRIVER1_LINE13(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0xc000000)|value<<26)
}
func (o *PIO_Type) GetDRIVER1_LINE13() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0xc000000) >> 26
}
func (o *PIO_Type) SetDRIVER1_LINE14(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0x30000000)|value<<28)
}
func (o *PIO_Type) GetDRIVER1_LINE14() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0x30000000) >> 28
}
func (o *PIO_Type) SetDRIVER1_LINE15(value uint32) {
	volatile.StoreUint32(&o.DRIVER1.Reg, volatile.LoadUint32(&o.DRIVER1.Reg)&^(0xc0000000)|value<<30)
}
func (o *PIO_Type) GetDRIVER1_LINE15() uint32 {
	return (volatile.LoadUint32(&o.DRIVER1.Reg) & 0xc0000000) >> 30
}

// PIO.DRIVER2: I/O Drive Register 2
func (o *PIO_Type) SetDRIVER2_LINE16(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0x3)|value)
}
func (o *PIO_Type) GetDRIVER2_LINE16() uint32 {
	return volatile.LoadUint32(&o.DRIVER2.Reg) & 0x3
}
func (o *PIO_Type) SetDRIVER2_LINE17(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0xc)|value<<2)
}
func (o *PIO_Type) GetDRIVER2_LINE17() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0xc) >> 2
}
func (o *PIO_Type) SetDRIVER2_LINE18(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0x30)|value<<4)
}
func (o *PIO_Type) GetDRIVER2_LINE18() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0x30) >> 4
}
func (o *PIO_Type) SetDRIVER2_LINE19(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0xc0)|value<<6)
}
func (o *PIO_Type) GetDRIVER2_LINE19() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0xc0) >> 6
}
func (o *PIO_Type) SetDRIVER2_LINE20(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0x300)|value<<8)
}
func (o *PIO_Type) GetDRIVER2_LINE20() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0x300) >> 8
}
func (o *PIO_Type) SetDRIVER2_LINE21(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0xc00)|value<<10)
}
func (o *PIO_Type) GetDRIVER2_LINE21() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0xc00) >> 10
}
func (o *PIO_Type) SetDRIVER2_LINE22(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0x3000)|value<<12)
}
func (o *PIO_Type) GetDRIVER2_LINE22() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0x3000) >> 12
}
func (o *PIO_Type) SetDRIVER2_LINE23(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0xc000)|value<<14)
}
func (o *PIO_Type) GetDRIVER2_LINE23() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0xc000) >> 14
}
func (o *PIO_Type) SetDRIVER2_LINE24(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0x30000)|value<<16)
}
func (o *PIO_Type) GetDRIVER2_LINE24() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0x30000) >> 16
}
func (o *PIO_Type) SetDRIVER2_LINE25(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0xc0000)|value<<18)
}
func (o *PIO_Type) GetDRIVER2_LINE25() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0xc0000) >> 18
}
func (o *PIO_Type) SetDRIVER2_LINE26(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0x300000)|value<<20)
}
func (o *PIO_Type) GetDRIVER2_LINE26() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0x300000) >> 20
}
func (o *PIO_Type) SetDRIVER2_LINE27(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0xc00000)|value<<22)
}
func (o *PIO_Type) GetDRIVER2_LINE27() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0xc00000) >> 22
}
func (o *PIO_Type) SetDRIVER2_LINE28(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0x3000000)|value<<24)
}
func (o *PIO_Type) GetDRIVER2_LINE28() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0x3000000) >> 24
}
func (o *PIO_Type) SetDRIVER2_LINE29(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0xc000000)|value<<26)
}
func (o *PIO_Type) GetDRIVER2_LINE29() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0xc000000) >> 26
}
func (o *PIO_Type) SetDRIVER2_LINE30(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0x30000000)|value<<28)
}
func (o *PIO_Type) GetDRIVER2_LINE30() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0x30000000) >> 28
}
func (o *PIO_Type) SetDRIVER2_LINE31(value uint32) {
	volatile.StoreUint32(&o.DRIVER2.Reg, volatile.LoadUint32(&o.DRIVER2.Reg)&^(0xc0000000)|value<<30)
}
func (o *PIO_Type) GetDRIVER2_LINE31() uint32 {
	return (volatile.LoadUint32(&o.DRIVER2.Reg) & 0xc0000000) >> 30
}

// Power Management Controller
type PMC_Type struct {
	PMC_SCER    volatile.Register32 // 0x0
	PMC_SCDR    volatile.Register32 // 0x4
	PMC_SCSR    volatile.Register32 // 0x8
	_           [4]byte
	PMC_PCER0   volatile.Register32 // 0x10
	PMC_PCDR0   volatile.Register32 // 0x14
	PMC_PCSR0   volatile.Register32 // 0x18
	CKGR_UCKR   volatile.Register32 // 0x1C
	CKGR_MOR    volatile.Register32 // 0x20
	CKGR_MCFR   volatile.Register32 // 0x24
	CKGR_PLLAR  volatile.Register32 // 0x28
	_           [4]byte
	PMC_MCKR    volatile.Register32 // 0x30
	_           [4]byte
	PMC_USB     volatile.Register32    // 0x38
	PMC_SMD     volatile.Register32    // 0x3C
	PMC_PCK     [3]volatile.Register32 // 0x40
	_           [20]byte
	PMC_IER     volatile.Register32 // 0x60
	PMC_IDR     volatile.Register32 // 0x64
	PMC_SR      volatile.Register32 // 0x68
	PMC_IMR     volatile.Register32 // 0x6C
	_           [16]byte
	PMC_PLLICPR volatile.Register32 // 0x80
	_           [96]byte
	PMC_WPMR    volatile.Register32 // 0xE4
	PMC_WPSR    volatile.Register32 // 0xE8
	_           [20]byte
	PMC_PCER1   volatile.Register32 // 0x100
	PMC_PCDR1   volatile.Register32 // 0x104
	PMC_PCSR1   volatile.Register32 // 0x108
	PMC_PCR     volatile.Register32 // 0x10C
}

// PMC.PMC_SCER: System Clock Enable Register
func (o *PMC_Type) SetPMC_SCER_DDRCK(value uint32) {
	volatile.StoreUint32(&o.PMC_SCER.Reg, volatile.LoadUint32(&o.PMC_SCER.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_SCER_DDRCK() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCER.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_SCER_SMDCK(value uint32) {
	volatile.StoreUint32(&o.PMC_SCER.Reg, volatile.LoadUint32(&o.PMC_SCER.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetPMC_SCER_SMDCK() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCER.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetPMC_SCER_UHP(value uint32) {
	volatile.StoreUint32(&o.PMC_SCER.Reg, volatile.LoadUint32(&o.PMC_SCER.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_SCER_UHP() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCER.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_SCER_UDP(value uint32) {
	volatile.StoreUint32(&o.PMC_SCER.Reg, volatile.LoadUint32(&o.PMC_SCER.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_SCER_UDP() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCER.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_SCER_PCK0(value uint32) {
	volatile.StoreUint32(&o.PMC_SCER.Reg, volatile.LoadUint32(&o.PMC_SCER.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_SCER_PCK0() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCER.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_SCER_PCK1(value uint32) {
	volatile.StoreUint32(&o.PMC_SCER.Reg, volatile.LoadUint32(&o.PMC_SCER.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_SCER_PCK1() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCER.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_SCER_PCK2(value uint32) {
	volatile.StoreUint32(&o.PMC_SCER.Reg, volatile.LoadUint32(&o.PMC_SCER.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPMC_SCER_PCK2() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCER.Reg) & 0x400) >> 10
}

// PMC.PMC_SCDR: System Clock Disable Register
func (o *PMC_Type) SetPMC_SCDR_PCK(value uint32) {
	volatile.StoreUint32(&o.PMC_SCDR.Reg, volatile.LoadUint32(&o.PMC_SCDR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_SCDR_PCK() uint32 {
	return volatile.LoadUint32(&o.PMC_SCDR.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_SCDR_DDRCK(value uint32) {
	volatile.StoreUint32(&o.PMC_SCDR.Reg, volatile.LoadUint32(&o.PMC_SCDR.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_SCDR_DDRCK() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCDR.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_SCDR_SMDCK(value uint32) {
	volatile.StoreUint32(&o.PMC_SCDR.Reg, volatile.LoadUint32(&o.PMC_SCDR.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetPMC_SCDR_SMDCK() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCDR.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetPMC_SCDR_UHP(value uint32) {
	volatile.StoreUint32(&o.PMC_SCDR.Reg, volatile.LoadUint32(&o.PMC_SCDR.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_SCDR_UHP() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCDR.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_SCDR_UDP(value uint32) {
	volatile.StoreUint32(&o.PMC_SCDR.Reg, volatile.LoadUint32(&o.PMC_SCDR.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_SCDR_UDP() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCDR.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_SCDR_PCK0(value uint32) {
	volatile.StoreUint32(&o.PMC_SCDR.Reg, volatile.LoadUint32(&o.PMC_SCDR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_SCDR_PCK0() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCDR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_SCDR_PCK1(value uint32) {
	volatile.StoreUint32(&o.PMC_SCDR.Reg, volatile.LoadUint32(&o.PMC_SCDR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_SCDR_PCK1() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCDR.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_SCDR_PCK2(value uint32) {
	volatile.StoreUint32(&o.PMC_SCDR.Reg, volatile.LoadUint32(&o.PMC_SCDR.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPMC_SCDR_PCK2() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCDR.Reg) & 0x400) >> 10
}

// PMC.PMC_SCSR: System Clock Status Register
func (o *PMC_Type) SetPMC_SCSR_PCK(value uint32) {
	volatile.StoreUint32(&o.PMC_SCSR.Reg, volatile.LoadUint32(&o.PMC_SCSR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_SCSR_PCK() uint32 {
	return volatile.LoadUint32(&o.PMC_SCSR.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_SCSR_DDRCK(value uint32) {
	volatile.StoreUint32(&o.PMC_SCSR.Reg, volatile.LoadUint32(&o.PMC_SCSR.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_SCSR_DDRCK() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCSR.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_SCSR_SMDCK(value uint32) {
	volatile.StoreUint32(&o.PMC_SCSR.Reg, volatile.LoadUint32(&o.PMC_SCSR.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetPMC_SCSR_SMDCK() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCSR.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetPMC_SCSR_UHP(value uint32) {
	volatile.StoreUint32(&o.PMC_SCSR.Reg, volatile.LoadUint32(&o.PMC_SCSR.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_SCSR_UHP() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCSR.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_SCSR_UDP(value uint32) {
	volatile.StoreUint32(&o.PMC_SCSR.Reg, volatile.LoadUint32(&o.PMC_SCSR.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_SCSR_UDP() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCSR.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_SCSR_PCK0(value uint32) {
	volatile.StoreUint32(&o.PMC_SCSR.Reg, volatile.LoadUint32(&o.PMC_SCSR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_SCSR_PCK0() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCSR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_SCSR_PCK1(value uint32) {
	volatile.StoreUint32(&o.PMC_SCSR.Reg, volatile.LoadUint32(&o.PMC_SCSR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_SCSR_PCK1() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCSR.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_SCSR_PCK2(value uint32) {
	volatile.StoreUint32(&o.PMC_SCSR.Reg, volatile.LoadUint32(&o.PMC_SCSR.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPMC_SCSR_PCK2() uint32 {
	return (volatile.LoadUint32(&o.PMC_SCSR.Reg) & 0x400) >> 10
}

// PMC.PMC_PCER0: Peripheral Clock Enable Register 0
func (o *PMC_Type) SetPMC_PCER0_PID2(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_PCER0_PID2() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_PCER0_PID3(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_PCER0_PID3() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_PCER0_PID4(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetPMC_PCER0_PID4() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetPMC_PCER0_PID5(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetPMC_PCER0_PID5() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetPMC_PCER0_PID6(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_PCER0_PID6() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_PCER0_PID7(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_PCER0_PID7() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_PCER0_PID8(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_PCER0_PID8() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_PCER0_PID9(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_PCER0_PID9() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_PCER0_PID10(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPMC_PCER0_PID10() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetPMC_PCER0_PID11(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetPMC_PCER0_PID11() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetPMC_PCER0_PID12(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPMC_PCER0_PID12() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPMC_PCER0_PID13(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetPMC_PCER0_PID13() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetPMC_PCER0_PID14(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetPMC_PCER0_PID14() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetPMC_PCER0_PID15(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetPMC_PCER0_PID15() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetPMC_PCER0_PID16(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_PCER0_PID16() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_PCER0_PID17(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_PCER0_PID17() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_PCER0_PID18(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_PCER0_PID18() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPMC_PCER0_PID19(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPMC_PCER0_PID19() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPMC_PCER0_PID20(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetPMC_PCER0_PID20() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetPMC_PCER0_PID21(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetPMC_PCER0_PID21() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetPMC_PCER0_PID22(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x400000)|value<<22)
}
func (o *PMC_Type) GetPMC_PCER0_PID22() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x400000) >> 22
}
func (o *PMC_Type) SetPMC_PCER0_PID23(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetPMC_PCER0_PID23() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x800000) >> 23
}
func (o *PMC_Type) SetPMC_PCER0_PID24(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetPMC_PCER0_PID24() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetPMC_PCER0_PID25(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetPMC_PCER0_PID25() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetPMC_PCER0_PID26(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetPMC_PCER0_PID26() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetPMC_PCER0_PID27(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetPMC_PCER0_PID27() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetPMC_PCER0_PID28(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPMC_PCER0_PID28() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetPMC_PCER0_PID29(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetPMC_PCER0_PID29() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x20000000) >> 29
}
func (o *PMC_Type) SetPMC_PCER0_PID30(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x40000000)|value<<30)
}
func (o *PMC_Type) GetPMC_PCER0_PID30() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x40000000) >> 30
}
func (o *PMC_Type) SetPMC_PCER0_PID31(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER0.Reg, volatile.LoadUint32(&o.PMC_PCER0.Reg)&^(0x80000000)|value<<31)
}
func (o *PMC_Type) GetPMC_PCER0_PID31() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER0.Reg) & 0x80000000) >> 31
}

// PMC.PMC_PCDR0: Peripheral Clock Disable Register 0
func (o *PMC_Type) SetPMC_PCDR0_PID2(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_PCDR0_PID2() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_PCDR0_PID3(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_PCDR0_PID3() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_PCDR0_PID4(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetPMC_PCDR0_PID4() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetPMC_PCDR0_PID5(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetPMC_PCDR0_PID5() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetPMC_PCDR0_PID6(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_PCDR0_PID6() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_PCDR0_PID7(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_PCDR0_PID7() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_PCDR0_PID8(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_PCDR0_PID8() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_PCDR0_PID9(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_PCDR0_PID9() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_PCDR0_PID10(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPMC_PCDR0_PID10() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetPMC_PCDR0_PID11(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetPMC_PCDR0_PID11() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetPMC_PCDR0_PID12(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPMC_PCDR0_PID12() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPMC_PCDR0_PID13(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetPMC_PCDR0_PID13() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetPMC_PCDR0_PID14(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetPMC_PCDR0_PID14() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetPMC_PCDR0_PID15(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetPMC_PCDR0_PID15() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetPMC_PCDR0_PID16(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_PCDR0_PID16() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_PCDR0_PID17(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_PCDR0_PID17() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_PCDR0_PID18(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_PCDR0_PID18() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPMC_PCDR0_PID19(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPMC_PCDR0_PID19() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPMC_PCDR0_PID20(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetPMC_PCDR0_PID20() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetPMC_PCDR0_PID21(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetPMC_PCDR0_PID21() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetPMC_PCDR0_PID22(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x400000)|value<<22)
}
func (o *PMC_Type) GetPMC_PCDR0_PID22() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x400000) >> 22
}
func (o *PMC_Type) SetPMC_PCDR0_PID23(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetPMC_PCDR0_PID23() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x800000) >> 23
}
func (o *PMC_Type) SetPMC_PCDR0_PID24(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetPMC_PCDR0_PID24() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetPMC_PCDR0_PID25(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetPMC_PCDR0_PID25() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetPMC_PCDR0_PID26(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetPMC_PCDR0_PID26() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetPMC_PCDR0_PID27(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetPMC_PCDR0_PID27() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetPMC_PCDR0_PID28(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPMC_PCDR0_PID28() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetPMC_PCDR0_PID29(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetPMC_PCDR0_PID29() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x20000000) >> 29
}
func (o *PMC_Type) SetPMC_PCDR0_PID30(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x40000000)|value<<30)
}
func (o *PMC_Type) GetPMC_PCDR0_PID30() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x40000000) >> 30
}
func (o *PMC_Type) SetPMC_PCDR0_PID31(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR0.Reg, volatile.LoadUint32(&o.PMC_PCDR0.Reg)&^(0x80000000)|value<<31)
}
func (o *PMC_Type) GetPMC_PCDR0_PID31() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR0.Reg) & 0x80000000) >> 31
}

// PMC.PMC_PCSR0: Peripheral Clock Status Register 0
func (o *PMC_Type) SetPMC_PCSR0_PID2(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_PCSR0_PID2() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_PCSR0_PID3(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_PCSR0_PID3() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_PCSR0_PID4(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetPMC_PCSR0_PID4() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetPMC_PCSR0_PID5(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetPMC_PCSR0_PID5() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetPMC_PCSR0_PID6(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_PCSR0_PID6() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_PCSR0_PID7(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_PCSR0_PID7() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_PCSR0_PID8(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_PCSR0_PID8() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_PCSR0_PID9(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_PCSR0_PID9() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_PCSR0_PID10(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPMC_PCSR0_PID10() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetPMC_PCSR0_PID11(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetPMC_PCSR0_PID11() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetPMC_PCSR0_PID12(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPMC_PCSR0_PID12() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPMC_PCSR0_PID13(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetPMC_PCSR0_PID13() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetPMC_PCSR0_PID14(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetPMC_PCSR0_PID14() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetPMC_PCSR0_PID15(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetPMC_PCSR0_PID15() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetPMC_PCSR0_PID16(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_PCSR0_PID16() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_PCSR0_PID17(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_PCSR0_PID17() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_PCSR0_PID18(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_PCSR0_PID18() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPMC_PCSR0_PID19(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPMC_PCSR0_PID19() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPMC_PCSR0_PID20(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetPMC_PCSR0_PID20() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x100000) >> 20
}
func (o *PMC_Type) SetPMC_PCSR0_PID21(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x200000)|value<<21)
}
func (o *PMC_Type) GetPMC_PCSR0_PID21() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x200000) >> 21
}
func (o *PMC_Type) SetPMC_PCSR0_PID22(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x400000)|value<<22)
}
func (o *PMC_Type) GetPMC_PCSR0_PID22() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x400000) >> 22
}
func (o *PMC_Type) SetPMC_PCSR0_PID23(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetPMC_PCSR0_PID23() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x800000) >> 23
}
func (o *PMC_Type) SetPMC_PCSR0_PID24(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetPMC_PCSR0_PID24() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetPMC_PCSR0_PID25(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetPMC_PCSR0_PID25() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetPMC_PCSR0_PID26(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetPMC_PCSR0_PID26() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetPMC_PCSR0_PID27(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetPMC_PCSR0_PID27() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetPMC_PCSR0_PID28(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPMC_PCSR0_PID28() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetPMC_PCSR0_PID29(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetPMC_PCSR0_PID29() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x20000000) >> 29
}
func (o *PMC_Type) SetPMC_PCSR0_PID30(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x40000000)|value<<30)
}
func (o *PMC_Type) GetPMC_PCSR0_PID30() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x40000000) >> 30
}
func (o *PMC_Type) SetPMC_PCSR0_PID31(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR0.Reg, volatile.LoadUint32(&o.PMC_PCSR0.Reg)&^(0x80000000)|value<<31)
}
func (o *PMC_Type) GetPMC_PCSR0_PID31() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR0.Reg) & 0x80000000) >> 31
}

// PMC.CKGR_UCKR: UTMI Clock Register
func (o *PMC_Type) SetCKGR_UCKR_UPLLEN(value uint32) {
	volatile.StoreUint32(&o.CKGR_UCKR.Reg, volatile.LoadUint32(&o.CKGR_UCKR.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetCKGR_UCKR_UPLLEN() uint32 {
	return (volatile.LoadUint32(&o.CKGR_UCKR.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetCKGR_UCKR_UPLLCOUNT(value uint32) {
	volatile.StoreUint32(&o.CKGR_UCKR.Reg, volatile.LoadUint32(&o.CKGR_UCKR.Reg)&^(0xf00000)|value<<20)
}
func (o *PMC_Type) GetCKGR_UCKR_UPLLCOUNT() uint32 {
	return (volatile.LoadUint32(&o.CKGR_UCKR.Reg) & 0xf00000) >> 20
}
func (o *PMC_Type) SetCKGR_UCKR_BIASEN(value uint32) {
	volatile.StoreUint32(&o.CKGR_UCKR.Reg, volatile.LoadUint32(&o.CKGR_UCKR.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetCKGR_UCKR_BIASEN() uint32 {
	return (volatile.LoadUint32(&o.CKGR_UCKR.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetCKGR_UCKR_BIASCOUNT(value uint32) {
	volatile.StoreUint32(&o.CKGR_UCKR.Reg, volatile.LoadUint32(&o.CKGR_UCKR.Reg)&^(0xf0000000)|value<<28)
}
func (o *PMC_Type) GetCKGR_UCKR_BIASCOUNT() uint32 {
	return (volatile.LoadUint32(&o.CKGR_UCKR.Reg) & 0xf0000000) >> 28
}

// PMC.CKGR_MOR: Main Oscillator Register
func (o *PMC_Type) SetCKGR_MOR_MOSCXTEN(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetCKGR_MOR_MOSCXTEN() uint32 {
	return volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0x1
}
func (o *PMC_Type) SetCKGR_MOR_MOSCXTBY(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetCKGR_MOR_MOSCXTBY() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetCKGR_MOR_MOSCRCEN(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetCKGR_MOR_MOSCRCEN() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetCKGR_MOR_MOSCXTST(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0xff00)|value<<8)
}
func (o *PMC_Type) GetCKGR_MOR_MOSCXTST() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0xff00) >> 8
}
func (o *PMC_Type) SetCKGR_MOR_KEY(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0xff0000)|value<<16)
}
func (o *PMC_Type) GetCKGR_MOR_KEY() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0xff0000) >> 16
}
func (o *PMC_Type) SetCKGR_MOR_MOSCSEL(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetCKGR_MOR_MOSCSEL() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetCKGR_MOR_CFDEN(value uint32) {
	volatile.StoreUint32(&o.CKGR_MOR.Reg, volatile.LoadUint32(&o.CKGR_MOR.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetCKGR_MOR_CFDEN() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MOR.Reg) & 0x2000000) >> 25
}

// PMC.CKGR_MCFR: Main Clock Frequency Register
func (o *PMC_Type) SetCKGR_MCFR_MAINF(value uint32) {
	volatile.StoreUint32(&o.CKGR_MCFR.Reg, volatile.LoadUint32(&o.CKGR_MCFR.Reg)&^(0xffff)|value)
}
func (o *PMC_Type) GetCKGR_MCFR_MAINF() uint32 {
	return volatile.LoadUint32(&o.CKGR_MCFR.Reg) & 0xffff
}
func (o *PMC_Type) SetCKGR_MCFR_MAINFRDY(value uint32) {
	volatile.StoreUint32(&o.CKGR_MCFR.Reg, volatile.LoadUint32(&o.CKGR_MCFR.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetCKGR_MCFR_MAINFRDY() uint32 {
	return (volatile.LoadUint32(&o.CKGR_MCFR.Reg) & 0x10000) >> 16
}

// PMC.CKGR_PLLAR: PLLA Register
func (o *PMC_Type) SetCKGR_PLLAR_DIVA(value uint32) {
	volatile.StoreUint32(&o.CKGR_PLLAR.Reg, volatile.LoadUint32(&o.CKGR_PLLAR.Reg)&^(0xff)|value)
}
func (o *PMC_Type) GetCKGR_PLLAR_DIVA() uint32 {
	return volatile.LoadUint32(&o.CKGR_PLLAR.Reg) & 0xff
}
func (o *PMC_Type) SetCKGR_PLLAR_PLLACOUNT(value uint32) {
	volatile.StoreUint32(&o.CKGR_PLLAR.Reg, volatile.LoadUint32(&o.CKGR_PLLAR.Reg)&^(0x3f00)|value<<8)
}
func (o *PMC_Type) GetCKGR_PLLAR_PLLACOUNT() uint32 {
	return (volatile.LoadUint32(&o.CKGR_PLLAR.Reg) & 0x3f00) >> 8
}
func (o *PMC_Type) SetCKGR_PLLAR_OUTA(value uint32) {
	volatile.StoreUint32(&o.CKGR_PLLAR.Reg, volatile.LoadUint32(&o.CKGR_PLLAR.Reg)&^(0xc000)|value<<14)
}
func (o *PMC_Type) GetCKGR_PLLAR_OUTA() uint32 {
	return (volatile.LoadUint32(&o.CKGR_PLLAR.Reg) & 0xc000) >> 14
}
func (o *PMC_Type) SetCKGR_PLLAR_MULA(value uint32) {
	volatile.StoreUint32(&o.CKGR_PLLAR.Reg, volatile.LoadUint32(&o.CKGR_PLLAR.Reg)&^(0x7ff0000)|value<<16)
}
func (o *PMC_Type) GetCKGR_PLLAR_MULA() uint32 {
	return (volatile.LoadUint32(&o.CKGR_PLLAR.Reg) & 0x7ff0000) >> 16
}
func (o *PMC_Type) SetCKGR_PLLAR_STUCKTO1(value uint32) {
	volatile.StoreUint32(&o.CKGR_PLLAR.Reg, volatile.LoadUint32(&o.CKGR_PLLAR.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetCKGR_PLLAR_STUCKTO1() uint32 {
	return (volatile.LoadUint32(&o.CKGR_PLLAR.Reg) & 0x20000000) >> 29
}

// PMC.PMC_MCKR: Master Clock Register
func (o *PMC_Type) SetPMC_MCKR_CSS(value uint32) {
	volatile.StoreUint32(&o.PMC_MCKR.Reg, volatile.LoadUint32(&o.PMC_MCKR.Reg)&^(0x3)|value)
}
func (o *PMC_Type) GetPMC_MCKR_CSS() uint32 {
	return volatile.LoadUint32(&o.PMC_MCKR.Reg) & 0x3
}
func (o *PMC_Type) SetPMC_MCKR_PRES(value uint32) {
	volatile.StoreUint32(&o.PMC_MCKR.Reg, volatile.LoadUint32(&o.PMC_MCKR.Reg)&^(0x70)|value<<4)
}
func (o *PMC_Type) GetPMC_MCKR_PRES() uint32 {
	return (volatile.LoadUint32(&o.PMC_MCKR.Reg) & 0x70) >> 4
}
func (o *PMC_Type) SetPMC_MCKR_MDIV(value uint32) {
	volatile.StoreUint32(&o.PMC_MCKR.Reg, volatile.LoadUint32(&o.PMC_MCKR.Reg)&^(0x300)|value<<8)
}
func (o *PMC_Type) GetPMC_MCKR_MDIV() uint32 {
	return (volatile.LoadUint32(&o.PMC_MCKR.Reg) & 0x300) >> 8
}
func (o *PMC_Type) SetPMC_MCKR_PLLADIV2(value uint32) {
	volatile.StoreUint32(&o.PMC_MCKR.Reg, volatile.LoadUint32(&o.PMC_MCKR.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPMC_MCKR_PLLADIV2() uint32 {
	return (volatile.LoadUint32(&o.PMC_MCKR.Reg) & 0x1000) >> 12
}

// PMC.PMC_USB: USB Clock Register
func (o *PMC_Type) SetPMC_USB_USBS(value uint32) {
	volatile.StoreUint32(&o.PMC_USB.Reg, volatile.LoadUint32(&o.PMC_USB.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_USB_USBS() uint32 {
	return volatile.LoadUint32(&o.PMC_USB.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_USB_USBDIV(value uint32) {
	volatile.StoreUint32(&o.PMC_USB.Reg, volatile.LoadUint32(&o.PMC_USB.Reg)&^(0xf00)|value<<8)
}
func (o *PMC_Type) GetPMC_USB_USBDIV() uint32 {
	return (volatile.LoadUint32(&o.PMC_USB.Reg) & 0xf00) >> 8
}

// PMC.PMC_SMD: Soft Modem Clock Register
func (o *PMC_Type) SetPMC_SMD_SMDS(value uint32) {
	volatile.StoreUint32(&o.PMC_SMD.Reg, volatile.LoadUint32(&o.PMC_SMD.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_SMD_SMDS() uint32 {
	return volatile.LoadUint32(&o.PMC_SMD.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_SMD_SMDDIV(value uint32) {
	volatile.StoreUint32(&o.PMC_SMD.Reg, volatile.LoadUint32(&o.PMC_SMD.Reg)&^(0x1f00)|value<<8)
}
func (o *PMC_Type) GetPMC_SMD_SMDDIV() uint32 {
	return (volatile.LoadUint32(&o.PMC_SMD.Reg) & 0x1f00) >> 8
}

// PMC.PMC_PCK: Programmable Clock 0 Register
func (o *PMC_Type) SetPMC_PCK_CSS(idx int, value uint32) {
	volatile.StoreUint32(&o.PMC_PCK[idx].Reg, volatile.LoadUint32(&o.PMC_PCK[idx].Reg)&^(0x7)|value)
}
func (o *PMC_Type) GetPMC_PCK_CSS(idx int) uint32 {
	return volatile.LoadUint32(&o.PMC_PCK[idx].Reg) & 0x7
}
func (o *PMC_Type) SetPMC_PCK_PRES(idx int, value uint32) {
	volatile.StoreUint32(&o.PMC_PCK[idx].Reg, volatile.LoadUint32(&o.PMC_PCK[idx].Reg)&^(0x70)|value<<4)
}
func (o *PMC_Type) GetPMC_PCK_PRES(idx int) uint32 {
	return (volatile.LoadUint32(&o.PMC_PCK[idx].Reg) & 0x70) >> 4
}

// PMC.PMC_IER: Interrupt Enable Register
func (o *PMC_Type) SetPMC_IER_MOSCXTS(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_IER_MOSCXTS() uint32 {
	return volatile.LoadUint32(&o.PMC_IER.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_IER_LOCKA(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetPMC_IER_LOCKA() uint32 {
	return (volatile.LoadUint32(&o.PMC_IER.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetPMC_IER_MCKRDY(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_IER_MCKRDY() uint32 {
	return (volatile.LoadUint32(&o.PMC_IER.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_IER_LOCKU(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_IER_LOCKU() uint32 {
	return (volatile.LoadUint32(&o.PMC_IER.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_IER_PCKRDY0(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_IER_PCKRDY0() uint32 {
	return (volatile.LoadUint32(&o.PMC_IER.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_IER_PCKRDY1(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_IER_PCKRDY1() uint32 {
	return (volatile.LoadUint32(&o.PMC_IER.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_IER_MOSCSELS(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_IER_MOSCSELS() uint32 {
	return (volatile.LoadUint32(&o.PMC_IER.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_IER_MOSCRCS(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_IER_MOSCRCS() uint32 {
	return (volatile.LoadUint32(&o.PMC_IER.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_IER_CFDEV(value uint32) {
	volatile.StoreUint32(&o.PMC_IER.Reg, volatile.LoadUint32(&o.PMC_IER.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_IER_CFDEV() uint32 {
	return (volatile.LoadUint32(&o.PMC_IER.Reg) & 0x40000) >> 18
}

// PMC.PMC_IDR: Interrupt Disable Register
func (o *PMC_Type) SetPMC_IDR_MOSCXTS(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_IDR_MOSCXTS() uint32 {
	return volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_IDR_LOCKA(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetPMC_IDR_LOCKA() uint32 {
	return (volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetPMC_IDR_MCKRDY(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_IDR_MCKRDY() uint32 {
	return (volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_IDR_LOCKU(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_IDR_LOCKU() uint32 {
	return (volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_IDR_PCKRDY0(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_IDR_PCKRDY0() uint32 {
	return (volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_IDR_PCKRDY1(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_IDR_PCKRDY1() uint32 {
	return (volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_IDR_MOSCSELS(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_IDR_MOSCSELS() uint32 {
	return (volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_IDR_MOSCRCS(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_IDR_MOSCRCS() uint32 {
	return (volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_IDR_CFDEV(value uint32) {
	volatile.StoreUint32(&o.PMC_IDR.Reg, volatile.LoadUint32(&o.PMC_IDR.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_IDR_CFDEV() uint32 {
	return (volatile.LoadUint32(&o.PMC_IDR.Reg) & 0x40000) >> 18
}

// PMC.PMC_SR: Status Register
func (o *PMC_Type) SetPMC_SR_MOSCXTS(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_SR_MOSCXTS() uint32 {
	return volatile.LoadUint32(&o.PMC_SR.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_SR_LOCKA(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetPMC_SR_LOCKA() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetPMC_SR_MCKRDY(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_SR_MCKRDY() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_SR_LOCKU(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_SR_LOCKU() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_SR_OSCSELS(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_SR_OSCSELS() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_SR_PCKRDY0(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_SR_PCKRDY0() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_SR_PCKRDY1(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_SR_PCKRDY1() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_SR_MOSCSELS(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_SR_MOSCSELS() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_SR_MOSCRCS(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_SR_MOSCRCS() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_SR_CFDEV(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_SR_CFDEV() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPMC_SR_CFDS(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPMC_SR_CFDS() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPMC_SR_FOS(value uint32) {
	volatile.StoreUint32(&o.PMC_SR.Reg, volatile.LoadUint32(&o.PMC_SR.Reg)&^(0x100000)|value<<20)
}
func (o *PMC_Type) GetPMC_SR_FOS() uint32 {
	return (volatile.LoadUint32(&o.PMC_SR.Reg) & 0x100000) >> 20
}

// PMC.PMC_IMR: Interrupt Mask Register
func (o *PMC_Type) SetPMC_IMR_MOSCXTS(value uint32) {
	volatile.StoreUint32(&o.PMC_IMR.Reg, volatile.LoadUint32(&o.PMC_IMR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_IMR_MOSCXTS() uint32 {
	return volatile.LoadUint32(&o.PMC_IMR.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_IMR_LOCKA(value uint32) {
	volatile.StoreUint32(&o.PMC_IMR.Reg, volatile.LoadUint32(&o.PMC_IMR.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetPMC_IMR_LOCKA() uint32 {
	return (volatile.LoadUint32(&o.PMC_IMR.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetPMC_IMR_MCKRDY(value uint32) {
	volatile.StoreUint32(&o.PMC_IMR.Reg, volatile.LoadUint32(&o.PMC_IMR.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_IMR_MCKRDY() uint32 {
	return (volatile.LoadUint32(&o.PMC_IMR.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_IMR_PCKRDY0(value uint32) {
	volatile.StoreUint32(&o.PMC_IMR.Reg, volatile.LoadUint32(&o.PMC_IMR.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_IMR_PCKRDY0() uint32 {
	return (volatile.LoadUint32(&o.PMC_IMR.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_IMR_PCKRDY1(value uint32) {
	volatile.StoreUint32(&o.PMC_IMR.Reg, volatile.LoadUint32(&o.PMC_IMR.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_IMR_PCKRDY1() uint32 {
	return (volatile.LoadUint32(&o.PMC_IMR.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_IMR_MOSCSELS(value uint32) {
	volatile.StoreUint32(&o.PMC_IMR.Reg, volatile.LoadUint32(&o.PMC_IMR.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_IMR_MOSCSELS() uint32 {
	return (volatile.LoadUint32(&o.PMC_IMR.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_IMR_MOSCRCS(value uint32) {
	volatile.StoreUint32(&o.PMC_IMR.Reg, volatile.LoadUint32(&o.PMC_IMR.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_IMR_MOSCRCS() uint32 {
	return (volatile.LoadUint32(&o.PMC_IMR.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_IMR_CFDEV(value uint32) {
	volatile.StoreUint32(&o.PMC_IMR.Reg, volatile.LoadUint32(&o.PMC_IMR.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_IMR_CFDEV() uint32 {
	return (volatile.LoadUint32(&o.PMC_IMR.Reg) & 0x40000) >> 18
}

// PMC.PMC_PLLICPR: PLL Charge Pump Current Register
func (o *PMC_Type) SetPMC_PLLICPR_ICPLLA(value uint32) {
	volatile.StoreUint32(&o.PMC_PLLICPR.Reg, volatile.LoadUint32(&o.PMC_PLLICPR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_PLLICPR_ICPLLA() uint32 {
	return volatile.LoadUint32(&o.PMC_PLLICPR.Reg) & 0x1
}

// PMC.PMC_WPMR: Write Protect Mode Register
func (o *PMC_Type) SetPMC_WPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.PMC_WPMR.Reg, volatile.LoadUint32(&o.PMC_WPMR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_WPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.PMC_WPMR.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_WPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.PMC_WPMR.Reg, volatile.LoadUint32(&o.PMC_WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *PMC_Type) GetPMC_WPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.PMC_WPMR.Reg) & 0xffffff00) >> 8
}

// PMC.PMC_WPSR: Write Protect Status Register
func (o *PMC_Type) SetPMC_WPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.PMC_WPSR.Reg, volatile.LoadUint32(&o.PMC_WPSR.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_WPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.PMC_WPSR.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_WPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.PMC_WPSR.Reg, volatile.LoadUint32(&o.PMC_WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *PMC_Type) GetPMC_WPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.PMC_WPSR.Reg) & 0xffff00) >> 8
}

// PMC.PMC_PCER1: Peripheral Clock Enable Register 1
func (o *PMC_Type) SetPMC_PCER1_PID32(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_PCER1_PID32() uint32 {
	return volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_PCER1_PID33(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetPMC_PCER1_PID33() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetPMC_PCER1_PID34(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_PCER1_PID34() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_PCER1_PID35(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_PCER1_PID35() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_PCER1_PID36(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetPMC_PCER1_PID36() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetPMC_PCER1_PID37(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetPMC_PCER1_PID37() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetPMC_PCER1_PID38(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_PCER1_PID38() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_PCER1_PID39(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_PCER1_PID39() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_PCER1_PID40(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_PCER1_PID40() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_PCER1_PID41(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_PCER1_PID41() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_PCER1_PID42(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPMC_PCER1_PID42() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetPMC_PCER1_PID43(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetPMC_PCER1_PID43() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetPMC_PCER1_PID44(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPMC_PCER1_PID44() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPMC_PCER1_PID45(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetPMC_PCER1_PID45() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetPMC_PCER1_PID46(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetPMC_PCER1_PID46() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetPMC_PCER1_PID47(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetPMC_PCER1_PID47() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetPMC_PCER1_PID48(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_PCER1_PID48() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_PCER1_PID49(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_PCER1_PID49() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_PCER1_PID50(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_PCER1_PID50() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPMC_PCER1_PID51(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPMC_PCER1_PID51() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPMC_PCER1_PID53(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x300000)|value<<20)
}
func (o *PMC_Type) GetPMC_PCER1_PID53() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x300000) >> 20
}
func (o *PMC_Type) SetPMC_PCER1_PID54(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x400000)|value<<22)
}
func (o *PMC_Type) GetPMC_PCER1_PID54() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x400000) >> 22
}
func (o *PMC_Type) SetPMC_PCER1_PID55(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetPMC_PCER1_PID55() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x800000) >> 23
}
func (o *PMC_Type) SetPMC_PCER1_PID56(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetPMC_PCER1_PID56() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetPMC_PCER1_PID57(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetPMC_PCER1_PID57() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetPMC_PCER1_PID58(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetPMC_PCER1_PID58() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetPMC_PCER1_PID59(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetPMC_PCER1_PID59() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetPMC_PCER1_PID60(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPMC_PCER1_PID60() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetPMC_PCER1_PID61(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetPMC_PCER1_PID61() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x20000000) >> 29
}
func (o *PMC_Type) SetPMC_PCER1_PID62(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x40000000)|value<<30)
}
func (o *PMC_Type) GetPMC_PCER1_PID62() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x40000000) >> 30
}
func (o *PMC_Type) SetPMC_PCER1_PID63(value uint32) {
	volatile.StoreUint32(&o.PMC_PCER1.Reg, volatile.LoadUint32(&o.PMC_PCER1.Reg)&^(0x80000000)|value<<31)
}
func (o *PMC_Type) GetPMC_PCER1_PID63() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCER1.Reg) & 0x80000000) >> 31
}

// PMC.PMC_PCDR1: Peripheral Clock Disable Register 1
func (o *PMC_Type) SetPMC_PCDR1_PID32(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_PCDR1_PID32() uint32 {
	return volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_PCDR1_PID33(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetPMC_PCDR1_PID33() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetPMC_PCDR1_PID34(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_PCDR1_PID34() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_PCDR1_PID35(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_PCDR1_PID35() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_PCDR1_PID36(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetPMC_PCDR1_PID36() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetPMC_PCDR1_PID37(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetPMC_PCDR1_PID37() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetPMC_PCDR1_PID38(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_PCDR1_PID38() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_PCDR1_PID39(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_PCDR1_PID39() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_PCDR1_PID40(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_PCDR1_PID40() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_PCDR1_PID41(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_PCDR1_PID41() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_PCDR1_PID42(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPMC_PCDR1_PID42() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetPMC_PCDR1_PID43(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetPMC_PCDR1_PID43() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetPMC_PCDR1_PID44(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPMC_PCDR1_PID44() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPMC_PCDR1_PID45(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetPMC_PCDR1_PID45() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetPMC_PCDR1_PID46(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetPMC_PCDR1_PID46() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetPMC_PCDR1_PID47(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetPMC_PCDR1_PID47() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetPMC_PCDR1_PID48(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_PCDR1_PID48() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_PCDR1_PID49(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_PCDR1_PID49() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_PCDR1_PID50(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_PCDR1_PID50() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPMC_PCDR1_PID51(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPMC_PCDR1_PID51() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPMC_PCDR1_PID53(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x300000)|value<<20)
}
func (o *PMC_Type) GetPMC_PCDR1_PID53() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x300000) >> 20
}
func (o *PMC_Type) SetPMC_PCDR1_PID54(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x400000)|value<<22)
}
func (o *PMC_Type) GetPMC_PCDR1_PID54() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x400000) >> 22
}
func (o *PMC_Type) SetPMC_PCDR1_PID55(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetPMC_PCDR1_PID55() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x800000) >> 23
}
func (o *PMC_Type) SetPMC_PCDR1_PID56(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetPMC_PCDR1_PID56() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetPMC_PCDR1_PID57(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetPMC_PCDR1_PID57() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetPMC_PCDR1_PID58(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetPMC_PCDR1_PID58() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetPMC_PCDR1_PID59(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetPMC_PCDR1_PID59() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetPMC_PCDR1_PID60(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPMC_PCDR1_PID60() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetPMC_PCDR1_PID61(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetPMC_PCDR1_PID61() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x20000000) >> 29
}
func (o *PMC_Type) SetPMC_PCDR1_PID62(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x40000000)|value<<30)
}
func (o *PMC_Type) GetPMC_PCDR1_PID62() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x40000000) >> 30
}
func (o *PMC_Type) SetPMC_PCDR1_PID63(value uint32) {
	volatile.StoreUint32(&o.PMC_PCDR1.Reg, volatile.LoadUint32(&o.PMC_PCDR1.Reg)&^(0x80000000)|value<<31)
}
func (o *PMC_Type) GetPMC_PCDR1_PID63() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCDR1.Reg) & 0x80000000) >> 31
}

// PMC.PMC_PCSR1: Peripheral Clock Status Register 1
func (o *PMC_Type) SetPMC_PCSR1_PID32(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x1)|value)
}
func (o *PMC_Type) GetPMC_PCSR1_PID32() uint32 {
	return volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x1
}
func (o *PMC_Type) SetPMC_PCSR1_PID33(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x2)|value<<1)
}
func (o *PMC_Type) GetPMC_PCSR1_PID33() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x2) >> 1
}
func (o *PMC_Type) SetPMC_PCSR1_PID34(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x4)|value<<2)
}
func (o *PMC_Type) GetPMC_PCSR1_PID34() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x4) >> 2
}
func (o *PMC_Type) SetPMC_PCSR1_PID35(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x8)|value<<3)
}
func (o *PMC_Type) GetPMC_PCSR1_PID35() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x8) >> 3
}
func (o *PMC_Type) SetPMC_PCSR1_PID36(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x10)|value<<4)
}
func (o *PMC_Type) GetPMC_PCSR1_PID36() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x10) >> 4
}
func (o *PMC_Type) SetPMC_PCSR1_PID37(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x20)|value<<5)
}
func (o *PMC_Type) GetPMC_PCSR1_PID37() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x20) >> 5
}
func (o *PMC_Type) SetPMC_PCSR1_PID38(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x40)|value<<6)
}
func (o *PMC_Type) GetPMC_PCSR1_PID38() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x40) >> 6
}
func (o *PMC_Type) SetPMC_PCSR1_PID39(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x80)|value<<7)
}
func (o *PMC_Type) GetPMC_PCSR1_PID39() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x80) >> 7
}
func (o *PMC_Type) SetPMC_PCSR1_PID40(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x100)|value<<8)
}
func (o *PMC_Type) GetPMC_PCSR1_PID40() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x100) >> 8
}
func (o *PMC_Type) SetPMC_PCSR1_PID41(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x200)|value<<9)
}
func (o *PMC_Type) GetPMC_PCSR1_PID41() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x200) >> 9
}
func (o *PMC_Type) SetPMC_PCSR1_PID42(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x400)|value<<10)
}
func (o *PMC_Type) GetPMC_PCSR1_PID42() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x400) >> 10
}
func (o *PMC_Type) SetPMC_PCSR1_PID43(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x800)|value<<11)
}
func (o *PMC_Type) GetPMC_PCSR1_PID43() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x800) >> 11
}
func (o *PMC_Type) SetPMC_PCSR1_PID44(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPMC_PCSR1_PID44() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPMC_PCSR1_PID45(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x2000)|value<<13)
}
func (o *PMC_Type) GetPMC_PCSR1_PID45() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x2000) >> 13
}
func (o *PMC_Type) SetPMC_PCSR1_PID46(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x4000)|value<<14)
}
func (o *PMC_Type) GetPMC_PCSR1_PID46() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x4000) >> 14
}
func (o *PMC_Type) SetPMC_PCSR1_PID47(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x8000)|value<<15)
}
func (o *PMC_Type) GetPMC_PCSR1_PID47() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x8000) >> 15
}
func (o *PMC_Type) SetPMC_PCSR1_PID48(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x10000)|value<<16)
}
func (o *PMC_Type) GetPMC_PCSR1_PID48() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x10000) >> 16
}
func (o *PMC_Type) SetPMC_PCSR1_PID49(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x20000)|value<<17)
}
func (o *PMC_Type) GetPMC_PCSR1_PID49() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x20000) >> 17
}
func (o *PMC_Type) SetPMC_PCSR1_PID50(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x40000)|value<<18)
}
func (o *PMC_Type) GetPMC_PCSR1_PID50() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x40000) >> 18
}
func (o *PMC_Type) SetPMC_PCSR1_PID51(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x80000)|value<<19)
}
func (o *PMC_Type) GetPMC_PCSR1_PID51() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x80000) >> 19
}
func (o *PMC_Type) SetPMC_PCSR1_PID53(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x300000)|value<<20)
}
func (o *PMC_Type) GetPMC_PCSR1_PID53() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x300000) >> 20
}
func (o *PMC_Type) SetPMC_PCSR1_PID54(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x400000)|value<<22)
}
func (o *PMC_Type) GetPMC_PCSR1_PID54() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x400000) >> 22
}
func (o *PMC_Type) SetPMC_PCSR1_PID55(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x800000)|value<<23)
}
func (o *PMC_Type) GetPMC_PCSR1_PID55() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x800000) >> 23
}
func (o *PMC_Type) SetPMC_PCSR1_PID56(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x1000000)|value<<24)
}
func (o *PMC_Type) GetPMC_PCSR1_PID56() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x1000000) >> 24
}
func (o *PMC_Type) SetPMC_PCSR1_PID57(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x2000000)|value<<25)
}
func (o *PMC_Type) GetPMC_PCSR1_PID57() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x2000000) >> 25
}
func (o *PMC_Type) SetPMC_PCSR1_PID58(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x4000000)|value<<26)
}
func (o *PMC_Type) GetPMC_PCSR1_PID58() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x4000000) >> 26
}
func (o *PMC_Type) SetPMC_PCSR1_PID59(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x8000000)|value<<27)
}
func (o *PMC_Type) GetPMC_PCSR1_PID59() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x8000000) >> 27
}
func (o *PMC_Type) SetPMC_PCSR1_PID60(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPMC_PCSR1_PID60() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x10000000) >> 28
}
func (o *PMC_Type) SetPMC_PCSR1_PID61(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x20000000)|value<<29)
}
func (o *PMC_Type) GetPMC_PCSR1_PID61() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x20000000) >> 29
}
func (o *PMC_Type) SetPMC_PCSR1_PID62(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x40000000)|value<<30)
}
func (o *PMC_Type) GetPMC_PCSR1_PID62() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x40000000) >> 30
}
func (o *PMC_Type) SetPMC_PCSR1_PID63(value uint32) {
	volatile.StoreUint32(&o.PMC_PCSR1.Reg, volatile.LoadUint32(&o.PMC_PCSR1.Reg)&^(0x80000000)|value<<31)
}
func (o *PMC_Type) GetPMC_PCSR1_PID63() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCSR1.Reg) & 0x80000000) >> 31
}

// PMC.PMC_PCR: Peripheral Control Register
func (o *PMC_Type) SetPMC_PCR_PID(value uint32) {
	volatile.StoreUint32(&o.PMC_PCR.Reg, volatile.LoadUint32(&o.PMC_PCR.Reg)&^(0x3f)|value)
}
func (o *PMC_Type) GetPMC_PCR_PID() uint32 {
	return volatile.LoadUint32(&o.PMC_PCR.Reg) & 0x3f
}
func (o *PMC_Type) SetPMC_PCR_CMD(value uint32) {
	volatile.StoreUint32(&o.PMC_PCR.Reg, volatile.LoadUint32(&o.PMC_PCR.Reg)&^(0x1000)|value<<12)
}
func (o *PMC_Type) GetPMC_PCR_CMD() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCR.Reg) & 0x1000) >> 12
}
func (o *PMC_Type) SetPMC_PCR_DIV(value uint32) {
	volatile.StoreUint32(&o.PMC_PCR.Reg, volatile.LoadUint32(&o.PMC_PCR.Reg)&^(0x30000)|value<<16)
}
func (o *PMC_Type) GetPMC_PCR_DIV() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCR.Reg) & 0x30000) >> 16
}
func (o *PMC_Type) SetPMC_PCR_EN(value uint32) {
	volatile.StoreUint32(&o.PMC_PCR.Reg, volatile.LoadUint32(&o.PMC_PCR.Reg)&^(0x10000000)|value<<28)
}
func (o *PMC_Type) GetPMC_PCR_EN() uint32 {
	return (volatile.LoadUint32(&o.PMC_PCR.Reg) & 0x10000000) >> 28
}

// Reset Controller
type SYSC_Type struct {
	CR volatile.Register32 // 0x0
	SR volatile.Register32 // 0x4
	MR volatile.Register32 // 0x8
}

// SYSC.CR: Control Register
func (o *SYSC_Type) SetCR_PROCRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetCR_PROCRST() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *SYSC_Type) SetCR_PERRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *SYSC_Type) GetCR_PERRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *SYSC_Type) SetCR_EXTRST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *SYSC_Type) GetCR_EXTRST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *SYSC_Type) SetCR_KEY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSC_Type) GetCR_KEY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xff000000) >> 24
}

// SYSC.SR: Status Register
func (o *SYSC_Type) SetSR_URSTS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SYSC_Type) GetSR_URSTS() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *SYSC_Type) SetSR_RSTTYP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x700)|value<<8)
}
func (o *SYSC_Type) GetSR_RSTTYP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x700) >> 8
}
func (o *SYSC_Type) SetSR_NRSTL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *SYSC_Type) GetSR_NRSTL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *SYSC_Type) SetSR_SRCMP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *SYSC_Type) GetSR_SRCMP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}

// SYSC.MR: Mode Register
func (o *SYSC_Type) SetMR_ERSTL(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xf00)|value<<8)
}
func (o *SYSC_Type) GetMR_ERSTL() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xf00) >> 8
}
func (o *SYSC_Type) SetMR_KEY(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSC_Type) GetMR_KEY() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xff000000) >> 24
}

// Constants for SMD: Software Modem Device
const ()

// Constants for AXIMX: AXI Matrix
const (
	// REMAP: Remap Register
	// Position of REMAP0 field.
	AXIMX_REMAP_REMAP0_Pos = 0x0
	// Bit mask of REMAP0 field.
	AXIMX_REMAP_REMAP0_Msk = 0x1
	// Bit REMAP0.
	AXIMX_REMAP_REMAP0 = 0x1
	// Position of REMAP1 field.
	AXIMX_REMAP_REMAP1_Pos = 0x1
	// Bit mask of REMAP1 field.
	AXIMX_REMAP_REMAP1_Msk = 0x2
	// Bit REMAP1.
	AXIMX_REMAP_REMAP1 = 0x2

	// PERIPH_ID4: Peripheral ID Register 4
	// Position of ID field.
	AXIMX_PERIPH_ID4_ID_Pos = 0x0
	// Bit mask of ID field.
	AXIMX_PERIPH_ID4_ID_Msk = 0xff
	// Part Number
	AXIMX_PERIPH_ID4_ID_ID0 = 0x1
	// 4KB count, JEP106 continuation code
	AXIMX_PERIPH_ID4_ID_ID4 = 0x4
	// JEP106[3:0, part number[11:8]
	AXIMX_PERIPH_ID4_ID_ID1 = 0xb3
	// Revision, JEP106 code flag, JEP106[6:4]
	AXIMX_PERIPH_ID4_ID_ID2 = 0xb6

	// PERIPH_ID5: Peripheral ID Register 5
	// Position of ID field.
	AXIMX_PERIPH_ID5_ID_Pos = 0x0
	// Bit mask of ID field.
	AXIMX_PERIPH_ID5_ID_Msk = 0xff
	// Part Number
	AXIMX_PERIPH_ID5_ID_ID0 = 0x1
	// 4KB count, JEP106 continuation code
	AXIMX_PERIPH_ID5_ID_ID4 = 0x4
	// JEP106[3:0, part number[11:8]
	AXIMX_PERIPH_ID5_ID_ID1 = 0xb3
	// Revision, JEP106 code flag, JEP106[6:4]
	AXIMX_PERIPH_ID5_ID_ID2 = 0xb6

	// PERIPH_ID6: Peripheral ID Register 6
	// Position of ID field.
	AXIMX_PERIPH_ID6_ID_Pos = 0x0
	// Bit mask of ID field.
	AXIMX_PERIPH_ID6_ID_Msk = 0xff
	// Part Number
	AXIMX_PERIPH_ID6_ID_ID0 = 0x1
	// 4KB count, JEP106 continuation code
	AXIMX_PERIPH_ID6_ID_ID4 = 0x4
	// JEP106[3:0, part number[11:8]
	AXIMX_PERIPH_ID6_ID_ID1 = 0xb3
	// Revision, JEP106 code flag, JEP106[6:4]
	AXIMX_PERIPH_ID6_ID_ID2 = 0xb6

	// PERIPH_ID7: Peripheral ID Register 7
	// Position of ID field.
	AXIMX_PERIPH_ID7_ID_Pos = 0x0
	// Bit mask of ID field.
	AXIMX_PERIPH_ID7_ID_Msk = 0xff
	// Part Number
	AXIMX_PERIPH_ID7_ID_ID0 = 0x1
	// 4KB count, JEP106 continuation code
	AXIMX_PERIPH_ID7_ID_ID4 = 0x4
	// JEP106[3:0, part number[11:8]
	AXIMX_PERIPH_ID7_ID_ID1 = 0xb3
	// Revision, JEP106 code flag, JEP106[6:4]
	AXIMX_PERIPH_ID7_ID_ID2 = 0xb6

	// PERIPH_ID0: Peripheral ID Register 0
	// Position of ID field.
	AXIMX_PERIPH_ID0_ID_Pos = 0x0
	// Bit mask of ID field.
	AXIMX_PERIPH_ID0_ID_Msk = 0xff
	// Part Number
	AXIMX_PERIPH_ID0_ID_ID0 = 0x1
	// 4KB count, JEP106 continuation code
	AXIMX_PERIPH_ID0_ID_ID4 = 0x4
	// JEP106[3:0, part number[11:8]
	AXIMX_PERIPH_ID0_ID_ID1 = 0xb3
	// Revision, JEP106 code flag, JEP106[6:4]
	AXIMX_PERIPH_ID0_ID_ID2 = 0xb6

	// PERIPH_ID1: Peripheral ID Register 1
	// Position of ID field.
	AXIMX_PERIPH_ID1_ID_Pos = 0x0
	// Bit mask of ID field.
	AXIMX_PERIPH_ID1_ID_Msk = 0xff
	// Part Number
	AXIMX_PERIPH_ID1_ID_ID0 = 0x1
	// 4KB count, JEP106 continuation code
	AXIMX_PERIPH_ID1_ID_ID4 = 0x4
	// JEP106[3:0, part number[11:8]
	AXIMX_PERIPH_ID1_ID_ID1 = 0xb3
	// Revision, JEP106 code flag, JEP106[6:4]
	AXIMX_PERIPH_ID1_ID_ID2 = 0xb6

	// PERIPH_ID2: Peripheral ID Register 2
	// Position of ID field.
	AXIMX_PERIPH_ID2_ID_Pos = 0x0
	// Bit mask of ID field.
	AXIMX_PERIPH_ID2_ID_Msk = 0xff
	// Part Number
	AXIMX_PERIPH_ID2_ID_ID0 = 0x1
	// 4KB count, JEP106 continuation code
	AXIMX_PERIPH_ID2_ID_ID4 = 0x4
	// JEP106[3:0, part number[11:8]
	AXIMX_PERIPH_ID2_ID_ID1 = 0xb3
	// Revision, JEP106 code flag, JEP106[6:4]
	AXIMX_PERIPH_ID2_ID_ID2 = 0xb6

	// PERIPH_ID3: Peripheral ID Register 3
	// Position of ID field.
	AXIMX_PERIPH_ID3_ID_Pos = 0x0
	// Bit mask of ID field.
	AXIMX_PERIPH_ID3_ID_Msk = 0xff
	// Part Number
	AXIMX_PERIPH_ID3_ID_ID0 = 0x1
	// 4KB count, JEP106 continuation code
	AXIMX_PERIPH_ID3_ID_ID4 = 0x4
	// JEP106[3:0, part number[11:8]
	AXIMX_PERIPH_ID3_ID_ID1 = 0xb3
	// Revision, JEP106 code flag, JEP106[6:4]
	AXIMX_PERIPH_ID3_ID_ID2 = 0xb6

	// COMP_ID: Component ID Register
	// Position of ID field.
	AXIMX_COMP_ID_ID_Pos = 0x0
	// Bit mask of ID field.
	AXIMX_COMP_ID_ID_Msk = 0xff

	// AMIB3_FN_MOD_BM_ISS: AMIB3 Bus Matrix Functionality Modification Register
	// Position of RD_ISS field.
	AXIMX_AMIB3_FN_MOD_BM_ISS_RD_ISS_Pos = 0x0
	// Bit mask of RD_ISS field.
	AXIMX_AMIB3_FN_MOD_BM_ISS_RD_ISS_Msk = 0x1
	// Bit RD_ISS.
	AXIMX_AMIB3_FN_MOD_BM_ISS_RD_ISS = 0x1
	// Position of WR_ISS field.
	AXIMX_AMIB3_FN_MOD_BM_ISS_WR_ISS_Pos = 0x1
	// Bit mask of WR_ISS field.
	AXIMX_AMIB3_FN_MOD_BM_ISS_WR_ISS_Msk = 0x2
	// Bit WR_ISS.
	AXIMX_AMIB3_FN_MOD_BM_ISS_WR_ISS = 0x2

	// AMIB3_FN_MOD2: AMIB3 Bypass Merge
	// Position of BP_MRG field.
	AXIMX_AMIB3_FN_MOD2_BP_MRG_Pos = 0x0
	// Bit mask of BP_MRG field.
	AXIMX_AMIB3_FN_MOD2_BP_MRG_Msk = 0x1
	// Bit BP_MRG.
	AXIMX_AMIB3_FN_MOD2_BP_MRG = 0x1

	// ASIB0_READ_QOS: ASIB0 Read Channel QoS Register
	// Position of RD_QOS field.
	AXIMX_ASIB0_READ_QOS_RD_QOS_Pos = 0x0
	// Bit mask of RD_QOS field.
	AXIMX_ASIB0_READ_QOS_RD_QOS_Msk = 0xf

	// ASIB0_WRITE_QOS: ASIB0 Write Channel QoS Register
	// Position of WR_QOS field.
	AXIMX_ASIB0_WRITE_QOS_WR_QOS_Pos = 0x0
	// Bit mask of WR_QOS field.
	AXIMX_ASIB0_WRITE_QOS_WR_QOS_Msk = 0xf

	// ASIB1_FN_MOD_AHB: ASIB1 AHB Functionality Modification Register
	// Position of RD_INCR_OVR field.
	AXIMX_ASIB1_FN_MOD_AHB_RD_INCR_OVR_Pos = 0x0
	// Bit mask of RD_INCR_OVR field.
	AXIMX_ASIB1_FN_MOD_AHB_RD_INCR_OVR_Msk = 0x1
	// Bit RD_INCR_OVR.
	AXIMX_ASIB1_FN_MOD_AHB_RD_INCR_OVR = 0x1
	// Position of WR_INCR_OVR field.
	AXIMX_ASIB1_FN_MOD_AHB_WR_INCR_OVR_Pos = 0x1
	// Bit mask of WR_INCR_OVR field.
	AXIMX_ASIB1_FN_MOD_AHB_WR_INCR_OVR_Msk = 0x2
	// Bit WR_INCR_OVR.
	AXIMX_ASIB1_FN_MOD_AHB_WR_INCR_OVR = 0x2
	// Position of LOCK_OVR field.
	AXIMX_ASIB1_FN_MOD_AHB_LOCK_OVR_Pos = 0x2
	// Bit mask of LOCK_OVR field.
	AXIMX_ASIB1_FN_MOD_AHB_LOCK_OVR_Msk = 0x4
	// Bit LOCK_OVR.
	AXIMX_ASIB1_FN_MOD_AHB_LOCK_OVR = 0x4

	// ASIB1_READ_QOS: ASIB1 Read Channel QoS Register
	// Position of RD_QOS field.
	AXIMX_ASIB1_READ_QOS_RD_QOS_Pos = 0x0
	// Bit mask of RD_QOS field.
	AXIMX_ASIB1_READ_QOS_RD_QOS_Msk = 0xf

	// ASIB1_WRITE_QOS: ASIB1 Write Channel QoS Register
	// Position of WR_QOS field.
	AXIMX_ASIB1_WRITE_QOS_WR_QOS_Pos = 0x0
	// Bit mask of WR_QOS field.
	AXIMX_ASIB1_WRITE_QOS_WR_QOS_Msk = 0xf

	// ASIB1_FN_MOD: ASIB1 Issuing Functionality Modification Register
	// Position of RD_ISS field.
	AXIMX_ASIB1_FN_MOD_RD_ISS_Pos = 0x0
	// Bit mask of RD_ISS field.
	AXIMX_ASIB1_FN_MOD_RD_ISS_Msk = 0x1
	// Bit RD_ISS.
	AXIMX_ASIB1_FN_MOD_RD_ISS = 0x1
	// Position of WR_ISS field.
	AXIMX_ASIB1_FN_MOD_WR_ISS_Pos = 0x1
	// Bit mask of WR_ISS field.
	AXIMX_ASIB1_FN_MOD_WR_ISS_Msk = 0x2
	// Bit WR_ISS.
	AXIMX_ASIB1_FN_MOD_WR_ISS = 0x2
)

// Constants for HSMCI0: High Speed MultiMedia Card Interface 0
const (
	// CR: Control Register
	// Position of MCIEN field.
	HSMCI_CR_MCIEN_Pos = 0x0
	// Bit mask of MCIEN field.
	HSMCI_CR_MCIEN_Msk = 0x1
	// Bit MCIEN.
	HSMCI_CR_MCIEN = 0x1
	// Position of MCIDIS field.
	HSMCI_CR_MCIDIS_Pos = 0x1
	// Bit mask of MCIDIS field.
	HSMCI_CR_MCIDIS_Msk = 0x2
	// Bit MCIDIS.
	HSMCI_CR_MCIDIS = 0x2
	// Position of PWSEN field.
	HSMCI_CR_PWSEN_Pos = 0x2
	// Bit mask of PWSEN field.
	HSMCI_CR_PWSEN_Msk = 0x4
	// Bit PWSEN.
	HSMCI_CR_PWSEN = 0x4
	// Position of PWSDIS field.
	HSMCI_CR_PWSDIS_Pos = 0x3
	// Bit mask of PWSDIS field.
	HSMCI_CR_PWSDIS_Msk = 0x8
	// Bit PWSDIS.
	HSMCI_CR_PWSDIS = 0x8
	// Position of SWRST field.
	HSMCI_CR_SWRST_Pos = 0x7
	// Bit mask of SWRST field.
	HSMCI_CR_SWRST_Msk = 0x80
	// Bit SWRST.
	HSMCI_CR_SWRST = 0x80

	// MR: Mode Register
	// Position of CLKDIV field.
	HSMCI_MR_CLKDIV_Pos = 0x0
	// Bit mask of CLKDIV field.
	HSMCI_MR_CLKDIV_Msk = 0xff
	// Position of PWSDIV field.
	HSMCI_MR_PWSDIV_Pos = 0x8
	// Bit mask of PWSDIV field.
	HSMCI_MR_PWSDIV_Msk = 0x700
	// Position of RDPROOF field.
	HSMCI_MR_RDPROOF_Pos = 0xb
	// Bit mask of RDPROOF field.
	HSMCI_MR_RDPROOF_Msk = 0x800
	// Bit RDPROOF.
	HSMCI_MR_RDPROOF = 0x800
	// Position of WRPROOF field.
	HSMCI_MR_WRPROOF_Pos = 0xc
	// Bit mask of WRPROOF field.
	HSMCI_MR_WRPROOF_Msk = 0x1000
	// Bit WRPROOF.
	HSMCI_MR_WRPROOF = 0x1000
	// Position of FBYTE field.
	HSMCI_MR_FBYTE_Pos = 0xd
	// Bit mask of FBYTE field.
	HSMCI_MR_FBYTE_Msk = 0x2000
	// Bit FBYTE.
	HSMCI_MR_FBYTE = 0x2000
	// Position of PADV field.
	HSMCI_MR_PADV_Pos = 0xe
	// Bit mask of PADV field.
	HSMCI_MR_PADV_Msk = 0x4000
	// Bit PADV.
	HSMCI_MR_PADV = 0x4000
	// Position of CLKODD field.
	HSMCI_MR_CLKODD_Pos = 0x10
	// Bit mask of CLKODD field.
	HSMCI_MR_CLKODD_Msk = 0x10000
	// Bit CLKODD.
	HSMCI_MR_CLKODD = 0x10000

	// DTOR: Data Timeout Register
	// Position of DTOCYC field.
	HSMCI_DTOR_DTOCYC_Pos = 0x0
	// Bit mask of DTOCYC field.
	HSMCI_DTOR_DTOCYC_Msk = 0xf
	// Position of DTOMUL field.
	HSMCI_DTOR_DTOMUL_Pos = 0x4
	// Bit mask of DTOMUL field.
	HSMCI_DTOR_DTOMUL_Msk = 0x70
	// DTOCYC
	HSMCI_DTOR_DTOMUL_1 = 0x0
	// DTOCYC x 16
	HSMCI_DTOR_DTOMUL_16 = 0x1
	// DTOCYC x 128
	HSMCI_DTOR_DTOMUL_128 = 0x2
	// DTOCYC x 256
	HSMCI_DTOR_DTOMUL_256 = 0x3
	// DTOCYC x 1024
	HSMCI_DTOR_DTOMUL_1024 = 0x4
	// DTOCYC x 4096
	HSMCI_DTOR_DTOMUL_4096 = 0x5
	// DTOCYC x 65536
	HSMCI_DTOR_DTOMUL_65536 = 0x6
	// DTOCYC x 1048576
	HSMCI_DTOR_DTOMUL_1048576 = 0x7

	// SDCR: SD/SDIO Card Register
	// Position of SDCSEL field.
	HSMCI_SDCR_SDCSEL_Pos = 0x0
	// Bit mask of SDCSEL field.
	HSMCI_SDCR_SDCSEL_Msk = 0x3
	// Slot A is selected.
	HSMCI_SDCR_SDCSEL_SLOTA = 0x0
	// Position of SDCBUS field.
	HSMCI_SDCR_SDCBUS_Pos = 0x6
	// Bit mask of SDCBUS field.
	HSMCI_SDCR_SDCBUS_Msk = 0xc0
	// 1 bit
	HSMCI_SDCR_SDCBUS_1 = 0x0
	// 4 bit
	HSMCI_SDCR_SDCBUS_4 = 0x2
	// 8 bit
	HSMCI_SDCR_SDCBUS_8 = 0x3

	// ARGR: Argument Register
	// Position of ARG field.
	HSMCI_ARGR_ARG_Pos = 0x0
	// Bit mask of ARG field.
	HSMCI_ARGR_ARG_Msk = 0xffffffff

	// CMDR: Command Register
	// Position of CMDNB field.
	HSMCI_CMDR_CMDNB_Pos = 0x0
	// Bit mask of CMDNB field.
	HSMCI_CMDR_CMDNB_Msk = 0x3f
	// Position of RSPTYP field.
	HSMCI_CMDR_RSPTYP_Pos = 0x6
	// Bit mask of RSPTYP field.
	HSMCI_CMDR_RSPTYP_Msk = 0xc0
	// No response.
	HSMCI_CMDR_RSPTYP_NORESP = 0x0
	// 48-bit response.
	HSMCI_CMDR_RSPTYP_48_BIT = 0x1
	// 136-bit response.
	HSMCI_CMDR_RSPTYP_136_BIT = 0x2
	// R1b response type
	HSMCI_CMDR_RSPTYP_R1B = 0x3
	// Position of SPCMD field.
	HSMCI_CMDR_SPCMD_Pos = 0x8
	// Bit mask of SPCMD field.
	HSMCI_CMDR_SPCMD_Msk = 0x700
	// Not a special CMD.
	HSMCI_CMDR_SPCMD_STD = 0x0
	// Initialization CMD: 74 clock cycles for initialization sequence.
	HSMCI_CMDR_SPCMD_INIT = 0x1
	// Synchronized CMD: Wait for the end of the current data block transfer before sending the pending command.
	HSMCI_CMDR_SPCMD_SYNC = 0x2
	// CE-ATA Completion Signal disable Command. The host cancels the ability for the device to return a command completion signal on the command line.
	HSMCI_CMDR_SPCMD_CE_ATA = 0x3
	// Interrupt command: Corresponds to the Interrupt Mode (CMD40).
	HSMCI_CMDR_SPCMD_IT_CMD = 0x4
	// Interrupt response: Corresponds to the Interrupt Mode (CMD40).
	HSMCI_CMDR_SPCMD_IT_RESP = 0x5
	// Boot Operation Request. Start a boot operation mode, the host processor can read boot data from the MMC device directly.
	HSMCI_CMDR_SPCMD_BOR = 0x6
	// End Boot Operation. This command allows the host processor to terminate the boot operation mode.
	HSMCI_CMDR_SPCMD_EBO = 0x7
	// Position of OPDCMD field.
	HSMCI_CMDR_OPDCMD_Pos = 0xb
	// Bit mask of OPDCMD field.
	HSMCI_CMDR_OPDCMD_Msk = 0x800
	// Bit OPDCMD.
	HSMCI_CMDR_OPDCMD = 0x800
	// Push pull command.
	HSMCI_CMDR_OPDCMD_PUSHPULL = 0x0
	// Open drain command.
	HSMCI_CMDR_OPDCMD_OPENDRAIN = 0x1
	// Position of MAXLAT field.
	HSMCI_CMDR_MAXLAT_Pos = 0xc
	// Bit mask of MAXLAT field.
	HSMCI_CMDR_MAXLAT_Msk = 0x1000
	// Bit MAXLAT.
	HSMCI_CMDR_MAXLAT = 0x1000
	// 5-cycle max latency.
	HSMCI_CMDR_MAXLAT_5 = 0x0
	// 64-cycle max latency.
	HSMCI_CMDR_MAXLAT_64 = 0x1
	// Position of TRCMD field.
	HSMCI_CMDR_TRCMD_Pos = 0x10
	// Bit mask of TRCMD field.
	HSMCI_CMDR_TRCMD_Msk = 0x30000
	// No data transfer
	HSMCI_CMDR_TRCMD_NO_DATA = 0x0
	// Start data transfer
	HSMCI_CMDR_TRCMD_START_DATA = 0x1
	// Stop data transfer
	HSMCI_CMDR_TRCMD_STOP_DATA = 0x2
	// Position of TRDIR field.
	HSMCI_CMDR_TRDIR_Pos = 0x12
	// Bit mask of TRDIR field.
	HSMCI_CMDR_TRDIR_Msk = 0x40000
	// Bit TRDIR.
	HSMCI_CMDR_TRDIR = 0x40000
	// Write.
	HSMCI_CMDR_TRDIR_WRITE = 0x0
	// Read.
	HSMCI_CMDR_TRDIR_READ = 0x1
	// Position of TRTYP field.
	HSMCI_CMDR_TRTYP_Pos = 0x13
	// Bit mask of TRTYP field.
	HSMCI_CMDR_TRTYP_Msk = 0x380000
	// MMC/SD Card Single Block
	HSMCI_CMDR_TRTYP_SINGLE = 0x0
	// MMC/SD Card Multiple Block
	HSMCI_CMDR_TRTYP_MULTIPLE = 0x1
	// MMC Stream
	HSMCI_CMDR_TRTYP_STREAM = 0x2
	// SDIO Byte
	HSMCI_CMDR_TRTYP_BYTE = 0x4
	// SDIO Block
	HSMCI_CMDR_TRTYP_BLOCK = 0x5
	// Position of IOSPCMD field.
	HSMCI_CMDR_IOSPCMD_Pos = 0x18
	// Bit mask of IOSPCMD field.
	HSMCI_CMDR_IOSPCMD_Msk = 0x3000000
	// Not an SDIO Special Command
	HSMCI_CMDR_IOSPCMD_STD = 0x0
	// SDIO Suspend Command
	HSMCI_CMDR_IOSPCMD_SUSPEND = 0x1
	// SDIO Resume Command
	HSMCI_CMDR_IOSPCMD_RESUME = 0x2
	// Position of ATACS field.
	HSMCI_CMDR_ATACS_Pos = 0x1a
	// Bit mask of ATACS field.
	HSMCI_CMDR_ATACS_Msk = 0x4000000
	// Bit ATACS.
	HSMCI_CMDR_ATACS = 0x4000000
	// Normal operation mode.
	HSMCI_CMDR_ATACS_NORMAL = 0x0
	// This bit indicates that a completion signal is expected within a programmed amount of time (HSMCI_CSTOR).
	HSMCI_CMDR_ATACS_COMPLETION = 0x1
	// Position of BOOT_ACK field.
	HSMCI_CMDR_BOOT_ACK_Pos = 0x1b
	// Bit mask of BOOT_ACK field.
	HSMCI_CMDR_BOOT_ACK_Msk = 0x8000000
	// Bit BOOT_ACK.
	HSMCI_CMDR_BOOT_ACK = 0x8000000

	// BLKR: Block Register
	// Position of BCNT field.
	HSMCI_BLKR_BCNT_Pos = 0x0
	// Bit mask of BCNT field.
	HSMCI_BLKR_BCNT_Msk = 0xffff
	// Position of BLKLEN field.
	HSMCI_BLKR_BLKLEN_Pos = 0x10
	// Bit mask of BLKLEN field.
	HSMCI_BLKR_BLKLEN_Msk = 0xffff0000

	// CSTOR: Completion Signal Timeout Register
	// Position of CSTOCYC field.
	HSMCI_CSTOR_CSTOCYC_Pos = 0x0
	// Bit mask of CSTOCYC field.
	HSMCI_CSTOR_CSTOCYC_Msk = 0xf
	// Position of CSTOMUL field.
	HSMCI_CSTOR_CSTOMUL_Pos = 0x4
	// Bit mask of CSTOMUL field.
	HSMCI_CSTOR_CSTOMUL_Msk = 0x70
	// CSTOCYC x 1
	HSMCI_CSTOR_CSTOMUL_1 = 0x0
	// CSTOCYC x 16
	HSMCI_CSTOR_CSTOMUL_16 = 0x1
	// CSTOCYC x 128
	HSMCI_CSTOR_CSTOMUL_128 = 0x2
	// CSTOCYC x 256
	HSMCI_CSTOR_CSTOMUL_256 = 0x3
	// CSTOCYC x 1024
	HSMCI_CSTOR_CSTOMUL_1024 = 0x4
	// CSTOCYC x 4096
	HSMCI_CSTOR_CSTOMUL_4096 = 0x5
	// CSTOCYC x 65536
	HSMCI_CSTOR_CSTOMUL_65536 = 0x6
	// CSTOCYC x 1048576
	HSMCI_CSTOR_CSTOMUL_1048576 = 0x7

	// RSPR: Response Register
	// Position of RSP field.
	HSMCI_RSPR_RSP_Pos = 0x0
	// Bit mask of RSP field.
	HSMCI_RSPR_RSP_Msk = 0xffffffff

	// RDR: Receive Data Register
	// Position of DATA field.
	HSMCI_RDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	HSMCI_RDR_DATA_Msk = 0xffffffff

	// TDR: Transmit Data Register
	// Position of DATA field.
	HSMCI_TDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	HSMCI_TDR_DATA_Msk = 0xffffffff

	// SR: Status Register
	// Position of CMDRDY field.
	HSMCI_SR_CMDRDY_Pos = 0x0
	// Bit mask of CMDRDY field.
	HSMCI_SR_CMDRDY_Msk = 0x1
	// Bit CMDRDY.
	HSMCI_SR_CMDRDY = 0x1
	// Position of RXRDY field.
	HSMCI_SR_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	HSMCI_SR_RXRDY_Msk = 0x2
	// Bit RXRDY.
	HSMCI_SR_RXRDY = 0x2
	// Position of TXRDY field.
	HSMCI_SR_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	HSMCI_SR_TXRDY_Msk = 0x4
	// Bit TXRDY.
	HSMCI_SR_TXRDY = 0x4
	// Position of BLKE field.
	HSMCI_SR_BLKE_Pos = 0x3
	// Bit mask of BLKE field.
	HSMCI_SR_BLKE_Msk = 0x8
	// Bit BLKE.
	HSMCI_SR_BLKE = 0x8
	// Position of DTIP field.
	HSMCI_SR_DTIP_Pos = 0x4
	// Bit mask of DTIP field.
	HSMCI_SR_DTIP_Msk = 0x10
	// Bit DTIP.
	HSMCI_SR_DTIP = 0x10
	// Position of NOTBUSY field.
	HSMCI_SR_NOTBUSY_Pos = 0x5
	// Bit mask of NOTBUSY field.
	HSMCI_SR_NOTBUSY_Msk = 0x20
	// Bit NOTBUSY.
	HSMCI_SR_NOTBUSY = 0x20
	// Position of SDIOIRQA field.
	HSMCI_SR_SDIOIRQA_Pos = 0x8
	// Bit mask of SDIOIRQA field.
	HSMCI_SR_SDIOIRQA_Msk = 0x100
	// Bit SDIOIRQA.
	HSMCI_SR_SDIOIRQA = 0x100
	// Position of SDIOWAIT field.
	HSMCI_SR_SDIOWAIT_Pos = 0xc
	// Bit mask of SDIOWAIT field.
	HSMCI_SR_SDIOWAIT_Msk = 0x1000
	// Bit SDIOWAIT.
	HSMCI_SR_SDIOWAIT = 0x1000
	// Position of CSRCV field.
	HSMCI_SR_CSRCV_Pos = 0xd
	// Bit mask of CSRCV field.
	HSMCI_SR_CSRCV_Msk = 0x2000
	// Bit CSRCV.
	HSMCI_SR_CSRCV = 0x2000
	// Position of RINDE field.
	HSMCI_SR_RINDE_Pos = 0x10
	// Bit mask of RINDE field.
	HSMCI_SR_RINDE_Msk = 0x10000
	// Bit RINDE.
	HSMCI_SR_RINDE = 0x10000
	// Position of RDIRE field.
	HSMCI_SR_RDIRE_Pos = 0x11
	// Bit mask of RDIRE field.
	HSMCI_SR_RDIRE_Msk = 0x20000
	// Bit RDIRE.
	HSMCI_SR_RDIRE = 0x20000
	// Position of RCRCE field.
	HSMCI_SR_RCRCE_Pos = 0x12
	// Bit mask of RCRCE field.
	HSMCI_SR_RCRCE_Msk = 0x40000
	// Bit RCRCE.
	HSMCI_SR_RCRCE = 0x40000
	// Position of RENDE field.
	HSMCI_SR_RENDE_Pos = 0x13
	// Bit mask of RENDE field.
	HSMCI_SR_RENDE_Msk = 0x80000
	// Bit RENDE.
	HSMCI_SR_RENDE = 0x80000
	// Position of RTOE field.
	HSMCI_SR_RTOE_Pos = 0x14
	// Bit mask of RTOE field.
	HSMCI_SR_RTOE_Msk = 0x100000
	// Bit RTOE.
	HSMCI_SR_RTOE = 0x100000
	// Position of DCRCE field.
	HSMCI_SR_DCRCE_Pos = 0x15
	// Bit mask of DCRCE field.
	HSMCI_SR_DCRCE_Msk = 0x200000
	// Bit DCRCE.
	HSMCI_SR_DCRCE = 0x200000
	// Position of DTOE field.
	HSMCI_SR_DTOE_Pos = 0x16
	// Bit mask of DTOE field.
	HSMCI_SR_DTOE_Msk = 0x400000
	// Bit DTOE.
	HSMCI_SR_DTOE = 0x400000
	// Position of CSTOE field.
	HSMCI_SR_CSTOE_Pos = 0x17
	// Bit mask of CSTOE field.
	HSMCI_SR_CSTOE_Msk = 0x800000
	// Bit CSTOE.
	HSMCI_SR_CSTOE = 0x800000
	// Position of BLKOVRE field.
	HSMCI_SR_BLKOVRE_Pos = 0x18
	// Bit mask of BLKOVRE field.
	HSMCI_SR_BLKOVRE_Msk = 0x1000000
	// Bit BLKOVRE.
	HSMCI_SR_BLKOVRE = 0x1000000
	// Position of DMADONE field.
	HSMCI_SR_DMADONE_Pos = 0x19
	// Bit mask of DMADONE field.
	HSMCI_SR_DMADONE_Msk = 0x2000000
	// Bit DMADONE.
	HSMCI_SR_DMADONE = 0x2000000
	// Position of FIFOEMPTY field.
	HSMCI_SR_FIFOEMPTY_Pos = 0x1a
	// Bit mask of FIFOEMPTY field.
	HSMCI_SR_FIFOEMPTY_Msk = 0x4000000
	// Bit FIFOEMPTY.
	HSMCI_SR_FIFOEMPTY = 0x4000000
	// Position of XFRDONE field.
	HSMCI_SR_XFRDONE_Pos = 0x1b
	// Bit mask of XFRDONE field.
	HSMCI_SR_XFRDONE_Msk = 0x8000000
	// Bit XFRDONE.
	HSMCI_SR_XFRDONE = 0x8000000
	// Position of ACKRCV field.
	HSMCI_SR_ACKRCV_Pos = 0x1c
	// Bit mask of ACKRCV field.
	HSMCI_SR_ACKRCV_Msk = 0x10000000
	// Bit ACKRCV.
	HSMCI_SR_ACKRCV = 0x10000000
	// Position of ACKRCVE field.
	HSMCI_SR_ACKRCVE_Pos = 0x1d
	// Bit mask of ACKRCVE field.
	HSMCI_SR_ACKRCVE_Msk = 0x20000000
	// Bit ACKRCVE.
	HSMCI_SR_ACKRCVE = 0x20000000
	// Position of OVRE field.
	HSMCI_SR_OVRE_Pos = 0x1e
	// Bit mask of OVRE field.
	HSMCI_SR_OVRE_Msk = 0x40000000
	// Bit OVRE.
	HSMCI_SR_OVRE = 0x40000000
	// Position of UNRE field.
	HSMCI_SR_UNRE_Pos = 0x1f
	// Bit mask of UNRE field.
	HSMCI_SR_UNRE_Msk = 0x80000000
	// Bit UNRE.
	HSMCI_SR_UNRE = 0x80000000

	// IER: Interrupt Enable Register
	// Position of CMDRDY field.
	HSMCI_IER_CMDRDY_Pos = 0x0
	// Bit mask of CMDRDY field.
	HSMCI_IER_CMDRDY_Msk = 0x1
	// Bit CMDRDY.
	HSMCI_IER_CMDRDY = 0x1
	// Position of RXRDY field.
	HSMCI_IER_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	HSMCI_IER_RXRDY_Msk = 0x2
	// Bit RXRDY.
	HSMCI_IER_RXRDY = 0x2
	// Position of TXRDY field.
	HSMCI_IER_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	HSMCI_IER_TXRDY_Msk = 0x4
	// Bit TXRDY.
	HSMCI_IER_TXRDY = 0x4
	// Position of BLKE field.
	HSMCI_IER_BLKE_Pos = 0x3
	// Bit mask of BLKE field.
	HSMCI_IER_BLKE_Msk = 0x8
	// Bit BLKE.
	HSMCI_IER_BLKE = 0x8
	// Position of DTIP field.
	HSMCI_IER_DTIP_Pos = 0x4
	// Bit mask of DTIP field.
	HSMCI_IER_DTIP_Msk = 0x10
	// Bit DTIP.
	HSMCI_IER_DTIP = 0x10
	// Position of NOTBUSY field.
	HSMCI_IER_NOTBUSY_Pos = 0x5
	// Bit mask of NOTBUSY field.
	HSMCI_IER_NOTBUSY_Msk = 0x20
	// Bit NOTBUSY.
	HSMCI_IER_NOTBUSY = 0x20
	// Position of SDIOIRQA field.
	HSMCI_IER_SDIOIRQA_Pos = 0x8
	// Bit mask of SDIOIRQA field.
	HSMCI_IER_SDIOIRQA_Msk = 0x100
	// Bit SDIOIRQA.
	HSMCI_IER_SDIOIRQA = 0x100
	// Position of SDIOWAIT field.
	HSMCI_IER_SDIOWAIT_Pos = 0xc
	// Bit mask of SDIOWAIT field.
	HSMCI_IER_SDIOWAIT_Msk = 0x1000
	// Bit SDIOWAIT.
	HSMCI_IER_SDIOWAIT = 0x1000
	// Position of CSRCV field.
	HSMCI_IER_CSRCV_Pos = 0xd
	// Bit mask of CSRCV field.
	HSMCI_IER_CSRCV_Msk = 0x2000
	// Bit CSRCV.
	HSMCI_IER_CSRCV = 0x2000
	// Position of RINDE field.
	HSMCI_IER_RINDE_Pos = 0x10
	// Bit mask of RINDE field.
	HSMCI_IER_RINDE_Msk = 0x10000
	// Bit RINDE.
	HSMCI_IER_RINDE = 0x10000
	// Position of RDIRE field.
	HSMCI_IER_RDIRE_Pos = 0x11
	// Bit mask of RDIRE field.
	HSMCI_IER_RDIRE_Msk = 0x20000
	// Bit RDIRE.
	HSMCI_IER_RDIRE = 0x20000
	// Position of RCRCE field.
	HSMCI_IER_RCRCE_Pos = 0x12
	// Bit mask of RCRCE field.
	HSMCI_IER_RCRCE_Msk = 0x40000
	// Bit RCRCE.
	HSMCI_IER_RCRCE = 0x40000
	// Position of RENDE field.
	HSMCI_IER_RENDE_Pos = 0x13
	// Bit mask of RENDE field.
	HSMCI_IER_RENDE_Msk = 0x80000
	// Bit RENDE.
	HSMCI_IER_RENDE = 0x80000
	// Position of RTOE field.
	HSMCI_IER_RTOE_Pos = 0x14
	// Bit mask of RTOE field.
	HSMCI_IER_RTOE_Msk = 0x100000
	// Bit RTOE.
	HSMCI_IER_RTOE = 0x100000
	// Position of DCRCE field.
	HSMCI_IER_DCRCE_Pos = 0x15
	// Bit mask of DCRCE field.
	HSMCI_IER_DCRCE_Msk = 0x200000
	// Bit DCRCE.
	HSMCI_IER_DCRCE = 0x200000
	// Position of DTOE field.
	HSMCI_IER_DTOE_Pos = 0x16
	// Bit mask of DTOE field.
	HSMCI_IER_DTOE_Msk = 0x400000
	// Bit DTOE.
	HSMCI_IER_DTOE = 0x400000
	// Position of CSTOE field.
	HSMCI_IER_CSTOE_Pos = 0x17
	// Bit mask of CSTOE field.
	HSMCI_IER_CSTOE_Msk = 0x800000
	// Bit CSTOE.
	HSMCI_IER_CSTOE = 0x800000
	// Position of BLKOVRE field.
	HSMCI_IER_BLKOVRE_Pos = 0x18
	// Bit mask of BLKOVRE field.
	HSMCI_IER_BLKOVRE_Msk = 0x1000000
	// Bit BLKOVRE.
	HSMCI_IER_BLKOVRE = 0x1000000
	// Position of DMADONE field.
	HSMCI_IER_DMADONE_Pos = 0x19
	// Bit mask of DMADONE field.
	HSMCI_IER_DMADONE_Msk = 0x2000000
	// Bit DMADONE.
	HSMCI_IER_DMADONE = 0x2000000
	// Position of FIFOEMPTY field.
	HSMCI_IER_FIFOEMPTY_Pos = 0x1a
	// Bit mask of FIFOEMPTY field.
	HSMCI_IER_FIFOEMPTY_Msk = 0x4000000
	// Bit FIFOEMPTY.
	HSMCI_IER_FIFOEMPTY = 0x4000000
	// Position of XFRDONE field.
	HSMCI_IER_XFRDONE_Pos = 0x1b
	// Bit mask of XFRDONE field.
	HSMCI_IER_XFRDONE_Msk = 0x8000000
	// Bit XFRDONE.
	HSMCI_IER_XFRDONE = 0x8000000
	// Position of ACKRCV field.
	HSMCI_IER_ACKRCV_Pos = 0x1c
	// Bit mask of ACKRCV field.
	HSMCI_IER_ACKRCV_Msk = 0x10000000
	// Bit ACKRCV.
	HSMCI_IER_ACKRCV = 0x10000000
	// Position of ACKRCVE field.
	HSMCI_IER_ACKRCVE_Pos = 0x1d
	// Bit mask of ACKRCVE field.
	HSMCI_IER_ACKRCVE_Msk = 0x20000000
	// Bit ACKRCVE.
	HSMCI_IER_ACKRCVE = 0x20000000
	// Position of OVRE field.
	HSMCI_IER_OVRE_Pos = 0x1e
	// Bit mask of OVRE field.
	HSMCI_IER_OVRE_Msk = 0x40000000
	// Bit OVRE.
	HSMCI_IER_OVRE = 0x40000000
	// Position of UNRE field.
	HSMCI_IER_UNRE_Pos = 0x1f
	// Bit mask of UNRE field.
	HSMCI_IER_UNRE_Msk = 0x80000000
	// Bit UNRE.
	HSMCI_IER_UNRE = 0x80000000

	// IDR: Interrupt Disable Register
	// Position of CMDRDY field.
	HSMCI_IDR_CMDRDY_Pos = 0x0
	// Bit mask of CMDRDY field.
	HSMCI_IDR_CMDRDY_Msk = 0x1
	// Bit CMDRDY.
	HSMCI_IDR_CMDRDY = 0x1
	// Position of RXRDY field.
	HSMCI_IDR_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	HSMCI_IDR_RXRDY_Msk = 0x2
	// Bit RXRDY.
	HSMCI_IDR_RXRDY = 0x2
	// Position of TXRDY field.
	HSMCI_IDR_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	HSMCI_IDR_TXRDY_Msk = 0x4
	// Bit TXRDY.
	HSMCI_IDR_TXRDY = 0x4
	// Position of BLKE field.
	HSMCI_IDR_BLKE_Pos = 0x3
	// Bit mask of BLKE field.
	HSMCI_IDR_BLKE_Msk = 0x8
	// Bit BLKE.
	HSMCI_IDR_BLKE = 0x8
	// Position of DTIP field.
	HSMCI_IDR_DTIP_Pos = 0x4
	// Bit mask of DTIP field.
	HSMCI_IDR_DTIP_Msk = 0x10
	// Bit DTIP.
	HSMCI_IDR_DTIP = 0x10
	// Position of NOTBUSY field.
	HSMCI_IDR_NOTBUSY_Pos = 0x5
	// Bit mask of NOTBUSY field.
	HSMCI_IDR_NOTBUSY_Msk = 0x20
	// Bit NOTBUSY.
	HSMCI_IDR_NOTBUSY = 0x20
	// Position of SDIOIRQA field.
	HSMCI_IDR_SDIOIRQA_Pos = 0x8
	// Bit mask of SDIOIRQA field.
	HSMCI_IDR_SDIOIRQA_Msk = 0x100
	// Bit SDIOIRQA.
	HSMCI_IDR_SDIOIRQA = 0x100
	// Position of SDIOWAIT field.
	HSMCI_IDR_SDIOWAIT_Pos = 0xc
	// Bit mask of SDIOWAIT field.
	HSMCI_IDR_SDIOWAIT_Msk = 0x1000
	// Bit SDIOWAIT.
	HSMCI_IDR_SDIOWAIT = 0x1000
	// Position of CSRCV field.
	HSMCI_IDR_CSRCV_Pos = 0xd
	// Bit mask of CSRCV field.
	HSMCI_IDR_CSRCV_Msk = 0x2000
	// Bit CSRCV.
	HSMCI_IDR_CSRCV = 0x2000
	// Position of RINDE field.
	HSMCI_IDR_RINDE_Pos = 0x10
	// Bit mask of RINDE field.
	HSMCI_IDR_RINDE_Msk = 0x10000
	// Bit RINDE.
	HSMCI_IDR_RINDE = 0x10000
	// Position of RDIRE field.
	HSMCI_IDR_RDIRE_Pos = 0x11
	// Bit mask of RDIRE field.
	HSMCI_IDR_RDIRE_Msk = 0x20000
	// Bit RDIRE.
	HSMCI_IDR_RDIRE = 0x20000
	// Position of RCRCE field.
	HSMCI_IDR_RCRCE_Pos = 0x12
	// Bit mask of RCRCE field.
	HSMCI_IDR_RCRCE_Msk = 0x40000
	// Bit RCRCE.
	HSMCI_IDR_RCRCE = 0x40000
	// Position of RENDE field.
	HSMCI_IDR_RENDE_Pos = 0x13
	// Bit mask of RENDE field.
	HSMCI_IDR_RENDE_Msk = 0x80000
	// Bit RENDE.
	HSMCI_IDR_RENDE = 0x80000
	// Position of RTOE field.
	HSMCI_IDR_RTOE_Pos = 0x14
	// Bit mask of RTOE field.
	HSMCI_IDR_RTOE_Msk = 0x100000
	// Bit RTOE.
	HSMCI_IDR_RTOE = 0x100000
	// Position of DCRCE field.
	HSMCI_IDR_DCRCE_Pos = 0x15
	// Bit mask of DCRCE field.
	HSMCI_IDR_DCRCE_Msk = 0x200000
	// Bit DCRCE.
	HSMCI_IDR_DCRCE = 0x200000
	// Position of DTOE field.
	HSMCI_IDR_DTOE_Pos = 0x16
	// Bit mask of DTOE field.
	HSMCI_IDR_DTOE_Msk = 0x400000
	// Bit DTOE.
	HSMCI_IDR_DTOE = 0x400000
	// Position of CSTOE field.
	HSMCI_IDR_CSTOE_Pos = 0x17
	// Bit mask of CSTOE field.
	HSMCI_IDR_CSTOE_Msk = 0x800000
	// Bit CSTOE.
	HSMCI_IDR_CSTOE = 0x800000
	// Position of BLKOVRE field.
	HSMCI_IDR_BLKOVRE_Pos = 0x18
	// Bit mask of BLKOVRE field.
	HSMCI_IDR_BLKOVRE_Msk = 0x1000000
	// Bit BLKOVRE.
	HSMCI_IDR_BLKOVRE = 0x1000000
	// Position of DMADONE field.
	HSMCI_IDR_DMADONE_Pos = 0x19
	// Bit mask of DMADONE field.
	HSMCI_IDR_DMADONE_Msk = 0x2000000
	// Bit DMADONE.
	HSMCI_IDR_DMADONE = 0x2000000
	// Position of FIFOEMPTY field.
	HSMCI_IDR_FIFOEMPTY_Pos = 0x1a
	// Bit mask of FIFOEMPTY field.
	HSMCI_IDR_FIFOEMPTY_Msk = 0x4000000
	// Bit FIFOEMPTY.
	HSMCI_IDR_FIFOEMPTY = 0x4000000
	// Position of XFRDONE field.
	HSMCI_IDR_XFRDONE_Pos = 0x1b
	// Bit mask of XFRDONE field.
	HSMCI_IDR_XFRDONE_Msk = 0x8000000
	// Bit XFRDONE.
	HSMCI_IDR_XFRDONE = 0x8000000
	// Position of ACKRCV field.
	HSMCI_IDR_ACKRCV_Pos = 0x1c
	// Bit mask of ACKRCV field.
	HSMCI_IDR_ACKRCV_Msk = 0x10000000
	// Bit ACKRCV.
	HSMCI_IDR_ACKRCV = 0x10000000
	// Position of ACKRCVE field.
	HSMCI_IDR_ACKRCVE_Pos = 0x1d
	// Bit mask of ACKRCVE field.
	HSMCI_IDR_ACKRCVE_Msk = 0x20000000
	// Bit ACKRCVE.
	HSMCI_IDR_ACKRCVE = 0x20000000
	// Position of OVRE field.
	HSMCI_IDR_OVRE_Pos = 0x1e
	// Bit mask of OVRE field.
	HSMCI_IDR_OVRE_Msk = 0x40000000
	// Bit OVRE.
	HSMCI_IDR_OVRE = 0x40000000
	// Position of UNRE field.
	HSMCI_IDR_UNRE_Pos = 0x1f
	// Bit mask of UNRE field.
	HSMCI_IDR_UNRE_Msk = 0x80000000
	// Bit UNRE.
	HSMCI_IDR_UNRE = 0x80000000

	// IMR: Interrupt Mask Register
	// Position of CMDRDY field.
	HSMCI_IMR_CMDRDY_Pos = 0x0
	// Bit mask of CMDRDY field.
	HSMCI_IMR_CMDRDY_Msk = 0x1
	// Bit CMDRDY.
	HSMCI_IMR_CMDRDY = 0x1
	// Position of RXRDY field.
	HSMCI_IMR_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	HSMCI_IMR_RXRDY_Msk = 0x2
	// Bit RXRDY.
	HSMCI_IMR_RXRDY = 0x2
	// Position of TXRDY field.
	HSMCI_IMR_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	HSMCI_IMR_TXRDY_Msk = 0x4
	// Bit TXRDY.
	HSMCI_IMR_TXRDY = 0x4
	// Position of BLKE field.
	HSMCI_IMR_BLKE_Pos = 0x3
	// Bit mask of BLKE field.
	HSMCI_IMR_BLKE_Msk = 0x8
	// Bit BLKE.
	HSMCI_IMR_BLKE = 0x8
	// Position of DTIP field.
	HSMCI_IMR_DTIP_Pos = 0x4
	// Bit mask of DTIP field.
	HSMCI_IMR_DTIP_Msk = 0x10
	// Bit DTIP.
	HSMCI_IMR_DTIP = 0x10
	// Position of NOTBUSY field.
	HSMCI_IMR_NOTBUSY_Pos = 0x5
	// Bit mask of NOTBUSY field.
	HSMCI_IMR_NOTBUSY_Msk = 0x20
	// Bit NOTBUSY.
	HSMCI_IMR_NOTBUSY = 0x20
	// Position of SDIOIRQA field.
	HSMCI_IMR_SDIOIRQA_Pos = 0x8
	// Bit mask of SDIOIRQA field.
	HSMCI_IMR_SDIOIRQA_Msk = 0x100
	// Bit SDIOIRQA.
	HSMCI_IMR_SDIOIRQA = 0x100
	// Position of SDIOWAIT field.
	HSMCI_IMR_SDIOWAIT_Pos = 0xc
	// Bit mask of SDIOWAIT field.
	HSMCI_IMR_SDIOWAIT_Msk = 0x1000
	// Bit SDIOWAIT.
	HSMCI_IMR_SDIOWAIT = 0x1000
	// Position of CSRCV field.
	HSMCI_IMR_CSRCV_Pos = 0xd
	// Bit mask of CSRCV field.
	HSMCI_IMR_CSRCV_Msk = 0x2000
	// Bit CSRCV.
	HSMCI_IMR_CSRCV = 0x2000
	// Position of RINDE field.
	HSMCI_IMR_RINDE_Pos = 0x10
	// Bit mask of RINDE field.
	HSMCI_IMR_RINDE_Msk = 0x10000
	// Bit RINDE.
	HSMCI_IMR_RINDE = 0x10000
	// Position of RDIRE field.
	HSMCI_IMR_RDIRE_Pos = 0x11
	// Bit mask of RDIRE field.
	HSMCI_IMR_RDIRE_Msk = 0x20000
	// Bit RDIRE.
	HSMCI_IMR_RDIRE = 0x20000
	// Position of RCRCE field.
	HSMCI_IMR_RCRCE_Pos = 0x12
	// Bit mask of RCRCE field.
	HSMCI_IMR_RCRCE_Msk = 0x40000
	// Bit RCRCE.
	HSMCI_IMR_RCRCE = 0x40000
	// Position of RENDE field.
	HSMCI_IMR_RENDE_Pos = 0x13
	// Bit mask of RENDE field.
	HSMCI_IMR_RENDE_Msk = 0x80000
	// Bit RENDE.
	HSMCI_IMR_RENDE = 0x80000
	// Position of RTOE field.
	HSMCI_IMR_RTOE_Pos = 0x14
	// Bit mask of RTOE field.
	HSMCI_IMR_RTOE_Msk = 0x100000
	// Bit RTOE.
	HSMCI_IMR_RTOE = 0x100000
	// Position of DCRCE field.
	HSMCI_IMR_DCRCE_Pos = 0x15
	// Bit mask of DCRCE field.
	HSMCI_IMR_DCRCE_Msk = 0x200000
	// Bit DCRCE.
	HSMCI_IMR_DCRCE = 0x200000
	// Position of DTOE field.
	HSMCI_IMR_DTOE_Pos = 0x16
	// Bit mask of DTOE field.
	HSMCI_IMR_DTOE_Msk = 0x400000
	// Bit DTOE.
	HSMCI_IMR_DTOE = 0x400000
	// Position of CSTOE field.
	HSMCI_IMR_CSTOE_Pos = 0x17
	// Bit mask of CSTOE field.
	HSMCI_IMR_CSTOE_Msk = 0x800000
	// Bit CSTOE.
	HSMCI_IMR_CSTOE = 0x800000
	// Position of BLKOVRE field.
	HSMCI_IMR_BLKOVRE_Pos = 0x18
	// Bit mask of BLKOVRE field.
	HSMCI_IMR_BLKOVRE_Msk = 0x1000000
	// Bit BLKOVRE.
	HSMCI_IMR_BLKOVRE = 0x1000000
	// Position of DMADONE field.
	HSMCI_IMR_DMADONE_Pos = 0x19
	// Bit mask of DMADONE field.
	HSMCI_IMR_DMADONE_Msk = 0x2000000
	// Bit DMADONE.
	HSMCI_IMR_DMADONE = 0x2000000
	// Position of FIFOEMPTY field.
	HSMCI_IMR_FIFOEMPTY_Pos = 0x1a
	// Bit mask of FIFOEMPTY field.
	HSMCI_IMR_FIFOEMPTY_Msk = 0x4000000
	// Bit FIFOEMPTY.
	HSMCI_IMR_FIFOEMPTY = 0x4000000
	// Position of XFRDONE field.
	HSMCI_IMR_XFRDONE_Pos = 0x1b
	// Bit mask of XFRDONE field.
	HSMCI_IMR_XFRDONE_Msk = 0x8000000
	// Bit XFRDONE.
	HSMCI_IMR_XFRDONE = 0x8000000
	// Position of ACKRCV field.
	HSMCI_IMR_ACKRCV_Pos = 0x1c
	// Bit mask of ACKRCV field.
	HSMCI_IMR_ACKRCV_Msk = 0x10000000
	// Bit ACKRCV.
	HSMCI_IMR_ACKRCV = 0x10000000
	// Position of ACKRCVE field.
	HSMCI_IMR_ACKRCVE_Pos = 0x1d
	// Bit mask of ACKRCVE field.
	HSMCI_IMR_ACKRCVE_Msk = 0x20000000
	// Bit ACKRCVE.
	HSMCI_IMR_ACKRCVE = 0x20000000
	// Position of OVRE field.
	HSMCI_IMR_OVRE_Pos = 0x1e
	// Bit mask of OVRE field.
	HSMCI_IMR_OVRE_Msk = 0x40000000
	// Bit OVRE.
	HSMCI_IMR_OVRE = 0x40000000
	// Position of UNRE field.
	HSMCI_IMR_UNRE_Pos = 0x1f
	// Bit mask of UNRE field.
	HSMCI_IMR_UNRE_Msk = 0x80000000
	// Bit UNRE.
	HSMCI_IMR_UNRE = 0x80000000

	// DMA: DMA Configuration Register
	// Position of OFFSET field.
	HSMCI_DMA_OFFSET_Pos = 0x0
	// Bit mask of OFFSET field.
	HSMCI_DMA_OFFSET_Msk = 0x3
	// Position of CHKSIZE field.
	HSMCI_DMA_CHKSIZE_Pos = 0x4
	// Bit mask of CHKSIZE field.
	HSMCI_DMA_CHKSIZE_Msk = 0x70
	// Position of DMAEN field.
	HSMCI_DMA_DMAEN_Pos = 0x8
	// Bit mask of DMAEN field.
	HSMCI_DMA_DMAEN_Msk = 0x100
	// Bit DMAEN.
	HSMCI_DMA_DMAEN = 0x100
	// Position of ROPT field.
	HSMCI_DMA_ROPT_Pos = 0xc
	// Bit mask of ROPT field.
	HSMCI_DMA_ROPT_Msk = 0x1000
	// Bit ROPT.
	HSMCI_DMA_ROPT = 0x1000

	// CFG: Configuration Register
	// Position of FIFOMODE field.
	HSMCI_CFG_FIFOMODE_Pos = 0x0
	// Bit mask of FIFOMODE field.
	HSMCI_CFG_FIFOMODE_Msk = 0x1
	// Bit FIFOMODE.
	HSMCI_CFG_FIFOMODE = 0x1
	// Position of FERRCTRL field.
	HSMCI_CFG_FERRCTRL_Pos = 0x4
	// Bit mask of FERRCTRL field.
	HSMCI_CFG_FERRCTRL_Msk = 0x10
	// Bit FERRCTRL.
	HSMCI_CFG_FERRCTRL = 0x10
	// Position of HSMODE field.
	HSMCI_CFG_HSMODE_Pos = 0x8
	// Bit mask of HSMODE field.
	HSMCI_CFG_HSMODE_Msk = 0x100
	// Bit HSMODE.
	HSMCI_CFG_HSMODE = 0x100
	// Position of LSYNC field.
	HSMCI_CFG_LSYNC_Pos = 0xc
	// Bit mask of LSYNC field.
	HSMCI_CFG_LSYNC_Msk = 0x1000
	// Bit LSYNC.
	HSMCI_CFG_LSYNC = 0x1000

	// WPMR: Write Protection Mode Register
	// Position of WP_EN field.
	HSMCI_WPMR_WP_EN_Pos = 0x0
	// Bit mask of WP_EN field.
	HSMCI_WPMR_WP_EN_Msk = 0x1
	// Bit WP_EN.
	HSMCI_WPMR_WP_EN = 0x1
	// Position of WP_KEY field.
	HSMCI_WPMR_WP_KEY_Pos = 0x8
	// Bit mask of WP_KEY field.
	HSMCI_WPMR_WP_KEY_Msk = 0xffffff00

	// WPSR: Write Protection Status Register
	// Position of WP_VS field.
	HSMCI_WPSR_WP_VS_Pos = 0x0
	// Bit mask of WP_VS field.
	HSMCI_WPSR_WP_VS_Msk = 0xf
	// No Write Protection Violation occurred since the last read of this register (WP_SR)
	HSMCI_WPSR_WP_VS_NONE = 0x0
	// Write Protection detected unauthorized attempt to write a control register had occurred (since the last read.)
	HSMCI_WPSR_WP_VS_WRITE = 0x1
	// Software reset had been performed while Write Protection was enabled (since the last read).
	HSMCI_WPSR_WP_VS_RESET = 0x2
	// Both Write Protection violation and software reset with Write Protection enabled have occurred since the last read.
	HSMCI_WPSR_WP_VS_BOTH = 0x3
	// Position of WP_VSRC field.
	HSMCI_WPSR_WP_VSRC_Pos = 0x8
	// Bit mask of WP_VSRC field.
	HSMCI_WPSR_WP_VSRC_Msk = 0xffff00

	// FIFO: FIFO Memory Aperture0
	// Position of DATA field.
	HSMCI_FIFO_DATA_Pos = 0x0
	// Bit mask of DATA field.
	HSMCI_FIFO_DATA_Msk = 0xffffffff
)

// Constants for SPI0: Serial Peripheral Interface 0
const (
	// CR: Control Register
	// Position of SPIEN field.
	SPI_CR_SPIEN_Pos = 0x0
	// Bit mask of SPIEN field.
	SPI_CR_SPIEN_Msk = 0x1
	// Bit SPIEN.
	SPI_CR_SPIEN = 0x1
	// Position of SPIDIS field.
	SPI_CR_SPIDIS_Pos = 0x1
	// Bit mask of SPIDIS field.
	SPI_CR_SPIDIS_Msk = 0x2
	// Bit SPIDIS.
	SPI_CR_SPIDIS = 0x2
	// Position of SWRST field.
	SPI_CR_SWRST_Pos = 0x7
	// Bit mask of SWRST field.
	SPI_CR_SWRST_Msk = 0x80
	// Bit SWRST.
	SPI_CR_SWRST = 0x80
	// Position of LASTXFER field.
	SPI_CR_LASTXFER_Pos = 0x18
	// Bit mask of LASTXFER field.
	SPI_CR_LASTXFER_Msk = 0x1000000
	// Bit LASTXFER.
	SPI_CR_LASTXFER = 0x1000000

	// MR: Mode Register
	// Position of MSTR field.
	SPI_MR_MSTR_Pos = 0x0
	// Bit mask of MSTR field.
	SPI_MR_MSTR_Msk = 0x1
	// Bit MSTR.
	SPI_MR_MSTR = 0x1
	// Position of PS field.
	SPI_MR_PS_Pos = 0x1
	// Bit mask of PS field.
	SPI_MR_PS_Msk = 0x2
	// Bit PS.
	SPI_MR_PS = 0x2
	// Position of PCSDEC field.
	SPI_MR_PCSDEC_Pos = 0x2
	// Bit mask of PCSDEC field.
	SPI_MR_PCSDEC_Msk = 0x4
	// Bit PCSDEC.
	SPI_MR_PCSDEC = 0x4
	// Position of MODFDIS field.
	SPI_MR_MODFDIS_Pos = 0x4
	// Bit mask of MODFDIS field.
	SPI_MR_MODFDIS_Msk = 0x10
	// Bit MODFDIS.
	SPI_MR_MODFDIS = 0x10
	// Position of WDRBT field.
	SPI_MR_WDRBT_Pos = 0x5
	// Bit mask of WDRBT field.
	SPI_MR_WDRBT_Msk = 0x20
	// Bit WDRBT.
	SPI_MR_WDRBT = 0x20
	// Position of LLB field.
	SPI_MR_LLB_Pos = 0x7
	// Bit mask of LLB field.
	SPI_MR_LLB_Msk = 0x80
	// Bit LLB.
	SPI_MR_LLB = 0x80
	// Position of PCS field.
	SPI_MR_PCS_Pos = 0x10
	// Bit mask of PCS field.
	SPI_MR_PCS_Msk = 0xf0000
	// Position of DLYBCS field.
	SPI_MR_DLYBCS_Pos = 0x18
	// Bit mask of DLYBCS field.
	SPI_MR_DLYBCS_Msk = 0xff000000

	// RDR: Receive Data Register
	// Position of RD field.
	SPI_RDR_RD_Pos = 0x0
	// Bit mask of RD field.
	SPI_RDR_RD_Msk = 0xffff
	// Position of PCS field.
	SPI_RDR_PCS_Pos = 0x10
	// Bit mask of PCS field.
	SPI_RDR_PCS_Msk = 0xf0000

	// TDR: Transmit Data Register
	// Position of TD field.
	SPI_TDR_TD_Pos = 0x0
	// Bit mask of TD field.
	SPI_TDR_TD_Msk = 0xffff
	// Position of PCS field.
	SPI_TDR_PCS_Pos = 0x10
	// Bit mask of PCS field.
	SPI_TDR_PCS_Msk = 0xf0000
	// Position of LASTXFER field.
	SPI_TDR_LASTXFER_Pos = 0x18
	// Bit mask of LASTXFER field.
	SPI_TDR_LASTXFER_Msk = 0x1000000
	// Bit LASTXFER.
	SPI_TDR_LASTXFER = 0x1000000

	// SR: Status Register
	// Position of RDRF field.
	SPI_SR_RDRF_Pos = 0x0
	// Bit mask of RDRF field.
	SPI_SR_RDRF_Msk = 0x1
	// Bit RDRF.
	SPI_SR_RDRF = 0x1
	// Position of TDRE field.
	SPI_SR_TDRE_Pos = 0x1
	// Bit mask of TDRE field.
	SPI_SR_TDRE_Msk = 0x2
	// Bit TDRE.
	SPI_SR_TDRE = 0x2
	// Position of MODF field.
	SPI_SR_MODF_Pos = 0x2
	// Bit mask of MODF field.
	SPI_SR_MODF_Msk = 0x4
	// Bit MODF.
	SPI_SR_MODF = 0x4
	// Position of OVRES field.
	SPI_SR_OVRES_Pos = 0x3
	// Bit mask of OVRES field.
	SPI_SR_OVRES_Msk = 0x8
	// Bit OVRES.
	SPI_SR_OVRES = 0x8
	// Position of NSSR field.
	SPI_SR_NSSR_Pos = 0x8
	// Bit mask of NSSR field.
	SPI_SR_NSSR_Msk = 0x100
	// Bit NSSR.
	SPI_SR_NSSR = 0x100
	// Position of TXEMPTY field.
	SPI_SR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	SPI_SR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	SPI_SR_TXEMPTY = 0x200
	// Position of UNDES field.
	SPI_SR_UNDES_Pos = 0xa
	// Bit mask of UNDES field.
	SPI_SR_UNDES_Msk = 0x400
	// Bit UNDES.
	SPI_SR_UNDES = 0x400
	// Position of SPIENS field.
	SPI_SR_SPIENS_Pos = 0x10
	// Bit mask of SPIENS field.
	SPI_SR_SPIENS_Msk = 0x10000
	// Bit SPIENS.
	SPI_SR_SPIENS = 0x10000

	// IER: Interrupt Enable Register
	// Position of RDRF field.
	SPI_IER_RDRF_Pos = 0x0
	// Bit mask of RDRF field.
	SPI_IER_RDRF_Msk = 0x1
	// Bit RDRF.
	SPI_IER_RDRF = 0x1
	// Position of TDRE field.
	SPI_IER_TDRE_Pos = 0x1
	// Bit mask of TDRE field.
	SPI_IER_TDRE_Msk = 0x2
	// Bit TDRE.
	SPI_IER_TDRE = 0x2
	// Position of MODF field.
	SPI_IER_MODF_Pos = 0x2
	// Bit mask of MODF field.
	SPI_IER_MODF_Msk = 0x4
	// Bit MODF.
	SPI_IER_MODF = 0x4
	// Position of OVRES field.
	SPI_IER_OVRES_Pos = 0x3
	// Bit mask of OVRES field.
	SPI_IER_OVRES_Msk = 0x8
	// Bit OVRES.
	SPI_IER_OVRES = 0x8
	// Position of NSSR field.
	SPI_IER_NSSR_Pos = 0x8
	// Bit mask of NSSR field.
	SPI_IER_NSSR_Msk = 0x100
	// Bit NSSR.
	SPI_IER_NSSR = 0x100
	// Position of TXEMPTY field.
	SPI_IER_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	SPI_IER_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	SPI_IER_TXEMPTY = 0x200
	// Position of UNDES field.
	SPI_IER_UNDES_Pos = 0xa
	// Bit mask of UNDES field.
	SPI_IER_UNDES_Msk = 0x400
	// Bit UNDES.
	SPI_IER_UNDES = 0x400

	// IDR: Interrupt Disable Register
	// Position of RDRF field.
	SPI_IDR_RDRF_Pos = 0x0
	// Bit mask of RDRF field.
	SPI_IDR_RDRF_Msk = 0x1
	// Bit RDRF.
	SPI_IDR_RDRF = 0x1
	// Position of TDRE field.
	SPI_IDR_TDRE_Pos = 0x1
	// Bit mask of TDRE field.
	SPI_IDR_TDRE_Msk = 0x2
	// Bit TDRE.
	SPI_IDR_TDRE = 0x2
	// Position of MODF field.
	SPI_IDR_MODF_Pos = 0x2
	// Bit mask of MODF field.
	SPI_IDR_MODF_Msk = 0x4
	// Bit MODF.
	SPI_IDR_MODF = 0x4
	// Position of OVRES field.
	SPI_IDR_OVRES_Pos = 0x3
	// Bit mask of OVRES field.
	SPI_IDR_OVRES_Msk = 0x8
	// Bit OVRES.
	SPI_IDR_OVRES = 0x8
	// Position of NSSR field.
	SPI_IDR_NSSR_Pos = 0x8
	// Bit mask of NSSR field.
	SPI_IDR_NSSR_Msk = 0x100
	// Bit NSSR.
	SPI_IDR_NSSR = 0x100
	// Position of TXEMPTY field.
	SPI_IDR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	SPI_IDR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	SPI_IDR_TXEMPTY = 0x200
	// Position of UNDES field.
	SPI_IDR_UNDES_Pos = 0xa
	// Bit mask of UNDES field.
	SPI_IDR_UNDES_Msk = 0x400
	// Bit UNDES.
	SPI_IDR_UNDES = 0x400

	// IMR: Interrupt Mask Register
	// Position of RDRF field.
	SPI_IMR_RDRF_Pos = 0x0
	// Bit mask of RDRF field.
	SPI_IMR_RDRF_Msk = 0x1
	// Bit RDRF.
	SPI_IMR_RDRF = 0x1
	// Position of TDRE field.
	SPI_IMR_TDRE_Pos = 0x1
	// Bit mask of TDRE field.
	SPI_IMR_TDRE_Msk = 0x2
	// Bit TDRE.
	SPI_IMR_TDRE = 0x2
	// Position of MODF field.
	SPI_IMR_MODF_Pos = 0x2
	// Bit mask of MODF field.
	SPI_IMR_MODF_Msk = 0x4
	// Bit MODF.
	SPI_IMR_MODF = 0x4
	// Position of OVRES field.
	SPI_IMR_OVRES_Pos = 0x3
	// Bit mask of OVRES field.
	SPI_IMR_OVRES_Msk = 0x8
	// Bit OVRES.
	SPI_IMR_OVRES = 0x8
	// Position of NSSR field.
	SPI_IMR_NSSR_Pos = 0x8
	// Bit mask of NSSR field.
	SPI_IMR_NSSR_Msk = 0x100
	// Bit NSSR.
	SPI_IMR_NSSR = 0x100
	// Position of TXEMPTY field.
	SPI_IMR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	SPI_IMR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	SPI_IMR_TXEMPTY = 0x200
	// Position of UNDES field.
	SPI_IMR_UNDES_Pos = 0xa
	// Bit mask of UNDES field.
	SPI_IMR_UNDES_Msk = 0x400
	// Bit UNDES.
	SPI_IMR_UNDES = 0x400

	// CSR: Chip Select Register
	// Position of CPOL field.
	SPI_CSR_CPOL_Pos = 0x0
	// Bit mask of CPOL field.
	SPI_CSR_CPOL_Msk = 0x1
	// Bit CPOL.
	SPI_CSR_CPOL = 0x1
	// Position of NCPHA field.
	SPI_CSR_NCPHA_Pos = 0x1
	// Bit mask of NCPHA field.
	SPI_CSR_NCPHA_Msk = 0x2
	// Bit NCPHA.
	SPI_CSR_NCPHA = 0x2
	// Position of CSNAAT field.
	SPI_CSR_CSNAAT_Pos = 0x2
	// Bit mask of CSNAAT field.
	SPI_CSR_CSNAAT_Msk = 0x4
	// Bit CSNAAT.
	SPI_CSR_CSNAAT = 0x4
	// Position of CSAAT field.
	SPI_CSR_CSAAT_Pos = 0x3
	// Bit mask of CSAAT field.
	SPI_CSR_CSAAT_Msk = 0x8
	// Bit CSAAT.
	SPI_CSR_CSAAT = 0x8
	// Position of BITS field.
	SPI_CSR_BITS_Pos = 0x4
	// Bit mask of BITS field.
	SPI_CSR_BITS_Msk = 0xf0
	// 8 bits for transfer
	SPI_CSR_BITS_8_BIT = 0x0
	// 9 bits for transfer
	SPI_CSR_BITS_9_BIT = 0x1
	// 10 bits for transfer
	SPI_CSR_BITS_10_BIT = 0x2
	// 11 bits for transfer
	SPI_CSR_BITS_11_BIT = 0x3
	// 12 bits for transfer
	SPI_CSR_BITS_12_BIT = 0x4
	// 13 bits for transfer
	SPI_CSR_BITS_13_BIT = 0x5
	// 14 bits for transfer
	SPI_CSR_BITS_14_BIT = 0x6
	// 15 bits for transfer
	SPI_CSR_BITS_15_BIT = 0x7
	// 16 bits for transfer
	SPI_CSR_BITS_16_BIT = 0x8
	// Position of SCBR field.
	SPI_CSR_SCBR_Pos = 0x8
	// Bit mask of SCBR field.
	SPI_CSR_SCBR_Msk = 0xff00
	// Position of DLYBS field.
	SPI_CSR_DLYBS_Pos = 0x10
	// Bit mask of DLYBS field.
	SPI_CSR_DLYBS_Msk = 0xff0000
	// Position of DLYBCT field.
	SPI_CSR_DLYBCT_Pos = 0x18
	// Bit mask of DLYBCT field.
	SPI_CSR_DLYBCT_Msk = 0xff000000

	// WPMR: Write Protection Control Register
	// Position of WPEN field.
	SPI_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	SPI_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	SPI_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	SPI_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	SPI_WPMR_WPKEY_Msk = 0xffffff00

	// WPSR: Write Protection Status Register
	// Position of WPVS field.
	SPI_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	SPI_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	SPI_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	SPI_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	SPI_WPSR_WPVSRC_Msk = 0xff00
)

// Constants for SSC0: Synchronous Serial Controller 0
const (
	// CR: Control Register
	// Position of RXEN field.
	SSC_CR_RXEN_Pos = 0x0
	// Bit mask of RXEN field.
	SSC_CR_RXEN_Msk = 0x1
	// Bit RXEN.
	SSC_CR_RXEN = 0x1
	// Position of RXDIS field.
	SSC_CR_RXDIS_Pos = 0x1
	// Bit mask of RXDIS field.
	SSC_CR_RXDIS_Msk = 0x2
	// Bit RXDIS.
	SSC_CR_RXDIS = 0x2
	// Position of TXEN field.
	SSC_CR_TXEN_Pos = 0x8
	// Bit mask of TXEN field.
	SSC_CR_TXEN_Msk = 0x100
	// Bit TXEN.
	SSC_CR_TXEN = 0x100
	// Position of TXDIS field.
	SSC_CR_TXDIS_Pos = 0x9
	// Bit mask of TXDIS field.
	SSC_CR_TXDIS_Msk = 0x200
	// Bit TXDIS.
	SSC_CR_TXDIS = 0x200
	// Position of SWRST field.
	SSC_CR_SWRST_Pos = 0xf
	// Bit mask of SWRST field.
	SSC_CR_SWRST_Msk = 0x8000
	// Bit SWRST.
	SSC_CR_SWRST = 0x8000

	// CMR: Clock Mode Register
	// Position of DIV field.
	SSC_CMR_DIV_Pos = 0x0
	// Bit mask of DIV field.
	SSC_CMR_DIV_Msk = 0xfff

	// RCMR: Receive Clock Mode Register
	// Position of CKS field.
	SSC_RCMR_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SSC_RCMR_CKS_Msk = 0x3
	// Divided Clock
	SSC_RCMR_CKS_MCK = 0x0
	// TK Clock signal
	SSC_RCMR_CKS_TK = 0x1
	// RK pin
	SSC_RCMR_CKS_RK = 0x2
	// Position of CKO field.
	SSC_RCMR_CKO_Pos = 0x2
	// Bit mask of CKO field.
	SSC_RCMR_CKO_Msk = 0x1c
	// None, RK pin is an input
	SSC_RCMR_CKO_NONE = 0x0
	// Continuous Receive Clock, RK pin is an output
	SSC_RCMR_CKO_CONTINUOUS = 0x1
	// Receive Clock only during data transfers, RK pin is an output
	SSC_RCMR_CKO_TRANSFER = 0x2
	// Position of CKI field.
	SSC_RCMR_CKI_Pos = 0x5
	// Bit mask of CKI field.
	SSC_RCMR_CKI_Msk = 0x20
	// Bit CKI.
	SSC_RCMR_CKI = 0x20
	// Position of CKG field.
	SSC_RCMR_CKG_Pos = 0x6
	// Bit mask of CKG field.
	SSC_RCMR_CKG_Msk = 0xc0
	// None
	SSC_RCMR_CKG_CONTINUOUS = 0x0
	// Receive Clock enabled only if RF Pin is Low
	SSC_RCMR_CKG_EN_RF_LOW = 0x1
	// Receive Clock enabled only if RF Pin is High
	SSC_RCMR_CKG_EN_RF_HIGH = 0x2
	// Position of START field.
	SSC_RCMR_START_Pos = 0x8
	// Bit mask of START field.
	SSC_RCMR_START_Msk = 0xf00
	// Continuous, as soon as the receiver is enabled, and immediately after the end of transfer of the previous data.
	SSC_RCMR_START_CONTINUOUS = 0x0
	// Transmit start
	SSC_RCMR_START_TRANSMIT = 0x1
	// Detection of a low level on RF signal
	SSC_RCMR_START_RF_LOW = 0x2
	// Detection of a high level on RF signal
	SSC_RCMR_START_RF_HIGH = 0x3
	// Detection of a falling edge on RF signal
	SSC_RCMR_START_RF_FALLING = 0x4
	// Detection of a rising edge on RF signal
	SSC_RCMR_START_RF_RISING = 0x5
	// Detection of any level change on RF signal
	SSC_RCMR_START_RF_LEVEL = 0x6
	// Detection of any edge on RF signal
	SSC_RCMR_START_RF_EDGE = 0x7
	// Compare 0
	SSC_RCMR_START_CMP_0 = 0x8
	// Position of STOP field.
	SSC_RCMR_STOP_Pos = 0xc
	// Bit mask of STOP field.
	SSC_RCMR_STOP_Msk = 0x1000
	// Bit STOP.
	SSC_RCMR_STOP = 0x1000
	// Position of STTDLY field.
	SSC_RCMR_STTDLY_Pos = 0x10
	// Bit mask of STTDLY field.
	SSC_RCMR_STTDLY_Msk = 0xff0000
	// Position of PERIOD field.
	SSC_RCMR_PERIOD_Pos = 0x18
	// Bit mask of PERIOD field.
	SSC_RCMR_PERIOD_Msk = 0xff000000

	// RFMR: Receive Frame Mode Register
	// Position of DATLEN field.
	SSC_RFMR_DATLEN_Pos = 0x0
	// Bit mask of DATLEN field.
	SSC_RFMR_DATLEN_Msk = 0x1f
	// Position of LOOP field.
	SSC_RFMR_LOOP_Pos = 0x5
	// Bit mask of LOOP field.
	SSC_RFMR_LOOP_Msk = 0x20
	// Bit LOOP.
	SSC_RFMR_LOOP = 0x20
	// Position of MSBF field.
	SSC_RFMR_MSBF_Pos = 0x7
	// Bit mask of MSBF field.
	SSC_RFMR_MSBF_Msk = 0x80
	// Bit MSBF.
	SSC_RFMR_MSBF = 0x80
	// Position of DATNB field.
	SSC_RFMR_DATNB_Pos = 0x8
	// Bit mask of DATNB field.
	SSC_RFMR_DATNB_Msk = 0xf00
	// Position of FSLEN field.
	SSC_RFMR_FSLEN_Pos = 0x10
	// Bit mask of FSLEN field.
	SSC_RFMR_FSLEN_Msk = 0xf0000
	// Position of FSOS field.
	SSC_RFMR_FSOS_Pos = 0x14
	// Bit mask of FSOS field.
	SSC_RFMR_FSOS_Msk = 0x700000
	// None, RF pin is an input
	SSC_RFMR_FSOS_NONE = 0x0
	// Negative Pulse, RF pin is an output
	SSC_RFMR_FSOS_NEGATIVE = 0x1
	// Positive Pulse, RF pin is an output
	SSC_RFMR_FSOS_POSITIVE = 0x2
	// Driven Low during data transfer, RF pin is an output
	SSC_RFMR_FSOS_LOW = 0x3
	// Driven High during data transfer, RF pin is an output
	SSC_RFMR_FSOS_HIGH = 0x4
	// Toggling at each start of data transfer, RF pin is an output
	SSC_RFMR_FSOS_TOGGLING = 0x5
	// Position of FSEDGE field.
	SSC_RFMR_FSEDGE_Pos = 0x18
	// Bit mask of FSEDGE field.
	SSC_RFMR_FSEDGE_Msk = 0x1000000
	// Bit FSEDGE.
	SSC_RFMR_FSEDGE = 0x1000000
	// Positive Edge Detection
	SSC_RFMR_FSEDGE_POSITIVE = 0x0
	// Negative Edge Detection
	SSC_RFMR_FSEDGE_NEGATIVE = 0x1
	// Position of FSLEN_EXT field.
	SSC_RFMR_FSLEN_EXT_Pos = 0x1c
	// Bit mask of FSLEN_EXT field.
	SSC_RFMR_FSLEN_EXT_Msk = 0xf0000000

	// TCMR: Transmit Clock Mode Register
	// Position of CKS field.
	SSC_TCMR_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SSC_TCMR_CKS_Msk = 0x3
	// Divided Clock
	SSC_TCMR_CKS_MCK = 0x0
	// RK Clock signal
	SSC_TCMR_CKS_RK = 0x1
	// TK pin
	SSC_TCMR_CKS_TK = 0x2
	// Position of CKO field.
	SSC_TCMR_CKO_Pos = 0x2
	// Bit mask of CKO field.
	SSC_TCMR_CKO_Msk = 0x1c
	// None, TK pin is an input
	SSC_TCMR_CKO_NONE = 0x0
	// Continuous Transmit Clock, TK pin is an output
	SSC_TCMR_CKO_CONTINUOUS = 0x1
	// Transmit Clock only during data transfers, TK pin is an output
	SSC_TCMR_CKO_TRANSFER = 0x2
	// Position of CKI field.
	SSC_TCMR_CKI_Pos = 0x5
	// Bit mask of CKI field.
	SSC_TCMR_CKI_Msk = 0x20
	// Bit CKI.
	SSC_TCMR_CKI = 0x20
	// Position of CKG field.
	SSC_TCMR_CKG_Pos = 0x6
	// Bit mask of CKG field.
	SSC_TCMR_CKG_Msk = 0xc0
	// None
	SSC_TCMR_CKG_CONTINUOUS = 0x0
	// Transmit Clock enabled only if TF pin is Low
	SSC_TCMR_CKG_EN_TF_LOW = 0x1
	// Transmit Clock enabled only if TF pin is High
	SSC_TCMR_CKG_EN_TF_HIGH = 0x2
	// Position of START field.
	SSC_TCMR_START_Pos = 0x8
	// Bit mask of START field.
	SSC_TCMR_START_Msk = 0xf00
	// Continuous, as soon as a word is written in the SSC_THR Register (if Transmit is enabled), and immediately after the end of transfer of the previous data.
	SSC_TCMR_START_CONTINUOUS = 0x0
	// Receive start
	SSC_TCMR_START_RECEIVE = 0x1
	// Detection of a low level on TF signal
	SSC_TCMR_START_TF_LOW = 0x2
	// Detection of a high level on TF signal
	SSC_TCMR_START_TF_HIGH = 0x3
	// Detection of a falling edge on TF signal
	SSC_TCMR_START_TF_FALLING = 0x4
	// Detection of a rising edge on TF signal
	SSC_TCMR_START_TF_RISING = 0x5
	// Detection of any level change on TF signal
	SSC_TCMR_START_TF_LEVEL = 0x6
	// Detection of any edge on TF signal
	SSC_TCMR_START_TF_EDGE = 0x7
	// Position of STTDLY field.
	SSC_TCMR_STTDLY_Pos = 0x10
	// Bit mask of STTDLY field.
	SSC_TCMR_STTDLY_Msk = 0xff0000
	// Position of PERIOD field.
	SSC_TCMR_PERIOD_Pos = 0x18
	// Bit mask of PERIOD field.
	SSC_TCMR_PERIOD_Msk = 0xff000000

	// TFMR: Transmit Frame Mode Register
	// Position of DATLEN field.
	SSC_TFMR_DATLEN_Pos = 0x0
	// Bit mask of DATLEN field.
	SSC_TFMR_DATLEN_Msk = 0x1f
	// Position of DATDEF field.
	SSC_TFMR_DATDEF_Pos = 0x5
	// Bit mask of DATDEF field.
	SSC_TFMR_DATDEF_Msk = 0x20
	// Bit DATDEF.
	SSC_TFMR_DATDEF = 0x20
	// Position of MSBF field.
	SSC_TFMR_MSBF_Pos = 0x7
	// Bit mask of MSBF field.
	SSC_TFMR_MSBF_Msk = 0x80
	// Bit MSBF.
	SSC_TFMR_MSBF = 0x80
	// Position of DATNB field.
	SSC_TFMR_DATNB_Pos = 0x8
	// Bit mask of DATNB field.
	SSC_TFMR_DATNB_Msk = 0xf00
	// Position of FSLEN field.
	SSC_TFMR_FSLEN_Pos = 0x10
	// Bit mask of FSLEN field.
	SSC_TFMR_FSLEN_Msk = 0xf0000
	// Position of FSOS field.
	SSC_TFMR_FSOS_Pos = 0x14
	// Bit mask of FSOS field.
	SSC_TFMR_FSOS_Msk = 0x700000
	// None, TF pin is an input
	SSC_TFMR_FSOS_NONE = 0x0
	// Negative Pulse, TF pin is an output
	SSC_TFMR_FSOS_NEGATIVE = 0x1
	// Positive Pulse,TF pin is an output
	SSC_TFMR_FSOS_POSITIVE = 0x2
	// TF pin Driven Low during data transfer
	SSC_TFMR_FSOS_LOW = 0x3
	// TF pin Driven High during data transfer
	SSC_TFMR_FSOS_HIGH = 0x4
	// TF pin Toggles at each start of data transfer
	SSC_TFMR_FSOS_TOGGLING = 0x5
	// Position of FSDEN field.
	SSC_TFMR_FSDEN_Pos = 0x17
	// Bit mask of FSDEN field.
	SSC_TFMR_FSDEN_Msk = 0x800000
	// Bit FSDEN.
	SSC_TFMR_FSDEN = 0x800000
	// Position of FSEDGE field.
	SSC_TFMR_FSEDGE_Pos = 0x18
	// Bit mask of FSEDGE field.
	SSC_TFMR_FSEDGE_Msk = 0x1000000
	// Bit FSEDGE.
	SSC_TFMR_FSEDGE = 0x1000000
	// Positive Edge Detection
	SSC_TFMR_FSEDGE_POSITIVE = 0x0
	// Negative Edge Detection
	SSC_TFMR_FSEDGE_NEGATIVE = 0x1
	// Position of FSLEN_EXT field.
	SSC_TFMR_FSLEN_EXT_Pos = 0x1c
	// Bit mask of FSLEN_EXT field.
	SSC_TFMR_FSLEN_EXT_Msk = 0xf0000000

	// RHR: Receive Holding Register
	// Position of RDAT field.
	SSC_RHR_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SSC_RHR_RDAT_Msk = 0xffffffff

	// THR: Transmit Holding Register
	// Position of TDAT field.
	SSC_THR_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SSC_THR_TDAT_Msk = 0xffffffff

	// RSHR: Receive Sync. Holding Register
	// Position of RSDAT field.
	SSC_RSHR_RSDAT_Pos = 0x0
	// Bit mask of RSDAT field.
	SSC_RSHR_RSDAT_Msk = 0xffff

	// TSHR: Transmit Sync. Holding Register
	// Position of TSDAT field.
	SSC_TSHR_TSDAT_Pos = 0x0
	// Bit mask of TSDAT field.
	SSC_TSHR_TSDAT_Msk = 0xffff

	// RC0R: Receive Compare 0 Register
	// Position of CP0 field.
	SSC_RC0R_CP0_Pos = 0x0
	// Bit mask of CP0 field.
	SSC_RC0R_CP0_Msk = 0xffff

	// RC1R: Receive Compare 1 Register
	// Position of CP1 field.
	SSC_RC1R_CP1_Pos = 0x0
	// Bit mask of CP1 field.
	SSC_RC1R_CP1_Msk = 0xffff

	// SR: Status Register
	// Position of TXRDY field.
	SSC_SR_TXRDY_Pos = 0x0
	// Bit mask of TXRDY field.
	SSC_SR_TXRDY_Msk = 0x1
	// Bit TXRDY.
	SSC_SR_TXRDY = 0x1
	// Position of TXEMPTY field.
	SSC_SR_TXEMPTY_Pos = 0x1
	// Bit mask of TXEMPTY field.
	SSC_SR_TXEMPTY_Msk = 0x2
	// Bit TXEMPTY.
	SSC_SR_TXEMPTY = 0x2
	// Position of RXRDY field.
	SSC_SR_RXRDY_Pos = 0x4
	// Bit mask of RXRDY field.
	SSC_SR_RXRDY_Msk = 0x10
	// Bit RXRDY.
	SSC_SR_RXRDY = 0x10
	// Position of OVRUN field.
	SSC_SR_OVRUN_Pos = 0x5
	// Bit mask of OVRUN field.
	SSC_SR_OVRUN_Msk = 0x20
	// Bit OVRUN.
	SSC_SR_OVRUN = 0x20
	// Position of CP0 field.
	SSC_SR_CP0_Pos = 0x8
	// Bit mask of CP0 field.
	SSC_SR_CP0_Msk = 0x100
	// Bit CP0.
	SSC_SR_CP0 = 0x100
	// Position of CP1 field.
	SSC_SR_CP1_Pos = 0x9
	// Bit mask of CP1 field.
	SSC_SR_CP1_Msk = 0x200
	// Bit CP1.
	SSC_SR_CP1 = 0x200
	// Position of TXSYN field.
	SSC_SR_TXSYN_Pos = 0xa
	// Bit mask of TXSYN field.
	SSC_SR_TXSYN_Msk = 0x400
	// Bit TXSYN.
	SSC_SR_TXSYN = 0x400
	// Position of RXSYN field.
	SSC_SR_RXSYN_Pos = 0xb
	// Bit mask of RXSYN field.
	SSC_SR_RXSYN_Msk = 0x800
	// Bit RXSYN.
	SSC_SR_RXSYN = 0x800
	// Position of TXEN field.
	SSC_SR_TXEN_Pos = 0x10
	// Bit mask of TXEN field.
	SSC_SR_TXEN_Msk = 0x10000
	// Bit TXEN.
	SSC_SR_TXEN = 0x10000
	// Position of RXEN field.
	SSC_SR_RXEN_Pos = 0x11
	// Bit mask of RXEN field.
	SSC_SR_RXEN_Msk = 0x20000
	// Bit RXEN.
	SSC_SR_RXEN = 0x20000

	// IER: Interrupt Enable Register
	// Position of TXRDY field.
	SSC_IER_TXRDY_Pos = 0x0
	// Bit mask of TXRDY field.
	SSC_IER_TXRDY_Msk = 0x1
	// Bit TXRDY.
	SSC_IER_TXRDY = 0x1
	// Position of TXEMPTY field.
	SSC_IER_TXEMPTY_Pos = 0x1
	// Bit mask of TXEMPTY field.
	SSC_IER_TXEMPTY_Msk = 0x2
	// Bit TXEMPTY.
	SSC_IER_TXEMPTY = 0x2
	// Position of RXRDY field.
	SSC_IER_RXRDY_Pos = 0x4
	// Bit mask of RXRDY field.
	SSC_IER_RXRDY_Msk = 0x10
	// Bit RXRDY.
	SSC_IER_RXRDY = 0x10
	// Position of OVRUN field.
	SSC_IER_OVRUN_Pos = 0x5
	// Bit mask of OVRUN field.
	SSC_IER_OVRUN_Msk = 0x20
	// Bit OVRUN.
	SSC_IER_OVRUN = 0x20
	// Position of CP0 field.
	SSC_IER_CP0_Pos = 0x8
	// Bit mask of CP0 field.
	SSC_IER_CP0_Msk = 0x100
	// Bit CP0.
	SSC_IER_CP0 = 0x100
	// Position of CP1 field.
	SSC_IER_CP1_Pos = 0x9
	// Bit mask of CP1 field.
	SSC_IER_CP1_Msk = 0x200
	// Bit CP1.
	SSC_IER_CP1 = 0x200
	// Position of TXSYN field.
	SSC_IER_TXSYN_Pos = 0xa
	// Bit mask of TXSYN field.
	SSC_IER_TXSYN_Msk = 0x400
	// Bit TXSYN.
	SSC_IER_TXSYN = 0x400
	// Position of RXSYN field.
	SSC_IER_RXSYN_Pos = 0xb
	// Bit mask of RXSYN field.
	SSC_IER_RXSYN_Msk = 0x800
	// Bit RXSYN.
	SSC_IER_RXSYN = 0x800

	// IDR: Interrupt Disable Register
	// Position of TXRDY field.
	SSC_IDR_TXRDY_Pos = 0x0
	// Bit mask of TXRDY field.
	SSC_IDR_TXRDY_Msk = 0x1
	// Bit TXRDY.
	SSC_IDR_TXRDY = 0x1
	// Position of TXEMPTY field.
	SSC_IDR_TXEMPTY_Pos = 0x1
	// Bit mask of TXEMPTY field.
	SSC_IDR_TXEMPTY_Msk = 0x2
	// Bit TXEMPTY.
	SSC_IDR_TXEMPTY = 0x2
	// Position of RXRDY field.
	SSC_IDR_RXRDY_Pos = 0x4
	// Bit mask of RXRDY field.
	SSC_IDR_RXRDY_Msk = 0x10
	// Bit RXRDY.
	SSC_IDR_RXRDY = 0x10
	// Position of OVRUN field.
	SSC_IDR_OVRUN_Pos = 0x5
	// Bit mask of OVRUN field.
	SSC_IDR_OVRUN_Msk = 0x20
	// Bit OVRUN.
	SSC_IDR_OVRUN = 0x20
	// Position of CP0 field.
	SSC_IDR_CP0_Pos = 0x8
	// Bit mask of CP0 field.
	SSC_IDR_CP0_Msk = 0x100
	// Bit CP0.
	SSC_IDR_CP0 = 0x100
	// Position of CP1 field.
	SSC_IDR_CP1_Pos = 0x9
	// Bit mask of CP1 field.
	SSC_IDR_CP1_Msk = 0x200
	// Bit CP1.
	SSC_IDR_CP1 = 0x200
	// Position of TXSYN field.
	SSC_IDR_TXSYN_Pos = 0xa
	// Bit mask of TXSYN field.
	SSC_IDR_TXSYN_Msk = 0x400
	// Bit TXSYN.
	SSC_IDR_TXSYN = 0x400
	// Position of RXSYN field.
	SSC_IDR_RXSYN_Pos = 0xb
	// Bit mask of RXSYN field.
	SSC_IDR_RXSYN_Msk = 0x800
	// Bit RXSYN.
	SSC_IDR_RXSYN = 0x800

	// IMR: Interrupt Mask Register
	// Position of TXRDY field.
	SSC_IMR_TXRDY_Pos = 0x0
	// Bit mask of TXRDY field.
	SSC_IMR_TXRDY_Msk = 0x1
	// Bit TXRDY.
	SSC_IMR_TXRDY = 0x1
	// Position of TXEMPTY field.
	SSC_IMR_TXEMPTY_Pos = 0x1
	// Bit mask of TXEMPTY field.
	SSC_IMR_TXEMPTY_Msk = 0x2
	// Bit TXEMPTY.
	SSC_IMR_TXEMPTY = 0x2
	// Position of RXRDY field.
	SSC_IMR_RXRDY_Pos = 0x4
	// Bit mask of RXRDY field.
	SSC_IMR_RXRDY_Msk = 0x10
	// Bit RXRDY.
	SSC_IMR_RXRDY = 0x10
	// Position of OVRUN field.
	SSC_IMR_OVRUN_Pos = 0x5
	// Bit mask of OVRUN field.
	SSC_IMR_OVRUN_Msk = 0x20
	// Bit OVRUN.
	SSC_IMR_OVRUN = 0x20
	// Position of CP0 field.
	SSC_IMR_CP0_Pos = 0x8
	// Bit mask of CP0 field.
	SSC_IMR_CP0_Msk = 0x100
	// Bit CP0.
	SSC_IMR_CP0 = 0x100
	// Position of CP1 field.
	SSC_IMR_CP1_Pos = 0x9
	// Bit mask of CP1 field.
	SSC_IMR_CP1_Msk = 0x200
	// Bit CP1.
	SSC_IMR_CP1 = 0x200
	// Position of TXSYN field.
	SSC_IMR_TXSYN_Pos = 0xa
	// Bit mask of TXSYN field.
	SSC_IMR_TXSYN_Msk = 0x400
	// Bit TXSYN.
	SSC_IMR_TXSYN = 0x400
	// Position of RXSYN field.
	SSC_IMR_RXSYN_Pos = 0xb
	// Bit mask of RXSYN field.
	SSC_IMR_RXSYN_Msk = 0x800
	// Bit RXSYN.
	SSC_IMR_RXSYN = 0x800

	// WPMR: Write Protect Mode Register
	// Position of WPEN field.
	SSC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	SSC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	SSC_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	SSC_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	SSC_WPMR_WPKEY_Msk = 0xffffff00
)

// Constants for CAN0: Controller Area Network 0
const (
	// MR: Mode Register
	// Position of CANEN field.
	CAN_MR_CANEN_Pos = 0x0
	// Bit mask of CANEN field.
	CAN_MR_CANEN_Msk = 0x1
	// Bit CANEN.
	CAN_MR_CANEN = 0x1
	// Position of LPM field.
	CAN_MR_LPM_Pos = 0x1
	// Bit mask of LPM field.
	CAN_MR_LPM_Msk = 0x2
	// Bit LPM.
	CAN_MR_LPM = 0x2
	// Position of ABM field.
	CAN_MR_ABM_Pos = 0x2
	// Bit mask of ABM field.
	CAN_MR_ABM_Msk = 0x4
	// Bit ABM.
	CAN_MR_ABM = 0x4
	// Position of OVL field.
	CAN_MR_OVL_Pos = 0x3
	// Bit mask of OVL field.
	CAN_MR_OVL_Msk = 0x8
	// Bit OVL.
	CAN_MR_OVL = 0x8
	// Position of TEOF field.
	CAN_MR_TEOF_Pos = 0x4
	// Bit mask of TEOF field.
	CAN_MR_TEOF_Msk = 0x10
	// Bit TEOF.
	CAN_MR_TEOF = 0x10
	// Position of TTM field.
	CAN_MR_TTM_Pos = 0x5
	// Bit mask of TTM field.
	CAN_MR_TTM_Msk = 0x20
	// Bit TTM.
	CAN_MR_TTM = 0x20
	// Position of TIMFRZ field.
	CAN_MR_TIMFRZ_Pos = 0x6
	// Bit mask of TIMFRZ field.
	CAN_MR_TIMFRZ_Msk = 0x40
	// Bit TIMFRZ.
	CAN_MR_TIMFRZ = 0x40
	// Position of DRPT field.
	CAN_MR_DRPT_Pos = 0x7
	// Bit mask of DRPT field.
	CAN_MR_DRPT_Msk = 0x80
	// Bit DRPT.
	CAN_MR_DRPT = 0x80

	// IER: Interrupt Enable Register
	// Position of MB0 field.
	CAN_IER_MB0_Pos = 0x0
	// Bit mask of MB0 field.
	CAN_IER_MB0_Msk = 0x1
	// Bit MB0.
	CAN_IER_MB0 = 0x1
	// Position of MB1 field.
	CAN_IER_MB1_Pos = 0x1
	// Bit mask of MB1 field.
	CAN_IER_MB1_Msk = 0x2
	// Bit MB1.
	CAN_IER_MB1 = 0x2
	// Position of MB2 field.
	CAN_IER_MB2_Pos = 0x2
	// Bit mask of MB2 field.
	CAN_IER_MB2_Msk = 0x4
	// Bit MB2.
	CAN_IER_MB2 = 0x4
	// Position of MB3 field.
	CAN_IER_MB3_Pos = 0x3
	// Bit mask of MB3 field.
	CAN_IER_MB3_Msk = 0x8
	// Bit MB3.
	CAN_IER_MB3 = 0x8
	// Position of MB4 field.
	CAN_IER_MB4_Pos = 0x4
	// Bit mask of MB4 field.
	CAN_IER_MB4_Msk = 0x10
	// Bit MB4.
	CAN_IER_MB4 = 0x10
	// Position of MB5 field.
	CAN_IER_MB5_Pos = 0x5
	// Bit mask of MB5 field.
	CAN_IER_MB5_Msk = 0x20
	// Bit MB5.
	CAN_IER_MB5 = 0x20
	// Position of MB6 field.
	CAN_IER_MB6_Pos = 0x6
	// Bit mask of MB6 field.
	CAN_IER_MB6_Msk = 0x40
	// Bit MB6.
	CAN_IER_MB6 = 0x40
	// Position of MB7 field.
	CAN_IER_MB7_Pos = 0x7
	// Bit mask of MB7 field.
	CAN_IER_MB7_Msk = 0x80
	// Bit MB7.
	CAN_IER_MB7 = 0x80
	// Position of ERRA field.
	CAN_IER_ERRA_Pos = 0x10
	// Bit mask of ERRA field.
	CAN_IER_ERRA_Msk = 0x10000
	// Bit ERRA.
	CAN_IER_ERRA = 0x10000
	// Position of WARN field.
	CAN_IER_WARN_Pos = 0x11
	// Bit mask of WARN field.
	CAN_IER_WARN_Msk = 0x20000
	// Bit WARN.
	CAN_IER_WARN = 0x20000
	// Position of ERRP field.
	CAN_IER_ERRP_Pos = 0x12
	// Bit mask of ERRP field.
	CAN_IER_ERRP_Msk = 0x40000
	// Bit ERRP.
	CAN_IER_ERRP = 0x40000
	// Position of BOFF field.
	CAN_IER_BOFF_Pos = 0x13
	// Bit mask of BOFF field.
	CAN_IER_BOFF_Msk = 0x80000
	// Bit BOFF.
	CAN_IER_BOFF = 0x80000
	// Position of SLEEP field.
	CAN_IER_SLEEP_Pos = 0x14
	// Bit mask of SLEEP field.
	CAN_IER_SLEEP_Msk = 0x100000
	// Bit SLEEP.
	CAN_IER_SLEEP = 0x100000
	// Position of WAKEUP field.
	CAN_IER_WAKEUP_Pos = 0x15
	// Bit mask of WAKEUP field.
	CAN_IER_WAKEUP_Msk = 0x200000
	// Bit WAKEUP.
	CAN_IER_WAKEUP = 0x200000
	// Position of TOVF field.
	CAN_IER_TOVF_Pos = 0x16
	// Bit mask of TOVF field.
	CAN_IER_TOVF_Msk = 0x400000
	// Bit TOVF.
	CAN_IER_TOVF = 0x400000
	// Position of TSTP field.
	CAN_IER_TSTP_Pos = 0x17
	// Bit mask of TSTP field.
	CAN_IER_TSTP_Msk = 0x800000
	// Bit TSTP.
	CAN_IER_TSTP = 0x800000
	// Position of CERR field.
	CAN_IER_CERR_Pos = 0x18
	// Bit mask of CERR field.
	CAN_IER_CERR_Msk = 0x1000000
	// Bit CERR.
	CAN_IER_CERR = 0x1000000
	// Position of SERR field.
	CAN_IER_SERR_Pos = 0x19
	// Bit mask of SERR field.
	CAN_IER_SERR_Msk = 0x2000000
	// Bit SERR.
	CAN_IER_SERR = 0x2000000
	// Position of AERR field.
	CAN_IER_AERR_Pos = 0x1a
	// Bit mask of AERR field.
	CAN_IER_AERR_Msk = 0x4000000
	// Bit AERR.
	CAN_IER_AERR = 0x4000000
	// Position of FERR field.
	CAN_IER_FERR_Pos = 0x1b
	// Bit mask of FERR field.
	CAN_IER_FERR_Msk = 0x8000000
	// Bit FERR.
	CAN_IER_FERR = 0x8000000
	// Position of BERR field.
	CAN_IER_BERR_Pos = 0x1c
	// Bit mask of BERR field.
	CAN_IER_BERR_Msk = 0x10000000
	// Bit BERR.
	CAN_IER_BERR = 0x10000000

	// IDR: Interrupt Disable Register
	// Position of MB0 field.
	CAN_IDR_MB0_Pos = 0x0
	// Bit mask of MB0 field.
	CAN_IDR_MB0_Msk = 0x1
	// Bit MB0.
	CAN_IDR_MB0 = 0x1
	// Position of MB1 field.
	CAN_IDR_MB1_Pos = 0x1
	// Bit mask of MB1 field.
	CAN_IDR_MB1_Msk = 0x2
	// Bit MB1.
	CAN_IDR_MB1 = 0x2
	// Position of MB2 field.
	CAN_IDR_MB2_Pos = 0x2
	// Bit mask of MB2 field.
	CAN_IDR_MB2_Msk = 0x4
	// Bit MB2.
	CAN_IDR_MB2 = 0x4
	// Position of MB3 field.
	CAN_IDR_MB3_Pos = 0x3
	// Bit mask of MB3 field.
	CAN_IDR_MB3_Msk = 0x8
	// Bit MB3.
	CAN_IDR_MB3 = 0x8
	// Position of MB4 field.
	CAN_IDR_MB4_Pos = 0x4
	// Bit mask of MB4 field.
	CAN_IDR_MB4_Msk = 0x10
	// Bit MB4.
	CAN_IDR_MB4 = 0x10
	// Position of MB5 field.
	CAN_IDR_MB5_Pos = 0x5
	// Bit mask of MB5 field.
	CAN_IDR_MB5_Msk = 0x20
	// Bit MB5.
	CAN_IDR_MB5 = 0x20
	// Position of MB6 field.
	CAN_IDR_MB6_Pos = 0x6
	// Bit mask of MB6 field.
	CAN_IDR_MB6_Msk = 0x40
	// Bit MB6.
	CAN_IDR_MB6 = 0x40
	// Position of MB7 field.
	CAN_IDR_MB7_Pos = 0x7
	// Bit mask of MB7 field.
	CAN_IDR_MB7_Msk = 0x80
	// Bit MB7.
	CAN_IDR_MB7 = 0x80
	// Position of ERRA field.
	CAN_IDR_ERRA_Pos = 0x10
	// Bit mask of ERRA field.
	CAN_IDR_ERRA_Msk = 0x10000
	// Bit ERRA.
	CAN_IDR_ERRA = 0x10000
	// Position of WARN field.
	CAN_IDR_WARN_Pos = 0x11
	// Bit mask of WARN field.
	CAN_IDR_WARN_Msk = 0x20000
	// Bit WARN.
	CAN_IDR_WARN = 0x20000
	// Position of ERRP field.
	CAN_IDR_ERRP_Pos = 0x12
	// Bit mask of ERRP field.
	CAN_IDR_ERRP_Msk = 0x40000
	// Bit ERRP.
	CAN_IDR_ERRP = 0x40000
	// Position of BOFF field.
	CAN_IDR_BOFF_Pos = 0x13
	// Bit mask of BOFF field.
	CAN_IDR_BOFF_Msk = 0x80000
	// Bit BOFF.
	CAN_IDR_BOFF = 0x80000
	// Position of SLEEP field.
	CAN_IDR_SLEEP_Pos = 0x14
	// Bit mask of SLEEP field.
	CAN_IDR_SLEEP_Msk = 0x100000
	// Bit SLEEP.
	CAN_IDR_SLEEP = 0x100000
	// Position of WAKEUP field.
	CAN_IDR_WAKEUP_Pos = 0x15
	// Bit mask of WAKEUP field.
	CAN_IDR_WAKEUP_Msk = 0x200000
	// Bit WAKEUP.
	CAN_IDR_WAKEUP = 0x200000
	// Position of TOVF field.
	CAN_IDR_TOVF_Pos = 0x16
	// Bit mask of TOVF field.
	CAN_IDR_TOVF_Msk = 0x400000
	// Bit TOVF.
	CAN_IDR_TOVF = 0x400000
	// Position of TSTP field.
	CAN_IDR_TSTP_Pos = 0x17
	// Bit mask of TSTP field.
	CAN_IDR_TSTP_Msk = 0x800000
	// Bit TSTP.
	CAN_IDR_TSTP = 0x800000
	// Position of CERR field.
	CAN_IDR_CERR_Pos = 0x18
	// Bit mask of CERR field.
	CAN_IDR_CERR_Msk = 0x1000000
	// Bit CERR.
	CAN_IDR_CERR = 0x1000000
	// Position of SERR field.
	CAN_IDR_SERR_Pos = 0x19
	// Bit mask of SERR field.
	CAN_IDR_SERR_Msk = 0x2000000
	// Bit SERR.
	CAN_IDR_SERR = 0x2000000
	// Position of AERR field.
	CAN_IDR_AERR_Pos = 0x1a
	// Bit mask of AERR field.
	CAN_IDR_AERR_Msk = 0x4000000
	// Bit AERR.
	CAN_IDR_AERR = 0x4000000
	// Position of FERR field.
	CAN_IDR_FERR_Pos = 0x1b
	// Bit mask of FERR field.
	CAN_IDR_FERR_Msk = 0x8000000
	// Bit FERR.
	CAN_IDR_FERR = 0x8000000
	// Position of BERR field.
	CAN_IDR_BERR_Pos = 0x1c
	// Bit mask of BERR field.
	CAN_IDR_BERR_Msk = 0x10000000
	// Bit BERR.
	CAN_IDR_BERR = 0x10000000

	// IMR: Interrupt Mask Register
	// Position of MB0 field.
	CAN_IMR_MB0_Pos = 0x0
	// Bit mask of MB0 field.
	CAN_IMR_MB0_Msk = 0x1
	// Bit MB0.
	CAN_IMR_MB0 = 0x1
	// Position of MB1 field.
	CAN_IMR_MB1_Pos = 0x1
	// Bit mask of MB1 field.
	CAN_IMR_MB1_Msk = 0x2
	// Bit MB1.
	CAN_IMR_MB1 = 0x2
	// Position of MB2 field.
	CAN_IMR_MB2_Pos = 0x2
	// Bit mask of MB2 field.
	CAN_IMR_MB2_Msk = 0x4
	// Bit MB2.
	CAN_IMR_MB2 = 0x4
	// Position of MB3 field.
	CAN_IMR_MB3_Pos = 0x3
	// Bit mask of MB3 field.
	CAN_IMR_MB3_Msk = 0x8
	// Bit MB3.
	CAN_IMR_MB3 = 0x8
	// Position of MB4 field.
	CAN_IMR_MB4_Pos = 0x4
	// Bit mask of MB4 field.
	CAN_IMR_MB4_Msk = 0x10
	// Bit MB4.
	CAN_IMR_MB4 = 0x10
	// Position of MB5 field.
	CAN_IMR_MB5_Pos = 0x5
	// Bit mask of MB5 field.
	CAN_IMR_MB5_Msk = 0x20
	// Bit MB5.
	CAN_IMR_MB5 = 0x20
	// Position of MB6 field.
	CAN_IMR_MB6_Pos = 0x6
	// Bit mask of MB6 field.
	CAN_IMR_MB6_Msk = 0x40
	// Bit MB6.
	CAN_IMR_MB6 = 0x40
	// Position of MB7 field.
	CAN_IMR_MB7_Pos = 0x7
	// Bit mask of MB7 field.
	CAN_IMR_MB7_Msk = 0x80
	// Bit MB7.
	CAN_IMR_MB7 = 0x80
	// Position of ERRA field.
	CAN_IMR_ERRA_Pos = 0x10
	// Bit mask of ERRA field.
	CAN_IMR_ERRA_Msk = 0x10000
	// Bit ERRA.
	CAN_IMR_ERRA = 0x10000
	// Position of WARN field.
	CAN_IMR_WARN_Pos = 0x11
	// Bit mask of WARN field.
	CAN_IMR_WARN_Msk = 0x20000
	// Bit WARN.
	CAN_IMR_WARN = 0x20000
	// Position of ERRP field.
	CAN_IMR_ERRP_Pos = 0x12
	// Bit mask of ERRP field.
	CAN_IMR_ERRP_Msk = 0x40000
	// Bit ERRP.
	CAN_IMR_ERRP = 0x40000
	// Position of BOFF field.
	CAN_IMR_BOFF_Pos = 0x13
	// Bit mask of BOFF field.
	CAN_IMR_BOFF_Msk = 0x80000
	// Bit BOFF.
	CAN_IMR_BOFF = 0x80000
	// Position of SLEEP field.
	CAN_IMR_SLEEP_Pos = 0x14
	// Bit mask of SLEEP field.
	CAN_IMR_SLEEP_Msk = 0x100000
	// Bit SLEEP.
	CAN_IMR_SLEEP = 0x100000
	// Position of WAKEUP field.
	CAN_IMR_WAKEUP_Pos = 0x15
	// Bit mask of WAKEUP field.
	CAN_IMR_WAKEUP_Msk = 0x200000
	// Bit WAKEUP.
	CAN_IMR_WAKEUP = 0x200000
	// Position of TOVF field.
	CAN_IMR_TOVF_Pos = 0x16
	// Bit mask of TOVF field.
	CAN_IMR_TOVF_Msk = 0x400000
	// Bit TOVF.
	CAN_IMR_TOVF = 0x400000
	// Position of TSTP field.
	CAN_IMR_TSTP_Pos = 0x17
	// Bit mask of TSTP field.
	CAN_IMR_TSTP_Msk = 0x800000
	// Bit TSTP.
	CAN_IMR_TSTP = 0x800000
	// Position of CERR field.
	CAN_IMR_CERR_Pos = 0x18
	// Bit mask of CERR field.
	CAN_IMR_CERR_Msk = 0x1000000
	// Bit CERR.
	CAN_IMR_CERR = 0x1000000
	// Position of SERR field.
	CAN_IMR_SERR_Pos = 0x19
	// Bit mask of SERR field.
	CAN_IMR_SERR_Msk = 0x2000000
	// Bit SERR.
	CAN_IMR_SERR = 0x2000000
	// Position of AERR field.
	CAN_IMR_AERR_Pos = 0x1a
	// Bit mask of AERR field.
	CAN_IMR_AERR_Msk = 0x4000000
	// Bit AERR.
	CAN_IMR_AERR = 0x4000000
	// Position of FERR field.
	CAN_IMR_FERR_Pos = 0x1b
	// Bit mask of FERR field.
	CAN_IMR_FERR_Msk = 0x8000000
	// Bit FERR.
	CAN_IMR_FERR = 0x8000000
	// Position of BERR field.
	CAN_IMR_BERR_Pos = 0x1c
	// Bit mask of BERR field.
	CAN_IMR_BERR_Msk = 0x10000000
	// Bit BERR.
	CAN_IMR_BERR = 0x10000000

	// SR: Status Register
	// Position of MB0 field.
	CAN_SR_MB0_Pos = 0x0
	// Bit mask of MB0 field.
	CAN_SR_MB0_Msk = 0x1
	// Bit MB0.
	CAN_SR_MB0 = 0x1
	// Position of MB1 field.
	CAN_SR_MB1_Pos = 0x1
	// Bit mask of MB1 field.
	CAN_SR_MB1_Msk = 0x2
	// Bit MB1.
	CAN_SR_MB1 = 0x2
	// Position of MB2 field.
	CAN_SR_MB2_Pos = 0x2
	// Bit mask of MB2 field.
	CAN_SR_MB2_Msk = 0x4
	// Bit MB2.
	CAN_SR_MB2 = 0x4
	// Position of MB3 field.
	CAN_SR_MB3_Pos = 0x3
	// Bit mask of MB3 field.
	CAN_SR_MB3_Msk = 0x8
	// Bit MB3.
	CAN_SR_MB3 = 0x8
	// Position of MB4 field.
	CAN_SR_MB4_Pos = 0x4
	// Bit mask of MB4 field.
	CAN_SR_MB4_Msk = 0x10
	// Bit MB4.
	CAN_SR_MB4 = 0x10
	// Position of MB5 field.
	CAN_SR_MB5_Pos = 0x5
	// Bit mask of MB5 field.
	CAN_SR_MB5_Msk = 0x20
	// Bit MB5.
	CAN_SR_MB5 = 0x20
	// Position of MB6 field.
	CAN_SR_MB6_Pos = 0x6
	// Bit mask of MB6 field.
	CAN_SR_MB6_Msk = 0x40
	// Bit MB6.
	CAN_SR_MB6 = 0x40
	// Position of MB7 field.
	CAN_SR_MB7_Pos = 0x7
	// Bit mask of MB7 field.
	CAN_SR_MB7_Msk = 0x80
	// Bit MB7.
	CAN_SR_MB7 = 0x80
	// Position of ERRA field.
	CAN_SR_ERRA_Pos = 0x10
	// Bit mask of ERRA field.
	CAN_SR_ERRA_Msk = 0x10000
	// Bit ERRA.
	CAN_SR_ERRA = 0x10000
	// Position of WARN field.
	CAN_SR_WARN_Pos = 0x11
	// Bit mask of WARN field.
	CAN_SR_WARN_Msk = 0x20000
	// Bit WARN.
	CAN_SR_WARN = 0x20000
	// Position of ERRP field.
	CAN_SR_ERRP_Pos = 0x12
	// Bit mask of ERRP field.
	CAN_SR_ERRP_Msk = 0x40000
	// Bit ERRP.
	CAN_SR_ERRP = 0x40000
	// Position of BOFF field.
	CAN_SR_BOFF_Pos = 0x13
	// Bit mask of BOFF field.
	CAN_SR_BOFF_Msk = 0x80000
	// Bit BOFF.
	CAN_SR_BOFF = 0x80000
	// Position of SLEEP field.
	CAN_SR_SLEEP_Pos = 0x14
	// Bit mask of SLEEP field.
	CAN_SR_SLEEP_Msk = 0x100000
	// Bit SLEEP.
	CAN_SR_SLEEP = 0x100000
	// Position of WAKEUP field.
	CAN_SR_WAKEUP_Pos = 0x15
	// Bit mask of WAKEUP field.
	CAN_SR_WAKEUP_Msk = 0x200000
	// Bit WAKEUP.
	CAN_SR_WAKEUP = 0x200000
	// Position of TOVF field.
	CAN_SR_TOVF_Pos = 0x16
	// Bit mask of TOVF field.
	CAN_SR_TOVF_Msk = 0x400000
	// Bit TOVF.
	CAN_SR_TOVF = 0x400000
	// Position of TSTP field.
	CAN_SR_TSTP_Pos = 0x17
	// Bit mask of TSTP field.
	CAN_SR_TSTP_Msk = 0x800000
	// Bit TSTP.
	CAN_SR_TSTP = 0x800000
	// Position of CERR field.
	CAN_SR_CERR_Pos = 0x18
	// Bit mask of CERR field.
	CAN_SR_CERR_Msk = 0x1000000
	// Bit CERR.
	CAN_SR_CERR = 0x1000000
	// Position of SERR field.
	CAN_SR_SERR_Pos = 0x19
	// Bit mask of SERR field.
	CAN_SR_SERR_Msk = 0x2000000
	// Bit SERR.
	CAN_SR_SERR = 0x2000000
	// Position of AERR field.
	CAN_SR_AERR_Pos = 0x1a
	// Bit mask of AERR field.
	CAN_SR_AERR_Msk = 0x4000000
	// Bit AERR.
	CAN_SR_AERR = 0x4000000
	// Position of FERR field.
	CAN_SR_FERR_Pos = 0x1b
	// Bit mask of FERR field.
	CAN_SR_FERR_Msk = 0x8000000
	// Bit FERR.
	CAN_SR_FERR = 0x8000000
	// Position of BERR field.
	CAN_SR_BERR_Pos = 0x1c
	// Bit mask of BERR field.
	CAN_SR_BERR_Msk = 0x10000000
	// Bit BERR.
	CAN_SR_BERR = 0x10000000
	// Position of RBSY field.
	CAN_SR_RBSY_Pos = 0x1d
	// Bit mask of RBSY field.
	CAN_SR_RBSY_Msk = 0x20000000
	// Bit RBSY.
	CAN_SR_RBSY = 0x20000000
	// Position of TBSY field.
	CAN_SR_TBSY_Pos = 0x1e
	// Bit mask of TBSY field.
	CAN_SR_TBSY_Msk = 0x40000000
	// Bit TBSY.
	CAN_SR_TBSY = 0x40000000
	// Position of OVLSY field.
	CAN_SR_OVLSY_Pos = 0x1f
	// Bit mask of OVLSY field.
	CAN_SR_OVLSY_Msk = 0x80000000
	// Bit OVLSY.
	CAN_SR_OVLSY = 0x80000000

	// BR: Baudrate Register
	// Position of PHASE2 field.
	CAN_BR_PHASE2_Pos = 0x0
	// Bit mask of PHASE2 field.
	CAN_BR_PHASE2_Msk = 0x7
	// Position of PHASE1 field.
	CAN_BR_PHASE1_Pos = 0x4
	// Bit mask of PHASE1 field.
	CAN_BR_PHASE1_Msk = 0x70
	// Position of PROPAG field.
	CAN_BR_PROPAG_Pos = 0x8
	// Bit mask of PROPAG field.
	CAN_BR_PROPAG_Msk = 0x700
	// Position of SJW field.
	CAN_BR_SJW_Pos = 0xc
	// Bit mask of SJW field.
	CAN_BR_SJW_Msk = 0x3000
	// Position of BRP field.
	CAN_BR_BRP_Pos = 0x10
	// Bit mask of BRP field.
	CAN_BR_BRP_Msk = 0x7f0000
	// Position of SMP field.
	CAN_BR_SMP_Pos = 0x18
	// Bit mask of SMP field.
	CAN_BR_SMP_Msk = 0x1000000
	// Bit SMP.
	CAN_BR_SMP = 0x1000000
	// The incoming bit stream is sampled once at sample point.
	CAN_BR_SMP_ONCE = 0x0
	// The incoming bit stream is sampled three times with a period of a MCK clock period, centered on sample point.
	CAN_BR_SMP_THREE = 0x1

	// TIM: Timer Register
	// Position of TIMER field.
	CAN_TIM_TIMER_Pos = 0x0
	// Bit mask of TIMER field.
	CAN_TIM_TIMER_Msk = 0xffff

	// TIMESTP: Timestamp Register
	// Position of MTIMESTAMP field.
	CAN_TIMESTP_MTIMESTAMP_Pos = 0x0
	// Bit mask of MTIMESTAMP field.
	CAN_TIMESTP_MTIMESTAMP_Msk = 0xffff

	// ECR: Error Counter Register
	// Position of REC field.
	CAN_ECR_REC_Pos = 0x0
	// Bit mask of REC field.
	CAN_ECR_REC_Msk = 0xff
	// Position of TEC field.
	CAN_ECR_TEC_Pos = 0x10
	// Bit mask of TEC field.
	CAN_ECR_TEC_Msk = 0x1ff0000

	// TCR: Transfer Command Register
	// Position of MB0 field.
	CAN_TCR_MB0_Pos = 0x0
	// Bit mask of MB0 field.
	CAN_TCR_MB0_Msk = 0x1
	// Bit MB0.
	CAN_TCR_MB0 = 0x1
	// Position of MB1 field.
	CAN_TCR_MB1_Pos = 0x1
	// Bit mask of MB1 field.
	CAN_TCR_MB1_Msk = 0x2
	// Bit MB1.
	CAN_TCR_MB1 = 0x2
	// Position of MB2 field.
	CAN_TCR_MB2_Pos = 0x2
	// Bit mask of MB2 field.
	CAN_TCR_MB2_Msk = 0x4
	// Bit MB2.
	CAN_TCR_MB2 = 0x4
	// Position of MB3 field.
	CAN_TCR_MB3_Pos = 0x3
	// Bit mask of MB3 field.
	CAN_TCR_MB3_Msk = 0x8
	// Bit MB3.
	CAN_TCR_MB3 = 0x8
	// Position of MB4 field.
	CAN_TCR_MB4_Pos = 0x4
	// Bit mask of MB4 field.
	CAN_TCR_MB4_Msk = 0x10
	// Bit MB4.
	CAN_TCR_MB4 = 0x10
	// Position of MB5 field.
	CAN_TCR_MB5_Pos = 0x5
	// Bit mask of MB5 field.
	CAN_TCR_MB5_Msk = 0x20
	// Bit MB5.
	CAN_TCR_MB5 = 0x20
	// Position of MB6 field.
	CAN_TCR_MB6_Pos = 0x6
	// Bit mask of MB6 field.
	CAN_TCR_MB6_Msk = 0x40
	// Bit MB6.
	CAN_TCR_MB6 = 0x40
	// Position of MB7 field.
	CAN_TCR_MB7_Pos = 0x7
	// Bit mask of MB7 field.
	CAN_TCR_MB7_Msk = 0x80
	// Bit MB7.
	CAN_TCR_MB7 = 0x80
	// Position of TIMRST field.
	CAN_TCR_TIMRST_Pos = 0x1f
	// Bit mask of TIMRST field.
	CAN_TCR_TIMRST_Msk = 0x80000000
	// Bit TIMRST.
	CAN_TCR_TIMRST = 0x80000000

	// ACR: Abort Command Register
	// Position of MB0 field.
	CAN_ACR_MB0_Pos = 0x0
	// Bit mask of MB0 field.
	CAN_ACR_MB0_Msk = 0x1
	// Bit MB0.
	CAN_ACR_MB0 = 0x1
	// Position of MB1 field.
	CAN_ACR_MB1_Pos = 0x1
	// Bit mask of MB1 field.
	CAN_ACR_MB1_Msk = 0x2
	// Bit MB1.
	CAN_ACR_MB1 = 0x2
	// Position of MB2 field.
	CAN_ACR_MB2_Pos = 0x2
	// Bit mask of MB2 field.
	CAN_ACR_MB2_Msk = 0x4
	// Bit MB2.
	CAN_ACR_MB2 = 0x4
	// Position of MB3 field.
	CAN_ACR_MB3_Pos = 0x3
	// Bit mask of MB3 field.
	CAN_ACR_MB3_Msk = 0x8
	// Bit MB3.
	CAN_ACR_MB3 = 0x8
	// Position of MB4 field.
	CAN_ACR_MB4_Pos = 0x4
	// Bit mask of MB4 field.
	CAN_ACR_MB4_Msk = 0x10
	// Bit MB4.
	CAN_ACR_MB4 = 0x10
	// Position of MB5 field.
	CAN_ACR_MB5_Pos = 0x5
	// Bit mask of MB5 field.
	CAN_ACR_MB5_Msk = 0x20
	// Bit MB5.
	CAN_ACR_MB5 = 0x20
	// Position of MB6 field.
	CAN_ACR_MB6_Pos = 0x6
	// Bit mask of MB6 field.
	CAN_ACR_MB6_Msk = 0x40
	// Bit MB6.
	CAN_ACR_MB6 = 0x40
	// Position of MB7 field.
	CAN_ACR_MB7_Pos = 0x7
	// Bit mask of MB7 field.
	CAN_ACR_MB7_Msk = 0x80
	// Bit MB7.
	CAN_ACR_MB7 = 0x80

	// WPMR: Write Protect Mode Register
	// Position of WPEN field.
	CAN_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	CAN_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	CAN_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	CAN_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	CAN_WPMR_WPKEY_Msk = 0xffffff00

	// WPSR: Write Protect Status Register
	// Position of WPVS field.
	CAN_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	CAN_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	CAN_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	CAN_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	CAN_WPSR_WPVSRC_Msk = 0xff00

	// MMR0: Mailbox Mode Register (MB = 0)
	// Position of MTIMEMARK field.
	CAN_MMR0_MTIMEMARK_Pos = 0x0
	// Bit mask of MTIMEMARK field.
	CAN_MMR0_MTIMEMARK_Msk = 0xffff
	// Position of PRIOR field.
	CAN_MMR0_PRIOR_Pos = 0x10
	// Bit mask of PRIOR field.
	CAN_MMR0_PRIOR_Msk = 0xf0000
	// Position of MOT field.
	CAN_MMR0_MOT_Pos = 0x18
	// Bit mask of MOT field.
	CAN_MMR0_MOT_Msk = 0x7000000
	// Mailbox is disabled. This prevents receiving or transmitting any messages with this mailbox.
	CAN_MMR0_MOT_MB_DISABLED = 0x0
	// Reception Mailbox. Mailbox is configured for reception. If a message is received while the mailbox data register is full, it is discarded.
	CAN_MMR0_MOT_MB_RX = 0x1
	// Reception mailbox with overwrite. Mailbox is configured for reception. If a message is received while the mailbox is full, it overwrites the previous message.
	CAN_MMR0_MOT_MB_RX_OVERWRITE = 0x2
	// Transmit mailbox. Mailbox is configured for transmission.
	CAN_MMR0_MOT_MB_TX = 0x3
	// Consumer Mailbox. Mailbox is configured in reception but behaves as a Transmit Mailbox, i.e., it sends a remote frame and waits for an answer.
	CAN_MMR0_MOT_MB_CONSUMER = 0x4
	// Producer Mailbox. Mailbox is configured in transmission but also behaves like a reception mailbox, i.e., it waits to receive a Remote Frame before sending its contents.
	CAN_MMR0_MOT_MB_PRODUCER = 0x5

	// MAM0: Mailbox Acceptance Mask Register (MB = 0)
	// Position of MIDvB field.
	CAN_MAM0_MIDvB_Pos = 0x0
	// Bit mask of MIDvB field.
	CAN_MAM0_MIDvB_Msk = 0x3ffff
	// Position of MIDvA field.
	CAN_MAM0_MIDvA_Pos = 0x12
	// Bit mask of MIDvA field.
	CAN_MAM0_MIDvA_Msk = 0x1ffc0000
	// Position of MIDE field.
	CAN_MAM0_MIDE_Pos = 0x1d
	// Bit mask of MIDE field.
	CAN_MAM0_MIDE_Msk = 0x20000000
	// Bit MIDE.
	CAN_MAM0_MIDE = 0x20000000

	// MID0: Mailbox ID Register (MB = 0)
	// Position of MIDvB field.
	CAN_MID0_MIDvB_Pos = 0x0
	// Bit mask of MIDvB field.
	CAN_MID0_MIDvB_Msk = 0x3ffff
	// Position of MIDvA field.
	CAN_MID0_MIDvA_Pos = 0x12
	// Bit mask of MIDvA field.
	CAN_MID0_MIDvA_Msk = 0x1ffc0000
	// Position of MIDE field.
	CAN_MID0_MIDE_Pos = 0x1d
	// Bit mask of MIDE field.
	CAN_MID0_MIDE_Msk = 0x20000000
	// Bit MIDE.
	CAN_MID0_MIDE = 0x20000000

	// MFID0: Mailbox Family ID Register (MB = 0)
	// Position of MFID field.
	CAN_MFID0_MFID_Pos = 0x0
	// Bit mask of MFID field.
	CAN_MFID0_MFID_Msk = 0x1fffffff

	// MSR0: Mailbox Status Register (MB = 0)
	// Position of MTIMESTAMP field.
	CAN_MSR0_MTIMESTAMP_Pos = 0x0
	// Bit mask of MTIMESTAMP field.
	CAN_MSR0_MTIMESTAMP_Msk = 0xffff
	// Position of MDLC field.
	CAN_MSR0_MDLC_Pos = 0x10
	// Bit mask of MDLC field.
	CAN_MSR0_MDLC_Msk = 0xf0000
	// Position of MRTR field.
	CAN_MSR0_MRTR_Pos = 0x14
	// Bit mask of MRTR field.
	CAN_MSR0_MRTR_Msk = 0x100000
	// Bit MRTR.
	CAN_MSR0_MRTR = 0x100000
	// Position of MABT field.
	CAN_MSR0_MABT_Pos = 0x16
	// Bit mask of MABT field.
	CAN_MSR0_MABT_Msk = 0x400000
	// Bit MABT.
	CAN_MSR0_MABT = 0x400000
	// Position of MRDY field.
	CAN_MSR0_MRDY_Pos = 0x17
	// Bit mask of MRDY field.
	CAN_MSR0_MRDY_Msk = 0x800000
	// Bit MRDY.
	CAN_MSR0_MRDY = 0x800000
	// Position of MMI field.
	CAN_MSR0_MMI_Pos = 0x18
	// Bit mask of MMI field.
	CAN_MSR0_MMI_Msk = 0x1000000
	// Bit MMI.
	CAN_MSR0_MMI = 0x1000000

	// MDL0: Mailbox Data Low Register (MB = 0)
	// Position of MDL field.
	CAN_MDL0_MDL_Pos = 0x0
	// Bit mask of MDL field.
	CAN_MDL0_MDL_Msk = 0xffffffff

	// MDH0: Mailbox Data High Register (MB = 0)
	// Position of MDH field.
	CAN_MDH0_MDH_Pos = 0x0
	// Bit mask of MDH field.
	CAN_MDH0_MDH_Msk = 0xffffffff

	// MCR0: Mailbox Control Register (MB = 0)
	// Position of MDLC field.
	CAN_MCR0_MDLC_Pos = 0x10
	// Bit mask of MDLC field.
	CAN_MCR0_MDLC_Msk = 0xf0000
	// Position of MRTR field.
	CAN_MCR0_MRTR_Pos = 0x14
	// Bit mask of MRTR field.
	CAN_MCR0_MRTR_Msk = 0x100000
	// Bit MRTR.
	CAN_MCR0_MRTR = 0x100000
	// Position of MACR field.
	CAN_MCR0_MACR_Pos = 0x16
	// Bit mask of MACR field.
	CAN_MCR0_MACR_Msk = 0x400000
	// Bit MACR.
	CAN_MCR0_MACR = 0x400000
	// Position of MTCR field.
	CAN_MCR0_MTCR_Pos = 0x17
	// Bit mask of MTCR field.
	CAN_MCR0_MTCR_Msk = 0x800000
	// Bit MTCR.
	CAN_MCR0_MTCR = 0x800000

	// MMR1: Mailbox Mode Register (MB = 1)
	// Position of MTIMEMARK field.
	CAN_MMR1_MTIMEMARK_Pos = 0x0
	// Bit mask of MTIMEMARK field.
	CAN_MMR1_MTIMEMARK_Msk = 0xffff
	// Position of PRIOR field.
	CAN_MMR1_PRIOR_Pos = 0x10
	// Bit mask of PRIOR field.
	CAN_MMR1_PRIOR_Msk = 0xf0000
	// Position of MOT field.
	CAN_MMR1_MOT_Pos = 0x18
	// Bit mask of MOT field.
	CAN_MMR1_MOT_Msk = 0x7000000
	// Mailbox is disabled. This prevents receiving or transmitting any messages with this mailbox.
	CAN_MMR1_MOT_MB_DISABLED = 0x0
	// Reception Mailbox. Mailbox is configured for reception. If a message is received while the mailbox data register is full, it is discarded.
	CAN_MMR1_MOT_MB_RX = 0x1
	// Reception mailbox with overwrite. Mailbox is configured for reception. If a message is received while the mailbox is full, it overwrites the previous message.
	CAN_MMR1_MOT_MB_RX_OVERWRITE = 0x2
	// Transmit mailbox. Mailbox is configured for transmission.
	CAN_MMR1_MOT_MB_TX = 0x3
	// Consumer Mailbox. Mailbox is configured in reception but behaves as a Transmit Mailbox, i.e., it sends a remote frame and waits for an answer.
	CAN_MMR1_MOT_MB_CONSUMER = 0x4
	// Producer Mailbox. Mailbox is configured in transmission but also behaves like a reception mailbox, i.e., it waits to receive a Remote Frame before sending its contents.
	CAN_MMR1_MOT_MB_PRODUCER = 0x5

	// MAM1: Mailbox Acceptance Mask Register (MB = 1)
	// Position of MIDvB field.
	CAN_MAM1_MIDvB_Pos = 0x0
	// Bit mask of MIDvB field.
	CAN_MAM1_MIDvB_Msk = 0x3ffff
	// Position of MIDvA field.
	CAN_MAM1_MIDvA_Pos = 0x12
	// Bit mask of MIDvA field.
	CAN_MAM1_MIDvA_Msk = 0x1ffc0000
	// Position of MIDE field.
	CAN_MAM1_MIDE_Pos = 0x1d
	// Bit mask of MIDE field.
	CAN_MAM1_MIDE_Msk = 0x20000000
	// Bit MIDE.
	CAN_MAM1_MIDE = 0x20000000

	// MID1: Mailbox ID Register (MB = 1)
	// Position of MIDvB field.
	CAN_MID1_MIDvB_Pos = 0x0
	// Bit mask of MIDvB field.
	CAN_MID1_MIDvB_Msk = 0x3ffff
	// Position of MIDvA field.
	CAN_MID1_MIDvA_Pos = 0x12
	// Bit mask of MIDvA field.
	CAN_MID1_MIDvA_Msk = 0x1ffc0000
	// Position of MIDE field.
	CAN_MID1_MIDE_Pos = 0x1d
	// Bit mask of MIDE field.
	CAN_MID1_MIDE_Msk = 0x20000000
	// Bit MIDE.
	CAN_MID1_MIDE = 0x20000000

	// MFID1: Mailbox Family ID Register (MB = 1)
	// Position of MFID field.
	CAN_MFID1_MFID_Pos = 0x0
	// Bit mask of MFID field.
	CAN_MFID1_MFID_Msk = 0x1fffffff

	// MSR1: Mailbox Status Register (MB = 1)
	// Position of MTIMESTAMP field.
	CAN_MSR1_MTIMESTAMP_Pos = 0x0
	// Bit mask of MTIMESTAMP field.
	CAN_MSR1_MTIMESTAMP_Msk = 0xffff
	// Position of MDLC field.
	CAN_MSR1_MDLC_Pos = 0x10
	// Bit mask of MDLC field.
	CAN_MSR1_MDLC_Msk = 0xf0000
	// Position of MRTR field.
	CAN_MSR1_MRTR_Pos = 0x14
	// Bit mask of MRTR field.
	CAN_MSR1_MRTR_Msk = 0x100000
	// Bit MRTR.
	CAN_MSR1_MRTR = 0x100000
	// Position of MABT field.
	CAN_MSR1_MABT_Pos = 0x16
	// Bit mask of MABT field.
	CAN_MSR1_MABT_Msk = 0x400000
	// Bit MABT.
	CAN_MSR1_MABT = 0x400000
	// Position of MRDY field.
	CAN_MSR1_MRDY_Pos = 0x17
	// Bit mask of MRDY field.
	CAN_MSR1_MRDY_Msk = 0x800000
	// Bit MRDY.
	CAN_MSR1_MRDY = 0x800000
	// Position of MMI field.
	CAN_MSR1_MMI_Pos = 0x18
	// Bit mask of MMI field.
	CAN_MSR1_MMI_Msk = 0x1000000
	// Bit MMI.
	CAN_MSR1_MMI = 0x1000000

	// MDL1: Mailbox Data Low Register (MB = 1)
	// Position of MDL field.
	CAN_MDL1_MDL_Pos = 0x0
	// Bit mask of MDL field.
	CAN_MDL1_MDL_Msk = 0xffffffff

	// MDH1: Mailbox Data High Register (MB = 1)
	// Position of MDH field.
	CAN_MDH1_MDH_Pos = 0x0
	// Bit mask of MDH field.
	CAN_MDH1_MDH_Msk = 0xffffffff

	// MCR1: Mailbox Control Register (MB = 1)
	// Position of MDLC field.
	CAN_MCR1_MDLC_Pos = 0x10
	// Bit mask of MDLC field.
	CAN_MCR1_MDLC_Msk = 0xf0000
	// Position of MRTR field.
	CAN_MCR1_MRTR_Pos = 0x14
	// Bit mask of MRTR field.
	CAN_MCR1_MRTR_Msk = 0x100000
	// Bit MRTR.
	CAN_MCR1_MRTR = 0x100000
	// Position of MACR field.
	CAN_MCR1_MACR_Pos = 0x16
	// Bit mask of MACR field.
	CAN_MCR1_MACR_Msk = 0x400000
	// Bit MACR.
	CAN_MCR1_MACR = 0x400000
	// Position of MTCR field.
	CAN_MCR1_MTCR_Pos = 0x17
	// Bit mask of MTCR field.
	CAN_MCR1_MTCR_Msk = 0x800000
	// Bit MTCR.
	CAN_MCR1_MTCR = 0x800000

	// MMR2: Mailbox Mode Register (MB = 2)
	// Position of MTIMEMARK field.
	CAN_MMR2_MTIMEMARK_Pos = 0x0
	// Bit mask of MTIMEMARK field.
	CAN_MMR2_MTIMEMARK_Msk = 0xffff
	// Position of PRIOR field.
	CAN_MMR2_PRIOR_Pos = 0x10
	// Bit mask of PRIOR field.
	CAN_MMR2_PRIOR_Msk = 0xf0000
	// Position of MOT field.
	CAN_MMR2_MOT_Pos = 0x18
	// Bit mask of MOT field.
	CAN_MMR2_MOT_Msk = 0x7000000
	// Mailbox is disabled. This prevents receiving or transmitting any messages with this mailbox.
	CAN_MMR2_MOT_MB_DISABLED = 0x0
	// Reception Mailbox. Mailbox is configured for reception. If a message is received while the mailbox data register is full, it is discarded.
	CAN_MMR2_MOT_MB_RX = 0x1
	// Reception mailbox with overwrite. Mailbox is configured for reception. If a message is received while the mailbox is full, it overwrites the previous message.
	CAN_MMR2_MOT_MB_RX_OVERWRITE = 0x2
	// Transmit mailbox. Mailbox is configured for transmission.
	CAN_MMR2_MOT_MB_TX = 0x3
	// Consumer Mailbox. Mailbox is configured in reception but behaves as a Transmit Mailbox, i.e., it sends a remote frame and waits for an answer.
	CAN_MMR2_MOT_MB_CONSUMER = 0x4
	// Producer Mailbox. Mailbox is configured in transmission but also behaves like a reception mailbox, i.e., it waits to receive a Remote Frame before sending its contents.
	CAN_MMR2_MOT_MB_PRODUCER = 0x5

	// MAM2: Mailbox Acceptance Mask Register (MB = 2)
	// Position of MIDvB field.
	CAN_MAM2_MIDvB_Pos = 0x0
	// Bit mask of MIDvB field.
	CAN_MAM2_MIDvB_Msk = 0x3ffff
	// Position of MIDvA field.
	CAN_MAM2_MIDvA_Pos = 0x12
	// Bit mask of MIDvA field.
	CAN_MAM2_MIDvA_Msk = 0x1ffc0000
	// Position of MIDE field.
	CAN_MAM2_MIDE_Pos = 0x1d
	// Bit mask of MIDE field.
	CAN_MAM2_MIDE_Msk = 0x20000000
	// Bit MIDE.
	CAN_MAM2_MIDE = 0x20000000

	// MID2: Mailbox ID Register (MB = 2)
	// Position of MIDvB field.
	CAN_MID2_MIDvB_Pos = 0x0
	// Bit mask of MIDvB field.
	CAN_MID2_MIDvB_Msk = 0x3ffff
	// Position of MIDvA field.
	CAN_MID2_MIDvA_Pos = 0x12
	// Bit mask of MIDvA field.
	CAN_MID2_MIDvA_Msk = 0x1ffc0000
	// Position of MIDE field.
	CAN_MID2_MIDE_Pos = 0x1d
	// Bit mask of MIDE field.
	CAN_MID2_MIDE_Msk = 0x20000000
	// Bit MIDE.
	CAN_MID2_MIDE = 0x20000000

	// MFID2: Mailbox Family ID Register (MB = 2)
	// Position of MFID field.
	CAN_MFID2_MFID_Pos = 0x0
	// Bit mask of MFID field.
	CAN_MFID2_MFID_Msk = 0x1fffffff

	// MSR2: Mailbox Status Register (MB = 2)
	// Position of MTIMESTAMP field.
	CAN_MSR2_MTIMESTAMP_Pos = 0x0
	// Bit mask of MTIMESTAMP field.
	CAN_MSR2_MTIMESTAMP_Msk = 0xffff
	// Position of MDLC field.
	CAN_MSR2_MDLC_Pos = 0x10
	// Bit mask of MDLC field.
	CAN_MSR2_MDLC_Msk = 0xf0000
	// Position of MRTR field.
	CAN_MSR2_MRTR_Pos = 0x14
	// Bit mask of MRTR field.
	CAN_MSR2_MRTR_Msk = 0x100000
	// Bit MRTR.
	CAN_MSR2_MRTR = 0x100000
	// Position of MABT field.
	CAN_MSR2_MABT_Pos = 0x16
	// Bit mask of MABT field.
	CAN_MSR2_MABT_Msk = 0x400000
	// Bit MABT.
	CAN_MSR2_MABT = 0x400000
	// Position of MRDY field.
	CAN_MSR2_MRDY_Pos = 0x17
	// Bit mask of MRDY field.
	CAN_MSR2_MRDY_Msk = 0x800000
	// Bit MRDY.
	CAN_MSR2_MRDY = 0x800000
	// Position of MMI field.
	CAN_MSR2_MMI_Pos = 0x18
	// Bit mask of MMI field.
	CAN_MSR2_MMI_Msk = 0x1000000
	// Bit MMI.
	CAN_MSR2_MMI = 0x1000000

	// MDL2: Mailbox Data Low Register (MB = 2)
	// Position of MDL field.
	CAN_MDL2_MDL_Pos = 0x0
	// Bit mask of MDL field.
	CAN_MDL2_MDL_Msk = 0xffffffff

	// MDH2: Mailbox Data High Register (MB = 2)
	// Position of MDH field.
	CAN_MDH2_MDH_Pos = 0x0
	// Bit mask of MDH field.
	CAN_MDH2_MDH_Msk = 0xffffffff

	// MCR2: Mailbox Control Register (MB = 2)
	// Position of MDLC field.
	CAN_MCR2_MDLC_Pos = 0x10
	// Bit mask of MDLC field.
	CAN_MCR2_MDLC_Msk = 0xf0000
	// Position of MRTR field.
	CAN_MCR2_MRTR_Pos = 0x14
	// Bit mask of MRTR field.
	CAN_MCR2_MRTR_Msk = 0x100000
	// Bit MRTR.
	CAN_MCR2_MRTR = 0x100000
	// Position of MACR field.
	CAN_MCR2_MACR_Pos = 0x16
	// Bit mask of MACR field.
	CAN_MCR2_MACR_Msk = 0x400000
	// Bit MACR.
	CAN_MCR2_MACR = 0x400000
	// Position of MTCR field.
	CAN_MCR2_MTCR_Pos = 0x17
	// Bit mask of MTCR field.
	CAN_MCR2_MTCR_Msk = 0x800000
	// Bit MTCR.
	CAN_MCR2_MTCR = 0x800000

	// MMR3: Mailbox Mode Register (MB = 3)
	// Position of MTIMEMARK field.
	CAN_MMR3_MTIMEMARK_Pos = 0x0
	// Bit mask of MTIMEMARK field.
	CAN_MMR3_MTIMEMARK_Msk = 0xffff
	// Position of PRIOR field.
	CAN_MMR3_PRIOR_Pos = 0x10
	// Bit mask of PRIOR field.
	CAN_MMR3_PRIOR_Msk = 0xf0000
	// Position of MOT field.
	CAN_MMR3_MOT_Pos = 0x18
	// Bit mask of MOT field.
	CAN_MMR3_MOT_Msk = 0x7000000
	// Mailbox is disabled. This prevents receiving or transmitting any messages with this mailbox.
	CAN_MMR3_MOT_MB_DISABLED = 0x0
	// Reception Mailbox. Mailbox is configured for reception. If a message is received while the mailbox data register is full, it is discarded.
	CAN_MMR3_MOT_MB_RX = 0x1
	// Reception mailbox with overwrite. Mailbox is configured for reception. If a message is received while the mailbox is full, it overwrites the previous message.
	CAN_MMR3_MOT_MB_RX_OVERWRITE = 0x2
	// Transmit mailbox. Mailbox is configured for transmission.
	CAN_MMR3_MOT_MB_TX = 0x3
	// Consumer Mailbox. Mailbox is configured in reception but behaves as a Transmit Mailbox, i.e., it sends a remote frame and waits for an answer.
	CAN_MMR3_MOT_MB_CONSUMER = 0x4
	// Producer Mailbox. Mailbox is configured in transmission but also behaves like a reception mailbox, i.e., it waits to receive a Remote Frame before sending its contents.
	CAN_MMR3_MOT_MB_PRODUCER = 0x5

	// MAM3: Mailbox Acceptance Mask Register (MB = 3)
	// Position of MIDvB field.
	CAN_MAM3_MIDvB_Pos = 0x0
	// Bit mask of MIDvB field.
	CAN_MAM3_MIDvB_Msk = 0x3ffff
	// Position of MIDvA field.
	CAN_MAM3_MIDvA_Pos = 0x12
	// Bit mask of MIDvA field.
	CAN_MAM3_MIDvA_Msk = 0x1ffc0000
	// Position of MIDE field.
	CAN_MAM3_MIDE_Pos = 0x1d
	// Bit mask of MIDE field.
	CAN_MAM3_MIDE_Msk = 0x20000000
	// Bit MIDE.
	CAN_MAM3_MIDE = 0x20000000

	// MID3: Mailbox ID Register (MB = 3)
	// Position of MIDvB field.
	CAN_MID3_MIDvB_Pos = 0x0
	// Bit mask of MIDvB field.
	CAN_MID3_MIDvB_Msk = 0x3ffff
	// Position of MIDvA field.
	CAN_MID3_MIDvA_Pos = 0x12
	// Bit mask of MIDvA field.
	CAN_MID3_MIDvA_Msk = 0x1ffc0000
	// Position of MIDE field.
	CAN_MID3_MIDE_Pos = 0x1d
	// Bit mask of MIDE field.
	CAN_MID3_MIDE_Msk = 0x20000000
	// Bit MIDE.
	CAN_MID3_MIDE = 0x20000000

	// MFID3: Mailbox Family ID Register (MB = 3)
	// Position of MFID field.
	CAN_MFID3_MFID_Pos = 0x0
	// Bit mask of MFID field.
	CAN_MFID3_MFID_Msk = 0x1fffffff

	// MSR3: Mailbox Status Register (MB = 3)
	// Position of MTIMESTAMP field.
	CAN_MSR3_MTIMESTAMP_Pos = 0x0
	// Bit mask of MTIMESTAMP field.
	CAN_MSR3_MTIMESTAMP_Msk = 0xffff
	// Position of MDLC field.
	CAN_MSR3_MDLC_Pos = 0x10
	// Bit mask of MDLC field.
	CAN_MSR3_MDLC_Msk = 0xf0000
	// Position of MRTR field.
	CAN_MSR3_MRTR_Pos = 0x14
	// Bit mask of MRTR field.
	CAN_MSR3_MRTR_Msk = 0x100000
	// Bit MRTR.
	CAN_MSR3_MRTR = 0x100000
	// Position of MABT field.
	CAN_MSR3_MABT_Pos = 0x16
	// Bit mask of MABT field.
	CAN_MSR3_MABT_Msk = 0x400000
	// Bit MABT.
	CAN_MSR3_MABT = 0x400000
	// Position of MRDY field.
	CAN_MSR3_MRDY_Pos = 0x17
	// Bit mask of MRDY field.
	CAN_MSR3_MRDY_Msk = 0x800000
	// Bit MRDY.
	CAN_MSR3_MRDY = 0x800000
	// Position of MMI field.
	CAN_MSR3_MMI_Pos = 0x18
	// Bit mask of MMI field.
	CAN_MSR3_MMI_Msk = 0x1000000
	// Bit MMI.
	CAN_MSR3_MMI = 0x1000000

	// MDL3: Mailbox Data Low Register (MB = 3)
	// Position of MDL field.
	CAN_MDL3_MDL_Pos = 0x0
	// Bit mask of MDL field.
	CAN_MDL3_MDL_Msk = 0xffffffff

	// MDH3: Mailbox Data High Register (MB = 3)
	// Position of MDH field.
	CAN_MDH3_MDH_Pos = 0x0
	// Bit mask of MDH field.
	CAN_MDH3_MDH_Msk = 0xffffffff

	// MCR3: Mailbox Control Register (MB = 3)
	// Position of MDLC field.
	CAN_MCR3_MDLC_Pos = 0x10
	// Bit mask of MDLC field.
	CAN_MCR3_MDLC_Msk = 0xf0000
	// Position of MRTR field.
	CAN_MCR3_MRTR_Pos = 0x14
	// Bit mask of MRTR field.
	CAN_MCR3_MRTR_Msk = 0x100000
	// Bit MRTR.
	CAN_MCR3_MRTR = 0x100000
	// Position of MACR field.
	CAN_MCR3_MACR_Pos = 0x16
	// Bit mask of MACR field.
	CAN_MCR3_MACR_Msk = 0x400000
	// Bit MACR.
	CAN_MCR3_MACR = 0x400000
	// Position of MTCR field.
	CAN_MCR3_MTCR_Pos = 0x17
	// Bit mask of MTCR field.
	CAN_MCR3_MTCR_Msk = 0x800000
	// Bit MTCR.
	CAN_MCR3_MTCR = 0x800000

	// MMR4: Mailbox Mode Register (MB = 4)
	// Position of MTIMEMARK field.
	CAN_MMR4_MTIMEMARK_Pos = 0x0
	// Bit mask of MTIMEMARK field.
	CAN_MMR4_MTIMEMARK_Msk = 0xffff
	// Position of PRIOR field.
	CAN_MMR4_PRIOR_Pos = 0x10
	// Bit mask of PRIOR field.
	CAN_MMR4_PRIOR_Msk = 0xf0000
	// Position of MOT field.
	CAN_MMR4_MOT_Pos = 0x18
	// Bit mask of MOT field.
	CAN_MMR4_MOT_Msk = 0x7000000
	// Mailbox is disabled. This prevents receiving or transmitting any messages with this mailbox.
	CAN_MMR4_MOT_MB_DISABLED = 0x0
	// Reception Mailbox. Mailbox is configured for reception. If a message is received while the mailbox data register is full, it is discarded.
	CAN_MMR4_MOT_MB_RX = 0x1
	// Reception mailbox with overwrite. Mailbox is configured for reception. If a message is received while the mailbox is full, it overwrites the previous message.
	CAN_MMR4_MOT_MB_RX_OVERWRITE = 0x2
	// Transmit mailbox. Mailbox is configured for transmission.
	CAN_MMR4_MOT_MB_TX = 0x3
	// Consumer Mailbox. Mailbox is configured in reception but behaves as a Transmit Mailbox, i.e., it sends a remote frame and waits for an answer.
	CAN_MMR4_MOT_MB_CONSUMER = 0x4
	// Producer Mailbox. Mailbox is configured in transmission but also behaves like a reception mailbox, i.e., it waits to receive a Remote Frame before sending its contents.
	CAN_MMR4_MOT_MB_PRODUCER = 0x5

	// MAM4: Mailbox Acceptance Mask Register (MB = 4)
	// Position of MIDvB field.
	CAN_MAM4_MIDvB_Pos = 0x0
	// Bit mask of MIDvB field.
	CAN_MAM4_MIDvB_Msk = 0x3ffff
	// Position of MIDvA field.
	CAN_MAM4_MIDvA_Pos = 0x12
	// Bit mask of MIDvA field.
	CAN_MAM4_MIDvA_Msk = 0x1ffc0000
	// Position of MIDE field.
	CAN_MAM4_MIDE_Pos = 0x1d
	// Bit mask of MIDE field.
	CAN_MAM4_MIDE_Msk = 0x20000000
	// Bit MIDE.
	CAN_MAM4_MIDE = 0x20000000

	// MID4: Mailbox ID Register (MB = 4)
	// Position of MIDvB field.
	CAN_MID4_MIDvB_Pos = 0x0
	// Bit mask of MIDvB field.
	CAN_MID4_MIDvB_Msk = 0x3ffff
	// Position of MIDvA field.
	CAN_MID4_MIDvA_Pos = 0x12
	// Bit mask of MIDvA field.
	CAN_MID4_MIDvA_Msk = 0x1ffc0000
	// Position of MIDE field.
	CAN_MID4_MIDE_Pos = 0x1d
	// Bit mask of MIDE field.
	CAN_MID4_MIDE_Msk = 0x20000000
	// Bit MIDE.
	CAN_MID4_MIDE = 0x20000000

	// MFID4: Mailbox Family ID Register (MB = 4)
	// Position of MFID field.
	CAN_MFID4_MFID_Pos = 0x0
	// Bit mask of MFID field.
	CAN_MFID4_MFID_Msk = 0x1fffffff

	// MSR4: Mailbox Status Register (MB = 4)
	// Position of MTIMESTAMP field.
	CAN_MSR4_MTIMESTAMP_Pos = 0x0
	// Bit mask of MTIMESTAMP field.
	CAN_MSR4_MTIMESTAMP_Msk = 0xffff
	// Position of MDLC field.
	CAN_MSR4_MDLC_Pos = 0x10
	// Bit mask of MDLC field.
	CAN_MSR4_MDLC_Msk = 0xf0000
	// Position of MRTR field.
	CAN_MSR4_MRTR_Pos = 0x14
	// Bit mask of MRTR field.
	CAN_MSR4_MRTR_Msk = 0x100000
	// Bit MRTR.
	CAN_MSR4_MRTR = 0x100000
	// Position of MABT field.
	CAN_MSR4_MABT_Pos = 0x16
	// Bit mask of MABT field.
	CAN_MSR4_MABT_Msk = 0x400000
	// Bit MABT.
	CAN_MSR4_MABT = 0x400000
	// Position of MRDY field.
	CAN_MSR4_MRDY_Pos = 0x17
	// Bit mask of MRDY field.
	CAN_MSR4_MRDY_Msk = 0x800000
	// Bit MRDY.
	CAN_MSR4_MRDY = 0x800000
	// Position of MMI field.
	CAN_MSR4_MMI_Pos = 0x18
	// Bit mask of MMI field.
	CAN_MSR4_MMI_Msk = 0x1000000
	// Bit MMI.
	CAN_MSR4_MMI = 0x1000000

	// MDL4: Mailbox Data Low Register (MB = 4)
	// Position of MDL field.
	CAN_MDL4_MDL_Pos = 0x0
	// Bit mask of MDL field.
	CAN_MDL4_MDL_Msk = 0xffffffff

	// MDH4: Mailbox Data High Register (MB = 4)
	// Position of MDH field.
	CAN_MDH4_MDH_Pos = 0x0
	// Bit mask of MDH field.
	CAN_MDH4_MDH_Msk = 0xffffffff

	// MCR4: Mailbox Control Register (MB = 4)
	// Position of MDLC field.
	CAN_MCR4_MDLC_Pos = 0x10
	// Bit mask of MDLC field.
	CAN_MCR4_MDLC_Msk = 0xf0000
	// Position of MRTR field.
	CAN_MCR4_MRTR_Pos = 0x14
	// Bit mask of MRTR field.
	CAN_MCR4_MRTR_Msk = 0x100000
	// Bit MRTR.
	CAN_MCR4_MRTR = 0x100000
	// Position of MACR field.
	CAN_MCR4_MACR_Pos = 0x16
	// Bit mask of MACR field.
	CAN_MCR4_MACR_Msk = 0x400000
	// Bit MACR.
	CAN_MCR4_MACR = 0x400000
	// Position of MTCR field.
	CAN_MCR4_MTCR_Pos = 0x17
	// Bit mask of MTCR field.
	CAN_MCR4_MTCR_Msk = 0x800000
	// Bit MTCR.
	CAN_MCR4_MTCR = 0x800000

	// MMR5: Mailbox Mode Register (MB = 5)
	// Position of MTIMEMARK field.
	CAN_MMR5_MTIMEMARK_Pos = 0x0
	// Bit mask of MTIMEMARK field.
	CAN_MMR5_MTIMEMARK_Msk = 0xffff
	// Position of PRIOR field.
	CAN_MMR5_PRIOR_Pos = 0x10
	// Bit mask of PRIOR field.
	CAN_MMR5_PRIOR_Msk = 0xf0000
	// Position of MOT field.
	CAN_MMR5_MOT_Pos = 0x18
	// Bit mask of MOT field.
	CAN_MMR5_MOT_Msk = 0x7000000
	// Mailbox is disabled. This prevents receiving or transmitting any messages with this mailbox.
	CAN_MMR5_MOT_MB_DISABLED = 0x0
	// Reception Mailbox. Mailbox is configured for reception. If a message is received while the mailbox data register is full, it is discarded.
	CAN_MMR5_MOT_MB_RX = 0x1
	// Reception mailbox with overwrite. Mailbox is configured for reception. If a message is received while the mailbox is full, it overwrites the previous message.
	CAN_MMR5_MOT_MB_RX_OVERWRITE = 0x2
	// Transmit mailbox. Mailbox is configured for transmission.
	CAN_MMR5_MOT_MB_TX = 0x3
	// Consumer Mailbox. Mailbox is configured in reception but behaves as a Transmit Mailbox, i.e., it sends a remote frame and waits for an answer.
	CAN_MMR5_MOT_MB_CONSUMER = 0x4
	// Producer Mailbox. Mailbox is configured in transmission but also behaves like a reception mailbox, i.e., it waits to receive a Remote Frame before sending its contents.
	CAN_MMR5_MOT_MB_PRODUCER = 0x5

	// MAM5: Mailbox Acceptance Mask Register (MB = 5)
	// Position of MIDvB field.
	CAN_MAM5_MIDvB_Pos = 0x0
	// Bit mask of MIDvB field.
	CAN_MAM5_MIDvB_Msk = 0x3ffff
	// Position of MIDvA field.
	CAN_MAM5_MIDvA_Pos = 0x12
	// Bit mask of MIDvA field.
	CAN_MAM5_MIDvA_Msk = 0x1ffc0000
	// Position of MIDE field.
	CAN_MAM5_MIDE_Pos = 0x1d
	// Bit mask of MIDE field.
	CAN_MAM5_MIDE_Msk = 0x20000000
	// Bit MIDE.
	CAN_MAM5_MIDE = 0x20000000

	// MID5: Mailbox ID Register (MB = 5)
	// Position of MIDvB field.
	CAN_MID5_MIDvB_Pos = 0x0
	// Bit mask of MIDvB field.
	CAN_MID5_MIDvB_Msk = 0x3ffff
	// Position of MIDvA field.
	CAN_MID5_MIDvA_Pos = 0x12
	// Bit mask of MIDvA field.
	CAN_MID5_MIDvA_Msk = 0x1ffc0000
	// Position of MIDE field.
	CAN_MID5_MIDE_Pos = 0x1d
	// Bit mask of MIDE field.
	CAN_MID5_MIDE_Msk = 0x20000000
	// Bit MIDE.
	CAN_MID5_MIDE = 0x20000000

	// MFID5: Mailbox Family ID Register (MB = 5)
	// Position of MFID field.
	CAN_MFID5_MFID_Pos = 0x0
	// Bit mask of MFID field.
	CAN_MFID5_MFID_Msk = 0x1fffffff

	// MSR5: Mailbox Status Register (MB = 5)
	// Position of MTIMESTAMP field.
	CAN_MSR5_MTIMESTAMP_Pos = 0x0
	// Bit mask of MTIMESTAMP field.
	CAN_MSR5_MTIMESTAMP_Msk = 0xffff
	// Position of MDLC field.
	CAN_MSR5_MDLC_Pos = 0x10
	// Bit mask of MDLC field.
	CAN_MSR5_MDLC_Msk = 0xf0000
	// Position of MRTR field.
	CAN_MSR5_MRTR_Pos = 0x14
	// Bit mask of MRTR field.
	CAN_MSR5_MRTR_Msk = 0x100000
	// Bit MRTR.
	CAN_MSR5_MRTR = 0x100000
	// Position of MABT field.
	CAN_MSR5_MABT_Pos = 0x16
	// Bit mask of MABT field.
	CAN_MSR5_MABT_Msk = 0x400000
	// Bit MABT.
	CAN_MSR5_MABT = 0x400000
	// Position of MRDY field.
	CAN_MSR5_MRDY_Pos = 0x17
	// Bit mask of MRDY field.
	CAN_MSR5_MRDY_Msk = 0x800000
	// Bit MRDY.
	CAN_MSR5_MRDY = 0x800000
	// Position of MMI field.
	CAN_MSR5_MMI_Pos = 0x18
	// Bit mask of MMI field.
	CAN_MSR5_MMI_Msk = 0x1000000
	// Bit MMI.
	CAN_MSR5_MMI = 0x1000000

	// MDL5: Mailbox Data Low Register (MB = 5)
	// Position of MDL field.
	CAN_MDL5_MDL_Pos = 0x0
	// Bit mask of MDL field.
	CAN_MDL5_MDL_Msk = 0xffffffff

	// MDH5: Mailbox Data High Register (MB = 5)
	// Position of MDH field.
	CAN_MDH5_MDH_Pos = 0x0
	// Bit mask of MDH field.
	CAN_MDH5_MDH_Msk = 0xffffffff

	// MCR5: Mailbox Control Register (MB = 5)
	// Position of MDLC field.
	CAN_MCR5_MDLC_Pos = 0x10
	// Bit mask of MDLC field.
	CAN_MCR5_MDLC_Msk = 0xf0000
	// Position of MRTR field.
	CAN_MCR5_MRTR_Pos = 0x14
	// Bit mask of MRTR field.
	CAN_MCR5_MRTR_Msk = 0x100000
	// Bit MRTR.
	CAN_MCR5_MRTR = 0x100000
	// Position of MACR field.
	CAN_MCR5_MACR_Pos = 0x16
	// Bit mask of MACR field.
	CAN_MCR5_MACR_Msk = 0x400000
	// Bit MACR.
	CAN_MCR5_MACR = 0x400000
	// Position of MTCR field.
	CAN_MCR5_MTCR_Pos = 0x17
	// Bit mask of MTCR field.
	CAN_MCR5_MTCR_Msk = 0x800000
	// Bit MTCR.
	CAN_MCR5_MTCR = 0x800000

	// MMR6: Mailbox Mode Register (MB = 6)
	// Position of MTIMEMARK field.
	CAN_MMR6_MTIMEMARK_Pos = 0x0
	// Bit mask of MTIMEMARK field.
	CAN_MMR6_MTIMEMARK_Msk = 0xffff
	// Position of PRIOR field.
	CAN_MMR6_PRIOR_Pos = 0x10
	// Bit mask of PRIOR field.
	CAN_MMR6_PRIOR_Msk = 0xf0000
	// Position of MOT field.
	CAN_MMR6_MOT_Pos = 0x18
	// Bit mask of MOT field.
	CAN_MMR6_MOT_Msk = 0x7000000
	// Mailbox is disabled. This prevents receiving or transmitting any messages with this mailbox.
	CAN_MMR6_MOT_MB_DISABLED = 0x0
	// Reception Mailbox. Mailbox is configured for reception. If a message is received while the mailbox data register is full, it is discarded.
	CAN_MMR6_MOT_MB_RX = 0x1
	// Reception mailbox with overwrite. Mailbox is configured for reception. If a message is received while the mailbox is full, it overwrites the previous message.
	CAN_MMR6_MOT_MB_RX_OVERWRITE = 0x2
	// Transmit mailbox. Mailbox is configured for transmission.
	CAN_MMR6_MOT_MB_TX = 0x3
	// Consumer Mailbox. Mailbox is configured in reception but behaves as a Transmit Mailbox, i.e., it sends a remote frame and waits for an answer.
	CAN_MMR6_MOT_MB_CONSUMER = 0x4
	// Producer Mailbox. Mailbox is configured in transmission but also behaves like a reception mailbox, i.e., it waits to receive a Remote Frame before sending its contents.
	CAN_MMR6_MOT_MB_PRODUCER = 0x5

	// MAM6: Mailbox Acceptance Mask Register (MB = 6)
	// Position of MIDvB field.
	CAN_MAM6_MIDvB_Pos = 0x0
	// Bit mask of MIDvB field.
	CAN_MAM6_MIDvB_Msk = 0x3ffff
	// Position of MIDvA field.
	CAN_MAM6_MIDvA_Pos = 0x12
	// Bit mask of MIDvA field.
	CAN_MAM6_MIDvA_Msk = 0x1ffc0000
	// Position of MIDE field.
	CAN_MAM6_MIDE_Pos = 0x1d
	// Bit mask of MIDE field.
	CAN_MAM6_MIDE_Msk = 0x20000000
	// Bit MIDE.
	CAN_MAM6_MIDE = 0x20000000

	// MID6: Mailbox ID Register (MB = 6)
	// Position of MIDvB field.
	CAN_MID6_MIDvB_Pos = 0x0
	// Bit mask of MIDvB field.
	CAN_MID6_MIDvB_Msk = 0x3ffff
	// Position of MIDvA field.
	CAN_MID6_MIDvA_Pos = 0x12
	// Bit mask of MIDvA field.
	CAN_MID6_MIDvA_Msk = 0x1ffc0000
	// Position of MIDE field.
	CAN_MID6_MIDE_Pos = 0x1d
	// Bit mask of MIDE field.
	CAN_MID6_MIDE_Msk = 0x20000000
	// Bit MIDE.
	CAN_MID6_MIDE = 0x20000000

	// MFID6: Mailbox Family ID Register (MB = 6)
	// Position of MFID field.
	CAN_MFID6_MFID_Pos = 0x0
	// Bit mask of MFID field.
	CAN_MFID6_MFID_Msk = 0x1fffffff

	// MSR6: Mailbox Status Register (MB = 6)
	// Position of MTIMESTAMP field.
	CAN_MSR6_MTIMESTAMP_Pos = 0x0
	// Bit mask of MTIMESTAMP field.
	CAN_MSR6_MTIMESTAMP_Msk = 0xffff
	// Position of MDLC field.
	CAN_MSR6_MDLC_Pos = 0x10
	// Bit mask of MDLC field.
	CAN_MSR6_MDLC_Msk = 0xf0000
	// Position of MRTR field.
	CAN_MSR6_MRTR_Pos = 0x14
	// Bit mask of MRTR field.
	CAN_MSR6_MRTR_Msk = 0x100000
	// Bit MRTR.
	CAN_MSR6_MRTR = 0x100000
	// Position of MABT field.
	CAN_MSR6_MABT_Pos = 0x16
	// Bit mask of MABT field.
	CAN_MSR6_MABT_Msk = 0x400000
	// Bit MABT.
	CAN_MSR6_MABT = 0x400000
	// Position of MRDY field.
	CAN_MSR6_MRDY_Pos = 0x17
	// Bit mask of MRDY field.
	CAN_MSR6_MRDY_Msk = 0x800000
	// Bit MRDY.
	CAN_MSR6_MRDY = 0x800000
	// Position of MMI field.
	CAN_MSR6_MMI_Pos = 0x18
	// Bit mask of MMI field.
	CAN_MSR6_MMI_Msk = 0x1000000
	// Bit MMI.
	CAN_MSR6_MMI = 0x1000000

	// MDL6: Mailbox Data Low Register (MB = 6)
	// Position of MDL field.
	CAN_MDL6_MDL_Pos = 0x0
	// Bit mask of MDL field.
	CAN_MDL6_MDL_Msk = 0xffffffff

	// MDH6: Mailbox Data High Register (MB = 6)
	// Position of MDH field.
	CAN_MDH6_MDH_Pos = 0x0
	// Bit mask of MDH field.
	CAN_MDH6_MDH_Msk = 0xffffffff

	// MCR6: Mailbox Control Register (MB = 6)
	// Position of MDLC field.
	CAN_MCR6_MDLC_Pos = 0x10
	// Bit mask of MDLC field.
	CAN_MCR6_MDLC_Msk = 0xf0000
	// Position of MRTR field.
	CAN_MCR6_MRTR_Pos = 0x14
	// Bit mask of MRTR field.
	CAN_MCR6_MRTR_Msk = 0x100000
	// Bit MRTR.
	CAN_MCR6_MRTR = 0x100000
	// Position of MACR field.
	CAN_MCR6_MACR_Pos = 0x16
	// Bit mask of MACR field.
	CAN_MCR6_MACR_Msk = 0x400000
	// Bit MACR.
	CAN_MCR6_MACR = 0x400000
	// Position of MTCR field.
	CAN_MCR6_MTCR_Pos = 0x17
	// Bit mask of MTCR field.
	CAN_MCR6_MTCR_Msk = 0x800000
	// Bit MTCR.
	CAN_MCR6_MTCR = 0x800000

	// MMR7: Mailbox Mode Register (MB = 7)
	// Position of MTIMEMARK field.
	CAN_MMR7_MTIMEMARK_Pos = 0x0
	// Bit mask of MTIMEMARK field.
	CAN_MMR7_MTIMEMARK_Msk = 0xffff
	// Position of PRIOR field.
	CAN_MMR7_PRIOR_Pos = 0x10
	// Bit mask of PRIOR field.
	CAN_MMR7_PRIOR_Msk = 0xf0000
	// Position of MOT field.
	CAN_MMR7_MOT_Pos = 0x18
	// Bit mask of MOT field.
	CAN_MMR7_MOT_Msk = 0x7000000
	// Mailbox is disabled. This prevents receiving or transmitting any messages with this mailbox.
	CAN_MMR7_MOT_MB_DISABLED = 0x0
	// Reception Mailbox. Mailbox is configured for reception. If a message is received while the mailbox data register is full, it is discarded.
	CAN_MMR7_MOT_MB_RX = 0x1
	// Reception mailbox with overwrite. Mailbox is configured for reception. If a message is received while the mailbox is full, it overwrites the previous message.
	CAN_MMR7_MOT_MB_RX_OVERWRITE = 0x2
	// Transmit mailbox. Mailbox is configured for transmission.
	CAN_MMR7_MOT_MB_TX = 0x3
	// Consumer Mailbox. Mailbox is configured in reception but behaves as a Transmit Mailbox, i.e., it sends a remote frame and waits for an answer.
	CAN_MMR7_MOT_MB_CONSUMER = 0x4
	// Producer Mailbox. Mailbox is configured in transmission but also behaves like a reception mailbox, i.e., it waits to receive a Remote Frame before sending its contents.
	CAN_MMR7_MOT_MB_PRODUCER = 0x5

	// MAM7: Mailbox Acceptance Mask Register (MB = 7)
	// Position of MIDvB field.
	CAN_MAM7_MIDvB_Pos = 0x0
	// Bit mask of MIDvB field.
	CAN_MAM7_MIDvB_Msk = 0x3ffff
	// Position of MIDvA field.
	CAN_MAM7_MIDvA_Pos = 0x12
	// Bit mask of MIDvA field.
	CAN_MAM7_MIDvA_Msk = 0x1ffc0000
	// Position of MIDE field.
	CAN_MAM7_MIDE_Pos = 0x1d
	// Bit mask of MIDE field.
	CAN_MAM7_MIDE_Msk = 0x20000000
	// Bit MIDE.
	CAN_MAM7_MIDE = 0x20000000

	// MID7: Mailbox ID Register (MB = 7)
	// Position of MIDvB field.
	CAN_MID7_MIDvB_Pos = 0x0
	// Bit mask of MIDvB field.
	CAN_MID7_MIDvB_Msk = 0x3ffff
	// Position of MIDvA field.
	CAN_MID7_MIDvA_Pos = 0x12
	// Bit mask of MIDvA field.
	CAN_MID7_MIDvA_Msk = 0x1ffc0000
	// Position of MIDE field.
	CAN_MID7_MIDE_Pos = 0x1d
	// Bit mask of MIDE field.
	CAN_MID7_MIDE_Msk = 0x20000000
	// Bit MIDE.
	CAN_MID7_MIDE = 0x20000000

	// MFID7: Mailbox Family ID Register (MB = 7)
	// Position of MFID field.
	CAN_MFID7_MFID_Pos = 0x0
	// Bit mask of MFID field.
	CAN_MFID7_MFID_Msk = 0x1fffffff

	// MSR7: Mailbox Status Register (MB = 7)
	// Position of MTIMESTAMP field.
	CAN_MSR7_MTIMESTAMP_Pos = 0x0
	// Bit mask of MTIMESTAMP field.
	CAN_MSR7_MTIMESTAMP_Msk = 0xffff
	// Position of MDLC field.
	CAN_MSR7_MDLC_Pos = 0x10
	// Bit mask of MDLC field.
	CAN_MSR7_MDLC_Msk = 0xf0000
	// Position of MRTR field.
	CAN_MSR7_MRTR_Pos = 0x14
	// Bit mask of MRTR field.
	CAN_MSR7_MRTR_Msk = 0x100000
	// Bit MRTR.
	CAN_MSR7_MRTR = 0x100000
	// Position of MABT field.
	CAN_MSR7_MABT_Pos = 0x16
	// Bit mask of MABT field.
	CAN_MSR7_MABT_Msk = 0x400000
	// Bit MABT.
	CAN_MSR7_MABT = 0x400000
	// Position of MRDY field.
	CAN_MSR7_MRDY_Pos = 0x17
	// Bit mask of MRDY field.
	CAN_MSR7_MRDY_Msk = 0x800000
	// Bit MRDY.
	CAN_MSR7_MRDY = 0x800000
	// Position of MMI field.
	CAN_MSR7_MMI_Pos = 0x18
	// Bit mask of MMI field.
	CAN_MSR7_MMI_Msk = 0x1000000
	// Bit MMI.
	CAN_MSR7_MMI = 0x1000000

	// MDL7: Mailbox Data Low Register (MB = 7)
	// Position of MDL field.
	CAN_MDL7_MDL_Pos = 0x0
	// Bit mask of MDL field.
	CAN_MDL7_MDL_Msk = 0xffffffff

	// MDH7: Mailbox Data High Register (MB = 7)
	// Position of MDH field.
	CAN_MDH7_MDH_Pos = 0x0
	// Bit mask of MDH field.
	CAN_MDH7_MDH_Msk = 0xffffffff

	// MCR7: Mailbox Control Register (MB = 7)
	// Position of MDLC field.
	CAN_MCR7_MDLC_Pos = 0x10
	// Bit mask of MDLC field.
	CAN_MCR7_MDLC_Msk = 0xf0000
	// Position of MRTR field.
	CAN_MCR7_MRTR_Pos = 0x14
	// Bit mask of MRTR field.
	CAN_MCR7_MRTR_Msk = 0x100000
	// Bit MRTR.
	CAN_MCR7_MRTR = 0x100000
	// Position of MACR field.
	CAN_MCR7_MACR_Pos = 0x16
	// Bit mask of MACR field.
	CAN_MCR7_MACR_Msk = 0x400000
	// Bit MACR.
	CAN_MCR7_MACR = 0x400000
	// Position of MTCR field.
	CAN_MCR7_MTCR_Pos = 0x17
	// Bit mask of MTCR field.
	CAN_MCR7_MTCR_Msk = 0x800000
	// Bit MTCR.
	CAN_MCR7_MTCR = 0x800000
)

// Constants for TC0: Timer Counter 0
const (
	// CCR0: Channel Control Register (channel = 0)
	// Position of CLKEN field.
	TC_CCR0_CLKEN_Pos = 0x0
	// Bit mask of CLKEN field.
	TC_CCR0_CLKEN_Msk = 0x1
	// Bit CLKEN.
	TC_CCR0_CLKEN = 0x1
	// Position of CLKDIS field.
	TC_CCR0_CLKDIS_Pos = 0x1
	// Bit mask of CLKDIS field.
	TC_CCR0_CLKDIS_Msk = 0x2
	// Bit CLKDIS.
	TC_CCR0_CLKDIS = 0x2
	// Position of SWTRG field.
	TC_CCR0_SWTRG_Pos = 0x2
	// Bit mask of SWTRG field.
	TC_CCR0_SWTRG_Msk = 0x4
	// Bit SWTRG.
	TC_CCR0_SWTRG = 0x4

	// CMR0: Channel Mode Register (channel = 0)
	// Position of TCCLKS field.
	TC_CMR0_TCCLKS_Pos = 0x0
	// Bit mask of TCCLKS field.
	TC_CMR0_TCCLKS_Msk = 0x7
	// Clock selected: TCLK1
	TC_CMR0_TCCLKS_TIMER_CLOCK1 = 0x0
	// Clock selected: TCLK2
	TC_CMR0_TCCLKS_TIMER_CLOCK2 = 0x1
	// Clock selected: TCLK3
	TC_CMR0_TCCLKS_TIMER_CLOCK3 = 0x2
	// Clock selected: TCLK4
	TC_CMR0_TCCLKS_TIMER_CLOCK4 = 0x3
	// Clock selected: TCLK5
	TC_CMR0_TCCLKS_TIMER_CLOCK5 = 0x4
	// Clock selected: XC0
	TC_CMR0_TCCLKS_XC0 = 0x5
	// Clock selected: XC1
	TC_CMR0_TCCLKS_XC1 = 0x6
	// Clock selected: XC2
	TC_CMR0_TCCLKS_XC2 = 0x7
	// Position of CLKI field.
	TC_CMR0_CLKI_Pos = 0x3
	// Bit mask of CLKI field.
	TC_CMR0_CLKI_Msk = 0x8
	// Bit CLKI.
	TC_CMR0_CLKI = 0x8
	// Position of BURST field.
	TC_CMR0_BURST_Pos = 0x4
	// Bit mask of BURST field.
	TC_CMR0_BURST_Msk = 0x30
	// The clock is not gated by an external signal.
	TC_CMR0_BURST_NONE = 0x0
	// XC0 is ANDed with the selected clock.
	TC_CMR0_BURST_XC0 = 0x1
	// XC1 is ANDed with the selected clock.
	TC_CMR0_BURST_XC1 = 0x2
	// XC2 is ANDed with the selected clock.
	TC_CMR0_BURST_XC2 = 0x3
	// Position of LDBSTOP field.
	TC_CMR0_LDBSTOP_Pos = 0x6
	// Bit mask of LDBSTOP field.
	TC_CMR0_LDBSTOP_Msk = 0x40
	// Bit LDBSTOP.
	TC_CMR0_LDBSTOP = 0x40
	// Position of LDBDIS field.
	TC_CMR0_LDBDIS_Pos = 0x7
	// Bit mask of LDBDIS field.
	TC_CMR0_LDBDIS_Msk = 0x80
	// Bit LDBDIS.
	TC_CMR0_LDBDIS = 0x80
	// Position of ETRGEDG field.
	TC_CMR0_ETRGEDG_Pos = 0x8
	// Bit mask of ETRGEDG field.
	TC_CMR0_ETRGEDG_Msk = 0x300
	// The clock is not gated by an external signal.
	TC_CMR0_ETRGEDG_NONE = 0x0
	// Rising edge
	TC_CMR0_ETRGEDG_RISING = 0x1
	// Falling edge
	TC_CMR0_ETRGEDG_FALLING = 0x2
	// Each edge
	TC_CMR0_ETRGEDG_EDGE = 0x3
	// Position of ABETRG field.
	TC_CMR0_ABETRG_Pos = 0xa
	// Bit mask of ABETRG field.
	TC_CMR0_ABETRG_Msk = 0x400
	// Bit ABETRG.
	TC_CMR0_ABETRG = 0x400
	// Position of CPCTRG field.
	TC_CMR0_CPCTRG_Pos = 0xe
	// Bit mask of CPCTRG field.
	TC_CMR0_CPCTRG_Msk = 0x4000
	// Bit CPCTRG.
	TC_CMR0_CPCTRG = 0x4000
	// Position of WAVE field.
	TC_CMR0_WAVE_Pos = 0xf
	// Bit mask of WAVE field.
	TC_CMR0_WAVE_Msk = 0x8000
	// Bit WAVE.
	TC_CMR0_WAVE = 0x8000
	// Position of LDRA field.
	TC_CMR0_LDRA_Pos = 0x10
	// Bit mask of LDRA field.
	TC_CMR0_LDRA_Msk = 0x30000
	// None
	TC_CMR0_LDRA_NONE = 0x0
	// Rising edge of TIOA
	TC_CMR0_LDRA_RISING = 0x1
	// Falling edge of TIOA
	TC_CMR0_LDRA_FALLING = 0x2
	// Each edge of TIOA
	TC_CMR0_LDRA_EDGE = 0x3
	// Position of LDRB field.
	TC_CMR0_LDRB_Pos = 0x12
	// Bit mask of LDRB field.
	TC_CMR0_LDRB_Msk = 0xc0000
	// None
	TC_CMR0_LDRB_NONE = 0x0
	// Rising edge of TIOA
	TC_CMR0_LDRB_RISING = 0x1
	// Falling edge of TIOA
	TC_CMR0_LDRB_FALLING = 0x2
	// Each edge of TIOA
	TC_CMR0_LDRB_EDGE = 0x3

	// CMR0_WAVE_EQ_1: Channel Mode Register (channel = 0)
	// Position of TCCLKS field.
	TC_CMR0_WAVE_EQ_1_TCCLKS_Pos = 0x0
	// Bit mask of TCCLKS field.
	TC_CMR0_WAVE_EQ_1_TCCLKS_Msk = 0x7
	// Clock selected: TCLK1
	TC_CMR0_WAVE_EQ_1_TCCLKS_TIMER_CLOCK1 = 0x0
	// Clock selected: TCLK2
	TC_CMR0_WAVE_EQ_1_TCCLKS_TIMER_CLOCK2 = 0x1
	// Clock selected: TCLK3
	TC_CMR0_WAVE_EQ_1_TCCLKS_TIMER_CLOCK3 = 0x2
	// Clock selected: TCLK4
	TC_CMR0_WAVE_EQ_1_TCCLKS_TIMER_CLOCK4 = 0x3
	// Clock selected: TCLK5
	TC_CMR0_WAVE_EQ_1_TCCLKS_TIMER_CLOCK5 = 0x4
	// Clock selected: XC0
	TC_CMR0_WAVE_EQ_1_TCCLKS_XC0 = 0x5
	// Clock selected: XC1
	TC_CMR0_WAVE_EQ_1_TCCLKS_XC1 = 0x6
	// Clock selected: XC2
	TC_CMR0_WAVE_EQ_1_TCCLKS_XC2 = 0x7
	// Position of CLKI field.
	TC_CMR0_WAVE_EQ_1_CLKI_Pos = 0x3
	// Bit mask of CLKI field.
	TC_CMR0_WAVE_EQ_1_CLKI_Msk = 0x8
	// Bit CLKI.
	TC_CMR0_WAVE_EQ_1_CLKI = 0x8
	// Position of BURST field.
	TC_CMR0_WAVE_EQ_1_BURST_Pos = 0x4
	// Bit mask of BURST field.
	TC_CMR0_WAVE_EQ_1_BURST_Msk = 0x30
	// The clock is not gated by an external signal.
	TC_CMR0_WAVE_EQ_1_BURST_NONE = 0x0
	// XC0 is ANDed with the selected clock.
	TC_CMR0_WAVE_EQ_1_BURST_XC0 = 0x1
	// XC1 is ANDed with the selected clock.
	TC_CMR0_WAVE_EQ_1_BURST_XC1 = 0x2
	// XC2 is ANDed with the selected clock.
	TC_CMR0_WAVE_EQ_1_BURST_XC2 = 0x3
	// Position of CPCSTOP field.
	TC_CMR0_WAVE_EQ_1_CPCSTOP_Pos = 0x6
	// Bit mask of CPCSTOP field.
	TC_CMR0_WAVE_EQ_1_CPCSTOP_Msk = 0x40
	// Bit CPCSTOP.
	TC_CMR0_WAVE_EQ_1_CPCSTOP = 0x40
	// Position of CPCDIS field.
	TC_CMR0_WAVE_EQ_1_CPCDIS_Pos = 0x7
	// Bit mask of CPCDIS field.
	TC_CMR0_WAVE_EQ_1_CPCDIS_Msk = 0x80
	// Bit CPCDIS.
	TC_CMR0_WAVE_EQ_1_CPCDIS = 0x80
	// Position of EEVTEDG field.
	TC_CMR0_WAVE_EQ_1_EEVTEDG_Pos = 0x8
	// Bit mask of EEVTEDG field.
	TC_CMR0_WAVE_EQ_1_EEVTEDG_Msk = 0x300
	// None
	TC_CMR0_WAVE_EQ_1_EEVTEDG_NONE = 0x0
	// Rising edge
	TC_CMR0_WAVE_EQ_1_EEVTEDG_RISING = 0x1
	// Falling edge
	TC_CMR0_WAVE_EQ_1_EEVTEDG_FALLING = 0x2
	// Each edge
	TC_CMR0_WAVE_EQ_1_EEVTEDG_EDGE = 0x3
	// Position of EEVT field.
	TC_CMR0_WAVE_EQ_1_EEVT_Pos = 0xa
	// Bit mask of EEVT field.
	TC_CMR0_WAVE_EQ_1_EEVT_Msk = 0xc00
	// TIOB
	TC_CMR0_WAVE_EQ_1_EEVT_TIOB = 0x0
	// XC0
	TC_CMR0_WAVE_EQ_1_EEVT_XC0 = 0x1
	// XC1
	TC_CMR0_WAVE_EQ_1_EEVT_XC1 = 0x2
	// XC2
	TC_CMR0_WAVE_EQ_1_EEVT_XC2 = 0x3
	// Position of ENETRG field.
	TC_CMR0_WAVE_EQ_1_ENETRG_Pos = 0xc
	// Bit mask of ENETRG field.
	TC_CMR0_WAVE_EQ_1_ENETRG_Msk = 0x1000
	// Bit ENETRG.
	TC_CMR0_WAVE_EQ_1_ENETRG = 0x1000
	// Position of WAVSEL field.
	TC_CMR0_WAVE_EQ_1_WAVSEL_Pos = 0xd
	// Bit mask of WAVSEL field.
	TC_CMR0_WAVE_EQ_1_WAVSEL_Msk = 0x6000
	// UP mode without automatic trigger on RC Compare
	TC_CMR0_WAVE_EQ_1_WAVSEL_UP = 0x0
	// UPDOWN mode without automatic trigger on RC Compare
	TC_CMR0_WAVE_EQ_1_WAVSEL_UPDOWN = 0x1
	// UP mode with automatic trigger on RC Compare
	TC_CMR0_WAVE_EQ_1_WAVSEL_UP_RC = 0x2
	// UPDOWN mode with automatic trigger on RC Compare
	TC_CMR0_WAVE_EQ_1_WAVSEL_UPDOWN_RC = 0x3
	// Position of WAVE field.
	TC_CMR0_WAVE_EQ_1_WAVE_Pos = 0xf
	// Bit mask of WAVE field.
	TC_CMR0_WAVE_EQ_1_WAVE_Msk = 0x8000
	// Bit WAVE.
	TC_CMR0_WAVE_EQ_1_WAVE = 0x8000
	// Position of ACPA field.
	TC_CMR0_WAVE_EQ_1_ACPA_Pos = 0x10
	// Bit mask of ACPA field.
	TC_CMR0_WAVE_EQ_1_ACPA_Msk = 0x30000
	// None
	TC_CMR0_WAVE_EQ_1_ACPA_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_ACPA_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_ACPA_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_ACPA_TOGGLE = 0x3
	// Position of ACPC field.
	TC_CMR0_WAVE_EQ_1_ACPC_Pos = 0x12
	// Bit mask of ACPC field.
	TC_CMR0_WAVE_EQ_1_ACPC_Msk = 0xc0000
	// None
	TC_CMR0_WAVE_EQ_1_ACPC_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_ACPC_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_ACPC_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_ACPC_TOGGLE = 0x3
	// Position of AEEVT field.
	TC_CMR0_WAVE_EQ_1_AEEVT_Pos = 0x14
	// Bit mask of AEEVT field.
	TC_CMR0_WAVE_EQ_1_AEEVT_Msk = 0x300000
	// None
	TC_CMR0_WAVE_EQ_1_AEEVT_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_AEEVT_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_AEEVT_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_AEEVT_TOGGLE = 0x3
	// Position of ASWTRG field.
	TC_CMR0_WAVE_EQ_1_ASWTRG_Pos = 0x16
	// Bit mask of ASWTRG field.
	TC_CMR0_WAVE_EQ_1_ASWTRG_Msk = 0xc00000
	// None
	TC_CMR0_WAVE_EQ_1_ASWTRG_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_ASWTRG_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_ASWTRG_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_ASWTRG_TOGGLE = 0x3
	// Position of BCPB field.
	TC_CMR0_WAVE_EQ_1_BCPB_Pos = 0x18
	// Bit mask of BCPB field.
	TC_CMR0_WAVE_EQ_1_BCPB_Msk = 0x3000000
	// None
	TC_CMR0_WAVE_EQ_1_BCPB_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_BCPB_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_BCPB_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_BCPB_TOGGLE = 0x3
	// Position of BCPC field.
	TC_CMR0_WAVE_EQ_1_BCPC_Pos = 0x1a
	// Bit mask of BCPC field.
	TC_CMR0_WAVE_EQ_1_BCPC_Msk = 0xc000000
	// None
	TC_CMR0_WAVE_EQ_1_BCPC_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_BCPC_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_BCPC_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_BCPC_TOGGLE = 0x3
	// Position of BEEVT field.
	TC_CMR0_WAVE_EQ_1_BEEVT_Pos = 0x1c
	// Bit mask of BEEVT field.
	TC_CMR0_WAVE_EQ_1_BEEVT_Msk = 0x30000000
	// None
	TC_CMR0_WAVE_EQ_1_BEEVT_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_BEEVT_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_BEEVT_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_BEEVT_TOGGLE = 0x3
	// Position of BSWTRG field.
	TC_CMR0_WAVE_EQ_1_BSWTRG_Pos = 0x1e
	// Bit mask of BSWTRG field.
	TC_CMR0_WAVE_EQ_1_BSWTRG_Msk = 0xc0000000
	// None
	TC_CMR0_WAVE_EQ_1_BSWTRG_NONE = 0x0
	// Set
	TC_CMR0_WAVE_EQ_1_BSWTRG_SET = 0x1
	// Clear
	TC_CMR0_WAVE_EQ_1_BSWTRG_CLEAR = 0x2
	// Toggle
	TC_CMR0_WAVE_EQ_1_BSWTRG_TOGGLE = 0x3

	// SMMR0: Stepper Motor Mode Register (channel = 0)
	// Position of GCEN field.
	TC_SMMR0_GCEN_Pos = 0x0
	// Bit mask of GCEN field.
	TC_SMMR0_GCEN_Msk = 0x1
	// Bit GCEN.
	TC_SMMR0_GCEN = 0x1
	// Position of DOWN field.
	TC_SMMR0_DOWN_Pos = 0x1
	// Bit mask of DOWN field.
	TC_SMMR0_DOWN_Msk = 0x2
	// Bit DOWN.
	TC_SMMR0_DOWN = 0x2

	// RAB0: Register AB (channel = 0)
	// Position of RAB field.
	TC_RAB0_RAB_Pos = 0x0
	// Bit mask of RAB field.
	TC_RAB0_RAB_Msk = 0xffffffff

	// CV0: Counter Value (channel = 0)
	// Position of CV field.
	TC_CV0_CV_Pos = 0x0
	// Bit mask of CV field.
	TC_CV0_CV_Msk = 0xffffffff

	// RA0: Register A (channel = 0)
	// Position of RA field.
	TC_RA0_RA_Pos = 0x0
	// Bit mask of RA field.
	TC_RA0_RA_Msk = 0xffffffff

	// RB0: Register B (channel = 0)
	// Position of RB field.
	TC_RB0_RB_Pos = 0x0
	// Bit mask of RB field.
	TC_RB0_RB_Msk = 0xffffffff

	// RC0: Register C (channel = 0)
	// Position of RC field.
	TC_RC0_RC_Pos = 0x0
	// Bit mask of RC field.
	TC_RC0_RC_Msk = 0xffffffff

	// SR0: Status Register (channel = 0)
	// Position of COVFS field.
	TC_SR0_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_SR0_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_SR0_COVFS = 0x1
	// Position of LOVRS field.
	TC_SR0_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_SR0_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_SR0_LOVRS = 0x2
	// Position of CPAS field.
	TC_SR0_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_SR0_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_SR0_CPAS = 0x4
	// Position of CPBS field.
	TC_SR0_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_SR0_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_SR0_CPBS = 0x8
	// Position of CPCS field.
	TC_SR0_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_SR0_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_SR0_CPCS = 0x10
	// Position of LDRAS field.
	TC_SR0_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_SR0_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_SR0_LDRAS = 0x20
	// Position of LDRBS field.
	TC_SR0_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_SR0_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_SR0_LDRBS = 0x40
	// Position of ETRGS field.
	TC_SR0_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_SR0_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_SR0_ETRGS = 0x80
	// Position of CLKSTA field.
	TC_SR0_CLKSTA_Pos = 0x10
	// Bit mask of CLKSTA field.
	TC_SR0_CLKSTA_Msk = 0x10000
	// Bit CLKSTA.
	TC_SR0_CLKSTA = 0x10000
	// Position of MTIOA field.
	TC_SR0_MTIOA_Pos = 0x11
	// Bit mask of MTIOA field.
	TC_SR0_MTIOA_Msk = 0x20000
	// Bit MTIOA.
	TC_SR0_MTIOA = 0x20000
	// Position of MTIOB field.
	TC_SR0_MTIOB_Pos = 0x12
	// Bit mask of MTIOB field.
	TC_SR0_MTIOB_Msk = 0x40000
	// Bit MTIOB.
	TC_SR0_MTIOB = 0x40000

	// IER0: Interrupt Enable Register (channel = 0)
	// Position of COVFS field.
	TC_IER0_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IER0_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IER0_COVFS = 0x1
	// Position of LOVRS field.
	TC_IER0_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IER0_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IER0_LOVRS = 0x2
	// Position of CPAS field.
	TC_IER0_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IER0_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IER0_CPAS = 0x4
	// Position of CPBS field.
	TC_IER0_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IER0_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IER0_CPBS = 0x8
	// Position of CPCS field.
	TC_IER0_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IER0_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IER0_CPCS = 0x10
	// Position of LDRAS field.
	TC_IER0_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IER0_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IER0_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IER0_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IER0_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IER0_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IER0_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IER0_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IER0_ETRGS = 0x80

	// IDR0: Interrupt Disable Register (channel = 0)
	// Position of COVFS field.
	TC_IDR0_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IDR0_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IDR0_COVFS = 0x1
	// Position of LOVRS field.
	TC_IDR0_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IDR0_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IDR0_LOVRS = 0x2
	// Position of CPAS field.
	TC_IDR0_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IDR0_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IDR0_CPAS = 0x4
	// Position of CPBS field.
	TC_IDR0_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IDR0_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IDR0_CPBS = 0x8
	// Position of CPCS field.
	TC_IDR0_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IDR0_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IDR0_CPCS = 0x10
	// Position of LDRAS field.
	TC_IDR0_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IDR0_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IDR0_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IDR0_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IDR0_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IDR0_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IDR0_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IDR0_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IDR0_ETRGS = 0x80

	// IMR0: Interrupt Mask Register (channel = 0)
	// Position of COVFS field.
	TC_IMR0_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IMR0_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IMR0_COVFS = 0x1
	// Position of LOVRS field.
	TC_IMR0_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IMR0_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IMR0_LOVRS = 0x2
	// Position of CPAS field.
	TC_IMR0_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IMR0_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IMR0_CPAS = 0x4
	// Position of CPBS field.
	TC_IMR0_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IMR0_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IMR0_CPBS = 0x8
	// Position of CPCS field.
	TC_IMR0_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IMR0_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IMR0_CPCS = 0x10
	// Position of LDRAS field.
	TC_IMR0_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IMR0_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IMR0_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IMR0_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IMR0_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IMR0_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IMR0_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IMR0_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IMR0_ETRGS = 0x80

	// CCR1: Channel Control Register (channel = 1)
	// Position of CLKEN field.
	TC_CCR1_CLKEN_Pos = 0x0
	// Bit mask of CLKEN field.
	TC_CCR1_CLKEN_Msk = 0x1
	// Bit CLKEN.
	TC_CCR1_CLKEN = 0x1
	// Position of CLKDIS field.
	TC_CCR1_CLKDIS_Pos = 0x1
	// Bit mask of CLKDIS field.
	TC_CCR1_CLKDIS_Msk = 0x2
	// Bit CLKDIS.
	TC_CCR1_CLKDIS = 0x2
	// Position of SWTRG field.
	TC_CCR1_SWTRG_Pos = 0x2
	// Bit mask of SWTRG field.
	TC_CCR1_SWTRG_Msk = 0x4
	// Bit SWTRG.
	TC_CCR1_SWTRG = 0x4

	// CMR1: Channel Mode Register (channel = 1)
	// Position of TCCLKS field.
	TC_CMR1_TCCLKS_Pos = 0x0
	// Bit mask of TCCLKS field.
	TC_CMR1_TCCLKS_Msk = 0x7
	// Clock selected: TCLK1
	TC_CMR1_TCCLKS_TIMER_CLOCK1 = 0x0
	// Clock selected: TCLK2
	TC_CMR1_TCCLKS_TIMER_CLOCK2 = 0x1
	// Clock selected: TCLK3
	TC_CMR1_TCCLKS_TIMER_CLOCK3 = 0x2
	// Clock selected: TCLK4
	TC_CMR1_TCCLKS_TIMER_CLOCK4 = 0x3
	// Clock selected: TCLK5
	TC_CMR1_TCCLKS_TIMER_CLOCK5 = 0x4
	// Clock selected: XC0
	TC_CMR1_TCCLKS_XC0 = 0x5
	// Clock selected: XC1
	TC_CMR1_TCCLKS_XC1 = 0x6
	// Clock selected: XC2
	TC_CMR1_TCCLKS_XC2 = 0x7
	// Position of CLKI field.
	TC_CMR1_CLKI_Pos = 0x3
	// Bit mask of CLKI field.
	TC_CMR1_CLKI_Msk = 0x8
	// Bit CLKI.
	TC_CMR1_CLKI = 0x8
	// Position of BURST field.
	TC_CMR1_BURST_Pos = 0x4
	// Bit mask of BURST field.
	TC_CMR1_BURST_Msk = 0x30
	// The clock is not gated by an external signal.
	TC_CMR1_BURST_NONE = 0x0
	// XC0 is ANDed with the selected clock.
	TC_CMR1_BURST_XC0 = 0x1
	// XC1 is ANDed with the selected clock.
	TC_CMR1_BURST_XC1 = 0x2
	// XC2 is ANDed with the selected clock.
	TC_CMR1_BURST_XC2 = 0x3
	// Position of LDBSTOP field.
	TC_CMR1_LDBSTOP_Pos = 0x6
	// Bit mask of LDBSTOP field.
	TC_CMR1_LDBSTOP_Msk = 0x40
	// Bit LDBSTOP.
	TC_CMR1_LDBSTOP = 0x40
	// Position of LDBDIS field.
	TC_CMR1_LDBDIS_Pos = 0x7
	// Bit mask of LDBDIS field.
	TC_CMR1_LDBDIS_Msk = 0x80
	// Bit LDBDIS.
	TC_CMR1_LDBDIS = 0x80
	// Position of ETRGEDG field.
	TC_CMR1_ETRGEDG_Pos = 0x8
	// Bit mask of ETRGEDG field.
	TC_CMR1_ETRGEDG_Msk = 0x300
	// The clock is not gated by an external signal.
	TC_CMR1_ETRGEDG_NONE = 0x0
	// Rising edge
	TC_CMR1_ETRGEDG_RISING = 0x1
	// Falling edge
	TC_CMR1_ETRGEDG_FALLING = 0x2
	// Each edge
	TC_CMR1_ETRGEDG_EDGE = 0x3
	// Position of ABETRG field.
	TC_CMR1_ABETRG_Pos = 0xa
	// Bit mask of ABETRG field.
	TC_CMR1_ABETRG_Msk = 0x400
	// Bit ABETRG.
	TC_CMR1_ABETRG = 0x400
	// Position of CPCTRG field.
	TC_CMR1_CPCTRG_Pos = 0xe
	// Bit mask of CPCTRG field.
	TC_CMR1_CPCTRG_Msk = 0x4000
	// Bit CPCTRG.
	TC_CMR1_CPCTRG = 0x4000
	// Position of WAVE field.
	TC_CMR1_WAVE_Pos = 0xf
	// Bit mask of WAVE field.
	TC_CMR1_WAVE_Msk = 0x8000
	// Bit WAVE.
	TC_CMR1_WAVE = 0x8000
	// Position of LDRA field.
	TC_CMR1_LDRA_Pos = 0x10
	// Bit mask of LDRA field.
	TC_CMR1_LDRA_Msk = 0x30000
	// None
	TC_CMR1_LDRA_NONE = 0x0
	// Rising edge of TIOA
	TC_CMR1_LDRA_RISING = 0x1
	// Falling edge of TIOA
	TC_CMR1_LDRA_FALLING = 0x2
	// Each edge of TIOA
	TC_CMR1_LDRA_EDGE = 0x3
	// Position of LDRB field.
	TC_CMR1_LDRB_Pos = 0x12
	// Bit mask of LDRB field.
	TC_CMR1_LDRB_Msk = 0xc0000
	// None
	TC_CMR1_LDRB_NONE = 0x0
	// Rising edge of TIOA
	TC_CMR1_LDRB_RISING = 0x1
	// Falling edge of TIOA
	TC_CMR1_LDRB_FALLING = 0x2
	// Each edge of TIOA
	TC_CMR1_LDRB_EDGE = 0x3

	// CMR1_WAVE_EQ_1: Channel Mode Register (channel = 1)
	// Position of TCCLKS field.
	TC_CMR1_WAVE_EQ_1_TCCLKS_Pos = 0x0
	// Bit mask of TCCLKS field.
	TC_CMR1_WAVE_EQ_1_TCCLKS_Msk = 0x7
	// Clock selected: TCLK1
	TC_CMR1_WAVE_EQ_1_TCCLKS_TIMER_CLOCK1 = 0x0
	// Clock selected: TCLK2
	TC_CMR1_WAVE_EQ_1_TCCLKS_TIMER_CLOCK2 = 0x1
	// Clock selected: TCLK3
	TC_CMR1_WAVE_EQ_1_TCCLKS_TIMER_CLOCK3 = 0x2
	// Clock selected: TCLK4
	TC_CMR1_WAVE_EQ_1_TCCLKS_TIMER_CLOCK4 = 0x3
	// Clock selected: TCLK5
	TC_CMR1_WAVE_EQ_1_TCCLKS_TIMER_CLOCK5 = 0x4
	// Clock selected: XC0
	TC_CMR1_WAVE_EQ_1_TCCLKS_XC0 = 0x5
	// Clock selected: XC1
	TC_CMR1_WAVE_EQ_1_TCCLKS_XC1 = 0x6
	// Clock selected: XC2
	TC_CMR1_WAVE_EQ_1_TCCLKS_XC2 = 0x7
	// Position of CLKI field.
	TC_CMR1_WAVE_EQ_1_CLKI_Pos = 0x3
	// Bit mask of CLKI field.
	TC_CMR1_WAVE_EQ_1_CLKI_Msk = 0x8
	// Bit CLKI.
	TC_CMR1_WAVE_EQ_1_CLKI = 0x8
	// Position of BURST field.
	TC_CMR1_WAVE_EQ_1_BURST_Pos = 0x4
	// Bit mask of BURST field.
	TC_CMR1_WAVE_EQ_1_BURST_Msk = 0x30
	// The clock is not gated by an external signal.
	TC_CMR1_WAVE_EQ_1_BURST_NONE = 0x0
	// XC0 is ANDed with the selected clock.
	TC_CMR1_WAVE_EQ_1_BURST_XC0 = 0x1
	// XC1 is ANDed with the selected clock.
	TC_CMR1_WAVE_EQ_1_BURST_XC1 = 0x2
	// XC2 is ANDed with the selected clock.
	TC_CMR1_WAVE_EQ_1_BURST_XC2 = 0x3
	// Position of CPCSTOP field.
	TC_CMR1_WAVE_EQ_1_CPCSTOP_Pos = 0x6
	// Bit mask of CPCSTOP field.
	TC_CMR1_WAVE_EQ_1_CPCSTOP_Msk = 0x40
	// Bit CPCSTOP.
	TC_CMR1_WAVE_EQ_1_CPCSTOP = 0x40
	// Position of CPCDIS field.
	TC_CMR1_WAVE_EQ_1_CPCDIS_Pos = 0x7
	// Bit mask of CPCDIS field.
	TC_CMR1_WAVE_EQ_1_CPCDIS_Msk = 0x80
	// Bit CPCDIS.
	TC_CMR1_WAVE_EQ_1_CPCDIS = 0x80
	// Position of EEVTEDG field.
	TC_CMR1_WAVE_EQ_1_EEVTEDG_Pos = 0x8
	// Bit mask of EEVTEDG field.
	TC_CMR1_WAVE_EQ_1_EEVTEDG_Msk = 0x300
	// None
	TC_CMR1_WAVE_EQ_1_EEVTEDG_NONE = 0x0
	// Rising edge
	TC_CMR1_WAVE_EQ_1_EEVTEDG_RISING = 0x1
	// Falling edge
	TC_CMR1_WAVE_EQ_1_EEVTEDG_FALLING = 0x2
	// Each edge
	TC_CMR1_WAVE_EQ_1_EEVTEDG_EDGE = 0x3
	// Position of EEVT field.
	TC_CMR1_WAVE_EQ_1_EEVT_Pos = 0xa
	// Bit mask of EEVT field.
	TC_CMR1_WAVE_EQ_1_EEVT_Msk = 0xc00
	// TIOB
	TC_CMR1_WAVE_EQ_1_EEVT_TIOB = 0x0
	// XC0
	TC_CMR1_WAVE_EQ_1_EEVT_XC0 = 0x1
	// XC1
	TC_CMR1_WAVE_EQ_1_EEVT_XC1 = 0x2
	// XC2
	TC_CMR1_WAVE_EQ_1_EEVT_XC2 = 0x3
	// Position of ENETRG field.
	TC_CMR1_WAVE_EQ_1_ENETRG_Pos = 0xc
	// Bit mask of ENETRG field.
	TC_CMR1_WAVE_EQ_1_ENETRG_Msk = 0x1000
	// Bit ENETRG.
	TC_CMR1_WAVE_EQ_1_ENETRG = 0x1000
	// Position of WAVSEL field.
	TC_CMR1_WAVE_EQ_1_WAVSEL_Pos = 0xd
	// Bit mask of WAVSEL field.
	TC_CMR1_WAVE_EQ_1_WAVSEL_Msk = 0x6000
	// UP mode without automatic trigger on RC Compare
	TC_CMR1_WAVE_EQ_1_WAVSEL_UP = 0x0
	// UPDOWN mode without automatic trigger on RC Compare
	TC_CMR1_WAVE_EQ_1_WAVSEL_UPDOWN = 0x1
	// UP mode with automatic trigger on RC Compare
	TC_CMR1_WAVE_EQ_1_WAVSEL_UP_RC = 0x2
	// UPDOWN mode with automatic trigger on RC Compare
	TC_CMR1_WAVE_EQ_1_WAVSEL_UPDOWN_RC = 0x3
	// Position of WAVE field.
	TC_CMR1_WAVE_EQ_1_WAVE_Pos = 0xf
	// Bit mask of WAVE field.
	TC_CMR1_WAVE_EQ_1_WAVE_Msk = 0x8000
	// Bit WAVE.
	TC_CMR1_WAVE_EQ_1_WAVE = 0x8000
	// Position of ACPA field.
	TC_CMR1_WAVE_EQ_1_ACPA_Pos = 0x10
	// Bit mask of ACPA field.
	TC_CMR1_WAVE_EQ_1_ACPA_Msk = 0x30000
	// None
	TC_CMR1_WAVE_EQ_1_ACPA_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_ACPA_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_ACPA_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_ACPA_TOGGLE = 0x3
	// Position of ACPC field.
	TC_CMR1_WAVE_EQ_1_ACPC_Pos = 0x12
	// Bit mask of ACPC field.
	TC_CMR1_WAVE_EQ_1_ACPC_Msk = 0xc0000
	// None
	TC_CMR1_WAVE_EQ_1_ACPC_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_ACPC_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_ACPC_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_ACPC_TOGGLE = 0x3
	// Position of AEEVT field.
	TC_CMR1_WAVE_EQ_1_AEEVT_Pos = 0x14
	// Bit mask of AEEVT field.
	TC_CMR1_WAVE_EQ_1_AEEVT_Msk = 0x300000
	// None
	TC_CMR1_WAVE_EQ_1_AEEVT_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_AEEVT_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_AEEVT_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_AEEVT_TOGGLE = 0x3
	// Position of ASWTRG field.
	TC_CMR1_WAVE_EQ_1_ASWTRG_Pos = 0x16
	// Bit mask of ASWTRG field.
	TC_CMR1_WAVE_EQ_1_ASWTRG_Msk = 0xc00000
	// None
	TC_CMR1_WAVE_EQ_1_ASWTRG_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_ASWTRG_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_ASWTRG_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_ASWTRG_TOGGLE = 0x3
	// Position of BCPB field.
	TC_CMR1_WAVE_EQ_1_BCPB_Pos = 0x18
	// Bit mask of BCPB field.
	TC_CMR1_WAVE_EQ_1_BCPB_Msk = 0x3000000
	// None
	TC_CMR1_WAVE_EQ_1_BCPB_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_BCPB_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_BCPB_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_BCPB_TOGGLE = 0x3
	// Position of BCPC field.
	TC_CMR1_WAVE_EQ_1_BCPC_Pos = 0x1a
	// Bit mask of BCPC field.
	TC_CMR1_WAVE_EQ_1_BCPC_Msk = 0xc000000
	// None
	TC_CMR1_WAVE_EQ_1_BCPC_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_BCPC_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_BCPC_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_BCPC_TOGGLE = 0x3
	// Position of BEEVT field.
	TC_CMR1_WAVE_EQ_1_BEEVT_Pos = 0x1c
	// Bit mask of BEEVT field.
	TC_CMR1_WAVE_EQ_1_BEEVT_Msk = 0x30000000
	// None
	TC_CMR1_WAVE_EQ_1_BEEVT_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_BEEVT_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_BEEVT_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_BEEVT_TOGGLE = 0x3
	// Position of BSWTRG field.
	TC_CMR1_WAVE_EQ_1_BSWTRG_Pos = 0x1e
	// Bit mask of BSWTRG field.
	TC_CMR1_WAVE_EQ_1_BSWTRG_Msk = 0xc0000000
	// None
	TC_CMR1_WAVE_EQ_1_BSWTRG_NONE = 0x0
	// Set
	TC_CMR1_WAVE_EQ_1_BSWTRG_SET = 0x1
	// Clear
	TC_CMR1_WAVE_EQ_1_BSWTRG_CLEAR = 0x2
	// Toggle
	TC_CMR1_WAVE_EQ_1_BSWTRG_TOGGLE = 0x3

	// SMMR1: Stepper Motor Mode Register (channel = 1)
	// Position of GCEN field.
	TC_SMMR1_GCEN_Pos = 0x0
	// Bit mask of GCEN field.
	TC_SMMR1_GCEN_Msk = 0x1
	// Bit GCEN.
	TC_SMMR1_GCEN = 0x1
	// Position of DOWN field.
	TC_SMMR1_DOWN_Pos = 0x1
	// Bit mask of DOWN field.
	TC_SMMR1_DOWN_Msk = 0x2
	// Bit DOWN.
	TC_SMMR1_DOWN = 0x2

	// RAB1: Register AB (channel = 1)
	// Position of RAB field.
	TC_RAB1_RAB_Pos = 0x0
	// Bit mask of RAB field.
	TC_RAB1_RAB_Msk = 0xffffffff

	// CV1: Counter Value (channel = 1)
	// Position of CV field.
	TC_CV1_CV_Pos = 0x0
	// Bit mask of CV field.
	TC_CV1_CV_Msk = 0xffffffff

	// RA1: Register A (channel = 1)
	// Position of RA field.
	TC_RA1_RA_Pos = 0x0
	// Bit mask of RA field.
	TC_RA1_RA_Msk = 0xffffffff

	// RB1: Register B (channel = 1)
	// Position of RB field.
	TC_RB1_RB_Pos = 0x0
	// Bit mask of RB field.
	TC_RB1_RB_Msk = 0xffffffff

	// RC1: Register C (channel = 1)
	// Position of RC field.
	TC_RC1_RC_Pos = 0x0
	// Bit mask of RC field.
	TC_RC1_RC_Msk = 0xffffffff

	// SR1: Status Register (channel = 1)
	// Position of COVFS field.
	TC_SR1_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_SR1_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_SR1_COVFS = 0x1
	// Position of LOVRS field.
	TC_SR1_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_SR1_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_SR1_LOVRS = 0x2
	// Position of CPAS field.
	TC_SR1_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_SR1_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_SR1_CPAS = 0x4
	// Position of CPBS field.
	TC_SR1_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_SR1_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_SR1_CPBS = 0x8
	// Position of CPCS field.
	TC_SR1_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_SR1_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_SR1_CPCS = 0x10
	// Position of LDRAS field.
	TC_SR1_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_SR1_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_SR1_LDRAS = 0x20
	// Position of LDRBS field.
	TC_SR1_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_SR1_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_SR1_LDRBS = 0x40
	// Position of ETRGS field.
	TC_SR1_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_SR1_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_SR1_ETRGS = 0x80
	// Position of CLKSTA field.
	TC_SR1_CLKSTA_Pos = 0x10
	// Bit mask of CLKSTA field.
	TC_SR1_CLKSTA_Msk = 0x10000
	// Bit CLKSTA.
	TC_SR1_CLKSTA = 0x10000
	// Position of MTIOA field.
	TC_SR1_MTIOA_Pos = 0x11
	// Bit mask of MTIOA field.
	TC_SR1_MTIOA_Msk = 0x20000
	// Bit MTIOA.
	TC_SR1_MTIOA = 0x20000
	// Position of MTIOB field.
	TC_SR1_MTIOB_Pos = 0x12
	// Bit mask of MTIOB field.
	TC_SR1_MTIOB_Msk = 0x40000
	// Bit MTIOB.
	TC_SR1_MTIOB = 0x40000

	// IER1: Interrupt Enable Register (channel = 1)
	// Position of COVFS field.
	TC_IER1_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IER1_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IER1_COVFS = 0x1
	// Position of LOVRS field.
	TC_IER1_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IER1_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IER1_LOVRS = 0x2
	// Position of CPAS field.
	TC_IER1_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IER1_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IER1_CPAS = 0x4
	// Position of CPBS field.
	TC_IER1_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IER1_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IER1_CPBS = 0x8
	// Position of CPCS field.
	TC_IER1_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IER1_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IER1_CPCS = 0x10
	// Position of LDRAS field.
	TC_IER1_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IER1_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IER1_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IER1_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IER1_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IER1_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IER1_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IER1_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IER1_ETRGS = 0x80

	// IDR1: Interrupt Disable Register (channel = 1)
	// Position of COVFS field.
	TC_IDR1_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IDR1_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IDR1_COVFS = 0x1
	// Position of LOVRS field.
	TC_IDR1_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IDR1_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IDR1_LOVRS = 0x2
	// Position of CPAS field.
	TC_IDR1_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IDR1_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IDR1_CPAS = 0x4
	// Position of CPBS field.
	TC_IDR1_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IDR1_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IDR1_CPBS = 0x8
	// Position of CPCS field.
	TC_IDR1_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IDR1_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IDR1_CPCS = 0x10
	// Position of LDRAS field.
	TC_IDR1_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IDR1_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IDR1_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IDR1_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IDR1_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IDR1_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IDR1_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IDR1_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IDR1_ETRGS = 0x80

	// IMR1: Interrupt Mask Register (channel = 1)
	// Position of COVFS field.
	TC_IMR1_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IMR1_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IMR1_COVFS = 0x1
	// Position of LOVRS field.
	TC_IMR1_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IMR1_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IMR1_LOVRS = 0x2
	// Position of CPAS field.
	TC_IMR1_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IMR1_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IMR1_CPAS = 0x4
	// Position of CPBS field.
	TC_IMR1_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IMR1_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IMR1_CPBS = 0x8
	// Position of CPCS field.
	TC_IMR1_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IMR1_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IMR1_CPCS = 0x10
	// Position of LDRAS field.
	TC_IMR1_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IMR1_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IMR1_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IMR1_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IMR1_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IMR1_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IMR1_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IMR1_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IMR1_ETRGS = 0x80

	// CCR2: Channel Control Register (channel = 2)
	// Position of CLKEN field.
	TC_CCR2_CLKEN_Pos = 0x0
	// Bit mask of CLKEN field.
	TC_CCR2_CLKEN_Msk = 0x1
	// Bit CLKEN.
	TC_CCR2_CLKEN = 0x1
	// Position of CLKDIS field.
	TC_CCR2_CLKDIS_Pos = 0x1
	// Bit mask of CLKDIS field.
	TC_CCR2_CLKDIS_Msk = 0x2
	// Bit CLKDIS.
	TC_CCR2_CLKDIS = 0x2
	// Position of SWTRG field.
	TC_CCR2_SWTRG_Pos = 0x2
	// Bit mask of SWTRG field.
	TC_CCR2_SWTRG_Msk = 0x4
	// Bit SWTRG.
	TC_CCR2_SWTRG = 0x4

	// CMR2: Channel Mode Register (channel = 2)
	// Position of TCCLKS field.
	TC_CMR2_TCCLKS_Pos = 0x0
	// Bit mask of TCCLKS field.
	TC_CMR2_TCCLKS_Msk = 0x7
	// Clock selected: TCLK1
	TC_CMR2_TCCLKS_TIMER_CLOCK1 = 0x0
	// Clock selected: TCLK2
	TC_CMR2_TCCLKS_TIMER_CLOCK2 = 0x1
	// Clock selected: TCLK3
	TC_CMR2_TCCLKS_TIMER_CLOCK3 = 0x2
	// Clock selected: TCLK4
	TC_CMR2_TCCLKS_TIMER_CLOCK4 = 0x3
	// Clock selected: TCLK5
	TC_CMR2_TCCLKS_TIMER_CLOCK5 = 0x4
	// Clock selected: XC0
	TC_CMR2_TCCLKS_XC0 = 0x5
	// Clock selected: XC1
	TC_CMR2_TCCLKS_XC1 = 0x6
	// Clock selected: XC2
	TC_CMR2_TCCLKS_XC2 = 0x7
	// Position of CLKI field.
	TC_CMR2_CLKI_Pos = 0x3
	// Bit mask of CLKI field.
	TC_CMR2_CLKI_Msk = 0x8
	// Bit CLKI.
	TC_CMR2_CLKI = 0x8
	// Position of BURST field.
	TC_CMR2_BURST_Pos = 0x4
	// Bit mask of BURST field.
	TC_CMR2_BURST_Msk = 0x30
	// The clock is not gated by an external signal.
	TC_CMR2_BURST_NONE = 0x0
	// XC0 is ANDed with the selected clock.
	TC_CMR2_BURST_XC0 = 0x1
	// XC1 is ANDed with the selected clock.
	TC_CMR2_BURST_XC1 = 0x2
	// XC2 is ANDed with the selected clock.
	TC_CMR2_BURST_XC2 = 0x3
	// Position of LDBSTOP field.
	TC_CMR2_LDBSTOP_Pos = 0x6
	// Bit mask of LDBSTOP field.
	TC_CMR2_LDBSTOP_Msk = 0x40
	// Bit LDBSTOP.
	TC_CMR2_LDBSTOP = 0x40
	// Position of LDBDIS field.
	TC_CMR2_LDBDIS_Pos = 0x7
	// Bit mask of LDBDIS field.
	TC_CMR2_LDBDIS_Msk = 0x80
	// Bit LDBDIS.
	TC_CMR2_LDBDIS = 0x80
	// Position of ETRGEDG field.
	TC_CMR2_ETRGEDG_Pos = 0x8
	// Bit mask of ETRGEDG field.
	TC_CMR2_ETRGEDG_Msk = 0x300
	// The clock is not gated by an external signal.
	TC_CMR2_ETRGEDG_NONE = 0x0
	// Rising edge
	TC_CMR2_ETRGEDG_RISING = 0x1
	// Falling edge
	TC_CMR2_ETRGEDG_FALLING = 0x2
	// Each edge
	TC_CMR2_ETRGEDG_EDGE = 0x3
	// Position of ABETRG field.
	TC_CMR2_ABETRG_Pos = 0xa
	// Bit mask of ABETRG field.
	TC_CMR2_ABETRG_Msk = 0x400
	// Bit ABETRG.
	TC_CMR2_ABETRG = 0x400
	// Position of CPCTRG field.
	TC_CMR2_CPCTRG_Pos = 0xe
	// Bit mask of CPCTRG field.
	TC_CMR2_CPCTRG_Msk = 0x4000
	// Bit CPCTRG.
	TC_CMR2_CPCTRG = 0x4000
	// Position of WAVE field.
	TC_CMR2_WAVE_Pos = 0xf
	// Bit mask of WAVE field.
	TC_CMR2_WAVE_Msk = 0x8000
	// Bit WAVE.
	TC_CMR2_WAVE = 0x8000
	// Position of LDRA field.
	TC_CMR2_LDRA_Pos = 0x10
	// Bit mask of LDRA field.
	TC_CMR2_LDRA_Msk = 0x30000
	// None
	TC_CMR2_LDRA_NONE = 0x0
	// Rising edge of TIOA
	TC_CMR2_LDRA_RISING = 0x1
	// Falling edge of TIOA
	TC_CMR2_LDRA_FALLING = 0x2
	// Each edge of TIOA
	TC_CMR2_LDRA_EDGE = 0x3
	// Position of LDRB field.
	TC_CMR2_LDRB_Pos = 0x12
	// Bit mask of LDRB field.
	TC_CMR2_LDRB_Msk = 0xc0000
	// None
	TC_CMR2_LDRB_NONE = 0x0
	// Rising edge of TIOA
	TC_CMR2_LDRB_RISING = 0x1
	// Falling edge of TIOA
	TC_CMR2_LDRB_FALLING = 0x2
	// Each edge of TIOA
	TC_CMR2_LDRB_EDGE = 0x3

	// CMR2_WAVE_EQ_1: Channel Mode Register (channel = 2)
	// Position of TCCLKS field.
	TC_CMR2_WAVE_EQ_1_TCCLKS_Pos = 0x0
	// Bit mask of TCCLKS field.
	TC_CMR2_WAVE_EQ_1_TCCLKS_Msk = 0x7
	// Clock selected: TCLK1
	TC_CMR2_WAVE_EQ_1_TCCLKS_TIMER_CLOCK1 = 0x0
	// Clock selected: TCLK2
	TC_CMR2_WAVE_EQ_1_TCCLKS_TIMER_CLOCK2 = 0x1
	// Clock selected: TCLK3
	TC_CMR2_WAVE_EQ_1_TCCLKS_TIMER_CLOCK3 = 0x2
	// Clock selected: TCLK4
	TC_CMR2_WAVE_EQ_1_TCCLKS_TIMER_CLOCK4 = 0x3
	// Clock selected: TCLK5
	TC_CMR2_WAVE_EQ_1_TCCLKS_TIMER_CLOCK5 = 0x4
	// Clock selected: XC0
	TC_CMR2_WAVE_EQ_1_TCCLKS_XC0 = 0x5
	// Clock selected: XC1
	TC_CMR2_WAVE_EQ_1_TCCLKS_XC1 = 0x6
	// Clock selected: XC2
	TC_CMR2_WAVE_EQ_1_TCCLKS_XC2 = 0x7
	// Position of CLKI field.
	TC_CMR2_WAVE_EQ_1_CLKI_Pos = 0x3
	// Bit mask of CLKI field.
	TC_CMR2_WAVE_EQ_1_CLKI_Msk = 0x8
	// Bit CLKI.
	TC_CMR2_WAVE_EQ_1_CLKI = 0x8
	// Position of BURST field.
	TC_CMR2_WAVE_EQ_1_BURST_Pos = 0x4
	// Bit mask of BURST field.
	TC_CMR2_WAVE_EQ_1_BURST_Msk = 0x30
	// The clock is not gated by an external signal.
	TC_CMR2_WAVE_EQ_1_BURST_NONE = 0x0
	// XC0 is ANDed with the selected clock.
	TC_CMR2_WAVE_EQ_1_BURST_XC0 = 0x1
	// XC1 is ANDed with the selected clock.
	TC_CMR2_WAVE_EQ_1_BURST_XC1 = 0x2
	// XC2 is ANDed with the selected clock.
	TC_CMR2_WAVE_EQ_1_BURST_XC2 = 0x3
	// Position of CPCSTOP field.
	TC_CMR2_WAVE_EQ_1_CPCSTOP_Pos = 0x6
	// Bit mask of CPCSTOP field.
	TC_CMR2_WAVE_EQ_1_CPCSTOP_Msk = 0x40
	// Bit CPCSTOP.
	TC_CMR2_WAVE_EQ_1_CPCSTOP = 0x40
	// Position of CPCDIS field.
	TC_CMR2_WAVE_EQ_1_CPCDIS_Pos = 0x7
	// Bit mask of CPCDIS field.
	TC_CMR2_WAVE_EQ_1_CPCDIS_Msk = 0x80
	// Bit CPCDIS.
	TC_CMR2_WAVE_EQ_1_CPCDIS = 0x80
	// Position of EEVTEDG field.
	TC_CMR2_WAVE_EQ_1_EEVTEDG_Pos = 0x8
	// Bit mask of EEVTEDG field.
	TC_CMR2_WAVE_EQ_1_EEVTEDG_Msk = 0x300
	// None
	TC_CMR2_WAVE_EQ_1_EEVTEDG_NONE = 0x0
	// Rising edge
	TC_CMR2_WAVE_EQ_1_EEVTEDG_RISING = 0x1
	// Falling edge
	TC_CMR2_WAVE_EQ_1_EEVTEDG_FALLING = 0x2
	// Each edge
	TC_CMR2_WAVE_EQ_1_EEVTEDG_EDGE = 0x3
	// Position of EEVT field.
	TC_CMR2_WAVE_EQ_1_EEVT_Pos = 0xa
	// Bit mask of EEVT field.
	TC_CMR2_WAVE_EQ_1_EEVT_Msk = 0xc00
	// TIOB
	TC_CMR2_WAVE_EQ_1_EEVT_TIOB = 0x0
	// XC0
	TC_CMR2_WAVE_EQ_1_EEVT_XC0 = 0x1
	// XC1
	TC_CMR2_WAVE_EQ_1_EEVT_XC1 = 0x2
	// XC2
	TC_CMR2_WAVE_EQ_1_EEVT_XC2 = 0x3
	// Position of ENETRG field.
	TC_CMR2_WAVE_EQ_1_ENETRG_Pos = 0xc
	// Bit mask of ENETRG field.
	TC_CMR2_WAVE_EQ_1_ENETRG_Msk = 0x1000
	// Bit ENETRG.
	TC_CMR2_WAVE_EQ_1_ENETRG = 0x1000
	// Position of WAVSEL field.
	TC_CMR2_WAVE_EQ_1_WAVSEL_Pos = 0xd
	// Bit mask of WAVSEL field.
	TC_CMR2_WAVE_EQ_1_WAVSEL_Msk = 0x6000
	// UP mode without automatic trigger on RC Compare
	TC_CMR2_WAVE_EQ_1_WAVSEL_UP = 0x0
	// UPDOWN mode without automatic trigger on RC Compare
	TC_CMR2_WAVE_EQ_1_WAVSEL_UPDOWN = 0x1
	// UP mode with automatic trigger on RC Compare
	TC_CMR2_WAVE_EQ_1_WAVSEL_UP_RC = 0x2
	// UPDOWN mode with automatic trigger on RC Compare
	TC_CMR2_WAVE_EQ_1_WAVSEL_UPDOWN_RC = 0x3
	// Position of WAVE field.
	TC_CMR2_WAVE_EQ_1_WAVE_Pos = 0xf
	// Bit mask of WAVE field.
	TC_CMR2_WAVE_EQ_1_WAVE_Msk = 0x8000
	// Bit WAVE.
	TC_CMR2_WAVE_EQ_1_WAVE = 0x8000
	// Position of ACPA field.
	TC_CMR2_WAVE_EQ_1_ACPA_Pos = 0x10
	// Bit mask of ACPA field.
	TC_CMR2_WAVE_EQ_1_ACPA_Msk = 0x30000
	// None
	TC_CMR2_WAVE_EQ_1_ACPA_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_ACPA_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_ACPA_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_ACPA_TOGGLE = 0x3
	// Position of ACPC field.
	TC_CMR2_WAVE_EQ_1_ACPC_Pos = 0x12
	// Bit mask of ACPC field.
	TC_CMR2_WAVE_EQ_1_ACPC_Msk = 0xc0000
	// None
	TC_CMR2_WAVE_EQ_1_ACPC_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_ACPC_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_ACPC_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_ACPC_TOGGLE = 0x3
	// Position of AEEVT field.
	TC_CMR2_WAVE_EQ_1_AEEVT_Pos = 0x14
	// Bit mask of AEEVT field.
	TC_CMR2_WAVE_EQ_1_AEEVT_Msk = 0x300000
	// None
	TC_CMR2_WAVE_EQ_1_AEEVT_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_AEEVT_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_AEEVT_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_AEEVT_TOGGLE = 0x3
	// Position of ASWTRG field.
	TC_CMR2_WAVE_EQ_1_ASWTRG_Pos = 0x16
	// Bit mask of ASWTRG field.
	TC_CMR2_WAVE_EQ_1_ASWTRG_Msk = 0xc00000
	// None
	TC_CMR2_WAVE_EQ_1_ASWTRG_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_ASWTRG_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_ASWTRG_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_ASWTRG_TOGGLE = 0x3
	// Position of BCPB field.
	TC_CMR2_WAVE_EQ_1_BCPB_Pos = 0x18
	// Bit mask of BCPB field.
	TC_CMR2_WAVE_EQ_1_BCPB_Msk = 0x3000000
	// None
	TC_CMR2_WAVE_EQ_1_BCPB_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_BCPB_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_BCPB_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_BCPB_TOGGLE = 0x3
	// Position of BCPC field.
	TC_CMR2_WAVE_EQ_1_BCPC_Pos = 0x1a
	// Bit mask of BCPC field.
	TC_CMR2_WAVE_EQ_1_BCPC_Msk = 0xc000000
	// None
	TC_CMR2_WAVE_EQ_1_BCPC_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_BCPC_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_BCPC_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_BCPC_TOGGLE = 0x3
	// Position of BEEVT field.
	TC_CMR2_WAVE_EQ_1_BEEVT_Pos = 0x1c
	// Bit mask of BEEVT field.
	TC_CMR2_WAVE_EQ_1_BEEVT_Msk = 0x30000000
	// None
	TC_CMR2_WAVE_EQ_1_BEEVT_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_BEEVT_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_BEEVT_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_BEEVT_TOGGLE = 0x3
	// Position of BSWTRG field.
	TC_CMR2_WAVE_EQ_1_BSWTRG_Pos = 0x1e
	// Bit mask of BSWTRG field.
	TC_CMR2_WAVE_EQ_1_BSWTRG_Msk = 0xc0000000
	// None
	TC_CMR2_WAVE_EQ_1_BSWTRG_NONE = 0x0
	// Set
	TC_CMR2_WAVE_EQ_1_BSWTRG_SET = 0x1
	// Clear
	TC_CMR2_WAVE_EQ_1_BSWTRG_CLEAR = 0x2
	// Toggle
	TC_CMR2_WAVE_EQ_1_BSWTRG_TOGGLE = 0x3

	// SMMR2: Stepper Motor Mode Register (channel = 2)
	// Position of GCEN field.
	TC_SMMR2_GCEN_Pos = 0x0
	// Bit mask of GCEN field.
	TC_SMMR2_GCEN_Msk = 0x1
	// Bit GCEN.
	TC_SMMR2_GCEN = 0x1
	// Position of DOWN field.
	TC_SMMR2_DOWN_Pos = 0x1
	// Bit mask of DOWN field.
	TC_SMMR2_DOWN_Msk = 0x2
	// Bit DOWN.
	TC_SMMR2_DOWN = 0x2

	// RAB2: Register AB (channel = 2)
	// Position of RAB field.
	TC_RAB2_RAB_Pos = 0x0
	// Bit mask of RAB field.
	TC_RAB2_RAB_Msk = 0xffffffff

	// CV2: Counter Value (channel = 2)
	// Position of CV field.
	TC_CV2_CV_Pos = 0x0
	// Bit mask of CV field.
	TC_CV2_CV_Msk = 0xffffffff

	// RA2: Register A (channel = 2)
	// Position of RA field.
	TC_RA2_RA_Pos = 0x0
	// Bit mask of RA field.
	TC_RA2_RA_Msk = 0xffffffff

	// RB2: Register B (channel = 2)
	// Position of RB field.
	TC_RB2_RB_Pos = 0x0
	// Bit mask of RB field.
	TC_RB2_RB_Msk = 0xffffffff

	// RC2: Register C (channel = 2)
	// Position of RC field.
	TC_RC2_RC_Pos = 0x0
	// Bit mask of RC field.
	TC_RC2_RC_Msk = 0xffffffff

	// SR2: Status Register (channel = 2)
	// Position of COVFS field.
	TC_SR2_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_SR2_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_SR2_COVFS = 0x1
	// Position of LOVRS field.
	TC_SR2_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_SR2_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_SR2_LOVRS = 0x2
	// Position of CPAS field.
	TC_SR2_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_SR2_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_SR2_CPAS = 0x4
	// Position of CPBS field.
	TC_SR2_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_SR2_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_SR2_CPBS = 0x8
	// Position of CPCS field.
	TC_SR2_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_SR2_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_SR2_CPCS = 0x10
	// Position of LDRAS field.
	TC_SR2_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_SR2_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_SR2_LDRAS = 0x20
	// Position of LDRBS field.
	TC_SR2_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_SR2_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_SR2_LDRBS = 0x40
	// Position of ETRGS field.
	TC_SR2_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_SR2_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_SR2_ETRGS = 0x80
	// Position of CLKSTA field.
	TC_SR2_CLKSTA_Pos = 0x10
	// Bit mask of CLKSTA field.
	TC_SR2_CLKSTA_Msk = 0x10000
	// Bit CLKSTA.
	TC_SR2_CLKSTA = 0x10000
	// Position of MTIOA field.
	TC_SR2_MTIOA_Pos = 0x11
	// Bit mask of MTIOA field.
	TC_SR2_MTIOA_Msk = 0x20000
	// Bit MTIOA.
	TC_SR2_MTIOA = 0x20000
	// Position of MTIOB field.
	TC_SR2_MTIOB_Pos = 0x12
	// Bit mask of MTIOB field.
	TC_SR2_MTIOB_Msk = 0x40000
	// Bit MTIOB.
	TC_SR2_MTIOB = 0x40000

	// IER2: Interrupt Enable Register (channel = 2)
	// Position of COVFS field.
	TC_IER2_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IER2_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IER2_COVFS = 0x1
	// Position of LOVRS field.
	TC_IER2_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IER2_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IER2_LOVRS = 0x2
	// Position of CPAS field.
	TC_IER2_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IER2_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IER2_CPAS = 0x4
	// Position of CPBS field.
	TC_IER2_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IER2_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IER2_CPBS = 0x8
	// Position of CPCS field.
	TC_IER2_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IER2_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IER2_CPCS = 0x10
	// Position of LDRAS field.
	TC_IER2_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IER2_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IER2_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IER2_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IER2_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IER2_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IER2_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IER2_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IER2_ETRGS = 0x80

	// IDR2: Interrupt Disable Register (channel = 2)
	// Position of COVFS field.
	TC_IDR2_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IDR2_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IDR2_COVFS = 0x1
	// Position of LOVRS field.
	TC_IDR2_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IDR2_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IDR2_LOVRS = 0x2
	// Position of CPAS field.
	TC_IDR2_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IDR2_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IDR2_CPAS = 0x4
	// Position of CPBS field.
	TC_IDR2_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IDR2_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IDR2_CPBS = 0x8
	// Position of CPCS field.
	TC_IDR2_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IDR2_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IDR2_CPCS = 0x10
	// Position of LDRAS field.
	TC_IDR2_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IDR2_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IDR2_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IDR2_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IDR2_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IDR2_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IDR2_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IDR2_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IDR2_ETRGS = 0x80

	// IMR2: Interrupt Mask Register (channel = 2)
	// Position of COVFS field.
	TC_IMR2_COVFS_Pos = 0x0
	// Bit mask of COVFS field.
	TC_IMR2_COVFS_Msk = 0x1
	// Bit COVFS.
	TC_IMR2_COVFS = 0x1
	// Position of LOVRS field.
	TC_IMR2_LOVRS_Pos = 0x1
	// Bit mask of LOVRS field.
	TC_IMR2_LOVRS_Msk = 0x2
	// Bit LOVRS.
	TC_IMR2_LOVRS = 0x2
	// Position of CPAS field.
	TC_IMR2_CPAS_Pos = 0x2
	// Bit mask of CPAS field.
	TC_IMR2_CPAS_Msk = 0x4
	// Bit CPAS.
	TC_IMR2_CPAS = 0x4
	// Position of CPBS field.
	TC_IMR2_CPBS_Pos = 0x3
	// Bit mask of CPBS field.
	TC_IMR2_CPBS_Msk = 0x8
	// Bit CPBS.
	TC_IMR2_CPBS = 0x8
	// Position of CPCS field.
	TC_IMR2_CPCS_Pos = 0x4
	// Bit mask of CPCS field.
	TC_IMR2_CPCS_Msk = 0x10
	// Bit CPCS.
	TC_IMR2_CPCS = 0x10
	// Position of LDRAS field.
	TC_IMR2_LDRAS_Pos = 0x5
	// Bit mask of LDRAS field.
	TC_IMR2_LDRAS_Msk = 0x20
	// Bit LDRAS.
	TC_IMR2_LDRAS = 0x20
	// Position of LDRBS field.
	TC_IMR2_LDRBS_Pos = 0x6
	// Bit mask of LDRBS field.
	TC_IMR2_LDRBS_Msk = 0x40
	// Bit LDRBS.
	TC_IMR2_LDRBS = 0x40
	// Position of ETRGS field.
	TC_IMR2_ETRGS_Pos = 0x7
	// Bit mask of ETRGS field.
	TC_IMR2_ETRGS_Msk = 0x80
	// Bit ETRGS.
	TC_IMR2_ETRGS = 0x80

	// BCR: Block Control Register
	// Position of SYNC field.
	TC_BCR_SYNC_Pos = 0x0
	// Bit mask of SYNC field.
	TC_BCR_SYNC_Msk = 0x1
	// Bit SYNC.
	TC_BCR_SYNC = 0x1

	// BMR: Block Mode Register
	// Position of TC0XC0S field.
	TC_BMR_TC0XC0S_Pos = 0x0
	// Bit mask of TC0XC0S field.
	TC_BMR_TC0XC0S_Msk = 0x3
	// Signal connected to XC0: TCLK0
	TC_BMR_TC0XC0S_TCLK0 = 0x0
	// Signal connected to XC0: TIOA1
	TC_BMR_TC0XC0S_TIOA1 = 0x2
	// Signal connected to XC0: TIOA2
	TC_BMR_TC0XC0S_TIOA2 = 0x3
	// Position of TC1XC1S field.
	TC_BMR_TC1XC1S_Pos = 0x2
	// Bit mask of TC1XC1S field.
	TC_BMR_TC1XC1S_Msk = 0xc
	// Signal connected to XC1: TCLK1
	TC_BMR_TC1XC1S_TCLK1 = 0x0
	// Signal connected to XC1: TIOA0
	TC_BMR_TC1XC1S_TIOA0 = 0x2
	// Signal connected to XC1: TIOA2
	TC_BMR_TC1XC1S_TIOA2 = 0x3
	// Position of TC2XC2S field.
	TC_BMR_TC2XC2S_Pos = 0x4
	// Bit mask of TC2XC2S field.
	TC_BMR_TC2XC2S_Msk = 0x30
	// Signal connected to XC2: TCLK2
	TC_BMR_TC2XC2S_TCLK2 = 0x0
	// Signal connected to XC2: TIOA1
	TC_BMR_TC2XC2S_TIOA1 = 0x2
	// Signal connected to XC2: TIOA2
	TC_BMR_TC2XC2S_TIOA2 = 0x3
	// Position of QDEN field.
	TC_BMR_QDEN_Pos = 0x8
	// Bit mask of QDEN field.
	TC_BMR_QDEN_Msk = 0x100
	// Bit QDEN.
	TC_BMR_QDEN = 0x100
	// Position of POSEN field.
	TC_BMR_POSEN_Pos = 0x9
	// Bit mask of POSEN field.
	TC_BMR_POSEN_Msk = 0x200
	// Bit POSEN.
	TC_BMR_POSEN = 0x200
	// Position of SPEEDEN field.
	TC_BMR_SPEEDEN_Pos = 0xa
	// Bit mask of SPEEDEN field.
	TC_BMR_SPEEDEN_Msk = 0x400
	// Bit SPEEDEN.
	TC_BMR_SPEEDEN = 0x400
	// Position of QDTRANS field.
	TC_BMR_QDTRANS_Pos = 0xb
	// Bit mask of QDTRANS field.
	TC_BMR_QDTRANS_Msk = 0x800
	// Bit QDTRANS.
	TC_BMR_QDTRANS = 0x800
	// Position of EDGPHA field.
	TC_BMR_EDGPHA_Pos = 0xc
	// Bit mask of EDGPHA field.
	TC_BMR_EDGPHA_Msk = 0x1000
	// Bit EDGPHA.
	TC_BMR_EDGPHA = 0x1000
	// Position of INVA field.
	TC_BMR_INVA_Pos = 0xd
	// Bit mask of INVA field.
	TC_BMR_INVA_Msk = 0x2000
	// Bit INVA.
	TC_BMR_INVA = 0x2000
	// Position of INVB field.
	TC_BMR_INVB_Pos = 0xe
	// Bit mask of INVB field.
	TC_BMR_INVB_Msk = 0x4000
	// Bit INVB.
	TC_BMR_INVB = 0x4000
	// Position of INVIDX field.
	TC_BMR_INVIDX_Pos = 0xf
	// Bit mask of INVIDX field.
	TC_BMR_INVIDX_Msk = 0x8000
	// Bit INVIDX.
	TC_BMR_INVIDX = 0x8000
	// Position of SWAP field.
	TC_BMR_SWAP_Pos = 0x10
	// Bit mask of SWAP field.
	TC_BMR_SWAP_Msk = 0x10000
	// Bit SWAP.
	TC_BMR_SWAP = 0x10000
	// Position of IDXPHB field.
	TC_BMR_IDXPHB_Pos = 0x11
	// Bit mask of IDXPHB field.
	TC_BMR_IDXPHB_Msk = 0x20000
	// Bit IDXPHB.
	TC_BMR_IDXPHB = 0x20000
	// Position of FILTER field.
	TC_BMR_FILTER_Pos = 0x13
	// Bit mask of FILTER field.
	TC_BMR_FILTER_Msk = 0x80000
	// Bit FILTER.
	TC_BMR_FILTER = 0x80000
	// Position of MAXFILT field.
	TC_BMR_MAXFILT_Pos = 0x14
	// Bit mask of MAXFILT field.
	TC_BMR_MAXFILT_Msk = 0x3f00000

	// QIER: QDEC Interrupt Enable Register
	// Position of IDX field.
	TC_QIER_IDX_Pos = 0x0
	// Bit mask of IDX field.
	TC_QIER_IDX_Msk = 0x1
	// Bit IDX.
	TC_QIER_IDX = 0x1
	// Position of DIRCHG field.
	TC_QIER_DIRCHG_Pos = 0x1
	// Bit mask of DIRCHG field.
	TC_QIER_DIRCHG_Msk = 0x2
	// Bit DIRCHG.
	TC_QIER_DIRCHG = 0x2
	// Position of QERR field.
	TC_QIER_QERR_Pos = 0x2
	// Bit mask of QERR field.
	TC_QIER_QERR_Msk = 0x4
	// Bit QERR.
	TC_QIER_QERR = 0x4

	// QIDR: QDEC Interrupt Disable Register
	// Position of IDX field.
	TC_QIDR_IDX_Pos = 0x0
	// Bit mask of IDX field.
	TC_QIDR_IDX_Msk = 0x1
	// Bit IDX.
	TC_QIDR_IDX = 0x1
	// Position of DIRCHG field.
	TC_QIDR_DIRCHG_Pos = 0x1
	// Bit mask of DIRCHG field.
	TC_QIDR_DIRCHG_Msk = 0x2
	// Bit DIRCHG.
	TC_QIDR_DIRCHG = 0x2
	// Position of QERR field.
	TC_QIDR_QERR_Pos = 0x2
	// Bit mask of QERR field.
	TC_QIDR_QERR_Msk = 0x4
	// Bit QERR.
	TC_QIDR_QERR = 0x4

	// QIMR: QDEC Interrupt Mask Register
	// Position of IDX field.
	TC_QIMR_IDX_Pos = 0x0
	// Bit mask of IDX field.
	TC_QIMR_IDX_Msk = 0x1
	// Bit IDX.
	TC_QIMR_IDX = 0x1
	// Position of DIRCHG field.
	TC_QIMR_DIRCHG_Pos = 0x1
	// Bit mask of DIRCHG field.
	TC_QIMR_DIRCHG_Msk = 0x2
	// Bit DIRCHG.
	TC_QIMR_DIRCHG = 0x2
	// Position of QERR field.
	TC_QIMR_QERR_Pos = 0x2
	// Bit mask of QERR field.
	TC_QIMR_QERR_Msk = 0x4
	// Bit QERR.
	TC_QIMR_QERR = 0x4

	// QISR: QDEC Interrupt Status Register
	// Position of IDX field.
	TC_QISR_IDX_Pos = 0x0
	// Bit mask of IDX field.
	TC_QISR_IDX_Msk = 0x1
	// Bit IDX.
	TC_QISR_IDX = 0x1
	// Position of DIRCHG field.
	TC_QISR_DIRCHG_Pos = 0x1
	// Bit mask of DIRCHG field.
	TC_QISR_DIRCHG_Msk = 0x2
	// Bit DIRCHG.
	TC_QISR_DIRCHG = 0x2
	// Position of QERR field.
	TC_QISR_QERR_Pos = 0x2
	// Bit mask of QERR field.
	TC_QISR_QERR_Msk = 0x4
	// Bit QERR.
	TC_QISR_QERR = 0x4
	// Position of DIR field.
	TC_QISR_DIR_Pos = 0x8
	// Bit mask of DIR field.
	TC_QISR_DIR_Msk = 0x100
	// Bit DIR.
	TC_QISR_DIR = 0x100

	// WPMR: Write Protect Mode Register
	// Position of WPEN field.
	TC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	TC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	TC_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	TC_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	TC_WPMR_WPKEY_Msk = 0xffffff00
)

// Constants for TWI0: Two-wire Interface 0
const (
	// CR: Control Register
	// Position of START field.
	TWI_CR_START_Pos = 0x0
	// Bit mask of START field.
	TWI_CR_START_Msk = 0x1
	// Bit START.
	TWI_CR_START = 0x1
	// Position of STOP field.
	TWI_CR_STOP_Pos = 0x1
	// Bit mask of STOP field.
	TWI_CR_STOP_Msk = 0x2
	// Bit STOP.
	TWI_CR_STOP = 0x2
	// Position of MSEN field.
	TWI_CR_MSEN_Pos = 0x2
	// Bit mask of MSEN field.
	TWI_CR_MSEN_Msk = 0x4
	// Bit MSEN.
	TWI_CR_MSEN = 0x4
	// Position of MSDIS field.
	TWI_CR_MSDIS_Pos = 0x3
	// Bit mask of MSDIS field.
	TWI_CR_MSDIS_Msk = 0x8
	// Bit MSDIS.
	TWI_CR_MSDIS = 0x8
	// Position of SVEN field.
	TWI_CR_SVEN_Pos = 0x4
	// Bit mask of SVEN field.
	TWI_CR_SVEN_Msk = 0x10
	// Bit SVEN.
	TWI_CR_SVEN = 0x10
	// Position of SVDIS field.
	TWI_CR_SVDIS_Pos = 0x5
	// Bit mask of SVDIS field.
	TWI_CR_SVDIS_Msk = 0x20
	// Bit SVDIS.
	TWI_CR_SVDIS = 0x20
	// Position of QUICK field.
	TWI_CR_QUICK_Pos = 0x6
	// Bit mask of QUICK field.
	TWI_CR_QUICK_Msk = 0x40
	// Bit QUICK.
	TWI_CR_QUICK = 0x40
	// Position of SWRST field.
	TWI_CR_SWRST_Pos = 0x7
	// Bit mask of SWRST field.
	TWI_CR_SWRST_Msk = 0x80
	// Bit SWRST.
	TWI_CR_SWRST = 0x80

	// MMR: Master Mode Register
	// Position of IADRSZ field.
	TWI_MMR_IADRSZ_Pos = 0x8
	// Bit mask of IADRSZ field.
	TWI_MMR_IADRSZ_Msk = 0x300
	// No internal device address
	TWI_MMR_IADRSZ_NONE = 0x0
	// One-byte internal device address
	TWI_MMR_IADRSZ_1_BYTE = 0x1
	// Two-byte internal device address
	TWI_MMR_IADRSZ_2_BYTE = 0x2
	// Three-byte internal device address
	TWI_MMR_IADRSZ_3_BYTE = 0x3
	// Position of MREAD field.
	TWI_MMR_MREAD_Pos = 0xc
	// Bit mask of MREAD field.
	TWI_MMR_MREAD_Msk = 0x1000
	// Bit MREAD.
	TWI_MMR_MREAD = 0x1000
	// Position of DADR field.
	TWI_MMR_DADR_Pos = 0x10
	// Bit mask of DADR field.
	TWI_MMR_DADR_Msk = 0x7f0000

	// SMR: Slave Mode Register
	// Position of SADR field.
	TWI_SMR_SADR_Pos = 0x10
	// Bit mask of SADR field.
	TWI_SMR_SADR_Msk = 0x7f0000

	// IADR: Internal Address Register
	// Position of IADR field.
	TWI_IADR_IADR_Pos = 0x0
	// Bit mask of IADR field.
	TWI_IADR_IADR_Msk = 0xffffff

	// CWGR: Clock Waveform Generator Register
	// Position of CLDIV field.
	TWI_CWGR_CLDIV_Pos = 0x0
	// Bit mask of CLDIV field.
	TWI_CWGR_CLDIV_Msk = 0xff
	// Position of CHDIV field.
	TWI_CWGR_CHDIV_Pos = 0x8
	// Bit mask of CHDIV field.
	TWI_CWGR_CHDIV_Msk = 0xff00
	// Position of CKDIV field.
	TWI_CWGR_CKDIV_Pos = 0x10
	// Bit mask of CKDIV field.
	TWI_CWGR_CKDIV_Msk = 0x70000

	// SR: Status Register
	// Position of TXCOMP field.
	TWI_SR_TXCOMP_Pos = 0x0
	// Bit mask of TXCOMP field.
	TWI_SR_TXCOMP_Msk = 0x1
	// Bit TXCOMP.
	TWI_SR_TXCOMP = 0x1
	// Position of RXRDY field.
	TWI_SR_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	TWI_SR_RXRDY_Msk = 0x2
	// Bit RXRDY.
	TWI_SR_RXRDY = 0x2
	// Position of TXRDY field.
	TWI_SR_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	TWI_SR_TXRDY_Msk = 0x4
	// Bit TXRDY.
	TWI_SR_TXRDY = 0x4
	// Position of SVREAD field.
	TWI_SR_SVREAD_Pos = 0x3
	// Bit mask of SVREAD field.
	TWI_SR_SVREAD_Msk = 0x8
	// Bit SVREAD.
	TWI_SR_SVREAD = 0x8
	// Position of SVACC field.
	TWI_SR_SVACC_Pos = 0x4
	// Bit mask of SVACC field.
	TWI_SR_SVACC_Msk = 0x10
	// Bit SVACC.
	TWI_SR_SVACC = 0x10
	// Position of GACC field.
	TWI_SR_GACC_Pos = 0x5
	// Bit mask of GACC field.
	TWI_SR_GACC_Msk = 0x20
	// Bit GACC.
	TWI_SR_GACC = 0x20
	// Position of OVRE field.
	TWI_SR_OVRE_Pos = 0x6
	// Bit mask of OVRE field.
	TWI_SR_OVRE_Msk = 0x40
	// Bit OVRE.
	TWI_SR_OVRE = 0x40
	// Position of NACK field.
	TWI_SR_NACK_Pos = 0x8
	// Bit mask of NACK field.
	TWI_SR_NACK_Msk = 0x100
	// Bit NACK.
	TWI_SR_NACK = 0x100
	// Position of ARBLST field.
	TWI_SR_ARBLST_Pos = 0x9
	// Bit mask of ARBLST field.
	TWI_SR_ARBLST_Msk = 0x200
	// Bit ARBLST.
	TWI_SR_ARBLST = 0x200
	// Position of SCLWS field.
	TWI_SR_SCLWS_Pos = 0xa
	// Bit mask of SCLWS field.
	TWI_SR_SCLWS_Msk = 0x400
	// Bit SCLWS.
	TWI_SR_SCLWS = 0x400
	// Position of EOSACC field.
	TWI_SR_EOSACC_Pos = 0xb
	// Bit mask of EOSACC field.
	TWI_SR_EOSACC_Msk = 0x800
	// Bit EOSACC.
	TWI_SR_EOSACC = 0x800

	// IER: Interrupt Enable Register
	// Position of TXCOMP field.
	TWI_IER_TXCOMP_Pos = 0x0
	// Bit mask of TXCOMP field.
	TWI_IER_TXCOMP_Msk = 0x1
	// Bit TXCOMP.
	TWI_IER_TXCOMP = 0x1
	// Position of RXRDY field.
	TWI_IER_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	TWI_IER_RXRDY_Msk = 0x2
	// Bit RXRDY.
	TWI_IER_RXRDY = 0x2
	// Position of TXRDY field.
	TWI_IER_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	TWI_IER_TXRDY_Msk = 0x4
	// Bit TXRDY.
	TWI_IER_TXRDY = 0x4
	// Position of SVACC field.
	TWI_IER_SVACC_Pos = 0x4
	// Bit mask of SVACC field.
	TWI_IER_SVACC_Msk = 0x10
	// Bit SVACC.
	TWI_IER_SVACC = 0x10
	// Position of GACC field.
	TWI_IER_GACC_Pos = 0x5
	// Bit mask of GACC field.
	TWI_IER_GACC_Msk = 0x20
	// Bit GACC.
	TWI_IER_GACC = 0x20
	// Position of OVRE field.
	TWI_IER_OVRE_Pos = 0x6
	// Bit mask of OVRE field.
	TWI_IER_OVRE_Msk = 0x40
	// Bit OVRE.
	TWI_IER_OVRE = 0x40
	// Position of NACK field.
	TWI_IER_NACK_Pos = 0x8
	// Bit mask of NACK field.
	TWI_IER_NACK_Msk = 0x100
	// Bit NACK.
	TWI_IER_NACK = 0x100
	// Position of ARBLST field.
	TWI_IER_ARBLST_Pos = 0x9
	// Bit mask of ARBLST field.
	TWI_IER_ARBLST_Msk = 0x200
	// Bit ARBLST.
	TWI_IER_ARBLST = 0x200
	// Position of SCL_WS field.
	TWI_IER_SCL_WS_Pos = 0xa
	// Bit mask of SCL_WS field.
	TWI_IER_SCL_WS_Msk = 0x400
	// Bit SCL_WS.
	TWI_IER_SCL_WS = 0x400
	// Position of EOSACC field.
	TWI_IER_EOSACC_Pos = 0xb
	// Bit mask of EOSACC field.
	TWI_IER_EOSACC_Msk = 0x800
	// Bit EOSACC.
	TWI_IER_EOSACC = 0x800

	// IDR: Interrupt Disable Register
	// Position of TXCOMP field.
	TWI_IDR_TXCOMP_Pos = 0x0
	// Bit mask of TXCOMP field.
	TWI_IDR_TXCOMP_Msk = 0x1
	// Bit TXCOMP.
	TWI_IDR_TXCOMP = 0x1
	// Position of RXRDY field.
	TWI_IDR_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	TWI_IDR_RXRDY_Msk = 0x2
	// Bit RXRDY.
	TWI_IDR_RXRDY = 0x2
	// Position of TXRDY field.
	TWI_IDR_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	TWI_IDR_TXRDY_Msk = 0x4
	// Bit TXRDY.
	TWI_IDR_TXRDY = 0x4
	// Position of SVACC field.
	TWI_IDR_SVACC_Pos = 0x4
	// Bit mask of SVACC field.
	TWI_IDR_SVACC_Msk = 0x10
	// Bit SVACC.
	TWI_IDR_SVACC = 0x10
	// Position of GACC field.
	TWI_IDR_GACC_Pos = 0x5
	// Bit mask of GACC field.
	TWI_IDR_GACC_Msk = 0x20
	// Bit GACC.
	TWI_IDR_GACC = 0x20
	// Position of OVRE field.
	TWI_IDR_OVRE_Pos = 0x6
	// Bit mask of OVRE field.
	TWI_IDR_OVRE_Msk = 0x40
	// Bit OVRE.
	TWI_IDR_OVRE = 0x40
	// Position of NACK field.
	TWI_IDR_NACK_Pos = 0x8
	// Bit mask of NACK field.
	TWI_IDR_NACK_Msk = 0x100
	// Bit NACK.
	TWI_IDR_NACK = 0x100
	// Position of ARBLST field.
	TWI_IDR_ARBLST_Pos = 0x9
	// Bit mask of ARBLST field.
	TWI_IDR_ARBLST_Msk = 0x200
	// Bit ARBLST.
	TWI_IDR_ARBLST = 0x200
	// Position of SCL_WS field.
	TWI_IDR_SCL_WS_Pos = 0xa
	// Bit mask of SCL_WS field.
	TWI_IDR_SCL_WS_Msk = 0x400
	// Bit SCL_WS.
	TWI_IDR_SCL_WS = 0x400
	// Position of EOSACC field.
	TWI_IDR_EOSACC_Pos = 0xb
	// Bit mask of EOSACC field.
	TWI_IDR_EOSACC_Msk = 0x800
	// Bit EOSACC.
	TWI_IDR_EOSACC = 0x800

	// IMR: Interrupt Mask Register
	// Position of TXCOMP field.
	TWI_IMR_TXCOMP_Pos = 0x0
	// Bit mask of TXCOMP field.
	TWI_IMR_TXCOMP_Msk = 0x1
	// Bit TXCOMP.
	TWI_IMR_TXCOMP = 0x1
	// Position of RXRDY field.
	TWI_IMR_RXRDY_Pos = 0x1
	// Bit mask of RXRDY field.
	TWI_IMR_RXRDY_Msk = 0x2
	// Bit RXRDY.
	TWI_IMR_RXRDY = 0x2
	// Position of TXRDY field.
	TWI_IMR_TXRDY_Pos = 0x2
	// Bit mask of TXRDY field.
	TWI_IMR_TXRDY_Msk = 0x4
	// Bit TXRDY.
	TWI_IMR_TXRDY = 0x4
	// Position of SVACC field.
	TWI_IMR_SVACC_Pos = 0x4
	// Bit mask of SVACC field.
	TWI_IMR_SVACC_Msk = 0x10
	// Bit SVACC.
	TWI_IMR_SVACC = 0x10
	// Position of GACC field.
	TWI_IMR_GACC_Pos = 0x5
	// Bit mask of GACC field.
	TWI_IMR_GACC_Msk = 0x20
	// Bit GACC.
	TWI_IMR_GACC = 0x20
	// Position of OVRE field.
	TWI_IMR_OVRE_Pos = 0x6
	// Bit mask of OVRE field.
	TWI_IMR_OVRE_Msk = 0x40
	// Bit OVRE.
	TWI_IMR_OVRE = 0x40
	// Position of NACK field.
	TWI_IMR_NACK_Pos = 0x8
	// Bit mask of NACK field.
	TWI_IMR_NACK_Msk = 0x100
	// Bit NACK.
	TWI_IMR_NACK = 0x100
	// Position of ARBLST field.
	TWI_IMR_ARBLST_Pos = 0x9
	// Bit mask of ARBLST field.
	TWI_IMR_ARBLST_Msk = 0x200
	// Bit ARBLST.
	TWI_IMR_ARBLST = 0x200
	// Position of SCL_WS field.
	TWI_IMR_SCL_WS_Pos = 0xa
	// Bit mask of SCL_WS field.
	TWI_IMR_SCL_WS_Msk = 0x400
	// Bit SCL_WS.
	TWI_IMR_SCL_WS = 0x400
	// Position of EOSACC field.
	TWI_IMR_EOSACC_Pos = 0xb
	// Bit mask of EOSACC field.
	TWI_IMR_EOSACC_Msk = 0x800
	// Bit EOSACC.
	TWI_IMR_EOSACC = 0x800

	// RHR: Receive Holding Register
	// Position of RXDATA field.
	TWI_RHR_RXDATA_Pos = 0x0
	// Bit mask of RXDATA field.
	TWI_RHR_RXDATA_Msk = 0xff

	// THR: Transmit Holding Register
	// Position of TXDATA field.
	TWI_THR_TXDATA_Pos = 0x0
	// Bit mask of TXDATA field.
	TWI_THR_TXDATA_Msk = 0xff

	// WPROT_MODE: Protection Mode Register
	// Position of WPROT field.
	TWI_WPROT_MODE_WPROT_Pos = 0x0
	// Bit mask of WPROT field.
	TWI_WPROT_MODE_WPROT_Msk = 0x1
	// Bit WPROT.
	TWI_WPROT_MODE_WPROT = 0x1
	// Position of SECURITY_CODE field.
	TWI_WPROT_MODE_SECURITY_CODE_Pos = 0x8
	// Bit mask of SECURITY_CODE field.
	TWI_WPROT_MODE_SECURITY_CODE_Msk = 0xffffff00

	// WPROT_STATUS: Protection Status Register
	// Position of WPROTERR field.
	TWI_WPROT_STATUS_WPROTERR_Pos = 0x0
	// Bit mask of WPROTERR field.
	TWI_WPROT_STATUS_WPROTERR_Msk = 0x1
	// Bit WPROTERR.
	TWI_WPROT_STATUS_WPROTERR = 0x1
	// Position of WPROTADDR field.
	TWI_WPROT_STATUS_WPROTADDR_Pos = 0x8
	// Bit mask of WPROTADDR field.
	TWI_WPROT_STATUS_WPROTADDR_Msk = 0xffffff00
)

// Constants for USART0: Universal Synchronous Asynchronous Receiver Transmitter 0
const (
	// CR: Control Register
	// Position of RSTRX field.
	USART_CR_RSTRX_Pos = 0x2
	// Bit mask of RSTRX field.
	USART_CR_RSTRX_Msk = 0x4
	// Bit RSTRX.
	USART_CR_RSTRX = 0x4
	// Position of RSTTX field.
	USART_CR_RSTTX_Pos = 0x3
	// Bit mask of RSTTX field.
	USART_CR_RSTTX_Msk = 0x8
	// Bit RSTTX.
	USART_CR_RSTTX = 0x8
	// Position of RXEN field.
	USART_CR_RXEN_Pos = 0x4
	// Bit mask of RXEN field.
	USART_CR_RXEN_Msk = 0x10
	// Bit RXEN.
	USART_CR_RXEN = 0x10
	// Position of RXDIS field.
	USART_CR_RXDIS_Pos = 0x5
	// Bit mask of RXDIS field.
	USART_CR_RXDIS_Msk = 0x20
	// Bit RXDIS.
	USART_CR_RXDIS = 0x20
	// Position of TXEN field.
	USART_CR_TXEN_Pos = 0x6
	// Bit mask of TXEN field.
	USART_CR_TXEN_Msk = 0x40
	// Bit TXEN.
	USART_CR_TXEN = 0x40
	// Position of TXDIS field.
	USART_CR_TXDIS_Pos = 0x7
	// Bit mask of TXDIS field.
	USART_CR_TXDIS_Msk = 0x80
	// Bit TXDIS.
	USART_CR_TXDIS = 0x80
	// Position of RSTSTA field.
	USART_CR_RSTSTA_Pos = 0x8
	// Bit mask of RSTSTA field.
	USART_CR_RSTSTA_Msk = 0x100
	// Bit RSTSTA.
	USART_CR_RSTSTA = 0x100
	// Position of STTBRK field.
	USART_CR_STTBRK_Pos = 0x9
	// Bit mask of STTBRK field.
	USART_CR_STTBRK_Msk = 0x200
	// Bit STTBRK.
	USART_CR_STTBRK = 0x200
	// Position of STPBRK field.
	USART_CR_STPBRK_Pos = 0xa
	// Bit mask of STPBRK field.
	USART_CR_STPBRK_Msk = 0x400
	// Bit STPBRK.
	USART_CR_STPBRK = 0x400
	// Position of STTTO field.
	USART_CR_STTTO_Pos = 0xb
	// Bit mask of STTTO field.
	USART_CR_STTTO_Msk = 0x800
	// Bit STTTO.
	USART_CR_STTTO = 0x800
	// Position of SENDA field.
	USART_CR_SENDA_Pos = 0xc
	// Bit mask of SENDA field.
	USART_CR_SENDA_Msk = 0x1000
	// Bit SENDA.
	USART_CR_SENDA = 0x1000
	// Position of RSTIT field.
	USART_CR_RSTIT_Pos = 0xd
	// Bit mask of RSTIT field.
	USART_CR_RSTIT_Msk = 0x2000
	// Bit RSTIT.
	USART_CR_RSTIT = 0x2000
	// Position of RSTNACK field.
	USART_CR_RSTNACK_Pos = 0xe
	// Bit mask of RSTNACK field.
	USART_CR_RSTNACK_Msk = 0x4000
	// Bit RSTNACK.
	USART_CR_RSTNACK = 0x4000
	// Position of RETTO field.
	USART_CR_RETTO_Pos = 0xf
	// Bit mask of RETTO field.
	USART_CR_RETTO_Msk = 0x8000
	// Bit RETTO.
	USART_CR_RETTO = 0x8000
	// Position of RTSEN field.
	USART_CR_RTSEN_Pos = 0x12
	// Bit mask of RTSEN field.
	USART_CR_RTSEN_Msk = 0x40000
	// Bit RTSEN.
	USART_CR_RTSEN = 0x40000
	// Position of RTSDIS field.
	USART_CR_RTSDIS_Pos = 0x13
	// Bit mask of RTSDIS field.
	USART_CR_RTSDIS_Msk = 0x80000
	// Bit RTSDIS.
	USART_CR_RTSDIS = 0x80000

	// CR_SPI_MODE: Control Register
	// Position of RSTRX field.
	USART_CR_SPI_MODE_RSTRX_Pos = 0x2
	// Bit mask of RSTRX field.
	USART_CR_SPI_MODE_RSTRX_Msk = 0x4
	// Bit RSTRX.
	USART_CR_SPI_MODE_RSTRX = 0x4
	// Position of RSTTX field.
	USART_CR_SPI_MODE_RSTTX_Pos = 0x3
	// Bit mask of RSTTX field.
	USART_CR_SPI_MODE_RSTTX_Msk = 0x8
	// Bit RSTTX.
	USART_CR_SPI_MODE_RSTTX = 0x8
	// Position of RXEN field.
	USART_CR_SPI_MODE_RXEN_Pos = 0x4
	// Bit mask of RXEN field.
	USART_CR_SPI_MODE_RXEN_Msk = 0x10
	// Bit RXEN.
	USART_CR_SPI_MODE_RXEN = 0x10
	// Position of RXDIS field.
	USART_CR_SPI_MODE_RXDIS_Pos = 0x5
	// Bit mask of RXDIS field.
	USART_CR_SPI_MODE_RXDIS_Msk = 0x20
	// Bit RXDIS.
	USART_CR_SPI_MODE_RXDIS = 0x20
	// Position of TXEN field.
	USART_CR_SPI_MODE_TXEN_Pos = 0x6
	// Bit mask of TXEN field.
	USART_CR_SPI_MODE_TXEN_Msk = 0x40
	// Bit TXEN.
	USART_CR_SPI_MODE_TXEN = 0x40
	// Position of TXDIS field.
	USART_CR_SPI_MODE_TXDIS_Pos = 0x7
	// Bit mask of TXDIS field.
	USART_CR_SPI_MODE_TXDIS_Msk = 0x80
	// Bit TXDIS.
	USART_CR_SPI_MODE_TXDIS = 0x80
	// Position of RSTSTA field.
	USART_CR_SPI_MODE_RSTSTA_Pos = 0x8
	// Bit mask of RSTSTA field.
	USART_CR_SPI_MODE_RSTSTA_Msk = 0x100
	// Bit RSTSTA.
	USART_CR_SPI_MODE_RSTSTA = 0x100
	// Position of FCS field.
	USART_CR_SPI_MODE_FCS_Pos = 0x12
	// Bit mask of FCS field.
	USART_CR_SPI_MODE_FCS_Msk = 0x40000
	// Bit FCS.
	USART_CR_SPI_MODE_FCS = 0x40000
	// Position of RCS field.
	USART_CR_SPI_MODE_RCS_Pos = 0x13
	// Bit mask of RCS field.
	USART_CR_SPI_MODE_RCS_Msk = 0x80000
	// Bit RCS.
	USART_CR_SPI_MODE_RCS = 0x80000

	// MR: Mode Register
	// Position of USART_MODE field.
	USART_MR_USART_MODE_Pos = 0x0
	// Bit mask of USART_MODE field.
	USART_MR_USART_MODE_Msk = 0xf
	// Normal mode
	USART_MR_USART_MODE_NORMAL = 0x0
	// RS485
	USART_MR_USART_MODE_RS485 = 0x1
	// Hardware Handshaking
	USART_MR_USART_MODE_HW_HANDSHAKING = 0x2
	// IS07816 Protocol: T = 0
	USART_MR_USART_MODE_IS07816_T_0 = 0x4
	// IS07816 Protocol: T = 1
	USART_MR_USART_MODE_IS07816_T_1 = 0x6
	// IrDA
	USART_MR_USART_MODE_IRDA = 0x8
	// SPI Master
	USART_MR_USART_MODE_SPI_MASTER = 0xe
	// SPI Slave
	USART_MR_USART_MODE_SPI_SLAVE = 0xf
	// Position of USCLKS field.
	USART_MR_USCLKS_Pos = 0x4
	// Bit mask of USCLKS field.
	USART_MR_USCLKS_Msk = 0x30
	// Master Clock MCK is selected
	USART_MR_USCLKS_MCK = 0x0
	// Internal Clock Divided MCK/DIV (DIV=(DIV=8)) is selected
	USART_MR_USCLKS_DIV = 0x1
	// Serial Clock SLK is selected
	USART_MR_USCLKS_SCK = 0x3
	// Position of CHRL field.
	USART_MR_CHRL_Pos = 0x6
	// Bit mask of CHRL field.
	USART_MR_CHRL_Msk = 0xc0
	// Character length is 5 bits
	USART_MR_CHRL_5_BIT = 0x0
	// Character length is 6 bits
	USART_MR_CHRL_6_BIT = 0x1
	// Character length is 7 bits
	USART_MR_CHRL_7_BIT = 0x2
	// Character length is 8 bits
	USART_MR_CHRL_8_BIT = 0x3
	// Position of SYNC field.
	USART_MR_SYNC_Pos = 0x8
	// Bit mask of SYNC field.
	USART_MR_SYNC_Msk = 0x100
	// Bit SYNC.
	USART_MR_SYNC = 0x100
	// Position of PAR field.
	USART_MR_PAR_Pos = 0x9
	// Bit mask of PAR field.
	USART_MR_PAR_Msk = 0xe00
	// Even parity
	USART_MR_PAR_EVEN = 0x0
	// Odd parity
	USART_MR_PAR_ODD = 0x1
	// Parity forced to 0 (Space)
	USART_MR_PAR_SPACE = 0x2
	// Parity forced to 1 (Mark)
	USART_MR_PAR_MARK = 0x3
	// No parity
	USART_MR_PAR_NO = 0x4
	// Multidrop mode
	USART_MR_PAR_MULTIDROP = 0x6
	// Position of NBSTOP field.
	USART_MR_NBSTOP_Pos = 0xc
	// Bit mask of NBSTOP field.
	USART_MR_NBSTOP_Msk = 0x3000
	// 1 stop bit
	USART_MR_NBSTOP_1_BIT = 0x0
	// 1.5 stop bit (SYNC = 0) or reserved (SYNC = 1)
	USART_MR_NBSTOP_1_5_BIT = 0x1
	// 2 stop bits
	USART_MR_NBSTOP_2_BIT = 0x2
	// Position of CHMODE field.
	USART_MR_CHMODE_Pos = 0xe
	// Bit mask of CHMODE field.
	USART_MR_CHMODE_Msk = 0xc000
	// Normal Mode
	USART_MR_CHMODE_NORMAL = 0x0
	// Automatic Echo. Receiver input is connected to the TXD pin.
	USART_MR_CHMODE_AUTOMATIC = 0x1
	// Local Loopback. Transmitter output is connected to the Receiver Input.
	USART_MR_CHMODE_LOCAL_LOOPBACK = 0x2
	// Remote Loopback. RXD pin is internally connected to the TXD pin.
	USART_MR_CHMODE_REMOTE_LOOPBACK = 0x3
	// Position of MSBF field.
	USART_MR_MSBF_Pos = 0x10
	// Bit mask of MSBF field.
	USART_MR_MSBF_Msk = 0x10000
	// Bit MSBF.
	USART_MR_MSBF = 0x10000
	// Position of MODE9 field.
	USART_MR_MODE9_Pos = 0x11
	// Bit mask of MODE9 field.
	USART_MR_MODE9_Msk = 0x20000
	// Bit MODE9.
	USART_MR_MODE9 = 0x20000
	// Position of CLKO field.
	USART_MR_CLKO_Pos = 0x12
	// Bit mask of CLKO field.
	USART_MR_CLKO_Msk = 0x40000
	// Bit CLKO.
	USART_MR_CLKO = 0x40000
	// Position of OVER field.
	USART_MR_OVER_Pos = 0x13
	// Bit mask of OVER field.
	USART_MR_OVER_Msk = 0x80000
	// Bit OVER.
	USART_MR_OVER = 0x80000
	// Position of INACK field.
	USART_MR_INACK_Pos = 0x14
	// Bit mask of INACK field.
	USART_MR_INACK_Msk = 0x100000
	// Bit INACK.
	USART_MR_INACK = 0x100000
	// Position of DSNACK field.
	USART_MR_DSNACK_Pos = 0x15
	// Bit mask of DSNACK field.
	USART_MR_DSNACK_Msk = 0x200000
	// Bit DSNACK.
	USART_MR_DSNACK = 0x200000
	// Position of VAR_SYNC field.
	USART_MR_VAR_SYNC_Pos = 0x16
	// Bit mask of VAR_SYNC field.
	USART_MR_VAR_SYNC_Msk = 0x400000
	// Bit VAR_SYNC.
	USART_MR_VAR_SYNC = 0x400000
	// Position of INVDATA field.
	USART_MR_INVDATA_Pos = 0x17
	// Bit mask of INVDATA field.
	USART_MR_INVDATA_Msk = 0x800000
	// Bit INVDATA.
	USART_MR_INVDATA = 0x800000
	// Position of MAX_ITERATION field.
	USART_MR_MAX_ITERATION_Pos = 0x18
	// Bit mask of MAX_ITERATION field.
	USART_MR_MAX_ITERATION_Msk = 0x7000000
	// Position of FILTER field.
	USART_MR_FILTER_Pos = 0x1c
	// Bit mask of FILTER field.
	USART_MR_FILTER_Msk = 0x10000000
	// Bit FILTER.
	USART_MR_FILTER = 0x10000000
	// Position of MAN field.
	USART_MR_MAN_Pos = 0x1d
	// Bit mask of MAN field.
	USART_MR_MAN_Msk = 0x20000000
	// Bit MAN.
	USART_MR_MAN = 0x20000000
	// Position of MODSYNC field.
	USART_MR_MODSYNC_Pos = 0x1e
	// Bit mask of MODSYNC field.
	USART_MR_MODSYNC_Msk = 0x40000000
	// Bit MODSYNC.
	USART_MR_MODSYNC = 0x40000000
	// Position of ONEBIT field.
	USART_MR_ONEBIT_Pos = 0x1f
	// Bit mask of ONEBIT field.
	USART_MR_ONEBIT_Msk = 0x80000000
	// Bit ONEBIT.
	USART_MR_ONEBIT = 0x80000000

	// MR_SPI_MODE: Mode Register
	// Position of USART_MODE field.
	USART_MR_SPI_MODE_USART_MODE_Pos = 0x0
	// Bit mask of USART_MODE field.
	USART_MR_SPI_MODE_USART_MODE_Msk = 0xf
	// SPI Master
	USART_MR_SPI_MODE_USART_MODE_SPI_MASTER = 0xe
	// SPI Slave
	USART_MR_SPI_MODE_USART_MODE_SPI_SLAVE = 0xf
	// Position of USCLKS field.
	USART_MR_SPI_MODE_USCLKS_Pos = 0x4
	// Bit mask of USCLKS field.
	USART_MR_SPI_MODE_USCLKS_Msk = 0x30
	// Master Clock MCK is selected
	USART_MR_SPI_MODE_USCLKS_MCK = 0x0
	// Internal Clock Divided MCK/DIV (DIV=(DIV=8)) is selected
	USART_MR_SPI_MODE_USCLKS_DIV = 0x1
	// Serial Clock SLK is selected
	USART_MR_SPI_MODE_USCLKS_SCK = 0x3
	// Position of CHRL field.
	USART_MR_SPI_MODE_CHRL_Pos = 0x6
	// Bit mask of CHRL field.
	USART_MR_SPI_MODE_CHRL_Msk = 0xc0
	// Character length is 8 bits
	USART_MR_SPI_MODE_CHRL_8_BIT = 0x3
	// Position of CPHA field.
	USART_MR_SPI_MODE_CPHA_Pos = 0x8
	// Bit mask of CPHA field.
	USART_MR_SPI_MODE_CPHA_Msk = 0x100
	// Bit CPHA.
	USART_MR_SPI_MODE_CPHA = 0x100
	// Position of CPOL field.
	USART_MR_SPI_MODE_CPOL_Pos = 0x10
	// Bit mask of CPOL field.
	USART_MR_SPI_MODE_CPOL_Msk = 0x10000
	// Bit CPOL.
	USART_MR_SPI_MODE_CPOL = 0x10000
	// Position of WRDBT field.
	USART_MR_SPI_MODE_WRDBT_Pos = 0x14
	// Bit mask of WRDBT field.
	USART_MR_SPI_MODE_WRDBT_Msk = 0x100000
	// Bit WRDBT.
	USART_MR_SPI_MODE_WRDBT = 0x100000

	// IER: Interrupt Enable Register
	// Position of RXRDY field.
	USART_IER_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_IER_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_IER_RXRDY = 0x1
	// Position of TXRDY field.
	USART_IER_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_IER_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_IER_TXRDY = 0x2
	// Position of RXBRK field.
	USART_IER_RXBRK_Pos = 0x2
	// Bit mask of RXBRK field.
	USART_IER_RXBRK_Msk = 0x4
	// Bit RXBRK.
	USART_IER_RXBRK = 0x4
	// Position of OVRE field.
	USART_IER_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_IER_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_IER_OVRE = 0x20
	// Position of FRAME field.
	USART_IER_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	USART_IER_FRAME_Msk = 0x40
	// Bit FRAME.
	USART_IER_FRAME = 0x40
	// Position of PARE field.
	USART_IER_PARE_Pos = 0x7
	// Bit mask of PARE field.
	USART_IER_PARE_Msk = 0x80
	// Bit PARE.
	USART_IER_PARE = 0x80
	// Position of TIMEOUT field.
	USART_IER_TIMEOUT_Pos = 0x8
	// Bit mask of TIMEOUT field.
	USART_IER_TIMEOUT_Msk = 0x100
	// Bit TIMEOUT.
	USART_IER_TIMEOUT = 0x100
	// Position of TXEMPTY field.
	USART_IER_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_IER_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_IER_TXEMPTY = 0x200
	// Position of ITER field.
	USART_IER_ITER_Pos = 0xa
	// Bit mask of ITER field.
	USART_IER_ITER_Msk = 0x400
	// Bit ITER.
	USART_IER_ITER = 0x400
	// Position of NACK field.
	USART_IER_NACK_Pos = 0xd
	// Bit mask of NACK field.
	USART_IER_NACK_Msk = 0x2000
	// Bit NACK.
	USART_IER_NACK = 0x2000
	// Position of CTSIC field.
	USART_IER_CTSIC_Pos = 0x13
	// Bit mask of CTSIC field.
	USART_IER_CTSIC_Msk = 0x80000
	// Bit CTSIC.
	USART_IER_CTSIC = 0x80000
	// Position of MANE field.
	USART_IER_MANE_Pos = 0x18
	// Bit mask of MANE field.
	USART_IER_MANE_Msk = 0x1000000
	// Bit MANE.
	USART_IER_MANE = 0x1000000

	// IER_SPI_MODE: Interrupt Enable Register
	// Position of RXRDY field.
	USART_IER_SPI_MODE_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_IER_SPI_MODE_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_IER_SPI_MODE_RXRDY = 0x1
	// Position of TXRDY field.
	USART_IER_SPI_MODE_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_IER_SPI_MODE_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_IER_SPI_MODE_TXRDY = 0x2
	// Position of OVRE field.
	USART_IER_SPI_MODE_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_IER_SPI_MODE_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_IER_SPI_MODE_OVRE = 0x20
	// Position of TXEMPTY field.
	USART_IER_SPI_MODE_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_IER_SPI_MODE_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_IER_SPI_MODE_TXEMPTY = 0x200
	// Position of UNRE field.
	USART_IER_SPI_MODE_UNRE_Pos = 0xa
	// Bit mask of UNRE field.
	USART_IER_SPI_MODE_UNRE_Msk = 0x400
	// Bit UNRE.
	USART_IER_SPI_MODE_UNRE = 0x400

	// IDR: Interrupt Disable Register
	// Position of RXRDY field.
	USART_IDR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_IDR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_IDR_RXRDY = 0x1
	// Position of TXRDY field.
	USART_IDR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_IDR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_IDR_TXRDY = 0x2
	// Position of RXBRK field.
	USART_IDR_RXBRK_Pos = 0x2
	// Bit mask of RXBRK field.
	USART_IDR_RXBRK_Msk = 0x4
	// Bit RXBRK.
	USART_IDR_RXBRK = 0x4
	// Position of OVRE field.
	USART_IDR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_IDR_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_IDR_OVRE = 0x20
	// Position of FRAME field.
	USART_IDR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	USART_IDR_FRAME_Msk = 0x40
	// Bit FRAME.
	USART_IDR_FRAME = 0x40
	// Position of PARE field.
	USART_IDR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	USART_IDR_PARE_Msk = 0x80
	// Bit PARE.
	USART_IDR_PARE = 0x80
	// Position of TIMEOUT field.
	USART_IDR_TIMEOUT_Pos = 0x8
	// Bit mask of TIMEOUT field.
	USART_IDR_TIMEOUT_Msk = 0x100
	// Bit TIMEOUT.
	USART_IDR_TIMEOUT = 0x100
	// Position of TXEMPTY field.
	USART_IDR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_IDR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_IDR_TXEMPTY = 0x200
	// Position of ITER field.
	USART_IDR_ITER_Pos = 0xa
	// Bit mask of ITER field.
	USART_IDR_ITER_Msk = 0x400
	// Bit ITER.
	USART_IDR_ITER = 0x400
	// Position of NACK field.
	USART_IDR_NACK_Pos = 0xd
	// Bit mask of NACK field.
	USART_IDR_NACK_Msk = 0x2000
	// Bit NACK.
	USART_IDR_NACK = 0x2000
	// Position of CTSIC field.
	USART_IDR_CTSIC_Pos = 0x13
	// Bit mask of CTSIC field.
	USART_IDR_CTSIC_Msk = 0x80000
	// Bit CTSIC.
	USART_IDR_CTSIC = 0x80000
	// Position of MANE field.
	USART_IDR_MANE_Pos = 0x18
	// Bit mask of MANE field.
	USART_IDR_MANE_Msk = 0x1000000
	// Bit MANE.
	USART_IDR_MANE = 0x1000000

	// IDR_SPI_MODE: Interrupt Disable Register
	// Position of RXRDY field.
	USART_IDR_SPI_MODE_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_IDR_SPI_MODE_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_IDR_SPI_MODE_RXRDY = 0x1
	// Position of TXRDY field.
	USART_IDR_SPI_MODE_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_IDR_SPI_MODE_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_IDR_SPI_MODE_TXRDY = 0x2
	// Position of OVRE field.
	USART_IDR_SPI_MODE_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_IDR_SPI_MODE_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_IDR_SPI_MODE_OVRE = 0x20
	// Position of TXEMPTY field.
	USART_IDR_SPI_MODE_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_IDR_SPI_MODE_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_IDR_SPI_MODE_TXEMPTY = 0x200
	// Position of UNRE field.
	USART_IDR_SPI_MODE_UNRE_Pos = 0xa
	// Bit mask of UNRE field.
	USART_IDR_SPI_MODE_UNRE_Msk = 0x400
	// Bit UNRE.
	USART_IDR_SPI_MODE_UNRE = 0x400

	// IMR: Interrupt Mask Register
	// Position of RXRDY field.
	USART_IMR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_IMR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_IMR_RXRDY = 0x1
	// Position of TXRDY field.
	USART_IMR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_IMR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_IMR_TXRDY = 0x2
	// Position of RXBRK field.
	USART_IMR_RXBRK_Pos = 0x2
	// Bit mask of RXBRK field.
	USART_IMR_RXBRK_Msk = 0x4
	// Bit RXBRK.
	USART_IMR_RXBRK = 0x4
	// Position of OVRE field.
	USART_IMR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_IMR_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_IMR_OVRE = 0x20
	// Position of FRAME field.
	USART_IMR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	USART_IMR_FRAME_Msk = 0x40
	// Bit FRAME.
	USART_IMR_FRAME = 0x40
	// Position of PARE field.
	USART_IMR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	USART_IMR_PARE_Msk = 0x80
	// Bit PARE.
	USART_IMR_PARE = 0x80
	// Position of TIMEOUT field.
	USART_IMR_TIMEOUT_Pos = 0x8
	// Bit mask of TIMEOUT field.
	USART_IMR_TIMEOUT_Msk = 0x100
	// Bit TIMEOUT.
	USART_IMR_TIMEOUT = 0x100
	// Position of TXEMPTY field.
	USART_IMR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_IMR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_IMR_TXEMPTY = 0x200
	// Position of ITER field.
	USART_IMR_ITER_Pos = 0xa
	// Bit mask of ITER field.
	USART_IMR_ITER_Msk = 0x400
	// Bit ITER.
	USART_IMR_ITER = 0x400
	// Position of NACK field.
	USART_IMR_NACK_Pos = 0xd
	// Bit mask of NACK field.
	USART_IMR_NACK_Msk = 0x2000
	// Bit NACK.
	USART_IMR_NACK = 0x2000
	// Position of CTSIC field.
	USART_IMR_CTSIC_Pos = 0x13
	// Bit mask of CTSIC field.
	USART_IMR_CTSIC_Msk = 0x80000
	// Bit CTSIC.
	USART_IMR_CTSIC = 0x80000
	// Position of MANE field.
	USART_IMR_MANE_Pos = 0x18
	// Bit mask of MANE field.
	USART_IMR_MANE_Msk = 0x1000000
	// Bit MANE.
	USART_IMR_MANE = 0x1000000

	// IMR_SPI_MODE: Interrupt Mask Register
	// Position of RXRDY field.
	USART_IMR_SPI_MODE_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_IMR_SPI_MODE_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_IMR_SPI_MODE_RXRDY = 0x1
	// Position of TXRDY field.
	USART_IMR_SPI_MODE_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_IMR_SPI_MODE_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_IMR_SPI_MODE_TXRDY = 0x2
	// Position of OVRE field.
	USART_IMR_SPI_MODE_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_IMR_SPI_MODE_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_IMR_SPI_MODE_OVRE = 0x20
	// Position of TXEMPTY field.
	USART_IMR_SPI_MODE_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_IMR_SPI_MODE_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_IMR_SPI_MODE_TXEMPTY = 0x200
	// Position of UNRE field.
	USART_IMR_SPI_MODE_UNRE_Pos = 0xa
	// Bit mask of UNRE field.
	USART_IMR_SPI_MODE_UNRE_Msk = 0x400
	// Bit UNRE.
	USART_IMR_SPI_MODE_UNRE = 0x400

	// CSR: Channel Status Register
	// Position of RXRDY field.
	USART_CSR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_CSR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_CSR_RXRDY = 0x1
	// Position of TXRDY field.
	USART_CSR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_CSR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_CSR_TXRDY = 0x2
	// Position of RXBRK field.
	USART_CSR_RXBRK_Pos = 0x2
	// Bit mask of RXBRK field.
	USART_CSR_RXBRK_Msk = 0x4
	// Bit RXBRK.
	USART_CSR_RXBRK = 0x4
	// Position of OVRE field.
	USART_CSR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_CSR_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_CSR_OVRE = 0x20
	// Position of FRAME field.
	USART_CSR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	USART_CSR_FRAME_Msk = 0x40
	// Bit FRAME.
	USART_CSR_FRAME = 0x40
	// Position of PARE field.
	USART_CSR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	USART_CSR_PARE_Msk = 0x80
	// Bit PARE.
	USART_CSR_PARE = 0x80
	// Position of TIMEOUT field.
	USART_CSR_TIMEOUT_Pos = 0x8
	// Bit mask of TIMEOUT field.
	USART_CSR_TIMEOUT_Msk = 0x100
	// Bit TIMEOUT.
	USART_CSR_TIMEOUT = 0x100
	// Position of TXEMPTY field.
	USART_CSR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_CSR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_CSR_TXEMPTY = 0x200
	// Position of ITER field.
	USART_CSR_ITER_Pos = 0xa
	// Bit mask of ITER field.
	USART_CSR_ITER_Msk = 0x400
	// Bit ITER.
	USART_CSR_ITER = 0x400
	// Position of NACK field.
	USART_CSR_NACK_Pos = 0xd
	// Bit mask of NACK field.
	USART_CSR_NACK_Msk = 0x2000
	// Bit NACK.
	USART_CSR_NACK = 0x2000
	// Position of CTSIC field.
	USART_CSR_CTSIC_Pos = 0x13
	// Bit mask of CTSIC field.
	USART_CSR_CTSIC_Msk = 0x80000
	// Bit CTSIC.
	USART_CSR_CTSIC = 0x80000
	// Position of CTS field.
	USART_CSR_CTS_Pos = 0x17
	// Bit mask of CTS field.
	USART_CSR_CTS_Msk = 0x800000
	// Bit CTS.
	USART_CSR_CTS = 0x800000
	// Position of MANERR field.
	USART_CSR_MANERR_Pos = 0x18
	// Bit mask of MANERR field.
	USART_CSR_MANERR_Msk = 0x1000000
	// Bit MANERR.
	USART_CSR_MANERR = 0x1000000

	// CSR_SPI_MODE: Channel Status Register
	// Position of RXRDY field.
	USART_CSR_SPI_MODE_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	USART_CSR_SPI_MODE_RXRDY_Msk = 0x1
	// Bit RXRDY.
	USART_CSR_SPI_MODE_RXRDY = 0x1
	// Position of TXRDY field.
	USART_CSR_SPI_MODE_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	USART_CSR_SPI_MODE_TXRDY_Msk = 0x2
	// Bit TXRDY.
	USART_CSR_SPI_MODE_TXRDY = 0x2
	// Position of OVRE field.
	USART_CSR_SPI_MODE_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	USART_CSR_SPI_MODE_OVRE_Msk = 0x20
	// Bit OVRE.
	USART_CSR_SPI_MODE_OVRE = 0x20
	// Position of TXEMPTY field.
	USART_CSR_SPI_MODE_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	USART_CSR_SPI_MODE_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	USART_CSR_SPI_MODE_TXEMPTY = 0x200
	// Position of UNRE field.
	USART_CSR_SPI_MODE_UNRE_Pos = 0xa
	// Bit mask of UNRE field.
	USART_CSR_SPI_MODE_UNRE_Msk = 0x400
	// Bit UNRE.
	USART_CSR_SPI_MODE_UNRE = 0x400

	// RHR: Receiver Holding Register
	// Position of RXCHR field.
	USART_RHR_RXCHR_Pos = 0x0
	// Bit mask of RXCHR field.
	USART_RHR_RXCHR_Msk = 0x1ff
	// Position of RXSYNH field.
	USART_RHR_RXSYNH_Pos = 0xf
	// Bit mask of RXSYNH field.
	USART_RHR_RXSYNH_Msk = 0x8000
	// Bit RXSYNH.
	USART_RHR_RXSYNH = 0x8000

	// THR: Transmitter Holding Register
	// Position of TXCHR field.
	USART_THR_TXCHR_Pos = 0x0
	// Bit mask of TXCHR field.
	USART_THR_TXCHR_Msk = 0x1ff
	// Position of TXSYNH field.
	USART_THR_TXSYNH_Pos = 0xf
	// Bit mask of TXSYNH field.
	USART_THR_TXSYNH_Msk = 0x8000
	// Bit TXSYNH.
	USART_THR_TXSYNH = 0x8000

	// BRGR: Baud Rate Generator Register
	// Position of CD field.
	USART_BRGR_CD_Pos = 0x0
	// Bit mask of CD field.
	USART_BRGR_CD_Msk = 0xffff
	// Position of FP field.
	USART_BRGR_FP_Pos = 0x10
	// Bit mask of FP field.
	USART_BRGR_FP_Msk = 0x70000

	// RTOR: Receiver Time-out Register
	// Position of TO field.
	USART_RTOR_TO_Pos = 0x0
	// Bit mask of TO field.
	USART_RTOR_TO_Msk = 0xffff

	// TTGR: Transmitter Timeguard Register
	// Position of TG field.
	USART_TTGR_TG_Pos = 0x0
	// Bit mask of TG field.
	USART_TTGR_TG_Msk = 0xff

	// FIDI: FI DI Ratio Register
	// Position of FI_DI_RATIO field.
	USART_FIDI_FI_DI_RATIO_Pos = 0x0
	// Bit mask of FI_DI_RATIO field.
	USART_FIDI_FI_DI_RATIO_Msk = 0x7ff

	// NER: Number of Errors Register
	// Position of NB_ERRORS field.
	USART_NER_NB_ERRORS_Pos = 0x0
	// Bit mask of NB_ERRORS field.
	USART_NER_NB_ERRORS_Msk = 0xff

	// IF: IrDA Filter Register
	// Position of IRDA_FILTER field.
	USART_IF_IRDA_FILTER_Pos = 0x0
	// Bit mask of IRDA_FILTER field.
	USART_IF_IRDA_FILTER_Msk = 0xff

	// MAN: Manchester Encoder Decoder Register
	// Position of TX_PL field.
	USART_MAN_TX_PL_Pos = 0x0
	// Bit mask of TX_PL field.
	USART_MAN_TX_PL_Msk = 0xf
	// Position of TX_PP field.
	USART_MAN_TX_PP_Pos = 0x8
	// Bit mask of TX_PP field.
	USART_MAN_TX_PP_Msk = 0x300
	// The preamble is composed of '1's
	USART_MAN_TX_PP_ALL_ONE = 0x0
	// The preamble is composed of '0's
	USART_MAN_TX_PP_ALL_ZERO = 0x1
	// The preamble is composed of '01's
	USART_MAN_TX_PP_ZERO_ONE = 0x2
	// The preamble is composed of '10's
	USART_MAN_TX_PP_ONE_ZERO = 0x3
	// Position of TX_MPOL field.
	USART_MAN_TX_MPOL_Pos = 0xc
	// Bit mask of TX_MPOL field.
	USART_MAN_TX_MPOL_Msk = 0x1000
	// Bit TX_MPOL.
	USART_MAN_TX_MPOL = 0x1000
	// Position of RX_PL field.
	USART_MAN_RX_PL_Pos = 0x10
	// Bit mask of RX_PL field.
	USART_MAN_RX_PL_Msk = 0xf0000
	// Position of RX_PP field.
	USART_MAN_RX_PP_Pos = 0x18
	// Bit mask of RX_PP field.
	USART_MAN_RX_PP_Msk = 0x3000000
	// The preamble is composed of '1's
	USART_MAN_RX_PP_ALL_ONE = 0x0
	// The preamble is composed of '0's
	USART_MAN_RX_PP_ALL_ZERO = 0x1
	// The preamble is composed of '01's
	USART_MAN_RX_PP_ZERO_ONE = 0x2
	// The preamble is composed of '10's
	USART_MAN_RX_PP_ONE_ZERO = 0x3
	// Position of RX_MPOL field.
	USART_MAN_RX_MPOL_Pos = 0x1c
	// Bit mask of RX_MPOL field.
	USART_MAN_RX_MPOL_Msk = 0x10000000
	// Bit RX_MPOL.
	USART_MAN_RX_MPOL = 0x10000000
	// Position of ONE field.
	USART_MAN_ONE_Pos = 0x1d
	// Bit mask of ONE field.
	USART_MAN_ONE_Msk = 0x20000000
	// Bit ONE.
	USART_MAN_ONE = 0x20000000
	// Position of DRIFT field.
	USART_MAN_DRIFT_Pos = 0x1e
	// Bit mask of DRIFT field.
	USART_MAN_DRIFT_Msk = 0x40000000
	// Bit DRIFT.
	USART_MAN_DRIFT = 0x40000000

	// WPMR: Write Protect Mode Register
	// Position of WPEN field.
	USART_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	USART_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	USART_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	USART_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	USART_WPMR_WPKEY_Msk = 0xffffff00

	// WPSR: Write Protect Status Register
	// Position of WPVS field.
	USART_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	USART_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	USART_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	USART_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	USART_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for UART0: Universal Asynchronous Receiver Transmitter 0
const (
	// CR: Control Register
	// Position of RSTRX field.
	UART_CR_RSTRX_Pos = 0x2
	// Bit mask of RSTRX field.
	UART_CR_RSTRX_Msk = 0x4
	// Bit RSTRX.
	UART_CR_RSTRX = 0x4
	// Position of RSTTX field.
	UART_CR_RSTTX_Pos = 0x3
	// Bit mask of RSTTX field.
	UART_CR_RSTTX_Msk = 0x8
	// Bit RSTTX.
	UART_CR_RSTTX = 0x8
	// Position of RXEN field.
	UART_CR_RXEN_Pos = 0x4
	// Bit mask of RXEN field.
	UART_CR_RXEN_Msk = 0x10
	// Bit RXEN.
	UART_CR_RXEN = 0x10
	// Position of RXDIS field.
	UART_CR_RXDIS_Pos = 0x5
	// Bit mask of RXDIS field.
	UART_CR_RXDIS_Msk = 0x20
	// Bit RXDIS.
	UART_CR_RXDIS = 0x20
	// Position of TXEN field.
	UART_CR_TXEN_Pos = 0x6
	// Bit mask of TXEN field.
	UART_CR_TXEN_Msk = 0x40
	// Bit TXEN.
	UART_CR_TXEN = 0x40
	// Position of TXDIS field.
	UART_CR_TXDIS_Pos = 0x7
	// Bit mask of TXDIS field.
	UART_CR_TXDIS_Msk = 0x80
	// Bit TXDIS.
	UART_CR_TXDIS = 0x80
	// Position of RSTSTA field.
	UART_CR_RSTSTA_Pos = 0x8
	// Bit mask of RSTSTA field.
	UART_CR_RSTSTA_Msk = 0x100
	// Bit RSTSTA.
	UART_CR_RSTSTA = 0x100

	// MR: Mode Register
	// Position of PAR field.
	UART_MR_PAR_Pos = 0x9
	// Bit mask of PAR field.
	UART_MR_PAR_Msk = 0xe00
	// Even Parity
	UART_MR_PAR_EVEN = 0x0
	// Odd Parity
	UART_MR_PAR_ODD = 0x1
	// Space: parity forced to 0
	UART_MR_PAR_SPACE = 0x2
	// Mark: parity forced to 1
	UART_MR_PAR_MARK = 0x3
	// No Parity
	UART_MR_PAR_NO = 0x4
	// Position of CHMODE field.
	UART_MR_CHMODE_Pos = 0xe
	// Bit mask of CHMODE field.
	UART_MR_CHMODE_Msk = 0xc000
	// Normal Mode
	UART_MR_CHMODE_NORMAL = 0x0
	// Automatic Echo
	UART_MR_CHMODE_AUTOMATIC = 0x1
	// Local Loopback
	UART_MR_CHMODE_LOCAL_LOOPBACK = 0x2
	// Remote Loopback
	UART_MR_CHMODE_REMOTE_LOOPBACK = 0x3

	// IER: Interrupt Enable Register
	// Position of RXRDY field.
	UART_IER_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	UART_IER_RXRDY_Msk = 0x1
	// Bit RXRDY.
	UART_IER_RXRDY = 0x1
	// Position of TXRDY field.
	UART_IER_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	UART_IER_TXRDY_Msk = 0x2
	// Bit TXRDY.
	UART_IER_TXRDY = 0x2
	// Position of OVRE field.
	UART_IER_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	UART_IER_OVRE_Msk = 0x20
	// Bit OVRE.
	UART_IER_OVRE = 0x20
	// Position of FRAME field.
	UART_IER_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	UART_IER_FRAME_Msk = 0x40
	// Bit FRAME.
	UART_IER_FRAME = 0x40
	// Position of PARE field.
	UART_IER_PARE_Pos = 0x7
	// Bit mask of PARE field.
	UART_IER_PARE_Msk = 0x80
	// Bit PARE.
	UART_IER_PARE = 0x80
	// Position of TXEMPTY field.
	UART_IER_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	UART_IER_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	UART_IER_TXEMPTY = 0x200

	// IDR: Interrupt Disable Register
	// Position of RXRDY field.
	UART_IDR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	UART_IDR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	UART_IDR_RXRDY = 0x1
	// Position of TXRDY field.
	UART_IDR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	UART_IDR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	UART_IDR_TXRDY = 0x2
	// Position of OVRE field.
	UART_IDR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	UART_IDR_OVRE_Msk = 0x20
	// Bit OVRE.
	UART_IDR_OVRE = 0x20
	// Position of FRAME field.
	UART_IDR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	UART_IDR_FRAME_Msk = 0x40
	// Bit FRAME.
	UART_IDR_FRAME = 0x40
	// Position of PARE field.
	UART_IDR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	UART_IDR_PARE_Msk = 0x80
	// Bit PARE.
	UART_IDR_PARE = 0x80
	// Position of TXEMPTY field.
	UART_IDR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	UART_IDR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	UART_IDR_TXEMPTY = 0x200

	// IMR: Interrupt Mask Register
	// Position of RXRDY field.
	UART_IMR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	UART_IMR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	UART_IMR_RXRDY = 0x1
	// Position of TXRDY field.
	UART_IMR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	UART_IMR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	UART_IMR_TXRDY = 0x2
	// Position of OVRE field.
	UART_IMR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	UART_IMR_OVRE_Msk = 0x20
	// Bit OVRE.
	UART_IMR_OVRE = 0x20
	// Position of FRAME field.
	UART_IMR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	UART_IMR_FRAME_Msk = 0x40
	// Bit FRAME.
	UART_IMR_FRAME = 0x40
	// Position of PARE field.
	UART_IMR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	UART_IMR_PARE_Msk = 0x80
	// Bit PARE.
	UART_IMR_PARE = 0x80
	// Position of TXEMPTY field.
	UART_IMR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	UART_IMR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	UART_IMR_TXEMPTY = 0x200

	// SR: Status Register
	// Position of RXRDY field.
	UART_SR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	UART_SR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	UART_SR_RXRDY = 0x1
	// Position of TXRDY field.
	UART_SR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	UART_SR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	UART_SR_TXRDY = 0x2
	// Position of OVRE field.
	UART_SR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	UART_SR_OVRE_Msk = 0x20
	// Bit OVRE.
	UART_SR_OVRE = 0x20
	// Position of FRAME field.
	UART_SR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	UART_SR_FRAME_Msk = 0x40
	// Bit FRAME.
	UART_SR_FRAME = 0x40
	// Position of PARE field.
	UART_SR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	UART_SR_PARE_Msk = 0x80
	// Bit PARE.
	UART_SR_PARE = 0x80
	// Position of TXEMPTY field.
	UART_SR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	UART_SR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	UART_SR_TXEMPTY = 0x200

	// RHR: Receive Holding Register
	// Position of RXCHR field.
	UART_RHR_RXCHR_Pos = 0x0
	// Bit mask of RXCHR field.
	UART_RHR_RXCHR_Msk = 0xff

	// THR: Transmit Holding Register
	// Position of TXCHR field.
	UART_THR_TXCHR_Pos = 0x0
	// Bit mask of TXCHR field.
	UART_THR_TXCHR_Msk = 0xff

	// BRGR: Baud Rate Generator Register
	// Position of CD field.
	UART_BRGR_CD_Pos = 0x0
	// Bit mask of CD field.
	UART_BRGR_CD_Msk = 0xffff
)

// Constants for GMAC: Gigabit Ethernet MAC
const (
	// NCR: Network Control Register
	// Position of LB field.
	GMAC_NCR_LB_Pos = 0x0
	// Bit mask of LB field.
	GMAC_NCR_LB_Msk = 0x1
	// Bit LB.
	GMAC_NCR_LB = 0x1
	// Position of LBL field.
	GMAC_NCR_LBL_Pos = 0x1
	// Bit mask of LBL field.
	GMAC_NCR_LBL_Msk = 0x2
	// Bit LBL.
	GMAC_NCR_LBL = 0x2
	// Position of RXEN field.
	GMAC_NCR_RXEN_Pos = 0x2
	// Bit mask of RXEN field.
	GMAC_NCR_RXEN_Msk = 0x4
	// Bit RXEN.
	GMAC_NCR_RXEN = 0x4
	// Position of TXEN field.
	GMAC_NCR_TXEN_Pos = 0x3
	// Bit mask of TXEN field.
	GMAC_NCR_TXEN_Msk = 0x8
	// Bit TXEN.
	GMAC_NCR_TXEN = 0x8
	// Position of MPE field.
	GMAC_NCR_MPE_Pos = 0x4
	// Bit mask of MPE field.
	GMAC_NCR_MPE_Msk = 0x10
	// Bit MPE.
	GMAC_NCR_MPE = 0x10
	// Position of CLRSTAT field.
	GMAC_NCR_CLRSTAT_Pos = 0x5
	// Bit mask of CLRSTAT field.
	GMAC_NCR_CLRSTAT_Msk = 0x20
	// Bit CLRSTAT.
	GMAC_NCR_CLRSTAT = 0x20
	// Position of INCSTAT field.
	GMAC_NCR_INCSTAT_Pos = 0x6
	// Bit mask of INCSTAT field.
	GMAC_NCR_INCSTAT_Msk = 0x40
	// Bit INCSTAT.
	GMAC_NCR_INCSTAT = 0x40
	// Position of WESTAT field.
	GMAC_NCR_WESTAT_Pos = 0x7
	// Bit mask of WESTAT field.
	GMAC_NCR_WESTAT_Msk = 0x80
	// Bit WESTAT.
	GMAC_NCR_WESTAT = 0x80
	// Position of BP field.
	GMAC_NCR_BP_Pos = 0x8
	// Bit mask of BP field.
	GMAC_NCR_BP_Msk = 0x100
	// Bit BP.
	GMAC_NCR_BP = 0x100
	// Position of TSTART field.
	GMAC_NCR_TSTART_Pos = 0x9
	// Bit mask of TSTART field.
	GMAC_NCR_TSTART_Msk = 0x200
	// Bit TSTART.
	GMAC_NCR_TSTART = 0x200
	// Position of THALT field.
	GMAC_NCR_THALT_Pos = 0xa
	// Bit mask of THALT field.
	GMAC_NCR_THALT_Msk = 0x400
	// Bit THALT.
	GMAC_NCR_THALT = 0x400
	// Position of TXPF field.
	GMAC_NCR_TXPF_Pos = 0xb
	// Bit mask of TXPF field.
	GMAC_NCR_TXPF_Msk = 0x800
	// Bit TXPF.
	GMAC_NCR_TXPF = 0x800
	// Position of TXZQPF field.
	GMAC_NCR_TXZQPF_Pos = 0xc
	// Bit mask of TXZQPF field.
	GMAC_NCR_TXZQPF_Msk = 0x1000
	// Bit TXZQPF.
	GMAC_NCR_TXZQPF = 0x1000
	// Position of RDS field.
	GMAC_NCR_RDS_Pos = 0xe
	// Bit mask of RDS field.
	GMAC_NCR_RDS_Msk = 0x4000
	// Bit RDS.
	GMAC_NCR_RDS = 0x4000
	// Position of SRTSM field.
	GMAC_NCR_SRTSM_Pos = 0xf
	// Bit mask of SRTSM field.
	GMAC_NCR_SRTSM_Msk = 0x8000
	// Bit SRTSM.
	GMAC_NCR_SRTSM = 0x8000
	// Position of ENPBPR field.
	GMAC_NCR_ENPBPR_Pos = 0x10
	// Bit mask of ENPBPR field.
	GMAC_NCR_ENPBPR_Msk = 0x10000
	// Bit ENPBPR.
	GMAC_NCR_ENPBPR = 0x10000
	// Position of TXPBPF field.
	GMAC_NCR_TXPBPF_Pos = 0x11
	// Bit mask of TXPBPF field.
	GMAC_NCR_TXPBPF_Msk = 0x20000
	// Bit TXPBPF.
	GMAC_NCR_TXPBPF = 0x20000
	// Position of FNP field.
	GMAC_NCR_FNP_Pos = 0x12
	// Bit mask of FNP field.
	GMAC_NCR_FNP_Msk = 0x40000
	// Bit FNP.
	GMAC_NCR_FNP = 0x40000

	// NCFGR: Network Configuration Register
	// Position of SPD field.
	GMAC_NCFGR_SPD_Pos = 0x0
	// Bit mask of SPD field.
	GMAC_NCFGR_SPD_Msk = 0x1
	// Bit SPD.
	GMAC_NCFGR_SPD = 0x1
	// Position of FD field.
	GMAC_NCFGR_FD_Pos = 0x1
	// Bit mask of FD field.
	GMAC_NCFGR_FD_Msk = 0x2
	// Bit FD.
	GMAC_NCFGR_FD = 0x2
	// Position of DNVLAN field.
	GMAC_NCFGR_DNVLAN_Pos = 0x2
	// Bit mask of DNVLAN field.
	GMAC_NCFGR_DNVLAN_Msk = 0x4
	// Bit DNVLAN.
	GMAC_NCFGR_DNVLAN = 0x4
	// Position of JFRAME field.
	GMAC_NCFGR_JFRAME_Pos = 0x3
	// Bit mask of JFRAME field.
	GMAC_NCFGR_JFRAME_Msk = 0x8
	// Bit JFRAME.
	GMAC_NCFGR_JFRAME = 0x8
	// Position of CAF field.
	GMAC_NCFGR_CAF_Pos = 0x4
	// Bit mask of CAF field.
	GMAC_NCFGR_CAF_Msk = 0x10
	// Bit CAF.
	GMAC_NCFGR_CAF = 0x10
	// Position of NBC field.
	GMAC_NCFGR_NBC_Pos = 0x5
	// Bit mask of NBC field.
	GMAC_NCFGR_NBC_Msk = 0x20
	// Bit NBC.
	GMAC_NCFGR_NBC = 0x20
	// Position of MTIHEN field.
	GMAC_NCFGR_MTIHEN_Pos = 0x6
	// Bit mask of MTIHEN field.
	GMAC_NCFGR_MTIHEN_Msk = 0x40
	// Bit MTIHEN.
	GMAC_NCFGR_MTIHEN = 0x40
	// Position of UNIHEN field.
	GMAC_NCFGR_UNIHEN_Pos = 0x7
	// Bit mask of UNIHEN field.
	GMAC_NCFGR_UNIHEN_Msk = 0x80
	// Bit UNIHEN.
	GMAC_NCFGR_UNIHEN = 0x80
	// Position of MAXFS field.
	GMAC_NCFGR_MAXFS_Pos = 0x8
	// Bit mask of MAXFS field.
	GMAC_NCFGR_MAXFS_Msk = 0x100
	// Bit MAXFS.
	GMAC_NCFGR_MAXFS = 0x100
	// Position of GBE field.
	GMAC_NCFGR_GBE_Pos = 0xa
	// Bit mask of GBE field.
	GMAC_NCFGR_GBE_Msk = 0x400
	// Bit GBE.
	GMAC_NCFGR_GBE = 0x400
	// Position of PIS field.
	GMAC_NCFGR_PIS_Pos = 0xb
	// Bit mask of PIS field.
	GMAC_NCFGR_PIS_Msk = 0x800
	// Bit PIS.
	GMAC_NCFGR_PIS = 0x800
	// Position of RTY field.
	GMAC_NCFGR_RTY_Pos = 0xc
	// Bit mask of RTY field.
	GMAC_NCFGR_RTY_Msk = 0x1000
	// Bit RTY.
	GMAC_NCFGR_RTY = 0x1000
	// Position of PEN field.
	GMAC_NCFGR_PEN_Pos = 0xd
	// Bit mask of PEN field.
	GMAC_NCFGR_PEN_Msk = 0x2000
	// Bit PEN.
	GMAC_NCFGR_PEN = 0x2000
	// Position of RXBUFO field.
	GMAC_NCFGR_RXBUFO_Pos = 0xe
	// Bit mask of RXBUFO field.
	GMAC_NCFGR_RXBUFO_Msk = 0xc000
	// Position of LFERD field.
	GMAC_NCFGR_LFERD_Pos = 0x10
	// Bit mask of LFERD field.
	GMAC_NCFGR_LFERD_Msk = 0x10000
	// Bit LFERD.
	GMAC_NCFGR_LFERD = 0x10000
	// Position of RFCS field.
	GMAC_NCFGR_RFCS_Pos = 0x11
	// Bit mask of RFCS field.
	GMAC_NCFGR_RFCS_Msk = 0x20000
	// Bit RFCS.
	GMAC_NCFGR_RFCS = 0x20000
	// Position of CLK field.
	GMAC_NCFGR_CLK_Pos = 0x12
	// Bit mask of CLK field.
	GMAC_NCFGR_CLK_Msk = 0x1c0000
	// MCK divided by 8 (MCK up to 20 MHz)
	GMAC_NCFGR_CLK_MCK_8 = 0x0
	// MCK divided by 16 (MCK up to 40 MHz)
	GMAC_NCFGR_CLK_MCK_16 = 0x1
	// MCK divided by 32 (MCK up to 80 MHz)
	GMAC_NCFGR_CLK_MCK_32 = 0x2
	// MCK divided by 48 (MCK up to 120MHz)
	GMAC_NCFGR_CLK_MCK_48 = 0x3
	// MCK divided by 64 (MCK up to 160 MHz)
	GMAC_NCFGR_CLK_MCK_64 = 0x4
	// MCK divided by 96 (MCK up to 240 MHz)
	GMAC_NCFGR_CLK_MCK_96 = 0x5
	// MCK divided by 128 (MCK up to 320 MHz)
	GMAC_NCFGR_CLK_MCK_128 = 0x6
	// MCK divided by 224 (MCK up to 540 MHz)
	GMAC_NCFGR_CLK_MCK_224 = 0x7
	// Position of DBW field.
	GMAC_NCFGR_DBW_Pos = 0x15
	// Bit mask of DBW field.
	GMAC_NCFGR_DBW_Msk = 0x600000
	// 32-bit data bus width
	GMAC_NCFGR_DBW_DBW32 = 0x0
	// 64-bit data bus width
	GMAC_NCFGR_DBW_DBW64 = 0x1
	// Position of DCPF field.
	GMAC_NCFGR_DCPF_Pos = 0x17
	// Bit mask of DCPF field.
	GMAC_NCFGR_DCPF_Msk = 0x800000
	// Bit DCPF.
	GMAC_NCFGR_DCPF = 0x800000
	// Position of RXCOEN field.
	GMAC_NCFGR_RXCOEN_Pos = 0x18
	// Bit mask of RXCOEN field.
	GMAC_NCFGR_RXCOEN_Msk = 0x1000000
	// Bit RXCOEN.
	GMAC_NCFGR_RXCOEN = 0x1000000
	// Position of EFRHD field.
	GMAC_NCFGR_EFRHD_Pos = 0x19
	// Bit mask of EFRHD field.
	GMAC_NCFGR_EFRHD_Msk = 0x2000000
	// Bit EFRHD.
	GMAC_NCFGR_EFRHD = 0x2000000
	// Position of IRXFCS field.
	GMAC_NCFGR_IRXFCS_Pos = 0x1a
	// Bit mask of IRXFCS field.
	GMAC_NCFGR_IRXFCS_Msk = 0x4000000
	// Bit IRXFCS.
	GMAC_NCFGR_IRXFCS = 0x4000000
	// Position of IPGSEN field.
	GMAC_NCFGR_IPGSEN_Pos = 0x1c
	// Bit mask of IPGSEN field.
	GMAC_NCFGR_IPGSEN_Msk = 0x10000000
	// Bit IPGSEN.
	GMAC_NCFGR_IPGSEN = 0x10000000
	// Position of RXBP field.
	GMAC_NCFGR_RXBP_Pos = 0x1d
	// Bit mask of RXBP field.
	GMAC_NCFGR_RXBP_Msk = 0x20000000
	// Bit RXBP.
	GMAC_NCFGR_RXBP = 0x20000000
	// Position of IRXER field.
	GMAC_NCFGR_IRXER_Pos = 0x1e
	// Bit mask of IRXER field.
	GMAC_NCFGR_IRXER_Msk = 0x40000000
	// Bit IRXER.
	GMAC_NCFGR_IRXER = 0x40000000

	// NSR: Network Status Register
	// Position of MDIO field.
	GMAC_NSR_MDIO_Pos = 0x1
	// Bit mask of MDIO field.
	GMAC_NSR_MDIO_Msk = 0x2
	// Bit MDIO.
	GMAC_NSR_MDIO = 0x2
	// Position of IDLE field.
	GMAC_NSR_IDLE_Pos = 0x2
	// Bit mask of IDLE field.
	GMAC_NSR_IDLE_Msk = 0x4
	// Bit IDLE.
	GMAC_NSR_IDLE = 0x4

	// UR: User Register
	// Position of RGMII field.
	GMAC_UR_RGMII_Pos = 0x0
	// Bit mask of RGMII field.
	GMAC_UR_RGMII_Msk = 0x1
	// Bit RGMII.
	GMAC_UR_RGMII = 0x1
	// Position of HDFC field.
	GMAC_UR_HDFC_Pos = 0x6
	// Bit mask of HDFC field.
	GMAC_UR_HDFC_Msk = 0x40
	// Bit HDFC.
	GMAC_UR_HDFC = 0x40
	// Position of BPDG field.
	GMAC_UR_BPDG_Pos = 0x7
	// Bit mask of BPDG field.
	GMAC_UR_BPDG_Msk = 0x80
	// Bit BPDG.
	GMAC_UR_BPDG = 0x80

	// DCFGR: DMA Configuration Register
	// Position of FBLDO field.
	GMAC_DCFGR_FBLDO_Pos = 0x0
	// Bit mask of FBLDO field.
	GMAC_DCFGR_FBLDO_Msk = 0x1f
	// 00001: Always use SINGLE AHB bursts
	GMAC_DCFGR_FBLDO_SINGLE = 0x1
	// 001xx: Attempt to use INCR4 AHB bursts (Default)
	GMAC_DCFGR_FBLDO_INCR4 = 0x4
	// 01xxx: Attempt to use INCR8 AHB bursts
	GMAC_DCFGR_FBLDO_INCR8 = 0x8
	// 1xxxx: Attempt to use INCR16 AHB bursts
	GMAC_DCFGR_FBLDO_INCR16 = 0x10
	// Position of ESMA field.
	GMAC_DCFGR_ESMA_Pos = 0x6
	// Bit mask of ESMA field.
	GMAC_DCFGR_ESMA_Msk = 0x40
	// Bit ESMA.
	GMAC_DCFGR_ESMA = 0x40
	// Position of ESPA field.
	GMAC_DCFGR_ESPA_Pos = 0x7
	// Bit mask of ESPA field.
	GMAC_DCFGR_ESPA_Msk = 0x80
	// Bit ESPA.
	GMAC_DCFGR_ESPA = 0x80
	// Position of RXBMS field.
	GMAC_DCFGR_RXBMS_Pos = 0x8
	// Bit mask of RXBMS field.
	GMAC_DCFGR_RXBMS_Msk = 0x300
	// 1 Kbyte Memory Size
	GMAC_DCFGR_RXBMS_EIGHTH = 0x0
	// 2 Kbytes Memory Size
	GMAC_DCFGR_RXBMS_QUARTER = 0x1
	// 4 Kbytes Memory Size
	GMAC_DCFGR_RXBMS_HALF = 0x2
	// 8 Kbytes Memory Size
	GMAC_DCFGR_RXBMS_FULL = 0x3
	// Position of TXPBMS field.
	GMAC_DCFGR_TXPBMS_Pos = 0xa
	// Bit mask of TXPBMS field.
	GMAC_DCFGR_TXPBMS_Msk = 0x400
	// Bit TXPBMS.
	GMAC_DCFGR_TXPBMS = 0x400
	// Position of TXCOEN field.
	GMAC_DCFGR_TXCOEN_Pos = 0xb
	// Bit mask of TXCOEN field.
	GMAC_DCFGR_TXCOEN_Msk = 0x800
	// Bit TXCOEN.
	GMAC_DCFGR_TXCOEN = 0x800
	// Position of DRBS field.
	GMAC_DCFGR_DRBS_Pos = 0x10
	// Bit mask of DRBS field.
	GMAC_DCFGR_DRBS_Msk = 0xff0000
	// Position of DDRP field.
	GMAC_DCFGR_DDRP_Pos = 0x18
	// Bit mask of DDRP field.
	GMAC_DCFGR_DDRP_Msk = 0x1000000
	// Bit DDRP.
	GMAC_DCFGR_DDRP = 0x1000000

	// TSR: Transmit Status Register
	// Position of UBR field.
	GMAC_TSR_UBR_Pos = 0x0
	// Bit mask of UBR field.
	GMAC_TSR_UBR_Msk = 0x1
	// Bit UBR.
	GMAC_TSR_UBR = 0x1
	// Position of COL field.
	GMAC_TSR_COL_Pos = 0x1
	// Bit mask of COL field.
	GMAC_TSR_COL_Msk = 0x2
	// Bit COL.
	GMAC_TSR_COL = 0x2
	// Position of RLE field.
	GMAC_TSR_RLE_Pos = 0x2
	// Bit mask of RLE field.
	GMAC_TSR_RLE_Msk = 0x4
	// Bit RLE.
	GMAC_TSR_RLE = 0x4
	// Position of TXGO field.
	GMAC_TSR_TXGO_Pos = 0x3
	// Bit mask of TXGO field.
	GMAC_TSR_TXGO_Msk = 0x8
	// Bit TXGO.
	GMAC_TSR_TXGO = 0x8
	// Position of TFC field.
	GMAC_TSR_TFC_Pos = 0x4
	// Bit mask of TFC field.
	GMAC_TSR_TFC_Msk = 0x10
	// Bit TFC.
	GMAC_TSR_TFC = 0x10
	// Position of TXCOMP field.
	GMAC_TSR_TXCOMP_Pos = 0x5
	// Bit mask of TXCOMP field.
	GMAC_TSR_TXCOMP_Msk = 0x20
	// Bit TXCOMP.
	GMAC_TSR_TXCOMP = 0x20
	// Position of UND field.
	GMAC_TSR_UND_Pos = 0x6
	// Bit mask of UND field.
	GMAC_TSR_UND_Msk = 0x40
	// Bit UND.
	GMAC_TSR_UND = 0x40
	// Position of LCO field.
	GMAC_TSR_LCO_Pos = 0x7
	// Bit mask of LCO field.
	GMAC_TSR_LCO_Msk = 0x80
	// Bit LCO.
	GMAC_TSR_LCO = 0x80
	// Position of HRESP field.
	GMAC_TSR_HRESP_Pos = 0x8
	// Bit mask of HRESP field.
	GMAC_TSR_HRESP_Msk = 0x100
	// Bit HRESP.
	GMAC_TSR_HRESP = 0x100

	// RBQB: Receive Buffer Queue Base Address
	// Position of ADDR field.
	GMAC_RBQB_ADDR_Pos = 0x2
	// Bit mask of ADDR field.
	GMAC_RBQB_ADDR_Msk = 0xfffffffc

	// TBQB: Transmit Buffer Queue Base Address
	// Position of ADDR field.
	GMAC_TBQB_ADDR_Pos = 0x2
	// Bit mask of ADDR field.
	GMAC_TBQB_ADDR_Msk = 0xfffffffc

	// RSR: Receive Status Register
	// Position of BNA field.
	GMAC_RSR_BNA_Pos = 0x0
	// Bit mask of BNA field.
	GMAC_RSR_BNA_Msk = 0x1
	// Bit BNA.
	GMAC_RSR_BNA = 0x1
	// Position of REC field.
	GMAC_RSR_REC_Pos = 0x1
	// Bit mask of REC field.
	GMAC_RSR_REC_Msk = 0x2
	// Bit REC.
	GMAC_RSR_REC = 0x2
	// Position of RXOVR field.
	GMAC_RSR_RXOVR_Pos = 0x2
	// Bit mask of RXOVR field.
	GMAC_RSR_RXOVR_Msk = 0x4
	// Bit RXOVR.
	GMAC_RSR_RXOVR = 0x4
	// Position of HNO field.
	GMAC_RSR_HNO_Pos = 0x3
	// Bit mask of HNO field.
	GMAC_RSR_HNO_Msk = 0x8
	// Bit HNO.
	GMAC_RSR_HNO = 0x8

	// ISR: Interrupt Status Register
	// Position of MFS field.
	GMAC_ISR_MFS_Pos = 0x0
	// Bit mask of MFS field.
	GMAC_ISR_MFS_Msk = 0x1
	// Bit MFS.
	GMAC_ISR_MFS = 0x1
	// Position of RCOMP field.
	GMAC_ISR_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	GMAC_ISR_RCOMP_Msk = 0x2
	// Bit RCOMP.
	GMAC_ISR_RCOMP = 0x2
	// Position of RXUBR field.
	GMAC_ISR_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	GMAC_ISR_RXUBR_Msk = 0x4
	// Bit RXUBR.
	GMAC_ISR_RXUBR = 0x4
	// Position of TXUBR field.
	GMAC_ISR_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	GMAC_ISR_TXUBR_Msk = 0x8
	// Bit TXUBR.
	GMAC_ISR_TXUBR = 0x8
	// Position of TUR field.
	GMAC_ISR_TUR_Pos = 0x4
	// Bit mask of TUR field.
	GMAC_ISR_TUR_Msk = 0x10
	// Bit TUR.
	GMAC_ISR_TUR = 0x10
	// Position of RLEX field.
	GMAC_ISR_RLEX_Pos = 0x5
	// Bit mask of RLEX field.
	GMAC_ISR_RLEX_Msk = 0x20
	// Bit RLEX.
	GMAC_ISR_RLEX = 0x20
	// Position of TFC field.
	GMAC_ISR_TFC_Pos = 0x6
	// Bit mask of TFC field.
	GMAC_ISR_TFC_Msk = 0x40
	// Bit TFC.
	GMAC_ISR_TFC = 0x40
	// Position of TCOMP field.
	GMAC_ISR_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	GMAC_ISR_TCOMP_Msk = 0x80
	// Bit TCOMP.
	GMAC_ISR_TCOMP = 0x80
	// Position of ROVR field.
	GMAC_ISR_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	GMAC_ISR_ROVR_Msk = 0x400
	// Bit ROVR.
	GMAC_ISR_ROVR = 0x400
	// Position of HRESP field.
	GMAC_ISR_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	GMAC_ISR_HRESP_Msk = 0x800
	// Bit HRESP.
	GMAC_ISR_HRESP = 0x800
	// Position of PFNZ field.
	GMAC_ISR_PFNZ_Pos = 0xc
	// Bit mask of PFNZ field.
	GMAC_ISR_PFNZ_Msk = 0x1000
	// Bit PFNZ.
	GMAC_ISR_PFNZ = 0x1000
	// Position of PTZ field.
	GMAC_ISR_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	GMAC_ISR_PTZ_Msk = 0x2000
	// Bit PTZ.
	GMAC_ISR_PTZ = 0x2000
	// Position of PFTR field.
	GMAC_ISR_PFTR_Pos = 0xe
	// Bit mask of PFTR field.
	GMAC_ISR_PFTR_Msk = 0x4000
	// Bit PFTR.
	GMAC_ISR_PFTR = 0x4000
	// Position of EXINT field.
	GMAC_ISR_EXINT_Pos = 0xf
	// Bit mask of EXINT field.
	GMAC_ISR_EXINT_Msk = 0x8000
	// Bit EXINT.
	GMAC_ISR_EXINT = 0x8000
	// Position of DRQFR field.
	GMAC_ISR_DRQFR_Pos = 0x12
	// Bit mask of DRQFR field.
	GMAC_ISR_DRQFR_Msk = 0x40000
	// Bit DRQFR.
	GMAC_ISR_DRQFR = 0x40000
	// Position of SFR field.
	GMAC_ISR_SFR_Pos = 0x13
	// Bit mask of SFR field.
	GMAC_ISR_SFR_Msk = 0x80000
	// Bit SFR.
	GMAC_ISR_SFR = 0x80000
	// Position of DRQFT field.
	GMAC_ISR_DRQFT_Pos = 0x14
	// Bit mask of DRQFT field.
	GMAC_ISR_DRQFT_Msk = 0x100000
	// Bit DRQFT.
	GMAC_ISR_DRQFT = 0x100000
	// Position of SFT field.
	GMAC_ISR_SFT_Pos = 0x15
	// Bit mask of SFT field.
	GMAC_ISR_SFT_Msk = 0x200000
	// Bit SFT.
	GMAC_ISR_SFT = 0x200000
	// Position of PDRQFR field.
	GMAC_ISR_PDRQFR_Pos = 0x16
	// Bit mask of PDRQFR field.
	GMAC_ISR_PDRQFR_Msk = 0x400000
	// Bit PDRQFR.
	GMAC_ISR_PDRQFR = 0x400000
	// Position of PDRSFR field.
	GMAC_ISR_PDRSFR_Pos = 0x17
	// Bit mask of PDRSFR field.
	GMAC_ISR_PDRSFR_Msk = 0x800000
	// Bit PDRSFR.
	GMAC_ISR_PDRSFR = 0x800000
	// Position of PDRQFT field.
	GMAC_ISR_PDRQFT_Pos = 0x18
	// Bit mask of PDRQFT field.
	GMAC_ISR_PDRQFT_Msk = 0x1000000
	// Bit PDRQFT.
	GMAC_ISR_PDRQFT = 0x1000000
	// Position of PDRSFT field.
	GMAC_ISR_PDRSFT_Pos = 0x19
	// Bit mask of PDRSFT field.
	GMAC_ISR_PDRSFT_Msk = 0x2000000
	// Bit PDRSFT.
	GMAC_ISR_PDRSFT = 0x2000000
	// Position of SRI field.
	GMAC_ISR_SRI_Pos = 0x1a
	// Bit mask of SRI field.
	GMAC_ISR_SRI_Msk = 0x4000000
	// Bit SRI.
	GMAC_ISR_SRI = 0x4000000
	// Position of WOL field.
	GMAC_ISR_WOL_Pos = 0x1c
	// Bit mask of WOL field.
	GMAC_ISR_WOL_Msk = 0x10000000
	// Bit WOL.
	GMAC_ISR_WOL = 0x10000000

	// IER: Interrupt Enable Register
	// Position of MFS field.
	GMAC_IER_MFS_Pos = 0x0
	// Bit mask of MFS field.
	GMAC_IER_MFS_Msk = 0x1
	// Bit MFS.
	GMAC_IER_MFS = 0x1
	// Position of RCOMP field.
	GMAC_IER_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	GMAC_IER_RCOMP_Msk = 0x2
	// Bit RCOMP.
	GMAC_IER_RCOMP = 0x2
	// Position of RXUBR field.
	GMAC_IER_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	GMAC_IER_RXUBR_Msk = 0x4
	// Bit RXUBR.
	GMAC_IER_RXUBR = 0x4
	// Position of TXUBR field.
	GMAC_IER_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	GMAC_IER_TXUBR_Msk = 0x8
	// Bit TXUBR.
	GMAC_IER_TXUBR = 0x8
	// Position of TUR field.
	GMAC_IER_TUR_Pos = 0x4
	// Bit mask of TUR field.
	GMAC_IER_TUR_Msk = 0x10
	// Bit TUR.
	GMAC_IER_TUR = 0x10
	// Position of RLEX field.
	GMAC_IER_RLEX_Pos = 0x5
	// Bit mask of RLEX field.
	GMAC_IER_RLEX_Msk = 0x20
	// Bit RLEX.
	GMAC_IER_RLEX = 0x20
	// Position of TFC field.
	GMAC_IER_TFC_Pos = 0x6
	// Bit mask of TFC field.
	GMAC_IER_TFC_Msk = 0x40
	// Bit TFC.
	GMAC_IER_TFC = 0x40
	// Position of TCOMP field.
	GMAC_IER_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	GMAC_IER_TCOMP_Msk = 0x80
	// Bit TCOMP.
	GMAC_IER_TCOMP = 0x80
	// Position of ROVR field.
	GMAC_IER_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	GMAC_IER_ROVR_Msk = 0x400
	// Bit ROVR.
	GMAC_IER_ROVR = 0x400
	// Position of HRESP field.
	GMAC_IER_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	GMAC_IER_HRESP_Msk = 0x800
	// Bit HRESP.
	GMAC_IER_HRESP = 0x800
	// Position of PFNZ field.
	GMAC_IER_PFNZ_Pos = 0xc
	// Bit mask of PFNZ field.
	GMAC_IER_PFNZ_Msk = 0x1000
	// Bit PFNZ.
	GMAC_IER_PFNZ = 0x1000
	// Position of PTZ field.
	GMAC_IER_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	GMAC_IER_PTZ_Msk = 0x2000
	// Bit PTZ.
	GMAC_IER_PTZ = 0x2000
	// Position of PFTR field.
	GMAC_IER_PFTR_Pos = 0xe
	// Bit mask of PFTR field.
	GMAC_IER_PFTR_Msk = 0x4000
	// Bit PFTR.
	GMAC_IER_PFTR = 0x4000
	// Position of EXINT field.
	GMAC_IER_EXINT_Pos = 0xf
	// Bit mask of EXINT field.
	GMAC_IER_EXINT_Msk = 0x8000
	// Bit EXINT.
	GMAC_IER_EXINT = 0x8000
	// Position of DRQFR field.
	GMAC_IER_DRQFR_Pos = 0x12
	// Bit mask of DRQFR field.
	GMAC_IER_DRQFR_Msk = 0x40000
	// Bit DRQFR.
	GMAC_IER_DRQFR = 0x40000
	// Position of SFR field.
	GMAC_IER_SFR_Pos = 0x13
	// Bit mask of SFR field.
	GMAC_IER_SFR_Msk = 0x80000
	// Bit SFR.
	GMAC_IER_SFR = 0x80000
	// Position of DRQFT field.
	GMAC_IER_DRQFT_Pos = 0x14
	// Bit mask of DRQFT field.
	GMAC_IER_DRQFT_Msk = 0x100000
	// Bit DRQFT.
	GMAC_IER_DRQFT = 0x100000
	// Position of SFT field.
	GMAC_IER_SFT_Pos = 0x15
	// Bit mask of SFT field.
	GMAC_IER_SFT_Msk = 0x200000
	// Bit SFT.
	GMAC_IER_SFT = 0x200000
	// Position of PDRQFR field.
	GMAC_IER_PDRQFR_Pos = 0x16
	// Bit mask of PDRQFR field.
	GMAC_IER_PDRQFR_Msk = 0x400000
	// Bit PDRQFR.
	GMAC_IER_PDRQFR = 0x400000
	// Position of PDRSFR field.
	GMAC_IER_PDRSFR_Pos = 0x17
	// Bit mask of PDRSFR field.
	GMAC_IER_PDRSFR_Msk = 0x800000
	// Bit PDRSFR.
	GMAC_IER_PDRSFR = 0x800000
	// Position of PDRQFT field.
	GMAC_IER_PDRQFT_Pos = 0x18
	// Bit mask of PDRQFT field.
	GMAC_IER_PDRQFT_Msk = 0x1000000
	// Bit PDRQFT.
	GMAC_IER_PDRQFT = 0x1000000
	// Position of PDRSFT field.
	GMAC_IER_PDRSFT_Pos = 0x19
	// Bit mask of PDRSFT field.
	GMAC_IER_PDRSFT_Msk = 0x2000000
	// Bit PDRSFT.
	GMAC_IER_PDRSFT = 0x2000000
	// Position of SRI field.
	GMAC_IER_SRI_Pos = 0x1a
	// Bit mask of SRI field.
	GMAC_IER_SRI_Msk = 0x4000000
	// Bit SRI.
	GMAC_IER_SRI = 0x4000000
	// Position of WOL field.
	GMAC_IER_WOL_Pos = 0x1c
	// Bit mask of WOL field.
	GMAC_IER_WOL_Msk = 0x10000000
	// Bit WOL.
	GMAC_IER_WOL = 0x10000000

	// IDR: Interrupt Disable Register
	// Position of MFS field.
	GMAC_IDR_MFS_Pos = 0x0
	// Bit mask of MFS field.
	GMAC_IDR_MFS_Msk = 0x1
	// Bit MFS.
	GMAC_IDR_MFS = 0x1
	// Position of RCOMP field.
	GMAC_IDR_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	GMAC_IDR_RCOMP_Msk = 0x2
	// Bit RCOMP.
	GMAC_IDR_RCOMP = 0x2
	// Position of RXUBR field.
	GMAC_IDR_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	GMAC_IDR_RXUBR_Msk = 0x4
	// Bit RXUBR.
	GMAC_IDR_RXUBR = 0x4
	// Position of TXUBR field.
	GMAC_IDR_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	GMAC_IDR_TXUBR_Msk = 0x8
	// Bit TXUBR.
	GMAC_IDR_TXUBR = 0x8
	// Position of TUR field.
	GMAC_IDR_TUR_Pos = 0x4
	// Bit mask of TUR field.
	GMAC_IDR_TUR_Msk = 0x10
	// Bit TUR.
	GMAC_IDR_TUR = 0x10
	// Position of RLEX field.
	GMAC_IDR_RLEX_Pos = 0x5
	// Bit mask of RLEX field.
	GMAC_IDR_RLEX_Msk = 0x20
	// Bit RLEX.
	GMAC_IDR_RLEX = 0x20
	// Position of TFC field.
	GMAC_IDR_TFC_Pos = 0x6
	// Bit mask of TFC field.
	GMAC_IDR_TFC_Msk = 0x40
	// Bit TFC.
	GMAC_IDR_TFC = 0x40
	// Position of TCOMP field.
	GMAC_IDR_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	GMAC_IDR_TCOMP_Msk = 0x80
	// Bit TCOMP.
	GMAC_IDR_TCOMP = 0x80
	// Position of ROVR field.
	GMAC_IDR_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	GMAC_IDR_ROVR_Msk = 0x400
	// Bit ROVR.
	GMAC_IDR_ROVR = 0x400
	// Position of HRESP field.
	GMAC_IDR_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	GMAC_IDR_HRESP_Msk = 0x800
	// Bit HRESP.
	GMAC_IDR_HRESP = 0x800
	// Position of PFNZ field.
	GMAC_IDR_PFNZ_Pos = 0xc
	// Bit mask of PFNZ field.
	GMAC_IDR_PFNZ_Msk = 0x1000
	// Bit PFNZ.
	GMAC_IDR_PFNZ = 0x1000
	// Position of PTZ field.
	GMAC_IDR_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	GMAC_IDR_PTZ_Msk = 0x2000
	// Bit PTZ.
	GMAC_IDR_PTZ = 0x2000
	// Position of PFTR field.
	GMAC_IDR_PFTR_Pos = 0xe
	// Bit mask of PFTR field.
	GMAC_IDR_PFTR_Msk = 0x4000
	// Bit PFTR.
	GMAC_IDR_PFTR = 0x4000
	// Position of EXINT field.
	GMAC_IDR_EXINT_Pos = 0xf
	// Bit mask of EXINT field.
	GMAC_IDR_EXINT_Msk = 0x8000
	// Bit EXINT.
	GMAC_IDR_EXINT = 0x8000
	// Position of DRQFR field.
	GMAC_IDR_DRQFR_Pos = 0x12
	// Bit mask of DRQFR field.
	GMAC_IDR_DRQFR_Msk = 0x40000
	// Bit DRQFR.
	GMAC_IDR_DRQFR = 0x40000
	// Position of SFR field.
	GMAC_IDR_SFR_Pos = 0x13
	// Bit mask of SFR field.
	GMAC_IDR_SFR_Msk = 0x80000
	// Bit SFR.
	GMAC_IDR_SFR = 0x80000
	// Position of DRQFT field.
	GMAC_IDR_DRQFT_Pos = 0x14
	// Bit mask of DRQFT field.
	GMAC_IDR_DRQFT_Msk = 0x100000
	// Bit DRQFT.
	GMAC_IDR_DRQFT = 0x100000
	// Position of SFT field.
	GMAC_IDR_SFT_Pos = 0x15
	// Bit mask of SFT field.
	GMAC_IDR_SFT_Msk = 0x200000
	// Bit SFT.
	GMAC_IDR_SFT = 0x200000
	// Position of PDRQFR field.
	GMAC_IDR_PDRQFR_Pos = 0x16
	// Bit mask of PDRQFR field.
	GMAC_IDR_PDRQFR_Msk = 0x400000
	// Bit PDRQFR.
	GMAC_IDR_PDRQFR = 0x400000
	// Position of PDRSFR field.
	GMAC_IDR_PDRSFR_Pos = 0x17
	// Bit mask of PDRSFR field.
	GMAC_IDR_PDRSFR_Msk = 0x800000
	// Bit PDRSFR.
	GMAC_IDR_PDRSFR = 0x800000
	// Position of PDRQFT field.
	GMAC_IDR_PDRQFT_Pos = 0x18
	// Bit mask of PDRQFT field.
	GMAC_IDR_PDRQFT_Msk = 0x1000000
	// Bit PDRQFT.
	GMAC_IDR_PDRQFT = 0x1000000
	// Position of PDRSFT field.
	GMAC_IDR_PDRSFT_Pos = 0x19
	// Bit mask of PDRSFT field.
	GMAC_IDR_PDRSFT_Msk = 0x2000000
	// Bit PDRSFT.
	GMAC_IDR_PDRSFT = 0x2000000
	// Position of SRI field.
	GMAC_IDR_SRI_Pos = 0x1a
	// Bit mask of SRI field.
	GMAC_IDR_SRI_Msk = 0x4000000
	// Bit SRI.
	GMAC_IDR_SRI = 0x4000000
	// Position of WOL field.
	GMAC_IDR_WOL_Pos = 0x1c
	// Bit mask of WOL field.
	GMAC_IDR_WOL_Msk = 0x10000000
	// Bit WOL.
	GMAC_IDR_WOL = 0x10000000

	// IMR: Interrupt Mask Register
	// Position of MFS field.
	GMAC_IMR_MFS_Pos = 0x0
	// Bit mask of MFS field.
	GMAC_IMR_MFS_Msk = 0x1
	// Bit MFS.
	GMAC_IMR_MFS = 0x1
	// Position of RCOMP field.
	GMAC_IMR_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	GMAC_IMR_RCOMP_Msk = 0x2
	// Bit RCOMP.
	GMAC_IMR_RCOMP = 0x2
	// Position of RXUBR field.
	GMAC_IMR_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	GMAC_IMR_RXUBR_Msk = 0x4
	// Bit RXUBR.
	GMAC_IMR_RXUBR = 0x4
	// Position of TXUBR field.
	GMAC_IMR_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	GMAC_IMR_TXUBR_Msk = 0x8
	// Bit TXUBR.
	GMAC_IMR_TXUBR = 0x8
	// Position of TUR field.
	GMAC_IMR_TUR_Pos = 0x4
	// Bit mask of TUR field.
	GMAC_IMR_TUR_Msk = 0x10
	// Bit TUR.
	GMAC_IMR_TUR = 0x10
	// Position of RLEX field.
	GMAC_IMR_RLEX_Pos = 0x5
	// Bit mask of RLEX field.
	GMAC_IMR_RLEX_Msk = 0x20
	// Bit RLEX.
	GMAC_IMR_RLEX = 0x20
	// Position of TFC field.
	GMAC_IMR_TFC_Pos = 0x6
	// Bit mask of TFC field.
	GMAC_IMR_TFC_Msk = 0x40
	// Bit TFC.
	GMAC_IMR_TFC = 0x40
	// Position of TCOMP field.
	GMAC_IMR_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	GMAC_IMR_TCOMP_Msk = 0x80
	// Bit TCOMP.
	GMAC_IMR_TCOMP = 0x80
	// Position of ROVR field.
	GMAC_IMR_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	GMAC_IMR_ROVR_Msk = 0x400
	// Bit ROVR.
	GMAC_IMR_ROVR = 0x400
	// Position of HRESP field.
	GMAC_IMR_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	GMAC_IMR_HRESP_Msk = 0x800
	// Bit HRESP.
	GMAC_IMR_HRESP = 0x800
	// Position of PFNZ field.
	GMAC_IMR_PFNZ_Pos = 0xc
	// Bit mask of PFNZ field.
	GMAC_IMR_PFNZ_Msk = 0x1000
	// Bit PFNZ.
	GMAC_IMR_PFNZ = 0x1000
	// Position of PTZ field.
	GMAC_IMR_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	GMAC_IMR_PTZ_Msk = 0x2000
	// Bit PTZ.
	GMAC_IMR_PTZ = 0x2000
	// Position of PFTR field.
	GMAC_IMR_PFTR_Pos = 0xe
	// Bit mask of PFTR field.
	GMAC_IMR_PFTR_Msk = 0x4000
	// Bit PFTR.
	GMAC_IMR_PFTR = 0x4000
	// Position of EXINT field.
	GMAC_IMR_EXINT_Pos = 0xf
	// Bit mask of EXINT field.
	GMAC_IMR_EXINT_Msk = 0x8000
	// Bit EXINT.
	GMAC_IMR_EXINT = 0x8000
	// Position of DRQFR field.
	GMAC_IMR_DRQFR_Pos = 0x12
	// Bit mask of DRQFR field.
	GMAC_IMR_DRQFR_Msk = 0x40000
	// Bit DRQFR.
	GMAC_IMR_DRQFR = 0x40000
	// Position of SFR field.
	GMAC_IMR_SFR_Pos = 0x13
	// Bit mask of SFR field.
	GMAC_IMR_SFR_Msk = 0x80000
	// Bit SFR.
	GMAC_IMR_SFR = 0x80000
	// Position of DRQFT field.
	GMAC_IMR_DRQFT_Pos = 0x14
	// Bit mask of DRQFT field.
	GMAC_IMR_DRQFT_Msk = 0x100000
	// Bit DRQFT.
	GMAC_IMR_DRQFT = 0x100000
	// Position of SFT field.
	GMAC_IMR_SFT_Pos = 0x15
	// Bit mask of SFT field.
	GMAC_IMR_SFT_Msk = 0x200000
	// Bit SFT.
	GMAC_IMR_SFT = 0x200000
	// Position of PDRQFR field.
	GMAC_IMR_PDRQFR_Pos = 0x16
	// Bit mask of PDRQFR field.
	GMAC_IMR_PDRQFR_Msk = 0x400000
	// Bit PDRQFR.
	GMAC_IMR_PDRQFR = 0x400000
	// Position of PDRSFR field.
	GMAC_IMR_PDRSFR_Pos = 0x17
	// Bit mask of PDRSFR field.
	GMAC_IMR_PDRSFR_Msk = 0x800000
	// Bit PDRSFR.
	GMAC_IMR_PDRSFR = 0x800000
	// Position of PDRQFT field.
	GMAC_IMR_PDRQFT_Pos = 0x18
	// Bit mask of PDRQFT field.
	GMAC_IMR_PDRQFT_Msk = 0x1000000
	// Bit PDRQFT.
	GMAC_IMR_PDRQFT = 0x1000000
	// Position of PDRSFT field.
	GMAC_IMR_PDRSFT_Pos = 0x19
	// Bit mask of PDRSFT field.
	GMAC_IMR_PDRSFT_Msk = 0x2000000
	// Bit PDRSFT.
	GMAC_IMR_PDRSFT = 0x2000000

	// MAN: PHY Maintenance Register
	// Position of DATA field.
	GMAC_MAN_DATA_Pos = 0x0
	// Bit mask of DATA field.
	GMAC_MAN_DATA_Msk = 0xffff
	// Position of WTN field.
	GMAC_MAN_WTN_Pos = 0x10
	// Bit mask of WTN field.
	GMAC_MAN_WTN_Msk = 0x30000
	// Position of REGA field.
	GMAC_MAN_REGA_Pos = 0x12
	// Bit mask of REGA field.
	GMAC_MAN_REGA_Msk = 0x7c0000
	// Position of PHYA field.
	GMAC_MAN_PHYA_Pos = 0x17
	// Bit mask of PHYA field.
	GMAC_MAN_PHYA_Msk = 0xf800000
	// Position of OP field.
	GMAC_MAN_OP_Pos = 0x1c
	// Bit mask of OP field.
	GMAC_MAN_OP_Msk = 0x30000000
	// Position of CLTTO field.
	GMAC_MAN_CLTTO_Pos = 0x1e
	// Bit mask of CLTTO field.
	GMAC_MAN_CLTTO_Msk = 0x40000000
	// Bit CLTTO.
	GMAC_MAN_CLTTO = 0x40000000
	// Position of WZO field.
	GMAC_MAN_WZO_Pos = 0x1f
	// Bit mask of WZO field.
	GMAC_MAN_WZO_Msk = 0x80000000
	// Bit WZO.
	GMAC_MAN_WZO = 0x80000000

	// RPQ: Received Pause Quantum Register
	// Position of RPQ field.
	GMAC_RPQ_RPQ_Pos = 0x0
	// Bit mask of RPQ field.
	GMAC_RPQ_RPQ_Msk = 0xffff

	// TPQ: Transmit Pause Quantum Register
	// Position of TPQ field.
	GMAC_TPQ_TPQ_Pos = 0x0
	// Bit mask of TPQ field.
	GMAC_TPQ_TPQ_Msk = 0xffff

	// TPSF: TX Partial Store and Forward Register
	// Position of TPB1ADR field.
	GMAC_TPSF_TPB1ADR_Pos = 0x0
	// Bit mask of TPB1ADR field.
	GMAC_TPSF_TPB1ADR_Msk = 0xfff
	// Position of ENTXP field.
	GMAC_TPSF_ENTXP_Pos = 0x1f
	// Bit mask of ENTXP field.
	GMAC_TPSF_ENTXP_Msk = 0x80000000
	// Bit ENTXP.
	GMAC_TPSF_ENTXP = 0x80000000

	// RPSF: RX Partial Store and Forward Register
	// Position of RPB1ADR field.
	GMAC_RPSF_RPB1ADR_Pos = 0x0
	// Bit mask of RPB1ADR field.
	GMAC_RPSF_RPB1ADR_Msk = 0xfff
	// Position of ENRXP field.
	GMAC_RPSF_ENRXP_Pos = 0x1f
	// Bit mask of ENRXP field.
	GMAC_RPSF_ENRXP_Msk = 0x80000000
	// Bit ENRXP.
	GMAC_RPSF_ENRXP = 0x80000000

	// HRB: Hash Register Bottom [31:0]
	// Position of ADDR field.
	GMAC_HRB_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_HRB_ADDR_Msk = 0xffffffff

	// HRT: Hash Register Top [63:32]
	// Position of ADDR field.
	GMAC_HRT_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_HRT_ADDR_Msk = 0xffffffff

	// SAB1: Specific Address 1 Bottom [31:0] Register
	// Position of ADDR field.
	GMAC_SAB1_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_SAB1_ADDR_Msk = 0xffffffff

	// SAT1: Specific Address 1 Top [47:32] Register
	// Position of ADDR field.
	GMAC_SAT1_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_SAT1_ADDR_Msk = 0xffff

	// SAB2: Specific Address 2 Bottom [31:0] Register
	// Position of ADDR field.
	GMAC_SAB2_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_SAB2_ADDR_Msk = 0xffffffff

	// SAT2: Specific Address 2 Top [47:32] Register
	// Position of ADDR field.
	GMAC_SAT2_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_SAT2_ADDR_Msk = 0xffff

	// SAB3: Specific Address 3 Bottom [31:0] Register
	// Position of ADDR field.
	GMAC_SAB3_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_SAB3_ADDR_Msk = 0xffffffff

	// SAT3: Specific Address 3 Top [47:32] Register
	// Position of ADDR field.
	GMAC_SAT3_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_SAT3_ADDR_Msk = 0xffff

	// SAB4: Specific Address 4 Bottom [31:0] Register
	// Position of ADDR field.
	GMAC_SAB4_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_SAB4_ADDR_Msk = 0xffffffff

	// SAT4: Specific Address 4 Top [47:32] Register
	// Position of ADDR field.
	GMAC_SAT4_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_SAT4_ADDR_Msk = 0xffff

	// TIDM: Type ID Match 1 Register
	// Position of TID field.
	GMAC_TIDM_TID_Pos = 0x0
	// Bit mask of TID field.
	GMAC_TIDM_TID_Msk = 0xffff

	// WOL: Wake on LAN Register
	// Position of IP field.
	GMAC_WOL_IP_Pos = 0x0
	// Bit mask of IP field.
	GMAC_WOL_IP_Msk = 0xffff
	// Position of MAG field.
	GMAC_WOL_MAG_Pos = 0x10
	// Bit mask of MAG field.
	GMAC_WOL_MAG_Msk = 0x10000
	// Bit MAG.
	GMAC_WOL_MAG = 0x10000
	// Position of ARP field.
	GMAC_WOL_ARP_Pos = 0x11
	// Bit mask of ARP field.
	GMAC_WOL_ARP_Msk = 0x20000
	// Bit ARP.
	GMAC_WOL_ARP = 0x20000
	// Position of SA1 field.
	GMAC_WOL_SA1_Pos = 0x12
	// Bit mask of SA1 field.
	GMAC_WOL_SA1_Msk = 0x40000
	// Bit SA1.
	GMAC_WOL_SA1 = 0x40000
	// Position of MTI field.
	GMAC_WOL_MTI_Pos = 0x13
	// Bit mask of MTI field.
	GMAC_WOL_MTI_Msk = 0x80000
	// Bit MTI.
	GMAC_WOL_MTI = 0x80000

	// IPGS: IPG Stretch Register
	// Position of FL field.
	GMAC_IPGS_FL_Pos = 0x0
	// Bit mask of FL field.
	GMAC_IPGS_FL_Msk = 0xffff

	// SVLAN: Stacked VLAN Register
	// Position of VLAN_TYPE field.
	GMAC_SVLAN_VLAN_TYPE_Pos = 0x0
	// Bit mask of VLAN_TYPE field.
	GMAC_SVLAN_VLAN_TYPE_Msk = 0xffff
	// Position of ESVLAN field.
	GMAC_SVLAN_ESVLAN_Pos = 0x1f
	// Bit mask of ESVLAN field.
	GMAC_SVLAN_ESVLAN_Msk = 0x80000000
	// Bit ESVLAN.
	GMAC_SVLAN_ESVLAN = 0x80000000

	// TPFCP: Transmit PFC Pause Register
	// Position of PEV field.
	GMAC_TPFCP_PEV_Pos = 0x0
	// Bit mask of PEV field.
	GMAC_TPFCP_PEV_Msk = 0xff
	// Position of PQ field.
	GMAC_TPFCP_PQ_Pos = 0x8
	// Bit mask of PQ field.
	GMAC_TPFCP_PQ_Msk = 0xff00

	// SAMB1: Specific Address 1 Mask Bottom [31:0] Register
	// Position of ADDR field.
	GMAC_SAMB1_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_SAMB1_ADDR_Msk = 0xffffffff

	// SAMT1: Specific Address 1 Mask Top [47:32] Register
	// Position of ADDR field.
	GMAC_SAMT1_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_SAMT1_ADDR_Msk = 0xffff

	// OTLO: Octets Transmitted [31:0] Register
	// Position of TXO field.
	GMAC_OTLO_TXO_Pos = 0x0
	// Bit mask of TXO field.
	GMAC_OTLO_TXO_Msk = 0xffffffff

	// OTHI: Octets Transmitted [47:32] Register
	// Position of TXO field.
	GMAC_OTHI_TXO_Pos = 0x0
	// Bit mask of TXO field.
	GMAC_OTHI_TXO_Msk = 0xffff

	// FT: Frames Transmitted Register
	// Position of FTX field.
	GMAC_FT_FTX_Pos = 0x0
	// Bit mask of FTX field.
	GMAC_FT_FTX_Msk = 0xffffffff

	// BCFT: Broadcast Frames Transmitted Register
	// Position of BFTX field.
	GMAC_BCFT_BFTX_Pos = 0x0
	// Bit mask of BFTX field.
	GMAC_BCFT_BFTX_Msk = 0xffffffff

	// MFT: Multicast Frames Transmitted Register
	// Position of MFTX field.
	GMAC_MFT_MFTX_Pos = 0x0
	// Bit mask of MFTX field.
	GMAC_MFT_MFTX_Msk = 0xffffffff

	// PFT: Pause Frames Transmitted Register
	// Position of PFTX field.
	GMAC_PFT_PFTX_Pos = 0x0
	// Bit mask of PFTX field.
	GMAC_PFT_PFTX_Msk = 0xffff

	// BFT64: 64 Byte Frames Transmitted Register
	// Position of NFTX field.
	GMAC_BFT64_NFTX_Pos = 0x0
	// Bit mask of NFTX field.
	GMAC_BFT64_NFTX_Msk = 0xffffffff

	// TBFT127: 65 to 127 Byte Frames Transmitted Register
	// Position of NFTX field.
	GMAC_TBFT127_NFTX_Pos = 0x0
	// Bit mask of NFTX field.
	GMAC_TBFT127_NFTX_Msk = 0xffffffff

	// TBFT255: 128 to 255 Byte Frames Transmitted Register
	// Position of NFTX field.
	GMAC_TBFT255_NFTX_Pos = 0x0
	// Bit mask of NFTX field.
	GMAC_TBFT255_NFTX_Msk = 0xffffffff

	// TBFT511: 256 to 511 Byte Frames Transmitted Register
	// Position of NFTX field.
	GMAC_TBFT511_NFTX_Pos = 0x0
	// Bit mask of NFTX field.
	GMAC_TBFT511_NFTX_Msk = 0xffffffff

	// TBFT1023: 512 to 1023 Byte Frames Transmitted Register
	// Position of NFTX field.
	GMAC_TBFT1023_NFTX_Pos = 0x0
	// Bit mask of NFTX field.
	GMAC_TBFT1023_NFTX_Msk = 0xffffffff

	// TBFT1518: 1024 to 1518 Byte Frames Transmitted Register
	// Position of NFTX field.
	GMAC_TBFT1518_NFTX_Pos = 0x0
	// Bit mask of NFTX field.
	GMAC_TBFT1518_NFTX_Msk = 0xffffffff

	// GTBFT1518: Greater Than 1518 Byte Frames Transmitted Register
	// Position of NFTX field.
	GMAC_GTBFT1518_NFTX_Pos = 0x0
	// Bit mask of NFTX field.
	GMAC_GTBFT1518_NFTX_Msk = 0xffffffff

	// TUR: Transmit Under Runs Register
	// Position of TXUNR field.
	GMAC_TUR_TXUNR_Pos = 0x0
	// Bit mask of TXUNR field.
	GMAC_TUR_TXUNR_Msk = 0x3ff

	// SCF: Single Collision Frames Register
	// Position of SCOL field.
	GMAC_SCF_SCOL_Pos = 0x0
	// Bit mask of SCOL field.
	GMAC_SCF_SCOL_Msk = 0x3ffff

	// MCF: Multiple Collision Frames Register
	// Position of MCOL field.
	GMAC_MCF_MCOL_Pos = 0x0
	// Bit mask of MCOL field.
	GMAC_MCF_MCOL_Msk = 0x3ffff

	// EC: Excessive Collisions Register
	// Position of XCOL field.
	GMAC_EC_XCOL_Pos = 0x0
	// Bit mask of XCOL field.
	GMAC_EC_XCOL_Msk = 0x3ff

	// LC: Late Collisions Register
	// Position of LCOL field.
	GMAC_LC_LCOL_Pos = 0x0
	// Bit mask of LCOL field.
	GMAC_LC_LCOL_Msk = 0x3ff

	// DTF: Deferred Transmission Frames Register
	// Position of DEFT field.
	GMAC_DTF_DEFT_Pos = 0x0
	// Bit mask of DEFT field.
	GMAC_DTF_DEFT_Msk = 0x3ffff

	// CSE: Carrier Sense Errors Register
	// Position of CSR field.
	GMAC_CSE_CSR_Pos = 0x0
	// Bit mask of CSR field.
	GMAC_CSE_CSR_Msk = 0x3ff

	// ORLO: Octets Received [31:0] Received
	// Position of RXO field.
	GMAC_ORLO_RXO_Pos = 0x0
	// Bit mask of RXO field.
	GMAC_ORLO_RXO_Msk = 0xffffffff

	// ORHI: Octets Received [47:32] Received
	// Position of RXO field.
	GMAC_ORHI_RXO_Pos = 0x0
	// Bit mask of RXO field.
	GMAC_ORHI_RXO_Msk = 0xffff

	// FR: Frames Received Register
	// Position of FRX field.
	GMAC_FR_FRX_Pos = 0x0
	// Bit mask of FRX field.
	GMAC_FR_FRX_Msk = 0xffffffff

	// BCFR: Broadcast Frames Received Register
	// Position of BFRX field.
	GMAC_BCFR_BFRX_Pos = 0x0
	// Bit mask of BFRX field.
	GMAC_BCFR_BFRX_Msk = 0xffffffff

	// MFR: Multicast Frames Received Register
	// Position of MFRX field.
	GMAC_MFR_MFRX_Pos = 0x0
	// Bit mask of MFRX field.
	GMAC_MFR_MFRX_Msk = 0xffffffff

	// PFR: Pause Frames Received Register
	// Position of PFRX field.
	GMAC_PFR_PFRX_Pos = 0x0
	// Bit mask of PFRX field.
	GMAC_PFR_PFRX_Msk = 0xffff

	// BFR64: 64 Byte Frames Received Register
	// Position of NFRX field.
	GMAC_BFR64_NFRX_Pos = 0x0
	// Bit mask of NFRX field.
	GMAC_BFR64_NFRX_Msk = 0xffffffff

	// TBFR127: 65 to 127 Byte Frames Received Register
	// Position of NFRX field.
	GMAC_TBFR127_NFRX_Pos = 0x0
	// Bit mask of NFRX field.
	GMAC_TBFR127_NFRX_Msk = 0xffffffff

	// TBFR255: 128 to 255 Byte Frames Received Register
	// Position of NFRX field.
	GMAC_TBFR255_NFRX_Pos = 0x0
	// Bit mask of NFRX field.
	GMAC_TBFR255_NFRX_Msk = 0xffffffff

	// TBFR511: 256 to 511Byte Frames Received Register
	// Position of NFRX field.
	GMAC_TBFR511_NFRX_Pos = 0x0
	// Bit mask of NFRX field.
	GMAC_TBFR511_NFRX_Msk = 0xffffffff

	// TBFR1023: 512 to 1023 Byte Frames Received Register
	// Position of NFRX field.
	GMAC_TBFR1023_NFRX_Pos = 0x0
	// Bit mask of NFRX field.
	GMAC_TBFR1023_NFRX_Msk = 0xffffffff

	// TBFR1518: 1024 to 1518 Byte Frames Received Register
	// Position of NFRX field.
	GMAC_TBFR1518_NFRX_Pos = 0x0
	// Bit mask of NFRX field.
	GMAC_TBFR1518_NFRX_Msk = 0xffffffff

	// TMXBFR: 1519 to Maximum Byte Frames Received Register
	// Position of NFRX field.
	GMAC_TMXBFR_NFRX_Pos = 0x0
	// Bit mask of NFRX field.
	GMAC_TMXBFR_NFRX_Msk = 0xffffffff

	// UFR: Undersize Frames Received Register
	// Position of UFRX field.
	GMAC_UFR_UFRX_Pos = 0x0
	// Bit mask of UFRX field.
	GMAC_UFR_UFRX_Msk = 0x3ff

	// OFR: Oversize Frames Received Register
	// Position of OFRX field.
	GMAC_OFR_OFRX_Pos = 0x0
	// Bit mask of OFRX field.
	GMAC_OFR_OFRX_Msk = 0x3ff

	// JR: Jabbers Received Register
	// Position of JRX field.
	GMAC_JR_JRX_Pos = 0x0
	// Bit mask of JRX field.
	GMAC_JR_JRX_Msk = 0x3ff

	// FCSE: Frame Check Sequence Errors Register
	// Position of FCKR field.
	GMAC_FCSE_FCKR_Pos = 0x0
	// Bit mask of FCKR field.
	GMAC_FCSE_FCKR_Msk = 0x3ff

	// LFFE: Length Field Frame Errors Register
	// Position of LFER field.
	GMAC_LFFE_LFER_Pos = 0x0
	// Bit mask of LFER field.
	GMAC_LFFE_LFER_Msk = 0x3ff

	// RSE: Receive Symbol Errors Register
	// Position of RXSE field.
	GMAC_RSE_RXSE_Pos = 0x0
	// Bit mask of RXSE field.
	GMAC_RSE_RXSE_Msk = 0x3ff

	// AE: Alignment Errors Register
	// Position of AER field.
	GMAC_AE_AER_Pos = 0x0
	// Bit mask of AER field.
	GMAC_AE_AER_Msk = 0x3ff

	// RRE: Receive Resource Errors Register
	// Position of RXRER field.
	GMAC_RRE_RXRER_Pos = 0x0
	// Bit mask of RXRER field.
	GMAC_RRE_RXRER_Msk = 0x3ffff

	// ROE: Receive Overrun Register
	// Position of RXOVR field.
	GMAC_ROE_RXOVR_Pos = 0x0
	// Bit mask of RXOVR field.
	GMAC_ROE_RXOVR_Msk = 0x3ff

	// IHCE: IP Header Checksum Errors Register
	// Position of HCKER field.
	GMAC_IHCE_HCKER_Pos = 0x0
	// Bit mask of HCKER field.
	GMAC_IHCE_HCKER_Msk = 0xff

	// TCE: TCP Checksum Errors Register
	// Position of TCKER field.
	GMAC_TCE_TCKER_Pos = 0x0
	// Bit mask of TCKER field.
	GMAC_TCE_TCKER_Msk = 0xff

	// UCE: UDP Checksum Errors Register
	// Position of UCKER field.
	GMAC_UCE_UCKER_Pos = 0x0
	// Bit mask of UCKER field.
	GMAC_UCE_UCKER_Msk = 0xff

	// TSSS: 1588 Timer Sync Strobe Seconds Register
	// Position of VTS field.
	GMAC_TSSS_VTS_Pos = 0x0
	// Bit mask of VTS field.
	GMAC_TSSS_VTS_Msk = 0xffffffff

	// TSSN: 1588 Timer Sync Strobe Nanoseconds Register
	// Position of VTN field.
	GMAC_TSSN_VTN_Pos = 0x0
	// Bit mask of VTN field.
	GMAC_TSSN_VTN_Msk = 0x3fffffff

	// TS: 1588 Timer Seconds Register
	// Position of TCS field.
	GMAC_TS_TCS_Pos = 0x0
	// Bit mask of TCS field.
	GMAC_TS_TCS_Msk = 0xffffffff

	// TN: 1588 Timer Nanoseconds Register
	// Position of TNS field.
	GMAC_TN_TNS_Pos = 0x0
	// Bit mask of TNS field.
	GMAC_TN_TNS_Msk = 0x3fffffff

	// TA: 1588 Timer Adjust Register
	// Position of ITDT field.
	GMAC_TA_ITDT_Pos = 0x0
	// Bit mask of ITDT field.
	GMAC_TA_ITDT_Msk = 0x3fffffff
	// Position of ADJ field.
	GMAC_TA_ADJ_Pos = 0x1f
	// Bit mask of ADJ field.
	GMAC_TA_ADJ_Msk = 0x80000000
	// Bit ADJ.
	GMAC_TA_ADJ = 0x80000000

	// TI: 1588 Timer Increment Register
	// Position of CNS field.
	GMAC_TI_CNS_Pos = 0x0
	// Bit mask of CNS field.
	GMAC_TI_CNS_Msk = 0xff
	// Position of ACNS field.
	GMAC_TI_ACNS_Pos = 0x8
	// Bit mask of ACNS field.
	GMAC_TI_ACNS_Msk = 0xff00
	// Position of NIT field.
	GMAC_TI_NIT_Pos = 0x10
	// Bit mask of NIT field.
	GMAC_TI_NIT_Msk = 0xff0000

	// EFTS: PTP Event Frame Transmitted Seconds
	// Position of RUD field.
	GMAC_EFTS_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_EFTS_RUD_Msk = 0xffffffff

	// EFTN: PTP Event Frame Transmitted Nanoseconds
	// Position of RUD field.
	GMAC_EFTN_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_EFTN_RUD_Msk = 0x3fffffff

	// EFRS: PTP Event Frame Received Seconds
	// Position of RUD field.
	GMAC_EFRS_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_EFRS_RUD_Msk = 0xffffffff

	// EFRN: PTP Event Frame Received Nanoseconds
	// Position of RUD field.
	GMAC_EFRN_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_EFRN_RUD_Msk = 0x3fffffff

	// PEFTS: PTP Peer Event Frame Transmitted Seconds
	// Position of RUD field.
	GMAC_PEFTS_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_PEFTS_RUD_Msk = 0xffffffff

	// PEFTN: PTP Peer Event Frame Transmitted Nanoseconds
	// Position of RUD field.
	GMAC_PEFTN_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_PEFTN_RUD_Msk = 0x3fffffff

	// PEFRS: PTP Peer Event Frame Received Seconds
	// Position of RUD field.
	GMAC_PEFRS_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_PEFRS_RUD_Msk = 0xffffffff

	// PEFRN: PTP Peer Event Frame Received Nanoseconds
	// Position of RUD field.
	GMAC_PEFRN_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_PEFRN_RUD_Msk = 0x3fffffff

	// ISRPQ: Interrupt Status Register Priority Queue
	// Position of RCOMP field.
	GMAC_ISRPQ_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	GMAC_ISRPQ_RCOMP_Msk = 0x2
	// Bit RCOMP.
	GMAC_ISRPQ_RCOMP = 0x2
	// Position of RXUBR field.
	GMAC_ISRPQ_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	GMAC_ISRPQ_RXUBR_Msk = 0x4
	// Bit RXUBR.
	GMAC_ISRPQ_RXUBR = 0x4
	// Position of RLEX field.
	GMAC_ISRPQ_RLEX_Pos = 0x5
	// Bit mask of RLEX field.
	GMAC_ISRPQ_RLEX_Msk = 0x20
	// Bit RLEX.
	GMAC_ISRPQ_RLEX = 0x20
	// Position of TFC field.
	GMAC_ISRPQ_TFC_Pos = 0x6
	// Bit mask of TFC field.
	GMAC_ISRPQ_TFC_Msk = 0x40
	// Bit TFC.
	GMAC_ISRPQ_TFC = 0x40
	// Position of TCOMP field.
	GMAC_ISRPQ_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	GMAC_ISRPQ_TCOMP_Msk = 0x80
	// Bit TCOMP.
	GMAC_ISRPQ_TCOMP = 0x80
	// Position of ROVR field.
	GMAC_ISRPQ_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	GMAC_ISRPQ_ROVR_Msk = 0x400
	// Bit ROVR.
	GMAC_ISRPQ_ROVR = 0x400
	// Position of HRESP field.
	GMAC_ISRPQ_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	GMAC_ISRPQ_HRESP_Msk = 0x800
	// Bit HRESP.
	GMAC_ISRPQ_HRESP = 0x800

	// TBQBAPQ: Transmit Buffer Queue Base Address Priority Queue
	// Position of TXBQBA field.
	GMAC_TBQBAPQ_TXBQBA_Pos = 0x2
	// Bit mask of TXBQBA field.
	GMAC_TBQBAPQ_TXBQBA_Msk = 0xfc

	// RBQBAPQ: Receive Buffer Queue Base Address Priority Queue
	// Position of RXBQBA field.
	GMAC_RBQBAPQ_RXBQBA_Pos = 0x2
	// Bit mask of RXBQBA field.
	GMAC_RBQBAPQ_RXBQBA_Msk = 0xfc

	// RBSRPQ: Receive Buffer Size Register Priority Queue
	// Position of RBS field.
	GMAC_RBSRPQ_RBS_Pos = 0x0
	// Bit mask of RBS field.
	GMAC_RBSRPQ_RBS_Msk = 0xffff

	// ST1RPQ: Screening Type1 Register Priority Queue
	// Position of QNB field.
	GMAC_ST1RPQ_QNB_Pos = 0x0
	// Bit mask of QNB field.
	GMAC_ST1RPQ_QNB_Msk = 0xf
	// Position of DSTCM field.
	GMAC_ST1RPQ_DSTCM_Pos = 0x4
	// Bit mask of DSTCM field.
	GMAC_ST1RPQ_DSTCM_Msk = 0xff0
	// Position of UDPM field.
	GMAC_ST1RPQ_UDPM_Pos = 0xc
	// Bit mask of UDPM field.
	GMAC_ST1RPQ_UDPM_Msk = 0xffff000
	// Position of DSTCE field.
	GMAC_ST1RPQ_DSTCE_Pos = 0x1c
	// Bit mask of DSTCE field.
	GMAC_ST1RPQ_DSTCE_Msk = 0x10000000
	// Bit DSTCE.
	GMAC_ST1RPQ_DSTCE = 0x10000000
	// Position of UDPE field.
	GMAC_ST1RPQ_UDPE_Pos = 0x1d
	// Bit mask of UDPE field.
	GMAC_ST1RPQ_UDPE_Msk = 0x20000000
	// Bit UDPE.
	GMAC_ST1RPQ_UDPE = 0x20000000

	// ST2RPQ: Screening Type2 Register Priority Queue
	// Position of QNB field.
	GMAC_ST2RPQ_QNB_Pos = 0x0
	// Bit mask of QNB field.
	GMAC_ST2RPQ_QNB_Msk = 0xf
	// Position of VLANP field.
	GMAC_ST2RPQ_VLANP_Pos = 0x4
	// Bit mask of VLANP field.
	GMAC_ST2RPQ_VLANP_Msk = 0xf0
	// Position of VLANE field.
	GMAC_ST2RPQ_VLANE_Pos = 0x8
	// Bit mask of VLANE field.
	GMAC_ST2RPQ_VLANE_Msk = 0x100
	// Bit VLANE.
	GMAC_ST2RPQ_VLANE = 0x100

	// IERPQ: Interrupt Enable Register Priority Queue
	// Position of RCOMP field.
	GMAC_IERPQ_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	GMAC_IERPQ_RCOMP_Msk = 0x2
	// Bit RCOMP.
	GMAC_IERPQ_RCOMP = 0x2
	// Position of RXUBR field.
	GMAC_IERPQ_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	GMAC_IERPQ_RXUBR_Msk = 0x4
	// Bit RXUBR.
	GMAC_IERPQ_RXUBR = 0x4
	// Position of RLEX field.
	GMAC_IERPQ_RLEX_Pos = 0x5
	// Bit mask of RLEX field.
	GMAC_IERPQ_RLEX_Msk = 0x20
	// Bit RLEX.
	GMAC_IERPQ_RLEX = 0x20
	// Position of TFC field.
	GMAC_IERPQ_TFC_Pos = 0x6
	// Bit mask of TFC field.
	GMAC_IERPQ_TFC_Msk = 0x40
	// Bit TFC.
	GMAC_IERPQ_TFC = 0x40
	// Position of TCOMP field.
	GMAC_IERPQ_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	GMAC_IERPQ_TCOMP_Msk = 0x80
	// Bit TCOMP.
	GMAC_IERPQ_TCOMP = 0x80
	// Position of ROVR field.
	GMAC_IERPQ_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	GMAC_IERPQ_ROVR_Msk = 0x400
	// Bit ROVR.
	GMAC_IERPQ_ROVR = 0x400
	// Position of HRESP field.
	GMAC_IERPQ_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	GMAC_IERPQ_HRESP_Msk = 0x800
	// Bit HRESP.
	GMAC_IERPQ_HRESP = 0x800

	// IDRPQ: Interrupt Disable Register Priority Queue
	// Position of RCOMP field.
	GMAC_IDRPQ_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	GMAC_IDRPQ_RCOMP_Msk = 0x2
	// Bit RCOMP.
	GMAC_IDRPQ_RCOMP = 0x2
	// Position of RXUBR field.
	GMAC_IDRPQ_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	GMAC_IDRPQ_RXUBR_Msk = 0x4
	// Bit RXUBR.
	GMAC_IDRPQ_RXUBR = 0x4
	// Position of RLEX field.
	GMAC_IDRPQ_RLEX_Pos = 0x5
	// Bit mask of RLEX field.
	GMAC_IDRPQ_RLEX_Msk = 0x20
	// Bit RLEX.
	GMAC_IDRPQ_RLEX = 0x20
	// Position of TFC field.
	GMAC_IDRPQ_TFC_Pos = 0x6
	// Bit mask of TFC field.
	GMAC_IDRPQ_TFC_Msk = 0x40
	// Bit TFC.
	GMAC_IDRPQ_TFC = 0x40
	// Position of TCOMP field.
	GMAC_IDRPQ_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	GMAC_IDRPQ_TCOMP_Msk = 0x80
	// Bit TCOMP.
	GMAC_IDRPQ_TCOMP = 0x80
	// Position of ROVR field.
	GMAC_IDRPQ_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	GMAC_IDRPQ_ROVR_Msk = 0x400
	// Bit ROVR.
	GMAC_IDRPQ_ROVR = 0x400
	// Position of HRESP field.
	GMAC_IDRPQ_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	GMAC_IDRPQ_HRESP_Msk = 0x800
	// Bit HRESP.
	GMAC_IDRPQ_HRESP = 0x800

	// IMRPQ: Interrupt Mask Register Priority Queue
	// Position of RCOMP field.
	GMAC_IMRPQ_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	GMAC_IMRPQ_RCOMP_Msk = 0x2
	// Bit RCOMP.
	GMAC_IMRPQ_RCOMP = 0x2
	// Position of RXUBR field.
	GMAC_IMRPQ_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	GMAC_IMRPQ_RXUBR_Msk = 0x4
	// Bit RXUBR.
	GMAC_IMRPQ_RXUBR = 0x4
	// Position of RLEX field.
	GMAC_IMRPQ_RLEX_Pos = 0x5
	// Bit mask of RLEX field.
	GMAC_IMRPQ_RLEX_Msk = 0x20
	// Bit RLEX.
	GMAC_IMRPQ_RLEX = 0x20
	// Position of AHB field.
	GMAC_IMRPQ_AHB_Pos = 0x6
	// Bit mask of AHB field.
	GMAC_IMRPQ_AHB_Msk = 0x40
	// Bit AHB.
	GMAC_IMRPQ_AHB = 0x40
	// Position of TCOMP field.
	GMAC_IMRPQ_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	GMAC_IMRPQ_TCOMP_Msk = 0x80
	// Bit TCOMP.
	GMAC_IMRPQ_TCOMP = 0x80
	// Position of ROVR field.
	GMAC_IMRPQ_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	GMAC_IMRPQ_ROVR_Msk = 0x400
	// Bit ROVR.
	GMAC_IMRPQ_ROVR = 0x400
	// Position of HRESP field.
	GMAC_IMRPQ_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	GMAC_IMRPQ_HRESP_Msk = 0x800
	// Bit HRESP.
	GMAC_IMRPQ_HRESP = 0x800
)

// Constants for PWM: Pulse Width Modulation Controller
const (
	// CLK: PWM Clock Register
	// Position of DIVA field.
	PWM_CLK_DIVA_Pos = 0x0
	// Bit mask of DIVA field.
	PWM_CLK_DIVA_Msk = 0xff
	// Position of PREA field.
	PWM_CLK_PREA_Pos = 0x8
	// Bit mask of PREA field.
	PWM_CLK_PREA_Msk = 0xf00
	// Position of DIVB field.
	PWM_CLK_DIVB_Pos = 0x10
	// Bit mask of DIVB field.
	PWM_CLK_DIVB_Msk = 0xff0000
	// Position of PREB field.
	PWM_CLK_PREB_Pos = 0x18
	// Bit mask of PREB field.
	PWM_CLK_PREB_Msk = 0xf000000

	// ENA: PWM Enable Register
	// Position of CHID0 field.
	PWM_ENA_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_ENA_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_ENA_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_ENA_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_ENA_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_ENA_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_ENA_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_ENA_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_ENA_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_ENA_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_ENA_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_ENA_CHID3 = 0x8

	// DIS: PWM Disable Register
	// Position of CHID0 field.
	PWM_DIS_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_DIS_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_DIS_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_DIS_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_DIS_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_DIS_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_DIS_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_DIS_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_DIS_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_DIS_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_DIS_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_DIS_CHID3 = 0x8

	// SR: PWM Status Register
	// Position of CHID0 field.
	PWM_SR_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_SR_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_SR_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_SR_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_SR_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_SR_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_SR_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_SR_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_SR_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_SR_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_SR_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_SR_CHID3 = 0x8

	// IER1: PWM Interrupt Enable Register 1
	// Position of CHID0 field.
	PWM_IER1_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_IER1_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_IER1_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_IER1_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_IER1_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_IER1_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_IER1_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_IER1_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_IER1_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_IER1_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_IER1_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_IER1_CHID3 = 0x8
	// Position of FCHID0 field.
	PWM_IER1_FCHID0_Pos = 0x10
	// Bit mask of FCHID0 field.
	PWM_IER1_FCHID0_Msk = 0x10000
	// Bit FCHID0.
	PWM_IER1_FCHID0 = 0x10000
	// Position of FCHID1 field.
	PWM_IER1_FCHID1_Pos = 0x11
	// Bit mask of FCHID1 field.
	PWM_IER1_FCHID1_Msk = 0x20000
	// Bit FCHID1.
	PWM_IER1_FCHID1 = 0x20000
	// Position of FCHID2 field.
	PWM_IER1_FCHID2_Pos = 0x12
	// Bit mask of FCHID2 field.
	PWM_IER1_FCHID2_Msk = 0x40000
	// Bit FCHID2.
	PWM_IER1_FCHID2 = 0x40000
	// Position of FCHID3 field.
	PWM_IER1_FCHID3_Pos = 0x13
	// Bit mask of FCHID3 field.
	PWM_IER1_FCHID3_Msk = 0x80000
	// Bit FCHID3.
	PWM_IER1_FCHID3 = 0x80000

	// IDR1: PWM Interrupt Disable Register 1
	// Position of CHID0 field.
	PWM_IDR1_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_IDR1_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_IDR1_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_IDR1_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_IDR1_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_IDR1_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_IDR1_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_IDR1_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_IDR1_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_IDR1_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_IDR1_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_IDR1_CHID3 = 0x8
	// Position of FCHID0 field.
	PWM_IDR1_FCHID0_Pos = 0x10
	// Bit mask of FCHID0 field.
	PWM_IDR1_FCHID0_Msk = 0x10000
	// Bit FCHID0.
	PWM_IDR1_FCHID0 = 0x10000
	// Position of FCHID1 field.
	PWM_IDR1_FCHID1_Pos = 0x11
	// Bit mask of FCHID1 field.
	PWM_IDR1_FCHID1_Msk = 0x20000
	// Bit FCHID1.
	PWM_IDR1_FCHID1 = 0x20000
	// Position of FCHID2 field.
	PWM_IDR1_FCHID2_Pos = 0x12
	// Bit mask of FCHID2 field.
	PWM_IDR1_FCHID2_Msk = 0x40000
	// Bit FCHID2.
	PWM_IDR1_FCHID2 = 0x40000
	// Position of FCHID3 field.
	PWM_IDR1_FCHID3_Pos = 0x13
	// Bit mask of FCHID3 field.
	PWM_IDR1_FCHID3_Msk = 0x80000
	// Bit FCHID3.
	PWM_IDR1_FCHID3 = 0x80000

	// IMR1: PWM Interrupt Mask Register 1
	// Position of CHID0 field.
	PWM_IMR1_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_IMR1_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_IMR1_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_IMR1_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_IMR1_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_IMR1_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_IMR1_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_IMR1_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_IMR1_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_IMR1_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_IMR1_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_IMR1_CHID3 = 0x8
	// Position of FCHID0 field.
	PWM_IMR1_FCHID0_Pos = 0x10
	// Bit mask of FCHID0 field.
	PWM_IMR1_FCHID0_Msk = 0x10000
	// Bit FCHID0.
	PWM_IMR1_FCHID0 = 0x10000
	// Position of FCHID1 field.
	PWM_IMR1_FCHID1_Pos = 0x11
	// Bit mask of FCHID1 field.
	PWM_IMR1_FCHID1_Msk = 0x20000
	// Bit FCHID1.
	PWM_IMR1_FCHID1 = 0x20000
	// Position of FCHID2 field.
	PWM_IMR1_FCHID2_Pos = 0x12
	// Bit mask of FCHID2 field.
	PWM_IMR1_FCHID2_Msk = 0x40000
	// Bit FCHID2.
	PWM_IMR1_FCHID2 = 0x40000
	// Position of FCHID3 field.
	PWM_IMR1_FCHID3_Pos = 0x13
	// Bit mask of FCHID3 field.
	PWM_IMR1_FCHID3_Msk = 0x80000
	// Bit FCHID3.
	PWM_IMR1_FCHID3 = 0x80000

	// ISR1: PWM Interrupt Status Register 1
	// Position of CHID0 field.
	PWM_ISR1_CHID0_Pos = 0x0
	// Bit mask of CHID0 field.
	PWM_ISR1_CHID0_Msk = 0x1
	// Bit CHID0.
	PWM_ISR1_CHID0 = 0x1
	// Position of CHID1 field.
	PWM_ISR1_CHID1_Pos = 0x1
	// Bit mask of CHID1 field.
	PWM_ISR1_CHID1_Msk = 0x2
	// Bit CHID1.
	PWM_ISR1_CHID1 = 0x2
	// Position of CHID2 field.
	PWM_ISR1_CHID2_Pos = 0x2
	// Bit mask of CHID2 field.
	PWM_ISR1_CHID2_Msk = 0x4
	// Bit CHID2.
	PWM_ISR1_CHID2 = 0x4
	// Position of CHID3 field.
	PWM_ISR1_CHID3_Pos = 0x3
	// Bit mask of CHID3 field.
	PWM_ISR1_CHID3_Msk = 0x8
	// Bit CHID3.
	PWM_ISR1_CHID3 = 0x8
	// Position of FCHID0 field.
	PWM_ISR1_FCHID0_Pos = 0x10
	// Bit mask of FCHID0 field.
	PWM_ISR1_FCHID0_Msk = 0x10000
	// Bit FCHID0.
	PWM_ISR1_FCHID0 = 0x10000
	// Position of FCHID1 field.
	PWM_ISR1_FCHID1_Pos = 0x11
	// Bit mask of FCHID1 field.
	PWM_ISR1_FCHID1_Msk = 0x20000
	// Bit FCHID1.
	PWM_ISR1_FCHID1 = 0x20000
	// Position of FCHID2 field.
	PWM_ISR1_FCHID2_Pos = 0x12
	// Bit mask of FCHID2 field.
	PWM_ISR1_FCHID2_Msk = 0x40000
	// Bit FCHID2.
	PWM_ISR1_FCHID2 = 0x40000
	// Position of FCHID3 field.
	PWM_ISR1_FCHID3_Pos = 0x13
	// Bit mask of FCHID3 field.
	PWM_ISR1_FCHID3_Msk = 0x80000
	// Bit FCHID3.
	PWM_ISR1_FCHID3 = 0x80000

	// SCM: PWM Sync Channels Mode Register
	// Position of SYNC0 field.
	PWM_SCM_SYNC0_Pos = 0x0
	// Bit mask of SYNC0 field.
	PWM_SCM_SYNC0_Msk = 0x1
	// Bit SYNC0.
	PWM_SCM_SYNC0 = 0x1
	// Position of SYNC1 field.
	PWM_SCM_SYNC1_Pos = 0x1
	// Bit mask of SYNC1 field.
	PWM_SCM_SYNC1_Msk = 0x2
	// Bit SYNC1.
	PWM_SCM_SYNC1 = 0x2
	// Position of SYNC2 field.
	PWM_SCM_SYNC2_Pos = 0x2
	// Bit mask of SYNC2 field.
	PWM_SCM_SYNC2_Msk = 0x4
	// Bit SYNC2.
	PWM_SCM_SYNC2 = 0x4
	// Position of SYNC3 field.
	PWM_SCM_SYNC3_Pos = 0x3
	// Bit mask of SYNC3 field.
	PWM_SCM_SYNC3_Msk = 0x8
	// Bit SYNC3.
	PWM_SCM_SYNC3 = 0x8
	// Position of UPDM field.
	PWM_SCM_UPDM_Pos = 0x10
	// Bit mask of UPDM field.
	PWM_SCM_UPDM_Msk = 0x30000
	// Manual write of double buffer registers and manual update of synchronous channels
	PWM_SCM_UPDM_MODE0 = 0x0
	// Manual write of double buffer registers and automatic update of synchronous channels
	PWM_SCM_UPDM_MODE1 = 0x1

	// SCUC: PWM Sync Channels Update Control Register
	// Position of UPDULOCK field.
	PWM_SCUC_UPDULOCK_Pos = 0x0
	// Bit mask of UPDULOCK field.
	PWM_SCUC_UPDULOCK_Msk = 0x1
	// Bit UPDULOCK.
	PWM_SCUC_UPDULOCK = 0x1

	// SCUP: PWM Sync Channels Update Period Register
	// Position of UPR field.
	PWM_SCUP_UPR_Pos = 0x0
	// Bit mask of UPR field.
	PWM_SCUP_UPR_Msk = 0xf
	// Position of UPRCNT field.
	PWM_SCUP_UPRCNT_Pos = 0x4
	// Bit mask of UPRCNT field.
	PWM_SCUP_UPRCNT_Msk = 0xf0

	// SCUPUPD: PWM Sync Channels Update Period Update Register
	// Position of UPRUPD field.
	PWM_SCUPUPD_UPRUPD_Pos = 0x0
	// Bit mask of UPRUPD field.
	PWM_SCUPUPD_UPRUPD_Msk = 0xf

	// IER2: PWM Interrupt Enable Register 2
	// Position of WRDY field.
	PWM_IER2_WRDY_Pos = 0x0
	// Bit mask of WRDY field.
	PWM_IER2_WRDY_Msk = 0x1
	// Bit WRDY.
	PWM_IER2_WRDY = 0x1
	// Position of UNRE field.
	PWM_IER2_UNRE_Pos = 0x3
	// Bit mask of UNRE field.
	PWM_IER2_UNRE_Msk = 0x8
	// Bit UNRE.
	PWM_IER2_UNRE = 0x8
	// Position of CMPM0 field.
	PWM_IER2_CMPM0_Pos = 0x8
	// Bit mask of CMPM0 field.
	PWM_IER2_CMPM0_Msk = 0x100
	// Bit CMPM0.
	PWM_IER2_CMPM0 = 0x100
	// Position of CMPM1 field.
	PWM_IER2_CMPM1_Pos = 0x9
	// Bit mask of CMPM1 field.
	PWM_IER2_CMPM1_Msk = 0x200
	// Bit CMPM1.
	PWM_IER2_CMPM1 = 0x200
	// Position of CMPM2 field.
	PWM_IER2_CMPM2_Pos = 0xa
	// Bit mask of CMPM2 field.
	PWM_IER2_CMPM2_Msk = 0x400
	// Bit CMPM2.
	PWM_IER2_CMPM2 = 0x400
	// Position of CMPM3 field.
	PWM_IER2_CMPM3_Pos = 0xb
	// Bit mask of CMPM3 field.
	PWM_IER2_CMPM3_Msk = 0x800
	// Bit CMPM3.
	PWM_IER2_CMPM3 = 0x800
	// Position of CMPM4 field.
	PWM_IER2_CMPM4_Pos = 0xc
	// Bit mask of CMPM4 field.
	PWM_IER2_CMPM4_Msk = 0x1000
	// Bit CMPM4.
	PWM_IER2_CMPM4 = 0x1000
	// Position of CMPM5 field.
	PWM_IER2_CMPM5_Pos = 0xd
	// Bit mask of CMPM5 field.
	PWM_IER2_CMPM5_Msk = 0x2000
	// Bit CMPM5.
	PWM_IER2_CMPM5 = 0x2000
	// Position of CMPM6 field.
	PWM_IER2_CMPM6_Pos = 0xe
	// Bit mask of CMPM6 field.
	PWM_IER2_CMPM6_Msk = 0x4000
	// Bit CMPM6.
	PWM_IER2_CMPM6 = 0x4000
	// Position of CMPM7 field.
	PWM_IER2_CMPM7_Pos = 0xf
	// Bit mask of CMPM7 field.
	PWM_IER2_CMPM7_Msk = 0x8000
	// Bit CMPM7.
	PWM_IER2_CMPM7 = 0x8000
	// Position of CMPU0 field.
	PWM_IER2_CMPU0_Pos = 0x10
	// Bit mask of CMPU0 field.
	PWM_IER2_CMPU0_Msk = 0x10000
	// Bit CMPU0.
	PWM_IER2_CMPU0 = 0x10000
	// Position of CMPU1 field.
	PWM_IER2_CMPU1_Pos = 0x11
	// Bit mask of CMPU1 field.
	PWM_IER2_CMPU1_Msk = 0x20000
	// Bit CMPU1.
	PWM_IER2_CMPU1 = 0x20000
	// Position of CMPU2 field.
	PWM_IER2_CMPU2_Pos = 0x12
	// Bit mask of CMPU2 field.
	PWM_IER2_CMPU2_Msk = 0x40000
	// Bit CMPU2.
	PWM_IER2_CMPU2 = 0x40000
	// Position of CMPU3 field.
	PWM_IER2_CMPU3_Pos = 0x13
	// Bit mask of CMPU3 field.
	PWM_IER2_CMPU3_Msk = 0x80000
	// Bit CMPU3.
	PWM_IER2_CMPU3 = 0x80000
	// Position of CMPU4 field.
	PWM_IER2_CMPU4_Pos = 0x14
	// Bit mask of CMPU4 field.
	PWM_IER2_CMPU4_Msk = 0x100000
	// Bit CMPU4.
	PWM_IER2_CMPU4 = 0x100000
	// Position of CMPU5 field.
	PWM_IER2_CMPU5_Pos = 0x15
	// Bit mask of CMPU5 field.
	PWM_IER2_CMPU5_Msk = 0x200000
	// Bit CMPU5.
	PWM_IER2_CMPU5 = 0x200000
	// Position of CMPU6 field.
	PWM_IER2_CMPU6_Pos = 0x16
	// Bit mask of CMPU6 field.
	PWM_IER2_CMPU6_Msk = 0x400000
	// Bit CMPU6.
	PWM_IER2_CMPU6 = 0x400000
	// Position of CMPU7 field.
	PWM_IER2_CMPU7_Pos = 0x17
	// Bit mask of CMPU7 field.
	PWM_IER2_CMPU7_Msk = 0x800000
	// Bit CMPU7.
	PWM_IER2_CMPU7 = 0x800000

	// IDR2: PWM Interrupt Disable Register 2
	// Position of WRDY field.
	PWM_IDR2_WRDY_Pos = 0x0
	// Bit mask of WRDY field.
	PWM_IDR2_WRDY_Msk = 0x1
	// Bit WRDY.
	PWM_IDR2_WRDY = 0x1
	// Position of UNRE field.
	PWM_IDR2_UNRE_Pos = 0x3
	// Bit mask of UNRE field.
	PWM_IDR2_UNRE_Msk = 0x8
	// Bit UNRE.
	PWM_IDR2_UNRE = 0x8
	// Position of CMPM0 field.
	PWM_IDR2_CMPM0_Pos = 0x8
	// Bit mask of CMPM0 field.
	PWM_IDR2_CMPM0_Msk = 0x100
	// Bit CMPM0.
	PWM_IDR2_CMPM0 = 0x100
	// Position of CMPM1 field.
	PWM_IDR2_CMPM1_Pos = 0x9
	// Bit mask of CMPM1 field.
	PWM_IDR2_CMPM1_Msk = 0x200
	// Bit CMPM1.
	PWM_IDR2_CMPM1 = 0x200
	// Position of CMPM2 field.
	PWM_IDR2_CMPM2_Pos = 0xa
	// Bit mask of CMPM2 field.
	PWM_IDR2_CMPM2_Msk = 0x400
	// Bit CMPM2.
	PWM_IDR2_CMPM2 = 0x400
	// Position of CMPM3 field.
	PWM_IDR2_CMPM3_Pos = 0xb
	// Bit mask of CMPM3 field.
	PWM_IDR2_CMPM3_Msk = 0x800
	// Bit CMPM3.
	PWM_IDR2_CMPM3 = 0x800
	// Position of CMPM4 field.
	PWM_IDR2_CMPM4_Pos = 0xc
	// Bit mask of CMPM4 field.
	PWM_IDR2_CMPM4_Msk = 0x1000
	// Bit CMPM4.
	PWM_IDR2_CMPM4 = 0x1000
	// Position of CMPM5 field.
	PWM_IDR2_CMPM5_Pos = 0xd
	// Bit mask of CMPM5 field.
	PWM_IDR2_CMPM5_Msk = 0x2000
	// Bit CMPM5.
	PWM_IDR2_CMPM5 = 0x2000
	// Position of CMPM6 field.
	PWM_IDR2_CMPM6_Pos = 0xe
	// Bit mask of CMPM6 field.
	PWM_IDR2_CMPM6_Msk = 0x4000
	// Bit CMPM6.
	PWM_IDR2_CMPM6 = 0x4000
	// Position of CMPM7 field.
	PWM_IDR2_CMPM7_Pos = 0xf
	// Bit mask of CMPM7 field.
	PWM_IDR2_CMPM7_Msk = 0x8000
	// Bit CMPM7.
	PWM_IDR2_CMPM7 = 0x8000
	// Position of CMPU0 field.
	PWM_IDR2_CMPU0_Pos = 0x10
	// Bit mask of CMPU0 field.
	PWM_IDR2_CMPU0_Msk = 0x10000
	// Bit CMPU0.
	PWM_IDR2_CMPU0 = 0x10000
	// Position of CMPU1 field.
	PWM_IDR2_CMPU1_Pos = 0x11
	// Bit mask of CMPU1 field.
	PWM_IDR2_CMPU1_Msk = 0x20000
	// Bit CMPU1.
	PWM_IDR2_CMPU1 = 0x20000
	// Position of CMPU2 field.
	PWM_IDR2_CMPU2_Pos = 0x12
	// Bit mask of CMPU2 field.
	PWM_IDR2_CMPU2_Msk = 0x40000
	// Bit CMPU2.
	PWM_IDR2_CMPU2 = 0x40000
	// Position of CMPU3 field.
	PWM_IDR2_CMPU3_Pos = 0x13
	// Bit mask of CMPU3 field.
	PWM_IDR2_CMPU3_Msk = 0x80000
	// Bit CMPU3.
	PWM_IDR2_CMPU3 = 0x80000
	// Position of CMPU4 field.
	PWM_IDR2_CMPU4_Pos = 0x14
	// Bit mask of CMPU4 field.
	PWM_IDR2_CMPU4_Msk = 0x100000
	// Bit CMPU4.
	PWM_IDR2_CMPU4 = 0x100000
	// Position of CMPU5 field.
	PWM_IDR2_CMPU5_Pos = 0x15
	// Bit mask of CMPU5 field.
	PWM_IDR2_CMPU5_Msk = 0x200000
	// Bit CMPU5.
	PWM_IDR2_CMPU5 = 0x200000
	// Position of CMPU6 field.
	PWM_IDR2_CMPU6_Pos = 0x16
	// Bit mask of CMPU6 field.
	PWM_IDR2_CMPU6_Msk = 0x400000
	// Bit CMPU6.
	PWM_IDR2_CMPU6 = 0x400000
	// Position of CMPU7 field.
	PWM_IDR2_CMPU7_Pos = 0x17
	// Bit mask of CMPU7 field.
	PWM_IDR2_CMPU7_Msk = 0x800000
	// Bit CMPU7.
	PWM_IDR2_CMPU7 = 0x800000

	// IMR2: PWM Interrupt Mask Register 2
	// Position of WRDY field.
	PWM_IMR2_WRDY_Pos = 0x0
	// Bit mask of WRDY field.
	PWM_IMR2_WRDY_Msk = 0x1
	// Bit WRDY.
	PWM_IMR2_WRDY = 0x1
	// Position of UNRE field.
	PWM_IMR2_UNRE_Pos = 0x3
	// Bit mask of UNRE field.
	PWM_IMR2_UNRE_Msk = 0x8
	// Bit UNRE.
	PWM_IMR2_UNRE = 0x8
	// Position of CMPM0 field.
	PWM_IMR2_CMPM0_Pos = 0x8
	// Bit mask of CMPM0 field.
	PWM_IMR2_CMPM0_Msk = 0x100
	// Bit CMPM0.
	PWM_IMR2_CMPM0 = 0x100
	// Position of CMPM1 field.
	PWM_IMR2_CMPM1_Pos = 0x9
	// Bit mask of CMPM1 field.
	PWM_IMR2_CMPM1_Msk = 0x200
	// Bit CMPM1.
	PWM_IMR2_CMPM1 = 0x200
	// Position of CMPM2 field.
	PWM_IMR2_CMPM2_Pos = 0xa
	// Bit mask of CMPM2 field.
	PWM_IMR2_CMPM2_Msk = 0x400
	// Bit CMPM2.
	PWM_IMR2_CMPM2 = 0x400
	// Position of CMPM3 field.
	PWM_IMR2_CMPM3_Pos = 0xb
	// Bit mask of CMPM3 field.
	PWM_IMR2_CMPM3_Msk = 0x800
	// Bit CMPM3.
	PWM_IMR2_CMPM3 = 0x800
	// Position of CMPM4 field.
	PWM_IMR2_CMPM4_Pos = 0xc
	// Bit mask of CMPM4 field.
	PWM_IMR2_CMPM4_Msk = 0x1000
	// Bit CMPM4.
	PWM_IMR2_CMPM4 = 0x1000
	// Position of CMPM5 field.
	PWM_IMR2_CMPM5_Pos = 0xd
	// Bit mask of CMPM5 field.
	PWM_IMR2_CMPM5_Msk = 0x2000
	// Bit CMPM5.
	PWM_IMR2_CMPM5 = 0x2000
	// Position of CMPM6 field.
	PWM_IMR2_CMPM6_Pos = 0xe
	// Bit mask of CMPM6 field.
	PWM_IMR2_CMPM6_Msk = 0x4000
	// Bit CMPM6.
	PWM_IMR2_CMPM6 = 0x4000
	// Position of CMPM7 field.
	PWM_IMR2_CMPM7_Pos = 0xf
	// Bit mask of CMPM7 field.
	PWM_IMR2_CMPM7_Msk = 0x8000
	// Bit CMPM7.
	PWM_IMR2_CMPM7 = 0x8000
	// Position of CMPU0 field.
	PWM_IMR2_CMPU0_Pos = 0x10
	// Bit mask of CMPU0 field.
	PWM_IMR2_CMPU0_Msk = 0x10000
	// Bit CMPU0.
	PWM_IMR2_CMPU0 = 0x10000
	// Position of CMPU1 field.
	PWM_IMR2_CMPU1_Pos = 0x11
	// Bit mask of CMPU1 field.
	PWM_IMR2_CMPU1_Msk = 0x20000
	// Bit CMPU1.
	PWM_IMR2_CMPU1 = 0x20000
	// Position of CMPU2 field.
	PWM_IMR2_CMPU2_Pos = 0x12
	// Bit mask of CMPU2 field.
	PWM_IMR2_CMPU2_Msk = 0x40000
	// Bit CMPU2.
	PWM_IMR2_CMPU2 = 0x40000
	// Position of CMPU3 field.
	PWM_IMR2_CMPU3_Pos = 0x13
	// Bit mask of CMPU3 field.
	PWM_IMR2_CMPU3_Msk = 0x80000
	// Bit CMPU3.
	PWM_IMR2_CMPU3 = 0x80000
	// Position of CMPU4 field.
	PWM_IMR2_CMPU4_Pos = 0x14
	// Bit mask of CMPU4 field.
	PWM_IMR2_CMPU4_Msk = 0x100000
	// Bit CMPU4.
	PWM_IMR2_CMPU4 = 0x100000
	// Position of CMPU5 field.
	PWM_IMR2_CMPU5_Pos = 0x15
	// Bit mask of CMPU5 field.
	PWM_IMR2_CMPU5_Msk = 0x200000
	// Bit CMPU5.
	PWM_IMR2_CMPU5 = 0x200000
	// Position of CMPU6 field.
	PWM_IMR2_CMPU6_Pos = 0x16
	// Bit mask of CMPU6 field.
	PWM_IMR2_CMPU6_Msk = 0x400000
	// Bit CMPU6.
	PWM_IMR2_CMPU6 = 0x400000
	// Position of CMPU7 field.
	PWM_IMR2_CMPU7_Pos = 0x17
	// Bit mask of CMPU7 field.
	PWM_IMR2_CMPU7_Msk = 0x800000
	// Bit CMPU7.
	PWM_IMR2_CMPU7 = 0x800000

	// ISR2: PWM Interrupt Status Register 2
	// Position of WRDY field.
	PWM_ISR2_WRDY_Pos = 0x0
	// Bit mask of WRDY field.
	PWM_ISR2_WRDY_Msk = 0x1
	// Bit WRDY.
	PWM_ISR2_WRDY = 0x1
	// Position of UNRE field.
	PWM_ISR2_UNRE_Pos = 0x3
	// Bit mask of UNRE field.
	PWM_ISR2_UNRE_Msk = 0x8
	// Bit UNRE.
	PWM_ISR2_UNRE = 0x8
	// Position of CMPM0 field.
	PWM_ISR2_CMPM0_Pos = 0x8
	// Bit mask of CMPM0 field.
	PWM_ISR2_CMPM0_Msk = 0x100
	// Bit CMPM0.
	PWM_ISR2_CMPM0 = 0x100
	// Position of CMPM1 field.
	PWM_ISR2_CMPM1_Pos = 0x9
	// Bit mask of CMPM1 field.
	PWM_ISR2_CMPM1_Msk = 0x200
	// Bit CMPM1.
	PWM_ISR2_CMPM1 = 0x200
	// Position of CMPM2 field.
	PWM_ISR2_CMPM2_Pos = 0xa
	// Bit mask of CMPM2 field.
	PWM_ISR2_CMPM2_Msk = 0x400
	// Bit CMPM2.
	PWM_ISR2_CMPM2 = 0x400
	// Position of CMPM3 field.
	PWM_ISR2_CMPM3_Pos = 0xb
	// Bit mask of CMPM3 field.
	PWM_ISR2_CMPM3_Msk = 0x800
	// Bit CMPM3.
	PWM_ISR2_CMPM3 = 0x800
	// Position of CMPM4 field.
	PWM_ISR2_CMPM4_Pos = 0xc
	// Bit mask of CMPM4 field.
	PWM_ISR2_CMPM4_Msk = 0x1000
	// Bit CMPM4.
	PWM_ISR2_CMPM4 = 0x1000
	// Position of CMPM5 field.
	PWM_ISR2_CMPM5_Pos = 0xd
	// Bit mask of CMPM5 field.
	PWM_ISR2_CMPM5_Msk = 0x2000
	// Bit CMPM5.
	PWM_ISR2_CMPM5 = 0x2000
	// Position of CMPM6 field.
	PWM_ISR2_CMPM6_Pos = 0xe
	// Bit mask of CMPM6 field.
	PWM_ISR2_CMPM6_Msk = 0x4000
	// Bit CMPM6.
	PWM_ISR2_CMPM6 = 0x4000
	// Position of CMPM7 field.
	PWM_ISR2_CMPM7_Pos = 0xf
	// Bit mask of CMPM7 field.
	PWM_ISR2_CMPM7_Msk = 0x8000
	// Bit CMPM7.
	PWM_ISR2_CMPM7 = 0x8000
	// Position of CMPU0 field.
	PWM_ISR2_CMPU0_Pos = 0x10
	// Bit mask of CMPU0 field.
	PWM_ISR2_CMPU0_Msk = 0x10000
	// Bit CMPU0.
	PWM_ISR2_CMPU0 = 0x10000
	// Position of CMPU1 field.
	PWM_ISR2_CMPU1_Pos = 0x11
	// Bit mask of CMPU1 field.
	PWM_ISR2_CMPU1_Msk = 0x20000
	// Bit CMPU1.
	PWM_ISR2_CMPU1 = 0x20000
	// Position of CMPU2 field.
	PWM_ISR2_CMPU2_Pos = 0x12
	// Bit mask of CMPU2 field.
	PWM_ISR2_CMPU2_Msk = 0x40000
	// Bit CMPU2.
	PWM_ISR2_CMPU2 = 0x40000
	// Position of CMPU3 field.
	PWM_ISR2_CMPU3_Pos = 0x13
	// Bit mask of CMPU3 field.
	PWM_ISR2_CMPU3_Msk = 0x80000
	// Bit CMPU3.
	PWM_ISR2_CMPU3 = 0x80000
	// Position of CMPU4 field.
	PWM_ISR2_CMPU4_Pos = 0x14
	// Bit mask of CMPU4 field.
	PWM_ISR2_CMPU4_Msk = 0x100000
	// Bit CMPU4.
	PWM_ISR2_CMPU4 = 0x100000
	// Position of CMPU5 field.
	PWM_ISR2_CMPU5_Pos = 0x15
	// Bit mask of CMPU5 field.
	PWM_ISR2_CMPU5_Msk = 0x200000
	// Bit CMPU5.
	PWM_ISR2_CMPU5 = 0x200000
	// Position of CMPU6 field.
	PWM_ISR2_CMPU6_Pos = 0x16
	// Bit mask of CMPU6 field.
	PWM_ISR2_CMPU6_Msk = 0x400000
	// Bit CMPU6.
	PWM_ISR2_CMPU6 = 0x400000
	// Position of CMPU7 field.
	PWM_ISR2_CMPU7_Pos = 0x17
	// Bit mask of CMPU7 field.
	PWM_ISR2_CMPU7_Msk = 0x800000
	// Bit CMPU7.
	PWM_ISR2_CMPU7 = 0x800000

	// OOV: PWM Output Override Value Register
	// Position of OOVH0 field.
	PWM_OOV_OOVH0_Pos = 0x0
	// Bit mask of OOVH0 field.
	PWM_OOV_OOVH0_Msk = 0x1
	// Bit OOVH0.
	PWM_OOV_OOVH0 = 0x1
	// Position of OOVH1 field.
	PWM_OOV_OOVH1_Pos = 0x1
	// Bit mask of OOVH1 field.
	PWM_OOV_OOVH1_Msk = 0x2
	// Bit OOVH1.
	PWM_OOV_OOVH1 = 0x2
	// Position of OOVH2 field.
	PWM_OOV_OOVH2_Pos = 0x2
	// Bit mask of OOVH2 field.
	PWM_OOV_OOVH2_Msk = 0x4
	// Bit OOVH2.
	PWM_OOV_OOVH2 = 0x4
	// Position of OOVH3 field.
	PWM_OOV_OOVH3_Pos = 0x3
	// Bit mask of OOVH3 field.
	PWM_OOV_OOVH3_Msk = 0x8
	// Bit OOVH3.
	PWM_OOV_OOVH3 = 0x8
	// Position of OOVL0 field.
	PWM_OOV_OOVL0_Pos = 0x10
	// Bit mask of OOVL0 field.
	PWM_OOV_OOVL0_Msk = 0x10000
	// Bit OOVL0.
	PWM_OOV_OOVL0 = 0x10000
	// Position of OOVL1 field.
	PWM_OOV_OOVL1_Pos = 0x11
	// Bit mask of OOVL1 field.
	PWM_OOV_OOVL1_Msk = 0x20000
	// Bit OOVL1.
	PWM_OOV_OOVL1 = 0x20000
	// Position of OOVL2 field.
	PWM_OOV_OOVL2_Pos = 0x12
	// Bit mask of OOVL2 field.
	PWM_OOV_OOVL2_Msk = 0x40000
	// Bit OOVL2.
	PWM_OOV_OOVL2 = 0x40000
	// Position of OOVL3 field.
	PWM_OOV_OOVL3_Pos = 0x13
	// Bit mask of OOVL3 field.
	PWM_OOV_OOVL3_Msk = 0x80000
	// Bit OOVL3.
	PWM_OOV_OOVL3 = 0x80000

	// OS: PWM Output Selection Register
	// Position of OSH0 field.
	PWM_OS_OSH0_Pos = 0x0
	// Bit mask of OSH0 field.
	PWM_OS_OSH0_Msk = 0x1
	// Bit OSH0.
	PWM_OS_OSH0 = 0x1
	// Position of OSH1 field.
	PWM_OS_OSH1_Pos = 0x1
	// Bit mask of OSH1 field.
	PWM_OS_OSH1_Msk = 0x2
	// Bit OSH1.
	PWM_OS_OSH1 = 0x2
	// Position of OSH2 field.
	PWM_OS_OSH2_Pos = 0x2
	// Bit mask of OSH2 field.
	PWM_OS_OSH2_Msk = 0x4
	// Bit OSH2.
	PWM_OS_OSH2 = 0x4
	// Position of OSH3 field.
	PWM_OS_OSH3_Pos = 0x3
	// Bit mask of OSH3 field.
	PWM_OS_OSH3_Msk = 0x8
	// Bit OSH3.
	PWM_OS_OSH3 = 0x8
	// Position of OSL0 field.
	PWM_OS_OSL0_Pos = 0x10
	// Bit mask of OSL0 field.
	PWM_OS_OSL0_Msk = 0x10000
	// Bit OSL0.
	PWM_OS_OSL0 = 0x10000
	// Position of OSL1 field.
	PWM_OS_OSL1_Pos = 0x11
	// Bit mask of OSL1 field.
	PWM_OS_OSL1_Msk = 0x20000
	// Bit OSL1.
	PWM_OS_OSL1 = 0x20000
	// Position of OSL2 field.
	PWM_OS_OSL2_Pos = 0x12
	// Bit mask of OSL2 field.
	PWM_OS_OSL2_Msk = 0x40000
	// Bit OSL2.
	PWM_OS_OSL2 = 0x40000
	// Position of OSL3 field.
	PWM_OS_OSL3_Pos = 0x13
	// Bit mask of OSL3 field.
	PWM_OS_OSL3_Msk = 0x80000
	// Bit OSL3.
	PWM_OS_OSL3 = 0x80000

	// OSS: PWM Output Selection Set Register
	// Position of OSSH0 field.
	PWM_OSS_OSSH0_Pos = 0x0
	// Bit mask of OSSH0 field.
	PWM_OSS_OSSH0_Msk = 0x1
	// Bit OSSH0.
	PWM_OSS_OSSH0 = 0x1
	// Position of OSSH1 field.
	PWM_OSS_OSSH1_Pos = 0x1
	// Bit mask of OSSH1 field.
	PWM_OSS_OSSH1_Msk = 0x2
	// Bit OSSH1.
	PWM_OSS_OSSH1 = 0x2
	// Position of OSSH2 field.
	PWM_OSS_OSSH2_Pos = 0x2
	// Bit mask of OSSH2 field.
	PWM_OSS_OSSH2_Msk = 0x4
	// Bit OSSH2.
	PWM_OSS_OSSH2 = 0x4
	// Position of OSSH3 field.
	PWM_OSS_OSSH3_Pos = 0x3
	// Bit mask of OSSH3 field.
	PWM_OSS_OSSH3_Msk = 0x8
	// Bit OSSH3.
	PWM_OSS_OSSH3 = 0x8
	// Position of OSSL0 field.
	PWM_OSS_OSSL0_Pos = 0x10
	// Bit mask of OSSL0 field.
	PWM_OSS_OSSL0_Msk = 0x10000
	// Bit OSSL0.
	PWM_OSS_OSSL0 = 0x10000
	// Position of OSSL1 field.
	PWM_OSS_OSSL1_Pos = 0x11
	// Bit mask of OSSL1 field.
	PWM_OSS_OSSL1_Msk = 0x20000
	// Bit OSSL1.
	PWM_OSS_OSSL1 = 0x20000
	// Position of OSSL2 field.
	PWM_OSS_OSSL2_Pos = 0x12
	// Bit mask of OSSL2 field.
	PWM_OSS_OSSL2_Msk = 0x40000
	// Bit OSSL2.
	PWM_OSS_OSSL2 = 0x40000
	// Position of OSSL3 field.
	PWM_OSS_OSSL3_Pos = 0x13
	// Bit mask of OSSL3 field.
	PWM_OSS_OSSL3_Msk = 0x80000
	// Bit OSSL3.
	PWM_OSS_OSSL3 = 0x80000

	// OSC: PWM Output Selection Clear Register
	// Position of OSCH0 field.
	PWM_OSC_OSCH0_Pos = 0x0
	// Bit mask of OSCH0 field.
	PWM_OSC_OSCH0_Msk = 0x1
	// Bit OSCH0.
	PWM_OSC_OSCH0 = 0x1
	// Position of OSCH1 field.
	PWM_OSC_OSCH1_Pos = 0x1
	// Bit mask of OSCH1 field.
	PWM_OSC_OSCH1_Msk = 0x2
	// Bit OSCH1.
	PWM_OSC_OSCH1 = 0x2
	// Position of OSCH2 field.
	PWM_OSC_OSCH2_Pos = 0x2
	// Bit mask of OSCH2 field.
	PWM_OSC_OSCH2_Msk = 0x4
	// Bit OSCH2.
	PWM_OSC_OSCH2 = 0x4
	// Position of OSCH3 field.
	PWM_OSC_OSCH3_Pos = 0x3
	// Bit mask of OSCH3 field.
	PWM_OSC_OSCH3_Msk = 0x8
	// Bit OSCH3.
	PWM_OSC_OSCH3 = 0x8
	// Position of OSCL0 field.
	PWM_OSC_OSCL0_Pos = 0x10
	// Bit mask of OSCL0 field.
	PWM_OSC_OSCL0_Msk = 0x10000
	// Bit OSCL0.
	PWM_OSC_OSCL0 = 0x10000
	// Position of OSCL1 field.
	PWM_OSC_OSCL1_Pos = 0x11
	// Bit mask of OSCL1 field.
	PWM_OSC_OSCL1_Msk = 0x20000
	// Bit OSCL1.
	PWM_OSC_OSCL1 = 0x20000
	// Position of OSCL2 field.
	PWM_OSC_OSCL2_Pos = 0x12
	// Bit mask of OSCL2 field.
	PWM_OSC_OSCL2_Msk = 0x40000
	// Bit OSCL2.
	PWM_OSC_OSCL2 = 0x40000
	// Position of OSCL3 field.
	PWM_OSC_OSCL3_Pos = 0x13
	// Bit mask of OSCL3 field.
	PWM_OSC_OSCL3_Msk = 0x80000
	// Bit OSCL3.
	PWM_OSC_OSCL3 = 0x80000

	// OSSUPD: PWM Output Selection Set Update Register
	// Position of OSSUPH0 field.
	PWM_OSSUPD_OSSUPH0_Pos = 0x0
	// Bit mask of OSSUPH0 field.
	PWM_OSSUPD_OSSUPH0_Msk = 0x1
	// Bit OSSUPH0.
	PWM_OSSUPD_OSSUPH0 = 0x1
	// Position of OSSUPH1 field.
	PWM_OSSUPD_OSSUPH1_Pos = 0x1
	// Bit mask of OSSUPH1 field.
	PWM_OSSUPD_OSSUPH1_Msk = 0x2
	// Bit OSSUPH1.
	PWM_OSSUPD_OSSUPH1 = 0x2
	// Position of OSSUPH2 field.
	PWM_OSSUPD_OSSUPH2_Pos = 0x2
	// Bit mask of OSSUPH2 field.
	PWM_OSSUPD_OSSUPH2_Msk = 0x4
	// Bit OSSUPH2.
	PWM_OSSUPD_OSSUPH2 = 0x4
	// Position of OSSUPH3 field.
	PWM_OSSUPD_OSSUPH3_Pos = 0x3
	// Bit mask of OSSUPH3 field.
	PWM_OSSUPD_OSSUPH3_Msk = 0x8
	// Bit OSSUPH3.
	PWM_OSSUPD_OSSUPH3 = 0x8
	// Position of OSSUPL0 field.
	PWM_OSSUPD_OSSUPL0_Pos = 0x10
	// Bit mask of OSSUPL0 field.
	PWM_OSSUPD_OSSUPL0_Msk = 0x10000
	// Bit OSSUPL0.
	PWM_OSSUPD_OSSUPL0 = 0x10000
	// Position of OSSUPL1 field.
	PWM_OSSUPD_OSSUPL1_Pos = 0x11
	// Bit mask of OSSUPL1 field.
	PWM_OSSUPD_OSSUPL1_Msk = 0x20000
	// Bit OSSUPL1.
	PWM_OSSUPD_OSSUPL1 = 0x20000
	// Position of OSSUPL2 field.
	PWM_OSSUPD_OSSUPL2_Pos = 0x12
	// Bit mask of OSSUPL2 field.
	PWM_OSSUPD_OSSUPL2_Msk = 0x40000
	// Bit OSSUPL2.
	PWM_OSSUPD_OSSUPL2 = 0x40000
	// Position of OSSUPL3 field.
	PWM_OSSUPD_OSSUPL3_Pos = 0x13
	// Bit mask of OSSUPL3 field.
	PWM_OSSUPD_OSSUPL3_Msk = 0x80000
	// Bit OSSUPL3.
	PWM_OSSUPD_OSSUPL3 = 0x80000

	// OSCUPD: PWM Output Selection Clear Update Register
	// Position of OSCUPH0 field.
	PWM_OSCUPD_OSCUPH0_Pos = 0x0
	// Bit mask of OSCUPH0 field.
	PWM_OSCUPD_OSCUPH0_Msk = 0x1
	// Bit OSCUPH0.
	PWM_OSCUPD_OSCUPH0 = 0x1
	// Position of OSCUPH1 field.
	PWM_OSCUPD_OSCUPH1_Pos = 0x1
	// Bit mask of OSCUPH1 field.
	PWM_OSCUPD_OSCUPH1_Msk = 0x2
	// Bit OSCUPH1.
	PWM_OSCUPD_OSCUPH1 = 0x2
	// Position of OSCUPH2 field.
	PWM_OSCUPD_OSCUPH2_Pos = 0x2
	// Bit mask of OSCUPH2 field.
	PWM_OSCUPD_OSCUPH2_Msk = 0x4
	// Bit OSCUPH2.
	PWM_OSCUPD_OSCUPH2 = 0x4
	// Position of OSCUPH3 field.
	PWM_OSCUPD_OSCUPH3_Pos = 0x3
	// Bit mask of OSCUPH3 field.
	PWM_OSCUPD_OSCUPH3_Msk = 0x8
	// Bit OSCUPH3.
	PWM_OSCUPD_OSCUPH3 = 0x8
	// Position of OSCUPL0 field.
	PWM_OSCUPD_OSCUPL0_Pos = 0x10
	// Bit mask of OSCUPL0 field.
	PWM_OSCUPD_OSCUPL0_Msk = 0x10000
	// Bit OSCUPL0.
	PWM_OSCUPD_OSCUPL0 = 0x10000
	// Position of OSCUPL1 field.
	PWM_OSCUPD_OSCUPL1_Pos = 0x11
	// Bit mask of OSCUPL1 field.
	PWM_OSCUPD_OSCUPL1_Msk = 0x20000
	// Bit OSCUPL1.
	PWM_OSCUPD_OSCUPL1 = 0x20000
	// Position of OSCUPL2 field.
	PWM_OSCUPD_OSCUPL2_Pos = 0x12
	// Bit mask of OSCUPL2 field.
	PWM_OSCUPD_OSCUPL2_Msk = 0x40000
	// Bit OSCUPL2.
	PWM_OSCUPD_OSCUPL2 = 0x40000
	// Position of OSCUPL3 field.
	PWM_OSCUPD_OSCUPL3_Pos = 0x13
	// Bit mask of OSCUPL3 field.
	PWM_OSCUPD_OSCUPL3_Msk = 0x80000
	// Bit OSCUPL3.
	PWM_OSCUPD_OSCUPL3 = 0x80000

	// FMR: PWM Fault Mode Register
	// Position of FPOL field.
	PWM_FMR_FPOL_Pos = 0x0
	// Bit mask of FPOL field.
	PWM_FMR_FPOL_Msk = 0xff
	// Position of FMOD field.
	PWM_FMR_FMOD_Pos = 0x8
	// Bit mask of FMOD field.
	PWM_FMR_FMOD_Msk = 0xff00
	// Position of FFIL field.
	PWM_FMR_FFIL_Pos = 0x10
	// Bit mask of FFIL field.
	PWM_FMR_FFIL_Msk = 0xff0000

	// FSR: PWM Fault Status Register
	// Position of FIV field.
	PWM_FSR_FIV_Pos = 0x0
	// Bit mask of FIV field.
	PWM_FSR_FIV_Msk = 0xff
	// Position of FS field.
	PWM_FSR_FS_Pos = 0x8
	// Bit mask of FS field.
	PWM_FSR_FS_Msk = 0xff00

	// FCR: PWM Fault Clear Register
	// Position of FCLR field.
	PWM_FCR_FCLR_Pos = 0x0
	// Bit mask of FCLR field.
	PWM_FCR_FCLR_Msk = 0xff

	// FPV: PWM Fault Protection Value Register
	// Position of FPVH0 field.
	PWM_FPV_FPVH0_Pos = 0x0
	// Bit mask of FPVH0 field.
	PWM_FPV_FPVH0_Msk = 0x1
	// Bit FPVH0.
	PWM_FPV_FPVH0 = 0x1
	// Position of FPVH1 field.
	PWM_FPV_FPVH1_Pos = 0x1
	// Bit mask of FPVH1 field.
	PWM_FPV_FPVH1_Msk = 0x2
	// Bit FPVH1.
	PWM_FPV_FPVH1 = 0x2
	// Position of FPVH2 field.
	PWM_FPV_FPVH2_Pos = 0x2
	// Bit mask of FPVH2 field.
	PWM_FPV_FPVH2_Msk = 0x4
	// Bit FPVH2.
	PWM_FPV_FPVH2 = 0x4
	// Position of FPVH3 field.
	PWM_FPV_FPVH3_Pos = 0x3
	// Bit mask of FPVH3 field.
	PWM_FPV_FPVH3_Msk = 0x8
	// Bit FPVH3.
	PWM_FPV_FPVH3 = 0x8
	// Position of FPVL0 field.
	PWM_FPV_FPVL0_Pos = 0x10
	// Bit mask of FPVL0 field.
	PWM_FPV_FPVL0_Msk = 0x10000
	// Bit FPVL0.
	PWM_FPV_FPVL0 = 0x10000
	// Position of FPVL1 field.
	PWM_FPV_FPVL1_Pos = 0x11
	// Bit mask of FPVL1 field.
	PWM_FPV_FPVL1_Msk = 0x20000
	// Bit FPVL1.
	PWM_FPV_FPVL1 = 0x20000
	// Position of FPVL2 field.
	PWM_FPV_FPVL2_Pos = 0x12
	// Bit mask of FPVL2 field.
	PWM_FPV_FPVL2_Msk = 0x40000
	// Bit FPVL2.
	PWM_FPV_FPVL2 = 0x40000
	// Position of FPVL3 field.
	PWM_FPV_FPVL3_Pos = 0x13
	// Bit mask of FPVL3 field.
	PWM_FPV_FPVL3_Msk = 0x80000
	// Bit FPVL3.
	PWM_FPV_FPVL3 = 0x80000

	// FPE: PWM Fault Protection Enable Register
	// Position of FPE0 field.
	PWM_FPE_FPE0_Pos = 0x0
	// Bit mask of FPE0 field.
	PWM_FPE_FPE0_Msk = 0xff
	// Position of FPE1 field.
	PWM_FPE_FPE1_Pos = 0x8
	// Bit mask of FPE1 field.
	PWM_FPE_FPE1_Msk = 0xff00
	// Position of FPE2 field.
	PWM_FPE_FPE2_Pos = 0x10
	// Bit mask of FPE2 field.
	PWM_FPE_FPE2_Msk = 0xff0000
	// Position of FPE3 field.
	PWM_FPE_FPE3_Pos = 0x18
	// Bit mask of FPE3 field.
	PWM_FPE_FPE3_Msk = 0xff000000

	// ELMR: PWM Event Line 0 Mode Register
	// Position of CSEL0 field.
	PWM_ELMR_CSEL0_Pos = 0x0
	// Bit mask of CSEL0 field.
	PWM_ELMR_CSEL0_Msk = 0x1
	// Bit CSEL0.
	PWM_ELMR_CSEL0 = 0x1
	// Position of CSEL1 field.
	PWM_ELMR_CSEL1_Pos = 0x1
	// Bit mask of CSEL1 field.
	PWM_ELMR_CSEL1_Msk = 0x2
	// Bit CSEL1.
	PWM_ELMR_CSEL1 = 0x2
	// Position of CSEL2 field.
	PWM_ELMR_CSEL2_Pos = 0x2
	// Bit mask of CSEL2 field.
	PWM_ELMR_CSEL2_Msk = 0x4
	// Bit CSEL2.
	PWM_ELMR_CSEL2 = 0x4
	// Position of CSEL3 field.
	PWM_ELMR_CSEL3_Pos = 0x3
	// Bit mask of CSEL3 field.
	PWM_ELMR_CSEL3_Msk = 0x8
	// Bit CSEL3.
	PWM_ELMR_CSEL3 = 0x8
	// Position of CSEL4 field.
	PWM_ELMR_CSEL4_Pos = 0x4
	// Bit mask of CSEL4 field.
	PWM_ELMR_CSEL4_Msk = 0x10
	// Bit CSEL4.
	PWM_ELMR_CSEL4 = 0x10
	// Position of CSEL5 field.
	PWM_ELMR_CSEL5_Pos = 0x5
	// Bit mask of CSEL5 field.
	PWM_ELMR_CSEL5_Msk = 0x20
	// Bit CSEL5.
	PWM_ELMR_CSEL5 = 0x20
	// Position of CSEL6 field.
	PWM_ELMR_CSEL6_Pos = 0x6
	// Bit mask of CSEL6 field.
	PWM_ELMR_CSEL6_Msk = 0x40
	// Bit CSEL6.
	PWM_ELMR_CSEL6 = 0x40
	// Position of CSEL7 field.
	PWM_ELMR_CSEL7_Pos = 0x7
	// Bit mask of CSEL7 field.
	PWM_ELMR_CSEL7_Msk = 0x80
	// Bit CSEL7.
	PWM_ELMR_CSEL7 = 0x80

	// SMMR: PWM Stepper Motor Mode Register
	// Position of GCEN0 field.
	PWM_SMMR_GCEN0_Pos = 0x0
	// Bit mask of GCEN0 field.
	PWM_SMMR_GCEN0_Msk = 0x1
	// Bit GCEN0.
	PWM_SMMR_GCEN0 = 0x1
	// Position of GCEN1 field.
	PWM_SMMR_GCEN1_Pos = 0x1
	// Bit mask of GCEN1 field.
	PWM_SMMR_GCEN1_Msk = 0x2
	// Bit GCEN1.
	PWM_SMMR_GCEN1 = 0x2
	// Position of DOWN0 field.
	PWM_SMMR_DOWN0_Pos = 0x10
	// Bit mask of DOWN0 field.
	PWM_SMMR_DOWN0_Msk = 0x10000
	// Bit DOWN0.
	PWM_SMMR_DOWN0 = 0x10000
	// Position of DOWN1 field.
	PWM_SMMR_DOWN1_Pos = 0x11
	// Bit mask of DOWN1 field.
	PWM_SMMR_DOWN1_Msk = 0x20000
	// Bit DOWN1.
	PWM_SMMR_DOWN1 = 0x20000

	// WPCR: PWM Write Protect Control Register
	// Position of WPCMD field.
	PWM_WPCR_WPCMD_Pos = 0x0
	// Bit mask of WPCMD field.
	PWM_WPCR_WPCMD_Msk = 0x3
	// Position of WPRG0 field.
	PWM_WPCR_WPRG0_Pos = 0x2
	// Bit mask of WPRG0 field.
	PWM_WPCR_WPRG0_Msk = 0x4
	// Bit WPRG0.
	PWM_WPCR_WPRG0 = 0x4
	// Position of WPRG1 field.
	PWM_WPCR_WPRG1_Pos = 0x3
	// Bit mask of WPRG1 field.
	PWM_WPCR_WPRG1_Msk = 0x8
	// Bit WPRG1.
	PWM_WPCR_WPRG1 = 0x8
	// Position of WPRG2 field.
	PWM_WPCR_WPRG2_Pos = 0x4
	// Bit mask of WPRG2 field.
	PWM_WPCR_WPRG2_Msk = 0x10
	// Bit WPRG2.
	PWM_WPCR_WPRG2 = 0x10
	// Position of WPRG3 field.
	PWM_WPCR_WPRG3_Pos = 0x5
	// Bit mask of WPRG3 field.
	PWM_WPCR_WPRG3_Msk = 0x20
	// Bit WPRG3.
	PWM_WPCR_WPRG3 = 0x20
	// Position of WPRG4 field.
	PWM_WPCR_WPRG4_Pos = 0x6
	// Bit mask of WPRG4 field.
	PWM_WPCR_WPRG4_Msk = 0x40
	// Bit WPRG4.
	PWM_WPCR_WPRG4 = 0x40
	// Position of WPRG5 field.
	PWM_WPCR_WPRG5_Pos = 0x7
	// Bit mask of WPRG5 field.
	PWM_WPCR_WPRG5_Msk = 0x80
	// Bit WPRG5.
	PWM_WPCR_WPRG5 = 0x80
	// Position of WPKEY field.
	PWM_WPCR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	PWM_WPCR_WPKEY_Msk = 0xffffff00

	// WPSR: PWM Write Protect Status Register
	// Position of WPSWS0 field.
	PWM_WPSR_WPSWS0_Pos = 0x0
	// Bit mask of WPSWS0 field.
	PWM_WPSR_WPSWS0_Msk = 0x1
	// Bit WPSWS0.
	PWM_WPSR_WPSWS0 = 0x1
	// Position of WPSWS1 field.
	PWM_WPSR_WPSWS1_Pos = 0x1
	// Bit mask of WPSWS1 field.
	PWM_WPSR_WPSWS1_Msk = 0x2
	// Bit WPSWS1.
	PWM_WPSR_WPSWS1 = 0x2
	// Position of WPSWS2 field.
	PWM_WPSR_WPSWS2_Pos = 0x2
	// Bit mask of WPSWS2 field.
	PWM_WPSR_WPSWS2_Msk = 0x4
	// Bit WPSWS2.
	PWM_WPSR_WPSWS2 = 0x4
	// Position of WPSWS3 field.
	PWM_WPSR_WPSWS3_Pos = 0x3
	// Bit mask of WPSWS3 field.
	PWM_WPSR_WPSWS3_Msk = 0x8
	// Bit WPSWS3.
	PWM_WPSR_WPSWS3 = 0x8
	// Position of WPSWS4 field.
	PWM_WPSR_WPSWS4_Pos = 0x4
	// Bit mask of WPSWS4 field.
	PWM_WPSR_WPSWS4_Msk = 0x10
	// Bit WPSWS4.
	PWM_WPSR_WPSWS4 = 0x10
	// Position of WPSWS5 field.
	PWM_WPSR_WPSWS5_Pos = 0x5
	// Bit mask of WPSWS5 field.
	PWM_WPSR_WPSWS5_Msk = 0x20
	// Bit WPSWS5.
	PWM_WPSR_WPSWS5 = 0x20
	// Position of WPVS field.
	PWM_WPSR_WPVS_Pos = 0x7
	// Bit mask of WPVS field.
	PWM_WPSR_WPVS_Msk = 0x80
	// Bit WPVS.
	PWM_WPSR_WPVS = 0x80
	// Position of WPHWS0 field.
	PWM_WPSR_WPHWS0_Pos = 0x8
	// Bit mask of WPHWS0 field.
	PWM_WPSR_WPHWS0_Msk = 0x100
	// Bit WPHWS0.
	PWM_WPSR_WPHWS0 = 0x100
	// Position of WPHWS1 field.
	PWM_WPSR_WPHWS1_Pos = 0x9
	// Bit mask of WPHWS1 field.
	PWM_WPSR_WPHWS1_Msk = 0x200
	// Bit WPHWS1.
	PWM_WPSR_WPHWS1 = 0x200
	// Position of WPHWS2 field.
	PWM_WPSR_WPHWS2_Pos = 0xa
	// Bit mask of WPHWS2 field.
	PWM_WPSR_WPHWS2_Msk = 0x400
	// Bit WPHWS2.
	PWM_WPSR_WPHWS2 = 0x400
	// Position of WPHWS3 field.
	PWM_WPSR_WPHWS3_Pos = 0xb
	// Bit mask of WPHWS3 field.
	PWM_WPSR_WPHWS3_Msk = 0x800
	// Bit WPHWS3.
	PWM_WPSR_WPHWS3 = 0x800
	// Position of WPHWS4 field.
	PWM_WPSR_WPHWS4_Pos = 0xc
	// Bit mask of WPHWS4 field.
	PWM_WPSR_WPHWS4_Msk = 0x1000
	// Bit WPHWS4.
	PWM_WPSR_WPHWS4 = 0x1000
	// Position of WPHWS5 field.
	PWM_WPSR_WPHWS5_Pos = 0xd
	// Bit mask of WPHWS5 field.
	PWM_WPSR_WPHWS5_Msk = 0x2000
	// Bit WPHWS5.
	PWM_WPSR_WPHWS5 = 0x2000
	// Position of WPVSRC field.
	PWM_WPSR_WPVSRC_Pos = 0x10
	// Bit mask of WPVSRC field.
	PWM_WPSR_WPVSRC_Msk = 0xffff0000

	// CMPV0: PWM Comparison 0 Value Register
	// Position of CV field.
	PWM_CMPV0_CV_Pos = 0x0
	// Bit mask of CV field.
	PWM_CMPV0_CV_Msk = 0xffffff
	// Position of CVM field.
	PWM_CMPV0_CVM_Pos = 0x18
	// Bit mask of CVM field.
	PWM_CMPV0_CVM_Msk = 0x1000000
	// Bit CVM.
	PWM_CMPV0_CVM = 0x1000000

	// CMPVUPD0: PWM Comparison 0 Value Update Register
	// Position of CVUPD field.
	PWM_CMPVUPD0_CVUPD_Pos = 0x0
	// Bit mask of CVUPD field.
	PWM_CMPVUPD0_CVUPD_Msk = 0xffffff
	// Position of CVMUPD field.
	PWM_CMPVUPD0_CVMUPD_Pos = 0x18
	// Bit mask of CVMUPD field.
	PWM_CMPVUPD0_CVMUPD_Msk = 0x1000000
	// Bit CVMUPD.
	PWM_CMPVUPD0_CVMUPD = 0x1000000

	// CMPM0: PWM Comparison 0 Mode Register
	// Position of CEN field.
	PWM_CMPM0_CEN_Pos = 0x0
	// Bit mask of CEN field.
	PWM_CMPM0_CEN_Msk = 0x1
	// Bit CEN.
	PWM_CMPM0_CEN = 0x1
	// Position of CTR field.
	PWM_CMPM0_CTR_Pos = 0x4
	// Bit mask of CTR field.
	PWM_CMPM0_CTR_Msk = 0xf0
	// Position of CPR field.
	PWM_CMPM0_CPR_Pos = 0x8
	// Bit mask of CPR field.
	PWM_CMPM0_CPR_Msk = 0xf00
	// Position of CPRCNT field.
	PWM_CMPM0_CPRCNT_Pos = 0xc
	// Bit mask of CPRCNT field.
	PWM_CMPM0_CPRCNT_Msk = 0xf000
	// Position of CUPR field.
	PWM_CMPM0_CUPR_Pos = 0x10
	// Bit mask of CUPR field.
	PWM_CMPM0_CUPR_Msk = 0xf0000
	// Position of CUPRCNT field.
	PWM_CMPM0_CUPRCNT_Pos = 0x14
	// Bit mask of CUPRCNT field.
	PWM_CMPM0_CUPRCNT_Msk = 0xf00000

	// CMPMUPD0: PWM Comparison 0 Mode Update Register
	// Position of CENUPD field.
	PWM_CMPMUPD0_CENUPD_Pos = 0x0
	// Bit mask of CENUPD field.
	PWM_CMPMUPD0_CENUPD_Msk = 0x1
	// Bit CENUPD.
	PWM_CMPMUPD0_CENUPD = 0x1
	// Position of CTRUPD field.
	PWM_CMPMUPD0_CTRUPD_Pos = 0x4
	// Bit mask of CTRUPD field.
	PWM_CMPMUPD0_CTRUPD_Msk = 0xf0
	// Position of CPRUPD field.
	PWM_CMPMUPD0_CPRUPD_Pos = 0x8
	// Bit mask of CPRUPD field.
	PWM_CMPMUPD0_CPRUPD_Msk = 0xf00
	// Position of CUPRUPD field.
	PWM_CMPMUPD0_CUPRUPD_Pos = 0x10
	// Bit mask of CUPRUPD field.
	PWM_CMPMUPD0_CUPRUPD_Msk = 0xf0000

	// CMPV1: PWM Comparison 1 Value Register
	// Position of CV field.
	PWM_CMPV1_CV_Pos = 0x0
	// Bit mask of CV field.
	PWM_CMPV1_CV_Msk = 0xffffff
	// Position of CVM field.
	PWM_CMPV1_CVM_Pos = 0x18
	// Bit mask of CVM field.
	PWM_CMPV1_CVM_Msk = 0x1000000
	// Bit CVM.
	PWM_CMPV1_CVM = 0x1000000

	// CMPVUPD1: PWM Comparison 1 Value Update Register
	// Position of CVUPD field.
	PWM_CMPVUPD1_CVUPD_Pos = 0x0
	// Bit mask of CVUPD field.
	PWM_CMPVUPD1_CVUPD_Msk = 0xffffff
	// Position of CVMUPD field.
	PWM_CMPVUPD1_CVMUPD_Pos = 0x18
	// Bit mask of CVMUPD field.
	PWM_CMPVUPD1_CVMUPD_Msk = 0x1000000
	// Bit CVMUPD.
	PWM_CMPVUPD1_CVMUPD = 0x1000000

	// CMPM1: PWM Comparison 1 Mode Register
	// Position of CEN field.
	PWM_CMPM1_CEN_Pos = 0x0
	// Bit mask of CEN field.
	PWM_CMPM1_CEN_Msk = 0x1
	// Bit CEN.
	PWM_CMPM1_CEN = 0x1
	// Position of CTR field.
	PWM_CMPM1_CTR_Pos = 0x4
	// Bit mask of CTR field.
	PWM_CMPM1_CTR_Msk = 0xf0
	// Position of CPR field.
	PWM_CMPM1_CPR_Pos = 0x8
	// Bit mask of CPR field.
	PWM_CMPM1_CPR_Msk = 0xf00
	// Position of CPRCNT field.
	PWM_CMPM1_CPRCNT_Pos = 0xc
	// Bit mask of CPRCNT field.
	PWM_CMPM1_CPRCNT_Msk = 0xf000
	// Position of CUPR field.
	PWM_CMPM1_CUPR_Pos = 0x10
	// Bit mask of CUPR field.
	PWM_CMPM1_CUPR_Msk = 0xf0000
	// Position of CUPRCNT field.
	PWM_CMPM1_CUPRCNT_Pos = 0x14
	// Bit mask of CUPRCNT field.
	PWM_CMPM1_CUPRCNT_Msk = 0xf00000

	// CMPMUPD1: PWM Comparison 1 Mode Update Register
	// Position of CENUPD field.
	PWM_CMPMUPD1_CENUPD_Pos = 0x0
	// Bit mask of CENUPD field.
	PWM_CMPMUPD1_CENUPD_Msk = 0x1
	// Bit CENUPD.
	PWM_CMPMUPD1_CENUPD = 0x1
	// Position of CTRUPD field.
	PWM_CMPMUPD1_CTRUPD_Pos = 0x4
	// Bit mask of CTRUPD field.
	PWM_CMPMUPD1_CTRUPD_Msk = 0xf0
	// Position of CPRUPD field.
	PWM_CMPMUPD1_CPRUPD_Pos = 0x8
	// Bit mask of CPRUPD field.
	PWM_CMPMUPD1_CPRUPD_Msk = 0xf00
	// Position of CUPRUPD field.
	PWM_CMPMUPD1_CUPRUPD_Pos = 0x10
	// Bit mask of CUPRUPD field.
	PWM_CMPMUPD1_CUPRUPD_Msk = 0xf0000

	// CMPV2: PWM Comparison 2 Value Register
	// Position of CV field.
	PWM_CMPV2_CV_Pos = 0x0
	// Bit mask of CV field.
	PWM_CMPV2_CV_Msk = 0xffffff
	// Position of CVM field.
	PWM_CMPV2_CVM_Pos = 0x18
	// Bit mask of CVM field.
	PWM_CMPV2_CVM_Msk = 0x1000000
	// Bit CVM.
	PWM_CMPV2_CVM = 0x1000000

	// CMPVUPD2: PWM Comparison 2 Value Update Register
	// Position of CVUPD field.
	PWM_CMPVUPD2_CVUPD_Pos = 0x0
	// Bit mask of CVUPD field.
	PWM_CMPVUPD2_CVUPD_Msk = 0xffffff
	// Position of CVMUPD field.
	PWM_CMPVUPD2_CVMUPD_Pos = 0x18
	// Bit mask of CVMUPD field.
	PWM_CMPVUPD2_CVMUPD_Msk = 0x1000000
	// Bit CVMUPD.
	PWM_CMPVUPD2_CVMUPD = 0x1000000

	// CMPM2: PWM Comparison 2 Mode Register
	// Position of CEN field.
	PWM_CMPM2_CEN_Pos = 0x0
	// Bit mask of CEN field.
	PWM_CMPM2_CEN_Msk = 0x1
	// Bit CEN.
	PWM_CMPM2_CEN = 0x1
	// Position of CTR field.
	PWM_CMPM2_CTR_Pos = 0x4
	// Bit mask of CTR field.
	PWM_CMPM2_CTR_Msk = 0xf0
	// Position of CPR field.
	PWM_CMPM2_CPR_Pos = 0x8
	// Bit mask of CPR field.
	PWM_CMPM2_CPR_Msk = 0xf00
	// Position of CPRCNT field.
	PWM_CMPM2_CPRCNT_Pos = 0xc
	// Bit mask of CPRCNT field.
	PWM_CMPM2_CPRCNT_Msk = 0xf000
	// Position of CUPR field.
	PWM_CMPM2_CUPR_Pos = 0x10
	// Bit mask of CUPR field.
	PWM_CMPM2_CUPR_Msk = 0xf0000
	// Position of CUPRCNT field.
	PWM_CMPM2_CUPRCNT_Pos = 0x14
	// Bit mask of CUPRCNT field.
	PWM_CMPM2_CUPRCNT_Msk = 0xf00000

	// CMPMUPD2: PWM Comparison 2 Mode Update Register
	// Position of CENUPD field.
	PWM_CMPMUPD2_CENUPD_Pos = 0x0
	// Bit mask of CENUPD field.
	PWM_CMPMUPD2_CENUPD_Msk = 0x1
	// Bit CENUPD.
	PWM_CMPMUPD2_CENUPD = 0x1
	// Position of CTRUPD field.
	PWM_CMPMUPD2_CTRUPD_Pos = 0x4
	// Bit mask of CTRUPD field.
	PWM_CMPMUPD2_CTRUPD_Msk = 0xf0
	// Position of CPRUPD field.
	PWM_CMPMUPD2_CPRUPD_Pos = 0x8
	// Bit mask of CPRUPD field.
	PWM_CMPMUPD2_CPRUPD_Msk = 0xf00
	// Position of CUPRUPD field.
	PWM_CMPMUPD2_CUPRUPD_Pos = 0x10
	// Bit mask of CUPRUPD field.
	PWM_CMPMUPD2_CUPRUPD_Msk = 0xf0000

	// CMPV3: PWM Comparison 3 Value Register
	// Position of CV field.
	PWM_CMPV3_CV_Pos = 0x0
	// Bit mask of CV field.
	PWM_CMPV3_CV_Msk = 0xffffff
	// Position of CVM field.
	PWM_CMPV3_CVM_Pos = 0x18
	// Bit mask of CVM field.
	PWM_CMPV3_CVM_Msk = 0x1000000
	// Bit CVM.
	PWM_CMPV3_CVM = 0x1000000

	// CMPVUPD3: PWM Comparison 3 Value Update Register
	// Position of CVUPD field.
	PWM_CMPVUPD3_CVUPD_Pos = 0x0
	// Bit mask of CVUPD field.
	PWM_CMPVUPD3_CVUPD_Msk = 0xffffff
	// Position of CVMUPD field.
	PWM_CMPVUPD3_CVMUPD_Pos = 0x18
	// Bit mask of CVMUPD field.
	PWM_CMPVUPD3_CVMUPD_Msk = 0x1000000
	// Bit CVMUPD.
	PWM_CMPVUPD3_CVMUPD = 0x1000000

	// CMPM3: PWM Comparison 3 Mode Register
	// Position of CEN field.
	PWM_CMPM3_CEN_Pos = 0x0
	// Bit mask of CEN field.
	PWM_CMPM3_CEN_Msk = 0x1
	// Bit CEN.
	PWM_CMPM3_CEN = 0x1
	// Position of CTR field.
	PWM_CMPM3_CTR_Pos = 0x4
	// Bit mask of CTR field.
	PWM_CMPM3_CTR_Msk = 0xf0
	// Position of CPR field.
	PWM_CMPM3_CPR_Pos = 0x8
	// Bit mask of CPR field.
	PWM_CMPM3_CPR_Msk = 0xf00
	// Position of CPRCNT field.
	PWM_CMPM3_CPRCNT_Pos = 0xc
	// Bit mask of CPRCNT field.
	PWM_CMPM3_CPRCNT_Msk = 0xf000
	// Position of CUPR field.
	PWM_CMPM3_CUPR_Pos = 0x10
	// Bit mask of CUPR field.
	PWM_CMPM3_CUPR_Msk = 0xf0000
	// Position of CUPRCNT field.
	PWM_CMPM3_CUPRCNT_Pos = 0x14
	// Bit mask of CUPRCNT field.
	PWM_CMPM3_CUPRCNT_Msk = 0xf00000

	// CMPMUPD3: PWM Comparison 3 Mode Update Register
	// Position of CENUPD field.
	PWM_CMPMUPD3_CENUPD_Pos = 0x0
	// Bit mask of CENUPD field.
	PWM_CMPMUPD3_CENUPD_Msk = 0x1
	// Bit CENUPD.
	PWM_CMPMUPD3_CENUPD = 0x1
	// Position of CTRUPD field.
	PWM_CMPMUPD3_CTRUPD_Pos = 0x4
	// Bit mask of CTRUPD field.
	PWM_CMPMUPD3_CTRUPD_Msk = 0xf0
	// Position of CPRUPD field.
	PWM_CMPMUPD3_CPRUPD_Pos = 0x8
	// Bit mask of CPRUPD field.
	PWM_CMPMUPD3_CPRUPD_Msk = 0xf00
	// Position of CUPRUPD field.
	PWM_CMPMUPD3_CUPRUPD_Pos = 0x10
	// Bit mask of CUPRUPD field.
	PWM_CMPMUPD3_CUPRUPD_Msk = 0xf0000

	// CMPV4: PWM Comparison 4 Value Register
	// Position of CV field.
	PWM_CMPV4_CV_Pos = 0x0
	// Bit mask of CV field.
	PWM_CMPV4_CV_Msk = 0xffffff
	// Position of CVM field.
	PWM_CMPV4_CVM_Pos = 0x18
	// Bit mask of CVM field.
	PWM_CMPV4_CVM_Msk = 0x1000000
	// Bit CVM.
	PWM_CMPV4_CVM = 0x1000000

	// CMPVUPD4: PWM Comparison 4 Value Update Register
	// Position of CVUPD field.
	PWM_CMPVUPD4_CVUPD_Pos = 0x0
	// Bit mask of CVUPD field.
	PWM_CMPVUPD4_CVUPD_Msk = 0xffffff
	// Position of CVMUPD field.
	PWM_CMPVUPD4_CVMUPD_Pos = 0x18
	// Bit mask of CVMUPD field.
	PWM_CMPVUPD4_CVMUPD_Msk = 0x1000000
	// Bit CVMUPD.
	PWM_CMPVUPD4_CVMUPD = 0x1000000

	// CMPM4: PWM Comparison 4 Mode Register
	// Position of CEN field.
	PWM_CMPM4_CEN_Pos = 0x0
	// Bit mask of CEN field.
	PWM_CMPM4_CEN_Msk = 0x1
	// Bit CEN.
	PWM_CMPM4_CEN = 0x1
	// Position of CTR field.
	PWM_CMPM4_CTR_Pos = 0x4
	// Bit mask of CTR field.
	PWM_CMPM4_CTR_Msk = 0xf0
	// Position of CPR field.
	PWM_CMPM4_CPR_Pos = 0x8
	// Bit mask of CPR field.
	PWM_CMPM4_CPR_Msk = 0xf00
	// Position of CPRCNT field.
	PWM_CMPM4_CPRCNT_Pos = 0xc
	// Bit mask of CPRCNT field.
	PWM_CMPM4_CPRCNT_Msk = 0xf000
	// Position of CUPR field.
	PWM_CMPM4_CUPR_Pos = 0x10
	// Bit mask of CUPR field.
	PWM_CMPM4_CUPR_Msk = 0xf0000
	// Position of CUPRCNT field.
	PWM_CMPM4_CUPRCNT_Pos = 0x14
	// Bit mask of CUPRCNT field.
	PWM_CMPM4_CUPRCNT_Msk = 0xf00000

	// CMPMUPD4: PWM Comparison 4 Mode Update Register
	// Position of CENUPD field.
	PWM_CMPMUPD4_CENUPD_Pos = 0x0
	// Bit mask of CENUPD field.
	PWM_CMPMUPD4_CENUPD_Msk = 0x1
	// Bit CENUPD.
	PWM_CMPMUPD4_CENUPD = 0x1
	// Position of CTRUPD field.
	PWM_CMPMUPD4_CTRUPD_Pos = 0x4
	// Bit mask of CTRUPD field.
	PWM_CMPMUPD4_CTRUPD_Msk = 0xf0
	// Position of CPRUPD field.
	PWM_CMPMUPD4_CPRUPD_Pos = 0x8
	// Bit mask of CPRUPD field.
	PWM_CMPMUPD4_CPRUPD_Msk = 0xf00
	// Position of CUPRUPD field.
	PWM_CMPMUPD4_CUPRUPD_Pos = 0x10
	// Bit mask of CUPRUPD field.
	PWM_CMPMUPD4_CUPRUPD_Msk = 0xf0000

	// CMPV5: PWM Comparison 5 Value Register
	// Position of CV field.
	PWM_CMPV5_CV_Pos = 0x0
	// Bit mask of CV field.
	PWM_CMPV5_CV_Msk = 0xffffff
	// Position of CVM field.
	PWM_CMPV5_CVM_Pos = 0x18
	// Bit mask of CVM field.
	PWM_CMPV5_CVM_Msk = 0x1000000
	// Bit CVM.
	PWM_CMPV5_CVM = 0x1000000

	// CMPVUPD5: PWM Comparison 5 Value Update Register
	// Position of CVUPD field.
	PWM_CMPVUPD5_CVUPD_Pos = 0x0
	// Bit mask of CVUPD field.
	PWM_CMPVUPD5_CVUPD_Msk = 0xffffff
	// Position of CVMUPD field.
	PWM_CMPVUPD5_CVMUPD_Pos = 0x18
	// Bit mask of CVMUPD field.
	PWM_CMPVUPD5_CVMUPD_Msk = 0x1000000
	// Bit CVMUPD.
	PWM_CMPVUPD5_CVMUPD = 0x1000000

	// CMPM5: PWM Comparison 5 Mode Register
	// Position of CEN field.
	PWM_CMPM5_CEN_Pos = 0x0
	// Bit mask of CEN field.
	PWM_CMPM5_CEN_Msk = 0x1
	// Bit CEN.
	PWM_CMPM5_CEN = 0x1
	// Position of CTR field.
	PWM_CMPM5_CTR_Pos = 0x4
	// Bit mask of CTR field.
	PWM_CMPM5_CTR_Msk = 0xf0
	// Position of CPR field.
	PWM_CMPM5_CPR_Pos = 0x8
	// Bit mask of CPR field.
	PWM_CMPM5_CPR_Msk = 0xf00
	// Position of CPRCNT field.
	PWM_CMPM5_CPRCNT_Pos = 0xc
	// Bit mask of CPRCNT field.
	PWM_CMPM5_CPRCNT_Msk = 0xf000
	// Position of CUPR field.
	PWM_CMPM5_CUPR_Pos = 0x10
	// Bit mask of CUPR field.
	PWM_CMPM5_CUPR_Msk = 0xf0000
	// Position of CUPRCNT field.
	PWM_CMPM5_CUPRCNT_Pos = 0x14
	// Bit mask of CUPRCNT field.
	PWM_CMPM5_CUPRCNT_Msk = 0xf00000

	// CMPMUPD5: PWM Comparison 5 Mode Update Register
	// Position of CENUPD field.
	PWM_CMPMUPD5_CENUPD_Pos = 0x0
	// Bit mask of CENUPD field.
	PWM_CMPMUPD5_CENUPD_Msk = 0x1
	// Bit CENUPD.
	PWM_CMPMUPD5_CENUPD = 0x1
	// Position of CTRUPD field.
	PWM_CMPMUPD5_CTRUPD_Pos = 0x4
	// Bit mask of CTRUPD field.
	PWM_CMPMUPD5_CTRUPD_Msk = 0xf0
	// Position of CPRUPD field.
	PWM_CMPMUPD5_CPRUPD_Pos = 0x8
	// Bit mask of CPRUPD field.
	PWM_CMPMUPD5_CPRUPD_Msk = 0xf00
	// Position of CUPRUPD field.
	PWM_CMPMUPD5_CUPRUPD_Pos = 0x10
	// Bit mask of CUPRUPD field.
	PWM_CMPMUPD5_CUPRUPD_Msk = 0xf0000

	// CMPV6: PWM Comparison 6 Value Register
	// Position of CV field.
	PWM_CMPV6_CV_Pos = 0x0
	// Bit mask of CV field.
	PWM_CMPV6_CV_Msk = 0xffffff
	// Position of CVM field.
	PWM_CMPV6_CVM_Pos = 0x18
	// Bit mask of CVM field.
	PWM_CMPV6_CVM_Msk = 0x1000000
	// Bit CVM.
	PWM_CMPV6_CVM = 0x1000000

	// CMPVUPD6: PWM Comparison 6 Value Update Register
	// Position of CVUPD field.
	PWM_CMPVUPD6_CVUPD_Pos = 0x0
	// Bit mask of CVUPD field.
	PWM_CMPVUPD6_CVUPD_Msk = 0xffffff
	// Position of CVMUPD field.
	PWM_CMPVUPD6_CVMUPD_Pos = 0x18
	// Bit mask of CVMUPD field.
	PWM_CMPVUPD6_CVMUPD_Msk = 0x1000000
	// Bit CVMUPD.
	PWM_CMPVUPD6_CVMUPD = 0x1000000

	// CMPM6: PWM Comparison 6 Mode Register
	// Position of CEN field.
	PWM_CMPM6_CEN_Pos = 0x0
	// Bit mask of CEN field.
	PWM_CMPM6_CEN_Msk = 0x1
	// Bit CEN.
	PWM_CMPM6_CEN = 0x1
	// Position of CTR field.
	PWM_CMPM6_CTR_Pos = 0x4
	// Bit mask of CTR field.
	PWM_CMPM6_CTR_Msk = 0xf0
	// Position of CPR field.
	PWM_CMPM6_CPR_Pos = 0x8
	// Bit mask of CPR field.
	PWM_CMPM6_CPR_Msk = 0xf00
	// Position of CPRCNT field.
	PWM_CMPM6_CPRCNT_Pos = 0xc
	// Bit mask of CPRCNT field.
	PWM_CMPM6_CPRCNT_Msk = 0xf000
	// Position of CUPR field.
	PWM_CMPM6_CUPR_Pos = 0x10
	// Bit mask of CUPR field.
	PWM_CMPM6_CUPR_Msk = 0xf0000
	// Position of CUPRCNT field.
	PWM_CMPM6_CUPRCNT_Pos = 0x14
	// Bit mask of CUPRCNT field.
	PWM_CMPM6_CUPRCNT_Msk = 0xf00000

	// CMPMUPD6: PWM Comparison 6 Mode Update Register
	// Position of CENUPD field.
	PWM_CMPMUPD6_CENUPD_Pos = 0x0
	// Bit mask of CENUPD field.
	PWM_CMPMUPD6_CENUPD_Msk = 0x1
	// Bit CENUPD.
	PWM_CMPMUPD6_CENUPD = 0x1
	// Position of CTRUPD field.
	PWM_CMPMUPD6_CTRUPD_Pos = 0x4
	// Bit mask of CTRUPD field.
	PWM_CMPMUPD6_CTRUPD_Msk = 0xf0
	// Position of CPRUPD field.
	PWM_CMPMUPD6_CPRUPD_Pos = 0x8
	// Bit mask of CPRUPD field.
	PWM_CMPMUPD6_CPRUPD_Msk = 0xf00
	// Position of CUPRUPD field.
	PWM_CMPMUPD6_CUPRUPD_Pos = 0x10
	// Bit mask of CUPRUPD field.
	PWM_CMPMUPD6_CUPRUPD_Msk = 0xf0000

	// CMPV7: PWM Comparison 7 Value Register
	// Position of CV field.
	PWM_CMPV7_CV_Pos = 0x0
	// Bit mask of CV field.
	PWM_CMPV7_CV_Msk = 0xffffff
	// Position of CVM field.
	PWM_CMPV7_CVM_Pos = 0x18
	// Bit mask of CVM field.
	PWM_CMPV7_CVM_Msk = 0x1000000
	// Bit CVM.
	PWM_CMPV7_CVM = 0x1000000

	// CMPVUPD7: PWM Comparison 7 Value Update Register
	// Position of CVUPD field.
	PWM_CMPVUPD7_CVUPD_Pos = 0x0
	// Bit mask of CVUPD field.
	PWM_CMPVUPD7_CVUPD_Msk = 0xffffff
	// Position of CVMUPD field.
	PWM_CMPVUPD7_CVMUPD_Pos = 0x18
	// Bit mask of CVMUPD field.
	PWM_CMPVUPD7_CVMUPD_Msk = 0x1000000
	// Bit CVMUPD.
	PWM_CMPVUPD7_CVMUPD = 0x1000000

	// CMPM7: PWM Comparison 7 Mode Register
	// Position of CEN field.
	PWM_CMPM7_CEN_Pos = 0x0
	// Bit mask of CEN field.
	PWM_CMPM7_CEN_Msk = 0x1
	// Bit CEN.
	PWM_CMPM7_CEN = 0x1
	// Position of CTR field.
	PWM_CMPM7_CTR_Pos = 0x4
	// Bit mask of CTR field.
	PWM_CMPM7_CTR_Msk = 0xf0
	// Position of CPR field.
	PWM_CMPM7_CPR_Pos = 0x8
	// Bit mask of CPR field.
	PWM_CMPM7_CPR_Msk = 0xf00
	// Position of CPRCNT field.
	PWM_CMPM7_CPRCNT_Pos = 0xc
	// Bit mask of CPRCNT field.
	PWM_CMPM7_CPRCNT_Msk = 0xf000
	// Position of CUPR field.
	PWM_CMPM7_CUPR_Pos = 0x10
	// Bit mask of CUPR field.
	PWM_CMPM7_CUPR_Msk = 0xf0000
	// Position of CUPRCNT field.
	PWM_CMPM7_CUPRCNT_Pos = 0x14
	// Bit mask of CUPRCNT field.
	PWM_CMPM7_CUPRCNT_Msk = 0xf00000

	// CMPMUPD7: PWM Comparison 7 Mode Update Register
	// Position of CENUPD field.
	PWM_CMPMUPD7_CENUPD_Pos = 0x0
	// Bit mask of CENUPD field.
	PWM_CMPMUPD7_CENUPD_Msk = 0x1
	// Bit CENUPD.
	PWM_CMPMUPD7_CENUPD = 0x1
	// Position of CTRUPD field.
	PWM_CMPMUPD7_CTRUPD_Pos = 0x4
	// Bit mask of CTRUPD field.
	PWM_CMPMUPD7_CTRUPD_Msk = 0xf0
	// Position of CPRUPD field.
	PWM_CMPMUPD7_CPRUPD_Pos = 0x8
	// Bit mask of CPRUPD field.
	PWM_CMPMUPD7_CPRUPD_Msk = 0xf00
	// Position of CUPRUPD field.
	PWM_CMPMUPD7_CUPRUPD_Pos = 0x10
	// Bit mask of CUPRUPD field.
	PWM_CMPMUPD7_CUPRUPD_Msk = 0xf0000

	// CMR0: PWM Channel Mode Register (ch_num = 0)
	// Position of CPRE field.
	PWM_CMR0_CPRE_Pos = 0x0
	// Bit mask of CPRE field.
	PWM_CMR0_CPRE_Msk = 0xf
	// Master clock
	PWM_CMR0_CPRE_MCK = 0x0
	// Master clock/2
	PWM_CMR0_CPRE_MCK_DIV_2 = 0x1
	// Master clock/4
	PWM_CMR0_CPRE_MCK_DIV_4 = 0x2
	// Master clock/8
	PWM_CMR0_CPRE_MCK_DIV_8 = 0x3
	// Master clock/16
	PWM_CMR0_CPRE_MCK_DIV_16 = 0x4
	// Master clock/32
	PWM_CMR0_CPRE_MCK_DIV_32 = 0x5
	// Master clock/64
	PWM_CMR0_CPRE_MCK_DIV_64 = 0x6
	// Master clock/128
	PWM_CMR0_CPRE_MCK_DIV_128 = 0x7
	// Master clock/256
	PWM_CMR0_CPRE_MCK_DIV_256 = 0x8
	// Master clock/512
	PWM_CMR0_CPRE_MCK_DIV_512 = 0x9
	// Master clock/1024
	PWM_CMR0_CPRE_MCK_DIV_1024 = 0xa
	// Clock A
	PWM_CMR0_CPRE_CLKA = 0xb
	// Clock B
	PWM_CMR0_CPRE_CLKB = 0xc
	// Position of CALG field.
	PWM_CMR0_CALG_Pos = 0x8
	// Bit mask of CALG field.
	PWM_CMR0_CALG_Msk = 0x100
	// Bit CALG.
	PWM_CMR0_CALG = 0x100
	// Position of CPOL field.
	PWM_CMR0_CPOL_Pos = 0x9
	// Bit mask of CPOL field.
	PWM_CMR0_CPOL_Msk = 0x200
	// Bit CPOL.
	PWM_CMR0_CPOL = 0x200
	// Position of CES field.
	PWM_CMR0_CES_Pos = 0xa
	// Bit mask of CES field.
	PWM_CMR0_CES_Msk = 0x400
	// Bit CES.
	PWM_CMR0_CES = 0x400
	// Position of DTE field.
	PWM_CMR0_DTE_Pos = 0x10
	// Bit mask of DTE field.
	PWM_CMR0_DTE_Msk = 0x10000
	// Bit DTE.
	PWM_CMR0_DTE = 0x10000
	// Position of DTHI field.
	PWM_CMR0_DTHI_Pos = 0x11
	// Bit mask of DTHI field.
	PWM_CMR0_DTHI_Msk = 0x20000
	// Bit DTHI.
	PWM_CMR0_DTHI = 0x20000
	// Position of DTLI field.
	PWM_CMR0_DTLI_Pos = 0x12
	// Bit mask of DTLI field.
	PWM_CMR0_DTLI_Msk = 0x40000
	// Bit DTLI.
	PWM_CMR0_DTLI = 0x40000

	// CDTY0: PWM Channel Duty Cycle Register (ch_num = 0)
	// Position of CDTY field.
	PWM_CDTY0_CDTY_Pos = 0x0
	// Bit mask of CDTY field.
	PWM_CDTY0_CDTY_Msk = 0xffffff

	// CDTYUPD0: PWM Channel Duty Cycle Update Register (ch_num = 0)
	// Position of CDTYUPD field.
	PWM_CDTYUPD0_CDTYUPD_Pos = 0x0
	// Bit mask of CDTYUPD field.
	PWM_CDTYUPD0_CDTYUPD_Msk = 0xffffff

	// CPRD0: PWM Channel Period Register (ch_num = 0)
	// Position of CPRD field.
	PWM_CPRD0_CPRD_Pos = 0x0
	// Bit mask of CPRD field.
	PWM_CPRD0_CPRD_Msk = 0xffffff

	// CPRDUPD0: PWM Channel Period Update Register (ch_num = 0)
	// Position of CPRDUPD field.
	PWM_CPRDUPD0_CPRDUPD_Pos = 0x0
	// Bit mask of CPRDUPD field.
	PWM_CPRDUPD0_CPRDUPD_Msk = 0xffffff

	// CCNT0: PWM Channel Counter Register (ch_num = 0)
	// Position of CNT field.
	PWM_CCNT0_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_CCNT0_CNT_Msk = 0xffffff

	// DT0: PWM Channel Dead Time Register (ch_num = 0)
	// Position of DTH field.
	PWM_DT0_DTH_Pos = 0x0
	// Bit mask of DTH field.
	PWM_DT0_DTH_Msk = 0xffff
	// Position of DTL field.
	PWM_DT0_DTL_Pos = 0x10
	// Bit mask of DTL field.
	PWM_DT0_DTL_Msk = 0xffff0000

	// DTUPD0: PWM Channel Dead Time Update Register (ch_num = 0)
	// Position of DTHUPD field.
	PWM_DTUPD0_DTHUPD_Pos = 0x0
	// Bit mask of DTHUPD field.
	PWM_DTUPD0_DTHUPD_Msk = 0xffff
	// Position of DTLUPD field.
	PWM_DTUPD0_DTLUPD_Pos = 0x10
	// Bit mask of DTLUPD field.
	PWM_DTUPD0_DTLUPD_Msk = 0xffff0000

	// CMR1: PWM Channel Mode Register (ch_num = 1)
	// Position of CPRE field.
	PWM_CMR1_CPRE_Pos = 0x0
	// Bit mask of CPRE field.
	PWM_CMR1_CPRE_Msk = 0xf
	// Master clock
	PWM_CMR1_CPRE_MCK = 0x0
	// Master clock/2
	PWM_CMR1_CPRE_MCK_DIV_2 = 0x1
	// Master clock/4
	PWM_CMR1_CPRE_MCK_DIV_4 = 0x2
	// Master clock/8
	PWM_CMR1_CPRE_MCK_DIV_8 = 0x3
	// Master clock/16
	PWM_CMR1_CPRE_MCK_DIV_16 = 0x4
	// Master clock/32
	PWM_CMR1_CPRE_MCK_DIV_32 = 0x5
	// Master clock/64
	PWM_CMR1_CPRE_MCK_DIV_64 = 0x6
	// Master clock/128
	PWM_CMR1_CPRE_MCK_DIV_128 = 0x7
	// Master clock/256
	PWM_CMR1_CPRE_MCK_DIV_256 = 0x8
	// Master clock/512
	PWM_CMR1_CPRE_MCK_DIV_512 = 0x9
	// Master clock/1024
	PWM_CMR1_CPRE_MCK_DIV_1024 = 0xa
	// Clock A
	PWM_CMR1_CPRE_CLKA = 0xb
	// Clock B
	PWM_CMR1_CPRE_CLKB = 0xc
	// Position of CALG field.
	PWM_CMR1_CALG_Pos = 0x8
	// Bit mask of CALG field.
	PWM_CMR1_CALG_Msk = 0x100
	// Bit CALG.
	PWM_CMR1_CALG = 0x100
	// Position of CPOL field.
	PWM_CMR1_CPOL_Pos = 0x9
	// Bit mask of CPOL field.
	PWM_CMR1_CPOL_Msk = 0x200
	// Bit CPOL.
	PWM_CMR1_CPOL = 0x200
	// Position of CES field.
	PWM_CMR1_CES_Pos = 0xa
	// Bit mask of CES field.
	PWM_CMR1_CES_Msk = 0x400
	// Bit CES.
	PWM_CMR1_CES = 0x400
	// Position of DTE field.
	PWM_CMR1_DTE_Pos = 0x10
	// Bit mask of DTE field.
	PWM_CMR1_DTE_Msk = 0x10000
	// Bit DTE.
	PWM_CMR1_DTE = 0x10000
	// Position of DTHI field.
	PWM_CMR1_DTHI_Pos = 0x11
	// Bit mask of DTHI field.
	PWM_CMR1_DTHI_Msk = 0x20000
	// Bit DTHI.
	PWM_CMR1_DTHI = 0x20000
	// Position of DTLI field.
	PWM_CMR1_DTLI_Pos = 0x12
	// Bit mask of DTLI field.
	PWM_CMR1_DTLI_Msk = 0x40000
	// Bit DTLI.
	PWM_CMR1_DTLI = 0x40000

	// CDTY1: PWM Channel Duty Cycle Register (ch_num = 1)
	// Position of CDTY field.
	PWM_CDTY1_CDTY_Pos = 0x0
	// Bit mask of CDTY field.
	PWM_CDTY1_CDTY_Msk = 0xffffff

	// CDTYUPD1: PWM Channel Duty Cycle Update Register (ch_num = 1)
	// Position of CDTYUPD field.
	PWM_CDTYUPD1_CDTYUPD_Pos = 0x0
	// Bit mask of CDTYUPD field.
	PWM_CDTYUPD1_CDTYUPD_Msk = 0xffffff

	// CPRD1: PWM Channel Period Register (ch_num = 1)
	// Position of CPRD field.
	PWM_CPRD1_CPRD_Pos = 0x0
	// Bit mask of CPRD field.
	PWM_CPRD1_CPRD_Msk = 0xffffff

	// CPRDUPD1: PWM Channel Period Update Register (ch_num = 1)
	// Position of CPRDUPD field.
	PWM_CPRDUPD1_CPRDUPD_Pos = 0x0
	// Bit mask of CPRDUPD field.
	PWM_CPRDUPD1_CPRDUPD_Msk = 0xffffff

	// CCNT1: PWM Channel Counter Register (ch_num = 1)
	// Position of CNT field.
	PWM_CCNT1_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_CCNT1_CNT_Msk = 0xffffff

	// DT1: PWM Channel Dead Time Register (ch_num = 1)
	// Position of DTH field.
	PWM_DT1_DTH_Pos = 0x0
	// Bit mask of DTH field.
	PWM_DT1_DTH_Msk = 0xffff
	// Position of DTL field.
	PWM_DT1_DTL_Pos = 0x10
	// Bit mask of DTL field.
	PWM_DT1_DTL_Msk = 0xffff0000

	// DTUPD1: PWM Channel Dead Time Update Register (ch_num = 1)
	// Position of DTHUPD field.
	PWM_DTUPD1_DTHUPD_Pos = 0x0
	// Bit mask of DTHUPD field.
	PWM_DTUPD1_DTHUPD_Msk = 0xffff
	// Position of DTLUPD field.
	PWM_DTUPD1_DTLUPD_Pos = 0x10
	// Bit mask of DTLUPD field.
	PWM_DTUPD1_DTLUPD_Msk = 0xffff0000

	// CMR2: PWM Channel Mode Register (ch_num = 2)
	// Position of CPRE field.
	PWM_CMR2_CPRE_Pos = 0x0
	// Bit mask of CPRE field.
	PWM_CMR2_CPRE_Msk = 0xf
	// Master clock
	PWM_CMR2_CPRE_MCK = 0x0
	// Master clock/2
	PWM_CMR2_CPRE_MCK_DIV_2 = 0x1
	// Master clock/4
	PWM_CMR2_CPRE_MCK_DIV_4 = 0x2
	// Master clock/8
	PWM_CMR2_CPRE_MCK_DIV_8 = 0x3
	// Master clock/16
	PWM_CMR2_CPRE_MCK_DIV_16 = 0x4
	// Master clock/32
	PWM_CMR2_CPRE_MCK_DIV_32 = 0x5
	// Master clock/64
	PWM_CMR2_CPRE_MCK_DIV_64 = 0x6
	// Master clock/128
	PWM_CMR2_CPRE_MCK_DIV_128 = 0x7
	// Master clock/256
	PWM_CMR2_CPRE_MCK_DIV_256 = 0x8
	// Master clock/512
	PWM_CMR2_CPRE_MCK_DIV_512 = 0x9
	// Master clock/1024
	PWM_CMR2_CPRE_MCK_DIV_1024 = 0xa
	// Clock A
	PWM_CMR2_CPRE_CLKA = 0xb
	// Clock B
	PWM_CMR2_CPRE_CLKB = 0xc
	// Position of CALG field.
	PWM_CMR2_CALG_Pos = 0x8
	// Bit mask of CALG field.
	PWM_CMR2_CALG_Msk = 0x100
	// Bit CALG.
	PWM_CMR2_CALG = 0x100
	// Position of CPOL field.
	PWM_CMR2_CPOL_Pos = 0x9
	// Bit mask of CPOL field.
	PWM_CMR2_CPOL_Msk = 0x200
	// Bit CPOL.
	PWM_CMR2_CPOL = 0x200
	// Position of CES field.
	PWM_CMR2_CES_Pos = 0xa
	// Bit mask of CES field.
	PWM_CMR2_CES_Msk = 0x400
	// Bit CES.
	PWM_CMR2_CES = 0x400
	// Position of DTE field.
	PWM_CMR2_DTE_Pos = 0x10
	// Bit mask of DTE field.
	PWM_CMR2_DTE_Msk = 0x10000
	// Bit DTE.
	PWM_CMR2_DTE = 0x10000
	// Position of DTHI field.
	PWM_CMR2_DTHI_Pos = 0x11
	// Bit mask of DTHI field.
	PWM_CMR2_DTHI_Msk = 0x20000
	// Bit DTHI.
	PWM_CMR2_DTHI = 0x20000
	// Position of DTLI field.
	PWM_CMR2_DTLI_Pos = 0x12
	// Bit mask of DTLI field.
	PWM_CMR2_DTLI_Msk = 0x40000
	// Bit DTLI.
	PWM_CMR2_DTLI = 0x40000

	// CDTY2: PWM Channel Duty Cycle Register (ch_num = 2)
	// Position of CDTY field.
	PWM_CDTY2_CDTY_Pos = 0x0
	// Bit mask of CDTY field.
	PWM_CDTY2_CDTY_Msk = 0xffffff

	// CDTYUPD2: PWM Channel Duty Cycle Update Register (ch_num = 2)
	// Position of CDTYUPD field.
	PWM_CDTYUPD2_CDTYUPD_Pos = 0x0
	// Bit mask of CDTYUPD field.
	PWM_CDTYUPD2_CDTYUPD_Msk = 0xffffff

	// CPRD2: PWM Channel Period Register (ch_num = 2)
	// Position of CPRD field.
	PWM_CPRD2_CPRD_Pos = 0x0
	// Bit mask of CPRD field.
	PWM_CPRD2_CPRD_Msk = 0xffffff

	// CPRDUPD2: PWM Channel Period Update Register (ch_num = 2)
	// Position of CPRDUPD field.
	PWM_CPRDUPD2_CPRDUPD_Pos = 0x0
	// Bit mask of CPRDUPD field.
	PWM_CPRDUPD2_CPRDUPD_Msk = 0xffffff

	// CCNT2: PWM Channel Counter Register (ch_num = 2)
	// Position of CNT field.
	PWM_CCNT2_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_CCNT2_CNT_Msk = 0xffffff

	// DT2: PWM Channel Dead Time Register (ch_num = 2)
	// Position of DTH field.
	PWM_DT2_DTH_Pos = 0x0
	// Bit mask of DTH field.
	PWM_DT2_DTH_Msk = 0xffff
	// Position of DTL field.
	PWM_DT2_DTL_Pos = 0x10
	// Bit mask of DTL field.
	PWM_DT2_DTL_Msk = 0xffff0000

	// DTUPD2: PWM Channel Dead Time Update Register (ch_num = 2)
	// Position of DTHUPD field.
	PWM_DTUPD2_DTHUPD_Pos = 0x0
	// Bit mask of DTHUPD field.
	PWM_DTUPD2_DTHUPD_Msk = 0xffff
	// Position of DTLUPD field.
	PWM_DTUPD2_DTLUPD_Pos = 0x10
	// Bit mask of DTLUPD field.
	PWM_DTUPD2_DTLUPD_Msk = 0xffff0000

	// CMR3: PWM Channel Mode Register (ch_num = 3)
	// Position of CPRE field.
	PWM_CMR3_CPRE_Pos = 0x0
	// Bit mask of CPRE field.
	PWM_CMR3_CPRE_Msk = 0xf
	// Master clock
	PWM_CMR3_CPRE_MCK = 0x0
	// Master clock/2
	PWM_CMR3_CPRE_MCK_DIV_2 = 0x1
	// Master clock/4
	PWM_CMR3_CPRE_MCK_DIV_4 = 0x2
	// Master clock/8
	PWM_CMR3_CPRE_MCK_DIV_8 = 0x3
	// Master clock/16
	PWM_CMR3_CPRE_MCK_DIV_16 = 0x4
	// Master clock/32
	PWM_CMR3_CPRE_MCK_DIV_32 = 0x5
	// Master clock/64
	PWM_CMR3_CPRE_MCK_DIV_64 = 0x6
	// Master clock/128
	PWM_CMR3_CPRE_MCK_DIV_128 = 0x7
	// Master clock/256
	PWM_CMR3_CPRE_MCK_DIV_256 = 0x8
	// Master clock/512
	PWM_CMR3_CPRE_MCK_DIV_512 = 0x9
	// Master clock/1024
	PWM_CMR3_CPRE_MCK_DIV_1024 = 0xa
	// Clock A
	PWM_CMR3_CPRE_CLKA = 0xb
	// Clock B
	PWM_CMR3_CPRE_CLKB = 0xc
	// Position of CALG field.
	PWM_CMR3_CALG_Pos = 0x8
	// Bit mask of CALG field.
	PWM_CMR3_CALG_Msk = 0x100
	// Bit CALG.
	PWM_CMR3_CALG = 0x100
	// Position of CPOL field.
	PWM_CMR3_CPOL_Pos = 0x9
	// Bit mask of CPOL field.
	PWM_CMR3_CPOL_Msk = 0x200
	// Bit CPOL.
	PWM_CMR3_CPOL = 0x200
	// Position of CES field.
	PWM_CMR3_CES_Pos = 0xa
	// Bit mask of CES field.
	PWM_CMR3_CES_Msk = 0x400
	// Bit CES.
	PWM_CMR3_CES = 0x400
	// Position of DTE field.
	PWM_CMR3_DTE_Pos = 0x10
	// Bit mask of DTE field.
	PWM_CMR3_DTE_Msk = 0x10000
	// Bit DTE.
	PWM_CMR3_DTE = 0x10000
	// Position of DTHI field.
	PWM_CMR3_DTHI_Pos = 0x11
	// Bit mask of DTHI field.
	PWM_CMR3_DTHI_Msk = 0x20000
	// Bit DTHI.
	PWM_CMR3_DTHI = 0x20000
	// Position of DTLI field.
	PWM_CMR3_DTLI_Pos = 0x12
	// Bit mask of DTLI field.
	PWM_CMR3_DTLI_Msk = 0x40000
	// Bit DTLI.
	PWM_CMR3_DTLI = 0x40000

	// CDTY3: PWM Channel Duty Cycle Register (ch_num = 3)
	// Position of CDTY field.
	PWM_CDTY3_CDTY_Pos = 0x0
	// Bit mask of CDTY field.
	PWM_CDTY3_CDTY_Msk = 0xffffff

	// CDTYUPD3: PWM Channel Duty Cycle Update Register (ch_num = 3)
	// Position of CDTYUPD field.
	PWM_CDTYUPD3_CDTYUPD_Pos = 0x0
	// Bit mask of CDTYUPD field.
	PWM_CDTYUPD3_CDTYUPD_Msk = 0xffffff

	// CPRD3: PWM Channel Period Register (ch_num = 3)
	// Position of CPRD field.
	PWM_CPRD3_CPRD_Pos = 0x0
	// Bit mask of CPRD field.
	PWM_CPRD3_CPRD_Msk = 0xffffff

	// CPRDUPD3: PWM Channel Period Update Register (ch_num = 3)
	// Position of CPRDUPD field.
	PWM_CPRDUPD3_CPRDUPD_Pos = 0x0
	// Bit mask of CPRDUPD field.
	PWM_CPRDUPD3_CPRDUPD_Msk = 0xffffff

	// CCNT3: PWM Channel Counter Register (ch_num = 3)
	// Position of CNT field.
	PWM_CCNT3_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_CCNT3_CNT_Msk = 0xffffff

	// DT3: PWM Channel Dead Time Register (ch_num = 3)
	// Position of DTH field.
	PWM_DT3_DTH_Pos = 0x0
	// Bit mask of DTH field.
	PWM_DT3_DTH_Msk = 0xffff
	// Position of DTL field.
	PWM_DT3_DTL_Pos = 0x10
	// Bit mask of DTL field.
	PWM_DT3_DTL_Msk = 0xffff0000

	// DTUPD3: PWM Channel Dead Time Update Register (ch_num = 3)
	// Position of DTHUPD field.
	PWM_DTUPD3_DTHUPD_Pos = 0x0
	// Bit mask of DTHUPD field.
	PWM_DTUPD3_DTHUPD_Msk = 0xffff
	// Position of DTLUPD field.
	PWM_DTUPD3_DTLUPD_Pos = 0x10
	// Bit mask of DTLUPD field.
	PWM_DTUPD3_DTLUPD_Msk = 0xffff0000
)

// Constants for ISI: Image Sensor Interface
const (
	// CFG1: ISI Configuration 1 Register
	// Position of HSYNC_POL field.
	ISI_CFG1_HSYNC_POL_Pos = 0x2
	// Bit mask of HSYNC_POL field.
	ISI_CFG1_HSYNC_POL_Msk = 0x4
	// Bit HSYNC_POL.
	ISI_CFG1_HSYNC_POL = 0x4
	// Position of VSYNC_POL field.
	ISI_CFG1_VSYNC_POL_Pos = 0x3
	// Bit mask of VSYNC_POL field.
	ISI_CFG1_VSYNC_POL_Msk = 0x8
	// Bit VSYNC_POL.
	ISI_CFG1_VSYNC_POL = 0x8
	// Position of PIXCLK_POL field.
	ISI_CFG1_PIXCLK_POL_Pos = 0x4
	// Bit mask of PIXCLK_POL field.
	ISI_CFG1_PIXCLK_POL_Msk = 0x10
	// Bit PIXCLK_POL.
	ISI_CFG1_PIXCLK_POL = 0x10
	// Position of EMB_SYNC field.
	ISI_CFG1_EMB_SYNC_Pos = 0x6
	// Bit mask of EMB_SYNC field.
	ISI_CFG1_EMB_SYNC_Msk = 0x40
	// Bit EMB_SYNC.
	ISI_CFG1_EMB_SYNC = 0x40
	// Position of CRC_SYNC field.
	ISI_CFG1_CRC_SYNC_Pos = 0x7
	// Bit mask of CRC_SYNC field.
	ISI_CFG1_CRC_SYNC_Msk = 0x80
	// Bit CRC_SYNC.
	ISI_CFG1_CRC_SYNC = 0x80
	// Position of FRATE field.
	ISI_CFG1_FRATE_Pos = 0x8
	// Bit mask of FRATE field.
	ISI_CFG1_FRATE_Msk = 0x700
	// Position of DISCR field.
	ISI_CFG1_DISCR_Pos = 0xb
	// Bit mask of DISCR field.
	ISI_CFG1_DISCR_Msk = 0x800
	// Bit DISCR.
	ISI_CFG1_DISCR = 0x800
	// Position of FULL field.
	ISI_CFG1_FULL_Pos = 0xc
	// Bit mask of FULL field.
	ISI_CFG1_FULL_Msk = 0x1000
	// Bit FULL.
	ISI_CFG1_FULL = 0x1000
	// Position of THMASK field.
	ISI_CFG1_THMASK_Pos = 0xd
	// Bit mask of THMASK field.
	ISI_CFG1_THMASK_Msk = 0x6000
	// Only 4 beats AHB burst allowed
	ISI_CFG1_THMASK_BEATS_4 = 0x0
	// Only 4 and 8 beats AHB burst allowed
	ISI_CFG1_THMASK_BEATS_8 = 0x1
	// 4, 8 and 16 beats AHB burst allowed
	ISI_CFG1_THMASK_BEATS_16 = 0x2
	// Position of SLD field.
	ISI_CFG1_SLD_Pos = 0x10
	// Bit mask of SLD field.
	ISI_CFG1_SLD_Msk = 0xff0000
	// Position of SFD field.
	ISI_CFG1_SFD_Pos = 0x18
	// Bit mask of SFD field.
	ISI_CFG1_SFD_Msk = 0xff000000

	// CFG2: ISI Configuration 2 Register
	// Position of IM_VSIZE field.
	ISI_CFG2_IM_VSIZE_Pos = 0x0
	// Bit mask of IM_VSIZE field.
	ISI_CFG2_IM_VSIZE_Msk = 0x7ff
	// Position of GS_MODE field.
	ISI_CFG2_GS_MODE_Pos = 0xb
	// Bit mask of GS_MODE field.
	ISI_CFG2_GS_MODE_Msk = 0x800
	// Bit GS_MODE.
	ISI_CFG2_GS_MODE = 0x800
	// Position of RGB_MODE field.
	ISI_CFG2_RGB_MODE_Pos = 0xc
	// Bit mask of RGB_MODE field.
	ISI_CFG2_RGB_MODE_Msk = 0x1000
	// Bit RGB_MODE.
	ISI_CFG2_RGB_MODE = 0x1000
	// Position of GRAYSCALE field.
	ISI_CFG2_GRAYSCALE_Pos = 0xd
	// Bit mask of GRAYSCALE field.
	ISI_CFG2_GRAYSCALE_Msk = 0x2000
	// Bit GRAYSCALE.
	ISI_CFG2_GRAYSCALE = 0x2000
	// Position of RGB_SWAP field.
	ISI_CFG2_RGB_SWAP_Pos = 0xe
	// Bit mask of RGB_SWAP field.
	ISI_CFG2_RGB_SWAP_Msk = 0x4000
	// Bit RGB_SWAP.
	ISI_CFG2_RGB_SWAP = 0x4000
	// Position of COL_SPACE field.
	ISI_CFG2_COL_SPACE_Pos = 0xf
	// Bit mask of COL_SPACE field.
	ISI_CFG2_COL_SPACE_Msk = 0x8000
	// Bit COL_SPACE.
	ISI_CFG2_COL_SPACE = 0x8000
	// Position of IM_HSIZE field.
	ISI_CFG2_IM_HSIZE_Pos = 0x10
	// Bit mask of IM_HSIZE field.
	ISI_CFG2_IM_HSIZE_Msk = 0x7ff0000
	// Position of YCC_SWAP field.
	ISI_CFG2_YCC_SWAP_Pos = 0x1c
	// Bit mask of YCC_SWAP field.
	ISI_CFG2_YCC_SWAP_Msk = 0x30000000
	// Position of RGB_CFG field.
	ISI_CFG2_RGB_CFG_Pos = 0x1e
	// Bit mask of RGB_CFG field.
	ISI_CFG2_RGB_CFG_Msk = 0xc0000000

	// PSIZE: ISI Preview Size Register
	// Position of PREV_VSIZE field.
	ISI_PSIZE_PREV_VSIZE_Pos = 0x0
	// Bit mask of PREV_VSIZE field.
	ISI_PSIZE_PREV_VSIZE_Msk = 0x3ff
	// Position of PREV_HSIZE field.
	ISI_PSIZE_PREV_HSIZE_Pos = 0x10
	// Bit mask of PREV_HSIZE field.
	ISI_PSIZE_PREV_HSIZE_Msk = 0x3ff0000

	// PDECF: ISI Preview Decimation Factor Register
	// Position of DEC_FACTOR field.
	ISI_PDECF_DEC_FACTOR_Pos = 0x0
	// Bit mask of DEC_FACTOR field.
	ISI_PDECF_DEC_FACTOR_Msk = 0xff

	// Y2R_SET0: ISI CSC YCrCb To RGB Set 0 Register
	// Position of C0 field.
	ISI_Y2R_SET0_C0_Pos = 0x0
	// Bit mask of C0 field.
	ISI_Y2R_SET0_C0_Msk = 0xff
	// Position of C1 field.
	ISI_Y2R_SET0_C1_Pos = 0x8
	// Bit mask of C1 field.
	ISI_Y2R_SET0_C1_Msk = 0xff00
	// Position of C2 field.
	ISI_Y2R_SET0_C2_Pos = 0x10
	// Bit mask of C2 field.
	ISI_Y2R_SET0_C2_Msk = 0xff0000
	// Position of C3 field.
	ISI_Y2R_SET0_C3_Pos = 0x18
	// Bit mask of C3 field.
	ISI_Y2R_SET0_C3_Msk = 0xff000000

	// Y2R_SET1: ISI CSC YCrCb To RGB Set 1 Register
	// Position of C4 field.
	ISI_Y2R_SET1_C4_Pos = 0x0
	// Bit mask of C4 field.
	ISI_Y2R_SET1_C4_Msk = 0x1ff
	// Position of Yoff field.
	ISI_Y2R_SET1_Yoff_Pos = 0xc
	// Bit mask of Yoff field.
	ISI_Y2R_SET1_Yoff_Msk = 0x1000
	// Bit Yoff.
	ISI_Y2R_SET1_Yoff = 0x1000
	// Position of Croff field.
	ISI_Y2R_SET1_Croff_Pos = 0xd
	// Bit mask of Croff field.
	ISI_Y2R_SET1_Croff_Msk = 0x2000
	// Bit Croff.
	ISI_Y2R_SET1_Croff = 0x2000
	// Position of Cboff field.
	ISI_Y2R_SET1_Cboff_Pos = 0xe
	// Bit mask of Cboff field.
	ISI_Y2R_SET1_Cboff_Msk = 0x4000
	// Bit Cboff.
	ISI_Y2R_SET1_Cboff = 0x4000

	// R2Y_SET0: ISI CSC RGB To YCrCb Set 0 Register
	// Position of C0 field.
	ISI_R2Y_SET0_C0_Pos = 0x0
	// Bit mask of C0 field.
	ISI_R2Y_SET0_C0_Msk = 0x7f
	// Position of C1 field.
	ISI_R2Y_SET0_C1_Pos = 0x8
	// Bit mask of C1 field.
	ISI_R2Y_SET0_C1_Msk = 0x7f00
	// Position of C2 field.
	ISI_R2Y_SET0_C2_Pos = 0x10
	// Bit mask of C2 field.
	ISI_R2Y_SET0_C2_Msk = 0x7f0000
	// Position of Roff field.
	ISI_R2Y_SET0_Roff_Pos = 0x18
	// Bit mask of Roff field.
	ISI_R2Y_SET0_Roff_Msk = 0x1000000
	// Bit Roff.
	ISI_R2Y_SET0_Roff = 0x1000000

	// R2Y_SET1: ISI CSC RGB To YCrCb Set 1 Register
	// Position of C3 field.
	ISI_R2Y_SET1_C3_Pos = 0x0
	// Bit mask of C3 field.
	ISI_R2Y_SET1_C3_Msk = 0x7f
	// Position of C4 field.
	ISI_R2Y_SET1_C4_Pos = 0x8
	// Bit mask of C4 field.
	ISI_R2Y_SET1_C4_Msk = 0x7f00
	// Position of C5 field.
	ISI_R2Y_SET1_C5_Pos = 0x10
	// Bit mask of C5 field.
	ISI_R2Y_SET1_C5_Msk = 0x7f0000
	// Position of Goff field.
	ISI_R2Y_SET1_Goff_Pos = 0x18
	// Bit mask of Goff field.
	ISI_R2Y_SET1_Goff_Msk = 0x1000000
	// Bit Goff.
	ISI_R2Y_SET1_Goff = 0x1000000

	// R2Y_SET2: ISI CSC RGB To YCrCb Set 2 Register
	// Position of C6 field.
	ISI_R2Y_SET2_C6_Pos = 0x0
	// Bit mask of C6 field.
	ISI_R2Y_SET2_C6_Msk = 0x7f
	// Position of C7 field.
	ISI_R2Y_SET2_C7_Pos = 0x8
	// Bit mask of C7 field.
	ISI_R2Y_SET2_C7_Msk = 0x7f00
	// Position of C8 field.
	ISI_R2Y_SET2_C8_Pos = 0x10
	// Bit mask of C8 field.
	ISI_R2Y_SET2_C8_Msk = 0x7f0000
	// Position of Boff field.
	ISI_R2Y_SET2_Boff_Pos = 0x18
	// Bit mask of Boff field.
	ISI_R2Y_SET2_Boff_Msk = 0x1000000
	// Bit Boff.
	ISI_R2Y_SET2_Boff = 0x1000000

	// CR: ISI Control Register
	// Position of ISI_EN field.
	ISI_CR_ISI_EN_Pos = 0x0
	// Bit mask of ISI_EN field.
	ISI_CR_ISI_EN_Msk = 0x1
	// Bit ISI_EN.
	ISI_CR_ISI_EN = 0x1
	// Position of ISI_DIS field.
	ISI_CR_ISI_DIS_Pos = 0x1
	// Bit mask of ISI_DIS field.
	ISI_CR_ISI_DIS_Msk = 0x2
	// Bit ISI_DIS.
	ISI_CR_ISI_DIS = 0x2
	// Position of ISI_SRST field.
	ISI_CR_ISI_SRST_Pos = 0x2
	// Bit mask of ISI_SRST field.
	ISI_CR_ISI_SRST_Msk = 0x4
	// Bit ISI_SRST.
	ISI_CR_ISI_SRST = 0x4
	// Position of ISI_CDC field.
	ISI_CR_ISI_CDC_Pos = 0x8
	// Bit mask of ISI_CDC field.
	ISI_CR_ISI_CDC_Msk = 0x100
	// Bit ISI_CDC.
	ISI_CR_ISI_CDC = 0x100

	// SR: ISI Status Register
	// Position of ENABLE field.
	ISI_SR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	ISI_SR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	ISI_SR_ENABLE = 0x1
	// Position of DIS_DONE field.
	ISI_SR_DIS_DONE_Pos = 0x1
	// Bit mask of DIS_DONE field.
	ISI_SR_DIS_DONE_Msk = 0x2
	// Bit DIS_DONE.
	ISI_SR_DIS_DONE = 0x2
	// Position of SRST field.
	ISI_SR_SRST_Pos = 0x2
	// Bit mask of SRST field.
	ISI_SR_SRST_Msk = 0x4
	// Bit SRST.
	ISI_SR_SRST = 0x4
	// Position of CDC_PND field.
	ISI_SR_CDC_PND_Pos = 0x8
	// Bit mask of CDC_PND field.
	ISI_SR_CDC_PND_Msk = 0x100
	// Bit CDC_PND.
	ISI_SR_CDC_PND = 0x100
	// Position of VSYNC field.
	ISI_SR_VSYNC_Pos = 0xa
	// Bit mask of VSYNC field.
	ISI_SR_VSYNC_Msk = 0x400
	// Bit VSYNC.
	ISI_SR_VSYNC = 0x400
	// Position of PXFR_DONE field.
	ISI_SR_PXFR_DONE_Pos = 0x10
	// Bit mask of PXFR_DONE field.
	ISI_SR_PXFR_DONE_Msk = 0x10000
	// Bit PXFR_DONE.
	ISI_SR_PXFR_DONE = 0x10000
	// Position of CXFR_DONE field.
	ISI_SR_CXFR_DONE_Pos = 0x11
	// Bit mask of CXFR_DONE field.
	ISI_SR_CXFR_DONE_Msk = 0x20000
	// Bit CXFR_DONE.
	ISI_SR_CXFR_DONE = 0x20000
	// Position of SIP field.
	ISI_SR_SIP_Pos = 0x13
	// Bit mask of SIP field.
	ISI_SR_SIP_Msk = 0x80000
	// Bit SIP.
	ISI_SR_SIP = 0x80000
	// Position of P_OVR field.
	ISI_SR_P_OVR_Pos = 0x18
	// Bit mask of P_OVR field.
	ISI_SR_P_OVR_Msk = 0x1000000
	// Bit P_OVR.
	ISI_SR_P_OVR = 0x1000000
	// Position of C_OVR field.
	ISI_SR_C_OVR_Pos = 0x19
	// Bit mask of C_OVR field.
	ISI_SR_C_OVR_Msk = 0x2000000
	// Bit C_OVR.
	ISI_SR_C_OVR = 0x2000000
	// Position of CRC_ERR field.
	ISI_SR_CRC_ERR_Pos = 0x1a
	// Bit mask of CRC_ERR field.
	ISI_SR_CRC_ERR_Msk = 0x4000000
	// Bit CRC_ERR.
	ISI_SR_CRC_ERR = 0x4000000
	// Position of FR_OVR field.
	ISI_SR_FR_OVR_Pos = 0x1b
	// Bit mask of FR_OVR field.
	ISI_SR_FR_OVR_Msk = 0x8000000
	// Bit FR_OVR.
	ISI_SR_FR_OVR = 0x8000000

	// IER: ISI Interrupt Enable Register
	// Position of DIS_DONE field.
	ISI_IER_DIS_DONE_Pos = 0x1
	// Bit mask of DIS_DONE field.
	ISI_IER_DIS_DONE_Msk = 0x2
	// Bit DIS_DONE.
	ISI_IER_DIS_DONE = 0x2
	// Position of SRST field.
	ISI_IER_SRST_Pos = 0x2
	// Bit mask of SRST field.
	ISI_IER_SRST_Msk = 0x4
	// Bit SRST.
	ISI_IER_SRST = 0x4
	// Position of VSYNC field.
	ISI_IER_VSYNC_Pos = 0xa
	// Bit mask of VSYNC field.
	ISI_IER_VSYNC_Msk = 0x400
	// Bit VSYNC.
	ISI_IER_VSYNC = 0x400
	// Position of PXFR_DONE field.
	ISI_IER_PXFR_DONE_Pos = 0x10
	// Bit mask of PXFR_DONE field.
	ISI_IER_PXFR_DONE_Msk = 0x10000
	// Bit PXFR_DONE.
	ISI_IER_PXFR_DONE = 0x10000
	// Position of CXFR_DONE field.
	ISI_IER_CXFR_DONE_Pos = 0x11
	// Bit mask of CXFR_DONE field.
	ISI_IER_CXFR_DONE_Msk = 0x20000
	// Bit CXFR_DONE.
	ISI_IER_CXFR_DONE = 0x20000
	// Position of P_OVR field.
	ISI_IER_P_OVR_Pos = 0x18
	// Bit mask of P_OVR field.
	ISI_IER_P_OVR_Msk = 0x1000000
	// Bit P_OVR.
	ISI_IER_P_OVR = 0x1000000
	// Position of C_OVR field.
	ISI_IER_C_OVR_Pos = 0x19
	// Bit mask of C_OVR field.
	ISI_IER_C_OVR_Msk = 0x2000000
	// Bit C_OVR.
	ISI_IER_C_OVR = 0x2000000
	// Position of CRC_ERR field.
	ISI_IER_CRC_ERR_Pos = 0x1a
	// Bit mask of CRC_ERR field.
	ISI_IER_CRC_ERR_Msk = 0x4000000
	// Bit CRC_ERR.
	ISI_IER_CRC_ERR = 0x4000000
	// Position of FR_OVR field.
	ISI_IER_FR_OVR_Pos = 0x1b
	// Bit mask of FR_OVR field.
	ISI_IER_FR_OVR_Msk = 0x8000000
	// Bit FR_OVR.
	ISI_IER_FR_OVR = 0x8000000

	// IDR: ISI Interrupt Disable Register
	// Position of DIS_DONE field.
	ISI_IDR_DIS_DONE_Pos = 0x1
	// Bit mask of DIS_DONE field.
	ISI_IDR_DIS_DONE_Msk = 0x2
	// Bit DIS_DONE.
	ISI_IDR_DIS_DONE = 0x2
	// Position of SRST field.
	ISI_IDR_SRST_Pos = 0x2
	// Bit mask of SRST field.
	ISI_IDR_SRST_Msk = 0x4
	// Bit SRST.
	ISI_IDR_SRST = 0x4
	// Position of VSYNC field.
	ISI_IDR_VSYNC_Pos = 0xa
	// Bit mask of VSYNC field.
	ISI_IDR_VSYNC_Msk = 0x400
	// Bit VSYNC.
	ISI_IDR_VSYNC = 0x400
	// Position of PXFR_DONE field.
	ISI_IDR_PXFR_DONE_Pos = 0x10
	// Bit mask of PXFR_DONE field.
	ISI_IDR_PXFR_DONE_Msk = 0x10000
	// Bit PXFR_DONE.
	ISI_IDR_PXFR_DONE = 0x10000
	// Position of CXFR_DONE field.
	ISI_IDR_CXFR_DONE_Pos = 0x11
	// Bit mask of CXFR_DONE field.
	ISI_IDR_CXFR_DONE_Msk = 0x20000
	// Bit CXFR_DONE.
	ISI_IDR_CXFR_DONE = 0x20000
	// Position of P_OVR field.
	ISI_IDR_P_OVR_Pos = 0x18
	// Bit mask of P_OVR field.
	ISI_IDR_P_OVR_Msk = 0x1000000
	// Bit P_OVR.
	ISI_IDR_P_OVR = 0x1000000
	// Position of C_OVR field.
	ISI_IDR_C_OVR_Pos = 0x19
	// Bit mask of C_OVR field.
	ISI_IDR_C_OVR_Msk = 0x2000000
	// Bit C_OVR.
	ISI_IDR_C_OVR = 0x2000000
	// Position of CRC_ERR field.
	ISI_IDR_CRC_ERR_Pos = 0x1a
	// Bit mask of CRC_ERR field.
	ISI_IDR_CRC_ERR_Msk = 0x4000000
	// Bit CRC_ERR.
	ISI_IDR_CRC_ERR = 0x4000000
	// Position of FR_OVR field.
	ISI_IDR_FR_OVR_Pos = 0x1b
	// Bit mask of FR_OVR field.
	ISI_IDR_FR_OVR_Msk = 0x8000000
	// Bit FR_OVR.
	ISI_IDR_FR_OVR = 0x8000000

	// IMR: ISI Interrupt Mask Register
	// Position of DIS_DONE field.
	ISI_IMR_DIS_DONE_Pos = 0x1
	// Bit mask of DIS_DONE field.
	ISI_IMR_DIS_DONE_Msk = 0x2
	// Bit DIS_DONE.
	ISI_IMR_DIS_DONE = 0x2
	// Position of SRST field.
	ISI_IMR_SRST_Pos = 0x2
	// Bit mask of SRST field.
	ISI_IMR_SRST_Msk = 0x4
	// Bit SRST.
	ISI_IMR_SRST = 0x4
	// Position of VSYNC field.
	ISI_IMR_VSYNC_Pos = 0xa
	// Bit mask of VSYNC field.
	ISI_IMR_VSYNC_Msk = 0x400
	// Bit VSYNC.
	ISI_IMR_VSYNC = 0x400
	// Position of PXFR_DONE field.
	ISI_IMR_PXFR_DONE_Pos = 0x10
	// Bit mask of PXFR_DONE field.
	ISI_IMR_PXFR_DONE_Msk = 0x10000
	// Bit PXFR_DONE.
	ISI_IMR_PXFR_DONE = 0x10000
	// Position of CXFR_DONE field.
	ISI_IMR_CXFR_DONE_Pos = 0x11
	// Bit mask of CXFR_DONE field.
	ISI_IMR_CXFR_DONE_Msk = 0x20000
	// Bit CXFR_DONE.
	ISI_IMR_CXFR_DONE = 0x20000
	// Position of P_OVR field.
	ISI_IMR_P_OVR_Pos = 0x18
	// Bit mask of P_OVR field.
	ISI_IMR_P_OVR_Msk = 0x1000000
	// Bit P_OVR.
	ISI_IMR_P_OVR = 0x1000000
	// Position of C_OVR field.
	ISI_IMR_C_OVR_Pos = 0x19
	// Bit mask of C_OVR field.
	ISI_IMR_C_OVR_Msk = 0x2000000
	// Bit C_OVR.
	ISI_IMR_C_OVR = 0x2000000
	// Position of CRC_ERR field.
	ISI_IMR_CRC_ERR_Pos = 0x1a
	// Bit mask of CRC_ERR field.
	ISI_IMR_CRC_ERR_Msk = 0x4000000
	// Bit CRC_ERR.
	ISI_IMR_CRC_ERR = 0x4000000
	// Position of FR_OVR field.
	ISI_IMR_FR_OVR_Pos = 0x1b
	// Bit mask of FR_OVR field.
	ISI_IMR_FR_OVR_Msk = 0x8000000
	// Bit FR_OVR.
	ISI_IMR_FR_OVR = 0x8000000

	// DMA_CHER: DMA Channel Enable Register
	// Position of P_CH_EN field.
	ISI_DMA_CHER_P_CH_EN_Pos = 0x0
	// Bit mask of P_CH_EN field.
	ISI_DMA_CHER_P_CH_EN_Msk = 0x1
	// Bit P_CH_EN.
	ISI_DMA_CHER_P_CH_EN = 0x1
	// Position of C_CH_EN field.
	ISI_DMA_CHER_C_CH_EN_Pos = 0x1
	// Bit mask of C_CH_EN field.
	ISI_DMA_CHER_C_CH_EN_Msk = 0x2
	// Bit C_CH_EN.
	ISI_DMA_CHER_C_CH_EN = 0x2

	// DMA_CHDR: DMA Channel Disable Register
	// Position of P_CH_DIS field.
	ISI_DMA_CHDR_P_CH_DIS_Pos = 0x0
	// Bit mask of P_CH_DIS field.
	ISI_DMA_CHDR_P_CH_DIS_Msk = 0x1
	// Bit P_CH_DIS.
	ISI_DMA_CHDR_P_CH_DIS = 0x1
	// Position of C_CH_DIS field.
	ISI_DMA_CHDR_C_CH_DIS_Pos = 0x1
	// Bit mask of C_CH_DIS field.
	ISI_DMA_CHDR_C_CH_DIS_Msk = 0x2
	// Bit C_CH_DIS.
	ISI_DMA_CHDR_C_CH_DIS = 0x2

	// DMA_CHSR: DMA Channel Status Register
	// Position of P_CH_S field.
	ISI_DMA_CHSR_P_CH_S_Pos = 0x0
	// Bit mask of P_CH_S field.
	ISI_DMA_CHSR_P_CH_S_Msk = 0x1
	// Bit P_CH_S.
	ISI_DMA_CHSR_P_CH_S = 0x1
	// Position of C_CH_S field.
	ISI_DMA_CHSR_C_CH_S_Pos = 0x1
	// Bit mask of C_CH_S field.
	ISI_DMA_CHSR_C_CH_S_Msk = 0x2
	// Bit C_CH_S.
	ISI_DMA_CHSR_C_CH_S = 0x2

	// DMA_P_ADDR: DMA Preview Base Address Register
	// Position of P_ADDR field.
	ISI_DMA_P_ADDR_P_ADDR_Pos = 0x2
	// Bit mask of P_ADDR field.
	ISI_DMA_P_ADDR_P_ADDR_Msk = 0xfffffffc

	// DMA_P_CTRL: DMA Preview Control Register
	// Position of P_FETCH field.
	ISI_DMA_P_CTRL_P_FETCH_Pos = 0x0
	// Bit mask of P_FETCH field.
	ISI_DMA_P_CTRL_P_FETCH_Msk = 0x1
	// Bit P_FETCH.
	ISI_DMA_P_CTRL_P_FETCH = 0x1
	// Position of P_WB field.
	ISI_DMA_P_CTRL_P_WB_Pos = 0x1
	// Bit mask of P_WB field.
	ISI_DMA_P_CTRL_P_WB_Msk = 0x2
	// Bit P_WB.
	ISI_DMA_P_CTRL_P_WB = 0x2
	// Position of P_IEN field.
	ISI_DMA_P_CTRL_P_IEN_Pos = 0x2
	// Bit mask of P_IEN field.
	ISI_DMA_P_CTRL_P_IEN_Msk = 0x4
	// Bit P_IEN.
	ISI_DMA_P_CTRL_P_IEN = 0x4
	// Position of P_DONE field.
	ISI_DMA_P_CTRL_P_DONE_Pos = 0x3
	// Bit mask of P_DONE field.
	ISI_DMA_P_CTRL_P_DONE_Msk = 0x8
	// Bit P_DONE.
	ISI_DMA_P_CTRL_P_DONE = 0x8

	// DMA_P_DSCR: DMA Preview Descriptor Address Register
	// Position of P_DSCR field.
	ISI_DMA_P_DSCR_P_DSCR_Pos = 0x2
	// Bit mask of P_DSCR field.
	ISI_DMA_P_DSCR_P_DSCR_Msk = 0xfffffffc

	// DMA_C_ADDR: DMA Codec Base Address Register
	// Position of C_ADDR field.
	ISI_DMA_C_ADDR_C_ADDR_Pos = 0x2
	// Bit mask of C_ADDR field.
	ISI_DMA_C_ADDR_C_ADDR_Msk = 0xfffffffc

	// DMA_C_CTRL: DMA Codec Control Register
	// Position of C_FETCH field.
	ISI_DMA_C_CTRL_C_FETCH_Pos = 0x0
	// Bit mask of C_FETCH field.
	ISI_DMA_C_CTRL_C_FETCH_Msk = 0x1
	// Bit C_FETCH.
	ISI_DMA_C_CTRL_C_FETCH = 0x1
	// Position of C_WB field.
	ISI_DMA_C_CTRL_C_WB_Pos = 0x1
	// Bit mask of C_WB field.
	ISI_DMA_C_CTRL_C_WB_Msk = 0x2
	// Bit C_WB.
	ISI_DMA_C_CTRL_C_WB = 0x2
	// Position of C_IEN field.
	ISI_DMA_C_CTRL_C_IEN_Pos = 0x2
	// Bit mask of C_IEN field.
	ISI_DMA_C_CTRL_C_IEN_Msk = 0x4
	// Bit C_IEN.
	ISI_DMA_C_CTRL_C_IEN = 0x4
	// Position of C_DONE field.
	ISI_DMA_C_CTRL_C_DONE_Pos = 0x3
	// Bit mask of C_DONE field.
	ISI_DMA_C_CTRL_C_DONE_Msk = 0x8
	// Bit C_DONE.
	ISI_DMA_C_CTRL_C_DONE = 0x8

	// DMA_C_DSCR: DMA Codec Descriptor Address Register
	// Position of C_DSCR field.
	ISI_DMA_C_DSCR_C_DSCR_Pos = 0x2
	// Bit mask of C_DSCR field.
	ISI_DMA_C_DSCR_C_DSCR_Msk = 0xfffffffc

	// WPCR: Write Protection Control Register
	// Position of WP_EN field.
	ISI_WPCR_WP_EN_Pos = 0x0
	// Bit mask of WP_EN field.
	ISI_WPCR_WP_EN_Msk = 0x1
	// Bit WP_EN.
	ISI_WPCR_WP_EN = 0x1
	// Position of WP_KEY field.
	ISI_WPCR_WP_KEY_Pos = 0x8
	// Bit mask of WP_KEY field.
	ISI_WPCR_WP_KEY_Msk = 0xffffff00

	// WPSR: Write Protection Status Register
	// Position of WP_VS field.
	ISI_WPSR_WP_VS_Pos = 0x0
	// Bit mask of WP_VS field.
	ISI_WPSR_WP_VS_Msk = 0xf
	// Position of WP_VSRC field.
	ISI_WPSR_WP_VSRC_Pos = 0x8
	// Bit mask of WP_VSRC field.
	ISI_WPSR_WP_VSRC_Msk = 0xffff00
)

// Constants for SFR: Special Function Registers
const (
	// OHCIICR: OHCI Interrupt Configuration Register
	// Position of RES0 field.
	SFR_OHCIICR_RES0_Pos = 0x0
	// Bit mask of RES0 field.
	SFR_OHCIICR_RES0_Msk = 0x1
	// Bit RES0.
	SFR_OHCIICR_RES0 = 0x1
	// Position of RES1 field.
	SFR_OHCIICR_RES1_Pos = 0x1
	// Bit mask of RES1 field.
	SFR_OHCIICR_RES1_Msk = 0x2
	// Bit RES1.
	SFR_OHCIICR_RES1 = 0x2
	// Position of RES2 field.
	SFR_OHCIICR_RES2_Pos = 0x2
	// Bit mask of RES2 field.
	SFR_OHCIICR_RES2_Msk = 0x4
	// Bit RES2.
	SFR_OHCIICR_RES2 = 0x4
	// Position of ARIE field.
	SFR_OHCIICR_ARIE_Pos = 0x4
	// Bit mask of ARIE field.
	SFR_OHCIICR_ARIE_Msk = 0x10
	// Bit ARIE.
	SFR_OHCIICR_ARIE = 0x10
	// Position of APPSTART field.
	SFR_OHCIICR_APPSTART_Pos = 0x5
	// Bit mask of APPSTART field.
	SFR_OHCIICR_APPSTART_Msk = 0x20
	// Bit APPSTART.
	SFR_OHCIICR_APPSTART = 0x20
	// Position of UDPPUDIS field.
	SFR_OHCIICR_UDPPUDIS_Pos = 0x17
	// Bit mask of UDPPUDIS field.
	SFR_OHCIICR_UDPPUDIS_Msk = 0x800000
	// Bit UDPPUDIS.
	SFR_OHCIICR_UDPPUDIS = 0x800000

	// OHCIISR: OHCI Interrupt Status Register
	// Position of RIS0 field.
	SFR_OHCIISR_RIS0_Pos = 0x0
	// Bit mask of RIS0 field.
	SFR_OHCIISR_RIS0_Msk = 0x1
	// Bit RIS0.
	SFR_OHCIISR_RIS0 = 0x1
	// Position of RIS1 field.
	SFR_OHCIISR_RIS1_Pos = 0x1
	// Bit mask of RIS1 field.
	SFR_OHCIISR_RIS1_Msk = 0x2
	// Bit RIS1.
	SFR_OHCIISR_RIS1 = 0x2
	// Position of RIS2 field.
	SFR_OHCIISR_RIS2_Pos = 0x2
	// Bit mask of RIS2 field.
	SFR_OHCIISR_RIS2_Msk = 0x4
	// Bit RIS2.
	SFR_OHCIISR_RIS2 = 0x4

	// AHB: AHB Configuration Register
	// Position of PFETCH10 field.
	SFR_AHB_PFETCH10_Pos = 0xa
	// Bit mask of PFETCH10 field.
	SFR_AHB_PFETCH10_Msk = 0x400
	// Bit PFETCH10.
	SFR_AHB_PFETCH10 = 0x400
	// INCR undefined burst converted to burst of 4 beats.
	SFR_AHB_PFETCH10_INCR4 = 0x0
	// INCR undefined burst converted to burst of 8 beats.
	SFR_AHB_PFETCH10_INCR8 = 0x1
	// Position of PFETCH11 field.
	SFR_AHB_PFETCH11_Pos = 0xb
	// Bit mask of PFETCH11 field.
	SFR_AHB_PFETCH11_Msk = 0x800
	// Bit PFETCH11.
	SFR_AHB_PFETCH11 = 0x800
	// INCR undefined burst converted to burst of 4 beats.
	SFR_AHB_PFETCH11_INCR4 = 0x0
	// INCR undefined burst converted to burst of 8 beats.
	SFR_AHB_PFETCH11_INCR8 = 0x1
	// Position of PFETCH12 field.
	SFR_AHB_PFETCH12_Pos = 0xc
	// Bit mask of PFETCH12 field.
	SFR_AHB_PFETCH12_Msk = 0x1000
	// Bit PFETCH12.
	SFR_AHB_PFETCH12 = 0x1000
	// INCR undefined burst converted to burst of 4 beats.
	SFR_AHB_PFETCH12_INCR4 = 0x0
	// INCR undefined burst converted to burst of 8 beats.
	SFR_AHB_PFETCH12_INCR8 = 0x1
	// Position of PFETCH13 field.
	SFR_AHB_PFETCH13_Pos = 0xd
	// Bit mask of PFETCH13 field.
	SFR_AHB_PFETCH13_Msk = 0x2000
	// Bit PFETCH13.
	SFR_AHB_PFETCH13 = 0x2000
	// INCR undefined burst converted to burst of 4 beats.
	SFR_AHB_PFETCH13_INCR4 = 0x0
	// INCR undefined burst converted to burst of 8 beats.
	SFR_AHB_PFETCH13_INCR8 = 0x1
	// Position of PFETCH14 field.
	SFR_AHB_PFETCH14_Pos = 0xe
	// Bit mask of PFETCH14 field.
	SFR_AHB_PFETCH14_Msk = 0x4000
	// Bit PFETCH14.
	SFR_AHB_PFETCH14 = 0x4000
	// INCR undefined burst converted to burst of 4 beats.
	SFR_AHB_PFETCH14_INCR4 = 0x0
	// INCR undefined burst converted to burst of 8 beats.
	SFR_AHB_PFETCH14_INCR8 = 0x1
	// Position of DLBOPT10 field.
	SFR_AHB_DLBOPT10_Pos = 0x1a
	// Bit mask of DLBOPT10 field.
	SFR_AHB_DLBOPT10_Msk = 0x4000000
	// Bit DLBOPT10.
	SFR_AHB_DLBOPT10 = 0x4000000
	// Position of DLBOPT11 field.
	SFR_AHB_DLBOPT11_Pos = 0x1b
	// Bit mask of DLBOPT11 field.
	SFR_AHB_DLBOPT11_Msk = 0x8000000
	// Bit DLBOPT11.
	SFR_AHB_DLBOPT11 = 0x8000000
	// Position of DLBOPT12 field.
	SFR_AHB_DLBOPT12_Pos = 0x1c
	// Bit mask of DLBOPT12 field.
	SFR_AHB_DLBOPT12_Msk = 0x10000000
	// Bit DLBOPT12.
	SFR_AHB_DLBOPT12 = 0x10000000
	// Position of DLBOPT13 field.
	SFR_AHB_DLBOPT13_Pos = 0x1d
	// Bit mask of DLBOPT13 field.
	SFR_AHB_DLBOPT13_Msk = 0x20000000
	// Bit DLBOPT13.
	SFR_AHB_DLBOPT13 = 0x20000000
	// Position of DLBOPT14 field.
	SFR_AHB_DLBOPT14_Pos = 0x1e
	// Bit mask of DLBOPT14 field.
	SFR_AHB_DLBOPT14_Msk = 0x40000000
	// Bit DLBOPT14.
	SFR_AHB_DLBOPT14 = 0x40000000

	// BRIDGE: Bridge Configuration Register
	// Position of APBTURBO field.
	SFR_BRIDGE_APBTURBO_Pos = 0x0
	// Bit mask of APBTURBO field.
	SFR_BRIDGE_APBTURBO_Msk = 0x1
	// Bit APBTURBO.
	SFR_BRIDGE_APBTURBO = 0x1
	// Position of AXI2AHBSEL field.
	SFR_BRIDGE_AXI2AHBSEL_Pos = 0x8
	// Bit mask of AXI2AHBSEL field.
	SFR_BRIDGE_AXI2AHBSEL_Msk = 0x100
	// Bit AXI2AHBSEL.
	SFR_BRIDGE_AXI2AHBSEL = 0x100
	// use single port bridge.
	SFR_BRIDGE_AXI2AHBSEL_SINGLE = 0x0
	// use dual port bridge.
	SFR_BRIDGE_AXI2AHBSEL_DUAL = 0x1

	// SECURE: Security Configuration Register
	// Position of ROM field.
	SFR_SECURE_ROM_Pos = 0x0
	// Bit mask of ROM field.
	SFR_SECURE_ROM_Msk = 0x1
	// Bit ROM.
	SFR_SECURE_ROM = 0x1
	// Position of FUSE field.
	SFR_SECURE_FUSE_Pos = 0x8
	// Bit mask of FUSE field.
	SFR_SECURE_FUSE_Msk = 0x100
	// Bit FUSE.
	SFR_SECURE_FUSE = 0x100

	// UTMICKTRIM: UTMI Clock Trimming Register
	// Position of FREQ field.
	SFR_UTMICKTRIM_FREQ_Pos = 0x0
	// Bit mask of FREQ field.
	SFR_UTMICKTRIM_FREQ_Msk = 0x3
	// 12 MHz reference clock
	SFR_UTMICKTRIM_FREQ_12 = 0x0
	// 16 MHz reference clock
	SFR_UTMICKTRIM_FREQ_16 = 0x1
	// 24 MHz reference clock
	SFR_UTMICKTRIM_FREQ_24 = 0x2
	// 48 MHz reference clock
	SFR_UTMICKTRIM_FREQ_48 = 0x3
	// Position of VBG field.
	SFR_UTMICKTRIM_VBG_Pos = 0x10
	// Bit mask of VBG field.
	SFR_UTMICKTRIM_VBG_Msk = 0xf0000

	// UTMIHSTRIM: UTMI High Speed Trimming Register
	// Position of SQUELCH field.
	SFR_UTMIHSTRIM_SQUELCH_Pos = 0x0
	// Bit mask of SQUELCH field.
	SFR_UTMIHSTRIM_SQUELCH_Msk = 0x7
	// Position of DISC field.
	SFR_UTMIHSTRIM_DISC_Pos = 0x4
	// Bit mask of DISC field.
	SFR_UTMIHSTRIM_DISC_Msk = 0x70
	// Position of SLOPE0 field.
	SFR_UTMIHSTRIM_SLOPE0_Pos = 0x8
	// Bit mask of SLOPE0 field.
	SFR_UTMIHSTRIM_SLOPE0_Msk = 0x700
	// Position of SLOPE1 field.
	SFR_UTMIHSTRIM_SLOPE1_Pos = 0xc
	// Bit mask of SLOPE1 field.
	SFR_UTMIHSTRIM_SLOPE1_Msk = 0x7000
	// Position of SLOPE2 field.
	SFR_UTMIHSTRIM_SLOPE2_Pos = 0x10
	// Bit mask of SLOPE2 field.
	SFR_UTMIHSTRIM_SLOPE2_Msk = 0x70000

	// UTMIFSTRIM: UTMI Full Speed Trimming Register
	// Position of RISE field.
	SFR_UTMIFSTRIM_RISE_Pos = 0x0
	// Bit mask of RISE field.
	SFR_UTMIFSTRIM_RISE_Msk = 0x7
	// Position of FALL field.
	SFR_UTMIFSTRIM_FALL_Pos = 0x4
	// Bit mask of FALL field.
	SFR_UTMIFSTRIM_FALL_Msk = 0x70
	// Position of XCVR field.
	SFR_UTMIFSTRIM_XCVR_Pos = 0x8
	// Bit mask of XCVR field.
	SFR_UTMIFSTRIM_XCVR_Msk = 0x300
	// Position of ZN field.
	SFR_UTMIFSTRIM_ZN_Pos = 0x10
	// Bit mask of ZN field.
	SFR_UTMIFSTRIM_ZN_Msk = 0x70000
	// Position of ZP field.
	SFR_UTMIFSTRIM_ZP_Pos = 0x14
	// Bit mask of ZP field.
	SFR_UTMIFSTRIM_ZP_Msk = 0x700000

	// UTMISWAP: UTMI DP/DM Pin Swapping Register
	// Position of PORT0 field.
	SFR_UTMISWAP_PORT0_Pos = 0x0
	// Bit mask of PORT0 field.
	SFR_UTMISWAP_PORT0_Msk = 0x1
	// Bit PORT0.
	SFR_UTMISWAP_PORT0 = 0x1
	// DP/DM normal pinout.
	SFR_UTMISWAP_PORT0_NORMAL = 0x0
	// DP/DM swapped pinout.
	SFR_UTMISWAP_PORT0_SWAPPED = 0x1
	// Position of PORT1 field.
	SFR_UTMISWAP_PORT1_Pos = 0x1
	// Bit mask of PORT1 field.
	SFR_UTMISWAP_PORT1_Msk = 0x2
	// Bit PORT1.
	SFR_UTMISWAP_PORT1 = 0x2
	// DP/DM normal pinout.
	SFR_UTMISWAP_PORT1_NORMAL = 0x0
	// DP/DM swapped pinout.
	SFR_UTMISWAP_PORT1_SWAPPED = 0x1
	// Position of PORT2 field.
	SFR_UTMISWAP_PORT2_Pos = 0x2
	// Bit mask of PORT2 field.
	SFR_UTMISWAP_PORT2_Msk = 0x4
	// Bit PORT2.
	SFR_UTMISWAP_PORT2 = 0x4
	// DP/DM normal pinout.
	SFR_UTMISWAP_PORT2_NORMAL = 0x0
	// DP/DM swapped pinout.
	SFR_UTMISWAP_PORT2_SWAPPED = 0x1

	// EBICFG: EBI Configuration Register
	// Position of DRIVE0 field.
	SFR_EBICFG_DRIVE0_Pos = 0x0
	// Bit mask of DRIVE0 field.
	SFR_EBICFG_DRIVE0_Msk = 0x3
	// Low drive level
	SFR_EBICFG_DRIVE0_LOW = 0x0
	// Medium drive level
	SFR_EBICFG_DRIVE0_MEDIUM = 0x2
	// High drive level
	SFR_EBICFG_DRIVE0_HIGH = 0x3
	// Position of PULL0 field.
	SFR_EBICFG_PULL0_Pos = 0x2
	// Bit mask of PULL0 field.
	SFR_EBICFG_PULL0_Msk = 0xc
	// Pull-up
	SFR_EBICFG_PULL0_UP = 0x0
	// No Pull
	SFR_EBICFG_PULL0_NONE = 0x1
	// Pull-down
	SFR_EBICFG_PULL0_DOWN = 0x3
	// Position of SCH0 field.
	SFR_EBICFG_SCH0_Pos = 0x4
	// Bit mask of SCH0 field.
	SFR_EBICFG_SCH0_Msk = 0x10
	// Bit SCH0.
	SFR_EBICFG_SCH0 = 0x10
	// Position of DRIVE1 field.
	SFR_EBICFG_DRIVE1_Pos = 0x8
	// Bit mask of DRIVE1 field.
	SFR_EBICFG_DRIVE1_Msk = 0x300
	// Low drive level
	SFR_EBICFG_DRIVE1_LOW = 0x0
	// Medium drive level
	SFR_EBICFG_DRIVE1_MEDIUM = 0x2
	// High drive level
	SFR_EBICFG_DRIVE1_HIGH = 0x3
	// Position of PULL1 field.
	SFR_EBICFG_PULL1_Pos = 0xa
	// Bit mask of PULL1 field.
	SFR_EBICFG_PULL1_Msk = 0xc00
	// Pull-up
	SFR_EBICFG_PULL1_UP = 0x0
	// No Pull
	SFR_EBICFG_PULL1_NONE = 0x1
	// Pull-down
	SFR_EBICFG_PULL1_DOWN = 0x3
	// Position of SCH1 field.
	SFR_EBICFG_SCH1_Pos = 0xc
	// Bit mask of SCH1 field.
	SFR_EBICFG_SCH1_Msk = 0x1000
	// Bit SCH1.
	SFR_EBICFG_SCH1 = 0x1000
	// Position of BMS field.
	SFR_EBICFG_BMS_Pos = 0x10
	// Bit mask of BMS field.
	SFR_EBICFG_BMS_Msk = 0x10000
	// Bit BMS.
	SFR_EBICFG_BMS = 0x10000
	// Boot on ROM.
	SFR_EBICFG_BMS_ROM = 0x0
	// Boot on EBI.
	SFR_EBICFG_BMS_EBI = 0x1
)

// Constants for ADC: Analog-to-Digital Converter
const (
	// CR: Control Register
	// Position of SWRST field.
	ADC_CR_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	ADC_CR_SWRST_Msk = 0x1
	// Bit SWRST.
	ADC_CR_SWRST = 0x1
	// Position of START field.
	ADC_CR_START_Pos = 0x1
	// Bit mask of START field.
	ADC_CR_START_Msk = 0x2
	// Bit START.
	ADC_CR_START = 0x2
	// Position of TSCALIB field.
	ADC_CR_TSCALIB_Pos = 0x2
	// Bit mask of TSCALIB field.
	ADC_CR_TSCALIB_Msk = 0x4
	// Bit TSCALIB.
	ADC_CR_TSCALIB = 0x4
	// Position of AUTOCAL field.
	ADC_CR_AUTOCAL_Pos = 0x3
	// Bit mask of AUTOCAL field.
	ADC_CR_AUTOCAL_Msk = 0x8
	// Bit AUTOCAL.
	ADC_CR_AUTOCAL = 0x8

	// MR: Mode Register
	// Position of TRGSEL field.
	ADC_MR_TRGSEL_Pos = 0x1
	// Bit mask of TRGSEL field.
	ADC_MR_TRGSEL_Msk = 0xe
	// ADTRG
	ADC_MR_TRGSEL_ADC_TRIG0 = 0x0
	// TIOA0
	ADC_MR_TRGSEL_ADC_TRIG1 = 0x1
	// TIOA1
	ADC_MR_TRGSEL_ADC_TRIG2 = 0x2
	// TIOA2
	ADC_MR_TRGSEL_ADC_TRIG3 = 0x3
	// PWM event line 0
	ADC_MR_TRGSEL_ADC_TRIG4 = 0x4
	// PWM_even line 1
	ADC_MR_TRGSEL_ADC_TRIG5 = 0x5
	// Position of SLEEP field.
	ADC_MR_SLEEP_Pos = 0x5
	// Bit mask of SLEEP field.
	ADC_MR_SLEEP_Msk = 0x20
	// Bit SLEEP.
	ADC_MR_SLEEP = 0x20
	// Normal Mode: The ADC Core and reference voltage circuitry are kept ON between conversions
	ADC_MR_SLEEP_NORMAL = 0x0
	// Sleep Mode: The wake-up time can be modified by programming FWUP bit
	ADC_MR_SLEEP_SLEEP = 0x1
	// Position of FWUP field.
	ADC_MR_FWUP_Pos = 0x6
	// Bit mask of FWUP field.
	ADC_MR_FWUP_Msk = 0x40
	// Bit FWUP.
	ADC_MR_FWUP = 0x40
	// If SLEEP is 1 then both ADC Core and reference voltage circuitry are OFF between conversions
	ADC_MR_FWUP_OFF = 0x0
	// If SLEEP is 1 then Fast Wake-up Sleep Mode: The Voltage reference is ON between conversions and ADC Core is OFF
	ADC_MR_FWUP_ON = 0x1
	// Position of PRESCAL field.
	ADC_MR_PRESCAL_Pos = 0x8
	// Bit mask of PRESCAL field.
	ADC_MR_PRESCAL_Msk = 0xff00
	// Position of STARTUP field.
	ADC_MR_STARTUP_Pos = 0x10
	// Bit mask of STARTUP field.
	ADC_MR_STARTUP_Msk = 0xf0000
	// 0 periods of ADCClock
	ADC_MR_STARTUP_SUT0 = 0x0
	// 8 periods of ADCClock
	ADC_MR_STARTUP_SUT8 = 0x1
	// 16 periods of ADCClock
	ADC_MR_STARTUP_SUT16 = 0x2
	// 24 periods of ADCClock
	ADC_MR_STARTUP_SUT24 = 0x3
	// 64 periods of ADCClock
	ADC_MR_STARTUP_SUT64 = 0x4
	// 80 periods of ADCClock
	ADC_MR_STARTUP_SUT80 = 0x5
	// 96 periods of ADCClock
	ADC_MR_STARTUP_SUT96 = 0x6
	// 112 periods of ADCClock
	ADC_MR_STARTUP_SUT112 = 0x7
	// 512 periods of ADCClock
	ADC_MR_STARTUP_SUT512 = 0x8
	// 576 periods of ADCClock
	ADC_MR_STARTUP_SUT576 = 0x9
	// 640 periods of ADCClock
	ADC_MR_STARTUP_SUT640 = 0xa
	// 704 periods of ADCClock
	ADC_MR_STARTUP_SUT704 = 0xb
	// 768 periods of ADCClock
	ADC_MR_STARTUP_SUT768 = 0xc
	// 832 periods of ADCClock
	ADC_MR_STARTUP_SUT832 = 0xd
	// 896 periods of ADCClock
	ADC_MR_STARTUP_SUT896 = 0xe
	// 960 periods of ADCClock
	ADC_MR_STARTUP_SUT960 = 0xf
	// Position of SETTLING field.
	ADC_MR_SETTLING_Pos = 0x14
	// Bit mask of SETTLING field.
	ADC_MR_SETTLING_Msk = 0x300000
	// 3 periods of ADCClock
	ADC_MR_SETTLING_AST3 = 0x0
	// 5 periods of ADCClock
	ADC_MR_SETTLING_AST5 = 0x1
	// 9 periods of ADCClock
	ADC_MR_SETTLING_AST9 = 0x2
	// 17 periods of ADCClock
	ADC_MR_SETTLING_AST17 = 0x3
	// Position of ANACH field.
	ADC_MR_ANACH_Pos = 0x17
	// Bit mask of ANACH field.
	ADC_MR_ANACH_Msk = 0x800000
	// Bit ANACH.
	ADC_MR_ANACH = 0x800000
	// No analog change on channel switching: DIFF0, GAIN0 and OFF0 are used for all channels
	ADC_MR_ANACH_NONE = 0x0
	// Allows different analog settings for each channel. See ADC_CGR and ADC_COR Registers
	ADC_MR_ANACH_ALLOWED = 0x1
	// Position of TRACKTIM field.
	ADC_MR_TRACKTIM_Pos = 0x18
	// Bit mask of TRACKTIM field.
	ADC_MR_TRACKTIM_Msk = 0xf000000
	// Position of USEQ field.
	ADC_MR_USEQ_Pos = 0x1f
	// Bit mask of USEQ field.
	ADC_MR_USEQ_Msk = 0x80000000
	// Bit USEQ.
	ADC_MR_USEQ = 0x80000000
	// Normal Mode: The controller converts channels in a simple numeric order depending only on the channel index.
	ADC_MR_USEQ_NUM_ORDER = 0x0
	// User Sequence Mode: The sequence respects what is defined in ADC_SEQR1 and ADC_SEQR2 registers and can be used to convert several times the same channel.
	ADC_MR_USEQ_REG_ORDER = 0x1

	// SEQR1: Channel Sequence Register 1
	// Position of USCH1 field.
	ADC_SEQR1_USCH1_Pos = 0x0
	// Bit mask of USCH1 field.
	ADC_SEQR1_USCH1_Msk = 0xf
	// Position of USCH2 field.
	ADC_SEQR1_USCH2_Pos = 0x4
	// Bit mask of USCH2 field.
	ADC_SEQR1_USCH2_Msk = 0xf0
	// Position of USCH3 field.
	ADC_SEQR1_USCH3_Pos = 0x8
	// Bit mask of USCH3 field.
	ADC_SEQR1_USCH3_Msk = 0xf00
	// Position of USCH4 field.
	ADC_SEQR1_USCH4_Pos = 0xc
	// Bit mask of USCH4 field.
	ADC_SEQR1_USCH4_Msk = 0xf000
	// Position of USCH5 field.
	ADC_SEQR1_USCH5_Pos = 0x10
	// Bit mask of USCH5 field.
	ADC_SEQR1_USCH5_Msk = 0xf0000
	// Position of USCH6 field.
	ADC_SEQR1_USCH6_Pos = 0x14
	// Bit mask of USCH6 field.
	ADC_SEQR1_USCH6_Msk = 0xf00000
	// Position of USCH7 field.
	ADC_SEQR1_USCH7_Pos = 0x18
	// Bit mask of USCH7 field.
	ADC_SEQR1_USCH7_Msk = 0xf000000
	// Position of USCH8 field.
	ADC_SEQR1_USCH8_Pos = 0x1c
	// Bit mask of USCH8 field.
	ADC_SEQR1_USCH8_Msk = 0xf0000000

	// SEQR2: Channel Sequence Register 2
	// Position of USCH9 field.
	ADC_SEQR2_USCH9_Pos = 0x0
	// Bit mask of USCH9 field.
	ADC_SEQR2_USCH9_Msk = 0xf
	// Position of USCH10 field.
	ADC_SEQR2_USCH10_Pos = 0x4
	// Bit mask of USCH10 field.
	ADC_SEQR2_USCH10_Msk = 0xf0
	// Position of USCH11 field.
	ADC_SEQR2_USCH11_Pos = 0x8
	// Bit mask of USCH11 field.
	ADC_SEQR2_USCH11_Msk = 0xf00

	// CHER: Channel Enable Register
	// Position of CH0 field.
	ADC_CHER_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	ADC_CHER_CH0_Msk = 0x1
	// Bit CH0.
	ADC_CHER_CH0 = 0x1
	// Position of CH1 field.
	ADC_CHER_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	ADC_CHER_CH1_Msk = 0x2
	// Bit CH1.
	ADC_CHER_CH1 = 0x2
	// Position of CH2 field.
	ADC_CHER_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	ADC_CHER_CH2_Msk = 0x4
	// Bit CH2.
	ADC_CHER_CH2 = 0x4
	// Position of CH3 field.
	ADC_CHER_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	ADC_CHER_CH3_Msk = 0x8
	// Bit CH3.
	ADC_CHER_CH3 = 0x8
	// Position of CH4 field.
	ADC_CHER_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	ADC_CHER_CH4_Msk = 0x10
	// Bit CH4.
	ADC_CHER_CH4 = 0x10
	// Position of CH5 field.
	ADC_CHER_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	ADC_CHER_CH5_Msk = 0x20
	// Bit CH5.
	ADC_CHER_CH5 = 0x20
	// Position of CH6 field.
	ADC_CHER_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	ADC_CHER_CH6_Msk = 0x40
	// Bit CH6.
	ADC_CHER_CH6 = 0x40
	// Position of CH7 field.
	ADC_CHER_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	ADC_CHER_CH7_Msk = 0x80
	// Bit CH7.
	ADC_CHER_CH7 = 0x80
	// Position of CH8 field.
	ADC_CHER_CH8_Pos = 0x8
	// Bit mask of CH8 field.
	ADC_CHER_CH8_Msk = 0x100
	// Bit CH8.
	ADC_CHER_CH8 = 0x100
	// Position of CH9 field.
	ADC_CHER_CH9_Pos = 0x9
	// Bit mask of CH9 field.
	ADC_CHER_CH9_Msk = 0x200
	// Bit CH9.
	ADC_CHER_CH9 = 0x200
	// Position of CH10 field.
	ADC_CHER_CH10_Pos = 0xa
	// Bit mask of CH10 field.
	ADC_CHER_CH10_Msk = 0x400
	// Bit CH10.
	ADC_CHER_CH10 = 0x400
	// Position of CH11 field.
	ADC_CHER_CH11_Pos = 0xb
	// Bit mask of CH11 field.
	ADC_CHER_CH11_Msk = 0x800
	// Bit CH11.
	ADC_CHER_CH11 = 0x800

	// CHDR: Channel Disable Register
	// Position of CH0 field.
	ADC_CHDR_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	ADC_CHDR_CH0_Msk = 0x1
	// Bit CH0.
	ADC_CHDR_CH0 = 0x1
	// Position of CH1 field.
	ADC_CHDR_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	ADC_CHDR_CH1_Msk = 0x2
	// Bit CH1.
	ADC_CHDR_CH1 = 0x2
	// Position of CH2 field.
	ADC_CHDR_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	ADC_CHDR_CH2_Msk = 0x4
	// Bit CH2.
	ADC_CHDR_CH2 = 0x4
	// Position of CH3 field.
	ADC_CHDR_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	ADC_CHDR_CH3_Msk = 0x8
	// Bit CH3.
	ADC_CHDR_CH3 = 0x8
	// Position of CH4 field.
	ADC_CHDR_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	ADC_CHDR_CH4_Msk = 0x10
	// Bit CH4.
	ADC_CHDR_CH4 = 0x10
	// Position of CH5 field.
	ADC_CHDR_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	ADC_CHDR_CH5_Msk = 0x20
	// Bit CH5.
	ADC_CHDR_CH5 = 0x20
	// Position of CH6 field.
	ADC_CHDR_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	ADC_CHDR_CH6_Msk = 0x40
	// Bit CH6.
	ADC_CHDR_CH6 = 0x40
	// Position of CH7 field.
	ADC_CHDR_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	ADC_CHDR_CH7_Msk = 0x80
	// Bit CH7.
	ADC_CHDR_CH7 = 0x80
	// Position of CH8 field.
	ADC_CHDR_CH8_Pos = 0x8
	// Bit mask of CH8 field.
	ADC_CHDR_CH8_Msk = 0x100
	// Bit CH8.
	ADC_CHDR_CH8 = 0x100
	// Position of CH9 field.
	ADC_CHDR_CH9_Pos = 0x9
	// Bit mask of CH9 field.
	ADC_CHDR_CH9_Msk = 0x200
	// Bit CH9.
	ADC_CHDR_CH9 = 0x200
	// Position of CH10 field.
	ADC_CHDR_CH10_Pos = 0xa
	// Bit mask of CH10 field.
	ADC_CHDR_CH10_Msk = 0x400
	// Bit CH10.
	ADC_CHDR_CH10 = 0x400
	// Position of CH11 field.
	ADC_CHDR_CH11_Pos = 0xb
	// Bit mask of CH11 field.
	ADC_CHDR_CH11_Msk = 0x800
	// Bit CH11.
	ADC_CHDR_CH11 = 0x800

	// CHSR: Channel Status Register
	// Position of CH0 field.
	ADC_CHSR_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	ADC_CHSR_CH0_Msk = 0x1
	// Bit CH0.
	ADC_CHSR_CH0 = 0x1
	// Position of CH1 field.
	ADC_CHSR_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	ADC_CHSR_CH1_Msk = 0x2
	// Bit CH1.
	ADC_CHSR_CH1 = 0x2
	// Position of CH2 field.
	ADC_CHSR_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	ADC_CHSR_CH2_Msk = 0x4
	// Bit CH2.
	ADC_CHSR_CH2 = 0x4
	// Position of CH3 field.
	ADC_CHSR_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	ADC_CHSR_CH3_Msk = 0x8
	// Bit CH3.
	ADC_CHSR_CH3 = 0x8
	// Position of CH4 field.
	ADC_CHSR_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	ADC_CHSR_CH4_Msk = 0x10
	// Bit CH4.
	ADC_CHSR_CH4 = 0x10
	// Position of CH5 field.
	ADC_CHSR_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	ADC_CHSR_CH5_Msk = 0x20
	// Bit CH5.
	ADC_CHSR_CH5 = 0x20
	// Position of CH6 field.
	ADC_CHSR_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	ADC_CHSR_CH6_Msk = 0x40
	// Bit CH6.
	ADC_CHSR_CH6 = 0x40
	// Position of CH7 field.
	ADC_CHSR_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	ADC_CHSR_CH7_Msk = 0x80
	// Bit CH7.
	ADC_CHSR_CH7 = 0x80
	// Position of CH8 field.
	ADC_CHSR_CH8_Pos = 0x8
	// Bit mask of CH8 field.
	ADC_CHSR_CH8_Msk = 0x100
	// Bit CH8.
	ADC_CHSR_CH8 = 0x100
	// Position of CH9 field.
	ADC_CHSR_CH9_Pos = 0x9
	// Bit mask of CH9 field.
	ADC_CHSR_CH9_Msk = 0x200
	// Bit CH9.
	ADC_CHSR_CH9 = 0x200
	// Position of CH10 field.
	ADC_CHSR_CH10_Pos = 0xa
	// Bit mask of CH10 field.
	ADC_CHSR_CH10_Msk = 0x400
	// Bit CH10.
	ADC_CHSR_CH10 = 0x400
	// Position of CH11 field.
	ADC_CHSR_CH11_Pos = 0xb
	// Bit mask of CH11 field.
	ADC_CHSR_CH11_Msk = 0x800
	// Bit CH11.
	ADC_CHSR_CH11 = 0x800

	// LCDR: Last Converted Data Register
	// Position of LDATA field.
	ADC_LCDR_LDATA_Pos = 0x0
	// Bit mask of LDATA field.
	ADC_LCDR_LDATA_Msk = 0xfff
	// Position of CHNB field.
	ADC_LCDR_CHNB_Pos = 0xc
	// Bit mask of CHNB field.
	ADC_LCDR_CHNB_Msk = 0xf000

	// IER: Interrupt Enable Register
	// Position of EOC0 field.
	ADC_IER_EOC0_Pos = 0x0
	// Bit mask of EOC0 field.
	ADC_IER_EOC0_Msk = 0x1
	// Bit EOC0.
	ADC_IER_EOC0 = 0x1
	// Position of EOC1 field.
	ADC_IER_EOC1_Pos = 0x1
	// Bit mask of EOC1 field.
	ADC_IER_EOC1_Msk = 0x2
	// Bit EOC1.
	ADC_IER_EOC1 = 0x2
	// Position of EOC2 field.
	ADC_IER_EOC2_Pos = 0x2
	// Bit mask of EOC2 field.
	ADC_IER_EOC2_Msk = 0x4
	// Bit EOC2.
	ADC_IER_EOC2 = 0x4
	// Position of EOC3 field.
	ADC_IER_EOC3_Pos = 0x3
	// Bit mask of EOC3 field.
	ADC_IER_EOC3_Msk = 0x8
	// Bit EOC3.
	ADC_IER_EOC3 = 0x8
	// Position of EOC4 field.
	ADC_IER_EOC4_Pos = 0x4
	// Bit mask of EOC4 field.
	ADC_IER_EOC4_Msk = 0x10
	// Bit EOC4.
	ADC_IER_EOC4 = 0x10
	// Position of EOC5 field.
	ADC_IER_EOC5_Pos = 0x5
	// Bit mask of EOC5 field.
	ADC_IER_EOC5_Msk = 0x20
	// Bit EOC5.
	ADC_IER_EOC5 = 0x20
	// Position of EOC6 field.
	ADC_IER_EOC6_Pos = 0x6
	// Bit mask of EOC6 field.
	ADC_IER_EOC6_Msk = 0x40
	// Bit EOC6.
	ADC_IER_EOC6 = 0x40
	// Position of EOC7 field.
	ADC_IER_EOC7_Pos = 0x7
	// Bit mask of EOC7 field.
	ADC_IER_EOC7_Msk = 0x80
	// Bit EOC7.
	ADC_IER_EOC7 = 0x80
	// Position of EOC8 field.
	ADC_IER_EOC8_Pos = 0x8
	// Bit mask of EOC8 field.
	ADC_IER_EOC8_Msk = 0x100
	// Bit EOC8.
	ADC_IER_EOC8 = 0x100
	// Position of EOC9 field.
	ADC_IER_EOC9_Pos = 0x9
	// Bit mask of EOC9 field.
	ADC_IER_EOC9_Msk = 0x200
	// Bit EOC9.
	ADC_IER_EOC9 = 0x200
	// Position of EOC10 field.
	ADC_IER_EOC10_Pos = 0xa
	// Bit mask of EOC10 field.
	ADC_IER_EOC10_Msk = 0x400
	// Bit EOC10.
	ADC_IER_EOC10 = 0x400
	// Position of EOC11 field.
	ADC_IER_EOC11_Pos = 0xb
	// Bit mask of EOC11 field.
	ADC_IER_EOC11_Msk = 0x800
	// Bit EOC11.
	ADC_IER_EOC11 = 0x800
	// Position of XRDY field.
	ADC_IER_XRDY_Pos = 0x14
	// Bit mask of XRDY field.
	ADC_IER_XRDY_Msk = 0x100000
	// Bit XRDY.
	ADC_IER_XRDY = 0x100000
	// Position of YRDY field.
	ADC_IER_YRDY_Pos = 0x15
	// Bit mask of YRDY field.
	ADC_IER_YRDY_Msk = 0x200000
	// Bit YRDY.
	ADC_IER_YRDY = 0x200000
	// Position of PRDY field.
	ADC_IER_PRDY_Pos = 0x16
	// Bit mask of PRDY field.
	ADC_IER_PRDY_Msk = 0x400000
	// Bit PRDY.
	ADC_IER_PRDY = 0x400000
	// Position of EOCAL field.
	ADC_IER_EOCAL_Pos = 0x17
	// Bit mask of EOCAL field.
	ADC_IER_EOCAL_Msk = 0x800000
	// Bit EOCAL.
	ADC_IER_EOCAL = 0x800000
	// Position of DRDY field.
	ADC_IER_DRDY_Pos = 0x18
	// Bit mask of DRDY field.
	ADC_IER_DRDY_Msk = 0x1000000
	// Bit DRDY.
	ADC_IER_DRDY = 0x1000000
	// Position of GOVRE field.
	ADC_IER_GOVRE_Pos = 0x19
	// Bit mask of GOVRE field.
	ADC_IER_GOVRE_Msk = 0x2000000
	// Bit GOVRE.
	ADC_IER_GOVRE = 0x2000000
	// Position of COMPE field.
	ADC_IER_COMPE_Pos = 0x1a
	// Bit mask of COMPE field.
	ADC_IER_COMPE_Msk = 0x4000000
	// Bit COMPE.
	ADC_IER_COMPE = 0x4000000
	// Position of PEN field.
	ADC_IER_PEN_Pos = 0x1d
	// Bit mask of PEN field.
	ADC_IER_PEN_Msk = 0x20000000
	// Bit PEN.
	ADC_IER_PEN = 0x20000000
	// Position of NOPEN field.
	ADC_IER_NOPEN_Pos = 0x1e
	// Bit mask of NOPEN field.
	ADC_IER_NOPEN_Msk = 0x40000000
	// Bit NOPEN.
	ADC_IER_NOPEN = 0x40000000

	// IDR: Interrupt Disable Register
	// Position of EOC0 field.
	ADC_IDR_EOC0_Pos = 0x0
	// Bit mask of EOC0 field.
	ADC_IDR_EOC0_Msk = 0x1
	// Bit EOC0.
	ADC_IDR_EOC0 = 0x1
	// Position of EOC1 field.
	ADC_IDR_EOC1_Pos = 0x1
	// Bit mask of EOC1 field.
	ADC_IDR_EOC1_Msk = 0x2
	// Bit EOC1.
	ADC_IDR_EOC1 = 0x2
	// Position of EOC2 field.
	ADC_IDR_EOC2_Pos = 0x2
	// Bit mask of EOC2 field.
	ADC_IDR_EOC2_Msk = 0x4
	// Bit EOC2.
	ADC_IDR_EOC2 = 0x4
	// Position of EOC3 field.
	ADC_IDR_EOC3_Pos = 0x3
	// Bit mask of EOC3 field.
	ADC_IDR_EOC3_Msk = 0x8
	// Bit EOC3.
	ADC_IDR_EOC3 = 0x8
	// Position of EOC4 field.
	ADC_IDR_EOC4_Pos = 0x4
	// Bit mask of EOC4 field.
	ADC_IDR_EOC4_Msk = 0x10
	// Bit EOC4.
	ADC_IDR_EOC4 = 0x10
	// Position of EOC5 field.
	ADC_IDR_EOC5_Pos = 0x5
	// Bit mask of EOC5 field.
	ADC_IDR_EOC5_Msk = 0x20
	// Bit EOC5.
	ADC_IDR_EOC5 = 0x20
	// Position of EOC6 field.
	ADC_IDR_EOC6_Pos = 0x6
	// Bit mask of EOC6 field.
	ADC_IDR_EOC6_Msk = 0x40
	// Bit EOC6.
	ADC_IDR_EOC6 = 0x40
	// Position of EOC7 field.
	ADC_IDR_EOC7_Pos = 0x7
	// Bit mask of EOC7 field.
	ADC_IDR_EOC7_Msk = 0x80
	// Bit EOC7.
	ADC_IDR_EOC7 = 0x80
	// Position of EOC8 field.
	ADC_IDR_EOC8_Pos = 0x8
	// Bit mask of EOC8 field.
	ADC_IDR_EOC8_Msk = 0x100
	// Bit EOC8.
	ADC_IDR_EOC8 = 0x100
	// Position of EOC9 field.
	ADC_IDR_EOC9_Pos = 0x9
	// Bit mask of EOC9 field.
	ADC_IDR_EOC9_Msk = 0x200
	// Bit EOC9.
	ADC_IDR_EOC9 = 0x200
	// Position of EOC10 field.
	ADC_IDR_EOC10_Pos = 0xa
	// Bit mask of EOC10 field.
	ADC_IDR_EOC10_Msk = 0x400
	// Bit EOC10.
	ADC_IDR_EOC10 = 0x400
	// Position of EOC11 field.
	ADC_IDR_EOC11_Pos = 0xb
	// Bit mask of EOC11 field.
	ADC_IDR_EOC11_Msk = 0x800
	// Bit EOC11.
	ADC_IDR_EOC11 = 0x800
	// Position of XRDY field.
	ADC_IDR_XRDY_Pos = 0x14
	// Bit mask of XRDY field.
	ADC_IDR_XRDY_Msk = 0x100000
	// Bit XRDY.
	ADC_IDR_XRDY = 0x100000
	// Position of YRDY field.
	ADC_IDR_YRDY_Pos = 0x15
	// Bit mask of YRDY field.
	ADC_IDR_YRDY_Msk = 0x200000
	// Bit YRDY.
	ADC_IDR_YRDY = 0x200000
	// Position of PRDY field.
	ADC_IDR_PRDY_Pos = 0x16
	// Bit mask of PRDY field.
	ADC_IDR_PRDY_Msk = 0x400000
	// Bit PRDY.
	ADC_IDR_PRDY = 0x400000
	// Position of EOCAL field.
	ADC_IDR_EOCAL_Pos = 0x17
	// Bit mask of EOCAL field.
	ADC_IDR_EOCAL_Msk = 0x800000
	// Bit EOCAL.
	ADC_IDR_EOCAL = 0x800000
	// Position of DRDY field.
	ADC_IDR_DRDY_Pos = 0x18
	// Bit mask of DRDY field.
	ADC_IDR_DRDY_Msk = 0x1000000
	// Bit DRDY.
	ADC_IDR_DRDY = 0x1000000
	// Position of GOVRE field.
	ADC_IDR_GOVRE_Pos = 0x19
	// Bit mask of GOVRE field.
	ADC_IDR_GOVRE_Msk = 0x2000000
	// Bit GOVRE.
	ADC_IDR_GOVRE = 0x2000000
	// Position of COMPE field.
	ADC_IDR_COMPE_Pos = 0x1a
	// Bit mask of COMPE field.
	ADC_IDR_COMPE_Msk = 0x4000000
	// Bit COMPE.
	ADC_IDR_COMPE = 0x4000000
	// Position of PEN field.
	ADC_IDR_PEN_Pos = 0x1d
	// Bit mask of PEN field.
	ADC_IDR_PEN_Msk = 0x20000000
	// Bit PEN.
	ADC_IDR_PEN = 0x20000000
	// Position of NOPEN field.
	ADC_IDR_NOPEN_Pos = 0x1e
	// Bit mask of NOPEN field.
	ADC_IDR_NOPEN_Msk = 0x40000000
	// Bit NOPEN.
	ADC_IDR_NOPEN = 0x40000000

	// IMR: Interrupt Mask Register
	// Position of EOC0 field.
	ADC_IMR_EOC0_Pos = 0x0
	// Bit mask of EOC0 field.
	ADC_IMR_EOC0_Msk = 0x1
	// Bit EOC0.
	ADC_IMR_EOC0 = 0x1
	// Position of EOC1 field.
	ADC_IMR_EOC1_Pos = 0x1
	// Bit mask of EOC1 field.
	ADC_IMR_EOC1_Msk = 0x2
	// Bit EOC1.
	ADC_IMR_EOC1 = 0x2
	// Position of EOC2 field.
	ADC_IMR_EOC2_Pos = 0x2
	// Bit mask of EOC2 field.
	ADC_IMR_EOC2_Msk = 0x4
	// Bit EOC2.
	ADC_IMR_EOC2 = 0x4
	// Position of EOC3 field.
	ADC_IMR_EOC3_Pos = 0x3
	// Bit mask of EOC3 field.
	ADC_IMR_EOC3_Msk = 0x8
	// Bit EOC3.
	ADC_IMR_EOC3 = 0x8
	// Position of EOC4 field.
	ADC_IMR_EOC4_Pos = 0x4
	// Bit mask of EOC4 field.
	ADC_IMR_EOC4_Msk = 0x10
	// Bit EOC4.
	ADC_IMR_EOC4 = 0x10
	// Position of EOC5 field.
	ADC_IMR_EOC5_Pos = 0x5
	// Bit mask of EOC5 field.
	ADC_IMR_EOC5_Msk = 0x20
	// Bit EOC5.
	ADC_IMR_EOC5 = 0x20
	// Position of EOC6 field.
	ADC_IMR_EOC6_Pos = 0x6
	// Bit mask of EOC6 field.
	ADC_IMR_EOC6_Msk = 0x40
	// Bit EOC6.
	ADC_IMR_EOC6 = 0x40
	// Position of EOC7 field.
	ADC_IMR_EOC7_Pos = 0x7
	// Bit mask of EOC7 field.
	ADC_IMR_EOC7_Msk = 0x80
	// Bit EOC7.
	ADC_IMR_EOC7 = 0x80
	// Position of EOC8 field.
	ADC_IMR_EOC8_Pos = 0x8
	// Bit mask of EOC8 field.
	ADC_IMR_EOC8_Msk = 0x100
	// Bit EOC8.
	ADC_IMR_EOC8 = 0x100
	// Position of EOC9 field.
	ADC_IMR_EOC9_Pos = 0x9
	// Bit mask of EOC9 field.
	ADC_IMR_EOC9_Msk = 0x200
	// Bit EOC9.
	ADC_IMR_EOC9 = 0x200
	// Position of EOC10 field.
	ADC_IMR_EOC10_Pos = 0xa
	// Bit mask of EOC10 field.
	ADC_IMR_EOC10_Msk = 0x400
	// Bit EOC10.
	ADC_IMR_EOC10 = 0x400
	// Position of EOC11 field.
	ADC_IMR_EOC11_Pos = 0xb
	// Bit mask of EOC11 field.
	ADC_IMR_EOC11_Msk = 0x800
	// Bit EOC11.
	ADC_IMR_EOC11 = 0x800
	// Position of XRDY field.
	ADC_IMR_XRDY_Pos = 0x14
	// Bit mask of XRDY field.
	ADC_IMR_XRDY_Msk = 0x100000
	// Bit XRDY.
	ADC_IMR_XRDY = 0x100000
	// Position of YRDY field.
	ADC_IMR_YRDY_Pos = 0x15
	// Bit mask of YRDY field.
	ADC_IMR_YRDY_Msk = 0x200000
	// Bit YRDY.
	ADC_IMR_YRDY = 0x200000
	// Position of PRDY field.
	ADC_IMR_PRDY_Pos = 0x16
	// Bit mask of PRDY field.
	ADC_IMR_PRDY_Msk = 0x400000
	// Bit PRDY.
	ADC_IMR_PRDY = 0x400000
	// Position of EOCAL field.
	ADC_IMR_EOCAL_Pos = 0x17
	// Bit mask of EOCAL field.
	ADC_IMR_EOCAL_Msk = 0x800000
	// Bit EOCAL.
	ADC_IMR_EOCAL = 0x800000
	// Position of DRDY field.
	ADC_IMR_DRDY_Pos = 0x18
	// Bit mask of DRDY field.
	ADC_IMR_DRDY_Msk = 0x1000000
	// Bit DRDY.
	ADC_IMR_DRDY = 0x1000000
	// Position of GOVRE field.
	ADC_IMR_GOVRE_Pos = 0x19
	// Bit mask of GOVRE field.
	ADC_IMR_GOVRE_Msk = 0x2000000
	// Bit GOVRE.
	ADC_IMR_GOVRE = 0x2000000
	// Position of COMPE field.
	ADC_IMR_COMPE_Pos = 0x1a
	// Bit mask of COMPE field.
	ADC_IMR_COMPE_Msk = 0x4000000
	// Bit COMPE.
	ADC_IMR_COMPE = 0x4000000
	// Position of PEN field.
	ADC_IMR_PEN_Pos = 0x1d
	// Bit mask of PEN field.
	ADC_IMR_PEN_Msk = 0x20000000
	// Bit PEN.
	ADC_IMR_PEN = 0x20000000
	// Position of NOPEN field.
	ADC_IMR_NOPEN_Pos = 0x1e
	// Bit mask of NOPEN field.
	ADC_IMR_NOPEN_Msk = 0x40000000
	// Bit NOPEN.
	ADC_IMR_NOPEN = 0x40000000

	// ISR: Interrupt Status Register
	// Position of EOC0 field.
	ADC_ISR_EOC0_Pos = 0x0
	// Bit mask of EOC0 field.
	ADC_ISR_EOC0_Msk = 0x1
	// Bit EOC0.
	ADC_ISR_EOC0 = 0x1
	// Position of EOC1 field.
	ADC_ISR_EOC1_Pos = 0x1
	// Bit mask of EOC1 field.
	ADC_ISR_EOC1_Msk = 0x2
	// Bit EOC1.
	ADC_ISR_EOC1 = 0x2
	// Position of EOC2 field.
	ADC_ISR_EOC2_Pos = 0x2
	// Bit mask of EOC2 field.
	ADC_ISR_EOC2_Msk = 0x4
	// Bit EOC2.
	ADC_ISR_EOC2 = 0x4
	// Position of EOC3 field.
	ADC_ISR_EOC3_Pos = 0x3
	// Bit mask of EOC3 field.
	ADC_ISR_EOC3_Msk = 0x8
	// Bit EOC3.
	ADC_ISR_EOC3 = 0x8
	// Position of EOC4 field.
	ADC_ISR_EOC4_Pos = 0x4
	// Bit mask of EOC4 field.
	ADC_ISR_EOC4_Msk = 0x10
	// Bit EOC4.
	ADC_ISR_EOC4 = 0x10
	// Position of EOC5 field.
	ADC_ISR_EOC5_Pos = 0x5
	// Bit mask of EOC5 field.
	ADC_ISR_EOC5_Msk = 0x20
	// Bit EOC5.
	ADC_ISR_EOC5 = 0x20
	// Position of EOC6 field.
	ADC_ISR_EOC6_Pos = 0x6
	// Bit mask of EOC6 field.
	ADC_ISR_EOC6_Msk = 0x40
	// Bit EOC6.
	ADC_ISR_EOC6 = 0x40
	// Position of EOC7 field.
	ADC_ISR_EOC7_Pos = 0x7
	// Bit mask of EOC7 field.
	ADC_ISR_EOC7_Msk = 0x80
	// Bit EOC7.
	ADC_ISR_EOC7 = 0x80
	// Position of EOC8 field.
	ADC_ISR_EOC8_Pos = 0x8
	// Bit mask of EOC8 field.
	ADC_ISR_EOC8_Msk = 0x100
	// Bit EOC8.
	ADC_ISR_EOC8 = 0x100
	// Position of EOC9 field.
	ADC_ISR_EOC9_Pos = 0x9
	// Bit mask of EOC9 field.
	ADC_ISR_EOC9_Msk = 0x200
	// Bit EOC9.
	ADC_ISR_EOC9 = 0x200
	// Position of EOC10 field.
	ADC_ISR_EOC10_Pos = 0xa
	// Bit mask of EOC10 field.
	ADC_ISR_EOC10_Msk = 0x400
	// Bit EOC10.
	ADC_ISR_EOC10 = 0x400
	// Position of EOC11 field.
	ADC_ISR_EOC11_Pos = 0xb
	// Bit mask of EOC11 field.
	ADC_ISR_EOC11_Msk = 0x800
	// Bit EOC11.
	ADC_ISR_EOC11 = 0x800
	// Position of XRDY field.
	ADC_ISR_XRDY_Pos = 0x14
	// Bit mask of XRDY field.
	ADC_ISR_XRDY_Msk = 0x100000
	// Bit XRDY.
	ADC_ISR_XRDY = 0x100000
	// Position of YRDY field.
	ADC_ISR_YRDY_Pos = 0x15
	// Bit mask of YRDY field.
	ADC_ISR_YRDY_Msk = 0x200000
	// Bit YRDY.
	ADC_ISR_YRDY = 0x200000
	// Position of PRDY field.
	ADC_ISR_PRDY_Pos = 0x16
	// Bit mask of PRDY field.
	ADC_ISR_PRDY_Msk = 0x400000
	// Bit PRDY.
	ADC_ISR_PRDY = 0x400000
	// Position of EOCAL field.
	ADC_ISR_EOCAL_Pos = 0x17
	// Bit mask of EOCAL field.
	ADC_ISR_EOCAL_Msk = 0x800000
	// Bit EOCAL.
	ADC_ISR_EOCAL = 0x800000
	// Position of DRDY field.
	ADC_ISR_DRDY_Pos = 0x18
	// Bit mask of DRDY field.
	ADC_ISR_DRDY_Msk = 0x1000000
	// Bit DRDY.
	ADC_ISR_DRDY = 0x1000000
	// Position of GOVRE field.
	ADC_ISR_GOVRE_Pos = 0x19
	// Bit mask of GOVRE field.
	ADC_ISR_GOVRE_Msk = 0x2000000
	// Bit GOVRE.
	ADC_ISR_GOVRE = 0x2000000
	// Position of COMPE field.
	ADC_ISR_COMPE_Pos = 0x1a
	// Bit mask of COMPE field.
	ADC_ISR_COMPE_Msk = 0x4000000
	// Bit COMPE.
	ADC_ISR_COMPE = 0x4000000
	// Position of PEN field.
	ADC_ISR_PEN_Pos = 0x1d
	// Bit mask of PEN field.
	ADC_ISR_PEN_Msk = 0x20000000
	// Bit PEN.
	ADC_ISR_PEN = 0x20000000
	// Position of NOPEN field.
	ADC_ISR_NOPEN_Pos = 0x1e
	// Bit mask of NOPEN field.
	ADC_ISR_NOPEN_Msk = 0x40000000
	// Bit NOPEN.
	ADC_ISR_NOPEN = 0x40000000
	// Position of PENS field.
	ADC_ISR_PENS_Pos = 0x1f
	// Bit mask of PENS field.
	ADC_ISR_PENS_Msk = 0x80000000
	// Bit PENS.
	ADC_ISR_PENS = 0x80000000

	// OVER: Overrun Status Register
	// Position of OVRE0 field.
	ADC_OVER_OVRE0_Pos = 0x0
	// Bit mask of OVRE0 field.
	ADC_OVER_OVRE0_Msk = 0x1
	// Bit OVRE0.
	ADC_OVER_OVRE0 = 0x1
	// Position of OVRE1 field.
	ADC_OVER_OVRE1_Pos = 0x1
	// Bit mask of OVRE1 field.
	ADC_OVER_OVRE1_Msk = 0x2
	// Bit OVRE1.
	ADC_OVER_OVRE1 = 0x2
	// Position of OVRE2 field.
	ADC_OVER_OVRE2_Pos = 0x2
	// Bit mask of OVRE2 field.
	ADC_OVER_OVRE2_Msk = 0x4
	// Bit OVRE2.
	ADC_OVER_OVRE2 = 0x4
	// Position of OVRE3 field.
	ADC_OVER_OVRE3_Pos = 0x3
	// Bit mask of OVRE3 field.
	ADC_OVER_OVRE3_Msk = 0x8
	// Bit OVRE3.
	ADC_OVER_OVRE3 = 0x8
	// Position of OVRE4 field.
	ADC_OVER_OVRE4_Pos = 0x4
	// Bit mask of OVRE4 field.
	ADC_OVER_OVRE4_Msk = 0x10
	// Bit OVRE4.
	ADC_OVER_OVRE4 = 0x10
	// Position of OVRE5 field.
	ADC_OVER_OVRE5_Pos = 0x5
	// Bit mask of OVRE5 field.
	ADC_OVER_OVRE5_Msk = 0x20
	// Bit OVRE5.
	ADC_OVER_OVRE5 = 0x20
	// Position of OVRE6 field.
	ADC_OVER_OVRE6_Pos = 0x6
	// Bit mask of OVRE6 field.
	ADC_OVER_OVRE6_Msk = 0x40
	// Bit OVRE6.
	ADC_OVER_OVRE6 = 0x40
	// Position of OVRE7 field.
	ADC_OVER_OVRE7_Pos = 0x7
	// Bit mask of OVRE7 field.
	ADC_OVER_OVRE7_Msk = 0x80
	// Bit OVRE7.
	ADC_OVER_OVRE7 = 0x80
	// Position of OVRE8 field.
	ADC_OVER_OVRE8_Pos = 0x8
	// Bit mask of OVRE8 field.
	ADC_OVER_OVRE8_Msk = 0x100
	// Bit OVRE8.
	ADC_OVER_OVRE8 = 0x100
	// Position of OVRE9 field.
	ADC_OVER_OVRE9_Pos = 0x9
	// Bit mask of OVRE9 field.
	ADC_OVER_OVRE9_Msk = 0x200
	// Bit OVRE9.
	ADC_OVER_OVRE9 = 0x200
	// Position of OVRE10 field.
	ADC_OVER_OVRE10_Pos = 0xa
	// Bit mask of OVRE10 field.
	ADC_OVER_OVRE10_Msk = 0x400
	// Bit OVRE10.
	ADC_OVER_OVRE10 = 0x400
	// Position of OVRE11 field.
	ADC_OVER_OVRE11_Pos = 0xb
	// Bit mask of OVRE11 field.
	ADC_OVER_OVRE11_Msk = 0x800
	// Bit OVRE11.
	ADC_OVER_OVRE11 = 0x800

	// EMR: Extended Mode Register
	// Position of CMPMODE field.
	ADC_EMR_CMPMODE_Pos = 0x0
	// Bit mask of CMPMODE field.
	ADC_EMR_CMPMODE_Msk = 0x3
	// Generates an event when the converted data is lower than the low threshold of the window.
	ADC_EMR_CMPMODE_LOW = 0x0
	// Generates an event when the converted data is higher than the high threshold of the window.
	ADC_EMR_CMPMODE_HIGH = 0x1
	// Generates an event when the converted data is in the comparison window.
	ADC_EMR_CMPMODE_IN = 0x2
	// Generates an event when the converted data is out of the comparison window.
	ADC_EMR_CMPMODE_OUT = 0x3
	// Position of CMPSEL field.
	ADC_EMR_CMPSEL_Pos = 0x4
	// Bit mask of CMPSEL field.
	ADC_EMR_CMPSEL_Msk = 0xf0
	// Position of CMPALL field.
	ADC_EMR_CMPALL_Pos = 0x9
	// Bit mask of CMPALL field.
	ADC_EMR_CMPALL_Msk = 0x200
	// Bit CMPALL.
	ADC_EMR_CMPALL = 0x200
	// Position of CMPFILTER field.
	ADC_EMR_CMPFILTER_Pos = 0xc
	// Bit mask of CMPFILTER field.
	ADC_EMR_CMPFILTER_Msk = 0x3000
	// Position of TAG field.
	ADC_EMR_TAG_Pos = 0x18
	// Bit mask of TAG field.
	ADC_EMR_TAG_Msk = 0x1000000
	// Bit TAG.
	ADC_EMR_TAG = 0x1000000

	// CWR: Compare Window Register
	// Position of LOWTHRES field.
	ADC_CWR_LOWTHRES_Pos = 0x0
	// Bit mask of LOWTHRES field.
	ADC_CWR_LOWTHRES_Msk = 0xfff
	// Position of HIGHTHRES field.
	ADC_CWR_HIGHTHRES_Pos = 0x10
	// Bit mask of HIGHTHRES field.
	ADC_CWR_HIGHTHRES_Msk = 0xfff0000

	// CGR: Channel Gain Register
	// Position of GAIN0 field.
	ADC_CGR_GAIN0_Pos = 0x0
	// Bit mask of GAIN0 field.
	ADC_CGR_GAIN0_Msk = 0x3
	// Position of GAIN1 field.
	ADC_CGR_GAIN1_Pos = 0x2
	// Bit mask of GAIN1 field.
	ADC_CGR_GAIN1_Msk = 0xc
	// Position of GAIN2 field.
	ADC_CGR_GAIN2_Pos = 0x4
	// Bit mask of GAIN2 field.
	ADC_CGR_GAIN2_Msk = 0x30
	// Position of GAIN3 field.
	ADC_CGR_GAIN3_Pos = 0x6
	// Bit mask of GAIN3 field.
	ADC_CGR_GAIN3_Msk = 0xc0
	// Position of GAIN4 field.
	ADC_CGR_GAIN4_Pos = 0x8
	// Bit mask of GAIN4 field.
	ADC_CGR_GAIN4_Msk = 0x300
	// Position of GAIN5 field.
	ADC_CGR_GAIN5_Pos = 0xa
	// Bit mask of GAIN5 field.
	ADC_CGR_GAIN5_Msk = 0xc00
	// Position of GAIN6 field.
	ADC_CGR_GAIN6_Pos = 0xc
	// Bit mask of GAIN6 field.
	ADC_CGR_GAIN6_Msk = 0x3000
	// Position of GAIN7 field.
	ADC_CGR_GAIN7_Pos = 0xe
	// Bit mask of GAIN7 field.
	ADC_CGR_GAIN7_Msk = 0xc000
	// Position of GAIN8 field.
	ADC_CGR_GAIN8_Pos = 0x10
	// Bit mask of GAIN8 field.
	ADC_CGR_GAIN8_Msk = 0x30000
	// Position of GAIN9 field.
	ADC_CGR_GAIN9_Pos = 0x12
	// Bit mask of GAIN9 field.
	ADC_CGR_GAIN9_Msk = 0xc0000
	// Position of GAIN10 field.
	ADC_CGR_GAIN10_Pos = 0x14
	// Bit mask of GAIN10 field.
	ADC_CGR_GAIN10_Msk = 0x300000
	// Position of GAIN11 field.
	ADC_CGR_GAIN11_Pos = 0x16
	// Bit mask of GAIN11 field.
	ADC_CGR_GAIN11_Msk = 0xc00000

	// COR: Channel Offset Register
	// Position of OFF0 field.
	ADC_COR_OFF0_Pos = 0x0
	// Bit mask of OFF0 field.
	ADC_COR_OFF0_Msk = 0x1
	// Bit OFF0.
	ADC_COR_OFF0 = 0x1
	// Position of OFF1 field.
	ADC_COR_OFF1_Pos = 0x1
	// Bit mask of OFF1 field.
	ADC_COR_OFF1_Msk = 0x2
	// Bit OFF1.
	ADC_COR_OFF1 = 0x2
	// Position of OFF2 field.
	ADC_COR_OFF2_Pos = 0x2
	// Bit mask of OFF2 field.
	ADC_COR_OFF2_Msk = 0x4
	// Bit OFF2.
	ADC_COR_OFF2 = 0x4
	// Position of OFF3 field.
	ADC_COR_OFF3_Pos = 0x3
	// Bit mask of OFF3 field.
	ADC_COR_OFF3_Msk = 0x8
	// Bit OFF3.
	ADC_COR_OFF3 = 0x8
	// Position of OFF4 field.
	ADC_COR_OFF4_Pos = 0x4
	// Bit mask of OFF4 field.
	ADC_COR_OFF4_Msk = 0x10
	// Bit OFF4.
	ADC_COR_OFF4 = 0x10
	// Position of OFF5 field.
	ADC_COR_OFF5_Pos = 0x5
	// Bit mask of OFF5 field.
	ADC_COR_OFF5_Msk = 0x20
	// Bit OFF5.
	ADC_COR_OFF5 = 0x20
	// Position of OFF6 field.
	ADC_COR_OFF6_Pos = 0x6
	// Bit mask of OFF6 field.
	ADC_COR_OFF6_Msk = 0x40
	// Bit OFF6.
	ADC_COR_OFF6 = 0x40
	// Position of OFF7 field.
	ADC_COR_OFF7_Pos = 0x7
	// Bit mask of OFF7 field.
	ADC_COR_OFF7_Msk = 0x80
	// Bit OFF7.
	ADC_COR_OFF7 = 0x80
	// Position of OFF8 field.
	ADC_COR_OFF8_Pos = 0x8
	// Bit mask of OFF8 field.
	ADC_COR_OFF8_Msk = 0x100
	// Bit OFF8.
	ADC_COR_OFF8 = 0x100
	// Position of OFF9 field.
	ADC_COR_OFF9_Pos = 0x9
	// Bit mask of OFF9 field.
	ADC_COR_OFF9_Msk = 0x200
	// Bit OFF9.
	ADC_COR_OFF9 = 0x200
	// Position of OFF10 field.
	ADC_COR_OFF10_Pos = 0xa
	// Bit mask of OFF10 field.
	ADC_COR_OFF10_Msk = 0x400
	// Bit OFF10.
	ADC_COR_OFF10 = 0x400
	// Position of OFF11 field.
	ADC_COR_OFF11_Pos = 0xb
	// Bit mask of OFF11 field.
	ADC_COR_OFF11_Msk = 0x800
	// Bit OFF11.
	ADC_COR_OFF11 = 0x800
	// Position of DIFF0 field.
	ADC_COR_DIFF0_Pos = 0x10
	// Bit mask of DIFF0 field.
	ADC_COR_DIFF0_Msk = 0x10000
	// Bit DIFF0.
	ADC_COR_DIFF0 = 0x10000
	// Position of DIFF1 field.
	ADC_COR_DIFF1_Pos = 0x11
	// Bit mask of DIFF1 field.
	ADC_COR_DIFF1_Msk = 0x20000
	// Bit DIFF1.
	ADC_COR_DIFF1 = 0x20000
	// Position of DIFF2 field.
	ADC_COR_DIFF2_Pos = 0x12
	// Bit mask of DIFF2 field.
	ADC_COR_DIFF2_Msk = 0x40000
	// Bit DIFF2.
	ADC_COR_DIFF2 = 0x40000
	// Position of DIFF3 field.
	ADC_COR_DIFF3_Pos = 0x13
	// Bit mask of DIFF3 field.
	ADC_COR_DIFF3_Msk = 0x80000
	// Bit DIFF3.
	ADC_COR_DIFF3 = 0x80000
	// Position of DIFF4 field.
	ADC_COR_DIFF4_Pos = 0x14
	// Bit mask of DIFF4 field.
	ADC_COR_DIFF4_Msk = 0x100000
	// Bit DIFF4.
	ADC_COR_DIFF4 = 0x100000
	// Position of DIFF5 field.
	ADC_COR_DIFF5_Pos = 0x15
	// Bit mask of DIFF5 field.
	ADC_COR_DIFF5_Msk = 0x200000
	// Bit DIFF5.
	ADC_COR_DIFF5 = 0x200000
	// Position of DIFF6 field.
	ADC_COR_DIFF6_Pos = 0x16
	// Bit mask of DIFF6 field.
	ADC_COR_DIFF6_Msk = 0x400000
	// Bit DIFF6.
	ADC_COR_DIFF6 = 0x400000
	// Position of DIFF7 field.
	ADC_COR_DIFF7_Pos = 0x17
	// Bit mask of DIFF7 field.
	ADC_COR_DIFF7_Msk = 0x800000
	// Bit DIFF7.
	ADC_COR_DIFF7 = 0x800000
	// Position of DIFF8 field.
	ADC_COR_DIFF8_Pos = 0x18
	// Bit mask of DIFF8 field.
	ADC_COR_DIFF8_Msk = 0x1000000
	// Bit DIFF8.
	ADC_COR_DIFF8 = 0x1000000
	// Position of DIFF9 field.
	ADC_COR_DIFF9_Pos = 0x19
	// Bit mask of DIFF9 field.
	ADC_COR_DIFF9_Msk = 0x2000000
	// Bit DIFF9.
	ADC_COR_DIFF9 = 0x2000000
	// Position of DIFF10 field.
	ADC_COR_DIFF10_Pos = 0x1a
	// Bit mask of DIFF10 field.
	ADC_COR_DIFF10_Msk = 0x4000000
	// Bit DIFF10.
	ADC_COR_DIFF10 = 0x4000000
	// Position of DIFF11 field.
	ADC_COR_DIFF11_Pos = 0x1b
	// Bit mask of DIFF11 field.
	ADC_COR_DIFF11_Msk = 0x8000000
	// Bit DIFF11.
	ADC_COR_DIFF11 = 0x8000000

	// CDR: Channel Data Register
	// Position of DATA field.
	ADC_CDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	ADC_CDR_DATA_Msk = 0xfff

	// ACR: Analog Control Register
	// Position of PENDETSENS field.
	ADC_ACR_PENDETSENS_Pos = 0x0
	// Bit mask of PENDETSENS field.
	ADC_ACR_PENDETSENS_Msk = 0x3

	// TSMR: Touchscreen Mode Register
	// Position of TSMODE field.
	ADC_TSMR_TSMODE_Pos = 0x0
	// Bit mask of TSMODE field.
	ADC_TSMR_TSMODE_Msk = 0x3
	// No Touchscreen
	ADC_TSMR_TSMODE_NONE = 0x0
	// 4-wire Touchscreen without pressure measurement
	ADC_TSMR_TSMODE_4_WIRE_NO_PM = 0x1
	// 4-wire Touchscreen with pressure measurement
	ADC_TSMR_TSMODE_4_WIRE = 0x2
	// 5-wire Touchscreen
	ADC_TSMR_TSMODE_5_WIRE = 0x3
	// Position of TSAV field.
	ADC_TSMR_TSAV_Pos = 0x4
	// Bit mask of TSAV field.
	ADC_TSMR_TSAV_Msk = 0x30
	// No Filtering. Only one ADC conversion per measure
	ADC_TSMR_TSAV_NO_FILTER = 0x0
	// Averages 2 ADC conversions
	ADC_TSMR_TSAV_AVG2CONV = 0x1
	// Averages 4 ADC conversions
	ADC_TSMR_TSAV_AVG4CONV = 0x2
	// Averages 8 ADC conversions
	ADC_TSMR_TSAV_AVG8CONV = 0x3
	// Position of TSFREQ field.
	ADC_TSMR_TSFREQ_Pos = 0x8
	// Bit mask of TSFREQ field.
	ADC_TSMR_TSFREQ_Msk = 0xf00
	// Position of TSSCTIM field.
	ADC_TSMR_TSSCTIM_Pos = 0x10
	// Bit mask of TSSCTIM field.
	ADC_TSMR_TSSCTIM_Msk = 0xf0000
	// Position of NOTSDMA field.
	ADC_TSMR_NOTSDMA_Pos = 0x16
	// Bit mask of NOTSDMA field.
	ADC_TSMR_NOTSDMA_Msk = 0x400000
	// Bit NOTSDMA.
	ADC_TSMR_NOTSDMA = 0x400000
	// Position of PENDET field.
	ADC_TSMR_PENDET_Pos = 0x18
	// Bit mask of PENDET field.
	ADC_TSMR_PENDET_Msk = 0x1000000
	// Bit PENDET.
	ADC_TSMR_PENDET = 0x1000000
	// Position of PENDBC field.
	ADC_TSMR_PENDBC_Pos = 0x1c
	// Bit mask of PENDBC field.
	ADC_TSMR_PENDBC_Msk = 0xf0000000

	// XPOSR: Touchscreen X Position Register
	// Position of XPOS field.
	ADC_XPOSR_XPOS_Pos = 0x0
	// Bit mask of XPOS field.
	ADC_XPOSR_XPOS_Msk = 0xfff
	// Position of XSCALE field.
	ADC_XPOSR_XSCALE_Pos = 0x10
	// Bit mask of XSCALE field.
	ADC_XPOSR_XSCALE_Msk = 0xfff0000

	// YPOSR: Touchscreen Y Position Register
	// Position of YPOS field.
	ADC_YPOSR_YPOS_Pos = 0x0
	// Bit mask of YPOS field.
	ADC_YPOSR_YPOS_Msk = 0xfff
	// Position of YSCALE field.
	ADC_YPOSR_YSCALE_Pos = 0x10
	// Bit mask of YSCALE field.
	ADC_YPOSR_YSCALE_Msk = 0xfff0000

	// PRESSR: Touchscreen Pressure Register
	// Position of Z1 field.
	ADC_PRESSR_Z1_Pos = 0x0
	// Bit mask of Z1 field.
	ADC_PRESSR_Z1_Msk = 0xfff
	// Position of Z2 field.
	ADC_PRESSR_Z2_Pos = 0x10
	// Bit mask of Z2 field.
	ADC_PRESSR_Z2_Msk = 0xfff0000

	// TRGR: Trigger Register
	// Position of TRGMOD field.
	ADC_TRGR_TRGMOD_Pos = 0x0
	// Bit mask of TRGMOD field.
	ADC_TRGR_TRGMOD_Msk = 0x7
	// No trigger, only software trigger can start conversions
	ADC_TRGR_TRGMOD_NO_TRIGGER = 0x0
	// External Trigger Rising Edge
	ADC_TRGR_TRGMOD_EXT_TRIG_RISE = 0x1
	// External Trigger Falling Edge
	ADC_TRGR_TRGMOD_EXT_TRIG_FALL = 0x2
	// External Trigger Any Edge
	ADC_TRGR_TRGMOD_EXT_TRIG_ANY = 0x3
	// Pen Detect Trigger (shall be selected only if PENDET is set and TSAMOD = Touchscreen only mode)
	ADC_TRGR_TRGMOD_PEN_TRIG = 0x4
	// Periodic Trigger (TRGPER shall be initiated appropriately)
	ADC_TRGR_TRGMOD_PERIOD_TRIG = 0x5
	// Continuous Mode
	ADC_TRGR_TRGMOD_CONTINUOUS = 0x6
	// Position of TRGPER field.
	ADC_TRGR_TRGPER_Pos = 0x10
	// Bit mask of TRGPER field.
	ADC_TRGR_TRGPER_Msk = 0xffff0000

	// WPMR: Write Protect Mode Register
	// Position of WPEN field.
	ADC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	ADC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	ADC_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	ADC_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	ADC_WPMR_WPKEY_Msk = 0xffffff00

	// WPSR: Write Protect Status Register
	// Position of WPVS field.
	ADC_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	ADC_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	ADC_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	ADC_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	ADC_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for EMAC: Ethernet MAC 10/100
const (
	// NCR: Network Control Register
	// Position of LB field.
	EMAC_NCR_LB_Pos = 0x0
	// Bit mask of LB field.
	EMAC_NCR_LB_Msk = 0x1
	// Bit LB.
	EMAC_NCR_LB = 0x1
	// Position of LLB field.
	EMAC_NCR_LLB_Pos = 0x1
	// Bit mask of LLB field.
	EMAC_NCR_LLB_Msk = 0x2
	// Bit LLB.
	EMAC_NCR_LLB = 0x2
	// Position of RE field.
	EMAC_NCR_RE_Pos = 0x2
	// Bit mask of RE field.
	EMAC_NCR_RE_Msk = 0x4
	// Bit RE.
	EMAC_NCR_RE = 0x4
	// Position of TE field.
	EMAC_NCR_TE_Pos = 0x3
	// Bit mask of TE field.
	EMAC_NCR_TE_Msk = 0x8
	// Bit TE.
	EMAC_NCR_TE = 0x8
	// Position of MPE field.
	EMAC_NCR_MPE_Pos = 0x4
	// Bit mask of MPE field.
	EMAC_NCR_MPE_Msk = 0x10
	// Bit MPE.
	EMAC_NCR_MPE = 0x10
	// Position of CLRSTAT field.
	EMAC_NCR_CLRSTAT_Pos = 0x5
	// Bit mask of CLRSTAT field.
	EMAC_NCR_CLRSTAT_Msk = 0x20
	// Bit CLRSTAT.
	EMAC_NCR_CLRSTAT = 0x20
	// Position of INCSTAT field.
	EMAC_NCR_INCSTAT_Pos = 0x6
	// Bit mask of INCSTAT field.
	EMAC_NCR_INCSTAT_Msk = 0x40
	// Bit INCSTAT.
	EMAC_NCR_INCSTAT = 0x40
	// Position of WESTAT field.
	EMAC_NCR_WESTAT_Pos = 0x7
	// Bit mask of WESTAT field.
	EMAC_NCR_WESTAT_Msk = 0x80
	// Bit WESTAT.
	EMAC_NCR_WESTAT = 0x80
	// Position of BP field.
	EMAC_NCR_BP_Pos = 0x8
	// Bit mask of BP field.
	EMAC_NCR_BP_Msk = 0x100
	// Bit BP.
	EMAC_NCR_BP = 0x100
	// Position of TSTART field.
	EMAC_NCR_TSTART_Pos = 0x9
	// Bit mask of TSTART field.
	EMAC_NCR_TSTART_Msk = 0x200
	// Bit TSTART.
	EMAC_NCR_TSTART = 0x200
	// Position of THALT field.
	EMAC_NCR_THALT_Pos = 0xa
	// Bit mask of THALT field.
	EMAC_NCR_THALT_Msk = 0x400
	// Bit THALT.
	EMAC_NCR_THALT = 0x400

	// NCFGR: Network Configuration Register
	// Position of SPD field.
	EMAC_NCFGR_SPD_Pos = 0x0
	// Bit mask of SPD field.
	EMAC_NCFGR_SPD_Msk = 0x1
	// Bit SPD.
	EMAC_NCFGR_SPD = 0x1
	// Position of FD field.
	EMAC_NCFGR_FD_Pos = 0x1
	// Bit mask of FD field.
	EMAC_NCFGR_FD_Msk = 0x2
	// Bit FD.
	EMAC_NCFGR_FD = 0x2
	// Position of JFRAME field.
	EMAC_NCFGR_JFRAME_Pos = 0x3
	// Bit mask of JFRAME field.
	EMAC_NCFGR_JFRAME_Msk = 0x8
	// Bit JFRAME.
	EMAC_NCFGR_JFRAME = 0x8
	// Position of CAF field.
	EMAC_NCFGR_CAF_Pos = 0x4
	// Bit mask of CAF field.
	EMAC_NCFGR_CAF_Msk = 0x10
	// Bit CAF.
	EMAC_NCFGR_CAF = 0x10
	// Position of NBC field.
	EMAC_NCFGR_NBC_Pos = 0x5
	// Bit mask of NBC field.
	EMAC_NCFGR_NBC_Msk = 0x20
	// Bit NBC.
	EMAC_NCFGR_NBC = 0x20
	// Position of MTI field.
	EMAC_NCFGR_MTI_Pos = 0x6
	// Bit mask of MTI field.
	EMAC_NCFGR_MTI_Msk = 0x40
	// Bit MTI.
	EMAC_NCFGR_MTI = 0x40
	// Position of UNI field.
	EMAC_NCFGR_UNI_Pos = 0x7
	// Bit mask of UNI field.
	EMAC_NCFGR_UNI_Msk = 0x80
	// Bit UNI.
	EMAC_NCFGR_UNI = 0x80
	// Position of BIG field.
	EMAC_NCFGR_BIG_Pos = 0x8
	// Bit mask of BIG field.
	EMAC_NCFGR_BIG_Msk = 0x100
	// Bit BIG.
	EMAC_NCFGR_BIG = 0x100
	// Position of CLK field.
	EMAC_NCFGR_CLK_Pos = 0xa
	// Bit mask of CLK field.
	EMAC_NCFGR_CLK_Msk = 0xc00
	// MCK divided by 8 (MCK up to 20 MHz).
	EMAC_NCFGR_CLK_MCK_8 = 0x0
	// MCK divided by 16 (MCK up to 40 MHz).
	EMAC_NCFGR_CLK_MCK_16 = 0x1
	// MCK divided by 32 (MCK up to 80 MHz).
	EMAC_NCFGR_CLK_MCK_32 = 0x2
	// MCK divided by 64 (MCK up to 160 MHz).
	EMAC_NCFGR_CLK_MCK_64 = 0x3
	// Position of RTY field.
	EMAC_NCFGR_RTY_Pos = 0xc
	// Bit mask of RTY field.
	EMAC_NCFGR_RTY_Msk = 0x1000
	// Bit RTY.
	EMAC_NCFGR_RTY = 0x1000
	// Position of PAE field.
	EMAC_NCFGR_PAE_Pos = 0xd
	// Bit mask of PAE field.
	EMAC_NCFGR_PAE_Msk = 0x2000
	// Bit PAE.
	EMAC_NCFGR_PAE = 0x2000
	// Position of RBOF field.
	EMAC_NCFGR_RBOF_Pos = 0xe
	// Bit mask of RBOF field.
	EMAC_NCFGR_RBOF_Msk = 0xc000
	// No offset from start of receive buffer.
	EMAC_NCFGR_RBOF_OFFSET_0 = 0x0
	// One-byte offset from start of receive buffer.
	EMAC_NCFGR_RBOF_OFFSET_1 = 0x1
	// Two-byte offset from start of receive buffer.
	EMAC_NCFGR_RBOF_OFFSET_2 = 0x2
	// Three-byte offset from start of receive buffer.
	EMAC_NCFGR_RBOF_OFFSET_3 = 0x3
	// Position of RLCE field.
	EMAC_NCFGR_RLCE_Pos = 0x10
	// Bit mask of RLCE field.
	EMAC_NCFGR_RLCE_Msk = 0x10000
	// Bit RLCE.
	EMAC_NCFGR_RLCE = 0x10000
	// Position of DRFCS field.
	EMAC_NCFGR_DRFCS_Pos = 0x11
	// Bit mask of DRFCS field.
	EMAC_NCFGR_DRFCS_Msk = 0x20000
	// Bit DRFCS.
	EMAC_NCFGR_DRFCS = 0x20000
	// Position of EFRHD field.
	EMAC_NCFGR_EFRHD_Pos = 0x12
	// Bit mask of EFRHD field.
	EMAC_NCFGR_EFRHD_Msk = 0x40000
	// Bit EFRHD.
	EMAC_NCFGR_EFRHD = 0x40000
	// Position of IRXFCS field.
	EMAC_NCFGR_IRXFCS_Pos = 0x13
	// Bit mask of IRXFCS field.
	EMAC_NCFGR_IRXFCS_Msk = 0x80000
	// Bit IRXFCS.
	EMAC_NCFGR_IRXFCS = 0x80000

	// NSR: Network Status Register
	// Position of MDIO field.
	EMAC_NSR_MDIO_Pos = 0x1
	// Bit mask of MDIO field.
	EMAC_NSR_MDIO_Msk = 0x2
	// Bit MDIO.
	EMAC_NSR_MDIO = 0x2
	// Position of IDLE field.
	EMAC_NSR_IDLE_Pos = 0x2
	// Bit mask of IDLE field.
	EMAC_NSR_IDLE_Msk = 0x4
	// Bit IDLE.
	EMAC_NSR_IDLE = 0x4

	// TSR: Transmit Status Register
	// Position of UBR field.
	EMAC_TSR_UBR_Pos = 0x0
	// Bit mask of UBR field.
	EMAC_TSR_UBR_Msk = 0x1
	// Bit UBR.
	EMAC_TSR_UBR = 0x1
	// Position of COL field.
	EMAC_TSR_COL_Pos = 0x1
	// Bit mask of COL field.
	EMAC_TSR_COL_Msk = 0x2
	// Bit COL.
	EMAC_TSR_COL = 0x2
	// Position of RLES field.
	EMAC_TSR_RLES_Pos = 0x2
	// Bit mask of RLES field.
	EMAC_TSR_RLES_Msk = 0x4
	// Bit RLES.
	EMAC_TSR_RLES = 0x4
	// Position of TGO field.
	EMAC_TSR_TGO_Pos = 0x3
	// Bit mask of TGO field.
	EMAC_TSR_TGO_Msk = 0x8
	// Bit TGO.
	EMAC_TSR_TGO = 0x8
	// Position of BEX field.
	EMAC_TSR_BEX_Pos = 0x4
	// Bit mask of BEX field.
	EMAC_TSR_BEX_Msk = 0x10
	// Bit BEX.
	EMAC_TSR_BEX = 0x10
	// Position of COMP field.
	EMAC_TSR_COMP_Pos = 0x5
	// Bit mask of COMP field.
	EMAC_TSR_COMP_Msk = 0x20
	// Bit COMP.
	EMAC_TSR_COMP = 0x20
	// Position of UND field.
	EMAC_TSR_UND_Pos = 0x6
	// Bit mask of UND field.
	EMAC_TSR_UND_Msk = 0x40
	// Bit UND.
	EMAC_TSR_UND = 0x40

	// RBQP: Receive Buffer Queue Pointer Register
	// Position of ADDR field.
	EMAC_RBQP_ADDR_Pos = 0x2
	// Bit mask of ADDR field.
	EMAC_RBQP_ADDR_Msk = 0xfffffffc

	// TBQP: Transmit Buffer Queue Pointer Register
	// Position of ADDR field.
	EMAC_TBQP_ADDR_Pos = 0x2
	// Bit mask of ADDR field.
	EMAC_TBQP_ADDR_Msk = 0xfffffffc

	// RSR: Receive Status Register
	// Position of BNA field.
	EMAC_RSR_BNA_Pos = 0x0
	// Bit mask of BNA field.
	EMAC_RSR_BNA_Msk = 0x1
	// Bit BNA.
	EMAC_RSR_BNA = 0x1
	// Position of REC field.
	EMAC_RSR_REC_Pos = 0x1
	// Bit mask of REC field.
	EMAC_RSR_REC_Msk = 0x2
	// Bit REC.
	EMAC_RSR_REC = 0x2
	// Position of OVR field.
	EMAC_RSR_OVR_Pos = 0x2
	// Bit mask of OVR field.
	EMAC_RSR_OVR_Msk = 0x4
	// Bit OVR.
	EMAC_RSR_OVR = 0x4

	// ISR: Interrupt Status Register
	// Position of MFD field.
	EMAC_ISR_MFD_Pos = 0x0
	// Bit mask of MFD field.
	EMAC_ISR_MFD_Msk = 0x1
	// Bit MFD.
	EMAC_ISR_MFD = 0x1
	// Position of RCOMP field.
	EMAC_ISR_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	EMAC_ISR_RCOMP_Msk = 0x2
	// Bit RCOMP.
	EMAC_ISR_RCOMP = 0x2
	// Position of RXUBR field.
	EMAC_ISR_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	EMAC_ISR_RXUBR_Msk = 0x4
	// Bit RXUBR.
	EMAC_ISR_RXUBR = 0x4
	// Position of TXUBR field.
	EMAC_ISR_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	EMAC_ISR_TXUBR_Msk = 0x8
	// Bit TXUBR.
	EMAC_ISR_TXUBR = 0x8
	// Position of TUND field.
	EMAC_ISR_TUND_Pos = 0x4
	// Bit mask of TUND field.
	EMAC_ISR_TUND_Msk = 0x10
	// Bit TUND.
	EMAC_ISR_TUND = 0x10
	// Position of RLEX field.
	EMAC_ISR_RLEX_Pos = 0x5
	// Bit mask of RLEX field.
	EMAC_ISR_RLEX_Msk = 0x20
	// Bit RLEX.
	EMAC_ISR_RLEX = 0x20
	// Position of TXERR field.
	EMAC_ISR_TXERR_Pos = 0x6
	// Bit mask of TXERR field.
	EMAC_ISR_TXERR_Msk = 0x40
	// Bit TXERR.
	EMAC_ISR_TXERR = 0x40
	// Position of TCOMP field.
	EMAC_ISR_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	EMAC_ISR_TCOMP_Msk = 0x80
	// Bit TCOMP.
	EMAC_ISR_TCOMP = 0x80
	// Position of ROVR field.
	EMAC_ISR_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	EMAC_ISR_ROVR_Msk = 0x400
	// Bit ROVR.
	EMAC_ISR_ROVR = 0x400
	// Position of HRESP field.
	EMAC_ISR_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	EMAC_ISR_HRESP_Msk = 0x800
	// Bit HRESP.
	EMAC_ISR_HRESP = 0x800
	// Position of PFRE field.
	EMAC_ISR_PFRE_Pos = 0xc
	// Bit mask of PFRE field.
	EMAC_ISR_PFRE_Msk = 0x1000
	// Bit PFRE.
	EMAC_ISR_PFRE = 0x1000
	// Position of PTZ field.
	EMAC_ISR_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	EMAC_ISR_PTZ_Msk = 0x2000
	// Bit PTZ.
	EMAC_ISR_PTZ = 0x2000
	// Position of WOL field.
	EMAC_ISR_WOL_Pos = 0xe
	// Bit mask of WOL field.
	EMAC_ISR_WOL_Msk = 0x4000
	// Bit WOL.
	EMAC_ISR_WOL = 0x4000

	// IER: Interrupt Enable Register
	// Position of MFD field.
	EMAC_IER_MFD_Pos = 0x0
	// Bit mask of MFD field.
	EMAC_IER_MFD_Msk = 0x1
	// Bit MFD.
	EMAC_IER_MFD = 0x1
	// Position of RCOMP field.
	EMAC_IER_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	EMAC_IER_RCOMP_Msk = 0x2
	// Bit RCOMP.
	EMAC_IER_RCOMP = 0x2
	// Position of RXUBR field.
	EMAC_IER_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	EMAC_IER_RXUBR_Msk = 0x4
	// Bit RXUBR.
	EMAC_IER_RXUBR = 0x4
	// Position of TXUBR field.
	EMAC_IER_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	EMAC_IER_TXUBR_Msk = 0x8
	// Bit TXUBR.
	EMAC_IER_TXUBR = 0x8
	// Position of TUND field.
	EMAC_IER_TUND_Pos = 0x4
	// Bit mask of TUND field.
	EMAC_IER_TUND_Msk = 0x10
	// Bit TUND.
	EMAC_IER_TUND = 0x10
	// Position of RLE field.
	EMAC_IER_RLE_Pos = 0x5
	// Bit mask of RLE field.
	EMAC_IER_RLE_Msk = 0x20
	// Bit RLE.
	EMAC_IER_RLE = 0x20
	// Position of TXERR field.
	EMAC_IER_TXERR_Pos = 0x6
	// Bit mask of TXERR field.
	EMAC_IER_TXERR_Msk = 0x40
	// Bit TXERR.
	EMAC_IER_TXERR = 0x40
	// Position of TCOMP field.
	EMAC_IER_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	EMAC_IER_TCOMP_Msk = 0x80
	// Bit TCOMP.
	EMAC_IER_TCOMP = 0x80
	// Position of ROVR field.
	EMAC_IER_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	EMAC_IER_ROVR_Msk = 0x400
	// Bit ROVR.
	EMAC_IER_ROVR = 0x400
	// Position of HRESP field.
	EMAC_IER_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	EMAC_IER_HRESP_Msk = 0x800
	// Bit HRESP.
	EMAC_IER_HRESP = 0x800
	// Position of PFR field.
	EMAC_IER_PFR_Pos = 0xc
	// Bit mask of PFR field.
	EMAC_IER_PFR_Msk = 0x1000
	// Bit PFR.
	EMAC_IER_PFR = 0x1000
	// Position of PTZ field.
	EMAC_IER_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	EMAC_IER_PTZ_Msk = 0x2000
	// Bit PTZ.
	EMAC_IER_PTZ = 0x2000
	// Position of WOL field.
	EMAC_IER_WOL_Pos = 0xe
	// Bit mask of WOL field.
	EMAC_IER_WOL_Msk = 0x4000
	// Bit WOL.
	EMAC_IER_WOL = 0x4000

	// IDR: Interrupt Disable Register
	// Position of MFD field.
	EMAC_IDR_MFD_Pos = 0x0
	// Bit mask of MFD field.
	EMAC_IDR_MFD_Msk = 0x1
	// Bit MFD.
	EMAC_IDR_MFD = 0x1
	// Position of RCOMP field.
	EMAC_IDR_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	EMAC_IDR_RCOMP_Msk = 0x2
	// Bit RCOMP.
	EMAC_IDR_RCOMP = 0x2
	// Position of RXUBR field.
	EMAC_IDR_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	EMAC_IDR_RXUBR_Msk = 0x4
	// Bit RXUBR.
	EMAC_IDR_RXUBR = 0x4
	// Position of TXUBR field.
	EMAC_IDR_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	EMAC_IDR_TXUBR_Msk = 0x8
	// Bit TXUBR.
	EMAC_IDR_TXUBR = 0x8
	// Position of TUND field.
	EMAC_IDR_TUND_Pos = 0x4
	// Bit mask of TUND field.
	EMAC_IDR_TUND_Msk = 0x10
	// Bit TUND.
	EMAC_IDR_TUND = 0x10
	// Position of RLE field.
	EMAC_IDR_RLE_Pos = 0x5
	// Bit mask of RLE field.
	EMAC_IDR_RLE_Msk = 0x20
	// Bit RLE.
	EMAC_IDR_RLE = 0x20
	// Position of TXERR field.
	EMAC_IDR_TXERR_Pos = 0x6
	// Bit mask of TXERR field.
	EMAC_IDR_TXERR_Msk = 0x40
	// Bit TXERR.
	EMAC_IDR_TXERR = 0x40
	// Position of TCOMP field.
	EMAC_IDR_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	EMAC_IDR_TCOMP_Msk = 0x80
	// Bit TCOMP.
	EMAC_IDR_TCOMP = 0x80
	// Position of ROVR field.
	EMAC_IDR_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	EMAC_IDR_ROVR_Msk = 0x400
	// Bit ROVR.
	EMAC_IDR_ROVR = 0x400
	// Position of HRESP field.
	EMAC_IDR_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	EMAC_IDR_HRESP_Msk = 0x800
	// Bit HRESP.
	EMAC_IDR_HRESP = 0x800
	// Position of PFR field.
	EMAC_IDR_PFR_Pos = 0xc
	// Bit mask of PFR field.
	EMAC_IDR_PFR_Msk = 0x1000
	// Bit PFR.
	EMAC_IDR_PFR = 0x1000
	// Position of PTZ field.
	EMAC_IDR_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	EMAC_IDR_PTZ_Msk = 0x2000
	// Bit PTZ.
	EMAC_IDR_PTZ = 0x2000
	// Position of WOL field.
	EMAC_IDR_WOL_Pos = 0xe
	// Bit mask of WOL field.
	EMAC_IDR_WOL_Msk = 0x4000
	// Bit WOL.
	EMAC_IDR_WOL = 0x4000

	// IMR: Interrupt Mask Register
	// Position of MFD field.
	EMAC_IMR_MFD_Pos = 0x0
	// Bit mask of MFD field.
	EMAC_IMR_MFD_Msk = 0x1
	// Bit MFD.
	EMAC_IMR_MFD = 0x1
	// Position of RCOMP field.
	EMAC_IMR_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	EMAC_IMR_RCOMP_Msk = 0x2
	// Bit RCOMP.
	EMAC_IMR_RCOMP = 0x2
	// Position of RXUBR field.
	EMAC_IMR_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	EMAC_IMR_RXUBR_Msk = 0x4
	// Bit RXUBR.
	EMAC_IMR_RXUBR = 0x4
	// Position of TXUBR field.
	EMAC_IMR_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	EMAC_IMR_TXUBR_Msk = 0x8
	// Bit TXUBR.
	EMAC_IMR_TXUBR = 0x8
	// Position of TUND field.
	EMAC_IMR_TUND_Pos = 0x4
	// Bit mask of TUND field.
	EMAC_IMR_TUND_Msk = 0x10
	// Bit TUND.
	EMAC_IMR_TUND = 0x10
	// Position of RLE field.
	EMAC_IMR_RLE_Pos = 0x5
	// Bit mask of RLE field.
	EMAC_IMR_RLE_Msk = 0x20
	// Bit RLE.
	EMAC_IMR_RLE = 0x20
	// Position of TXERR field.
	EMAC_IMR_TXERR_Pos = 0x6
	// Bit mask of TXERR field.
	EMAC_IMR_TXERR_Msk = 0x40
	// Bit TXERR.
	EMAC_IMR_TXERR = 0x40
	// Position of TCOMP field.
	EMAC_IMR_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	EMAC_IMR_TCOMP_Msk = 0x80
	// Bit TCOMP.
	EMAC_IMR_TCOMP = 0x80
	// Position of ROVR field.
	EMAC_IMR_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	EMAC_IMR_ROVR_Msk = 0x400
	// Bit ROVR.
	EMAC_IMR_ROVR = 0x400
	// Position of HRESP field.
	EMAC_IMR_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	EMAC_IMR_HRESP_Msk = 0x800
	// Bit HRESP.
	EMAC_IMR_HRESP = 0x800
	// Position of PFR field.
	EMAC_IMR_PFR_Pos = 0xc
	// Bit mask of PFR field.
	EMAC_IMR_PFR_Msk = 0x1000
	// Bit PFR.
	EMAC_IMR_PFR = 0x1000
	// Position of PTZ field.
	EMAC_IMR_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	EMAC_IMR_PTZ_Msk = 0x2000
	// Bit PTZ.
	EMAC_IMR_PTZ = 0x2000
	// Position of WOL field.
	EMAC_IMR_WOL_Pos = 0xe
	// Bit mask of WOL field.
	EMAC_IMR_WOL_Msk = 0x4000
	// Bit WOL.
	EMAC_IMR_WOL = 0x4000

	// MAN: Phy Maintenance Register
	// Position of DATA field.
	EMAC_MAN_DATA_Pos = 0x0
	// Bit mask of DATA field.
	EMAC_MAN_DATA_Msk = 0xffff
	// Position of CODE field.
	EMAC_MAN_CODE_Pos = 0x10
	// Bit mask of CODE field.
	EMAC_MAN_CODE_Msk = 0x30000
	// Position of REGA field.
	EMAC_MAN_REGA_Pos = 0x12
	// Bit mask of REGA field.
	EMAC_MAN_REGA_Msk = 0x7c0000
	// Position of PHYA field.
	EMAC_MAN_PHYA_Pos = 0x17
	// Bit mask of PHYA field.
	EMAC_MAN_PHYA_Msk = 0xf800000
	// Position of RW field.
	EMAC_MAN_RW_Pos = 0x1c
	// Bit mask of RW field.
	EMAC_MAN_RW_Msk = 0x30000000
	// Position of SOF field.
	EMAC_MAN_SOF_Pos = 0x1e
	// Bit mask of SOF field.
	EMAC_MAN_SOF_Msk = 0xc0000000

	// PTR: Pause Time Register
	// Position of PTIME field.
	EMAC_PTR_PTIME_Pos = 0x0
	// Bit mask of PTIME field.
	EMAC_PTR_PTIME_Msk = 0xffff

	// PFR: Pause Frames Received Register
	// Position of FROK field.
	EMAC_PFR_FROK_Pos = 0x0
	// Bit mask of FROK field.
	EMAC_PFR_FROK_Msk = 0xffff

	// FTO: Frames Transmitted Ok Register
	// Position of FTOK field.
	EMAC_FTO_FTOK_Pos = 0x0
	// Bit mask of FTOK field.
	EMAC_FTO_FTOK_Msk = 0xffffff

	// SCF: Single Collision Frames Register
	// Position of SCF field.
	EMAC_SCF_SCF_Pos = 0x0
	// Bit mask of SCF field.
	EMAC_SCF_SCF_Msk = 0xffff

	// MCF: Multiple Collision Frames Register
	// Position of MCF field.
	EMAC_MCF_MCF_Pos = 0x0
	// Bit mask of MCF field.
	EMAC_MCF_MCF_Msk = 0xffff

	// FRO: Frames Received Ok Register
	// Position of FROK field.
	EMAC_FRO_FROK_Pos = 0x0
	// Bit mask of FROK field.
	EMAC_FRO_FROK_Msk = 0xffffff

	// FCSE: Frame Check Sequence Errors Register
	// Position of FCSE field.
	EMAC_FCSE_FCSE_Pos = 0x0
	// Bit mask of FCSE field.
	EMAC_FCSE_FCSE_Msk = 0xff

	// ALE: Alignment Errors Register
	// Position of ALE field.
	EMAC_ALE_ALE_Pos = 0x0
	// Bit mask of ALE field.
	EMAC_ALE_ALE_Msk = 0xff

	// DTF: Deferred Transmission Frames Register
	// Position of DTF field.
	EMAC_DTF_DTF_Pos = 0x0
	// Bit mask of DTF field.
	EMAC_DTF_DTF_Msk = 0xffff

	// LCOL: Late Collisions Register
	// Position of LCOL field.
	EMAC_LCOL_LCOL_Pos = 0x0
	// Bit mask of LCOL field.
	EMAC_LCOL_LCOL_Msk = 0xff

	// ECOL: Excessive Collisions Register
	// Position of EXCOL field.
	EMAC_ECOL_EXCOL_Pos = 0x0
	// Bit mask of EXCOL field.
	EMAC_ECOL_EXCOL_Msk = 0xff

	// TUND: Transmit Underrun Errors Register
	// Position of TUND field.
	EMAC_TUND_TUND_Pos = 0x0
	// Bit mask of TUND field.
	EMAC_TUND_TUND_Msk = 0xff

	// CSE: Carrier Sense Errors Register
	// Position of CSE field.
	EMAC_CSE_CSE_Pos = 0x0
	// Bit mask of CSE field.
	EMAC_CSE_CSE_Msk = 0xff

	// RRE: Receive Resource Errors Register
	// Position of RRE field.
	EMAC_RRE_RRE_Pos = 0x0
	// Bit mask of RRE field.
	EMAC_RRE_RRE_Msk = 0xffff

	// ROV: Receive Overrun Errors Register
	// Position of ROVR field.
	EMAC_ROV_ROVR_Pos = 0x0
	// Bit mask of ROVR field.
	EMAC_ROV_ROVR_Msk = 0xff

	// RSE: Receive Symbol Errors Register
	// Position of RSE field.
	EMAC_RSE_RSE_Pos = 0x0
	// Bit mask of RSE field.
	EMAC_RSE_RSE_Msk = 0xff

	// ELE: Excessive Length Errors Register
	// Position of EXL field.
	EMAC_ELE_EXL_Pos = 0x0
	// Bit mask of EXL field.
	EMAC_ELE_EXL_Msk = 0xff

	// RJA: Receive Jabbers Register
	// Position of RJB field.
	EMAC_RJA_RJB_Pos = 0x0
	// Bit mask of RJB field.
	EMAC_RJA_RJB_Msk = 0xff

	// USF: Undersize Frames Register
	// Position of USF field.
	EMAC_USF_USF_Pos = 0x0
	// Bit mask of USF field.
	EMAC_USF_USF_Msk = 0xff

	// STE: SQE Test Errors Register
	// Position of SQER field.
	EMAC_STE_SQER_Pos = 0x0
	// Bit mask of SQER field.
	EMAC_STE_SQER_Msk = 0xff

	// RLE: Received Length Field Mismatch Register
	// Position of RLFM field.
	EMAC_RLE_RLFM_Pos = 0x0
	// Bit mask of RLFM field.
	EMAC_RLE_RLFM_Msk = 0xff

	// HRB: Hash Register Bottom [31:0] Register
	// Position of ADDR field.
	EMAC_HRB_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_HRB_ADDR_Msk = 0xffffffff

	// HRT: Hash Register Top [63:32] Register
	// Position of ADDR field.
	EMAC_HRT_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_HRT_ADDR_Msk = 0xffffffff

	// SA1B: Specific Address 1 Bottom Register
	// Position of ADDR field.
	EMAC_SA1B_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA1B_ADDR_Msk = 0xffffffff

	// SA1T: Specific Address 1 Top Register
	// Position of ADDR field.
	EMAC_SA1T_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA1T_ADDR_Msk = 0xffff

	// SA2B: Specific Address 2 Bottom Register
	// Position of ADDR field.
	EMAC_SA2B_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA2B_ADDR_Msk = 0xffffffff

	// SA2T: Specific Address 2 Top Register
	// Position of ADDR field.
	EMAC_SA2T_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA2T_ADDR_Msk = 0xffff

	// SA3B: Specific Address 3 Bottom Register
	// Position of ADDR field.
	EMAC_SA3B_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA3B_ADDR_Msk = 0xffffffff

	// SA3T: Specific Address 3 Top Register
	// Position of ADDR field.
	EMAC_SA3T_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA3T_ADDR_Msk = 0xffff

	// SA4B: Specific Address 4 Bottom Register
	// Position of ADDR field.
	EMAC_SA4B_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA4B_ADDR_Msk = 0xffffffff

	// SA4T: Specific Address 4 Top Register
	// Position of ADDR field.
	EMAC_SA4T_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	EMAC_SA4T_ADDR_Msk = 0xffff

	// TID: Type ID Checking Register
	// Position of TID field.
	EMAC_TID_TID_Pos = 0x0
	// Bit mask of TID field.
	EMAC_TID_TID_Msk = 0xffff

	// USRIO: User Input/Output Register
	// Position of RMII field.
	EMAC_USRIO_RMII_Pos = 0x0
	// Bit mask of RMII field.
	EMAC_USRIO_RMII_Msk = 0x1
	// Bit RMII.
	EMAC_USRIO_RMII = 0x1
	// Position of CLKEN field.
	EMAC_USRIO_CLKEN_Pos = 0x1
	// Bit mask of CLKEN field.
	EMAC_USRIO_CLKEN_Msk = 0x2
	// Bit CLKEN.
	EMAC_USRIO_CLKEN = 0x2

	// WOL: Wake on LAN Register
	// Position of IP field.
	EMAC_WOL_IP_Pos = 0x0
	// Bit mask of IP field.
	EMAC_WOL_IP_Msk = 0xffff
	// Position of MAG field.
	EMAC_WOL_MAG_Pos = 0x10
	// Bit mask of MAG field.
	EMAC_WOL_MAG_Msk = 0x10000
	// Bit MAG.
	EMAC_WOL_MAG = 0x10000
	// Position of ARP field.
	EMAC_WOL_ARP_Pos = 0x11
	// Bit mask of ARP field.
	EMAC_WOL_ARP_Msk = 0x20000
	// Bit ARP.
	EMAC_WOL_ARP = 0x20000
	// Position of SA1 field.
	EMAC_WOL_SA1_Pos = 0x12
	// Bit mask of SA1 field.
	EMAC_WOL_SA1_Msk = 0x40000
	// Bit SA1.
	EMAC_WOL_SA1 = 0x40000
	// Position of MTI field.
	EMAC_WOL_MTI_Pos = 0x13
	// Bit mask of MTI field.
	EMAC_WOL_MTI_Msk = 0x80000
	// Bit MTI.
	EMAC_WOL_MTI = 0x80000
)

// Constants for UDPHS: USB High Speed Device Port
const (
	// CTRL: UDPHS Control Register
	// Position of DEV_ADDR field.
	UDPHS_CTRL_DEV_ADDR_Pos = 0x0
	// Bit mask of DEV_ADDR field.
	UDPHS_CTRL_DEV_ADDR_Msk = 0x7f
	// Position of FADDR_EN field.
	UDPHS_CTRL_FADDR_EN_Pos = 0x7
	// Bit mask of FADDR_EN field.
	UDPHS_CTRL_FADDR_EN_Msk = 0x80
	// Bit FADDR_EN.
	UDPHS_CTRL_FADDR_EN = 0x80
	// Position of EN_UDPHS field.
	UDPHS_CTRL_EN_UDPHS_Pos = 0x8
	// Bit mask of EN_UDPHS field.
	UDPHS_CTRL_EN_UDPHS_Msk = 0x100
	// Bit EN_UDPHS.
	UDPHS_CTRL_EN_UDPHS = 0x100
	// Position of DETACH field.
	UDPHS_CTRL_DETACH_Pos = 0x9
	// Bit mask of DETACH field.
	UDPHS_CTRL_DETACH_Msk = 0x200
	// Bit DETACH.
	UDPHS_CTRL_DETACH = 0x200
	// Position of REWAKEUP field.
	UDPHS_CTRL_REWAKEUP_Pos = 0xa
	// Bit mask of REWAKEUP field.
	UDPHS_CTRL_REWAKEUP_Msk = 0x400
	// Bit REWAKEUP.
	UDPHS_CTRL_REWAKEUP = 0x400
	// Position of PULLD_DIS field.
	UDPHS_CTRL_PULLD_DIS_Pos = 0xb
	// Bit mask of PULLD_DIS field.
	UDPHS_CTRL_PULLD_DIS_Msk = 0x800
	// Bit PULLD_DIS.
	UDPHS_CTRL_PULLD_DIS = 0x800

	// FNUM: UDPHS Frame Number Register
	// Position of MICRO_FRAME_NUM field.
	UDPHS_FNUM_MICRO_FRAME_NUM_Pos = 0x0
	// Bit mask of MICRO_FRAME_NUM field.
	UDPHS_FNUM_MICRO_FRAME_NUM_Msk = 0x7
	// Position of FRAME_NUMBER field.
	UDPHS_FNUM_FRAME_NUMBER_Pos = 0x3
	// Bit mask of FRAME_NUMBER field.
	UDPHS_FNUM_FRAME_NUMBER_Msk = 0x3ff8
	// Position of FNUM_ERR field.
	UDPHS_FNUM_FNUM_ERR_Pos = 0x1f
	// Bit mask of FNUM_ERR field.
	UDPHS_FNUM_FNUM_ERR_Msk = 0x80000000
	// Bit FNUM_ERR.
	UDPHS_FNUM_FNUM_ERR = 0x80000000

	// IEN: UDPHS Interrupt Enable Register
	// Position of DET_SUSPD field.
	UDPHS_IEN_DET_SUSPD_Pos = 0x1
	// Bit mask of DET_SUSPD field.
	UDPHS_IEN_DET_SUSPD_Msk = 0x2
	// Bit DET_SUSPD.
	UDPHS_IEN_DET_SUSPD = 0x2
	// Position of MICRO_SOF field.
	UDPHS_IEN_MICRO_SOF_Pos = 0x2
	// Bit mask of MICRO_SOF field.
	UDPHS_IEN_MICRO_SOF_Msk = 0x4
	// Bit MICRO_SOF.
	UDPHS_IEN_MICRO_SOF = 0x4
	// Position of INT_SOF field.
	UDPHS_IEN_INT_SOF_Pos = 0x3
	// Bit mask of INT_SOF field.
	UDPHS_IEN_INT_SOF_Msk = 0x8
	// Bit INT_SOF.
	UDPHS_IEN_INT_SOF = 0x8
	// Position of ENDRESET field.
	UDPHS_IEN_ENDRESET_Pos = 0x4
	// Bit mask of ENDRESET field.
	UDPHS_IEN_ENDRESET_Msk = 0x10
	// Bit ENDRESET.
	UDPHS_IEN_ENDRESET = 0x10
	// Position of WAKE_UP field.
	UDPHS_IEN_WAKE_UP_Pos = 0x5
	// Bit mask of WAKE_UP field.
	UDPHS_IEN_WAKE_UP_Msk = 0x20
	// Bit WAKE_UP.
	UDPHS_IEN_WAKE_UP = 0x20
	// Position of ENDOFRSM field.
	UDPHS_IEN_ENDOFRSM_Pos = 0x6
	// Bit mask of ENDOFRSM field.
	UDPHS_IEN_ENDOFRSM_Msk = 0x40
	// Bit ENDOFRSM.
	UDPHS_IEN_ENDOFRSM = 0x40
	// Position of UPSTR_RES field.
	UDPHS_IEN_UPSTR_RES_Pos = 0x7
	// Bit mask of UPSTR_RES field.
	UDPHS_IEN_UPSTR_RES_Msk = 0x80
	// Bit UPSTR_RES.
	UDPHS_IEN_UPSTR_RES = 0x80
	// Position of EPT_0 field.
	UDPHS_IEN_EPT_0_Pos = 0x8
	// Bit mask of EPT_0 field.
	UDPHS_IEN_EPT_0_Msk = 0x100
	// Bit EPT_0.
	UDPHS_IEN_EPT_0 = 0x100
	// Position of EPT_1 field.
	UDPHS_IEN_EPT_1_Pos = 0x9
	// Bit mask of EPT_1 field.
	UDPHS_IEN_EPT_1_Msk = 0x200
	// Bit EPT_1.
	UDPHS_IEN_EPT_1 = 0x200
	// Position of EPT_2 field.
	UDPHS_IEN_EPT_2_Pos = 0xa
	// Bit mask of EPT_2 field.
	UDPHS_IEN_EPT_2_Msk = 0x400
	// Bit EPT_2.
	UDPHS_IEN_EPT_2 = 0x400
	// Position of EPT_3 field.
	UDPHS_IEN_EPT_3_Pos = 0xb
	// Bit mask of EPT_3 field.
	UDPHS_IEN_EPT_3_Msk = 0x800
	// Bit EPT_3.
	UDPHS_IEN_EPT_3 = 0x800
	// Position of EPT_4 field.
	UDPHS_IEN_EPT_4_Pos = 0xc
	// Bit mask of EPT_4 field.
	UDPHS_IEN_EPT_4_Msk = 0x1000
	// Bit EPT_4.
	UDPHS_IEN_EPT_4 = 0x1000
	// Position of EPT_5 field.
	UDPHS_IEN_EPT_5_Pos = 0xd
	// Bit mask of EPT_5 field.
	UDPHS_IEN_EPT_5_Msk = 0x2000
	// Bit EPT_5.
	UDPHS_IEN_EPT_5 = 0x2000
	// Position of EPT_6 field.
	UDPHS_IEN_EPT_6_Pos = 0xe
	// Bit mask of EPT_6 field.
	UDPHS_IEN_EPT_6_Msk = 0x4000
	// Bit EPT_6.
	UDPHS_IEN_EPT_6 = 0x4000
	// Position of EPT_7 field.
	UDPHS_IEN_EPT_7_Pos = 0xf
	// Bit mask of EPT_7 field.
	UDPHS_IEN_EPT_7_Msk = 0x8000
	// Bit EPT_7.
	UDPHS_IEN_EPT_7 = 0x8000
	// Position of EPT_8 field.
	UDPHS_IEN_EPT_8_Pos = 0x10
	// Bit mask of EPT_8 field.
	UDPHS_IEN_EPT_8_Msk = 0x10000
	// Bit EPT_8.
	UDPHS_IEN_EPT_8 = 0x10000
	// Position of EPT_9 field.
	UDPHS_IEN_EPT_9_Pos = 0x11
	// Bit mask of EPT_9 field.
	UDPHS_IEN_EPT_9_Msk = 0x20000
	// Bit EPT_9.
	UDPHS_IEN_EPT_9 = 0x20000
	// Position of EPT_10 field.
	UDPHS_IEN_EPT_10_Pos = 0x12
	// Bit mask of EPT_10 field.
	UDPHS_IEN_EPT_10_Msk = 0x40000
	// Bit EPT_10.
	UDPHS_IEN_EPT_10 = 0x40000
	// Position of EPT_11 field.
	UDPHS_IEN_EPT_11_Pos = 0x13
	// Bit mask of EPT_11 field.
	UDPHS_IEN_EPT_11_Msk = 0x80000
	// Bit EPT_11.
	UDPHS_IEN_EPT_11 = 0x80000
	// Position of EPT_12 field.
	UDPHS_IEN_EPT_12_Pos = 0x14
	// Bit mask of EPT_12 field.
	UDPHS_IEN_EPT_12_Msk = 0x100000
	// Bit EPT_12.
	UDPHS_IEN_EPT_12 = 0x100000
	// Position of EPT_13 field.
	UDPHS_IEN_EPT_13_Pos = 0x15
	// Bit mask of EPT_13 field.
	UDPHS_IEN_EPT_13_Msk = 0x200000
	// Bit EPT_13.
	UDPHS_IEN_EPT_13 = 0x200000
	// Position of EPT_14 field.
	UDPHS_IEN_EPT_14_Pos = 0x16
	// Bit mask of EPT_14 field.
	UDPHS_IEN_EPT_14_Msk = 0x400000
	// Bit EPT_14.
	UDPHS_IEN_EPT_14 = 0x400000
	// Position of EPT_15 field.
	UDPHS_IEN_EPT_15_Pos = 0x17
	// Bit mask of EPT_15 field.
	UDPHS_IEN_EPT_15_Msk = 0x800000
	// Bit EPT_15.
	UDPHS_IEN_EPT_15 = 0x800000
	// Position of DMA_1 field.
	UDPHS_IEN_DMA_1_Pos = 0x19
	// Bit mask of DMA_1 field.
	UDPHS_IEN_DMA_1_Msk = 0x2000000
	// Bit DMA_1.
	UDPHS_IEN_DMA_1 = 0x2000000
	// Position of DMA_2 field.
	UDPHS_IEN_DMA_2_Pos = 0x1a
	// Bit mask of DMA_2 field.
	UDPHS_IEN_DMA_2_Msk = 0x4000000
	// Bit DMA_2.
	UDPHS_IEN_DMA_2 = 0x4000000
	// Position of DMA_3 field.
	UDPHS_IEN_DMA_3_Pos = 0x1b
	// Bit mask of DMA_3 field.
	UDPHS_IEN_DMA_3_Msk = 0x8000000
	// Bit DMA_3.
	UDPHS_IEN_DMA_3 = 0x8000000
	// Position of DMA_4 field.
	UDPHS_IEN_DMA_4_Pos = 0x1c
	// Bit mask of DMA_4 field.
	UDPHS_IEN_DMA_4_Msk = 0x10000000
	// Bit DMA_4.
	UDPHS_IEN_DMA_4 = 0x10000000
	// Position of DMA_5 field.
	UDPHS_IEN_DMA_5_Pos = 0x1d
	// Bit mask of DMA_5 field.
	UDPHS_IEN_DMA_5_Msk = 0x20000000
	// Bit DMA_5.
	UDPHS_IEN_DMA_5 = 0x20000000
	// Position of DMA_6 field.
	UDPHS_IEN_DMA_6_Pos = 0x1e
	// Bit mask of DMA_6 field.
	UDPHS_IEN_DMA_6_Msk = 0x40000000
	// Bit DMA_6.
	UDPHS_IEN_DMA_6 = 0x40000000
	// Position of DMA_7 field.
	UDPHS_IEN_DMA_7_Pos = 0x1f
	// Bit mask of DMA_7 field.
	UDPHS_IEN_DMA_7_Msk = 0x80000000
	// Bit DMA_7.
	UDPHS_IEN_DMA_7 = 0x80000000

	// INTSTA: UDPHS Interrupt Status Register
	// Position of SPEED field.
	UDPHS_INTSTA_SPEED_Pos = 0x0
	// Bit mask of SPEED field.
	UDPHS_INTSTA_SPEED_Msk = 0x1
	// Bit SPEED.
	UDPHS_INTSTA_SPEED = 0x1
	// Position of DET_SUSPD field.
	UDPHS_INTSTA_DET_SUSPD_Pos = 0x1
	// Bit mask of DET_SUSPD field.
	UDPHS_INTSTA_DET_SUSPD_Msk = 0x2
	// Bit DET_SUSPD.
	UDPHS_INTSTA_DET_SUSPD = 0x2
	// Position of MICRO_SOF field.
	UDPHS_INTSTA_MICRO_SOF_Pos = 0x2
	// Bit mask of MICRO_SOF field.
	UDPHS_INTSTA_MICRO_SOF_Msk = 0x4
	// Bit MICRO_SOF.
	UDPHS_INTSTA_MICRO_SOF = 0x4
	// Position of INT_SOF field.
	UDPHS_INTSTA_INT_SOF_Pos = 0x3
	// Bit mask of INT_SOF field.
	UDPHS_INTSTA_INT_SOF_Msk = 0x8
	// Bit INT_SOF.
	UDPHS_INTSTA_INT_SOF = 0x8
	// Position of ENDRESET field.
	UDPHS_INTSTA_ENDRESET_Pos = 0x4
	// Bit mask of ENDRESET field.
	UDPHS_INTSTA_ENDRESET_Msk = 0x10
	// Bit ENDRESET.
	UDPHS_INTSTA_ENDRESET = 0x10
	// Position of WAKE_UP field.
	UDPHS_INTSTA_WAKE_UP_Pos = 0x5
	// Bit mask of WAKE_UP field.
	UDPHS_INTSTA_WAKE_UP_Msk = 0x20
	// Bit WAKE_UP.
	UDPHS_INTSTA_WAKE_UP = 0x20
	// Position of ENDOFRSM field.
	UDPHS_INTSTA_ENDOFRSM_Pos = 0x6
	// Bit mask of ENDOFRSM field.
	UDPHS_INTSTA_ENDOFRSM_Msk = 0x40
	// Bit ENDOFRSM.
	UDPHS_INTSTA_ENDOFRSM = 0x40
	// Position of UPSTR_RES field.
	UDPHS_INTSTA_UPSTR_RES_Pos = 0x7
	// Bit mask of UPSTR_RES field.
	UDPHS_INTSTA_UPSTR_RES_Msk = 0x80
	// Bit UPSTR_RES.
	UDPHS_INTSTA_UPSTR_RES = 0x80
	// Position of EPT_0 field.
	UDPHS_INTSTA_EPT_0_Pos = 0x8
	// Bit mask of EPT_0 field.
	UDPHS_INTSTA_EPT_0_Msk = 0x100
	// Bit EPT_0.
	UDPHS_INTSTA_EPT_0 = 0x100
	// Position of EPT_1 field.
	UDPHS_INTSTA_EPT_1_Pos = 0x9
	// Bit mask of EPT_1 field.
	UDPHS_INTSTA_EPT_1_Msk = 0x200
	// Bit EPT_1.
	UDPHS_INTSTA_EPT_1 = 0x200
	// Position of EPT_2 field.
	UDPHS_INTSTA_EPT_2_Pos = 0xa
	// Bit mask of EPT_2 field.
	UDPHS_INTSTA_EPT_2_Msk = 0x400
	// Bit EPT_2.
	UDPHS_INTSTA_EPT_2 = 0x400
	// Position of EPT_3 field.
	UDPHS_INTSTA_EPT_3_Pos = 0xb
	// Bit mask of EPT_3 field.
	UDPHS_INTSTA_EPT_3_Msk = 0x800
	// Bit EPT_3.
	UDPHS_INTSTA_EPT_3 = 0x800
	// Position of EPT_4 field.
	UDPHS_INTSTA_EPT_4_Pos = 0xc
	// Bit mask of EPT_4 field.
	UDPHS_INTSTA_EPT_4_Msk = 0x1000
	// Bit EPT_4.
	UDPHS_INTSTA_EPT_4 = 0x1000
	// Position of EPT_5 field.
	UDPHS_INTSTA_EPT_5_Pos = 0xd
	// Bit mask of EPT_5 field.
	UDPHS_INTSTA_EPT_5_Msk = 0x2000
	// Bit EPT_5.
	UDPHS_INTSTA_EPT_5 = 0x2000
	// Position of EPT_6 field.
	UDPHS_INTSTA_EPT_6_Pos = 0xe
	// Bit mask of EPT_6 field.
	UDPHS_INTSTA_EPT_6_Msk = 0x4000
	// Bit EPT_6.
	UDPHS_INTSTA_EPT_6 = 0x4000
	// Position of EPT_7 field.
	UDPHS_INTSTA_EPT_7_Pos = 0xf
	// Bit mask of EPT_7 field.
	UDPHS_INTSTA_EPT_7_Msk = 0x8000
	// Bit EPT_7.
	UDPHS_INTSTA_EPT_7 = 0x8000
	// Position of EPT_8 field.
	UDPHS_INTSTA_EPT_8_Pos = 0x10
	// Bit mask of EPT_8 field.
	UDPHS_INTSTA_EPT_8_Msk = 0x10000
	// Bit EPT_8.
	UDPHS_INTSTA_EPT_8 = 0x10000
	// Position of EPT_9 field.
	UDPHS_INTSTA_EPT_9_Pos = 0x11
	// Bit mask of EPT_9 field.
	UDPHS_INTSTA_EPT_9_Msk = 0x20000
	// Bit EPT_9.
	UDPHS_INTSTA_EPT_9 = 0x20000
	// Position of EPT_10 field.
	UDPHS_INTSTA_EPT_10_Pos = 0x12
	// Bit mask of EPT_10 field.
	UDPHS_INTSTA_EPT_10_Msk = 0x40000
	// Bit EPT_10.
	UDPHS_INTSTA_EPT_10 = 0x40000
	// Position of EPT_11 field.
	UDPHS_INTSTA_EPT_11_Pos = 0x13
	// Bit mask of EPT_11 field.
	UDPHS_INTSTA_EPT_11_Msk = 0x80000
	// Bit EPT_11.
	UDPHS_INTSTA_EPT_11 = 0x80000
	// Position of EPT_12 field.
	UDPHS_INTSTA_EPT_12_Pos = 0x14
	// Bit mask of EPT_12 field.
	UDPHS_INTSTA_EPT_12_Msk = 0x100000
	// Bit EPT_12.
	UDPHS_INTSTA_EPT_12 = 0x100000
	// Position of EPT_13 field.
	UDPHS_INTSTA_EPT_13_Pos = 0x15
	// Bit mask of EPT_13 field.
	UDPHS_INTSTA_EPT_13_Msk = 0x200000
	// Bit EPT_13.
	UDPHS_INTSTA_EPT_13 = 0x200000
	// Position of EPT_14 field.
	UDPHS_INTSTA_EPT_14_Pos = 0x16
	// Bit mask of EPT_14 field.
	UDPHS_INTSTA_EPT_14_Msk = 0x400000
	// Bit EPT_14.
	UDPHS_INTSTA_EPT_14 = 0x400000
	// Position of EPT_15 field.
	UDPHS_INTSTA_EPT_15_Pos = 0x17
	// Bit mask of EPT_15 field.
	UDPHS_INTSTA_EPT_15_Msk = 0x800000
	// Bit EPT_15.
	UDPHS_INTSTA_EPT_15 = 0x800000
	// Position of DMA_1 field.
	UDPHS_INTSTA_DMA_1_Pos = 0x19
	// Bit mask of DMA_1 field.
	UDPHS_INTSTA_DMA_1_Msk = 0x2000000
	// Bit DMA_1.
	UDPHS_INTSTA_DMA_1 = 0x2000000
	// Position of DMA_2 field.
	UDPHS_INTSTA_DMA_2_Pos = 0x1a
	// Bit mask of DMA_2 field.
	UDPHS_INTSTA_DMA_2_Msk = 0x4000000
	// Bit DMA_2.
	UDPHS_INTSTA_DMA_2 = 0x4000000
	// Position of DMA_3 field.
	UDPHS_INTSTA_DMA_3_Pos = 0x1b
	// Bit mask of DMA_3 field.
	UDPHS_INTSTA_DMA_3_Msk = 0x8000000
	// Bit DMA_3.
	UDPHS_INTSTA_DMA_3 = 0x8000000
	// Position of DMA_4 field.
	UDPHS_INTSTA_DMA_4_Pos = 0x1c
	// Bit mask of DMA_4 field.
	UDPHS_INTSTA_DMA_4_Msk = 0x10000000
	// Bit DMA_4.
	UDPHS_INTSTA_DMA_4 = 0x10000000
	// Position of DMA_5 field.
	UDPHS_INTSTA_DMA_5_Pos = 0x1d
	// Bit mask of DMA_5 field.
	UDPHS_INTSTA_DMA_5_Msk = 0x20000000
	// Bit DMA_5.
	UDPHS_INTSTA_DMA_5 = 0x20000000
	// Position of DMA_6 field.
	UDPHS_INTSTA_DMA_6_Pos = 0x1e
	// Bit mask of DMA_6 field.
	UDPHS_INTSTA_DMA_6_Msk = 0x40000000
	// Bit DMA_6.
	UDPHS_INTSTA_DMA_6 = 0x40000000
	// Position of DMA_7 field.
	UDPHS_INTSTA_DMA_7_Pos = 0x1f
	// Bit mask of DMA_7 field.
	UDPHS_INTSTA_DMA_7_Msk = 0x80000000
	// Bit DMA_7.
	UDPHS_INTSTA_DMA_7 = 0x80000000

	// CLRINT: UDPHS Clear Interrupt Register
	// Position of DET_SUSPD field.
	UDPHS_CLRINT_DET_SUSPD_Pos = 0x1
	// Bit mask of DET_SUSPD field.
	UDPHS_CLRINT_DET_SUSPD_Msk = 0x2
	// Bit DET_SUSPD.
	UDPHS_CLRINT_DET_SUSPD = 0x2
	// Position of MICRO_SOF field.
	UDPHS_CLRINT_MICRO_SOF_Pos = 0x2
	// Bit mask of MICRO_SOF field.
	UDPHS_CLRINT_MICRO_SOF_Msk = 0x4
	// Bit MICRO_SOF.
	UDPHS_CLRINT_MICRO_SOF = 0x4
	// Position of INT_SOF field.
	UDPHS_CLRINT_INT_SOF_Pos = 0x3
	// Bit mask of INT_SOF field.
	UDPHS_CLRINT_INT_SOF_Msk = 0x8
	// Bit INT_SOF.
	UDPHS_CLRINT_INT_SOF = 0x8
	// Position of ENDRESET field.
	UDPHS_CLRINT_ENDRESET_Pos = 0x4
	// Bit mask of ENDRESET field.
	UDPHS_CLRINT_ENDRESET_Msk = 0x10
	// Bit ENDRESET.
	UDPHS_CLRINT_ENDRESET = 0x10
	// Position of WAKE_UP field.
	UDPHS_CLRINT_WAKE_UP_Pos = 0x5
	// Bit mask of WAKE_UP field.
	UDPHS_CLRINT_WAKE_UP_Msk = 0x20
	// Bit WAKE_UP.
	UDPHS_CLRINT_WAKE_UP = 0x20
	// Position of ENDOFRSM field.
	UDPHS_CLRINT_ENDOFRSM_Pos = 0x6
	// Bit mask of ENDOFRSM field.
	UDPHS_CLRINT_ENDOFRSM_Msk = 0x40
	// Bit ENDOFRSM.
	UDPHS_CLRINT_ENDOFRSM = 0x40
	// Position of UPSTR_RES field.
	UDPHS_CLRINT_UPSTR_RES_Pos = 0x7
	// Bit mask of UPSTR_RES field.
	UDPHS_CLRINT_UPSTR_RES_Msk = 0x80
	// Bit UPSTR_RES.
	UDPHS_CLRINT_UPSTR_RES = 0x80

	// EPTRST: UDPHS Endpoints Reset Register
	// Position of EPT_0 field.
	UDPHS_EPTRST_EPT_0_Pos = 0x0
	// Bit mask of EPT_0 field.
	UDPHS_EPTRST_EPT_0_Msk = 0x1
	// Bit EPT_0.
	UDPHS_EPTRST_EPT_0 = 0x1
	// Position of EPT_1 field.
	UDPHS_EPTRST_EPT_1_Pos = 0x1
	// Bit mask of EPT_1 field.
	UDPHS_EPTRST_EPT_1_Msk = 0x2
	// Bit EPT_1.
	UDPHS_EPTRST_EPT_1 = 0x2
	// Position of EPT_2 field.
	UDPHS_EPTRST_EPT_2_Pos = 0x2
	// Bit mask of EPT_2 field.
	UDPHS_EPTRST_EPT_2_Msk = 0x4
	// Bit EPT_2.
	UDPHS_EPTRST_EPT_2 = 0x4
	// Position of EPT_3 field.
	UDPHS_EPTRST_EPT_3_Pos = 0x3
	// Bit mask of EPT_3 field.
	UDPHS_EPTRST_EPT_3_Msk = 0x8
	// Bit EPT_3.
	UDPHS_EPTRST_EPT_3 = 0x8
	// Position of EPT_4 field.
	UDPHS_EPTRST_EPT_4_Pos = 0x4
	// Bit mask of EPT_4 field.
	UDPHS_EPTRST_EPT_4_Msk = 0x10
	// Bit EPT_4.
	UDPHS_EPTRST_EPT_4 = 0x10
	// Position of EPT_5 field.
	UDPHS_EPTRST_EPT_5_Pos = 0x5
	// Bit mask of EPT_5 field.
	UDPHS_EPTRST_EPT_5_Msk = 0x20
	// Bit EPT_5.
	UDPHS_EPTRST_EPT_5 = 0x20
	// Position of EPT_6 field.
	UDPHS_EPTRST_EPT_6_Pos = 0x6
	// Bit mask of EPT_6 field.
	UDPHS_EPTRST_EPT_6_Msk = 0x40
	// Bit EPT_6.
	UDPHS_EPTRST_EPT_6 = 0x40
	// Position of EPT_7 field.
	UDPHS_EPTRST_EPT_7_Pos = 0x7
	// Bit mask of EPT_7 field.
	UDPHS_EPTRST_EPT_7_Msk = 0x80
	// Bit EPT_7.
	UDPHS_EPTRST_EPT_7 = 0x80
	// Position of EPT_8 field.
	UDPHS_EPTRST_EPT_8_Pos = 0x8
	// Bit mask of EPT_8 field.
	UDPHS_EPTRST_EPT_8_Msk = 0x100
	// Bit EPT_8.
	UDPHS_EPTRST_EPT_8 = 0x100
	// Position of EPT_9 field.
	UDPHS_EPTRST_EPT_9_Pos = 0x9
	// Bit mask of EPT_9 field.
	UDPHS_EPTRST_EPT_9_Msk = 0x200
	// Bit EPT_9.
	UDPHS_EPTRST_EPT_9 = 0x200
	// Position of EPT_10 field.
	UDPHS_EPTRST_EPT_10_Pos = 0xa
	// Bit mask of EPT_10 field.
	UDPHS_EPTRST_EPT_10_Msk = 0x400
	// Bit EPT_10.
	UDPHS_EPTRST_EPT_10 = 0x400
	// Position of EPT_11 field.
	UDPHS_EPTRST_EPT_11_Pos = 0xb
	// Bit mask of EPT_11 field.
	UDPHS_EPTRST_EPT_11_Msk = 0x800
	// Bit EPT_11.
	UDPHS_EPTRST_EPT_11 = 0x800
	// Position of EPT_12 field.
	UDPHS_EPTRST_EPT_12_Pos = 0xc
	// Bit mask of EPT_12 field.
	UDPHS_EPTRST_EPT_12_Msk = 0x1000
	// Bit EPT_12.
	UDPHS_EPTRST_EPT_12 = 0x1000
	// Position of EPT_13 field.
	UDPHS_EPTRST_EPT_13_Pos = 0xd
	// Bit mask of EPT_13 field.
	UDPHS_EPTRST_EPT_13_Msk = 0x2000
	// Bit EPT_13.
	UDPHS_EPTRST_EPT_13 = 0x2000
	// Position of EPT_14 field.
	UDPHS_EPTRST_EPT_14_Pos = 0xe
	// Bit mask of EPT_14 field.
	UDPHS_EPTRST_EPT_14_Msk = 0x4000
	// Bit EPT_14.
	UDPHS_EPTRST_EPT_14 = 0x4000
	// Position of EPT_15 field.
	UDPHS_EPTRST_EPT_15_Pos = 0xf
	// Bit mask of EPT_15 field.
	UDPHS_EPTRST_EPT_15_Msk = 0x8000
	// Bit EPT_15.
	UDPHS_EPTRST_EPT_15 = 0x8000

	// TST: UDPHS Test Register
	// Position of SPEED_CFG field.
	UDPHS_TST_SPEED_CFG_Pos = 0x0
	// Bit mask of SPEED_CFG field.
	UDPHS_TST_SPEED_CFG_Msk = 0x3
	// Normal Mode: The macro is in Full Speed mode, ready to make a High Speed identification, if the host supports it and then to automatically switch to High Speed mode
	UDPHS_TST_SPEED_CFG_NORMAL = 0x0
	// Force High Speed: Set this value to force the hardware to work in High Speed mode. Only for debug or test purpose.
	UDPHS_TST_SPEED_CFG_HIGH_SPEED = 0x2
	// Force Full Speed: Set this value to force the hardware to work only in Full Speed mode. In this configuration, the macro will not respond to a High Speed reset handshake.
	UDPHS_TST_SPEED_CFG_FULL_SPEED = 0x3
	// Position of TST_J field.
	UDPHS_TST_TST_J_Pos = 0x2
	// Bit mask of TST_J field.
	UDPHS_TST_TST_J_Msk = 0x4
	// Bit TST_J.
	UDPHS_TST_TST_J = 0x4
	// Position of TST_K field.
	UDPHS_TST_TST_K_Pos = 0x3
	// Bit mask of TST_K field.
	UDPHS_TST_TST_K_Msk = 0x8
	// Bit TST_K.
	UDPHS_TST_TST_K = 0x8
	// Position of TST_PKT field.
	UDPHS_TST_TST_PKT_Pos = 0x4
	// Bit mask of TST_PKT field.
	UDPHS_TST_TST_PKT_Msk = 0x10
	// Bit TST_PKT.
	UDPHS_TST_TST_PKT = 0x10
	// Position of OPMODE2 field.
	UDPHS_TST_OPMODE2_Pos = 0x5
	// Bit mask of OPMODE2 field.
	UDPHS_TST_OPMODE2_Msk = 0x20
	// Bit OPMODE2.
	UDPHS_TST_OPMODE2 = 0x20

	// EPTCFG0: UDPHS Endpoint Configuration Register (endpoint = 0)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG0_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG0_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG0_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG0_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG0_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG0_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG0_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG0_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG0_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG0_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG0_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG0_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG0_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG0_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG0_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG0_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG0_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG0_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG0_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG0_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG0_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG0_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG0_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG0_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG0_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG0_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG0_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG0_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG0_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG0_EPT_MAPD = 0x80000000

	// EPTCTLENB0: UDPHS Endpoint Control Enable Register (endpoint = 0)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB0_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB0_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB0_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB0_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB0_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB0_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB0_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB0_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB0_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB0_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB0_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB0_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB0_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB0_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB0_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB0_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB0_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB0_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB0_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB0_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB0_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB0_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB0_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB0_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB0_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB0_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB0_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB0_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB0_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB0_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB0_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB0_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB0_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB0_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB0_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB0_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB0_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB0_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB0_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB0_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB0_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB0_SHRT_PCKT = 0x80000000

	// EPTCTLENB0_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 0)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB0_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB0_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB0_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB0_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB0_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB0_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB0_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB0_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB0_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB0_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB0_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB0_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB0_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB0_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB0_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB0_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB0_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB0_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB0_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB0_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB0_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB0_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB0_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB0_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB0_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB0_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB0_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB0_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB0_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB0_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB0_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS0: UDPHS Endpoint Control Disable Register (endpoint = 0)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS0_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS0_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS0_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS0_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS0_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS0_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS0_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS0_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS0_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS0_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS0_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS0_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS0_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS0_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS0_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS0_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS0_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS0_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS0_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS0_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS0_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS0_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS0_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS0_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS0_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS0_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS0_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS0_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS0_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS0_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS0_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS0_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS0_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS0_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS0_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS0_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS0_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS0_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS0_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS0_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS0_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS0_SHRT_PCKT = 0x80000000

	// EPTCTLDIS0_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 0)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS0_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS0_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS0_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS0_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS0_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS0_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS0_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS0_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS0_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS0_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS0_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS0_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS0_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS0_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS0_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS0_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS0_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS0_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS0_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS0_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS0_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS0_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS0_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS0_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS0_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS0_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS0_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS0_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS0_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS0_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS0_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL0: UDPHS Endpoint Control Register (endpoint = 0)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL0_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL0_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL0_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL0_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL0_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL0_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL0_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL0_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL0_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL0_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL0_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL0_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL0_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL0_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL0_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL0_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL0_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL0_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL0_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL0_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL0_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL0_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL0_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL0_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL0_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL0_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL0_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL0_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL0_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL0_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL0_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL0_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL0_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL0_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL0_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL0_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL0_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL0_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL0_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL0_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL0_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL0_SHRT_PCKT = 0x80000000

	// EPTCTL0_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 0)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL0_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL0_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL0_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL0_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL0_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL0_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL0_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL0_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL0_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL0_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL0_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL0_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL0_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL0_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL0_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL0_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL0_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL0_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL0_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL0_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL0_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL0_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL0_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL0_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL0_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL0_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL0_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL0_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL0_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL0_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL0_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL0_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL0_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL0_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL0_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA0: UDPHS Endpoint Set Status Register (endpoint = 0)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA0_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA0_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA0_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA0_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA0_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA0_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA0_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA0_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA0_TXRDY = 0x800

	// EPTSETSTA0_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 0)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA0_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA0_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA0_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA0_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA0_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA0_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA0: UDPHS Endpoint Clear Status Register (endpoint = 0)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA0_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA0_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA0_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA0_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA0_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA0_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA0_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA0_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA0_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA0_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA0_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA0_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA0_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA0_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA0_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA0_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA0_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA0_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA0_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA0_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA0_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA0_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA0_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA0_NAK_OUT = 0x8000

	// EPTCLRSTA0_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 0)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA0_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA0_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA0_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA0_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA0_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA0_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA0_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA0_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA0_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA0_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA0: UDPHS Endpoint Status Register (endpoint = 0)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA0_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA0_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA0_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA0_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA0_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA0_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA0_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA0_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA0_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA0_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA0_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA0_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA0_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA0_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA0_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA0_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA0_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA0_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA0_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA0_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA0_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA0_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA0_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA0_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA0_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA0_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA0_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA0_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA0_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA0_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA0_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA0_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA0_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA0_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA0_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA0_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA0_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA0_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA0_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA0_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA0_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA0_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA0_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA0_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA0_SHRT_PCKT = 0x80000000

	// EPTSTA0_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 0)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA0_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA0_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA0_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA0_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA0_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA0_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA0_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA0_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA0_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA0_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA0_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA0_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA0_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA0_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA0_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA0_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA0_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA0_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA0_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA0_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA0_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA0_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA0_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA0_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA0_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA0_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA0_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA0_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA0_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA0_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA0_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA0_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA0_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA0_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA0_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG1: UDPHS Endpoint Configuration Register (endpoint = 1)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG1_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG1_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG1_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG1_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG1_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG1_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG1_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG1_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG1_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG1_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG1_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG1_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG1_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG1_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG1_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG1_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG1_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG1_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG1_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG1_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG1_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG1_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG1_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG1_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG1_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG1_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG1_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG1_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG1_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG1_EPT_MAPD = 0x80000000

	// EPTCTLENB1: UDPHS Endpoint Control Enable Register (endpoint = 1)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB1_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB1_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB1_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB1_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB1_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB1_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB1_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB1_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB1_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB1_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB1_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB1_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB1_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB1_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB1_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB1_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB1_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB1_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB1_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB1_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB1_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB1_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB1_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB1_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB1_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB1_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB1_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB1_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB1_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB1_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB1_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB1_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB1_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB1_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB1_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB1_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB1_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB1_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB1_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB1_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB1_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB1_SHRT_PCKT = 0x80000000

	// EPTCTLENB1_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 1)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB1_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB1_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB1_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB1_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB1_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB1_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB1_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB1_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB1_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB1_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB1_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB1_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB1_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB1_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB1_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB1_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB1_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB1_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB1_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB1_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB1_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB1_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB1_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB1_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB1_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB1_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB1_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB1_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB1_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB1_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB1_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS1: UDPHS Endpoint Control Disable Register (endpoint = 1)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS1_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS1_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS1_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS1_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS1_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS1_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS1_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS1_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS1_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS1_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS1_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS1_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS1_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS1_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS1_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS1_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS1_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS1_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS1_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS1_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS1_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS1_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS1_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS1_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS1_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS1_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS1_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS1_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS1_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS1_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS1_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS1_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS1_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS1_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS1_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS1_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS1_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS1_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS1_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS1_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS1_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS1_SHRT_PCKT = 0x80000000

	// EPTCTLDIS1_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 1)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS1_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS1_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS1_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS1_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS1_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS1_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS1_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS1_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS1_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS1_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS1_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS1_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS1_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS1_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS1_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS1_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS1_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS1_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS1_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS1_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS1_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS1_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS1_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS1_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS1_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS1_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS1_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS1_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS1_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS1_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS1_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL1: UDPHS Endpoint Control Register (endpoint = 1)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL1_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL1_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL1_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL1_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL1_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL1_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL1_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL1_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL1_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL1_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL1_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL1_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL1_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL1_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL1_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL1_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL1_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL1_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL1_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL1_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL1_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL1_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL1_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL1_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL1_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL1_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL1_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL1_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL1_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL1_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL1_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL1_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL1_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL1_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL1_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL1_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL1_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL1_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL1_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL1_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL1_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL1_SHRT_PCKT = 0x80000000

	// EPTCTL1_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 1)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL1_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL1_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL1_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL1_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL1_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL1_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL1_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL1_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL1_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL1_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL1_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL1_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL1_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL1_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL1_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL1_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL1_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL1_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL1_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL1_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL1_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL1_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL1_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL1_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL1_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL1_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL1_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL1_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL1_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL1_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL1_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL1_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL1_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL1_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL1_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA1: UDPHS Endpoint Set Status Register (endpoint = 1)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA1_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA1_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA1_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA1_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA1_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA1_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA1_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA1_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA1_TXRDY = 0x800

	// EPTSETSTA1_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 1)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA1_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA1_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA1_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA1_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA1_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA1_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA1: UDPHS Endpoint Clear Status Register (endpoint = 1)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA1_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA1_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA1_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA1_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA1_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA1_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA1_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA1_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA1_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA1_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA1_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA1_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA1_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA1_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA1_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA1_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA1_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA1_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA1_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA1_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA1_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA1_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA1_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA1_NAK_OUT = 0x8000

	// EPTCLRSTA1_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 1)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA1_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA1_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA1_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA1_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA1_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA1_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA1_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA1_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA1_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA1_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA1: UDPHS Endpoint Status Register (endpoint = 1)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA1_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA1_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA1_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA1_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA1_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA1_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA1_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA1_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA1_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA1_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA1_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA1_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA1_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA1_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA1_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA1_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA1_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA1_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA1_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA1_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA1_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA1_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA1_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA1_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA1_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA1_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA1_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA1_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA1_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA1_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA1_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA1_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA1_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA1_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA1_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA1_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA1_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA1_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA1_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA1_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA1_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA1_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA1_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA1_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA1_SHRT_PCKT = 0x80000000

	// EPTSTA1_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 1)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA1_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA1_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA1_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA1_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA1_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA1_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA1_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA1_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA1_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA1_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA1_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA1_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA1_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA1_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA1_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA1_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA1_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA1_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA1_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA1_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA1_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA1_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA1_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA1_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA1_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA1_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA1_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA1_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA1_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA1_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA1_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA1_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA1_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA1_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA1_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG2: UDPHS Endpoint Configuration Register (endpoint = 2)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG2_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG2_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG2_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG2_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG2_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG2_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG2_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG2_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG2_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG2_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG2_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG2_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG2_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG2_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG2_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG2_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG2_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG2_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG2_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG2_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG2_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG2_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG2_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG2_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG2_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG2_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG2_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG2_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG2_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG2_EPT_MAPD = 0x80000000

	// EPTCTLENB2: UDPHS Endpoint Control Enable Register (endpoint = 2)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB2_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB2_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB2_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB2_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB2_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB2_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB2_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB2_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB2_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB2_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB2_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB2_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB2_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB2_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB2_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB2_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB2_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB2_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB2_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB2_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB2_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB2_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB2_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB2_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB2_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB2_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB2_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB2_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB2_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB2_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB2_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB2_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB2_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB2_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB2_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB2_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB2_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB2_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB2_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB2_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB2_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB2_SHRT_PCKT = 0x80000000

	// EPTCTLENB2_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 2)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB2_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB2_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB2_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB2_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB2_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB2_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB2_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB2_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB2_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB2_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB2_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB2_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB2_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB2_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB2_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB2_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB2_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB2_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB2_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB2_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB2_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB2_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB2_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB2_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB2_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB2_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB2_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB2_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB2_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB2_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB2_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS2: UDPHS Endpoint Control Disable Register (endpoint = 2)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS2_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS2_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS2_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS2_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS2_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS2_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS2_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS2_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS2_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS2_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS2_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS2_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS2_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS2_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS2_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS2_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS2_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS2_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS2_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS2_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS2_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS2_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS2_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS2_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS2_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS2_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS2_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS2_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS2_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS2_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS2_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS2_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS2_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS2_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS2_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS2_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS2_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS2_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS2_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS2_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS2_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS2_SHRT_PCKT = 0x80000000

	// EPTCTLDIS2_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 2)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS2_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS2_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS2_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS2_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS2_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS2_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS2_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS2_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS2_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS2_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS2_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS2_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS2_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS2_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS2_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS2_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS2_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS2_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS2_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS2_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS2_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS2_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS2_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS2_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS2_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS2_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS2_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS2_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS2_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS2_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS2_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL2: UDPHS Endpoint Control Register (endpoint = 2)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL2_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL2_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL2_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL2_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL2_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL2_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL2_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL2_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL2_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL2_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL2_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL2_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL2_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL2_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL2_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL2_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL2_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL2_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL2_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL2_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL2_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL2_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL2_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL2_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL2_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL2_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL2_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL2_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL2_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL2_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL2_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL2_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL2_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL2_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL2_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL2_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL2_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL2_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL2_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL2_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL2_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL2_SHRT_PCKT = 0x80000000

	// EPTCTL2_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 2)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL2_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL2_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL2_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL2_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL2_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL2_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL2_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL2_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL2_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL2_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL2_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL2_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL2_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL2_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL2_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL2_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL2_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL2_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL2_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL2_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL2_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL2_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL2_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL2_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL2_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL2_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL2_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL2_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL2_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL2_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL2_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL2_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL2_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL2_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL2_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA2: UDPHS Endpoint Set Status Register (endpoint = 2)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA2_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA2_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA2_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA2_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA2_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA2_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA2_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA2_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA2_TXRDY = 0x800

	// EPTSETSTA2_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 2)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA2_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA2_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA2_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA2_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA2_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA2_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA2: UDPHS Endpoint Clear Status Register (endpoint = 2)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA2_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA2_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA2_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA2_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA2_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA2_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA2_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA2_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA2_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA2_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA2_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA2_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA2_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA2_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA2_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA2_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA2_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA2_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA2_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA2_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA2_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA2_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA2_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA2_NAK_OUT = 0x8000

	// EPTCLRSTA2_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 2)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA2_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA2_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA2_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA2_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA2_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA2_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA2_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA2_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA2_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA2_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA2: UDPHS Endpoint Status Register (endpoint = 2)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA2_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA2_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA2_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA2_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA2_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA2_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA2_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA2_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA2_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA2_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA2_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA2_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA2_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA2_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA2_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA2_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA2_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA2_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA2_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA2_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA2_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA2_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA2_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA2_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA2_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA2_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA2_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA2_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA2_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA2_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA2_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA2_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA2_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA2_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA2_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA2_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA2_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA2_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA2_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA2_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA2_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA2_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA2_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA2_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA2_SHRT_PCKT = 0x80000000

	// EPTSTA2_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 2)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA2_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA2_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA2_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA2_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA2_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA2_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA2_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA2_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA2_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA2_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA2_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA2_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA2_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA2_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA2_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA2_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA2_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA2_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA2_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA2_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA2_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA2_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA2_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA2_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA2_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA2_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA2_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA2_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA2_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA2_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA2_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA2_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA2_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA2_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA2_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG3: UDPHS Endpoint Configuration Register (endpoint = 3)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG3_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG3_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG3_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG3_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG3_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG3_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG3_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG3_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG3_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG3_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG3_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG3_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG3_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG3_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG3_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG3_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG3_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG3_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG3_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG3_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG3_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG3_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG3_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG3_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG3_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG3_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG3_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG3_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG3_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG3_EPT_MAPD = 0x80000000

	// EPTCTLENB3: UDPHS Endpoint Control Enable Register (endpoint = 3)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB3_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB3_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB3_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB3_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB3_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB3_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB3_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB3_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB3_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB3_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB3_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB3_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB3_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB3_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB3_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB3_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB3_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB3_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB3_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB3_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB3_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB3_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB3_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB3_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB3_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB3_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB3_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB3_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB3_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB3_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB3_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB3_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB3_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB3_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB3_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB3_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB3_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB3_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB3_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB3_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB3_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB3_SHRT_PCKT = 0x80000000

	// EPTCTLENB3_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 3)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB3_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB3_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB3_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB3_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB3_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB3_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB3_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB3_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB3_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB3_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB3_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB3_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB3_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB3_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB3_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB3_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB3_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB3_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB3_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB3_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB3_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB3_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB3_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB3_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB3_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB3_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB3_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB3_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB3_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB3_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB3_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS3: UDPHS Endpoint Control Disable Register (endpoint = 3)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS3_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS3_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS3_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS3_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS3_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS3_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS3_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS3_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS3_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS3_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS3_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS3_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS3_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS3_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS3_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS3_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS3_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS3_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS3_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS3_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS3_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS3_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS3_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS3_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS3_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS3_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS3_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS3_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS3_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS3_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS3_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS3_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS3_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS3_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS3_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS3_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS3_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS3_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS3_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS3_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS3_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS3_SHRT_PCKT = 0x80000000

	// EPTCTLDIS3_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 3)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS3_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS3_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS3_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS3_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS3_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS3_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS3_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS3_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS3_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS3_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS3_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS3_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS3_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS3_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS3_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS3_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS3_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS3_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS3_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS3_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS3_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS3_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS3_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS3_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS3_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS3_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS3_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS3_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS3_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS3_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS3_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL3: UDPHS Endpoint Control Register (endpoint = 3)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL3_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL3_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL3_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL3_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL3_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL3_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL3_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL3_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL3_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL3_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL3_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL3_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL3_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL3_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL3_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL3_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL3_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL3_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL3_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL3_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL3_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL3_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL3_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL3_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL3_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL3_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL3_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL3_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL3_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL3_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL3_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL3_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL3_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL3_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL3_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL3_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL3_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL3_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL3_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL3_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL3_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL3_SHRT_PCKT = 0x80000000

	// EPTCTL3_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 3)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL3_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL3_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL3_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL3_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL3_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL3_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL3_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL3_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL3_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL3_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL3_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL3_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL3_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL3_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL3_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL3_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL3_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL3_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL3_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL3_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL3_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL3_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL3_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL3_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL3_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL3_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL3_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL3_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL3_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL3_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL3_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL3_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL3_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL3_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL3_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA3: UDPHS Endpoint Set Status Register (endpoint = 3)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA3_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA3_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA3_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA3_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA3_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA3_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA3_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA3_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA3_TXRDY = 0x800

	// EPTSETSTA3_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 3)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA3_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA3_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA3_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA3_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA3_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA3_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA3: UDPHS Endpoint Clear Status Register (endpoint = 3)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA3_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA3_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA3_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA3_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA3_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA3_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA3_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA3_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA3_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA3_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA3_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA3_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA3_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA3_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA3_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA3_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA3_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA3_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA3_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA3_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA3_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA3_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA3_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA3_NAK_OUT = 0x8000

	// EPTCLRSTA3_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 3)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA3_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA3_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA3_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA3_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA3_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA3_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA3_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA3_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA3_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA3_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA3: UDPHS Endpoint Status Register (endpoint = 3)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA3_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA3_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA3_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA3_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA3_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA3_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA3_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA3_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA3_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA3_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA3_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA3_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA3_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA3_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA3_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA3_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA3_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA3_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA3_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA3_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA3_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA3_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA3_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA3_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA3_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA3_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA3_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA3_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA3_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA3_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA3_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA3_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA3_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA3_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA3_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA3_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA3_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA3_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA3_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA3_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA3_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA3_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA3_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA3_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA3_SHRT_PCKT = 0x80000000

	// EPTSTA3_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 3)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA3_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA3_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA3_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA3_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA3_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA3_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA3_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA3_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA3_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA3_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA3_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA3_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA3_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA3_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA3_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA3_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA3_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA3_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA3_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA3_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA3_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA3_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA3_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA3_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA3_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA3_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA3_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA3_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA3_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA3_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA3_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA3_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA3_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA3_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA3_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG4: UDPHS Endpoint Configuration Register (endpoint = 4)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG4_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG4_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG4_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG4_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG4_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG4_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG4_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG4_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG4_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG4_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG4_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG4_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG4_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG4_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG4_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG4_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG4_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG4_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG4_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG4_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG4_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG4_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG4_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG4_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG4_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG4_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG4_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG4_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG4_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG4_EPT_MAPD = 0x80000000

	// EPTCTLENB4: UDPHS Endpoint Control Enable Register (endpoint = 4)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB4_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB4_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB4_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB4_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB4_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB4_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB4_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB4_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB4_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB4_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB4_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB4_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB4_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB4_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB4_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB4_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB4_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB4_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB4_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB4_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB4_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB4_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB4_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB4_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB4_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB4_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB4_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB4_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB4_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB4_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB4_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB4_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB4_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB4_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB4_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB4_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB4_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB4_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB4_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB4_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB4_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB4_SHRT_PCKT = 0x80000000

	// EPTCTLENB4_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 4)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB4_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB4_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB4_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB4_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB4_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB4_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB4_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB4_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB4_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB4_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB4_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB4_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB4_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB4_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB4_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB4_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB4_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB4_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB4_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB4_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB4_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB4_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB4_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB4_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB4_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB4_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB4_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB4_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB4_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB4_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB4_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS4: UDPHS Endpoint Control Disable Register (endpoint = 4)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS4_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS4_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS4_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS4_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS4_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS4_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS4_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS4_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS4_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS4_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS4_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS4_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS4_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS4_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS4_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS4_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS4_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS4_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS4_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS4_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS4_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS4_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS4_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS4_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS4_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS4_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS4_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS4_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS4_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS4_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS4_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS4_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS4_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS4_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS4_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS4_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS4_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS4_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS4_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS4_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS4_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS4_SHRT_PCKT = 0x80000000

	// EPTCTLDIS4_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 4)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS4_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS4_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS4_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS4_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS4_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS4_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS4_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS4_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS4_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS4_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS4_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS4_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS4_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS4_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS4_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS4_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS4_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS4_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS4_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS4_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS4_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS4_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS4_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS4_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS4_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS4_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS4_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS4_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS4_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS4_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS4_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL4: UDPHS Endpoint Control Register (endpoint = 4)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL4_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL4_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL4_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL4_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL4_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL4_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL4_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL4_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL4_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL4_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL4_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL4_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL4_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL4_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL4_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL4_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL4_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL4_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL4_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL4_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL4_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL4_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL4_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL4_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL4_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL4_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL4_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL4_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL4_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL4_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL4_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL4_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL4_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL4_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL4_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL4_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL4_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL4_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL4_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL4_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL4_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL4_SHRT_PCKT = 0x80000000

	// EPTCTL4_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 4)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL4_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL4_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL4_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL4_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL4_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL4_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL4_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL4_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL4_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL4_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL4_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL4_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL4_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL4_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL4_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL4_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL4_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL4_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL4_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL4_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL4_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL4_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL4_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL4_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL4_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL4_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL4_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL4_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL4_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL4_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL4_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL4_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL4_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL4_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL4_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA4: UDPHS Endpoint Set Status Register (endpoint = 4)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA4_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA4_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA4_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA4_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA4_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA4_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA4_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA4_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA4_TXRDY = 0x800

	// EPTSETSTA4_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 4)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA4_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA4_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA4_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA4_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA4_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA4_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA4: UDPHS Endpoint Clear Status Register (endpoint = 4)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA4_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA4_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA4_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA4_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA4_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA4_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA4_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA4_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA4_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA4_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA4_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA4_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA4_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA4_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA4_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA4_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA4_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA4_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA4_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA4_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA4_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA4_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA4_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA4_NAK_OUT = 0x8000

	// EPTCLRSTA4_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 4)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA4_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA4_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA4_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA4_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA4_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA4_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA4_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA4_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA4_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA4_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA4: UDPHS Endpoint Status Register (endpoint = 4)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA4_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA4_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA4_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA4_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA4_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA4_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA4_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA4_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA4_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA4_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA4_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA4_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA4_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA4_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA4_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA4_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA4_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA4_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA4_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA4_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA4_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA4_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA4_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA4_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA4_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA4_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA4_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA4_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA4_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA4_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA4_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA4_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA4_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA4_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA4_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA4_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA4_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA4_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA4_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA4_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA4_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA4_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA4_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA4_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA4_SHRT_PCKT = 0x80000000

	// EPTSTA4_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 4)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA4_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA4_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA4_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA4_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA4_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA4_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA4_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA4_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA4_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA4_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA4_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA4_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA4_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA4_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA4_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA4_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA4_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA4_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA4_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA4_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA4_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA4_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA4_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA4_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA4_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA4_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA4_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA4_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA4_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA4_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA4_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA4_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA4_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA4_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA4_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG5: UDPHS Endpoint Configuration Register (endpoint = 5)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG5_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG5_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG5_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG5_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG5_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG5_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG5_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG5_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG5_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG5_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG5_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG5_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG5_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG5_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG5_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG5_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG5_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG5_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG5_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG5_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG5_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG5_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG5_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG5_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG5_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG5_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG5_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG5_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG5_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG5_EPT_MAPD = 0x80000000

	// EPTCTLENB5: UDPHS Endpoint Control Enable Register (endpoint = 5)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB5_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB5_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB5_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB5_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB5_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB5_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB5_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB5_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB5_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB5_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB5_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB5_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB5_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB5_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB5_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB5_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB5_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB5_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB5_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB5_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB5_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB5_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB5_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB5_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB5_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB5_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB5_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB5_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB5_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB5_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB5_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB5_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB5_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB5_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB5_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB5_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB5_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB5_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB5_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB5_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB5_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB5_SHRT_PCKT = 0x80000000

	// EPTCTLENB5_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 5)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB5_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB5_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB5_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB5_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB5_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB5_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB5_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB5_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB5_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB5_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB5_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB5_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB5_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB5_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB5_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB5_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB5_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB5_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB5_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB5_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB5_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB5_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB5_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB5_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB5_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB5_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB5_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB5_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB5_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB5_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB5_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS5: UDPHS Endpoint Control Disable Register (endpoint = 5)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS5_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS5_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS5_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS5_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS5_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS5_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS5_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS5_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS5_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS5_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS5_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS5_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS5_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS5_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS5_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS5_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS5_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS5_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS5_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS5_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS5_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS5_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS5_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS5_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS5_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS5_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS5_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS5_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS5_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS5_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS5_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS5_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS5_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS5_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS5_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS5_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS5_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS5_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS5_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS5_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS5_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS5_SHRT_PCKT = 0x80000000

	// EPTCTLDIS5_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 5)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS5_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS5_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS5_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS5_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS5_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS5_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS5_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS5_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS5_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS5_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS5_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS5_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS5_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS5_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS5_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS5_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS5_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS5_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS5_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS5_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS5_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS5_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS5_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS5_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS5_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS5_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS5_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS5_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS5_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS5_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS5_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL5: UDPHS Endpoint Control Register (endpoint = 5)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL5_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL5_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL5_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL5_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL5_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL5_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL5_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL5_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL5_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL5_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL5_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL5_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL5_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL5_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL5_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL5_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL5_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL5_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL5_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL5_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL5_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL5_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL5_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL5_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL5_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL5_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL5_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL5_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL5_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL5_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL5_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL5_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL5_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL5_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL5_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL5_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL5_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL5_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL5_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL5_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL5_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL5_SHRT_PCKT = 0x80000000

	// EPTCTL5_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 5)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL5_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL5_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL5_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL5_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL5_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL5_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL5_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL5_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL5_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL5_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL5_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL5_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL5_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL5_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL5_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL5_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL5_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL5_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL5_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL5_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL5_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL5_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL5_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL5_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL5_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL5_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL5_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL5_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL5_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL5_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL5_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL5_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL5_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL5_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL5_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA5: UDPHS Endpoint Set Status Register (endpoint = 5)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA5_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA5_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA5_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA5_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA5_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA5_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA5_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA5_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA5_TXRDY = 0x800

	// EPTSETSTA5_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 5)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA5_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA5_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA5_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA5_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA5_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA5_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA5: UDPHS Endpoint Clear Status Register (endpoint = 5)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA5_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA5_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA5_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA5_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA5_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA5_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA5_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA5_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA5_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA5_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA5_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA5_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA5_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA5_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA5_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA5_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA5_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA5_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA5_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA5_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA5_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA5_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA5_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA5_NAK_OUT = 0x8000

	// EPTCLRSTA5_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 5)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA5_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA5_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA5_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA5_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA5_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA5_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA5_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA5_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA5_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA5_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA5: UDPHS Endpoint Status Register (endpoint = 5)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA5_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA5_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA5_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA5_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA5_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA5_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA5_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA5_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA5_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA5_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA5_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA5_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA5_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA5_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA5_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA5_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA5_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA5_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA5_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA5_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA5_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA5_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA5_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA5_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA5_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA5_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA5_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA5_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA5_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA5_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA5_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA5_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA5_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA5_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA5_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA5_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA5_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA5_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA5_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA5_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA5_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA5_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA5_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA5_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA5_SHRT_PCKT = 0x80000000

	// EPTSTA5_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 5)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA5_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA5_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA5_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA5_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA5_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA5_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA5_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA5_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA5_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA5_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA5_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA5_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA5_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA5_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA5_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA5_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA5_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA5_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA5_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA5_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA5_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA5_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA5_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA5_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA5_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA5_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA5_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA5_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA5_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA5_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA5_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA5_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA5_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA5_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA5_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG6: UDPHS Endpoint Configuration Register (endpoint = 6)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG6_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG6_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG6_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG6_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG6_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG6_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG6_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG6_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG6_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG6_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG6_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG6_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG6_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG6_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG6_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG6_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG6_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG6_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG6_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG6_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG6_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG6_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG6_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG6_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG6_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG6_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG6_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG6_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG6_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG6_EPT_MAPD = 0x80000000

	// EPTCTLENB6: UDPHS Endpoint Control Enable Register (endpoint = 6)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB6_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB6_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB6_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB6_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB6_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB6_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB6_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB6_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB6_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB6_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB6_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB6_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB6_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB6_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB6_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB6_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB6_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB6_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB6_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB6_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB6_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB6_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB6_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB6_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB6_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB6_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB6_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB6_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB6_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB6_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB6_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB6_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB6_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB6_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB6_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB6_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB6_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB6_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB6_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB6_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB6_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB6_SHRT_PCKT = 0x80000000

	// EPTCTLENB6_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 6)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB6_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB6_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB6_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB6_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB6_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB6_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB6_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB6_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB6_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB6_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB6_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB6_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB6_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB6_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB6_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB6_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB6_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB6_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB6_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB6_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB6_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB6_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB6_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB6_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB6_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB6_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB6_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB6_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB6_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB6_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB6_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS6: UDPHS Endpoint Control Disable Register (endpoint = 6)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS6_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS6_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS6_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS6_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS6_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS6_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS6_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS6_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS6_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS6_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS6_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS6_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS6_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS6_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS6_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS6_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS6_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS6_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS6_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS6_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS6_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS6_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS6_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS6_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS6_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS6_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS6_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS6_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS6_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS6_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS6_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS6_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS6_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS6_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS6_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS6_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS6_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS6_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS6_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS6_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS6_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS6_SHRT_PCKT = 0x80000000

	// EPTCTLDIS6_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 6)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS6_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS6_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS6_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS6_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS6_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS6_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS6_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS6_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS6_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS6_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS6_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS6_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS6_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS6_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS6_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS6_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS6_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS6_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS6_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS6_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS6_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS6_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS6_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS6_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS6_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS6_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS6_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS6_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS6_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS6_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS6_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL6: UDPHS Endpoint Control Register (endpoint = 6)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL6_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL6_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL6_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL6_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL6_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL6_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL6_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL6_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL6_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL6_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL6_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL6_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL6_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL6_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL6_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL6_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL6_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL6_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL6_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL6_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL6_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL6_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL6_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL6_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL6_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL6_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL6_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL6_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL6_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL6_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL6_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL6_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL6_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL6_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL6_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL6_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL6_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL6_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL6_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL6_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL6_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL6_SHRT_PCKT = 0x80000000

	// EPTCTL6_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 6)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL6_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL6_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL6_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL6_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL6_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL6_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL6_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL6_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL6_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL6_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL6_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL6_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL6_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL6_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL6_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL6_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL6_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL6_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL6_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL6_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL6_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL6_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL6_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL6_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL6_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL6_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL6_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL6_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL6_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL6_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL6_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL6_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL6_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL6_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL6_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA6: UDPHS Endpoint Set Status Register (endpoint = 6)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA6_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA6_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA6_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA6_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA6_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA6_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA6_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA6_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA6_TXRDY = 0x800

	// EPTSETSTA6_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 6)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA6_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA6_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA6_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA6_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA6_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA6_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA6: UDPHS Endpoint Clear Status Register (endpoint = 6)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA6_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA6_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA6_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA6_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA6_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA6_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA6_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA6_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA6_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA6_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA6_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA6_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA6_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA6_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA6_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA6_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA6_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA6_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA6_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA6_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA6_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA6_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA6_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA6_NAK_OUT = 0x8000

	// EPTCLRSTA6_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 6)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA6_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA6_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA6_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA6_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA6_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA6_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA6_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA6_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA6_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA6_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA6: UDPHS Endpoint Status Register (endpoint = 6)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA6_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA6_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA6_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA6_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA6_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA6_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA6_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA6_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA6_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA6_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA6_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA6_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA6_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA6_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA6_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA6_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA6_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA6_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA6_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA6_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA6_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA6_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA6_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA6_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA6_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA6_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA6_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA6_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA6_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA6_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA6_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA6_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA6_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA6_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA6_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA6_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA6_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA6_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA6_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA6_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA6_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA6_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA6_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA6_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA6_SHRT_PCKT = 0x80000000

	// EPTSTA6_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 6)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA6_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA6_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA6_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA6_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA6_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA6_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA6_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA6_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA6_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA6_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA6_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA6_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA6_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA6_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA6_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA6_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA6_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA6_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA6_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA6_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA6_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA6_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA6_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA6_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA6_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA6_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA6_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA6_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA6_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA6_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA6_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA6_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA6_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA6_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA6_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG7: UDPHS Endpoint Configuration Register (endpoint = 7)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG7_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG7_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG7_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG7_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG7_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG7_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG7_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG7_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG7_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG7_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG7_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG7_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG7_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG7_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG7_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG7_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG7_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG7_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG7_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG7_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG7_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG7_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG7_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG7_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG7_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG7_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG7_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG7_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG7_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG7_EPT_MAPD = 0x80000000

	// EPTCTLENB7: UDPHS Endpoint Control Enable Register (endpoint = 7)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB7_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB7_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB7_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB7_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB7_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB7_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB7_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB7_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB7_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB7_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB7_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB7_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB7_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB7_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB7_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB7_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB7_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB7_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB7_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB7_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB7_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB7_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB7_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB7_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB7_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB7_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB7_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB7_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB7_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB7_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB7_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB7_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB7_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB7_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB7_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB7_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB7_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB7_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB7_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB7_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB7_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB7_SHRT_PCKT = 0x80000000

	// EPTCTLENB7_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 7)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB7_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB7_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB7_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB7_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB7_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB7_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB7_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB7_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB7_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB7_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB7_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB7_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB7_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB7_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB7_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB7_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB7_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB7_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB7_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB7_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB7_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB7_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB7_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB7_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB7_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB7_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB7_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB7_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB7_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB7_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB7_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS7: UDPHS Endpoint Control Disable Register (endpoint = 7)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS7_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS7_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS7_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS7_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS7_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS7_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS7_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS7_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS7_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS7_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS7_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS7_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS7_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS7_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS7_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS7_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS7_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS7_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS7_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS7_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS7_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS7_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS7_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS7_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS7_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS7_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS7_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS7_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS7_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS7_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS7_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS7_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS7_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS7_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS7_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS7_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS7_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS7_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS7_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS7_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS7_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS7_SHRT_PCKT = 0x80000000

	// EPTCTLDIS7_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 7)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS7_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS7_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS7_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS7_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS7_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS7_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS7_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS7_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS7_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS7_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS7_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS7_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS7_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS7_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS7_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS7_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS7_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS7_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS7_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS7_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS7_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS7_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS7_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS7_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS7_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS7_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS7_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS7_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS7_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS7_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS7_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL7: UDPHS Endpoint Control Register (endpoint = 7)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL7_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL7_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL7_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL7_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL7_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL7_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL7_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL7_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL7_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL7_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL7_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL7_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL7_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL7_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL7_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL7_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL7_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL7_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL7_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL7_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL7_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL7_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL7_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL7_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL7_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL7_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL7_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL7_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL7_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL7_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL7_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL7_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL7_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL7_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL7_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL7_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL7_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL7_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL7_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL7_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL7_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL7_SHRT_PCKT = 0x80000000

	// EPTCTL7_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 7)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL7_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL7_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL7_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL7_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL7_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL7_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL7_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL7_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL7_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL7_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL7_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL7_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL7_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL7_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL7_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL7_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL7_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL7_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL7_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL7_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL7_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL7_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL7_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL7_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL7_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL7_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL7_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL7_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL7_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL7_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL7_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL7_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL7_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL7_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL7_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL7_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL7_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL7_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL7_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL7_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL7_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL7_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA7: UDPHS Endpoint Set Status Register (endpoint = 7)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA7_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA7_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA7_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA7_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA7_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA7_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA7_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA7_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA7_TXRDY = 0x800

	// EPTSETSTA7_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 7)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA7_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA7_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA7_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA7_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA7_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA7_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA7: UDPHS Endpoint Clear Status Register (endpoint = 7)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA7_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA7_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA7_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA7_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA7_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA7_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA7_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA7_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA7_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA7_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA7_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA7_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA7_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA7_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA7_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA7_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA7_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA7_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA7_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA7_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA7_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA7_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA7_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA7_NAK_OUT = 0x8000

	// EPTCLRSTA7_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 7)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA7_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA7_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA7_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA7_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA7_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA7_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA7_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA7_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA7_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA7_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA7_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA7_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA7_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA7_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA7_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA7_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA7_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA7_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA7: UDPHS Endpoint Status Register (endpoint = 7)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA7_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA7_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA7_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA7_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA7_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA7_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA7_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA7_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA7_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA7_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA7_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA7_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA7_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA7_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA7_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA7_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA7_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA7_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA7_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA7_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA7_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA7_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA7_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA7_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA7_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA7_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA7_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA7_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA7_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA7_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA7_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA7_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA7_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA7_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA7_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA7_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA7_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA7_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA7_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA7_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA7_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA7_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA7_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA7_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA7_SHRT_PCKT = 0x80000000

	// EPTSTA7_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 7)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA7_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA7_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA7_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA7_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA7_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA7_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA7_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA7_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA7_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA7_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA7_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA7_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA7_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA7_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA7_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA7_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA7_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA7_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA7_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA7_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA7_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA7_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA7_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA7_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA7_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA7_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA7_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA7_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA7_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA7_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA7_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA7_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA7_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA7_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA7_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA7_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA7_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA7_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA7_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA7_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA7_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA7_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG8: UDPHS Endpoint Configuration Register (endpoint = 8)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG8_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG8_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG8_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG8_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG8_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG8_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG8_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG8_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG8_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG8_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG8_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG8_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG8_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG8_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG8_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG8_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG8_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG8_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG8_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG8_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG8_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG8_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG8_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG8_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG8_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG8_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG8_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG8_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG8_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG8_EPT_MAPD = 0x80000000

	// EPTCTLENB8: UDPHS Endpoint Control Enable Register (endpoint = 8)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB8_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB8_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB8_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB8_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB8_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB8_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB8_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB8_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB8_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB8_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB8_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB8_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB8_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB8_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB8_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB8_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB8_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB8_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB8_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB8_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB8_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB8_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB8_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB8_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB8_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB8_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB8_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB8_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB8_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB8_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB8_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB8_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB8_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB8_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB8_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB8_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB8_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB8_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB8_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB8_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB8_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB8_SHRT_PCKT = 0x80000000

	// EPTCTLENB8_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 8)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB8_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB8_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB8_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB8_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB8_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB8_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB8_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB8_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB8_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB8_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB8_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB8_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB8_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB8_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB8_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB8_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB8_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB8_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB8_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB8_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB8_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB8_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB8_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB8_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB8_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB8_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB8_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB8_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB8_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB8_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB8_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS8: UDPHS Endpoint Control Disable Register (endpoint = 8)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS8_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS8_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS8_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS8_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS8_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS8_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS8_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS8_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS8_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS8_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS8_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS8_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS8_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS8_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS8_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS8_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS8_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS8_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS8_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS8_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS8_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS8_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS8_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS8_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS8_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS8_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS8_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS8_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS8_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS8_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS8_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS8_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS8_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS8_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS8_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS8_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS8_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS8_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS8_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS8_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS8_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS8_SHRT_PCKT = 0x80000000

	// EPTCTLDIS8_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 8)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS8_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS8_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS8_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS8_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS8_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS8_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS8_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS8_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS8_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS8_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS8_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS8_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS8_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS8_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS8_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS8_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS8_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS8_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS8_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS8_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS8_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS8_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS8_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS8_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS8_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS8_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS8_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS8_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS8_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS8_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS8_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL8: UDPHS Endpoint Control Register (endpoint = 8)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL8_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL8_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL8_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL8_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL8_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL8_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL8_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL8_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL8_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL8_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL8_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL8_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL8_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL8_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL8_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL8_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL8_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL8_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL8_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL8_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL8_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL8_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL8_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL8_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL8_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL8_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL8_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL8_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL8_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL8_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL8_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL8_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL8_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL8_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL8_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL8_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL8_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL8_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL8_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL8_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL8_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL8_SHRT_PCKT = 0x80000000

	// EPTCTL8_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 8)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL8_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL8_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL8_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL8_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL8_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL8_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL8_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL8_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL8_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL8_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL8_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL8_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL8_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL8_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL8_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL8_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL8_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL8_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL8_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL8_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL8_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL8_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL8_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL8_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL8_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL8_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL8_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL8_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL8_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL8_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL8_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL8_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL8_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL8_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL8_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL8_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL8_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL8_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL8_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL8_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL8_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL8_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA8: UDPHS Endpoint Set Status Register (endpoint = 8)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA8_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA8_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA8_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA8_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA8_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA8_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA8_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA8_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA8_TXRDY = 0x800

	// EPTSETSTA8_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 8)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA8_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA8_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA8_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA8_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA8_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA8_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA8: UDPHS Endpoint Clear Status Register (endpoint = 8)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA8_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA8_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA8_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA8_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA8_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA8_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA8_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA8_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA8_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA8_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA8_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA8_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA8_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA8_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA8_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA8_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA8_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA8_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA8_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA8_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA8_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA8_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA8_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA8_NAK_OUT = 0x8000

	// EPTCLRSTA8_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 8)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA8_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA8_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA8_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA8_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA8_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA8_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA8_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA8_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA8_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA8_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA8_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA8_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA8_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA8_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA8_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA8_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA8_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA8_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA8: UDPHS Endpoint Status Register (endpoint = 8)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA8_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA8_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA8_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA8_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA8_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA8_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA8_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA8_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA8_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA8_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA8_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA8_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA8_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA8_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA8_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA8_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA8_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA8_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA8_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA8_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA8_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA8_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA8_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA8_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA8_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA8_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA8_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA8_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA8_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA8_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA8_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA8_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA8_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA8_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA8_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA8_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA8_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA8_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA8_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA8_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA8_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA8_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA8_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA8_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA8_SHRT_PCKT = 0x80000000

	// EPTSTA8_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 8)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA8_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA8_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA8_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA8_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA8_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA8_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA8_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA8_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA8_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA8_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA8_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA8_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA8_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA8_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA8_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA8_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA8_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA8_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA8_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA8_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA8_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA8_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA8_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA8_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA8_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA8_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA8_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA8_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA8_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA8_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA8_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA8_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA8_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA8_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA8_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA8_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA8_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA8_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA8_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA8_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA8_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA8_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG9: UDPHS Endpoint Configuration Register (endpoint = 9)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG9_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG9_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG9_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG9_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG9_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG9_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG9_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG9_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG9_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG9_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG9_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG9_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG9_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG9_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG9_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG9_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG9_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG9_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG9_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG9_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG9_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG9_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG9_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG9_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG9_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG9_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG9_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG9_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG9_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG9_EPT_MAPD = 0x80000000

	// EPTCTLENB9: UDPHS Endpoint Control Enable Register (endpoint = 9)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB9_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB9_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB9_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB9_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB9_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB9_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB9_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB9_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB9_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB9_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB9_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB9_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB9_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB9_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB9_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB9_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB9_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB9_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB9_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB9_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB9_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB9_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB9_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB9_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB9_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB9_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB9_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB9_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB9_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB9_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB9_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB9_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB9_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB9_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB9_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB9_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB9_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB9_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB9_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB9_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB9_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB9_SHRT_PCKT = 0x80000000

	// EPTCTLENB9_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 9)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB9_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB9_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB9_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB9_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB9_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB9_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB9_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB9_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB9_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB9_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB9_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB9_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB9_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB9_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB9_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB9_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB9_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB9_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB9_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB9_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB9_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB9_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB9_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB9_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB9_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB9_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB9_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB9_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB9_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB9_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB9_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS9: UDPHS Endpoint Control Disable Register (endpoint = 9)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS9_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS9_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS9_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS9_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS9_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS9_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS9_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS9_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS9_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS9_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS9_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS9_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS9_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS9_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS9_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS9_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS9_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS9_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS9_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS9_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS9_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS9_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS9_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS9_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS9_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS9_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS9_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS9_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS9_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS9_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS9_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS9_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS9_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS9_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS9_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS9_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS9_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS9_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS9_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS9_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS9_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS9_SHRT_PCKT = 0x80000000

	// EPTCTLDIS9_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 9)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS9_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS9_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS9_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS9_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS9_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS9_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS9_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS9_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS9_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS9_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS9_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS9_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS9_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS9_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS9_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS9_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS9_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS9_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS9_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS9_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS9_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS9_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS9_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS9_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS9_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS9_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS9_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS9_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS9_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS9_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS9_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL9: UDPHS Endpoint Control Register (endpoint = 9)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL9_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL9_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL9_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL9_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL9_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL9_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL9_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL9_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL9_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL9_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL9_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL9_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL9_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL9_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL9_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL9_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL9_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL9_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL9_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL9_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL9_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL9_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL9_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL9_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL9_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL9_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL9_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL9_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL9_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL9_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL9_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL9_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL9_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL9_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL9_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL9_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL9_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL9_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL9_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL9_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL9_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL9_SHRT_PCKT = 0x80000000

	// EPTCTL9_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 9)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL9_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL9_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL9_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL9_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL9_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL9_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL9_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL9_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL9_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL9_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL9_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL9_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL9_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL9_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL9_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL9_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL9_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL9_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL9_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL9_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL9_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL9_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL9_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL9_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL9_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL9_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL9_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL9_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL9_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL9_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL9_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL9_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL9_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL9_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL9_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL9_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL9_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL9_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL9_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL9_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL9_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL9_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA9: UDPHS Endpoint Set Status Register (endpoint = 9)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA9_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA9_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA9_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA9_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA9_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA9_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA9_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA9_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA9_TXRDY = 0x800

	// EPTSETSTA9_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 9)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA9_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA9_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA9_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA9_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA9_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA9_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA9: UDPHS Endpoint Clear Status Register (endpoint = 9)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA9_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA9_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA9_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA9_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA9_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA9_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA9_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA9_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA9_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA9_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA9_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA9_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA9_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA9_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA9_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA9_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA9_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA9_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA9_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA9_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA9_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA9_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA9_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA9_NAK_OUT = 0x8000

	// EPTCLRSTA9_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 9)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA9_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA9_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA9_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA9_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA9_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA9_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA9_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA9_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA9_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA9_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA9_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA9_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA9_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA9_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA9_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA9_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA9_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA9_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA9: UDPHS Endpoint Status Register (endpoint = 9)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA9_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA9_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA9_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA9_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA9_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA9_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA9_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA9_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA9_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA9_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA9_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA9_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA9_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA9_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA9_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA9_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA9_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA9_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA9_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA9_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA9_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA9_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA9_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA9_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA9_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA9_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA9_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA9_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA9_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA9_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA9_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA9_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA9_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA9_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA9_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA9_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA9_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA9_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA9_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA9_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA9_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA9_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA9_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA9_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA9_SHRT_PCKT = 0x80000000

	// EPTSTA9_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 9)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA9_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA9_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA9_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA9_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA9_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA9_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA9_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA9_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA9_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA9_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA9_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA9_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA9_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA9_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA9_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA9_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA9_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA9_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA9_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA9_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA9_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA9_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA9_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA9_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA9_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA9_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA9_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA9_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA9_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA9_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA9_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA9_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA9_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA9_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA9_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA9_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA9_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA9_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA9_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA9_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA9_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA9_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG10: UDPHS Endpoint Configuration Register (endpoint = 10)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG10_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG10_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG10_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG10_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG10_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG10_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG10_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG10_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG10_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG10_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG10_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG10_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG10_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG10_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG10_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG10_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG10_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG10_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG10_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG10_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG10_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG10_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG10_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG10_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG10_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG10_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG10_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG10_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG10_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG10_EPT_MAPD = 0x80000000

	// EPTCTLENB10: UDPHS Endpoint Control Enable Register (endpoint = 10)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB10_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB10_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB10_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB10_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB10_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB10_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB10_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB10_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB10_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB10_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB10_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB10_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB10_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB10_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB10_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB10_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB10_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB10_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB10_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB10_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB10_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB10_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB10_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB10_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB10_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB10_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB10_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB10_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB10_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB10_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB10_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB10_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB10_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB10_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB10_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB10_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB10_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB10_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB10_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB10_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB10_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB10_SHRT_PCKT = 0x80000000

	// EPTCTLENB10_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 10)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB10_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB10_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB10_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB10_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB10_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB10_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB10_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB10_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB10_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB10_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB10_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB10_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB10_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB10_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB10_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB10_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB10_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB10_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB10_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB10_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB10_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB10_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB10_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB10_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB10_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB10_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB10_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB10_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB10_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB10_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB10_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS10: UDPHS Endpoint Control Disable Register (endpoint = 10)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS10_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS10_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS10_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS10_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS10_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS10_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS10_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS10_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS10_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS10_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS10_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS10_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS10_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS10_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS10_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS10_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS10_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS10_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS10_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS10_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS10_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS10_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS10_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS10_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS10_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS10_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS10_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS10_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS10_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS10_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS10_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS10_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS10_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS10_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS10_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS10_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS10_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS10_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS10_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS10_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS10_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS10_SHRT_PCKT = 0x80000000

	// EPTCTLDIS10_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 10)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS10_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS10_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS10_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS10_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS10_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS10_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS10_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS10_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS10_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS10_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS10_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS10_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS10_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS10_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS10_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS10_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS10_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS10_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS10_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS10_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS10_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS10_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS10_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS10_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS10_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS10_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS10_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS10_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS10_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS10_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS10_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL10: UDPHS Endpoint Control Register (endpoint = 10)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL10_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL10_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL10_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL10_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL10_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL10_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL10_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL10_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL10_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL10_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL10_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL10_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL10_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL10_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL10_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL10_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL10_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL10_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL10_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL10_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL10_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL10_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL10_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL10_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL10_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL10_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL10_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL10_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL10_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL10_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL10_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL10_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL10_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL10_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL10_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL10_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL10_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL10_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL10_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL10_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL10_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL10_SHRT_PCKT = 0x80000000

	// EPTCTL10_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 10)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL10_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL10_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL10_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL10_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL10_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL10_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL10_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL10_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL10_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL10_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL10_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL10_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL10_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL10_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL10_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL10_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL10_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL10_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL10_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL10_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL10_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL10_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL10_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL10_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL10_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL10_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL10_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL10_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL10_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL10_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL10_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL10_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL10_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL10_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL10_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL10_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL10_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL10_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL10_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL10_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL10_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL10_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA10: UDPHS Endpoint Set Status Register (endpoint = 10)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA10_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA10_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA10_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA10_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA10_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA10_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA10_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA10_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA10_TXRDY = 0x800

	// EPTSETSTA10_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 10)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA10_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA10_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA10_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA10_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA10_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA10_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA10: UDPHS Endpoint Clear Status Register (endpoint = 10)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA10_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA10_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA10_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA10_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA10_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA10_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA10_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA10_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA10_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA10_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA10_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA10_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA10_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA10_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA10_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA10_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA10_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA10_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA10_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA10_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA10_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA10_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA10_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA10_NAK_OUT = 0x8000

	// EPTCLRSTA10_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 10)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA10_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA10_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA10_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA10_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA10_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA10_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA10_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA10_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA10_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA10_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA10_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA10_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA10_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA10_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA10_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA10_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA10_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA10_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA10: UDPHS Endpoint Status Register (endpoint = 10)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA10_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA10_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA10_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA10_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA10_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA10_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA10_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA10_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA10_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA10_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA10_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA10_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA10_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA10_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA10_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA10_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA10_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA10_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA10_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA10_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA10_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA10_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA10_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA10_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA10_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA10_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA10_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA10_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA10_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA10_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA10_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA10_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA10_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA10_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA10_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA10_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA10_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA10_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA10_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA10_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA10_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA10_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA10_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA10_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA10_SHRT_PCKT = 0x80000000

	// EPTSTA10_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 10)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA10_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA10_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA10_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA10_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA10_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA10_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA10_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA10_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA10_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA10_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA10_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA10_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA10_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA10_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA10_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA10_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA10_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA10_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA10_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA10_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA10_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA10_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA10_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA10_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA10_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA10_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA10_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA10_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA10_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA10_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA10_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA10_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA10_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA10_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA10_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA10_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA10_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA10_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA10_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA10_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA10_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA10_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG11: UDPHS Endpoint Configuration Register (endpoint = 11)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG11_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG11_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG11_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG11_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG11_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG11_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG11_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG11_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG11_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG11_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG11_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG11_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG11_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG11_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG11_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG11_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG11_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG11_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG11_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG11_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG11_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG11_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG11_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG11_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG11_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG11_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG11_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG11_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG11_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG11_EPT_MAPD = 0x80000000

	// EPTCTLENB11: UDPHS Endpoint Control Enable Register (endpoint = 11)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB11_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB11_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB11_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB11_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB11_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB11_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB11_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB11_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB11_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB11_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB11_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB11_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB11_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB11_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB11_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB11_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB11_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB11_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB11_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB11_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB11_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB11_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB11_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB11_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB11_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB11_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB11_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB11_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB11_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB11_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB11_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB11_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB11_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB11_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB11_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB11_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB11_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB11_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB11_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB11_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB11_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB11_SHRT_PCKT = 0x80000000

	// EPTCTLENB11_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 11)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB11_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB11_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB11_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB11_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB11_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB11_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB11_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB11_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB11_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB11_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB11_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB11_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB11_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB11_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB11_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB11_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB11_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB11_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB11_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB11_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB11_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB11_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB11_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB11_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB11_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB11_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB11_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB11_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB11_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB11_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB11_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS11: UDPHS Endpoint Control Disable Register (endpoint = 11)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS11_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS11_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS11_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS11_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS11_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS11_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS11_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS11_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS11_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS11_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS11_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS11_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS11_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS11_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS11_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS11_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS11_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS11_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS11_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS11_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS11_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS11_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS11_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS11_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS11_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS11_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS11_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS11_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS11_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS11_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS11_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS11_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS11_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS11_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS11_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS11_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS11_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS11_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS11_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS11_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS11_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS11_SHRT_PCKT = 0x80000000

	// EPTCTLDIS11_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 11)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS11_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS11_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS11_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS11_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS11_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS11_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS11_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS11_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS11_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS11_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS11_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS11_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS11_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS11_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS11_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS11_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS11_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS11_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS11_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS11_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS11_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS11_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS11_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS11_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS11_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS11_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS11_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS11_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS11_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS11_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS11_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL11: UDPHS Endpoint Control Register (endpoint = 11)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL11_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL11_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL11_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL11_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL11_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL11_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL11_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL11_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL11_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL11_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL11_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL11_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL11_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL11_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL11_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL11_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL11_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL11_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL11_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL11_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL11_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL11_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL11_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL11_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL11_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL11_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL11_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL11_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL11_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL11_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL11_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL11_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL11_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL11_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL11_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL11_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL11_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL11_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL11_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL11_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL11_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL11_SHRT_PCKT = 0x80000000

	// EPTCTL11_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 11)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL11_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL11_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL11_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL11_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL11_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL11_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL11_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL11_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL11_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL11_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL11_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL11_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL11_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL11_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL11_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL11_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL11_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL11_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL11_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL11_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL11_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL11_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL11_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL11_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL11_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL11_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL11_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL11_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL11_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL11_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL11_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL11_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL11_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL11_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL11_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL11_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL11_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL11_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL11_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL11_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL11_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL11_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA11: UDPHS Endpoint Set Status Register (endpoint = 11)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA11_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA11_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA11_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA11_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA11_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA11_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA11_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA11_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA11_TXRDY = 0x800

	// EPTSETSTA11_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 11)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA11_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA11_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA11_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA11_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA11_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA11_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA11: UDPHS Endpoint Clear Status Register (endpoint = 11)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA11_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA11_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA11_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA11_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA11_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA11_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA11_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA11_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA11_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA11_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA11_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA11_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA11_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA11_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA11_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA11_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA11_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA11_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA11_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA11_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA11_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA11_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA11_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA11_NAK_OUT = 0x8000

	// EPTCLRSTA11_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 11)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA11_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA11_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA11_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA11_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA11_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA11_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA11_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA11_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA11_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA11_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA11_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA11_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA11_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA11_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA11_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA11_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA11_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA11_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA11: UDPHS Endpoint Status Register (endpoint = 11)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA11_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA11_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA11_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA11_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA11_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA11_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA11_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA11_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA11_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA11_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA11_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA11_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA11_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA11_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA11_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA11_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA11_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA11_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA11_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA11_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA11_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA11_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA11_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA11_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA11_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA11_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA11_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA11_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA11_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA11_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA11_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA11_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA11_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA11_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA11_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA11_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA11_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA11_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA11_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA11_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA11_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA11_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA11_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA11_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA11_SHRT_PCKT = 0x80000000

	// EPTSTA11_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 11)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA11_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA11_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA11_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA11_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA11_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA11_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA11_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA11_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA11_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA11_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA11_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA11_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA11_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA11_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA11_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA11_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA11_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA11_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA11_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA11_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA11_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA11_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA11_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA11_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA11_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA11_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA11_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA11_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA11_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA11_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA11_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA11_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA11_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA11_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA11_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA11_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA11_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA11_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA11_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA11_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA11_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA11_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG12: UDPHS Endpoint Configuration Register (endpoint = 12)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG12_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG12_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG12_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG12_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG12_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG12_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG12_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG12_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG12_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG12_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG12_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG12_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG12_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG12_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG12_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG12_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG12_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG12_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG12_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG12_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG12_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG12_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG12_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG12_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG12_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG12_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG12_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG12_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG12_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG12_EPT_MAPD = 0x80000000

	// EPTCTLENB12: UDPHS Endpoint Control Enable Register (endpoint = 12)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB12_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB12_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB12_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB12_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB12_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB12_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB12_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB12_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB12_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB12_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB12_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB12_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB12_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB12_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB12_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB12_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB12_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB12_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB12_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB12_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB12_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB12_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB12_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB12_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB12_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB12_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB12_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB12_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB12_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB12_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB12_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB12_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB12_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB12_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB12_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB12_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB12_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB12_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB12_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB12_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB12_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB12_SHRT_PCKT = 0x80000000

	// EPTCTLENB12_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 12)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB12_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB12_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB12_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB12_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB12_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB12_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB12_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB12_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB12_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB12_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB12_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB12_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB12_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB12_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB12_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB12_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB12_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB12_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB12_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB12_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB12_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB12_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB12_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB12_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB12_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB12_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB12_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB12_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB12_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB12_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB12_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS12: UDPHS Endpoint Control Disable Register (endpoint = 12)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS12_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS12_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS12_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS12_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS12_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS12_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS12_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS12_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS12_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS12_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS12_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS12_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS12_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS12_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS12_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS12_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS12_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS12_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS12_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS12_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS12_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS12_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS12_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS12_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS12_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS12_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS12_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS12_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS12_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS12_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS12_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS12_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS12_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS12_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS12_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS12_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS12_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS12_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS12_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS12_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS12_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS12_SHRT_PCKT = 0x80000000

	// EPTCTLDIS12_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 12)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS12_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS12_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS12_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS12_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS12_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS12_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS12_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS12_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS12_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS12_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS12_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS12_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS12_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS12_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS12_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS12_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS12_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS12_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS12_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS12_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS12_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS12_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS12_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS12_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS12_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS12_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS12_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS12_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS12_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS12_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS12_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL12: UDPHS Endpoint Control Register (endpoint = 12)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL12_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL12_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL12_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL12_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL12_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL12_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL12_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL12_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL12_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL12_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL12_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL12_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL12_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL12_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL12_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL12_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL12_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL12_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL12_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL12_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL12_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL12_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL12_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL12_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL12_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL12_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL12_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL12_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL12_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL12_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL12_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL12_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL12_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL12_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL12_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL12_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL12_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL12_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL12_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL12_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL12_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL12_SHRT_PCKT = 0x80000000

	// EPTCTL12_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 12)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL12_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL12_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL12_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL12_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL12_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL12_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL12_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL12_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL12_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL12_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL12_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL12_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL12_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL12_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL12_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL12_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL12_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL12_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL12_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL12_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL12_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL12_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL12_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL12_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL12_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL12_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL12_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL12_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL12_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL12_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL12_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL12_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL12_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL12_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL12_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL12_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL12_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL12_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL12_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL12_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL12_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL12_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA12: UDPHS Endpoint Set Status Register (endpoint = 12)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA12_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA12_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA12_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA12_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA12_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA12_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA12_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA12_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA12_TXRDY = 0x800

	// EPTSETSTA12_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 12)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA12_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA12_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA12_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA12_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA12_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA12_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA12: UDPHS Endpoint Clear Status Register (endpoint = 12)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA12_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA12_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA12_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA12_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA12_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA12_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA12_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA12_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA12_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA12_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA12_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA12_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA12_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA12_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA12_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA12_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA12_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA12_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA12_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA12_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA12_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA12_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA12_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA12_NAK_OUT = 0x8000

	// EPTCLRSTA12_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 12)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA12_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA12_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA12_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA12_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA12_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA12_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA12_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA12_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA12_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA12_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA12_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA12_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA12_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA12_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA12_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA12_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA12_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA12_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA12: UDPHS Endpoint Status Register (endpoint = 12)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA12_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA12_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA12_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA12_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA12_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA12_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA12_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA12_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA12_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA12_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA12_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA12_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA12_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA12_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA12_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA12_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA12_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA12_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA12_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA12_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA12_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA12_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA12_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA12_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA12_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA12_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA12_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA12_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA12_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA12_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA12_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA12_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA12_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA12_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA12_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA12_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA12_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA12_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA12_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA12_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA12_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA12_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA12_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA12_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA12_SHRT_PCKT = 0x80000000

	// EPTSTA12_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 12)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA12_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA12_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA12_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA12_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA12_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA12_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA12_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA12_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA12_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA12_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA12_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA12_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA12_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA12_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA12_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA12_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA12_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA12_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA12_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA12_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA12_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA12_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA12_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA12_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA12_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA12_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA12_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA12_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA12_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA12_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA12_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA12_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA12_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA12_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA12_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA12_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA12_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA12_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA12_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA12_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA12_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA12_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG13: UDPHS Endpoint Configuration Register (endpoint = 13)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG13_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG13_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG13_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG13_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG13_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG13_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG13_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG13_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG13_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG13_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG13_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG13_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG13_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG13_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG13_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG13_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG13_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG13_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG13_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG13_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG13_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG13_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG13_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG13_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG13_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG13_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG13_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG13_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG13_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG13_EPT_MAPD = 0x80000000

	// EPTCTLENB13: UDPHS Endpoint Control Enable Register (endpoint = 13)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB13_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB13_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB13_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB13_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB13_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB13_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB13_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB13_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB13_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB13_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB13_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB13_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB13_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB13_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB13_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB13_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB13_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB13_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB13_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB13_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB13_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB13_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB13_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB13_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB13_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB13_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB13_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB13_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB13_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB13_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB13_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB13_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB13_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB13_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB13_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB13_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB13_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB13_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB13_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB13_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB13_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB13_SHRT_PCKT = 0x80000000

	// EPTCTLENB13_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 13)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB13_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB13_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB13_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB13_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB13_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB13_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB13_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB13_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB13_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB13_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB13_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB13_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB13_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB13_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB13_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB13_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB13_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB13_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB13_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB13_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB13_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB13_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB13_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB13_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB13_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB13_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB13_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB13_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB13_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB13_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB13_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS13: UDPHS Endpoint Control Disable Register (endpoint = 13)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS13_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS13_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS13_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS13_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS13_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS13_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS13_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS13_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS13_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS13_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS13_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS13_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS13_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS13_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS13_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS13_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS13_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS13_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS13_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS13_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS13_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS13_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS13_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS13_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS13_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS13_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS13_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS13_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS13_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS13_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS13_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS13_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS13_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS13_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS13_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS13_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS13_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS13_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS13_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS13_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS13_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS13_SHRT_PCKT = 0x80000000

	// EPTCTLDIS13_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 13)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS13_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS13_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS13_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS13_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS13_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS13_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS13_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS13_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS13_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS13_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS13_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS13_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS13_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS13_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS13_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS13_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS13_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS13_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS13_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS13_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS13_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS13_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS13_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS13_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS13_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS13_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS13_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS13_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS13_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS13_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS13_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL13: UDPHS Endpoint Control Register (endpoint = 13)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL13_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL13_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL13_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL13_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL13_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL13_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL13_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL13_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL13_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL13_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL13_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL13_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL13_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL13_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL13_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL13_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL13_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL13_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL13_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL13_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL13_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL13_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL13_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL13_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL13_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL13_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL13_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL13_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL13_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL13_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL13_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL13_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL13_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL13_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL13_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL13_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL13_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL13_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL13_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL13_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL13_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL13_SHRT_PCKT = 0x80000000

	// EPTCTL13_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 13)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL13_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL13_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL13_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL13_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL13_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL13_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL13_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL13_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL13_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL13_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL13_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL13_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL13_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL13_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL13_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL13_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL13_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL13_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL13_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL13_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL13_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL13_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL13_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL13_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL13_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL13_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL13_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL13_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL13_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL13_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL13_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL13_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL13_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL13_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL13_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL13_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL13_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL13_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL13_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL13_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL13_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL13_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA13: UDPHS Endpoint Set Status Register (endpoint = 13)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA13_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA13_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA13_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA13_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA13_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA13_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA13_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA13_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA13_TXRDY = 0x800

	// EPTSETSTA13_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 13)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA13_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA13_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA13_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA13_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA13_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA13_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA13: UDPHS Endpoint Clear Status Register (endpoint = 13)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA13_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA13_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA13_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA13_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA13_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA13_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA13_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA13_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA13_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA13_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA13_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA13_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA13_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA13_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA13_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA13_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA13_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA13_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA13_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA13_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA13_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA13_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA13_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA13_NAK_OUT = 0x8000

	// EPTCLRSTA13_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 13)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA13_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA13_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA13_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA13_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA13_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA13_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA13_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA13_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA13_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA13_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA13_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA13_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA13_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA13_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA13_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA13_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA13_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA13_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA13: UDPHS Endpoint Status Register (endpoint = 13)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA13_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA13_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA13_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA13_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA13_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA13_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA13_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA13_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA13_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA13_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA13_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA13_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA13_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA13_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA13_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA13_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA13_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA13_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA13_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA13_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA13_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA13_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA13_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA13_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA13_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA13_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA13_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA13_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA13_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA13_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA13_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA13_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA13_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA13_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA13_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA13_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA13_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA13_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA13_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA13_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA13_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA13_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA13_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA13_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA13_SHRT_PCKT = 0x80000000

	// EPTSTA13_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 13)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA13_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA13_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA13_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA13_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA13_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA13_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA13_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA13_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA13_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA13_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA13_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA13_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA13_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA13_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA13_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA13_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA13_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA13_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA13_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA13_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA13_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA13_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA13_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA13_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA13_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA13_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA13_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA13_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA13_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA13_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA13_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA13_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA13_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA13_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA13_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA13_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA13_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA13_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA13_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA13_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA13_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA13_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG14: UDPHS Endpoint Configuration Register (endpoint = 14)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG14_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG14_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG14_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG14_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG14_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG14_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG14_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG14_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG14_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG14_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG14_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG14_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG14_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG14_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG14_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG14_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG14_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG14_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG14_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG14_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG14_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG14_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG14_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG14_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG14_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG14_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG14_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG14_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG14_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG14_EPT_MAPD = 0x80000000

	// EPTCTLENB14: UDPHS Endpoint Control Enable Register (endpoint = 14)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB14_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB14_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB14_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB14_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB14_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB14_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB14_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB14_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB14_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB14_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB14_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB14_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB14_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB14_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB14_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB14_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB14_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB14_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB14_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB14_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB14_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB14_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB14_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB14_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB14_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB14_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB14_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB14_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB14_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB14_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB14_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB14_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB14_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB14_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB14_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB14_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB14_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB14_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB14_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB14_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB14_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB14_SHRT_PCKT = 0x80000000

	// EPTCTLENB14_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 14)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB14_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB14_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB14_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB14_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB14_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB14_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB14_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB14_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB14_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB14_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB14_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB14_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB14_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB14_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB14_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB14_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB14_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB14_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB14_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB14_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB14_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB14_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB14_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB14_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB14_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB14_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB14_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB14_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB14_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB14_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB14_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS14: UDPHS Endpoint Control Disable Register (endpoint = 14)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS14_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS14_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS14_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS14_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS14_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS14_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS14_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS14_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS14_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS14_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS14_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS14_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS14_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS14_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS14_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS14_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS14_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS14_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS14_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS14_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS14_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS14_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS14_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS14_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS14_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS14_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS14_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS14_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS14_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS14_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS14_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS14_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS14_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS14_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS14_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS14_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS14_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS14_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS14_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS14_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS14_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS14_SHRT_PCKT = 0x80000000

	// EPTCTLDIS14_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 14)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS14_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS14_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS14_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS14_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS14_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS14_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS14_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS14_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS14_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS14_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS14_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS14_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS14_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS14_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS14_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS14_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS14_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS14_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS14_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS14_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS14_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS14_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS14_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS14_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS14_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS14_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS14_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS14_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS14_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS14_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS14_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL14: UDPHS Endpoint Control Register (endpoint = 14)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL14_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL14_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL14_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL14_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL14_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL14_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL14_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL14_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL14_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL14_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL14_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL14_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL14_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL14_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL14_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL14_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL14_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL14_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL14_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL14_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL14_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL14_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL14_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL14_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL14_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL14_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL14_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL14_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL14_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL14_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL14_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL14_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL14_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL14_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL14_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL14_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL14_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL14_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL14_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL14_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL14_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL14_SHRT_PCKT = 0x80000000

	// EPTCTL14_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 14)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL14_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL14_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL14_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL14_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL14_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL14_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL14_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL14_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL14_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL14_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL14_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL14_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL14_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL14_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL14_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL14_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL14_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL14_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL14_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL14_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL14_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL14_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL14_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL14_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL14_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL14_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL14_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL14_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL14_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL14_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL14_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL14_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL14_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL14_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL14_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL14_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL14_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL14_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL14_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL14_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL14_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL14_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA14: UDPHS Endpoint Set Status Register (endpoint = 14)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA14_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA14_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA14_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA14_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA14_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA14_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA14_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA14_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA14_TXRDY = 0x800

	// EPTSETSTA14_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 14)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA14_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA14_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA14_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA14_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA14_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA14_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA14: UDPHS Endpoint Clear Status Register (endpoint = 14)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA14_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA14_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA14_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA14_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA14_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA14_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA14_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA14_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA14_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA14_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA14_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA14_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA14_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA14_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA14_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA14_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA14_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA14_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA14_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA14_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA14_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA14_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA14_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA14_NAK_OUT = 0x8000

	// EPTCLRSTA14_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 14)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA14_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA14_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA14_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA14_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA14_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA14_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA14_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA14_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA14_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA14_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA14_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA14_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA14_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA14_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA14_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA14_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA14_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA14_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA14: UDPHS Endpoint Status Register (endpoint = 14)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA14_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA14_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA14_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA14_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA14_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA14_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA14_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA14_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA14_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA14_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA14_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA14_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA14_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA14_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA14_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA14_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA14_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA14_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA14_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA14_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA14_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA14_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA14_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA14_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA14_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA14_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA14_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA14_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA14_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA14_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA14_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA14_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA14_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA14_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA14_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA14_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA14_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA14_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA14_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA14_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA14_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA14_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA14_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA14_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA14_SHRT_PCKT = 0x80000000

	// EPTSTA14_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 14)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA14_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA14_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA14_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA14_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA14_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA14_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA14_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA14_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA14_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA14_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA14_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA14_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA14_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA14_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA14_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA14_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA14_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA14_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA14_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA14_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA14_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA14_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA14_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA14_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA14_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA14_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA14_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA14_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA14_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA14_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA14_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA14_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA14_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA14_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA14_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA14_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA14_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA14_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA14_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA14_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA14_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA14_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCFG15: UDPHS Endpoint Configuration Register (endpoint = 15)
	// Position of EPT_SIZE field.
	UDPHS_EPTCFG15_EPT_SIZE_Pos = 0x0
	// Bit mask of EPT_SIZE field.
	UDPHS_EPTCFG15_EPT_SIZE_Msk = 0x7
	// 8 bytes
	UDPHS_EPTCFG15_EPT_SIZE_8 = 0x0
	// 16 bytes
	UDPHS_EPTCFG15_EPT_SIZE_16 = 0x1
	// 32 bytes
	UDPHS_EPTCFG15_EPT_SIZE_32 = 0x2
	// 64 bytes
	UDPHS_EPTCFG15_EPT_SIZE_64 = 0x3
	// 128 bytes
	UDPHS_EPTCFG15_EPT_SIZE_128 = 0x4
	// 256 bytes
	UDPHS_EPTCFG15_EPT_SIZE_256 = 0x5
	// 512 bytes
	UDPHS_EPTCFG15_EPT_SIZE_512 = 0x6
	// 1024 bytes
	UDPHS_EPTCFG15_EPT_SIZE_1024 = 0x7
	// Position of EPT_DIR field.
	UDPHS_EPTCFG15_EPT_DIR_Pos = 0x3
	// Bit mask of EPT_DIR field.
	UDPHS_EPTCFG15_EPT_DIR_Msk = 0x8
	// Bit EPT_DIR.
	UDPHS_EPTCFG15_EPT_DIR = 0x8
	// Position of EPT_TYPE field.
	UDPHS_EPTCFG15_EPT_TYPE_Pos = 0x4
	// Bit mask of EPT_TYPE field.
	UDPHS_EPTCFG15_EPT_TYPE_Msk = 0x30
	// Control endpoint
	UDPHS_EPTCFG15_EPT_TYPE_CTRL8 = 0x0
	// Isochronous endpoint
	UDPHS_EPTCFG15_EPT_TYPE_ISO = 0x1
	// Bulk endpoint
	UDPHS_EPTCFG15_EPT_TYPE_BULK = 0x2
	// Interrupt endpoint
	UDPHS_EPTCFG15_EPT_TYPE_INT = 0x3
	// Position of BK_NUMBER field.
	UDPHS_EPTCFG15_BK_NUMBER_Pos = 0x6
	// Bit mask of BK_NUMBER field.
	UDPHS_EPTCFG15_BK_NUMBER_Msk = 0xc0
	// Zero bank, the endpoint is not mapped in memory
	UDPHS_EPTCFG15_BK_NUMBER_0 = 0x0
	// One bank (bank 0)
	UDPHS_EPTCFG15_BK_NUMBER_1 = 0x1
	// Double bank (Ping-Pong: bank0/bank1)
	UDPHS_EPTCFG15_BK_NUMBER_2 = 0x2
	// Triple bank (bank0/bank1/bank2)
	UDPHS_EPTCFG15_BK_NUMBER_3 = 0x3
	// Position of NB_TRANS field.
	UDPHS_EPTCFG15_NB_TRANS_Pos = 0x8
	// Bit mask of NB_TRANS field.
	UDPHS_EPTCFG15_NB_TRANS_Msk = 0x300
	// Position of EPT_MAPD field.
	UDPHS_EPTCFG15_EPT_MAPD_Pos = 0x1f
	// Bit mask of EPT_MAPD field.
	UDPHS_EPTCFG15_EPT_MAPD_Msk = 0x80000000
	// Bit EPT_MAPD.
	UDPHS_EPTCFG15_EPT_MAPD = 0x80000000

	// EPTCTLENB15: UDPHS Endpoint Control Enable Register (endpoint = 15)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB15_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB15_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB15_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB15_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB15_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB15_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB15_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB15_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB15_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLENB15_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLENB15_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLENB15_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB15_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB15_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB15_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB15_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB15_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB15_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB15_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB15_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB15_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLENB15_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLENB15_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLENB15_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLENB15_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLENB15_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLENB15_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLENB15_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLENB15_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLENB15_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLENB15_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLENB15_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLENB15_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLENB15_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLENB15_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLENB15_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB15_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB15_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB15_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB15_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB15_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB15_SHRT_PCKT = 0x80000000

	// EPTCTLENB15_ISOENDPT: UDPHS Endpoint Control Enable Register (endpoint = 15)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTLENB15_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTLENB15_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTLENB15_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLENB15_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLENB15_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLENB15_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLENB15_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLENB15_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLENB15_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLENB15_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLENB15_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLENB15_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLENB15_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLENB15_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLENB15_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLENB15_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLENB15_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLENB15_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLENB15_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLENB15_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLENB15_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLENB15_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLENB15_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLENB15_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLENB15_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLENB15_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLENB15_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLENB15_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLENB15_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLENB15_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLENB15_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTLDIS15: UDPHS Endpoint Control Disable Register (endpoint = 15)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS15_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS15_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS15_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS15_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS15_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS15_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS15_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS15_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS15_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTLDIS15_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTLDIS15_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTLDIS15_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS15_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS15_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS15_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS15_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS15_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS15_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS15_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS15_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS15_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTLDIS15_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTLDIS15_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTLDIS15_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTLDIS15_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTLDIS15_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTLDIS15_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTLDIS15_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTLDIS15_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTLDIS15_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTLDIS15_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTLDIS15_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTLDIS15_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTLDIS15_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTLDIS15_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTLDIS15_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS15_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS15_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS15_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS15_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS15_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS15_SHRT_PCKT = 0x80000000

	// EPTCTLDIS15_ISOENDPT: UDPHS Endpoint Control Disable Register (endpoint = 15)
	// Position of EPT_DISABL field.
	UDPHS_EPTCTLDIS15_ISOENDPT_EPT_DISABL_Pos = 0x0
	// Bit mask of EPT_DISABL field.
	UDPHS_EPTCTLDIS15_ISOENDPT_EPT_DISABL_Msk = 0x1
	// Bit EPT_DISABL.
	UDPHS_EPTCTLDIS15_ISOENDPT_EPT_DISABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTLDIS15_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTLDIS15_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTLDIS15_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTLDIS15_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTLDIS15_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTLDIS15_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTLDIS15_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTLDIS15_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTLDIS15_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTLDIS15_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTLDIS15_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTLDIS15_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS15_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTLDIS15_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTLDIS15_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTLDIS15_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTLDIS15_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTLDIS15_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTLDIS15_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTLDIS15_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTLDIS15_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTLDIS15_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTLDIS15_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTLDIS15_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTLDIS15_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTLDIS15_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTLDIS15_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTLDIS15_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTCTL15: UDPHS Endpoint Control Register (endpoint = 15)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL15_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL15_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL15_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL15_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL15_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL15_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL15_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL15_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL15_INTDIS_DMA = 0x8
	// Position of NYET_DIS field.
	UDPHS_EPTCTL15_NYET_DIS_Pos = 0x4
	// Bit mask of NYET_DIS field.
	UDPHS_EPTCTL15_NYET_DIS_Msk = 0x10
	// Bit NYET_DIS.
	UDPHS_EPTCTL15_NYET_DIS = 0x10
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL15_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL15_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL15_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL15_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL15_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL15_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL15_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL15_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL15_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTCTL15_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTCTL15_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTCTL15_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTCTL15_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCTL15_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCTL15_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCTL15_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCTL15_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCTL15_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCTL15_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCTL15_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCTL15_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCTL15_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCTL15_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCTL15_NAK_OUT = 0x8000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL15_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL15_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL15_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL15_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL15_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL15_SHRT_PCKT = 0x80000000

	// EPTCTL15_ISOENDPT: UDPHS Endpoint Control Register (endpoint = 15)
	// Position of EPT_ENABL field.
	UDPHS_EPTCTL15_ISOENDPT_EPT_ENABL_Pos = 0x0
	// Bit mask of EPT_ENABL field.
	UDPHS_EPTCTL15_ISOENDPT_EPT_ENABL_Msk = 0x1
	// Bit EPT_ENABL.
	UDPHS_EPTCTL15_ISOENDPT_EPT_ENABL = 0x1
	// Position of AUTO_VALID field.
	UDPHS_EPTCTL15_ISOENDPT_AUTO_VALID_Pos = 0x1
	// Bit mask of AUTO_VALID field.
	UDPHS_EPTCTL15_ISOENDPT_AUTO_VALID_Msk = 0x2
	// Bit AUTO_VALID.
	UDPHS_EPTCTL15_ISOENDPT_AUTO_VALID = 0x2
	// Position of INTDIS_DMA field.
	UDPHS_EPTCTL15_ISOENDPT_INTDIS_DMA_Pos = 0x3
	// Bit mask of INTDIS_DMA field.
	UDPHS_EPTCTL15_ISOENDPT_INTDIS_DMA_Msk = 0x8
	// Bit INTDIS_DMA.
	UDPHS_EPTCTL15_ISOENDPT_INTDIS_DMA = 0x8
	// Position of DATAX_RX field.
	UDPHS_EPTCTL15_ISOENDPT_DATAX_RX_Pos = 0x6
	// Bit mask of DATAX_RX field.
	UDPHS_EPTCTL15_ISOENDPT_DATAX_RX_Msk = 0x40
	// Bit DATAX_RX.
	UDPHS_EPTCTL15_ISOENDPT_DATAX_RX = 0x40
	// Position of MDATA_RX field.
	UDPHS_EPTCTL15_ISOENDPT_MDATA_RX_Pos = 0x7
	// Bit mask of MDATA_RX field.
	UDPHS_EPTCTL15_ISOENDPT_MDATA_RX_Msk = 0x80
	// Bit MDATA_RX.
	UDPHS_EPTCTL15_ISOENDPT_MDATA_RX = 0x80
	// Position of ERR_OVFLW field.
	UDPHS_EPTCTL15_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTCTL15_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTCTL15_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCTL15_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCTL15_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCTL15_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCTL15_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCTL15_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCTL15_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTCTL15_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTCTL15_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTCTL15_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCTL15_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCTL15_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCTL15_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCTL15_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCTL15_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCTL15_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCTL15_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCTL15_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCTL15_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of BUSY_BANK field.
	UDPHS_EPTCTL15_ISOENDPT_BUSY_BANK_Pos = 0x12
	// Bit mask of BUSY_BANK field.
	UDPHS_EPTCTL15_ISOENDPT_BUSY_BANK_Msk = 0x40000
	// Bit BUSY_BANK.
	UDPHS_EPTCTL15_ISOENDPT_BUSY_BANK = 0x40000
	// Position of SHRT_PCKT field.
	UDPHS_EPTCTL15_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTCTL15_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTCTL15_ISOENDPT_SHRT_PCKT = 0x80000000

	// EPTSETSTA15: UDPHS Endpoint Set Status Register (endpoint = 15)
	// Position of FRCESTALL field.
	UDPHS_EPTSETSTA15_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSETSTA15_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSETSTA15_FRCESTALL = 0x20
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA15_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA15_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA15_RXRDY_TXKL = 0x200
	// Position of TXRDY field.
	UDPHS_EPTSETSTA15_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSETSTA15_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSETSTA15_TXRDY = 0x800

	// EPTSETSTA15_ISOENDPT: UDPHS Endpoint Set Status Register (endpoint = 15)
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSETSTA15_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSETSTA15_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSETSTA15_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TXRDY_TRER field.
	UDPHS_EPTSETSTA15_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSETSTA15_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSETSTA15_ISOENDPT_TXRDY_TRER = 0x800

	// EPTCLRSTA15: UDPHS Endpoint Clear Status Register (endpoint = 15)
	// Position of FRCESTALL field.
	UDPHS_EPTCLRSTA15_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTCLRSTA15_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTCLRSTA15_FRCESTALL = 0x20
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA15_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA15_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA15_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA15_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA15_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA15_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA15_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA15_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA15_TX_COMPLT = 0x400
	// Position of RX_SETUP field.
	UDPHS_EPTCLRSTA15_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTCLRSTA15_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTCLRSTA15_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTCLRSTA15_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTCLRSTA15_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTCLRSTA15_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTCLRSTA15_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTCLRSTA15_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTCLRSTA15_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTCLRSTA15_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTCLRSTA15_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTCLRSTA15_NAK_OUT = 0x8000

	// EPTCLRSTA15_ISOENDPT: UDPHS Endpoint Clear Status Register (endpoint = 15)
	// Position of TOGGLESQ field.
	UDPHS_EPTCLRSTA15_ISOENDPT_TOGGLESQ_Pos = 0x6
	// Bit mask of TOGGLESQ field.
	UDPHS_EPTCLRSTA15_ISOENDPT_TOGGLESQ_Msk = 0x40
	// Bit TOGGLESQ.
	UDPHS_EPTCLRSTA15_ISOENDPT_TOGGLESQ = 0x40
	// Position of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA15_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTCLRSTA15_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTCLRSTA15_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTCLRSTA15_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTCLRSTA15_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTCLRSTA15_ISOENDPT_TX_COMPLT = 0x400
	// Position of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA15_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTCLRSTA15_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTCLRSTA15_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA15_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTCLRSTA15_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTCLRSTA15_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTCLRSTA15_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTCLRSTA15_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTCLRSTA15_ISOENDPT_ERR_FLUSH = 0x4000

	// EPTSTA15: UDPHS Endpoint Status Register (endpoint = 15)
	// Position of FRCESTALL field.
	UDPHS_EPTSTA15_FRCESTALL_Pos = 0x5
	// Bit mask of FRCESTALL field.
	UDPHS_EPTSTA15_FRCESTALL_Msk = 0x20
	// Bit FRCESTALL.
	UDPHS_EPTSTA15_FRCESTALL = 0x20
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA15_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA15_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA15_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA15_TOGGLESQ_STA_DATA1 = 0x1
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA15_TOGGLESQ_STA_DATA2 = 0x2
	// Reserved for High Bandwidth Isochronous Endpoint
	UDPHS_EPTSTA15_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA15_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA15_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA15_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA15_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA15_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA15_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA15_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA15_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA15_TX_COMPLT = 0x400
	// Position of TXRDY field.
	UDPHS_EPTSTA15_TXRDY_Pos = 0xb
	// Bit mask of TXRDY field.
	UDPHS_EPTSTA15_TXRDY_Msk = 0x800
	// Bit TXRDY.
	UDPHS_EPTSTA15_TXRDY = 0x800
	// Position of RX_SETUP field.
	UDPHS_EPTSTA15_RX_SETUP_Pos = 0xc
	// Bit mask of RX_SETUP field.
	UDPHS_EPTSTA15_RX_SETUP_Msk = 0x1000
	// Bit RX_SETUP.
	UDPHS_EPTSTA15_RX_SETUP = 0x1000
	// Position of STALL_SNT field.
	UDPHS_EPTSTA15_STALL_SNT_Pos = 0xd
	// Bit mask of STALL_SNT field.
	UDPHS_EPTSTA15_STALL_SNT_Msk = 0x2000
	// Bit STALL_SNT.
	UDPHS_EPTSTA15_STALL_SNT = 0x2000
	// Position of NAK_IN field.
	UDPHS_EPTSTA15_NAK_IN_Pos = 0xe
	// Bit mask of NAK_IN field.
	UDPHS_EPTSTA15_NAK_IN_Msk = 0x4000
	// Bit NAK_IN.
	UDPHS_EPTSTA15_NAK_IN = 0x4000
	// Position of NAK_OUT field.
	UDPHS_EPTSTA15_NAK_OUT_Pos = 0xf
	// Bit mask of NAK_OUT field.
	UDPHS_EPTSTA15_NAK_OUT_Msk = 0x8000
	// Bit NAK_OUT.
	UDPHS_EPTSTA15_NAK_OUT = 0x8000
	// Position of CURBK_CTLDIR field.
	UDPHS_EPTSTA15_CURBK_CTLDIR_Pos = 0x10
	// Bit mask of CURBK_CTLDIR field.
	UDPHS_EPTSTA15_CURBK_CTLDIR_Msk = 0x30000
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA15_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA15_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA15_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA15_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA15_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA15_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA15_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA15_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA15_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA15_SHRT_PCKT = 0x80000000

	// EPTSTA15_ISOENDPT: UDPHS Endpoint Status Register (endpoint = 15)
	// Position of TOGGLESQ_STA field.
	UDPHS_EPTSTA15_ISOENDPT_TOGGLESQ_STA_Pos = 0x6
	// Bit mask of TOGGLESQ_STA field.
	UDPHS_EPTSTA15_ISOENDPT_TOGGLESQ_STA_Msk = 0xc0
	// DATA0
	UDPHS_EPTSTA15_ISOENDPT_TOGGLESQ_STA_DATA0 = 0x0
	// DATA1
	UDPHS_EPTSTA15_ISOENDPT_TOGGLESQ_STA_DATA1 = 0x1
	// Data2 (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA15_ISOENDPT_TOGGLESQ_STA_DATA2 = 0x2
	// MData (only for High Bandwidth Isochronous Endpoint)
	UDPHS_EPTSTA15_ISOENDPT_TOGGLESQ_STA_MDATA = 0x3
	// Position of ERR_OVFLW field.
	UDPHS_EPTSTA15_ISOENDPT_ERR_OVFLW_Pos = 0x8
	// Bit mask of ERR_OVFLW field.
	UDPHS_EPTSTA15_ISOENDPT_ERR_OVFLW_Msk = 0x100
	// Bit ERR_OVFLW.
	UDPHS_EPTSTA15_ISOENDPT_ERR_OVFLW = 0x100
	// Position of RXRDY_TXKL field.
	UDPHS_EPTSTA15_ISOENDPT_RXRDY_TXKL_Pos = 0x9
	// Bit mask of RXRDY_TXKL field.
	UDPHS_EPTSTA15_ISOENDPT_RXRDY_TXKL_Msk = 0x200
	// Bit RXRDY_TXKL.
	UDPHS_EPTSTA15_ISOENDPT_RXRDY_TXKL = 0x200
	// Position of TX_COMPLT field.
	UDPHS_EPTSTA15_ISOENDPT_TX_COMPLT_Pos = 0xa
	// Bit mask of TX_COMPLT field.
	UDPHS_EPTSTA15_ISOENDPT_TX_COMPLT_Msk = 0x400
	// Bit TX_COMPLT.
	UDPHS_EPTSTA15_ISOENDPT_TX_COMPLT = 0x400
	// Position of TXRDY_TRER field.
	UDPHS_EPTSTA15_ISOENDPT_TXRDY_TRER_Pos = 0xb
	// Bit mask of TXRDY_TRER field.
	UDPHS_EPTSTA15_ISOENDPT_TXRDY_TRER_Msk = 0x800
	// Bit TXRDY_TRER.
	UDPHS_EPTSTA15_ISOENDPT_TXRDY_TRER = 0x800
	// Position of ERR_FL_ISO field.
	UDPHS_EPTSTA15_ISOENDPT_ERR_FL_ISO_Pos = 0xc
	// Bit mask of ERR_FL_ISO field.
	UDPHS_EPTSTA15_ISOENDPT_ERR_FL_ISO_Msk = 0x1000
	// Bit ERR_FL_ISO.
	UDPHS_EPTSTA15_ISOENDPT_ERR_FL_ISO = 0x1000
	// Position of ERR_CRC_NTR field.
	UDPHS_EPTSTA15_ISOENDPT_ERR_CRC_NTR_Pos = 0xd
	// Bit mask of ERR_CRC_NTR field.
	UDPHS_EPTSTA15_ISOENDPT_ERR_CRC_NTR_Msk = 0x2000
	// Bit ERR_CRC_NTR.
	UDPHS_EPTSTA15_ISOENDPT_ERR_CRC_NTR = 0x2000
	// Position of ERR_FLUSH field.
	UDPHS_EPTSTA15_ISOENDPT_ERR_FLUSH_Pos = 0xe
	// Bit mask of ERR_FLUSH field.
	UDPHS_EPTSTA15_ISOENDPT_ERR_FLUSH_Msk = 0x4000
	// Bit ERR_FLUSH.
	UDPHS_EPTSTA15_ISOENDPT_ERR_FLUSH = 0x4000
	// Position of CURBK field.
	UDPHS_EPTSTA15_ISOENDPT_CURBK_Pos = 0x10
	// Bit mask of CURBK field.
	UDPHS_EPTSTA15_ISOENDPT_CURBK_Msk = 0x30000
	// Bank 0 (or single bank)
	UDPHS_EPTSTA15_ISOENDPT_CURBK_BANK0 = 0x0
	// Bank 1
	UDPHS_EPTSTA15_ISOENDPT_CURBK_BANK1 = 0x1
	// Bank 2
	UDPHS_EPTSTA15_ISOENDPT_CURBK_BANK2 = 0x2
	// Position of BUSY_BANK_STA field.
	UDPHS_EPTSTA15_ISOENDPT_BUSY_BANK_STA_Pos = 0x12
	// Bit mask of BUSY_BANK_STA field.
	UDPHS_EPTSTA15_ISOENDPT_BUSY_BANK_STA_Msk = 0xc0000
	// 1 busy bank
	UDPHS_EPTSTA15_ISOENDPT_BUSY_BANK_STA_1BUSYBANK = 0x0
	// 2 busy banks
	UDPHS_EPTSTA15_ISOENDPT_BUSY_BANK_STA_2BUSYBANKS = 0x1
	// 3 busy banks
	UDPHS_EPTSTA15_ISOENDPT_BUSY_BANK_STA_3BUSYBANKS = 0x2
	// Position of BYTE_COUNT field.
	UDPHS_EPTSTA15_ISOENDPT_BYTE_COUNT_Pos = 0x14
	// Bit mask of BYTE_COUNT field.
	UDPHS_EPTSTA15_ISOENDPT_BYTE_COUNT_Msk = 0x7ff00000
	// Position of SHRT_PCKT field.
	UDPHS_EPTSTA15_ISOENDPT_SHRT_PCKT_Pos = 0x1f
	// Bit mask of SHRT_PCKT field.
	UDPHS_EPTSTA15_ISOENDPT_SHRT_PCKT_Msk = 0x80000000
	// Bit SHRT_PCKT.
	UDPHS_EPTSTA15_ISOENDPT_SHRT_PCKT = 0x80000000

	// DMANXTDSC0: UDPHS DMA Next Descriptor Address Register (channel = 0)
	// Position of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC0_NXT_DSC_ADD_Pos = 0x0
	// Bit mask of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC0_NXT_DSC_ADD_Msk = 0xffffffff

	// DMAADDRESS0: UDPHS DMA Channel Address Register (channel = 0)
	// Position of BUFF_ADD field.
	UDPHS_DMAADDRESS0_BUFF_ADD_Pos = 0x0
	// Bit mask of BUFF_ADD field.
	UDPHS_DMAADDRESS0_BUFF_ADD_Msk = 0xffffffff

	// DMACONTROL0: UDPHS DMA Channel Control Register (channel = 0)
	// Position of CHANN_ENB field.
	UDPHS_DMACONTROL0_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMACONTROL0_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMACONTROL0_CHANN_ENB = 0x1
	// Position of LDNXT_DSC field.
	UDPHS_DMACONTROL0_LDNXT_DSC_Pos = 0x1
	// Bit mask of LDNXT_DSC field.
	UDPHS_DMACONTROL0_LDNXT_DSC_Msk = 0x2
	// Bit LDNXT_DSC.
	UDPHS_DMACONTROL0_LDNXT_DSC = 0x2
	// Position of END_TR_EN field.
	UDPHS_DMACONTROL0_END_TR_EN_Pos = 0x2
	// Bit mask of END_TR_EN field.
	UDPHS_DMACONTROL0_END_TR_EN_Msk = 0x4
	// Bit END_TR_EN.
	UDPHS_DMACONTROL0_END_TR_EN = 0x4
	// Position of END_B_EN field.
	UDPHS_DMACONTROL0_END_B_EN_Pos = 0x3
	// Bit mask of END_B_EN field.
	UDPHS_DMACONTROL0_END_B_EN_Msk = 0x8
	// Bit END_B_EN.
	UDPHS_DMACONTROL0_END_B_EN = 0x8
	// Position of END_TR_IT field.
	UDPHS_DMACONTROL0_END_TR_IT_Pos = 0x4
	// Bit mask of END_TR_IT field.
	UDPHS_DMACONTROL0_END_TR_IT_Msk = 0x10
	// Bit END_TR_IT.
	UDPHS_DMACONTROL0_END_TR_IT = 0x10
	// Position of END_BUFFIT field.
	UDPHS_DMACONTROL0_END_BUFFIT_Pos = 0x5
	// Bit mask of END_BUFFIT field.
	UDPHS_DMACONTROL0_END_BUFFIT_Msk = 0x20
	// Bit END_BUFFIT.
	UDPHS_DMACONTROL0_END_BUFFIT = 0x20
	// Position of DESC_LD_IT field.
	UDPHS_DMACONTROL0_DESC_LD_IT_Pos = 0x6
	// Bit mask of DESC_LD_IT field.
	UDPHS_DMACONTROL0_DESC_LD_IT_Msk = 0x40
	// Bit DESC_LD_IT.
	UDPHS_DMACONTROL0_DESC_LD_IT = 0x40
	// Position of BURST_LCK field.
	UDPHS_DMACONTROL0_BURST_LCK_Pos = 0x7
	// Bit mask of BURST_LCK field.
	UDPHS_DMACONTROL0_BURST_LCK_Msk = 0x80
	// Bit BURST_LCK.
	UDPHS_DMACONTROL0_BURST_LCK = 0x80
	// Position of BUFF_LENGTH field.
	UDPHS_DMACONTROL0_BUFF_LENGTH_Pos = 0x10
	// Bit mask of BUFF_LENGTH field.
	UDPHS_DMACONTROL0_BUFF_LENGTH_Msk = 0xffff0000

	// DMASTATUS0: UDPHS DMA Channel Status Register (channel = 0)
	// Position of CHANN_ENB field.
	UDPHS_DMASTATUS0_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMASTATUS0_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMASTATUS0_CHANN_ENB = 0x1
	// Position of CHANN_ACT field.
	UDPHS_DMASTATUS0_CHANN_ACT_Pos = 0x1
	// Bit mask of CHANN_ACT field.
	UDPHS_DMASTATUS0_CHANN_ACT_Msk = 0x2
	// Bit CHANN_ACT.
	UDPHS_DMASTATUS0_CHANN_ACT = 0x2
	// Position of END_TR_ST field.
	UDPHS_DMASTATUS0_END_TR_ST_Pos = 0x4
	// Bit mask of END_TR_ST field.
	UDPHS_DMASTATUS0_END_TR_ST_Msk = 0x10
	// Bit END_TR_ST.
	UDPHS_DMASTATUS0_END_TR_ST = 0x10
	// Position of END_BF_ST field.
	UDPHS_DMASTATUS0_END_BF_ST_Pos = 0x5
	// Bit mask of END_BF_ST field.
	UDPHS_DMASTATUS0_END_BF_ST_Msk = 0x20
	// Bit END_BF_ST.
	UDPHS_DMASTATUS0_END_BF_ST = 0x20
	// Position of DESC_LDST field.
	UDPHS_DMASTATUS0_DESC_LDST_Pos = 0x6
	// Bit mask of DESC_LDST field.
	UDPHS_DMASTATUS0_DESC_LDST_Msk = 0x40
	// Bit DESC_LDST.
	UDPHS_DMASTATUS0_DESC_LDST = 0x40
	// Position of BUFF_COUNT field.
	UDPHS_DMASTATUS0_BUFF_COUNT_Pos = 0x10
	// Bit mask of BUFF_COUNT field.
	UDPHS_DMASTATUS0_BUFF_COUNT_Msk = 0xffff0000

	// DMANXTDSC1: UDPHS DMA Next Descriptor Address Register (channel = 1)
	// Position of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC1_NXT_DSC_ADD_Pos = 0x0
	// Bit mask of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC1_NXT_DSC_ADD_Msk = 0xffffffff

	// DMAADDRESS1: UDPHS DMA Channel Address Register (channel = 1)
	// Position of BUFF_ADD field.
	UDPHS_DMAADDRESS1_BUFF_ADD_Pos = 0x0
	// Bit mask of BUFF_ADD field.
	UDPHS_DMAADDRESS1_BUFF_ADD_Msk = 0xffffffff

	// DMACONTROL1: UDPHS DMA Channel Control Register (channel = 1)
	// Position of CHANN_ENB field.
	UDPHS_DMACONTROL1_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMACONTROL1_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMACONTROL1_CHANN_ENB = 0x1
	// Position of LDNXT_DSC field.
	UDPHS_DMACONTROL1_LDNXT_DSC_Pos = 0x1
	// Bit mask of LDNXT_DSC field.
	UDPHS_DMACONTROL1_LDNXT_DSC_Msk = 0x2
	// Bit LDNXT_DSC.
	UDPHS_DMACONTROL1_LDNXT_DSC = 0x2
	// Position of END_TR_EN field.
	UDPHS_DMACONTROL1_END_TR_EN_Pos = 0x2
	// Bit mask of END_TR_EN field.
	UDPHS_DMACONTROL1_END_TR_EN_Msk = 0x4
	// Bit END_TR_EN.
	UDPHS_DMACONTROL1_END_TR_EN = 0x4
	// Position of END_B_EN field.
	UDPHS_DMACONTROL1_END_B_EN_Pos = 0x3
	// Bit mask of END_B_EN field.
	UDPHS_DMACONTROL1_END_B_EN_Msk = 0x8
	// Bit END_B_EN.
	UDPHS_DMACONTROL1_END_B_EN = 0x8
	// Position of END_TR_IT field.
	UDPHS_DMACONTROL1_END_TR_IT_Pos = 0x4
	// Bit mask of END_TR_IT field.
	UDPHS_DMACONTROL1_END_TR_IT_Msk = 0x10
	// Bit END_TR_IT.
	UDPHS_DMACONTROL1_END_TR_IT = 0x10
	// Position of END_BUFFIT field.
	UDPHS_DMACONTROL1_END_BUFFIT_Pos = 0x5
	// Bit mask of END_BUFFIT field.
	UDPHS_DMACONTROL1_END_BUFFIT_Msk = 0x20
	// Bit END_BUFFIT.
	UDPHS_DMACONTROL1_END_BUFFIT = 0x20
	// Position of DESC_LD_IT field.
	UDPHS_DMACONTROL1_DESC_LD_IT_Pos = 0x6
	// Bit mask of DESC_LD_IT field.
	UDPHS_DMACONTROL1_DESC_LD_IT_Msk = 0x40
	// Bit DESC_LD_IT.
	UDPHS_DMACONTROL1_DESC_LD_IT = 0x40
	// Position of BURST_LCK field.
	UDPHS_DMACONTROL1_BURST_LCK_Pos = 0x7
	// Bit mask of BURST_LCK field.
	UDPHS_DMACONTROL1_BURST_LCK_Msk = 0x80
	// Bit BURST_LCK.
	UDPHS_DMACONTROL1_BURST_LCK = 0x80
	// Position of BUFF_LENGTH field.
	UDPHS_DMACONTROL1_BUFF_LENGTH_Pos = 0x10
	// Bit mask of BUFF_LENGTH field.
	UDPHS_DMACONTROL1_BUFF_LENGTH_Msk = 0xffff0000

	// DMASTATUS1: UDPHS DMA Channel Status Register (channel = 1)
	// Position of CHANN_ENB field.
	UDPHS_DMASTATUS1_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMASTATUS1_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMASTATUS1_CHANN_ENB = 0x1
	// Position of CHANN_ACT field.
	UDPHS_DMASTATUS1_CHANN_ACT_Pos = 0x1
	// Bit mask of CHANN_ACT field.
	UDPHS_DMASTATUS1_CHANN_ACT_Msk = 0x2
	// Bit CHANN_ACT.
	UDPHS_DMASTATUS1_CHANN_ACT = 0x2
	// Position of END_TR_ST field.
	UDPHS_DMASTATUS1_END_TR_ST_Pos = 0x4
	// Bit mask of END_TR_ST field.
	UDPHS_DMASTATUS1_END_TR_ST_Msk = 0x10
	// Bit END_TR_ST.
	UDPHS_DMASTATUS1_END_TR_ST = 0x10
	// Position of END_BF_ST field.
	UDPHS_DMASTATUS1_END_BF_ST_Pos = 0x5
	// Bit mask of END_BF_ST field.
	UDPHS_DMASTATUS1_END_BF_ST_Msk = 0x20
	// Bit END_BF_ST.
	UDPHS_DMASTATUS1_END_BF_ST = 0x20
	// Position of DESC_LDST field.
	UDPHS_DMASTATUS1_DESC_LDST_Pos = 0x6
	// Bit mask of DESC_LDST field.
	UDPHS_DMASTATUS1_DESC_LDST_Msk = 0x40
	// Bit DESC_LDST.
	UDPHS_DMASTATUS1_DESC_LDST = 0x40
	// Position of BUFF_COUNT field.
	UDPHS_DMASTATUS1_BUFF_COUNT_Pos = 0x10
	// Bit mask of BUFF_COUNT field.
	UDPHS_DMASTATUS1_BUFF_COUNT_Msk = 0xffff0000

	// DMANXTDSC2: UDPHS DMA Next Descriptor Address Register (channel = 2)
	// Position of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC2_NXT_DSC_ADD_Pos = 0x0
	// Bit mask of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC2_NXT_DSC_ADD_Msk = 0xffffffff

	// DMAADDRESS2: UDPHS DMA Channel Address Register (channel = 2)
	// Position of BUFF_ADD field.
	UDPHS_DMAADDRESS2_BUFF_ADD_Pos = 0x0
	// Bit mask of BUFF_ADD field.
	UDPHS_DMAADDRESS2_BUFF_ADD_Msk = 0xffffffff

	// DMACONTROL2: UDPHS DMA Channel Control Register (channel = 2)
	// Position of CHANN_ENB field.
	UDPHS_DMACONTROL2_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMACONTROL2_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMACONTROL2_CHANN_ENB = 0x1
	// Position of LDNXT_DSC field.
	UDPHS_DMACONTROL2_LDNXT_DSC_Pos = 0x1
	// Bit mask of LDNXT_DSC field.
	UDPHS_DMACONTROL2_LDNXT_DSC_Msk = 0x2
	// Bit LDNXT_DSC.
	UDPHS_DMACONTROL2_LDNXT_DSC = 0x2
	// Position of END_TR_EN field.
	UDPHS_DMACONTROL2_END_TR_EN_Pos = 0x2
	// Bit mask of END_TR_EN field.
	UDPHS_DMACONTROL2_END_TR_EN_Msk = 0x4
	// Bit END_TR_EN.
	UDPHS_DMACONTROL2_END_TR_EN = 0x4
	// Position of END_B_EN field.
	UDPHS_DMACONTROL2_END_B_EN_Pos = 0x3
	// Bit mask of END_B_EN field.
	UDPHS_DMACONTROL2_END_B_EN_Msk = 0x8
	// Bit END_B_EN.
	UDPHS_DMACONTROL2_END_B_EN = 0x8
	// Position of END_TR_IT field.
	UDPHS_DMACONTROL2_END_TR_IT_Pos = 0x4
	// Bit mask of END_TR_IT field.
	UDPHS_DMACONTROL2_END_TR_IT_Msk = 0x10
	// Bit END_TR_IT.
	UDPHS_DMACONTROL2_END_TR_IT = 0x10
	// Position of END_BUFFIT field.
	UDPHS_DMACONTROL2_END_BUFFIT_Pos = 0x5
	// Bit mask of END_BUFFIT field.
	UDPHS_DMACONTROL2_END_BUFFIT_Msk = 0x20
	// Bit END_BUFFIT.
	UDPHS_DMACONTROL2_END_BUFFIT = 0x20
	// Position of DESC_LD_IT field.
	UDPHS_DMACONTROL2_DESC_LD_IT_Pos = 0x6
	// Bit mask of DESC_LD_IT field.
	UDPHS_DMACONTROL2_DESC_LD_IT_Msk = 0x40
	// Bit DESC_LD_IT.
	UDPHS_DMACONTROL2_DESC_LD_IT = 0x40
	// Position of BURST_LCK field.
	UDPHS_DMACONTROL2_BURST_LCK_Pos = 0x7
	// Bit mask of BURST_LCK field.
	UDPHS_DMACONTROL2_BURST_LCK_Msk = 0x80
	// Bit BURST_LCK.
	UDPHS_DMACONTROL2_BURST_LCK = 0x80
	// Position of BUFF_LENGTH field.
	UDPHS_DMACONTROL2_BUFF_LENGTH_Pos = 0x10
	// Bit mask of BUFF_LENGTH field.
	UDPHS_DMACONTROL2_BUFF_LENGTH_Msk = 0xffff0000

	// DMASTATUS2: UDPHS DMA Channel Status Register (channel = 2)
	// Position of CHANN_ENB field.
	UDPHS_DMASTATUS2_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMASTATUS2_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMASTATUS2_CHANN_ENB = 0x1
	// Position of CHANN_ACT field.
	UDPHS_DMASTATUS2_CHANN_ACT_Pos = 0x1
	// Bit mask of CHANN_ACT field.
	UDPHS_DMASTATUS2_CHANN_ACT_Msk = 0x2
	// Bit CHANN_ACT.
	UDPHS_DMASTATUS2_CHANN_ACT = 0x2
	// Position of END_TR_ST field.
	UDPHS_DMASTATUS2_END_TR_ST_Pos = 0x4
	// Bit mask of END_TR_ST field.
	UDPHS_DMASTATUS2_END_TR_ST_Msk = 0x10
	// Bit END_TR_ST.
	UDPHS_DMASTATUS2_END_TR_ST = 0x10
	// Position of END_BF_ST field.
	UDPHS_DMASTATUS2_END_BF_ST_Pos = 0x5
	// Bit mask of END_BF_ST field.
	UDPHS_DMASTATUS2_END_BF_ST_Msk = 0x20
	// Bit END_BF_ST.
	UDPHS_DMASTATUS2_END_BF_ST = 0x20
	// Position of DESC_LDST field.
	UDPHS_DMASTATUS2_DESC_LDST_Pos = 0x6
	// Bit mask of DESC_LDST field.
	UDPHS_DMASTATUS2_DESC_LDST_Msk = 0x40
	// Bit DESC_LDST.
	UDPHS_DMASTATUS2_DESC_LDST = 0x40
	// Position of BUFF_COUNT field.
	UDPHS_DMASTATUS2_BUFF_COUNT_Pos = 0x10
	// Bit mask of BUFF_COUNT field.
	UDPHS_DMASTATUS2_BUFF_COUNT_Msk = 0xffff0000

	// DMANXTDSC3: UDPHS DMA Next Descriptor Address Register (channel = 3)
	// Position of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC3_NXT_DSC_ADD_Pos = 0x0
	// Bit mask of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC3_NXT_DSC_ADD_Msk = 0xffffffff

	// DMAADDRESS3: UDPHS DMA Channel Address Register (channel = 3)
	// Position of BUFF_ADD field.
	UDPHS_DMAADDRESS3_BUFF_ADD_Pos = 0x0
	// Bit mask of BUFF_ADD field.
	UDPHS_DMAADDRESS3_BUFF_ADD_Msk = 0xffffffff

	// DMACONTROL3: UDPHS DMA Channel Control Register (channel = 3)
	// Position of CHANN_ENB field.
	UDPHS_DMACONTROL3_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMACONTROL3_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMACONTROL3_CHANN_ENB = 0x1
	// Position of LDNXT_DSC field.
	UDPHS_DMACONTROL3_LDNXT_DSC_Pos = 0x1
	// Bit mask of LDNXT_DSC field.
	UDPHS_DMACONTROL3_LDNXT_DSC_Msk = 0x2
	// Bit LDNXT_DSC.
	UDPHS_DMACONTROL3_LDNXT_DSC = 0x2
	// Position of END_TR_EN field.
	UDPHS_DMACONTROL3_END_TR_EN_Pos = 0x2
	// Bit mask of END_TR_EN field.
	UDPHS_DMACONTROL3_END_TR_EN_Msk = 0x4
	// Bit END_TR_EN.
	UDPHS_DMACONTROL3_END_TR_EN = 0x4
	// Position of END_B_EN field.
	UDPHS_DMACONTROL3_END_B_EN_Pos = 0x3
	// Bit mask of END_B_EN field.
	UDPHS_DMACONTROL3_END_B_EN_Msk = 0x8
	// Bit END_B_EN.
	UDPHS_DMACONTROL3_END_B_EN = 0x8
	// Position of END_TR_IT field.
	UDPHS_DMACONTROL3_END_TR_IT_Pos = 0x4
	// Bit mask of END_TR_IT field.
	UDPHS_DMACONTROL3_END_TR_IT_Msk = 0x10
	// Bit END_TR_IT.
	UDPHS_DMACONTROL3_END_TR_IT = 0x10
	// Position of END_BUFFIT field.
	UDPHS_DMACONTROL3_END_BUFFIT_Pos = 0x5
	// Bit mask of END_BUFFIT field.
	UDPHS_DMACONTROL3_END_BUFFIT_Msk = 0x20
	// Bit END_BUFFIT.
	UDPHS_DMACONTROL3_END_BUFFIT = 0x20
	// Position of DESC_LD_IT field.
	UDPHS_DMACONTROL3_DESC_LD_IT_Pos = 0x6
	// Bit mask of DESC_LD_IT field.
	UDPHS_DMACONTROL3_DESC_LD_IT_Msk = 0x40
	// Bit DESC_LD_IT.
	UDPHS_DMACONTROL3_DESC_LD_IT = 0x40
	// Position of BURST_LCK field.
	UDPHS_DMACONTROL3_BURST_LCK_Pos = 0x7
	// Bit mask of BURST_LCK field.
	UDPHS_DMACONTROL3_BURST_LCK_Msk = 0x80
	// Bit BURST_LCK.
	UDPHS_DMACONTROL3_BURST_LCK = 0x80
	// Position of BUFF_LENGTH field.
	UDPHS_DMACONTROL3_BUFF_LENGTH_Pos = 0x10
	// Bit mask of BUFF_LENGTH field.
	UDPHS_DMACONTROL3_BUFF_LENGTH_Msk = 0xffff0000

	// DMASTATUS3: UDPHS DMA Channel Status Register (channel = 3)
	// Position of CHANN_ENB field.
	UDPHS_DMASTATUS3_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMASTATUS3_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMASTATUS3_CHANN_ENB = 0x1
	// Position of CHANN_ACT field.
	UDPHS_DMASTATUS3_CHANN_ACT_Pos = 0x1
	// Bit mask of CHANN_ACT field.
	UDPHS_DMASTATUS3_CHANN_ACT_Msk = 0x2
	// Bit CHANN_ACT.
	UDPHS_DMASTATUS3_CHANN_ACT = 0x2
	// Position of END_TR_ST field.
	UDPHS_DMASTATUS3_END_TR_ST_Pos = 0x4
	// Bit mask of END_TR_ST field.
	UDPHS_DMASTATUS3_END_TR_ST_Msk = 0x10
	// Bit END_TR_ST.
	UDPHS_DMASTATUS3_END_TR_ST = 0x10
	// Position of END_BF_ST field.
	UDPHS_DMASTATUS3_END_BF_ST_Pos = 0x5
	// Bit mask of END_BF_ST field.
	UDPHS_DMASTATUS3_END_BF_ST_Msk = 0x20
	// Bit END_BF_ST.
	UDPHS_DMASTATUS3_END_BF_ST = 0x20
	// Position of DESC_LDST field.
	UDPHS_DMASTATUS3_DESC_LDST_Pos = 0x6
	// Bit mask of DESC_LDST field.
	UDPHS_DMASTATUS3_DESC_LDST_Msk = 0x40
	// Bit DESC_LDST.
	UDPHS_DMASTATUS3_DESC_LDST = 0x40
	// Position of BUFF_COUNT field.
	UDPHS_DMASTATUS3_BUFF_COUNT_Pos = 0x10
	// Bit mask of BUFF_COUNT field.
	UDPHS_DMASTATUS3_BUFF_COUNT_Msk = 0xffff0000

	// DMANXTDSC4: UDPHS DMA Next Descriptor Address Register (channel = 4)
	// Position of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC4_NXT_DSC_ADD_Pos = 0x0
	// Bit mask of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC4_NXT_DSC_ADD_Msk = 0xffffffff

	// DMAADDRESS4: UDPHS DMA Channel Address Register (channel = 4)
	// Position of BUFF_ADD field.
	UDPHS_DMAADDRESS4_BUFF_ADD_Pos = 0x0
	// Bit mask of BUFF_ADD field.
	UDPHS_DMAADDRESS4_BUFF_ADD_Msk = 0xffffffff

	// DMACONTROL4: UDPHS DMA Channel Control Register (channel = 4)
	// Position of CHANN_ENB field.
	UDPHS_DMACONTROL4_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMACONTROL4_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMACONTROL4_CHANN_ENB = 0x1
	// Position of LDNXT_DSC field.
	UDPHS_DMACONTROL4_LDNXT_DSC_Pos = 0x1
	// Bit mask of LDNXT_DSC field.
	UDPHS_DMACONTROL4_LDNXT_DSC_Msk = 0x2
	// Bit LDNXT_DSC.
	UDPHS_DMACONTROL4_LDNXT_DSC = 0x2
	// Position of END_TR_EN field.
	UDPHS_DMACONTROL4_END_TR_EN_Pos = 0x2
	// Bit mask of END_TR_EN field.
	UDPHS_DMACONTROL4_END_TR_EN_Msk = 0x4
	// Bit END_TR_EN.
	UDPHS_DMACONTROL4_END_TR_EN = 0x4
	// Position of END_B_EN field.
	UDPHS_DMACONTROL4_END_B_EN_Pos = 0x3
	// Bit mask of END_B_EN field.
	UDPHS_DMACONTROL4_END_B_EN_Msk = 0x8
	// Bit END_B_EN.
	UDPHS_DMACONTROL4_END_B_EN = 0x8
	// Position of END_TR_IT field.
	UDPHS_DMACONTROL4_END_TR_IT_Pos = 0x4
	// Bit mask of END_TR_IT field.
	UDPHS_DMACONTROL4_END_TR_IT_Msk = 0x10
	// Bit END_TR_IT.
	UDPHS_DMACONTROL4_END_TR_IT = 0x10
	// Position of END_BUFFIT field.
	UDPHS_DMACONTROL4_END_BUFFIT_Pos = 0x5
	// Bit mask of END_BUFFIT field.
	UDPHS_DMACONTROL4_END_BUFFIT_Msk = 0x20
	// Bit END_BUFFIT.
	UDPHS_DMACONTROL4_END_BUFFIT = 0x20
	// Position of DESC_LD_IT field.
	UDPHS_DMACONTROL4_DESC_LD_IT_Pos = 0x6
	// Bit mask of DESC_LD_IT field.
	UDPHS_DMACONTROL4_DESC_LD_IT_Msk = 0x40
	// Bit DESC_LD_IT.
	UDPHS_DMACONTROL4_DESC_LD_IT = 0x40
	// Position of BURST_LCK field.
	UDPHS_DMACONTROL4_BURST_LCK_Pos = 0x7
	// Bit mask of BURST_LCK field.
	UDPHS_DMACONTROL4_BURST_LCK_Msk = 0x80
	// Bit BURST_LCK.
	UDPHS_DMACONTROL4_BURST_LCK = 0x80
	// Position of BUFF_LENGTH field.
	UDPHS_DMACONTROL4_BUFF_LENGTH_Pos = 0x10
	// Bit mask of BUFF_LENGTH field.
	UDPHS_DMACONTROL4_BUFF_LENGTH_Msk = 0xffff0000

	// DMASTATUS4: UDPHS DMA Channel Status Register (channel = 4)
	// Position of CHANN_ENB field.
	UDPHS_DMASTATUS4_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMASTATUS4_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMASTATUS4_CHANN_ENB = 0x1
	// Position of CHANN_ACT field.
	UDPHS_DMASTATUS4_CHANN_ACT_Pos = 0x1
	// Bit mask of CHANN_ACT field.
	UDPHS_DMASTATUS4_CHANN_ACT_Msk = 0x2
	// Bit CHANN_ACT.
	UDPHS_DMASTATUS4_CHANN_ACT = 0x2
	// Position of END_TR_ST field.
	UDPHS_DMASTATUS4_END_TR_ST_Pos = 0x4
	// Bit mask of END_TR_ST field.
	UDPHS_DMASTATUS4_END_TR_ST_Msk = 0x10
	// Bit END_TR_ST.
	UDPHS_DMASTATUS4_END_TR_ST = 0x10
	// Position of END_BF_ST field.
	UDPHS_DMASTATUS4_END_BF_ST_Pos = 0x5
	// Bit mask of END_BF_ST field.
	UDPHS_DMASTATUS4_END_BF_ST_Msk = 0x20
	// Bit END_BF_ST.
	UDPHS_DMASTATUS4_END_BF_ST = 0x20
	// Position of DESC_LDST field.
	UDPHS_DMASTATUS4_DESC_LDST_Pos = 0x6
	// Bit mask of DESC_LDST field.
	UDPHS_DMASTATUS4_DESC_LDST_Msk = 0x40
	// Bit DESC_LDST.
	UDPHS_DMASTATUS4_DESC_LDST = 0x40
	// Position of BUFF_COUNT field.
	UDPHS_DMASTATUS4_BUFF_COUNT_Pos = 0x10
	// Bit mask of BUFF_COUNT field.
	UDPHS_DMASTATUS4_BUFF_COUNT_Msk = 0xffff0000

	// DMANXTDSC5: UDPHS DMA Next Descriptor Address Register (channel = 5)
	// Position of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC5_NXT_DSC_ADD_Pos = 0x0
	// Bit mask of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC5_NXT_DSC_ADD_Msk = 0xffffffff

	// DMAADDRESS5: UDPHS DMA Channel Address Register (channel = 5)
	// Position of BUFF_ADD field.
	UDPHS_DMAADDRESS5_BUFF_ADD_Pos = 0x0
	// Bit mask of BUFF_ADD field.
	UDPHS_DMAADDRESS5_BUFF_ADD_Msk = 0xffffffff

	// DMACONTROL5: UDPHS DMA Channel Control Register (channel = 5)
	// Position of CHANN_ENB field.
	UDPHS_DMACONTROL5_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMACONTROL5_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMACONTROL5_CHANN_ENB = 0x1
	// Position of LDNXT_DSC field.
	UDPHS_DMACONTROL5_LDNXT_DSC_Pos = 0x1
	// Bit mask of LDNXT_DSC field.
	UDPHS_DMACONTROL5_LDNXT_DSC_Msk = 0x2
	// Bit LDNXT_DSC.
	UDPHS_DMACONTROL5_LDNXT_DSC = 0x2
	// Position of END_TR_EN field.
	UDPHS_DMACONTROL5_END_TR_EN_Pos = 0x2
	// Bit mask of END_TR_EN field.
	UDPHS_DMACONTROL5_END_TR_EN_Msk = 0x4
	// Bit END_TR_EN.
	UDPHS_DMACONTROL5_END_TR_EN = 0x4
	// Position of END_B_EN field.
	UDPHS_DMACONTROL5_END_B_EN_Pos = 0x3
	// Bit mask of END_B_EN field.
	UDPHS_DMACONTROL5_END_B_EN_Msk = 0x8
	// Bit END_B_EN.
	UDPHS_DMACONTROL5_END_B_EN = 0x8
	// Position of END_TR_IT field.
	UDPHS_DMACONTROL5_END_TR_IT_Pos = 0x4
	// Bit mask of END_TR_IT field.
	UDPHS_DMACONTROL5_END_TR_IT_Msk = 0x10
	// Bit END_TR_IT.
	UDPHS_DMACONTROL5_END_TR_IT = 0x10
	// Position of END_BUFFIT field.
	UDPHS_DMACONTROL5_END_BUFFIT_Pos = 0x5
	// Bit mask of END_BUFFIT field.
	UDPHS_DMACONTROL5_END_BUFFIT_Msk = 0x20
	// Bit END_BUFFIT.
	UDPHS_DMACONTROL5_END_BUFFIT = 0x20
	// Position of DESC_LD_IT field.
	UDPHS_DMACONTROL5_DESC_LD_IT_Pos = 0x6
	// Bit mask of DESC_LD_IT field.
	UDPHS_DMACONTROL5_DESC_LD_IT_Msk = 0x40
	// Bit DESC_LD_IT.
	UDPHS_DMACONTROL5_DESC_LD_IT = 0x40
	// Position of BURST_LCK field.
	UDPHS_DMACONTROL5_BURST_LCK_Pos = 0x7
	// Bit mask of BURST_LCK field.
	UDPHS_DMACONTROL5_BURST_LCK_Msk = 0x80
	// Bit BURST_LCK.
	UDPHS_DMACONTROL5_BURST_LCK = 0x80
	// Position of BUFF_LENGTH field.
	UDPHS_DMACONTROL5_BUFF_LENGTH_Pos = 0x10
	// Bit mask of BUFF_LENGTH field.
	UDPHS_DMACONTROL5_BUFF_LENGTH_Msk = 0xffff0000

	// DMASTATUS5: UDPHS DMA Channel Status Register (channel = 5)
	// Position of CHANN_ENB field.
	UDPHS_DMASTATUS5_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMASTATUS5_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMASTATUS5_CHANN_ENB = 0x1
	// Position of CHANN_ACT field.
	UDPHS_DMASTATUS5_CHANN_ACT_Pos = 0x1
	// Bit mask of CHANN_ACT field.
	UDPHS_DMASTATUS5_CHANN_ACT_Msk = 0x2
	// Bit CHANN_ACT.
	UDPHS_DMASTATUS5_CHANN_ACT = 0x2
	// Position of END_TR_ST field.
	UDPHS_DMASTATUS5_END_TR_ST_Pos = 0x4
	// Bit mask of END_TR_ST field.
	UDPHS_DMASTATUS5_END_TR_ST_Msk = 0x10
	// Bit END_TR_ST.
	UDPHS_DMASTATUS5_END_TR_ST = 0x10
	// Position of END_BF_ST field.
	UDPHS_DMASTATUS5_END_BF_ST_Pos = 0x5
	// Bit mask of END_BF_ST field.
	UDPHS_DMASTATUS5_END_BF_ST_Msk = 0x20
	// Bit END_BF_ST.
	UDPHS_DMASTATUS5_END_BF_ST = 0x20
	// Position of DESC_LDST field.
	UDPHS_DMASTATUS5_DESC_LDST_Pos = 0x6
	// Bit mask of DESC_LDST field.
	UDPHS_DMASTATUS5_DESC_LDST_Msk = 0x40
	// Bit DESC_LDST.
	UDPHS_DMASTATUS5_DESC_LDST = 0x40
	// Position of BUFF_COUNT field.
	UDPHS_DMASTATUS5_BUFF_COUNT_Pos = 0x10
	// Bit mask of BUFF_COUNT field.
	UDPHS_DMASTATUS5_BUFF_COUNT_Msk = 0xffff0000

	// DMANXTDSC6: UDPHS DMA Next Descriptor Address Register (channel = 6)
	// Position of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC6_NXT_DSC_ADD_Pos = 0x0
	// Bit mask of NXT_DSC_ADD field.
	UDPHS_DMANXTDSC6_NXT_DSC_ADD_Msk = 0xffffffff

	// DMAADDRESS6: UDPHS DMA Channel Address Register (channel = 6)
	// Position of BUFF_ADD field.
	UDPHS_DMAADDRESS6_BUFF_ADD_Pos = 0x0
	// Bit mask of BUFF_ADD field.
	UDPHS_DMAADDRESS6_BUFF_ADD_Msk = 0xffffffff

	// DMACONTROL6: UDPHS DMA Channel Control Register (channel = 6)
	// Position of CHANN_ENB field.
	UDPHS_DMACONTROL6_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMACONTROL6_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMACONTROL6_CHANN_ENB = 0x1
	// Position of LDNXT_DSC field.
	UDPHS_DMACONTROL6_LDNXT_DSC_Pos = 0x1
	// Bit mask of LDNXT_DSC field.
	UDPHS_DMACONTROL6_LDNXT_DSC_Msk = 0x2
	// Bit LDNXT_DSC.
	UDPHS_DMACONTROL6_LDNXT_DSC = 0x2
	// Position of END_TR_EN field.
	UDPHS_DMACONTROL6_END_TR_EN_Pos = 0x2
	// Bit mask of END_TR_EN field.
	UDPHS_DMACONTROL6_END_TR_EN_Msk = 0x4
	// Bit END_TR_EN.
	UDPHS_DMACONTROL6_END_TR_EN = 0x4
	// Position of END_B_EN field.
	UDPHS_DMACONTROL6_END_B_EN_Pos = 0x3
	// Bit mask of END_B_EN field.
	UDPHS_DMACONTROL6_END_B_EN_Msk = 0x8
	// Bit END_B_EN.
	UDPHS_DMACONTROL6_END_B_EN = 0x8
	// Position of END_TR_IT field.
	UDPHS_DMACONTROL6_END_TR_IT_Pos = 0x4
	// Bit mask of END_TR_IT field.
	UDPHS_DMACONTROL6_END_TR_IT_Msk = 0x10
	// Bit END_TR_IT.
	UDPHS_DMACONTROL6_END_TR_IT = 0x10
	// Position of END_BUFFIT field.
	UDPHS_DMACONTROL6_END_BUFFIT_Pos = 0x5
	// Bit mask of END_BUFFIT field.
	UDPHS_DMACONTROL6_END_BUFFIT_Msk = 0x20
	// Bit END_BUFFIT.
	UDPHS_DMACONTROL6_END_BUFFIT = 0x20
	// Position of DESC_LD_IT field.
	UDPHS_DMACONTROL6_DESC_LD_IT_Pos = 0x6
	// Bit mask of DESC_LD_IT field.
	UDPHS_DMACONTROL6_DESC_LD_IT_Msk = 0x40
	// Bit DESC_LD_IT.
	UDPHS_DMACONTROL6_DESC_LD_IT = 0x40
	// Position of BURST_LCK field.
	UDPHS_DMACONTROL6_BURST_LCK_Pos = 0x7
	// Bit mask of BURST_LCK field.
	UDPHS_DMACONTROL6_BURST_LCK_Msk = 0x80
	// Bit BURST_LCK.
	UDPHS_DMACONTROL6_BURST_LCK = 0x80
	// Position of BUFF_LENGTH field.
	UDPHS_DMACONTROL6_BUFF_LENGTH_Pos = 0x10
	// Bit mask of BUFF_LENGTH field.
	UDPHS_DMACONTROL6_BUFF_LENGTH_Msk = 0xffff0000

	// DMASTATUS6: UDPHS DMA Channel Status Register (channel = 6)
	// Position of CHANN_ENB field.
	UDPHS_DMASTATUS6_CHANN_ENB_Pos = 0x0
	// Bit mask of CHANN_ENB field.
	UDPHS_DMASTATUS6_CHANN_ENB_Msk = 0x1
	// Bit CHANN_ENB.
	UDPHS_DMASTATUS6_CHANN_ENB = 0x1
	// Position of CHANN_ACT field.
	UDPHS_DMASTATUS6_CHANN_ACT_Pos = 0x1
	// Bit mask of CHANN_ACT field.
	UDPHS_DMASTATUS6_CHANN_ACT_Msk = 0x2
	// Bit CHANN_ACT.
	UDPHS_DMASTATUS6_CHANN_ACT = 0x2
	// Position of END_TR_ST field.
	UDPHS_DMASTATUS6_END_TR_ST_Pos = 0x4
	// Bit mask of END_TR_ST field.
	UDPHS_DMASTATUS6_END_TR_ST_Msk = 0x10
	// Bit END_TR_ST.
	UDPHS_DMASTATUS6_END_TR_ST = 0x10
	// Position of END_BF_ST field.
	UDPHS_DMASTATUS6_END_BF_ST_Pos = 0x5
	// Bit mask of END_BF_ST field.
	UDPHS_DMASTATUS6_END_BF_ST_Msk = 0x20
	// Bit END_BF_ST.
	UDPHS_DMASTATUS6_END_BF_ST = 0x20
	// Position of DESC_LDST field.
	UDPHS_DMASTATUS6_DESC_LDST_Pos = 0x6
	// Bit mask of DESC_LDST field.
	UDPHS_DMASTATUS6_DESC_LDST_Msk = 0x40
	// Bit DESC_LDST.
	UDPHS_DMASTATUS6_DESC_LDST = 0x40
	// Position of BUFF_COUNT field.
	UDPHS_DMASTATUS6_BUFF_COUNT_Pos = 0x10
	// Bit mask of BUFF_COUNT field.
	UDPHS_DMASTATUS6_BUFF_COUNT_Msk = 0xffff0000
)

// Constants for TRNG: True Random Number Generator
const (
	// CR: Control Register
	// Position of ENABLE field.
	TRNG_CR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	TRNG_CR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	TRNG_CR_ENABLE = 0x1
	// Position of KEY field.
	TRNG_CR_KEY_Pos = 0x8
	// Bit mask of KEY field.
	TRNG_CR_KEY_Msk = 0xffffff00

	// IER: Interrupt Enable Register
	// Position of DATRDY field.
	TRNG_IER_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	TRNG_IER_DATRDY_Msk = 0x1
	// Bit DATRDY.
	TRNG_IER_DATRDY = 0x1

	// IDR: Interrupt Disable Register
	// Position of DATRDY field.
	TRNG_IDR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	TRNG_IDR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	TRNG_IDR_DATRDY = 0x1

	// IMR: Interrupt Mask Register
	// Position of DATRDY field.
	TRNG_IMR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	TRNG_IMR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	TRNG_IMR_DATRDY = 0x1

	// ISR: Interrupt Status Register
	// Position of DATRDY field.
	TRNG_ISR_DATRDY_Pos = 0x0
	// Bit mask of DATRDY field.
	TRNG_ISR_DATRDY_Msk = 0x1
	// Bit DATRDY.
	TRNG_ISR_DATRDY = 0x1

	// ODATA: Output Data Register
	// Position of ODATA field.
	TRNG_ODATA_ODATA_Pos = 0x0
	// Bit mask of ODATA field.
	TRNG_ODATA_ODATA_Msk = 0xffffffff
)

// Constants for FUSE: Fuse Controller
const (
	// CR: Fuse Control Register
	// Position of WRQ field.
	FUSE_CR_WRQ_Pos = 0x0
	// Bit mask of WRQ field.
	FUSE_CR_WRQ_Msk = 0x1
	// Bit WRQ.
	FUSE_CR_WRQ = 0x1
	// Position of RRQ field.
	FUSE_CR_RRQ_Pos = 0x1
	// Bit mask of RRQ field.
	FUSE_CR_RRQ_Msk = 0x2
	// Bit RRQ.
	FUSE_CR_RRQ = 0x2
	// Position of KEY field.
	FUSE_CR_KEY_Pos = 0x8
	// Bit mask of KEY field.
	FUSE_CR_KEY_Msk = 0xff00
	// valid key.
	FUSE_CR_KEY_VALID = 0xfb

	// MR: Fuse Mode Register
	// Position of MSK field.
	FUSE_MR_MSK_Pos = 0x0
	// Bit mask of MSK field.
	FUSE_MR_MSK_Msk = 0x1
	// Bit MSK.
	FUSE_MR_MSK = 0x1

	// IR: Fuse Index Register
	// Position of WS field.
	FUSE_IR_WS_Pos = 0x0
	// Bit mask of WS field.
	FUSE_IR_WS_Msk = 0x1
	// Bit WS.
	FUSE_IR_WS = 0x1
	// Position of RS field.
	FUSE_IR_RS_Pos = 0x1
	// Bit mask of RS field.
	FUSE_IR_RS_Msk = 0x2
	// Bit RS.
	FUSE_IR_RS = 0x2
	// Position of WSEL field.
	FUSE_IR_WSEL_Pos = 0x8
	// Bit mask of WSEL field.
	FUSE_IR_WSEL_Msk = 0xf00

	// DR: Fuse Data Register
	// Position of DATA field.
	FUSE_DR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	FUSE_DR_DATA_Msk = 0xffffffff

	// SR: Fuse Status Register
	// Position of FUSE field.
	FUSE_SR_FUSE_Pos = 0x0
	// Bit mask of FUSE field.
	FUSE_SR_FUSE_Msk = 0xffffffff
)

// Constants for DMAC0: DMA Controller 0
const (
	// GCFG: DMAC Global Configuration Register
	// Position of ARB_CFG field.
	DMAC_GCFG_ARB_CFG_Pos = 0x4
	// Bit mask of ARB_CFG field.
	DMAC_GCFG_ARB_CFG_Msk = 0x10
	// Bit ARB_CFG.
	DMAC_GCFG_ARB_CFG = 0x10
	// Fixed priority arbiter.
	DMAC_GCFG_ARB_CFG_FIXED = 0x0
	// Modified round robin arbiter.
	DMAC_GCFG_ARB_CFG_ROUND_ROBIN = 0x1
	// Position of DICEN field.
	DMAC_GCFG_DICEN_Pos = 0x8
	// Bit mask of DICEN field.
	DMAC_GCFG_DICEN_Msk = 0x100
	// Bit DICEN.
	DMAC_GCFG_DICEN = 0x100

	// EN: DMAC Enable Register
	// Position of ENABLE field.
	DMAC_EN_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	DMAC_EN_ENABLE_Msk = 0x1
	// Bit ENABLE.
	DMAC_EN_ENABLE = 0x1

	// SREQ: DMAC Software Single Request Register
	// Position of SSREQ0 field.
	DMAC_SREQ_SSREQ0_Pos = 0x0
	// Bit mask of SSREQ0 field.
	DMAC_SREQ_SSREQ0_Msk = 0x1
	// Bit SSREQ0.
	DMAC_SREQ_SSREQ0 = 0x1
	// Position of DSREQ0 field.
	DMAC_SREQ_DSREQ0_Pos = 0x1
	// Bit mask of DSREQ0 field.
	DMAC_SREQ_DSREQ0_Msk = 0x2
	// Bit DSREQ0.
	DMAC_SREQ_DSREQ0 = 0x2
	// Position of SSREQ1 field.
	DMAC_SREQ_SSREQ1_Pos = 0x2
	// Bit mask of SSREQ1 field.
	DMAC_SREQ_SSREQ1_Msk = 0x4
	// Bit SSREQ1.
	DMAC_SREQ_SSREQ1 = 0x4
	// Position of DSREQ1 field.
	DMAC_SREQ_DSREQ1_Pos = 0x3
	// Bit mask of DSREQ1 field.
	DMAC_SREQ_DSREQ1_Msk = 0x8
	// Bit DSREQ1.
	DMAC_SREQ_DSREQ1 = 0x8
	// Position of SSREQ2 field.
	DMAC_SREQ_SSREQ2_Pos = 0x4
	// Bit mask of SSREQ2 field.
	DMAC_SREQ_SSREQ2_Msk = 0x10
	// Bit SSREQ2.
	DMAC_SREQ_SSREQ2 = 0x10
	// Position of DSREQ2 field.
	DMAC_SREQ_DSREQ2_Pos = 0x5
	// Bit mask of DSREQ2 field.
	DMAC_SREQ_DSREQ2_Msk = 0x20
	// Bit DSREQ2.
	DMAC_SREQ_DSREQ2 = 0x20
	// Position of SSREQ3 field.
	DMAC_SREQ_SSREQ3_Pos = 0x6
	// Bit mask of SSREQ3 field.
	DMAC_SREQ_SSREQ3_Msk = 0x40
	// Bit SSREQ3.
	DMAC_SREQ_SSREQ3 = 0x40
	// Position of DSREQ3 field.
	DMAC_SREQ_DSREQ3_Pos = 0x7
	// Bit mask of DSREQ3 field.
	DMAC_SREQ_DSREQ3_Msk = 0x80
	// Bit DSREQ3.
	DMAC_SREQ_DSREQ3 = 0x80
	// Position of SSREQ4 field.
	DMAC_SREQ_SSREQ4_Pos = 0x8
	// Bit mask of SSREQ4 field.
	DMAC_SREQ_SSREQ4_Msk = 0x100
	// Bit SSREQ4.
	DMAC_SREQ_SSREQ4 = 0x100
	// Position of DSREQ4 field.
	DMAC_SREQ_DSREQ4_Pos = 0x9
	// Bit mask of DSREQ4 field.
	DMAC_SREQ_DSREQ4_Msk = 0x200
	// Bit DSREQ4.
	DMAC_SREQ_DSREQ4 = 0x200
	// Position of SSREQ5 field.
	DMAC_SREQ_SSREQ5_Pos = 0xa
	// Bit mask of SSREQ5 field.
	DMAC_SREQ_SSREQ5_Msk = 0x400
	// Bit SSREQ5.
	DMAC_SREQ_SSREQ5 = 0x400
	// Position of DSREQ5 field.
	DMAC_SREQ_DSREQ5_Pos = 0xb
	// Bit mask of DSREQ5 field.
	DMAC_SREQ_DSREQ5_Msk = 0x800
	// Bit DSREQ5.
	DMAC_SREQ_DSREQ5 = 0x800
	// Position of SSREQ6 field.
	DMAC_SREQ_SSREQ6_Pos = 0xc
	// Bit mask of SSREQ6 field.
	DMAC_SREQ_SSREQ6_Msk = 0x1000
	// Bit SSREQ6.
	DMAC_SREQ_SSREQ6 = 0x1000
	// Position of DSREQ6 field.
	DMAC_SREQ_DSREQ6_Pos = 0xd
	// Bit mask of DSREQ6 field.
	DMAC_SREQ_DSREQ6_Msk = 0x2000
	// Bit DSREQ6.
	DMAC_SREQ_DSREQ6 = 0x2000
	// Position of SSREQ7 field.
	DMAC_SREQ_SSREQ7_Pos = 0xe
	// Bit mask of SSREQ7 field.
	DMAC_SREQ_SSREQ7_Msk = 0x4000
	// Bit SSREQ7.
	DMAC_SREQ_SSREQ7 = 0x4000
	// Position of DSREQ7 field.
	DMAC_SREQ_DSREQ7_Pos = 0xf
	// Bit mask of DSREQ7 field.
	DMAC_SREQ_DSREQ7_Msk = 0x8000
	// Bit DSREQ7.
	DMAC_SREQ_DSREQ7 = 0x8000

	// CREQ: DMAC Software Chunk Transfer Request Register
	// Position of SCREQ0 field.
	DMAC_CREQ_SCREQ0_Pos = 0x0
	// Bit mask of SCREQ0 field.
	DMAC_CREQ_SCREQ0_Msk = 0x1
	// Bit SCREQ0.
	DMAC_CREQ_SCREQ0 = 0x1
	// Position of DCREQ0 field.
	DMAC_CREQ_DCREQ0_Pos = 0x1
	// Bit mask of DCREQ0 field.
	DMAC_CREQ_DCREQ0_Msk = 0x2
	// Bit DCREQ0.
	DMAC_CREQ_DCREQ0 = 0x2
	// Position of SCREQ1 field.
	DMAC_CREQ_SCREQ1_Pos = 0x2
	// Bit mask of SCREQ1 field.
	DMAC_CREQ_SCREQ1_Msk = 0x4
	// Bit SCREQ1.
	DMAC_CREQ_SCREQ1 = 0x4
	// Position of DCREQ1 field.
	DMAC_CREQ_DCREQ1_Pos = 0x3
	// Bit mask of DCREQ1 field.
	DMAC_CREQ_DCREQ1_Msk = 0x8
	// Bit DCREQ1.
	DMAC_CREQ_DCREQ1 = 0x8
	// Position of SCREQ2 field.
	DMAC_CREQ_SCREQ2_Pos = 0x4
	// Bit mask of SCREQ2 field.
	DMAC_CREQ_SCREQ2_Msk = 0x10
	// Bit SCREQ2.
	DMAC_CREQ_SCREQ2 = 0x10
	// Position of DCREQ2 field.
	DMAC_CREQ_DCREQ2_Pos = 0x5
	// Bit mask of DCREQ2 field.
	DMAC_CREQ_DCREQ2_Msk = 0x20
	// Bit DCREQ2.
	DMAC_CREQ_DCREQ2 = 0x20
	// Position of SCREQ3 field.
	DMAC_CREQ_SCREQ3_Pos = 0x6
	// Bit mask of SCREQ3 field.
	DMAC_CREQ_SCREQ3_Msk = 0x40
	// Bit SCREQ3.
	DMAC_CREQ_SCREQ3 = 0x40
	// Position of DCREQ3 field.
	DMAC_CREQ_DCREQ3_Pos = 0x7
	// Bit mask of DCREQ3 field.
	DMAC_CREQ_DCREQ3_Msk = 0x80
	// Bit DCREQ3.
	DMAC_CREQ_DCREQ3 = 0x80
	// Position of SCREQ4 field.
	DMAC_CREQ_SCREQ4_Pos = 0x8
	// Bit mask of SCREQ4 field.
	DMAC_CREQ_SCREQ4_Msk = 0x100
	// Bit SCREQ4.
	DMAC_CREQ_SCREQ4 = 0x100
	// Position of DCREQ4 field.
	DMAC_CREQ_DCREQ4_Pos = 0x9
	// Bit mask of DCREQ4 field.
	DMAC_CREQ_DCREQ4_Msk = 0x200
	// Bit DCREQ4.
	DMAC_CREQ_DCREQ4 = 0x200
	// Position of SCREQ5 field.
	DMAC_CREQ_SCREQ5_Pos = 0xa
	// Bit mask of SCREQ5 field.
	DMAC_CREQ_SCREQ5_Msk = 0x400
	// Bit SCREQ5.
	DMAC_CREQ_SCREQ5 = 0x400
	// Position of DCREQ5 field.
	DMAC_CREQ_DCREQ5_Pos = 0xb
	// Bit mask of DCREQ5 field.
	DMAC_CREQ_DCREQ5_Msk = 0x800
	// Bit DCREQ5.
	DMAC_CREQ_DCREQ5 = 0x800
	// Position of SCREQ6 field.
	DMAC_CREQ_SCREQ6_Pos = 0xc
	// Bit mask of SCREQ6 field.
	DMAC_CREQ_SCREQ6_Msk = 0x1000
	// Bit SCREQ6.
	DMAC_CREQ_SCREQ6 = 0x1000
	// Position of DCREQ6 field.
	DMAC_CREQ_DCREQ6_Pos = 0xd
	// Bit mask of DCREQ6 field.
	DMAC_CREQ_DCREQ6_Msk = 0x2000
	// Bit DCREQ6.
	DMAC_CREQ_DCREQ6 = 0x2000
	// Position of SCREQ7 field.
	DMAC_CREQ_SCREQ7_Pos = 0xe
	// Bit mask of SCREQ7 field.
	DMAC_CREQ_SCREQ7_Msk = 0x4000
	// Bit SCREQ7.
	DMAC_CREQ_SCREQ7 = 0x4000
	// Position of DCREQ7 field.
	DMAC_CREQ_DCREQ7_Pos = 0xf
	// Bit mask of DCREQ7 field.
	DMAC_CREQ_DCREQ7_Msk = 0x8000
	// Bit DCREQ7.
	DMAC_CREQ_DCREQ7 = 0x8000

	// LAST: DMAC Software Last Transfer Flag Register
	// Position of SLAST0 field.
	DMAC_LAST_SLAST0_Pos = 0x0
	// Bit mask of SLAST0 field.
	DMAC_LAST_SLAST0_Msk = 0x1
	// Bit SLAST0.
	DMAC_LAST_SLAST0 = 0x1
	// Position of DLAST0 field.
	DMAC_LAST_DLAST0_Pos = 0x1
	// Bit mask of DLAST0 field.
	DMAC_LAST_DLAST0_Msk = 0x2
	// Bit DLAST0.
	DMAC_LAST_DLAST0 = 0x2
	// Position of SLAST1 field.
	DMAC_LAST_SLAST1_Pos = 0x2
	// Bit mask of SLAST1 field.
	DMAC_LAST_SLAST1_Msk = 0x4
	// Bit SLAST1.
	DMAC_LAST_SLAST1 = 0x4
	// Position of DLAST1 field.
	DMAC_LAST_DLAST1_Pos = 0x3
	// Bit mask of DLAST1 field.
	DMAC_LAST_DLAST1_Msk = 0x8
	// Bit DLAST1.
	DMAC_LAST_DLAST1 = 0x8
	// Position of SLAST2 field.
	DMAC_LAST_SLAST2_Pos = 0x4
	// Bit mask of SLAST2 field.
	DMAC_LAST_SLAST2_Msk = 0x10
	// Bit SLAST2.
	DMAC_LAST_SLAST2 = 0x10
	// Position of DLAST2 field.
	DMAC_LAST_DLAST2_Pos = 0x5
	// Bit mask of DLAST2 field.
	DMAC_LAST_DLAST2_Msk = 0x20
	// Bit DLAST2.
	DMAC_LAST_DLAST2 = 0x20
	// Position of SLAST3 field.
	DMAC_LAST_SLAST3_Pos = 0x6
	// Bit mask of SLAST3 field.
	DMAC_LAST_SLAST3_Msk = 0x40
	// Bit SLAST3.
	DMAC_LAST_SLAST3 = 0x40
	// Position of DLAST3 field.
	DMAC_LAST_DLAST3_Pos = 0x7
	// Bit mask of DLAST3 field.
	DMAC_LAST_DLAST3_Msk = 0x80
	// Bit DLAST3.
	DMAC_LAST_DLAST3 = 0x80
	// Position of SLAST4 field.
	DMAC_LAST_SLAST4_Pos = 0x8
	// Bit mask of SLAST4 field.
	DMAC_LAST_SLAST4_Msk = 0x100
	// Bit SLAST4.
	DMAC_LAST_SLAST4 = 0x100
	// Position of DLAST4 field.
	DMAC_LAST_DLAST4_Pos = 0x9
	// Bit mask of DLAST4 field.
	DMAC_LAST_DLAST4_Msk = 0x200
	// Bit DLAST4.
	DMAC_LAST_DLAST4 = 0x200
	// Position of SLAST5 field.
	DMAC_LAST_SLAST5_Pos = 0xa
	// Bit mask of SLAST5 field.
	DMAC_LAST_SLAST5_Msk = 0x400
	// Bit SLAST5.
	DMAC_LAST_SLAST5 = 0x400
	// Position of DLAST5 field.
	DMAC_LAST_DLAST5_Pos = 0xb
	// Bit mask of DLAST5 field.
	DMAC_LAST_DLAST5_Msk = 0x800
	// Bit DLAST5.
	DMAC_LAST_DLAST5 = 0x800
	// Position of SLAST6 field.
	DMAC_LAST_SLAST6_Pos = 0xc
	// Bit mask of SLAST6 field.
	DMAC_LAST_SLAST6_Msk = 0x1000
	// Bit SLAST6.
	DMAC_LAST_SLAST6 = 0x1000
	// Position of DLAST6 field.
	DMAC_LAST_DLAST6_Pos = 0xd
	// Bit mask of DLAST6 field.
	DMAC_LAST_DLAST6_Msk = 0x2000
	// Bit DLAST6.
	DMAC_LAST_DLAST6 = 0x2000
	// Position of SLAST7 field.
	DMAC_LAST_SLAST7_Pos = 0xe
	// Bit mask of SLAST7 field.
	DMAC_LAST_SLAST7_Msk = 0x4000
	// Bit SLAST7.
	DMAC_LAST_SLAST7 = 0x4000
	// Position of DLAST7 field.
	DMAC_LAST_DLAST7_Pos = 0xf
	// Bit mask of DLAST7 field.
	DMAC_LAST_DLAST7_Msk = 0x8000
	// Bit DLAST7.
	DMAC_LAST_DLAST7 = 0x8000

	// EBCIER: DMAC Error, Chained Buffer Transfer Completed Interrupt and Buffer Transfer Completed Interrupt Enable register.
	// Position of BTC0 field.
	DMAC_EBCIER_BTC0_Pos = 0x0
	// Bit mask of BTC0 field.
	DMAC_EBCIER_BTC0_Msk = 0x1
	// Bit BTC0.
	DMAC_EBCIER_BTC0 = 0x1
	// Position of BTC1 field.
	DMAC_EBCIER_BTC1_Pos = 0x1
	// Bit mask of BTC1 field.
	DMAC_EBCIER_BTC1_Msk = 0x2
	// Bit BTC1.
	DMAC_EBCIER_BTC1 = 0x2
	// Position of BTC2 field.
	DMAC_EBCIER_BTC2_Pos = 0x2
	// Bit mask of BTC2 field.
	DMAC_EBCIER_BTC2_Msk = 0x4
	// Bit BTC2.
	DMAC_EBCIER_BTC2 = 0x4
	// Position of BTC3 field.
	DMAC_EBCIER_BTC3_Pos = 0x3
	// Bit mask of BTC3 field.
	DMAC_EBCIER_BTC3_Msk = 0x8
	// Bit BTC3.
	DMAC_EBCIER_BTC3 = 0x8
	// Position of BTC4 field.
	DMAC_EBCIER_BTC4_Pos = 0x4
	// Bit mask of BTC4 field.
	DMAC_EBCIER_BTC4_Msk = 0x10
	// Bit BTC4.
	DMAC_EBCIER_BTC4 = 0x10
	// Position of BTC5 field.
	DMAC_EBCIER_BTC5_Pos = 0x5
	// Bit mask of BTC5 field.
	DMAC_EBCIER_BTC5_Msk = 0x20
	// Bit BTC5.
	DMAC_EBCIER_BTC5 = 0x20
	// Position of BTC6 field.
	DMAC_EBCIER_BTC6_Pos = 0x6
	// Bit mask of BTC6 field.
	DMAC_EBCIER_BTC6_Msk = 0x40
	// Bit BTC6.
	DMAC_EBCIER_BTC6 = 0x40
	// Position of BTC7 field.
	DMAC_EBCIER_BTC7_Pos = 0x7
	// Bit mask of BTC7 field.
	DMAC_EBCIER_BTC7_Msk = 0x80
	// Bit BTC7.
	DMAC_EBCIER_BTC7 = 0x80
	// Position of CBTC0 field.
	DMAC_EBCIER_CBTC0_Pos = 0x8
	// Bit mask of CBTC0 field.
	DMAC_EBCIER_CBTC0_Msk = 0x100
	// Bit CBTC0.
	DMAC_EBCIER_CBTC0 = 0x100
	// Position of CBTC1 field.
	DMAC_EBCIER_CBTC1_Pos = 0x9
	// Bit mask of CBTC1 field.
	DMAC_EBCIER_CBTC1_Msk = 0x200
	// Bit CBTC1.
	DMAC_EBCIER_CBTC1 = 0x200
	// Position of CBTC2 field.
	DMAC_EBCIER_CBTC2_Pos = 0xa
	// Bit mask of CBTC2 field.
	DMAC_EBCIER_CBTC2_Msk = 0x400
	// Bit CBTC2.
	DMAC_EBCIER_CBTC2 = 0x400
	// Position of CBTC3 field.
	DMAC_EBCIER_CBTC3_Pos = 0xb
	// Bit mask of CBTC3 field.
	DMAC_EBCIER_CBTC3_Msk = 0x800
	// Bit CBTC3.
	DMAC_EBCIER_CBTC3 = 0x800
	// Position of CBTC4 field.
	DMAC_EBCIER_CBTC4_Pos = 0xc
	// Bit mask of CBTC4 field.
	DMAC_EBCIER_CBTC4_Msk = 0x1000
	// Bit CBTC4.
	DMAC_EBCIER_CBTC4 = 0x1000
	// Position of CBTC5 field.
	DMAC_EBCIER_CBTC5_Pos = 0xd
	// Bit mask of CBTC5 field.
	DMAC_EBCIER_CBTC5_Msk = 0x2000
	// Bit CBTC5.
	DMAC_EBCIER_CBTC5 = 0x2000
	// Position of CBTC6 field.
	DMAC_EBCIER_CBTC6_Pos = 0xe
	// Bit mask of CBTC6 field.
	DMAC_EBCIER_CBTC6_Msk = 0x4000
	// Bit CBTC6.
	DMAC_EBCIER_CBTC6 = 0x4000
	// Position of CBTC7 field.
	DMAC_EBCIER_CBTC7_Pos = 0xf
	// Bit mask of CBTC7 field.
	DMAC_EBCIER_CBTC7_Msk = 0x8000
	// Bit CBTC7.
	DMAC_EBCIER_CBTC7 = 0x8000
	// Position of ERR0 field.
	DMAC_EBCIER_ERR0_Pos = 0x10
	// Bit mask of ERR0 field.
	DMAC_EBCIER_ERR0_Msk = 0x10000
	// Bit ERR0.
	DMAC_EBCIER_ERR0 = 0x10000
	// Position of ERR1 field.
	DMAC_EBCIER_ERR1_Pos = 0x11
	// Bit mask of ERR1 field.
	DMAC_EBCIER_ERR1_Msk = 0x20000
	// Bit ERR1.
	DMAC_EBCIER_ERR1 = 0x20000
	// Position of ERR2 field.
	DMAC_EBCIER_ERR2_Pos = 0x12
	// Bit mask of ERR2 field.
	DMAC_EBCIER_ERR2_Msk = 0x40000
	// Bit ERR2.
	DMAC_EBCIER_ERR2 = 0x40000
	// Position of ERR3 field.
	DMAC_EBCIER_ERR3_Pos = 0x13
	// Bit mask of ERR3 field.
	DMAC_EBCIER_ERR3_Msk = 0x80000
	// Bit ERR3.
	DMAC_EBCIER_ERR3 = 0x80000
	// Position of ERR4 field.
	DMAC_EBCIER_ERR4_Pos = 0x14
	// Bit mask of ERR4 field.
	DMAC_EBCIER_ERR4_Msk = 0x100000
	// Bit ERR4.
	DMAC_EBCIER_ERR4 = 0x100000
	// Position of ERR5 field.
	DMAC_EBCIER_ERR5_Pos = 0x15
	// Bit mask of ERR5 field.
	DMAC_EBCIER_ERR5_Msk = 0x200000
	// Bit ERR5.
	DMAC_EBCIER_ERR5 = 0x200000
	// Position of ERR6 field.
	DMAC_EBCIER_ERR6_Pos = 0x16
	// Bit mask of ERR6 field.
	DMAC_EBCIER_ERR6_Msk = 0x400000
	// Bit ERR6.
	DMAC_EBCIER_ERR6 = 0x400000
	// Position of ERR7 field.
	DMAC_EBCIER_ERR7_Pos = 0x17
	// Bit mask of ERR7 field.
	DMAC_EBCIER_ERR7_Msk = 0x800000
	// Bit ERR7.
	DMAC_EBCIER_ERR7 = 0x800000
	// Position of DICERR0 field.
	DMAC_EBCIER_DICERR0_Pos = 0x18
	// Bit mask of DICERR0 field.
	DMAC_EBCIER_DICERR0_Msk = 0x1000000
	// Bit DICERR0.
	DMAC_EBCIER_DICERR0 = 0x1000000
	// Position of DICERR1 field.
	DMAC_EBCIER_DICERR1_Pos = 0x19
	// Bit mask of DICERR1 field.
	DMAC_EBCIER_DICERR1_Msk = 0x2000000
	// Bit DICERR1.
	DMAC_EBCIER_DICERR1 = 0x2000000
	// Position of DICERR2 field.
	DMAC_EBCIER_DICERR2_Pos = 0x1a
	// Bit mask of DICERR2 field.
	DMAC_EBCIER_DICERR2_Msk = 0x4000000
	// Bit DICERR2.
	DMAC_EBCIER_DICERR2 = 0x4000000
	// Position of DICERR3 field.
	DMAC_EBCIER_DICERR3_Pos = 0x1b
	// Bit mask of DICERR3 field.
	DMAC_EBCIER_DICERR3_Msk = 0x8000000
	// Bit DICERR3.
	DMAC_EBCIER_DICERR3 = 0x8000000
	// Position of DICERR4 field.
	DMAC_EBCIER_DICERR4_Pos = 0x1c
	// Bit mask of DICERR4 field.
	DMAC_EBCIER_DICERR4_Msk = 0x10000000
	// Bit DICERR4.
	DMAC_EBCIER_DICERR4 = 0x10000000
	// Position of DICERR5 field.
	DMAC_EBCIER_DICERR5_Pos = 0x1d
	// Bit mask of DICERR5 field.
	DMAC_EBCIER_DICERR5_Msk = 0x20000000
	// Bit DICERR5.
	DMAC_EBCIER_DICERR5 = 0x20000000
	// Position of DICERR6 field.
	DMAC_EBCIER_DICERR6_Pos = 0x1e
	// Bit mask of DICERR6 field.
	DMAC_EBCIER_DICERR6_Msk = 0x40000000
	// Bit DICERR6.
	DMAC_EBCIER_DICERR6 = 0x40000000
	// Position of DICERR7 field.
	DMAC_EBCIER_DICERR7_Pos = 0x1f
	// Bit mask of DICERR7 field.
	DMAC_EBCIER_DICERR7_Msk = 0x80000000
	// Bit DICERR7.
	DMAC_EBCIER_DICERR7 = 0x80000000

	// EBCIDR: DMAC Error, Chained Buffer Transfer Completed Interrupt and Buffer Transfer Completed Interrupt Disable register.
	// Position of BTC0 field.
	DMAC_EBCIDR_BTC0_Pos = 0x0
	// Bit mask of BTC0 field.
	DMAC_EBCIDR_BTC0_Msk = 0x1
	// Bit BTC0.
	DMAC_EBCIDR_BTC0 = 0x1
	// Position of BTC1 field.
	DMAC_EBCIDR_BTC1_Pos = 0x1
	// Bit mask of BTC1 field.
	DMAC_EBCIDR_BTC1_Msk = 0x2
	// Bit BTC1.
	DMAC_EBCIDR_BTC1 = 0x2
	// Position of BTC2 field.
	DMAC_EBCIDR_BTC2_Pos = 0x2
	// Bit mask of BTC2 field.
	DMAC_EBCIDR_BTC2_Msk = 0x4
	// Bit BTC2.
	DMAC_EBCIDR_BTC2 = 0x4
	// Position of BTC3 field.
	DMAC_EBCIDR_BTC3_Pos = 0x3
	// Bit mask of BTC3 field.
	DMAC_EBCIDR_BTC3_Msk = 0x8
	// Bit BTC3.
	DMAC_EBCIDR_BTC3 = 0x8
	// Position of BTC4 field.
	DMAC_EBCIDR_BTC4_Pos = 0x4
	// Bit mask of BTC4 field.
	DMAC_EBCIDR_BTC4_Msk = 0x10
	// Bit BTC4.
	DMAC_EBCIDR_BTC4 = 0x10
	// Position of BTC5 field.
	DMAC_EBCIDR_BTC5_Pos = 0x5
	// Bit mask of BTC5 field.
	DMAC_EBCIDR_BTC5_Msk = 0x20
	// Bit BTC5.
	DMAC_EBCIDR_BTC5 = 0x20
	// Position of BTC6 field.
	DMAC_EBCIDR_BTC6_Pos = 0x6
	// Bit mask of BTC6 field.
	DMAC_EBCIDR_BTC6_Msk = 0x40
	// Bit BTC6.
	DMAC_EBCIDR_BTC6 = 0x40
	// Position of BTC7 field.
	DMAC_EBCIDR_BTC7_Pos = 0x7
	// Bit mask of BTC7 field.
	DMAC_EBCIDR_BTC7_Msk = 0x80
	// Bit BTC7.
	DMAC_EBCIDR_BTC7 = 0x80
	// Position of CBTC0 field.
	DMAC_EBCIDR_CBTC0_Pos = 0x8
	// Bit mask of CBTC0 field.
	DMAC_EBCIDR_CBTC0_Msk = 0x100
	// Bit CBTC0.
	DMAC_EBCIDR_CBTC0 = 0x100
	// Position of CBTC1 field.
	DMAC_EBCIDR_CBTC1_Pos = 0x9
	// Bit mask of CBTC1 field.
	DMAC_EBCIDR_CBTC1_Msk = 0x200
	// Bit CBTC1.
	DMAC_EBCIDR_CBTC1 = 0x200
	// Position of CBTC2 field.
	DMAC_EBCIDR_CBTC2_Pos = 0xa
	// Bit mask of CBTC2 field.
	DMAC_EBCIDR_CBTC2_Msk = 0x400
	// Bit CBTC2.
	DMAC_EBCIDR_CBTC2 = 0x400
	// Position of CBTC3 field.
	DMAC_EBCIDR_CBTC3_Pos = 0xb
	// Bit mask of CBTC3 field.
	DMAC_EBCIDR_CBTC3_Msk = 0x800
	// Bit CBTC3.
	DMAC_EBCIDR_CBTC3 = 0x800
	// Position of CBTC4 field.
	DMAC_EBCIDR_CBTC4_Pos = 0xc
	// Bit mask of CBTC4 field.
	DMAC_EBCIDR_CBTC4_Msk = 0x1000
	// Bit CBTC4.
	DMAC_EBCIDR_CBTC4 = 0x1000
	// Position of CBTC5 field.
	DMAC_EBCIDR_CBTC5_Pos = 0xd
	// Bit mask of CBTC5 field.
	DMAC_EBCIDR_CBTC5_Msk = 0x2000
	// Bit CBTC5.
	DMAC_EBCIDR_CBTC5 = 0x2000
	// Position of CBTC6 field.
	DMAC_EBCIDR_CBTC6_Pos = 0xe
	// Bit mask of CBTC6 field.
	DMAC_EBCIDR_CBTC6_Msk = 0x4000
	// Bit CBTC6.
	DMAC_EBCIDR_CBTC6 = 0x4000
	// Position of CBTC7 field.
	DMAC_EBCIDR_CBTC7_Pos = 0xf
	// Bit mask of CBTC7 field.
	DMAC_EBCIDR_CBTC7_Msk = 0x8000
	// Bit CBTC7.
	DMAC_EBCIDR_CBTC7 = 0x8000
	// Position of ERR0 field.
	DMAC_EBCIDR_ERR0_Pos = 0x10
	// Bit mask of ERR0 field.
	DMAC_EBCIDR_ERR0_Msk = 0x10000
	// Bit ERR0.
	DMAC_EBCIDR_ERR0 = 0x10000
	// Position of ERR1 field.
	DMAC_EBCIDR_ERR1_Pos = 0x11
	// Bit mask of ERR1 field.
	DMAC_EBCIDR_ERR1_Msk = 0x20000
	// Bit ERR1.
	DMAC_EBCIDR_ERR1 = 0x20000
	// Position of ERR2 field.
	DMAC_EBCIDR_ERR2_Pos = 0x12
	// Bit mask of ERR2 field.
	DMAC_EBCIDR_ERR2_Msk = 0x40000
	// Bit ERR2.
	DMAC_EBCIDR_ERR2 = 0x40000
	// Position of ERR3 field.
	DMAC_EBCIDR_ERR3_Pos = 0x13
	// Bit mask of ERR3 field.
	DMAC_EBCIDR_ERR3_Msk = 0x80000
	// Bit ERR3.
	DMAC_EBCIDR_ERR3 = 0x80000
	// Position of ERR4 field.
	DMAC_EBCIDR_ERR4_Pos = 0x14
	// Bit mask of ERR4 field.
	DMAC_EBCIDR_ERR4_Msk = 0x100000
	// Bit ERR4.
	DMAC_EBCIDR_ERR4 = 0x100000
	// Position of ERR5 field.
	DMAC_EBCIDR_ERR5_Pos = 0x15
	// Bit mask of ERR5 field.
	DMAC_EBCIDR_ERR5_Msk = 0x200000
	// Bit ERR5.
	DMAC_EBCIDR_ERR5 = 0x200000
	// Position of ERR6 field.
	DMAC_EBCIDR_ERR6_Pos = 0x16
	// Bit mask of ERR6 field.
	DMAC_EBCIDR_ERR6_Msk = 0x400000
	// Bit ERR6.
	DMAC_EBCIDR_ERR6 = 0x400000
	// Position of ERR7 field.
	DMAC_EBCIDR_ERR7_Pos = 0x17
	// Bit mask of ERR7 field.
	DMAC_EBCIDR_ERR7_Msk = 0x800000
	// Bit ERR7.
	DMAC_EBCIDR_ERR7 = 0x800000
	// Position of DICERR0 field.
	DMAC_EBCIDR_DICERR0_Pos = 0x18
	// Bit mask of DICERR0 field.
	DMAC_EBCIDR_DICERR0_Msk = 0x1000000
	// Bit DICERR0.
	DMAC_EBCIDR_DICERR0 = 0x1000000
	// Position of DICERR1 field.
	DMAC_EBCIDR_DICERR1_Pos = 0x19
	// Bit mask of DICERR1 field.
	DMAC_EBCIDR_DICERR1_Msk = 0x2000000
	// Bit DICERR1.
	DMAC_EBCIDR_DICERR1 = 0x2000000
	// Position of DICERR2 field.
	DMAC_EBCIDR_DICERR2_Pos = 0x1a
	// Bit mask of DICERR2 field.
	DMAC_EBCIDR_DICERR2_Msk = 0x4000000
	// Bit DICERR2.
	DMAC_EBCIDR_DICERR2 = 0x4000000
	// Position of DICERR3 field.
	DMAC_EBCIDR_DICERR3_Pos = 0x1b
	// Bit mask of DICERR3 field.
	DMAC_EBCIDR_DICERR3_Msk = 0x8000000
	// Bit DICERR3.
	DMAC_EBCIDR_DICERR3 = 0x8000000
	// Position of DICERR4 field.
	DMAC_EBCIDR_DICERR4_Pos = 0x1c
	// Bit mask of DICERR4 field.
	DMAC_EBCIDR_DICERR4_Msk = 0x10000000
	// Bit DICERR4.
	DMAC_EBCIDR_DICERR4 = 0x10000000
	// Position of DICERR5 field.
	DMAC_EBCIDR_DICERR5_Pos = 0x1d
	// Bit mask of DICERR5 field.
	DMAC_EBCIDR_DICERR5_Msk = 0x20000000
	// Bit DICERR5.
	DMAC_EBCIDR_DICERR5 = 0x20000000
	// Position of DICERR6 field.
	DMAC_EBCIDR_DICERR6_Pos = 0x1e
	// Bit mask of DICERR6 field.
	DMAC_EBCIDR_DICERR6_Msk = 0x40000000
	// Bit DICERR6.
	DMAC_EBCIDR_DICERR6 = 0x40000000
	// Position of DICERR7 field.
	DMAC_EBCIDR_DICERR7_Pos = 0x1f
	// Bit mask of DICERR7 field.
	DMAC_EBCIDR_DICERR7_Msk = 0x80000000
	// Bit DICERR7.
	DMAC_EBCIDR_DICERR7 = 0x80000000

	// EBCIMR: DMAC Error, Chained Buffer Transfer Completed Interrupt and Buffer transfer completed Mask Register.
	// Position of BTC0 field.
	DMAC_EBCIMR_BTC0_Pos = 0x0
	// Bit mask of BTC0 field.
	DMAC_EBCIMR_BTC0_Msk = 0x1
	// Bit BTC0.
	DMAC_EBCIMR_BTC0 = 0x1
	// Position of BTC1 field.
	DMAC_EBCIMR_BTC1_Pos = 0x1
	// Bit mask of BTC1 field.
	DMAC_EBCIMR_BTC1_Msk = 0x2
	// Bit BTC1.
	DMAC_EBCIMR_BTC1 = 0x2
	// Position of BTC2 field.
	DMAC_EBCIMR_BTC2_Pos = 0x2
	// Bit mask of BTC2 field.
	DMAC_EBCIMR_BTC2_Msk = 0x4
	// Bit BTC2.
	DMAC_EBCIMR_BTC2 = 0x4
	// Position of BTC3 field.
	DMAC_EBCIMR_BTC3_Pos = 0x3
	// Bit mask of BTC3 field.
	DMAC_EBCIMR_BTC3_Msk = 0x8
	// Bit BTC3.
	DMAC_EBCIMR_BTC3 = 0x8
	// Position of BTC4 field.
	DMAC_EBCIMR_BTC4_Pos = 0x4
	// Bit mask of BTC4 field.
	DMAC_EBCIMR_BTC4_Msk = 0x10
	// Bit BTC4.
	DMAC_EBCIMR_BTC4 = 0x10
	// Position of BTC5 field.
	DMAC_EBCIMR_BTC5_Pos = 0x5
	// Bit mask of BTC5 field.
	DMAC_EBCIMR_BTC5_Msk = 0x20
	// Bit BTC5.
	DMAC_EBCIMR_BTC5 = 0x20
	// Position of BTC6 field.
	DMAC_EBCIMR_BTC6_Pos = 0x6
	// Bit mask of BTC6 field.
	DMAC_EBCIMR_BTC6_Msk = 0x40
	// Bit BTC6.
	DMAC_EBCIMR_BTC6 = 0x40
	// Position of BTC7 field.
	DMAC_EBCIMR_BTC7_Pos = 0x7
	// Bit mask of BTC7 field.
	DMAC_EBCIMR_BTC7_Msk = 0x80
	// Bit BTC7.
	DMAC_EBCIMR_BTC7 = 0x80
	// Position of CBTC0 field.
	DMAC_EBCIMR_CBTC0_Pos = 0x8
	// Bit mask of CBTC0 field.
	DMAC_EBCIMR_CBTC0_Msk = 0x100
	// Bit CBTC0.
	DMAC_EBCIMR_CBTC0 = 0x100
	// Position of CBTC1 field.
	DMAC_EBCIMR_CBTC1_Pos = 0x9
	// Bit mask of CBTC1 field.
	DMAC_EBCIMR_CBTC1_Msk = 0x200
	// Bit CBTC1.
	DMAC_EBCIMR_CBTC1 = 0x200
	// Position of CBTC2 field.
	DMAC_EBCIMR_CBTC2_Pos = 0xa
	// Bit mask of CBTC2 field.
	DMAC_EBCIMR_CBTC2_Msk = 0x400
	// Bit CBTC2.
	DMAC_EBCIMR_CBTC2 = 0x400
	// Position of CBTC3 field.
	DMAC_EBCIMR_CBTC3_Pos = 0xb
	// Bit mask of CBTC3 field.
	DMAC_EBCIMR_CBTC3_Msk = 0x800
	// Bit CBTC3.
	DMAC_EBCIMR_CBTC3 = 0x800
	// Position of CBTC4 field.
	DMAC_EBCIMR_CBTC4_Pos = 0xc
	// Bit mask of CBTC4 field.
	DMAC_EBCIMR_CBTC4_Msk = 0x1000
	// Bit CBTC4.
	DMAC_EBCIMR_CBTC4 = 0x1000
	// Position of CBTC5 field.
	DMAC_EBCIMR_CBTC5_Pos = 0xd
	// Bit mask of CBTC5 field.
	DMAC_EBCIMR_CBTC5_Msk = 0x2000
	// Bit CBTC5.
	DMAC_EBCIMR_CBTC5 = 0x2000
	// Position of CBTC6 field.
	DMAC_EBCIMR_CBTC6_Pos = 0xe
	// Bit mask of CBTC6 field.
	DMAC_EBCIMR_CBTC6_Msk = 0x4000
	// Bit CBTC6.
	DMAC_EBCIMR_CBTC6 = 0x4000
	// Position of CBTC7 field.
	DMAC_EBCIMR_CBTC7_Pos = 0xf
	// Bit mask of CBTC7 field.
	DMAC_EBCIMR_CBTC7_Msk = 0x8000
	// Bit CBTC7.
	DMAC_EBCIMR_CBTC7 = 0x8000
	// Position of ERR0 field.
	DMAC_EBCIMR_ERR0_Pos = 0x10
	// Bit mask of ERR0 field.
	DMAC_EBCIMR_ERR0_Msk = 0x10000
	// Bit ERR0.
	DMAC_EBCIMR_ERR0 = 0x10000
	// Position of ERR1 field.
	DMAC_EBCIMR_ERR1_Pos = 0x11
	// Bit mask of ERR1 field.
	DMAC_EBCIMR_ERR1_Msk = 0x20000
	// Bit ERR1.
	DMAC_EBCIMR_ERR1 = 0x20000
	// Position of ERR2 field.
	DMAC_EBCIMR_ERR2_Pos = 0x12
	// Bit mask of ERR2 field.
	DMAC_EBCIMR_ERR2_Msk = 0x40000
	// Bit ERR2.
	DMAC_EBCIMR_ERR2 = 0x40000
	// Position of ERR3 field.
	DMAC_EBCIMR_ERR3_Pos = 0x13
	// Bit mask of ERR3 field.
	DMAC_EBCIMR_ERR3_Msk = 0x80000
	// Bit ERR3.
	DMAC_EBCIMR_ERR3 = 0x80000
	// Position of ERR4 field.
	DMAC_EBCIMR_ERR4_Pos = 0x14
	// Bit mask of ERR4 field.
	DMAC_EBCIMR_ERR4_Msk = 0x100000
	// Bit ERR4.
	DMAC_EBCIMR_ERR4 = 0x100000
	// Position of ERR5 field.
	DMAC_EBCIMR_ERR5_Pos = 0x15
	// Bit mask of ERR5 field.
	DMAC_EBCIMR_ERR5_Msk = 0x200000
	// Bit ERR5.
	DMAC_EBCIMR_ERR5 = 0x200000
	// Position of ERR6 field.
	DMAC_EBCIMR_ERR6_Pos = 0x16
	// Bit mask of ERR6 field.
	DMAC_EBCIMR_ERR6_Msk = 0x400000
	// Bit ERR6.
	DMAC_EBCIMR_ERR6 = 0x400000
	// Position of ERR7 field.
	DMAC_EBCIMR_ERR7_Pos = 0x17
	// Bit mask of ERR7 field.
	DMAC_EBCIMR_ERR7_Msk = 0x800000
	// Bit ERR7.
	DMAC_EBCIMR_ERR7 = 0x800000
	// Position of DICERR0 field.
	DMAC_EBCIMR_DICERR0_Pos = 0x18
	// Bit mask of DICERR0 field.
	DMAC_EBCIMR_DICERR0_Msk = 0x1000000
	// Bit DICERR0.
	DMAC_EBCIMR_DICERR0 = 0x1000000
	// Position of DICERR1 field.
	DMAC_EBCIMR_DICERR1_Pos = 0x19
	// Bit mask of DICERR1 field.
	DMAC_EBCIMR_DICERR1_Msk = 0x2000000
	// Bit DICERR1.
	DMAC_EBCIMR_DICERR1 = 0x2000000
	// Position of DICERR2 field.
	DMAC_EBCIMR_DICERR2_Pos = 0x1a
	// Bit mask of DICERR2 field.
	DMAC_EBCIMR_DICERR2_Msk = 0x4000000
	// Bit DICERR2.
	DMAC_EBCIMR_DICERR2 = 0x4000000
	// Position of DICERR3 field.
	DMAC_EBCIMR_DICERR3_Pos = 0x1b
	// Bit mask of DICERR3 field.
	DMAC_EBCIMR_DICERR3_Msk = 0x8000000
	// Bit DICERR3.
	DMAC_EBCIMR_DICERR3 = 0x8000000
	// Position of DICERR4 field.
	DMAC_EBCIMR_DICERR4_Pos = 0x1c
	// Bit mask of DICERR4 field.
	DMAC_EBCIMR_DICERR4_Msk = 0x10000000
	// Bit DICERR4.
	DMAC_EBCIMR_DICERR4 = 0x10000000
	// Position of DICERR5 field.
	DMAC_EBCIMR_DICERR5_Pos = 0x1d
	// Bit mask of DICERR5 field.
	DMAC_EBCIMR_DICERR5_Msk = 0x20000000
	// Bit DICERR5.
	DMAC_EBCIMR_DICERR5 = 0x20000000
	// Position of DICERR6 field.
	DMAC_EBCIMR_DICERR6_Pos = 0x1e
	// Bit mask of DICERR6 field.
	DMAC_EBCIMR_DICERR6_Msk = 0x40000000
	// Bit DICERR6.
	DMAC_EBCIMR_DICERR6 = 0x40000000
	// Position of DICERR7 field.
	DMAC_EBCIMR_DICERR7_Pos = 0x1f
	// Bit mask of DICERR7 field.
	DMAC_EBCIMR_DICERR7_Msk = 0x80000000
	// Bit DICERR7.
	DMAC_EBCIMR_DICERR7 = 0x80000000

	// EBCISR: DMAC Error, Chained Buffer Transfer Completed Interrupt and Buffer transfer completed Status Register.
	// Position of BTC0 field.
	DMAC_EBCISR_BTC0_Pos = 0x0
	// Bit mask of BTC0 field.
	DMAC_EBCISR_BTC0_Msk = 0x1
	// Bit BTC0.
	DMAC_EBCISR_BTC0 = 0x1
	// Position of BTC1 field.
	DMAC_EBCISR_BTC1_Pos = 0x1
	// Bit mask of BTC1 field.
	DMAC_EBCISR_BTC1_Msk = 0x2
	// Bit BTC1.
	DMAC_EBCISR_BTC1 = 0x2
	// Position of BTC2 field.
	DMAC_EBCISR_BTC2_Pos = 0x2
	// Bit mask of BTC2 field.
	DMAC_EBCISR_BTC2_Msk = 0x4
	// Bit BTC2.
	DMAC_EBCISR_BTC2 = 0x4
	// Position of BTC3 field.
	DMAC_EBCISR_BTC3_Pos = 0x3
	// Bit mask of BTC3 field.
	DMAC_EBCISR_BTC3_Msk = 0x8
	// Bit BTC3.
	DMAC_EBCISR_BTC3 = 0x8
	// Position of BTC4 field.
	DMAC_EBCISR_BTC4_Pos = 0x4
	// Bit mask of BTC4 field.
	DMAC_EBCISR_BTC4_Msk = 0x10
	// Bit BTC4.
	DMAC_EBCISR_BTC4 = 0x10
	// Position of BTC5 field.
	DMAC_EBCISR_BTC5_Pos = 0x5
	// Bit mask of BTC5 field.
	DMAC_EBCISR_BTC5_Msk = 0x20
	// Bit BTC5.
	DMAC_EBCISR_BTC5 = 0x20
	// Position of BTC6 field.
	DMAC_EBCISR_BTC6_Pos = 0x6
	// Bit mask of BTC6 field.
	DMAC_EBCISR_BTC6_Msk = 0x40
	// Bit BTC6.
	DMAC_EBCISR_BTC6 = 0x40
	// Position of BTC7 field.
	DMAC_EBCISR_BTC7_Pos = 0x7
	// Bit mask of BTC7 field.
	DMAC_EBCISR_BTC7_Msk = 0x80
	// Bit BTC7.
	DMAC_EBCISR_BTC7 = 0x80
	// Position of CBTC0 field.
	DMAC_EBCISR_CBTC0_Pos = 0x8
	// Bit mask of CBTC0 field.
	DMAC_EBCISR_CBTC0_Msk = 0x100
	// Bit CBTC0.
	DMAC_EBCISR_CBTC0 = 0x100
	// Position of CBTC1 field.
	DMAC_EBCISR_CBTC1_Pos = 0x9
	// Bit mask of CBTC1 field.
	DMAC_EBCISR_CBTC1_Msk = 0x200
	// Bit CBTC1.
	DMAC_EBCISR_CBTC1 = 0x200
	// Position of CBTC2 field.
	DMAC_EBCISR_CBTC2_Pos = 0xa
	// Bit mask of CBTC2 field.
	DMAC_EBCISR_CBTC2_Msk = 0x400
	// Bit CBTC2.
	DMAC_EBCISR_CBTC2 = 0x400
	// Position of CBTC3 field.
	DMAC_EBCISR_CBTC3_Pos = 0xb
	// Bit mask of CBTC3 field.
	DMAC_EBCISR_CBTC3_Msk = 0x800
	// Bit CBTC3.
	DMAC_EBCISR_CBTC3 = 0x800
	// Position of CBTC4 field.
	DMAC_EBCISR_CBTC4_Pos = 0xc
	// Bit mask of CBTC4 field.
	DMAC_EBCISR_CBTC4_Msk = 0x1000
	// Bit CBTC4.
	DMAC_EBCISR_CBTC4 = 0x1000
	// Position of CBTC5 field.
	DMAC_EBCISR_CBTC5_Pos = 0xd
	// Bit mask of CBTC5 field.
	DMAC_EBCISR_CBTC5_Msk = 0x2000
	// Bit CBTC5.
	DMAC_EBCISR_CBTC5 = 0x2000
	// Position of CBTC6 field.
	DMAC_EBCISR_CBTC6_Pos = 0xe
	// Bit mask of CBTC6 field.
	DMAC_EBCISR_CBTC6_Msk = 0x4000
	// Bit CBTC6.
	DMAC_EBCISR_CBTC6 = 0x4000
	// Position of CBTC7 field.
	DMAC_EBCISR_CBTC7_Pos = 0xf
	// Bit mask of CBTC7 field.
	DMAC_EBCISR_CBTC7_Msk = 0x8000
	// Bit CBTC7.
	DMAC_EBCISR_CBTC7 = 0x8000
	// Position of ERR0 field.
	DMAC_EBCISR_ERR0_Pos = 0x10
	// Bit mask of ERR0 field.
	DMAC_EBCISR_ERR0_Msk = 0x10000
	// Bit ERR0.
	DMAC_EBCISR_ERR0 = 0x10000
	// Position of ERR1 field.
	DMAC_EBCISR_ERR1_Pos = 0x11
	// Bit mask of ERR1 field.
	DMAC_EBCISR_ERR1_Msk = 0x20000
	// Bit ERR1.
	DMAC_EBCISR_ERR1 = 0x20000
	// Position of ERR2 field.
	DMAC_EBCISR_ERR2_Pos = 0x12
	// Bit mask of ERR2 field.
	DMAC_EBCISR_ERR2_Msk = 0x40000
	// Bit ERR2.
	DMAC_EBCISR_ERR2 = 0x40000
	// Position of ERR3 field.
	DMAC_EBCISR_ERR3_Pos = 0x13
	// Bit mask of ERR3 field.
	DMAC_EBCISR_ERR3_Msk = 0x80000
	// Bit ERR3.
	DMAC_EBCISR_ERR3 = 0x80000
	// Position of ERR4 field.
	DMAC_EBCISR_ERR4_Pos = 0x14
	// Bit mask of ERR4 field.
	DMAC_EBCISR_ERR4_Msk = 0x100000
	// Bit ERR4.
	DMAC_EBCISR_ERR4 = 0x100000
	// Position of ERR5 field.
	DMAC_EBCISR_ERR5_Pos = 0x15
	// Bit mask of ERR5 field.
	DMAC_EBCISR_ERR5_Msk = 0x200000
	// Bit ERR5.
	DMAC_EBCISR_ERR5 = 0x200000
	// Position of ERR6 field.
	DMAC_EBCISR_ERR6_Pos = 0x16
	// Bit mask of ERR6 field.
	DMAC_EBCISR_ERR6_Msk = 0x400000
	// Bit ERR6.
	DMAC_EBCISR_ERR6 = 0x400000
	// Position of ERR7 field.
	DMAC_EBCISR_ERR7_Pos = 0x17
	// Bit mask of ERR7 field.
	DMAC_EBCISR_ERR7_Msk = 0x800000
	// Bit ERR7.
	DMAC_EBCISR_ERR7 = 0x800000
	// Position of DICERR0 field.
	DMAC_EBCISR_DICERR0_Pos = 0x18
	// Bit mask of DICERR0 field.
	DMAC_EBCISR_DICERR0_Msk = 0x1000000
	// Bit DICERR0.
	DMAC_EBCISR_DICERR0 = 0x1000000
	// Position of DICERR1 field.
	DMAC_EBCISR_DICERR1_Pos = 0x19
	// Bit mask of DICERR1 field.
	DMAC_EBCISR_DICERR1_Msk = 0x2000000
	// Bit DICERR1.
	DMAC_EBCISR_DICERR1 = 0x2000000
	// Position of DICERR2 field.
	DMAC_EBCISR_DICERR2_Pos = 0x1a
	// Bit mask of DICERR2 field.
	DMAC_EBCISR_DICERR2_Msk = 0x4000000
	// Bit DICERR2.
	DMAC_EBCISR_DICERR2 = 0x4000000
	// Position of DICERR3 field.
	DMAC_EBCISR_DICERR3_Pos = 0x1b
	// Bit mask of DICERR3 field.
	DMAC_EBCISR_DICERR3_Msk = 0x8000000
	// Bit DICERR3.
	DMAC_EBCISR_DICERR3 = 0x8000000
	// Position of DICERR4 field.
	DMAC_EBCISR_DICERR4_Pos = 0x1c
	// Bit mask of DICERR4 field.
	DMAC_EBCISR_DICERR4_Msk = 0x10000000
	// Bit DICERR4.
	DMAC_EBCISR_DICERR4 = 0x10000000
	// Position of DICERR5 field.
	DMAC_EBCISR_DICERR5_Pos = 0x1d
	// Bit mask of DICERR5 field.
	DMAC_EBCISR_DICERR5_Msk = 0x20000000
	// Bit DICERR5.
	DMAC_EBCISR_DICERR5 = 0x20000000
	// Position of DICERR6 field.
	DMAC_EBCISR_DICERR6_Pos = 0x1e
	// Bit mask of DICERR6 field.
	DMAC_EBCISR_DICERR6_Msk = 0x40000000
	// Bit DICERR6.
	DMAC_EBCISR_DICERR6 = 0x40000000
	// Position of DICERR7 field.
	DMAC_EBCISR_DICERR7_Pos = 0x1f
	// Bit mask of DICERR7 field.
	DMAC_EBCISR_DICERR7_Msk = 0x80000000
	// Bit DICERR7.
	DMAC_EBCISR_DICERR7 = 0x80000000

	// CHER: DMAC Channel Handler Enable Register
	// Position of ENA0 field.
	DMAC_CHER_ENA0_Pos = 0x0
	// Bit mask of ENA0 field.
	DMAC_CHER_ENA0_Msk = 0x1
	// Bit ENA0.
	DMAC_CHER_ENA0 = 0x1
	// Position of ENA1 field.
	DMAC_CHER_ENA1_Pos = 0x1
	// Bit mask of ENA1 field.
	DMAC_CHER_ENA1_Msk = 0x2
	// Bit ENA1.
	DMAC_CHER_ENA1 = 0x2
	// Position of ENA2 field.
	DMAC_CHER_ENA2_Pos = 0x2
	// Bit mask of ENA2 field.
	DMAC_CHER_ENA2_Msk = 0x4
	// Bit ENA2.
	DMAC_CHER_ENA2 = 0x4
	// Position of ENA3 field.
	DMAC_CHER_ENA3_Pos = 0x3
	// Bit mask of ENA3 field.
	DMAC_CHER_ENA3_Msk = 0x8
	// Bit ENA3.
	DMAC_CHER_ENA3 = 0x8
	// Position of ENA4 field.
	DMAC_CHER_ENA4_Pos = 0x4
	// Bit mask of ENA4 field.
	DMAC_CHER_ENA4_Msk = 0x10
	// Bit ENA4.
	DMAC_CHER_ENA4 = 0x10
	// Position of ENA5 field.
	DMAC_CHER_ENA5_Pos = 0x5
	// Bit mask of ENA5 field.
	DMAC_CHER_ENA5_Msk = 0x20
	// Bit ENA5.
	DMAC_CHER_ENA5 = 0x20
	// Position of ENA6 field.
	DMAC_CHER_ENA6_Pos = 0x6
	// Bit mask of ENA6 field.
	DMAC_CHER_ENA6_Msk = 0x40
	// Bit ENA6.
	DMAC_CHER_ENA6 = 0x40
	// Position of ENA7 field.
	DMAC_CHER_ENA7_Pos = 0x7
	// Bit mask of ENA7 field.
	DMAC_CHER_ENA7_Msk = 0x80
	// Bit ENA7.
	DMAC_CHER_ENA7 = 0x80
	// Position of SUSP0 field.
	DMAC_CHER_SUSP0_Pos = 0x8
	// Bit mask of SUSP0 field.
	DMAC_CHER_SUSP0_Msk = 0x100
	// Bit SUSP0.
	DMAC_CHER_SUSP0 = 0x100
	// Position of SUSP1 field.
	DMAC_CHER_SUSP1_Pos = 0x9
	// Bit mask of SUSP1 field.
	DMAC_CHER_SUSP1_Msk = 0x200
	// Bit SUSP1.
	DMAC_CHER_SUSP1 = 0x200
	// Position of SUSP2 field.
	DMAC_CHER_SUSP2_Pos = 0xa
	// Bit mask of SUSP2 field.
	DMAC_CHER_SUSP2_Msk = 0x400
	// Bit SUSP2.
	DMAC_CHER_SUSP2 = 0x400
	// Position of SUSP3 field.
	DMAC_CHER_SUSP3_Pos = 0xb
	// Bit mask of SUSP3 field.
	DMAC_CHER_SUSP3_Msk = 0x800
	// Bit SUSP3.
	DMAC_CHER_SUSP3 = 0x800
	// Position of SUSP4 field.
	DMAC_CHER_SUSP4_Pos = 0xc
	// Bit mask of SUSP4 field.
	DMAC_CHER_SUSP4_Msk = 0x1000
	// Bit SUSP4.
	DMAC_CHER_SUSP4 = 0x1000
	// Position of SUSP5 field.
	DMAC_CHER_SUSP5_Pos = 0xd
	// Bit mask of SUSP5 field.
	DMAC_CHER_SUSP5_Msk = 0x2000
	// Bit SUSP5.
	DMAC_CHER_SUSP5 = 0x2000
	// Position of SUSP6 field.
	DMAC_CHER_SUSP6_Pos = 0xe
	// Bit mask of SUSP6 field.
	DMAC_CHER_SUSP6_Msk = 0x4000
	// Bit SUSP6.
	DMAC_CHER_SUSP6 = 0x4000
	// Position of SUSP7 field.
	DMAC_CHER_SUSP7_Pos = 0xf
	// Bit mask of SUSP7 field.
	DMAC_CHER_SUSP7_Msk = 0x8000
	// Bit SUSP7.
	DMAC_CHER_SUSP7 = 0x8000
	// Position of KEEP0 field.
	DMAC_CHER_KEEP0_Pos = 0x18
	// Bit mask of KEEP0 field.
	DMAC_CHER_KEEP0_Msk = 0x1000000
	// Bit KEEP0.
	DMAC_CHER_KEEP0 = 0x1000000
	// Position of KEEP1 field.
	DMAC_CHER_KEEP1_Pos = 0x19
	// Bit mask of KEEP1 field.
	DMAC_CHER_KEEP1_Msk = 0x2000000
	// Bit KEEP1.
	DMAC_CHER_KEEP1 = 0x2000000
	// Position of KEEP2 field.
	DMAC_CHER_KEEP2_Pos = 0x1a
	// Bit mask of KEEP2 field.
	DMAC_CHER_KEEP2_Msk = 0x4000000
	// Bit KEEP2.
	DMAC_CHER_KEEP2 = 0x4000000
	// Position of KEEP3 field.
	DMAC_CHER_KEEP3_Pos = 0x1b
	// Bit mask of KEEP3 field.
	DMAC_CHER_KEEP3_Msk = 0x8000000
	// Bit KEEP3.
	DMAC_CHER_KEEP3 = 0x8000000
	// Position of KEEP4 field.
	DMAC_CHER_KEEP4_Pos = 0x1c
	// Bit mask of KEEP4 field.
	DMAC_CHER_KEEP4_Msk = 0x10000000
	// Bit KEEP4.
	DMAC_CHER_KEEP4 = 0x10000000
	// Position of KEEP5 field.
	DMAC_CHER_KEEP5_Pos = 0x1d
	// Bit mask of KEEP5 field.
	DMAC_CHER_KEEP5_Msk = 0x20000000
	// Bit KEEP5.
	DMAC_CHER_KEEP5 = 0x20000000
	// Position of KEEP6 field.
	DMAC_CHER_KEEP6_Pos = 0x1e
	// Bit mask of KEEP6 field.
	DMAC_CHER_KEEP6_Msk = 0x40000000
	// Bit KEEP6.
	DMAC_CHER_KEEP6 = 0x40000000
	// Position of KEEP7 field.
	DMAC_CHER_KEEP7_Pos = 0x1f
	// Bit mask of KEEP7 field.
	DMAC_CHER_KEEP7_Msk = 0x80000000
	// Bit KEEP7.
	DMAC_CHER_KEEP7 = 0x80000000

	// CHDR: DMAC Channel Handler Disable Register
	// Position of DIS0 field.
	DMAC_CHDR_DIS0_Pos = 0x0
	// Bit mask of DIS0 field.
	DMAC_CHDR_DIS0_Msk = 0x1
	// Bit DIS0.
	DMAC_CHDR_DIS0 = 0x1
	// Position of DIS1 field.
	DMAC_CHDR_DIS1_Pos = 0x1
	// Bit mask of DIS1 field.
	DMAC_CHDR_DIS1_Msk = 0x2
	// Bit DIS1.
	DMAC_CHDR_DIS1 = 0x2
	// Position of DIS2 field.
	DMAC_CHDR_DIS2_Pos = 0x2
	// Bit mask of DIS2 field.
	DMAC_CHDR_DIS2_Msk = 0x4
	// Bit DIS2.
	DMAC_CHDR_DIS2 = 0x4
	// Position of DIS3 field.
	DMAC_CHDR_DIS3_Pos = 0x3
	// Bit mask of DIS3 field.
	DMAC_CHDR_DIS3_Msk = 0x8
	// Bit DIS3.
	DMAC_CHDR_DIS3 = 0x8
	// Position of DIS4 field.
	DMAC_CHDR_DIS4_Pos = 0x4
	// Bit mask of DIS4 field.
	DMAC_CHDR_DIS4_Msk = 0x10
	// Bit DIS4.
	DMAC_CHDR_DIS4 = 0x10
	// Position of DIS5 field.
	DMAC_CHDR_DIS5_Pos = 0x5
	// Bit mask of DIS5 field.
	DMAC_CHDR_DIS5_Msk = 0x20
	// Bit DIS5.
	DMAC_CHDR_DIS5 = 0x20
	// Position of DIS6 field.
	DMAC_CHDR_DIS6_Pos = 0x6
	// Bit mask of DIS6 field.
	DMAC_CHDR_DIS6_Msk = 0x40
	// Bit DIS6.
	DMAC_CHDR_DIS6 = 0x40
	// Position of DIS7 field.
	DMAC_CHDR_DIS7_Pos = 0x7
	// Bit mask of DIS7 field.
	DMAC_CHDR_DIS7_Msk = 0x80
	// Bit DIS7.
	DMAC_CHDR_DIS7 = 0x80
	// Position of RES0 field.
	DMAC_CHDR_RES0_Pos = 0x8
	// Bit mask of RES0 field.
	DMAC_CHDR_RES0_Msk = 0x100
	// Bit RES0.
	DMAC_CHDR_RES0 = 0x100
	// Position of RES1 field.
	DMAC_CHDR_RES1_Pos = 0x9
	// Bit mask of RES1 field.
	DMAC_CHDR_RES1_Msk = 0x200
	// Bit RES1.
	DMAC_CHDR_RES1 = 0x200
	// Position of RES2 field.
	DMAC_CHDR_RES2_Pos = 0xa
	// Bit mask of RES2 field.
	DMAC_CHDR_RES2_Msk = 0x400
	// Bit RES2.
	DMAC_CHDR_RES2 = 0x400
	// Position of RES3 field.
	DMAC_CHDR_RES3_Pos = 0xb
	// Bit mask of RES3 field.
	DMAC_CHDR_RES3_Msk = 0x800
	// Bit RES3.
	DMAC_CHDR_RES3 = 0x800
	// Position of RES4 field.
	DMAC_CHDR_RES4_Pos = 0xc
	// Bit mask of RES4 field.
	DMAC_CHDR_RES4_Msk = 0x1000
	// Bit RES4.
	DMAC_CHDR_RES4 = 0x1000
	// Position of RES5 field.
	DMAC_CHDR_RES5_Pos = 0xd
	// Bit mask of RES5 field.
	DMAC_CHDR_RES5_Msk = 0x2000
	// Bit RES5.
	DMAC_CHDR_RES5 = 0x2000
	// Position of RES6 field.
	DMAC_CHDR_RES6_Pos = 0xe
	// Bit mask of RES6 field.
	DMAC_CHDR_RES6_Msk = 0x4000
	// Bit RES6.
	DMAC_CHDR_RES6 = 0x4000
	// Position of RES7 field.
	DMAC_CHDR_RES7_Pos = 0xf
	// Bit mask of RES7 field.
	DMAC_CHDR_RES7_Msk = 0x8000
	// Bit RES7.
	DMAC_CHDR_RES7 = 0x8000

	// CHSR: DMAC Channel Handler Status Register
	// Position of ENA0 field.
	DMAC_CHSR_ENA0_Pos = 0x0
	// Bit mask of ENA0 field.
	DMAC_CHSR_ENA0_Msk = 0x1
	// Bit ENA0.
	DMAC_CHSR_ENA0 = 0x1
	// Position of ENA1 field.
	DMAC_CHSR_ENA1_Pos = 0x1
	// Bit mask of ENA1 field.
	DMAC_CHSR_ENA1_Msk = 0x2
	// Bit ENA1.
	DMAC_CHSR_ENA1 = 0x2
	// Position of ENA2 field.
	DMAC_CHSR_ENA2_Pos = 0x2
	// Bit mask of ENA2 field.
	DMAC_CHSR_ENA2_Msk = 0x4
	// Bit ENA2.
	DMAC_CHSR_ENA2 = 0x4
	// Position of ENA3 field.
	DMAC_CHSR_ENA3_Pos = 0x3
	// Bit mask of ENA3 field.
	DMAC_CHSR_ENA3_Msk = 0x8
	// Bit ENA3.
	DMAC_CHSR_ENA3 = 0x8
	// Position of ENA4 field.
	DMAC_CHSR_ENA4_Pos = 0x4
	// Bit mask of ENA4 field.
	DMAC_CHSR_ENA4_Msk = 0x10
	// Bit ENA4.
	DMAC_CHSR_ENA4 = 0x10
	// Position of ENA5 field.
	DMAC_CHSR_ENA5_Pos = 0x5
	// Bit mask of ENA5 field.
	DMAC_CHSR_ENA5_Msk = 0x20
	// Bit ENA5.
	DMAC_CHSR_ENA5 = 0x20
	// Position of ENA6 field.
	DMAC_CHSR_ENA6_Pos = 0x6
	// Bit mask of ENA6 field.
	DMAC_CHSR_ENA6_Msk = 0x40
	// Bit ENA6.
	DMAC_CHSR_ENA6 = 0x40
	// Position of ENA7 field.
	DMAC_CHSR_ENA7_Pos = 0x7
	// Bit mask of ENA7 field.
	DMAC_CHSR_ENA7_Msk = 0x80
	// Bit ENA7.
	DMAC_CHSR_ENA7 = 0x80
	// Position of SUSP0 field.
	DMAC_CHSR_SUSP0_Pos = 0x8
	// Bit mask of SUSP0 field.
	DMAC_CHSR_SUSP0_Msk = 0x100
	// Bit SUSP0.
	DMAC_CHSR_SUSP0 = 0x100
	// Position of SUSP1 field.
	DMAC_CHSR_SUSP1_Pos = 0x9
	// Bit mask of SUSP1 field.
	DMAC_CHSR_SUSP1_Msk = 0x200
	// Bit SUSP1.
	DMAC_CHSR_SUSP1 = 0x200
	// Position of SUSP2 field.
	DMAC_CHSR_SUSP2_Pos = 0xa
	// Bit mask of SUSP2 field.
	DMAC_CHSR_SUSP2_Msk = 0x400
	// Bit SUSP2.
	DMAC_CHSR_SUSP2 = 0x400
	// Position of SUSP3 field.
	DMAC_CHSR_SUSP3_Pos = 0xb
	// Bit mask of SUSP3 field.
	DMAC_CHSR_SUSP3_Msk = 0x800
	// Bit SUSP3.
	DMAC_CHSR_SUSP3 = 0x800
	// Position of SUSP4 field.
	DMAC_CHSR_SUSP4_Pos = 0xc
	// Bit mask of SUSP4 field.
	DMAC_CHSR_SUSP4_Msk = 0x1000
	// Bit SUSP4.
	DMAC_CHSR_SUSP4 = 0x1000
	// Position of SUSP5 field.
	DMAC_CHSR_SUSP5_Pos = 0xd
	// Bit mask of SUSP5 field.
	DMAC_CHSR_SUSP5_Msk = 0x2000
	// Bit SUSP5.
	DMAC_CHSR_SUSP5 = 0x2000
	// Position of SUSP6 field.
	DMAC_CHSR_SUSP6_Pos = 0xe
	// Bit mask of SUSP6 field.
	DMAC_CHSR_SUSP6_Msk = 0x4000
	// Bit SUSP6.
	DMAC_CHSR_SUSP6 = 0x4000
	// Position of SUSP7 field.
	DMAC_CHSR_SUSP7_Pos = 0xf
	// Bit mask of SUSP7 field.
	DMAC_CHSR_SUSP7_Msk = 0x8000
	// Bit SUSP7.
	DMAC_CHSR_SUSP7 = 0x8000
	// Position of EMPT0 field.
	DMAC_CHSR_EMPT0_Pos = 0x10
	// Bit mask of EMPT0 field.
	DMAC_CHSR_EMPT0_Msk = 0x10000
	// Bit EMPT0.
	DMAC_CHSR_EMPT0 = 0x10000
	// Position of EMPT1 field.
	DMAC_CHSR_EMPT1_Pos = 0x11
	// Bit mask of EMPT1 field.
	DMAC_CHSR_EMPT1_Msk = 0x20000
	// Bit EMPT1.
	DMAC_CHSR_EMPT1 = 0x20000
	// Position of EMPT2 field.
	DMAC_CHSR_EMPT2_Pos = 0x12
	// Bit mask of EMPT2 field.
	DMAC_CHSR_EMPT2_Msk = 0x40000
	// Bit EMPT2.
	DMAC_CHSR_EMPT2 = 0x40000
	// Position of EMPT3 field.
	DMAC_CHSR_EMPT3_Pos = 0x13
	// Bit mask of EMPT3 field.
	DMAC_CHSR_EMPT3_Msk = 0x80000
	// Bit EMPT3.
	DMAC_CHSR_EMPT3 = 0x80000
	// Position of EMPT4 field.
	DMAC_CHSR_EMPT4_Pos = 0x14
	// Bit mask of EMPT4 field.
	DMAC_CHSR_EMPT4_Msk = 0x100000
	// Bit EMPT4.
	DMAC_CHSR_EMPT4 = 0x100000
	// Position of EMPT5 field.
	DMAC_CHSR_EMPT5_Pos = 0x15
	// Bit mask of EMPT5 field.
	DMAC_CHSR_EMPT5_Msk = 0x200000
	// Bit EMPT5.
	DMAC_CHSR_EMPT5 = 0x200000
	// Position of EMPT6 field.
	DMAC_CHSR_EMPT6_Pos = 0x16
	// Bit mask of EMPT6 field.
	DMAC_CHSR_EMPT6_Msk = 0x400000
	// Bit EMPT6.
	DMAC_CHSR_EMPT6 = 0x400000
	// Position of EMPT7 field.
	DMAC_CHSR_EMPT7_Pos = 0x17
	// Bit mask of EMPT7 field.
	DMAC_CHSR_EMPT7_Msk = 0x800000
	// Bit EMPT7.
	DMAC_CHSR_EMPT7 = 0x800000
	// Position of STAL0 field.
	DMAC_CHSR_STAL0_Pos = 0x18
	// Bit mask of STAL0 field.
	DMAC_CHSR_STAL0_Msk = 0x1000000
	// Bit STAL0.
	DMAC_CHSR_STAL0 = 0x1000000
	// Position of STAL1 field.
	DMAC_CHSR_STAL1_Pos = 0x19
	// Bit mask of STAL1 field.
	DMAC_CHSR_STAL1_Msk = 0x2000000
	// Bit STAL1.
	DMAC_CHSR_STAL1 = 0x2000000
	// Position of STAL2 field.
	DMAC_CHSR_STAL2_Pos = 0x1a
	// Bit mask of STAL2 field.
	DMAC_CHSR_STAL2_Msk = 0x4000000
	// Bit STAL2.
	DMAC_CHSR_STAL2 = 0x4000000
	// Position of STAL3 field.
	DMAC_CHSR_STAL3_Pos = 0x1b
	// Bit mask of STAL3 field.
	DMAC_CHSR_STAL3_Msk = 0x8000000
	// Bit STAL3.
	DMAC_CHSR_STAL3 = 0x8000000
	// Position of STAL4 field.
	DMAC_CHSR_STAL4_Pos = 0x1c
	// Bit mask of STAL4 field.
	DMAC_CHSR_STAL4_Msk = 0x10000000
	// Bit STAL4.
	DMAC_CHSR_STAL4 = 0x10000000
	// Position of STAL5 field.
	DMAC_CHSR_STAL5_Pos = 0x1d
	// Bit mask of STAL5 field.
	DMAC_CHSR_STAL5_Msk = 0x20000000
	// Bit STAL5.
	DMAC_CHSR_STAL5 = 0x20000000
	// Position of STAL6 field.
	DMAC_CHSR_STAL6_Pos = 0x1e
	// Bit mask of STAL6 field.
	DMAC_CHSR_STAL6_Msk = 0x40000000
	// Bit STAL6.
	DMAC_CHSR_STAL6 = 0x40000000
	// Position of STAL7 field.
	DMAC_CHSR_STAL7_Pos = 0x1f
	// Bit mask of STAL7 field.
	DMAC_CHSR_STAL7_Msk = 0x80000000
	// Bit STAL7.
	DMAC_CHSR_STAL7 = 0x80000000

	// SADDR0: DMAC Channel Source Address Register (ch_num = 0)
	// Position of SADDR field.
	DMAC_SADDR0_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR0_SADDR_Msk = 0xffffffff

	// DADDR0: DMAC Channel Destination Address Register (ch_num = 0)
	// Position of DADDR field.
	DMAC_DADDR0_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR0_DADDR_Msk = 0xffffffff

	// DSCR0: DMAC Channel Descriptor Address Register (ch_num = 0)
	// Position of DSCR_IF field.
	DMAC_DSCR0_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR0_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR0_DSCR_IF_AHB_IF0 = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR0_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR0_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR0_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR0_DSCR_Msk = 0xfffffffc

	// CTRLA0: DMAC Channel Control A Register (ch_num = 0)
	// Position of BTSIZE field.
	DMAC_CTRLA0_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA0_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA0_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA0_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA0_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA0_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA0_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA0_SCSIZE_CHK_16 = 0x3
	// Position of DCSIZE field.
	DMAC_CTRLA0_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA0_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA0_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA0_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA0_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA0_DCSIZE_CHK_16 = 0x3
	// Position of SRC_WIDTH field.
	DMAC_CTRLA0_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA0_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA0_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA0_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA0_SRC_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA0_SRC_WIDTH_DWORD = 0x3
	// Position of DST_WIDTH field.
	DMAC_CTRLA0_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA0_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA0_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA0_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA0_DST_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA0_DST_WIDTH_DWORD = 0x3
	// Position of DONE field.
	DMAC_CTRLA0_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA0_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA0_DONE = 0x80000000

	// CTRLB0: DMAC Channel Control B Register (ch_num = 0)
	// Position of SIF field.
	DMAC_CTRLB0_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB0_SIF_Msk = 0x3
	// The source transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB0_SIF_AHB_IF0 = 0x0
	// The source transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB0_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB0_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB0_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB0_DIF_Msk = 0x30
	// The destination transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB0_DIF_AHB_IF0 = 0x0
	// The destination transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB0_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB0_DIF_AHB_IF2 = 0x2
	// Position of SRC_PIP field.
	DMAC_CTRLB0_SRC_PIP_Pos = 0x8
	// Bit mask of SRC_PIP field.
	DMAC_CTRLB0_SRC_PIP_Msk = 0x100
	// Bit SRC_PIP.
	DMAC_CTRLB0_SRC_PIP = 0x100
	// Picture-in-Picture mode is disabled. The source data area is contiguous.
	DMAC_CTRLB0_SRC_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the source PIP counter reaches the programmable boundary, the address is automatically incremented by a user defined amount.
	DMAC_CTRLB0_SRC_PIP_ENABLE = 0x1
	// Position of DST_PIP field.
	DMAC_CTRLB0_DST_PIP_Pos = 0xc
	// Bit mask of DST_PIP field.
	DMAC_CTRLB0_DST_PIP_Msk = 0x1000
	// Bit DST_PIP.
	DMAC_CTRLB0_DST_PIP = 0x1000
	// Picture-in-Picture mode is disabled. The Destination data area is contiguous.
	DMAC_CTRLB0_DST_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the Destination PIP counter reaches the programmable boundary the address is automatically incremented by a user-defined amount.
	DMAC_CTRLB0_DST_PIP_ENABLE = 0x1
	// Position of SRC_DSCR field.
	DMAC_CTRLB0_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB0_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB0_SRC_DSCR = 0x10000
	// Source address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB0_SRC_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the source.
	DMAC_CTRLB0_SRC_DSCR_FETCH_DISABLE = 0x1
	// Position of DST_DSCR field.
	DMAC_CTRLB0_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB0_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB0_DST_DSCR = 0x100000
	// Destination address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB0_DST_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the destination.
	DMAC_CTRLB0_DST_DSCR_FETCH_DISABLE = 0x1
	// Position of FC field.
	DMAC_CTRLB0_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB0_FC_Msk = 0x600000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB0_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB0_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB0_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB0_FC_PER2PER_DMA_FC = 0x3
	// Position of SRC_INCR field.
	DMAC_CTRLB0_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB0_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB0_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB0_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB0_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB0_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB0_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB0_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB0_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB0_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB0_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB0_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB0_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB0_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB0_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB0_AUTO = 0x80000000
	// Automatic multiple buffer transfer is disabled.
	DMAC_CTRLB0_AUTO_DISABLE = 0x0
	// Automatic multiple buffer transfer is enabled. This bit enables replay mode or contiguous mode when several buffers are transferred.
	DMAC_CTRLB0_AUTO_ENABLE = 0x1

	// CFG0: DMAC Channel Configuration Register (ch_num = 0)
	// Position of SRC_PER field.
	DMAC_CFG0_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG0_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG0_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG0_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG0_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG0_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG0_SRC_REP = 0x100
	// When automatic mode is activated, source address is contiguous between two buffers.
	DMAC_CFG0_SRC_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the source address and the control register are reloaded from previous transfer.
	DMAC_CFG0_SRC_REP_RELOAD_ADDR = 0x1
	// Position of SRC_H2SEL field.
	DMAC_CFG0_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG0_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG0_SRC_H2SEL = 0x200
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG0_SRC_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG0_SRC_H2SEL_HW = 0x1
	// Position of SRC_PER_MSB field.
	DMAC_CFG0_SRC_PER_MSB_Pos = 0xa
	// Bit mask of SRC_PER_MSB field.
	DMAC_CFG0_SRC_PER_MSB_Msk = 0xc00
	// Position of DST_REP field.
	DMAC_CFG0_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG0_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG0_DST_REP = 0x1000
	// When automatic mode is activated, destination address is contiguous between two buffers.
	DMAC_CFG0_DST_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the destination and the control register are reloaded from the pre-vious transfer.
	DMAC_CFG0_DST_REP_RELOAD_ADDR = 0x1
	// Position of DST_H2SEL field.
	DMAC_CFG0_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG0_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG0_DST_H2SEL = 0x2000
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG0_DST_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG0_DST_H2SEL_HW = 0x1
	// Position of DST_PER_MSB field.
	DMAC_CFG0_DST_PER_MSB_Pos = 0xe
	// Bit mask of DST_PER_MSB field.
	DMAC_CFG0_DST_PER_MSB_Msk = 0xc000
	// Position of SOD field.
	DMAC_CFG0_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG0_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG0_SOD = 0x10000
	// STOP ON DONE disabled, the descriptor fetch operation ignores DONE Field of CTRLA register.
	DMAC_CFG0_SOD_DISABLE = 0x0
	// STOP ON DONE activated, the DMAC module is automatically disabled if DONE FIELD is set to 1.
	DMAC_CFG0_SOD_ENABLE = 0x1
	// Position of LOCK_IF field.
	DMAC_CFG0_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG0_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG0_LOCK_IF = 0x100000
	// Interface Lock capability is disabled
	DMAC_CFG0_LOCK_IF_DISABLE = 0x0
	// Interface Lock capability is enabled
	DMAC_CFG0_LOCK_IF_ENABLE = 0x1
	// Position of LOCK_B field.
	DMAC_CFG0_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG0_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG0_LOCK_B = 0x200000
	// AHB Bus Locking capability is disabled.
	DMAC_CFG0_LOCK_B_DISABLE = 0x0
	// Position of LOCK_IF_L field.
	DMAC_CFG0_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG0_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG0_LOCK_IF_L = 0x400000
	// The Master Interface Arbiter is locked by the channel x for a chunk transfer.
	DMAC_CFG0_LOCK_IF_L_CHUNK = 0x0
	// The Master Interface Arbiter is locked by the channel x for a buffer transfer.
	DMAC_CFG0_LOCK_IF_L_BUFFER = 0x1
	// Position of AHB_PROT field.
	DMAC_CFG0_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG0_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG0_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG0_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG0_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG0_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG0_FIFOCFG_ASAP_CFG = 0x2

	// SPIP0: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 0)
	// Position of SPIP_HOLE field.
	DMAC_SPIP0_SPIP_HOLE_Pos = 0x0
	// Bit mask of SPIP_HOLE field.
	DMAC_SPIP0_SPIP_HOLE_Msk = 0xffff
	// Position of SPIP_BOUNDARY field.
	DMAC_SPIP0_SPIP_BOUNDARY_Pos = 0x10
	// Bit mask of SPIP_BOUNDARY field.
	DMAC_SPIP0_SPIP_BOUNDARY_Msk = 0x3ff0000

	// DPIP0: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 0)
	// Position of DPIP_HOLE field.
	DMAC_DPIP0_DPIP_HOLE_Pos = 0x0
	// Bit mask of DPIP_HOLE field.
	DMAC_DPIP0_DPIP_HOLE_Msk = 0xffff
	// Position of DPIP_BOUNDARY field.
	DMAC_DPIP0_DPIP_BOUNDARY_Pos = 0x10
	// Bit mask of DPIP_BOUNDARY field.
	DMAC_DPIP0_DPIP_BOUNDARY_Msk = 0x3ff0000

	// SADDR1: DMAC Channel Source Address Register (ch_num = 1)
	// Position of SADDR field.
	DMAC_SADDR1_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR1_SADDR_Msk = 0xffffffff

	// DADDR1: DMAC Channel Destination Address Register (ch_num = 1)
	// Position of DADDR field.
	DMAC_DADDR1_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR1_DADDR_Msk = 0xffffffff

	// DSCR1: DMAC Channel Descriptor Address Register (ch_num = 1)
	// Position of DSCR_IF field.
	DMAC_DSCR1_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR1_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR1_DSCR_IF_AHB_IF0 = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR1_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR1_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR1_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR1_DSCR_Msk = 0xfffffffc

	// CTRLA1: DMAC Channel Control A Register (ch_num = 1)
	// Position of BTSIZE field.
	DMAC_CTRLA1_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA1_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA1_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA1_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA1_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA1_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA1_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA1_SCSIZE_CHK_16 = 0x3
	// Position of DCSIZE field.
	DMAC_CTRLA1_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA1_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA1_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA1_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA1_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA1_DCSIZE_CHK_16 = 0x3
	// Position of SRC_WIDTH field.
	DMAC_CTRLA1_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA1_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA1_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA1_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA1_SRC_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA1_SRC_WIDTH_DWORD = 0x3
	// Position of DST_WIDTH field.
	DMAC_CTRLA1_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA1_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA1_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA1_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA1_DST_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA1_DST_WIDTH_DWORD = 0x3
	// Position of DONE field.
	DMAC_CTRLA1_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA1_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA1_DONE = 0x80000000

	// CTRLB1: DMAC Channel Control B Register (ch_num = 1)
	// Position of SIF field.
	DMAC_CTRLB1_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB1_SIF_Msk = 0x3
	// The source transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB1_SIF_AHB_IF0 = 0x0
	// The source transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB1_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB1_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB1_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB1_DIF_Msk = 0x30
	// The destination transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB1_DIF_AHB_IF0 = 0x0
	// The destination transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB1_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB1_DIF_AHB_IF2 = 0x2
	// Position of SRC_PIP field.
	DMAC_CTRLB1_SRC_PIP_Pos = 0x8
	// Bit mask of SRC_PIP field.
	DMAC_CTRLB1_SRC_PIP_Msk = 0x100
	// Bit SRC_PIP.
	DMAC_CTRLB1_SRC_PIP = 0x100
	// Picture-in-Picture mode is disabled. The source data area is contiguous.
	DMAC_CTRLB1_SRC_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the source PIP counter reaches the programmable boundary, the address is automatically incremented by a user defined amount.
	DMAC_CTRLB1_SRC_PIP_ENABLE = 0x1
	// Position of DST_PIP field.
	DMAC_CTRLB1_DST_PIP_Pos = 0xc
	// Bit mask of DST_PIP field.
	DMAC_CTRLB1_DST_PIP_Msk = 0x1000
	// Bit DST_PIP.
	DMAC_CTRLB1_DST_PIP = 0x1000
	// Picture-in-Picture mode is disabled. The Destination data area is contiguous.
	DMAC_CTRLB1_DST_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the Destination PIP counter reaches the programmable boundary the address is automatically incremented by a user-defined amount.
	DMAC_CTRLB1_DST_PIP_ENABLE = 0x1
	// Position of SRC_DSCR field.
	DMAC_CTRLB1_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB1_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB1_SRC_DSCR = 0x10000
	// Source address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB1_SRC_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the source.
	DMAC_CTRLB1_SRC_DSCR_FETCH_DISABLE = 0x1
	// Position of DST_DSCR field.
	DMAC_CTRLB1_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB1_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB1_DST_DSCR = 0x100000
	// Destination address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB1_DST_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the destination.
	DMAC_CTRLB1_DST_DSCR_FETCH_DISABLE = 0x1
	// Position of FC field.
	DMAC_CTRLB1_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB1_FC_Msk = 0x600000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB1_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB1_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB1_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB1_FC_PER2PER_DMA_FC = 0x3
	// Position of SRC_INCR field.
	DMAC_CTRLB1_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB1_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB1_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB1_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB1_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB1_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB1_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB1_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB1_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB1_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB1_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB1_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB1_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB1_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB1_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB1_AUTO = 0x80000000
	// Automatic multiple buffer transfer is disabled.
	DMAC_CTRLB1_AUTO_DISABLE = 0x0
	// Automatic multiple buffer transfer is enabled. This bit enables replay mode or contiguous mode when several buffers are transferred.
	DMAC_CTRLB1_AUTO_ENABLE = 0x1

	// CFG1: DMAC Channel Configuration Register (ch_num = 1)
	// Position of SRC_PER field.
	DMAC_CFG1_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG1_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG1_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG1_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG1_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG1_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG1_SRC_REP = 0x100
	// When automatic mode is activated, source address is contiguous between two buffers.
	DMAC_CFG1_SRC_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the source address and the control register are reloaded from previous transfer.
	DMAC_CFG1_SRC_REP_RELOAD_ADDR = 0x1
	// Position of SRC_H2SEL field.
	DMAC_CFG1_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG1_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG1_SRC_H2SEL = 0x200
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG1_SRC_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG1_SRC_H2SEL_HW = 0x1
	// Position of SRC_PER_MSB field.
	DMAC_CFG1_SRC_PER_MSB_Pos = 0xa
	// Bit mask of SRC_PER_MSB field.
	DMAC_CFG1_SRC_PER_MSB_Msk = 0xc00
	// Position of DST_REP field.
	DMAC_CFG1_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG1_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG1_DST_REP = 0x1000
	// When automatic mode is activated, destination address is contiguous between two buffers.
	DMAC_CFG1_DST_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the destination and the control register are reloaded from the pre-vious transfer.
	DMAC_CFG1_DST_REP_RELOAD_ADDR = 0x1
	// Position of DST_H2SEL field.
	DMAC_CFG1_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG1_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG1_DST_H2SEL = 0x2000
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG1_DST_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG1_DST_H2SEL_HW = 0x1
	// Position of DST_PER_MSB field.
	DMAC_CFG1_DST_PER_MSB_Pos = 0xe
	// Bit mask of DST_PER_MSB field.
	DMAC_CFG1_DST_PER_MSB_Msk = 0xc000
	// Position of SOD field.
	DMAC_CFG1_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG1_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG1_SOD = 0x10000
	// STOP ON DONE disabled, the descriptor fetch operation ignores DONE Field of CTRLA register.
	DMAC_CFG1_SOD_DISABLE = 0x0
	// STOP ON DONE activated, the DMAC module is automatically disabled if DONE FIELD is set to 1.
	DMAC_CFG1_SOD_ENABLE = 0x1
	// Position of LOCK_IF field.
	DMAC_CFG1_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG1_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG1_LOCK_IF = 0x100000
	// Interface Lock capability is disabled
	DMAC_CFG1_LOCK_IF_DISABLE = 0x0
	// Interface Lock capability is enabled
	DMAC_CFG1_LOCK_IF_ENABLE = 0x1
	// Position of LOCK_B field.
	DMAC_CFG1_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG1_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG1_LOCK_B = 0x200000
	// AHB Bus Locking capability is disabled.
	DMAC_CFG1_LOCK_B_DISABLE = 0x0
	// Position of LOCK_IF_L field.
	DMAC_CFG1_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG1_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG1_LOCK_IF_L = 0x400000
	// The Master Interface Arbiter is locked by the channel x for a chunk transfer.
	DMAC_CFG1_LOCK_IF_L_CHUNK = 0x0
	// The Master Interface Arbiter is locked by the channel x for a buffer transfer.
	DMAC_CFG1_LOCK_IF_L_BUFFER = 0x1
	// Position of AHB_PROT field.
	DMAC_CFG1_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG1_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG1_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG1_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG1_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG1_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG1_FIFOCFG_ASAP_CFG = 0x2

	// SPIP1: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 1)
	// Position of SPIP_HOLE field.
	DMAC_SPIP1_SPIP_HOLE_Pos = 0x0
	// Bit mask of SPIP_HOLE field.
	DMAC_SPIP1_SPIP_HOLE_Msk = 0xffff
	// Position of SPIP_BOUNDARY field.
	DMAC_SPIP1_SPIP_BOUNDARY_Pos = 0x10
	// Bit mask of SPIP_BOUNDARY field.
	DMAC_SPIP1_SPIP_BOUNDARY_Msk = 0x3ff0000

	// DPIP1: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 1)
	// Position of DPIP_HOLE field.
	DMAC_DPIP1_DPIP_HOLE_Pos = 0x0
	// Bit mask of DPIP_HOLE field.
	DMAC_DPIP1_DPIP_HOLE_Msk = 0xffff
	// Position of DPIP_BOUNDARY field.
	DMAC_DPIP1_DPIP_BOUNDARY_Pos = 0x10
	// Bit mask of DPIP_BOUNDARY field.
	DMAC_DPIP1_DPIP_BOUNDARY_Msk = 0x3ff0000

	// SADDR2: DMAC Channel Source Address Register (ch_num = 2)
	// Position of SADDR field.
	DMAC_SADDR2_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR2_SADDR_Msk = 0xffffffff

	// DADDR2: DMAC Channel Destination Address Register (ch_num = 2)
	// Position of DADDR field.
	DMAC_DADDR2_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR2_DADDR_Msk = 0xffffffff

	// DSCR2: DMAC Channel Descriptor Address Register (ch_num = 2)
	// Position of DSCR_IF field.
	DMAC_DSCR2_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR2_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR2_DSCR_IF_AHB_IF0 = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR2_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR2_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR2_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR2_DSCR_Msk = 0xfffffffc

	// CTRLA2: DMAC Channel Control A Register (ch_num = 2)
	// Position of BTSIZE field.
	DMAC_CTRLA2_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA2_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA2_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA2_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA2_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA2_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA2_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA2_SCSIZE_CHK_16 = 0x3
	// Position of DCSIZE field.
	DMAC_CTRLA2_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA2_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA2_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA2_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA2_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA2_DCSIZE_CHK_16 = 0x3
	// Position of SRC_WIDTH field.
	DMAC_CTRLA2_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA2_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA2_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA2_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA2_SRC_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA2_SRC_WIDTH_DWORD = 0x3
	// Position of DST_WIDTH field.
	DMAC_CTRLA2_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA2_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA2_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA2_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA2_DST_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA2_DST_WIDTH_DWORD = 0x3
	// Position of DONE field.
	DMAC_CTRLA2_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA2_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA2_DONE = 0x80000000

	// CTRLB2: DMAC Channel Control B Register (ch_num = 2)
	// Position of SIF field.
	DMAC_CTRLB2_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB2_SIF_Msk = 0x3
	// The source transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB2_SIF_AHB_IF0 = 0x0
	// The source transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB2_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB2_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB2_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB2_DIF_Msk = 0x30
	// The destination transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB2_DIF_AHB_IF0 = 0x0
	// The destination transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB2_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB2_DIF_AHB_IF2 = 0x2
	// Position of SRC_PIP field.
	DMAC_CTRLB2_SRC_PIP_Pos = 0x8
	// Bit mask of SRC_PIP field.
	DMAC_CTRLB2_SRC_PIP_Msk = 0x100
	// Bit SRC_PIP.
	DMAC_CTRLB2_SRC_PIP = 0x100
	// Picture-in-Picture mode is disabled. The source data area is contiguous.
	DMAC_CTRLB2_SRC_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the source PIP counter reaches the programmable boundary, the address is automatically incremented by a user defined amount.
	DMAC_CTRLB2_SRC_PIP_ENABLE = 0x1
	// Position of DST_PIP field.
	DMAC_CTRLB2_DST_PIP_Pos = 0xc
	// Bit mask of DST_PIP field.
	DMAC_CTRLB2_DST_PIP_Msk = 0x1000
	// Bit DST_PIP.
	DMAC_CTRLB2_DST_PIP = 0x1000
	// Picture-in-Picture mode is disabled. The Destination data area is contiguous.
	DMAC_CTRLB2_DST_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the Destination PIP counter reaches the programmable boundary the address is automatically incremented by a user-defined amount.
	DMAC_CTRLB2_DST_PIP_ENABLE = 0x1
	// Position of SRC_DSCR field.
	DMAC_CTRLB2_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB2_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB2_SRC_DSCR = 0x10000
	// Source address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB2_SRC_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the source.
	DMAC_CTRLB2_SRC_DSCR_FETCH_DISABLE = 0x1
	// Position of DST_DSCR field.
	DMAC_CTRLB2_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB2_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB2_DST_DSCR = 0x100000
	// Destination address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB2_DST_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the destination.
	DMAC_CTRLB2_DST_DSCR_FETCH_DISABLE = 0x1
	// Position of FC field.
	DMAC_CTRLB2_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB2_FC_Msk = 0x600000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB2_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB2_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB2_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB2_FC_PER2PER_DMA_FC = 0x3
	// Position of SRC_INCR field.
	DMAC_CTRLB2_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB2_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB2_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB2_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB2_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB2_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB2_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB2_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB2_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB2_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB2_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB2_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB2_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB2_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB2_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB2_AUTO = 0x80000000
	// Automatic multiple buffer transfer is disabled.
	DMAC_CTRLB2_AUTO_DISABLE = 0x0
	// Automatic multiple buffer transfer is enabled. This bit enables replay mode or contiguous mode when several buffers are transferred.
	DMAC_CTRLB2_AUTO_ENABLE = 0x1

	// CFG2: DMAC Channel Configuration Register (ch_num = 2)
	// Position of SRC_PER field.
	DMAC_CFG2_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG2_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG2_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG2_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG2_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG2_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG2_SRC_REP = 0x100
	// When automatic mode is activated, source address is contiguous between two buffers.
	DMAC_CFG2_SRC_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the source address and the control register are reloaded from previous transfer.
	DMAC_CFG2_SRC_REP_RELOAD_ADDR = 0x1
	// Position of SRC_H2SEL field.
	DMAC_CFG2_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG2_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG2_SRC_H2SEL = 0x200
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG2_SRC_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG2_SRC_H2SEL_HW = 0x1
	// Position of SRC_PER_MSB field.
	DMAC_CFG2_SRC_PER_MSB_Pos = 0xa
	// Bit mask of SRC_PER_MSB field.
	DMAC_CFG2_SRC_PER_MSB_Msk = 0xc00
	// Position of DST_REP field.
	DMAC_CFG2_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG2_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG2_DST_REP = 0x1000
	// When automatic mode is activated, destination address is contiguous between two buffers.
	DMAC_CFG2_DST_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the destination and the control register are reloaded from the pre-vious transfer.
	DMAC_CFG2_DST_REP_RELOAD_ADDR = 0x1
	// Position of DST_H2SEL field.
	DMAC_CFG2_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG2_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG2_DST_H2SEL = 0x2000
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG2_DST_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG2_DST_H2SEL_HW = 0x1
	// Position of DST_PER_MSB field.
	DMAC_CFG2_DST_PER_MSB_Pos = 0xe
	// Bit mask of DST_PER_MSB field.
	DMAC_CFG2_DST_PER_MSB_Msk = 0xc000
	// Position of SOD field.
	DMAC_CFG2_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG2_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG2_SOD = 0x10000
	// STOP ON DONE disabled, the descriptor fetch operation ignores DONE Field of CTRLA register.
	DMAC_CFG2_SOD_DISABLE = 0x0
	// STOP ON DONE activated, the DMAC module is automatically disabled if DONE FIELD is set to 1.
	DMAC_CFG2_SOD_ENABLE = 0x1
	// Position of LOCK_IF field.
	DMAC_CFG2_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG2_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG2_LOCK_IF = 0x100000
	// Interface Lock capability is disabled
	DMAC_CFG2_LOCK_IF_DISABLE = 0x0
	// Interface Lock capability is enabled
	DMAC_CFG2_LOCK_IF_ENABLE = 0x1
	// Position of LOCK_B field.
	DMAC_CFG2_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG2_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG2_LOCK_B = 0x200000
	// AHB Bus Locking capability is disabled.
	DMAC_CFG2_LOCK_B_DISABLE = 0x0
	// Position of LOCK_IF_L field.
	DMAC_CFG2_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG2_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG2_LOCK_IF_L = 0x400000
	// The Master Interface Arbiter is locked by the channel x for a chunk transfer.
	DMAC_CFG2_LOCK_IF_L_CHUNK = 0x0
	// The Master Interface Arbiter is locked by the channel x for a buffer transfer.
	DMAC_CFG2_LOCK_IF_L_BUFFER = 0x1
	// Position of AHB_PROT field.
	DMAC_CFG2_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG2_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG2_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG2_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG2_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG2_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG2_FIFOCFG_ASAP_CFG = 0x2

	// SPIP2: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 2)
	// Position of SPIP_HOLE field.
	DMAC_SPIP2_SPIP_HOLE_Pos = 0x0
	// Bit mask of SPIP_HOLE field.
	DMAC_SPIP2_SPIP_HOLE_Msk = 0xffff
	// Position of SPIP_BOUNDARY field.
	DMAC_SPIP2_SPIP_BOUNDARY_Pos = 0x10
	// Bit mask of SPIP_BOUNDARY field.
	DMAC_SPIP2_SPIP_BOUNDARY_Msk = 0x3ff0000

	// DPIP2: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 2)
	// Position of DPIP_HOLE field.
	DMAC_DPIP2_DPIP_HOLE_Pos = 0x0
	// Bit mask of DPIP_HOLE field.
	DMAC_DPIP2_DPIP_HOLE_Msk = 0xffff
	// Position of DPIP_BOUNDARY field.
	DMAC_DPIP2_DPIP_BOUNDARY_Pos = 0x10
	// Bit mask of DPIP_BOUNDARY field.
	DMAC_DPIP2_DPIP_BOUNDARY_Msk = 0x3ff0000

	// SADDR3: DMAC Channel Source Address Register (ch_num = 3)
	// Position of SADDR field.
	DMAC_SADDR3_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR3_SADDR_Msk = 0xffffffff

	// DADDR3: DMAC Channel Destination Address Register (ch_num = 3)
	// Position of DADDR field.
	DMAC_DADDR3_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR3_DADDR_Msk = 0xffffffff

	// DSCR3: DMAC Channel Descriptor Address Register (ch_num = 3)
	// Position of DSCR_IF field.
	DMAC_DSCR3_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR3_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR3_DSCR_IF_AHB_IF0 = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR3_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR3_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR3_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR3_DSCR_Msk = 0xfffffffc

	// CTRLA3: DMAC Channel Control A Register (ch_num = 3)
	// Position of BTSIZE field.
	DMAC_CTRLA3_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA3_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA3_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA3_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA3_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA3_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA3_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA3_SCSIZE_CHK_16 = 0x3
	// Position of DCSIZE field.
	DMAC_CTRLA3_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA3_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA3_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA3_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA3_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA3_DCSIZE_CHK_16 = 0x3
	// Position of SRC_WIDTH field.
	DMAC_CTRLA3_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA3_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA3_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA3_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA3_SRC_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA3_SRC_WIDTH_DWORD = 0x3
	// Position of DST_WIDTH field.
	DMAC_CTRLA3_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA3_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA3_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA3_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA3_DST_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA3_DST_WIDTH_DWORD = 0x3
	// Position of DONE field.
	DMAC_CTRLA3_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA3_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA3_DONE = 0x80000000

	// CTRLB3: DMAC Channel Control B Register (ch_num = 3)
	// Position of SIF field.
	DMAC_CTRLB3_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB3_SIF_Msk = 0x3
	// The source transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB3_SIF_AHB_IF0 = 0x0
	// The source transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB3_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB3_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB3_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB3_DIF_Msk = 0x30
	// The destination transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB3_DIF_AHB_IF0 = 0x0
	// The destination transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB3_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB3_DIF_AHB_IF2 = 0x2
	// Position of SRC_PIP field.
	DMAC_CTRLB3_SRC_PIP_Pos = 0x8
	// Bit mask of SRC_PIP field.
	DMAC_CTRLB3_SRC_PIP_Msk = 0x100
	// Bit SRC_PIP.
	DMAC_CTRLB3_SRC_PIP = 0x100
	// Picture-in-Picture mode is disabled. The source data area is contiguous.
	DMAC_CTRLB3_SRC_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the source PIP counter reaches the programmable boundary, the address is automatically incremented by a user defined amount.
	DMAC_CTRLB3_SRC_PIP_ENABLE = 0x1
	// Position of DST_PIP field.
	DMAC_CTRLB3_DST_PIP_Pos = 0xc
	// Bit mask of DST_PIP field.
	DMAC_CTRLB3_DST_PIP_Msk = 0x1000
	// Bit DST_PIP.
	DMAC_CTRLB3_DST_PIP = 0x1000
	// Picture-in-Picture mode is disabled. The Destination data area is contiguous.
	DMAC_CTRLB3_DST_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the Destination PIP counter reaches the programmable boundary the address is automatically incremented by a user-defined amount.
	DMAC_CTRLB3_DST_PIP_ENABLE = 0x1
	// Position of SRC_DSCR field.
	DMAC_CTRLB3_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB3_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB3_SRC_DSCR = 0x10000
	// Source address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB3_SRC_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the source.
	DMAC_CTRLB3_SRC_DSCR_FETCH_DISABLE = 0x1
	// Position of DST_DSCR field.
	DMAC_CTRLB3_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB3_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB3_DST_DSCR = 0x100000
	// Destination address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB3_DST_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the destination.
	DMAC_CTRLB3_DST_DSCR_FETCH_DISABLE = 0x1
	// Position of FC field.
	DMAC_CTRLB3_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB3_FC_Msk = 0x600000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB3_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB3_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB3_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB3_FC_PER2PER_DMA_FC = 0x3
	// Position of SRC_INCR field.
	DMAC_CTRLB3_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB3_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB3_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB3_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB3_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB3_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB3_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB3_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB3_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB3_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB3_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB3_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB3_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB3_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB3_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB3_AUTO = 0x80000000
	// Automatic multiple buffer transfer is disabled.
	DMAC_CTRLB3_AUTO_DISABLE = 0x0
	// Automatic multiple buffer transfer is enabled. This bit enables replay mode or contiguous mode when several buffers are transferred.
	DMAC_CTRLB3_AUTO_ENABLE = 0x1

	// CFG3: DMAC Channel Configuration Register (ch_num = 3)
	// Position of SRC_PER field.
	DMAC_CFG3_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG3_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG3_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG3_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG3_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG3_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG3_SRC_REP = 0x100
	// When automatic mode is activated, source address is contiguous between two buffers.
	DMAC_CFG3_SRC_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the source address and the control register are reloaded from previous transfer.
	DMAC_CFG3_SRC_REP_RELOAD_ADDR = 0x1
	// Position of SRC_H2SEL field.
	DMAC_CFG3_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG3_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG3_SRC_H2SEL = 0x200
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG3_SRC_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG3_SRC_H2SEL_HW = 0x1
	// Position of SRC_PER_MSB field.
	DMAC_CFG3_SRC_PER_MSB_Pos = 0xa
	// Bit mask of SRC_PER_MSB field.
	DMAC_CFG3_SRC_PER_MSB_Msk = 0xc00
	// Position of DST_REP field.
	DMAC_CFG3_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG3_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG3_DST_REP = 0x1000
	// When automatic mode is activated, destination address is contiguous between two buffers.
	DMAC_CFG3_DST_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the destination and the control register are reloaded from the pre-vious transfer.
	DMAC_CFG3_DST_REP_RELOAD_ADDR = 0x1
	// Position of DST_H2SEL field.
	DMAC_CFG3_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG3_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG3_DST_H2SEL = 0x2000
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG3_DST_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG3_DST_H2SEL_HW = 0x1
	// Position of DST_PER_MSB field.
	DMAC_CFG3_DST_PER_MSB_Pos = 0xe
	// Bit mask of DST_PER_MSB field.
	DMAC_CFG3_DST_PER_MSB_Msk = 0xc000
	// Position of SOD field.
	DMAC_CFG3_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG3_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG3_SOD = 0x10000
	// STOP ON DONE disabled, the descriptor fetch operation ignores DONE Field of CTRLA register.
	DMAC_CFG3_SOD_DISABLE = 0x0
	// STOP ON DONE activated, the DMAC module is automatically disabled if DONE FIELD is set to 1.
	DMAC_CFG3_SOD_ENABLE = 0x1
	// Position of LOCK_IF field.
	DMAC_CFG3_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG3_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG3_LOCK_IF = 0x100000
	// Interface Lock capability is disabled
	DMAC_CFG3_LOCK_IF_DISABLE = 0x0
	// Interface Lock capability is enabled
	DMAC_CFG3_LOCK_IF_ENABLE = 0x1
	// Position of LOCK_B field.
	DMAC_CFG3_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG3_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG3_LOCK_B = 0x200000
	// AHB Bus Locking capability is disabled.
	DMAC_CFG3_LOCK_B_DISABLE = 0x0
	// Position of LOCK_IF_L field.
	DMAC_CFG3_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG3_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG3_LOCK_IF_L = 0x400000
	// The Master Interface Arbiter is locked by the channel x for a chunk transfer.
	DMAC_CFG3_LOCK_IF_L_CHUNK = 0x0
	// The Master Interface Arbiter is locked by the channel x for a buffer transfer.
	DMAC_CFG3_LOCK_IF_L_BUFFER = 0x1
	// Position of AHB_PROT field.
	DMAC_CFG3_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG3_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG3_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG3_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG3_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG3_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG3_FIFOCFG_ASAP_CFG = 0x2

	// SPIP3: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 3)
	// Position of SPIP_HOLE field.
	DMAC_SPIP3_SPIP_HOLE_Pos = 0x0
	// Bit mask of SPIP_HOLE field.
	DMAC_SPIP3_SPIP_HOLE_Msk = 0xffff
	// Position of SPIP_BOUNDARY field.
	DMAC_SPIP3_SPIP_BOUNDARY_Pos = 0x10
	// Bit mask of SPIP_BOUNDARY field.
	DMAC_SPIP3_SPIP_BOUNDARY_Msk = 0x3ff0000

	// DPIP3: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 3)
	// Position of DPIP_HOLE field.
	DMAC_DPIP3_DPIP_HOLE_Pos = 0x0
	// Bit mask of DPIP_HOLE field.
	DMAC_DPIP3_DPIP_HOLE_Msk = 0xffff
	// Position of DPIP_BOUNDARY field.
	DMAC_DPIP3_DPIP_BOUNDARY_Pos = 0x10
	// Bit mask of DPIP_BOUNDARY field.
	DMAC_DPIP3_DPIP_BOUNDARY_Msk = 0x3ff0000

	// SADDR4: DMAC Channel Source Address Register (ch_num = 4)
	// Position of SADDR field.
	DMAC_SADDR4_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR4_SADDR_Msk = 0xffffffff

	// DADDR4: DMAC Channel Destination Address Register (ch_num = 4)
	// Position of DADDR field.
	DMAC_DADDR4_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR4_DADDR_Msk = 0xffffffff

	// DSCR4: DMAC Channel Descriptor Address Register (ch_num = 4)
	// Position of DSCR_IF field.
	DMAC_DSCR4_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR4_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR4_DSCR_IF_AHB_IF0 = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR4_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR4_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR4_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR4_DSCR_Msk = 0xfffffffc

	// CTRLA4: DMAC Channel Control A Register (ch_num = 4)
	// Position of BTSIZE field.
	DMAC_CTRLA4_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA4_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA4_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA4_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA4_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA4_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA4_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA4_SCSIZE_CHK_16 = 0x3
	// Position of DCSIZE field.
	DMAC_CTRLA4_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA4_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA4_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA4_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA4_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA4_DCSIZE_CHK_16 = 0x3
	// Position of SRC_WIDTH field.
	DMAC_CTRLA4_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA4_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA4_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA4_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA4_SRC_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA4_SRC_WIDTH_DWORD = 0x3
	// Position of DST_WIDTH field.
	DMAC_CTRLA4_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA4_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA4_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA4_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA4_DST_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA4_DST_WIDTH_DWORD = 0x3
	// Position of DONE field.
	DMAC_CTRLA4_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA4_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA4_DONE = 0x80000000

	// CTRLB4: DMAC Channel Control B Register (ch_num = 4)
	// Position of SIF field.
	DMAC_CTRLB4_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB4_SIF_Msk = 0x3
	// The source transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB4_SIF_AHB_IF0 = 0x0
	// The source transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB4_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB4_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB4_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB4_DIF_Msk = 0x30
	// The destination transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB4_DIF_AHB_IF0 = 0x0
	// The destination transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB4_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB4_DIF_AHB_IF2 = 0x2
	// Position of SRC_PIP field.
	DMAC_CTRLB4_SRC_PIP_Pos = 0x8
	// Bit mask of SRC_PIP field.
	DMAC_CTRLB4_SRC_PIP_Msk = 0x100
	// Bit SRC_PIP.
	DMAC_CTRLB4_SRC_PIP = 0x100
	// Picture-in-Picture mode is disabled. The source data area is contiguous.
	DMAC_CTRLB4_SRC_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the source PIP counter reaches the programmable boundary, the address is automatically incremented by a user defined amount.
	DMAC_CTRLB4_SRC_PIP_ENABLE = 0x1
	// Position of DST_PIP field.
	DMAC_CTRLB4_DST_PIP_Pos = 0xc
	// Bit mask of DST_PIP field.
	DMAC_CTRLB4_DST_PIP_Msk = 0x1000
	// Bit DST_PIP.
	DMAC_CTRLB4_DST_PIP = 0x1000
	// Picture-in-Picture mode is disabled. The Destination data area is contiguous.
	DMAC_CTRLB4_DST_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the Destination PIP counter reaches the programmable boundary the address is automatically incremented by a user-defined amount.
	DMAC_CTRLB4_DST_PIP_ENABLE = 0x1
	// Position of SRC_DSCR field.
	DMAC_CTRLB4_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB4_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB4_SRC_DSCR = 0x10000
	// Source address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB4_SRC_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the source.
	DMAC_CTRLB4_SRC_DSCR_FETCH_DISABLE = 0x1
	// Position of DST_DSCR field.
	DMAC_CTRLB4_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB4_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB4_DST_DSCR = 0x100000
	// Destination address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB4_DST_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the destination.
	DMAC_CTRLB4_DST_DSCR_FETCH_DISABLE = 0x1
	// Position of FC field.
	DMAC_CTRLB4_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB4_FC_Msk = 0x600000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB4_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB4_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB4_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB4_FC_PER2PER_DMA_FC = 0x3
	// Position of SRC_INCR field.
	DMAC_CTRLB4_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB4_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB4_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB4_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB4_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB4_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB4_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB4_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB4_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB4_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB4_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB4_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB4_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB4_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB4_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB4_AUTO = 0x80000000
	// Automatic multiple buffer transfer is disabled.
	DMAC_CTRLB4_AUTO_DISABLE = 0x0
	// Automatic multiple buffer transfer is enabled. This bit enables replay mode or contiguous mode when several buffers are transferred.
	DMAC_CTRLB4_AUTO_ENABLE = 0x1

	// CFG4: DMAC Channel Configuration Register (ch_num = 4)
	// Position of SRC_PER field.
	DMAC_CFG4_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG4_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG4_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG4_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG4_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG4_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG4_SRC_REP = 0x100
	// When automatic mode is activated, source address is contiguous between two buffers.
	DMAC_CFG4_SRC_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the source address and the control register are reloaded from previous transfer.
	DMAC_CFG4_SRC_REP_RELOAD_ADDR = 0x1
	// Position of SRC_H2SEL field.
	DMAC_CFG4_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG4_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG4_SRC_H2SEL = 0x200
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG4_SRC_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG4_SRC_H2SEL_HW = 0x1
	// Position of SRC_PER_MSB field.
	DMAC_CFG4_SRC_PER_MSB_Pos = 0xa
	// Bit mask of SRC_PER_MSB field.
	DMAC_CFG4_SRC_PER_MSB_Msk = 0xc00
	// Position of DST_REP field.
	DMAC_CFG4_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG4_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG4_DST_REP = 0x1000
	// When automatic mode is activated, destination address is contiguous between two buffers.
	DMAC_CFG4_DST_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the destination and the control register are reloaded from the pre-vious transfer.
	DMAC_CFG4_DST_REP_RELOAD_ADDR = 0x1
	// Position of DST_H2SEL field.
	DMAC_CFG4_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG4_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG4_DST_H2SEL = 0x2000
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG4_DST_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG4_DST_H2SEL_HW = 0x1
	// Position of DST_PER_MSB field.
	DMAC_CFG4_DST_PER_MSB_Pos = 0xe
	// Bit mask of DST_PER_MSB field.
	DMAC_CFG4_DST_PER_MSB_Msk = 0xc000
	// Position of SOD field.
	DMAC_CFG4_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG4_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG4_SOD = 0x10000
	// STOP ON DONE disabled, the descriptor fetch operation ignores DONE Field of CTRLA register.
	DMAC_CFG4_SOD_DISABLE = 0x0
	// STOP ON DONE activated, the DMAC module is automatically disabled if DONE FIELD is set to 1.
	DMAC_CFG4_SOD_ENABLE = 0x1
	// Position of LOCK_IF field.
	DMAC_CFG4_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG4_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG4_LOCK_IF = 0x100000
	// Interface Lock capability is disabled
	DMAC_CFG4_LOCK_IF_DISABLE = 0x0
	// Interface Lock capability is enabled
	DMAC_CFG4_LOCK_IF_ENABLE = 0x1
	// Position of LOCK_B field.
	DMAC_CFG4_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG4_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG4_LOCK_B = 0x200000
	// AHB Bus Locking capability is disabled.
	DMAC_CFG4_LOCK_B_DISABLE = 0x0
	// Position of LOCK_IF_L field.
	DMAC_CFG4_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG4_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG4_LOCK_IF_L = 0x400000
	// The Master Interface Arbiter is locked by the channel x for a chunk transfer.
	DMAC_CFG4_LOCK_IF_L_CHUNK = 0x0
	// The Master Interface Arbiter is locked by the channel x for a buffer transfer.
	DMAC_CFG4_LOCK_IF_L_BUFFER = 0x1
	// Position of AHB_PROT field.
	DMAC_CFG4_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG4_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG4_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG4_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG4_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG4_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG4_FIFOCFG_ASAP_CFG = 0x2

	// SPIP4: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 4)
	// Position of SPIP_HOLE field.
	DMAC_SPIP4_SPIP_HOLE_Pos = 0x0
	// Bit mask of SPIP_HOLE field.
	DMAC_SPIP4_SPIP_HOLE_Msk = 0xffff
	// Position of SPIP_BOUNDARY field.
	DMAC_SPIP4_SPIP_BOUNDARY_Pos = 0x10
	// Bit mask of SPIP_BOUNDARY field.
	DMAC_SPIP4_SPIP_BOUNDARY_Msk = 0x3ff0000

	// DPIP4: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 4)
	// Position of DPIP_HOLE field.
	DMAC_DPIP4_DPIP_HOLE_Pos = 0x0
	// Bit mask of DPIP_HOLE field.
	DMAC_DPIP4_DPIP_HOLE_Msk = 0xffff
	// Position of DPIP_BOUNDARY field.
	DMAC_DPIP4_DPIP_BOUNDARY_Pos = 0x10
	// Bit mask of DPIP_BOUNDARY field.
	DMAC_DPIP4_DPIP_BOUNDARY_Msk = 0x3ff0000

	// SADDR5: DMAC Channel Source Address Register (ch_num = 5)
	// Position of SADDR field.
	DMAC_SADDR5_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR5_SADDR_Msk = 0xffffffff

	// DADDR5: DMAC Channel Destination Address Register (ch_num = 5)
	// Position of DADDR field.
	DMAC_DADDR5_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR5_DADDR_Msk = 0xffffffff

	// DSCR5: DMAC Channel Descriptor Address Register (ch_num = 5)
	// Position of DSCR_IF field.
	DMAC_DSCR5_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR5_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR5_DSCR_IF_AHB_IF0 = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR5_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR5_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR5_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR5_DSCR_Msk = 0xfffffffc

	// CTRLA5: DMAC Channel Control A Register (ch_num = 5)
	// Position of BTSIZE field.
	DMAC_CTRLA5_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA5_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA5_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA5_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA5_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA5_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA5_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA5_SCSIZE_CHK_16 = 0x3
	// Position of DCSIZE field.
	DMAC_CTRLA5_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA5_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA5_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA5_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA5_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA5_DCSIZE_CHK_16 = 0x3
	// Position of SRC_WIDTH field.
	DMAC_CTRLA5_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA5_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA5_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA5_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA5_SRC_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA5_SRC_WIDTH_DWORD = 0x3
	// Position of DST_WIDTH field.
	DMAC_CTRLA5_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA5_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA5_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA5_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA5_DST_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA5_DST_WIDTH_DWORD = 0x3
	// Position of DONE field.
	DMAC_CTRLA5_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA5_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA5_DONE = 0x80000000

	// CTRLB5: DMAC Channel Control B Register (ch_num = 5)
	// Position of SIF field.
	DMAC_CTRLB5_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB5_SIF_Msk = 0x3
	// The source transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB5_SIF_AHB_IF0 = 0x0
	// The source transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB5_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB5_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB5_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB5_DIF_Msk = 0x30
	// The destination transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB5_DIF_AHB_IF0 = 0x0
	// The destination transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB5_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB5_DIF_AHB_IF2 = 0x2
	// Position of SRC_PIP field.
	DMAC_CTRLB5_SRC_PIP_Pos = 0x8
	// Bit mask of SRC_PIP field.
	DMAC_CTRLB5_SRC_PIP_Msk = 0x100
	// Bit SRC_PIP.
	DMAC_CTRLB5_SRC_PIP = 0x100
	// Picture-in-Picture mode is disabled. The source data area is contiguous.
	DMAC_CTRLB5_SRC_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the source PIP counter reaches the programmable boundary, the address is automatically incremented by a user defined amount.
	DMAC_CTRLB5_SRC_PIP_ENABLE = 0x1
	// Position of DST_PIP field.
	DMAC_CTRLB5_DST_PIP_Pos = 0xc
	// Bit mask of DST_PIP field.
	DMAC_CTRLB5_DST_PIP_Msk = 0x1000
	// Bit DST_PIP.
	DMAC_CTRLB5_DST_PIP = 0x1000
	// Picture-in-Picture mode is disabled. The Destination data area is contiguous.
	DMAC_CTRLB5_DST_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the Destination PIP counter reaches the programmable boundary the address is automatically incremented by a user-defined amount.
	DMAC_CTRLB5_DST_PIP_ENABLE = 0x1
	// Position of SRC_DSCR field.
	DMAC_CTRLB5_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB5_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB5_SRC_DSCR = 0x10000
	// Source address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB5_SRC_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the source.
	DMAC_CTRLB5_SRC_DSCR_FETCH_DISABLE = 0x1
	// Position of DST_DSCR field.
	DMAC_CTRLB5_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB5_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB5_DST_DSCR = 0x100000
	// Destination address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB5_DST_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the destination.
	DMAC_CTRLB5_DST_DSCR_FETCH_DISABLE = 0x1
	// Position of FC field.
	DMAC_CTRLB5_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB5_FC_Msk = 0x600000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB5_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB5_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB5_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB5_FC_PER2PER_DMA_FC = 0x3
	// Position of SRC_INCR field.
	DMAC_CTRLB5_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB5_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB5_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB5_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB5_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB5_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB5_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB5_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB5_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB5_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB5_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB5_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB5_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB5_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB5_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB5_AUTO = 0x80000000
	// Automatic multiple buffer transfer is disabled.
	DMAC_CTRLB5_AUTO_DISABLE = 0x0
	// Automatic multiple buffer transfer is enabled. This bit enables replay mode or contiguous mode when several buffers are transferred.
	DMAC_CTRLB5_AUTO_ENABLE = 0x1

	// CFG5: DMAC Channel Configuration Register (ch_num = 5)
	// Position of SRC_PER field.
	DMAC_CFG5_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG5_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG5_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG5_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG5_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG5_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG5_SRC_REP = 0x100
	// When automatic mode is activated, source address is contiguous between two buffers.
	DMAC_CFG5_SRC_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the source address and the control register are reloaded from previous transfer.
	DMAC_CFG5_SRC_REP_RELOAD_ADDR = 0x1
	// Position of SRC_H2SEL field.
	DMAC_CFG5_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG5_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG5_SRC_H2SEL = 0x200
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG5_SRC_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG5_SRC_H2SEL_HW = 0x1
	// Position of SRC_PER_MSB field.
	DMAC_CFG5_SRC_PER_MSB_Pos = 0xa
	// Bit mask of SRC_PER_MSB field.
	DMAC_CFG5_SRC_PER_MSB_Msk = 0xc00
	// Position of DST_REP field.
	DMAC_CFG5_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG5_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG5_DST_REP = 0x1000
	// When automatic mode is activated, destination address is contiguous between two buffers.
	DMAC_CFG5_DST_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the destination and the control register are reloaded from the pre-vious transfer.
	DMAC_CFG5_DST_REP_RELOAD_ADDR = 0x1
	// Position of DST_H2SEL field.
	DMAC_CFG5_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG5_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG5_DST_H2SEL = 0x2000
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG5_DST_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG5_DST_H2SEL_HW = 0x1
	// Position of DST_PER_MSB field.
	DMAC_CFG5_DST_PER_MSB_Pos = 0xe
	// Bit mask of DST_PER_MSB field.
	DMAC_CFG5_DST_PER_MSB_Msk = 0xc000
	// Position of SOD field.
	DMAC_CFG5_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG5_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG5_SOD = 0x10000
	// STOP ON DONE disabled, the descriptor fetch operation ignores DONE Field of CTRLA register.
	DMAC_CFG5_SOD_DISABLE = 0x0
	// STOP ON DONE activated, the DMAC module is automatically disabled if DONE FIELD is set to 1.
	DMAC_CFG5_SOD_ENABLE = 0x1
	// Position of LOCK_IF field.
	DMAC_CFG5_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG5_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG5_LOCK_IF = 0x100000
	// Interface Lock capability is disabled
	DMAC_CFG5_LOCK_IF_DISABLE = 0x0
	// Interface Lock capability is enabled
	DMAC_CFG5_LOCK_IF_ENABLE = 0x1
	// Position of LOCK_B field.
	DMAC_CFG5_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG5_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG5_LOCK_B = 0x200000
	// AHB Bus Locking capability is disabled.
	DMAC_CFG5_LOCK_B_DISABLE = 0x0
	// Position of LOCK_IF_L field.
	DMAC_CFG5_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG5_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG5_LOCK_IF_L = 0x400000
	// The Master Interface Arbiter is locked by the channel x for a chunk transfer.
	DMAC_CFG5_LOCK_IF_L_CHUNK = 0x0
	// The Master Interface Arbiter is locked by the channel x for a buffer transfer.
	DMAC_CFG5_LOCK_IF_L_BUFFER = 0x1
	// Position of AHB_PROT field.
	DMAC_CFG5_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG5_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG5_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG5_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG5_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG5_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG5_FIFOCFG_ASAP_CFG = 0x2

	// SPIP5: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 5)
	// Position of SPIP_HOLE field.
	DMAC_SPIP5_SPIP_HOLE_Pos = 0x0
	// Bit mask of SPIP_HOLE field.
	DMAC_SPIP5_SPIP_HOLE_Msk = 0xffff
	// Position of SPIP_BOUNDARY field.
	DMAC_SPIP5_SPIP_BOUNDARY_Pos = 0x10
	// Bit mask of SPIP_BOUNDARY field.
	DMAC_SPIP5_SPIP_BOUNDARY_Msk = 0x3ff0000

	// DPIP5: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 5)
	// Position of DPIP_HOLE field.
	DMAC_DPIP5_DPIP_HOLE_Pos = 0x0
	// Bit mask of DPIP_HOLE field.
	DMAC_DPIP5_DPIP_HOLE_Msk = 0xffff
	// Position of DPIP_BOUNDARY field.
	DMAC_DPIP5_DPIP_BOUNDARY_Pos = 0x10
	// Bit mask of DPIP_BOUNDARY field.
	DMAC_DPIP5_DPIP_BOUNDARY_Msk = 0x3ff0000

	// SADDR6: DMAC Channel Source Address Register (ch_num = 6)
	// Position of SADDR field.
	DMAC_SADDR6_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR6_SADDR_Msk = 0xffffffff

	// DADDR6: DMAC Channel Destination Address Register (ch_num = 6)
	// Position of DADDR field.
	DMAC_DADDR6_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR6_DADDR_Msk = 0xffffffff

	// DSCR6: DMAC Channel Descriptor Address Register (ch_num = 6)
	// Position of DSCR_IF field.
	DMAC_DSCR6_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR6_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR6_DSCR_IF_AHB_IF0 = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR6_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR6_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR6_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR6_DSCR_Msk = 0xfffffffc

	// CTRLA6: DMAC Channel Control A Register (ch_num = 6)
	// Position of BTSIZE field.
	DMAC_CTRLA6_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA6_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA6_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA6_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA6_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA6_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA6_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA6_SCSIZE_CHK_16 = 0x3
	// Position of DCSIZE field.
	DMAC_CTRLA6_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA6_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA6_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA6_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA6_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA6_DCSIZE_CHK_16 = 0x3
	// Position of SRC_WIDTH field.
	DMAC_CTRLA6_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA6_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA6_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA6_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA6_SRC_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA6_SRC_WIDTH_DWORD = 0x3
	// Position of DST_WIDTH field.
	DMAC_CTRLA6_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA6_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA6_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA6_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA6_DST_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA6_DST_WIDTH_DWORD = 0x3
	// Position of DONE field.
	DMAC_CTRLA6_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA6_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA6_DONE = 0x80000000

	// CTRLB6: DMAC Channel Control B Register (ch_num = 6)
	// Position of SIF field.
	DMAC_CTRLB6_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB6_SIF_Msk = 0x3
	// The source transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB6_SIF_AHB_IF0 = 0x0
	// The source transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB6_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB6_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB6_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB6_DIF_Msk = 0x30
	// The destination transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB6_DIF_AHB_IF0 = 0x0
	// The destination transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB6_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB6_DIF_AHB_IF2 = 0x2
	// Position of SRC_PIP field.
	DMAC_CTRLB6_SRC_PIP_Pos = 0x8
	// Bit mask of SRC_PIP field.
	DMAC_CTRLB6_SRC_PIP_Msk = 0x100
	// Bit SRC_PIP.
	DMAC_CTRLB6_SRC_PIP = 0x100
	// Picture-in-Picture mode is disabled. The source data area is contiguous.
	DMAC_CTRLB6_SRC_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the source PIP counter reaches the programmable boundary, the address is automatically incremented by a user defined amount.
	DMAC_CTRLB6_SRC_PIP_ENABLE = 0x1
	// Position of DST_PIP field.
	DMAC_CTRLB6_DST_PIP_Pos = 0xc
	// Bit mask of DST_PIP field.
	DMAC_CTRLB6_DST_PIP_Msk = 0x1000
	// Bit DST_PIP.
	DMAC_CTRLB6_DST_PIP = 0x1000
	// Picture-in-Picture mode is disabled. The Destination data area is contiguous.
	DMAC_CTRLB6_DST_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the Destination PIP counter reaches the programmable boundary the address is automatically incremented by a user-defined amount.
	DMAC_CTRLB6_DST_PIP_ENABLE = 0x1
	// Position of SRC_DSCR field.
	DMAC_CTRLB6_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB6_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB6_SRC_DSCR = 0x10000
	// Source address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB6_SRC_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the source.
	DMAC_CTRLB6_SRC_DSCR_FETCH_DISABLE = 0x1
	// Position of DST_DSCR field.
	DMAC_CTRLB6_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB6_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB6_DST_DSCR = 0x100000
	// Destination address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB6_DST_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the destination.
	DMAC_CTRLB6_DST_DSCR_FETCH_DISABLE = 0x1
	// Position of FC field.
	DMAC_CTRLB6_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB6_FC_Msk = 0x600000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB6_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB6_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB6_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB6_FC_PER2PER_DMA_FC = 0x3
	// Position of SRC_INCR field.
	DMAC_CTRLB6_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB6_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB6_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB6_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB6_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB6_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB6_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB6_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB6_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB6_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB6_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB6_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB6_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB6_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB6_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB6_AUTO = 0x80000000
	// Automatic multiple buffer transfer is disabled.
	DMAC_CTRLB6_AUTO_DISABLE = 0x0
	// Automatic multiple buffer transfer is enabled. This bit enables replay mode or contiguous mode when several buffers are transferred.
	DMAC_CTRLB6_AUTO_ENABLE = 0x1

	// CFG6: DMAC Channel Configuration Register (ch_num = 6)
	// Position of SRC_PER field.
	DMAC_CFG6_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG6_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG6_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG6_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG6_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG6_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG6_SRC_REP = 0x100
	// When automatic mode is activated, source address is contiguous between two buffers.
	DMAC_CFG6_SRC_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the source address and the control register are reloaded from previous transfer.
	DMAC_CFG6_SRC_REP_RELOAD_ADDR = 0x1
	// Position of SRC_H2SEL field.
	DMAC_CFG6_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG6_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG6_SRC_H2SEL = 0x200
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG6_SRC_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG6_SRC_H2SEL_HW = 0x1
	// Position of SRC_PER_MSB field.
	DMAC_CFG6_SRC_PER_MSB_Pos = 0xa
	// Bit mask of SRC_PER_MSB field.
	DMAC_CFG6_SRC_PER_MSB_Msk = 0xc00
	// Position of DST_REP field.
	DMAC_CFG6_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG6_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG6_DST_REP = 0x1000
	// When automatic mode is activated, destination address is contiguous between two buffers.
	DMAC_CFG6_DST_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the destination and the control register are reloaded from the pre-vious transfer.
	DMAC_CFG6_DST_REP_RELOAD_ADDR = 0x1
	// Position of DST_H2SEL field.
	DMAC_CFG6_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG6_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG6_DST_H2SEL = 0x2000
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG6_DST_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG6_DST_H2SEL_HW = 0x1
	// Position of DST_PER_MSB field.
	DMAC_CFG6_DST_PER_MSB_Pos = 0xe
	// Bit mask of DST_PER_MSB field.
	DMAC_CFG6_DST_PER_MSB_Msk = 0xc000
	// Position of SOD field.
	DMAC_CFG6_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG6_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG6_SOD = 0x10000
	// STOP ON DONE disabled, the descriptor fetch operation ignores DONE Field of CTRLA register.
	DMAC_CFG6_SOD_DISABLE = 0x0
	// STOP ON DONE activated, the DMAC module is automatically disabled if DONE FIELD is set to 1.
	DMAC_CFG6_SOD_ENABLE = 0x1
	// Position of LOCK_IF field.
	DMAC_CFG6_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG6_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG6_LOCK_IF = 0x100000
	// Interface Lock capability is disabled
	DMAC_CFG6_LOCK_IF_DISABLE = 0x0
	// Interface Lock capability is enabled
	DMAC_CFG6_LOCK_IF_ENABLE = 0x1
	// Position of LOCK_B field.
	DMAC_CFG6_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG6_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG6_LOCK_B = 0x200000
	// AHB Bus Locking capability is disabled.
	DMAC_CFG6_LOCK_B_DISABLE = 0x0
	// Position of LOCK_IF_L field.
	DMAC_CFG6_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG6_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG6_LOCK_IF_L = 0x400000
	// The Master Interface Arbiter is locked by the channel x for a chunk transfer.
	DMAC_CFG6_LOCK_IF_L_CHUNK = 0x0
	// The Master Interface Arbiter is locked by the channel x for a buffer transfer.
	DMAC_CFG6_LOCK_IF_L_BUFFER = 0x1
	// Position of AHB_PROT field.
	DMAC_CFG6_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG6_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG6_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG6_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG6_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG6_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG6_FIFOCFG_ASAP_CFG = 0x2

	// SPIP6: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 6)
	// Position of SPIP_HOLE field.
	DMAC_SPIP6_SPIP_HOLE_Pos = 0x0
	// Bit mask of SPIP_HOLE field.
	DMAC_SPIP6_SPIP_HOLE_Msk = 0xffff
	// Position of SPIP_BOUNDARY field.
	DMAC_SPIP6_SPIP_BOUNDARY_Pos = 0x10
	// Bit mask of SPIP_BOUNDARY field.
	DMAC_SPIP6_SPIP_BOUNDARY_Msk = 0x3ff0000

	// DPIP6: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 6)
	// Position of DPIP_HOLE field.
	DMAC_DPIP6_DPIP_HOLE_Pos = 0x0
	// Bit mask of DPIP_HOLE field.
	DMAC_DPIP6_DPIP_HOLE_Msk = 0xffff
	// Position of DPIP_BOUNDARY field.
	DMAC_DPIP6_DPIP_BOUNDARY_Pos = 0x10
	// Bit mask of DPIP_BOUNDARY field.
	DMAC_DPIP6_DPIP_BOUNDARY_Msk = 0x3ff0000

	// SADDR7: DMAC Channel Source Address Register (ch_num = 7)
	// Position of SADDR field.
	DMAC_SADDR7_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMAC_SADDR7_SADDR_Msk = 0xffffffff

	// DADDR7: DMAC Channel Destination Address Register (ch_num = 7)
	// Position of DADDR field.
	DMAC_DADDR7_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMAC_DADDR7_DADDR_Msk = 0xffffffff

	// DSCR7: DMAC Channel Descriptor Address Register (ch_num = 7)
	// Position of DSCR_IF field.
	DMAC_DSCR7_DSCR_IF_Pos = 0x0
	// Bit mask of DSCR_IF field.
	DMAC_DSCR7_DSCR_IF_Msk = 0x3
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 0
	DMAC_DSCR7_DSCR_IF_AHB_IF0 = 0x0
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 1
	DMAC_DSCR7_DSCR_IF_AHB_IF1 = 0x1
	// The buffer transfer descriptor is fetched via AHB-Lite Interface 2
	DMAC_DSCR7_DSCR_IF_AHB_IF2 = 0x2
	// Position of DSCR field.
	DMAC_DSCR7_DSCR_Pos = 0x2
	// Bit mask of DSCR field.
	DMAC_DSCR7_DSCR_Msk = 0xfffffffc

	// CTRLA7: DMAC Channel Control A Register (ch_num = 7)
	// Position of BTSIZE field.
	DMAC_CTRLA7_BTSIZE_Pos = 0x0
	// Bit mask of BTSIZE field.
	DMAC_CTRLA7_BTSIZE_Msk = 0xffff
	// Position of SCSIZE field.
	DMAC_CTRLA7_SCSIZE_Pos = 0x10
	// Bit mask of SCSIZE field.
	DMAC_CTRLA7_SCSIZE_Msk = 0x70000
	// 1 data transferred
	DMAC_CTRLA7_SCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA7_SCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA7_SCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA7_SCSIZE_CHK_16 = 0x3
	// Position of DCSIZE field.
	DMAC_CTRLA7_DCSIZE_Pos = 0x14
	// Bit mask of DCSIZE field.
	DMAC_CTRLA7_DCSIZE_Msk = 0x700000
	// 1 data transferred
	DMAC_CTRLA7_DCSIZE_CHK_1 = 0x0
	// 4 data transferred
	DMAC_CTRLA7_DCSIZE_CHK_4 = 0x1
	// 8 data transferred
	DMAC_CTRLA7_DCSIZE_CHK_8 = 0x2
	// 16 data transferred
	DMAC_CTRLA7_DCSIZE_CHK_16 = 0x3
	// Position of SRC_WIDTH field.
	DMAC_CTRLA7_SRC_WIDTH_Pos = 0x18
	// Bit mask of SRC_WIDTH field.
	DMAC_CTRLA7_SRC_WIDTH_Msk = 0x3000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA7_SRC_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA7_SRC_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA7_SRC_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA7_SRC_WIDTH_DWORD = 0x3
	// Position of DST_WIDTH field.
	DMAC_CTRLA7_DST_WIDTH_Pos = 0x1c
	// Bit mask of DST_WIDTH field.
	DMAC_CTRLA7_DST_WIDTH_Msk = 0x30000000
	// the transfer size is set to 8-bit width
	DMAC_CTRLA7_DST_WIDTH_BYTE = 0x0
	// the transfer size is set to 16-bit width
	DMAC_CTRLA7_DST_WIDTH_HALF_WORD = 0x1
	// the transfer size is set to 32-bit width
	DMAC_CTRLA7_DST_WIDTH_WORD = 0x2
	// the transfer size is set to 64-bit width
	DMAC_CTRLA7_DST_WIDTH_DWORD = 0x3
	// Position of DONE field.
	DMAC_CTRLA7_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	DMAC_CTRLA7_DONE_Msk = 0x80000000
	// Bit DONE.
	DMAC_CTRLA7_DONE = 0x80000000

	// CTRLB7: DMAC Channel Control B Register (ch_num = 7)
	// Position of SIF field.
	DMAC_CTRLB7_SIF_Pos = 0x0
	// Bit mask of SIF field.
	DMAC_CTRLB7_SIF_Msk = 0x3
	// The source transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB7_SIF_AHB_IF0 = 0x0
	// The source transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB7_SIF_AHB_IF1 = 0x1
	// The source transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB7_SIF_AHB_IF2 = 0x2
	// Position of DIF field.
	DMAC_CTRLB7_DIF_Pos = 0x4
	// Bit mask of DIF field.
	DMAC_CTRLB7_DIF_Msk = 0x30
	// The destination transfer is done via AHB_Lite Interface 0
	DMAC_CTRLB7_DIF_AHB_IF0 = 0x0
	// The destination transfer is done via AHB_Lite Interface 1
	DMAC_CTRLB7_DIF_AHB_IF1 = 0x1
	// The destination transfer is done via AHB_Lite Interface 2
	DMAC_CTRLB7_DIF_AHB_IF2 = 0x2
	// Position of SRC_PIP field.
	DMAC_CTRLB7_SRC_PIP_Pos = 0x8
	// Bit mask of SRC_PIP field.
	DMAC_CTRLB7_SRC_PIP_Msk = 0x100
	// Bit SRC_PIP.
	DMAC_CTRLB7_SRC_PIP = 0x100
	// Picture-in-Picture mode is disabled. The source data area is contiguous.
	DMAC_CTRLB7_SRC_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the source PIP counter reaches the programmable boundary, the address is automatically incremented by a user defined amount.
	DMAC_CTRLB7_SRC_PIP_ENABLE = 0x1
	// Position of DST_PIP field.
	DMAC_CTRLB7_DST_PIP_Pos = 0xc
	// Bit mask of DST_PIP field.
	DMAC_CTRLB7_DST_PIP_Msk = 0x1000
	// Bit DST_PIP.
	DMAC_CTRLB7_DST_PIP = 0x1000
	// Picture-in-Picture mode is disabled. The Destination data area is contiguous.
	DMAC_CTRLB7_DST_PIP_DISABLE = 0x0
	// Picture-in-Picture mode is enabled. When the Destination PIP counter reaches the programmable boundary the address is automatically incremented by a user-defined amount.
	DMAC_CTRLB7_DST_PIP_ENABLE = 0x1
	// Position of SRC_DSCR field.
	DMAC_CTRLB7_SRC_DSCR_Pos = 0x10
	// Bit mask of SRC_DSCR field.
	DMAC_CTRLB7_SRC_DSCR_Msk = 0x10000
	// Bit SRC_DSCR.
	DMAC_CTRLB7_SRC_DSCR = 0x10000
	// Source address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB7_SRC_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the source.
	DMAC_CTRLB7_SRC_DSCR_FETCH_DISABLE = 0x1
	// Position of DST_DSCR field.
	DMAC_CTRLB7_DST_DSCR_Pos = 0x14
	// Bit mask of DST_DSCR field.
	DMAC_CTRLB7_DST_DSCR_Msk = 0x100000
	// Bit DST_DSCR.
	DMAC_CTRLB7_DST_DSCR = 0x100000
	// Destination address is updated when the descriptor is fetched from the memory.
	DMAC_CTRLB7_DST_DSCR_FETCH_FROM_MEM = 0x0
	// Buffer Descriptor Fetch operation is disabled for the destination.
	DMAC_CTRLB7_DST_DSCR_FETCH_DISABLE = 0x1
	// Position of FC field.
	DMAC_CTRLB7_FC_Pos = 0x15
	// Bit mask of FC field.
	DMAC_CTRLB7_FC_Msk = 0x600000
	// Memory-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB7_FC_MEM2MEM_DMA_FC = 0x0
	// Memory-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB7_FC_MEM2PER_DMA_FC = 0x1
	// Peripheral-to-Memory Transfer DMAC is flow controller
	DMAC_CTRLB7_FC_PER2MEM_DMA_FC = 0x2
	// Peripheral-to-Peripheral Transfer DMAC is flow controller
	DMAC_CTRLB7_FC_PER2PER_DMA_FC = 0x3
	// Position of SRC_INCR field.
	DMAC_CTRLB7_SRC_INCR_Pos = 0x18
	// Bit mask of SRC_INCR field.
	DMAC_CTRLB7_SRC_INCR_Msk = 0x3000000
	// The source address is incremented
	DMAC_CTRLB7_SRC_INCR_INCREMENTING = 0x0
	// The source address is decremented
	DMAC_CTRLB7_SRC_INCR_DECREMENTING = 0x1
	// The source address remains unchanged
	DMAC_CTRLB7_SRC_INCR_FIXED = 0x2
	// Position of DST_INCR field.
	DMAC_CTRLB7_DST_INCR_Pos = 0x1c
	// Bit mask of DST_INCR field.
	DMAC_CTRLB7_DST_INCR_Msk = 0x30000000
	// The destination address is incremented
	DMAC_CTRLB7_DST_INCR_INCREMENTING = 0x0
	// The destination address is decremented
	DMAC_CTRLB7_DST_INCR_DECREMENTING = 0x1
	// The destination address remains unchanged
	DMAC_CTRLB7_DST_INCR_FIXED = 0x2
	// Position of IEN field.
	DMAC_CTRLB7_IEN_Pos = 0x1e
	// Bit mask of IEN field.
	DMAC_CTRLB7_IEN_Msk = 0x40000000
	// Bit IEN.
	DMAC_CTRLB7_IEN = 0x40000000
	// Position of AUTO field.
	DMAC_CTRLB7_AUTO_Pos = 0x1f
	// Bit mask of AUTO field.
	DMAC_CTRLB7_AUTO_Msk = 0x80000000
	// Bit AUTO.
	DMAC_CTRLB7_AUTO = 0x80000000
	// Automatic multiple buffer transfer is disabled.
	DMAC_CTRLB7_AUTO_DISABLE = 0x0
	// Automatic multiple buffer transfer is enabled. This bit enables replay mode or contiguous mode when several buffers are transferred.
	DMAC_CTRLB7_AUTO_ENABLE = 0x1

	// CFG7: DMAC Channel Configuration Register (ch_num = 7)
	// Position of SRC_PER field.
	DMAC_CFG7_SRC_PER_Pos = 0x0
	// Bit mask of SRC_PER field.
	DMAC_CFG7_SRC_PER_Msk = 0xf
	// Position of DST_PER field.
	DMAC_CFG7_DST_PER_Pos = 0x4
	// Bit mask of DST_PER field.
	DMAC_CFG7_DST_PER_Msk = 0xf0
	// Position of SRC_REP field.
	DMAC_CFG7_SRC_REP_Pos = 0x8
	// Bit mask of SRC_REP field.
	DMAC_CFG7_SRC_REP_Msk = 0x100
	// Bit SRC_REP.
	DMAC_CFG7_SRC_REP = 0x100
	// When automatic mode is activated, source address is contiguous between two buffers.
	DMAC_CFG7_SRC_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the source address and the control register are reloaded from previous transfer.
	DMAC_CFG7_SRC_REP_RELOAD_ADDR = 0x1
	// Position of SRC_H2SEL field.
	DMAC_CFG7_SRC_H2SEL_Pos = 0x9
	// Bit mask of SRC_H2SEL field.
	DMAC_CFG7_SRC_H2SEL_Msk = 0x200
	// Bit SRC_H2SEL.
	DMAC_CFG7_SRC_H2SEL = 0x200
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG7_SRC_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG7_SRC_H2SEL_HW = 0x1
	// Position of SRC_PER_MSB field.
	DMAC_CFG7_SRC_PER_MSB_Pos = 0xa
	// Bit mask of SRC_PER_MSB field.
	DMAC_CFG7_SRC_PER_MSB_Msk = 0xc00
	// Position of DST_REP field.
	DMAC_CFG7_DST_REP_Pos = 0xc
	// Bit mask of DST_REP field.
	DMAC_CFG7_DST_REP_Msk = 0x1000
	// Bit DST_REP.
	DMAC_CFG7_DST_REP = 0x1000
	// When automatic mode is activated, destination address is contiguous between two buffers.
	DMAC_CFG7_DST_REP_CONTIGUOUS_ADDR = 0x0
	// When automatic mode is activated, the destination and the control register are reloaded from the pre-vious transfer.
	DMAC_CFG7_DST_REP_RELOAD_ADDR = 0x1
	// Position of DST_H2SEL field.
	DMAC_CFG7_DST_H2SEL_Pos = 0xd
	// Bit mask of DST_H2SEL field.
	DMAC_CFG7_DST_H2SEL_Msk = 0x2000
	// Bit DST_H2SEL.
	DMAC_CFG7_DST_H2SEL = 0x2000
	// Software handshaking interface is used to trigger a transfer request.
	DMAC_CFG7_DST_H2SEL_SW = 0x0
	// Hardware handshaking interface is used to trigger a transfer request.
	DMAC_CFG7_DST_H2SEL_HW = 0x1
	// Position of DST_PER_MSB field.
	DMAC_CFG7_DST_PER_MSB_Pos = 0xe
	// Bit mask of DST_PER_MSB field.
	DMAC_CFG7_DST_PER_MSB_Msk = 0xc000
	// Position of SOD field.
	DMAC_CFG7_SOD_Pos = 0x10
	// Bit mask of SOD field.
	DMAC_CFG7_SOD_Msk = 0x10000
	// Bit SOD.
	DMAC_CFG7_SOD = 0x10000
	// STOP ON DONE disabled, the descriptor fetch operation ignores DONE Field of CTRLA register.
	DMAC_CFG7_SOD_DISABLE = 0x0
	// STOP ON DONE activated, the DMAC module is automatically disabled if DONE FIELD is set to 1.
	DMAC_CFG7_SOD_ENABLE = 0x1
	// Position of LOCK_IF field.
	DMAC_CFG7_LOCK_IF_Pos = 0x14
	// Bit mask of LOCK_IF field.
	DMAC_CFG7_LOCK_IF_Msk = 0x100000
	// Bit LOCK_IF.
	DMAC_CFG7_LOCK_IF = 0x100000
	// Interface Lock capability is disabled
	DMAC_CFG7_LOCK_IF_DISABLE = 0x0
	// Interface Lock capability is enabled
	DMAC_CFG7_LOCK_IF_ENABLE = 0x1
	// Position of LOCK_B field.
	DMAC_CFG7_LOCK_B_Pos = 0x15
	// Bit mask of LOCK_B field.
	DMAC_CFG7_LOCK_B_Msk = 0x200000
	// Bit LOCK_B.
	DMAC_CFG7_LOCK_B = 0x200000
	// AHB Bus Locking capability is disabled.
	DMAC_CFG7_LOCK_B_DISABLE = 0x0
	// Position of LOCK_IF_L field.
	DMAC_CFG7_LOCK_IF_L_Pos = 0x16
	// Bit mask of LOCK_IF_L field.
	DMAC_CFG7_LOCK_IF_L_Msk = 0x400000
	// Bit LOCK_IF_L.
	DMAC_CFG7_LOCK_IF_L = 0x400000
	// The Master Interface Arbiter is locked by the channel x for a chunk transfer.
	DMAC_CFG7_LOCK_IF_L_CHUNK = 0x0
	// The Master Interface Arbiter is locked by the channel x for a buffer transfer.
	DMAC_CFG7_LOCK_IF_L_BUFFER = 0x1
	// Position of AHB_PROT field.
	DMAC_CFG7_AHB_PROT_Pos = 0x18
	// Bit mask of AHB_PROT field.
	DMAC_CFG7_AHB_PROT_Msk = 0x7000000
	// Position of FIFOCFG field.
	DMAC_CFG7_FIFOCFG_Pos = 0x1c
	// Bit mask of FIFOCFG field.
	DMAC_CFG7_FIFOCFG_Msk = 0x30000000
	// The largest defined length AHB burst is performed on the destination AHB interface.
	DMAC_CFG7_FIFOCFG_ALAP_CFG = 0x0
	// When half FIFO size is available/filled, a source/destination request is serviced.
	DMAC_CFG7_FIFOCFG_HALF_CFG = 0x1
	// When there is enough space/data available to perform a single AHB access, then the request is serviced.
	DMAC_CFG7_FIFOCFG_ASAP_CFG = 0x2

	// SPIP7: DMAC Channel Source Picture-in-Picture Configuration Register (ch_num = 7)
	// Position of SPIP_HOLE field.
	DMAC_SPIP7_SPIP_HOLE_Pos = 0x0
	// Bit mask of SPIP_HOLE field.
	DMAC_SPIP7_SPIP_HOLE_Msk = 0xffff
	// Position of SPIP_BOUNDARY field.
	DMAC_SPIP7_SPIP_BOUNDARY_Pos = 0x10
	// Bit mask of SPIP_BOUNDARY field.
	DMAC_SPIP7_SPIP_BOUNDARY_Msk = 0x3ff0000

	// DPIP7: DMAC Channel Destination Picture-in-Picture Configuration Register (ch_num = 7)
	// Position of DPIP_HOLE field.
	DMAC_DPIP7_DPIP_HOLE_Pos = 0x0
	// Bit mask of DPIP_HOLE field.
	DMAC_DPIP7_DPIP_HOLE_Msk = 0xffff
	// Position of DPIP_BOUNDARY field.
	DMAC_DPIP7_DPIP_BOUNDARY_Pos = 0x10
	// Bit mask of DPIP_BOUNDARY field.
	DMAC_DPIP7_DPIP_BOUNDARY_Msk = 0x3ff0000

	// WPMR: DMAC Write Protect Mode Register
	// Position of WPEN field.
	DMAC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	DMAC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	DMAC_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	DMAC_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	DMAC_WPMR_WPKEY_Msk = 0xffffff00

	// WPSR: DMAC Write Protect Status Register
	// Position of WPVS field.
	DMAC_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	DMAC_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	DMAC_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	DMAC_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	DMAC_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for MPDDRC: AHB Multi-port DDR-SDRAM Controller
const (
	// MR: MPDDRC Mode Register
	// Position of MODE field.
	EBI_MR_MODE_Pos = 0x0
	// Bit mask of MODE field.
	EBI_MR_MODE_Msk = 0x7
	// Normal Mode. Any access to the MPDDRC will be decoded normally. To activate this mode, the command must be followed by a write to the DDR-SDRAM.
	EBI_MR_MODE_NORMAL_CMD = 0x0
	// The MPDDRC issues a NOP command when the DDR-SDRAM device is accessed regardless of the cycle. To activate this mode, the command must be followed by a write to the DDR-SDRAM.
	EBI_MR_MODE_NOP_CMD = 0x1
	// The MPDDRC issues an "All Banks Precharge" command when the DDR-SDRAM device is accessed regardless of the cycle. To activate this mode, the command must be followed by a write to the SDRAM.
	EBI_MR_MODE_PRCGALL_CMD = 0x2
	// The MPDDRC issues a "Load Mode Register" command when the DDR-SDRAM device is accessed regardless of the cycle. To activate this mode, the command must be followed by a write to the DDR-SDRAM.
	EBI_MR_MODE_LMR_CMD = 0x3
	// The MPDDRC issues an "Auto-Refresh" Command when the DDR-SDRAM device is accessed regardless of the cycle. Previously, an "All Banks Precharge" command must be issued. To activate this mode, the command must be followed by a write to the DDR-SDRAM.
	EBI_MR_MODE_RFSH_CMD = 0x4
	// The MPDDRC issues an "Extended Load Mode Register" command when the SDRAM device is accessed regardless of the cycle. To activate this mode, the command must be followed by a write to the DDR-SDRAM. The write in the DDR-SDRAM must be done in the appropriate bank.
	EBI_MR_MODE_EXT_LMR_CMD = 0x5
	// Deep power mode: Access to deep power-down mode
	EBI_MR_MODE_DEEP_CMD = 0x6
	// The MPDDRC issues an "LPDDR2 Mode Register" command when the Low-power DDR2-SDRAM device is accessed regardless of the cycle. To activate this mode, the "Mode Register" command must be followed by a write to the Low-power DDR2-SDRAM.
	EBI_MR_MODE_LPDDR2_CMD = 0x7
	// Position of MRS field.
	EBI_MR_MRS_Pos = 0x8
	// Bit mask of MRS field.
	EBI_MR_MRS_Msk = 0xff00

	// RTR: MPDDRC Refresh Timer Register
	// Position of COUNT field.
	EBI_RTR_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	EBI_RTR_COUNT_Msk = 0xfff
	// Position of ADJ_REF field.
	EBI_RTR_ADJ_REF_Pos = 0x10
	// Bit mask of ADJ_REF field.
	EBI_RTR_ADJ_REF_Msk = 0x10000
	// Bit ADJ_REF.
	EBI_RTR_ADJ_REF = 0x10000
	// Position of REF_PB field.
	EBI_RTR_REF_PB_Pos = 0x11
	// Bit mask of REF_PB field.
	EBI_RTR_REF_PB_Msk = 0x20000
	// Bit REF_PB.
	EBI_RTR_REF_PB = 0x20000
	// Position of MR4_VALUE field.
	EBI_RTR_MR4_VALUE_Pos = 0x14
	// Bit mask of MR4_VALUE field.
	EBI_RTR_MR4_VALUE_Msk = 0x700000

	// CR: MPDDRC Configuration Register
	// Position of NC field.
	EBI_CR_NC_Pos = 0x0
	// Bit mask of NC field.
	EBI_CR_NC_Msk = 0x3
	// 9 DDR column bits
	EBI_CR_NC_COL_9 = 0x0
	// 10 DDR column bits
	EBI_CR_NC_COL_10 = 0x1
	// 11 DDR column bits
	EBI_CR_NC_COL_11 = 0x2
	// 12 DDR column bits
	EBI_CR_NC_COL_12 = 0x3
	// Position of NR field.
	EBI_CR_NR_Pos = 0x2
	// Bit mask of NR field.
	EBI_CR_NR_Msk = 0xc
	// 11 row bits
	EBI_CR_NR_ROW_11 = 0x0
	// 12 row bits
	EBI_CR_NR_ROW_12 = 0x1
	// 13 row bits
	EBI_CR_NR_ROW_13 = 0x2
	// 14 row bits
	EBI_CR_NR_ROW_14 = 0x3
	// Position of CAS field.
	EBI_CR_CAS_Pos = 0x4
	// Bit mask of CAS field.
	EBI_CR_CAS_Msk = 0x70
	// LPDDR1 CAS Latency 2
	EBI_CR_CAS_DDR_CAS2 = 0x2
	// DDR2/LPDDR2/LPDDR1 CAS Latency 3
	EBI_CR_CAS_DDR_CAS3 = 0x3
	// DDR2/LPDDR2 CAS Latency 4
	EBI_CR_CAS_DDR_CAS4 = 0x4
	// DDR2/LPDDR2 CAS Latency 5
	EBI_CR_CAS_DDR_CAS5 = 0x5
	// DDR2 CAS Latency 6
	EBI_CR_CAS_DDR_CAS6 = 0x6
	// Position of DLL field.
	EBI_CR_DLL_Pos = 0x7
	// Bit mask of DLL field.
	EBI_CR_DLL_Msk = 0x80
	// Bit DLL.
	EBI_CR_DLL = 0x80
	// Disable DLL reset.
	EBI_CR_DLL_RESET_DISABLED = 0x0
	// Enable DLL reset.
	EBI_CR_DLL_RESET_ENABLED = 0x1
	// Position of DIC_DS field.
	EBI_CR_DIC_DS_Pos = 0x8
	// Bit mask of DIC_DS field.
	EBI_CR_DIC_DS_Msk = 0x100
	// Bit DIC_DS.
	EBI_CR_DIC_DS = 0x100
	// Position of DIS_DLL field.
	EBI_CR_DIS_DLL_Pos = 0x9
	// Bit mask of DIS_DLL field.
	EBI_CR_DIS_DLL_Msk = 0x200
	// Bit DIS_DLL.
	EBI_CR_DIS_DLL = 0x200
	// Position of ZQ field.
	EBI_CR_ZQ_Pos = 0xa
	// Bit mask of ZQ field.
	EBI_CR_ZQ_Msk = 0xc00
	// Calibration command after initialization
	EBI_CR_ZQ_INIT = 0x0
	// Long calibration
	EBI_CR_ZQ_LONG = 0x1
	// Short calibration
	EBI_CR_ZQ_SHORT = 0x2
	// ZQ Reset
	EBI_CR_ZQ_RESET = 0x3
	// Position of OCD field.
	EBI_CR_OCD_Pos = 0xc
	// Bit mask of OCD field.
	EBI_CR_OCD_Msk = 0x7000
	// Position of DQMS field.
	EBI_CR_DQMS_Pos = 0x10
	// Bit mask of DQMS field.
	EBI_CR_DQMS_Msk = 0x10000
	// Bit DQMS.
	EBI_CR_DQMS = 0x10000
	// DQM is not shared with another controller.
	EBI_CR_DQMS_NOT_SHARED = 0x0
	// DQM is shared with another controller.
	EBI_CR_DQMS_SHARED = 0x1
	// Position of ENRDM field.
	EBI_CR_ENRDM_Pos = 0x11
	// Bit mask of ENRDM field.
	EBI_CR_ENRDM_Msk = 0x20000
	// Bit ENRDM.
	EBI_CR_ENRDM = 0x20000
	// DQS/DDR_DATA phase error correction is disabled.
	EBI_CR_ENRDM_OFF = 0x0
	// DQS/DDR_DATA phase error correction is enabled.
	EBI_CR_ENRDM_ON = 0x1
	// Position of NB field.
	EBI_CR_NB_Pos = 0x14
	// Bit mask of NB field.
	EBI_CR_NB_Msk = 0x100000
	// Bit NB.
	EBI_CR_NB = 0x100000
	// 4 banks
	EBI_CR_NB_4 = 0x0
	// 8 banks
	EBI_CR_NB_8 = 0x1
	// Position of NDQS field.
	EBI_CR_NDQS_Pos = 0x15
	// Bit mask of NDQS field.
	EBI_CR_NDQS_Msk = 0x200000
	// Bit NDQS.
	EBI_CR_NDQS = 0x200000
	// Not DQS is enabled.
	EBI_CR_NDQS_ENABLED = 0x0
	// Not DQS is disabled.
	EBI_CR_NDQS_DISABLED = 0x1
	// Position of DECOD field.
	EBI_CR_DECOD_Pos = 0x16
	// Bit mask of DECOD field.
	EBI_CR_DECOD_Msk = 0x400000
	// Bit DECOD.
	EBI_CR_DECOD = 0x400000
	// Position of UNAL field.
	EBI_CR_UNAL_Pos = 0x17
	// Bit mask of UNAL field.
	EBI_CR_UNAL_Msk = 0x800000
	// Bit UNAL.
	EBI_CR_UNAL = 0x800000
	// Unaligned access is not supported.
	EBI_CR_UNAL_UNSUPPORTED = 0x0
	// Unaligned access is supported.
	EBI_CR_UNAL_SUPPORTED = 0x1

	// TPR0: MPDDRC Timing Parameter 0 Register
	// Position of TRAS field.
	EBI_TPR0_TRAS_Pos = 0x0
	// Bit mask of TRAS field.
	EBI_TPR0_TRAS_Msk = 0xf
	// Position of TRCD field.
	EBI_TPR0_TRCD_Pos = 0x4
	// Bit mask of TRCD field.
	EBI_TPR0_TRCD_Msk = 0xf0
	// Position of TWR field.
	EBI_TPR0_TWR_Pos = 0x8
	// Bit mask of TWR field.
	EBI_TPR0_TWR_Msk = 0xf00
	// Position of TRC field.
	EBI_TPR0_TRC_Pos = 0xc
	// Bit mask of TRC field.
	EBI_TPR0_TRC_Msk = 0xf000
	// Position of TRP field.
	EBI_TPR0_TRP_Pos = 0x10
	// Bit mask of TRP field.
	EBI_TPR0_TRP_Msk = 0xf0000
	// Position of TRRD field.
	EBI_TPR0_TRRD_Pos = 0x14
	// Bit mask of TRRD field.
	EBI_TPR0_TRRD_Msk = 0xf00000
	// Position of TWTR field.
	EBI_TPR0_TWTR_Pos = 0x18
	// Bit mask of TWTR field.
	EBI_TPR0_TWTR_Msk = 0x7000000
	// Position of RDC_WRRD field.
	EBI_TPR0_RDC_WRRD_Pos = 0x1b
	// Bit mask of RDC_WRRD field.
	EBI_TPR0_RDC_WRRD_Msk = 0x8000000
	// Bit RDC_WRRD.
	EBI_TPR0_RDC_WRRD = 0x8000000
	// Position of TMRD field.
	EBI_TPR0_TMRD_Pos = 0x1c
	// Bit mask of TMRD field.
	EBI_TPR0_TMRD_Msk = 0xf0000000

	// TPR1: MPDDRC Timing Parameter 1 Register
	// Position of TRFC field.
	EBI_TPR1_TRFC_Pos = 0x0
	// Bit mask of TRFC field.
	EBI_TPR1_TRFC_Msk = 0x7f
	// Position of TXSNR field.
	EBI_TPR1_TXSNR_Pos = 0x8
	// Bit mask of TXSNR field.
	EBI_TPR1_TXSNR_Msk = 0xff00
	// Position of TXSRD field.
	EBI_TPR1_TXSRD_Pos = 0x10
	// Bit mask of TXSRD field.
	EBI_TPR1_TXSRD_Msk = 0xff0000
	// Position of TXP field.
	EBI_TPR1_TXP_Pos = 0x18
	// Bit mask of TXP field.
	EBI_TPR1_TXP_Msk = 0xf000000

	// TPR2: MPDDRC Timing Parameter 2 Register
	// Position of TXARD field.
	EBI_TPR2_TXARD_Pos = 0x0
	// Bit mask of TXARD field.
	EBI_TPR2_TXARD_Msk = 0xf
	// Position of TXARDS field.
	EBI_TPR2_TXARDS_Pos = 0x4
	// Bit mask of TXARDS field.
	EBI_TPR2_TXARDS_Msk = 0xf0
	// Position of TRPA field.
	EBI_TPR2_TRPA_Pos = 0x8
	// Bit mask of TRPA field.
	EBI_TPR2_TRPA_Msk = 0xf00
	// Position of TRTP field.
	EBI_TPR2_TRTP_Pos = 0xc
	// Bit mask of TRTP field.
	EBI_TPR2_TRTP_Msk = 0x7000
	// Position of TFAW field.
	EBI_TPR2_TFAW_Pos = 0x10
	// Bit mask of TFAW field.
	EBI_TPR2_TFAW_Msk = 0xf0000

	// LPR: MPDDRC Low-power Register
	// Position of LPCB field.
	EBI_LPR_LPCB_Pos = 0x0
	// Bit mask of LPCB field.
	EBI_LPR_LPCB_Msk = 0x3
	// Low-power Feature is inhibited. No power-down, self refresh and deep-power modes are issued to the DDR-SDRAM device.
	EBI_LPR_LPCB_DISABLED = 0x0
	// The MPDDRC issues a Self Refresh command to the DDR-SDRAM device, the clock(s) is/are de-activated and the CKE signal is set low. The DDR-SDRAM device leaves the self refresh mode when accessed and reenters it after the access.
	EBI_LPR_LPCB_SELFREFRESH = 0x1
	// The MPDDRC issues a Power-down Command to the DDR-SDRAM device after each access, the CKE signal is set low. The DDR-SDRAM device leaves the power-down mode when accessed and reenters it after the access.
	EBI_LPR_LPCB_POWERDOWN = 0x2
	// The MPDDRC issues a Deep Power-down command to the Low-power DDR-SDRAM device.
	EBI_LPR_LPCB_DEEP_PWD = 0x3
	// Position of CLK_FR field.
	EBI_LPR_CLK_FR_Pos = 0x2
	// Bit mask of CLK_FR field.
	EBI_LPR_CLK_FR_Msk = 0x4
	// Bit CLK_FR.
	EBI_LPR_CLK_FR = 0x4
	// Clock(s) is/are not frozen.
	EBI_LPR_CLK_FR_DISABLED = 0x0
	// Clock(s) is/are frozen.
	EBI_LPR_CLK_FR_ENABLED = 0x1
	// Position of LPDDR2_PWOFF field.
	EBI_LPR_LPDDR2_PWOFF_Pos = 0x3
	// Bit mask of LPDDR2_PWOFF field.
	EBI_LPR_LPDDR2_PWOFF_Msk = 0x8
	// Bit LPDDR2_PWOFF.
	EBI_LPR_LPDDR2_PWOFF = 0x8
	// No power off sequence applied to LPDDR2.
	EBI_LPR_LPDDR2_PWOFF_DISABLED = 0x0
	// A power off sequence is applied to the LPDDR2 device. CKE is forced low.
	EBI_LPR_LPDDR2_PWOFF_ENABLED = 0x1
	// Position of PASR field.
	EBI_LPR_PASR_Pos = 0x4
	// Bit mask of PASR field.
	EBI_LPR_PASR_Msk = 0x70
	// Position of DS field.
	EBI_LPR_DS_Pos = 0x8
	// Bit mask of DS field.
	EBI_LPR_DS_Msk = 0x700
	// Position of TIMEOUT field.
	EBI_LPR_TIMEOUT_Pos = 0xc
	// Bit mask of TIMEOUT field.
	EBI_LPR_TIMEOUT_Msk = 0x3000
	// The SDRAM controller activates the SDRAM low-power mode immediately after the end of the last transfer.
	EBI_LPR_TIMEOUT_0 = 0x0
	// The SDRAM controller activates the SDRAM low-power mode 64 clock cycles after the end of the last transfer.
	EBI_LPR_TIMEOUT_64 = 0x1
	// The SDRAM controller activates the SDRAM low-power mode 128 clock cycles after the end of the last transfer.
	EBI_LPR_TIMEOUT_128 = 0x2
	// Position of APDE field.
	EBI_LPR_APDE_Pos = 0x10
	// Bit mask of APDE field.
	EBI_LPR_APDE_Msk = 0x10000
	// Bit APDE.
	EBI_LPR_APDE = 0x10000
	// Fast Exit.
	EBI_LPR_APDE_FAST = 0x0
	// Low Exit.
	EBI_LPR_APDE_SLOW = 0x1
	// Position of UPD_MR field.
	EBI_LPR_UPD_MR_Pos = 0x14
	// Bit mask of UPD_MR field.
	EBI_LPR_UPD_MR_Msk = 0x300000
	// Update is disabled.
	EBI_LPR_UPD_MR_DISABLED = 0x0

	// MD: MPDDRC Memory Device Register
	// Position of MD field.
	EBI_MD_MD_Pos = 0x0
	// Bit mask of MD field.
	EBI_MD_MD_Msk = 0x7
	// Low-power DDR1-SDRAM
	EBI_MD_MD_LPDDR_SDRAM = 0x3
	// DDR2-SDRAM
	EBI_MD_MD_DDR2_SDRAM = 0x6
	// Low-Power DDR2-SDRAM
	EBI_MD_MD_LPDDR2_SDRAM = 0x7
	// Position of DBW field.
	EBI_MD_DBW_Pos = 0x4
	// Bit mask of DBW field.
	EBI_MD_DBW_Msk = 0x10
	// Bit DBW.
	EBI_MD_DBW = 0x10
	// Data bus width is 32 bits.
	EBI_MD_DBW_DBW_32_BITS = 0x0
	// Data bus width is 16 bits.(1)
	EBI_MD_DBW_DBW_16_BITS = 0x1

	// HS: MPDDRC High Speed Register
	// Position of DIS_ANTICIP_READ field.
	EBI_HS_DIS_ANTICIP_READ_Pos = 0x2
	// Bit mask of DIS_ANTICIP_READ field.
	EBI_HS_DIS_ANTICIP_READ_Msk = 0x4
	// Bit DIS_ANTICIP_READ.
	EBI_HS_DIS_ANTICIP_READ = 0x4

	// LPDDR2_LPR: MPDDRC LPDDR2 Low-power Register
	// Position of BK_MASK_PASR field.
	EBI_LPDDR2_LPR_BK_MASK_PASR_Pos = 0x0
	// Bit mask of BK_MASK_PASR field.
	EBI_LPDDR2_LPR_BK_MASK_PASR_Msk = 0xff
	// Position of SEG_MASK field.
	EBI_LPDDR2_LPR_SEG_MASK_Pos = 0x8
	// Bit mask of SEG_MASK field.
	EBI_LPDDR2_LPR_SEG_MASK_Msk = 0xffff00
	// Position of DS field.
	EBI_LPDDR2_LPR_DS_Pos = 0x18
	// Bit mask of DS field.
	EBI_LPDDR2_LPR_DS_Msk = 0xf000000

	// LPDDR2_CAL_MR4: MPDDRC LPDDR2 Calibration and MR4 Register
	// Position of COUNT_CAL field.
	EBI_LPDDR2_CAL_MR4_COUNT_CAL_Pos = 0x0
	// Bit mask of COUNT_CAL field.
	EBI_LPDDR2_CAL_MR4_COUNT_CAL_Msk = 0xffff
	// Position of MR4_READ field.
	EBI_LPDDR2_CAL_MR4_MR4_READ_Pos = 0x10
	// Bit mask of MR4_READ field.
	EBI_LPDDR2_CAL_MR4_MR4_READ_Msk = 0xffff0000

	// LPDDR2_TIM_CAL: MPDDRC LPDDR2 Timing Calibration Register
	// Position of ZQCS field.
	EBI_LPDDR2_TIM_CAL_ZQCS_Pos = 0x0
	// Bit mask of ZQCS field.
	EBI_LPDDR2_TIM_CAL_ZQCS_Msk = 0xff

	// IO_CALIBR: MPDDRC IO Calibration
	// Position of RDIV field.
	EBI_IO_CALIBR_RDIV_Pos = 0x0
	// Bit mask of RDIV field.
	EBI_IO_CALIBR_RDIV_Msk = 0x7
	// LPDDR2 RZQ = 34,3 Ohm, DDR2/LPDDR1: Not applicable
	EBI_IO_CALIBR_RDIV_RZQ_34 = 0x1
	// LPDDR2:RZQ = 40 Ohm, DDR2/LPDDR1: RZQ = 33,3 Ohm
	EBI_IO_CALIBR_RDIV_RZQ_40_RZQ_33_3 = 0x2
	// LPDDR2:RZQ =48 Ohm, DDR2/LPDDR1: RZQ =40 Ohm
	EBI_IO_CALIBR_RDIV_RZQ_48_RZQ_40 = 0x3
	// LPDDR2:RZQ =60 Ohm, DDR2/LPDDR1: RZQ =50 Ohm
	EBI_IO_CALIBR_RDIV_RZQ_60_RZQ_50 = 0x4
	// LPDDR2: RZQ = 80 Ohm, DDR2/LPDDR1: RZQ = 66,7 Ohm
	EBI_IO_CALIBR_RDIV_RZQ_80_RZQ_66_7 = 0x6
	// LPDDR2:RZQ = 120 Ohm, DDR2/LPDDR1: RZQ = 100 Ohm
	EBI_IO_CALIBR_RDIV_RZQ_120_RZQ_100 = 0x7
	// Position of TZQIO field.
	EBI_IO_CALIBR_TZQIO_Pos = 0x8
	// Bit mask of TZQIO field.
	EBI_IO_CALIBR_TZQIO_Msk = 0x700
	// Position of CALCODEP field.
	EBI_IO_CALIBR_CALCODEP_Pos = 0x10
	// Bit mask of CALCODEP field.
	EBI_IO_CALIBR_CALCODEP_Msk = 0xf0000
	// Position of CALCODEN field.
	EBI_IO_CALIBR_CALCODEN_Pos = 0x14
	// Bit mask of CALCODEN field.
	EBI_IO_CALIBR_CALCODEN_Msk = 0xf00000

	// SAW: MPDDRC Smart Adaptation Wrapper 0 Register
	// Position of FLUSH_MAX field.
	EBI_SAW_FLUSH_MAX_Pos = 0x0
	// Bit mask of FLUSH_MAX field.
	EBI_SAW_FLUSH_MAX_Msk = 0xff
	// Position of INCR_THRESH field.
	EBI_SAW_INCR_THRESH_Pos = 0x8
	// Bit mask of INCR_THRESH field.
	EBI_SAW_INCR_THRESH_Msk = 0x3f00
	// 1 word/dword max
	EBI_SAW_INCR_THRESH_1 = 0x1
	// 2 word/dword max
	EBI_SAW_INCR_THRESH_2 = 0x2
	// 4 word/dword max
	EBI_SAW_INCR_THRESH_4 = 0x4
	// 8 word/dword max
	EBI_SAW_INCR_THRESH_8 = 0x8
	// 16 word/dword max
	EBI_SAW_INCR_THRESH_16 = 0x10
	// 32 word/dword max
	EBI_SAW_INCR_THRESH_32 = 0x20
	// Position of PFCH_THRESH field.
	EBI_SAW_PFCH_THRESH_Pos = 0x10
	// Bit mask of PFCH_THRESH field.
	EBI_SAW_PFCH_THRESH_Msk = 0x3f0000
	// 2 word/dword max
	EBI_SAW_PFCH_THRESH_2 = 0x2
	// 4 word/dword max
	EBI_SAW_PFCH_THRESH_4 = 0x4
	// 8 word/dword max
	EBI_SAW_PFCH_THRESH_8 = 0x8

	// DLL_MO: MPDDRC DLL Master Offset Register
	// Position of MOFF field.
	EBI_DLL_MO_MOFF_Pos = 0x0
	// Bit mask of MOFF field.
	EBI_DLL_MO_MOFF_Msk = 0xf
	// Position of CLK90OFF field.
	EBI_DLL_MO_CLK90OFF_Pos = 0x8
	// Bit mask of CLK90OFF field.
	EBI_DLL_MO_CLK90OFF_Msk = 0x1f00
	// Position of SELOFF field.
	EBI_DLL_MO_SELOFF_Pos = 0x10
	// Bit mask of SELOFF field.
	EBI_DLL_MO_SELOFF_Msk = 0x10000
	// Bit SELOFF.
	EBI_DLL_MO_SELOFF = 0x10000

	// DLL_SOF: MPDDRC DLL Slave Offset Register
	// Position of S0OFF field.
	EBI_DLL_SOF_S0OFF_Pos = 0x0
	// Bit mask of S0OFF field.
	EBI_DLL_SOF_S0OFF_Msk = 0x1f
	// Position of S1OFF field.
	EBI_DLL_SOF_S1OFF_Pos = 0x8
	// Bit mask of S1OFF field.
	EBI_DLL_SOF_S1OFF_Msk = 0x1f00
	// Position of S2OFF field.
	EBI_DLL_SOF_S2OFF_Pos = 0x10
	// Bit mask of S2OFF field.
	EBI_DLL_SOF_S2OFF_Msk = 0x1f0000
	// Position of S3OFF field.
	EBI_DLL_SOF_S3OFF_Pos = 0x18
	// Bit mask of S3OFF field.
	EBI_DLL_SOF_S3OFF_Msk = 0x1f000000

	// DLL_MS: MPDDRC DLL Status Master Register
	// Position of MDINC field.
	EBI_DLL_MS_MDINC_Pos = 0x0
	// Bit mask of MDINC field.
	EBI_DLL_MS_MDINC_Msk = 0x1
	// Bit MDINC.
	EBI_DLL_MS_MDINC = 0x1
	// Position of MDDEC field.
	EBI_DLL_MS_MDDEC_Pos = 0x1
	// Bit mask of MDDEC field.
	EBI_DLL_MS_MDDEC_Msk = 0x2
	// Bit MDDEC.
	EBI_DLL_MS_MDDEC = 0x2
	// Position of MDOVF field.
	EBI_DLL_MS_MDOVF_Pos = 0x2
	// Bit mask of MDOVF field.
	EBI_DLL_MS_MDOVF_Msk = 0x4
	// Bit MDOVF.
	EBI_DLL_MS_MDOVF = 0x4
	// Position of MDVAL field.
	EBI_DLL_MS_MDVAL_Pos = 0x8
	// Bit mask of MDVAL field.
	EBI_DLL_MS_MDVAL_Msk = 0xff00

	// DLL_SS: MPDDRC DLL Status Slave 0 Register
	// Position of SDCOVF field.
	EBI_DLL_SS_SDCOVF_Pos = 0x0
	// Bit mask of SDCOVF field.
	EBI_DLL_SS_SDCOVF_Msk = 0x1
	// Bit SDCOVF.
	EBI_DLL_SS_SDCOVF = 0x1
	// Position of SDCUDF field.
	EBI_DLL_SS_SDCUDF_Pos = 0x1
	// Bit mask of SDCUDF field.
	EBI_DLL_SS_SDCUDF_Msk = 0x2
	// Bit SDCUDF.
	EBI_DLL_SS_SDCUDF = 0x2
	// Position of SDERF field.
	EBI_DLL_SS_SDERF_Pos = 0x2
	// Bit mask of SDERF field.
	EBI_DLL_SS_SDERF_Msk = 0x4
	// Bit SDERF.
	EBI_DLL_SS_SDERF = 0x4
	// Position of SDVAL field.
	EBI_DLL_SS_SDVAL_Pos = 0x8
	// Bit mask of SDVAL field.
	EBI_DLL_SS_SDVAL_Msk = 0xff00
	// Position of SDCVAL field.
	EBI_DLL_SS_SDCVAL_Pos = 0x10
	// Bit mask of SDCVAL field.
	EBI_DLL_SS_SDCVAL_Msk = 0xff0000

	// WPCR: MPDDRC Write Protect Control Register
	// Position of WPEN field.
	EBI_WPCR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	EBI_WPCR_WPEN_Msk = 0x1
	// Bit WPEN.
	EBI_WPCR_WPEN = 0x1
	// Position of WPKEY field.
	EBI_WPCR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	EBI_WPCR_WPKEY_Msk = 0xffffff00

	// WPSR: MPDDRC Write Protect Status Register
	// Position of WPVS field.
	EBI_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	EBI_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	EBI_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	EBI_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	EBI_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for MATRIX: AHB Bus Matrix
const (
	// MCFG: Master Configuration Register
	// Position of ULBT field.
	MATRIX_MCFG_ULBT_Pos = 0x0
	// Bit mask of ULBT field.
	MATRIX_MCFG_ULBT_Msk = 0x7

	// SCFG: Slave Configuration Register
	// Position of SLOT_CYCLE field.
	MATRIX_SCFG_SLOT_CYCLE_Pos = 0x0
	// Bit mask of SLOT_CYCLE field.
	MATRIX_SCFG_SLOT_CYCLE_Msk = 0x1ff
	// Position of DEFMSTR_TYPE field.
	MATRIX_SCFG_DEFMSTR_TYPE_Pos = 0x10
	// Bit mask of DEFMSTR_TYPE field.
	MATRIX_SCFG_DEFMSTR_TYPE_Msk = 0x30000
	// Position of FIXED_DEFMSTR field.
	MATRIX_SCFG_FIXED_DEFMSTR_Pos = 0x12
	// Bit mask of FIXED_DEFMSTR field.
	MATRIX_SCFG_FIXED_DEFMSTR_Msk = 0x3c0000

	// PRAS0: Priority Register A for Slave 0
	// Position of M0PR field.
	MATRIX_PRAS0_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS0_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS0_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS0_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS0_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS0_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS0_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS0_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS0_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS0_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS0_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS0_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS0_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS0_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS0_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS0_M7PR_Msk = 0x30000000

	// PRBS0: Priority Register B for Slave 0
	// Position of M8PR field.
	MATRIX_PRBS0_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS0_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS0_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS0_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS0_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS0_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS0_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS0_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS0_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS0_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS0_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS0_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS0_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS0_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS0_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS0_M15PR_Msk = 0x30000000

	// PRAS1: Priority Register A for Slave 1
	// Position of M0PR field.
	MATRIX_PRAS1_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS1_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS1_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS1_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS1_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS1_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS1_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS1_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS1_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS1_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS1_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS1_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS1_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS1_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS1_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS1_M7PR_Msk = 0x30000000

	// PRBS1: Priority Register B for Slave 1
	// Position of M8PR field.
	MATRIX_PRBS1_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS1_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS1_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS1_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS1_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS1_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS1_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS1_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS1_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS1_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS1_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS1_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS1_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS1_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS1_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS1_M15PR_Msk = 0x30000000

	// PRAS2: Priority Register A for Slave 2
	// Position of M0PR field.
	MATRIX_PRAS2_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS2_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS2_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS2_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS2_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS2_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS2_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS2_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS2_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS2_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS2_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS2_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS2_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS2_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS2_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS2_M7PR_Msk = 0x30000000

	// PRBS2: Priority Register B for Slave 2
	// Position of M8PR field.
	MATRIX_PRBS2_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS2_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS2_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS2_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS2_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS2_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS2_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS2_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS2_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS2_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS2_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS2_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS2_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS2_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS2_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS2_M15PR_Msk = 0x30000000

	// PRAS3: Priority Register A for Slave 3
	// Position of M0PR field.
	MATRIX_PRAS3_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS3_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS3_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS3_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS3_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS3_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS3_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS3_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS3_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS3_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS3_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS3_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS3_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS3_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS3_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS3_M7PR_Msk = 0x30000000

	// PRBS3: Priority Register B for Slave 3
	// Position of M8PR field.
	MATRIX_PRBS3_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS3_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS3_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS3_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS3_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS3_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS3_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS3_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS3_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS3_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS3_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS3_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS3_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS3_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS3_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS3_M15PR_Msk = 0x30000000

	// PRAS4: Priority Register A for Slave 4
	// Position of M0PR field.
	MATRIX_PRAS4_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS4_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS4_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS4_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS4_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS4_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS4_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS4_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS4_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS4_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS4_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS4_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS4_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS4_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS4_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS4_M7PR_Msk = 0x30000000

	// PRBS4: Priority Register B for Slave 4
	// Position of M8PR field.
	MATRIX_PRBS4_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS4_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS4_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS4_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS4_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS4_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS4_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS4_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS4_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS4_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS4_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS4_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS4_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS4_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS4_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS4_M15PR_Msk = 0x30000000

	// PRAS5: Priority Register A for Slave 5
	// Position of M0PR field.
	MATRIX_PRAS5_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS5_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS5_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS5_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS5_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS5_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS5_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS5_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS5_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS5_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS5_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS5_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS5_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS5_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS5_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS5_M7PR_Msk = 0x30000000

	// PRBS5: Priority Register B for Slave 5
	// Position of M8PR field.
	MATRIX_PRBS5_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS5_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS5_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS5_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS5_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS5_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS5_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS5_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS5_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS5_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS5_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS5_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS5_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS5_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS5_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS5_M15PR_Msk = 0x30000000

	// PRAS6: Priority Register A for Slave 6
	// Position of M0PR field.
	MATRIX_PRAS6_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS6_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS6_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS6_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS6_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS6_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS6_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS6_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS6_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS6_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS6_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS6_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS6_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS6_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS6_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS6_M7PR_Msk = 0x30000000

	// PRBS6: Priority Register B for Slave 6
	// Position of M8PR field.
	MATRIX_PRBS6_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS6_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS6_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS6_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS6_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS6_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS6_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS6_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS6_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS6_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS6_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS6_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS6_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS6_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS6_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS6_M15PR_Msk = 0x30000000

	// PRAS7: Priority Register A for Slave 7
	// Position of M0PR field.
	MATRIX_PRAS7_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS7_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS7_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS7_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS7_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS7_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS7_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS7_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS7_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS7_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS7_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS7_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS7_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS7_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS7_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS7_M7PR_Msk = 0x30000000

	// PRBS7: Priority Register B for Slave 7
	// Position of M8PR field.
	MATRIX_PRBS7_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS7_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS7_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS7_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS7_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS7_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS7_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS7_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS7_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS7_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS7_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS7_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS7_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS7_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS7_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS7_M15PR_Msk = 0x30000000

	// PRAS8: Priority Register A for Slave 8
	// Position of M0PR field.
	MATRIX_PRAS8_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS8_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS8_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS8_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS8_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS8_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS8_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS8_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS8_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS8_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS8_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS8_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS8_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS8_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS8_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS8_M7PR_Msk = 0x30000000

	// PRBS8: Priority Register B for Slave 8
	// Position of M8PR field.
	MATRIX_PRBS8_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS8_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS8_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS8_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS8_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS8_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS8_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS8_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS8_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS8_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS8_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS8_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS8_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS8_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS8_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS8_M15PR_Msk = 0x30000000

	// PRAS9: Priority Register A for Slave 9
	// Position of M0PR field.
	MATRIX_PRAS9_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS9_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS9_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS9_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS9_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS9_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS9_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS9_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS9_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS9_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS9_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS9_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS9_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS9_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS9_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS9_M7PR_Msk = 0x30000000

	// PRBS9: Priority Register B for Slave 9
	// Position of M8PR field.
	MATRIX_PRBS9_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS9_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS9_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS9_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS9_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS9_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS9_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS9_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS9_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS9_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS9_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS9_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS9_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS9_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS9_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS9_M15PR_Msk = 0x30000000

	// PRAS10: Priority Register A for Slave 10
	// Position of M0PR field.
	MATRIX_PRAS10_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS10_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS10_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS10_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS10_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS10_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS10_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS10_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS10_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS10_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS10_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS10_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS10_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS10_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS10_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS10_M7PR_Msk = 0x30000000

	// PRBS10: Priority Register B for Slave 10
	// Position of M8PR field.
	MATRIX_PRBS10_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS10_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS10_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS10_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS10_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS10_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS10_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS10_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS10_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS10_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS10_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS10_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS10_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS10_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS10_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS10_M15PR_Msk = 0x30000000

	// PRAS11: Priority Register A for Slave 11
	// Position of M0PR field.
	MATRIX_PRAS11_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS11_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS11_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS11_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS11_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS11_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS11_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS11_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS11_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS11_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS11_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS11_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS11_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS11_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS11_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS11_M7PR_Msk = 0x30000000

	// PRBS11: Priority Register B for Slave 11
	// Position of M8PR field.
	MATRIX_PRBS11_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS11_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS11_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS11_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS11_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS11_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS11_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS11_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS11_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS11_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS11_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS11_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS11_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS11_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS11_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS11_M15PR_Msk = 0x30000000

	// PRAS12: Priority Register A for Slave 12
	// Position of M0PR field.
	MATRIX_PRAS12_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS12_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS12_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS12_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS12_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS12_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS12_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS12_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS12_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS12_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS12_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS12_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS12_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS12_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS12_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS12_M7PR_Msk = 0x30000000

	// PRBS12: Priority Register B for Slave 12
	// Position of M8PR field.
	MATRIX_PRBS12_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS12_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS12_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS12_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS12_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS12_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS12_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS12_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS12_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS12_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS12_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS12_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS12_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS12_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS12_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS12_M15PR_Msk = 0x30000000

	// PRAS13: Priority Register A for Slave 13
	// Position of M0PR field.
	MATRIX_PRAS13_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS13_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS13_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS13_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS13_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS13_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS13_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS13_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS13_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS13_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS13_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS13_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS13_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS13_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS13_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS13_M7PR_Msk = 0x30000000

	// PRBS13: Priority Register B for Slave 13
	// Position of M8PR field.
	MATRIX_PRBS13_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS13_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS13_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS13_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS13_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS13_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS13_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS13_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS13_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS13_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS13_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS13_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS13_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS13_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS13_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS13_M15PR_Msk = 0x30000000

	// PRAS14: Priority Register A for Slave 14
	// Position of M0PR field.
	MATRIX_PRAS14_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS14_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS14_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS14_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS14_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS14_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS14_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS14_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS14_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS14_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS14_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS14_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS14_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS14_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS14_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS14_M7PR_Msk = 0x30000000

	// PRBS14: Priority Register B for Slave 14
	// Position of M8PR field.
	MATRIX_PRBS14_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS14_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS14_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS14_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS14_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS14_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS14_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS14_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS14_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS14_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS14_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS14_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS14_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS14_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS14_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS14_M15PR_Msk = 0x30000000

	// PRAS15: Priority Register A for Slave 15
	// Position of M0PR field.
	MATRIX_PRAS15_M0PR_Pos = 0x0
	// Bit mask of M0PR field.
	MATRIX_PRAS15_M0PR_Msk = 0x3
	// Position of M1PR field.
	MATRIX_PRAS15_M1PR_Pos = 0x4
	// Bit mask of M1PR field.
	MATRIX_PRAS15_M1PR_Msk = 0x30
	// Position of M2PR field.
	MATRIX_PRAS15_M2PR_Pos = 0x8
	// Bit mask of M2PR field.
	MATRIX_PRAS15_M2PR_Msk = 0x300
	// Position of M3PR field.
	MATRIX_PRAS15_M3PR_Pos = 0xc
	// Bit mask of M3PR field.
	MATRIX_PRAS15_M3PR_Msk = 0x3000
	// Position of M4PR field.
	MATRIX_PRAS15_M4PR_Pos = 0x10
	// Bit mask of M4PR field.
	MATRIX_PRAS15_M4PR_Msk = 0x30000
	// Position of M5PR field.
	MATRIX_PRAS15_M5PR_Pos = 0x14
	// Bit mask of M5PR field.
	MATRIX_PRAS15_M5PR_Msk = 0x300000
	// Position of M6PR field.
	MATRIX_PRAS15_M6PR_Pos = 0x18
	// Bit mask of M6PR field.
	MATRIX_PRAS15_M6PR_Msk = 0x3000000
	// Position of M7PR field.
	MATRIX_PRAS15_M7PR_Pos = 0x1c
	// Bit mask of M7PR field.
	MATRIX_PRAS15_M7PR_Msk = 0x30000000

	// PRBS15: Priority Register B for Slave 15
	// Position of M8PR field.
	MATRIX_PRBS15_M8PR_Pos = 0x0
	// Bit mask of M8PR field.
	MATRIX_PRBS15_M8PR_Msk = 0x3
	// Position of M9PR field.
	MATRIX_PRBS15_M9PR_Pos = 0x4
	// Bit mask of M9PR field.
	MATRIX_PRBS15_M9PR_Msk = 0x30
	// Position of M10PR field.
	MATRIX_PRBS15_M10PR_Pos = 0x8
	// Bit mask of M10PR field.
	MATRIX_PRBS15_M10PR_Msk = 0x300
	// Position of M11PR field.
	MATRIX_PRBS15_M11PR_Pos = 0xc
	// Bit mask of M11PR field.
	MATRIX_PRBS15_M11PR_Msk = 0x3000
	// Position of M12PR field.
	MATRIX_PRBS15_M12PR_Pos = 0x10
	// Bit mask of M12PR field.
	MATRIX_PRBS15_M12PR_Msk = 0x30000
	// Position of M13PR field.
	MATRIX_PRBS15_M13PR_Pos = 0x14
	// Bit mask of M13PR field.
	MATRIX_PRBS15_M13PR_Msk = 0x300000
	// Position of M14PR field.
	MATRIX_PRBS15_M14PR_Pos = 0x18
	// Bit mask of M14PR field.
	MATRIX_PRBS15_M14PR_Msk = 0x3000000
	// Position of M15PR field.
	MATRIX_PRBS15_M15PR_Pos = 0x1c
	// Bit mask of M15PR field.
	MATRIX_PRBS15_M15PR_Msk = 0x30000000

	// MRCR: Master Remap Control Register
	// Position of RCB0 field.
	MATRIX_MRCR_RCB0_Pos = 0x0
	// Bit mask of RCB0 field.
	MATRIX_MRCR_RCB0_Msk = 0x1
	// Bit RCB0.
	MATRIX_MRCR_RCB0 = 0x1
	// Position of RCB1 field.
	MATRIX_MRCR_RCB1_Pos = 0x1
	// Bit mask of RCB1 field.
	MATRIX_MRCR_RCB1_Msk = 0x2
	// Bit RCB1.
	MATRIX_MRCR_RCB1 = 0x2
	// Position of RCB2 field.
	MATRIX_MRCR_RCB2_Pos = 0x2
	// Bit mask of RCB2 field.
	MATRIX_MRCR_RCB2_Msk = 0x4
	// Bit RCB2.
	MATRIX_MRCR_RCB2 = 0x4
	// Position of RCB3 field.
	MATRIX_MRCR_RCB3_Pos = 0x3
	// Bit mask of RCB3 field.
	MATRIX_MRCR_RCB3_Msk = 0x8
	// Bit RCB3.
	MATRIX_MRCR_RCB3 = 0x8
	// Position of RCB4 field.
	MATRIX_MRCR_RCB4_Pos = 0x4
	// Bit mask of RCB4 field.
	MATRIX_MRCR_RCB4_Msk = 0x10
	// Bit RCB4.
	MATRIX_MRCR_RCB4 = 0x10
	// Position of RCB5 field.
	MATRIX_MRCR_RCB5_Pos = 0x5
	// Bit mask of RCB5 field.
	MATRIX_MRCR_RCB5_Msk = 0x20
	// Bit RCB5.
	MATRIX_MRCR_RCB5 = 0x20
	// Position of RCB6 field.
	MATRIX_MRCR_RCB6_Pos = 0x6
	// Bit mask of RCB6 field.
	MATRIX_MRCR_RCB6_Msk = 0x40
	// Bit RCB6.
	MATRIX_MRCR_RCB6 = 0x40
	// Position of RCB7 field.
	MATRIX_MRCR_RCB7_Pos = 0x7
	// Bit mask of RCB7 field.
	MATRIX_MRCR_RCB7_Msk = 0x80
	// Bit RCB7.
	MATRIX_MRCR_RCB7 = 0x80
	// Position of RCB8 field.
	MATRIX_MRCR_RCB8_Pos = 0x8
	// Bit mask of RCB8 field.
	MATRIX_MRCR_RCB8_Msk = 0x100
	// Bit RCB8.
	MATRIX_MRCR_RCB8 = 0x100
	// Position of RCB9 field.
	MATRIX_MRCR_RCB9_Pos = 0x9
	// Bit mask of RCB9 field.
	MATRIX_MRCR_RCB9_Msk = 0x200
	// Bit RCB9.
	MATRIX_MRCR_RCB9 = 0x200
	// Position of RCB10 field.
	MATRIX_MRCR_RCB10_Pos = 0xa
	// Bit mask of RCB10 field.
	MATRIX_MRCR_RCB10_Msk = 0x400
	// Bit RCB10.
	MATRIX_MRCR_RCB10 = 0x400
	// Position of RCB11 field.
	MATRIX_MRCR_RCB11_Pos = 0xb
	// Bit mask of RCB11 field.
	MATRIX_MRCR_RCB11_Msk = 0x800
	// Bit RCB11.
	MATRIX_MRCR_RCB11 = 0x800
	// Position of RCB12 field.
	MATRIX_MRCR_RCB12_Pos = 0xc
	// Bit mask of RCB12 field.
	MATRIX_MRCR_RCB12_Msk = 0x1000
	// Bit RCB12.
	MATRIX_MRCR_RCB12 = 0x1000
	// Position of RCB13 field.
	MATRIX_MRCR_RCB13_Pos = 0xd
	// Bit mask of RCB13 field.
	MATRIX_MRCR_RCB13_Msk = 0x2000
	// Bit RCB13.
	MATRIX_MRCR_RCB13 = 0x2000
	// Position of RCB14 field.
	MATRIX_MRCR_RCB14_Pos = 0xe
	// Bit mask of RCB14 field.
	MATRIX_MRCR_RCB14_Msk = 0x4000
	// Bit RCB14.
	MATRIX_MRCR_RCB14 = 0x4000
	// Position of RCB15 field.
	MATRIX_MRCR_RCB15_Pos = 0xf
	// Bit mask of RCB15 field.
	MATRIX_MRCR_RCB15_Msk = 0x8000
	// Bit RCB15.
	MATRIX_MRCR_RCB15 = 0x8000

	// SFR: Special Function Register
	// Position of SFR field.
	MATRIX_SFR_SFR_Pos = 0x0
	// Bit mask of SFR field.
	MATRIX_SFR_SFR_Msk = 0xffffffff

	// WPMR: Write Protect Mode Register
	// Position of WPEN field.
	MATRIX_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	MATRIX_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	MATRIX_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	MATRIX_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	MATRIX_WPMR_WPKEY_Msk = 0xffffff00

	// WPSR: Write Protect Status Register
	// Position of WPVS field.
	MATRIX_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	MATRIX_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	MATRIX_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	MATRIX_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	MATRIX_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for DBGU: Debug Unit
const (
	// CR: Control Register
	// Position of RSTRX field.
	DBGU_CR_RSTRX_Pos = 0x2
	// Bit mask of RSTRX field.
	DBGU_CR_RSTRX_Msk = 0x4
	// Bit RSTRX.
	DBGU_CR_RSTRX = 0x4
	// Position of RSTTX field.
	DBGU_CR_RSTTX_Pos = 0x3
	// Bit mask of RSTTX field.
	DBGU_CR_RSTTX_Msk = 0x8
	// Bit RSTTX.
	DBGU_CR_RSTTX = 0x8
	// Position of RXEN field.
	DBGU_CR_RXEN_Pos = 0x4
	// Bit mask of RXEN field.
	DBGU_CR_RXEN_Msk = 0x10
	// Bit RXEN.
	DBGU_CR_RXEN = 0x10
	// Position of RXDIS field.
	DBGU_CR_RXDIS_Pos = 0x5
	// Bit mask of RXDIS field.
	DBGU_CR_RXDIS_Msk = 0x20
	// Bit RXDIS.
	DBGU_CR_RXDIS = 0x20
	// Position of TXEN field.
	DBGU_CR_TXEN_Pos = 0x6
	// Bit mask of TXEN field.
	DBGU_CR_TXEN_Msk = 0x40
	// Bit TXEN.
	DBGU_CR_TXEN = 0x40
	// Position of TXDIS field.
	DBGU_CR_TXDIS_Pos = 0x7
	// Bit mask of TXDIS field.
	DBGU_CR_TXDIS_Msk = 0x80
	// Bit TXDIS.
	DBGU_CR_TXDIS = 0x80
	// Position of RSTSTA field.
	DBGU_CR_RSTSTA_Pos = 0x8
	// Bit mask of RSTSTA field.
	DBGU_CR_RSTSTA_Msk = 0x100
	// Bit RSTSTA.
	DBGU_CR_RSTSTA = 0x100

	// MR: Mode Register
	// Position of PAR field.
	DBGU_MR_PAR_Pos = 0x9
	// Bit mask of PAR field.
	DBGU_MR_PAR_Msk = 0xe00
	// Even Parity
	DBGU_MR_PAR_EVEN = 0x0
	// Odd Parity
	DBGU_MR_PAR_ODD = 0x1
	// Space: Parity forced to 0
	DBGU_MR_PAR_SPACE = 0x2
	// Mark: Parity forced to 1
	DBGU_MR_PAR_MARK = 0x3
	// No Parity
	DBGU_MR_PAR_NONE = 0x4
	// Position of CHMODE field.
	DBGU_MR_CHMODE_Pos = 0xe
	// Bit mask of CHMODE field.
	DBGU_MR_CHMODE_Msk = 0xc000
	// Normal Mode
	DBGU_MR_CHMODE_NORM = 0x0
	// Automatic Echo
	DBGU_MR_CHMODE_AUTO = 0x1
	// Local Loopback
	DBGU_MR_CHMODE_LOCLOOP = 0x2
	// Remote Loopback
	DBGU_MR_CHMODE_REMLOOP = 0x3

	// IER: Interrupt Enable Register
	// Position of RXRDY field.
	DBGU_IER_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	DBGU_IER_RXRDY_Msk = 0x1
	// Bit RXRDY.
	DBGU_IER_RXRDY = 0x1
	// Position of TXRDY field.
	DBGU_IER_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	DBGU_IER_TXRDY_Msk = 0x2
	// Bit TXRDY.
	DBGU_IER_TXRDY = 0x2
	// Position of OVRE field.
	DBGU_IER_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	DBGU_IER_OVRE_Msk = 0x20
	// Bit OVRE.
	DBGU_IER_OVRE = 0x20
	// Position of FRAME field.
	DBGU_IER_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	DBGU_IER_FRAME_Msk = 0x40
	// Bit FRAME.
	DBGU_IER_FRAME = 0x40
	// Position of PARE field.
	DBGU_IER_PARE_Pos = 0x7
	// Bit mask of PARE field.
	DBGU_IER_PARE_Msk = 0x80
	// Bit PARE.
	DBGU_IER_PARE = 0x80
	// Position of TXEMPTY field.
	DBGU_IER_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	DBGU_IER_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	DBGU_IER_TXEMPTY = 0x200
	// Position of COMMTX field.
	DBGU_IER_COMMTX_Pos = 0x1e
	// Bit mask of COMMTX field.
	DBGU_IER_COMMTX_Msk = 0x40000000
	// Bit COMMTX.
	DBGU_IER_COMMTX = 0x40000000
	// Position of COMMRX field.
	DBGU_IER_COMMRX_Pos = 0x1f
	// Bit mask of COMMRX field.
	DBGU_IER_COMMRX_Msk = 0x80000000
	// Bit COMMRX.
	DBGU_IER_COMMRX = 0x80000000

	// IDR: Interrupt Disable Register
	// Position of RXRDY field.
	DBGU_IDR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	DBGU_IDR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	DBGU_IDR_RXRDY = 0x1
	// Position of TXRDY field.
	DBGU_IDR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	DBGU_IDR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	DBGU_IDR_TXRDY = 0x2
	// Position of OVRE field.
	DBGU_IDR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	DBGU_IDR_OVRE_Msk = 0x20
	// Bit OVRE.
	DBGU_IDR_OVRE = 0x20
	// Position of FRAME field.
	DBGU_IDR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	DBGU_IDR_FRAME_Msk = 0x40
	// Bit FRAME.
	DBGU_IDR_FRAME = 0x40
	// Position of PARE field.
	DBGU_IDR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	DBGU_IDR_PARE_Msk = 0x80
	// Bit PARE.
	DBGU_IDR_PARE = 0x80
	// Position of TXEMPTY field.
	DBGU_IDR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	DBGU_IDR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	DBGU_IDR_TXEMPTY = 0x200
	// Position of COMMTX field.
	DBGU_IDR_COMMTX_Pos = 0x1e
	// Bit mask of COMMTX field.
	DBGU_IDR_COMMTX_Msk = 0x40000000
	// Bit COMMTX.
	DBGU_IDR_COMMTX = 0x40000000
	// Position of COMMRX field.
	DBGU_IDR_COMMRX_Pos = 0x1f
	// Bit mask of COMMRX field.
	DBGU_IDR_COMMRX_Msk = 0x80000000
	// Bit COMMRX.
	DBGU_IDR_COMMRX = 0x80000000

	// IMR: Interrupt Mask Register
	// Position of RXRDY field.
	DBGU_IMR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	DBGU_IMR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	DBGU_IMR_RXRDY = 0x1
	// Position of TXRDY field.
	DBGU_IMR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	DBGU_IMR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	DBGU_IMR_TXRDY = 0x2
	// Position of OVRE field.
	DBGU_IMR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	DBGU_IMR_OVRE_Msk = 0x20
	// Bit OVRE.
	DBGU_IMR_OVRE = 0x20
	// Position of FRAME field.
	DBGU_IMR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	DBGU_IMR_FRAME_Msk = 0x40
	// Bit FRAME.
	DBGU_IMR_FRAME = 0x40
	// Position of PARE field.
	DBGU_IMR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	DBGU_IMR_PARE_Msk = 0x80
	// Bit PARE.
	DBGU_IMR_PARE = 0x80
	// Position of TXEMPTY field.
	DBGU_IMR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	DBGU_IMR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	DBGU_IMR_TXEMPTY = 0x200
	// Position of COMMTX field.
	DBGU_IMR_COMMTX_Pos = 0x1e
	// Bit mask of COMMTX field.
	DBGU_IMR_COMMTX_Msk = 0x40000000
	// Bit COMMTX.
	DBGU_IMR_COMMTX = 0x40000000
	// Position of COMMRX field.
	DBGU_IMR_COMMRX_Pos = 0x1f
	// Bit mask of COMMRX field.
	DBGU_IMR_COMMRX_Msk = 0x80000000
	// Bit COMMRX.
	DBGU_IMR_COMMRX = 0x80000000

	// SR: Status Register
	// Position of RXRDY field.
	DBGU_SR_RXRDY_Pos = 0x0
	// Bit mask of RXRDY field.
	DBGU_SR_RXRDY_Msk = 0x1
	// Bit RXRDY.
	DBGU_SR_RXRDY = 0x1
	// Position of TXRDY field.
	DBGU_SR_TXRDY_Pos = 0x1
	// Bit mask of TXRDY field.
	DBGU_SR_TXRDY_Msk = 0x2
	// Bit TXRDY.
	DBGU_SR_TXRDY = 0x2
	// Position of OVRE field.
	DBGU_SR_OVRE_Pos = 0x5
	// Bit mask of OVRE field.
	DBGU_SR_OVRE_Msk = 0x20
	// Bit OVRE.
	DBGU_SR_OVRE = 0x20
	// Position of FRAME field.
	DBGU_SR_FRAME_Pos = 0x6
	// Bit mask of FRAME field.
	DBGU_SR_FRAME_Msk = 0x40
	// Bit FRAME.
	DBGU_SR_FRAME = 0x40
	// Position of PARE field.
	DBGU_SR_PARE_Pos = 0x7
	// Bit mask of PARE field.
	DBGU_SR_PARE_Msk = 0x80
	// Bit PARE.
	DBGU_SR_PARE = 0x80
	// Position of TXEMPTY field.
	DBGU_SR_TXEMPTY_Pos = 0x9
	// Bit mask of TXEMPTY field.
	DBGU_SR_TXEMPTY_Msk = 0x200
	// Bit TXEMPTY.
	DBGU_SR_TXEMPTY = 0x200
	// Position of COMMTX field.
	DBGU_SR_COMMTX_Pos = 0x1e
	// Bit mask of COMMTX field.
	DBGU_SR_COMMTX_Msk = 0x40000000
	// Bit COMMTX.
	DBGU_SR_COMMTX = 0x40000000
	// Position of COMMRX field.
	DBGU_SR_COMMRX_Pos = 0x1f
	// Bit mask of COMMRX field.
	DBGU_SR_COMMRX_Msk = 0x80000000
	// Bit COMMRX.
	DBGU_SR_COMMRX = 0x80000000

	// RHR: Receive Holding Register
	// Position of RXCHR field.
	DBGU_RHR_RXCHR_Pos = 0x0
	// Bit mask of RXCHR field.
	DBGU_RHR_RXCHR_Msk = 0xff

	// THR: Transmit Holding Register
	// Position of TXCHR field.
	DBGU_THR_TXCHR_Pos = 0x0
	// Bit mask of TXCHR field.
	DBGU_THR_TXCHR_Msk = 0xff

	// BRGR: Baud Rate Generator Register
	// Position of CD field.
	DBGU_BRGR_CD_Pos = 0x0
	// Bit mask of CD field.
	DBGU_BRGR_CD_Msk = 0xffff
	// DBGU Disabled
	DBGU_BRGR_CD_DISABLED = 0x0
	// MCK
	DBGU_BRGR_CD_MCK = 0x1

	// CIDR: Chip ID Register
	// Position of VERSION field.
	DBGU_CIDR_VERSION_Pos = 0x0
	// Bit mask of VERSION field.
	DBGU_CIDR_VERSION_Msk = 0x1f
	// Position of EPROC field.
	DBGU_CIDR_EPROC_Pos = 0x5
	// Bit mask of EPROC field.
	DBGU_CIDR_EPROC_Msk = 0xe0
	// ARM946ES
	DBGU_CIDR_EPROC_ARM946ES = 0x1
	// ARM7TDMI
	DBGU_CIDR_EPROC_ARM7TDMI = 0x2
	// Cortex-M3
	DBGU_CIDR_EPROC_CM3 = 0x3
	// ARM920T
	DBGU_CIDR_EPROC_ARM920T = 0x4
	// ARM926EJS
	DBGU_CIDR_EPROC_ARM926EJS = 0x5
	// Cortex-A5
	DBGU_CIDR_EPROC_CA5 = 0x6
	// Position of NVPSIZ field.
	DBGU_CIDR_NVPSIZ_Pos = 0x8
	// Bit mask of NVPSIZ field.
	DBGU_CIDR_NVPSIZ_Msk = 0xf00
	// None
	DBGU_CIDR_NVPSIZ_NONE = 0x0
	// 8K bytes
	DBGU_CIDR_NVPSIZ_8K = 0x1
	// 16K bytes
	DBGU_CIDR_NVPSIZ_16K = 0x2
	// 32K bytes
	DBGU_CIDR_NVPSIZ_32K = 0x3
	// 64K bytes
	DBGU_CIDR_NVPSIZ_64K = 0x5
	// 128K bytes
	DBGU_CIDR_NVPSIZ_128K = 0x7
	// 256K bytes
	DBGU_CIDR_NVPSIZ_256K = 0x9
	// 512K bytes
	DBGU_CIDR_NVPSIZ_512K = 0xa
	// 1024K bytes
	DBGU_CIDR_NVPSIZ_1024K = 0xc
	// 2048K bytes
	DBGU_CIDR_NVPSIZ_2048K = 0xe
	// Position of NVPSIZ2 field.
	DBGU_CIDR_NVPSIZ2_Pos = 0xc
	// Bit mask of NVPSIZ2 field.
	DBGU_CIDR_NVPSIZ2_Msk = 0xf000
	// None
	DBGU_CIDR_NVPSIZ2_NONE = 0x0
	// 8K bytes
	DBGU_CIDR_NVPSIZ2_8K = 0x1
	// 16K bytes
	DBGU_CIDR_NVPSIZ2_16K = 0x2
	// 32K bytes
	DBGU_CIDR_NVPSIZ2_32K = 0x3
	// 64K bytes
	DBGU_CIDR_NVPSIZ2_64K = 0x5
	// 128K bytes
	DBGU_CIDR_NVPSIZ2_128K = 0x7
	// 256K bytes
	DBGU_CIDR_NVPSIZ2_256K = 0x9
	// 512K bytes
	DBGU_CIDR_NVPSIZ2_512K = 0xa
	// 1024K bytes
	DBGU_CIDR_NVPSIZ2_1024K = 0xc
	// 2048K bytes
	DBGU_CIDR_NVPSIZ2_2048K = 0xe
	// Position of SRAMSIZ field.
	DBGU_CIDR_SRAMSIZ_Pos = 0x10
	// Bit mask of SRAMSIZ field.
	DBGU_CIDR_SRAMSIZ_Msk = 0xf0000
	// 1K bytes
	DBGU_CIDR_SRAMSIZ_1K = 0x1
	// 2K bytes
	DBGU_CIDR_SRAMSIZ_2K = 0x2
	// 6K bytes
	DBGU_CIDR_SRAMSIZ_6K = 0x3
	// 112K bytes
	DBGU_CIDR_SRAMSIZ_112K = 0x4
	// 4K bytes
	DBGU_CIDR_SRAMSIZ_4K = 0x5
	// 80K bytes
	DBGU_CIDR_SRAMSIZ_80K = 0x6
	// 160K bytes
	DBGU_CIDR_SRAMSIZ_160K = 0x7
	// 8K bytes
	DBGU_CIDR_SRAMSIZ_8K = 0x8
	// 16K bytes
	DBGU_CIDR_SRAMSIZ_16K = 0x9
	// 32K bytes
	DBGU_CIDR_SRAMSIZ_32K = 0xa
	// 64K bytes
	DBGU_CIDR_SRAMSIZ_64K = 0xb
	// 128K bytes
	DBGU_CIDR_SRAMSIZ_128K = 0xc
	// 256K bytes
	DBGU_CIDR_SRAMSIZ_256K = 0xd
	// 96K bytes
	DBGU_CIDR_SRAMSIZ_96K = 0xe
	// 512K bytes
	DBGU_CIDR_SRAMSIZ_512K = 0xf
	// Position of ARCH field.
	DBGU_CIDR_ARCH_Pos = 0x14
	// Bit mask of ARCH field.
	DBGU_CIDR_ARCH_Msk = 0xff00000
	// AT91SAM9xx Series
	DBGU_CIDR_ARCH_AT91SAM9xx = 0x19
	// AT91SAM9XExx Series
	DBGU_CIDR_ARCH_AT91SAM9XExx = 0x29
	// AT91x34 Series
	DBGU_CIDR_ARCH_AT91x34 = 0x34
	// CAP7 Series
	DBGU_CIDR_ARCH_CAP7 = 0x37
	// CAP9 Series
	DBGU_CIDR_ARCH_CAP9 = 0x39
	// CAP11 Series
	DBGU_CIDR_ARCH_CAP11 = 0x3b
	// AT91x40 Series
	DBGU_CIDR_ARCH_AT91x40 = 0x40
	// AT91x42 Series
	DBGU_CIDR_ARCH_AT91x42 = 0x42
	// AT91x55 Series
	DBGU_CIDR_ARCH_AT91x55 = 0x55
	// AT91SAM7Axx Series
	DBGU_CIDR_ARCH_AT91SAM7Axx = 0x60
	// AT91SAM7AQxx Series
	DBGU_CIDR_ARCH_AT91SAM7AQxx = 0x61
	// AT91x63 Series
	DBGU_CIDR_ARCH_AT91x63 = 0x63
	// AT91SAM7Sxx Series
	DBGU_CIDR_ARCH_AT91SAM7Sxx = 0x70
	// AT91SAM7XCxx Series
	DBGU_CIDR_ARCH_AT91SAM7XCxx = 0x71
	// AT91SAM7SExx Series
	DBGU_CIDR_ARCH_AT91SAM7SExx = 0x72
	// AT91SAM7Lxx Series
	DBGU_CIDR_ARCH_AT91SAM7Lxx = 0x73
	// AT91SAM7Xxx Series
	DBGU_CIDR_ARCH_AT91SAM7Xxx = 0x75
	// AT91SAM7SLxx Series
	DBGU_CIDR_ARCH_AT91SAM7SLxx = 0x76
	// ATSAM3UxC Series (100-pin version)
	DBGU_CIDR_ARCH_ATSAM3UxC = 0x80
	// ATSAM3UxE Series (144-pin version)
	DBGU_CIDR_ARCH_ATSAM3UxE = 0x81
	// ATSAM3AxC Series (100-pin version)
	DBGU_CIDR_ARCH_ATSAM3AxC = 0x83
	// ATSAM3XxC Series (100-pin version)
	DBGU_CIDR_ARCH_ATSAM3XxC = 0x84
	// ATSAM3XxE Series (144-pin version)
	DBGU_CIDR_ARCH_ATSAM3XxE = 0x85
	// ATSAM3XxG Series (208/217-pin version)
	DBGU_CIDR_ARCH_ATSAM3XxG = 0x86
	// ATSAM3SxA Series (48-pin version)
	DBGU_CIDR_ARCH_ATSAM3SxA = 0x88
	// ATSAM3SxB Series (64-pin version)
	DBGU_CIDR_ARCH_ATSAM3SxB = 0x89
	// ATSAM3SxC Series (100-pin version)
	DBGU_CIDR_ARCH_ATSAM3SxC = 0x8a
	// AT91x92 Series
	DBGU_CIDR_ARCH_AT91x92 = 0x92
	// ATSAM3NxA Series (48-pin version)
	DBGU_CIDR_ARCH_ATSAM3NxA = 0x93
	// ATSAM3NxB Series (64-pin version)
	DBGU_CIDR_ARCH_ATSAM3NxB = 0x94
	// ATSAM3NxC Series (100-pin version)
	DBGU_CIDR_ARCH_ATSAM3NxC = 0x95
	// ATSAM3SDxA Series (48-pin version)
	DBGU_CIDR_ARCH_ATSAM3SDxA = 0x98
	// ATSAM3SDxB Series (64-pin version)
	DBGU_CIDR_ARCH_ATSAM3SDxB = 0x99
	// ATSAM3SDxC Series (100-pin version)
	DBGU_CIDR_ARCH_ATSAM3SDxC = 0x9a
	// AT75Cxx Series
	DBGU_CIDR_ARCH_AT75Cxx = 0xf0
	// Position of NVPTYP field.
	DBGU_CIDR_NVPTYP_Pos = 0x1c
	// Bit mask of NVPTYP field.
	DBGU_CIDR_NVPTYP_Msk = 0x70000000
	// ROM
	DBGU_CIDR_NVPTYP_ROM = 0x0
	// ROMless or on-chip Flash
	DBGU_CIDR_NVPTYP_ROMLESS = 0x1
	// Embedded Flash Memory
	DBGU_CIDR_NVPTYP_FLASH = 0x2
	// ROM and Embedded Flash MemoryNVPSIZ is ROM size NVPSIZ2 is Flash size
	DBGU_CIDR_NVPTYP_ROM_FLASH = 0x3
	// SRAM emulating ROM
	DBGU_CIDR_NVPTYP_SRAM = 0x4
	// Position of EXT field.
	DBGU_CIDR_EXT_Pos = 0x1f
	// Bit mask of EXT field.
	DBGU_CIDR_EXT_Msk = 0x80000000
	// Bit EXT.
	DBGU_CIDR_EXT = 0x80000000

	// EXID: Chip ID Extension Register
	// Position of EXID field.
	DBGU_EXID_EXID_Pos = 0x0
	// Bit mask of EXID field.
	DBGU_EXID_EXID_Msk = 0xffffffff

	// FNR: Force NTRST Register
	// Position of FNTRST field.
	DBGU_FNR_FNTRST_Pos = 0x0
	// Bit mask of FNTRST field.
	DBGU_FNR_FNTRST_Msk = 0x1
	// Bit FNTRST.
	DBGU_FNR_FNTRST = 0x1
)

// Constants for AIC: Advanced Interrupt Controller
const (
	// SSR: Source Select Register
	// Position of INTSEL field.
	AIC_SSR_INTSEL_Pos = 0x0
	// Bit mask of INTSEL field.
	AIC_SSR_INTSEL_Msk = 0x7f

	// SMR: Source Mode Register
	// Position of PRIOR field.
	AIC_SMR_PRIOR_Pos = 0x0
	// Bit mask of PRIOR field.
	AIC_SMR_PRIOR_Msk = 0x7
	// Position of SRCTYPE field.
	AIC_SMR_SRCTYPE_Pos = 0x5
	// Bit mask of SRCTYPE field.
	AIC_SMR_SRCTYPE_Msk = 0x60
	// High level Sensitive for internal sourceLow level Sensitive for external source
	AIC_SMR_SRCTYPE_INT_LEVEL_SENSITIVE = 0x0
	// Positive edge triggered for internal sourceNegative edge triggered for external source
	AIC_SMR_SRCTYPE_INT_EDGE_TRIGGERED = 0x1
	// High level Sensitive for internal sourceHigh level Sensitive for external source
	AIC_SMR_SRCTYPE_EXT_HIGH_LEVEL = 0x2
	// Positive edge triggered for internal sourcePositive edge triggered for external source
	AIC_SMR_SRCTYPE_EXT_POSITIVE_EDGE = 0x3

	// SVR: Source Vector Register
	// Position of VECTOR field.
	AIC_SVR_VECTOR_Pos = 0x0
	// Bit mask of VECTOR field.
	AIC_SVR_VECTOR_Msk = 0xffffffff

	// IVR: Interrupt Vector Register
	// Position of IRQV field.
	AIC_IVR_IRQV_Pos = 0x0
	// Bit mask of IRQV field.
	AIC_IVR_IRQV_Msk = 0xffffffff

	// FVR: FIQ Interrupt Vector Register
	// Position of FIQV field.
	AIC_FVR_FIQV_Pos = 0x0
	// Bit mask of FIQV field.
	AIC_FVR_FIQV_Msk = 0xffffffff

	// ISR: Interrupt Status Register
	// Position of IRQID field.
	AIC_ISR_IRQID_Pos = 0x0
	// Bit mask of IRQID field.
	AIC_ISR_IRQID_Msk = 0x7f

	// IPR0: Interrupt Pending Register 0
	// Position of FIQ field.
	AIC_IPR0_FIQ_Pos = 0x0
	// Bit mask of FIQ field.
	AIC_IPR0_FIQ_Msk = 0x1
	// Bit FIQ.
	AIC_IPR0_FIQ = 0x1
	// Position of SYS field.
	AIC_IPR0_SYS_Pos = 0x1
	// Bit mask of SYS field.
	AIC_IPR0_SYS_Msk = 0x2
	// Bit SYS.
	AIC_IPR0_SYS = 0x2
	// Position of PID2 field.
	AIC_IPR0_PID2_Pos = 0x2
	// Bit mask of PID2 field.
	AIC_IPR0_PID2_Msk = 0x4
	// Bit PID2.
	AIC_IPR0_PID2 = 0x4
	// Position of PID3 field.
	AIC_IPR0_PID3_Pos = 0x3
	// Bit mask of PID3 field.
	AIC_IPR0_PID3_Msk = 0x8
	// Bit PID3.
	AIC_IPR0_PID3 = 0x8
	// Position of PID4 field.
	AIC_IPR0_PID4_Pos = 0x4
	// Bit mask of PID4 field.
	AIC_IPR0_PID4_Msk = 0x10
	// Bit PID4.
	AIC_IPR0_PID4 = 0x10
	// Position of PID5 field.
	AIC_IPR0_PID5_Pos = 0x5
	// Bit mask of PID5 field.
	AIC_IPR0_PID5_Msk = 0x20
	// Bit PID5.
	AIC_IPR0_PID5 = 0x20
	// Position of PID6 field.
	AIC_IPR0_PID6_Pos = 0x6
	// Bit mask of PID6 field.
	AIC_IPR0_PID6_Msk = 0x40
	// Bit PID6.
	AIC_IPR0_PID6 = 0x40
	// Position of PID7 field.
	AIC_IPR0_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	AIC_IPR0_PID7_Msk = 0x80
	// Bit PID7.
	AIC_IPR0_PID7 = 0x80
	// Position of PID8 field.
	AIC_IPR0_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	AIC_IPR0_PID8_Msk = 0x100
	// Bit PID8.
	AIC_IPR0_PID8 = 0x100
	// Position of PID9 field.
	AIC_IPR0_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	AIC_IPR0_PID9_Msk = 0x200
	// Bit PID9.
	AIC_IPR0_PID9 = 0x200
	// Position of PID10 field.
	AIC_IPR0_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	AIC_IPR0_PID10_Msk = 0x400
	// Bit PID10.
	AIC_IPR0_PID10 = 0x400
	// Position of PID11 field.
	AIC_IPR0_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	AIC_IPR0_PID11_Msk = 0x800
	// Bit PID11.
	AIC_IPR0_PID11 = 0x800
	// Position of PID12 field.
	AIC_IPR0_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	AIC_IPR0_PID12_Msk = 0x1000
	// Bit PID12.
	AIC_IPR0_PID12 = 0x1000
	// Position of PID13 field.
	AIC_IPR0_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	AIC_IPR0_PID13_Msk = 0x2000
	// Bit PID13.
	AIC_IPR0_PID13 = 0x2000
	// Position of PID14 field.
	AIC_IPR0_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	AIC_IPR0_PID14_Msk = 0x4000
	// Bit PID14.
	AIC_IPR0_PID14 = 0x4000
	// Position of PID15 field.
	AIC_IPR0_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	AIC_IPR0_PID15_Msk = 0x8000
	// Bit PID15.
	AIC_IPR0_PID15 = 0x8000
	// Position of PID16 field.
	AIC_IPR0_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	AIC_IPR0_PID16_Msk = 0x10000
	// Bit PID16.
	AIC_IPR0_PID16 = 0x10000
	// Position of PID17 field.
	AIC_IPR0_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	AIC_IPR0_PID17_Msk = 0x20000
	// Bit PID17.
	AIC_IPR0_PID17 = 0x20000
	// Position of PID18 field.
	AIC_IPR0_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	AIC_IPR0_PID18_Msk = 0x40000
	// Bit PID18.
	AIC_IPR0_PID18 = 0x40000
	// Position of PID19 field.
	AIC_IPR0_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	AIC_IPR0_PID19_Msk = 0x80000
	// Bit PID19.
	AIC_IPR0_PID19 = 0x80000
	// Position of PID20 field.
	AIC_IPR0_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	AIC_IPR0_PID20_Msk = 0x100000
	// Bit PID20.
	AIC_IPR0_PID20 = 0x100000
	// Position of PID21 field.
	AIC_IPR0_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	AIC_IPR0_PID21_Msk = 0x200000
	// Bit PID21.
	AIC_IPR0_PID21 = 0x200000
	// Position of PID22 field.
	AIC_IPR0_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	AIC_IPR0_PID22_Msk = 0x400000
	// Bit PID22.
	AIC_IPR0_PID22 = 0x400000
	// Position of PID23 field.
	AIC_IPR0_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	AIC_IPR0_PID23_Msk = 0x800000
	// Bit PID23.
	AIC_IPR0_PID23 = 0x800000
	// Position of PID24 field.
	AIC_IPR0_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	AIC_IPR0_PID24_Msk = 0x1000000
	// Bit PID24.
	AIC_IPR0_PID24 = 0x1000000
	// Position of PID25 field.
	AIC_IPR0_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	AIC_IPR0_PID25_Msk = 0x2000000
	// Bit PID25.
	AIC_IPR0_PID25 = 0x2000000
	// Position of PID26 field.
	AIC_IPR0_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	AIC_IPR0_PID26_Msk = 0x4000000
	// Bit PID26.
	AIC_IPR0_PID26 = 0x4000000
	// Position of PID27 field.
	AIC_IPR0_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	AIC_IPR0_PID27_Msk = 0x8000000
	// Bit PID27.
	AIC_IPR0_PID27 = 0x8000000
	// Position of PID28 field.
	AIC_IPR0_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	AIC_IPR0_PID28_Msk = 0x10000000
	// Bit PID28.
	AIC_IPR0_PID28 = 0x10000000
	// Position of PID29 field.
	AIC_IPR0_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	AIC_IPR0_PID29_Msk = 0x20000000
	// Bit PID29.
	AIC_IPR0_PID29 = 0x20000000
	// Position of PID30 field.
	AIC_IPR0_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	AIC_IPR0_PID30_Msk = 0x40000000
	// Bit PID30.
	AIC_IPR0_PID30 = 0x40000000
	// Position of PID31 field.
	AIC_IPR0_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	AIC_IPR0_PID31_Msk = 0x80000000
	// Bit PID31.
	AIC_IPR0_PID31 = 0x80000000

	// IPR1: Interrupt Pending Register 1
	// Position of PID32 field.
	AIC_IPR1_PID32_Pos = 0x0
	// Bit mask of PID32 field.
	AIC_IPR1_PID32_Msk = 0x1
	// Bit PID32.
	AIC_IPR1_PID32 = 0x1
	// Position of PID33 field.
	AIC_IPR1_PID33_Pos = 0x1
	// Bit mask of PID33 field.
	AIC_IPR1_PID33_Msk = 0x2
	// Bit PID33.
	AIC_IPR1_PID33 = 0x2
	// Position of PID34 field.
	AIC_IPR1_PID34_Pos = 0x2
	// Bit mask of PID34 field.
	AIC_IPR1_PID34_Msk = 0x4
	// Bit PID34.
	AIC_IPR1_PID34 = 0x4
	// Position of PID35 field.
	AIC_IPR1_PID35_Pos = 0x3
	// Bit mask of PID35 field.
	AIC_IPR1_PID35_Msk = 0x8
	// Bit PID35.
	AIC_IPR1_PID35 = 0x8
	// Position of PID36 field.
	AIC_IPR1_PID36_Pos = 0x4
	// Bit mask of PID36 field.
	AIC_IPR1_PID36_Msk = 0x10
	// Bit PID36.
	AIC_IPR1_PID36 = 0x10
	// Position of PID37 field.
	AIC_IPR1_PID37_Pos = 0x5
	// Bit mask of PID37 field.
	AIC_IPR1_PID37_Msk = 0x20
	// Bit PID37.
	AIC_IPR1_PID37 = 0x20
	// Position of PID38 field.
	AIC_IPR1_PID38_Pos = 0x6
	// Bit mask of PID38 field.
	AIC_IPR1_PID38_Msk = 0x40
	// Bit PID38.
	AIC_IPR1_PID38 = 0x40
	// Position of PID39 field.
	AIC_IPR1_PID39_Pos = 0x7
	// Bit mask of PID39 field.
	AIC_IPR1_PID39_Msk = 0x80
	// Bit PID39.
	AIC_IPR1_PID39 = 0x80
	// Position of PID40 field.
	AIC_IPR1_PID40_Pos = 0x8
	// Bit mask of PID40 field.
	AIC_IPR1_PID40_Msk = 0x100
	// Bit PID40.
	AIC_IPR1_PID40 = 0x100
	// Position of PID41 field.
	AIC_IPR1_PID41_Pos = 0x9
	// Bit mask of PID41 field.
	AIC_IPR1_PID41_Msk = 0x200
	// Bit PID41.
	AIC_IPR1_PID41 = 0x200
	// Position of PID42 field.
	AIC_IPR1_PID42_Pos = 0xa
	// Bit mask of PID42 field.
	AIC_IPR1_PID42_Msk = 0x400
	// Bit PID42.
	AIC_IPR1_PID42 = 0x400
	// Position of PID43 field.
	AIC_IPR1_PID43_Pos = 0xb
	// Bit mask of PID43 field.
	AIC_IPR1_PID43_Msk = 0x800
	// Bit PID43.
	AIC_IPR1_PID43 = 0x800
	// Position of PID44 field.
	AIC_IPR1_PID44_Pos = 0xc
	// Bit mask of PID44 field.
	AIC_IPR1_PID44_Msk = 0x1000
	// Bit PID44.
	AIC_IPR1_PID44 = 0x1000
	// Position of PID45 field.
	AIC_IPR1_PID45_Pos = 0xd
	// Bit mask of PID45 field.
	AIC_IPR1_PID45_Msk = 0x2000
	// Bit PID45.
	AIC_IPR1_PID45 = 0x2000
	// Position of PID46 field.
	AIC_IPR1_PID46_Pos = 0xe
	// Bit mask of PID46 field.
	AIC_IPR1_PID46_Msk = 0x4000
	// Bit PID46.
	AIC_IPR1_PID46 = 0x4000
	// Position of PID47 field.
	AIC_IPR1_PID47_Pos = 0xf
	// Bit mask of PID47 field.
	AIC_IPR1_PID47_Msk = 0x8000
	// Bit PID47.
	AIC_IPR1_PID47 = 0x8000
	// Position of PID48 field.
	AIC_IPR1_PID48_Pos = 0x10
	// Bit mask of PID48 field.
	AIC_IPR1_PID48_Msk = 0x10000
	// Bit PID48.
	AIC_IPR1_PID48 = 0x10000
	// Position of PID49 field.
	AIC_IPR1_PID49_Pos = 0x11
	// Bit mask of PID49 field.
	AIC_IPR1_PID49_Msk = 0x20000
	// Bit PID49.
	AIC_IPR1_PID49 = 0x20000
	// Position of PID50 field.
	AIC_IPR1_PID50_Pos = 0x12
	// Bit mask of PID50 field.
	AIC_IPR1_PID50_Msk = 0x40000
	// Bit PID50.
	AIC_IPR1_PID50 = 0x40000
	// Position of PID51 field.
	AIC_IPR1_PID51_Pos = 0x13
	// Bit mask of PID51 field.
	AIC_IPR1_PID51_Msk = 0x80000
	// Bit PID51.
	AIC_IPR1_PID51 = 0x80000
	// Position of PID52 field.
	AIC_IPR1_PID52_Pos = 0x14
	// Bit mask of PID52 field.
	AIC_IPR1_PID52_Msk = 0x100000
	// Bit PID52.
	AIC_IPR1_PID52 = 0x100000
	// Position of PID53 field.
	AIC_IPR1_PID53_Pos = 0x15
	// Bit mask of PID53 field.
	AIC_IPR1_PID53_Msk = 0x200000
	// Bit PID53.
	AIC_IPR1_PID53 = 0x200000
	// Position of PID54 field.
	AIC_IPR1_PID54_Pos = 0x16
	// Bit mask of PID54 field.
	AIC_IPR1_PID54_Msk = 0x400000
	// Bit PID54.
	AIC_IPR1_PID54 = 0x400000
	// Position of PID55 field.
	AIC_IPR1_PID55_Pos = 0x17
	// Bit mask of PID55 field.
	AIC_IPR1_PID55_Msk = 0x800000
	// Bit PID55.
	AIC_IPR1_PID55 = 0x800000
	// Position of PID56 field.
	AIC_IPR1_PID56_Pos = 0x18
	// Bit mask of PID56 field.
	AIC_IPR1_PID56_Msk = 0x1000000
	// Bit PID56.
	AIC_IPR1_PID56 = 0x1000000
	// Position of PID57 field.
	AIC_IPR1_PID57_Pos = 0x19
	// Bit mask of PID57 field.
	AIC_IPR1_PID57_Msk = 0x2000000
	// Bit PID57.
	AIC_IPR1_PID57 = 0x2000000
	// Position of PID58 field.
	AIC_IPR1_PID58_Pos = 0x1a
	// Bit mask of PID58 field.
	AIC_IPR1_PID58_Msk = 0x4000000
	// Bit PID58.
	AIC_IPR1_PID58 = 0x4000000
	// Position of PID59 field.
	AIC_IPR1_PID59_Pos = 0x1b
	// Bit mask of PID59 field.
	AIC_IPR1_PID59_Msk = 0x8000000
	// Bit PID59.
	AIC_IPR1_PID59 = 0x8000000
	// Position of PID60 field.
	AIC_IPR1_PID60_Pos = 0x1c
	// Bit mask of PID60 field.
	AIC_IPR1_PID60_Msk = 0x10000000
	// Bit PID60.
	AIC_IPR1_PID60 = 0x10000000
	// Position of PID61 field.
	AIC_IPR1_PID61_Pos = 0x1d
	// Bit mask of PID61 field.
	AIC_IPR1_PID61_Msk = 0x20000000
	// Bit PID61.
	AIC_IPR1_PID61 = 0x20000000
	// Position of PID62 field.
	AIC_IPR1_PID62_Pos = 0x1e
	// Bit mask of PID62 field.
	AIC_IPR1_PID62_Msk = 0x40000000
	// Bit PID62.
	AIC_IPR1_PID62 = 0x40000000
	// Position of PID63 field.
	AIC_IPR1_PID63_Pos = 0x1f
	// Bit mask of PID63 field.
	AIC_IPR1_PID63_Msk = 0x80000000
	// Bit PID63.
	AIC_IPR1_PID63 = 0x80000000

	// IPR2: Interrupt Pending Register 2
	// Position of PID64 field.
	AIC_IPR2_PID64_Pos = 0x0
	// Bit mask of PID64 field.
	AIC_IPR2_PID64_Msk = 0x1
	// Bit PID64.
	AIC_IPR2_PID64 = 0x1
	// Position of PID65 field.
	AIC_IPR2_PID65_Pos = 0x1
	// Bit mask of PID65 field.
	AIC_IPR2_PID65_Msk = 0x2
	// Bit PID65.
	AIC_IPR2_PID65 = 0x2
	// Position of PID66 field.
	AIC_IPR2_PID66_Pos = 0x2
	// Bit mask of PID66 field.
	AIC_IPR2_PID66_Msk = 0x4
	// Bit PID66.
	AIC_IPR2_PID66 = 0x4
	// Position of PID67 field.
	AIC_IPR2_PID67_Pos = 0x3
	// Bit mask of PID67 field.
	AIC_IPR2_PID67_Msk = 0x8
	// Bit PID67.
	AIC_IPR2_PID67 = 0x8
	// Position of PID68 field.
	AIC_IPR2_PID68_Pos = 0x4
	// Bit mask of PID68 field.
	AIC_IPR2_PID68_Msk = 0x10
	// Bit PID68.
	AIC_IPR2_PID68 = 0x10
	// Position of PID69 field.
	AIC_IPR2_PID69_Pos = 0x5
	// Bit mask of PID69 field.
	AIC_IPR2_PID69_Msk = 0x20
	// Bit PID69.
	AIC_IPR2_PID69 = 0x20
	// Position of PID70 field.
	AIC_IPR2_PID70_Pos = 0x6
	// Bit mask of PID70 field.
	AIC_IPR2_PID70_Msk = 0x40
	// Bit PID70.
	AIC_IPR2_PID70 = 0x40
	// Position of PID71 field.
	AIC_IPR2_PID71_Pos = 0x7
	// Bit mask of PID71 field.
	AIC_IPR2_PID71_Msk = 0x80
	// Bit PID71.
	AIC_IPR2_PID71 = 0x80
	// Position of PID72 field.
	AIC_IPR2_PID72_Pos = 0x8
	// Bit mask of PID72 field.
	AIC_IPR2_PID72_Msk = 0x100
	// Bit PID72.
	AIC_IPR2_PID72 = 0x100
	// Position of PID73 field.
	AIC_IPR2_PID73_Pos = 0x9
	// Bit mask of PID73 field.
	AIC_IPR2_PID73_Msk = 0x200
	// Bit PID73.
	AIC_IPR2_PID73 = 0x200
	// Position of PID74 field.
	AIC_IPR2_PID74_Pos = 0xa
	// Bit mask of PID74 field.
	AIC_IPR2_PID74_Msk = 0x400
	// Bit PID74.
	AIC_IPR2_PID74 = 0x400
	// Position of PID75 field.
	AIC_IPR2_PID75_Pos = 0xb
	// Bit mask of PID75 field.
	AIC_IPR2_PID75_Msk = 0x800
	// Bit PID75.
	AIC_IPR2_PID75 = 0x800
	// Position of PID76 field.
	AIC_IPR2_PID76_Pos = 0xc
	// Bit mask of PID76 field.
	AIC_IPR2_PID76_Msk = 0x1000
	// Bit PID76.
	AIC_IPR2_PID76 = 0x1000
	// Position of PID77 field.
	AIC_IPR2_PID77_Pos = 0xd
	// Bit mask of PID77 field.
	AIC_IPR2_PID77_Msk = 0x2000
	// Bit PID77.
	AIC_IPR2_PID77 = 0x2000
	// Position of PID78 field.
	AIC_IPR2_PID78_Pos = 0xe
	// Bit mask of PID78 field.
	AIC_IPR2_PID78_Msk = 0x4000
	// Bit PID78.
	AIC_IPR2_PID78 = 0x4000
	// Position of PID79 field.
	AIC_IPR2_PID79_Pos = 0xf
	// Bit mask of PID79 field.
	AIC_IPR2_PID79_Msk = 0x8000
	// Bit PID79.
	AIC_IPR2_PID79 = 0x8000
	// Position of PID80 field.
	AIC_IPR2_PID80_Pos = 0x10
	// Bit mask of PID80 field.
	AIC_IPR2_PID80_Msk = 0x10000
	// Bit PID80.
	AIC_IPR2_PID80 = 0x10000
	// Position of PID81 field.
	AIC_IPR2_PID81_Pos = 0x11
	// Bit mask of PID81 field.
	AIC_IPR2_PID81_Msk = 0x20000
	// Bit PID81.
	AIC_IPR2_PID81 = 0x20000
	// Position of PID82 field.
	AIC_IPR2_PID82_Pos = 0x12
	// Bit mask of PID82 field.
	AIC_IPR2_PID82_Msk = 0x40000
	// Bit PID82.
	AIC_IPR2_PID82 = 0x40000
	// Position of PID83 field.
	AIC_IPR2_PID83_Pos = 0x13
	// Bit mask of PID83 field.
	AIC_IPR2_PID83_Msk = 0x80000
	// Bit PID83.
	AIC_IPR2_PID83 = 0x80000
	// Position of PID84 field.
	AIC_IPR2_PID84_Pos = 0x14
	// Bit mask of PID84 field.
	AIC_IPR2_PID84_Msk = 0x100000
	// Bit PID84.
	AIC_IPR2_PID84 = 0x100000
	// Position of PID85 field.
	AIC_IPR2_PID85_Pos = 0x15
	// Bit mask of PID85 field.
	AIC_IPR2_PID85_Msk = 0x200000
	// Bit PID85.
	AIC_IPR2_PID85 = 0x200000
	// Position of PID86 field.
	AIC_IPR2_PID86_Pos = 0x16
	// Bit mask of PID86 field.
	AIC_IPR2_PID86_Msk = 0x400000
	// Bit PID86.
	AIC_IPR2_PID86 = 0x400000
	// Position of PID87 field.
	AIC_IPR2_PID87_Pos = 0x17
	// Bit mask of PID87 field.
	AIC_IPR2_PID87_Msk = 0x800000
	// Bit PID87.
	AIC_IPR2_PID87 = 0x800000
	// Position of PID88 field.
	AIC_IPR2_PID88_Pos = 0x18
	// Bit mask of PID88 field.
	AIC_IPR2_PID88_Msk = 0x1000000
	// Bit PID88.
	AIC_IPR2_PID88 = 0x1000000
	// Position of PID89 field.
	AIC_IPR2_PID89_Pos = 0x19
	// Bit mask of PID89 field.
	AIC_IPR2_PID89_Msk = 0x2000000
	// Bit PID89.
	AIC_IPR2_PID89 = 0x2000000
	// Position of PID90 field.
	AIC_IPR2_PID90_Pos = 0x1a
	// Bit mask of PID90 field.
	AIC_IPR2_PID90_Msk = 0x4000000
	// Bit PID90.
	AIC_IPR2_PID90 = 0x4000000
	// Position of PID91 field.
	AIC_IPR2_PID91_Pos = 0x1b
	// Bit mask of PID91 field.
	AIC_IPR2_PID91_Msk = 0x8000000
	// Bit PID91.
	AIC_IPR2_PID91 = 0x8000000
	// Position of PID92 field.
	AIC_IPR2_PID92_Pos = 0x1c
	// Bit mask of PID92 field.
	AIC_IPR2_PID92_Msk = 0x10000000
	// Bit PID92.
	AIC_IPR2_PID92 = 0x10000000
	// Position of PID93 field.
	AIC_IPR2_PID93_Pos = 0x1d
	// Bit mask of PID93 field.
	AIC_IPR2_PID93_Msk = 0x20000000
	// Bit PID93.
	AIC_IPR2_PID93 = 0x20000000
	// Position of PID94 field.
	AIC_IPR2_PID94_Pos = 0x1e
	// Bit mask of PID94 field.
	AIC_IPR2_PID94_Msk = 0x40000000
	// Bit PID94.
	AIC_IPR2_PID94 = 0x40000000
	// Position of PID95 field.
	AIC_IPR2_PID95_Pos = 0x1f
	// Bit mask of PID95 field.
	AIC_IPR2_PID95_Msk = 0x80000000
	// Bit PID95.
	AIC_IPR2_PID95 = 0x80000000

	// IPR3: Interrupt Pending Register 3
	// Position of PID96 field.
	AIC_IPR3_PID96_Pos = 0x0
	// Bit mask of PID96 field.
	AIC_IPR3_PID96_Msk = 0x1
	// Bit PID96.
	AIC_IPR3_PID96 = 0x1
	// Position of PID97 field.
	AIC_IPR3_PID97_Pos = 0x1
	// Bit mask of PID97 field.
	AIC_IPR3_PID97_Msk = 0x2
	// Bit PID97.
	AIC_IPR3_PID97 = 0x2
	// Position of PID98 field.
	AIC_IPR3_PID98_Pos = 0x2
	// Bit mask of PID98 field.
	AIC_IPR3_PID98_Msk = 0x4
	// Bit PID98.
	AIC_IPR3_PID98 = 0x4
	// Position of PID99 field.
	AIC_IPR3_PID99_Pos = 0x3
	// Bit mask of PID99 field.
	AIC_IPR3_PID99_Msk = 0x8
	// Bit PID99.
	AIC_IPR3_PID99 = 0x8
	// Position of PID100 field.
	AIC_IPR3_PID100_Pos = 0x4
	// Bit mask of PID100 field.
	AIC_IPR3_PID100_Msk = 0x10
	// Bit PID100.
	AIC_IPR3_PID100 = 0x10
	// Position of PID101 field.
	AIC_IPR3_PID101_Pos = 0x5
	// Bit mask of PID101 field.
	AIC_IPR3_PID101_Msk = 0x20
	// Bit PID101.
	AIC_IPR3_PID101 = 0x20
	// Position of PID102 field.
	AIC_IPR3_PID102_Pos = 0x6
	// Bit mask of PID102 field.
	AIC_IPR3_PID102_Msk = 0x40
	// Bit PID102.
	AIC_IPR3_PID102 = 0x40
	// Position of PID103 field.
	AIC_IPR3_PID103_Pos = 0x7
	// Bit mask of PID103 field.
	AIC_IPR3_PID103_Msk = 0x80
	// Bit PID103.
	AIC_IPR3_PID103 = 0x80
	// Position of PID104 field.
	AIC_IPR3_PID104_Pos = 0x8
	// Bit mask of PID104 field.
	AIC_IPR3_PID104_Msk = 0x100
	// Bit PID104.
	AIC_IPR3_PID104 = 0x100
	// Position of PID105 field.
	AIC_IPR3_PID105_Pos = 0x9
	// Bit mask of PID105 field.
	AIC_IPR3_PID105_Msk = 0x200
	// Bit PID105.
	AIC_IPR3_PID105 = 0x200
	// Position of PID106 field.
	AIC_IPR3_PID106_Pos = 0xa
	// Bit mask of PID106 field.
	AIC_IPR3_PID106_Msk = 0x400
	// Bit PID106.
	AIC_IPR3_PID106 = 0x400
	// Position of PID107 field.
	AIC_IPR3_PID107_Pos = 0xb
	// Bit mask of PID107 field.
	AIC_IPR3_PID107_Msk = 0x800
	// Bit PID107.
	AIC_IPR3_PID107 = 0x800
	// Position of PID108 field.
	AIC_IPR3_PID108_Pos = 0xc
	// Bit mask of PID108 field.
	AIC_IPR3_PID108_Msk = 0x1000
	// Bit PID108.
	AIC_IPR3_PID108 = 0x1000
	// Position of PID109 field.
	AIC_IPR3_PID109_Pos = 0xd
	// Bit mask of PID109 field.
	AIC_IPR3_PID109_Msk = 0x2000
	// Bit PID109.
	AIC_IPR3_PID109 = 0x2000
	// Position of PID110 field.
	AIC_IPR3_PID110_Pos = 0xe
	// Bit mask of PID110 field.
	AIC_IPR3_PID110_Msk = 0x4000
	// Bit PID110.
	AIC_IPR3_PID110 = 0x4000
	// Position of PID111 field.
	AIC_IPR3_PID111_Pos = 0xf
	// Bit mask of PID111 field.
	AIC_IPR3_PID111_Msk = 0x8000
	// Bit PID111.
	AIC_IPR3_PID111 = 0x8000
	// Position of PID112 field.
	AIC_IPR3_PID112_Pos = 0x10
	// Bit mask of PID112 field.
	AIC_IPR3_PID112_Msk = 0x10000
	// Bit PID112.
	AIC_IPR3_PID112 = 0x10000
	// Position of PID113 field.
	AIC_IPR3_PID113_Pos = 0x11
	// Bit mask of PID113 field.
	AIC_IPR3_PID113_Msk = 0x20000
	// Bit PID113.
	AIC_IPR3_PID113 = 0x20000
	// Position of PID114 field.
	AIC_IPR3_PID114_Pos = 0x12
	// Bit mask of PID114 field.
	AIC_IPR3_PID114_Msk = 0x40000
	// Bit PID114.
	AIC_IPR3_PID114 = 0x40000
	// Position of PID115 field.
	AIC_IPR3_PID115_Pos = 0x13
	// Bit mask of PID115 field.
	AIC_IPR3_PID115_Msk = 0x80000
	// Bit PID115.
	AIC_IPR3_PID115 = 0x80000
	// Position of PID116 field.
	AIC_IPR3_PID116_Pos = 0x14
	// Bit mask of PID116 field.
	AIC_IPR3_PID116_Msk = 0x100000
	// Bit PID116.
	AIC_IPR3_PID116 = 0x100000
	// Position of PID117 field.
	AIC_IPR3_PID117_Pos = 0x15
	// Bit mask of PID117 field.
	AIC_IPR3_PID117_Msk = 0x200000
	// Bit PID117.
	AIC_IPR3_PID117 = 0x200000
	// Position of PID118 field.
	AIC_IPR3_PID118_Pos = 0x16
	// Bit mask of PID118 field.
	AIC_IPR3_PID118_Msk = 0x400000
	// Bit PID118.
	AIC_IPR3_PID118 = 0x400000
	// Position of PID119 field.
	AIC_IPR3_PID119_Pos = 0x17
	// Bit mask of PID119 field.
	AIC_IPR3_PID119_Msk = 0x800000
	// Bit PID119.
	AIC_IPR3_PID119 = 0x800000
	// Position of PID120 field.
	AIC_IPR3_PID120_Pos = 0x18
	// Bit mask of PID120 field.
	AIC_IPR3_PID120_Msk = 0x1000000
	// Bit PID120.
	AIC_IPR3_PID120 = 0x1000000
	// Position of PID121 field.
	AIC_IPR3_PID121_Pos = 0x19
	// Bit mask of PID121 field.
	AIC_IPR3_PID121_Msk = 0x2000000
	// Bit PID121.
	AIC_IPR3_PID121 = 0x2000000
	// Position of PID122 field.
	AIC_IPR3_PID122_Pos = 0x1a
	// Bit mask of PID122 field.
	AIC_IPR3_PID122_Msk = 0x4000000
	// Bit PID122.
	AIC_IPR3_PID122 = 0x4000000
	// Position of PID123 field.
	AIC_IPR3_PID123_Pos = 0x1b
	// Bit mask of PID123 field.
	AIC_IPR3_PID123_Msk = 0x8000000
	// Bit PID123.
	AIC_IPR3_PID123 = 0x8000000
	// Position of PID124 field.
	AIC_IPR3_PID124_Pos = 0x1c
	// Bit mask of PID124 field.
	AIC_IPR3_PID124_Msk = 0x10000000
	// Bit PID124.
	AIC_IPR3_PID124 = 0x10000000
	// Position of PID125 field.
	AIC_IPR3_PID125_Pos = 0x1d
	// Bit mask of PID125 field.
	AIC_IPR3_PID125_Msk = 0x20000000
	// Bit PID125.
	AIC_IPR3_PID125 = 0x20000000
	// Position of PID126 field.
	AIC_IPR3_PID126_Pos = 0x1e
	// Bit mask of PID126 field.
	AIC_IPR3_PID126_Msk = 0x40000000
	// Bit PID126.
	AIC_IPR3_PID126 = 0x40000000
	// Position of PID127 field.
	AIC_IPR3_PID127_Pos = 0x1f
	// Bit mask of PID127 field.
	AIC_IPR3_PID127_Msk = 0x80000000
	// Bit PID127.
	AIC_IPR3_PID127 = 0x80000000

	// IMR: Interrupt Mask Register
	// Position of INTM field.
	AIC_IMR_INTM_Pos = 0x0
	// Bit mask of INTM field.
	AIC_IMR_INTM_Msk = 0x1
	// Bit INTM.
	AIC_IMR_INTM = 0x1

	// CISR: Core Interrupt Status Register
	// Position of NFIQ field.
	AIC_CISR_NFIQ_Pos = 0x0
	// Bit mask of NFIQ field.
	AIC_CISR_NFIQ_Msk = 0x1
	// Bit NFIQ.
	AIC_CISR_NFIQ = 0x1
	// Position of NIRQ field.
	AIC_CISR_NIRQ_Pos = 0x1
	// Bit mask of NIRQ field.
	AIC_CISR_NIRQ_Msk = 0x2
	// Bit NIRQ.
	AIC_CISR_NIRQ = 0x2

	// EOICR: End of Interrupt Command Register
	// Position of ENDIT field.
	AIC_EOICR_ENDIT_Pos = 0x0
	// Bit mask of ENDIT field.
	AIC_EOICR_ENDIT_Msk = 0x1
	// Bit ENDIT.
	AIC_EOICR_ENDIT = 0x1

	// SPU: Spurious Interrupt Vector Register
	// Position of SIVR field.
	AIC_SPU_SIVR_Pos = 0x0
	// Bit mask of SIVR field.
	AIC_SPU_SIVR_Msk = 0xffffffff

	// IECR: Interrupt Enable Command Register
	// Position of INTEN field.
	AIC_IECR_INTEN_Pos = 0x0
	// Bit mask of INTEN field.
	AIC_IECR_INTEN_Msk = 0x1
	// Bit INTEN.
	AIC_IECR_INTEN = 0x1

	// IDCR: Interrupt Disable Command Register
	// Position of INTD field.
	AIC_IDCR_INTD_Pos = 0x0
	// Bit mask of INTD field.
	AIC_IDCR_INTD_Msk = 0x1
	// Bit INTD.
	AIC_IDCR_INTD = 0x1

	// ICCR: Interrupt Clear Command Register
	// Position of INTCLR field.
	AIC_ICCR_INTCLR_Pos = 0x0
	// Bit mask of INTCLR field.
	AIC_ICCR_INTCLR_Msk = 0x1
	// Bit INTCLR.
	AIC_ICCR_INTCLR = 0x1

	// ISCR: Interrupt Set Command Register
	// Position of INTSET field.
	AIC_ISCR_INTSET_Pos = 0x0
	// Bit mask of INTSET field.
	AIC_ISCR_INTSET_Msk = 0x1
	// Bit INTSET.
	AIC_ISCR_INTSET = 0x1

	// FFER: Fast Forcing Enable Register
	// Position of FFEN field.
	AIC_FFER_FFEN_Pos = 0x0
	// Bit mask of FFEN field.
	AIC_FFER_FFEN_Msk = 0x1
	// Bit FFEN.
	AIC_FFER_FFEN = 0x1

	// FFDR: Fast Forcing Disable Register
	// Position of FFDIS field.
	AIC_FFDR_FFDIS_Pos = 0x0
	// Bit mask of FFDIS field.
	AIC_FFDR_FFDIS_Msk = 0x1
	// Bit FFDIS.
	AIC_FFDR_FFDIS = 0x1

	// FFSR: Fast Forcing Status Register
	// Position of FFS field.
	AIC_FFSR_FFS_Pos = 0x0
	// Bit mask of FFS field.
	AIC_FFSR_FFS_Msk = 0x1
	// Bit FFS.
	AIC_FFSR_FFS = 0x1

	// DCR: Debug Control Register
	// Position of PROT field.
	AIC_DCR_PROT_Pos = 0x0
	// Bit mask of PROT field.
	AIC_DCR_PROT_Msk = 0x1
	// Bit PROT.
	AIC_DCR_PROT = 0x1
	// Position of GMSK field.
	AIC_DCR_GMSK_Pos = 0x1
	// Bit mask of GMSK field.
	AIC_DCR_GMSK_Msk = 0x2
	// Bit GMSK.
	AIC_DCR_GMSK = 0x2

	// WPMR: Write Protect Mode Register
	// Position of WPEN field.
	AIC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	AIC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	AIC_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	AIC_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	AIC_WPMR_WPKEY_Msk = 0xffffff00

	// WPSR: Write Protect Status Register
	// Position of WPVS field.
	AIC_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	AIC_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	AIC_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	AIC_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	AIC_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for PIOA: Parallel Input/Output Controller A
const (
	// PER: PIO Enable Register
	// Position of P0 field.
	PIO_PER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PER_P0_Msk = 0x1
	// Bit P0.
	PIO_PER_P0 = 0x1
	// Position of P1 field.
	PIO_PER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PER_P1_Msk = 0x2
	// Bit P1.
	PIO_PER_P1 = 0x2
	// Position of P2 field.
	PIO_PER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PER_P2_Msk = 0x4
	// Bit P2.
	PIO_PER_P2 = 0x4
	// Position of P3 field.
	PIO_PER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PER_P3_Msk = 0x8
	// Bit P3.
	PIO_PER_P3 = 0x8
	// Position of P4 field.
	PIO_PER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PER_P4_Msk = 0x10
	// Bit P4.
	PIO_PER_P4 = 0x10
	// Position of P5 field.
	PIO_PER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PER_P5_Msk = 0x20
	// Bit P5.
	PIO_PER_P5 = 0x20
	// Position of P6 field.
	PIO_PER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PER_P6_Msk = 0x40
	// Bit P6.
	PIO_PER_P6 = 0x40
	// Position of P7 field.
	PIO_PER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PER_P7_Msk = 0x80
	// Bit P7.
	PIO_PER_P7 = 0x80
	// Position of P8 field.
	PIO_PER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PER_P8_Msk = 0x100
	// Bit P8.
	PIO_PER_P8 = 0x100
	// Position of P9 field.
	PIO_PER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PER_P9_Msk = 0x200
	// Bit P9.
	PIO_PER_P9 = 0x200
	// Position of P10 field.
	PIO_PER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PER_P10_Msk = 0x400
	// Bit P10.
	PIO_PER_P10 = 0x400
	// Position of P11 field.
	PIO_PER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PER_P11_Msk = 0x800
	// Bit P11.
	PIO_PER_P11 = 0x800
	// Position of P12 field.
	PIO_PER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PER_P12_Msk = 0x1000
	// Bit P12.
	PIO_PER_P12 = 0x1000
	// Position of P13 field.
	PIO_PER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PER_P13_Msk = 0x2000
	// Bit P13.
	PIO_PER_P13 = 0x2000
	// Position of P14 field.
	PIO_PER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PER_P14_Msk = 0x4000
	// Bit P14.
	PIO_PER_P14 = 0x4000
	// Position of P15 field.
	PIO_PER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PER_P15_Msk = 0x8000
	// Bit P15.
	PIO_PER_P15 = 0x8000
	// Position of P16 field.
	PIO_PER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PER_P16_Msk = 0x10000
	// Bit P16.
	PIO_PER_P16 = 0x10000
	// Position of P17 field.
	PIO_PER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PER_P17_Msk = 0x20000
	// Bit P17.
	PIO_PER_P17 = 0x20000
	// Position of P18 field.
	PIO_PER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PER_P18_Msk = 0x40000
	// Bit P18.
	PIO_PER_P18 = 0x40000
	// Position of P19 field.
	PIO_PER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PER_P19_Msk = 0x80000
	// Bit P19.
	PIO_PER_P19 = 0x80000
	// Position of P20 field.
	PIO_PER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PER_P20_Msk = 0x100000
	// Bit P20.
	PIO_PER_P20 = 0x100000
	// Position of P21 field.
	PIO_PER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PER_P21_Msk = 0x200000
	// Bit P21.
	PIO_PER_P21 = 0x200000
	// Position of P22 field.
	PIO_PER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PER_P22_Msk = 0x400000
	// Bit P22.
	PIO_PER_P22 = 0x400000
	// Position of P23 field.
	PIO_PER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PER_P23_Msk = 0x800000
	// Bit P23.
	PIO_PER_P23 = 0x800000
	// Position of P24 field.
	PIO_PER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PER_P24 = 0x1000000
	// Position of P25 field.
	PIO_PER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PER_P25 = 0x2000000
	// Position of P26 field.
	PIO_PER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PER_P26 = 0x4000000
	// Position of P27 field.
	PIO_PER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PER_P27 = 0x8000000
	// Position of P28 field.
	PIO_PER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PER_P28 = 0x10000000
	// Position of P29 field.
	PIO_PER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PER_P29 = 0x20000000
	// Position of P30 field.
	PIO_PER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PER_P30 = 0x40000000
	// Position of P31 field.
	PIO_PER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PER_P31 = 0x80000000

	// PDR: PIO Disable Register
	// Position of P0 field.
	PIO_PDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PDR_P0_Msk = 0x1
	// Bit P0.
	PIO_PDR_P0 = 0x1
	// Position of P1 field.
	PIO_PDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PDR_P1_Msk = 0x2
	// Bit P1.
	PIO_PDR_P1 = 0x2
	// Position of P2 field.
	PIO_PDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PDR_P2_Msk = 0x4
	// Bit P2.
	PIO_PDR_P2 = 0x4
	// Position of P3 field.
	PIO_PDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PDR_P3_Msk = 0x8
	// Bit P3.
	PIO_PDR_P3 = 0x8
	// Position of P4 field.
	PIO_PDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PDR_P4_Msk = 0x10
	// Bit P4.
	PIO_PDR_P4 = 0x10
	// Position of P5 field.
	PIO_PDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PDR_P5_Msk = 0x20
	// Bit P5.
	PIO_PDR_P5 = 0x20
	// Position of P6 field.
	PIO_PDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PDR_P6_Msk = 0x40
	// Bit P6.
	PIO_PDR_P6 = 0x40
	// Position of P7 field.
	PIO_PDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PDR_P7_Msk = 0x80
	// Bit P7.
	PIO_PDR_P7 = 0x80
	// Position of P8 field.
	PIO_PDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PDR_P8_Msk = 0x100
	// Bit P8.
	PIO_PDR_P8 = 0x100
	// Position of P9 field.
	PIO_PDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PDR_P9_Msk = 0x200
	// Bit P9.
	PIO_PDR_P9 = 0x200
	// Position of P10 field.
	PIO_PDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PDR_P10_Msk = 0x400
	// Bit P10.
	PIO_PDR_P10 = 0x400
	// Position of P11 field.
	PIO_PDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PDR_P11_Msk = 0x800
	// Bit P11.
	PIO_PDR_P11 = 0x800
	// Position of P12 field.
	PIO_PDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PDR_P12 = 0x1000
	// Position of P13 field.
	PIO_PDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PDR_P13 = 0x2000
	// Position of P14 field.
	PIO_PDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PDR_P14 = 0x4000
	// Position of P15 field.
	PIO_PDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PDR_P15 = 0x8000
	// Position of P16 field.
	PIO_PDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PDR_P16 = 0x10000
	// Position of P17 field.
	PIO_PDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PDR_P17 = 0x20000
	// Position of P18 field.
	PIO_PDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PDR_P18 = 0x40000
	// Position of P19 field.
	PIO_PDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PDR_P19 = 0x80000
	// Position of P20 field.
	PIO_PDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PDR_P20 = 0x100000
	// Position of P21 field.
	PIO_PDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PDR_P21 = 0x200000
	// Position of P22 field.
	PIO_PDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PDR_P22 = 0x400000
	// Position of P23 field.
	PIO_PDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PDR_P23 = 0x800000
	// Position of P24 field.
	PIO_PDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PDR_P31 = 0x80000000

	// PSR: PIO Status Register
	// Position of P0 field.
	PIO_PSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PSR_P0_Msk = 0x1
	// Bit P0.
	PIO_PSR_P0 = 0x1
	// Position of P1 field.
	PIO_PSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PSR_P1_Msk = 0x2
	// Bit P1.
	PIO_PSR_P1 = 0x2
	// Position of P2 field.
	PIO_PSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PSR_P2_Msk = 0x4
	// Bit P2.
	PIO_PSR_P2 = 0x4
	// Position of P3 field.
	PIO_PSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PSR_P3_Msk = 0x8
	// Bit P3.
	PIO_PSR_P3 = 0x8
	// Position of P4 field.
	PIO_PSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PSR_P4_Msk = 0x10
	// Bit P4.
	PIO_PSR_P4 = 0x10
	// Position of P5 field.
	PIO_PSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PSR_P5_Msk = 0x20
	// Bit P5.
	PIO_PSR_P5 = 0x20
	// Position of P6 field.
	PIO_PSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PSR_P6_Msk = 0x40
	// Bit P6.
	PIO_PSR_P6 = 0x40
	// Position of P7 field.
	PIO_PSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PSR_P7_Msk = 0x80
	// Bit P7.
	PIO_PSR_P7 = 0x80
	// Position of P8 field.
	PIO_PSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PSR_P8_Msk = 0x100
	// Bit P8.
	PIO_PSR_P8 = 0x100
	// Position of P9 field.
	PIO_PSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PSR_P9_Msk = 0x200
	// Bit P9.
	PIO_PSR_P9 = 0x200
	// Position of P10 field.
	PIO_PSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PSR_P10_Msk = 0x400
	// Bit P10.
	PIO_PSR_P10 = 0x400
	// Position of P11 field.
	PIO_PSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PSR_P11_Msk = 0x800
	// Bit P11.
	PIO_PSR_P11 = 0x800
	// Position of P12 field.
	PIO_PSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PSR_P12 = 0x1000
	// Position of P13 field.
	PIO_PSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PSR_P13 = 0x2000
	// Position of P14 field.
	PIO_PSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PSR_P14 = 0x4000
	// Position of P15 field.
	PIO_PSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PSR_P15 = 0x8000
	// Position of P16 field.
	PIO_PSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PSR_P16 = 0x10000
	// Position of P17 field.
	PIO_PSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PSR_P17 = 0x20000
	// Position of P18 field.
	PIO_PSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PSR_P18 = 0x40000
	// Position of P19 field.
	PIO_PSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PSR_P19 = 0x80000
	// Position of P20 field.
	PIO_PSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PSR_P20 = 0x100000
	// Position of P21 field.
	PIO_PSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PSR_P21 = 0x200000
	// Position of P22 field.
	PIO_PSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PSR_P22 = 0x400000
	// Position of P23 field.
	PIO_PSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PSR_P23 = 0x800000
	// Position of P24 field.
	PIO_PSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PSR_P31 = 0x80000000

	// OER: Output Enable Register
	// Position of P0 field.
	PIO_OER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_OER_P0_Msk = 0x1
	// Bit P0.
	PIO_OER_P0 = 0x1
	// Position of P1 field.
	PIO_OER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_OER_P1_Msk = 0x2
	// Bit P1.
	PIO_OER_P1 = 0x2
	// Position of P2 field.
	PIO_OER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_OER_P2_Msk = 0x4
	// Bit P2.
	PIO_OER_P2 = 0x4
	// Position of P3 field.
	PIO_OER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_OER_P3_Msk = 0x8
	// Bit P3.
	PIO_OER_P3 = 0x8
	// Position of P4 field.
	PIO_OER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_OER_P4_Msk = 0x10
	// Bit P4.
	PIO_OER_P4 = 0x10
	// Position of P5 field.
	PIO_OER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_OER_P5_Msk = 0x20
	// Bit P5.
	PIO_OER_P5 = 0x20
	// Position of P6 field.
	PIO_OER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_OER_P6_Msk = 0x40
	// Bit P6.
	PIO_OER_P6 = 0x40
	// Position of P7 field.
	PIO_OER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_OER_P7_Msk = 0x80
	// Bit P7.
	PIO_OER_P7 = 0x80
	// Position of P8 field.
	PIO_OER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_OER_P8_Msk = 0x100
	// Bit P8.
	PIO_OER_P8 = 0x100
	// Position of P9 field.
	PIO_OER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_OER_P9_Msk = 0x200
	// Bit P9.
	PIO_OER_P9 = 0x200
	// Position of P10 field.
	PIO_OER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_OER_P10_Msk = 0x400
	// Bit P10.
	PIO_OER_P10 = 0x400
	// Position of P11 field.
	PIO_OER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_OER_P11_Msk = 0x800
	// Bit P11.
	PIO_OER_P11 = 0x800
	// Position of P12 field.
	PIO_OER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_OER_P12_Msk = 0x1000
	// Bit P12.
	PIO_OER_P12 = 0x1000
	// Position of P13 field.
	PIO_OER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_OER_P13_Msk = 0x2000
	// Bit P13.
	PIO_OER_P13 = 0x2000
	// Position of P14 field.
	PIO_OER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_OER_P14_Msk = 0x4000
	// Bit P14.
	PIO_OER_P14 = 0x4000
	// Position of P15 field.
	PIO_OER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_OER_P15_Msk = 0x8000
	// Bit P15.
	PIO_OER_P15 = 0x8000
	// Position of P16 field.
	PIO_OER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_OER_P16_Msk = 0x10000
	// Bit P16.
	PIO_OER_P16 = 0x10000
	// Position of P17 field.
	PIO_OER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_OER_P17_Msk = 0x20000
	// Bit P17.
	PIO_OER_P17 = 0x20000
	// Position of P18 field.
	PIO_OER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_OER_P18_Msk = 0x40000
	// Bit P18.
	PIO_OER_P18 = 0x40000
	// Position of P19 field.
	PIO_OER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_OER_P19_Msk = 0x80000
	// Bit P19.
	PIO_OER_P19 = 0x80000
	// Position of P20 field.
	PIO_OER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_OER_P20_Msk = 0x100000
	// Bit P20.
	PIO_OER_P20 = 0x100000
	// Position of P21 field.
	PIO_OER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_OER_P21_Msk = 0x200000
	// Bit P21.
	PIO_OER_P21 = 0x200000
	// Position of P22 field.
	PIO_OER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_OER_P22_Msk = 0x400000
	// Bit P22.
	PIO_OER_P22 = 0x400000
	// Position of P23 field.
	PIO_OER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_OER_P23_Msk = 0x800000
	// Bit P23.
	PIO_OER_P23 = 0x800000
	// Position of P24 field.
	PIO_OER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_OER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_OER_P24 = 0x1000000
	// Position of P25 field.
	PIO_OER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_OER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_OER_P25 = 0x2000000
	// Position of P26 field.
	PIO_OER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_OER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_OER_P26 = 0x4000000
	// Position of P27 field.
	PIO_OER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_OER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_OER_P27 = 0x8000000
	// Position of P28 field.
	PIO_OER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_OER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_OER_P28 = 0x10000000
	// Position of P29 field.
	PIO_OER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_OER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_OER_P29 = 0x20000000
	// Position of P30 field.
	PIO_OER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_OER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_OER_P30 = 0x40000000
	// Position of P31 field.
	PIO_OER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_OER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_OER_P31 = 0x80000000

	// ODR: Output Disable Register
	// Position of P0 field.
	PIO_ODR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ODR_P0_Msk = 0x1
	// Bit P0.
	PIO_ODR_P0 = 0x1
	// Position of P1 field.
	PIO_ODR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ODR_P1_Msk = 0x2
	// Bit P1.
	PIO_ODR_P1 = 0x2
	// Position of P2 field.
	PIO_ODR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ODR_P2_Msk = 0x4
	// Bit P2.
	PIO_ODR_P2 = 0x4
	// Position of P3 field.
	PIO_ODR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ODR_P3_Msk = 0x8
	// Bit P3.
	PIO_ODR_P3 = 0x8
	// Position of P4 field.
	PIO_ODR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ODR_P4_Msk = 0x10
	// Bit P4.
	PIO_ODR_P4 = 0x10
	// Position of P5 field.
	PIO_ODR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ODR_P5_Msk = 0x20
	// Bit P5.
	PIO_ODR_P5 = 0x20
	// Position of P6 field.
	PIO_ODR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ODR_P6_Msk = 0x40
	// Bit P6.
	PIO_ODR_P6 = 0x40
	// Position of P7 field.
	PIO_ODR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ODR_P7_Msk = 0x80
	// Bit P7.
	PIO_ODR_P7 = 0x80
	// Position of P8 field.
	PIO_ODR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ODR_P8_Msk = 0x100
	// Bit P8.
	PIO_ODR_P8 = 0x100
	// Position of P9 field.
	PIO_ODR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ODR_P9_Msk = 0x200
	// Bit P9.
	PIO_ODR_P9 = 0x200
	// Position of P10 field.
	PIO_ODR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ODR_P10_Msk = 0x400
	// Bit P10.
	PIO_ODR_P10 = 0x400
	// Position of P11 field.
	PIO_ODR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ODR_P11_Msk = 0x800
	// Bit P11.
	PIO_ODR_P11 = 0x800
	// Position of P12 field.
	PIO_ODR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ODR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ODR_P12 = 0x1000
	// Position of P13 field.
	PIO_ODR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ODR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ODR_P13 = 0x2000
	// Position of P14 field.
	PIO_ODR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ODR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ODR_P14 = 0x4000
	// Position of P15 field.
	PIO_ODR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ODR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ODR_P15 = 0x8000
	// Position of P16 field.
	PIO_ODR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ODR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ODR_P16 = 0x10000
	// Position of P17 field.
	PIO_ODR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ODR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ODR_P17 = 0x20000
	// Position of P18 field.
	PIO_ODR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ODR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ODR_P18 = 0x40000
	// Position of P19 field.
	PIO_ODR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ODR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ODR_P19 = 0x80000
	// Position of P20 field.
	PIO_ODR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ODR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ODR_P20 = 0x100000
	// Position of P21 field.
	PIO_ODR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ODR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ODR_P21 = 0x200000
	// Position of P22 field.
	PIO_ODR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ODR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ODR_P22 = 0x400000
	// Position of P23 field.
	PIO_ODR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ODR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ODR_P23 = 0x800000
	// Position of P24 field.
	PIO_ODR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ODR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ODR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ODR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ODR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ODR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ODR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ODR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ODR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ODR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ODR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ODR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ODR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ODR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ODR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ODR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ODR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ODR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ODR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ODR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ODR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ODR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ODR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ODR_P31 = 0x80000000

	// OSR: Output Status Register
	// Position of P0 field.
	PIO_OSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_OSR_P0_Msk = 0x1
	// Bit P0.
	PIO_OSR_P0 = 0x1
	// Position of P1 field.
	PIO_OSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_OSR_P1_Msk = 0x2
	// Bit P1.
	PIO_OSR_P1 = 0x2
	// Position of P2 field.
	PIO_OSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_OSR_P2_Msk = 0x4
	// Bit P2.
	PIO_OSR_P2 = 0x4
	// Position of P3 field.
	PIO_OSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_OSR_P3_Msk = 0x8
	// Bit P3.
	PIO_OSR_P3 = 0x8
	// Position of P4 field.
	PIO_OSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_OSR_P4_Msk = 0x10
	// Bit P4.
	PIO_OSR_P4 = 0x10
	// Position of P5 field.
	PIO_OSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_OSR_P5_Msk = 0x20
	// Bit P5.
	PIO_OSR_P5 = 0x20
	// Position of P6 field.
	PIO_OSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_OSR_P6_Msk = 0x40
	// Bit P6.
	PIO_OSR_P6 = 0x40
	// Position of P7 field.
	PIO_OSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_OSR_P7_Msk = 0x80
	// Bit P7.
	PIO_OSR_P7 = 0x80
	// Position of P8 field.
	PIO_OSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_OSR_P8_Msk = 0x100
	// Bit P8.
	PIO_OSR_P8 = 0x100
	// Position of P9 field.
	PIO_OSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_OSR_P9_Msk = 0x200
	// Bit P9.
	PIO_OSR_P9 = 0x200
	// Position of P10 field.
	PIO_OSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_OSR_P10_Msk = 0x400
	// Bit P10.
	PIO_OSR_P10 = 0x400
	// Position of P11 field.
	PIO_OSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_OSR_P11_Msk = 0x800
	// Bit P11.
	PIO_OSR_P11 = 0x800
	// Position of P12 field.
	PIO_OSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_OSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_OSR_P12 = 0x1000
	// Position of P13 field.
	PIO_OSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_OSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_OSR_P13 = 0x2000
	// Position of P14 field.
	PIO_OSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_OSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_OSR_P14 = 0x4000
	// Position of P15 field.
	PIO_OSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_OSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_OSR_P15 = 0x8000
	// Position of P16 field.
	PIO_OSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_OSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_OSR_P16 = 0x10000
	// Position of P17 field.
	PIO_OSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_OSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_OSR_P17 = 0x20000
	// Position of P18 field.
	PIO_OSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_OSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_OSR_P18 = 0x40000
	// Position of P19 field.
	PIO_OSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_OSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_OSR_P19 = 0x80000
	// Position of P20 field.
	PIO_OSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_OSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_OSR_P20 = 0x100000
	// Position of P21 field.
	PIO_OSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_OSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_OSR_P21 = 0x200000
	// Position of P22 field.
	PIO_OSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_OSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_OSR_P22 = 0x400000
	// Position of P23 field.
	PIO_OSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_OSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_OSR_P23 = 0x800000
	// Position of P24 field.
	PIO_OSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_OSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_OSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_OSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_OSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_OSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_OSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_OSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_OSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_OSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_OSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_OSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_OSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_OSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_OSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_OSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_OSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_OSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_OSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_OSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_OSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_OSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_OSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_OSR_P31 = 0x80000000

	// IFER: Glitch Input Filter Enable Register
	// Position of P0 field.
	PIO_IFER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IFER_P0_Msk = 0x1
	// Bit P0.
	PIO_IFER_P0 = 0x1
	// Position of P1 field.
	PIO_IFER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IFER_P1_Msk = 0x2
	// Bit P1.
	PIO_IFER_P1 = 0x2
	// Position of P2 field.
	PIO_IFER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IFER_P2_Msk = 0x4
	// Bit P2.
	PIO_IFER_P2 = 0x4
	// Position of P3 field.
	PIO_IFER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IFER_P3_Msk = 0x8
	// Bit P3.
	PIO_IFER_P3 = 0x8
	// Position of P4 field.
	PIO_IFER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IFER_P4_Msk = 0x10
	// Bit P4.
	PIO_IFER_P4 = 0x10
	// Position of P5 field.
	PIO_IFER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IFER_P5_Msk = 0x20
	// Bit P5.
	PIO_IFER_P5 = 0x20
	// Position of P6 field.
	PIO_IFER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IFER_P6_Msk = 0x40
	// Bit P6.
	PIO_IFER_P6 = 0x40
	// Position of P7 field.
	PIO_IFER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IFER_P7_Msk = 0x80
	// Bit P7.
	PIO_IFER_P7 = 0x80
	// Position of P8 field.
	PIO_IFER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IFER_P8_Msk = 0x100
	// Bit P8.
	PIO_IFER_P8 = 0x100
	// Position of P9 field.
	PIO_IFER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IFER_P9_Msk = 0x200
	// Bit P9.
	PIO_IFER_P9 = 0x200
	// Position of P10 field.
	PIO_IFER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IFER_P10_Msk = 0x400
	// Bit P10.
	PIO_IFER_P10 = 0x400
	// Position of P11 field.
	PIO_IFER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IFER_P11_Msk = 0x800
	// Bit P11.
	PIO_IFER_P11 = 0x800
	// Position of P12 field.
	PIO_IFER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IFER_P12_Msk = 0x1000
	// Bit P12.
	PIO_IFER_P12 = 0x1000
	// Position of P13 field.
	PIO_IFER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IFER_P13_Msk = 0x2000
	// Bit P13.
	PIO_IFER_P13 = 0x2000
	// Position of P14 field.
	PIO_IFER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IFER_P14_Msk = 0x4000
	// Bit P14.
	PIO_IFER_P14 = 0x4000
	// Position of P15 field.
	PIO_IFER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IFER_P15_Msk = 0x8000
	// Bit P15.
	PIO_IFER_P15 = 0x8000
	// Position of P16 field.
	PIO_IFER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IFER_P16_Msk = 0x10000
	// Bit P16.
	PIO_IFER_P16 = 0x10000
	// Position of P17 field.
	PIO_IFER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IFER_P17_Msk = 0x20000
	// Bit P17.
	PIO_IFER_P17 = 0x20000
	// Position of P18 field.
	PIO_IFER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IFER_P18_Msk = 0x40000
	// Bit P18.
	PIO_IFER_P18 = 0x40000
	// Position of P19 field.
	PIO_IFER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IFER_P19_Msk = 0x80000
	// Bit P19.
	PIO_IFER_P19 = 0x80000
	// Position of P20 field.
	PIO_IFER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IFER_P20_Msk = 0x100000
	// Bit P20.
	PIO_IFER_P20 = 0x100000
	// Position of P21 field.
	PIO_IFER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IFER_P21_Msk = 0x200000
	// Bit P21.
	PIO_IFER_P21 = 0x200000
	// Position of P22 field.
	PIO_IFER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IFER_P22_Msk = 0x400000
	// Bit P22.
	PIO_IFER_P22 = 0x400000
	// Position of P23 field.
	PIO_IFER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IFER_P23_Msk = 0x800000
	// Bit P23.
	PIO_IFER_P23 = 0x800000
	// Position of P24 field.
	PIO_IFER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IFER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IFER_P24 = 0x1000000
	// Position of P25 field.
	PIO_IFER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IFER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IFER_P25 = 0x2000000
	// Position of P26 field.
	PIO_IFER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IFER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IFER_P26 = 0x4000000
	// Position of P27 field.
	PIO_IFER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IFER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IFER_P27 = 0x8000000
	// Position of P28 field.
	PIO_IFER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IFER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IFER_P28 = 0x10000000
	// Position of P29 field.
	PIO_IFER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IFER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IFER_P29 = 0x20000000
	// Position of P30 field.
	PIO_IFER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IFER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IFER_P30 = 0x40000000
	// Position of P31 field.
	PIO_IFER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IFER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IFER_P31 = 0x80000000

	// IFDR: Glitch Input Filter Disable Register
	// Position of P0 field.
	PIO_IFDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IFDR_P0_Msk = 0x1
	// Bit P0.
	PIO_IFDR_P0 = 0x1
	// Position of P1 field.
	PIO_IFDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IFDR_P1_Msk = 0x2
	// Bit P1.
	PIO_IFDR_P1 = 0x2
	// Position of P2 field.
	PIO_IFDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IFDR_P2_Msk = 0x4
	// Bit P2.
	PIO_IFDR_P2 = 0x4
	// Position of P3 field.
	PIO_IFDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IFDR_P3_Msk = 0x8
	// Bit P3.
	PIO_IFDR_P3 = 0x8
	// Position of P4 field.
	PIO_IFDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IFDR_P4_Msk = 0x10
	// Bit P4.
	PIO_IFDR_P4 = 0x10
	// Position of P5 field.
	PIO_IFDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IFDR_P5_Msk = 0x20
	// Bit P5.
	PIO_IFDR_P5 = 0x20
	// Position of P6 field.
	PIO_IFDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IFDR_P6_Msk = 0x40
	// Bit P6.
	PIO_IFDR_P6 = 0x40
	// Position of P7 field.
	PIO_IFDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IFDR_P7_Msk = 0x80
	// Bit P7.
	PIO_IFDR_P7 = 0x80
	// Position of P8 field.
	PIO_IFDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IFDR_P8_Msk = 0x100
	// Bit P8.
	PIO_IFDR_P8 = 0x100
	// Position of P9 field.
	PIO_IFDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IFDR_P9_Msk = 0x200
	// Bit P9.
	PIO_IFDR_P9 = 0x200
	// Position of P10 field.
	PIO_IFDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IFDR_P10_Msk = 0x400
	// Bit P10.
	PIO_IFDR_P10 = 0x400
	// Position of P11 field.
	PIO_IFDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IFDR_P11_Msk = 0x800
	// Bit P11.
	PIO_IFDR_P11 = 0x800
	// Position of P12 field.
	PIO_IFDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IFDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_IFDR_P12 = 0x1000
	// Position of P13 field.
	PIO_IFDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IFDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_IFDR_P13 = 0x2000
	// Position of P14 field.
	PIO_IFDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IFDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_IFDR_P14 = 0x4000
	// Position of P15 field.
	PIO_IFDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IFDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_IFDR_P15 = 0x8000
	// Position of P16 field.
	PIO_IFDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IFDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_IFDR_P16 = 0x10000
	// Position of P17 field.
	PIO_IFDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IFDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_IFDR_P17 = 0x20000
	// Position of P18 field.
	PIO_IFDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IFDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_IFDR_P18 = 0x40000
	// Position of P19 field.
	PIO_IFDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IFDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_IFDR_P19 = 0x80000
	// Position of P20 field.
	PIO_IFDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IFDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_IFDR_P20 = 0x100000
	// Position of P21 field.
	PIO_IFDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IFDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_IFDR_P21 = 0x200000
	// Position of P22 field.
	PIO_IFDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IFDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_IFDR_P22 = 0x400000
	// Position of P23 field.
	PIO_IFDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IFDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_IFDR_P23 = 0x800000
	// Position of P24 field.
	PIO_IFDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IFDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IFDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_IFDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IFDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IFDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_IFDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IFDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IFDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_IFDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IFDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IFDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_IFDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IFDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IFDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_IFDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IFDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IFDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_IFDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IFDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IFDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_IFDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IFDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IFDR_P31 = 0x80000000

	// IFSR: Glitch Input Filter Status Register
	// Position of P0 field.
	PIO_IFSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IFSR_P0_Msk = 0x1
	// Bit P0.
	PIO_IFSR_P0 = 0x1
	// Position of P1 field.
	PIO_IFSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IFSR_P1_Msk = 0x2
	// Bit P1.
	PIO_IFSR_P1 = 0x2
	// Position of P2 field.
	PIO_IFSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IFSR_P2_Msk = 0x4
	// Bit P2.
	PIO_IFSR_P2 = 0x4
	// Position of P3 field.
	PIO_IFSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IFSR_P3_Msk = 0x8
	// Bit P3.
	PIO_IFSR_P3 = 0x8
	// Position of P4 field.
	PIO_IFSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IFSR_P4_Msk = 0x10
	// Bit P4.
	PIO_IFSR_P4 = 0x10
	// Position of P5 field.
	PIO_IFSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IFSR_P5_Msk = 0x20
	// Bit P5.
	PIO_IFSR_P5 = 0x20
	// Position of P6 field.
	PIO_IFSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IFSR_P6_Msk = 0x40
	// Bit P6.
	PIO_IFSR_P6 = 0x40
	// Position of P7 field.
	PIO_IFSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IFSR_P7_Msk = 0x80
	// Bit P7.
	PIO_IFSR_P7 = 0x80
	// Position of P8 field.
	PIO_IFSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IFSR_P8_Msk = 0x100
	// Bit P8.
	PIO_IFSR_P8 = 0x100
	// Position of P9 field.
	PIO_IFSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IFSR_P9_Msk = 0x200
	// Bit P9.
	PIO_IFSR_P9 = 0x200
	// Position of P10 field.
	PIO_IFSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IFSR_P10_Msk = 0x400
	// Bit P10.
	PIO_IFSR_P10 = 0x400
	// Position of P11 field.
	PIO_IFSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IFSR_P11_Msk = 0x800
	// Bit P11.
	PIO_IFSR_P11 = 0x800
	// Position of P12 field.
	PIO_IFSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IFSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_IFSR_P12 = 0x1000
	// Position of P13 field.
	PIO_IFSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IFSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_IFSR_P13 = 0x2000
	// Position of P14 field.
	PIO_IFSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IFSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_IFSR_P14 = 0x4000
	// Position of P15 field.
	PIO_IFSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IFSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_IFSR_P15 = 0x8000
	// Position of P16 field.
	PIO_IFSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IFSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_IFSR_P16 = 0x10000
	// Position of P17 field.
	PIO_IFSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IFSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_IFSR_P17 = 0x20000
	// Position of P18 field.
	PIO_IFSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IFSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_IFSR_P18 = 0x40000
	// Position of P19 field.
	PIO_IFSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IFSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_IFSR_P19 = 0x80000
	// Position of P20 field.
	PIO_IFSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IFSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_IFSR_P20 = 0x100000
	// Position of P21 field.
	PIO_IFSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IFSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_IFSR_P21 = 0x200000
	// Position of P22 field.
	PIO_IFSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IFSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_IFSR_P22 = 0x400000
	// Position of P23 field.
	PIO_IFSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IFSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_IFSR_P23 = 0x800000
	// Position of P24 field.
	PIO_IFSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IFSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IFSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_IFSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IFSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IFSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_IFSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IFSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IFSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_IFSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IFSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IFSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_IFSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IFSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IFSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_IFSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IFSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IFSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_IFSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IFSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IFSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_IFSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IFSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IFSR_P31 = 0x80000000

	// SODR: Set Output Data Register
	// Position of P0 field.
	PIO_SODR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_SODR_P0_Msk = 0x1
	// Bit P0.
	PIO_SODR_P0 = 0x1
	// Position of P1 field.
	PIO_SODR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_SODR_P1_Msk = 0x2
	// Bit P1.
	PIO_SODR_P1 = 0x2
	// Position of P2 field.
	PIO_SODR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_SODR_P2_Msk = 0x4
	// Bit P2.
	PIO_SODR_P2 = 0x4
	// Position of P3 field.
	PIO_SODR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_SODR_P3_Msk = 0x8
	// Bit P3.
	PIO_SODR_P3 = 0x8
	// Position of P4 field.
	PIO_SODR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_SODR_P4_Msk = 0x10
	// Bit P4.
	PIO_SODR_P4 = 0x10
	// Position of P5 field.
	PIO_SODR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_SODR_P5_Msk = 0x20
	// Bit P5.
	PIO_SODR_P5 = 0x20
	// Position of P6 field.
	PIO_SODR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_SODR_P6_Msk = 0x40
	// Bit P6.
	PIO_SODR_P6 = 0x40
	// Position of P7 field.
	PIO_SODR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_SODR_P7_Msk = 0x80
	// Bit P7.
	PIO_SODR_P7 = 0x80
	// Position of P8 field.
	PIO_SODR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_SODR_P8_Msk = 0x100
	// Bit P8.
	PIO_SODR_P8 = 0x100
	// Position of P9 field.
	PIO_SODR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_SODR_P9_Msk = 0x200
	// Bit P9.
	PIO_SODR_P9 = 0x200
	// Position of P10 field.
	PIO_SODR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_SODR_P10_Msk = 0x400
	// Bit P10.
	PIO_SODR_P10 = 0x400
	// Position of P11 field.
	PIO_SODR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_SODR_P11_Msk = 0x800
	// Bit P11.
	PIO_SODR_P11 = 0x800
	// Position of P12 field.
	PIO_SODR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_SODR_P12_Msk = 0x1000
	// Bit P12.
	PIO_SODR_P12 = 0x1000
	// Position of P13 field.
	PIO_SODR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_SODR_P13_Msk = 0x2000
	// Bit P13.
	PIO_SODR_P13 = 0x2000
	// Position of P14 field.
	PIO_SODR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_SODR_P14_Msk = 0x4000
	// Bit P14.
	PIO_SODR_P14 = 0x4000
	// Position of P15 field.
	PIO_SODR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_SODR_P15_Msk = 0x8000
	// Bit P15.
	PIO_SODR_P15 = 0x8000
	// Position of P16 field.
	PIO_SODR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_SODR_P16_Msk = 0x10000
	// Bit P16.
	PIO_SODR_P16 = 0x10000
	// Position of P17 field.
	PIO_SODR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_SODR_P17_Msk = 0x20000
	// Bit P17.
	PIO_SODR_P17 = 0x20000
	// Position of P18 field.
	PIO_SODR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_SODR_P18_Msk = 0x40000
	// Bit P18.
	PIO_SODR_P18 = 0x40000
	// Position of P19 field.
	PIO_SODR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_SODR_P19_Msk = 0x80000
	// Bit P19.
	PIO_SODR_P19 = 0x80000
	// Position of P20 field.
	PIO_SODR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_SODR_P20_Msk = 0x100000
	// Bit P20.
	PIO_SODR_P20 = 0x100000
	// Position of P21 field.
	PIO_SODR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_SODR_P21_Msk = 0x200000
	// Bit P21.
	PIO_SODR_P21 = 0x200000
	// Position of P22 field.
	PIO_SODR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_SODR_P22_Msk = 0x400000
	// Bit P22.
	PIO_SODR_P22 = 0x400000
	// Position of P23 field.
	PIO_SODR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_SODR_P23_Msk = 0x800000
	// Bit P23.
	PIO_SODR_P23 = 0x800000
	// Position of P24 field.
	PIO_SODR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_SODR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_SODR_P24 = 0x1000000
	// Position of P25 field.
	PIO_SODR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_SODR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_SODR_P25 = 0x2000000
	// Position of P26 field.
	PIO_SODR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_SODR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_SODR_P26 = 0x4000000
	// Position of P27 field.
	PIO_SODR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_SODR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_SODR_P27 = 0x8000000
	// Position of P28 field.
	PIO_SODR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_SODR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_SODR_P28 = 0x10000000
	// Position of P29 field.
	PIO_SODR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_SODR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_SODR_P29 = 0x20000000
	// Position of P30 field.
	PIO_SODR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_SODR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_SODR_P30 = 0x40000000
	// Position of P31 field.
	PIO_SODR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_SODR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_SODR_P31 = 0x80000000

	// CODR: Clear Output Data Register
	// Position of P0 field.
	PIO_CODR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_CODR_P0_Msk = 0x1
	// Bit P0.
	PIO_CODR_P0 = 0x1
	// Position of P1 field.
	PIO_CODR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_CODR_P1_Msk = 0x2
	// Bit P1.
	PIO_CODR_P1 = 0x2
	// Position of P2 field.
	PIO_CODR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_CODR_P2_Msk = 0x4
	// Bit P2.
	PIO_CODR_P2 = 0x4
	// Position of P3 field.
	PIO_CODR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_CODR_P3_Msk = 0x8
	// Bit P3.
	PIO_CODR_P3 = 0x8
	// Position of P4 field.
	PIO_CODR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_CODR_P4_Msk = 0x10
	// Bit P4.
	PIO_CODR_P4 = 0x10
	// Position of P5 field.
	PIO_CODR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_CODR_P5_Msk = 0x20
	// Bit P5.
	PIO_CODR_P5 = 0x20
	// Position of P6 field.
	PIO_CODR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_CODR_P6_Msk = 0x40
	// Bit P6.
	PIO_CODR_P6 = 0x40
	// Position of P7 field.
	PIO_CODR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_CODR_P7_Msk = 0x80
	// Bit P7.
	PIO_CODR_P7 = 0x80
	// Position of P8 field.
	PIO_CODR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_CODR_P8_Msk = 0x100
	// Bit P8.
	PIO_CODR_P8 = 0x100
	// Position of P9 field.
	PIO_CODR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_CODR_P9_Msk = 0x200
	// Bit P9.
	PIO_CODR_P9 = 0x200
	// Position of P10 field.
	PIO_CODR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_CODR_P10_Msk = 0x400
	// Bit P10.
	PIO_CODR_P10 = 0x400
	// Position of P11 field.
	PIO_CODR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_CODR_P11_Msk = 0x800
	// Bit P11.
	PIO_CODR_P11 = 0x800
	// Position of P12 field.
	PIO_CODR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_CODR_P12_Msk = 0x1000
	// Bit P12.
	PIO_CODR_P12 = 0x1000
	// Position of P13 field.
	PIO_CODR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_CODR_P13_Msk = 0x2000
	// Bit P13.
	PIO_CODR_P13 = 0x2000
	// Position of P14 field.
	PIO_CODR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_CODR_P14_Msk = 0x4000
	// Bit P14.
	PIO_CODR_P14 = 0x4000
	// Position of P15 field.
	PIO_CODR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_CODR_P15_Msk = 0x8000
	// Bit P15.
	PIO_CODR_P15 = 0x8000
	// Position of P16 field.
	PIO_CODR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_CODR_P16_Msk = 0x10000
	// Bit P16.
	PIO_CODR_P16 = 0x10000
	// Position of P17 field.
	PIO_CODR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_CODR_P17_Msk = 0x20000
	// Bit P17.
	PIO_CODR_P17 = 0x20000
	// Position of P18 field.
	PIO_CODR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_CODR_P18_Msk = 0x40000
	// Bit P18.
	PIO_CODR_P18 = 0x40000
	// Position of P19 field.
	PIO_CODR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_CODR_P19_Msk = 0x80000
	// Bit P19.
	PIO_CODR_P19 = 0x80000
	// Position of P20 field.
	PIO_CODR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_CODR_P20_Msk = 0x100000
	// Bit P20.
	PIO_CODR_P20 = 0x100000
	// Position of P21 field.
	PIO_CODR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_CODR_P21_Msk = 0x200000
	// Bit P21.
	PIO_CODR_P21 = 0x200000
	// Position of P22 field.
	PIO_CODR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_CODR_P22_Msk = 0x400000
	// Bit P22.
	PIO_CODR_P22 = 0x400000
	// Position of P23 field.
	PIO_CODR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_CODR_P23_Msk = 0x800000
	// Bit P23.
	PIO_CODR_P23 = 0x800000
	// Position of P24 field.
	PIO_CODR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_CODR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_CODR_P24 = 0x1000000
	// Position of P25 field.
	PIO_CODR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_CODR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_CODR_P25 = 0x2000000
	// Position of P26 field.
	PIO_CODR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_CODR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_CODR_P26 = 0x4000000
	// Position of P27 field.
	PIO_CODR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_CODR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_CODR_P27 = 0x8000000
	// Position of P28 field.
	PIO_CODR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_CODR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_CODR_P28 = 0x10000000
	// Position of P29 field.
	PIO_CODR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_CODR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_CODR_P29 = 0x20000000
	// Position of P30 field.
	PIO_CODR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_CODR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_CODR_P30 = 0x40000000
	// Position of P31 field.
	PIO_CODR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_CODR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_CODR_P31 = 0x80000000

	// ODSR: Output Data Status Register
	// Position of P0 field.
	PIO_ODSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ODSR_P0_Msk = 0x1
	// Bit P0.
	PIO_ODSR_P0 = 0x1
	// Position of P1 field.
	PIO_ODSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ODSR_P1_Msk = 0x2
	// Bit P1.
	PIO_ODSR_P1 = 0x2
	// Position of P2 field.
	PIO_ODSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ODSR_P2_Msk = 0x4
	// Bit P2.
	PIO_ODSR_P2 = 0x4
	// Position of P3 field.
	PIO_ODSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ODSR_P3_Msk = 0x8
	// Bit P3.
	PIO_ODSR_P3 = 0x8
	// Position of P4 field.
	PIO_ODSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ODSR_P4_Msk = 0x10
	// Bit P4.
	PIO_ODSR_P4 = 0x10
	// Position of P5 field.
	PIO_ODSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ODSR_P5_Msk = 0x20
	// Bit P5.
	PIO_ODSR_P5 = 0x20
	// Position of P6 field.
	PIO_ODSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ODSR_P6_Msk = 0x40
	// Bit P6.
	PIO_ODSR_P6 = 0x40
	// Position of P7 field.
	PIO_ODSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ODSR_P7_Msk = 0x80
	// Bit P7.
	PIO_ODSR_P7 = 0x80
	// Position of P8 field.
	PIO_ODSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ODSR_P8_Msk = 0x100
	// Bit P8.
	PIO_ODSR_P8 = 0x100
	// Position of P9 field.
	PIO_ODSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ODSR_P9_Msk = 0x200
	// Bit P9.
	PIO_ODSR_P9 = 0x200
	// Position of P10 field.
	PIO_ODSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ODSR_P10_Msk = 0x400
	// Bit P10.
	PIO_ODSR_P10 = 0x400
	// Position of P11 field.
	PIO_ODSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ODSR_P11_Msk = 0x800
	// Bit P11.
	PIO_ODSR_P11 = 0x800
	// Position of P12 field.
	PIO_ODSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ODSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ODSR_P12 = 0x1000
	// Position of P13 field.
	PIO_ODSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ODSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ODSR_P13 = 0x2000
	// Position of P14 field.
	PIO_ODSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ODSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ODSR_P14 = 0x4000
	// Position of P15 field.
	PIO_ODSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ODSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ODSR_P15 = 0x8000
	// Position of P16 field.
	PIO_ODSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ODSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ODSR_P16 = 0x10000
	// Position of P17 field.
	PIO_ODSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ODSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ODSR_P17 = 0x20000
	// Position of P18 field.
	PIO_ODSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ODSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ODSR_P18 = 0x40000
	// Position of P19 field.
	PIO_ODSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ODSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ODSR_P19 = 0x80000
	// Position of P20 field.
	PIO_ODSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ODSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ODSR_P20 = 0x100000
	// Position of P21 field.
	PIO_ODSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ODSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ODSR_P21 = 0x200000
	// Position of P22 field.
	PIO_ODSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ODSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ODSR_P22 = 0x400000
	// Position of P23 field.
	PIO_ODSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ODSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ODSR_P23 = 0x800000
	// Position of P24 field.
	PIO_ODSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ODSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ODSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ODSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ODSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ODSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ODSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ODSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ODSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ODSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ODSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ODSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ODSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ODSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ODSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ODSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ODSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ODSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ODSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ODSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ODSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ODSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ODSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ODSR_P31 = 0x80000000

	// PDSR: Pin Data Status Register
	// Position of P0 field.
	PIO_PDSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PDSR_P0_Msk = 0x1
	// Bit P0.
	PIO_PDSR_P0 = 0x1
	// Position of P1 field.
	PIO_PDSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PDSR_P1_Msk = 0x2
	// Bit P1.
	PIO_PDSR_P1 = 0x2
	// Position of P2 field.
	PIO_PDSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PDSR_P2_Msk = 0x4
	// Bit P2.
	PIO_PDSR_P2 = 0x4
	// Position of P3 field.
	PIO_PDSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PDSR_P3_Msk = 0x8
	// Bit P3.
	PIO_PDSR_P3 = 0x8
	// Position of P4 field.
	PIO_PDSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PDSR_P4_Msk = 0x10
	// Bit P4.
	PIO_PDSR_P4 = 0x10
	// Position of P5 field.
	PIO_PDSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PDSR_P5_Msk = 0x20
	// Bit P5.
	PIO_PDSR_P5 = 0x20
	// Position of P6 field.
	PIO_PDSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PDSR_P6_Msk = 0x40
	// Bit P6.
	PIO_PDSR_P6 = 0x40
	// Position of P7 field.
	PIO_PDSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PDSR_P7_Msk = 0x80
	// Bit P7.
	PIO_PDSR_P7 = 0x80
	// Position of P8 field.
	PIO_PDSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PDSR_P8_Msk = 0x100
	// Bit P8.
	PIO_PDSR_P8 = 0x100
	// Position of P9 field.
	PIO_PDSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PDSR_P9_Msk = 0x200
	// Bit P9.
	PIO_PDSR_P9 = 0x200
	// Position of P10 field.
	PIO_PDSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PDSR_P10_Msk = 0x400
	// Bit P10.
	PIO_PDSR_P10 = 0x400
	// Position of P11 field.
	PIO_PDSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PDSR_P11_Msk = 0x800
	// Bit P11.
	PIO_PDSR_P11 = 0x800
	// Position of P12 field.
	PIO_PDSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PDSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PDSR_P12 = 0x1000
	// Position of P13 field.
	PIO_PDSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PDSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PDSR_P13 = 0x2000
	// Position of P14 field.
	PIO_PDSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PDSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PDSR_P14 = 0x4000
	// Position of P15 field.
	PIO_PDSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PDSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PDSR_P15 = 0x8000
	// Position of P16 field.
	PIO_PDSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PDSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PDSR_P16 = 0x10000
	// Position of P17 field.
	PIO_PDSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PDSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PDSR_P17 = 0x20000
	// Position of P18 field.
	PIO_PDSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PDSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PDSR_P18 = 0x40000
	// Position of P19 field.
	PIO_PDSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PDSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PDSR_P19 = 0x80000
	// Position of P20 field.
	PIO_PDSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PDSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PDSR_P20 = 0x100000
	// Position of P21 field.
	PIO_PDSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PDSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PDSR_P21 = 0x200000
	// Position of P22 field.
	PIO_PDSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PDSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PDSR_P22 = 0x400000
	// Position of P23 field.
	PIO_PDSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PDSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PDSR_P23 = 0x800000
	// Position of P24 field.
	PIO_PDSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PDSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PDSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PDSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PDSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PDSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PDSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PDSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PDSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PDSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PDSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PDSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PDSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PDSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PDSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PDSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PDSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PDSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PDSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PDSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PDSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PDSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PDSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PDSR_P31 = 0x80000000

	// IER: Interrupt Enable Register
	// Position of P0 field.
	PIO_IER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IER_P0_Msk = 0x1
	// Bit P0.
	PIO_IER_P0 = 0x1
	// Position of P1 field.
	PIO_IER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IER_P1_Msk = 0x2
	// Bit P1.
	PIO_IER_P1 = 0x2
	// Position of P2 field.
	PIO_IER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IER_P2_Msk = 0x4
	// Bit P2.
	PIO_IER_P2 = 0x4
	// Position of P3 field.
	PIO_IER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IER_P3_Msk = 0x8
	// Bit P3.
	PIO_IER_P3 = 0x8
	// Position of P4 field.
	PIO_IER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IER_P4_Msk = 0x10
	// Bit P4.
	PIO_IER_P4 = 0x10
	// Position of P5 field.
	PIO_IER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IER_P5_Msk = 0x20
	// Bit P5.
	PIO_IER_P5 = 0x20
	// Position of P6 field.
	PIO_IER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IER_P6_Msk = 0x40
	// Bit P6.
	PIO_IER_P6 = 0x40
	// Position of P7 field.
	PIO_IER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IER_P7_Msk = 0x80
	// Bit P7.
	PIO_IER_P7 = 0x80
	// Position of P8 field.
	PIO_IER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IER_P8_Msk = 0x100
	// Bit P8.
	PIO_IER_P8 = 0x100
	// Position of P9 field.
	PIO_IER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IER_P9_Msk = 0x200
	// Bit P9.
	PIO_IER_P9 = 0x200
	// Position of P10 field.
	PIO_IER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IER_P10_Msk = 0x400
	// Bit P10.
	PIO_IER_P10 = 0x400
	// Position of P11 field.
	PIO_IER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IER_P11_Msk = 0x800
	// Bit P11.
	PIO_IER_P11 = 0x800
	// Position of P12 field.
	PIO_IER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IER_P12_Msk = 0x1000
	// Bit P12.
	PIO_IER_P12 = 0x1000
	// Position of P13 field.
	PIO_IER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IER_P13_Msk = 0x2000
	// Bit P13.
	PIO_IER_P13 = 0x2000
	// Position of P14 field.
	PIO_IER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IER_P14_Msk = 0x4000
	// Bit P14.
	PIO_IER_P14 = 0x4000
	// Position of P15 field.
	PIO_IER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IER_P15_Msk = 0x8000
	// Bit P15.
	PIO_IER_P15 = 0x8000
	// Position of P16 field.
	PIO_IER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IER_P16_Msk = 0x10000
	// Bit P16.
	PIO_IER_P16 = 0x10000
	// Position of P17 field.
	PIO_IER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IER_P17_Msk = 0x20000
	// Bit P17.
	PIO_IER_P17 = 0x20000
	// Position of P18 field.
	PIO_IER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IER_P18_Msk = 0x40000
	// Bit P18.
	PIO_IER_P18 = 0x40000
	// Position of P19 field.
	PIO_IER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IER_P19_Msk = 0x80000
	// Bit P19.
	PIO_IER_P19 = 0x80000
	// Position of P20 field.
	PIO_IER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IER_P20_Msk = 0x100000
	// Bit P20.
	PIO_IER_P20 = 0x100000
	// Position of P21 field.
	PIO_IER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IER_P21_Msk = 0x200000
	// Bit P21.
	PIO_IER_P21 = 0x200000
	// Position of P22 field.
	PIO_IER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IER_P22_Msk = 0x400000
	// Bit P22.
	PIO_IER_P22 = 0x400000
	// Position of P23 field.
	PIO_IER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IER_P23_Msk = 0x800000
	// Bit P23.
	PIO_IER_P23 = 0x800000
	// Position of P24 field.
	PIO_IER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IER_P24 = 0x1000000
	// Position of P25 field.
	PIO_IER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IER_P25 = 0x2000000
	// Position of P26 field.
	PIO_IER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IER_P26 = 0x4000000
	// Position of P27 field.
	PIO_IER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IER_P27 = 0x8000000
	// Position of P28 field.
	PIO_IER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IER_P28 = 0x10000000
	// Position of P29 field.
	PIO_IER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IER_P29 = 0x20000000
	// Position of P30 field.
	PIO_IER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IER_P30 = 0x40000000
	// Position of P31 field.
	PIO_IER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IER_P31 = 0x80000000

	// IDR: Interrupt Disable Register
	// Position of P0 field.
	PIO_IDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IDR_P0_Msk = 0x1
	// Bit P0.
	PIO_IDR_P0 = 0x1
	// Position of P1 field.
	PIO_IDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IDR_P1_Msk = 0x2
	// Bit P1.
	PIO_IDR_P1 = 0x2
	// Position of P2 field.
	PIO_IDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IDR_P2_Msk = 0x4
	// Bit P2.
	PIO_IDR_P2 = 0x4
	// Position of P3 field.
	PIO_IDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IDR_P3_Msk = 0x8
	// Bit P3.
	PIO_IDR_P3 = 0x8
	// Position of P4 field.
	PIO_IDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IDR_P4_Msk = 0x10
	// Bit P4.
	PIO_IDR_P4 = 0x10
	// Position of P5 field.
	PIO_IDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IDR_P5_Msk = 0x20
	// Bit P5.
	PIO_IDR_P5 = 0x20
	// Position of P6 field.
	PIO_IDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IDR_P6_Msk = 0x40
	// Bit P6.
	PIO_IDR_P6 = 0x40
	// Position of P7 field.
	PIO_IDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IDR_P7_Msk = 0x80
	// Bit P7.
	PIO_IDR_P7 = 0x80
	// Position of P8 field.
	PIO_IDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IDR_P8_Msk = 0x100
	// Bit P8.
	PIO_IDR_P8 = 0x100
	// Position of P9 field.
	PIO_IDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IDR_P9_Msk = 0x200
	// Bit P9.
	PIO_IDR_P9 = 0x200
	// Position of P10 field.
	PIO_IDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IDR_P10_Msk = 0x400
	// Bit P10.
	PIO_IDR_P10 = 0x400
	// Position of P11 field.
	PIO_IDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IDR_P11_Msk = 0x800
	// Bit P11.
	PIO_IDR_P11 = 0x800
	// Position of P12 field.
	PIO_IDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_IDR_P12 = 0x1000
	// Position of P13 field.
	PIO_IDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_IDR_P13 = 0x2000
	// Position of P14 field.
	PIO_IDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_IDR_P14 = 0x4000
	// Position of P15 field.
	PIO_IDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_IDR_P15 = 0x8000
	// Position of P16 field.
	PIO_IDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_IDR_P16 = 0x10000
	// Position of P17 field.
	PIO_IDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_IDR_P17 = 0x20000
	// Position of P18 field.
	PIO_IDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_IDR_P18 = 0x40000
	// Position of P19 field.
	PIO_IDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_IDR_P19 = 0x80000
	// Position of P20 field.
	PIO_IDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_IDR_P20 = 0x100000
	// Position of P21 field.
	PIO_IDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_IDR_P21 = 0x200000
	// Position of P22 field.
	PIO_IDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_IDR_P22 = 0x400000
	// Position of P23 field.
	PIO_IDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_IDR_P23 = 0x800000
	// Position of P24 field.
	PIO_IDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_IDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_IDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_IDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_IDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_IDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_IDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_IDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IDR_P31 = 0x80000000

	// IMR: Interrupt Mask Register
	// Position of P0 field.
	PIO_IMR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IMR_P0_Msk = 0x1
	// Bit P0.
	PIO_IMR_P0 = 0x1
	// Position of P1 field.
	PIO_IMR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IMR_P1_Msk = 0x2
	// Bit P1.
	PIO_IMR_P1 = 0x2
	// Position of P2 field.
	PIO_IMR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IMR_P2_Msk = 0x4
	// Bit P2.
	PIO_IMR_P2 = 0x4
	// Position of P3 field.
	PIO_IMR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IMR_P3_Msk = 0x8
	// Bit P3.
	PIO_IMR_P3 = 0x8
	// Position of P4 field.
	PIO_IMR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IMR_P4_Msk = 0x10
	// Bit P4.
	PIO_IMR_P4 = 0x10
	// Position of P5 field.
	PIO_IMR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IMR_P5_Msk = 0x20
	// Bit P5.
	PIO_IMR_P5 = 0x20
	// Position of P6 field.
	PIO_IMR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IMR_P6_Msk = 0x40
	// Bit P6.
	PIO_IMR_P6 = 0x40
	// Position of P7 field.
	PIO_IMR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IMR_P7_Msk = 0x80
	// Bit P7.
	PIO_IMR_P7 = 0x80
	// Position of P8 field.
	PIO_IMR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IMR_P8_Msk = 0x100
	// Bit P8.
	PIO_IMR_P8 = 0x100
	// Position of P9 field.
	PIO_IMR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IMR_P9_Msk = 0x200
	// Bit P9.
	PIO_IMR_P9 = 0x200
	// Position of P10 field.
	PIO_IMR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IMR_P10_Msk = 0x400
	// Bit P10.
	PIO_IMR_P10 = 0x400
	// Position of P11 field.
	PIO_IMR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IMR_P11_Msk = 0x800
	// Bit P11.
	PIO_IMR_P11 = 0x800
	// Position of P12 field.
	PIO_IMR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IMR_P12_Msk = 0x1000
	// Bit P12.
	PIO_IMR_P12 = 0x1000
	// Position of P13 field.
	PIO_IMR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IMR_P13_Msk = 0x2000
	// Bit P13.
	PIO_IMR_P13 = 0x2000
	// Position of P14 field.
	PIO_IMR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IMR_P14_Msk = 0x4000
	// Bit P14.
	PIO_IMR_P14 = 0x4000
	// Position of P15 field.
	PIO_IMR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IMR_P15_Msk = 0x8000
	// Bit P15.
	PIO_IMR_P15 = 0x8000
	// Position of P16 field.
	PIO_IMR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IMR_P16_Msk = 0x10000
	// Bit P16.
	PIO_IMR_P16 = 0x10000
	// Position of P17 field.
	PIO_IMR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IMR_P17_Msk = 0x20000
	// Bit P17.
	PIO_IMR_P17 = 0x20000
	// Position of P18 field.
	PIO_IMR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IMR_P18_Msk = 0x40000
	// Bit P18.
	PIO_IMR_P18 = 0x40000
	// Position of P19 field.
	PIO_IMR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IMR_P19_Msk = 0x80000
	// Bit P19.
	PIO_IMR_P19 = 0x80000
	// Position of P20 field.
	PIO_IMR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IMR_P20_Msk = 0x100000
	// Bit P20.
	PIO_IMR_P20 = 0x100000
	// Position of P21 field.
	PIO_IMR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IMR_P21_Msk = 0x200000
	// Bit P21.
	PIO_IMR_P21 = 0x200000
	// Position of P22 field.
	PIO_IMR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IMR_P22_Msk = 0x400000
	// Bit P22.
	PIO_IMR_P22 = 0x400000
	// Position of P23 field.
	PIO_IMR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IMR_P23_Msk = 0x800000
	// Bit P23.
	PIO_IMR_P23 = 0x800000
	// Position of P24 field.
	PIO_IMR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IMR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IMR_P24 = 0x1000000
	// Position of P25 field.
	PIO_IMR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IMR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IMR_P25 = 0x2000000
	// Position of P26 field.
	PIO_IMR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IMR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IMR_P26 = 0x4000000
	// Position of P27 field.
	PIO_IMR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IMR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IMR_P27 = 0x8000000
	// Position of P28 field.
	PIO_IMR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IMR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IMR_P28 = 0x10000000
	// Position of P29 field.
	PIO_IMR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IMR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IMR_P29 = 0x20000000
	// Position of P30 field.
	PIO_IMR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IMR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IMR_P30 = 0x40000000
	// Position of P31 field.
	PIO_IMR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IMR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IMR_P31 = 0x80000000

	// ISR: Interrupt Status Register
	// Position of P0 field.
	PIO_ISR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ISR_P0_Msk = 0x1
	// Bit P0.
	PIO_ISR_P0 = 0x1
	// Position of P1 field.
	PIO_ISR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ISR_P1_Msk = 0x2
	// Bit P1.
	PIO_ISR_P1 = 0x2
	// Position of P2 field.
	PIO_ISR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ISR_P2_Msk = 0x4
	// Bit P2.
	PIO_ISR_P2 = 0x4
	// Position of P3 field.
	PIO_ISR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ISR_P3_Msk = 0x8
	// Bit P3.
	PIO_ISR_P3 = 0x8
	// Position of P4 field.
	PIO_ISR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ISR_P4_Msk = 0x10
	// Bit P4.
	PIO_ISR_P4 = 0x10
	// Position of P5 field.
	PIO_ISR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ISR_P5_Msk = 0x20
	// Bit P5.
	PIO_ISR_P5 = 0x20
	// Position of P6 field.
	PIO_ISR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ISR_P6_Msk = 0x40
	// Bit P6.
	PIO_ISR_P6 = 0x40
	// Position of P7 field.
	PIO_ISR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ISR_P7_Msk = 0x80
	// Bit P7.
	PIO_ISR_P7 = 0x80
	// Position of P8 field.
	PIO_ISR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ISR_P8_Msk = 0x100
	// Bit P8.
	PIO_ISR_P8 = 0x100
	// Position of P9 field.
	PIO_ISR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ISR_P9_Msk = 0x200
	// Bit P9.
	PIO_ISR_P9 = 0x200
	// Position of P10 field.
	PIO_ISR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ISR_P10_Msk = 0x400
	// Bit P10.
	PIO_ISR_P10 = 0x400
	// Position of P11 field.
	PIO_ISR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ISR_P11_Msk = 0x800
	// Bit P11.
	PIO_ISR_P11 = 0x800
	// Position of P12 field.
	PIO_ISR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ISR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ISR_P12 = 0x1000
	// Position of P13 field.
	PIO_ISR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ISR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ISR_P13 = 0x2000
	// Position of P14 field.
	PIO_ISR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ISR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ISR_P14 = 0x4000
	// Position of P15 field.
	PIO_ISR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ISR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ISR_P15 = 0x8000
	// Position of P16 field.
	PIO_ISR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ISR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ISR_P16 = 0x10000
	// Position of P17 field.
	PIO_ISR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ISR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ISR_P17 = 0x20000
	// Position of P18 field.
	PIO_ISR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ISR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ISR_P18 = 0x40000
	// Position of P19 field.
	PIO_ISR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ISR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ISR_P19 = 0x80000
	// Position of P20 field.
	PIO_ISR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ISR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ISR_P20 = 0x100000
	// Position of P21 field.
	PIO_ISR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ISR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ISR_P21 = 0x200000
	// Position of P22 field.
	PIO_ISR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ISR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ISR_P22 = 0x400000
	// Position of P23 field.
	PIO_ISR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ISR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ISR_P23 = 0x800000
	// Position of P24 field.
	PIO_ISR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ISR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ISR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ISR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ISR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ISR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ISR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ISR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ISR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ISR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ISR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ISR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ISR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ISR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ISR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ISR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ISR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ISR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ISR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ISR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ISR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ISR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ISR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ISR_P31 = 0x80000000

	// MDER: Multi-driver Enable Register
	// Position of P0 field.
	PIO_MDER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_MDER_P0_Msk = 0x1
	// Bit P0.
	PIO_MDER_P0 = 0x1
	// Position of P1 field.
	PIO_MDER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_MDER_P1_Msk = 0x2
	// Bit P1.
	PIO_MDER_P1 = 0x2
	// Position of P2 field.
	PIO_MDER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_MDER_P2_Msk = 0x4
	// Bit P2.
	PIO_MDER_P2 = 0x4
	// Position of P3 field.
	PIO_MDER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_MDER_P3_Msk = 0x8
	// Bit P3.
	PIO_MDER_P3 = 0x8
	// Position of P4 field.
	PIO_MDER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_MDER_P4_Msk = 0x10
	// Bit P4.
	PIO_MDER_P4 = 0x10
	// Position of P5 field.
	PIO_MDER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_MDER_P5_Msk = 0x20
	// Bit P5.
	PIO_MDER_P5 = 0x20
	// Position of P6 field.
	PIO_MDER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_MDER_P6_Msk = 0x40
	// Bit P6.
	PIO_MDER_P6 = 0x40
	// Position of P7 field.
	PIO_MDER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_MDER_P7_Msk = 0x80
	// Bit P7.
	PIO_MDER_P7 = 0x80
	// Position of P8 field.
	PIO_MDER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_MDER_P8_Msk = 0x100
	// Bit P8.
	PIO_MDER_P8 = 0x100
	// Position of P9 field.
	PIO_MDER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_MDER_P9_Msk = 0x200
	// Bit P9.
	PIO_MDER_P9 = 0x200
	// Position of P10 field.
	PIO_MDER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_MDER_P10_Msk = 0x400
	// Bit P10.
	PIO_MDER_P10 = 0x400
	// Position of P11 field.
	PIO_MDER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_MDER_P11_Msk = 0x800
	// Bit P11.
	PIO_MDER_P11 = 0x800
	// Position of P12 field.
	PIO_MDER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_MDER_P12_Msk = 0x1000
	// Bit P12.
	PIO_MDER_P12 = 0x1000
	// Position of P13 field.
	PIO_MDER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_MDER_P13_Msk = 0x2000
	// Bit P13.
	PIO_MDER_P13 = 0x2000
	// Position of P14 field.
	PIO_MDER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_MDER_P14_Msk = 0x4000
	// Bit P14.
	PIO_MDER_P14 = 0x4000
	// Position of P15 field.
	PIO_MDER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_MDER_P15_Msk = 0x8000
	// Bit P15.
	PIO_MDER_P15 = 0x8000
	// Position of P16 field.
	PIO_MDER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_MDER_P16_Msk = 0x10000
	// Bit P16.
	PIO_MDER_P16 = 0x10000
	// Position of P17 field.
	PIO_MDER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_MDER_P17_Msk = 0x20000
	// Bit P17.
	PIO_MDER_P17 = 0x20000
	// Position of P18 field.
	PIO_MDER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_MDER_P18_Msk = 0x40000
	// Bit P18.
	PIO_MDER_P18 = 0x40000
	// Position of P19 field.
	PIO_MDER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_MDER_P19_Msk = 0x80000
	// Bit P19.
	PIO_MDER_P19 = 0x80000
	// Position of P20 field.
	PIO_MDER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_MDER_P20_Msk = 0x100000
	// Bit P20.
	PIO_MDER_P20 = 0x100000
	// Position of P21 field.
	PIO_MDER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_MDER_P21_Msk = 0x200000
	// Bit P21.
	PIO_MDER_P21 = 0x200000
	// Position of P22 field.
	PIO_MDER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_MDER_P22_Msk = 0x400000
	// Bit P22.
	PIO_MDER_P22 = 0x400000
	// Position of P23 field.
	PIO_MDER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_MDER_P23_Msk = 0x800000
	// Bit P23.
	PIO_MDER_P23 = 0x800000
	// Position of P24 field.
	PIO_MDER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_MDER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_MDER_P24 = 0x1000000
	// Position of P25 field.
	PIO_MDER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_MDER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_MDER_P25 = 0x2000000
	// Position of P26 field.
	PIO_MDER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_MDER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_MDER_P26 = 0x4000000
	// Position of P27 field.
	PIO_MDER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_MDER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_MDER_P27 = 0x8000000
	// Position of P28 field.
	PIO_MDER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_MDER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_MDER_P28 = 0x10000000
	// Position of P29 field.
	PIO_MDER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_MDER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_MDER_P29 = 0x20000000
	// Position of P30 field.
	PIO_MDER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_MDER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_MDER_P30 = 0x40000000
	// Position of P31 field.
	PIO_MDER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_MDER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_MDER_P31 = 0x80000000

	// MDDR: Multi-driver Disable Register
	// Position of P0 field.
	PIO_MDDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_MDDR_P0_Msk = 0x1
	// Bit P0.
	PIO_MDDR_P0 = 0x1
	// Position of P1 field.
	PIO_MDDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_MDDR_P1_Msk = 0x2
	// Bit P1.
	PIO_MDDR_P1 = 0x2
	// Position of P2 field.
	PIO_MDDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_MDDR_P2_Msk = 0x4
	// Bit P2.
	PIO_MDDR_P2 = 0x4
	// Position of P3 field.
	PIO_MDDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_MDDR_P3_Msk = 0x8
	// Bit P3.
	PIO_MDDR_P3 = 0x8
	// Position of P4 field.
	PIO_MDDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_MDDR_P4_Msk = 0x10
	// Bit P4.
	PIO_MDDR_P4 = 0x10
	// Position of P5 field.
	PIO_MDDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_MDDR_P5_Msk = 0x20
	// Bit P5.
	PIO_MDDR_P5 = 0x20
	// Position of P6 field.
	PIO_MDDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_MDDR_P6_Msk = 0x40
	// Bit P6.
	PIO_MDDR_P6 = 0x40
	// Position of P7 field.
	PIO_MDDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_MDDR_P7_Msk = 0x80
	// Bit P7.
	PIO_MDDR_P7 = 0x80
	// Position of P8 field.
	PIO_MDDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_MDDR_P8_Msk = 0x100
	// Bit P8.
	PIO_MDDR_P8 = 0x100
	// Position of P9 field.
	PIO_MDDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_MDDR_P9_Msk = 0x200
	// Bit P9.
	PIO_MDDR_P9 = 0x200
	// Position of P10 field.
	PIO_MDDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_MDDR_P10_Msk = 0x400
	// Bit P10.
	PIO_MDDR_P10 = 0x400
	// Position of P11 field.
	PIO_MDDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_MDDR_P11_Msk = 0x800
	// Bit P11.
	PIO_MDDR_P11 = 0x800
	// Position of P12 field.
	PIO_MDDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_MDDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_MDDR_P12 = 0x1000
	// Position of P13 field.
	PIO_MDDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_MDDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_MDDR_P13 = 0x2000
	// Position of P14 field.
	PIO_MDDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_MDDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_MDDR_P14 = 0x4000
	// Position of P15 field.
	PIO_MDDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_MDDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_MDDR_P15 = 0x8000
	// Position of P16 field.
	PIO_MDDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_MDDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_MDDR_P16 = 0x10000
	// Position of P17 field.
	PIO_MDDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_MDDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_MDDR_P17 = 0x20000
	// Position of P18 field.
	PIO_MDDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_MDDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_MDDR_P18 = 0x40000
	// Position of P19 field.
	PIO_MDDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_MDDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_MDDR_P19 = 0x80000
	// Position of P20 field.
	PIO_MDDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_MDDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_MDDR_P20 = 0x100000
	// Position of P21 field.
	PIO_MDDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_MDDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_MDDR_P21 = 0x200000
	// Position of P22 field.
	PIO_MDDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_MDDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_MDDR_P22 = 0x400000
	// Position of P23 field.
	PIO_MDDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_MDDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_MDDR_P23 = 0x800000
	// Position of P24 field.
	PIO_MDDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_MDDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_MDDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_MDDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_MDDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_MDDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_MDDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_MDDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_MDDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_MDDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_MDDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_MDDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_MDDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_MDDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_MDDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_MDDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_MDDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_MDDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_MDDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_MDDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_MDDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_MDDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_MDDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_MDDR_P31 = 0x80000000

	// MDSR: Multi-driver Status Register
	// Position of P0 field.
	PIO_MDSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_MDSR_P0_Msk = 0x1
	// Bit P0.
	PIO_MDSR_P0 = 0x1
	// Position of P1 field.
	PIO_MDSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_MDSR_P1_Msk = 0x2
	// Bit P1.
	PIO_MDSR_P1 = 0x2
	// Position of P2 field.
	PIO_MDSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_MDSR_P2_Msk = 0x4
	// Bit P2.
	PIO_MDSR_P2 = 0x4
	// Position of P3 field.
	PIO_MDSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_MDSR_P3_Msk = 0x8
	// Bit P3.
	PIO_MDSR_P3 = 0x8
	// Position of P4 field.
	PIO_MDSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_MDSR_P4_Msk = 0x10
	// Bit P4.
	PIO_MDSR_P4 = 0x10
	// Position of P5 field.
	PIO_MDSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_MDSR_P5_Msk = 0x20
	// Bit P5.
	PIO_MDSR_P5 = 0x20
	// Position of P6 field.
	PIO_MDSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_MDSR_P6_Msk = 0x40
	// Bit P6.
	PIO_MDSR_P6 = 0x40
	// Position of P7 field.
	PIO_MDSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_MDSR_P7_Msk = 0x80
	// Bit P7.
	PIO_MDSR_P7 = 0x80
	// Position of P8 field.
	PIO_MDSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_MDSR_P8_Msk = 0x100
	// Bit P8.
	PIO_MDSR_P8 = 0x100
	// Position of P9 field.
	PIO_MDSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_MDSR_P9_Msk = 0x200
	// Bit P9.
	PIO_MDSR_P9 = 0x200
	// Position of P10 field.
	PIO_MDSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_MDSR_P10_Msk = 0x400
	// Bit P10.
	PIO_MDSR_P10 = 0x400
	// Position of P11 field.
	PIO_MDSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_MDSR_P11_Msk = 0x800
	// Bit P11.
	PIO_MDSR_P11 = 0x800
	// Position of P12 field.
	PIO_MDSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_MDSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_MDSR_P12 = 0x1000
	// Position of P13 field.
	PIO_MDSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_MDSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_MDSR_P13 = 0x2000
	// Position of P14 field.
	PIO_MDSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_MDSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_MDSR_P14 = 0x4000
	// Position of P15 field.
	PIO_MDSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_MDSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_MDSR_P15 = 0x8000
	// Position of P16 field.
	PIO_MDSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_MDSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_MDSR_P16 = 0x10000
	// Position of P17 field.
	PIO_MDSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_MDSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_MDSR_P17 = 0x20000
	// Position of P18 field.
	PIO_MDSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_MDSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_MDSR_P18 = 0x40000
	// Position of P19 field.
	PIO_MDSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_MDSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_MDSR_P19 = 0x80000
	// Position of P20 field.
	PIO_MDSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_MDSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_MDSR_P20 = 0x100000
	// Position of P21 field.
	PIO_MDSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_MDSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_MDSR_P21 = 0x200000
	// Position of P22 field.
	PIO_MDSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_MDSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_MDSR_P22 = 0x400000
	// Position of P23 field.
	PIO_MDSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_MDSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_MDSR_P23 = 0x800000
	// Position of P24 field.
	PIO_MDSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_MDSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_MDSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_MDSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_MDSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_MDSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_MDSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_MDSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_MDSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_MDSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_MDSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_MDSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_MDSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_MDSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_MDSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_MDSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_MDSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_MDSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_MDSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_MDSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_MDSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_MDSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_MDSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_MDSR_P31 = 0x80000000

	// PUDR: Pull-up Disable Register
	// Position of P0 field.
	PIO_PUDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PUDR_P0_Msk = 0x1
	// Bit P0.
	PIO_PUDR_P0 = 0x1
	// Position of P1 field.
	PIO_PUDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PUDR_P1_Msk = 0x2
	// Bit P1.
	PIO_PUDR_P1 = 0x2
	// Position of P2 field.
	PIO_PUDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PUDR_P2_Msk = 0x4
	// Bit P2.
	PIO_PUDR_P2 = 0x4
	// Position of P3 field.
	PIO_PUDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PUDR_P3_Msk = 0x8
	// Bit P3.
	PIO_PUDR_P3 = 0x8
	// Position of P4 field.
	PIO_PUDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PUDR_P4_Msk = 0x10
	// Bit P4.
	PIO_PUDR_P4 = 0x10
	// Position of P5 field.
	PIO_PUDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PUDR_P5_Msk = 0x20
	// Bit P5.
	PIO_PUDR_P5 = 0x20
	// Position of P6 field.
	PIO_PUDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PUDR_P6_Msk = 0x40
	// Bit P6.
	PIO_PUDR_P6 = 0x40
	// Position of P7 field.
	PIO_PUDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PUDR_P7_Msk = 0x80
	// Bit P7.
	PIO_PUDR_P7 = 0x80
	// Position of P8 field.
	PIO_PUDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PUDR_P8_Msk = 0x100
	// Bit P8.
	PIO_PUDR_P8 = 0x100
	// Position of P9 field.
	PIO_PUDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PUDR_P9_Msk = 0x200
	// Bit P9.
	PIO_PUDR_P9 = 0x200
	// Position of P10 field.
	PIO_PUDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PUDR_P10_Msk = 0x400
	// Bit P10.
	PIO_PUDR_P10 = 0x400
	// Position of P11 field.
	PIO_PUDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PUDR_P11_Msk = 0x800
	// Bit P11.
	PIO_PUDR_P11 = 0x800
	// Position of P12 field.
	PIO_PUDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PUDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PUDR_P12 = 0x1000
	// Position of P13 field.
	PIO_PUDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PUDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PUDR_P13 = 0x2000
	// Position of P14 field.
	PIO_PUDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PUDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PUDR_P14 = 0x4000
	// Position of P15 field.
	PIO_PUDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PUDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PUDR_P15 = 0x8000
	// Position of P16 field.
	PIO_PUDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PUDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PUDR_P16 = 0x10000
	// Position of P17 field.
	PIO_PUDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PUDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PUDR_P17 = 0x20000
	// Position of P18 field.
	PIO_PUDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PUDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PUDR_P18 = 0x40000
	// Position of P19 field.
	PIO_PUDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PUDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PUDR_P19 = 0x80000
	// Position of P20 field.
	PIO_PUDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PUDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PUDR_P20 = 0x100000
	// Position of P21 field.
	PIO_PUDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PUDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PUDR_P21 = 0x200000
	// Position of P22 field.
	PIO_PUDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PUDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PUDR_P22 = 0x400000
	// Position of P23 field.
	PIO_PUDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PUDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PUDR_P23 = 0x800000
	// Position of P24 field.
	PIO_PUDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PUDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PUDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PUDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PUDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PUDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PUDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PUDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PUDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PUDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PUDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PUDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PUDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PUDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PUDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PUDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PUDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PUDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PUDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PUDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PUDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PUDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PUDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PUDR_P31 = 0x80000000

	// PUER: Pull-up Enable Register
	// Position of P0 field.
	PIO_PUER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PUER_P0_Msk = 0x1
	// Bit P0.
	PIO_PUER_P0 = 0x1
	// Position of P1 field.
	PIO_PUER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PUER_P1_Msk = 0x2
	// Bit P1.
	PIO_PUER_P1 = 0x2
	// Position of P2 field.
	PIO_PUER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PUER_P2_Msk = 0x4
	// Bit P2.
	PIO_PUER_P2 = 0x4
	// Position of P3 field.
	PIO_PUER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PUER_P3_Msk = 0x8
	// Bit P3.
	PIO_PUER_P3 = 0x8
	// Position of P4 field.
	PIO_PUER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PUER_P4_Msk = 0x10
	// Bit P4.
	PIO_PUER_P4 = 0x10
	// Position of P5 field.
	PIO_PUER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PUER_P5_Msk = 0x20
	// Bit P5.
	PIO_PUER_P5 = 0x20
	// Position of P6 field.
	PIO_PUER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PUER_P6_Msk = 0x40
	// Bit P6.
	PIO_PUER_P6 = 0x40
	// Position of P7 field.
	PIO_PUER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PUER_P7_Msk = 0x80
	// Bit P7.
	PIO_PUER_P7 = 0x80
	// Position of P8 field.
	PIO_PUER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PUER_P8_Msk = 0x100
	// Bit P8.
	PIO_PUER_P8 = 0x100
	// Position of P9 field.
	PIO_PUER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PUER_P9_Msk = 0x200
	// Bit P9.
	PIO_PUER_P9 = 0x200
	// Position of P10 field.
	PIO_PUER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PUER_P10_Msk = 0x400
	// Bit P10.
	PIO_PUER_P10 = 0x400
	// Position of P11 field.
	PIO_PUER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PUER_P11_Msk = 0x800
	// Bit P11.
	PIO_PUER_P11 = 0x800
	// Position of P12 field.
	PIO_PUER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PUER_P12_Msk = 0x1000
	// Bit P12.
	PIO_PUER_P12 = 0x1000
	// Position of P13 field.
	PIO_PUER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PUER_P13_Msk = 0x2000
	// Bit P13.
	PIO_PUER_P13 = 0x2000
	// Position of P14 field.
	PIO_PUER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PUER_P14_Msk = 0x4000
	// Bit P14.
	PIO_PUER_P14 = 0x4000
	// Position of P15 field.
	PIO_PUER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PUER_P15_Msk = 0x8000
	// Bit P15.
	PIO_PUER_P15 = 0x8000
	// Position of P16 field.
	PIO_PUER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PUER_P16_Msk = 0x10000
	// Bit P16.
	PIO_PUER_P16 = 0x10000
	// Position of P17 field.
	PIO_PUER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PUER_P17_Msk = 0x20000
	// Bit P17.
	PIO_PUER_P17 = 0x20000
	// Position of P18 field.
	PIO_PUER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PUER_P18_Msk = 0x40000
	// Bit P18.
	PIO_PUER_P18 = 0x40000
	// Position of P19 field.
	PIO_PUER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PUER_P19_Msk = 0x80000
	// Bit P19.
	PIO_PUER_P19 = 0x80000
	// Position of P20 field.
	PIO_PUER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PUER_P20_Msk = 0x100000
	// Bit P20.
	PIO_PUER_P20 = 0x100000
	// Position of P21 field.
	PIO_PUER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PUER_P21_Msk = 0x200000
	// Bit P21.
	PIO_PUER_P21 = 0x200000
	// Position of P22 field.
	PIO_PUER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PUER_P22_Msk = 0x400000
	// Bit P22.
	PIO_PUER_P22 = 0x400000
	// Position of P23 field.
	PIO_PUER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PUER_P23_Msk = 0x800000
	// Bit P23.
	PIO_PUER_P23 = 0x800000
	// Position of P24 field.
	PIO_PUER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PUER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PUER_P24 = 0x1000000
	// Position of P25 field.
	PIO_PUER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PUER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PUER_P25 = 0x2000000
	// Position of P26 field.
	PIO_PUER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PUER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PUER_P26 = 0x4000000
	// Position of P27 field.
	PIO_PUER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PUER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PUER_P27 = 0x8000000
	// Position of P28 field.
	PIO_PUER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PUER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PUER_P28 = 0x10000000
	// Position of P29 field.
	PIO_PUER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PUER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PUER_P29 = 0x20000000
	// Position of P30 field.
	PIO_PUER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PUER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PUER_P30 = 0x40000000
	// Position of P31 field.
	PIO_PUER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PUER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PUER_P31 = 0x80000000

	// PUSR: Pad Pull-up Status Register
	// Position of P0 field.
	PIO_PUSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PUSR_P0_Msk = 0x1
	// Bit P0.
	PIO_PUSR_P0 = 0x1
	// Position of P1 field.
	PIO_PUSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PUSR_P1_Msk = 0x2
	// Bit P1.
	PIO_PUSR_P1 = 0x2
	// Position of P2 field.
	PIO_PUSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PUSR_P2_Msk = 0x4
	// Bit P2.
	PIO_PUSR_P2 = 0x4
	// Position of P3 field.
	PIO_PUSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PUSR_P3_Msk = 0x8
	// Bit P3.
	PIO_PUSR_P3 = 0x8
	// Position of P4 field.
	PIO_PUSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PUSR_P4_Msk = 0x10
	// Bit P4.
	PIO_PUSR_P4 = 0x10
	// Position of P5 field.
	PIO_PUSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PUSR_P5_Msk = 0x20
	// Bit P5.
	PIO_PUSR_P5 = 0x20
	// Position of P6 field.
	PIO_PUSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PUSR_P6_Msk = 0x40
	// Bit P6.
	PIO_PUSR_P6 = 0x40
	// Position of P7 field.
	PIO_PUSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PUSR_P7_Msk = 0x80
	// Bit P7.
	PIO_PUSR_P7 = 0x80
	// Position of P8 field.
	PIO_PUSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PUSR_P8_Msk = 0x100
	// Bit P8.
	PIO_PUSR_P8 = 0x100
	// Position of P9 field.
	PIO_PUSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PUSR_P9_Msk = 0x200
	// Bit P9.
	PIO_PUSR_P9 = 0x200
	// Position of P10 field.
	PIO_PUSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PUSR_P10_Msk = 0x400
	// Bit P10.
	PIO_PUSR_P10 = 0x400
	// Position of P11 field.
	PIO_PUSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PUSR_P11_Msk = 0x800
	// Bit P11.
	PIO_PUSR_P11 = 0x800
	// Position of P12 field.
	PIO_PUSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PUSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PUSR_P12 = 0x1000
	// Position of P13 field.
	PIO_PUSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PUSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PUSR_P13 = 0x2000
	// Position of P14 field.
	PIO_PUSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PUSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PUSR_P14 = 0x4000
	// Position of P15 field.
	PIO_PUSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PUSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PUSR_P15 = 0x8000
	// Position of P16 field.
	PIO_PUSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PUSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PUSR_P16 = 0x10000
	// Position of P17 field.
	PIO_PUSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PUSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PUSR_P17 = 0x20000
	// Position of P18 field.
	PIO_PUSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PUSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PUSR_P18 = 0x40000
	// Position of P19 field.
	PIO_PUSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PUSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PUSR_P19 = 0x80000
	// Position of P20 field.
	PIO_PUSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PUSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PUSR_P20 = 0x100000
	// Position of P21 field.
	PIO_PUSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PUSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PUSR_P21 = 0x200000
	// Position of P22 field.
	PIO_PUSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PUSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PUSR_P22 = 0x400000
	// Position of P23 field.
	PIO_PUSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PUSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PUSR_P23 = 0x800000
	// Position of P24 field.
	PIO_PUSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PUSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PUSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PUSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PUSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PUSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PUSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PUSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PUSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PUSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PUSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PUSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PUSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PUSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PUSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PUSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PUSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PUSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PUSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PUSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PUSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PUSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PUSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PUSR_P31 = 0x80000000

	// ABCDSR: Peripheral Select Register
	// Position of P0 field.
	PIO_ABCDSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ABCDSR_P0_Msk = 0x1
	// Bit P0.
	PIO_ABCDSR_P0 = 0x1
	// Position of P1 field.
	PIO_ABCDSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ABCDSR_P1_Msk = 0x2
	// Bit P1.
	PIO_ABCDSR_P1 = 0x2
	// Position of P2 field.
	PIO_ABCDSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ABCDSR_P2_Msk = 0x4
	// Bit P2.
	PIO_ABCDSR_P2 = 0x4
	// Position of P3 field.
	PIO_ABCDSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ABCDSR_P3_Msk = 0x8
	// Bit P3.
	PIO_ABCDSR_P3 = 0x8
	// Position of P4 field.
	PIO_ABCDSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ABCDSR_P4_Msk = 0x10
	// Bit P4.
	PIO_ABCDSR_P4 = 0x10
	// Position of P5 field.
	PIO_ABCDSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ABCDSR_P5_Msk = 0x20
	// Bit P5.
	PIO_ABCDSR_P5 = 0x20
	// Position of P6 field.
	PIO_ABCDSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ABCDSR_P6_Msk = 0x40
	// Bit P6.
	PIO_ABCDSR_P6 = 0x40
	// Position of P7 field.
	PIO_ABCDSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ABCDSR_P7_Msk = 0x80
	// Bit P7.
	PIO_ABCDSR_P7 = 0x80
	// Position of P8 field.
	PIO_ABCDSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ABCDSR_P8_Msk = 0x100
	// Bit P8.
	PIO_ABCDSR_P8 = 0x100
	// Position of P9 field.
	PIO_ABCDSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ABCDSR_P9_Msk = 0x200
	// Bit P9.
	PIO_ABCDSR_P9 = 0x200
	// Position of P10 field.
	PIO_ABCDSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ABCDSR_P10_Msk = 0x400
	// Bit P10.
	PIO_ABCDSR_P10 = 0x400
	// Position of P11 field.
	PIO_ABCDSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ABCDSR_P11_Msk = 0x800
	// Bit P11.
	PIO_ABCDSR_P11 = 0x800
	// Position of P12 field.
	PIO_ABCDSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ABCDSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ABCDSR_P12 = 0x1000
	// Position of P13 field.
	PIO_ABCDSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ABCDSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ABCDSR_P13 = 0x2000
	// Position of P14 field.
	PIO_ABCDSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ABCDSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ABCDSR_P14 = 0x4000
	// Position of P15 field.
	PIO_ABCDSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ABCDSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ABCDSR_P15 = 0x8000
	// Position of P16 field.
	PIO_ABCDSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ABCDSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ABCDSR_P16 = 0x10000
	// Position of P17 field.
	PIO_ABCDSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ABCDSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ABCDSR_P17 = 0x20000
	// Position of P18 field.
	PIO_ABCDSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ABCDSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ABCDSR_P18 = 0x40000
	// Position of P19 field.
	PIO_ABCDSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ABCDSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ABCDSR_P19 = 0x80000
	// Position of P20 field.
	PIO_ABCDSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ABCDSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ABCDSR_P20 = 0x100000
	// Position of P21 field.
	PIO_ABCDSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ABCDSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ABCDSR_P21 = 0x200000
	// Position of P22 field.
	PIO_ABCDSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ABCDSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ABCDSR_P22 = 0x400000
	// Position of P23 field.
	PIO_ABCDSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ABCDSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ABCDSR_P23 = 0x800000
	// Position of P24 field.
	PIO_ABCDSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ABCDSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ABCDSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ABCDSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ABCDSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ABCDSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ABCDSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ABCDSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ABCDSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ABCDSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ABCDSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ABCDSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ABCDSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ABCDSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ABCDSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ABCDSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ABCDSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ABCDSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ABCDSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ABCDSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ABCDSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ABCDSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ABCDSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ABCDSR_P31 = 0x80000000

	// IFSCDR: Input Filter Slow Clock Disable Register
	// Position of P0 field.
	PIO_IFSCDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IFSCDR_P0_Msk = 0x1
	// Bit P0.
	PIO_IFSCDR_P0 = 0x1
	// Position of P1 field.
	PIO_IFSCDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IFSCDR_P1_Msk = 0x2
	// Bit P1.
	PIO_IFSCDR_P1 = 0x2
	// Position of P2 field.
	PIO_IFSCDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IFSCDR_P2_Msk = 0x4
	// Bit P2.
	PIO_IFSCDR_P2 = 0x4
	// Position of P3 field.
	PIO_IFSCDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IFSCDR_P3_Msk = 0x8
	// Bit P3.
	PIO_IFSCDR_P3 = 0x8
	// Position of P4 field.
	PIO_IFSCDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IFSCDR_P4_Msk = 0x10
	// Bit P4.
	PIO_IFSCDR_P4 = 0x10
	// Position of P5 field.
	PIO_IFSCDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IFSCDR_P5_Msk = 0x20
	// Bit P5.
	PIO_IFSCDR_P5 = 0x20
	// Position of P6 field.
	PIO_IFSCDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IFSCDR_P6_Msk = 0x40
	// Bit P6.
	PIO_IFSCDR_P6 = 0x40
	// Position of P7 field.
	PIO_IFSCDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IFSCDR_P7_Msk = 0x80
	// Bit P7.
	PIO_IFSCDR_P7 = 0x80
	// Position of P8 field.
	PIO_IFSCDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IFSCDR_P8_Msk = 0x100
	// Bit P8.
	PIO_IFSCDR_P8 = 0x100
	// Position of P9 field.
	PIO_IFSCDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IFSCDR_P9_Msk = 0x200
	// Bit P9.
	PIO_IFSCDR_P9 = 0x200
	// Position of P10 field.
	PIO_IFSCDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IFSCDR_P10_Msk = 0x400
	// Bit P10.
	PIO_IFSCDR_P10 = 0x400
	// Position of P11 field.
	PIO_IFSCDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IFSCDR_P11_Msk = 0x800
	// Bit P11.
	PIO_IFSCDR_P11 = 0x800
	// Position of P12 field.
	PIO_IFSCDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IFSCDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_IFSCDR_P12 = 0x1000
	// Position of P13 field.
	PIO_IFSCDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IFSCDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_IFSCDR_P13 = 0x2000
	// Position of P14 field.
	PIO_IFSCDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IFSCDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_IFSCDR_P14 = 0x4000
	// Position of P15 field.
	PIO_IFSCDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IFSCDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_IFSCDR_P15 = 0x8000
	// Position of P16 field.
	PIO_IFSCDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IFSCDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_IFSCDR_P16 = 0x10000
	// Position of P17 field.
	PIO_IFSCDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IFSCDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_IFSCDR_P17 = 0x20000
	// Position of P18 field.
	PIO_IFSCDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IFSCDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_IFSCDR_P18 = 0x40000
	// Position of P19 field.
	PIO_IFSCDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IFSCDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_IFSCDR_P19 = 0x80000
	// Position of P20 field.
	PIO_IFSCDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IFSCDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_IFSCDR_P20 = 0x100000
	// Position of P21 field.
	PIO_IFSCDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IFSCDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_IFSCDR_P21 = 0x200000
	// Position of P22 field.
	PIO_IFSCDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IFSCDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_IFSCDR_P22 = 0x400000
	// Position of P23 field.
	PIO_IFSCDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IFSCDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_IFSCDR_P23 = 0x800000
	// Position of P24 field.
	PIO_IFSCDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IFSCDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IFSCDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_IFSCDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IFSCDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IFSCDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_IFSCDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IFSCDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IFSCDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_IFSCDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IFSCDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IFSCDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_IFSCDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IFSCDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IFSCDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_IFSCDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IFSCDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IFSCDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_IFSCDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IFSCDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IFSCDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_IFSCDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IFSCDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IFSCDR_P31 = 0x80000000

	// IFSCER: Input Filter Slow Clock Enable Register
	// Position of P0 field.
	PIO_IFSCER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IFSCER_P0_Msk = 0x1
	// Bit P0.
	PIO_IFSCER_P0 = 0x1
	// Position of P1 field.
	PIO_IFSCER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IFSCER_P1_Msk = 0x2
	// Bit P1.
	PIO_IFSCER_P1 = 0x2
	// Position of P2 field.
	PIO_IFSCER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IFSCER_P2_Msk = 0x4
	// Bit P2.
	PIO_IFSCER_P2 = 0x4
	// Position of P3 field.
	PIO_IFSCER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IFSCER_P3_Msk = 0x8
	// Bit P3.
	PIO_IFSCER_P3 = 0x8
	// Position of P4 field.
	PIO_IFSCER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IFSCER_P4_Msk = 0x10
	// Bit P4.
	PIO_IFSCER_P4 = 0x10
	// Position of P5 field.
	PIO_IFSCER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IFSCER_P5_Msk = 0x20
	// Bit P5.
	PIO_IFSCER_P5 = 0x20
	// Position of P6 field.
	PIO_IFSCER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IFSCER_P6_Msk = 0x40
	// Bit P6.
	PIO_IFSCER_P6 = 0x40
	// Position of P7 field.
	PIO_IFSCER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IFSCER_P7_Msk = 0x80
	// Bit P7.
	PIO_IFSCER_P7 = 0x80
	// Position of P8 field.
	PIO_IFSCER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IFSCER_P8_Msk = 0x100
	// Bit P8.
	PIO_IFSCER_P8 = 0x100
	// Position of P9 field.
	PIO_IFSCER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IFSCER_P9_Msk = 0x200
	// Bit P9.
	PIO_IFSCER_P9 = 0x200
	// Position of P10 field.
	PIO_IFSCER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IFSCER_P10_Msk = 0x400
	// Bit P10.
	PIO_IFSCER_P10 = 0x400
	// Position of P11 field.
	PIO_IFSCER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IFSCER_P11_Msk = 0x800
	// Bit P11.
	PIO_IFSCER_P11 = 0x800
	// Position of P12 field.
	PIO_IFSCER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IFSCER_P12_Msk = 0x1000
	// Bit P12.
	PIO_IFSCER_P12 = 0x1000
	// Position of P13 field.
	PIO_IFSCER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IFSCER_P13_Msk = 0x2000
	// Bit P13.
	PIO_IFSCER_P13 = 0x2000
	// Position of P14 field.
	PIO_IFSCER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IFSCER_P14_Msk = 0x4000
	// Bit P14.
	PIO_IFSCER_P14 = 0x4000
	// Position of P15 field.
	PIO_IFSCER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IFSCER_P15_Msk = 0x8000
	// Bit P15.
	PIO_IFSCER_P15 = 0x8000
	// Position of P16 field.
	PIO_IFSCER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IFSCER_P16_Msk = 0x10000
	// Bit P16.
	PIO_IFSCER_P16 = 0x10000
	// Position of P17 field.
	PIO_IFSCER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IFSCER_P17_Msk = 0x20000
	// Bit P17.
	PIO_IFSCER_P17 = 0x20000
	// Position of P18 field.
	PIO_IFSCER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IFSCER_P18_Msk = 0x40000
	// Bit P18.
	PIO_IFSCER_P18 = 0x40000
	// Position of P19 field.
	PIO_IFSCER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IFSCER_P19_Msk = 0x80000
	// Bit P19.
	PIO_IFSCER_P19 = 0x80000
	// Position of P20 field.
	PIO_IFSCER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IFSCER_P20_Msk = 0x100000
	// Bit P20.
	PIO_IFSCER_P20 = 0x100000
	// Position of P21 field.
	PIO_IFSCER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IFSCER_P21_Msk = 0x200000
	// Bit P21.
	PIO_IFSCER_P21 = 0x200000
	// Position of P22 field.
	PIO_IFSCER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IFSCER_P22_Msk = 0x400000
	// Bit P22.
	PIO_IFSCER_P22 = 0x400000
	// Position of P23 field.
	PIO_IFSCER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IFSCER_P23_Msk = 0x800000
	// Bit P23.
	PIO_IFSCER_P23 = 0x800000
	// Position of P24 field.
	PIO_IFSCER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IFSCER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IFSCER_P24 = 0x1000000
	// Position of P25 field.
	PIO_IFSCER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IFSCER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IFSCER_P25 = 0x2000000
	// Position of P26 field.
	PIO_IFSCER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IFSCER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IFSCER_P26 = 0x4000000
	// Position of P27 field.
	PIO_IFSCER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IFSCER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IFSCER_P27 = 0x8000000
	// Position of P28 field.
	PIO_IFSCER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IFSCER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IFSCER_P28 = 0x10000000
	// Position of P29 field.
	PIO_IFSCER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IFSCER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IFSCER_P29 = 0x20000000
	// Position of P30 field.
	PIO_IFSCER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IFSCER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IFSCER_P30 = 0x40000000
	// Position of P31 field.
	PIO_IFSCER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IFSCER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IFSCER_P31 = 0x80000000

	// IFSCSR: Input Filter Slow Clock Status Register
	// Position of P0 field.
	PIO_IFSCSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_IFSCSR_P0_Msk = 0x1
	// Bit P0.
	PIO_IFSCSR_P0 = 0x1
	// Position of P1 field.
	PIO_IFSCSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_IFSCSR_P1_Msk = 0x2
	// Bit P1.
	PIO_IFSCSR_P1 = 0x2
	// Position of P2 field.
	PIO_IFSCSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_IFSCSR_P2_Msk = 0x4
	// Bit P2.
	PIO_IFSCSR_P2 = 0x4
	// Position of P3 field.
	PIO_IFSCSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_IFSCSR_P3_Msk = 0x8
	// Bit P3.
	PIO_IFSCSR_P3 = 0x8
	// Position of P4 field.
	PIO_IFSCSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_IFSCSR_P4_Msk = 0x10
	// Bit P4.
	PIO_IFSCSR_P4 = 0x10
	// Position of P5 field.
	PIO_IFSCSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_IFSCSR_P5_Msk = 0x20
	// Bit P5.
	PIO_IFSCSR_P5 = 0x20
	// Position of P6 field.
	PIO_IFSCSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_IFSCSR_P6_Msk = 0x40
	// Bit P6.
	PIO_IFSCSR_P6 = 0x40
	// Position of P7 field.
	PIO_IFSCSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_IFSCSR_P7_Msk = 0x80
	// Bit P7.
	PIO_IFSCSR_P7 = 0x80
	// Position of P8 field.
	PIO_IFSCSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_IFSCSR_P8_Msk = 0x100
	// Bit P8.
	PIO_IFSCSR_P8 = 0x100
	// Position of P9 field.
	PIO_IFSCSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_IFSCSR_P9_Msk = 0x200
	// Bit P9.
	PIO_IFSCSR_P9 = 0x200
	// Position of P10 field.
	PIO_IFSCSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_IFSCSR_P10_Msk = 0x400
	// Bit P10.
	PIO_IFSCSR_P10 = 0x400
	// Position of P11 field.
	PIO_IFSCSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_IFSCSR_P11_Msk = 0x800
	// Bit P11.
	PIO_IFSCSR_P11 = 0x800
	// Position of P12 field.
	PIO_IFSCSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_IFSCSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_IFSCSR_P12 = 0x1000
	// Position of P13 field.
	PIO_IFSCSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_IFSCSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_IFSCSR_P13 = 0x2000
	// Position of P14 field.
	PIO_IFSCSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_IFSCSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_IFSCSR_P14 = 0x4000
	// Position of P15 field.
	PIO_IFSCSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_IFSCSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_IFSCSR_P15 = 0x8000
	// Position of P16 field.
	PIO_IFSCSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_IFSCSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_IFSCSR_P16 = 0x10000
	// Position of P17 field.
	PIO_IFSCSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_IFSCSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_IFSCSR_P17 = 0x20000
	// Position of P18 field.
	PIO_IFSCSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_IFSCSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_IFSCSR_P18 = 0x40000
	// Position of P19 field.
	PIO_IFSCSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_IFSCSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_IFSCSR_P19 = 0x80000
	// Position of P20 field.
	PIO_IFSCSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_IFSCSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_IFSCSR_P20 = 0x100000
	// Position of P21 field.
	PIO_IFSCSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_IFSCSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_IFSCSR_P21 = 0x200000
	// Position of P22 field.
	PIO_IFSCSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_IFSCSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_IFSCSR_P22 = 0x400000
	// Position of P23 field.
	PIO_IFSCSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_IFSCSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_IFSCSR_P23 = 0x800000
	// Position of P24 field.
	PIO_IFSCSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_IFSCSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_IFSCSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_IFSCSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_IFSCSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_IFSCSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_IFSCSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_IFSCSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_IFSCSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_IFSCSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_IFSCSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_IFSCSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_IFSCSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_IFSCSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_IFSCSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_IFSCSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_IFSCSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_IFSCSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_IFSCSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_IFSCSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_IFSCSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_IFSCSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_IFSCSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_IFSCSR_P31 = 0x80000000

	// SCDR: Slow Clock Divider Debouncing Register
	// Position of DIV field.
	PIO_SCDR_DIV_Pos = 0x0
	// Bit mask of DIV field.
	PIO_SCDR_DIV_Msk = 0x3fff

	// PPDDR: Pad Pull-down Disable Register
	// Position of P0 field.
	PIO_PPDDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PPDDR_P0_Msk = 0x1
	// Bit P0.
	PIO_PPDDR_P0 = 0x1
	// Position of P1 field.
	PIO_PPDDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PPDDR_P1_Msk = 0x2
	// Bit P1.
	PIO_PPDDR_P1 = 0x2
	// Position of P2 field.
	PIO_PPDDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PPDDR_P2_Msk = 0x4
	// Bit P2.
	PIO_PPDDR_P2 = 0x4
	// Position of P3 field.
	PIO_PPDDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PPDDR_P3_Msk = 0x8
	// Bit P3.
	PIO_PPDDR_P3 = 0x8
	// Position of P4 field.
	PIO_PPDDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PPDDR_P4_Msk = 0x10
	// Bit P4.
	PIO_PPDDR_P4 = 0x10
	// Position of P5 field.
	PIO_PPDDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PPDDR_P5_Msk = 0x20
	// Bit P5.
	PIO_PPDDR_P5 = 0x20
	// Position of P6 field.
	PIO_PPDDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PPDDR_P6_Msk = 0x40
	// Bit P6.
	PIO_PPDDR_P6 = 0x40
	// Position of P7 field.
	PIO_PPDDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PPDDR_P7_Msk = 0x80
	// Bit P7.
	PIO_PPDDR_P7 = 0x80
	// Position of P8 field.
	PIO_PPDDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PPDDR_P8_Msk = 0x100
	// Bit P8.
	PIO_PPDDR_P8 = 0x100
	// Position of P9 field.
	PIO_PPDDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PPDDR_P9_Msk = 0x200
	// Bit P9.
	PIO_PPDDR_P9 = 0x200
	// Position of P10 field.
	PIO_PPDDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PPDDR_P10_Msk = 0x400
	// Bit P10.
	PIO_PPDDR_P10 = 0x400
	// Position of P11 field.
	PIO_PPDDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PPDDR_P11_Msk = 0x800
	// Bit P11.
	PIO_PPDDR_P11 = 0x800
	// Position of P12 field.
	PIO_PPDDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PPDDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PPDDR_P12 = 0x1000
	// Position of P13 field.
	PIO_PPDDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PPDDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PPDDR_P13 = 0x2000
	// Position of P14 field.
	PIO_PPDDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PPDDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PPDDR_P14 = 0x4000
	// Position of P15 field.
	PIO_PPDDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PPDDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PPDDR_P15 = 0x8000
	// Position of P16 field.
	PIO_PPDDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PPDDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PPDDR_P16 = 0x10000
	// Position of P17 field.
	PIO_PPDDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PPDDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PPDDR_P17 = 0x20000
	// Position of P18 field.
	PIO_PPDDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PPDDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PPDDR_P18 = 0x40000
	// Position of P19 field.
	PIO_PPDDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PPDDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PPDDR_P19 = 0x80000
	// Position of P20 field.
	PIO_PPDDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PPDDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PPDDR_P20 = 0x100000
	// Position of P21 field.
	PIO_PPDDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PPDDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PPDDR_P21 = 0x200000
	// Position of P22 field.
	PIO_PPDDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PPDDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PPDDR_P22 = 0x400000
	// Position of P23 field.
	PIO_PPDDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PPDDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PPDDR_P23 = 0x800000
	// Position of P24 field.
	PIO_PPDDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PPDDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PPDDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PPDDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PPDDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PPDDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PPDDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PPDDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PPDDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PPDDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PPDDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PPDDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PPDDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PPDDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PPDDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PPDDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PPDDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PPDDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PPDDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PPDDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PPDDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PPDDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PPDDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PPDDR_P31 = 0x80000000

	// PPDER: Pad Pull-down Enable Register
	// Position of P0 field.
	PIO_PPDER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PPDER_P0_Msk = 0x1
	// Bit P0.
	PIO_PPDER_P0 = 0x1
	// Position of P1 field.
	PIO_PPDER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PPDER_P1_Msk = 0x2
	// Bit P1.
	PIO_PPDER_P1 = 0x2
	// Position of P2 field.
	PIO_PPDER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PPDER_P2_Msk = 0x4
	// Bit P2.
	PIO_PPDER_P2 = 0x4
	// Position of P3 field.
	PIO_PPDER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PPDER_P3_Msk = 0x8
	// Bit P3.
	PIO_PPDER_P3 = 0x8
	// Position of P4 field.
	PIO_PPDER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PPDER_P4_Msk = 0x10
	// Bit P4.
	PIO_PPDER_P4 = 0x10
	// Position of P5 field.
	PIO_PPDER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PPDER_P5_Msk = 0x20
	// Bit P5.
	PIO_PPDER_P5 = 0x20
	// Position of P6 field.
	PIO_PPDER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PPDER_P6_Msk = 0x40
	// Bit P6.
	PIO_PPDER_P6 = 0x40
	// Position of P7 field.
	PIO_PPDER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PPDER_P7_Msk = 0x80
	// Bit P7.
	PIO_PPDER_P7 = 0x80
	// Position of P8 field.
	PIO_PPDER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PPDER_P8_Msk = 0x100
	// Bit P8.
	PIO_PPDER_P8 = 0x100
	// Position of P9 field.
	PIO_PPDER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PPDER_P9_Msk = 0x200
	// Bit P9.
	PIO_PPDER_P9 = 0x200
	// Position of P10 field.
	PIO_PPDER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PPDER_P10_Msk = 0x400
	// Bit P10.
	PIO_PPDER_P10 = 0x400
	// Position of P11 field.
	PIO_PPDER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PPDER_P11_Msk = 0x800
	// Bit P11.
	PIO_PPDER_P11 = 0x800
	// Position of P12 field.
	PIO_PPDER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PPDER_P12_Msk = 0x1000
	// Bit P12.
	PIO_PPDER_P12 = 0x1000
	// Position of P13 field.
	PIO_PPDER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PPDER_P13_Msk = 0x2000
	// Bit P13.
	PIO_PPDER_P13 = 0x2000
	// Position of P14 field.
	PIO_PPDER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PPDER_P14_Msk = 0x4000
	// Bit P14.
	PIO_PPDER_P14 = 0x4000
	// Position of P15 field.
	PIO_PPDER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PPDER_P15_Msk = 0x8000
	// Bit P15.
	PIO_PPDER_P15 = 0x8000
	// Position of P16 field.
	PIO_PPDER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PPDER_P16_Msk = 0x10000
	// Bit P16.
	PIO_PPDER_P16 = 0x10000
	// Position of P17 field.
	PIO_PPDER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PPDER_P17_Msk = 0x20000
	// Bit P17.
	PIO_PPDER_P17 = 0x20000
	// Position of P18 field.
	PIO_PPDER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PPDER_P18_Msk = 0x40000
	// Bit P18.
	PIO_PPDER_P18 = 0x40000
	// Position of P19 field.
	PIO_PPDER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PPDER_P19_Msk = 0x80000
	// Bit P19.
	PIO_PPDER_P19 = 0x80000
	// Position of P20 field.
	PIO_PPDER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PPDER_P20_Msk = 0x100000
	// Bit P20.
	PIO_PPDER_P20 = 0x100000
	// Position of P21 field.
	PIO_PPDER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PPDER_P21_Msk = 0x200000
	// Bit P21.
	PIO_PPDER_P21 = 0x200000
	// Position of P22 field.
	PIO_PPDER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PPDER_P22_Msk = 0x400000
	// Bit P22.
	PIO_PPDER_P22 = 0x400000
	// Position of P23 field.
	PIO_PPDER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PPDER_P23_Msk = 0x800000
	// Bit P23.
	PIO_PPDER_P23 = 0x800000
	// Position of P24 field.
	PIO_PPDER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PPDER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PPDER_P24 = 0x1000000
	// Position of P25 field.
	PIO_PPDER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PPDER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PPDER_P25 = 0x2000000
	// Position of P26 field.
	PIO_PPDER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PPDER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PPDER_P26 = 0x4000000
	// Position of P27 field.
	PIO_PPDER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PPDER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PPDER_P27 = 0x8000000
	// Position of P28 field.
	PIO_PPDER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PPDER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PPDER_P28 = 0x10000000
	// Position of P29 field.
	PIO_PPDER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PPDER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PPDER_P29 = 0x20000000
	// Position of P30 field.
	PIO_PPDER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PPDER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PPDER_P30 = 0x40000000
	// Position of P31 field.
	PIO_PPDER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PPDER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PPDER_P31 = 0x80000000

	// PPDSR: Pad Pull-down Status Register
	// Position of P0 field.
	PIO_PPDSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_PPDSR_P0_Msk = 0x1
	// Bit P0.
	PIO_PPDSR_P0 = 0x1
	// Position of P1 field.
	PIO_PPDSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_PPDSR_P1_Msk = 0x2
	// Bit P1.
	PIO_PPDSR_P1 = 0x2
	// Position of P2 field.
	PIO_PPDSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_PPDSR_P2_Msk = 0x4
	// Bit P2.
	PIO_PPDSR_P2 = 0x4
	// Position of P3 field.
	PIO_PPDSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_PPDSR_P3_Msk = 0x8
	// Bit P3.
	PIO_PPDSR_P3 = 0x8
	// Position of P4 field.
	PIO_PPDSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_PPDSR_P4_Msk = 0x10
	// Bit P4.
	PIO_PPDSR_P4 = 0x10
	// Position of P5 field.
	PIO_PPDSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_PPDSR_P5_Msk = 0x20
	// Bit P5.
	PIO_PPDSR_P5 = 0x20
	// Position of P6 field.
	PIO_PPDSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_PPDSR_P6_Msk = 0x40
	// Bit P6.
	PIO_PPDSR_P6 = 0x40
	// Position of P7 field.
	PIO_PPDSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_PPDSR_P7_Msk = 0x80
	// Bit P7.
	PIO_PPDSR_P7 = 0x80
	// Position of P8 field.
	PIO_PPDSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_PPDSR_P8_Msk = 0x100
	// Bit P8.
	PIO_PPDSR_P8 = 0x100
	// Position of P9 field.
	PIO_PPDSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_PPDSR_P9_Msk = 0x200
	// Bit P9.
	PIO_PPDSR_P9 = 0x200
	// Position of P10 field.
	PIO_PPDSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_PPDSR_P10_Msk = 0x400
	// Bit P10.
	PIO_PPDSR_P10 = 0x400
	// Position of P11 field.
	PIO_PPDSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_PPDSR_P11_Msk = 0x800
	// Bit P11.
	PIO_PPDSR_P11 = 0x800
	// Position of P12 field.
	PIO_PPDSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_PPDSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_PPDSR_P12 = 0x1000
	// Position of P13 field.
	PIO_PPDSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_PPDSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_PPDSR_P13 = 0x2000
	// Position of P14 field.
	PIO_PPDSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_PPDSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_PPDSR_P14 = 0x4000
	// Position of P15 field.
	PIO_PPDSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_PPDSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_PPDSR_P15 = 0x8000
	// Position of P16 field.
	PIO_PPDSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_PPDSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_PPDSR_P16 = 0x10000
	// Position of P17 field.
	PIO_PPDSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_PPDSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_PPDSR_P17 = 0x20000
	// Position of P18 field.
	PIO_PPDSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_PPDSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_PPDSR_P18 = 0x40000
	// Position of P19 field.
	PIO_PPDSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_PPDSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_PPDSR_P19 = 0x80000
	// Position of P20 field.
	PIO_PPDSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_PPDSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_PPDSR_P20 = 0x100000
	// Position of P21 field.
	PIO_PPDSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_PPDSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_PPDSR_P21 = 0x200000
	// Position of P22 field.
	PIO_PPDSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_PPDSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_PPDSR_P22 = 0x400000
	// Position of P23 field.
	PIO_PPDSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_PPDSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_PPDSR_P23 = 0x800000
	// Position of P24 field.
	PIO_PPDSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_PPDSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_PPDSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_PPDSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_PPDSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_PPDSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_PPDSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_PPDSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_PPDSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_PPDSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_PPDSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_PPDSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_PPDSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_PPDSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_PPDSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_PPDSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_PPDSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_PPDSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_PPDSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_PPDSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_PPDSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_PPDSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_PPDSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_PPDSR_P31 = 0x80000000

	// OWER: Output Write Enable
	// Position of P0 field.
	PIO_OWER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_OWER_P0_Msk = 0x1
	// Bit P0.
	PIO_OWER_P0 = 0x1
	// Position of P1 field.
	PIO_OWER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_OWER_P1_Msk = 0x2
	// Bit P1.
	PIO_OWER_P1 = 0x2
	// Position of P2 field.
	PIO_OWER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_OWER_P2_Msk = 0x4
	// Bit P2.
	PIO_OWER_P2 = 0x4
	// Position of P3 field.
	PIO_OWER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_OWER_P3_Msk = 0x8
	// Bit P3.
	PIO_OWER_P3 = 0x8
	// Position of P4 field.
	PIO_OWER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_OWER_P4_Msk = 0x10
	// Bit P4.
	PIO_OWER_P4 = 0x10
	// Position of P5 field.
	PIO_OWER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_OWER_P5_Msk = 0x20
	// Bit P5.
	PIO_OWER_P5 = 0x20
	// Position of P6 field.
	PIO_OWER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_OWER_P6_Msk = 0x40
	// Bit P6.
	PIO_OWER_P6 = 0x40
	// Position of P7 field.
	PIO_OWER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_OWER_P7_Msk = 0x80
	// Bit P7.
	PIO_OWER_P7 = 0x80
	// Position of P8 field.
	PIO_OWER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_OWER_P8_Msk = 0x100
	// Bit P8.
	PIO_OWER_P8 = 0x100
	// Position of P9 field.
	PIO_OWER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_OWER_P9_Msk = 0x200
	// Bit P9.
	PIO_OWER_P9 = 0x200
	// Position of P10 field.
	PIO_OWER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_OWER_P10_Msk = 0x400
	// Bit P10.
	PIO_OWER_P10 = 0x400
	// Position of P11 field.
	PIO_OWER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_OWER_P11_Msk = 0x800
	// Bit P11.
	PIO_OWER_P11 = 0x800
	// Position of P12 field.
	PIO_OWER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_OWER_P12_Msk = 0x1000
	// Bit P12.
	PIO_OWER_P12 = 0x1000
	// Position of P13 field.
	PIO_OWER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_OWER_P13_Msk = 0x2000
	// Bit P13.
	PIO_OWER_P13 = 0x2000
	// Position of P14 field.
	PIO_OWER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_OWER_P14_Msk = 0x4000
	// Bit P14.
	PIO_OWER_P14 = 0x4000
	// Position of P15 field.
	PIO_OWER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_OWER_P15_Msk = 0x8000
	// Bit P15.
	PIO_OWER_P15 = 0x8000
	// Position of P16 field.
	PIO_OWER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_OWER_P16_Msk = 0x10000
	// Bit P16.
	PIO_OWER_P16 = 0x10000
	// Position of P17 field.
	PIO_OWER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_OWER_P17_Msk = 0x20000
	// Bit P17.
	PIO_OWER_P17 = 0x20000
	// Position of P18 field.
	PIO_OWER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_OWER_P18_Msk = 0x40000
	// Bit P18.
	PIO_OWER_P18 = 0x40000
	// Position of P19 field.
	PIO_OWER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_OWER_P19_Msk = 0x80000
	// Bit P19.
	PIO_OWER_P19 = 0x80000
	// Position of P20 field.
	PIO_OWER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_OWER_P20_Msk = 0x100000
	// Bit P20.
	PIO_OWER_P20 = 0x100000
	// Position of P21 field.
	PIO_OWER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_OWER_P21_Msk = 0x200000
	// Bit P21.
	PIO_OWER_P21 = 0x200000
	// Position of P22 field.
	PIO_OWER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_OWER_P22_Msk = 0x400000
	// Bit P22.
	PIO_OWER_P22 = 0x400000
	// Position of P23 field.
	PIO_OWER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_OWER_P23_Msk = 0x800000
	// Bit P23.
	PIO_OWER_P23 = 0x800000
	// Position of P24 field.
	PIO_OWER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_OWER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_OWER_P24 = 0x1000000
	// Position of P25 field.
	PIO_OWER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_OWER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_OWER_P25 = 0x2000000
	// Position of P26 field.
	PIO_OWER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_OWER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_OWER_P26 = 0x4000000
	// Position of P27 field.
	PIO_OWER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_OWER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_OWER_P27 = 0x8000000
	// Position of P28 field.
	PIO_OWER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_OWER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_OWER_P28 = 0x10000000
	// Position of P29 field.
	PIO_OWER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_OWER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_OWER_P29 = 0x20000000
	// Position of P30 field.
	PIO_OWER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_OWER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_OWER_P30 = 0x40000000
	// Position of P31 field.
	PIO_OWER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_OWER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_OWER_P31 = 0x80000000

	// OWDR: Output Write Disable
	// Position of P0 field.
	PIO_OWDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_OWDR_P0_Msk = 0x1
	// Bit P0.
	PIO_OWDR_P0 = 0x1
	// Position of P1 field.
	PIO_OWDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_OWDR_P1_Msk = 0x2
	// Bit P1.
	PIO_OWDR_P1 = 0x2
	// Position of P2 field.
	PIO_OWDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_OWDR_P2_Msk = 0x4
	// Bit P2.
	PIO_OWDR_P2 = 0x4
	// Position of P3 field.
	PIO_OWDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_OWDR_P3_Msk = 0x8
	// Bit P3.
	PIO_OWDR_P3 = 0x8
	// Position of P4 field.
	PIO_OWDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_OWDR_P4_Msk = 0x10
	// Bit P4.
	PIO_OWDR_P4 = 0x10
	// Position of P5 field.
	PIO_OWDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_OWDR_P5_Msk = 0x20
	// Bit P5.
	PIO_OWDR_P5 = 0x20
	// Position of P6 field.
	PIO_OWDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_OWDR_P6_Msk = 0x40
	// Bit P6.
	PIO_OWDR_P6 = 0x40
	// Position of P7 field.
	PIO_OWDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_OWDR_P7_Msk = 0x80
	// Bit P7.
	PIO_OWDR_P7 = 0x80
	// Position of P8 field.
	PIO_OWDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_OWDR_P8_Msk = 0x100
	// Bit P8.
	PIO_OWDR_P8 = 0x100
	// Position of P9 field.
	PIO_OWDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_OWDR_P9_Msk = 0x200
	// Bit P9.
	PIO_OWDR_P9 = 0x200
	// Position of P10 field.
	PIO_OWDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_OWDR_P10_Msk = 0x400
	// Bit P10.
	PIO_OWDR_P10 = 0x400
	// Position of P11 field.
	PIO_OWDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_OWDR_P11_Msk = 0x800
	// Bit P11.
	PIO_OWDR_P11 = 0x800
	// Position of P12 field.
	PIO_OWDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_OWDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_OWDR_P12 = 0x1000
	// Position of P13 field.
	PIO_OWDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_OWDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_OWDR_P13 = 0x2000
	// Position of P14 field.
	PIO_OWDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_OWDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_OWDR_P14 = 0x4000
	// Position of P15 field.
	PIO_OWDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_OWDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_OWDR_P15 = 0x8000
	// Position of P16 field.
	PIO_OWDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_OWDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_OWDR_P16 = 0x10000
	// Position of P17 field.
	PIO_OWDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_OWDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_OWDR_P17 = 0x20000
	// Position of P18 field.
	PIO_OWDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_OWDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_OWDR_P18 = 0x40000
	// Position of P19 field.
	PIO_OWDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_OWDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_OWDR_P19 = 0x80000
	// Position of P20 field.
	PIO_OWDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_OWDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_OWDR_P20 = 0x100000
	// Position of P21 field.
	PIO_OWDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_OWDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_OWDR_P21 = 0x200000
	// Position of P22 field.
	PIO_OWDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_OWDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_OWDR_P22 = 0x400000
	// Position of P23 field.
	PIO_OWDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_OWDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_OWDR_P23 = 0x800000
	// Position of P24 field.
	PIO_OWDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_OWDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_OWDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_OWDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_OWDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_OWDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_OWDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_OWDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_OWDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_OWDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_OWDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_OWDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_OWDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_OWDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_OWDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_OWDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_OWDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_OWDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_OWDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_OWDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_OWDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_OWDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_OWDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_OWDR_P31 = 0x80000000

	// OWSR: Output Write Status Register
	// Position of P0 field.
	PIO_OWSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_OWSR_P0_Msk = 0x1
	// Bit P0.
	PIO_OWSR_P0 = 0x1
	// Position of P1 field.
	PIO_OWSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_OWSR_P1_Msk = 0x2
	// Bit P1.
	PIO_OWSR_P1 = 0x2
	// Position of P2 field.
	PIO_OWSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_OWSR_P2_Msk = 0x4
	// Bit P2.
	PIO_OWSR_P2 = 0x4
	// Position of P3 field.
	PIO_OWSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_OWSR_P3_Msk = 0x8
	// Bit P3.
	PIO_OWSR_P3 = 0x8
	// Position of P4 field.
	PIO_OWSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_OWSR_P4_Msk = 0x10
	// Bit P4.
	PIO_OWSR_P4 = 0x10
	// Position of P5 field.
	PIO_OWSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_OWSR_P5_Msk = 0x20
	// Bit P5.
	PIO_OWSR_P5 = 0x20
	// Position of P6 field.
	PIO_OWSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_OWSR_P6_Msk = 0x40
	// Bit P6.
	PIO_OWSR_P6 = 0x40
	// Position of P7 field.
	PIO_OWSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_OWSR_P7_Msk = 0x80
	// Bit P7.
	PIO_OWSR_P7 = 0x80
	// Position of P8 field.
	PIO_OWSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_OWSR_P8_Msk = 0x100
	// Bit P8.
	PIO_OWSR_P8 = 0x100
	// Position of P9 field.
	PIO_OWSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_OWSR_P9_Msk = 0x200
	// Bit P9.
	PIO_OWSR_P9 = 0x200
	// Position of P10 field.
	PIO_OWSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_OWSR_P10_Msk = 0x400
	// Bit P10.
	PIO_OWSR_P10 = 0x400
	// Position of P11 field.
	PIO_OWSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_OWSR_P11_Msk = 0x800
	// Bit P11.
	PIO_OWSR_P11 = 0x800
	// Position of P12 field.
	PIO_OWSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_OWSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_OWSR_P12 = 0x1000
	// Position of P13 field.
	PIO_OWSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_OWSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_OWSR_P13 = 0x2000
	// Position of P14 field.
	PIO_OWSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_OWSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_OWSR_P14 = 0x4000
	// Position of P15 field.
	PIO_OWSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_OWSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_OWSR_P15 = 0x8000
	// Position of P16 field.
	PIO_OWSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_OWSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_OWSR_P16 = 0x10000
	// Position of P17 field.
	PIO_OWSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_OWSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_OWSR_P17 = 0x20000
	// Position of P18 field.
	PIO_OWSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_OWSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_OWSR_P18 = 0x40000
	// Position of P19 field.
	PIO_OWSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_OWSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_OWSR_P19 = 0x80000
	// Position of P20 field.
	PIO_OWSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_OWSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_OWSR_P20 = 0x100000
	// Position of P21 field.
	PIO_OWSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_OWSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_OWSR_P21 = 0x200000
	// Position of P22 field.
	PIO_OWSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_OWSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_OWSR_P22 = 0x400000
	// Position of P23 field.
	PIO_OWSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_OWSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_OWSR_P23 = 0x800000
	// Position of P24 field.
	PIO_OWSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_OWSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_OWSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_OWSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_OWSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_OWSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_OWSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_OWSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_OWSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_OWSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_OWSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_OWSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_OWSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_OWSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_OWSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_OWSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_OWSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_OWSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_OWSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_OWSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_OWSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_OWSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_OWSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_OWSR_P31 = 0x80000000

	// AIMER: Additional Interrupt Modes Enable Register
	// Position of P0 field.
	PIO_AIMER_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_AIMER_P0_Msk = 0x1
	// Bit P0.
	PIO_AIMER_P0 = 0x1
	// Position of P1 field.
	PIO_AIMER_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_AIMER_P1_Msk = 0x2
	// Bit P1.
	PIO_AIMER_P1 = 0x2
	// Position of P2 field.
	PIO_AIMER_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_AIMER_P2_Msk = 0x4
	// Bit P2.
	PIO_AIMER_P2 = 0x4
	// Position of P3 field.
	PIO_AIMER_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_AIMER_P3_Msk = 0x8
	// Bit P3.
	PIO_AIMER_P3 = 0x8
	// Position of P4 field.
	PIO_AIMER_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_AIMER_P4_Msk = 0x10
	// Bit P4.
	PIO_AIMER_P4 = 0x10
	// Position of P5 field.
	PIO_AIMER_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_AIMER_P5_Msk = 0x20
	// Bit P5.
	PIO_AIMER_P5 = 0x20
	// Position of P6 field.
	PIO_AIMER_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_AIMER_P6_Msk = 0x40
	// Bit P6.
	PIO_AIMER_P6 = 0x40
	// Position of P7 field.
	PIO_AIMER_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_AIMER_P7_Msk = 0x80
	// Bit P7.
	PIO_AIMER_P7 = 0x80
	// Position of P8 field.
	PIO_AIMER_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_AIMER_P8_Msk = 0x100
	// Bit P8.
	PIO_AIMER_P8 = 0x100
	// Position of P9 field.
	PIO_AIMER_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_AIMER_P9_Msk = 0x200
	// Bit P9.
	PIO_AIMER_P9 = 0x200
	// Position of P10 field.
	PIO_AIMER_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_AIMER_P10_Msk = 0x400
	// Bit P10.
	PIO_AIMER_P10 = 0x400
	// Position of P11 field.
	PIO_AIMER_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_AIMER_P11_Msk = 0x800
	// Bit P11.
	PIO_AIMER_P11 = 0x800
	// Position of P12 field.
	PIO_AIMER_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_AIMER_P12_Msk = 0x1000
	// Bit P12.
	PIO_AIMER_P12 = 0x1000
	// Position of P13 field.
	PIO_AIMER_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_AIMER_P13_Msk = 0x2000
	// Bit P13.
	PIO_AIMER_P13 = 0x2000
	// Position of P14 field.
	PIO_AIMER_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_AIMER_P14_Msk = 0x4000
	// Bit P14.
	PIO_AIMER_P14 = 0x4000
	// Position of P15 field.
	PIO_AIMER_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_AIMER_P15_Msk = 0x8000
	// Bit P15.
	PIO_AIMER_P15 = 0x8000
	// Position of P16 field.
	PIO_AIMER_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_AIMER_P16_Msk = 0x10000
	// Bit P16.
	PIO_AIMER_P16 = 0x10000
	// Position of P17 field.
	PIO_AIMER_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_AIMER_P17_Msk = 0x20000
	// Bit P17.
	PIO_AIMER_P17 = 0x20000
	// Position of P18 field.
	PIO_AIMER_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_AIMER_P18_Msk = 0x40000
	// Bit P18.
	PIO_AIMER_P18 = 0x40000
	// Position of P19 field.
	PIO_AIMER_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_AIMER_P19_Msk = 0x80000
	// Bit P19.
	PIO_AIMER_P19 = 0x80000
	// Position of P20 field.
	PIO_AIMER_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_AIMER_P20_Msk = 0x100000
	// Bit P20.
	PIO_AIMER_P20 = 0x100000
	// Position of P21 field.
	PIO_AIMER_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_AIMER_P21_Msk = 0x200000
	// Bit P21.
	PIO_AIMER_P21 = 0x200000
	// Position of P22 field.
	PIO_AIMER_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_AIMER_P22_Msk = 0x400000
	// Bit P22.
	PIO_AIMER_P22 = 0x400000
	// Position of P23 field.
	PIO_AIMER_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_AIMER_P23_Msk = 0x800000
	// Bit P23.
	PIO_AIMER_P23 = 0x800000
	// Position of P24 field.
	PIO_AIMER_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_AIMER_P24_Msk = 0x1000000
	// Bit P24.
	PIO_AIMER_P24 = 0x1000000
	// Position of P25 field.
	PIO_AIMER_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_AIMER_P25_Msk = 0x2000000
	// Bit P25.
	PIO_AIMER_P25 = 0x2000000
	// Position of P26 field.
	PIO_AIMER_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_AIMER_P26_Msk = 0x4000000
	// Bit P26.
	PIO_AIMER_P26 = 0x4000000
	// Position of P27 field.
	PIO_AIMER_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_AIMER_P27_Msk = 0x8000000
	// Bit P27.
	PIO_AIMER_P27 = 0x8000000
	// Position of P28 field.
	PIO_AIMER_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_AIMER_P28_Msk = 0x10000000
	// Bit P28.
	PIO_AIMER_P28 = 0x10000000
	// Position of P29 field.
	PIO_AIMER_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_AIMER_P29_Msk = 0x20000000
	// Bit P29.
	PIO_AIMER_P29 = 0x20000000
	// Position of P30 field.
	PIO_AIMER_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_AIMER_P30_Msk = 0x40000000
	// Bit P30.
	PIO_AIMER_P30 = 0x40000000
	// Position of P31 field.
	PIO_AIMER_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_AIMER_P31_Msk = 0x80000000
	// Bit P31.
	PIO_AIMER_P31 = 0x80000000

	// AIMDR: Additional Interrupt Modes Disables Register
	// Position of P0 field.
	PIO_AIMDR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_AIMDR_P0_Msk = 0x1
	// Bit P0.
	PIO_AIMDR_P0 = 0x1
	// Position of P1 field.
	PIO_AIMDR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_AIMDR_P1_Msk = 0x2
	// Bit P1.
	PIO_AIMDR_P1 = 0x2
	// Position of P2 field.
	PIO_AIMDR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_AIMDR_P2_Msk = 0x4
	// Bit P2.
	PIO_AIMDR_P2 = 0x4
	// Position of P3 field.
	PIO_AIMDR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_AIMDR_P3_Msk = 0x8
	// Bit P3.
	PIO_AIMDR_P3 = 0x8
	// Position of P4 field.
	PIO_AIMDR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_AIMDR_P4_Msk = 0x10
	// Bit P4.
	PIO_AIMDR_P4 = 0x10
	// Position of P5 field.
	PIO_AIMDR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_AIMDR_P5_Msk = 0x20
	// Bit P5.
	PIO_AIMDR_P5 = 0x20
	// Position of P6 field.
	PIO_AIMDR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_AIMDR_P6_Msk = 0x40
	// Bit P6.
	PIO_AIMDR_P6 = 0x40
	// Position of P7 field.
	PIO_AIMDR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_AIMDR_P7_Msk = 0x80
	// Bit P7.
	PIO_AIMDR_P7 = 0x80
	// Position of P8 field.
	PIO_AIMDR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_AIMDR_P8_Msk = 0x100
	// Bit P8.
	PIO_AIMDR_P8 = 0x100
	// Position of P9 field.
	PIO_AIMDR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_AIMDR_P9_Msk = 0x200
	// Bit P9.
	PIO_AIMDR_P9 = 0x200
	// Position of P10 field.
	PIO_AIMDR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_AIMDR_P10_Msk = 0x400
	// Bit P10.
	PIO_AIMDR_P10 = 0x400
	// Position of P11 field.
	PIO_AIMDR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_AIMDR_P11_Msk = 0x800
	// Bit P11.
	PIO_AIMDR_P11 = 0x800
	// Position of P12 field.
	PIO_AIMDR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_AIMDR_P12_Msk = 0x1000
	// Bit P12.
	PIO_AIMDR_P12 = 0x1000
	// Position of P13 field.
	PIO_AIMDR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_AIMDR_P13_Msk = 0x2000
	// Bit P13.
	PIO_AIMDR_P13 = 0x2000
	// Position of P14 field.
	PIO_AIMDR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_AIMDR_P14_Msk = 0x4000
	// Bit P14.
	PIO_AIMDR_P14 = 0x4000
	// Position of P15 field.
	PIO_AIMDR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_AIMDR_P15_Msk = 0x8000
	// Bit P15.
	PIO_AIMDR_P15 = 0x8000
	// Position of P16 field.
	PIO_AIMDR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_AIMDR_P16_Msk = 0x10000
	// Bit P16.
	PIO_AIMDR_P16 = 0x10000
	// Position of P17 field.
	PIO_AIMDR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_AIMDR_P17_Msk = 0x20000
	// Bit P17.
	PIO_AIMDR_P17 = 0x20000
	// Position of P18 field.
	PIO_AIMDR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_AIMDR_P18_Msk = 0x40000
	// Bit P18.
	PIO_AIMDR_P18 = 0x40000
	// Position of P19 field.
	PIO_AIMDR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_AIMDR_P19_Msk = 0x80000
	// Bit P19.
	PIO_AIMDR_P19 = 0x80000
	// Position of P20 field.
	PIO_AIMDR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_AIMDR_P20_Msk = 0x100000
	// Bit P20.
	PIO_AIMDR_P20 = 0x100000
	// Position of P21 field.
	PIO_AIMDR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_AIMDR_P21_Msk = 0x200000
	// Bit P21.
	PIO_AIMDR_P21 = 0x200000
	// Position of P22 field.
	PIO_AIMDR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_AIMDR_P22_Msk = 0x400000
	// Bit P22.
	PIO_AIMDR_P22 = 0x400000
	// Position of P23 field.
	PIO_AIMDR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_AIMDR_P23_Msk = 0x800000
	// Bit P23.
	PIO_AIMDR_P23 = 0x800000
	// Position of P24 field.
	PIO_AIMDR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_AIMDR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_AIMDR_P24 = 0x1000000
	// Position of P25 field.
	PIO_AIMDR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_AIMDR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_AIMDR_P25 = 0x2000000
	// Position of P26 field.
	PIO_AIMDR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_AIMDR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_AIMDR_P26 = 0x4000000
	// Position of P27 field.
	PIO_AIMDR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_AIMDR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_AIMDR_P27 = 0x8000000
	// Position of P28 field.
	PIO_AIMDR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_AIMDR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_AIMDR_P28 = 0x10000000
	// Position of P29 field.
	PIO_AIMDR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_AIMDR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_AIMDR_P29 = 0x20000000
	// Position of P30 field.
	PIO_AIMDR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_AIMDR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_AIMDR_P30 = 0x40000000
	// Position of P31 field.
	PIO_AIMDR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_AIMDR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_AIMDR_P31 = 0x80000000

	// AIMMR: Additional Interrupt Modes Mask Register
	// Position of P0 field.
	PIO_AIMMR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_AIMMR_P0_Msk = 0x1
	// Bit P0.
	PIO_AIMMR_P0 = 0x1
	// Position of P1 field.
	PIO_AIMMR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_AIMMR_P1_Msk = 0x2
	// Bit P1.
	PIO_AIMMR_P1 = 0x2
	// Position of P2 field.
	PIO_AIMMR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_AIMMR_P2_Msk = 0x4
	// Bit P2.
	PIO_AIMMR_P2 = 0x4
	// Position of P3 field.
	PIO_AIMMR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_AIMMR_P3_Msk = 0x8
	// Bit P3.
	PIO_AIMMR_P3 = 0x8
	// Position of P4 field.
	PIO_AIMMR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_AIMMR_P4_Msk = 0x10
	// Bit P4.
	PIO_AIMMR_P4 = 0x10
	// Position of P5 field.
	PIO_AIMMR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_AIMMR_P5_Msk = 0x20
	// Bit P5.
	PIO_AIMMR_P5 = 0x20
	// Position of P6 field.
	PIO_AIMMR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_AIMMR_P6_Msk = 0x40
	// Bit P6.
	PIO_AIMMR_P6 = 0x40
	// Position of P7 field.
	PIO_AIMMR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_AIMMR_P7_Msk = 0x80
	// Bit P7.
	PIO_AIMMR_P7 = 0x80
	// Position of P8 field.
	PIO_AIMMR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_AIMMR_P8_Msk = 0x100
	// Bit P8.
	PIO_AIMMR_P8 = 0x100
	// Position of P9 field.
	PIO_AIMMR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_AIMMR_P9_Msk = 0x200
	// Bit P9.
	PIO_AIMMR_P9 = 0x200
	// Position of P10 field.
	PIO_AIMMR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_AIMMR_P10_Msk = 0x400
	// Bit P10.
	PIO_AIMMR_P10 = 0x400
	// Position of P11 field.
	PIO_AIMMR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_AIMMR_P11_Msk = 0x800
	// Bit P11.
	PIO_AIMMR_P11 = 0x800
	// Position of P12 field.
	PIO_AIMMR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_AIMMR_P12_Msk = 0x1000
	// Bit P12.
	PIO_AIMMR_P12 = 0x1000
	// Position of P13 field.
	PIO_AIMMR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_AIMMR_P13_Msk = 0x2000
	// Bit P13.
	PIO_AIMMR_P13 = 0x2000
	// Position of P14 field.
	PIO_AIMMR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_AIMMR_P14_Msk = 0x4000
	// Bit P14.
	PIO_AIMMR_P14 = 0x4000
	// Position of P15 field.
	PIO_AIMMR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_AIMMR_P15_Msk = 0x8000
	// Bit P15.
	PIO_AIMMR_P15 = 0x8000
	// Position of P16 field.
	PIO_AIMMR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_AIMMR_P16_Msk = 0x10000
	// Bit P16.
	PIO_AIMMR_P16 = 0x10000
	// Position of P17 field.
	PIO_AIMMR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_AIMMR_P17_Msk = 0x20000
	// Bit P17.
	PIO_AIMMR_P17 = 0x20000
	// Position of P18 field.
	PIO_AIMMR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_AIMMR_P18_Msk = 0x40000
	// Bit P18.
	PIO_AIMMR_P18 = 0x40000
	// Position of P19 field.
	PIO_AIMMR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_AIMMR_P19_Msk = 0x80000
	// Bit P19.
	PIO_AIMMR_P19 = 0x80000
	// Position of P20 field.
	PIO_AIMMR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_AIMMR_P20_Msk = 0x100000
	// Bit P20.
	PIO_AIMMR_P20 = 0x100000
	// Position of P21 field.
	PIO_AIMMR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_AIMMR_P21_Msk = 0x200000
	// Bit P21.
	PIO_AIMMR_P21 = 0x200000
	// Position of P22 field.
	PIO_AIMMR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_AIMMR_P22_Msk = 0x400000
	// Bit P22.
	PIO_AIMMR_P22 = 0x400000
	// Position of P23 field.
	PIO_AIMMR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_AIMMR_P23_Msk = 0x800000
	// Bit P23.
	PIO_AIMMR_P23 = 0x800000
	// Position of P24 field.
	PIO_AIMMR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_AIMMR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_AIMMR_P24 = 0x1000000
	// Position of P25 field.
	PIO_AIMMR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_AIMMR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_AIMMR_P25 = 0x2000000
	// Position of P26 field.
	PIO_AIMMR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_AIMMR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_AIMMR_P26 = 0x4000000
	// Position of P27 field.
	PIO_AIMMR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_AIMMR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_AIMMR_P27 = 0x8000000
	// Position of P28 field.
	PIO_AIMMR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_AIMMR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_AIMMR_P28 = 0x10000000
	// Position of P29 field.
	PIO_AIMMR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_AIMMR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_AIMMR_P29 = 0x20000000
	// Position of P30 field.
	PIO_AIMMR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_AIMMR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_AIMMR_P30 = 0x40000000
	// Position of P31 field.
	PIO_AIMMR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_AIMMR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_AIMMR_P31 = 0x80000000

	// ESR: Edge Select Register
	// Position of P0 field.
	PIO_ESR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ESR_P0_Msk = 0x1
	// Bit P0.
	PIO_ESR_P0 = 0x1
	// Position of P1 field.
	PIO_ESR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ESR_P1_Msk = 0x2
	// Bit P1.
	PIO_ESR_P1 = 0x2
	// Position of P2 field.
	PIO_ESR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ESR_P2_Msk = 0x4
	// Bit P2.
	PIO_ESR_P2 = 0x4
	// Position of P3 field.
	PIO_ESR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ESR_P3_Msk = 0x8
	// Bit P3.
	PIO_ESR_P3 = 0x8
	// Position of P4 field.
	PIO_ESR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ESR_P4_Msk = 0x10
	// Bit P4.
	PIO_ESR_P4 = 0x10
	// Position of P5 field.
	PIO_ESR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ESR_P5_Msk = 0x20
	// Bit P5.
	PIO_ESR_P5 = 0x20
	// Position of P6 field.
	PIO_ESR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ESR_P6_Msk = 0x40
	// Bit P6.
	PIO_ESR_P6 = 0x40
	// Position of P7 field.
	PIO_ESR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ESR_P7_Msk = 0x80
	// Bit P7.
	PIO_ESR_P7 = 0x80
	// Position of P8 field.
	PIO_ESR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ESR_P8_Msk = 0x100
	// Bit P8.
	PIO_ESR_P8 = 0x100
	// Position of P9 field.
	PIO_ESR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ESR_P9_Msk = 0x200
	// Bit P9.
	PIO_ESR_P9 = 0x200
	// Position of P10 field.
	PIO_ESR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ESR_P10_Msk = 0x400
	// Bit P10.
	PIO_ESR_P10 = 0x400
	// Position of P11 field.
	PIO_ESR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ESR_P11_Msk = 0x800
	// Bit P11.
	PIO_ESR_P11 = 0x800
	// Position of P12 field.
	PIO_ESR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ESR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ESR_P12 = 0x1000
	// Position of P13 field.
	PIO_ESR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ESR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ESR_P13 = 0x2000
	// Position of P14 field.
	PIO_ESR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ESR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ESR_P14 = 0x4000
	// Position of P15 field.
	PIO_ESR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ESR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ESR_P15 = 0x8000
	// Position of P16 field.
	PIO_ESR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ESR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ESR_P16 = 0x10000
	// Position of P17 field.
	PIO_ESR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ESR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ESR_P17 = 0x20000
	// Position of P18 field.
	PIO_ESR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ESR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ESR_P18 = 0x40000
	// Position of P19 field.
	PIO_ESR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ESR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ESR_P19 = 0x80000
	// Position of P20 field.
	PIO_ESR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ESR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ESR_P20 = 0x100000
	// Position of P21 field.
	PIO_ESR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ESR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ESR_P21 = 0x200000
	// Position of P22 field.
	PIO_ESR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ESR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ESR_P22 = 0x400000
	// Position of P23 field.
	PIO_ESR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ESR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ESR_P23 = 0x800000
	// Position of P24 field.
	PIO_ESR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ESR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ESR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ESR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ESR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ESR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ESR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ESR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ESR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ESR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ESR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ESR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ESR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ESR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ESR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ESR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ESR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ESR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ESR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ESR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ESR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ESR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ESR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ESR_P31 = 0x80000000

	// LSR: Level Select Register
	// Position of P0 field.
	PIO_LSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_LSR_P0_Msk = 0x1
	// Bit P0.
	PIO_LSR_P0 = 0x1
	// Position of P1 field.
	PIO_LSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_LSR_P1_Msk = 0x2
	// Bit P1.
	PIO_LSR_P1 = 0x2
	// Position of P2 field.
	PIO_LSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_LSR_P2_Msk = 0x4
	// Bit P2.
	PIO_LSR_P2 = 0x4
	// Position of P3 field.
	PIO_LSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_LSR_P3_Msk = 0x8
	// Bit P3.
	PIO_LSR_P3 = 0x8
	// Position of P4 field.
	PIO_LSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_LSR_P4_Msk = 0x10
	// Bit P4.
	PIO_LSR_P4 = 0x10
	// Position of P5 field.
	PIO_LSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_LSR_P5_Msk = 0x20
	// Bit P5.
	PIO_LSR_P5 = 0x20
	// Position of P6 field.
	PIO_LSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_LSR_P6_Msk = 0x40
	// Bit P6.
	PIO_LSR_P6 = 0x40
	// Position of P7 field.
	PIO_LSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_LSR_P7_Msk = 0x80
	// Bit P7.
	PIO_LSR_P7 = 0x80
	// Position of P8 field.
	PIO_LSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_LSR_P8_Msk = 0x100
	// Bit P8.
	PIO_LSR_P8 = 0x100
	// Position of P9 field.
	PIO_LSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_LSR_P9_Msk = 0x200
	// Bit P9.
	PIO_LSR_P9 = 0x200
	// Position of P10 field.
	PIO_LSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_LSR_P10_Msk = 0x400
	// Bit P10.
	PIO_LSR_P10 = 0x400
	// Position of P11 field.
	PIO_LSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_LSR_P11_Msk = 0x800
	// Bit P11.
	PIO_LSR_P11 = 0x800
	// Position of P12 field.
	PIO_LSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_LSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_LSR_P12 = 0x1000
	// Position of P13 field.
	PIO_LSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_LSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_LSR_P13 = 0x2000
	// Position of P14 field.
	PIO_LSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_LSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_LSR_P14 = 0x4000
	// Position of P15 field.
	PIO_LSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_LSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_LSR_P15 = 0x8000
	// Position of P16 field.
	PIO_LSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_LSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_LSR_P16 = 0x10000
	// Position of P17 field.
	PIO_LSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_LSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_LSR_P17 = 0x20000
	// Position of P18 field.
	PIO_LSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_LSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_LSR_P18 = 0x40000
	// Position of P19 field.
	PIO_LSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_LSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_LSR_P19 = 0x80000
	// Position of P20 field.
	PIO_LSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_LSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_LSR_P20 = 0x100000
	// Position of P21 field.
	PIO_LSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_LSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_LSR_P21 = 0x200000
	// Position of P22 field.
	PIO_LSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_LSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_LSR_P22 = 0x400000
	// Position of P23 field.
	PIO_LSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_LSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_LSR_P23 = 0x800000
	// Position of P24 field.
	PIO_LSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_LSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_LSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_LSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_LSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_LSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_LSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_LSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_LSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_LSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_LSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_LSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_LSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_LSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_LSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_LSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_LSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_LSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_LSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_LSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_LSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_LSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_LSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_LSR_P31 = 0x80000000

	// ELSR: Edge/Level Status Register
	// Position of P0 field.
	PIO_ELSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_ELSR_P0_Msk = 0x1
	// Bit P0.
	PIO_ELSR_P0 = 0x1
	// Position of P1 field.
	PIO_ELSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_ELSR_P1_Msk = 0x2
	// Bit P1.
	PIO_ELSR_P1 = 0x2
	// Position of P2 field.
	PIO_ELSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_ELSR_P2_Msk = 0x4
	// Bit P2.
	PIO_ELSR_P2 = 0x4
	// Position of P3 field.
	PIO_ELSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_ELSR_P3_Msk = 0x8
	// Bit P3.
	PIO_ELSR_P3 = 0x8
	// Position of P4 field.
	PIO_ELSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_ELSR_P4_Msk = 0x10
	// Bit P4.
	PIO_ELSR_P4 = 0x10
	// Position of P5 field.
	PIO_ELSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_ELSR_P5_Msk = 0x20
	// Bit P5.
	PIO_ELSR_P5 = 0x20
	// Position of P6 field.
	PIO_ELSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_ELSR_P6_Msk = 0x40
	// Bit P6.
	PIO_ELSR_P6 = 0x40
	// Position of P7 field.
	PIO_ELSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_ELSR_P7_Msk = 0x80
	// Bit P7.
	PIO_ELSR_P7 = 0x80
	// Position of P8 field.
	PIO_ELSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_ELSR_P8_Msk = 0x100
	// Bit P8.
	PIO_ELSR_P8 = 0x100
	// Position of P9 field.
	PIO_ELSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_ELSR_P9_Msk = 0x200
	// Bit P9.
	PIO_ELSR_P9 = 0x200
	// Position of P10 field.
	PIO_ELSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_ELSR_P10_Msk = 0x400
	// Bit P10.
	PIO_ELSR_P10 = 0x400
	// Position of P11 field.
	PIO_ELSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_ELSR_P11_Msk = 0x800
	// Bit P11.
	PIO_ELSR_P11 = 0x800
	// Position of P12 field.
	PIO_ELSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_ELSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_ELSR_P12 = 0x1000
	// Position of P13 field.
	PIO_ELSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_ELSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_ELSR_P13 = 0x2000
	// Position of P14 field.
	PIO_ELSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_ELSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_ELSR_P14 = 0x4000
	// Position of P15 field.
	PIO_ELSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_ELSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_ELSR_P15 = 0x8000
	// Position of P16 field.
	PIO_ELSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_ELSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_ELSR_P16 = 0x10000
	// Position of P17 field.
	PIO_ELSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_ELSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_ELSR_P17 = 0x20000
	// Position of P18 field.
	PIO_ELSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_ELSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_ELSR_P18 = 0x40000
	// Position of P19 field.
	PIO_ELSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_ELSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_ELSR_P19 = 0x80000
	// Position of P20 field.
	PIO_ELSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_ELSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_ELSR_P20 = 0x100000
	// Position of P21 field.
	PIO_ELSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_ELSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_ELSR_P21 = 0x200000
	// Position of P22 field.
	PIO_ELSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_ELSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_ELSR_P22 = 0x400000
	// Position of P23 field.
	PIO_ELSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_ELSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_ELSR_P23 = 0x800000
	// Position of P24 field.
	PIO_ELSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_ELSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_ELSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_ELSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_ELSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_ELSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_ELSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_ELSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_ELSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_ELSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_ELSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_ELSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_ELSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_ELSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_ELSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_ELSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_ELSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_ELSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_ELSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_ELSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_ELSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_ELSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_ELSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_ELSR_P31 = 0x80000000

	// FELLSR: Falling Edge/Low Level Select Register
	// Position of P0 field.
	PIO_FELLSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_FELLSR_P0_Msk = 0x1
	// Bit P0.
	PIO_FELLSR_P0 = 0x1
	// Position of P1 field.
	PIO_FELLSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_FELLSR_P1_Msk = 0x2
	// Bit P1.
	PIO_FELLSR_P1 = 0x2
	// Position of P2 field.
	PIO_FELLSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_FELLSR_P2_Msk = 0x4
	// Bit P2.
	PIO_FELLSR_P2 = 0x4
	// Position of P3 field.
	PIO_FELLSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_FELLSR_P3_Msk = 0x8
	// Bit P3.
	PIO_FELLSR_P3 = 0x8
	// Position of P4 field.
	PIO_FELLSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_FELLSR_P4_Msk = 0x10
	// Bit P4.
	PIO_FELLSR_P4 = 0x10
	// Position of P5 field.
	PIO_FELLSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_FELLSR_P5_Msk = 0x20
	// Bit P5.
	PIO_FELLSR_P5 = 0x20
	// Position of P6 field.
	PIO_FELLSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_FELLSR_P6_Msk = 0x40
	// Bit P6.
	PIO_FELLSR_P6 = 0x40
	// Position of P7 field.
	PIO_FELLSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_FELLSR_P7_Msk = 0x80
	// Bit P7.
	PIO_FELLSR_P7 = 0x80
	// Position of P8 field.
	PIO_FELLSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_FELLSR_P8_Msk = 0x100
	// Bit P8.
	PIO_FELLSR_P8 = 0x100
	// Position of P9 field.
	PIO_FELLSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_FELLSR_P9_Msk = 0x200
	// Bit P9.
	PIO_FELLSR_P9 = 0x200
	// Position of P10 field.
	PIO_FELLSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_FELLSR_P10_Msk = 0x400
	// Bit P10.
	PIO_FELLSR_P10 = 0x400
	// Position of P11 field.
	PIO_FELLSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_FELLSR_P11_Msk = 0x800
	// Bit P11.
	PIO_FELLSR_P11 = 0x800
	// Position of P12 field.
	PIO_FELLSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_FELLSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_FELLSR_P12 = 0x1000
	// Position of P13 field.
	PIO_FELLSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_FELLSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_FELLSR_P13 = 0x2000
	// Position of P14 field.
	PIO_FELLSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_FELLSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_FELLSR_P14 = 0x4000
	// Position of P15 field.
	PIO_FELLSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_FELLSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_FELLSR_P15 = 0x8000
	// Position of P16 field.
	PIO_FELLSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_FELLSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_FELLSR_P16 = 0x10000
	// Position of P17 field.
	PIO_FELLSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_FELLSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_FELLSR_P17 = 0x20000
	// Position of P18 field.
	PIO_FELLSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_FELLSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_FELLSR_P18 = 0x40000
	// Position of P19 field.
	PIO_FELLSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_FELLSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_FELLSR_P19 = 0x80000
	// Position of P20 field.
	PIO_FELLSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_FELLSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_FELLSR_P20 = 0x100000
	// Position of P21 field.
	PIO_FELLSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_FELLSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_FELLSR_P21 = 0x200000
	// Position of P22 field.
	PIO_FELLSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_FELLSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_FELLSR_P22 = 0x400000
	// Position of P23 field.
	PIO_FELLSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_FELLSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_FELLSR_P23 = 0x800000
	// Position of P24 field.
	PIO_FELLSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_FELLSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_FELLSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_FELLSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_FELLSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_FELLSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_FELLSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_FELLSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_FELLSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_FELLSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_FELLSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_FELLSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_FELLSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_FELLSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_FELLSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_FELLSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_FELLSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_FELLSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_FELLSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_FELLSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_FELLSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_FELLSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_FELLSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_FELLSR_P31 = 0x80000000

	// REHLSR: Rising Edge/ High Level Select Register
	// Position of P0 field.
	PIO_REHLSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_REHLSR_P0_Msk = 0x1
	// Bit P0.
	PIO_REHLSR_P0 = 0x1
	// Position of P1 field.
	PIO_REHLSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_REHLSR_P1_Msk = 0x2
	// Bit P1.
	PIO_REHLSR_P1 = 0x2
	// Position of P2 field.
	PIO_REHLSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_REHLSR_P2_Msk = 0x4
	// Bit P2.
	PIO_REHLSR_P2 = 0x4
	// Position of P3 field.
	PIO_REHLSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_REHLSR_P3_Msk = 0x8
	// Bit P3.
	PIO_REHLSR_P3 = 0x8
	// Position of P4 field.
	PIO_REHLSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_REHLSR_P4_Msk = 0x10
	// Bit P4.
	PIO_REHLSR_P4 = 0x10
	// Position of P5 field.
	PIO_REHLSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_REHLSR_P5_Msk = 0x20
	// Bit P5.
	PIO_REHLSR_P5 = 0x20
	// Position of P6 field.
	PIO_REHLSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_REHLSR_P6_Msk = 0x40
	// Bit P6.
	PIO_REHLSR_P6 = 0x40
	// Position of P7 field.
	PIO_REHLSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_REHLSR_P7_Msk = 0x80
	// Bit P7.
	PIO_REHLSR_P7 = 0x80
	// Position of P8 field.
	PIO_REHLSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_REHLSR_P8_Msk = 0x100
	// Bit P8.
	PIO_REHLSR_P8 = 0x100
	// Position of P9 field.
	PIO_REHLSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_REHLSR_P9_Msk = 0x200
	// Bit P9.
	PIO_REHLSR_P9 = 0x200
	// Position of P10 field.
	PIO_REHLSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_REHLSR_P10_Msk = 0x400
	// Bit P10.
	PIO_REHLSR_P10 = 0x400
	// Position of P11 field.
	PIO_REHLSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_REHLSR_P11_Msk = 0x800
	// Bit P11.
	PIO_REHLSR_P11 = 0x800
	// Position of P12 field.
	PIO_REHLSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_REHLSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_REHLSR_P12 = 0x1000
	// Position of P13 field.
	PIO_REHLSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_REHLSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_REHLSR_P13 = 0x2000
	// Position of P14 field.
	PIO_REHLSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_REHLSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_REHLSR_P14 = 0x4000
	// Position of P15 field.
	PIO_REHLSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_REHLSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_REHLSR_P15 = 0x8000
	// Position of P16 field.
	PIO_REHLSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_REHLSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_REHLSR_P16 = 0x10000
	// Position of P17 field.
	PIO_REHLSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_REHLSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_REHLSR_P17 = 0x20000
	// Position of P18 field.
	PIO_REHLSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_REHLSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_REHLSR_P18 = 0x40000
	// Position of P19 field.
	PIO_REHLSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_REHLSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_REHLSR_P19 = 0x80000
	// Position of P20 field.
	PIO_REHLSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_REHLSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_REHLSR_P20 = 0x100000
	// Position of P21 field.
	PIO_REHLSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_REHLSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_REHLSR_P21 = 0x200000
	// Position of P22 field.
	PIO_REHLSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_REHLSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_REHLSR_P22 = 0x400000
	// Position of P23 field.
	PIO_REHLSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_REHLSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_REHLSR_P23 = 0x800000
	// Position of P24 field.
	PIO_REHLSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_REHLSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_REHLSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_REHLSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_REHLSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_REHLSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_REHLSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_REHLSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_REHLSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_REHLSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_REHLSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_REHLSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_REHLSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_REHLSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_REHLSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_REHLSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_REHLSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_REHLSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_REHLSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_REHLSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_REHLSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_REHLSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_REHLSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_REHLSR_P31 = 0x80000000

	// FRLHSR: Fall/Rise - Low/High Status Register
	// Position of P0 field.
	PIO_FRLHSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_FRLHSR_P0_Msk = 0x1
	// Bit P0.
	PIO_FRLHSR_P0 = 0x1
	// Position of P1 field.
	PIO_FRLHSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_FRLHSR_P1_Msk = 0x2
	// Bit P1.
	PIO_FRLHSR_P1 = 0x2
	// Position of P2 field.
	PIO_FRLHSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_FRLHSR_P2_Msk = 0x4
	// Bit P2.
	PIO_FRLHSR_P2 = 0x4
	// Position of P3 field.
	PIO_FRLHSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_FRLHSR_P3_Msk = 0x8
	// Bit P3.
	PIO_FRLHSR_P3 = 0x8
	// Position of P4 field.
	PIO_FRLHSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_FRLHSR_P4_Msk = 0x10
	// Bit P4.
	PIO_FRLHSR_P4 = 0x10
	// Position of P5 field.
	PIO_FRLHSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_FRLHSR_P5_Msk = 0x20
	// Bit P5.
	PIO_FRLHSR_P5 = 0x20
	// Position of P6 field.
	PIO_FRLHSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_FRLHSR_P6_Msk = 0x40
	// Bit P6.
	PIO_FRLHSR_P6 = 0x40
	// Position of P7 field.
	PIO_FRLHSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_FRLHSR_P7_Msk = 0x80
	// Bit P7.
	PIO_FRLHSR_P7 = 0x80
	// Position of P8 field.
	PIO_FRLHSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_FRLHSR_P8_Msk = 0x100
	// Bit P8.
	PIO_FRLHSR_P8 = 0x100
	// Position of P9 field.
	PIO_FRLHSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_FRLHSR_P9_Msk = 0x200
	// Bit P9.
	PIO_FRLHSR_P9 = 0x200
	// Position of P10 field.
	PIO_FRLHSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_FRLHSR_P10_Msk = 0x400
	// Bit P10.
	PIO_FRLHSR_P10 = 0x400
	// Position of P11 field.
	PIO_FRLHSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_FRLHSR_P11_Msk = 0x800
	// Bit P11.
	PIO_FRLHSR_P11 = 0x800
	// Position of P12 field.
	PIO_FRLHSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_FRLHSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_FRLHSR_P12 = 0x1000
	// Position of P13 field.
	PIO_FRLHSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_FRLHSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_FRLHSR_P13 = 0x2000
	// Position of P14 field.
	PIO_FRLHSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_FRLHSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_FRLHSR_P14 = 0x4000
	// Position of P15 field.
	PIO_FRLHSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_FRLHSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_FRLHSR_P15 = 0x8000
	// Position of P16 field.
	PIO_FRLHSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_FRLHSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_FRLHSR_P16 = 0x10000
	// Position of P17 field.
	PIO_FRLHSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_FRLHSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_FRLHSR_P17 = 0x20000
	// Position of P18 field.
	PIO_FRLHSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_FRLHSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_FRLHSR_P18 = 0x40000
	// Position of P19 field.
	PIO_FRLHSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_FRLHSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_FRLHSR_P19 = 0x80000
	// Position of P20 field.
	PIO_FRLHSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_FRLHSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_FRLHSR_P20 = 0x100000
	// Position of P21 field.
	PIO_FRLHSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_FRLHSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_FRLHSR_P21 = 0x200000
	// Position of P22 field.
	PIO_FRLHSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_FRLHSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_FRLHSR_P22 = 0x400000
	// Position of P23 field.
	PIO_FRLHSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_FRLHSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_FRLHSR_P23 = 0x800000
	// Position of P24 field.
	PIO_FRLHSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_FRLHSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_FRLHSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_FRLHSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_FRLHSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_FRLHSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_FRLHSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_FRLHSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_FRLHSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_FRLHSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_FRLHSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_FRLHSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_FRLHSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_FRLHSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_FRLHSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_FRLHSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_FRLHSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_FRLHSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_FRLHSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_FRLHSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_FRLHSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_FRLHSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_FRLHSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_FRLHSR_P31 = 0x80000000

	// LOCKSR: Lock Status
	// Position of P0 field.
	PIO_LOCKSR_P0_Pos = 0x0
	// Bit mask of P0 field.
	PIO_LOCKSR_P0_Msk = 0x1
	// Bit P0.
	PIO_LOCKSR_P0 = 0x1
	// Position of P1 field.
	PIO_LOCKSR_P1_Pos = 0x1
	// Bit mask of P1 field.
	PIO_LOCKSR_P1_Msk = 0x2
	// Bit P1.
	PIO_LOCKSR_P1 = 0x2
	// Position of P2 field.
	PIO_LOCKSR_P2_Pos = 0x2
	// Bit mask of P2 field.
	PIO_LOCKSR_P2_Msk = 0x4
	// Bit P2.
	PIO_LOCKSR_P2 = 0x4
	// Position of P3 field.
	PIO_LOCKSR_P3_Pos = 0x3
	// Bit mask of P3 field.
	PIO_LOCKSR_P3_Msk = 0x8
	// Bit P3.
	PIO_LOCKSR_P3 = 0x8
	// Position of P4 field.
	PIO_LOCKSR_P4_Pos = 0x4
	// Bit mask of P4 field.
	PIO_LOCKSR_P4_Msk = 0x10
	// Bit P4.
	PIO_LOCKSR_P4 = 0x10
	// Position of P5 field.
	PIO_LOCKSR_P5_Pos = 0x5
	// Bit mask of P5 field.
	PIO_LOCKSR_P5_Msk = 0x20
	// Bit P5.
	PIO_LOCKSR_P5 = 0x20
	// Position of P6 field.
	PIO_LOCKSR_P6_Pos = 0x6
	// Bit mask of P6 field.
	PIO_LOCKSR_P6_Msk = 0x40
	// Bit P6.
	PIO_LOCKSR_P6 = 0x40
	// Position of P7 field.
	PIO_LOCKSR_P7_Pos = 0x7
	// Bit mask of P7 field.
	PIO_LOCKSR_P7_Msk = 0x80
	// Bit P7.
	PIO_LOCKSR_P7 = 0x80
	// Position of P8 field.
	PIO_LOCKSR_P8_Pos = 0x8
	// Bit mask of P8 field.
	PIO_LOCKSR_P8_Msk = 0x100
	// Bit P8.
	PIO_LOCKSR_P8 = 0x100
	// Position of P9 field.
	PIO_LOCKSR_P9_Pos = 0x9
	// Bit mask of P9 field.
	PIO_LOCKSR_P9_Msk = 0x200
	// Bit P9.
	PIO_LOCKSR_P9 = 0x200
	// Position of P10 field.
	PIO_LOCKSR_P10_Pos = 0xa
	// Bit mask of P10 field.
	PIO_LOCKSR_P10_Msk = 0x400
	// Bit P10.
	PIO_LOCKSR_P10 = 0x400
	// Position of P11 field.
	PIO_LOCKSR_P11_Pos = 0xb
	// Bit mask of P11 field.
	PIO_LOCKSR_P11_Msk = 0x800
	// Bit P11.
	PIO_LOCKSR_P11 = 0x800
	// Position of P12 field.
	PIO_LOCKSR_P12_Pos = 0xc
	// Bit mask of P12 field.
	PIO_LOCKSR_P12_Msk = 0x1000
	// Bit P12.
	PIO_LOCKSR_P12 = 0x1000
	// Position of P13 field.
	PIO_LOCKSR_P13_Pos = 0xd
	// Bit mask of P13 field.
	PIO_LOCKSR_P13_Msk = 0x2000
	// Bit P13.
	PIO_LOCKSR_P13 = 0x2000
	// Position of P14 field.
	PIO_LOCKSR_P14_Pos = 0xe
	// Bit mask of P14 field.
	PIO_LOCKSR_P14_Msk = 0x4000
	// Bit P14.
	PIO_LOCKSR_P14 = 0x4000
	// Position of P15 field.
	PIO_LOCKSR_P15_Pos = 0xf
	// Bit mask of P15 field.
	PIO_LOCKSR_P15_Msk = 0x8000
	// Bit P15.
	PIO_LOCKSR_P15 = 0x8000
	// Position of P16 field.
	PIO_LOCKSR_P16_Pos = 0x10
	// Bit mask of P16 field.
	PIO_LOCKSR_P16_Msk = 0x10000
	// Bit P16.
	PIO_LOCKSR_P16 = 0x10000
	// Position of P17 field.
	PIO_LOCKSR_P17_Pos = 0x11
	// Bit mask of P17 field.
	PIO_LOCKSR_P17_Msk = 0x20000
	// Bit P17.
	PIO_LOCKSR_P17 = 0x20000
	// Position of P18 field.
	PIO_LOCKSR_P18_Pos = 0x12
	// Bit mask of P18 field.
	PIO_LOCKSR_P18_Msk = 0x40000
	// Bit P18.
	PIO_LOCKSR_P18 = 0x40000
	// Position of P19 field.
	PIO_LOCKSR_P19_Pos = 0x13
	// Bit mask of P19 field.
	PIO_LOCKSR_P19_Msk = 0x80000
	// Bit P19.
	PIO_LOCKSR_P19 = 0x80000
	// Position of P20 field.
	PIO_LOCKSR_P20_Pos = 0x14
	// Bit mask of P20 field.
	PIO_LOCKSR_P20_Msk = 0x100000
	// Bit P20.
	PIO_LOCKSR_P20 = 0x100000
	// Position of P21 field.
	PIO_LOCKSR_P21_Pos = 0x15
	// Bit mask of P21 field.
	PIO_LOCKSR_P21_Msk = 0x200000
	// Bit P21.
	PIO_LOCKSR_P21 = 0x200000
	// Position of P22 field.
	PIO_LOCKSR_P22_Pos = 0x16
	// Bit mask of P22 field.
	PIO_LOCKSR_P22_Msk = 0x400000
	// Bit P22.
	PIO_LOCKSR_P22 = 0x400000
	// Position of P23 field.
	PIO_LOCKSR_P23_Pos = 0x17
	// Bit mask of P23 field.
	PIO_LOCKSR_P23_Msk = 0x800000
	// Bit P23.
	PIO_LOCKSR_P23 = 0x800000
	// Position of P24 field.
	PIO_LOCKSR_P24_Pos = 0x18
	// Bit mask of P24 field.
	PIO_LOCKSR_P24_Msk = 0x1000000
	// Bit P24.
	PIO_LOCKSR_P24 = 0x1000000
	// Position of P25 field.
	PIO_LOCKSR_P25_Pos = 0x19
	// Bit mask of P25 field.
	PIO_LOCKSR_P25_Msk = 0x2000000
	// Bit P25.
	PIO_LOCKSR_P25 = 0x2000000
	// Position of P26 field.
	PIO_LOCKSR_P26_Pos = 0x1a
	// Bit mask of P26 field.
	PIO_LOCKSR_P26_Msk = 0x4000000
	// Bit P26.
	PIO_LOCKSR_P26 = 0x4000000
	// Position of P27 field.
	PIO_LOCKSR_P27_Pos = 0x1b
	// Bit mask of P27 field.
	PIO_LOCKSR_P27_Msk = 0x8000000
	// Bit P27.
	PIO_LOCKSR_P27 = 0x8000000
	// Position of P28 field.
	PIO_LOCKSR_P28_Pos = 0x1c
	// Bit mask of P28 field.
	PIO_LOCKSR_P28_Msk = 0x10000000
	// Bit P28.
	PIO_LOCKSR_P28 = 0x10000000
	// Position of P29 field.
	PIO_LOCKSR_P29_Pos = 0x1d
	// Bit mask of P29 field.
	PIO_LOCKSR_P29_Msk = 0x20000000
	// Bit P29.
	PIO_LOCKSR_P29 = 0x20000000
	// Position of P30 field.
	PIO_LOCKSR_P30_Pos = 0x1e
	// Bit mask of P30 field.
	PIO_LOCKSR_P30_Msk = 0x40000000
	// Bit P30.
	PIO_LOCKSR_P30 = 0x40000000
	// Position of P31 field.
	PIO_LOCKSR_P31_Pos = 0x1f
	// Bit mask of P31 field.
	PIO_LOCKSR_P31_Msk = 0x80000000
	// Bit P31.
	PIO_LOCKSR_P31 = 0x80000000

	// WPMR: Write Protect Mode Register
	// Position of WPEN field.
	PIO_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	PIO_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	PIO_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	PIO_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	PIO_WPMR_WPKEY_Msk = 0xffffff00

	// WPSR: Write Protect Status Register
	// Position of WPVS field.
	PIO_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	PIO_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	PIO_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	PIO_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	PIO_WPSR_WPVSRC_Msk = 0xffff00

	// SCHMITT: Schmitt Trigger Register
	// Position of SCHMITT0 field.
	PIO_SCHMITT_SCHMITT0_Pos = 0x0
	// Bit mask of SCHMITT0 field.
	PIO_SCHMITT_SCHMITT0_Msk = 0x1
	// Bit SCHMITT0.
	PIO_SCHMITT_SCHMITT0 = 0x1
	// Position of SCHMITT1 field.
	PIO_SCHMITT_SCHMITT1_Pos = 0x1
	// Bit mask of SCHMITT1 field.
	PIO_SCHMITT_SCHMITT1_Msk = 0x2
	// Bit SCHMITT1.
	PIO_SCHMITT_SCHMITT1 = 0x2
	// Position of SCHMITT2 field.
	PIO_SCHMITT_SCHMITT2_Pos = 0x2
	// Bit mask of SCHMITT2 field.
	PIO_SCHMITT_SCHMITT2_Msk = 0x4
	// Bit SCHMITT2.
	PIO_SCHMITT_SCHMITT2 = 0x4
	// Position of SCHMITT3 field.
	PIO_SCHMITT_SCHMITT3_Pos = 0x3
	// Bit mask of SCHMITT3 field.
	PIO_SCHMITT_SCHMITT3_Msk = 0x8
	// Bit SCHMITT3.
	PIO_SCHMITT_SCHMITT3 = 0x8
	// Position of SCHMITT4 field.
	PIO_SCHMITT_SCHMITT4_Pos = 0x4
	// Bit mask of SCHMITT4 field.
	PIO_SCHMITT_SCHMITT4_Msk = 0x10
	// Bit SCHMITT4.
	PIO_SCHMITT_SCHMITT4 = 0x10
	// Position of SCHMITT5 field.
	PIO_SCHMITT_SCHMITT5_Pos = 0x5
	// Bit mask of SCHMITT5 field.
	PIO_SCHMITT_SCHMITT5_Msk = 0x20
	// Bit SCHMITT5.
	PIO_SCHMITT_SCHMITT5 = 0x20
	// Position of SCHMITT6 field.
	PIO_SCHMITT_SCHMITT6_Pos = 0x6
	// Bit mask of SCHMITT6 field.
	PIO_SCHMITT_SCHMITT6_Msk = 0x40
	// Bit SCHMITT6.
	PIO_SCHMITT_SCHMITT6 = 0x40
	// Position of SCHMITT7 field.
	PIO_SCHMITT_SCHMITT7_Pos = 0x7
	// Bit mask of SCHMITT7 field.
	PIO_SCHMITT_SCHMITT7_Msk = 0x80
	// Bit SCHMITT7.
	PIO_SCHMITT_SCHMITT7 = 0x80
	// Position of SCHMITT8 field.
	PIO_SCHMITT_SCHMITT8_Pos = 0x8
	// Bit mask of SCHMITT8 field.
	PIO_SCHMITT_SCHMITT8_Msk = 0x100
	// Bit SCHMITT8.
	PIO_SCHMITT_SCHMITT8 = 0x100
	// Position of SCHMITT9 field.
	PIO_SCHMITT_SCHMITT9_Pos = 0x9
	// Bit mask of SCHMITT9 field.
	PIO_SCHMITT_SCHMITT9_Msk = 0x200
	// Bit SCHMITT9.
	PIO_SCHMITT_SCHMITT9 = 0x200
	// Position of SCHMITT10 field.
	PIO_SCHMITT_SCHMITT10_Pos = 0xa
	// Bit mask of SCHMITT10 field.
	PIO_SCHMITT_SCHMITT10_Msk = 0x400
	// Bit SCHMITT10.
	PIO_SCHMITT_SCHMITT10 = 0x400
	// Position of SCHMITT11 field.
	PIO_SCHMITT_SCHMITT11_Pos = 0xb
	// Bit mask of SCHMITT11 field.
	PIO_SCHMITT_SCHMITT11_Msk = 0x800
	// Bit SCHMITT11.
	PIO_SCHMITT_SCHMITT11 = 0x800
	// Position of SCHMITT12 field.
	PIO_SCHMITT_SCHMITT12_Pos = 0xc
	// Bit mask of SCHMITT12 field.
	PIO_SCHMITT_SCHMITT12_Msk = 0x1000
	// Bit SCHMITT12.
	PIO_SCHMITT_SCHMITT12 = 0x1000
	// Position of SCHMITT13 field.
	PIO_SCHMITT_SCHMITT13_Pos = 0xd
	// Bit mask of SCHMITT13 field.
	PIO_SCHMITT_SCHMITT13_Msk = 0x2000
	// Bit SCHMITT13.
	PIO_SCHMITT_SCHMITT13 = 0x2000
	// Position of SCHMITT14 field.
	PIO_SCHMITT_SCHMITT14_Pos = 0xe
	// Bit mask of SCHMITT14 field.
	PIO_SCHMITT_SCHMITT14_Msk = 0x4000
	// Bit SCHMITT14.
	PIO_SCHMITT_SCHMITT14 = 0x4000
	// Position of SCHMITT15 field.
	PIO_SCHMITT_SCHMITT15_Pos = 0xf
	// Bit mask of SCHMITT15 field.
	PIO_SCHMITT_SCHMITT15_Msk = 0x8000
	// Bit SCHMITT15.
	PIO_SCHMITT_SCHMITT15 = 0x8000
	// Position of SCHMITT16 field.
	PIO_SCHMITT_SCHMITT16_Pos = 0x10
	// Bit mask of SCHMITT16 field.
	PIO_SCHMITT_SCHMITT16_Msk = 0x10000
	// Bit SCHMITT16.
	PIO_SCHMITT_SCHMITT16 = 0x10000
	// Position of SCHMITT17 field.
	PIO_SCHMITT_SCHMITT17_Pos = 0x11
	// Bit mask of SCHMITT17 field.
	PIO_SCHMITT_SCHMITT17_Msk = 0x20000
	// Bit SCHMITT17.
	PIO_SCHMITT_SCHMITT17 = 0x20000
	// Position of SCHMITT18 field.
	PIO_SCHMITT_SCHMITT18_Pos = 0x12
	// Bit mask of SCHMITT18 field.
	PIO_SCHMITT_SCHMITT18_Msk = 0x40000
	// Bit SCHMITT18.
	PIO_SCHMITT_SCHMITT18 = 0x40000
	// Position of SCHMITT19 field.
	PIO_SCHMITT_SCHMITT19_Pos = 0x13
	// Bit mask of SCHMITT19 field.
	PIO_SCHMITT_SCHMITT19_Msk = 0x80000
	// Bit SCHMITT19.
	PIO_SCHMITT_SCHMITT19 = 0x80000
	// Position of SCHMITT20 field.
	PIO_SCHMITT_SCHMITT20_Pos = 0x14
	// Bit mask of SCHMITT20 field.
	PIO_SCHMITT_SCHMITT20_Msk = 0x100000
	// Bit SCHMITT20.
	PIO_SCHMITT_SCHMITT20 = 0x100000
	// Position of SCHMITT21 field.
	PIO_SCHMITT_SCHMITT21_Pos = 0x15
	// Bit mask of SCHMITT21 field.
	PIO_SCHMITT_SCHMITT21_Msk = 0x200000
	// Bit SCHMITT21.
	PIO_SCHMITT_SCHMITT21 = 0x200000
	// Position of SCHMITT22 field.
	PIO_SCHMITT_SCHMITT22_Pos = 0x16
	// Bit mask of SCHMITT22 field.
	PIO_SCHMITT_SCHMITT22_Msk = 0x400000
	// Bit SCHMITT22.
	PIO_SCHMITT_SCHMITT22 = 0x400000
	// Position of SCHMITT23 field.
	PIO_SCHMITT_SCHMITT23_Pos = 0x17
	// Bit mask of SCHMITT23 field.
	PIO_SCHMITT_SCHMITT23_Msk = 0x800000
	// Bit SCHMITT23.
	PIO_SCHMITT_SCHMITT23 = 0x800000
	// Position of SCHMITT24 field.
	PIO_SCHMITT_SCHMITT24_Pos = 0x18
	// Bit mask of SCHMITT24 field.
	PIO_SCHMITT_SCHMITT24_Msk = 0x1000000
	// Bit SCHMITT24.
	PIO_SCHMITT_SCHMITT24 = 0x1000000
	// Position of SCHMITT25 field.
	PIO_SCHMITT_SCHMITT25_Pos = 0x19
	// Bit mask of SCHMITT25 field.
	PIO_SCHMITT_SCHMITT25_Msk = 0x2000000
	// Bit SCHMITT25.
	PIO_SCHMITT_SCHMITT25 = 0x2000000
	// Position of SCHMITT26 field.
	PIO_SCHMITT_SCHMITT26_Pos = 0x1a
	// Bit mask of SCHMITT26 field.
	PIO_SCHMITT_SCHMITT26_Msk = 0x4000000
	// Bit SCHMITT26.
	PIO_SCHMITT_SCHMITT26 = 0x4000000
	// Position of SCHMITT27 field.
	PIO_SCHMITT_SCHMITT27_Pos = 0x1b
	// Bit mask of SCHMITT27 field.
	PIO_SCHMITT_SCHMITT27_Msk = 0x8000000
	// Bit SCHMITT27.
	PIO_SCHMITT_SCHMITT27 = 0x8000000
	// Position of SCHMITT28 field.
	PIO_SCHMITT_SCHMITT28_Pos = 0x1c
	// Bit mask of SCHMITT28 field.
	PIO_SCHMITT_SCHMITT28_Msk = 0x10000000
	// Bit SCHMITT28.
	PIO_SCHMITT_SCHMITT28 = 0x10000000
	// Position of SCHMITT29 field.
	PIO_SCHMITT_SCHMITT29_Pos = 0x1d
	// Bit mask of SCHMITT29 field.
	PIO_SCHMITT_SCHMITT29_Msk = 0x20000000
	// Bit SCHMITT29.
	PIO_SCHMITT_SCHMITT29 = 0x20000000
	// Position of SCHMITT30 field.
	PIO_SCHMITT_SCHMITT30_Pos = 0x1e
	// Bit mask of SCHMITT30 field.
	PIO_SCHMITT_SCHMITT30_Msk = 0x40000000
	// Bit SCHMITT30.
	PIO_SCHMITT_SCHMITT30 = 0x40000000
	// Position of SCHMITT31 field.
	PIO_SCHMITT_SCHMITT31_Pos = 0x1f
	// Bit mask of SCHMITT31 field.
	PIO_SCHMITT_SCHMITT31_Msk = 0x80000000
	// Bit SCHMITT31.
	PIO_SCHMITT_SCHMITT31 = 0x80000000

	// DRIVER1: I/O Drive Register 1
	// Position of LINE0 field.
	PIO_DRIVER1_LINE0_Pos = 0x0
	// Bit mask of LINE0 field.
	PIO_DRIVER1_LINE0_Msk = 0x3
	// Low drive
	PIO_DRIVER1_LINE0_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE0_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE0_HI_DRIVE = 0x3
	// Position of LINE1 field.
	PIO_DRIVER1_LINE1_Pos = 0x2
	// Bit mask of LINE1 field.
	PIO_DRIVER1_LINE1_Msk = 0xc
	// Low drive
	PIO_DRIVER1_LINE1_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE1_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE1_HI_DRIVE = 0x3
	// Position of LINE2 field.
	PIO_DRIVER1_LINE2_Pos = 0x4
	// Bit mask of LINE2 field.
	PIO_DRIVER1_LINE2_Msk = 0x30
	// Low drive
	PIO_DRIVER1_LINE2_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE2_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE2_HI_DRIVE = 0x3
	// Position of LINE3 field.
	PIO_DRIVER1_LINE3_Pos = 0x6
	// Bit mask of LINE3 field.
	PIO_DRIVER1_LINE3_Msk = 0xc0
	// Low drive
	PIO_DRIVER1_LINE3_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE3_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE3_HI_DRIVE = 0x3
	// Position of LINE4 field.
	PIO_DRIVER1_LINE4_Pos = 0x8
	// Bit mask of LINE4 field.
	PIO_DRIVER1_LINE4_Msk = 0x300
	// Low drive
	PIO_DRIVER1_LINE4_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE4_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE4_HI_DRIVE = 0x3
	// Position of LINE5 field.
	PIO_DRIVER1_LINE5_Pos = 0xa
	// Bit mask of LINE5 field.
	PIO_DRIVER1_LINE5_Msk = 0xc00
	// Low drive
	PIO_DRIVER1_LINE5_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE5_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE5_HI_DRIVE = 0x3
	// Position of LINE6 field.
	PIO_DRIVER1_LINE6_Pos = 0xc
	// Bit mask of LINE6 field.
	PIO_DRIVER1_LINE6_Msk = 0x3000
	// Low drive
	PIO_DRIVER1_LINE6_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE6_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE6_HI_DRIVE = 0x3
	// Position of LINE7 field.
	PIO_DRIVER1_LINE7_Pos = 0xe
	// Bit mask of LINE7 field.
	PIO_DRIVER1_LINE7_Msk = 0xc000
	// Low drive
	PIO_DRIVER1_LINE7_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE7_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE7_HI_DRIVE = 0x3
	// Position of LINE8 field.
	PIO_DRIVER1_LINE8_Pos = 0x10
	// Bit mask of LINE8 field.
	PIO_DRIVER1_LINE8_Msk = 0x30000
	// Low drive
	PIO_DRIVER1_LINE8_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE8_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE8_HI_DRIVE = 0x3
	// Position of LINE9 field.
	PIO_DRIVER1_LINE9_Pos = 0x12
	// Bit mask of LINE9 field.
	PIO_DRIVER1_LINE9_Msk = 0xc0000
	// Low drive
	PIO_DRIVER1_LINE9_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE9_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE9_HI_DRIVE = 0x3
	// Position of LINE10 field.
	PIO_DRIVER1_LINE10_Pos = 0x14
	// Bit mask of LINE10 field.
	PIO_DRIVER1_LINE10_Msk = 0x300000
	// Low drive
	PIO_DRIVER1_LINE10_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE10_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE10_HI_DRIVE = 0x3
	// Position of LINE11 field.
	PIO_DRIVER1_LINE11_Pos = 0x16
	// Bit mask of LINE11 field.
	PIO_DRIVER1_LINE11_Msk = 0xc00000
	// Low drive
	PIO_DRIVER1_LINE11_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE11_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE11_HI_DRIVE = 0x3
	// Position of LINE12 field.
	PIO_DRIVER1_LINE12_Pos = 0x18
	// Bit mask of LINE12 field.
	PIO_DRIVER1_LINE12_Msk = 0x3000000
	// Low drive
	PIO_DRIVER1_LINE12_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE12_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE12_HI_DRIVE = 0x3
	// Position of LINE13 field.
	PIO_DRIVER1_LINE13_Pos = 0x1a
	// Bit mask of LINE13 field.
	PIO_DRIVER1_LINE13_Msk = 0xc000000
	// Low drive
	PIO_DRIVER1_LINE13_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE13_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE13_HI_DRIVE = 0x3
	// Position of LINE14 field.
	PIO_DRIVER1_LINE14_Pos = 0x1c
	// Bit mask of LINE14 field.
	PIO_DRIVER1_LINE14_Msk = 0x30000000
	// Low drive
	PIO_DRIVER1_LINE14_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE14_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE14_HI_DRIVE = 0x3
	// Position of LINE15 field.
	PIO_DRIVER1_LINE15_Pos = 0x1e
	// Bit mask of LINE15 field.
	PIO_DRIVER1_LINE15_Msk = 0xc0000000
	// Low drive
	PIO_DRIVER1_LINE15_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER1_LINE15_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER1_LINE15_HI_DRIVE = 0x3

	// DRIVER2: I/O Drive Register 2
	// Position of LINE16 field.
	PIO_DRIVER2_LINE16_Pos = 0x0
	// Bit mask of LINE16 field.
	PIO_DRIVER2_LINE16_Msk = 0x3
	// Low drive
	PIO_DRIVER2_LINE16_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE16_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE16_HI_DRIVE = 0x3
	// Position of LINE17 field.
	PIO_DRIVER2_LINE17_Pos = 0x2
	// Bit mask of LINE17 field.
	PIO_DRIVER2_LINE17_Msk = 0xc
	// Low drive
	PIO_DRIVER2_LINE17_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE17_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE17_HI_DRIVE = 0x3
	// Position of LINE18 field.
	PIO_DRIVER2_LINE18_Pos = 0x4
	// Bit mask of LINE18 field.
	PIO_DRIVER2_LINE18_Msk = 0x30
	// Low drive
	PIO_DRIVER2_LINE18_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE18_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE18_HI_DRIVE = 0x3
	// Position of LINE19 field.
	PIO_DRIVER2_LINE19_Pos = 0x6
	// Bit mask of LINE19 field.
	PIO_DRIVER2_LINE19_Msk = 0xc0
	// Low drive
	PIO_DRIVER2_LINE19_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE19_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE19_HI_DRIVE = 0x3
	// Position of LINE20 field.
	PIO_DRIVER2_LINE20_Pos = 0x8
	// Bit mask of LINE20 field.
	PIO_DRIVER2_LINE20_Msk = 0x300
	// Low drive
	PIO_DRIVER2_LINE20_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE20_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE20_HI_DRIVE = 0x3
	// Position of LINE21 field.
	PIO_DRIVER2_LINE21_Pos = 0xa
	// Bit mask of LINE21 field.
	PIO_DRIVER2_LINE21_Msk = 0xc00
	// Low drive
	PIO_DRIVER2_LINE21_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE21_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE21_HI_DRIVE = 0x3
	// Position of LINE22 field.
	PIO_DRIVER2_LINE22_Pos = 0xc
	// Bit mask of LINE22 field.
	PIO_DRIVER2_LINE22_Msk = 0x3000
	// Low drive
	PIO_DRIVER2_LINE22_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE22_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE22_HI_DRIVE = 0x3
	// Position of LINE23 field.
	PIO_DRIVER2_LINE23_Pos = 0xe
	// Bit mask of LINE23 field.
	PIO_DRIVER2_LINE23_Msk = 0xc000
	// Low drive
	PIO_DRIVER2_LINE23_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE23_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE23_HI_DRIVE = 0x3
	// Position of LINE24 field.
	PIO_DRIVER2_LINE24_Pos = 0x10
	// Bit mask of LINE24 field.
	PIO_DRIVER2_LINE24_Msk = 0x30000
	// Low drive
	PIO_DRIVER2_LINE24_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE24_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE24_HI_DRIVE = 0x3
	// Position of LINE25 field.
	PIO_DRIVER2_LINE25_Pos = 0x12
	// Bit mask of LINE25 field.
	PIO_DRIVER2_LINE25_Msk = 0xc0000
	// Low drive
	PIO_DRIVER2_LINE25_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE25_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE25_HI_DRIVE = 0x3
	// Position of LINE26 field.
	PIO_DRIVER2_LINE26_Pos = 0x14
	// Bit mask of LINE26 field.
	PIO_DRIVER2_LINE26_Msk = 0x300000
	// Low drive
	PIO_DRIVER2_LINE26_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE26_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE26_HI_DRIVE = 0x3
	// Position of LINE27 field.
	PIO_DRIVER2_LINE27_Pos = 0x16
	// Bit mask of LINE27 field.
	PIO_DRIVER2_LINE27_Msk = 0xc00000
	// Low drive
	PIO_DRIVER2_LINE27_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE27_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE27_HI_DRIVE = 0x3
	// Position of LINE28 field.
	PIO_DRIVER2_LINE28_Pos = 0x18
	// Bit mask of LINE28 field.
	PIO_DRIVER2_LINE28_Msk = 0x3000000
	// Low drive
	PIO_DRIVER2_LINE28_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE28_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE28_HI_DRIVE = 0x3
	// Position of LINE29 field.
	PIO_DRIVER2_LINE29_Pos = 0x1a
	// Bit mask of LINE29 field.
	PIO_DRIVER2_LINE29_Msk = 0xc000000
	// Low drive
	PIO_DRIVER2_LINE29_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE29_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE29_HI_DRIVE = 0x3
	// Position of LINE30 field.
	PIO_DRIVER2_LINE30_Pos = 0x1c
	// Bit mask of LINE30 field.
	PIO_DRIVER2_LINE30_Msk = 0x30000000
	// Low drive
	PIO_DRIVER2_LINE30_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE30_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE30_HI_DRIVE = 0x3
	// Position of LINE31 field.
	PIO_DRIVER2_LINE31_Pos = 0x1e
	// Bit mask of LINE31 field.
	PIO_DRIVER2_LINE31_Msk = 0xc0000000
	// Low drive
	PIO_DRIVER2_LINE31_LO_DRIVE = 0x0
	// Medium drive
	PIO_DRIVER2_LINE31_ME_DRIVE = 0x2
	// High drive
	PIO_DRIVER2_LINE31_HI_DRIVE = 0x3
)

// Constants for PMC: Power Management Controller
const (
	// PMC_SCER: System Clock Enable Register
	// Position of DDRCK field.
	PMC_PMC_SCER_DDRCK_Pos = 0x2
	// Bit mask of DDRCK field.
	PMC_PMC_SCER_DDRCK_Msk = 0x4
	// Bit DDRCK.
	PMC_PMC_SCER_DDRCK = 0x4
	// Position of SMDCK field.
	PMC_PMC_SCER_SMDCK_Pos = 0x4
	// Bit mask of SMDCK field.
	PMC_PMC_SCER_SMDCK_Msk = 0x10
	// Bit SMDCK.
	PMC_PMC_SCER_SMDCK = 0x10
	// Position of UHP field.
	PMC_PMC_SCER_UHP_Pos = 0x6
	// Bit mask of UHP field.
	PMC_PMC_SCER_UHP_Msk = 0x40
	// Bit UHP.
	PMC_PMC_SCER_UHP = 0x40
	// Position of UDP field.
	PMC_PMC_SCER_UDP_Pos = 0x7
	// Bit mask of UDP field.
	PMC_PMC_SCER_UDP_Msk = 0x80
	// Bit UDP.
	PMC_PMC_SCER_UDP = 0x80
	// Position of PCK0 field.
	PMC_PMC_SCER_PCK0_Pos = 0x8
	// Bit mask of PCK0 field.
	PMC_PMC_SCER_PCK0_Msk = 0x100
	// Bit PCK0.
	PMC_PMC_SCER_PCK0 = 0x100
	// Position of PCK1 field.
	PMC_PMC_SCER_PCK1_Pos = 0x9
	// Bit mask of PCK1 field.
	PMC_PMC_SCER_PCK1_Msk = 0x200
	// Bit PCK1.
	PMC_PMC_SCER_PCK1 = 0x200
	// Position of PCK2 field.
	PMC_PMC_SCER_PCK2_Pos = 0xa
	// Bit mask of PCK2 field.
	PMC_PMC_SCER_PCK2_Msk = 0x400
	// Bit PCK2.
	PMC_PMC_SCER_PCK2 = 0x400

	// PMC_SCDR: System Clock Disable Register
	// Position of PCK field.
	PMC_PMC_SCDR_PCK_Pos = 0x0
	// Bit mask of PCK field.
	PMC_PMC_SCDR_PCK_Msk = 0x1
	// Bit PCK.
	PMC_PMC_SCDR_PCK = 0x1
	// Position of DDRCK field.
	PMC_PMC_SCDR_DDRCK_Pos = 0x2
	// Bit mask of DDRCK field.
	PMC_PMC_SCDR_DDRCK_Msk = 0x4
	// Bit DDRCK.
	PMC_PMC_SCDR_DDRCK = 0x4
	// Position of SMDCK field.
	PMC_PMC_SCDR_SMDCK_Pos = 0x4
	// Bit mask of SMDCK field.
	PMC_PMC_SCDR_SMDCK_Msk = 0x10
	// Bit SMDCK.
	PMC_PMC_SCDR_SMDCK = 0x10
	// Position of UHP field.
	PMC_PMC_SCDR_UHP_Pos = 0x6
	// Bit mask of UHP field.
	PMC_PMC_SCDR_UHP_Msk = 0x40
	// Bit UHP.
	PMC_PMC_SCDR_UHP = 0x40
	// Position of UDP field.
	PMC_PMC_SCDR_UDP_Pos = 0x7
	// Bit mask of UDP field.
	PMC_PMC_SCDR_UDP_Msk = 0x80
	// Bit UDP.
	PMC_PMC_SCDR_UDP = 0x80
	// Position of PCK0 field.
	PMC_PMC_SCDR_PCK0_Pos = 0x8
	// Bit mask of PCK0 field.
	PMC_PMC_SCDR_PCK0_Msk = 0x100
	// Bit PCK0.
	PMC_PMC_SCDR_PCK0 = 0x100
	// Position of PCK1 field.
	PMC_PMC_SCDR_PCK1_Pos = 0x9
	// Bit mask of PCK1 field.
	PMC_PMC_SCDR_PCK1_Msk = 0x200
	// Bit PCK1.
	PMC_PMC_SCDR_PCK1 = 0x200
	// Position of PCK2 field.
	PMC_PMC_SCDR_PCK2_Pos = 0xa
	// Bit mask of PCK2 field.
	PMC_PMC_SCDR_PCK2_Msk = 0x400
	// Bit PCK2.
	PMC_PMC_SCDR_PCK2 = 0x400

	// PMC_SCSR: System Clock Status Register
	// Position of PCK field.
	PMC_PMC_SCSR_PCK_Pos = 0x0
	// Bit mask of PCK field.
	PMC_PMC_SCSR_PCK_Msk = 0x1
	// Bit PCK.
	PMC_PMC_SCSR_PCK = 0x1
	// Position of DDRCK field.
	PMC_PMC_SCSR_DDRCK_Pos = 0x2
	// Bit mask of DDRCK field.
	PMC_PMC_SCSR_DDRCK_Msk = 0x4
	// Bit DDRCK.
	PMC_PMC_SCSR_DDRCK = 0x4
	// Position of SMDCK field.
	PMC_PMC_SCSR_SMDCK_Pos = 0x4
	// Bit mask of SMDCK field.
	PMC_PMC_SCSR_SMDCK_Msk = 0x10
	// Bit SMDCK.
	PMC_PMC_SCSR_SMDCK = 0x10
	// Position of UHP field.
	PMC_PMC_SCSR_UHP_Pos = 0x6
	// Bit mask of UHP field.
	PMC_PMC_SCSR_UHP_Msk = 0x40
	// Bit UHP.
	PMC_PMC_SCSR_UHP = 0x40
	// Position of UDP field.
	PMC_PMC_SCSR_UDP_Pos = 0x7
	// Bit mask of UDP field.
	PMC_PMC_SCSR_UDP_Msk = 0x80
	// Bit UDP.
	PMC_PMC_SCSR_UDP = 0x80
	// Position of PCK0 field.
	PMC_PMC_SCSR_PCK0_Pos = 0x8
	// Bit mask of PCK0 field.
	PMC_PMC_SCSR_PCK0_Msk = 0x100
	// Bit PCK0.
	PMC_PMC_SCSR_PCK0 = 0x100
	// Position of PCK1 field.
	PMC_PMC_SCSR_PCK1_Pos = 0x9
	// Bit mask of PCK1 field.
	PMC_PMC_SCSR_PCK1_Msk = 0x200
	// Bit PCK1.
	PMC_PMC_SCSR_PCK1 = 0x200
	// Position of PCK2 field.
	PMC_PMC_SCSR_PCK2_Pos = 0xa
	// Bit mask of PCK2 field.
	PMC_PMC_SCSR_PCK2_Msk = 0x400
	// Bit PCK2.
	PMC_PMC_SCSR_PCK2 = 0x400

	// PMC_PCER0: Peripheral Clock Enable Register 0
	// Position of PID2 field.
	PMC_PMC_PCER0_PID2_Pos = 0x2
	// Bit mask of PID2 field.
	PMC_PMC_PCER0_PID2_Msk = 0x4
	// Bit PID2.
	PMC_PMC_PCER0_PID2 = 0x4
	// Position of PID3 field.
	PMC_PMC_PCER0_PID3_Pos = 0x3
	// Bit mask of PID3 field.
	PMC_PMC_PCER0_PID3_Msk = 0x8
	// Bit PID3.
	PMC_PMC_PCER0_PID3 = 0x8
	// Position of PID4 field.
	PMC_PMC_PCER0_PID4_Pos = 0x4
	// Bit mask of PID4 field.
	PMC_PMC_PCER0_PID4_Msk = 0x10
	// Bit PID4.
	PMC_PMC_PCER0_PID4 = 0x10
	// Position of PID5 field.
	PMC_PMC_PCER0_PID5_Pos = 0x5
	// Bit mask of PID5 field.
	PMC_PMC_PCER0_PID5_Msk = 0x20
	// Bit PID5.
	PMC_PMC_PCER0_PID5 = 0x20
	// Position of PID6 field.
	PMC_PMC_PCER0_PID6_Pos = 0x6
	// Bit mask of PID6 field.
	PMC_PMC_PCER0_PID6_Msk = 0x40
	// Bit PID6.
	PMC_PMC_PCER0_PID6 = 0x40
	// Position of PID7 field.
	PMC_PMC_PCER0_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	PMC_PMC_PCER0_PID7_Msk = 0x80
	// Bit PID7.
	PMC_PMC_PCER0_PID7 = 0x80
	// Position of PID8 field.
	PMC_PMC_PCER0_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	PMC_PMC_PCER0_PID8_Msk = 0x100
	// Bit PID8.
	PMC_PMC_PCER0_PID8 = 0x100
	// Position of PID9 field.
	PMC_PMC_PCER0_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	PMC_PMC_PCER0_PID9_Msk = 0x200
	// Bit PID9.
	PMC_PMC_PCER0_PID9 = 0x200
	// Position of PID10 field.
	PMC_PMC_PCER0_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	PMC_PMC_PCER0_PID10_Msk = 0x400
	// Bit PID10.
	PMC_PMC_PCER0_PID10 = 0x400
	// Position of PID11 field.
	PMC_PMC_PCER0_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	PMC_PMC_PCER0_PID11_Msk = 0x800
	// Bit PID11.
	PMC_PMC_PCER0_PID11 = 0x800
	// Position of PID12 field.
	PMC_PMC_PCER0_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	PMC_PMC_PCER0_PID12_Msk = 0x1000
	// Bit PID12.
	PMC_PMC_PCER0_PID12 = 0x1000
	// Position of PID13 field.
	PMC_PMC_PCER0_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	PMC_PMC_PCER0_PID13_Msk = 0x2000
	// Bit PID13.
	PMC_PMC_PCER0_PID13 = 0x2000
	// Position of PID14 field.
	PMC_PMC_PCER0_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	PMC_PMC_PCER0_PID14_Msk = 0x4000
	// Bit PID14.
	PMC_PMC_PCER0_PID14 = 0x4000
	// Position of PID15 field.
	PMC_PMC_PCER0_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	PMC_PMC_PCER0_PID15_Msk = 0x8000
	// Bit PID15.
	PMC_PMC_PCER0_PID15 = 0x8000
	// Position of PID16 field.
	PMC_PMC_PCER0_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	PMC_PMC_PCER0_PID16_Msk = 0x10000
	// Bit PID16.
	PMC_PMC_PCER0_PID16 = 0x10000
	// Position of PID17 field.
	PMC_PMC_PCER0_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	PMC_PMC_PCER0_PID17_Msk = 0x20000
	// Bit PID17.
	PMC_PMC_PCER0_PID17 = 0x20000
	// Position of PID18 field.
	PMC_PMC_PCER0_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	PMC_PMC_PCER0_PID18_Msk = 0x40000
	// Bit PID18.
	PMC_PMC_PCER0_PID18 = 0x40000
	// Position of PID19 field.
	PMC_PMC_PCER0_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	PMC_PMC_PCER0_PID19_Msk = 0x80000
	// Bit PID19.
	PMC_PMC_PCER0_PID19 = 0x80000
	// Position of PID20 field.
	PMC_PMC_PCER0_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	PMC_PMC_PCER0_PID20_Msk = 0x100000
	// Bit PID20.
	PMC_PMC_PCER0_PID20 = 0x100000
	// Position of PID21 field.
	PMC_PMC_PCER0_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	PMC_PMC_PCER0_PID21_Msk = 0x200000
	// Bit PID21.
	PMC_PMC_PCER0_PID21 = 0x200000
	// Position of PID22 field.
	PMC_PMC_PCER0_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	PMC_PMC_PCER0_PID22_Msk = 0x400000
	// Bit PID22.
	PMC_PMC_PCER0_PID22 = 0x400000
	// Position of PID23 field.
	PMC_PMC_PCER0_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	PMC_PMC_PCER0_PID23_Msk = 0x800000
	// Bit PID23.
	PMC_PMC_PCER0_PID23 = 0x800000
	// Position of PID24 field.
	PMC_PMC_PCER0_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	PMC_PMC_PCER0_PID24_Msk = 0x1000000
	// Bit PID24.
	PMC_PMC_PCER0_PID24 = 0x1000000
	// Position of PID25 field.
	PMC_PMC_PCER0_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	PMC_PMC_PCER0_PID25_Msk = 0x2000000
	// Bit PID25.
	PMC_PMC_PCER0_PID25 = 0x2000000
	// Position of PID26 field.
	PMC_PMC_PCER0_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	PMC_PMC_PCER0_PID26_Msk = 0x4000000
	// Bit PID26.
	PMC_PMC_PCER0_PID26 = 0x4000000
	// Position of PID27 field.
	PMC_PMC_PCER0_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	PMC_PMC_PCER0_PID27_Msk = 0x8000000
	// Bit PID27.
	PMC_PMC_PCER0_PID27 = 0x8000000
	// Position of PID28 field.
	PMC_PMC_PCER0_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	PMC_PMC_PCER0_PID28_Msk = 0x10000000
	// Bit PID28.
	PMC_PMC_PCER0_PID28 = 0x10000000
	// Position of PID29 field.
	PMC_PMC_PCER0_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	PMC_PMC_PCER0_PID29_Msk = 0x20000000
	// Bit PID29.
	PMC_PMC_PCER0_PID29 = 0x20000000
	// Position of PID30 field.
	PMC_PMC_PCER0_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	PMC_PMC_PCER0_PID30_Msk = 0x40000000
	// Bit PID30.
	PMC_PMC_PCER0_PID30 = 0x40000000
	// Position of PID31 field.
	PMC_PMC_PCER0_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	PMC_PMC_PCER0_PID31_Msk = 0x80000000
	// Bit PID31.
	PMC_PMC_PCER0_PID31 = 0x80000000

	// PMC_PCDR0: Peripheral Clock Disable Register 0
	// Position of PID2 field.
	PMC_PMC_PCDR0_PID2_Pos = 0x2
	// Bit mask of PID2 field.
	PMC_PMC_PCDR0_PID2_Msk = 0x4
	// Bit PID2.
	PMC_PMC_PCDR0_PID2 = 0x4
	// Position of PID3 field.
	PMC_PMC_PCDR0_PID3_Pos = 0x3
	// Bit mask of PID3 field.
	PMC_PMC_PCDR0_PID3_Msk = 0x8
	// Bit PID3.
	PMC_PMC_PCDR0_PID3 = 0x8
	// Position of PID4 field.
	PMC_PMC_PCDR0_PID4_Pos = 0x4
	// Bit mask of PID4 field.
	PMC_PMC_PCDR0_PID4_Msk = 0x10
	// Bit PID4.
	PMC_PMC_PCDR0_PID4 = 0x10
	// Position of PID5 field.
	PMC_PMC_PCDR0_PID5_Pos = 0x5
	// Bit mask of PID5 field.
	PMC_PMC_PCDR0_PID5_Msk = 0x20
	// Bit PID5.
	PMC_PMC_PCDR0_PID5 = 0x20
	// Position of PID6 field.
	PMC_PMC_PCDR0_PID6_Pos = 0x6
	// Bit mask of PID6 field.
	PMC_PMC_PCDR0_PID6_Msk = 0x40
	// Bit PID6.
	PMC_PMC_PCDR0_PID6 = 0x40
	// Position of PID7 field.
	PMC_PMC_PCDR0_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	PMC_PMC_PCDR0_PID7_Msk = 0x80
	// Bit PID7.
	PMC_PMC_PCDR0_PID7 = 0x80
	// Position of PID8 field.
	PMC_PMC_PCDR0_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	PMC_PMC_PCDR0_PID8_Msk = 0x100
	// Bit PID8.
	PMC_PMC_PCDR0_PID8 = 0x100
	// Position of PID9 field.
	PMC_PMC_PCDR0_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	PMC_PMC_PCDR0_PID9_Msk = 0x200
	// Bit PID9.
	PMC_PMC_PCDR0_PID9 = 0x200
	// Position of PID10 field.
	PMC_PMC_PCDR0_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	PMC_PMC_PCDR0_PID10_Msk = 0x400
	// Bit PID10.
	PMC_PMC_PCDR0_PID10 = 0x400
	// Position of PID11 field.
	PMC_PMC_PCDR0_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	PMC_PMC_PCDR0_PID11_Msk = 0x800
	// Bit PID11.
	PMC_PMC_PCDR0_PID11 = 0x800
	// Position of PID12 field.
	PMC_PMC_PCDR0_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	PMC_PMC_PCDR0_PID12_Msk = 0x1000
	// Bit PID12.
	PMC_PMC_PCDR0_PID12 = 0x1000
	// Position of PID13 field.
	PMC_PMC_PCDR0_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	PMC_PMC_PCDR0_PID13_Msk = 0x2000
	// Bit PID13.
	PMC_PMC_PCDR0_PID13 = 0x2000
	// Position of PID14 field.
	PMC_PMC_PCDR0_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	PMC_PMC_PCDR0_PID14_Msk = 0x4000
	// Bit PID14.
	PMC_PMC_PCDR0_PID14 = 0x4000
	// Position of PID15 field.
	PMC_PMC_PCDR0_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	PMC_PMC_PCDR0_PID15_Msk = 0x8000
	// Bit PID15.
	PMC_PMC_PCDR0_PID15 = 0x8000
	// Position of PID16 field.
	PMC_PMC_PCDR0_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	PMC_PMC_PCDR0_PID16_Msk = 0x10000
	// Bit PID16.
	PMC_PMC_PCDR0_PID16 = 0x10000
	// Position of PID17 field.
	PMC_PMC_PCDR0_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	PMC_PMC_PCDR0_PID17_Msk = 0x20000
	// Bit PID17.
	PMC_PMC_PCDR0_PID17 = 0x20000
	// Position of PID18 field.
	PMC_PMC_PCDR0_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	PMC_PMC_PCDR0_PID18_Msk = 0x40000
	// Bit PID18.
	PMC_PMC_PCDR0_PID18 = 0x40000
	// Position of PID19 field.
	PMC_PMC_PCDR0_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	PMC_PMC_PCDR0_PID19_Msk = 0x80000
	// Bit PID19.
	PMC_PMC_PCDR0_PID19 = 0x80000
	// Position of PID20 field.
	PMC_PMC_PCDR0_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	PMC_PMC_PCDR0_PID20_Msk = 0x100000
	// Bit PID20.
	PMC_PMC_PCDR0_PID20 = 0x100000
	// Position of PID21 field.
	PMC_PMC_PCDR0_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	PMC_PMC_PCDR0_PID21_Msk = 0x200000
	// Bit PID21.
	PMC_PMC_PCDR0_PID21 = 0x200000
	// Position of PID22 field.
	PMC_PMC_PCDR0_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	PMC_PMC_PCDR0_PID22_Msk = 0x400000
	// Bit PID22.
	PMC_PMC_PCDR0_PID22 = 0x400000
	// Position of PID23 field.
	PMC_PMC_PCDR0_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	PMC_PMC_PCDR0_PID23_Msk = 0x800000
	// Bit PID23.
	PMC_PMC_PCDR0_PID23 = 0x800000
	// Position of PID24 field.
	PMC_PMC_PCDR0_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	PMC_PMC_PCDR0_PID24_Msk = 0x1000000
	// Bit PID24.
	PMC_PMC_PCDR0_PID24 = 0x1000000
	// Position of PID25 field.
	PMC_PMC_PCDR0_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	PMC_PMC_PCDR0_PID25_Msk = 0x2000000
	// Bit PID25.
	PMC_PMC_PCDR0_PID25 = 0x2000000
	// Position of PID26 field.
	PMC_PMC_PCDR0_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	PMC_PMC_PCDR0_PID26_Msk = 0x4000000
	// Bit PID26.
	PMC_PMC_PCDR0_PID26 = 0x4000000
	// Position of PID27 field.
	PMC_PMC_PCDR0_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	PMC_PMC_PCDR0_PID27_Msk = 0x8000000
	// Bit PID27.
	PMC_PMC_PCDR0_PID27 = 0x8000000
	// Position of PID28 field.
	PMC_PMC_PCDR0_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	PMC_PMC_PCDR0_PID28_Msk = 0x10000000
	// Bit PID28.
	PMC_PMC_PCDR0_PID28 = 0x10000000
	// Position of PID29 field.
	PMC_PMC_PCDR0_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	PMC_PMC_PCDR0_PID29_Msk = 0x20000000
	// Bit PID29.
	PMC_PMC_PCDR0_PID29 = 0x20000000
	// Position of PID30 field.
	PMC_PMC_PCDR0_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	PMC_PMC_PCDR0_PID30_Msk = 0x40000000
	// Bit PID30.
	PMC_PMC_PCDR0_PID30 = 0x40000000
	// Position of PID31 field.
	PMC_PMC_PCDR0_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	PMC_PMC_PCDR0_PID31_Msk = 0x80000000
	// Bit PID31.
	PMC_PMC_PCDR0_PID31 = 0x80000000

	// PMC_PCSR0: Peripheral Clock Status Register 0
	// Position of PID2 field.
	PMC_PMC_PCSR0_PID2_Pos = 0x2
	// Bit mask of PID2 field.
	PMC_PMC_PCSR0_PID2_Msk = 0x4
	// Bit PID2.
	PMC_PMC_PCSR0_PID2 = 0x4
	// Position of PID3 field.
	PMC_PMC_PCSR0_PID3_Pos = 0x3
	// Bit mask of PID3 field.
	PMC_PMC_PCSR0_PID3_Msk = 0x8
	// Bit PID3.
	PMC_PMC_PCSR0_PID3 = 0x8
	// Position of PID4 field.
	PMC_PMC_PCSR0_PID4_Pos = 0x4
	// Bit mask of PID4 field.
	PMC_PMC_PCSR0_PID4_Msk = 0x10
	// Bit PID4.
	PMC_PMC_PCSR0_PID4 = 0x10
	// Position of PID5 field.
	PMC_PMC_PCSR0_PID5_Pos = 0x5
	// Bit mask of PID5 field.
	PMC_PMC_PCSR0_PID5_Msk = 0x20
	// Bit PID5.
	PMC_PMC_PCSR0_PID5 = 0x20
	// Position of PID6 field.
	PMC_PMC_PCSR0_PID6_Pos = 0x6
	// Bit mask of PID6 field.
	PMC_PMC_PCSR0_PID6_Msk = 0x40
	// Bit PID6.
	PMC_PMC_PCSR0_PID6 = 0x40
	// Position of PID7 field.
	PMC_PMC_PCSR0_PID7_Pos = 0x7
	// Bit mask of PID7 field.
	PMC_PMC_PCSR0_PID7_Msk = 0x80
	// Bit PID7.
	PMC_PMC_PCSR0_PID7 = 0x80
	// Position of PID8 field.
	PMC_PMC_PCSR0_PID8_Pos = 0x8
	// Bit mask of PID8 field.
	PMC_PMC_PCSR0_PID8_Msk = 0x100
	// Bit PID8.
	PMC_PMC_PCSR0_PID8 = 0x100
	// Position of PID9 field.
	PMC_PMC_PCSR0_PID9_Pos = 0x9
	// Bit mask of PID9 field.
	PMC_PMC_PCSR0_PID9_Msk = 0x200
	// Bit PID9.
	PMC_PMC_PCSR0_PID9 = 0x200
	// Position of PID10 field.
	PMC_PMC_PCSR0_PID10_Pos = 0xa
	// Bit mask of PID10 field.
	PMC_PMC_PCSR0_PID10_Msk = 0x400
	// Bit PID10.
	PMC_PMC_PCSR0_PID10 = 0x400
	// Position of PID11 field.
	PMC_PMC_PCSR0_PID11_Pos = 0xb
	// Bit mask of PID11 field.
	PMC_PMC_PCSR0_PID11_Msk = 0x800
	// Bit PID11.
	PMC_PMC_PCSR0_PID11 = 0x800
	// Position of PID12 field.
	PMC_PMC_PCSR0_PID12_Pos = 0xc
	// Bit mask of PID12 field.
	PMC_PMC_PCSR0_PID12_Msk = 0x1000
	// Bit PID12.
	PMC_PMC_PCSR0_PID12 = 0x1000
	// Position of PID13 field.
	PMC_PMC_PCSR0_PID13_Pos = 0xd
	// Bit mask of PID13 field.
	PMC_PMC_PCSR0_PID13_Msk = 0x2000
	// Bit PID13.
	PMC_PMC_PCSR0_PID13 = 0x2000
	// Position of PID14 field.
	PMC_PMC_PCSR0_PID14_Pos = 0xe
	// Bit mask of PID14 field.
	PMC_PMC_PCSR0_PID14_Msk = 0x4000
	// Bit PID14.
	PMC_PMC_PCSR0_PID14 = 0x4000
	// Position of PID15 field.
	PMC_PMC_PCSR0_PID15_Pos = 0xf
	// Bit mask of PID15 field.
	PMC_PMC_PCSR0_PID15_Msk = 0x8000
	// Bit PID15.
	PMC_PMC_PCSR0_PID15 = 0x8000
	// Position of PID16 field.
	PMC_PMC_PCSR0_PID16_Pos = 0x10
	// Bit mask of PID16 field.
	PMC_PMC_PCSR0_PID16_Msk = 0x10000
	// Bit PID16.
	PMC_PMC_PCSR0_PID16 = 0x10000
	// Position of PID17 field.
	PMC_PMC_PCSR0_PID17_Pos = 0x11
	// Bit mask of PID17 field.
	PMC_PMC_PCSR0_PID17_Msk = 0x20000
	// Bit PID17.
	PMC_PMC_PCSR0_PID17 = 0x20000
	// Position of PID18 field.
	PMC_PMC_PCSR0_PID18_Pos = 0x12
	// Bit mask of PID18 field.
	PMC_PMC_PCSR0_PID18_Msk = 0x40000
	// Bit PID18.
	PMC_PMC_PCSR0_PID18 = 0x40000
	// Position of PID19 field.
	PMC_PMC_PCSR0_PID19_Pos = 0x13
	// Bit mask of PID19 field.
	PMC_PMC_PCSR0_PID19_Msk = 0x80000
	// Bit PID19.
	PMC_PMC_PCSR0_PID19 = 0x80000
	// Position of PID20 field.
	PMC_PMC_PCSR0_PID20_Pos = 0x14
	// Bit mask of PID20 field.
	PMC_PMC_PCSR0_PID20_Msk = 0x100000
	// Bit PID20.
	PMC_PMC_PCSR0_PID20 = 0x100000
	// Position of PID21 field.
	PMC_PMC_PCSR0_PID21_Pos = 0x15
	// Bit mask of PID21 field.
	PMC_PMC_PCSR0_PID21_Msk = 0x200000
	// Bit PID21.
	PMC_PMC_PCSR0_PID21 = 0x200000
	// Position of PID22 field.
	PMC_PMC_PCSR0_PID22_Pos = 0x16
	// Bit mask of PID22 field.
	PMC_PMC_PCSR0_PID22_Msk = 0x400000
	// Bit PID22.
	PMC_PMC_PCSR0_PID22 = 0x400000
	// Position of PID23 field.
	PMC_PMC_PCSR0_PID23_Pos = 0x17
	// Bit mask of PID23 field.
	PMC_PMC_PCSR0_PID23_Msk = 0x800000
	// Bit PID23.
	PMC_PMC_PCSR0_PID23 = 0x800000
	// Position of PID24 field.
	PMC_PMC_PCSR0_PID24_Pos = 0x18
	// Bit mask of PID24 field.
	PMC_PMC_PCSR0_PID24_Msk = 0x1000000
	// Bit PID24.
	PMC_PMC_PCSR0_PID24 = 0x1000000
	// Position of PID25 field.
	PMC_PMC_PCSR0_PID25_Pos = 0x19
	// Bit mask of PID25 field.
	PMC_PMC_PCSR0_PID25_Msk = 0x2000000
	// Bit PID25.
	PMC_PMC_PCSR0_PID25 = 0x2000000
	// Position of PID26 field.
	PMC_PMC_PCSR0_PID26_Pos = 0x1a
	// Bit mask of PID26 field.
	PMC_PMC_PCSR0_PID26_Msk = 0x4000000
	// Bit PID26.
	PMC_PMC_PCSR0_PID26 = 0x4000000
	// Position of PID27 field.
	PMC_PMC_PCSR0_PID27_Pos = 0x1b
	// Bit mask of PID27 field.
	PMC_PMC_PCSR0_PID27_Msk = 0x8000000
	// Bit PID27.
	PMC_PMC_PCSR0_PID27 = 0x8000000
	// Position of PID28 field.
	PMC_PMC_PCSR0_PID28_Pos = 0x1c
	// Bit mask of PID28 field.
	PMC_PMC_PCSR0_PID28_Msk = 0x10000000
	// Bit PID28.
	PMC_PMC_PCSR0_PID28 = 0x10000000
	// Position of PID29 field.
	PMC_PMC_PCSR0_PID29_Pos = 0x1d
	// Bit mask of PID29 field.
	PMC_PMC_PCSR0_PID29_Msk = 0x20000000
	// Bit PID29.
	PMC_PMC_PCSR0_PID29 = 0x20000000
	// Position of PID30 field.
	PMC_PMC_PCSR0_PID30_Pos = 0x1e
	// Bit mask of PID30 field.
	PMC_PMC_PCSR0_PID30_Msk = 0x40000000
	// Bit PID30.
	PMC_PMC_PCSR0_PID30 = 0x40000000
	// Position of PID31 field.
	PMC_PMC_PCSR0_PID31_Pos = 0x1f
	// Bit mask of PID31 field.
	PMC_PMC_PCSR0_PID31_Msk = 0x80000000
	// Bit PID31.
	PMC_PMC_PCSR0_PID31 = 0x80000000

	// CKGR_UCKR: UTMI Clock Register
	// Position of UPLLEN field.
	PMC_CKGR_UCKR_UPLLEN_Pos = 0x10
	// Bit mask of UPLLEN field.
	PMC_CKGR_UCKR_UPLLEN_Msk = 0x10000
	// Bit UPLLEN.
	PMC_CKGR_UCKR_UPLLEN = 0x10000
	// Position of UPLLCOUNT field.
	PMC_CKGR_UCKR_UPLLCOUNT_Pos = 0x14
	// Bit mask of UPLLCOUNT field.
	PMC_CKGR_UCKR_UPLLCOUNT_Msk = 0xf00000
	// Position of BIASEN field.
	PMC_CKGR_UCKR_BIASEN_Pos = 0x18
	// Bit mask of BIASEN field.
	PMC_CKGR_UCKR_BIASEN_Msk = 0x1000000
	// Bit BIASEN.
	PMC_CKGR_UCKR_BIASEN = 0x1000000
	// Position of BIASCOUNT field.
	PMC_CKGR_UCKR_BIASCOUNT_Pos = 0x1c
	// Bit mask of BIASCOUNT field.
	PMC_CKGR_UCKR_BIASCOUNT_Msk = 0xf0000000

	// CKGR_MOR: Main Oscillator Register
	// Position of MOSCXTEN field.
	PMC_CKGR_MOR_MOSCXTEN_Pos = 0x0
	// Bit mask of MOSCXTEN field.
	PMC_CKGR_MOR_MOSCXTEN_Msk = 0x1
	// Bit MOSCXTEN.
	PMC_CKGR_MOR_MOSCXTEN = 0x1
	// Position of MOSCXTBY field.
	PMC_CKGR_MOR_MOSCXTBY_Pos = 0x1
	// Bit mask of MOSCXTBY field.
	PMC_CKGR_MOR_MOSCXTBY_Msk = 0x2
	// Bit MOSCXTBY.
	PMC_CKGR_MOR_MOSCXTBY = 0x2
	// Position of MOSCRCEN field.
	PMC_CKGR_MOR_MOSCRCEN_Pos = 0x3
	// Bit mask of MOSCRCEN field.
	PMC_CKGR_MOR_MOSCRCEN_Msk = 0x8
	// Bit MOSCRCEN.
	PMC_CKGR_MOR_MOSCRCEN = 0x8
	// Position of MOSCXTST field.
	PMC_CKGR_MOR_MOSCXTST_Pos = 0x8
	// Bit mask of MOSCXTST field.
	PMC_CKGR_MOR_MOSCXTST_Msk = 0xff00
	// Position of KEY field.
	PMC_CKGR_MOR_KEY_Pos = 0x10
	// Bit mask of KEY field.
	PMC_CKGR_MOR_KEY_Msk = 0xff0000
	// Position of MOSCSEL field.
	PMC_CKGR_MOR_MOSCSEL_Pos = 0x18
	// Bit mask of MOSCSEL field.
	PMC_CKGR_MOR_MOSCSEL_Msk = 0x1000000
	// Bit MOSCSEL.
	PMC_CKGR_MOR_MOSCSEL = 0x1000000
	// Position of CFDEN field.
	PMC_CKGR_MOR_CFDEN_Pos = 0x19
	// Bit mask of CFDEN field.
	PMC_CKGR_MOR_CFDEN_Msk = 0x2000000
	// Bit CFDEN.
	PMC_CKGR_MOR_CFDEN = 0x2000000

	// CKGR_MCFR: Main Clock Frequency Register
	// Position of MAINF field.
	PMC_CKGR_MCFR_MAINF_Pos = 0x0
	// Bit mask of MAINF field.
	PMC_CKGR_MCFR_MAINF_Msk = 0xffff
	// Position of MAINFRDY field.
	PMC_CKGR_MCFR_MAINFRDY_Pos = 0x10
	// Bit mask of MAINFRDY field.
	PMC_CKGR_MCFR_MAINFRDY_Msk = 0x10000
	// Bit MAINFRDY.
	PMC_CKGR_MCFR_MAINFRDY = 0x10000

	// CKGR_PLLAR: PLLA Register
	// Position of DIVA field.
	PMC_CKGR_PLLAR_DIVA_Pos = 0x0
	// Bit mask of DIVA field.
	PMC_CKGR_PLLAR_DIVA_Msk = 0xff
	// Position of PLLACOUNT field.
	PMC_CKGR_PLLAR_PLLACOUNT_Pos = 0x8
	// Bit mask of PLLACOUNT field.
	PMC_CKGR_PLLAR_PLLACOUNT_Msk = 0x3f00
	// Position of OUTA field.
	PMC_CKGR_PLLAR_OUTA_Pos = 0xe
	// Bit mask of OUTA field.
	PMC_CKGR_PLLAR_OUTA_Msk = 0xc000
	// Position of MULA field.
	PMC_CKGR_PLLAR_MULA_Pos = 0x10
	// Bit mask of MULA field.
	PMC_CKGR_PLLAR_MULA_Msk = 0x7ff0000
	// Position of STUCKTO1 field.
	PMC_CKGR_PLLAR_STUCKTO1_Pos = 0x1d
	// Bit mask of STUCKTO1 field.
	PMC_CKGR_PLLAR_STUCKTO1_Msk = 0x20000000
	// Bit STUCKTO1.
	PMC_CKGR_PLLAR_STUCKTO1 = 0x20000000

	// PMC_MCKR: Master Clock Register
	// Position of CSS field.
	PMC_PMC_MCKR_CSS_Pos = 0x0
	// Bit mask of CSS field.
	PMC_PMC_MCKR_CSS_Msk = 0x3
	// Slow Clock is selected
	PMC_PMC_MCKR_CSS_SLOW_CLK = 0x0
	// Main Clock is selected
	PMC_PMC_MCKR_CSS_MAIN_CLK = 0x1
	// PLLACK/PLLADIV2 is selected
	PMC_PMC_MCKR_CSS_PLLA_CLK = 0x2
	// UPLL Clock is selected
	PMC_PMC_MCKR_CSS_UPLL_CLK = 0x3
	// Position of PRES field.
	PMC_PMC_MCKR_PRES_Pos = 0x4
	// Bit mask of PRES field.
	PMC_PMC_MCKR_PRES_Msk = 0x70
	// Selected clock
	PMC_PMC_MCKR_PRES_CLOCK = 0x0
	// Selected clock divided by 2
	PMC_PMC_MCKR_PRES_CLOCK_DIV2 = 0x1
	// Selected clock divided by 4
	PMC_PMC_MCKR_PRES_CLOCK_DIV4 = 0x2
	// Selected clock divided by 8
	PMC_PMC_MCKR_PRES_CLOCK_DIV8 = 0x3
	// Selected clock divided by 16
	PMC_PMC_MCKR_PRES_CLOCK_DIV16 = 0x4
	// Selected clock divided by 32
	PMC_PMC_MCKR_PRES_CLOCK_DIV32 = 0x5
	// Selected clock divided by 64
	PMC_PMC_MCKR_PRES_CLOCK_DIV64 = 0x6
	// Position of MDIV field.
	PMC_PMC_MCKR_MDIV_Pos = 0x8
	// Bit mask of MDIV field.
	PMC_PMC_MCKR_MDIV_Msk = 0x300
	// Master Clock is Prescaler Output Clock divided by 1.Warning: SysClk DDR and DDRCK are not available.
	PMC_PMC_MCKR_MDIV_EQ_PCK = 0x0
	// Master Clock is Prescaler Output Clock divided by 2.SysClk DDR is equal to 2 x MCK. DDRCK is equal to MCK.
	PMC_PMC_MCKR_MDIV_PCK_DIV2 = 0x1
	// Master Clock is Prescaler Output Clock divided by 4.SysClk DDR is equal to 2 x MCK. DDRCK is equal to MCK.
	PMC_PMC_MCKR_MDIV_PCK_DIV4 = 0x2
	// Master Clock is Prescaler Output Clock divided by 3.SysClk DDR is equal to 2 x MCK. DDRCK is equal to MCK.
	PMC_PMC_MCKR_MDIV_PCK_DIV3 = 0x3
	// Position of PLLADIV2 field.
	PMC_PMC_MCKR_PLLADIV2_Pos = 0xc
	// Bit mask of PLLADIV2 field.
	PMC_PMC_MCKR_PLLADIV2_Msk = 0x1000
	// Bit PLLADIV2.
	PMC_PMC_MCKR_PLLADIV2 = 0x1000
	// PLLA clock frequency is divided by 1.
	PMC_PMC_MCKR_PLLADIV2_NOT_DIV2 = 0x0
	// PLLA clock frequency is divided by 2.
	PMC_PMC_MCKR_PLLADIV2_DIV2 = 0x1

	// PMC_USB: USB Clock Register
	// Position of USBS field.
	PMC_PMC_USB_USBS_Pos = 0x0
	// Bit mask of USBS field.
	PMC_PMC_USB_USBS_Msk = 0x1
	// Bit USBS.
	PMC_PMC_USB_USBS = 0x1
	// Position of USBDIV field.
	PMC_PMC_USB_USBDIV_Pos = 0x8
	// Bit mask of USBDIV field.
	PMC_PMC_USB_USBDIV_Msk = 0xf00

	// PMC_SMD: Soft Modem Clock Register
	// Position of SMDS field.
	PMC_PMC_SMD_SMDS_Pos = 0x0
	// Bit mask of SMDS field.
	PMC_PMC_SMD_SMDS_Msk = 0x1
	// Bit SMDS.
	PMC_PMC_SMD_SMDS = 0x1
	// Position of SMDDIV field.
	PMC_PMC_SMD_SMDDIV_Pos = 0x8
	// Bit mask of SMDDIV field.
	PMC_PMC_SMD_SMDDIV_Msk = 0x1f00

	// PMC_PCK: Programmable Clock 0 Register
	// Position of CSS field.
	PMC_PMC_PCK_CSS_Pos = 0x0
	// Bit mask of CSS field.
	PMC_PMC_PCK_CSS_Msk = 0x7
	// Slow Clock is selected
	PMC_PMC_PCK_CSS_SLOW_CLK = 0x0
	// Main Clock is selected
	PMC_PMC_PCK_CSS_MAIN_CLK = 0x1
	// PLLACK/PLLADIV2 is selected
	PMC_PMC_PCK_CSS_PLLA_CLK = 0x2
	// UPLL Clock is selected
	PMC_PMC_PCK_CSS_UPLL_CLK = 0x3
	// Master Clock is selected
	PMC_PMC_PCK_CSS_MCK_CLK = 0x4
	// Position of PRES field.
	PMC_PMC_PCK_PRES_Pos = 0x4
	// Bit mask of PRES field.
	PMC_PMC_PCK_PRES_Msk = 0x70
	// Selected clock
	PMC_PMC_PCK_PRES_CLOCK = 0x0
	// Selected clock divided by 2
	PMC_PMC_PCK_PRES_CLOCK_DIV2 = 0x1
	// Selected clock divided by 4
	PMC_PMC_PCK_PRES_CLOCK_DIV4 = 0x2
	// Selected clock divided by 8
	PMC_PMC_PCK_PRES_CLOCK_DIV8 = 0x3
	// Selected clock divided by 16
	PMC_PMC_PCK_PRES_CLOCK_DIV16 = 0x4
	// Selected clock divided by 32
	PMC_PMC_PCK_PRES_CLOCK_DIV32 = 0x5
	// Selected clock divided by 64
	PMC_PMC_PCK_PRES_CLOCK_DIV64 = 0x6

	// PMC_IER: Interrupt Enable Register
	// Position of MOSCXTS field.
	PMC_PMC_IER_MOSCXTS_Pos = 0x0
	// Bit mask of MOSCXTS field.
	PMC_PMC_IER_MOSCXTS_Msk = 0x1
	// Bit MOSCXTS.
	PMC_PMC_IER_MOSCXTS = 0x1
	// Position of LOCKA field.
	PMC_PMC_IER_LOCKA_Pos = 0x1
	// Bit mask of LOCKA field.
	PMC_PMC_IER_LOCKA_Msk = 0x2
	// Bit LOCKA.
	PMC_PMC_IER_LOCKA = 0x2
	// Position of MCKRDY field.
	PMC_PMC_IER_MCKRDY_Pos = 0x3
	// Bit mask of MCKRDY field.
	PMC_PMC_IER_MCKRDY_Msk = 0x8
	// Bit MCKRDY.
	PMC_PMC_IER_MCKRDY = 0x8
	// Position of LOCKU field.
	PMC_PMC_IER_LOCKU_Pos = 0x6
	// Bit mask of LOCKU field.
	PMC_PMC_IER_LOCKU_Msk = 0x40
	// Bit LOCKU.
	PMC_PMC_IER_LOCKU = 0x40
	// Position of PCKRDY0 field.
	PMC_PMC_IER_PCKRDY0_Pos = 0x8
	// Bit mask of PCKRDY0 field.
	PMC_PMC_IER_PCKRDY0_Msk = 0x100
	// Bit PCKRDY0.
	PMC_PMC_IER_PCKRDY0 = 0x100
	// Position of PCKRDY1 field.
	PMC_PMC_IER_PCKRDY1_Pos = 0x9
	// Bit mask of PCKRDY1 field.
	PMC_PMC_IER_PCKRDY1_Msk = 0x200
	// Bit PCKRDY1.
	PMC_PMC_IER_PCKRDY1 = 0x200
	// Position of MOSCSELS field.
	PMC_PMC_IER_MOSCSELS_Pos = 0x10
	// Bit mask of MOSCSELS field.
	PMC_PMC_IER_MOSCSELS_Msk = 0x10000
	// Bit MOSCSELS.
	PMC_PMC_IER_MOSCSELS = 0x10000
	// Position of MOSCRCS field.
	PMC_PMC_IER_MOSCRCS_Pos = 0x11
	// Bit mask of MOSCRCS field.
	PMC_PMC_IER_MOSCRCS_Msk = 0x20000
	// Bit MOSCRCS.
	PMC_PMC_IER_MOSCRCS = 0x20000
	// Position of CFDEV field.
	PMC_PMC_IER_CFDEV_Pos = 0x12
	// Bit mask of CFDEV field.
	PMC_PMC_IER_CFDEV_Msk = 0x40000
	// Bit CFDEV.
	PMC_PMC_IER_CFDEV = 0x40000

	// PMC_IDR: Interrupt Disable Register
	// Position of MOSCXTS field.
	PMC_PMC_IDR_MOSCXTS_Pos = 0x0
	// Bit mask of MOSCXTS field.
	PMC_PMC_IDR_MOSCXTS_Msk = 0x1
	// Bit MOSCXTS.
	PMC_PMC_IDR_MOSCXTS = 0x1
	// Position of LOCKA field.
	PMC_PMC_IDR_LOCKA_Pos = 0x1
	// Bit mask of LOCKA field.
	PMC_PMC_IDR_LOCKA_Msk = 0x2
	// Bit LOCKA.
	PMC_PMC_IDR_LOCKA = 0x2
	// Position of MCKRDY field.
	PMC_PMC_IDR_MCKRDY_Pos = 0x3
	// Bit mask of MCKRDY field.
	PMC_PMC_IDR_MCKRDY_Msk = 0x8
	// Bit MCKRDY.
	PMC_PMC_IDR_MCKRDY = 0x8
	// Position of LOCKU field.
	PMC_PMC_IDR_LOCKU_Pos = 0x6
	// Bit mask of LOCKU field.
	PMC_PMC_IDR_LOCKU_Msk = 0x40
	// Bit LOCKU.
	PMC_PMC_IDR_LOCKU = 0x40
	// Position of PCKRDY0 field.
	PMC_PMC_IDR_PCKRDY0_Pos = 0x8
	// Bit mask of PCKRDY0 field.
	PMC_PMC_IDR_PCKRDY0_Msk = 0x100
	// Bit PCKRDY0.
	PMC_PMC_IDR_PCKRDY0 = 0x100
	// Position of PCKRDY1 field.
	PMC_PMC_IDR_PCKRDY1_Pos = 0x9
	// Bit mask of PCKRDY1 field.
	PMC_PMC_IDR_PCKRDY1_Msk = 0x200
	// Bit PCKRDY1.
	PMC_PMC_IDR_PCKRDY1 = 0x200
	// Position of MOSCSELS field.
	PMC_PMC_IDR_MOSCSELS_Pos = 0x10
	// Bit mask of MOSCSELS field.
	PMC_PMC_IDR_MOSCSELS_Msk = 0x10000
	// Bit MOSCSELS.
	PMC_PMC_IDR_MOSCSELS = 0x10000
	// Position of MOSCRCS field.
	PMC_PMC_IDR_MOSCRCS_Pos = 0x11
	// Bit mask of MOSCRCS field.
	PMC_PMC_IDR_MOSCRCS_Msk = 0x20000
	// Bit MOSCRCS.
	PMC_PMC_IDR_MOSCRCS = 0x20000
	// Position of CFDEV field.
	PMC_PMC_IDR_CFDEV_Pos = 0x12
	// Bit mask of CFDEV field.
	PMC_PMC_IDR_CFDEV_Msk = 0x40000
	// Bit CFDEV.
	PMC_PMC_IDR_CFDEV = 0x40000

	// PMC_SR: Status Register
	// Position of MOSCXTS field.
	PMC_PMC_SR_MOSCXTS_Pos = 0x0
	// Bit mask of MOSCXTS field.
	PMC_PMC_SR_MOSCXTS_Msk = 0x1
	// Bit MOSCXTS.
	PMC_PMC_SR_MOSCXTS = 0x1
	// Position of LOCKA field.
	PMC_PMC_SR_LOCKA_Pos = 0x1
	// Bit mask of LOCKA field.
	PMC_PMC_SR_LOCKA_Msk = 0x2
	// Bit LOCKA.
	PMC_PMC_SR_LOCKA = 0x2
	// Position of MCKRDY field.
	PMC_PMC_SR_MCKRDY_Pos = 0x3
	// Bit mask of MCKRDY field.
	PMC_PMC_SR_MCKRDY_Msk = 0x8
	// Bit MCKRDY.
	PMC_PMC_SR_MCKRDY = 0x8
	// Position of LOCKU field.
	PMC_PMC_SR_LOCKU_Pos = 0x6
	// Bit mask of LOCKU field.
	PMC_PMC_SR_LOCKU_Msk = 0x40
	// Bit LOCKU.
	PMC_PMC_SR_LOCKU = 0x40
	// Position of OSCSELS field.
	PMC_PMC_SR_OSCSELS_Pos = 0x7
	// Bit mask of OSCSELS field.
	PMC_PMC_SR_OSCSELS_Msk = 0x80
	// Bit OSCSELS.
	PMC_PMC_SR_OSCSELS = 0x80
	// Position of PCKRDY0 field.
	PMC_PMC_SR_PCKRDY0_Pos = 0x8
	// Bit mask of PCKRDY0 field.
	PMC_PMC_SR_PCKRDY0_Msk = 0x100
	// Bit PCKRDY0.
	PMC_PMC_SR_PCKRDY0 = 0x100
	// Position of PCKRDY1 field.
	PMC_PMC_SR_PCKRDY1_Pos = 0x9
	// Bit mask of PCKRDY1 field.
	PMC_PMC_SR_PCKRDY1_Msk = 0x200
	// Bit PCKRDY1.
	PMC_PMC_SR_PCKRDY1 = 0x200
	// Position of MOSCSELS field.
	PMC_PMC_SR_MOSCSELS_Pos = 0x10
	// Bit mask of MOSCSELS field.
	PMC_PMC_SR_MOSCSELS_Msk = 0x10000
	// Bit MOSCSELS.
	PMC_PMC_SR_MOSCSELS = 0x10000
	// Position of MOSCRCS field.
	PMC_PMC_SR_MOSCRCS_Pos = 0x11
	// Bit mask of MOSCRCS field.
	PMC_PMC_SR_MOSCRCS_Msk = 0x20000
	// Bit MOSCRCS.
	PMC_PMC_SR_MOSCRCS = 0x20000
	// Position of CFDEV field.
	PMC_PMC_SR_CFDEV_Pos = 0x12
	// Bit mask of CFDEV field.
	PMC_PMC_SR_CFDEV_Msk = 0x40000
	// Bit CFDEV.
	PMC_PMC_SR_CFDEV = 0x40000
	// Position of CFDS field.
	PMC_PMC_SR_CFDS_Pos = 0x13
	// Bit mask of CFDS field.
	PMC_PMC_SR_CFDS_Msk = 0x80000
	// Bit CFDS.
	PMC_PMC_SR_CFDS = 0x80000
	// Position of FOS field.
	PMC_PMC_SR_FOS_Pos = 0x14
	// Bit mask of FOS field.
	PMC_PMC_SR_FOS_Msk = 0x100000
	// Bit FOS.
	PMC_PMC_SR_FOS = 0x100000

	// PMC_IMR: Interrupt Mask Register
	// Position of MOSCXTS field.
	PMC_PMC_IMR_MOSCXTS_Pos = 0x0
	// Bit mask of MOSCXTS field.
	PMC_PMC_IMR_MOSCXTS_Msk = 0x1
	// Bit MOSCXTS.
	PMC_PMC_IMR_MOSCXTS = 0x1
	// Position of LOCKA field.
	PMC_PMC_IMR_LOCKA_Pos = 0x1
	// Bit mask of LOCKA field.
	PMC_PMC_IMR_LOCKA_Msk = 0x2
	// Bit LOCKA.
	PMC_PMC_IMR_LOCKA = 0x2
	// Position of MCKRDY field.
	PMC_PMC_IMR_MCKRDY_Pos = 0x3
	// Bit mask of MCKRDY field.
	PMC_PMC_IMR_MCKRDY_Msk = 0x8
	// Bit MCKRDY.
	PMC_PMC_IMR_MCKRDY = 0x8
	// Position of PCKRDY0 field.
	PMC_PMC_IMR_PCKRDY0_Pos = 0x8
	// Bit mask of PCKRDY0 field.
	PMC_PMC_IMR_PCKRDY0_Msk = 0x100
	// Bit PCKRDY0.
	PMC_PMC_IMR_PCKRDY0 = 0x100
	// Position of PCKRDY1 field.
	PMC_PMC_IMR_PCKRDY1_Pos = 0x9
	// Bit mask of PCKRDY1 field.
	PMC_PMC_IMR_PCKRDY1_Msk = 0x200
	// Bit PCKRDY1.
	PMC_PMC_IMR_PCKRDY1 = 0x200
	// Position of MOSCSELS field.
	PMC_PMC_IMR_MOSCSELS_Pos = 0x10
	// Bit mask of MOSCSELS field.
	PMC_PMC_IMR_MOSCSELS_Msk = 0x10000
	// Bit MOSCSELS.
	PMC_PMC_IMR_MOSCSELS = 0x10000
	// Position of MOSCRCS field.
	PMC_PMC_IMR_MOSCRCS_Pos = 0x11
	// Bit mask of MOSCRCS field.
	PMC_PMC_IMR_MOSCRCS_Msk = 0x20000
	// Bit MOSCRCS.
	PMC_PMC_IMR_MOSCRCS = 0x20000
	// Position of CFDEV field.
	PMC_PMC_IMR_CFDEV_Pos = 0x12
	// Bit mask of CFDEV field.
	PMC_PMC_IMR_CFDEV_Msk = 0x40000
	// Bit CFDEV.
	PMC_PMC_IMR_CFDEV = 0x40000

	// PMC_PLLICPR: PLL Charge Pump Current Register
	// Position of ICPLLA field.
	PMC_PMC_PLLICPR_ICPLLA_Pos = 0x0
	// Bit mask of ICPLLA field.
	PMC_PMC_PLLICPR_ICPLLA_Msk = 0x1
	// Bit ICPLLA.
	PMC_PMC_PLLICPR_ICPLLA = 0x1

	// PMC_WPMR: Write Protect Mode Register
	// Position of WPEN field.
	PMC_PMC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	PMC_PMC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	PMC_PMC_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	PMC_PMC_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	PMC_PMC_WPMR_WPKEY_Msk = 0xffffff00

	// PMC_WPSR: Write Protect Status Register
	// Position of WPVS field.
	PMC_PMC_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	PMC_PMC_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	PMC_PMC_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	PMC_PMC_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	PMC_PMC_WPSR_WPVSRC_Msk = 0xffff00

	// PMC_PCER1: Peripheral Clock Enable Register 1
	// Position of PID32 field.
	PMC_PMC_PCER1_PID32_Pos = 0x0
	// Bit mask of PID32 field.
	PMC_PMC_PCER1_PID32_Msk = 0x1
	// Bit PID32.
	PMC_PMC_PCER1_PID32 = 0x1
	// Position of PID33 field.
	PMC_PMC_PCER1_PID33_Pos = 0x1
	// Bit mask of PID33 field.
	PMC_PMC_PCER1_PID33_Msk = 0x2
	// Bit PID33.
	PMC_PMC_PCER1_PID33 = 0x2
	// Position of PID34 field.
	PMC_PMC_PCER1_PID34_Pos = 0x2
	// Bit mask of PID34 field.
	PMC_PMC_PCER1_PID34_Msk = 0x4
	// Bit PID34.
	PMC_PMC_PCER1_PID34 = 0x4
	// Position of PID35 field.
	PMC_PMC_PCER1_PID35_Pos = 0x3
	// Bit mask of PID35 field.
	PMC_PMC_PCER1_PID35_Msk = 0x8
	// Bit PID35.
	PMC_PMC_PCER1_PID35 = 0x8
	// Position of PID36 field.
	PMC_PMC_PCER1_PID36_Pos = 0x4
	// Bit mask of PID36 field.
	PMC_PMC_PCER1_PID36_Msk = 0x10
	// Bit PID36.
	PMC_PMC_PCER1_PID36 = 0x10
	// Position of PID37 field.
	PMC_PMC_PCER1_PID37_Pos = 0x5
	// Bit mask of PID37 field.
	PMC_PMC_PCER1_PID37_Msk = 0x20
	// Bit PID37.
	PMC_PMC_PCER1_PID37 = 0x20
	// Position of PID38 field.
	PMC_PMC_PCER1_PID38_Pos = 0x6
	// Bit mask of PID38 field.
	PMC_PMC_PCER1_PID38_Msk = 0x40
	// Bit PID38.
	PMC_PMC_PCER1_PID38 = 0x40
	// Position of PID39 field.
	PMC_PMC_PCER1_PID39_Pos = 0x7
	// Bit mask of PID39 field.
	PMC_PMC_PCER1_PID39_Msk = 0x80
	// Bit PID39.
	PMC_PMC_PCER1_PID39 = 0x80
	// Position of PID40 field.
	PMC_PMC_PCER1_PID40_Pos = 0x8
	// Bit mask of PID40 field.
	PMC_PMC_PCER1_PID40_Msk = 0x100
	// Bit PID40.
	PMC_PMC_PCER1_PID40 = 0x100
	// Position of PID41 field.
	PMC_PMC_PCER1_PID41_Pos = 0x9
	// Bit mask of PID41 field.
	PMC_PMC_PCER1_PID41_Msk = 0x200
	// Bit PID41.
	PMC_PMC_PCER1_PID41 = 0x200
	// Position of PID42 field.
	PMC_PMC_PCER1_PID42_Pos = 0xa
	// Bit mask of PID42 field.
	PMC_PMC_PCER1_PID42_Msk = 0x400
	// Bit PID42.
	PMC_PMC_PCER1_PID42 = 0x400
	// Position of PID43 field.
	PMC_PMC_PCER1_PID43_Pos = 0xb
	// Bit mask of PID43 field.
	PMC_PMC_PCER1_PID43_Msk = 0x800
	// Bit PID43.
	PMC_PMC_PCER1_PID43 = 0x800
	// Position of PID44 field.
	PMC_PMC_PCER1_PID44_Pos = 0xc
	// Bit mask of PID44 field.
	PMC_PMC_PCER1_PID44_Msk = 0x1000
	// Bit PID44.
	PMC_PMC_PCER1_PID44 = 0x1000
	// Position of PID45 field.
	PMC_PMC_PCER1_PID45_Pos = 0xd
	// Bit mask of PID45 field.
	PMC_PMC_PCER1_PID45_Msk = 0x2000
	// Bit PID45.
	PMC_PMC_PCER1_PID45 = 0x2000
	// Position of PID46 field.
	PMC_PMC_PCER1_PID46_Pos = 0xe
	// Bit mask of PID46 field.
	PMC_PMC_PCER1_PID46_Msk = 0x4000
	// Bit PID46.
	PMC_PMC_PCER1_PID46 = 0x4000
	// Position of PID47 field.
	PMC_PMC_PCER1_PID47_Pos = 0xf
	// Bit mask of PID47 field.
	PMC_PMC_PCER1_PID47_Msk = 0x8000
	// Bit PID47.
	PMC_PMC_PCER1_PID47 = 0x8000
	// Position of PID48 field.
	PMC_PMC_PCER1_PID48_Pos = 0x10
	// Bit mask of PID48 field.
	PMC_PMC_PCER1_PID48_Msk = 0x10000
	// Bit PID48.
	PMC_PMC_PCER1_PID48 = 0x10000
	// Position of PID49 field.
	PMC_PMC_PCER1_PID49_Pos = 0x11
	// Bit mask of PID49 field.
	PMC_PMC_PCER1_PID49_Msk = 0x20000
	// Bit PID49.
	PMC_PMC_PCER1_PID49 = 0x20000
	// Position of PID50 field.
	PMC_PMC_PCER1_PID50_Pos = 0x12
	// Bit mask of PID50 field.
	PMC_PMC_PCER1_PID50_Msk = 0x40000
	// Bit PID50.
	PMC_PMC_PCER1_PID50 = 0x40000
	// Position of PID51 field.
	PMC_PMC_PCER1_PID51_Pos = 0x13
	// Bit mask of PID51 field.
	PMC_PMC_PCER1_PID51_Msk = 0x80000
	// Bit PID51.
	PMC_PMC_PCER1_PID51 = 0x80000
	// Position of PID53 field.
	PMC_PMC_PCER1_PID53_Pos = 0x14
	// Bit mask of PID53 field.
	PMC_PMC_PCER1_PID53_Msk = 0x300000
	// Position of PID54 field.
	PMC_PMC_PCER1_PID54_Pos = 0x16
	// Bit mask of PID54 field.
	PMC_PMC_PCER1_PID54_Msk = 0x400000
	// Bit PID54.
	PMC_PMC_PCER1_PID54 = 0x400000
	// Position of PID55 field.
	PMC_PMC_PCER1_PID55_Pos = 0x17
	// Bit mask of PID55 field.
	PMC_PMC_PCER1_PID55_Msk = 0x800000
	// Bit PID55.
	PMC_PMC_PCER1_PID55 = 0x800000
	// Position of PID56 field.
	PMC_PMC_PCER1_PID56_Pos = 0x18
	// Bit mask of PID56 field.
	PMC_PMC_PCER1_PID56_Msk = 0x1000000
	// Bit PID56.
	PMC_PMC_PCER1_PID56 = 0x1000000
	// Position of PID57 field.
	PMC_PMC_PCER1_PID57_Pos = 0x19
	// Bit mask of PID57 field.
	PMC_PMC_PCER1_PID57_Msk = 0x2000000
	// Bit PID57.
	PMC_PMC_PCER1_PID57 = 0x2000000
	// Position of PID58 field.
	PMC_PMC_PCER1_PID58_Pos = 0x1a
	// Bit mask of PID58 field.
	PMC_PMC_PCER1_PID58_Msk = 0x4000000
	// Bit PID58.
	PMC_PMC_PCER1_PID58 = 0x4000000
	// Position of PID59 field.
	PMC_PMC_PCER1_PID59_Pos = 0x1b
	// Bit mask of PID59 field.
	PMC_PMC_PCER1_PID59_Msk = 0x8000000
	// Bit PID59.
	PMC_PMC_PCER1_PID59 = 0x8000000
	// Position of PID60 field.
	PMC_PMC_PCER1_PID60_Pos = 0x1c
	// Bit mask of PID60 field.
	PMC_PMC_PCER1_PID60_Msk = 0x10000000
	// Bit PID60.
	PMC_PMC_PCER1_PID60 = 0x10000000
	// Position of PID61 field.
	PMC_PMC_PCER1_PID61_Pos = 0x1d
	// Bit mask of PID61 field.
	PMC_PMC_PCER1_PID61_Msk = 0x20000000
	// Bit PID61.
	PMC_PMC_PCER1_PID61 = 0x20000000
	// Position of PID62 field.
	PMC_PMC_PCER1_PID62_Pos = 0x1e
	// Bit mask of PID62 field.
	PMC_PMC_PCER1_PID62_Msk = 0x40000000
	// Bit PID62.
	PMC_PMC_PCER1_PID62 = 0x40000000
	// Position of PID63 field.
	PMC_PMC_PCER1_PID63_Pos = 0x1f
	// Bit mask of PID63 field.
	PMC_PMC_PCER1_PID63_Msk = 0x80000000
	// Bit PID63.
	PMC_PMC_PCER1_PID63 = 0x80000000

	// PMC_PCDR1: Peripheral Clock Disable Register 1
	// Position of PID32 field.
	PMC_PMC_PCDR1_PID32_Pos = 0x0
	// Bit mask of PID32 field.
	PMC_PMC_PCDR1_PID32_Msk = 0x1
	// Bit PID32.
	PMC_PMC_PCDR1_PID32 = 0x1
	// Position of PID33 field.
	PMC_PMC_PCDR1_PID33_Pos = 0x1
	// Bit mask of PID33 field.
	PMC_PMC_PCDR1_PID33_Msk = 0x2
	// Bit PID33.
	PMC_PMC_PCDR1_PID33 = 0x2
	// Position of PID34 field.
	PMC_PMC_PCDR1_PID34_Pos = 0x2
	// Bit mask of PID34 field.
	PMC_PMC_PCDR1_PID34_Msk = 0x4
	// Bit PID34.
	PMC_PMC_PCDR1_PID34 = 0x4
	// Position of PID35 field.
	PMC_PMC_PCDR1_PID35_Pos = 0x3
	// Bit mask of PID35 field.
	PMC_PMC_PCDR1_PID35_Msk = 0x8
	// Bit PID35.
	PMC_PMC_PCDR1_PID35 = 0x8
	// Position of PID36 field.
	PMC_PMC_PCDR1_PID36_Pos = 0x4
	// Bit mask of PID36 field.
	PMC_PMC_PCDR1_PID36_Msk = 0x10
	// Bit PID36.
	PMC_PMC_PCDR1_PID36 = 0x10
	// Position of PID37 field.
	PMC_PMC_PCDR1_PID37_Pos = 0x5
	// Bit mask of PID37 field.
	PMC_PMC_PCDR1_PID37_Msk = 0x20
	// Bit PID37.
	PMC_PMC_PCDR1_PID37 = 0x20
	// Position of PID38 field.
	PMC_PMC_PCDR1_PID38_Pos = 0x6
	// Bit mask of PID38 field.
	PMC_PMC_PCDR1_PID38_Msk = 0x40
	// Bit PID38.
	PMC_PMC_PCDR1_PID38 = 0x40
	// Position of PID39 field.
	PMC_PMC_PCDR1_PID39_Pos = 0x7
	// Bit mask of PID39 field.
	PMC_PMC_PCDR1_PID39_Msk = 0x80
	// Bit PID39.
	PMC_PMC_PCDR1_PID39 = 0x80
	// Position of PID40 field.
	PMC_PMC_PCDR1_PID40_Pos = 0x8
	// Bit mask of PID40 field.
	PMC_PMC_PCDR1_PID40_Msk = 0x100
	// Bit PID40.
	PMC_PMC_PCDR1_PID40 = 0x100
	// Position of PID41 field.
	PMC_PMC_PCDR1_PID41_Pos = 0x9
	// Bit mask of PID41 field.
	PMC_PMC_PCDR1_PID41_Msk = 0x200
	// Bit PID41.
	PMC_PMC_PCDR1_PID41 = 0x200
	// Position of PID42 field.
	PMC_PMC_PCDR1_PID42_Pos = 0xa
	// Bit mask of PID42 field.
	PMC_PMC_PCDR1_PID42_Msk = 0x400
	// Bit PID42.
	PMC_PMC_PCDR1_PID42 = 0x400
	// Position of PID43 field.
	PMC_PMC_PCDR1_PID43_Pos = 0xb
	// Bit mask of PID43 field.
	PMC_PMC_PCDR1_PID43_Msk = 0x800
	// Bit PID43.
	PMC_PMC_PCDR1_PID43 = 0x800
	// Position of PID44 field.
	PMC_PMC_PCDR1_PID44_Pos = 0xc
	// Bit mask of PID44 field.
	PMC_PMC_PCDR1_PID44_Msk = 0x1000
	// Bit PID44.
	PMC_PMC_PCDR1_PID44 = 0x1000
	// Position of PID45 field.
	PMC_PMC_PCDR1_PID45_Pos = 0xd
	// Bit mask of PID45 field.
	PMC_PMC_PCDR1_PID45_Msk = 0x2000
	// Bit PID45.
	PMC_PMC_PCDR1_PID45 = 0x2000
	// Position of PID46 field.
	PMC_PMC_PCDR1_PID46_Pos = 0xe
	// Bit mask of PID46 field.
	PMC_PMC_PCDR1_PID46_Msk = 0x4000
	// Bit PID46.
	PMC_PMC_PCDR1_PID46 = 0x4000
	// Position of PID47 field.
	PMC_PMC_PCDR1_PID47_Pos = 0xf
	// Bit mask of PID47 field.
	PMC_PMC_PCDR1_PID47_Msk = 0x8000
	// Bit PID47.
	PMC_PMC_PCDR1_PID47 = 0x8000
	// Position of PID48 field.
	PMC_PMC_PCDR1_PID48_Pos = 0x10
	// Bit mask of PID48 field.
	PMC_PMC_PCDR1_PID48_Msk = 0x10000
	// Bit PID48.
	PMC_PMC_PCDR1_PID48 = 0x10000
	// Position of PID49 field.
	PMC_PMC_PCDR1_PID49_Pos = 0x11
	// Bit mask of PID49 field.
	PMC_PMC_PCDR1_PID49_Msk = 0x20000
	// Bit PID49.
	PMC_PMC_PCDR1_PID49 = 0x20000
	// Position of PID50 field.
	PMC_PMC_PCDR1_PID50_Pos = 0x12
	// Bit mask of PID50 field.
	PMC_PMC_PCDR1_PID50_Msk = 0x40000
	// Bit PID50.
	PMC_PMC_PCDR1_PID50 = 0x40000
	// Position of PID51 field.
	PMC_PMC_PCDR1_PID51_Pos = 0x13
	// Bit mask of PID51 field.
	PMC_PMC_PCDR1_PID51_Msk = 0x80000
	// Bit PID51.
	PMC_PMC_PCDR1_PID51 = 0x80000
	// Position of PID53 field.
	PMC_PMC_PCDR1_PID53_Pos = 0x14
	// Bit mask of PID53 field.
	PMC_PMC_PCDR1_PID53_Msk = 0x300000
	// Position of PID54 field.
	PMC_PMC_PCDR1_PID54_Pos = 0x16
	// Bit mask of PID54 field.
	PMC_PMC_PCDR1_PID54_Msk = 0x400000
	// Bit PID54.
	PMC_PMC_PCDR1_PID54 = 0x400000
	// Position of PID55 field.
	PMC_PMC_PCDR1_PID55_Pos = 0x17
	// Bit mask of PID55 field.
	PMC_PMC_PCDR1_PID55_Msk = 0x800000
	// Bit PID55.
	PMC_PMC_PCDR1_PID55 = 0x800000
	// Position of PID56 field.
	PMC_PMC_PCDR1_PID56_Pos = 0x18
	// Bit mask of PID56 field.
	PMC_PMC_PCDR1_PID56_Msk = 0x1000000
	// Bit PID56.
	PMC_PMC_PCDR1_PID56 = 0x1000000
	// Position of PID57 field.
	PMC_PMC_PCDR1_PID57_Pos = 0x19
	// Bit mask of PID57 field.
	PMC_PMC_PCDR1_PID57_Msk = 0x2000000
	// Bit PID57.
	PMC_PMC_PCDR1_PID57 = 0x2000000
	// Position of PID58 field.
	PMC_PMC_PCDR1_PID58_Pos = 0x1a
	// Bit mask of PID58 field.
	PMC_PMC_PCDR1_PID58_Msk = 0x4000000
	// Bit PID58.
	PMC_PMC_PCDR1_PID58 = 0x4000000
	// Position of PID59 field.
	PMC_PMC_PCDR1_PID59_Pos = 0x1b
	// Bit mask of PID59 field.
	PMC_PMC_PCDR1_PID59_Msk = 0x8000000
	// Bit PID59.
	PMC_PMC_PCDR1_PID59 = 0x8000000
	// Position of PID60 field.
	PMC_PMC_PCDR1_PID60_Pos = 0x1c
	// Bit mask of PID60 field.
	PMC_PMC_PCDR1_PID60_Msk = 0x10000000
	// Bit PID60.
	PMC_PMC_PCDR1_PID60 = 0x10000000
	// Position of PID61 field.
	PMC_PMC_PCDR1_PID61_Pos = 0x1d
	// Bit mask of PID61 field.
	PMC_PMC_PCDR1_PID61_Msk = 0x20000000
	// Bit PID61.
	PMC_PMC_PCDR1_PID61 = 0x20000000
	// Position of PID62 field.
	PMC_PMC_PCDR1_PID62_Pos = 0x1e
	// Bit mask of PID62 field.
	PMC_PMC_PCDR1_PID62_Msk = 0x40000000
	// Bit PID62.
	PMC_PMC_PCDR1_PID62 = 0x40000000
	// Position of PID63 field.
	PMC_PMC_PCDR1_PID63_Pos = 0x1f
	// Bit mask of PID63 field.
	PMC_PMC_PCDR1_PID63_Msk = 0x80000000
	// Bit PID63.
	PMC_PMC_PCDR1_PID63 = 0x80000000

	// PMC_PCSR1: Peripheral Clock Status Register 1
	// Position of PID32 field.
	PMC_PMC_PCSR1_PID32_Pos = 0x0
	// Bit mask of PID32 field.
	PMC_PMC_PCSR1_PID32_Msk = 0x1
	// Bit PID32.
	PMC_PMC_PCSR1_PID32 = 0x1
	// Position of PID33 field.
	PMC_PMC_PCSR1_PID33_Pos = 0x1
	// Bit mask of PID33 field.
	PMC_PMC_PCSR1_PID33_Msk = 0x2
	// Bit PID33.
	PMC_PMC_PCSR1_PID33 = 0x2
	// Position of PID34 field.
	PMC_PMC_PCSR1_PID34_Pos = 0x2
	// Bit mask of PID34 field.
	PMC_PMC_PCSR1_PID34_Msk = 0x4
	// Bit PID34.
	PMC_PMC_PCSR1_PID34 = 0x4
	// Position of PID35 field.
	PMC_PMC_PCSR1_PID35_Pos = 0x3
	// Bit mask of PID35 field.
	PMC_PMC_PCSR1_PID35_Msk = 0x8
	// Bit PID35.
	PMC_PMC_PCSR1_PID35 = 0x8
	// Position of PID36 field.
	PMC_PMC_PCSR1_PID36_Pos = 0x4
	// Bit mask of PID36 field.
	PMC_PMC_PCSR1_PID36_Msk = 0x10
	// Bit PID36.
	PMC_PMC_PCSR1_PID36 = 0x10
	// Position of PID37 field.
	PMC_PMC_PCSR1_PID37_Pos = 0x5
	// Bit mask of PID37 field.
	PMC_PMC_PCSR1_PID37_Msk = 0x20
	// Bit PID37.
	PMC_PMC_PCSR1_PID37 = 0x20
	// Position of PID38 field.
	PMC_PMC_PCSR1_PID38_Pos = 0x6
	// Bit mask of PID38 field.
	PMC_PMC_PCSR1_PID38_Msk = 0x40
	// Bit PID38.
	PMC_PMC_PCSR1_PID38 = 0x40
	// Position of PID39 field.
	PMC_PMC_PCSR1_PID39_Pos = 0x7
	// Bit mask of PID39 field.
	PMC_PMC_PCSR1_PID39_Msk = 0x80
	// Bit PID39.
	PMC_PMC_PCSR1_PID39 = 0x80
	// Position of PID40 field.
	PMC_PMC_PCSR1_PID40_Pos = 0x8
	// Bit mask of PID40 field.
	PMC_PMC_PCSR1_PID40_Msk = 0x100
	// Bit PID40.
	PMC_PMC_PCSR1_PID40 = 0x100
	// Position of PID41 field.
	PMC_PMC_PCSR1_PID41_Pos = 0x9
	// Bit mask of PID41 field.
	PMC_PMC_PCSR1_PID41_Msk = 0x200
	// Bit PID41.
	PMC_PMC_PCSR1_PID41 = 0x200
	// Position of PID42 field.
	PMC_PMC_PCSR1_PID42_Pos = 0xa
	// Bit mask of PID42 field.
	PMC_PMC_PCSR1_PID42_Msk = 0x400
	// Bit PID42.
	PMC_PMC_PCSR1_PID42 = 0x400
	// Position of PID43 field.
	PMC_PMC_PCSR1_PID43_Pos = 0xb
	// Bit mask of PID43 field.
	PMC_PMC_PCSR1_PID43_Msk = 0x800
	// Bit PID43.
	PMC_PMC_PCSR1_PID43 = 0x800
	// Position of PID44 field.
	PMC_PMC_PCSR1_PID44_Pos = 0xc
	// Bit mask of PID44 field.
	PMC_PMC_PCSR1_PID44_Msk = 0x1000
	// Bit PID44.
	PMC_PMC_PCSR1_PID44 = 0x1000
	// Position of PID45 field.
	PMC_PMC_PCSR1_PID45_Pos = 0xd
	// Bit mask of PID45 field.
	PMC_PMC_PCSR1_PID45_Msk = 0x2000
	// Bit PID45.
	PMC_PMC_PCSR1_PID45 = 0x2000
	// Position of PID46 field.
	PMC_PMC_PCSR1_PID46_Pos = 0xe
	// Bit mask of PID46 field.
	PMC_PMC_PCSR1_PID46_Msk = 0x4000
	// Bit PID46.
	PMC_PMC_PCSR1_PID46 = 0x4000
	// Position of PID47 field.
	PMC_PMC_PCSR1_PID47_Pos = 0xf
	// Bit mask of PID47 field.
	PMC_PMC_PCSR1_PID47_Msk = 0x8000
	// Bit PID47.
	PMC_PMC_PCSR1_PID47 = 0x8000
	// Position of PID48 field.
	PMC_PMC_PCSR1_PID48_Pos = 0x10
	// Bit mask of PID48 field.
	PMC_PMC_PCSR1_PID48_Msk = 0x10000
	// Bit PID48.
	PMC_PMC_PCSR1_PID48 = 0x10000
	// Position of PID49 field.
	PMC_PMC_PCSR1_PID49_Pos = 0x11
	// Bit mask of PID49 field.
	PMC_PMC_PCSR1_PID49_Msk = 0x20000
	// Bit PID49.
	PMC_PMC_PCSR1_PID49 = 0x20000
	// Position of PID50 field.
	PMC_PMC_PCSR1_PID50_Pos = 0x12
	// Bit mask of PID50 field.
	PMC_PMC_PCSR1_PID50_Msk = 0x40000
	// Bit PID50.
	PMC_PMC_PCSR1_PID50 = 0x40000
	// Position of PID51 field.
	PMC_PMC_PCSR1_PID51_Pos = 0x13
	// Bit mask of PID51 field.
	PMC_PMC_PCSR1_PID51_Msk = 0x80000
	// Bit PID51.
	PMC_PMC_PCSR1_PID51 = 0x80000
	// Position of PID53 field.
	PMC_PMC_PCSR1_PID53_Pos = 0x14
	// Bit mask of PID53 field.
	PMC_PMC_PCSR1_PID53_Msk = 0x300000
	// Position of PID54 field.
	PMC_PMC_PCSR1_PID54_Pos = 0x16
	// Bit mask of PID54 field.
	PMC_PMC_PCSR1_PID54_Msk = 0x400000
	// Bit PID54.
	PMC_PMC_PCSR1_PID54 = 0x400000
	// Position of PID55 field.
	PMC_PMC_PCSR1_PID55_Pos = 0x17
	// Bit mask of PID55 field.
	PMC_PMC_PCSR1_PID55_Msk = 0x800000
	// Bit PID55.
	PMC_PMC_PCSR1_PID55 = 0x800000
	// Position of PID56 field.
	PMC_PMC_PCSR1_PID56_Pos = 0x18
	// Bit mask of PID56 field.
	PMC_PMC_PCSR1_PID56_Msk = 0x1000000
	// Bit PID56.
	PMC_PMC_PCSR1_PID56 = 0x1000000
	// Position of PID57 field.
	PMC_PMC_PCSR1_PID57_Pos = 0x19
	// Bit mask of PID57 field.
	PMC_PMC_PCSR1_PID57_Msk = 0x2000000
	// Bit PID57.
	PMC_PMC_PCSR1_PID57 = 0x2000000
	// Position of PID58 field.
	PMC_PMC_PCSR1_PID58_Pos = 0x1a
	// Bit mask of PID58 field.
	PMC_PMC_PCSR1_PID58_Msk = 0x4000000
	// Bit PID58.
	PMC_PMC_PCSR1_PID58 = 0x4000000
	// Position of PID59 field.
	PMC_PMC_PCSR1_PID59_Pos = 0x1b
	// Bit mask of PID59 field.
	PMC_PMC_PCSR1_PID59_Msk = 0x8000000
	// Bit PID59.
	PMC_PMC_PCSR1_PID59 = 0x8000000
	// Position of PID60 field.
	PMC_PMC_PCSR1_PID60_Pos = 0x1c
	// Bit mask of PID60 field.
	PMC_PMC_PCSR1_PID60_Msk = 0x10000000
	// Bit PID60.
	PMC_PMC_PCSR1_PID60 = 0x10000000
	// Position of PID61 field.
	PMC_PMC_PCSR1_PID61_Pos = 0x1d
	// Bit mask of PID61 field.
	PMC_PMC_PCSR1_PID61_Msk = 0x20000000
	// Bit PID61.
	PMC_PMC_PCSR1_PID61 = 0x20000000
	// Position of PID62 field.
	PMC_PMC_PCSR1_PID62_Pos = 0x1e
	// Bit mask of PID62 field.
	PMC_PMC_PCSR1_PID62_Msk = 0x40000000
	// Bit PID62.
	PMC_PMC_PCSR1_PID62 = 0x40000000
	// Position of PID63 field.
	PMC_PMC_PCSR1_PID63_Pos = 0x1f
	// Bit mask of PID63 field.
	PMC_PMC_PCSR1_PID63_Msk = 0x80000000
	// Bit PID63.
	PMC_PMC_PCSR1_PID63 = 0x80000000

	// PMC_PCR: Peripheral Control Register
	// Position of PID field.
	PMC_PMC_PCR_PID_Pos = 0x0
	// Bit mask of PID field.
	PMC_PMC_PCR_PID_Msk = 0x3f
	// Position of CMD field.
	PMC_PMC_PCR_CMD_Pos = 0xc
	// Bit mask of CMD field.
	PMC_PMC_PCR_CMD_Msk = 0x1000
	// Bit CMD.
	PMC_PMC_PCR_CMD = 0x1000
	// Position of DIV field.
	PMC_PMC_PCR_DIV_Pos = 0x10
	// Bit mask of DIV field.
	PMC_PMC_PCR_DIV_Msk = 0x30000
	// Peripheral clock is MCK
	PMC_PMC_PCR_DIV_PERIPH_DIV_MCK = 0x0
	// Peripheral clock is MCK/2
	PMC_PMC_PCR_DIV_PERIPH_DIV2_MCK = 0x1
	// Peripheral clock is MCK/4
	PMC_PMC_PCR_DIV_PERIPH_DIV4_MCK = 0x2
	// Peripheral clock is MCK/8
	PMC_PMC_PCR_DIV_PERIPH_DIV8_MCK = 0x3
	// Position of EN field.
	PMC_PMC_PCR_EN_Pos = 0x1c
	// Bit mask of EN field.
	PMC_PMC_PCR_EN_Msk = 0x10000000
	// Bit EN.
	PMC_PMC_PCR_EN = 0x10000000
)

// Constants for RSTC: Reset Controller
const (
	// CR: Control Register
	// Position of PROCRST field.
	SYSC_CR_PROCRST_Pos = 0x0
	// Bit mask of PROCRST field.
	SYSC_CR_PROCRST_Msk = 0x1
	// Bit PROCRST.
	SYSC_CR_PROCRST = 0x1
	// Position of PERRST field.
	SYSC_CR_PERRST_Pos = 0x2
	// Bit mask of PERRST field.
	SYSC_CR_PERRST_Msk = 0x4
	// Bit PERRST.
	SYSC_CR_PERRST = 0x4
	// Position of EXTRST field.
	SYSC_CR_EXTRST_Pos = 0x3
	// Bit mask of EXTRST field.
	SYSC_CR_EXTRST_Msk = 0x8
	// Bit EXTRST.
	SYSC_CR_EXTRST = 0x8
	// Position of KEY field.
	SYSC_CR_KEY_Pos = 0x18
	// Bit mask of KEY field.
	SYSC_CR_KEY_Msk = 0xff000000

	// SR: Status Register
	// Position of URSTS field.
	SYSC_SR_URSTS_Pos = 0x0
	// Bit mask of URSTS field.
	SYSC_SR_URSTS_Msk = 0x1
	// Bit URSTS.
	SYSC_SR_URSTS = 0x1
	// Position of RSTTYP field.
	SYSC_SR_RSTTYP_Pos = 0x8
	// Bit mask of RSTTYP field.
	SYSC_SR_RSTTYP_Msk = 0x700
	// Position of NRSTL field.
	SYSC_SR_NRSTL_Pos = 0x10
	// Bit mask of NRSTL field.
	SYSC_SR_NRSTL_Msk = 0x10000
	// Bit NRSTL.
	SYSC_SR_NRSTL = 0x10000
	// Position of SRCMP field.
	SYSC_SR_SRCMP_Pos = 0x11
	// Bit mask of SRCMP field.
	SYSC_SR_SRCMP_Msk = 0x20000
	// Bit SRCMP.
	SYSC_SR_SRCMP = 0x20000

	// MR: Mode Register
	// Position of ERSTL field.
	SYSC_MR_ERSTL_Pos = 0x8
	// Bit mask of ERSTL field.
	SYSC_MR_ERSTL_Msk = 0xf00
	// Position of KEY field.
	SYSC_MR_KEY_Pos = 0x18
	// Bit mask of KEY field.
	SYSC_MR_KEY_Msk = 0xff000000
)
