// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from ATSAME53J18A.svd, see https://github.com/posborne/cmsis-svd/tree/master/data/Atmel

//go:build sam && atsame53j18a
// +build sam,atsame53j18a

// Microchip ATSAME53J18A Microcontroller
//

package sam

import (
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "ATSAME53J18A"
	CPU          = "CM4"
	FPUPresent   = true
	NVICPrioBits = 3
)

// Interrupt numbers.
const (
	// Power Manager
	IRQ_PM = 0

	// Main Clock
	IRQ_MCLK = 1

	// Oscillators Control
	IRQ_OSCCTRL_XOSC0 = 2

	// Oscillators Control
	IRQ_OSCCTRL_XOSC1 = 3

	// Oscillators Control
	IRQ_OSCCTRL_DFLL = 4

	// Oscillators Control
	IRQ_OSCCTRL_DPLL0 = 5

	// Oscillators Control
	IRQ_OSCCTRL_DPLL1 = 6

	// 32kHz Oscillators Control
	IRQ_OSC32KCTRL = 7

	// Supply Controller
	IRQ_SUPC_OTHER = 8

	// Supply Controller
	IRQ_SUPC_BODDET = 9

	// Watchdog Timer
	IRQ_WDT = 10

	// Real-Time Counter
	IRQ_RTC = 11

	// External Interrupt Controller
	IRQ_EIC_EXTINT_0 = 12

	// External Interrupt Controller
	IRQ_EIC_EXTINT_1 = 13

	// External Interrupt Controller
	IRQ_EIC_EXTINT_2 = 14

	// External Interrupt Controller
	IRQ_EIC_EXTINT_3 = 15

	// External Interrupt Controller
	IRQ_EIC_EXTINT_4 = 16

	// External Interrupt Controller
	IRQ_EIC_EXTINT_5 = 17

	// External Interrupt Controller
	IRQ_EIC_EXTINT_6 = 18

	// External Interrupt Controller
	IRQ_EIC_EXTINT_7 = 19

	// External Interrupt Controller
	IRQ_EIC_EXTINT_8 = 20

	// External Interrupt Controller
	IRQ_EIC_EXTINT_9 = 21

	// External Interrupt Controller
	IRQ_EIC_EXTINT_10 = 22

	// External Interrupt Controller
	IRQ_EIC_EXTINT_11 = 23

	// External Interrupt Controller
	IRQ_EIC_EXTINT_12 = 24

	// External Interrupt Controller
	IRQ_EIC_EXTINT_13 = 25

	// External Interrupt Controller
	IRQ_EIC_EXTINT_14 = 26

	// External Interrupt Controller
	IRQ_EIC_EXTINT_15 = 27

	// Frequency Meter
	IRQ_FREQM = 28

	// Non-Volatile Memory Controller
	IRQ_NVMCTRL_0 = 29

	// Non-Volatile Memory Controller
	IRQ_NVMCTRL_1 = 30

	// Direct Memory Access Controller
	IRQ_DMAC_0 = 31

	// Direct Memory Access Controller
	IRQ_DMAC_1 = 32

	// Direct Memory Access Controller
	IRQ_DMAC_2 = 33

	// Direct Memory Access Controller
	IRQ_DMAC_3 = 34

	// Direct Memory Access Controller
	IRQ_DMAC_OTHER = 35

	// Event System Interface
	IRQ_EVSYS_0 = 36

	// Event System Interface
	IRQ_EVSYS_1 = 37

	// Event System Interface
	IRQ_EVSYS_2 = 38

	// Event System Interface
	IRQ_EVSYS_3 = 39

	// Event System Interface
	IRQ_EVSYS_OTHER = 40

	// Peripheral Access Controller
	IRQ_PAC = 41

	// RAM ECC
	IRQ_RAMECC = 45

	// Serial Communication Interface
	IRQ_SERCOM0_0 = 46

	// Serial Communication Interface
	IRQ_SERCOM0_1 = 47

	// Serial Communication Interface
	IRQ_SERCOM0_2 = 48

	// Serial Communication Interface
	IRQ_SERCOM0_OTHER = 49

	IRQ_SERCOM1_0 = 50

	IRQ_SERCOM1_1 = 51

	IRQ_SERCOM1_2 = 52

	IRQ_SERCOM1_OTHER = 53

	IRQ_SERCOM2_0 = 54

	IRQ_SERCOM2_1 = 55

	IRQ_SERCOM2_2 = 56

	IRQ_SERCOM2_OTHER = 57

	IRQ_SERCOM3_0 = 58

	IRQ_SERCOM3_1 = 59

	IRQ_SERCOM3_2 = 60

	IRQ_SERCOM3_OTHER = 61

	IRQ_SERCOM4_0 = 62

	IRQ_SERCOM4_1 = 63

	IRQ_SERCOM4_2 = 64

	IRQ_SERCOM4_OTHER = 65

	IRQ_SERCOM5_0 = 66

	IRQ_SERCOM5_1 = 67

	IRQ_SERCOM5_2 = 68

	IRQ_SERCOM5_OTHER = 69

	// Universal Serial Bus
	IRQ_USB_OTHER = 80

	// Universal Serial Bus
	IRQ_USB_SOF_HSOF = 81

	// Universal Serial Bus
	IRQ_USB_TRCPT0 = 82

	// Universal Serial Bus
	IRQ_USB_TRCPT1 = 83

	// Ethernet MAC
	IRQ_GMAC = 84

	// Timer Counter Control
	IRQ_TCC0_OTHER = 85

	// Timer Counter Control
	IRQ_TCC0_MC0 = 86

	// Timer Counter Control
	IRQ_TCC0_MC1 = 87

	// Timer Counter Control
	IRQ_TCC0_MC2 = 88

	// Timer Counter Control
	IRQ_TCC0_MC3 = 89

	// Timer Counter Control
	IRQ_TCC0_MC4 = 90

	// Timer Counter Control
	IRQ_TCC0_MC5 = 91

	IRQ_TCC1_OTHER = 92

	IRQ_TCC1_MC0 = 93

	IRQ_TCC1_MC1 = 94

	IRQ_TCC1_MC2 = 95

	IRQ_TCC1_MC3 = 96

	IRQ_TCC2_OTHER = 97

	IRQ_TCC2_MC0 = 98

	IRQ_TCC2_MC1 = 99

	IRQ_TCC2_MC2 = 100

	IRQ_TCC3_OTHER = 101

	IRQ_TCC3_MC0 = 102

	IRQ_TCC3_MC1 = 103

	IRQ_TCC4_OTHER = 104

	IRQ_TCC4_MC0 = 105

	IRQ_TCC4_MC1 = 106

	// Basic Timer Counter
	IRQ_TC0 = 107

	IRQ_TC1 = 108

	IRQ_TC2 = 109

	IRQ_TC3 = 110

	IRQ_TC4 = 111

	IRQ_TC5 = 112

	// Quadrature Decodeur
	IRQ_PDEC_OTHER = 115

	// Quadrature Decodeur
	IRQ_PDEC_MC0 = 116

	// Quadrature Decodeur
	IRQ_PDEC_MC1 = 117

	// Analog Digital Converter
	IRQ_ADC0_OTHER = 118

	// Analog Digital Converter
	IRQ_ADC0_RESRDY = 119

	IRQ_ADC1_OTHER = 120

	IRQ_ADC1_RESRDY = 121

	// Analog Comparators
	IRQ_AC = 122

	// Digital-to-Analog Converter
	IRQ_DAC_OTHER = 123

	// Digital-to-Analog Converter
	IRQ_DAC_EMPTY_0 = 124

	// Digital-to-Analog Converter
	IRQ_DAC_EMPTY_1 = 125

	// Digital-to-Analog Converter
	IRQ_DAC_RESRDY_0 = 126

	// Digital-to-Analog Converter
	IRQ_DAC_RESRDY_1 = 127

	// Inter-IC Sound Interface
	IRQ_I2S = 128

	// Parallel Capture Controller
	IRQ_PCC = 129

	// Advanced Encryption Standard
	IRQ_AES = 130

	// True Random Generator
	IRQ_TRNG = 131

	// Integrity Check Monitor
	IRQ_ICM = 132

	// Quad SPI interface
	IRQ_QSPI = 134

	// SD/MMC Host Controller
	IRQ_SDHC0 = 135

	// Highest interrupt number on this device.
	IRQ_max = 135
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int)

//export PM_IRQHandler
func interruptPM() {
	callHandlers(IRQ_PM)
}

//export MCLK_IRQHandler
func interruptMCLK() {
	callHandlers(IRQ_MCLK)
}

//export OSCCTRL_XOSC0_IRQHandler
func interruptOSCCTRL_XOSC0() {
	callHandlers(IRQ_OSCCTRL_XOSC0)
}

//export OSCCTRL_XOSC1_IRQHandler
func interruptOSCCTRL_XOSC1() {
	callHandlers(IRQ_OSCCTRL_XOSC1)
}

//export OSCCTRL_DFLL_IRQHandler
func interruptOSCCTRL_DFLL() {
	callHandlers(IRQ_OSCCTRL_DFLL)
}

//export OSCCTRL_DPLL0_IRQHandler
func interruptOSCCTRL_DPLL0() {
	callHandlers(IRQ_OSCCTRL_DPLL0)
}

//export OSCCTRL_DPLL1_IRQHandler
func interruptOSCCTRL_DPLL1() {
	callHandlers(IRQ_OSCCTRL_DPLL1)
}

//export OSC32KCTRL_IRQHandler
func interruptOSC32KCTRL() {
	callHandlers(IRQ_OSC32KCTRL)
}

//export SUPC_OTHER_IRQHandler
func interruptSUPC_OTHER() {
	callHandlers(IRQ_SUPC_OTHER)
}

//export SUPC_BODDET_IRQHandler
func interruptSUPC_BODDET() {
	callHandlers(IRQ_SUPC_BODDET)
}

//export WDT_IRQHandler
func interruptWDT() {
	callHandlers(IRQ_WDT)
}

//export RTC_IRQHandler
func interruptRTC() {
	callHandlers(IRQ_RTC)
}

//export EIC_EXTINT_0_IRQHandler
func interruptEIC_EXTINT_0() {
	callHandlers(IRQ_EIC_EXTINT_0)
}

//export EIC_EXTINT_1_IRQHandler
func interruptEIC_EXTINT_1() {
	callHandlers(IRQ_EIC_EXTINT_1)
}

//export EIC_EXTINT_2_IRQHandler
func interruptEIC_EXTINT_2() {
	callHandlers(IRQ_EIC_EXTINT_2)
}

//export EIC_EXTINT_3_IRQHandler
func interruptEIC_EXTINT_3() {
	callHandlers(IRQ_EIC_EXTINT_3)
}

//export EIC_EXTINT_4_IRQHandler
func interruptEIC_EXTINT_4() {
	callHandlers(IRQ_EIC_EXTINT_4)
}

//export EIC_EXTINT_5_IRQHandler
func interruptEIC_EXTINT_5() {
	callHandlers(IRQ_EIC_EXTINT_5)
}

//export EIC_EXTINT_6_IRQHandler
func interruptEIC_EXTINT_6() {
	callHandlers(IRQ_EIC_EXTINT_6)
}

//export EIC_EXTINT_7_IRQHandler
func interruptEIC_EXTINT_7() {
	callHandlers(IRQ_EIC_EXTINT_7)
}

//export EIC_EXTINT_8_IRQHandler
func interruptEIC_EXTINT_8() {
	callHandlers(IRQ_EIC_EXTINT_8)
}

//export EIC_EXTINT_9_IRQHandler
func interruptEIC_EXTINT_9() {
	callHandlers(IRQ_EIC_EXTINT_9)
}

//export EIC_EXTINT_10_IRQHandler
func interruptEIC_EXTINT_10() {
	callHandlers(IRQ_EIC_EXTINT_10)
}

//export EIC_EXTINT_11_IRQHandler
func interruptEIC_EXTINT_11() {
	callHandlers(IRQ_EIC_EXTINT_11)
}

//export EIC_EXTINT_12_IRQHandler
func interruptEIC_EXTINT_12() {
	callHandlers(IRQ_EIC_EXTINT_12)
}

//export EIC_EXTINT_13_IRQHandler
func interruptEIC_EXTINT_13() {
	callHandlers(IRQ_EIC_EXTINT_13)
}

//export EIC_EXTINT_14_IRQHandler
func interruptEIC_EXTINT_14() {
	callHandlers(IRQ_EIC_EXTINT_14)
}

//export EIC_EXTINT_15_IRQHandler
func interruptEIC_EXTINT_15() {
	callHandlers(IRQ_EIC_EXTINT_15)
}

//export FREQM_IRQHandler
func interruptFREQM() {
	callHandlers(IRQ_FREQM)
}

//export NVMCTRL_0_IRQHandler
func interruptNVMCTRL_0() {
	callHandlers(IRQ_NVMCTRL_0)
}

//export NVMCTRL_1_IRQHandler
func interruptNVMCTRL_1() {
	callHandlers(IRQ_NVMCTRL_1)
}

//export DMAC_0_IRQHandler
func interruptDMAC_0() {
	callHandlers(IRQ_DMAC_0)
}

//export DMAC_1_IRQHandler
func interruptDMAC_1() {
	callHandlers(IRQ_DMAC_1)
}

//export DMAC_2_IRQHandler
func interruptDMAC_2() {
	callHandlers(IRQ_DMAC_2)
}

//export DMAC_3_IRQHandler
func interruptDMAC_3() {
	callHandlers(IRQ_DMAC_3)
}

//export DMAC_OTHER_IRQHandler
func interruptDMAC_OTHER() {
	callHandlers(IRQ_DMAC_OTHER)
}

//export EVSYS_0_IRQHandler
func interruptEVSYS_0() {
	callHandlers(IRQ_EVSYS_0)
}

//export EVSYS_1_IRQHandler
func interruptEVSYS_1() {
	callHandlers(IRQ_EVSYS_1)
}

//export EVSYS_2_IRQHandler
func interruptEVSYS_2() {
	callHandlers(IRQ_EVSYS_2)
}

//export EVSYS_3_IRQHandler
func interruptEVSYS_3() {
	callHandlers(IRQ_EVSYS_3)
}

//export EVSYS_OTHER_IRQHandler
func interruptEVSYS_OTHER() {
	callHandlers(IRQ_EVSYS_OTHER)
}

//export PAC_IRQHandler
func interruptPAC() {
	callHandlers(IRQ_PAC)
}

//export RAMECC_IRQHandler
func interruptRAMECC() {
	callHandlers(IRQ_RAMECC)
}

//export SERCOM0_0_IRQHandler
func interruptSERCOM0_0() {
	callHandlers(IRQ_SERCOM0_0)
}

//export SERCOM0_1_IRQHandler
func interruptSERCOM0_1() {
	callHandlers(IRQ_SERCOM0_1)
}

//export SERCOM0_2_IRQHandler
func interruptSERCOM0_2() {
	callHandlers(IRQ_SERCOM0_2)
}

//export SERCOM0_OTHER_IRQHandler
func interruptSERCOM0_OTHER() {
	callHandlers(IRQ_SERCOM0_OTHER)
}

//export SERCOM1_0_IRQHandler
func interruptSERCOM1_0() {
	callHandlers(IRQ_SERCOM1_0)
}

//export SERCOM1_1_IRQHandler
func interruptSERCOM1_1() {
	callHandlers(IRQ_SERCOM1_1)
}

//export SERCOM1_2_IRQHandler
func interruptSERCOM1_2() {
	callHandlers(IRQ_SERCOM1_2)
}

//export SERCOM1_OTHER_IRQHandler
func interruptSERCOM1_OTHER() {
	callHandlers(IRQ_SERCOM1_OTHER)
}

//export SERCOM2_0_IRQHandler
func interruptSERCOM2_0() {
	callHandlers(IRQ_SERCOM2_0)
}

//export SERCOM2_1_IRQHandler
func interruptSERCOM2_1() {
	callHandlers(IRQ_SERCOM2_1)
}

//export SERCOM2_2_IRQHandler
func interruptSERCOM2_2() {
	callHandlers(IRQ_SERCOM2_2)
}

//export SERCOM2_OTHER_IRQHandler
func interruptSERCOM2_OTHER() {
	callHandlers(IRQ_SERCOM2_OTHER)
}

//export SERCOM3_0_IRQHandler
func interruptSERCOM3_0() {
	callHandlers(IRQ_SERCOM3_0)
}

//export SERCOM3_1_IRQHandler
func interruptSERCOM3_1() {
	callHandlers(IRQ_SERCOM3_1)
}

//export SERCOM3_2_IRQHandler
func interruptSERCOM3_2() {
	callHandlers(IRQ_SERCOM3_2)
}

//export SERCOM3_OTHER_IRQHandler
func interruptSERCOM3_OTHER() {
	callHandlers(IRQ_SERCOM3_OTHER)
}

//export SERCOM4_0_IRQHandler
func interruptSERCOM4_0() {
	callHandlers(IRQ_SERCOM4_0)
}

//export SERCOM4_1_IRQHandler
func interruptSERCOM4_1() {
	callHandlers(IRQ_SERCOM4_1)
}

//export SERCOM4_2_IRQHandler
func interruptSERCOM4_2() {
	callHandlers(IRQ_SERCOM4_2)
}

//export SERCOM4_OTHER_IRQHandler
func interruptSERCOM4_OTHER() {
	callHandlers(IRQ_SERCOM4_OTHER)
}

//export SERCOM5_0_IRQHandler
func interruptSERCOM5_0() {
	callHandlers(IRQ_SERCOM5_0)
}

//export SERCOM5_1_IRQHandler
func interruptSERCOM5_1() {
	callHandlers(IRQ_SERCOM5_1)
}

//export SERCOM5_2_IRQHandler
func interruptSERCOM5_2() {
	callHandlers(IRQ_SERCOM5_2)
}

//export SERCOM5_OTHER_IRQHandler
func interruptSERCOM5_OTHER() {
	callHandlers(IRQ_SERCOM5_OTHER)
}

//export USB_OTHER_IRQHandler
func interruptUSB_OTHER() {
	callHandlers(IRQ_USB_OTHER)
}

//export USB_SOF_HSOF_IRQHandler
func interruptUSB_SOF_HSOF() {
	callHandlers(IRQ_USB_SOF_HSOF)
}

//export USB_TRCPT0_IRQHandler
func interruptUSB_TRCPT0() {
	callHandlers(IRQ_USB_TRCPT0)
}

//export USB_TRCPT1_IRQHandler
func interruptUSB_TRCPT1() {
	callHandlers(IRQ_USB_TRCPT1)
}

//export GMAC_IRQHandler
func interruptGMAC() {
	callHandlers(IRQ_GMAC)
}

//export TCC0_OTHER_IRQHandler
func interruptTCC0_OTHER() {
	callHandlers(IRQ_TCC0_OTHER)
}

//export TCC0_MC0_IRQHandler
func interruptTCC0_MC0() {
	callHandlers(IRQ_TCC0_MC0)
}

//export TCC0_MC1_IRQHandler
func interruptTCC0_MC1() {
	callHandlers(IRQ_TCC0_MC1)
}

//export TCC0_MC2_IRQHandler
func interruptTCC0_MC2() {
	callHandlers(IRQ_TCC0_MC2)
}

//export TCC0_MC3_IRQHandler
func interruptTCC0_MC3() {
	callHandlers(IRQ_TCC0_MC3)
}

//export TCC0_MC4_IRQHandler
func interruptTCC0_MC4() {
	callHandlers(IRQ_TCC0_MC4)
}

//export TCC0_MC5_IRQHandler
func interruptTCC0_MC5() {
	callHandlers(IRQ_TCC0_MC5)
}

//export TCC1_OTHER_IRQHandler
func interruptTCC1_OTHER() {
	callHandlers(IRQ_TCC1_OTHER)
}

//export TCC1_MC0_IRQHandler
func interruptTCC1_MC0() {
	callHandlers(IRQ_TCC1_MC0)
}

//export TCC1_MC1_IRQHandler
func interruptTCC1_MC1() {
	callHandlers(IRQ_TCC1_MC1)
}

//export TCC1_MC2_IRQHandler
func interruptTCC1_MC2() {
	callHandlers(IRQ_TCC1_MC2)
}

//export TCC1_MC3_IRQHandler
func interruptTCC1_MC3() {
	callHandlers(IRQ_TCC1_MC3)
}

//export TCC2_OTHER_IRQHandler
func interruptTCC2_OTHER() {
	callHandlers(IRQ_TCC2_OTHER)
}

//export TCC2_MC0_IRQHandler
func interruptTCC2_MC0() {
	callHandlers(IRQ_TCC2_MC0)
}

//export TCC2_MC1_IRQHandler
func interruptTCC2_MC1() {
	callHandlers(IRQ_TCC2_MC1)
}

//export TCC2_MC2_IRQHandler
func interruptTCC2_MC2() {
	callHandlers(IRQ_TCC2_MC2)
}

//export TCC3_OTHER_IRQHandler
func interruptTCC3_OTHER() {
	callHandlers(IRQ_TCC3_OTHER)
}

//export TCC3_MC0_IRQHandler
func interruptTCC3_MC0() {
	callHandlers(IRQ_TCC3_MC0)
}

//export TCC3_MC1_IRQHandler
func interruptTCC3_MC1() {
	callHandlers(IRQ_TCC3_MC1)
}

//export TCC4_OTHER_IRQHandler
func interruptTCC4_OTHER() {
	callHandlers(IRQ_TCC4_OTHER)
}

//export TCC4_MC0_IRQHandler
func interruptTCC4_MC0() {
	callHandlers(IRQ_TCC4_MC0)
}

//export TCC4_MC1_IRQHandler
func interruptTCC4_MC1() {
	callHandlers(IRQ_TCC4_MC1)
}

//export TC0_IRQHandler
func interruptTC0() {
	callHandlers(IRQ_TC0)
}

//export TC1_IRQHandler
func interruptTC1() {
	callHandlers(IRQ_TC1)
}

//export TC2_IRQHandler
func interruptTC2() {
	callHandlers(IRQ_TC2)
}

//export TC3_IRQHandler
func interruptTC3() {
	callHandlers(IRQ_TC3)
}

//export TC4_IRQHandler
func interruptTC4() {
	callHandlers(IRQ_TC4)
}

//export TC5_IRQHandler
func interruptTC5() {
	callHandlers(IRQ_TC5)
}

//export PDEC_OTHER_IRQHandler
func interruptPDEC_OTHER() {
	callHandlers(IRQ_PDEC_OTHER)
}

//export PDEC_MC0_IRQHandler
func interruptPDEC_MC0() {
	callHandlers(IRQ_PDEC_MC0)
}

//export PDEC_MC1_IRQHandler
func interruptPDEC_MC1() {
	callHandlers(IRQ_PDEC_MC1)
}

//export ADC0_OTHER_IRQHandler
func interruptADC0_OTHER() {
	callHandlers(IRQ_ADC0_OTHER)
}

//export ADC0_RESRDY_IRQHandler
func interruptADC0_RESRDY() {
	callHandlers(IRQ_ADC0_RESRDY)
}

//export ADC1_OTHER_IRQHandler
func interruptADC1_OTHER() {
	callHandlers(IRQ_ADC1_OTHER)
}

//export ADC1_RESRDY_IRQHandler
func interruptADC1_RESRDY() {
	callHandlers(IRQ_ADC1_RESRDY)
}

//export AC_IRQHandler
func interruptAC() {
	callHandlers(IRQ_AC)
}

//export DAC_OTHER_IRQHandler
func interruptDAC_OTHER() {
	callHandlers(IRQ_DAC_OTHER)
}

//export DAC_EMPTY_0_IRQHandler
func interruptDAC_EMPTY_0() {
	callHandlers(IRQ_DAC_EMPTY_0)
}

//export DAC_EMPTY_1_IRQHandler
func interruptDAC_EMPTY_1() {
	callHandlers(IRQ_DAC_EMPTY_1)
}

//export DAC_RESRDY_0_IRQHandler
func interruptDAC_RESRDY_0() {
	callHandlers(IRQ_DAC_RESRDY_0)
}

//export DAC_RESRDY_1_IRQHandler
func interruptDAC_RESRDY_1() {
	callHandlers(IRQ_DAC_RESRDY_1)
}

//export I2S_IRQHandler
func interruptI2S() {
	callHandlers(IRQ_I2S)
}

//export PCC_IRQHandler
func interruptPCC() {
	callHandlers(IRQ_PCC)
}

//export AES_IRQHandler
func interruptAES() {
	callHandlers(IRQ_AES)
}

//export TRNG_IRQHandler
func interruptTRNG() {
	callHandlers(IRQ_TRNG)
}

//export ICM_IRQHandler
func interruptICM() {
	callHandlers(IRQ_ICM)
}

//export QSPI_IRQHandler
func interruptQSPI() {
	callHandlers(IRQ_QSPI)
}

//export SDHC0_IRQHandler
func interruptSDHC0() {
	callHandlers(IRQ_SDHC0)
}

// Peripherals.
var (
	// Analog Comparators
	AC = (*AC_Type)(unsafe.Pointer(uintptr(0x42002000)))

	// Analog Digital Converter
	ADC0 = (*ADC_Type)(unsafe.Pointer(uintptr(0x43001c00)))

	// Advanced Encryption Standard
	AES = (*AES_Type)(unsafe.Pointer(uintptr(0x42002400)))

	// Configurable Custom Logic
	CCL = (*CCL_Type)(unsafe.Pointer(uintptr(0x42003800)))

	// Cortex M Cache Controller
	CMCC = (*CMCC_Type)(unsafe.Pointer(uintptr(0x41006000)))

	// Digital-to-Analog Converter
	DAC = (*DAC_Type)(unsafe.Pointer(uintptr(0x43002400)))

	// Direct Memory Access Controller
	DMAC = (*DMAC_Type)(unsafe.Pointer(uintptr(0x4100a000)))

	// Device Service Unit
	DSU = (*DSU_Type)(unsafe.Pointer(uintptr(0x41002000)))

	// External Interrupt Controller
	EIC = (*EIC_Type)(unsafe.Pointer(uintptr(0x40002800)))

	// Event System Interface
	EVSYS = (*EVSYS_Type)(unsafe.Pointer(uintptr(0x4100e000)))

	// Frequency Meter
	FREQM = (*FREQM_Type)(unsafe.Pointer(uintptr(0x40002c00)))

	// Generic Clock Generator
	GCLK = (*GCLK_Type)(unsafe.Pointer(uintptr(0x40001c00)))

	// Ethernet MAC
	GMAC = (*GMAC_Type)(unsafe.Pointer(uintptr(0x42000800)))

	// HSB Matrix
	HMATRIX = (*HMATRIXB_Type)(unsafe.Pointer(uintptr(0x4100c000)))

	// Integrity Check Monitor
	ICM = (*ICM_Type)(unsafe.Pointer(uintptr(0x42002c00)))

	// Inter-IC Sound Interface
	I2S = (*I2S_Type)(unsafe.Pointer(uintptr(0x43002800)))

	// Main Clock
	MCLK = (*MCLK_Type)(unsafe.Pointer(uintptr(0x40000800)))

	// Non-Volatile Memory Controller
	NVMCTRL = (*NVMCTRL_Type)(unsafe.Pointer(uintptr(0x41004000)))

	// Oscillators Control
	OSCCTRL = (*OSCCTRL_Type)(unsafe.Pointer(uintptr(0x40001000)))

	// 32kHz Oscillators Control
	OSC32KCTRL = (*OSC32KCTRL_Type)(unsafe.Pointer(uintptr(0x40001400)))

	// Peripheral Access Controller
	PAC = (*PAC_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// Parallel Capture Controller
	PCC = (*PCC_Type)(unsafe.Pointer(uintptr(0x43002c00)))

	// Quadrature Decodeur
	PDEC = (*PDEC_Type)(unsafe.Pointer(uintptr(0x42001c00)))

	// Power Manager
	PM = (*PM_Type)(unsafe.Pointer(uintptr(0x40000400)))

	// Port Module
	PORT = (*PORT_Type)(unsafe.Pointer(uintptr(0x41008000)))

	// Quad SPI interface
	QSPI = (*QSPI_Type)(unsafe.Pointer(uintptr(0x42003400)))

	// RAM ECC
	RAMECC = (*RAMECC_Type)(unsafe.Pointer(uintptr(0x41020000)))

	// Reset Controller
	RSTC = (*RSTC_Type)(unsafe.Pointer(uintptr(0x40000c00)))

	// Real-Time Counter
	RTC = (*RTC_Type)(unsafe.Pointer(uintptr(0x40002400)))

	// Real-Time Counter - MODE0
	RTC_MODE0 = (*RTC_MODE0_Type)(unsafe.Pointer(uintptr(0x40002400)))

	// Real-Time Counter - MODE1
	RTC_MODE1 = (*RTC_MODE1_Type)(unsafe.Pointer(uintptr(0x40002400)))

	// Real-Time Counter - MODE2
	RTC_MODE2 = (*RTC_MODE2_Type)(unsafe.Pointer(uintptr(0x40002400)))

	// SD/MMC Host Controller
	SDHC0 = (*SDHC_Type)(unsafe.Pointer(uintptr(0x45000000)))

	// Serial Communication Interface
	SERCOM0 = (*SERCOM_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// Serial Communication Interface - I2CM
	SERCOM0_I2CM = (*SERCOM_I2CM_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// Serial Communication Interface - I2CS
	SERCOM0_I2CS = (*SERCOM_I2CS_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// Serial Communication Interface - SPIS
	SERCOM0_SPIS = (*SERCOM_SPIS_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// Serial Communication Interface - SPIM
	SERCOM0_SPIM = (*SERCOM_SPIM_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// Serial Communication Interface - USART_EXT
	SERCOM0_USART_EXT = (*SERCOM_USART_EXT_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// Serial Communication Interface - USART_INT
	SERCOM0_USART_INT = (*SERCOM_USART_INT_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// Supply Controller
	SUPC = (*SUPC_Type)(unsafe.Pointer(uintptr(0x40001800)))

	// Basic Timer Counter
	TC0 = (*TC_Type)(unsafe.Pointer(uintptr(0x40003800)))

	// Basic Timer Counter - COUNT8
	TC0_COUNT8 = (*TC_COUNT8_Type)(unsafe.Pointer(uintptr(0x40003800)))

	// Basic Timer Counter - COUNT16
	TC0_COUNT16 = (*TC_COUNT16_Type)(unsafe.Pointer(uintptr(0x40003800)))

	// Basic Timer Counter - COUNT32
	TC0_COUNT32 = (*TC_COUNT32_Type)(unsafe.Pointer(uintptr(0x40003800)))

	// Timer Counter Control
	TCC0 = (*TCC_Type)(unsafe.Pointer(uintptr(0x41016000)))

	// True Random Generator
	TRNG = (*TRNG_Type)(unsafe.Pointer(uintptr(0x42002800)))

	// Universal Serial Bus
	USB = (*USB_Type)(unsafe.Pointer(uintptr(0x41000000)))

	// Universal Serial Bus - DEVICE
	USB_DEVICE = (*USB_DEVICE_Type)(unsafe.Pointer(uintptr(0x41000000)))

	// Universal Serial Bus - HOST
	USB_HOST = (*USB_HOST_Type)(unsafe.Pointer(uintptr(0x41000000)))

	// Watchdog Timer
	WDT = (*WDT_Type)(unsafe.Pointer(uintptr(0x40002000)))

	// Core Debug Register
	CoreDebug = (*CoreDebug_Type)(unsafe.Pointer(uintptr(0xe000edf0)))

	// Data Watchpoint and Trace Register
	DWT = (*DWT_Type)(unsafe.Pointer(uintptr(0xe0001000)))

	// Embedded Trace Macrocell
	ETM = (*ETM_Type)(unsafe.Pointer(uintptr(0xe0041000)))

	// Floating Point Unit
	FPU = (*FPU_Type)(unsafe.Pointer(uintptr(0xe000ef30)))

	// Instrumentation Trace Macrocell
	ITM = (*ITM_Type)(unsafe.Pointer(uintptr(0xe0000000)))

	// Memory Protection Unit
	MPU = (*MPU_Type)(unsafe.Pointer(uintptr(0xe000ed90)))

	// Nested Vectored Interrupt Controller
	NVIC = (*NVIC_Type)(unsafe.Pointer(uintptr(0xe000e100)))

	// System timer
	SysTick = (*SysTick_Type)(unsafe.Pointer(uintptr(0xe000e010)))

	// System Control Registers
	SystemControl = (*SystemControl_Type)(unsafe.Pointer(uintptr(0xe000e000)))

	// Trace Port Interface Register
	TPI = (*TPI_Type)(unsafe.Pointer(uintptr(0xe0040000)))

	// Analog Digital Converter
	ADC1 = (*ADC_Type)(unsafe.Pointer(uintptr(0x43002000)))

	// Serial Communication Interface
	SERCOM1 = (*SERCOM_Type)(unsafe.Pointer(uintptr(0x40003400)))

	// Serial Communication Interface - I2CM
	SERCOM1_I2CM = (*SERCOM_I2CM_Type)(unsafe.Pointer(uintptr(0x40003400)))

	// Serial Communication Interface - I2CS
	SERCOM1_I2CS = (*SERCOM_I2CS_Type)(unsafe.Pointer(uintptr(0x40003400)))

	// Serial Communication Interface - SPIS
	SERCOM1_SPIS = (*SERCOM_SPIS_Type)(unsafe.Pointer(uintptr(0x40003400)))

	// Serial Communication Interface - SPIM
	SERCOM1_SPIM = (*SERCOM_SPIM_Type)(unsafe.Pointer(uintptr(0x40003400)))

	// Serial Communication Interface - USART_EXT
	SERCOM1_USART_EXT = (*SERCOM_USART_EXT_Type)(unsafe.Pointer(uintptr(0x40003400)))

	// Serial Communication Interface - USART_INT
	SERCOM1_USART_INT = (*SERCOM_USART_INT_Type)(unsafe.Pointer(uintptr(0x40003400)))

	// Serial Communication Interface
	SERCOM2 = (*SERCOM_Type)(unsafe.Pointer(uintptr(0x41012000)))

	// Serial Communication Interface - I2CM
	SERCOM2_I2CM = (*SERCOM_I2CM_Type)(unsafe.Pointer(uintptr(0x41012000)))

	// Serial Communication Interface - I2CS
	SERCOM2_I2CS = (*SERCOM_I2CS_Type)(unsafe.Pointer(uintptr(0x41012000)))

	// Serial Communication Interface - SPIS
	SERCOM2_SPIS = (*SERCOM_SPIS_Type)(unsafe.Pointer(uintptr(0x41012000)))

	// Serial Communication Interface - SPIM
	SERCOM2_SPIM = (*SERCOM_SPIM_Type)(unsafe.Pointer(uintptr(0x41012000)))

	// Serial Communication Interface - USART_EXT
	SERCOM2_USART_EXT = (*SERCOM_USART_EXT_Type)(unsafe.Pointer(uintptr(0x41012000)))

	// Serial Communication Interface - USART_INT
	SERCOM2_USART_INT = (*SERCOM_USART_INT_Type)(unsafe.Pointer(uintptr(0x41012000)))

	// Serial Communication Interface
	SERCOM3 = (*SERCOM_Type)(unsafe.Pointer(uintptr(0x41014000)))

	// Serial Communication Interface - I2CM
	SERCOM3_I2CM = (*SERCOM_I2CM_Type)(unsafe.Pointer(uintptr(0x41014000)))

	// Serial Communication Interface - I2CS
	SERCOM3_I2CS = (*SERCOM_I2CS_Type)(unsafe.Pointer(uintptr(0x41014000)))

	// Serial Communication Interface - SPIS
	SERCOM3_SPIS = (*SERCOM_SPIS_Type)(unsafe.Pointer(uintptr(0x41014000)))

	// Serial Communication Interface - SPIM
	SERCOM3_SPIM = (*SERCOM_SPIM_Type)(unsafe.Pointer(uintptr(0x41014000)))

	// Serial Communication Interface - USART_EXT
	SERCOM3_USART_EXT = (*SERCOM_USART_EXT_Type)(unsafe.Pointer(uintptr(0x41014000)))

	// Serial Communication Interface - USART_INT
	SERCOM3_USART_INT = (*SERCOM_USART_INT_Type)(unsafe.Pointer(uintptr(0x41014000)))

	// Serial Communication Interface
	SERCOM4 = (*SERCOM_Type)(unsafe.Pointer(uintptr(0x43000000)))

	// Serial Communication Interface - I2CM
	SERCOM4_I2CM = (*SERCOM_I2CM_Type)(unsafe.Pointer(uintptr(0x43000000)))

	// Serial Communication Interface - I2CS
	SERCOM4_I2CS = (*SERCOM_I2CS_Type)(unsafe.Pointer(uintptr(0x43000000)))

	// Serial Communication Interface - SPIS
	SERCOM4_SPIS = (*SERCOM_SPIS_Type)(unsafe.Pointer(uintptr(0x43000000)))

	// Serial Communication Interface - SPIM
	SERCOM4_SPIM = (*SERCOM_SPIM_Type)(unsafe.Pointer(uintptr(0x43000000)))

	// Serial Communication Interface - USART_EXT
	SERCOM4_USART_EXT = (*SERCOM_USART_EXT_Type)(unsafe.Pointer(uintptr(0x43000000)))

	// Serial Communication Interface - USART_INT
	SERCOM4_USART_INT = (*SERCOM_USART_INT_Type)(unsafe.Pointer(uintptr(0x43000000)))

	// Serial Communication Interface
	SERCOM5 = (*SERCOM_Type)(unsafe.Pointer(uintptr(0x43000400)))

	// Serial Communication Interface - I2CM
	SERCOM5_I2CM = (*SERCOM_I2CM_Type)(unsafe.Pointer(uintptr(0x43000400)))

	// Serial Communication Interface - I2CS
	SERCOM5_I2CS = (*SERCOM_I2CS_Type)(unsafe.Pointer(uintptr(0x43000400)))

	// Serial Communication Interface - SPIS
	SERCOM5_SPIS = (*SERCOM_SPIS_Type)(unsafe.Pointer(uintptr(0x43000400)))

	// Serial Communication Interface - SPIM
	SERCOM5_SPIM = (*SERCOM_SPIM_Type)(unsafe.Pointer(uintptr(0x43000400)))

	// Serial Communication Interface - USART_EXT
	SERCOM5_USART_EXT = (*SERCOM_USART_EXT_Type)(unsafe.Pointer(uintptr(0x43000400)))

	// Serial Communication Interface - USART_INT
	SERCOM5_USART_INT = (*SERCOM_USART_INT_Type)(unsafe.Pointer(uintptr(0x43000400)))

	// Basic Timer Counter
	TC1 = (*TC_Type)(unsafe.Pointer(uintptr(0x40003c00)))

	// Basic Timer Counter - COUNT8
	TC1_COUNT8 = (*TC_COUNT8_Type)(unsafe.Pointer(uintptr(0x40003c00)))

	// Basic Timer Counter - COUNT16
	TC1_COUNT16 = (*TC_COUNT16_Type)(unsafe.Pointer(uintptr(0x40003c00)))

	// Basic Timer Counter - COUNT32
	TC1_COUNT32 = (*TC_COUNT32_Type)(unsafe.Pointer(uintptr(0x40003c00)))

	// Basic Timer Counter
	TC2 = (*TC_Type)(unsafe.Pointer(uintptr(0x4101a000)))

	// Basic Timer Counter - COUNT8
	TC2_COUNT8 = (*TC_COUNT8_Type)(unsafe.Pointer(uintptr(0x4101a000)))

	// Basic Timer Counter - COUNT16
	TC2_COUNT16 = (*TC_COUNT16_Type)(unsafe.Pointer(uintptr(0x4101a000)))

	// Basic Timer Counter - COUNT32
	TC2_COUNT32 = (*TC_COUNT32_Type)(unsafe.Pointer(uintptr(0x4101a000)))

	// Basic Timer Counter
	TC3 = (*TC_Type)(unsafe.Pointer(uintptr(0x4101c000)))

	// Basic Timer Counter - COUNT8
	TC3_COUNT8 = (*TC_COUNT8_Type)(unsafe.Pointer(uintptr(0x4101c000)))

	// Basic Timer Counter - COUNT16
	TC3_COUNT16 = (*TC_COUNT16_Type)(unsafe.Pointer(uintptr(0x4101c000)))

	// Basic Timer Counter - COUNT32
	TC3_COUNT32 = (*TC_COUNT32_Type)(unsafe.Pointer(uintptr(0x4101c000)))

	// Basic Timer Counter
	TC4 = (*TC_Type)(unsafe.Pointer(uintptr(0x42001400)))

	// Basic Timer Counter - COUNT8
	TC4_COUNT8 = (*TC_COUNT8_Type)(unsafe.Pointer(uintptr(0x42001400)))

	// Basic Timer Counter - COUNT16
	TC4_COUNT16 = (*TC_COUNT16_Type)(unsafe.Pointer(uintptr(0x42001400)))

	// Basic Timer Counter - COUNT32
	TC4_COUNT32 = (*TC_COUNT32_Type)(unsafe.Pointer(uintptr(0x42001400)))

	// Basic Timer Counter
	TC5 = (*TC_Type)(unsafe.Pointer(uintptr(0x42001800)))

	// Basic Timer Counter - COUNT8
	TC5_COUNT8 = (*TC_COUNT8_Type)(unsafe.Pointer(uintptr(0x42001800)))

	// Basic Timer Counter - COUNT16
	TC5_COUNT16 = (*TC_COUNT16_Type)(unsafe.Pointer(uintptr(0x42001800)))

	// Basic Timer Counter - COUNT32
	TC5_COUNT32 = (*TC_COUNT32_Type)(unsafe.Pointer(uintptr(0x42001800)))

	// Timer Counter Control
	TCC1 = (*TCC_Type)(unsafe.Pointer(uintptr(0x41018000)))

	// Timer Counter Control
	TCC2 = (*TCC_Type)(unsafe.Pointer(uintptr(0x42000c00)))

	// Timer Counter Control
	TCC3 = (*TCC_Type)(unsafe.Pointer(uintptr(0x42001000)))

	// Timer Counter Control
	TCC4 = (*TCC_Type)(unsafe.Pointer(uintptr(0x43001000)))
)

// Analog Comparators
type AC_Type struct {
	CTRLA    volatile.Register8  // 0x0
	CTRLB    volatile.Register8  // 0x1
	EVCTRL   volatile.Register16 // 0x2
	INTENCLR volatile.Register8  // 0x4
	INTENSET volatile.Register8  // 0x5
	INTFLAG  volatile.Register8  // 0x6
	STATUSA  volatile.Register8  // 0x7
	STATUSB  volatile.Register8  // 0x8
	DBGCTRL  volatile.Register8  // 0x9
	WINCTRL  volatile.Register8  // 0xA
	_        byte
	SCALER   [2]volatile.Register8 // 0xC
	_        [2]byte
	COMPCTRL [2]volatile.Register32 // 0x10
	_        [8]byte
	SYNCBUSY volatile.Register32 // 0x20
	CALIB    volatile.Register16 // 0x24
}

// AC.CTRLA: Control A
func (o *AC_Type) SetCTRLA_SWRST(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *AC_Type) GetCTRLA_SWRST() uint8 {
	return volatile.LoadUint8(&o.CTRLA.Reg) & 0x1
}
func (o *AC_Type) SetCTRLA_ENABLE(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *AC_Type) GetCTRLA_ENABLE() uint8 {
	return (volatile.LoadUint8(&o.CTRLA.Reg) & 0x2) >> 1
}

// AC.CTRLB: Control B
func (o *AC_Type) SetCTRLB_START0(value uint8) {
	volatile.StoreUint8(&o.CTRLB.Reg, volatile.LoadUint8(&o.CTRLB.Reg)&^(0x1)|value)
}
func (o *AC_Type) GetCTRLB_START0() uint8 {
	return volatile.LoadUint8(&o.CTRLB.Reg) & 0x1
}
func (o *AC_Type) SetCTRLB_START1(value uint8) {
	volatile.StoreUint8(&o.CTRLB.Reg, volatile.LoadUint8(&o.CTRLB.Reg)&^(0x2)|value<<1)
}
func (o *AC_Type) GetCTRLB_START1() uint8 {
	return (volatile.LoadUint8(&o.CTRLB.Reg) & 0x2) >> 1
}

// AC.EVCTRL: Event Control
func (o *AC_Type) SetEVCTRL_COMPEO0(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x1)|value)
}
func (o *AC_Type) GetEVCTRL_COMPEO0() uint16 {
	return volatile.LoadUint16(&o.EVCTRL.Reg) & 0x1
}
func (o *AC_Type) SetEVCTRL_COMPEO1(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x2)|value<<1)
}
func (o *AC_Type) GetEVCTRL_COMPEO1() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x2) >> 1
}
func (o *AC_Type) SetEVCTRL_WINEO0(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x10)|value<<4)
}
func (o *AC_Type) GetEVCTRL_WINEO0() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x10) >> 4
}
func (o *AC_Type) SetEVCTRL_COMPEI0(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x100)|value<<8)
}
func (o *AC_Type) GetEVCTRL_COMPEI0() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x100) >> 8
}
func (o *AC_Type) SetEVCTRL_COMPEI1(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x200)|value<<9)
}
func (o *AC_Type) GetEVCTRL_COMPEI1() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x200) >> 9
}
func (o *AC_Type) SetEVCTRL_INVEI0(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *AC_Type) GetEVCTRL_INVEI0() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x1000) >> 12
}
func (o *AC_Type) SetEVCTRL_INVEI1(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *AC_Type) GetEVCTRL_INVEI1() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x2000) >> 13
}

// AC.INTENCLR: Interrupt Enable Clear
func (o *AC_Type) SetINTENCLR_COMP0(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *AC_Type) GetINTENCLR_COMP0() uint8 {
	return volatile.LoadUint8(&o.INTENCLR.Reg) & 0x1
}
func (o *AC_Type) SetINTENCLR_COMP1(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *AC_Type) GetINTENCLR_COMP1() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *AC_Type) SetINTENCLR_WIN0(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *AC_Type) GetINTENCLR_WIN0() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x10) >> 4
}

// AC.INTENSET: Interrupt Enable Set
func (o *AC_Type) SetINTENSET_COMP0(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *AC_Type) GetINTENSET_COMP0() uint8 {
	return volatile.LoadUint8(&o.INTENSET.Reg) & 0x1
}
func (o *AC_Type) SetINTENSET_COMP1(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *AC_Type) GetINTENSET_COMP1() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *AC_Type) SetINTENSET_WIN0(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *AC_Type) GetINTENSET_WIN0() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x10) >> 4
}

// AC.INTFLAG: Interrupt Flag Status and Clear
func (o *AC_Type) SetINTFLAG_COMP0(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *AC_Type) GetINTFLAG_COMP0() uint8 {
	return volatile.LoadUint8(&o.INTFLAG.Reg) & 0x1
}
func (o *AC_Type) SetINTFLAG_COMP1(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *AC_Type) GetINTFLAG_COMP1() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *AC_Type) SetINTFLAG_WIN0(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x10)|value<<4)
}
func (o *AC_Type) GetINTFLAG_WIN0() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x10) >> 4
}

// AC.STATUSA: Status A
func (o *AC_Type) SetSTATUSA_STATE0(value uint8) {
	volatile.StoreUint8(&o.STATUSA.Reg, volatile.LoadUint8(&o.STATUSA.Reg)&^(0x1)|value)
}
func (o *AC_Type) GetSTATUSA_STATE0() uint8 {
	return volatile.LoadUint8(&o.STATUSA.Reg) & 0x1
}
func (o *AC_Type) SetSTATUSA_STATE1(value uint8) {
	volatile.StoreUint8(&o.STATUSA.Reg, volatile.LoadUint8(&o.STATUSA.Reg)&^(0x2)|value<<1)
}
func (o *AC_Type) GetSTATUSA_STATE1() uint8 {
	return (volatile.LoadUint8(&o.STATUSA.Reg) & 0x2) >> 1
}
func (o *AC_Type) SetSTATUSA_WSTATE0(value uint8) {
	volatile.StoreUint8(&o.STATUSA.Reg, volatile.LoadUint8(&o.STATUSA.Reg)&^(0x30)|value<<4)
}
func (o *AC_Type) GetSTATUSA_WSTATE0() uint8 {
	return (volatile.LoadUint8(&o.STATUSA.Reg) & 0x30) >> 4
}

// AC.STATUSB: Status B
func (o *AC_Type) SetSTATUSB_READY0(value uint8) {
	volatile.StoreUint8(&o.STATUSB.Reg, volatile.LoadUint8(&o.STATUSB.Reg)&^(0x1)|value)
}
func (o *AC_Type) GetSTATUSB_READY0() uint8 {
	return volatile.LoadUint8(&o.STATUSB.Reg) & 0x1
}
func (o *AC_Type) SetSTATUSB_READY1(value uint8) {
	volatile.StoreUint8(&o.STATUSB.Reg, volatile.LoadUint8(&o.STATUSB.Reg)&^(0x2)|value<<1)
}
func (o *AC_Type) GetSTATUSB_READY1() uint8 {
	return (volatile.LoadUint8(&o.STATUSB.Reg) & 0x2) >> 1
}

// AC.DBGCTRL: Debug Control
func (o *AC_Type) SetDBGCTRL_DBGRUN(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x1)|value)
}
func (o *AC_Type) GetDBGCTRL_DBGRUN() uint8 {
	return volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x1
}

// AC.WINCTRL: Window Control
func (o *AC_Type) SetWINCTRL_WEN0(value uint8) {
	volatile.StoreUint8(&o.WINCTRL.Reg, volatile.LoadUint8(&o.WINCTRL.Reg)&^(0x1)|value)
}
func (o *AC_Type) GetWINCTRL_WEN0() uint8 {
	return volatile.LoadUint8(&o.WINCTRL.Reg) & 0x1
}
func (o *AC_Type) SetWINCTRL_WINTSEL0(value uint8) {
	volatile.StoreUint8(&o.WINCTRL.Reg, volatile.LoadUint8(&o.WINCTRL.Reg)&^(0x6)|value<<1)
}
func (o *AC_Type) GetWINCTRL_WINTSEL0() uint8 {
	return (volatile.LoadUint8(&o.WINCTRL.Reg) & 0x6) >> 1
}

// AC.SCALER: Scaler n
func (o *AC_Type) SetSCALER_VALUE(idx int, value uint8) {
	volatile.StoreUint8(&o.SCALER[idx].Reg, volatile.LoadUint8(&o.SCALER[idx].Reg)&^(0x3f)|value)
}
func (o *AC_Type) GetSCALER_VALUE(idx int) uint8 {
	return volatile.LoadUint8(&o.SCALER[idx].Reg) & 0x3f
}

// AC.COMPCTRL: Comparator Control n
func (o *AC_Type) SetCOMPCTRL_ENABLE(idx int, value uint32) {
	volatile.StoreUint32(&o.COMPCTRL[idx].Reg, volatile.LoadUint32(&o.COMPCTRL[idx].Reg)&^(0x2)|value<<1)
}
func (o *AC_Type) GetCOMPCTRL_ENABLE(idx int) uint32 {
	return (volatile.LoadUint32(&o.COMPCTRL[idx].Reg) & 0x2) >> 1
}
func (o *AC_Type) SetCOMPCTRL_SINGLE(idx int, value uint32) {
	volatile.StoreUint32(&o.COMPCTRL[idx].Reg, volatile.LoadUint32(&o.COMPCTRL[idx].Reg)&^(0x4)|value<<2)
}
func (o *AC_Type) GetCOMPCTRL_SINGLE(idx int) uint32 {
	return (volatile.LoadUint32(&o.COMPCTRL[idx].Reg) & 0x4) >> 2
}
func (o *AC_Type) SetCOMPCTRL_INTSEL(idx int, value uint32) {
	volatile.StoreUint32(&o.COMPCTRL[idx].Reg, volatile.LoadUint32(&o.COMPCTRL[idx].Reg)&^(0x18)|value<<3)
}
func (o *AC_Type) GetCOMPCTRL_INTSEL(idx int) uint32 {
	return (volatile.LoadUint32(&o.COMPCTRL[idx].Reg) & 0x18) >> 3
}
func (o *AC_Type) SetCOMPCTRL_RUNSTDBY(idx int, value uint32) {
	volatile.StoreUint32(&o.COMPCTRL[idx].Reg, volatile.LoadUint32(&o.COMPCTRL[idx].Reg)&^(0x40)|value<<6)
}
func (o *AC_Type) GetCOMPCTRL_RUNSTDBY(idx int) uint32 {
	return (volatile.LoadUint32(&o.COMPCTRL[idx].Reg) & 0x40) >> 6
}
func (o *AC_Type) SetCOMPCTRL_MUXNEG(idx int, value uint32) {
	volatile.StoreUint32(&o.COMPCTRL[idx].Reg, volatile.LoadUint32(&o.COMPCTRL[idx].Reg)&^(0x700)|value<<8)
}
func (o *AC_Type) GetCOMPCTRL_MUXNEG(idx int) uint32 {
	return (volatile.LoadUint32(&o.COMPCTRL[idx].Reg) & 0x700) >> 8
}
func (o *AC_Type) SetCOMPCTRL_MUXPOS(idx int, value uint32) {
	volatile.StoreUint32(&o.COMPCTRL[idx].Reg, volatile.LoadUint32(&o.COMPCTRL[idx].Reg)&^(0x7000)|value<<12)
}
func (o *AC_Type) GetCOMPCTRL_MUXPOS(idx int) uint32 {
	return (volatile.LoadUint32(&o.COMPCTRL[idx].Reg) & 0x7000) >> 12
}
func (o *AC_Type) SetCOMPCTRL_SWAP(idx int, value uint32) {
	volatile.StoreUint32(&o.COMPCTRL[idx].Reg, volatile.LoadUint32(&o.COMPCTRL[idx].Reg)&^(0x8000)|value<<15)
}
func (o *AC_Type) GetCOMPCTRL_SWAP(idx int) uint32 {
	return (volatile.LoadUint32(&o.COMPCTRL[idx].Reg) & 0x8000) >> 15
}
func (o *AC_Type) SetCOMPCTRL_SPEED(idx int, value uint32) {
	volatile.StoreUint32(&o.COMPCTRL[idx].Reg, volatile.LoadUint32(&o.COMPCTRL[idx].Reg)&^(0x30000)|value<<16)
}
func (o *AC_Type) GetCOMPCTRL_SPEED(idx int) uint32 {
	return (volatile.LoadUint32(&o.COMPCTRL[idx].Reg) & 0x30000) >> 16
}
func (o *AC_Type) SetCOMPCTRL_HYSTEN(idx int, value uint32) {
	volatile.StoreUint32(&o.COMPCTRL[idx].Reg, volatile.LoadUint32(&o.COMPCTRL[idx].Reg)&^(0x80000)|value<<19)
}
func (o *AC_Type) GetCOMPCTRL_HYSTEN(idx int) uint32 {
	return (volatile.LoadUint32(&o.COMPCTRL[idx].Reg) & 0x80000) >> 19
}
func (o *AC_Type) SetCOMPCTRL_HYST(idx int, value uint32) {
	volatile.StoreUint32(&o.COMPCTRL[idx].Reg, volatile.LoadUint32(&o.COMPCTRL[idx].Reg)&^(0x300000)|value<<20)
}
func (o *AC_Type) GetCOMPCTRL_HYST(idx int) uint32 {
	return (volatile.LoadUint32(&o.COMPCTRL[idx].Reg) & 0x300000) >> 20
}
func (o *AC_Type) SetCOMPCTRL_FLEN(idx int, value uint32) {
	volatile.StoreUint32(&o.COMPCTRL[idx].Reg, volatile.LoadUint32(&o.COMPCTRL[idx].Reg)&^(0x7000000)|value<<24)
}
func (o *AC_Type) GetCOMPCTRL_FLEN(idx int) uint32 {
	return (volatile.LoadUint32(&o.COMPCTRL[idx].Reg) & 0x7000000) >> 24
}
func (o *AC_Type) SetCOMPCTRL_OUT(idx int, value uint32) {
	volatile.StoreUint32(&o.COMPCTRL[idx].Reg, volatile.LoadUint32(&o.COMPCTRL[idx].Reg)&^(0x30000000)|value<<28)
}
func (o *AC_Type) GetCOMPCTRL_OUT(idx int) uint32 {
	return (volatile.LoadUint32(&o.COMPCTRL[idx].Reg) & 0x30000000) >> 28
}

// AC.SYNCBUSY: Synchronization Busy
func (o *AC_Type) SetSYNCBUSY_SWRST(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *AC_Type) GetSYNCBUSY_SWRST() uint32 {
	return volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x1
}
func (o *AC_Type) SetSYNCBUSY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *AC_Type) GetSYNCBUSY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x2) >> 1
}
func (o *AC_Type) SetSYNCBUSY_WINCTRL(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x4)|value<<2)
}
func (o *AC_Type) GetSYNCBUSY_WINCTRL() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x4) >> 2
}
func (o *AC_Type) SetSYNCBUSY_COMPCTRL0(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x8)|value<<3)
}
func (o *AC_Type) GetSYNCBUSY_COMPCTRL0() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x8) >> 3
}
func (o *AC_Type) SetSYNCBUSY_COMPCTRL1(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x10)|value<<4)
}
func (o *AC_Type) GetSYNCBUSY_COMPCTRL1() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x10) >> 4
}

// AC.CALIB: Calibration
func (o *AC_Type) SetCALIB_BIAS0(value uint16) {
	volatile.StoreUint16(&o.CALIB.Reg, volatile.LoadUint16(&o.CALIB.Reg)&^(0x3)|value)
}
func (o *AC_Type) GetCALIB_BIAS0() uint16 {
	return volatile.LoadUint16(&o.CALIB.Reg) & 0x3
}

// Analog Digital Converter
type ADC_Type struct {
	CTRLA      volatile.Register16 // 0x0
	EVCTRL     volatile.Register8  // 0x2
	DBGCTRL    volatile.Register8  // 0x3
	INPUTCTRL  volatile.Register16 // 0x4
	CTRLB      volatile.Register16 // 0x6
	REFCTRL    volatile.Register8  // 0x8
	_          byte
	AVGCTRL    volatile.Register8  // 0xA
	SAMPCTRL   volatile.Register8  // 0xB
	WINLT      volatile.Register16 // 0xC
	WINUT      volatile.Register16 // 0xE
	GAINCORR   volatile.Register16 // 0x10
	OFFSETCORR volatile.Register16 // 0x12
	SWTRIG     volatile.Register8  // 0x14
	_          [23]byte
	INTENCLR   volatile.Register8  // 0x2C
	INTENSET   volatile.Register8  // 0x2D
	INTFLAG    volatile.Register8  // 0x2E
	STATUS     volatile.Register8  // 0x2F
	SYNCBUSY   volatile.Register32 // 0x30
	DSEQDATA   volatile.Register32 // 0x34
	DSEQCTRL   volatile.Register32 // 0x38
	DSEQSTAT   volatile.Register32 // 0x3C
	RESULT     volatile.Register16 // 0x40
	_          [2]byte
	RESS       volatile.Register16 // 0x44
	_          [2]byte
	CALIB      volatile.Register16 // 0x48
}

// ADC.CTRLA: Control A
func (o *ADC_Type) SetCTRLA_SWRST(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCTRLA_SWRST() uint16 {
	return volatile.LoadUint16(&o.CTRLA.Reg) & 0x1
}
func (o *ADC_Type) SetCTRLA_ENABLE(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCTRLA_ENABLE() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCTRLA_DUALSEL(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x18)|value<<3)
}
func (o *ADC_Type) GetCTRLA_DUALSEL() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x18) >> 3
}
func (o *ADC_Type) SetCTRLA_SLAVEEN(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetCTRLA_SLAVEEN() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetCTRLA_RUNSTDBY(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetCTRLA_RUNSTDBY() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetCTRLA_ONDEMAND(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetCTRLA_ONDEMAND() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetCTRLA_PRESCALER(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x700)|value<<8)
}
func (o *ADC_Type) GetCTRLA_PRESCALER() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x700) >> 8
}
func (o *ADC_Type) SetCTRLA_R2R(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_Type) GetCTRLA_R2R() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x8000) >> 15
}

// ADC.EVCTRL: Event Control
func (o *ADC_Type) SetEVCTRL_FLUSHEI(value uint8) {
	volatile.StoreUint8(&o.EVCTRL.Reg, volatile.LoadUint8(&o.EVCTRL.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetEVCTRL_FLUSHEI() uint8 {
	return volatile.LoadUint8(&o.EVCTRL.Reg) & 0x1
}
func (o *ADC_Type) SetEVCTRL_STARTEI(value uint8) {
	volatile.StoreUint8(&o.EVCTRL.Reg, volatile.LoadUint8(&o.EVCTRL.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetEVCTRL_STARTEI() uint8 {
	return (volatile.LoadUint8(&o.EVCTRL.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetEVCTRL_FLUSHINV(value uint8) {
	volatile.StoreUint8(&o.EVCTRL.Reg, volatile.LoadUint8(&o.EVCTRL.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetEVCTRL_FLUSHINV() uint8 {
	return (volatile.LoadUint8(&o.EVCTRL.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetEVCTRL_STARTINV(value uint8) {
	volatile.StoreUint8(&o.EVCTRL.Reg, volatile.LoadUint8(&o.EVCTRL.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetEVCTRL_STARTINV() uint8 {
	return (volatile.LoadUint8(&o.EVCTRL.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetEVCTRL_RESRDYEO(value uint8) {
	volatile.StoreUint8(&o.EVCTRL.Reg, volatile.LoadUint8(&o.EVCTRL.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetEVCTRL_RESRDYEO() uint8 {
	return (volatile.LoadUint8(&o.EVCTRL.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetEVCTRL_WINMONEO(value uint8) {
	volatile.StoreUint8(&o.EVCTRL.Reg, volatile.LoadUint8(&o.EVCTRL.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetEVCTRL_WINMONEO() uint8 {
	return (volatile.LoadUint8(&o.EVCTRL.Reg) & 0x20) >> 5
}

// ADC.DBGCTRL: Debug Control
func (o *ADC_Type) SetDBGCTRL_DBGRUN(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetDBGCTRL_DBGRUN() uint8 {
	return volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x1
}

// ADC.INPUTCTRL: Input Control
func (o *ADC_Type) SetINPUTCTRL_MUXPOS(value uint16) {
	volatile.StoreUint16(&o.INPUTCTRL.Reg, volatile.LoadUint16(&o.INPUTCTRL.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetINPUTCTRL_MUXPOS() uint16 {
	return volatile.LoadUint16(&o.INPUTCTRL.Reg) & 0x1f
}
func (o *ADC_Type) SetINPUTCTRL_DIFFMODE(value uint16) {
	volatile.StoreUint16(&o.INPUTCTRL.Reg, volatile.LoadUint16(&o.INPUTCTRL.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetINPUTCTRL_DIFFMODE() uint16 {
	return (volatile.LoadUint16(&o.INPUTCTRL.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetINPUTCTRL_MUXNEG(value uint16) {
	volatile.StoreUint16(&o.INPUTCTRL.Reg, volatile.LoadUint16(&o.INPUTCTRL.Reg)&^(0x1f00)|value<<8)
}
func (o *ADC_Type) GetINPUTCTRL_MUXNEG() uint16 {
	return (volatile.LoadUint16(&o.INPUTCTRL.Reg) & 0x1f00) >> 8
}
func (o *ADC_Type) SetINPUTCTRL_DSEQSTOP(value uint16) {
	volatile.StoreUint16(&o.INPUTCTRL.Reg, volatile.LoadUint16(&o.INPUTCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_Type) GetINPUTCTRL_DSEQSTOP() uint16 {
	return (volatile.LoadUint16(&o.INPUTCTRL.Reg) & 0x8000) >> 15
}

// ADC.CTRLB: Control B
func (o *ADC_Type) SetCTRLB_LEFTADJ(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCTRLB_LEFTADJ() uint16 {
	return volatile.LoadUint16(&o.CTRLB.Reg) & 0x1
}
func (o *ADC_Type) SetCTRLB_FREERUN(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCTRLB_FREERUN() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCTRLB_CORREN(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetCTRLB_CORREN() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetCTRLB_RESSEL(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x18)|value<<3)
}
func (o *ADC_Type) GetCTRLB_RESSEL() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x18) >> 3
}
func (o *ADC_Type) SetCTRLB_WINMODE(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x700)|value<<8)
}
func (o *ADC_Type) GetCTRLB_WINMODE() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x700) >> 8
}
func (o *ADC_Type) SetCTRLB_WINSS(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetCTRLB_WINSS() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x800) >> 11
}

// ADC.REFCTRL: Reference Control
func (o *ADC_Type) SetREFCTRL_REFSEL(value uint8) {
	volatile.StoreUint8(&o.REFCTRL.Reg, volatile.LoadUint8(&o.REFCTRL.Reg)&^(0xf)|value)
}
func (o *ADC_Type) GetREFCTRL_REFSEL() uint8 {
	return volatile.LoadUint8(&o.REFCTRL.Reg) & 0xf
}
func (o *ADC_Type) SetREFCTRL_REFCOMP(value uint8) {
	volatile.StoreUint8(&o.REFCTRL.Reg, volatile.LoadUint8(&o.REFCTRL.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetREFCTRL_REFCOMP() uint8 {
	return (volatile.LoadUint8(&o.REFCTRL.Reg) & 0x80) >> 7
}

// ADC.AVGCTRL: Average Control
func (o *ADC_Type) SetAVGCTRL_SAMPLENUM(value uint8) {
	volatile.StoreUint8(&o.AVGCTRL.Reg, volatile.LoadUint8(&o.AVGCTRL.Reg)&^(0xf)|value)
}
func (o *ADC_Type) GetAVGCTRL_SAMPLENUM() uint8 {
	return volatile.LoadUint8(&o.AVGCTRL.Reg) & 0xf
}
func (o *ADC_Type) SetAVGCTRL_ADJRES(value uint8) {
	volatile.StoreUint8(&o.AVGCTRL.Reg, volatile.LoadUint8(&o.AVGCTRL.Reg)&^(0x70)|value<<4)
}
func (o *ADC_Type) GetAVGCTRL_ADJRES() uint8 {
	return (volatile.LoadUint8(&o.AVGCTRL.Reg) & 0x70) >> 4
}

// ADC.SAMPCTRL: Sample Time Control
func (o *ADC_Type) SetSAMPCTRL_SAMPLEN(value uint8) {
	volatile.StoreUint8(&o.SAMPCTRL.Reg, volatile.LoadUint8(&o.SAMPCTRL.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetSAMPCTRL_SAMPLEN() uint8 {
	return volatile.LoadUint8(&o.SAMPCTRL.Reg) & 0x3f
}
func (o *ADC_Type) SetSAMPCTRL_OFFCOMP(value uint8) {
	volatile.StoreUint8(&o.SAMPCTRL.Reg, volatile.LoadUint8(&o.SAMPCTRL.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetSAMPCTRL_OFFCOMP() uint8 {
	return (volatile.LoadUint8(&o.SAMPCTRL.Reg) & 0x80) >> 7
}

// ADC.WINLT: Window Monitor Lower Threshold
func (o *ADC_Type) SetWINLT(value uint16) {
	volatile.StoreUint16(&o.WINLT.Reg, value)
}
func (o *ADC_Type) GetWINLT() uint16 {
	return volatile.LoadUint16(&o.WINLT.Reg)
}

// ADC.WINUT: Window Monitor Upper Threshold
func (o *ADC_Type) SetWINUT(value uint16) {
	volatile.StoreUint16(&o.WINUT.Reg, value)
}
func (o *ADC_Type) GetWINUT() uint16 {
	return volatile.LoadUint16(&o.WINUT.Reg)
}

// ADC.GAINCORR: Gain Correction
func (o *ADC_Type) SetGAINCORR(value uint16) {
	volatile.StoreUint16(&o.GAINCORR.Reg, volatile.LoadUint16(&o.GAINCORR.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetGAINCORR() uint16 {
	return volatile.LoadUint16(&o.GAINCORR.Reg) & 0xfff
}

// ADC.OFFSETCORR: Offset Correction
func (o *ADC_Type) SetOFFSETCORR(value uint16) {
	volatile.StoreUint16(&o.OFFSETCORR.Reg, volatile.LoadUint16(&o.OFFSETCORR.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetOFFSETCORR() uint16 {
	return volatile.LoadUint16(&o.OFFSETCORR.Reg) & 0xfff
}

// ADC.SWTRIG: Software Trigger
func (o *ADC_Type) SetSWTRIG_FLUSH(value uint8) {
	volatile.StoreUint8(&o.SWTRIG.Reg, volatile.LoadUint8(&o.SWTRIG.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetSWTRIG_FLUSH() uint8 {
	return volatile.LoadUint8(&o.SWTRIG.Reg) & 0x1
}
func (o *ADC_Type) SetSWTRIG_START(value uint8) {
	volatile.StoreUint8(&o.SWTRIG.Reg, volatile.LoadUint8(&o.SWTRIG.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetSWTRIG_START() uint8 {
	return (volatile.LoadUint8(&o.SWTRIG.Reg) & 0x2) >> 1
}

// ADC.INTENCLR: Interrupt Enable Clear
func (o *ADC_Type) SetINTENCLR_RESRDY(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetINTENCLR_RESRDY() uint8 {
	return volatile.LoadUint8(&o.INTENCLR.Reg) & 0x1
}
func (o *ADC_Type) SetINTENCLR_OVERRUN(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetINTENCLR_OVERRUN() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetINTENCLR_WINMON(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetINTENCLR_WINMON() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x4) >> 2
}

// ADC.INTENSET: Interrupt Enable Set
func (o *ADC_Type) SetINTENSET_RESRDY(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetINTENSET_RESRDY() uint8 {
	return volatile.LoadUint8(&o.INTENSET.Reg) & 0x1
}
func (o *ADC_Type) SetINTENSET_OVERRUN(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetINTENSET_OVERRUN() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetINTENSET_WINMON(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetINTENSET_WINMON() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x4) >> 2
}

// ADC.INTFLAG: Interrupt Flag Status and Clear
func (o *ADC_Type) SetINTFLAG_RESRDY(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetINTFLAG_RESRDY() uint8 {
	return volatile.LoadUint8(&o.INTFLAG.Reg) & 0x1
}
func (o *ADC_Type) SetINTFLAG_OVERRUN(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetINTFLAG_OVERRUN() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetINTFLAG_WINMON(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetINTFLAG_WINMON() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x4) >> 2
}

// ADC.STATUS: Status
func (o *ADC_Type) SetSTATUS_ADCBUSY(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetSTATUS_ADCBUSY() uint8 {
	return volatile.LoadUint8(&o.STATUS.Reg) & 0x1
}
func (o *ADC_Type) SetSTATUS_WCC(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0xfc)|value<<2)
}
func (o *ADC_Type) GetSTATUS_WCC() uint8 {
	return (volatile.LoadUint8(&o.STATUS.Reg) & 0xfc) >> 2
}

// ADC.SYNCBUSY: Synchronization Busy
func (o *ADC_Type) SetSYNCBUSY_SWRST(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetSYNCBUSY_SWRST() uint32 {
	return volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x1
}
func (o *ADC_Type) SetSYNCBUSY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetSYNCBUSY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetSYNCBUSY_INPUTCTRL(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetSYNCBUSY_INPUTCTRL() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetSYNCBUSY_CTRLB(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetSYNCBUSY_CTRLB() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetSYNCBUSY_REFCTRL(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetSYNCBUSY_REFCTRL() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetSYNCBUSY_AVGCTRL(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetSYNCBUSY_AVGCTRL() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetSYNCBUSY_SAMPCTRL(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetSYNCBUSY_SAMPCTRL() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetSYNCBUSY_WINLT(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetSYNCBUSY_WINLT() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetSYNCBUSY_WINUT(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetSYNCBUSY_WINUT() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetSYNCBUSY_GAINCORR(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetSYNCBUSY_GAINCORR() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetSYNCBUSY_OFFSETCORR(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetSYNCBUSY_OFFSETCORR() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetSYNCBUSY_SWTRIG(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetSYNCBUSY_SWTRIG() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x800) >> 11
}

// ADC.DSEQDATA: DMA Sequencial Data
func (o *ADC_Type) SetDSEQDATA(value uint32) {
	volatile.StoreUint32(&o.DSEQDATA.Reg, value)
}
func (o *ADC_Type) GetDSEQDATA() uint32 {
	return volatile.LoadUint32(&o.DSEQDATA.Reg)
}

// ADC.DSEQCTRL: DMA Sequential Control
func (o *ADC_Type) SetDSEQCTRL_INPUTCTRL(value uint32) {
	volatile.StoreUint32(&o.DSEQCTRL.Reg, volatile.LoadUint32(&o.DSEQCTRL.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetDSEQCTRL_INPUTCTRL() uint32 {
	return volatile.LoadUint32(&o.DSEQCTRL.Reg) & 0x1
}
func (o *ADC_Type) SetDSEQCTRL_CTRLB(value uint32) {
	volatile.StoreUint32(&o.DSEQCTRL.Reg, volatile.LoadUint32(&o.DSEQCTRL.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetDSEQCTRL_CTRLB() uint32 {
	return (volatile.LoadUint32(&o.DSEQCTRL.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetDSEQCTRL_REFCTRL(value uint32) {
	volatile.StoreUint32(&o.DSEQCTRL.Reg, volatile.LoadUint32(&o.DSEQCTRL.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetDSEQCTRL_REFCTRL() uint32 {
	return (volatile.LoadUint32(&o.DSEQCTRL.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetDSEQCTRL_AVGCTRL(value uint32) {
	volatile.StoreUint32(&o.DSEQCTRL.Reg, volatile.LoadUint32(&o.DSEQCTRL.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetDSEQCTRL_AVGCTRL() uint32 {
	return (volatile.LoadUint32(&o.DSEQCTRL.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetDSEQCTRL_SAMPCTRL(value uint32) {
	volatile.StoreUint32(&o.DSEQCTRL.Reg, volatile.LoadUint32(&o.DSEQCTRL.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetDSEQCTRL_SAMPCTRL() uint32 {
	return (volatile.LoadUint32(&o.DSEQCTRL.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetDSEQCTRL_WINLT(value uint32) {
	volatile.StoreUint32(&o.DSEQCTRL.Reg, volatile.LoadUint32(&o.DSEQCTRL.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetDSEQCTRL_WINLT() uint32 {
	return (volatile.LoadUint32(&o.DSEQCTRL.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetDSEQCTRL_WINUT(value uint32) {
	volatile.StoreUint32(&o.DSEQCTRL.Reg, volatile.LoadUint32(&o.DSEQCTRL.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetDSEQCTRL_WINUT() uint32 {
	return (volatile.LoadUint32(&o.DSEQCTRL.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetDSEQCTRL_GAINCORR(value uint32) {
	volatile.StoreUint32(&o.DSEQCTRL.Reg, volatile.LoadUint32(&o.DSEQCTRL.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetDSEQCTRL_GAINCORR() uint32 {
	return (volatile.LoadUint32(&o.DSEQCTRL.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetDSEQCTRL_OFFSETCORR(value uint32) {
	volatile.StoreUint32(&o.DSEQCTRL.Reg, volatile.LoadUint32(&o.DSEQCTRL.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetDSEQCTRL_OFFSETCORR() uint32 {
	return (volatile.LoadUint32(&o.DSEQCTRL.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetDSEQCTRL_AUTOSTART(value uint32) {
	volatile.StoreUint32(&o.DSEQCTRL.Reg, volatile.LoadUint32(&o.DSEQCTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetDSEQCTRL_AUTOSTART() uint32 {
	return (volatile.LoadUint32(&o.DSEQCTRL.Reg) & 0x80000000) >> 31
}

// ADC.DSEQSTAT: DMA Sequencial Status
func (o *ADC_Type) SetDSEQSTAT_INPUTCTRL(value uint32) {
	volatile.StoreUint32(&o.DSEQSTAT.Reg, volatile.LoadUint32(&o.DSEQSTAT.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetDSEQSTAT_INPUTCTRL() uint32 {
	return volatile.LoadUint32(&o.DSEQSTAT.Reg) & 0x1
}
func (o *ADC_Type) SetDSEQSTAT_CTRLB(value uint32) {
	volatile.StoreUint32(&o.DSEQSTAT.Reg, volatile.LoadUint32(&o.DSEQSTAT.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetDSEQSTAT_CTRLB() uint32 {
	return (volatile.LoadUint32(&o.DSEQSTAT.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetDSEQSTAT_REFCTRL(value uint32) {
	volatile.StoreUint32(&o.DSEQSTAT.Reg, volatile.LoadUint32(&o.DSEQSTAT.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetDSEQSTAT_REFCTRL() uint32 {
	return (volatile.LoadUint32(&o.DSEQSTAT.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetDSEQSTAT_AVGCTRL(value uint32) {
	volatile.StoreUint32(&o.DSEQSTAT.Reg, volatile.LoadUint32(&o.DSEQSTAT.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetDSEQSTAT_AVGCTRL() uint32 {
	return (volatile.LoadUint32(&o.DSEQSTAT.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetDSEQSTAT_SAMPCTRL(value uint32) {
	volatile.StoreUint32(&o.DSEQSTAT.Reg, volatile.LoadUint32(&o.DSEQSTAT.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetDSEQSTAT_SAMPCTRL() uint32 {
	return (volatile.LoadUint32(&o.DSEQSTAT.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetDSEQSTAT_WINLT(value uint32) {
	volatile.StoreUint32(&o.DSEQSTAT.Reg, volatile.LoadUint32(&o.DSEQSTAT.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetDSEQSTAT_WINLT() uint32 {
	return (volatile.LoadUint32(&o.DSEQSTAT.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetDSEQSTAT_WINUT(value uint32) {
	volatile.StoreUint32(&o.DSEQSTAT.Reg, volatile.LoadUint32(&o.DSEQSTAT.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetDSEQSTAT_WINUT() uint32 {
	return (volatile.LoadUint32(&o.DSEQSTAT.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetDSEQSTAT_GAINCORR(value uint32) {
	volatile.StoreUint32(&o.DSEQSTAT.Reg, volatile.LoadUint32(&o.DSEQSTAT.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetDSEQSTAT_GAINCORR() uint32 {
	return (volatile.LoadUint32(&o.DSEQSTAT.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetDSEQSTAT_OFFSETCORR(value uint32) {
	volatile.StoreUint32(&o.DSEQSTAT.Reg, volatile.LoadUint32(&o.DSEQSTAT.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetDSEQSTAT_OFFSETCORR() uint32 {
	return (volatile.LoadUint32(&o.DSEQSTAT.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetDSEQSTAT_BUSY(value uint32) {
	volatile.StoreUint32(&o.DSEQSTAT.Reg, volatile.LoadUint32(&o.DSEQSTAT.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetDSEQSTAT_BUSY() uint32 {
	return (volatile.LoadUint32(&o.DSEQSTAT.Reg) & 0x80000000) >> 31
}

// ADC.RESULT: Result Conversion Value
func (o *ADC_Type) SetRESULT(value uint16) {
	volatile.StoreUint16(&o.RESULT.Reg, value)
}
func (o *ADC_Type) GetRESULT() uint16 {
	return volatile.LoadUint16(&o.RESULT.Reg)
}

// ADC.RESS: Last Sample Result
func (o *ADC_Type) SetRESS(value uint16) {
	volatile.StoreUint16(&o.RESS.Reg, value)
}
func (o *ADC_Type) GetRESS() uint16 {
	return volatile.LoadUint16(&o.RESS.Reg)
}

// ADC.CALIB: Calibration
func (o *ADC_Type) SetCALIB_BIASCOMP(value uint16) {
	volatile.StoreUint16(&o.CALIB.Reg, volatile.LoadUint16(&o.CALIB.Reg)&^(0x7)|value)
}
func (o *ADC_Type) GetCALIB_BIASCOMP() uint16 {
	return volatile.LoadUint16(&o.CALIB.Reg) & 0x7
}
func (o *ADC_Type) SetCALIB_BIASR2R(value uint16) {
	volatile.StoreUint16(&o.CALIB.Reg, volatile.LoadUint16(&o.CALIB.Reg)&^(0x70)|value<<4)
}
func (o *ADC_Type) GetCALIB_BIASR2R() uint16 {
	return (volatile.LoadUint16(&o.CALIB.Reg) & 0x70) >> 4
}
func (o *ADC_Type) SetCALIB_BIASREFBUF(value uint16) {
	volatile.StoreUint16(&o.CALIB.Reg, volatile.LoadUint16(&o.CALIB.Reg)&^(0x700)|value<<8)
}
func (o *ADC_Type) GetCALIB_BIASREFBUF() uint16 {
	return (volatile.LoadUint16(&o.CALIB.Reg) & 0x700) >> 8
}

// Advanced Encryption Standard
type AES_Type struct {
	CTRLA      volatile.Register32 // 0x0
	CTRLB      volatile.Register8  // 0x4
	INTENCLR   volatile.Register8  // 0x5
	INTENSET   volatile.Register8  // 0x6
	INTFLAG    volatile.Register8  // 0x7
	DATABUFPTR volatile.Register8  // 0x8
	DBGCTRL    volatile.Register8  // 0x9
	_          [2]byte
	KEYWORD    [8]volatile.Register32 // 0xC
	_          [12]byte
	INDATA     volatile.Register32    // 0x38
	INTVECTV   [4]volatile.Register32 // 0x3C
	_          [16]byte
	HASHKEY    [4]volatile.Register32 // 0x5C
	GHASH      [4]volatile.Register32 // 0x6C
	_          [4]byte
	CIPLEN     volatile.Register32 // 0x80
	RANDSEED   volatile.Register32 // 0x84
}

// AES.CTRLA: Control A
func (o *AES_Type) SetCTRLA_SWRST(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetCTRLA_SWRST() uint32 {
	return volatile.LoadUint32(&o.CTRLA.Reg) & 0x1
}
func (o *AES_Type) SetCTRLA_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *AES_Type) GetCTRLA_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *AES_Type) SetCTRLA_AESMODE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1c)|value<<2)
}
func (o *AES_Type) GetCTRLA_AESMODE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x1c) >> 2
}
func (o *AES_Type) SetCTRLA_CFBS(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0xe0)|value<<5)
}
func (o *AES_Type) GetCTRLA_CFBS() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0xe0) >> 5
}
func (o *AES_Type) SetCTRLA_KEYSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x300)|value<<8)
}
func (o *AES_Type) GetCTRLA_KEYSIZE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x300) >> 8
}
func (o *AES_Type) SetCTRLA_CIPHER(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x400)|value<<10)
}
func (o *AES_Type) GetCTRLA_CIPHER() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x400) >> 10
}
func (o *AES_Type) SetCTRLA_STARTMODE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x800)|value<<11)
}
func (o *AES_Type) GetCTRLA_STARTMODE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x800) >> 11
}
func (o *AES_Type) SetCTRLA_LOD(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1000)|value<<12)
}
func (o *AES_Type) GetCTRLA_LOD() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x1000) >> 12
}
func (o *AES_Type) SetCTRLA_KEYGEN(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x2000)|value<<13)
}
func (o *AES_Type) GetCTRLA_KEYGEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x2000) >> 13
}
func (o *AES_Type) SetCTRLA_XORKEY(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x4000)|value<<14)
}
func (o *AES_Type) GetCTRLA_XORKEY() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x4000) >> 14
}
func (o *AES_Type) SetCTRLA_CTYPE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0xf0000)|value<<16)
}
func (o *AES_Type) GetCTRLA_CTYPE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0xf0000) >> 16
}

// AES.CTRLB: Control B
func (o *AES_Type) SetCTRLB_START(value uint8) {
	volatile.StoreUint8(&o.CTRLB.Reg, volatile.LoadUint8(&o.CTRLB.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetCTRLB_START() uint8 {
	return volatile.LoadUint8(&o.CTRLB.Reg) & 0x1
}
func (o *AES_Type) SetCTRLB_NEWMSG(value uint8) {
	volatile.StoreUint8(&o.CTRLB.Reg, volatile.LoadUint8(&o.CTRLB.Reg)&^(0x2)|value<<1)
}
func (o *AES_Type) GetCTRLB_NEWMSG() uint8 {
	return (volatile.LoadUint8(&o.CTRLB.Reg) & 0x2) >> 1
}
func (o *AES_Type) SetCTRLB_EOM(value uint8) {
	volatile.StoreUint8(&o.CTRLB.Reg, volatile.LoadUint8(&o.CTRLB.Reg)&^(0x4)|value<<2)
}
func (o *AES_Type) GetCTRLB_EOM() uint8 {
	return (volatile.LoadUint8(&o.CTRLB.Reg) & 0x4) >> 2
}
func (o *AES_Type) SetCTRLB_GFMUL(value uint8) {
	volatile.StoreUint8(&o.CTRLB.Reg, volatile.LoadUint8(&o.CTRLB.Reg)&^(0x8)|value<<3)
}
func (o *AES_Type) GetCTRLB_GFMUL() uint8 {
	return (volatile.LoadUint8(&o.CTRLB.Reg) & 0x8) >> 3
}

// AES.INTENCLR: Interrupt Enable Clear
func (o *AES_Type) SetINTENCLR_ENCCMP(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetINTENCLR_ENCCMP() uint8 {
	return volatile.LoadUint8(&o.INTENCLR.Reg) & 0x1
}
func (o *AES_Type) SetINTENCLR_GFMCMP(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *AES_Type) GetINTENCLR_GFMCMP() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x2) >> 1
}

// AES.INTENSET: Interrupt Enable Set
func (o *AES_Type) SetINTENSET_ENCCMP(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetINTENSET_ENCCMP() uint8 {
	return volatile.LoadUint8(&o.INTENSET.Reg) & 0x1
}
func (o *AES_Type) SetINTENSET_GFMCMP(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *AES_Type) GetINTENSET_GFMCMP() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x2) >> 1
}

// AES.INTFLAG: Interrupt Flag Status
func (o *AES_Type) SetINTFLAG_ENCCMP(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetINTFLAG_ENCCMP() uint8 {
	return volatile.LoadUint8(&o.INTFLAG.Reg) & 0x1
}
func (o *AES_Type) SetINTFLAG_GFMCMP(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *AES_Type) GetINTFLAG_GFMCMP() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x2) >> 1
}

// AES.DATABUFPTR: Data buffer pointer
func (o *AES_Type) SetDATABUFPTR_INDATAPTR(value uint8) {
	volatile.StoreUint8(&o.DATABUFPTR.Reg, volatile.LoadUint8(&o.DATABUFPTR.Reg)&^(0x3)|value)
}
func (o *AES_Type) GetDATABUFPTR_INDATAPTR() uint8 {
	return volatile.LoadUint8(&o.DATABUFPTR.Reg) & 0x3
}

// AES.DBGCTRL: Debug control
func (o *AES_Type) SetDBGCTRL_DBGRUN(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x1)|value)
}
func (o *AES_Type) GetDBGCTRL_DBGRUN() uint8 {
	return volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x1
}

// Configurable Custom Logic
type CCL_Type struct {
	CTRL    volatile.Register8 // 0x0
	_       [3]byte
	SEQCTRL [2]volatile.Register8 // 0x4
	_       [2]byte
	LUTCTRL [4]volatile.Register32 // 0x8
}

// CCL.CTRL: Control
func (o *CCL_Type) SetCTRL_SWRST(value uint8) {
	volatile.StoreUint8(&o.CTRL.Reg, volatile.LoadUint8(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *CCL_Type) GetCTRL_SWRST() uint8 {
	return volatile.LoadUint8(&o.CTRL.Reg) & 0x1
}
func (o *CCL_Type) SetCTRL_ENABLE(value uint8) {
	volatile.StoreUint8(&o.CTRL.Reg, volatile.LoadUint8(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *CCL_Type) GetCTRL_ENABLE() uint8 {
	return (volatile.LoadUint8(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *CCL_Type) SetCTRL_RUNSTDBY(value uint8) {
	volatile.StoreUint8(&o.CTRL.Reg, volatile.LoadUint8(&o.CTRL.Reg)&^(0x40)|value<<6)
}
func (o *CCL_Type) GetCTRL_RUNSTDBY() uint8 {
	return (volatile.LoadUint8(&o.CTRL.Reg) & 0x40) >> 6
}

// CCL.SEQCTRL: SEQ Control x
func (o *CCL_Type) SetSEQCTRL_SEQSEL(idx int, value uint8) {
	volatile.StoreUint8(&o.SEQCTRL[idx].Reg, volatile.LoadUint8(&o.SEQCTRL[idx].Reg)&^(0xf)|value)
}
func (o *CCL_Type) GetSEQCTRL_SEQSEL(idx int) uint8 {
	return volatile.LoadUint8(&o.SEQCTRL[idx].Reg) & 0xf
}

// CCL.LUTCTRL: LUT Control x
func (o *CCL_Type) SetLUTCTRL_ENABLE(idx int, value uint32) {
	volatile.StoreUint32(&o.LUTCTRL[idx].Reg, volatile.LoadUint32(&o.LUTCTRL[idx].Reg)&^(0x2)|value<<1)
}
func (o *CCL_Type) GetLUTCTRL_ENABLE(idx int) uint32 {
	return (volatile.LoadUint32(&o.LUTCTRL[idx].Reg) & 0x2) >> 1
}
func (o *CCL_Type) SetLUTCTRL_FILTSEL(idx int, value uint32) {
	volatile.StoreUint32(&o.LUTCTRL[idx].Reg, volatile.LoadUint32(&o.LUTCTRL[idx].Reg)&^(0x30)|value<<4)
}
func (o *CCL_Type) GetLUTCTRL_FILTSEL(idx int) uint32 {
	return (volatile.LoadUint32(&o.LUTCTRL[idx].Reg) & 0x30) >> 4
}
func (o *CCL_Type) SetLUTCTRL_EDGESEL(idx int, value uint32) {
	volatile.StoreUint32(&o.LUTCTRL[idx].Reg, volatile.LoadUint32(&o.LUTCTRL[idx].Reg)&^(0x80)|value<<7)
}
func (o *CCL_Type) GetLUTCTRL_EDGESEL(idx int) uint32 {
	return (volatile.LoadUint32(&o.LUTCTRL[idx].Reg) & 0x80) >> 7
}
func (o *CCL_Type) SetLUTCTRL_INSEL0(idx int, value uint32) {
	volatile.StoreUint32(&o.LUTCTRL[idx].Reg, volatile.LoadUint32(&o.LUTCTRL[idx].Reg)&^(0xf00)|value<<8)
}
func (o *CCL_Type) GetLUTCTRL_INSEL0(idx int) uint32 {
	return (volatile.LoadUint32(&o.LUTCTRL[idx].Reg) & 0xf00) >> 8
}
func (o *CCL_Type) SetLUTCTRL_INSEL1(idx int, value uint32) {
	volatile.StoreUint32(&o.LUTCTRL[idx].Reg, volatile.LoadUint32(&o.LUTCTRL[idx].Reg)&^(0xf000)|value<<12)
}
func (o *CCL_Type) GetLUTCTRL_INSEL1(idx int) uint32 {
	return (volatile.LoadUint32(&o.LUTCTRL[idx].Reg) & 0xf000) >> 12
}
func (o *CCL_Type) SetLUTCTRL_INSEL2(idx int, value uint32) {
	volatile.StoreUint32(&o.LUTCTRL[idx].Reg, volatile.LoadUint32(&o.LUTCTRL[idx].Reg)&^(0xf0000)|value<<16)
}
func (o *CCL_Type) GetLUTCTRL_INSEL2(idx int) uint32 {
	return (volatile.LoadUint32(&o.LUTCTRL[idx].Reg) & 0xf0000) >> 16
}
func (o *CCL_Type) SetLUTCTRL_INVEI(idx int, value uint32) {
	volatile.StoreUint32(&o.LUTCTRL[idx].Reg, volatile.LoadUint32(&o.LUTCTRL[idx].Reg)&^(0x100000)|value<<20)
}
func (o *CCL_Type) GetLUTCTRL_INVEI(idx int) uint32 {
	return (volatile.LoadUint32(&o.LUTCTRL[idx].Reg) & 0x100000) >> 20
}
func (o *CCL_Type) SetLUTCTRL_LUTEI(idx int, value uint32) {
	volatile.StoreUint32(&o.LUTCTRL[idx].Reg, volatile.LoadUint32(&o.LUTCTRL[idx].Reg)&^(0x200000)|value<<21)
}
func (o *CCL_Type) GetLUTCTRL_LUTEI(idx int) uint32 {
	return (volatile.LoadUint32(&o.LUTCTRL[idx].Reg) & 0x200000) >> 21
}
func (o *CCL_Type) SetLUTCTRL_LUTEO(idx int, value uint32) {
	volatile.StoreUint32(&o.LUTCTRL[idx].Reg, volatile.LoadUint32(&o.LUTCTRL[idx].Reg)&^(0x400000)|value<<22)
}
func (o *CCL_Type) GetLUTCTRL_LUTEO(idx int) uint32 {
	return (volatile.LoadUint32(&o.LUTCTRL[idx].Reg) & 0x400000) >> 22
}
func (o *CCL_Type) SetLUTCTRL_TRUTH(idx int, value uint32) {
	volatile.StoreUint32(&o.LUTCTRL[idx].Reg, volatile.LoadUint32(&o.LUTCTRL[idx].Reg)&^(0xff000000)|value<<24)
}
func (o *CCL_Type) GetLUTCTRL_TRUTH(idx int) uint32 {
	return (volatile.LoadUint32(&o.LUTCTRL[idx].Reg) & 0xff000000) >> 24
}

// Cortex M Cache Controller
type CMCC_Type struct {
	TYPE   volatile.Register32 // 0x0
	CFG    volatile.Register32 // 0x4
	CTRL   volatile.Register32 // 0x8
	SR     volatile.Register32 // 0xC
	LCKWAY volatile.Register32 // 0x10
	_      [12]byte
	MAINT0 volatile.Register32 // 0x20
	MAINT1 volatile.Register32 // 0x24
	MCFG   volatile.Register32 // 0x28
	MEN    volatile.Register32 // 0x2C
	MCTRL  volatile.Register32 // 0x30
	MSR    volatile.Register32 // 0x34
}

// CMCC.TYPE: Cache Type Register
func (o *CMCC_Type) SetTYPE_GCLK(value uint32) {
	volatile.StoreUint32(&o.TYPE.Reg, volatile.LoadUint32(&o.TYPE.Reg)&^(0x2)|value<<1)
}
func (o *CMCC_Type) GetTYPE_GCLK() uint32 {
	return (volatile.LoadUint32(&o.TYPE.Reg) & 0x2) >> 1
}
func (o *CMCC_Type) SetTYPE_RRP(value uint32) {
	volatile.StoreUint32(&o.TYPE.Reg, volatile.LoadUint32(&o.TYPE.Reg)&^(0x10)|value<<4)
}
func (o *CMCC_Type) GetTYPE_RRP() uint32 {
	return (volatile.LoadUint32(&o.TYPE.Reg) & 0x10) >> 4
}
func (o *CMCC_Type) SetTYPE_WAYNUM(value uint32) {
	volatile.StoreUint32(&o.TYPE.Reg, volatile.LoadUint32(&o.TYPE.Reg)&^(0x60)|value<<5)
}
func (o *CMCC_Type) GetTYPE_WAYNUM() uint32 {
	return (volatile.LoadUint32(&o.TYPE.Reg) & 0x60) >> 5
}
func (o *CMCC_Type) SetTYPE_LCKDOWN(value uint32) {
	volatile.StoreUint32(&o.TYPE.Reg, volatile.LoadUint32(&o.TYPE.Reg)&^(0x80)|value<<7)
}
func (o *CMCC_Type) GetTYPE_LCKDOWN() uint32 {
	return (volatile.LoadUint32(&o.TYPE.Reg) & 0x80) >> 7
}
func (o *CMCC_Type) SetTYPE_CSIZE(value uint32) {
	volatile.StoreUint32(&o.TYPE.Reg, volatile.LoadUint32(&o.TYPE.Reg)&^(0x700)|value<<8)
}
func (o *CMCC_Type) GetTYPE_CSIZE() uint32 {
	return (volatile.LoadUint32(&o.TYPE.Reg) & 0x700) >> 8
}
func (o *CMCC_Type) SetTYPE_CLSIZE(value uint32) {
	volatile.StoreUint32(&o.TYPE.Reg, volatile.LoadUint32(&o.TYPE.Reg)&^(0x3800)|value<<11)
}
func (o *CMCC_Type) GetTYPE_CLSIZE() uint32 {
	return (volatile.LoadUint32(&o.TYPE.Reg) & 0x3800) >> 11
}

// CMCC.CFG: Cache Configuration Register
func (o *CMCC_Type) SetCFG_ICDIS(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x2)|value<<1)
}
func (o *CMCC_Type) GetCFG_ICDIS() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x2) >> 1
}
func (o *CMCC_Type) SetCFG_DCDIS(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x4)|value<<2)
}
func (o *CMCC_Type) GetCFG_DCDIS() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x4) >> 2
}
func (o *CMCC_Type) SetCFG_CSIZESW(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x70)|value<<4)
}
func (o *CMCC_Type) GetCFG_CSIZESW() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x70) >> 4
}

// CMCC.CTRL: Cache Control Register
func (o *CMCC_Type) SetCTRL_CEN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *CMCC_Type) GetCTRL_CEN() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}

// CMCC.SR: Cache Status Register
func (o *CMCC_Type) SetSR_CSTS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *CMCC_Type) GetSR_CSTS() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// CMCC.LCKWAY: Cache Lock per Way Register
func (o *CMCC_Type) SetLCKWAY(value uint32) {
	volatile.StoreUint32(&o.LCKWAY.Reg, volatile.LoadUint32(&o.LCKWAY.Reg)&^(0xf)|value)
}
func (o *CMCC_Type) GetLCKWAY() uint32 {
	return volatile.LoadUint32(&o.LCKWAY.Reg) & 0xf
}

// CMCC.MAINT0: Cache Maintenance Register 0
func (o *CMCC_Type) SetMAINT0_INVALL(value uint32) {
	volatile.StoreUint32(&o.MAINT0.Reg, volatile.LoadUint32(&o.MAINT0.Reg)&^(0x1)|value)
}
func (o *CMCC_Type) GetMAINT0_INVALL() uint32 {
	return volatile.LoadUint32(&o.MAINT0.Reg) & 0x1
}

// CMCC.MAINT1: Cache Maintenance Register 1
func (o *CMCC_Type) SetMAINT1_INDEX(value uint32) {
	volatile.StoreUint32(&o.MAINT1.Reg, volatile.LoadUint32(&o.MAINT1.Reg)&^(0xff0)|value<<4)
}
func (o *CMCC_Type) GetMAINT1_INDEX() uint32 {
	return (volatile.LoadUint32(&o.MAINT1.Reg) & 0xff0) >> 4
}
func (o *CMCC_Type) SetMAINT1_WAY(value uint32) {
	volatile.StoreUint32(&o.MAINT1.Reg, volatile.LoadUint32(&o.MAINT1.Reg)&^(0xf0000000)|value<<28)
}
func (o *CMCC_Type) GetMAINT1_WAY() uint32 {
	return (volatile.LoadUint32(&o.MAINT1.Reg) & 0xf0000000) >> 28
}

// CMCC.MCFG: Cache Monitor Configuration Register
func (o *CMCC_Type) SetMCFG_MODE(value uint32) {
	volatile.StoreUint32(&o.MCFG.Reg, volatile.LoadUint32(&o.MCFG.Reg)&^(0x3)|value)
}
func (o *CMCC_Type) GetMCFG_MODE() uint32 {
	return volatile.LoadUint32(&o.MCFG.Reg) & 0x3
}

// CMCC.MEN: Cache Monitor Enable Register
func (o *CMCC_Type) SetMEN_MENABLE(value uint32) {
	volatile.StoreUint32(&o.MEN.Reg, volatile.LoadUint32(&o.MEN.Reg)&^(0x1)|value)
}
func (o *CMCC_Type) GetMEN_MENABLE() uint32 {
	return volatile.LoadUint32(&o.MEN.Reg) & 0x1
}

// CMCC.MCTRL: Cache Monitor Control Register
func (o *CMCC_Type) SetMCTRL_SWRST(value uint32) {
	volatile.StoreUint32(&o.MCTRL.Reg, volatile.LoadUint32(&o.MCTRL.Reg)&^(0x1)|value)
}
func (o *CMCC_Type) GetMCTRL_SWRST() uint32 {
	return volatile.LoadUint32(&o.MCTRL.Reg) & 0x1
}

// CMCC.MSR: Cache Monitor Status Register
func (o *CMCC_Type) SetMSR(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, value)
}
func (o *CMCC_Type) GetMSR() uint32 {
	return volatile.LoadUint32(&o.MSR.Reg)
}

// Digital-to-Analog Converter
type DAC_Type struct {
	CTRLA    volatile.Register8 // 0x0
	CTRLB    volatile.Register8 // 0x1
	EVCTRL   volatile.Register8 // 0x2
	_        byte
	INTENCLR volatile.Register8     // 0x4
	INTENSET volatile.Register8     // 0x5
	INTFLAG  volatile.Register8     // 0x6
	STATUS   volatile.Register8     // 0x7
	SYNCBUSY volatile.Register32    // 0x8
	DACCTRL  [2]volatile.Register16 // 0xC
	DATA     [2]volatile.Register16 // 0x10
	DATABUF  [2]volatile.Register16 // 0x14
	DBGCTRL  volatile.Register8     // 0x18
	_        [3]byte
	RESULT   [2]volatile.Register16 // 0x1C
}

// DAC.CTRLA: Control A
func (o *DAC_Type) SetCTRLA_SWRST(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetCTRLA_SWRST() uint8 {
	return volatile.LoadUint8(&o.CTRLA.Reg) & 0x1
}
func (o *DAC_Type) SetCTRLA_ENABLE(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetCTRLA_ENABLE() uint8 {
	return (volatile.LoadUint8(&o.CTRLA.Reg) & 0x2) >> 1
}

// DAC.CTRLB: Control B
func (o *DAC_Type) SetCTRLB_DIFF(value uint8) {
	volatile.StoreUint8(&o.CTRLB.Reg, volatile.LoadUint8(&o.CTRLB.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetCTRLB_DIFF() uint8 {
	return volatile.LoadUint8(&o.CTRLB.Reg) & 0x1
}
func (o *DAC_Type) SetCTRLB_REFSEL(value uint8) {
	volatile.StoreUint8(&o.CTRLB.Reg, volatile.LoadUint8(&o.CTRLB.Reg)&^(0x6)|value<<1)
}
func (o *DAC_Type) GetCTRLB_REFSEL() uint8 {
	return (volatile.LoadUint8(&o.CTRLB.Reg) & 0x6) >> 1
}

// DAC.EVCTRL: Event Control
func (o *DAC_Type) SetEVCTRL_STARTEI0(value uint8) {
	volatile.StoreUint8(&o.EVCTRL.Reg, volatile.LoadUint8(&o.EVCTRL.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetEVCTRL_STARTEI0() uint8 {
	return volatile.LoadUint8(&o.EVCTRL.Reg) & 0x1
}
func (o *DAC_Type) SetEVCTRL_STARTEI1(value uint8) {
	volatile.StoreUint8(&o.EVCTRL.Reg, volatile.LoadUint8(&o.EVCTRL.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetEVCTRL_STARTEI1() uint8 {
	return (volatile.LoadUint8(&o.EVCTRL.Reg) & 0x2) >> 1
}
func (o *DAC_Type) SetEVCTRL_EMPTYEO0(value uint8) {
	volatile.StoreUint8(&o.EVCTRL.Reg, volatile.LoadUint8(&o.EVCTRL.Reg)&^(0x4)|value<<2)
}
func (o *DAC_Type) GetEVCTRL_EMPTYEO0() uint8 {
	return (volatile.LoadUint8(&o.EVCTRL.Reg) & 0x4) >> 2
}
func (o *DAC_Type) SetEVCTRL_EMPTYEO1(value uint8) {
	volatile.StoreUint8(&o.EVCTRL.Reg, volatile.LoadUint8(&o.EVCTRL.Reg)&^(0x8)|value<<3)
}
func (o *DAC_Type) GetEVCTRL_EMPTYEO1() uint8 {
	return (volatile.LoadUint8(&o.EVCTRL.Reg) & 0x8) >> 3
}
func (o *DAC_Type) SetEVCTRL_INVEI0(value uint8) {
	volatile.StoreUint8(&o.EVCTRL.Reg, volatile.LoadUint8(&o.EVCTRL.Reg)&^(0x10)|value<<4)
}
func (o *DAC_Type) GetEVCTRL_INVEI0() uint8 {
	return (volatile.LoadUint8(&o.EVCTRL.Reg) & 0x10) >> 4
}
func (o *DAC_Type) SetEVCTRL_INVEI1(value uint8) {
	volatile.StoreUint8(&o.EVCTRL.Reg, volatile.LoadUint8(&o.EVCTRL.Reg)&^(0x20)|value<<5)
}
func (o *DAC_Type) GetEVCTRL_INVEI1() uint8 {
	return (volatile.LoadUint8(&o.EVCTRL.Reg) & 0x20) >> 5
}
func (o *DAC_Type) SetEVCTRL_RESRDYEO0(value uint8) {
	volatile.StoreUint8(&o.EVCTRL.Reg, volatile.LoadUint8(&o.EVCTRL.Reg)&^(0x40)|value<<6)
}
func (o *DAC_Type) GetEVCTRL_RESRDYEO0() uint8 {
	return (volatile.LoadUint8(&o.EVCTRL.Reg) & 0x40) >> 6
}
func (o *DAC_Type) SetEVCTRL_RESRDYEO1(value uint8) {
	volatile.StoreUint8(&o.EVCTRL.Reg, volatile.LoadUint8(&o.EVCTRL.Reg)&^(0x80)|value<<7)
}
func (o *DAC_Type) GetEVCTRL_RESRDYEO1() uint8 {
	return (volatile.LoadUint8(&o.EVCTRL.Reg) & 0x80) >> 7
}

// DAC.INTENCLR: Interrupt Enable Clear
func (o *DAC_Type) SetINTENCLR_UNDERRUN0(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetINTENCLR_UNDERRUN0() uint8 {
	return volatile.LoadUint8(&o.INTENCLR.Reg) & 0x1
}
func (o *DAC_Type) SetINTENCLR_UNDERRUN1(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetINTENCLR_UNDERRUN1() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *DAC_Type) SetINTENCLR_EMPTY0(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *DAC_Type) GetINTENCLR_EMPTY0() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *DAC_Type) SetINTENCLR_EMPTY1(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *DAC_Type) GetINTENCLR_EMPTY1() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *DAC_Type) SetINTENCLR_RESRDY0(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *DAC_Type) GetINTENCLR_RESRDY0() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *DAC_Type) SetINTENCLR_RESRDY1(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *DAC_Type) GetINTENCLR_RESRDY1() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *DAC_Type) SetINTENCLR_OVERRUN0(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *DAC_Type) GetINTENCLR_OVERRUN0() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *DAC_Type) SetINTENCLR_OVERRUN1(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *DAC_Type) GetINTENCLR_OVERRUN1() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x80) >> 7
}

// DAC.INTENSET: Interrupt Enable Set
func (o *DAC_Type) SetINTENSET_UNDERRUN0(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetINTENSET_UNDERRUN0() uint8 {
	return volatile.LoadUint8(&o.INTENSET.Reg) & 0x1
}
func (o *DAC_Type) SetINTENSET_UNDERRUN1(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetINTENSET_UNDERRUN1() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *DAC_Type) SetINTENSET_EMPTY0(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *DAC_Type) GetINTENSET_EMPTY0() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *DAC_Type) SetINTENSET_EMPTY1(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *DAC_Type) GetINTENSET_EMPTY1() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *DAC_Type) SetINTENSET_RESRDY0(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *DAC_Type) GetINTENSET_RESRDY0() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *DAC_Type) SetINTENSET_RESRDY1(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *DAC_Type) GetINTENSET_RESRDY1() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *DAC_Type) SetINTENSET_OVERRUN0(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *DAC_Type) GetINTENSET_OVERRUN0() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *DAC_Type) SetINTENSET_OVERRUN1(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *DAC_Type) GetINTENSET_OVERRUN1() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x80) >> 7
}

// DAC.INTFLAG: Interrupt Flag Status and Clear
func (o *DAC_Type) SetINTFLAG_UNDERRUN0(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetINTFLAG_UNDERRUN0() uint8 {
	return volatile.LoadUint8(&o.INTFLAG.Reg) & 0x1
}
func (o *DAC_Type) SetINTFLAG_UNDERRUN1(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetINTFLAG_UNDERRUN1() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *DAC_Type) SetINTFLAG_EMPTY0(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x4)|value<<2)
}
func (o *DAC_Type) GetINTFLAG_EMPTY0() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x4) >> 2
}
func (o *DAC_Type) SetINTFLAG_EMPTY1(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x8)|value<<3)
}
func (o *DAC_Type) GetINTFLAG_EMPTY1() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x8) >> 3
}
func (o *DAC_Type) SetINTFLAG_RESRDY0(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x10)|value<<4)
}
func (o *DAC_Type) GetINTFLAG_RESRDY0() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x10) >> 4
}
func (o *DAC_Type) SetINTFLAG_RESRDY1(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x20)|value<<5)
}
func (o *DAC_Type) GetINTFLAG_RESRDY1() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x20) >> 5
}
func (o *DAC_Type) SetINTFLAG_OVERRUN0(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x40)|value<<6)
}
func (o *DAC_Type) GetINTFLAG_OVERRUN0() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x40) >> 6
}
func (o *DAC_Type) SetINTFLAG_OVERRUN1(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x80)|value<<7)
}
func (o *DAC_Type) GetINTFLAG_OVERRUN1() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x80) >> 7
}

// DAC.STATUS: Status
func (o *DAC_Type) SetSTATUS_READY0(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetSTATUS_READY0() uint8 {
	return volatile.LoadUint8(&o.STATUS.Reg) & 0x1
}
func (o *DAC_Type) SetSTATUS_READY1(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetSTATUS_READY1() uint8 {
	return (volatile.LoadUint8(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *DAC_Type) SetSTATUS_EOC0(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *DAC_Type) GetSTATUS_EOC0() uint8 {
	return (volatile.LoadUint8(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *DAC_Type) SetSTATUS_EOC1(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *DAC_Type) GetSTATUS_EOC1() uint8 {
	return (volatile.LoadUint8(&o.STATUS.Reg) & 0x8) >> 3
}

// DAC.SYNCBUSY: Synchronization Busy
func (o *DAC_Type) SetSYNCBUSY_SWRST(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetSYNCBUSY_SWRST() uint32 {
	return volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x1
}
func (o *DAC_Type) SetSYNCBUSY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetSYNCBUSY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x2) >> 1
}
func (o *DAC_Type) SetSYNCBUSY_DATA0(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x4)|value<<2)
}
func (o *DAC_Type) GetSYNCBUSY_DATA0() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x4) >> 2
}
func (o *DAC_Type) SetSYNCBUSY_DATA1(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x8)|value<<3)
}
func (o *DAC_Type) GetSYNCBUSY_DATA1() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x8) >> 3
}
func (o *DAC_Type) SetSYNCBUSY_DATABUF0(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x10)|value<<4)
}
func (o *DAC_Type) GetSYNCBUSY_DATABUF0() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x10) >> 4
}
func (o *DAC_Type) SetSYNCBUSY_DATABUF1(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x20)|value<<5)
}
func (o *DAC_Type) GetSYNCBUSY_DATABUF1() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x20) >> 5
}

// DAC.DACCTRL: DAC n Control
func (o *DAC_Type) SetDACCTRL_LEFTADJ(idx int, value uint16) {
	volatile.StoreUint16(&o.DACCTRL[idx].Reg, volatile.LoadUint16(&o.DACCTRL[idx].Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetDACCTRL_LEFTADJ(idx int) uint16 {
	return volatile.LoadUint16(&o.DACCTRL[idx].Reg) & 0x1
}
func (o *DAC_Type) SetDACCTRL_ENABLE(idx int, value uint16) {
	volatile.StoreUint16(&o.DACCTRL[idx].Reg, volatile.LoadUint16(&o.DACCTRL[idx].Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetDACCTRL_ENABLE(idx int) uint16 {
	return (volatile.LoadUint16(&o.DACCTRL[idx].Reg) & 0x2) >> 1
}
func (o *DAC_Type) SetDACCTRL_CCTRL(idx int, value uint16) {
	volatile.StoreUint16(&o.DACCTRL[idx].Reg, volatile.LoadUint16(&o.DACCTRL[idx].Reg)&^(0xc)|value<<2)
}
func (o *DAC_Type) GetDACCTRL_CCTRL(idx int) uint16 {
	return (volatile.LoadUint16(&o.DACCTRL[idx].Reg) & 0xc) >> 2
}
func (o *DAC_Type) SetDACCTRL_FEXT(idx int, value uint16) {
	volatile.StoreUint16(&o.DACCTRL[idx].Reg, volatile.LoadUint16(&o.DACCTRL[idx].Reg)&^(0x20)|value<<5)
}
func (o *DAC_Type) GetDACCTRL_FEXT(idx int) uint16 {
	return (volatile.LoadUint16(&o.DACCTRL[idx].Reg) & 0x20) >> 5
}
func (o *DAC_Type) SetDACCTRL_RUNSTDBY(idx int, value uint16) {
	volatile.StoreUint16(&o.DACCTRL[idx].Reg, volatile.LoadUint16(&o.DACCTRL[idx].Reg)&^(0x40)|value<<6)
}
func (o *DAC_Type) GetDACCTRL_RUNSTDBY(idx int) uint16 {
	return (volatile.LoadUint16(&o.DACCTRL[idx].Reg) & 0x40) >> 6
}
func (o *DAC_Type) SetDACCTRL_DITHER(idx int, value uint16) {
	volatile.StoreUint16(&o.DACCTRL[idx].Reg, volatile.LoadUint16(&o.DACCTRL[idx].Reg)&^(0x80)|value<<7)
}
func (o *DAC_Type) GetDACCTRL_DITHER(idx int) uint16 {
	return (volatile.LoadUint16(&o.DACCTRL[idx].Reg) & 0x80) >> 7
}
func (o *DAC_Type) SetDACCTRL_REFRESH(idx int, value uint16) {
	volatile.StoreUint16(&o.DACCTRL[idx].Reg, volatile.LoadUint16(&o.DACCTRL[idx].Reg)&^(0xf00)|value<<8)
}
func (o *DAC_Type) GetDACCTRL_REFRESH(idx int) uint16 {
	return (volatile.LoadUint16(&o.DACCTRL[idx].Reg) & 0xf00) >> 8
}
func (o *DAC_Type) SetDACCTRL_OSR(idx int, value uint16) {
	volatile.StoreUint16(&o.DACCTRL[idx].Reg, volatile.LoadUint16(&o.DACCTRL[idx].Reg)&^(0xe000)|value<<13)
}
func (o *DAC_Type) GetDACCTRL_OSR(idx int) uint16 {
	return (volatile.LoadUint16(&o.DACCTRL[idx].Reg) & 0xe000) >> 13
}

// DAC.DATA: DAC n Data
func (o *DAC_Type) SetDATA(idx int, value uint16) {
	volatile.StoreUint16(&o.DATA[idx].Reg, value)
}
func (o *DAC_Type) GetDATA(idx int) uint16 {
	return volatile.LoadUint16(&o.DATA[idx].Reg)
}

// DAC.DATABUF: DAC n Data Buffer
func (o *DAC_Type) SetDATABUF(idx int, value uint16) {
	volatile.StoreUint16(&o.DATABUF[idx].Reg, value)
}
func (o *DAC_Type) GetDATABUF(idx int) uint16 {
	return volatile.LoadUint16(&o.DATABUF[idx].Reg)
}

// DAC.DBGCTRL: Debug Control
func (o *DAC_Type) SetDBGCTRL_DBGRUN(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetDBGCTRL_DBGRUN() uint8 {
	return volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x1
}

// DAC.RESULT: Filter Result
func (o *DAC_Type) SetRESULT(idx int, value uint16) {
	volatile.StoreUint16(&o.RESULT[idx].Reg, value)
}
func (o *DAC_Type) GetRESULT(idx int) uint16 {
	return volatile.LoadUint16(&o.RESULT[idx].Reg)
}

// Direct Memory Access Controller
type DMAC_Type struct {
	CTRL       volatile.Register16 // 0x0
	CRCCTRL    volatile.Register16 // 0x2
	CRCDATAIN  volatile.Register32 // 0x4
	CRCCHKSUM  volatile.Register32 // 0x8
	CRCSTATUS  volatile.Register8  // 0xC
	DBGCTRL    volatile.Register8  // 0xD
	_          [2]byte
	SWTRIGCTRL volatile.Register32 // 0x10
	PRICTRL0   volatile.Register32 // 0x14
	_          [8]byte
	INTPEND    volatile.Register16 // 0x20
	_          [2]byte
	INTSTATUS  volatile.Register32 // 0x24
	BUSYCH     volatile.Register32 // 0x28
	PENDCH     volatile.Register32 // 0x2C
	ACTIVE     volatile.Register32 // 0x30
	BASEADDR   volatile.Register32 // 0x34
	WRBADDR    volatile.Register32 // 0x38
	_          [4]byte
	CHANNEL    [32]DMAC_CHANNEL_Type // 0x40
}

// DMAC.CTRL: Control
func (o *DMAC_Type) SetCTRL_SWRST(value uint16) {
	volatile.StoreUint16(&o.CTRL.Reg, volatile.LoadUint16(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetCTRL_SWRST() uint16 {
	return volatile.LoadUint16(&o.CTRL.Reg) & 0x1
}
func (o *DMAC_Type) SetCTRL_DMAENABLE(value uint16) {
	volatile.StoreUint16(&o.CTRL.Reg, volatile.LoadUint16(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetCTRL_DMAENABLE() uint16 {
	return (volatile.LoadUint16(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetCTRL_LVLEN0(value uint16) {
	volatile.StoreUint16(&o.CTRL.Reg, volatile.LoadUint16(&o.CTRL.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetCTRL_LVLEN0() uint16 {
	return (volatile.LoadUint16(&o.CTRL.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetCTRL_LVLEN1(value uint16) {
	volatile.StoreUint16(&o.CTRL.Reg, volatile.LoadUint16(&o.CTRL.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetCTRL_LVLEN1() uint16 {
	return (volatile.LoadUint16(&o.CTRL.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetCTRL_LVLEN2(value uint16) {
	volatile.StoreUint16(&o.CTRL.Reg, volatile.LoadUint16(&o.CTRL.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetCTRL_LVLEN2() uint16 {
	return (volatile.LoadUint16(&o.CTRL.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetCTRL_LVLEN3(value uint16) {
	volatile.StoreUint16(&o.CTRL.Reg, volatile.LoadUint16(&o.CTRL.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetCTRL_LVLEN3() uint16 {
	return (volatile.LoadUint16(&o.CTRL.Reg) & 0x800) >> 11
}

// DMAC.CRCCTRL: CRC Control
func (o *DMAC_Type) SetCRCCTRL_CRCBEATSIZE(value uint16) {
	volatile.StoreUint16(&o.CRCCTRL.Reg, volatile.LoadUint16(&o.CRCCTRL.Reg)&^(0x3)|value)
}
func (o *DMAC_Type) GetCRCCTRL_CRCBEATSIZE() uint16 {
	return volatile.LoadUint16(&o.CRCCTRL.Reg) & 0x3
}
func (o *DMAC_Type) SetCRCCTRL_CRCPOLY(value uint16) {
	volatile.StoreUint16(&o.CRCCTRL.Reg, volatile.LoadUint16(&o.CRCCTRL.Reg)&^(0xc)|value<<2)
}
func (o *DMAC_Type) GetCRCCTRL_CRCPOLY() uint16 {
	return (volatile.LoadUint16(&o.CRCCTRL.Reg) & 0xc) >> 2
}
func (o *DMAC_Type) SetCRCCTRL_CRCSRC(value uint16) {
	volatile.StoreUint16(&o.CRCCTRL.Reg, volatile.LoadUint16(&o.CRCCTRL.Reg)&^(0x3f00)|value<<8)
}
func (o *DMAC_Type) GetCRCCTRL_CRCSRC() uint16 {
	return (volatile.LoadUint16(&o.CRCCTRL.Reg) & 0x3f00) >> 8
}
func (o *DMAC_Type) SetCRCCTRL_CRCMODE(value uint16) {
	volatile.StoreUint16(&o.CRCCTRL.Reg, volatile.LoadUint16(&o.CRCCTRL.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC_Type) GetCRCCTRL_CRCMODE() uint16 {
	return (volatile.LoadUint16(&o.CRCCTRL.Reg) & 0xc000) >> 14
}

// DMAC.CRCDATAIN: CRC Data Input
func (o *DMAC_Type) SetCRCDATAIN(value uint32) {
	volatile.StoreUint32(&o.CRCDATAIN.Reg, value)
}
func (o *DMAC_Type) GetCRCDATAIN() uint32 {
	return volatile.LoadUint32(&o.CRCDATAIN.Reg)
}

// DMAC.CRCCHKSUM: CRC Checksum
func (o *DMAC_Type) SetCRCCHKSUM(value uint32) {
	volatile.StoreUint32(&o.CRCCHKSUM.Reg, value)
}
func (o *DMAC_Type) GetCRCCHKSUM() uint32 {
	return volatile.LoadUint32(&o.CRCCHKSUM.Reg)
}

// DMAC.CRCSTATUS: CRC Status
func (o *DMAC_Type) SetCRCSTATUS_CRCBUSY(value uint8) {
	volatile.StoreUint8(&o.CRCSTATUS.Reg, volatile.LoadUint8(&o.CRCSTATUS.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetCRCSTATUS_CRCBUSY() uint8 {
	return volatile.LoadUint8(&o.CRCSTATUS.Reg) & 0x1
}
func (o *DMAC_Type) SetCRCSTATUS_CRCZERO(value uint8) {
	volatile.StoreUint8(&o.CRCSTATUS.Reg, volatile.LoadUint8(&o.CRCSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetCRCSTATUS_CRCZERO() uint8 {
	return (volatile.LoadUint8(&o.CRCSTATUS.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetCRCSTATUS_CRCERR(value uint8) {
	volatile.StoreUint8(&o.CRCSTATUS.Reg, volatile.LoadUint8(&o.CRCSTATUS.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetCRCSTATUS_CRCERR() uint8 {
	return (volatile.LoadUint8(&o.CRCSTATUS.Reg) & 0x4) >> 2
}

// DMAC.DBGCTRL: Debug Control
func (o *DMAC_Type) SetDBGCTRL_DBGRUN(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetDBGCTRL_DBGRUN() uint8 {
	return volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x1
}

// DMAC.SWTRIGCTRL: Software Trigger Control
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG0(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG0() uint32 {
	return volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x1
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG1(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG1() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG2(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG2() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG3(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG3() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG4(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG4() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG5(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG5() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG6(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG6() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG7(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG7() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG8(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG8() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG9(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG9() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG10(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG10() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG11(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG11() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG12(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG12() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG13(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG13() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG14(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG14() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG15(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG15() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG16(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG16() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG17(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x20000)|value<<17)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG17() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x20000) >> 17
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG18(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x40000)|value<<18)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG18() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x40000) >> 18
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG19(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x80000)|value<<19)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG19() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x80000) >> 19
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG20(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG20() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG21(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG21() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG22(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG22() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG23(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x800000)|value<<23)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG23() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x800000) >> 23
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG24(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG24() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x1000000) >> 24
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG25(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG25() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x2000000) >> 25
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG26(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG26() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x4000000) >> 26
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG27(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x8000000)|value<<27)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG27() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x8000000) >> 27
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG28(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG28() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x10000000) >> 28
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG29(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG29() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x20000000) >> 29
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG30(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG30() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetSWTRIGCTRL_SWTRIG31(value uint32) {
	volatile.StoreUint32(&o.SWTRIGCTRL.Reg, volatile.LoadUint32(&o.SWTRIGCTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetSWTRIGCTRL_SWTRIG31() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGCTRL.Reg) & 0x80000000) >> 31
}

// DMAC.PRICTRL0: Priority Control 0
func (o *DMAC_Type) SetPRICTRL0_LVLPRI0(value uint32) {
	volatile.StoreUint32(&o.PRICTRL0.Reg, volatile.LoadUint32(&o.PRICTRL0.Reg)&^(0x1f)|value)
}
func (o *DMAC_Type) GetPRICTRL0_LVLPRI0() uint32 {
	return volatile.LoadUint32(&o.PRICTRL0.Reg) & 0x1f
}
func (o *DMAC_Type) SetPRICTRL0_QOS0(value uint32) {
	volatile.StoreUint32(&o.PRICTRL0.Reg, volatile.LoadUint32(&o.PRICTRL0.Reg)&^(0x60)|value<<5)
}
func (o *DMAC_Type) GetPRICTRL0_QOS0() uint32 {
	return (volatile.LoadUint32(&o.PRICTRL0.Reg) & 0x60) >> 5
}
func (o *DMAC_Type) SetPRICTRL0_RRLVLEN0(value uint32) {
	volatile.StoreUint32(&o.PRICTRL0.Reg, volatile.LoadUint32(&o.PRICTRL0.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetPRICTRL0_RRLVLEN0() uint32 {
	return (volatile.LoadUint32(&o.PRICTRL0.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetPRICTRL0_LVLPRI1(value uint32) {
	volatile.StoreUint32(&o.PRICTRL0.Reg, volatile.LoadUint32(&o.PRICTRL0.Reg)&^(0x1f00)|value<<8)
}
func (o *DMAC_Type) GetPRICTRL0_LVLPRI1() uint32 {
	return (volatile.LoadUint32(&o.PRICTRL0.Reg) & 0x1f00) >> 8
}
func (o *DMAC_Type) SetPRICTRL0_QOS1(value uint32) {
	volatile.StoreUint32(&o.PRICTRL0.Reg, volatile.LoadUint32(&o.PRICTRL0.Reg)&^(0x6000)|value<<13)
}
func (o *DMAC_Type) GetPRICTRL0_QOS1() uint32 {
	return (volatile.LoadUint32(&o.PRICTRL0.Reg) & 0x6000) >> 13
}
func (o *DMAC_Type) SetPRICTRL0_RRLVLEN1(value uint32) {
	volatile.StoreUint32(&o.PRICTRL0.Reg, volatile.LoadUint32(&o.PRICTRL0.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetPRICTRL0_RRLVLEN1() uint32 {
	return (volatile.LoadUint32(&o.PRICTRL0.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetPRICTRL0_LVLPRI2(value uint32) {
	volatile.StoreUint32(&o.PRICTRL0.Reg, volatile.LoadUint32(&o.PRICTRL0.Reg)&^(0x1f0000)|value<<16)
}
func (o *DMAC_Type) GetPRICTRL0_LVLPRI2() uint32 {
	return (volatile.LoadUint32(&o.PRICTRL0.Reg) & 0x1f0000) >> 16
}
func (o *DMAC_Type) SetPRICTRL0_QOS2(value uint32) {
	volatile.StoreUint32(&o.PRICTRL0.Reg, volatile.LoadUint32(&o.PRICTRL0.Reg)&^(0x600000)|value<<21)
}
func (o *DMAC_Type) GetPRICTRL0_QOS2() uint32 {
	return (volatile.LoadUint32(&o.PRICTRL0.Reg) & 0x600000) >> 21
}
func (o *DMAC_Type) SetPRICTRL0_RRLVLEN2(value uint32) {
	volatile.StoreUint32(&o.PRICTRL0.Reg, volatile.LoadUint32(&o.PRICTRL0.Reg)&^(0x800000)|value<<23)
}
func (o *DMAC_Type) GetPRICTRL0_RRLVLEN2() uint32 {
	return (volatile.LoadUint32(&o.PRICTRL0.Reg) & 0x800000) >> 23
}
func (o *DMAC_Type) SetPRICTRL0_LVLPRI3(value uint32) {
	volatile.StoreUint32(&o.PRICTRL0.Reg, volatile.LoadUint32(&o.PRICTRL0.Reg)&^(0x1f000000)|value<<24)
}
func (o *DMAC_Type) GetPRICTRL0_LVLPRI3() uint32 {
	return (volatile.LoadUint32(&o.PRICTRL0.Reg) & 0x1f000000) >> 24
}
func (o *DMAC_Type) SetPRICTRL0_QOS3(value uint32) {
	volatile.StoreUint32(&o.PRICTRL0.Reg, volatile.LoadUint32(&o.PRICTRL0.Reg)&^(0x60000000)|value<<29)
}
func (o *DMAC_Type) GetPRICTRL0_QOS3() uint32 {
	return (volatile.LoadUint32(&o.PRICTRL0.Reg) & 0x60000000) >> 29
}
func (o *DMAC_Type) SetPRICTRL0_RRLVLEN3(value uint32) {
	volatile.StoreUint32(&o.PRICTRL0.Reg, volatile.LoadUint32(&o.PRICTRL0.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetPRICTRL0_RRLVLEN3() uint32 {
	return (volatile.LoadUint32(&o.PRICTRL0.Reg) & 0x80000000) >> 31
}

// DMAC.INTPEND: Interrupt Pending
func (o *DMAC_Type) SetINTPEND_ID(value uint16) {
	volatile.StoreUint16(&o.INTPEND.Reg, volatile.LoadUint16(&o.INTPEND.Reg)&^(0x1f)|value)
}
func (o *DMAC_Type) GetINTPEND_ID() uint16 {
	return volatile.LoadUint16(&o.INTPEND.Reg) & 0x1f
}
func (o *DMAC_Type) SetINTPEND_TERR(value uint16) {
	volatile.StoreUint16(&o.INTPEND.Reg, volatile.LoadUint16(&o.INTPEND.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetINTPEND_TERR() uint16 {
	return (volatile.LoadUint16(&o.INTPEND.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetINTPEND_TCMPL(value uint16) {
	volatile.StoreUint16(&o.INTPEND.Reg, volatile.LoadUint16(&o.INTPEND.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetINTPEND_TCMPL() uint16 {
	return (volatile.LoadUint16(&o.INTPEND.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetINTPEND_SUSP(value uint16) {
	volatile.StoreUint16(&o.INTPEND.Reg, volatile.LoadUint16(&o.INTPEND.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetINTPEND_SUSP() uint16 {
	return (volatile.LoadUint16(&o.INTPEND.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetINTPEND_CRCERR(value uint16) {
	volatile.StoreUint16(&o.INTPEND.Reg, volatile.LoadUint16(&o.INTPEND.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetINTPEND_CRCERR() uint16 {
	return (volatile.LoadUint16(&o.INTPEND.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetINTPEND_FERR(value uint16) {
	volatile.StoreUint16(&o.INTPEND.Reg, volatile.LoadUint16(&o.INTPEND.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetINTPEND_FERR() uint16 {
	return (volatile.LoadUint16(&o.INTPEND.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetINTPEND_BUSY(value uint16) {
	volatile.StoreUint16(&o.INTPEND.Reg, volatile.LoadUint16(&o.INTPEND.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetINTPEND_BUSY() uint16 {
	return (volatile.LoadUint16(&o.INTPEND.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetINTPEND_PEND(value uint16) {
	volatile.StoreUint16(&o.INTPEND.Reg, volatile.LoadUint16(&o.INTPEND.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetINTPEND_PEND() uint16 {
	return (volatile.LoadUint16(&o.INTPEND.Reg) & 0x8000) >> 15
}

// DMAC.INTSTATUS: Interrupt Status
func (o *DMAC_Type) SetINTSTATUS_CHINT0(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT0() uint32 {
	return volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x1
}
func (o *DMAC_Type) SetINTSTATUS_CHINT1(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT1() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetINTSTATUS_CHINT2(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT2() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetINTSTATUS_CHINT3(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT3() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetINTSTATUS_CHINT4(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT4() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetINTSTATUS_CHINT5(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT5() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetINTSTATUS_CHINT6(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT6() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetINTSTATUS_CHINT7(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT7() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetINTSTATUS_CHINT8(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT8() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetINTSTATUS_CHINT9(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT9() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetINTSTATUS_CHINT10(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT10() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetINTSTATUS_CHINT11(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT11() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetINTSTATUS_CHINT12(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT12() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetINTSTATUS_CHINT13(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT13() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetINTSTATUS_CHINT14(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT14() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetINTSTATUS_CHINT15(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT15() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetINTSTATUS_CHINT16(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT16() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetINTSTATUS_CHINT17(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x20000)|value<<17)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT17() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x20000) >> 17
}
func (o *DMAC_Type) SetINTSTATUS_CHINT18(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x40000)|value<<18)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT18() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x40000) >> 18
}
func (o *DMAC_Type) SetINTSTATUS_CHINT19(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x80000)|value<<19)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT19() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x80000) >> 19
}
func (o *DMAC_Type) SetINTSTATUS_CHINT20(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT20() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetINTSTATUS_CHINT21(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT21() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetINTSTATUS_CHINT22(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT22() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetINTSTATUS_CHINT23(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x800000)|value<<23)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT23() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x800000) >> 23
}
func (o *DMAC_Type) SetINTSTATUS_CHINT24(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT24() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x1000000) >> 24
}
func (o *DMAC_Type) SetINTSTATUS_CHINT25(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x2000000)|value<<25)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT25() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x2000000) >> 25
}
func (o *DMAC_Type) SetINTSTATUS_CHINT26(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT26() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x4000000) >> 26
}
func (o *DMAC_Type) SetINTSTATUS_CHINT27(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x8000000)|value<<27)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT27() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x8000000) >> 27
}
func (o *DMAC_Type) SetINTSTATUS_CHINT28(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x10000000)|value<<28)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT28() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x10000000) >> 28
}
func (o *DMAC_Type) SetINTSTATUS_CHINT29(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x20000000)|value<<29)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT29() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x20000000) >> 29
}
func (o *DMAC_Type) SetINTSTATUS_CHINT30(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT30() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetINTSTATUS_CHINT31(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetINTSTATUS_CHINT31() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x80000000) >> 31
}

// DMAC.BUSYCH: Busy Channels
func (o *DMAC_Type) SetBUSYCH_BUSYCH0(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH0() uint32 {
	return volatile.LoadUint32(&o.BUSYCH.Reg) & 0x1
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH1(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH1() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH2(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH2() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH3(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH3() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH4(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH4() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH5(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH5() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH6(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH6() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH7(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH7() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH8(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH8() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH9(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH9() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH10(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH10() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH11(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH11() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH12(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH12() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH13(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH13() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH14(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH14() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH15(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH15() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH16(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH16() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH17(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x20000)|value<<17)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH17() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x20000) >> 17
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH18(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x40000)|value<<18)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH18() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x40000) >> 18
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH19(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x80000)|value<<19)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH19() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x80000) >> 19
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH20(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH20() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH21(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH21() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH22(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH22() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH23(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x800000)|value<<23)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH23() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x800000) >> 23
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH24(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x1000000)|value<<24)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH24() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x1000000) >> 24
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH25(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x2000000)|value<<25)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH25() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x2000000) >> 25
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH26(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x4000000)|value<<26)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH26() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x4000000) >> 26
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH27(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x8000000)|value<<27)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH27() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x8000000) >> 27
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH28(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x10000000)|value<<28)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH28() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x10000000) >> 28
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH29(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x20000000)|value<<29)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH29() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x20000000) >> 29
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH30(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH30() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetBUSYCH_BUSYCH31(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetBUSYCH_BUSYCH31() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x80000000) >> 31
}

// DMAC.PENDCH: Pending Channels
func (o *DMAC_Type) SetPENDCH_PENDCH0(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetPENDCH_PENDCH0() uint32 {
	return volatile.LoadUint32(&o.PENDCH.Reg) & 0x1
}
func (o *DMAC_Type) SetPENDCH_PENDCH1(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetPENDCH_PENDCH1() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetPENDCH_PENDCH2(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetPENDCH_PENDCH2() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetPENDCH_PENDCH3(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetPENDCH_PENDCH3() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetPENDCH_PENDCH4(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x10)|value<<4)
}
func (o *DMAC_Type) GetPENDCH_PENDCH4() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x10) >> 4
}
func (o *DMAC_Type) SetPENDCH_PENDCH5(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x20)|value<<5)
}
func (o *DMAC_Type) GetPENDCH_PENDCH5() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x20) >> 5
}
func (o *DMAC_Type) SetPENDCH_PENDCH6(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_Type) GetPENDCH_PENDCH6() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x40) >> 6
}
func (o *DMAC_Type) SetPENDCH_PENDCH7(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_Type) GetPENDCH_PENDCH7() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x80) >> 7
}
func (o *DMAC_Type) SetPENDCH_PENDCH8(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x100)|value<<8)
}
func (o *DMAC_Type) GetPENDCH_PENDCH8() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x100) >> 8
}
func (o *DMAC_Type) SetPENDCH_PENDCH9(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x200)|value<<9)
}
func (o *DMAC_Type) GetPENDCH_PENDCH9() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x200) >> 9
}
func (o *DMAC_Type) SetPENDCH_PENDCH10(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x400)|value<<10)
}
func (o *DMAC_Type) GetPENDCH_PENDCH10() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x400) >> 10
}
func (o *DMAC_Type) SetPENDCH_PENDCH11(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x800)|value<<11)
}
func (o *DMAC_Type) GetPENDCH_PENDCH11() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x800) >> 11
}
func (o *DMAC_Type) SetPENDCH_PENDCH12(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x1000)|value<<12)
}
func (o *DMAC_Type) GetPENDCH_PENDCH12() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x1000) >> 12
}
func (o *DMAC_Type) SetPENDCH_PENDCH13(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x2000)|value<<13)
}
func (o *DMAC_Type) GetPENDCH_PENDCH13() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x2000) >> 13
}
func (o *DMAC_Type) SetPENDCH_PENDCH14(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x4000)|value<<14)
}
func (o *DMAC_Type) GetPENDCH_PENDCH14() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x4000) >> 14
}
func (o *DMAC_Type) SetPENDCH_PENDCH15(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetPENDCH_PENDCH15() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetPENDCH_PENDCH16(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x10000)|value<<16)
}
func (o *DMAC_Type) GetPENDCH_PENDCH16() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x10000) >> 16
}
func (o *DMAC_Type) SetPENDCH_PENDCH17(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x20000)|value<<17)
}
func (o *DMAC_Type) GetPENDCH_PENDCH17() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x20000) >> 17
}
func (o *DMAC_Type) SetPENDCH_PENDCH18(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x40000)|value<<18)
}
func (o *DMAC_Type) GetPENDCH_PENDCH18() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x40000) >> 18
}
func (o *DMAC_Type) SetPENDCH_PENDCH19(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x80000)|value<<19)
}
func (o *DMAC_Type) GetPENDCH_PENDCH19() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x80000) >> 19
}
func (o *DMAC_Type) SetPENDCH_PENDCH20(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x100000)|value<<20)
}
func (o *DMAC_Type) GetPENDCH_PENDCH20() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x100000) >> 20
}
func (o *DMAC_Type) SetPENDCH_PENDCH21(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x200000)|value<<21)
}
func (o *DMAC_Type) GetPENDCH_PENDCH21() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x200000) >> 21
}
func (o *DMAC_Type) SetPENDCH_PENDCH22(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x400000)|value<<22)
}
func (o *DMAC_Type) GetPENDCH_PENDCH22() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x400000) >> 22
}
func (o *DMAC_Type) SetPENDCH_PENDCH23(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x800000)|value<<23)
}
func (o *DMAC_Type) GetPENDCH_PENDCH23() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x800000) >> 23
}
func (o *DMAC_Type) SetPENDCH_PENDCH24(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x1000000)|value<<24)
}
func (o *DMAC_Type) GetPENDCH_PENDCH24() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x1000000) >> 24
}
func (o *DMAC_Type) SetPENDCH_PENDCH25(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x2000000)|value<<25)
}
func (o *DMAC_Type) GetPENDCH_PENDCH25() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x2000000) >> 25
}
func (o *DMAC_Type) SetPENDCH_PENDCH26(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x4000000)|value<<26)
}
func (o *DMAC_Type) GetPENDCH_PENDCH26() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x4000000) >> 26
}
func (o *DMAC_Type) SetPENDCH_PENDCH27(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x8000000)|value<<27)
}
func (o *DMAC_Type) GetPENDCH_PENDCH27() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x8000000) >> 27
}
func (o *DMAC_Type) SetPENDCH_PENDCH28(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x10000000)|value<<28)
}
func (o *DMAC_Type) GetPENDCH_PENDCH28() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x10000000) >> 28
}
func (o *DMAC_Type) SetPENDCH_PENDCH29(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x20000000)|value<<29)
}
func (o *DMAC_Type) GetPENDCH_PENDCH29() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x20000000) >> 29
}
func (o *DMAC_Type) SetPENDCH_PENDCH30(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x40000000)|value<<30)
}
func (o *DMAC_Type) GetPENDCH_PENDCH30() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x40000000) >> 30
}
func (o *DMAC_Type) SetPENDCH_PENDCH31(value uint32) {
	volatile.StoreUint32(&o.PENDCH.Reg, volatile.LoadUint32(&o.PENDCH.Reg)&^(0x80000000)|value<<31)
}
func (o *DMAC_Type) GetPENDCH_PENDCH31() uint32 {
	return (volatile.LoadUint32(&o.PENDCH.Reg) & 0x80000000) >> 31
}

// DMAC.ACTIVE: Active Channel and Levels
func (o *DMAC_Type) SetACTIVE_LVLEX0(value uint32) {
	volatile.StoreUint32(&o.ACTIVE.Reg, volatile.LoadUint32(&o.ACTIVE.Reg)&^(0x1)|value)
}
func (o *DMAC_Type) GetACTIVE_LVLEX0() uint32 {
	return volatile.LoadUint32(&o.ACTIVE.Reg) & 0x1
}
func (o *DMAC_Type) SetACTIVE_LVLEX1(value uint32) {
	volatile.StoreUint32(&o.ACTIVE.Reg, volatile.LoadUint32(&o.ACTIVE.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_Type) GetACTIVE_LVLEX1() uint32 {
	return (volatile.LoadUint32(&o.ACTIVE.Reg) & 0x2) >> 1
}
func (o *DMAC_Type) SetACTIVE_LVLEX2(value uint32) {
	volatile.StoreUint32(&o.ACTIVE.Reg, volatile.LoadUint32(&o.ACTIVE.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_Type) GetACTIVE_LVLEX2() uint32 {
	return (volatile.LoadUint32(&o.ACTIVE.Reg) & 0x4) >> 2
}
func (o *DMAC_Type) SetACTIVE_LVLEX3(value uint32) {
	volatile.StoreUint32(&o.ACTIVE.Reg, volatile.LoadUint32(&o.ACTIVE.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_Type) GetACTIVE_LVLEX3() uint32 {
	return (volatile.LoadUint32(&o.ACTIVE.Reg) & 0x8) >> 3
}
func (o *DMAC_Type) SetACTIVE_ID(value uint32) {
	volatile.StoreUint32(&o.ACTIVE.Reg, volatile.LoadUint32(&o.ACTIVE.Reg)&^(0x1f00)|value<<8)
}
func (o *DMAC_Type) GetACTIVE_ID() uint32 {
	return (volatile.LoadUint32(&o.ACTIVE.Reg) & 0x1f00) >> 8
}
func (o *DMAC_Type) SetACTIVE_ABUSY(value uint32) {
	volatile.StoreUint32(&o.ACTIVE.Reg, volatile.LoadUint32(&o.ACTIVE.Reg)&^(0x8000)|value<<15)
}
func (o *DMAC_Type) GetACTIVE_ABUSY() uint32 {
	return (volatile.LoadUint32(&o.ACTIVE.Reg) & 0x8000) >> 15
}
func (o *DMAC_Type) SetACTIVE_BTCNT(value uint32) {
	volatile.StoreUint32(&o.ACTIVE.Reg, volatile.LoadUint32(&o.ACTIVE.Reg)&^(0xffff0000)|value<<16)
}
func (o *DMAC_Type) GetACTIVE_BTCNT() uint32 {
	return (volatile.LoadUint32(&o.ACTIVE.Reg) & 0xffff0000) >> 16
}

// DMAC.BASEADDR: Descriptor Memory Section Base Address
func (o *DMAC_Type) SetBASEADDR(value uint32) {
	volatile.StoreUint32(&o.BASEADDR.Reg, value)
}
func (o *DMAC_Type) GetBASEADDR() uint32 {
	return volatile.LoadUint32(&o.BASEADDR.Reg)
}

// DMAC.WRBADDR: Write-Back Memory Section Base Address
func (o *DMAC_Type) SetWRBADDR(value uint32) {
	volatile.StoreUint32(&o.WRBADDR.Reg, value)
}
func (o *DMAC_Type) GetWRBADDR() uint32 {
	return volatile.LoadUint32(&o.WRBADDR.Reg)
}

type DMAC_CHANNEL_Type struct {
	CHCTRLA    volatile.Register32 // 0x40
	CHCTRLB    volatile.Register8  // 0x44
	CHPRILVL   volatile.Register8  // 0x45
	CHEVCTRL   volatile.Register8  // 0x46
	_          [5]byte
	CHINTENCLR volatile.Register8 // 0x4C
	CHINTENSET volatile.Register8 // 0x4D
	CHINTFLAG  volatile.Register8 // 0x4E
	CHSTATUS   volatile.Register8 // 0x4F
}

// DMAC_CHANNEL.CHCTRLA: Channel n Control A
func (o *DMAC_CHANNEL_Type) SetCHCTRLA_SWRST(value uint32) {
	volatile.StoreUint32(&o.CHCTRLA.Reg, volatile.LoadUint32(&o.CHCTRLA.Reg)&^(0x1)|value)
}
func (o *DMAC_CHANNEL_Type) GetCHCTRLA_SWRST() uint32 {
	return volatile.LoadUint32(&o.CHCTRLA.Reg) & 0x1
}
func (o *DMAC_CHANNEL_Type) SetCHCTRLA_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CHCTRLA.Reg, volatile.LoadUint32(&o.CHCTRLA.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_CHANNEL_Type) GetCHCTRLA_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CHCTRLA.Reg) & 0x2) >> 1
}
func (o *DMAC_CHANNEL_Type) SetCHCTRLA_RUNSTDBY(value uint32) {
	volatile.StoreUint32(&o.CHCTRLA.Reg, volatile.LoadUint32(&o.CHCTRLA.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_CHANNEL_Type) GetCHCTRLA_RUNSTDBY() uint32 {
	return (volatile.LoadUint32(&o.CHCTRLA.Reg) & 0x40) >> 6
}
func (o *DMAC_CHANNEL_Type) SetCHCTRLA_TRIGSRC(value uint32) {
	volatile.StoreUint32(&o.CHCTRLA.Reg, volatile.LoadUint32(&o.CHCTRLA.Reg)&^(0x7f00)|value<<8)
}
func (o *DMAC_CHANNEL_Type) GetCHCTRLA_TRIGSRC() uint32 {
	return (volatile.LoadUint32(&o.CHCTRLA.Reg) & 0x7f00) >> 8
}
func (o *DMAC_CHANNEL_Type) SetCHCTRLA_TRIGACT(value uint32) {
	volatile.StoreUint32(&o.CHCTRLA.Reg, volatile.LoadUint32(&o.CHCTRLA.Reg)&^(0x300000)|value<<20)
}
func (o *DMAC_CHANNEL_Type) GetCHCTRLA_TRIGACT() uint32 {
	return (volatile.LoadUint32(&o.CHCTRLA.Reg) & 0x300000) >> 20
}
func (o *DMAC_CHANNEL_Type) SetCHCTRLA_BURSTLEN(value uint32) {
	volatile.StoreUint32(&o.CHCTRLA.Reg, volatile.LoadUint32(&o.CHCTRLA.Reg)&^(0xf000000)|value<<24)
}
func (o *DMAC_CHANNEL_Type) GetCHCTRLA_BURSTLEN() uint32 {
	return (volatile.LoadUint32(&o.CHCTRLA.Reg) & 0xf000000) >> 24
}
func (o *DMAC_CHANNEL_Type) SetCHCTRLA_THRESHOLD(value uint32) {
	volatile.StoreUint32(&o.CHCTRLA.Reg, volatile.LoadUint32(&o.CHCTRLA.Reg)&^(0x30000000)|value<<28)
}
func (o *DMAC_CHANNEL_Type) GetCHCTRLA_THRESHOLD() uint32 {
	return (volatile.LoadUint32(&o.CHCTRLA.Reg) & 0x30000000) >> 28
}

// DMAC_CHANNEL.CHCTRLB: Channel n Control B
func (o *DMAC_CHANNEL_Type) SetCHCTRLB_CMD(value uint8) {
	volatile.StoreUint8(&o.CHCTRLB.Reg, volatile.LoadUint8(&o.CHCTRLB.Reg)&^(0x3)|value)
}
func (o *DMAC_CHANNEL_Type) GetCHCTRLB_CMD() uint8 {
	return volatile.LoadUint8(&o.CHCTRLB.Reg) & 0x3
}

// DMAC_CHANNEL.CHPRILVL: Channel n Priority Level
func (o *DMAC_CHANNEL_Type) SetCHPRILVL_PRILVL(value uint8) {
	volatile.StoreUint8(&o.CHPRILVL.Reg, volatile.LoadUint8(&o.CHPRILVL.Reg)&^(0x3)|value)
}
func (o *DMAC_CHANNEL_Type) GetCHPRILVL_PRILVL() uint8 {
	return volatile.LoadUint8(&o.CHPRILVL.Reg) & 0x3
}

// DMAC_CHANNEL.CHEVCTRL: Channel n Event Control
func (o *DMAC_CHANNEL_Type) SetCHEVCTRL_EVACT(value uint8) {
	volatile.StoreUint8(&o.CHEVCTRL.Reg, volatile.LoadUint8(&o.CHEVCTRL.Reg)&^(0x7)|value)
}
func (o *DMAC_CHANNEL_Type) GetCHEVCTRL_EVACT() uint8 {
	return volatile.LoadUint8(&o.CHEVCTRL.Reg) & 0x7
}
func (o *DMAC_CHANNEL_Type) SetCHEVCTRL_EVOMODE(value uint8) {
	volatile.StoreUint8(&o.CHEVCTRL.Reg, volatile.LoadUint8(&o.CHEVCTRL.Reg)&^(0x30)|value<<4)
}
func (o *DMAC_CHANNEL_Type) GetCHEVCTRL_EVOMODE() uint8 {
	return (volatile.LoadUint8(&o.CHEVCTRL.Reg) & 0x30) >> 4
}
func (o *DMAC_CHANNEL_Type) SetCHEVCTRL_EVIE(value uint8) {
	volatile.StoreUint8(&o.CHEVCTRL.Reg, volatile.LoadUint8(&o.CHEVCTRL.Reg)&^(0x40)|value<<6)
}
func (o *DMAC_CHANNEL_Type) GetCHEVCTRL_EVIE() uint8 {
	return (volatile.LoadUint8(&o.CHEVCTRL.Reg) & 0x40) >> 6
}
func (o *DMAC_CHANNEL_Type) SetCHEVCTRL_EVOE(value uint8) {
	volatile.StoreUint8(&o.CHEVCTRL.Reg, volatile.LoadUint8(&o.CHEVCTRL.Reg)&^(0x80)|value<<7)
}
func (o *DMAC_CHANNEL_Type) GetCHEVCTRL_EVOE() uint8 {
	return (volatile.LoadUint8(&o.CHEVCTRL.Reg) & 0x80) >> 7
}

// DMAC_CHANNEL.CHINTENCLR: Channel n Interrupt Enable Clear
func (o *DMAC_CHANNEL_Type) SetCHINTENCLR_TERR(value uint8) {
	volatile.StoreUint8(&o.CHINTENCLR.Reg, volatile.LoadUint8(&o.CHINTENCLR.Reg)&^(0x1)|value)
}
func (o *DMAC_CHANNEL_Type) GetCHINTENCLR_TERR() uint8 {
	return volatile.LoadUint8(&o.CHINTENCLR.Reg) & 0x1
}
func (o *DMAC_CHANNEL_Type) SetCHINTENCLR_TCMPL(value uint8) {
	volatile.StoreUint8(&o.CHINTENCLR.Reg, volatile.LoadUint8(&o.CHINTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_CHANNEL_Type) GetCHINTENCLR_TCMPL() uint8 {
	return (volatile.LoadUint8(&o.CHINTENCLR.Reg) & 0x2) >> 1
}
func (o *DMAC_CHANNEL_Type) SetCHINTENCLR_SUSP(value uint8) {
	volatile.StoreUint8(&o.CHINTENCLR.Reg, volatile.LoadUint8(&o.CHINTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_CHANNEL_Type) GetCHINTENCLR_SUSP() uint8 {
	return (volatile.LoadUint8(&o.CHINTENCLR.Reg) & 0x4) >> 2
}

// DMAC_CHANNEL.CHINTENSET: Channel n Interrupt Enable Set
func (o *DMAC_CHANNEL_Type) SetCHINTENSET_TERR(value uint8) {
	volatile.StoreUint8(&o.CHINTENSET.Reg, volatile.LoadUint8(&o.CHINTENSET.Reg)&^(0x1)|value)
}
func (o *DMAC_CHANNEL_Type) GetCHINTENSET_TERR() uint8 {
	return volatile.LoadUint8(&o.CHINTENSET.Reg) & 0x1
}
func (o *DMAC_CHANNEL_Type) SetCHINTENSET_TCMPL(value uint8) {
	volatile.StoreUint8(&o.CHINTENSET.Reg, volatile.LoadUint8(&o.CHINTENSET.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_CHANNEL_Type) GetCHINTENSET_TCMPL() uint8 {
	return (volatile.LoadUint8(&o.CHINTENSET.Reg) & 0x2) >> 1
}
func (o *DMAC_CHANNEL_Type) SetCHINTENSET_SUSP(value uint8) {
	volatile.StoreUint8(&o.CHINTENSET.Reg, volatile.LoadUint8(&o.CHINTENSET.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_CHANNEL_Type) GetCHINTENSET_SUSP() uint8 {
	return (volatile.LoadUint8(&o.CHINTENSET.Reg) & 0x4) >> 2
}

// DMAC_CHANNEL.CHINTFLAG: Channel n Interrupt Flag Status and Clear
func (o *DMAC_CHANNEL_Type) SetCHINTFLAG_TERR(value uint8) {
	volatile.StoreUint8(&o.CHINTFLAG.Reg, volatile.LoadUint8(&o.CHINTFLAG.Reg)&^(0x1)|value)
}
func (o *DMAC_CHANNEL_Type) GetCHINTFLAG_TERR() uint8 {
	return volatile.LoadUint8(&o.CHINTFLAG.Reg) & 0x1
}
func (o *DMAC_CHANNEL_Type) SetCHINTFLAG_TCMPL(value uint8) {
	volatile.StoreUint8(&o.CHINTFLAG.Reg, volatile.LoadUint8(&o.CHINTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_CHANNEL_Type) GetCHINTFLAG_TCMPL() uint8 {
	return (volatile.LoadUint8(&o.CHINTFLAG.Reg) & 0x2) >> 1
}
func (o *DMAC_CHANNEL_Type) SetCHINTFLAG_SUSP(value uint8) {
	volatile.StoreUint8(&o.CHINTFLAG.Reg, volatile.LoadUint8(&o.CHINTFLAG.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_CHANNEL_Type) GetCHINTFLAG_SUSP() uint8 {
	return (volatile.LoadUint8(&o.CHINTFLAG.Reg) & 0x4) >> 2
}

// DMAC_CHANNEL.CHSTATUS: Channel n Status
func (o *DMAC_CHANNEL_Type) SetCHSTATUS_PEND(value uint8) {
	volatile.StoreUint8(&o.CHSTATUS.Reg, volatile.LoadUint8(&o.CHSTATUS.Reg)&^(0x1)|value)
}
func (o *DMAC_CHANNEL_Type) GetCHSTATUS_PEND() uint8 {
	return volatile.LoadUint8(&o.CHSTATUS.Reg) & 0x1
}
func (o *DMAC_CHANNEL_Type) SetCHSTATUS_BUSY(value uint8) {
	volatile.StoreUint8(&o.CHSTATUS.Reg, volatile.LoadUint8(&o.CHSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *DMAC_CHANNEL_Type) GetCHSTATUS_BUSY() uint8 {
	return (volatile.LoadUint8(&o.CHSTATUS.Reg) & 0x2) >> 1
}
func (o *DMAC_CHANNEL_Type) SetCHSTATUS_FERR(value uint8) {
	volatile.StoreUint8(&o.CHSTATUS.Reg, volatile.LoadUint8(&o.CHSTATUS.Reg)&^(0x4)|value<<2)
}
func (o *DMAC_CHANNEL_Type) GetCHSTATUS_FERR() uint8 {
	return (volatile.LoadUint8(&o.CHSTATUS.Reg) & 0x4) >> 2
}
func (o *DMAC_CHANNEL_Type) SetCHSTATUS_CRCERR(value uint8) {
	volatile.StoreUint8(&o.CHSTATUS.Reg, volatile.LoadUint8(&o.CHSTATUS.Reg)&^(0x8)|value<<3)
}
func (o *DMAC_CHANNEL_Type) GetCHSTATUS_CRCERR() uint8 {
	return (volatile.LoadUint8(&o.CHSTATUS.Reg) & 0x8) >> 3
}

// Device Service Unit
type DSU_Type struct {
	CTRL    volatile.Register8 // 0x0
	STATUSA volatile.Register8 // 0x1
	STATUSB volatile.Register8 // 0x2
	_       byte
	ADDR    volatile.Register32    // 0x4
	LENGTH  volatile.Register32    // 0x8
	DATA    volatile.Register32    // 0xC
	DCC     [2]volatile.Register32 // 0x10
	DID     volatile.Register32    // 0x18
	CFG     volatile.Register32    // 0x1C
	_       [208]byte
	DCFG    [2]volatile.Register32 // 0xF0
	_       [3848]byte
	ENTRY0  volatile.Register32 // 0x1000
	ENTRY1  volatile.Register32 // 0x1004
	END     volatile.Register32 // 0x1008
	_       [4032]byte
	MEMTYPE volatile.Register32 // 0x1FCC
	PID4    volatile.Register32 // 0x1FD0
	PID5    volatile.Register32 // 0x1FD4
	PID6    volatile.Register32 // 0x1FD8
	PID7    volatile.Register32 // 0x1FDC
	PID0    volatile.Register32 // 0x1FE0
	PID1    volatile.Register32 // 0x1FE4
	PID2    volatile.Register32 // 0x1FE8
	PID3    volatile.Register32 // 0x1FEC
	CID0    volatile.Register32 // 0x1FF0
	CID1    volatile.Register32 // 0x1FF4
	CID2    volatile.Register32 // 0x1FF8
	CID3    volatile.Register32 // 0x1FFC
}

// DSU.CTRL: Control
func (o *DSU_Type) SetCTRL_SWRST(value uint8) {
	volatile.StoreUint8(&o.CTRL.Reg, volatile.LoadUint8(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *DSU_Type) GetCTRL_SWRST() uint8 {
	return volatile.LoadUint8(&o.CTRL.Reg) & 0x1
}
func (o *DSU_Type) SetCTRL_CRC(value uint8) {
	volatile.StoreUint8(&o.CTRL.Reg, volatile.LoadUint8(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *DSU_Type) GetCTRL_CRC() uint8 {
	return (volatile.LoadUint8(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *DSU_Type) SetCTRL_MBIST(value uint8) {
	volatile.StoreUint8(&o.CTRL.Reg, volatile.LoadUint8(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *DSU_Type) GetCTRL_MBIST() uint8 {
	return (volatile.LoadUint8(&o.CTRL.Reg) & 0x8) >> 3
}
func (o *DSU_Type) SetCTRL_CE(value uint8) {
	volatile.StoreUint8(&o.CTRL.Reg, volatile.LoadUint8(&o.CTRL.Reg)&^(0x10)|value<<4)
}
func (o *DSU_Type) GetCTRL_CE() uint8 {
	return (volatile.LoadUint8(&o.CTRL.Reg) & 0x10) >> 4
}
func (o *DSU_Type) SetCTRL_ARR(value uint8) {
	volatile.StoreUint8(&o.CTRL.Reg, volatile.LoadUint8(&o.CTRL.Reg)&^(0x40)|value<<6)
}
func (o *DSU_Type) GetCTRL_ARR() uint8 {
	return (volatile.LoadUint8(&o.CTRL.Reg) & 0x40) >> 6
}
func (o *DSU_Type) SetCTRL_SMSA(value uint8) {
	volatile.StoreUint8(&o.CTRL.Reg, volatile.LoadUint8(&o.CTRL.Reg)&^(0x80)|value<<7)
}
func (o *DSU_Type) GetCTRL_SMSA() uint8 {
	return (volatile.LoadUint8(&o.CTRL.Reg) & 0x80) >> 7
}

// DSU.STATUSA: Status A
func (o *DSU_Type) SetSTATUSA_DONE(value uint8) {
	volatile.StoreUint8(&o.STATUSA.Reg, volatile.LoadUint8(&o.STATUSA.Reg)&^(0x1)|value)
}
func (o *DSU_Type) GetSTATUSA_DONE() uint8 {
	return volatile.LoadUint8(&o.STATUSA.Reg) & 0x1
}
func (o *DSU_Type) SetSTATUSA_CRSTEXT(value uint8) {
	volatile.StoreUint8(&o.STATUSA.Reg, volatile.LoadUint8(&o.STATUSA.Reg)&^(0x2)|value<<1)
}
func (o *DSU_Type) GetSTATUSA_CRSTEXT() uint8 {
	return (volatile.LoadUint8(&o.STATUSA.Reg) & 0x2) >> 1
}
func (o *DSU_Type) SetSTATUSA_BERR(value uint8) {
	volatile.StoreUint8(&o.STATUSA.Reg, volatile.LoadUint8(&o.STATUSA.Reg)&^(0x4)|value<<2)
}
func (o *DSU_Type) GetSTATUSA_BERR() uint8 {
	return (volatile.LoadUint8(&o.STATUSA.Reg) & 0x4) >> 2
}
func (o *DSU_Type) SetSTATUSA_FAIL(value uint8) {
	volatile.StoreUint8(&o.STATUSA.Reg, volatile.LoadUint8(&o.STATUSA.Reg)&^(0x8)|value<<3)
}
func (o *DSU_Type) GetSTATUSA_FAIL() uint8 {
	return (volatile.LoadUint8(&o.STATUSA.Reg) & 0x8) >> 3
}
func (o *DSU_Type) SetSTATUSA_PERR(value uint8) {
	volatile.StoreUint8(&o.STATUSA.Reg, volatile.LoadUint8(&o.STATUSA.Reg)&^(0x10)|value<<4)
}
func (o *DSU_Type) GetSTATUSA_PERR() uint8 {
	return (volatile.LoadUint8(&o.STATUSA.Reg) & 0x10) >> 4
}

// DSU.STATUSB: Status B
func (o *DSU_Type) SetSTATUSB_PROT(value uint8) {
	volatile.StoreUint8(&o.STATUSB.Reg, volatile.LoadUint8(&o.STATUSB.Reg)&^(0x1)|value)
}
func (o *DSU_Type) GetSTATUSB_PROT() uint8 {
	return volatile.LoadUint8(&o.STATUSB.Reg) & 0x1
}
func (o *DSU_Type) SetSTATUSB_DBGPRES(value uint8) {
	volatile.StoreUint8(&o.STATUSB.Reg, volatile.LoadUint8(&o.STATUSB.Reg)&^(0x2)|value<<1)
}
func (o *DSU_Type) GetSTATUSB_DBGPRES() uint8 {
	return (volatile.LoadUint8(&o.STATUSB.Reg) & 0x2) >> 1
}
func (o *DSU_Type) SetSTATUSB_DCCD0(value uint8) {
	volatile.StoreUint8(&o.STATUSB.Reg, volatile.LoadUint8(&o.STATUSB.Reg)&^(0x4)|value<<2)
}
func (o *DSU_Type) GetSTATUSB_DCCD0() uint8 {
	return (volatile.LoadUint8(&o.STATUSB.Reg) & 0x4) >> 2
}
func (o *DSU_Type) SetSTATUSB_DCCD1(value uint8) {
	volatile.StoreUint8(&o.STATUSB.Reg, volatile.LoadUint8(&o.STATUSB.Reg)&^(0x8)|value<<3)
}
func (o *DSU_Type) GetSTATUSB_DCCD1() uint8 {
	return (volatile.LoadUint8(&o.STATUSB.Reg) & 0x8) >> 3
}
func (o *DSU_Type) SetSTATUSB_HPE(value uint8) {
	volatile.StoreUint8(&o.STATUSB.Reg, volatile.LoadUint8(&o.STATUSB.Reg)&^(0x10)|value<<4)
}
func (o *DSU_Type) GetSTATUSB_HPE() uint8 {
	return (volatile.LoadUint8(&o.STATUSB.Reg) & 0x10) >> 4
}
func (o *DSU_Type) SetSTATUSB_CELCK(value uint8) {
	volatile.StoreUint8(&o.STATUSB.Reg, volatile.LoadUint8(&o.STATUSB.Reg)&^(0x20)|value<<5)
}
func (o *DSU_Type) GetSTATUSB_CELCK() uint8 {
	return (volatile.LoadUint8(&o.STATUSB.Reg) & 0x20) >> 5
}
func (o *DSU_Type) SetSTATUSB_TDCCD0(value uint8) {
	volatile.StoreUint8(&o.STATUSB.Reg, volatile.LoadUint8(&o.STATUSB.Reg)&^(0x40)|value<<6)
}
func (o *DSU_Type) GetSTATUSB_TDCCD0() uint8 {
	return (volatile.LoadUint8(&o.STATUSB.Reg) & 0x40) >> 6
}
func (o *DSU_Type) SetSTATUSB_TDCCD1(value uint8) {
	volatile.StoreUint8(&o.STATUSB.Reg, volatile.LoadUint8(&o.STATUSB.Reg)&^(0x80)|value<<7)
}
func (o *DSU_Type) GetSTATUSB_TDCCD1() uint8 {
	return (volatile.LoadUint8(&o.STATUSB.Reg) & 0x80) >> 7
}

// DSU.ADDR: Address
func (o *DSU_Type) SetADDR_AMOD(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, volatile.LoadUint32(&o.ADDR.Reg)&^(0x3)|value)
}
func (o *DSU_Type) GetADDR_AMOD() uint32 {
	return volatile.LoadUint32(&o.ADDR.Reg) & 0x3
}
func (o *DSU_Type) SetADDR(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, volatile.LoadUint32(&o.ADDR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DSU_Type) GetADDR() uint32 {
	return (volatile.LoadUint32(&o.ADDR.Reg) & 0xfffffffc) >> 2
}

// DSU.LENGTH: Length
func (o *DSU_Type) SetLENGTH(value uint32) {
	volatile.StoreUint32(&o.LENGTH.Reg, volatile.LoadUint32(&o.LENGTH.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DSU_Type) GetLENGTH() uint32 {
	return (volatile.LoadUint32(&o.LENGTH.Reg) & 0xfffffffc) >> 2
}

// DSU.DATA: Data
func (o *DSU_Type) SetDATA(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, value)
}
func (o *DSU_Type) GetDATA() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg)
}

// DSU.DCC: Debug Communication Channel n
func (o *DSU_Type) SetDCC(idx int, value uint32) {
	volatile.StoreUint32(&o.DCC[idx].Reg, value)
}
func (o *DSU_Type) GetDCC(idx int) uint32 {
	return volatile.LoadUint32(&o.DCC[idx].Reg)
}

// DSU.DID: Device Identification
func (o *DSU_Type) SetDID_DEVSEL(value uint32) {
	volatile.StoreUint32(&o.DID.Reg, volatile.LoadUint32(&o.DID.Reg)&^(0xff)|value)
}
func (o *DSU_Type) GetDID_DEVSEL() uint32 {
	return volatile.LoadUint32(&o.DID.Reg) & 0xff
}
func (o *DSU_Type) SetDID_REVISION(value uint32) {
	volatile.StoreUint32(&o.DID.Reg, volatile.LoadUint32(&o.DID.Reg)&^(0xf00)|value<<8)
}
func (o *DSU_Type) GetDID_REVISION() uint32 {
	return (volatile.LoadUint32(&o.DID.Reg) & 0xf00) >> 8
}
func (o *DSU_Type) SetDID_DIE(value uint32) {
	volatile.StoreUint32(&o.DID.Reg, volatile.LoadUint32(&o.DID.Reg)&^(0xf000)|value<<12)
}
func (o *DSU_Type) GetDID_DIE() uint32 {
	return (volatile.LoadUint32(&o.DID.Reg) & 0xf000) >> 12
}
func (o *DSU_Type) SetDID_SERIES(value uint32) {
	volatile.StoreUint32(&o.DID.Reg, volatile.LoadUint32(&o.DID.Reg)&^(0x3f0000)|value<<16)
}
func (o *DSU_Type) GetDID_SERIES() uint32 {
	return (volatile.LoadUint32(&o.DID.Reg) & 0x3f0000) >> 16
}
func (o *DSU_Type) SetDID_FAMILY(value uint32) {
	volatile.StoreUint32(&o.DID.Reg, volatile.LoadUint32(&o.DID.Reg)&^(0xf800000)|value<<23)
}
func (o *DSU_Type) GetDID_FAMILY() uint32 {
	return (volatile.LoadUint32(&o.DID.Reg) & 0xf800000) >> 23
}
func (o *DSU_Type) SetDID_PROCESSOR(value uint32) {
	volatile.StoreUint32(&o.DID.Reg, volatile.LoadUint32(&o.DID.Reg)&^(0xf0000000)|value<<28)
}
func (o *DSU_Type) GetDID_PROCESSOR() uint32 {
	return (volatile.LoadUint32(&o.DID.Reg) & 0xf0000000) >> 28
}

// DSU.CFG: Configuration
func (o *DSU_Type) SetCFG_LQOS(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x3)|value)
}
func (o *DSU_Type) GetCFG_LQOS() uint32 {
	return volatile.LoadUint32(&o.CFG.Reg) & 0x3
}
func (o *DSU_Type) SetCFG_DCCDMALEVEL(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0xc)|value<<2)
}
func (o *DSU_Type) GetCFG_DCCDMALEVEL() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0xc) >> 2
}
func (o *DSU_Type) SetCFG_ETBRAMEN(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x10)|value<<4)
}
func (o *DSU_Type) GetCFG_ETBRAMEN() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x10) >> 4
}

// DSU.DCFG: Device Configuration
func (o *DSU_Type) SetDCFG(idx int, value uint32) {
	volatile.StoreUint32(&o.DCFG[idx].Reg, value)
}
func (o *DSU_Type) GetDCFG(idx int) uint32 {
	return volatile.LoadUint32(&o.DCFG[idx].Reg)
}

// DSU.ENTRY0: CoreSight ROM Table Entry 0
func (o *DSU_Type) SetENTRY0_EPRES(value uint32) {
	volatile.StoreUint32(&o.ENTRY0.Reg, volatile.LoadUint32(&o.ENTRY0.Reg)&^(0x1)|value)
}
func (o *DSU_Type) GetENTRY0_EPRES() uint32 {
	return volatile.LoadUint32(&o.ENTRY0.Reg) & 0x1
}
func (o *DSU_Type) SetENTRY0_FMT(value uint32) {
	volatile.StoreUint32(&o.ENTRY0.Reg, volatile.LoadUint32(&o.ENTRY0.Reg)&^(0x2)|value<<1)
}
func (o *DSU_Type) GetENTRY0_FMT() uint32 {
	return (volatile.LoadUint32(&o.ENTRY0.Reg) & 0x2) >> 1
}
func (o *DSU_Type) SetENTRY0_ADDOFF(value uint32) {
	volatile.StoreUint32(&o.ENTRY0.Reg, volatile.LoadUint32(&o.ENTRY0.Reg)&^(0xfffff000)|value<<12)
}
func (o *DSU_Type) GetENTRY0_ADDOFF() uint32 {
	return (volatile.LoadUint32(&o.ENTRY0.Reg) & 0xfffff000) >> 12
}

// DSU.END: CoreSight ROM Table End
func (o *DSU_Type) SetEND(value uint32) {
	volatile.StoreUint32(&o.END.Reg, value)
}
func (o *DSU_Type) GetEND() uint32 {
	return volatile.LoadUint32(&o.END.Reg)
}

// DSU.MEMTYPE: CoreSight ROM Table Memory Type
func (o *DSU_Type) SetMEMTYPE_SMEMP(value uint32) {
	volatile.StoreUint32(&o.MEMTYPE.Reg, volatile.LoadUint32(&o.MEMTYPE.Reg)&^(0x1)|value)
}
func (o *DSU_Type) GetMEMTYPE_SMEMP() uint32 {
	return volatile.LoadUint32(&o.MEMTYPE.Reg) & 0x1
}

// DSU.PID4: Peripheral Identification 4
func (o *DSU_Type) SetPID4_JEPCC(value uint32) {
	volatile.StoreUint32(&o.PID4.Reg, volatile.LoadUint32(&o.PID4.Reg)&^(0xf)|value)
}
func (o *DSU_Type) GetPID4_JEPCC() uint32 {
	return volatile.LoadUint32(&o.PID4.Reg) & 0xf
}
func (o *DSU_Type) SetPID4_FKBC(value uint32) {
	volatile.StoreUint32(&o.PID4.Reg, volatile.LoadUint32(&o.PID4.Reg)&^(0xf0)|value<<4)
}
func (o *DSU_Type) GetPID4_FKBC() uint32 {
	return (volatile.LoadUint32(&o.PID4.Reg) & 0xf0) >> 4
}

// DSU.PID0: Peripheral Identification 0
func (o *DSU_Type) SetPID0_PARTNBL(value uint32) {
	volatile.StoreUint32(&o.PID0.Reg, volatile.LoadUint32(&o.PID0.Reg)&^(0xff)|value)
}
func (o *DSU_Type) GetPID0_PARTNBL() uint32 {
	return volatile.LoadUint32(&o.PID0.Reg) & 0xff
}

// DSU.PID1: Peripheral Identification 1
func (o *DSU_Type) SetPID1_PARTNBH(value uint32) {
	volatile.StoreUint32(&o.PID1.Reg, volatile.LoadUint32(&o.PID1.Reg)&^(0xf)|value)
}
func (o *DSU_Type) GetPID1_PARTNBH() uint32 {
	return volatile.LoadUint32(&o.PID1.Reg) & 0xf
}
func (o *DSU_Type) SetPID1_JEPIDCL(value uint32) {
	volatile.StoreUint32(&o.PID1.Reg, volatile.LoadUint32(&o.PID1.Reg)&^(0xf0)|value<<4)
}
func (o *DSU_Type) GetPID1_JEPIDCL() uint32 {
	return (volatile.LoadUint32(&o.PID1.Reg) & 0xf0) >> 4
}

// DSU.PID2: Peripheral Identification 2
func (o *DSU_Type) SetPID2_JEPIDCH(value uint32) {
	volatile.StoreUint32(&o.PID2.Reg, volatile.LoadUint32(&o.PID2.Reg)&^(0x7)|value)
}
func (o *DSU_Type) GetPID2_JEPIDCH() uint32 {
	return volatile.LoadUint32(&o.PID2.Reg) & 0x7
}
func (o *DSU_Type) SetPID2_JEPU(value uint32) {
	volatile.StoreUint32(&o.PID2.Reg, volatile.LoadUint32(&o.PID2.Reg)&^(0x8)|value<<3)
}
func (o *DSU_Type) GetPID2_JEPU() uint32 {
	return (volatile.LoadUint32(&o.PID2.Reg) & 0x8) >> 3
}
func (o *DSU_Type) SetPID2_REVISION(value uint32) {
	volatile.StoreUint32(&o.PID2.Reg, volatile.LoadUint32(&o.PID2.Reg)&^(0xf0)|value<<4)
}
func (o *DSU_Type) GetPID2_REVISION() uint32 {
	return (volatile.LoadUint32(&o.PID2.Reg) & 0xf0) >> 4
}

// DSU.PID3: Peripheral Identification 3
func (o *DSU_Type) SetPID3_CUSMOD(value uint32) {
	volatile.StoreUint32(&o.PID3.Reg, volatile.LoadUint32(&o.PID3.Reg)&^(0xf)|value)
}
func (o *DSU_Type) GetPID3_CUSMOD() uint32 {
	return volatile.LoadUint32(&o.PID3.Reg) & 0xf
}
func (o *DSU_Type) SetPID3_REVAND(value uint32) {
	volatile.StoreUint32(&o.PID3.Reg, volatile.LoadUint32(&o.PID3.Reg)&^(0xf0)|value<<4)
}
func (o *DSU_Type) GetPID3_REVAND() uint32 {
	return (volatile.LoadUint32(&o.PID3.Reg) & 0xf0) >> 4
}

// DSU.CID0: Component Identification 0
func (o *DSU_Type) SetCID0_PREAMBLEB0(value uint32) {
	volatile.StoreUint32(&o.CID0.Reg, volatile.LoadUint32(&o.CID0.Reg)&^(0xff)|value)
}
func (o *DSU_Type) GetCID0_PREAMBLEB0() uint32 {
	return volatile.LoadUint32(&o.CID0.Reg) & 0xff
}

// DSU.CID1: Component Identification 1
func (o *DSU_Type) SetCID1_PREAMBLE(value uint32) {
	volatile.StoreUint32(&o.CID1.Reg, volatile.LoadUint32(&o.CID1.Reg)&^(0xf)|value)
}
func (o *DSU_Type) GetCID1_PREAMBLE() uint32 {
	return volatile.LoadUint32(&o.CID1.Reg) & 0xf
}
func (o *DSU_Type) SetCID1_CCLASS(value uint32) {
	volatile.StoreUint32(&o.CID1.Reg, volatile.LoadUint32(&o.CID1.Reg)&^(0xf0)|value<<4)
}
func (o *DSU_Type) GetCID1_CCLASS() uint32 {
	return (volatile.LoadUint32(&o.CID1.Reg) & 0xf0) >> 4
}

// DSU.CID2: Component Identification 2
func (o *DSU_Type) SetCID2_PREAMBLEB2(value uint32) {
	volatile.StoreUint32(&o.CID2.Reg, volatile.LoadUint32(&o.CID2.Reg)&^(0xff)|value)
}
func (o *DSU_Type) GetCID2_PREAMBLEB2() uint32 {
	return volatile.LoadUint32(&o.CID2.Reg) & 0xff
}

// DSU.CID3: Component Identification 3
func (o *DSU_Type) SetCID3_PREAMBLEB3(value uint32) {
	volatile.StoreUint32(&o.CID3.Reg, volatile.LoadUint32(&o.CID3.Reg)&^(0xff)|value)
}
func (o *DSU_Type) GetCID3_PREAMBLEB3() uint32 {
	return volatile.LoadUint32(&o.CID3.Reg) & 0xff
}

// External Interrupt Controller
type EIC_Type struct {
	CTRLA      volatile.Register8     // 0x0
	NMICTRL    volatile.Register8     // 0x1
	NMIFLAG    volatile.Register16    // 0x2
	SYNCBUSY   volatile.Register32    // 0x4
	EVCTRL     volatile.Register32    // 0x8
	INTENCLR   volatile.Register32    // 0xC
	INTENSET   volatile.Register32    // 0x10
	INTFLAG    volatile.Register32    // 0x14
	ASYNCH     volatile.Register32    // 0x18
	CONFIG     [2]volatile.Register32 // 0x1C
	_          [12]byte
	DEBOUNCEN  volatile.Register32 // 0x30
	DPRESCALER volatile.Register32 // 0x34
	PINSTATE   volatile.Register32 // 0x38
}

// EIC.CTRLA: Control A
func (o *EIC_Type) SetCTRLA_SWRST(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *EIC_Type) GetCTRLA_SWRST() uint8 {
	return volatile.LoadUint8(&o.CTRLA.Reg) & 0x1
}
func (o *EIC_Type) SetCTRLA_ENABLE(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *EIC_Type) GetCTRLA_ENABLE() uint8 {
	return (volatile.LoadUint8(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *EIC_Type) SetCTRLA_CKSEL(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x10)|value<<4)
}
func (o *EIC_Type) GetCTRLA_CKSEL() uint8 {
	return (volatile.LoadUint8(&o.CTRLA.Reg) & 0x10) >> 4
}

// EIC.NMICTRL: Non-Maskable Interrupt Control
func (o *EIC_Type) SetNMICTRL_NMISENSE(value uint8) {
	volatile.StoreUint8(&o.NMICTRL.Reg, volatile.LoadUint8(&o.NMICTRL.Reg)&^(0x7)|value)
}
func (o *EIC_Type) GetNMICTRL_NMISENSE() uint8 {
	return volatile.LoadUint8(&o.NMICTRL.Reg) & 0x7
}
func (o *EIC_Type) SetNMICTRL_NMIFILTEN(value uint8) {
	volatile.StoreUint8(&o.NMICTRL.Reg, volatile.LoadUint8(&o.NMICTRL.Reg)&^(0x8)|value<<3)
}
func (o *EIC_Type) GetNMICTRL_NMIFILTEN() uint8 {
	return (volatile.LoadUint8(&o.NMICTRL.Reg) & 0x8) >> 3
}
func (o *EIC_Type) SetNMICTRL_NMIASYNCH(value uint8) {
	volatile.StoreUint8(&o.NMICTRL.Reg, volatile.LoadUint8(&o.NMICTRL.Reg)&^(0x10)|value<<4)
}
func (o *EIC_Type) GetNMICTRL_NMIASYNCH() uint8 {
	return (volatile.LoadUint8(&o.NMICTRL.Reg) & 0x10) >> 4
}

// EIC.NMIFLAG: Non-Maskable Interrupt Flag Status and Clear
func (o *EIC_Type) SetNMIFLAG_NMI(value uint16) {
	volatile.StoreUint16(&o.NMIFLAG.Reg, volatile.LoadUint16(&o.NMIFLAG.Reg)&^(0x1)|value)
}
func (o *EIC_Type) GetNMIFLAG_NMI() uint16 {
	return volatile.LoadUint16(&o.NMIFLAG.Reg) & 0x1
}

// EIC.SYNCBUSY: Synchronization Busy
func (o *EIC_Type) SetSYNCBUSY_SWRST(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *EIC_Type) GetSYNCBUSY_SWRST() uint32 {
	return volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x1
}
func (o *EIC_Type) SetSYNCBUSY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *EIC_Type) GetSYNCBUSY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x2) >> 1
}

// EIC.EVCTRL: Event Control
func (o *EIC_Type) SetEVCTRL_EXTINTEO(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0xffff)|value)
}
func (o *EIC_Type) GetEVCTRL_EXTINTEO() uint32 {
	return volatile.LoadUint32(&o.EVCTRL.Reg) & 0xffff
}

// EIC.INTENCLR: Interrupt Enable Clear
func (o *EIC_Type) SetINTENCLR_EXTINT(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0xffff)|value)
}
func (o *EIC_Type) GetINTENCLR_EXTINT() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0xffff
}

// EIC.INTENSET: Interrupt Enable Set
func (o *EIC_Type) SetINTENSET_EXTINT(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0xffff)|value)
}
func (o *EIC_Type) GetINTENSET_EXTINT() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0xffff
}

// EIC.INTFLAG: Interrupt Flag Status and Clear
func (o *EIC_Type) SetINTFLAG_EXTINT(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0xffff)|value)
}
func (o *EIC_Type) GetINTFLAG_EXTINT() uint32 {
	return volatile.LoadUint32(&o.INTFLAG.Reg) & 0xffff
}

// EIC.ASYNCH: External Interrupt Asynchronous Mode
func (o *EIC_Type) SetASYNCH(value uint32) {
	volatile.StoreUint32(&o.ASYNCH.Reg, volatile.LoadUint32(&o.ASYNCH.Reg)&^(0xffff)|value)
}
func (o *EIC_Type) GetASYNCH() uint32 {
	return volatile.LoadUint32(&o.ASYNCH.Reg) & 0xffff
}

// EIC.CONFIG: External Interrupt Sense Configuration
func (o *EIC_Type) SetCONFIG_SENSE0(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x7)|value)
}
func (o *EIC_Type) GetCONFIG_SENSE0(idx int) uint32 {
	return volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x7
}
func (o *EIC_Type) SetCONFIG_FILTEN0(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x8)|value<<3)
}
func (o *EIC_Type) GetCONFIG_FILTEN0(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x8) >> 3
}
func (o *EIC_Type) SetCONFIG_SENSE1(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x70)|value<<4)
}
func (o *EIC_Type) GetCONFIG_SENSE1(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x70) >> 4
}
func (o *EIC_Type) SetCONFIG_FILTEN1(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x80)|value<<7)
}
func (o *EIC_Type) GetCONFIG_FILTEN1(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x80) >> 7
}
func (o *EIC_Type) SetCONFIG_SENSE2(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x700)|value<<8)
}
func (o *EIC_Type) GetCONFIG_SENSE2(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x700) >> 8
}
func (o *EIC_Type) SetCONFIG_FILTEN2(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x800)|value<<11)
}
func (o *EIC_Type) GetCONFIG_FILTEN2(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x800) >> 11
}
func (o *EIC_Type) SetCONFIG_SENSE3(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x7000)|value<<12)
}
func (o *EIC_Type) GetCONFIG_SENSE3(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x7000) >> 12
}
func (o *EIC_Type) SetCONFIG_FILTEN3(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x8000)|value<<15)
}
func (o *EIC_Type) GetCONFIG_FILTEN3(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x8000) >> 15
}
func (o *EIC_Type) SetCONFIG_SENSE4(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x70000)|value<<16)
}
func (o *EIC_Type) GetCONFIG_SENSE4(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x70000) >> 16
}
func (o *EIC_Type) SetCONFIG_FILTEN4(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x80000)|value<<19)
}
func (o *EIC_Type) GetCONFIG_FILTEN4(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x80000) >> 19
}
func (o *EIC_Type) SetCONFIG_SENSE5(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x700000)|value<<20)
}
func (o *EIC_Type) GetCONFIG_SENSE5(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x700000) >> 20
}
func (o *EIC_Type) SetCONFIG_FILTEN5(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x800000)|value<<23)
}
func (o *EIC_Type) GetCONFIG_FILTEN5(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x800000) >> 23
}
func (o *EIC_Type) SetCONFIG_SENSE6(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x7000000)|value<<24)
}
func (o *EIC_Type) GetCONFIG_SENSE6(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x7000000) >> 24
}
func (o *EIC_Type) SetCONFIG_FILTEN6(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x8000000)|value<<27)
}
func (o *EIC_Type) GetCONFIG_FILTEN6(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x8000000) >> 27
}
func (o *EIC_Type) SetCONFIG_SENSE7(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x70000000)|value<<28)
}
func (o *EIC_Type) GetCONFIG_SENSE7(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x70000000) >> 28
}
func (o *EIC_Type) SetCONFIG_FILTEN7(idx int, value uint32) {
	volatile.StoreUint32(&o.CONFIG[idx].Reg, volatile.LoadUint32(&o.CONFIG[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *EIC_Type) GetCONFIG_FILTEN7(idx int) uint32 {
	return (volatile.LoadUint32(&o.CONFIG[idx].Reg) & 0x80000000) >> 31
}

// EIC.DEBOUNCEN: Debouncer Enable
func (o *EIC_Type) SetDEBOUNCEN(value uint32) {
	volatile.StoreUint32(&o.DEBOUNCEN.Reg, volatile.LoadUint32(&o.DEBOUNCEN.Reg)&^(0xffff)|value)
}
func (o *EIC_Type) GetDEBOUNCEN() uint32 {
	return volatile.LoadUint32(&o.DEBOUNCEN.Reg) & 0xffff
}

// EIC.DPRESCALER: Debouncer Prescaler
func (o *EIC_Type) SetDPRESCALER_PRESCALER0(value uint32) {
	volatile.StoreUint32(&o.DPRESCALER.Reg, volatile.LoadUint32(&o.DPRESCALER.Reg)&^(0x7)|value)
}
func (o *EIC_Type) GetDPRESCALER_PRESCALER0() uint32 {
	return volatile.LoadUint32(&o.DPRESCALER.Reg) & 0x7
}
func (o *EIC_Type) SetDPRESCALER_STATES0(value uint32) {
	volatile.StoreUint32(&o.DPRESCALER.Reg, volatile.LoadUint32(&o.DPRESCALER.Reg)&^(0x8)|value<<3)
}
func (o *EIC_Type) GetDPRESCALER_STATES0() uint32 {
	return (volatile.LoadUint32(&o.DPRESCALER.Reg) & 0x8) >> 3
}
func (o *EIC_Type) SetDPRESCALER_PRESCALER1(value uint32) {
	volatile.StoreUint32(&o.DPRESCALER.Reg, volatile.LoadUint32(&o.DPRESCALER.Reg)&^(0x70)|value<<4)
}
func (o *EIC_Type) GetDPRESCALER_PRESCALER1() uint32 {
	return (volatile.LoadUint32(&o.DPRESCALER.Reg) & 0x70) >> 4
}
func (o *EIC_Type) SetDPRESCALER_STATES1(value uint32) {
	volatile.StoreUint32(&o.DPRESCALER.Reg, volatile.LoadUint32(&o.DPRESCALER.Reg)&^(0x80)|value<<7)
}
func (o *EIC_Type) GetDPRESCALER_STATES1() uint32 {
	return (volatile.LoadUint32(&o.DPRESCALER.Reg) & 0x80) >> 7
}
func (o *EIC_Type) SetDPRESCALER_TICKON(value uint32) {
	volatile.StoreUint32(&o.DPRESCALER.Reg, volatile.LoadUint32(&o.DPRESCALER.Reg)&^(0x10000)|value<<16)
}
func (o *EIC_Type) GetDPRESCALER_TICKON() uint32 {
	return (volatile.LoadUint32(&o.DPRESCALER.Reg) & 0x10000) >> 16
}

// EIC.PINSTATE: Pin State
func (o *EIC_Type) SetPINSTATE(value uint32) {
	volatile.StoreUint32(&o.PINSTATE.Reg, volatile.LoadUint32(&o.PINSTATE.Reg)&^(0xffff)|value)
}
func (o *EIC_Type) GetPINSTATE() uint32 {
	return volatile.LoadUint32(&o.PINSTATE.Reg) & 0xffff
}

// Event System Interface
type EVSYS_Type struct {
	CTRLA     volatile.Register8 // 0x0
	_         [3]byte
	SWEVT     volatile.Register32 // 0x4
	PRICTRL   volatile.Register8  // 0x8
	_         [7]byte
	INTPEND   volatile.Register16 // 0x10
	_         [2]byte
	INTSTATUS volatile.Register32     // 0x14
	BUSYCH    volatile.Register32     // 0x18
	READYUSR  volatile.Register32     // 0x1C
	CHANNEL   [32]EVSYS_CHANNEL_Type  // 0x20
	USER      [67]volatile.Register32 // 0x120
}

// EVSYS.CTRLA: Control
func (o *EVSYS_Type) SetCTRLA_SWRST(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *EVSYS_Type) GetCTRLA_SWRST() uint8 {
	return volatile.LoadUint8(&o.CTRLA.Reg) & 0x1
}

// EVSYS.SWEVT: Software Event
func (o *EVSYS_Type) SetSWEVT_CHANNEL0(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x1)|value)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL0() uint32 {
	return volatile.LoadUint32(&o.SWEVT.Reg) & 0x1
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL1(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x2)|value<<1)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL1() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x2) >> 1
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL2(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x4)|value<<2)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL2() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x4) >> 2
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL3(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x8)|value<<3)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL3() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x8) >> 3
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL4(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x10)|value<<4)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL4() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x10) >> 4
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL5(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x20)|value<<5)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL5() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x20) >> 5
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL6(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x40)|value<<6)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL6() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x40) >> 6
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL7(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x80)|value<<7)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL7() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x80) >> 7
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL8(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x100)|value<<8)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL8() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x100) >> 8
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL9(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x200)|value<<9)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL9() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x200) >> 9
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL10(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x400)|value<<10)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL10() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x400) >> 10
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL11(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x800)|value<<11)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL11() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x800) >> 11
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL12(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x1000)|value<<12)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL12() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x1000) >> 12
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL13(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x2000)|value<<13)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL13() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x2000) >> 13
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL14(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x4000)|value<<14)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL14() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x4000) >> 14
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL15(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x8000)|value<<15)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL15() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x8000) >> 15
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL16(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x10000)|value<<16)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL16() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x10000) >> 16
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL17(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x20000)|value<<17)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL17() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x20000) >> 17
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL18(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x40000)|value<<18)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL18() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x40000) >> 18
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL19(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x80000)|value<<19)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL19() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x80000) >> 19
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL20(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x100000)|value<<20)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL20() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x100000) >> 20
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL21(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x200000)|value<<21)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL21() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x200000) >> 21
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL22(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x400000)|value<<22)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL22() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x400000) >> 22
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL23(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x800000)|value<<23)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL23() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x800000) >> 23
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL24(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x1000000)|value<<24)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL24() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x1000000) >> 24
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL25(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x2000000)|value<<25)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL25() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x2000000) >> 25
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL26(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x4000000)|value<<26)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL26() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x4000000) >> 26
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL27(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x8000000)|value<<27)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL27() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x8000000) >> 27
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL28(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x10000000)|value<<28)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL28() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x10000000) >> 28
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL29(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x20000000)|value<<29)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL29() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x20000000) >> 29
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL30(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x40000000)|value<<30)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL30() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x40000000) >> 30
}
func (o *EVSYS_Type) SetSWEVT_CHANNEL31(value uint32) {
	volatile.StoreUint32(&o.SWEVT.Reg, volatile.LoadUint32(&o.SWEVT.Reg)&^(0x80000000)|value<<31)
}
func (o *EVSYS_Type) GetSWEVT_CHANNEL31() uint32 {
	return (volatile.LoadUint32(&o.SWEVT.Reg) & 0x80000000) >> 31
}

// EVSYS.PRICTRL: Priority Control
func (o *EVSYS_Type) SetPRICTRL_PRI(value uint8) {
	volatile.StoreUint8(&o.PRICTRL.Reg, volatile.LoadUint8(&o.PRICTRL.Reg)&^(0xf)|value)
}
func (o *EVSYS_Type) GetPRICTRL_PRI() uint8 {
	return volatile.LoadUint8(&o.PRICTRL.Reg) & 0xf
}
func (o *EVSYS_Type) SetPRICTRL_RREN(value uint8) {
	volatile.StoreUint8(&o.PRICTRL.Reg, volatile.LoadUint8(&o.PRICTRL.Reg)&^(0x80)|value<<7)
}
func (o *EVSYS_Type) GetPRICTRL_RREN() uint8 {
	return (volatile.LoadUint8(&o.PRICTRL.Reg) & 0x80) >> 7
}

// EVSYS.INTPEND: Channel Pending Interrupt
func (o *EVSYS_Type) SetINTPEND_ID(value uint16) {
	volatile.StoreUint16(&o.INTPEND.Reg, volatile.LoadUint16(&o.INTPEND.Reg)&^(0xf)|value)
}
func (o *EVSYS_Type) GetINTPEND_ID() uint16 {
	return volatile.LoadUint16(&o.INTPEND.Reg) & 0xf
}
func (o *EVSYS_Type) SetINTPEND_OVR(value uint16) {
	volatile.StoreUint16(&o.INTPEND.Reg, volatile.LoadUint16(&o.INTPEND.Reg)&^(0x100)|value<<8)
}
func (o *EVSYS_Type) GetINTPEND_OVR() uint16 {
	return (volatile.LoadUint16(&o.INTPEND.Reg) & 0x100) >> 8
}
func (o *EVSYS_Type) SetINTPEND_EVD(value uint16) {
	volatile.StoreUint16(&o.INTPEND.Reg, volatile.LoadUint16(&o.INTPEND.Reg)&^(0x200)|value<<9)
}
func (o *EVSYS_Type) GetINTPEND_EVD() uint16 {
	return (volatile.LoadUint16(&o.INTPEND.Reg) & 0x200) >> 9
}
func (o *EVSYS_Type) SetINTPEND_READY(value uint16) {
	volatile.StoreUint16(&o.INTPEND.Reg, volatile.LoadUint16(&o.INTPEND.Reg)&^(0x4000)|value<<14)
}
func (o *EVSYS_Type) GetINTPEND_READY() uint16 {
	return (volatile.LoadUint16(&o.INTPEND.Reg) & 0x4000) >> 14
}
func (o *EVSYS_Type) SetINTPEND_BUSY(value uint16) {
	volatile.StoreUint16(&o.INTPEND.Reg, volatile.LoadUint16(&o.INTPEND.Reg)&^(0x8000)|value<<15)
}
func (o *EVSYS_Type) GetINTPEND_BUSY() uint16 {
	return (volatile.LoadUint16(&o.INTPEND.Reg) & 0x8000) >> 15
}

// EVSYS.INTSTATUS: Interrupt Status
func (o *EVSYS_Type) SetINTSTATUS_CHINT0(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x1)|value)
}
func (o *EVSYS_Type) GetINTSTATUS_CHINT0() uint32 {
	return volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x1
}
func (o *EVSYS_Type) SetINTSTATUS_CHINT1(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *EVSYS_Type) GetINTSTATUS_CHINT1() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x2) >> 1
}
func (o *EVSYS_Type) SetINTSTATUS_CHINT2(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x4)|value<<2)
}
func (o *EVSYS_Type) GetINTSTATUS_CHINT2() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x4) >> 2
}
func (o *EVSYS_Type) SetINTSTATUS_CHINT3(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x8)|value<<3)
}
func (o *EVSYS_Type) GetINTSTATUS_CHINT3() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x8) >> 3
}
func (o *EVSYS_Type) SetINTSTATUS_CHINT4(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x10)|value<<4)
}
func (o *EVSYS_Type) GetINTSTATUS_CHINT4() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x10) >> 4
}
func (o *EVSYS_Type) SetINTSTATUS_CHINT5(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x20)|value<<5)
}
func (o *EVSYS_Type) GetINTSTATUS_CHINT5() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x20) >> 5
}
func (o *EVSYS_Type) SetINTSTATUS_CHINT6(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x40)|value<<6)
}
func (o *EVSYS_Type) GetINTSTATUS_CHINT6() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x40) >> 6
}
func (o *EVSYS_Type) SetINTSTATUS_CHINT7(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x80)|value<<7)
}
func (o *EVSYS_Type) GetINTSTATUS_CHINT7() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x80) >> 7
}
func (o *EVSYS_Type) SetINTSTATUS_CHINT8(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x100)|value<<8)
}
func (o *EVSYS_Type) GetINTSTATUS_CHINT8() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x100) >> 8
}
func (o *EVSYS_Type) SetINTSTATUS_CHINT9(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x200)|value<<9)
}
func (o *EVSYS_Type) GetINTSTATUS_CHINT9() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x200) >> 9
}
func (o *EVSYS_Type) SetINTSTATUS_CHINT10(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x400)|value<<10)
}
func (o *EVSYS_Type) GetINTSTATUS_CHINT10() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x400) >> 10
}
func (o *EVSYS_Type) SetINTSTATUS_CHINT11(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x800)|value<<11)
}
func (o *EVSYS_Type) GetINTSTATUS_CHINT11() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x800) >> 11
}

// EVSYS.BUSYCH: Busy Channels
func (o *EVSYS_Type) SetBUSYCH_BUSYCH0(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x1)|value)
}
func (o *EVSYS_Type) GetBUSYCH_BUSYCH0() uint32 {
	return volatile.LoadUint32(&o.BUSYCH.Reg) & 0x1
}
func (o *EVSYS_Type) SetBUSYCH_BUSYCH1(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x2)|value<<1)
}
func (o *EVSYS_Type) GetBUSYCH_BUSYCH1() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x2) >> 1
}
func (o *EVSYS_Type) SetBUSYCH_BUSYCH2(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x4)|value<<2)
}
func (o *EVSYS_Type) GetBUSYCH_BUSYCH2() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x4) >> 2
}
func (o *EVSYS_Type) SetBUSYCH_BUSYCH3(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x8)|value<<3)
}
func (o *EVSYS_Type) GetBUSYCH_BUSYCH3() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x8) >> 3
}
func (o *EVSYS_Type) SetBUSYCH_BUSYCH4(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x10)|value<<4)
}
func (o *EVSYS_Type) GetBUSYCH_BUSYCH4() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x10) >> 4
}
func (o *EVSYS_Type) SetBUSYCH_BUSYCH5(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x20)|value<<5)
}
func (o *EVSYS_Type) GetBUSYCH_BUSYCH5() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x20) >> 5
}
func (o *EVSYS_Type) SetBUSYCH_BUSYCH6(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x40)|value<<6)
}
func (o *EVSYS_Type) GetBUSYCH_BUSYCH6() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x40) >> 6
}
func (o *EVSYS_Type) SetBUSYCH_BUSYCH7(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x80)|value<<7)
}
func (o *EVSYS_Type) GetBUSYCH_BUSYCH7() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x80) >> 7
}
func (o *EVSYS_Type) SetBUSYCH_BUSYCH8(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x100)|value<<8)
}
func (o *EVSYS_Type) GetBUSYCH_BUSYCH8() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x100) >> 8
}
func (o *EVSYS_Type) SetBUSYCH_BUSYCH9(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x200)|value<<9)
}
func (o *EVSYS_Type) GetBUSYCH_BUSYCH9() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x200) >> 9
}
func (o *EVSYS_Type) SetBUSYCH_BUSYCH10(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x400)|value<<10)
}
func (o *EVSYS_Type) GetBUSYCH_BUSYCH10() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x400) >> 10
}
func (o *EVSYS_Type) SetBUSYCH_BUSYCH11(value uint32) {
	volatile.StoreUint32(&o.BUSYCH.Reg, volatile.LoadUint32(&o.BUSYCH.Reg)&^(0x800)|value<<11)
}
func (o *EVSYS_Type) GetBUSYCH_BUSYCH11() uint32 {
	return (volatile.LoadUint32(&o.BUSYCH.Reg) & 0x800) >> 11
}

// EVSYS.READYUSR: Ready Users
func (o *EVSYS_Type) SetREADYUSR_READYUSR0(value uint32) {
	volatile.StoreUint32(&o.READYUSR.Reg, volatile.LoadUint32(&o.READYUSR.Reg)&^(0x1)|value)
}
func (o *EVSYS_Type) GetREADYUSR_READYUSR0() uint32 {
	return volatile.LoadUint32(&o.READYUSR.Reg) & 0x1
}
func (o *EVSYS_Type) SetREADYUSR_READYUSR1(value uint32) {
	volatile.StoreUint32(&o.READYUSR.Reg, volatile.LoadUint32(&o.READYUSR.Reg)&^(0x2)|value<<1)
}
func (o *EVSYS_Type) GetREADYUSR_READYUSR1() uint32 {
	return (volatile.LoadUint32(&o.READYUSR.Reg) & 0x2) >> 1
}
func (o *EVSYS_Type) SetREADYUSR_READYUSR2(value uint32) {
	volatile.StoreUint32(&o.READYUSR.Reg, volatile.LoadUint32(&o.READYUSR.Reg)&^(0x4)|value<<2)
}
func (o *EVSYS_Type) GetREADYUSR_READYUSR2() uint32 {
	return (volatile.LoadUint32(&o.READYUSR.Reg) & 0x4) >> 2
}
func (o *EVSYS_Type) SetREADYUSR_READYUSR3(value uint32) {
	volatile.StoreUint32(&o.READYUSR.Reg, volatile.LoadUint32(&o.READYUSR.Reg)&^(0x8)|value<<3)
}
func (o *EVSYS_Type) GetREADYUSR_READYUSR3() uint32 {
	return (volatile.LoadUint32(&o.READYUSR.Reg) & 0x8) >> 3
}
func (o *EVSYS_Type) SetREADYUSR_READYUSR4(value uint32) {
	volatile.StoreUint32(&o.READYUSR.Reg, volatile.LoadUint32(&o.READYUSR.Reg)&^(0x10)|value<<4)
}
func (o *EVSYS_Type) GetREADYUSR_READYUSR4() uint32 {
	return (volatile.LoadUint32(&o.READYUSR.Reg) & 0x10) >> 4
}
func (o *EVSYS_Type) SetREADYUSR_READYUSR5(value uint32) {
	volatile.StoreUint32(&o.READYUSR.Reg, volatile.LoadUint32(&o.READYUSR.Reg)&^(0x20)|value<<5)
}
func (o *EVSYS_Type) GetREADYUSR_READYUSR5() uint32 {
	return (volatile.LoadUint32(&o.READYUSR.Reg) & 0x20) >> 5
}
func (o *EVSYS_Type) SetREADYUSR_READYUSR6(value uint32) {
	volatile.StoreUint32(&o.READYUSR.Reg, volatile.LoadUint32(&o.READYUSR.Reg)&^(0x40)|value<<6)
}
func (o *EVSYS_Type) GetREADYUSR_READYUSR6() uint32 {
	return (volatile.LoadUint32(&o.READYUSR.Reg) & 0x40) >> 6
}
func (o *EVSYS_Type) SetREADYUSR_READYUSR7(value uint32) {
	volatile.StoreUint32(&o.READYUSR.Reg, volatile.LoadUint32(&o.READYUSR.Reg)&^(0x80)|value<<7)
}
func (o *EVSYS_Type) GetREADYUSR_READYUSR7() uint32 {
	return (volatile.LoadUint32(&o.READYUSR.Reg) & 0x80) >> 7
}
func (o *EVSYS_Type) SetREADYUSR_READYUSR8(value uint32) {
	volatile.StoreUint32(&o.READYUSR.Reg, volatile.LoadUint32(&o.READYUSR.Reg)&^(0x100)|value<<8)
}
func (o *EVSYS_Type) GetREADYUSR_READYUSR8() uint32 {
	return (volatile.LoadUint32(&o.READYUSR.Reg) & 0x100) >> 8
}
func (o *EVSYS_Type) SetREADYUSR_READYUSR9(value uint32) {
	volatile.StoreUint32(&o.READYUSR.Reg, volatile.LoadUint32(&o.READYUSR.Reg)&^(0x200)|value<<9)
}
func (o *EVSYS_Type) GetREADYUSR_READYUSR9() uint32 {
	return (volatile.LoadUint32(&o.READYUSR.Reg) & 0x200) >> 9
}
func (o *EVSYS_Type) SetREADYUSR_READYUSR10(value uint32) {
	volatile.StoreUint32(&o.READYUSR.Reg, volatile.LoadUint32(&o.READYUSR.Reg)&^(0x400)|value<<10)
}
func (o *EVSYS_Type) GetREADYUSR_READYUSR10() uint32 {
	return (volatile.LoadUint32(&o.READYUSR.Reg) & 0x400) >> 10
}
func (o *EVSYS_Type) SetREADYUSR_READYUSR11(value uint32) {
	volatile.StoreUint32(&o.READYUSR.Reg, volatile.LoadUint32(&o.READYUSR.Reg)&^(0x800)|value<<11)
}
func (o *EVSYS_Type) GetREADYUSR_READYUSR11() uint32 {
	return (volatile.LoadUint32(&o.READYUSR.Reg) & 0x800) >> 11
}

// EVSYS.USER: User Multiplexer n
func (o *EVSYS_Type) SetUSER_CHANNEL(idx int, value uint32) {
	volatile.StoreUint32(&o.USER[idx].Reg, volatile.LoadUint32(&o.USER[idx].Reg)&^(0x3f)|value)
}
func (o *EVSYS_Type) GetUSER_CHANNEL(idx int) uint32 {
	return volatile.LoadUint32(&o.USER[idx].Reg) & 0x3f
}

type EVSYS_CHANNEL_Type struct {
	CHANNEL    volatile.Register32 // 0x20
	CHINTENCLR volatile.Register8  // 0x24
	CHINTENSET volatile.Register8  // 0x25
	CHINTFLAG  volatile.Register8  // 0x26
	CHSTATUS   volatile.Register8  // 0x27
}

// EVSYS_CHANNEL.CHANNEL: Channel n Control
func (o *EVSYS_CHANNEL_Type) SetCHANNEL_EVGEN(value uint32) {
	volatile.StoreUint32(&o.CHANNEL.Reg, volatile.LoadUint32(&o.CHANNEL.Reg)&^(0x7f)|value)
}
func (o *EVSYS_CHANNEL_Type) GetCHANNEL_EVGEN() uint32 {
	return volatile.LoadUint32(&o.CHANNEL.Reg) & 0x7f
}
func (o *EVSYS_CHANNEL_Type) SetCHANNEL_PATH(value uint32) {
	volatile.StoreUint32(&o.CHANNEL.Reg, volatile.LoadUint32(&o.CHANNEL.Reg)&^(0x300)|value<<8)
}
func (o *EVSYS_CHANNEL_Type) GetCHANNEL_PATH() uint32 {
	return (volatile.LoadUint32(&o.CHANNEL.Reg) & 0x300) >> 8
}
func (o *EVSYS_CHANNEL_Type) SetCHANNEL_EDGSEL(value uint32) {
	volatile.StoreUint32(&o.CHANNEL.Reg, volatile.LoadUint32(&o.CHANNEL.Reg)&^(0xc00)|value<<10)
}
func (o *EVSYS_CHANNEL_Type) GetCHANNEL_EDGSEL() uint32 {
	return (volatile.LoadUint32(&o.CHANNEL.Reg) & 0xc00) >> 10
}
func (o *EVSYS_CHANNEL_Type) SetCHANNEL_RUNSTDBY(value uint32) {
	volatile.StoreUint32(&o.CHANNEL.Reg, volatile.LoadUint32(&o.CHANNEL.Reg)&^(0x4000)|value<<14)
}
func (o *EVSYS_CHANNEL_Type) GetCHANNEL_RUNSTDBY() uint32 {
	return (volatile.LoadUint32(&o.CHANNEL.Reg) & 0x4000) >> 14
}
func (o *EVSYS_CHANNEL_Type) SetCHANNEL_ONDEMAND(value uint32) {
	volatile.StoreUint32(&o.CHANNEL.Reg, volatile.LoadUint32(&o.CHANNEL.Reg)&^(0x8000)|value<<15)
}
func (o *EVSYS_CHANNEL_Type) GetCHANNEL_ONDEMAND() uint32 {
	return (volatile.LoadUint32(&o.CHANNEL.Reg) & 0x8000) >> 15
}

// EVSYS_CHANNEL.CHINTENCLR: Channel n Interrupt Enable Clear
func (o *EVSYS_CHANNEL_Type) SetCHINTENCLR_OVR(value uint8) {
	volatile.StoreUint8(&o.CHINTENCLR.Reg, volatile.LoadUint8(&o.CHINTENCLR.Reg)&^(0x1)|value)
}
func (o *EVSYS_CHANNEL_Type) GetCHINTENCLR_OVR() uint8 {
	return volatile.LoadUint8(&o.CHINTENCLR.Reg) & 0x1
}
func (o *EVSYS_CHANNEL_Type) SetCHINTENCLR_EVD(value uint8) {
	volatile.StoreUint8(&o.CHINTENCLR.Reg, volatile.LoadUint8(&o.CHINTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *EVSYS_CHANNEL_Type) GetCHINTENCLR_EVD() uint8 {
	return (volatile.LoadUint8(&o.CHINTENCLR.Reg) & 0x2) >> 1
}

// EVSYS_CHANNEL.CHINTENSET: Channel n Interrupt Enable Set
func (o *EVSYS_CHANNEL_Type) SetCHINTENSET_OVR(value uint8) {
	volatile.StoreUint8(&o.CHINTENSET.Reg, volatile.LoadUint8(&o.CHINTENSET.Reg)&^(0x1)|value)
}
func (o *EVSYS_CHANNEL_Type) GetCHINTENSET_OVR() uint8 {
	return volatile.LoadUint8(&o.CHINTENSET.Reg) & 0x1
}
func (o *EVSYS_CHANNEL_Type) SetCHINTENSET_EVD(value uint8) {
	volatile.StoreUint8(&o.CHINTENSET.Reg, volatile.LoadUint8(&o.CHINTENSET.Reg)&^(0x2)|value<<1)
}
func (o *EVSYS_CHANNEL_Type) GetCHINTENSET_EVD() uint8 {
	return (volatile.LoadUint8(&o.CHINTENSET.Reg) & 0x2) >> 1
}

// EVSYS_CHANNEL.CHINTFLAG: Channel n Interrupt Flag Status and Clear
func (o *EVSYS_CHANNEL_Type) SetCHINTFLAG_OVR(value uint8) {
	volatile.StoreUint8(&o.CHINTFLAG.Reg, volatile.LoadUint8(&o.CHINTFLAG.Reg)&^(0x1)|value)
}
func (o *EVSYS_CHANNEL_Type) GetCHINTFLAG_OVR() uint8 {
	return volatile.LoadUint8(&o.CHINTFLAG.Reg) & 0x1
}
func (o *EVSYS_CHANNEL_Type) SetCHINTFLAG_EVD(value uint8) {
	volatile.StoreUint8(&o.CHINTFLAG.Reg, volatile.LoadUint8(&o.CHINTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *EVSYS_CHANNEL_Type) GetCHINTFLAG_EVD() uint8 {
	return (volatile.LoadUint8(&o.CHINTFLAG.Reg) & 0x2) >> 1
}

// EVSYS_CHANNEL.CHSTATUS: Channel n Status
func (o *EVSYS_CHANNEL_Type) SetCHSTATUS_RDYUSR(value uint8) {
	volatile.StoreUint8(&o.CHSTATUS.Reg, volatile.LoadUint8(&o.CHSTATUS.Reg)&^(0x1)|value)
}
func (o *EVSYS_CHANNEL_Type) GetCHSTATUS_RDYUSR() uint8 {
	return volatile.LoadUint8(&o.CHSTATUS.Reg) & 0x1
}
func (o *EVSYS_CHANNEL_Type) SetCHSTATUS_BUSYCH(value uint8) {
	volatile.StoreUint8(&o.CHSTATUS.Reg, volatile.LoadUint8(&o.CHSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *EVSYS_CHANNEL_Type) GetCHSTATUS_BUSYCH() uint8 {
	return (volatile.LoadUint8(&o.CHSTATUS.Reg) & 0x2) >> 1
}

// Frequency Meter
type FREQM_Type struct {
	CTRLA    volatile.Register8  // 0x0
	CTRLB    volatile.Register8  // 0x1
	CFGA     volatile.Register16 // 0x2
	_        [4]byte
	INTENCLR volatile.Register8  // 0x8
	INTENSET volatile.Register8  // 0x9
	INTFLAG  volatile.Register8  // 0xA
	STATUS   volatile.Register8  // 0xB
	SYNCBUSY volatile.Register32 // 0xC
	VALUE    volatile.Register32 // 0x10
}

// FREQM.CTRLA: Control A Register
func (o *FREQM_Type) SetCTRLA_SWRST(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *FREQM_Type) GetCTRLA_SWRST() uint8 {
	return volatile.LoadUint8(&o.CTRLA.Reg) & 0x1
}
func (o *FREQM_Type) SetCTRLA_ENABLE(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *FREQM_Type) GetCTRLA_ENABLE() uint8 {
	return (volatile.LoadUint8(&o.CTRLA.Reg) & 0x2) >> 1
}

// FREQM.CTRLB: Control B Register
func (o *FREQM_Type) SetCTRLB_START(value uint8) {
	volatile.StoreUint8(&o.CTRLB.Reg, volatile.LoadUint8(&o.CTRLB.Reg)&^(0x1)|value)
}
func (o *FREQM_Type) GetCTRLB_START() uint8 {
	return volatile.LoadUint8(&o.CTRLB.Reg) & 0x1
}

// FREQM.CFGA: Config A register
func (o *FREQM_Type) SetCFGA_REFNUM(value uint16) {
	volatile.StoreUint16(&o.CFGA.Reg, volatile.LoadUint16(&o.CFGA.Reg)&^(0xff)|value)
}
func (o *FREQM_Type) GetCFGA_REFNUM() uint16 {
	return volatile.LoadUint16(&o.CFGA.Reg) & 0xff
}

// FREQM.INTENCLR: Interrupt Enable Clear Register
func (o *FREQM_Type) SetINTENCLR_DONE(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *FREQM_Type) GetINTENCLR_DONE() uint8 {
	return volatile.LoadUint8(&o.INTENCLR.Reg) & 0x1
}

// FREQM.INTENSET: Interrupt Enable Set Register
func (o *FREQM_Type) SetINTENSET_DONE(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *FREQM_Type) GetINTENSET_DONE() uint8 {
	return volatile.LoadUint8(&o.INTENSET.Reg) & 0x1
}

// FREQM.INTFLAG: Interrupt Flag Register
func (o *FREQM_Type) SetINTFLAG_DONE(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *FREQM_Type) GetINTFLAG_DONE() uint8 {
	return volatile.LoadUint8(&o.INTFLAG.Reg) & 0x1
}

// FREQM.STATUS: Status Register
func (o *FREQM_Type) SetSTATUS_BUSY(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *FREQM_Type) GetSTATUS_BUSY() uint8 {
	return volatile.LoadUint8(&o.STATUS.Reg) & 0x1
}
func (o *FREQM_Type) SetSTATUS_OVF(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *FREQM_Type) GetSTATUS_OVF() uint8 {
	return (volatile.LoadUint8(&o.STATUS.Reg) & 0x2) >> 1
}

// FREQM.SYNCBUSY: Synchronization Busy Register
func (o *FREQM_Type) SetSYNCBUSY_SWRST(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *FREQM_Type) GetSYNCBUSY_SWRST() uint32 {
	return volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x1
}
func (o *FREQM_Type) SetSYNCBUSY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *FREQM_Type) GetSYNCBUSY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x2) >> 1
}

// FREQM.VALUE: Count Value Register
func (o *FREQM_Type) SetVALUE(value uint32) {
	volatile.StoreUint32(&o.VALUE.Reg, volatile.LoadUint32(&o.VALUE.Reg)&^(0xffffff)|value)
}
func (o *FREQM_Type) GetVALUE() uint32 {
	return volatile.LoadUint32(&o.VALUE.Reg) & 0xffffff
}

// Generic Clock Generator
type GCLK_Type struct {
	CTRLA    volatile.Register8 // 0x0
	_        [3]byte
	SYNCBUSY volatile.Register32 // 0x4
	_        [24]byte
	GENCTRL  [12]volatile.Register32 // 0x20
	_        [48]byte
	PCHCTRL  [48]volatile.Register32 // 0x80
}

// GCLK.CTRLA: Control
func (o *GCLK_Type) SetCTRLA_SWRST(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *GCLK_Type) GetCTRLA_SWRST() uint8 {
	return volatile.LoadUint8(&o.CTRLA.Reg) & 0x1
}

// GCLK.SYNCBUSY: Synchronization Busy
func (o *GCLK_Type) SetSYNCBUSY_SWRST(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *GCLK_Type) GetSYNCBUSY_SWRST() uint32 {
	return volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x1
}
func (o *GCLK_Type) SetSYNCBUSY_GENCTRL(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x3ffc)|value<<2)
}
func (o *GCLK_Type) GetSYNCBUSY_GENCTRL() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x3ffc) >> 2
}

// GCLK.GENCTRL: Generic Clock Generator Control
func (o *GCLK_Type) SetGENCTRL_SRC(idx int, value uint32) {
	volatile.StoreUint32(&o.GENCTRL[idx].Reg, volatile.LoadUint32(&o.GENCTRL[idx].Reg)&^(0xf)|value)
}
func (o *GCLK_Type) GetGENCTRL_SRC(idx int) uint32 {
	return volatile.LoadUint32(&o.GENCTRL[idx].Reg) & 0xf
}
func (o *GCLK_Type) SetGENCTRL_GENEN(idx int, value uint32) {
	volatile.StoreUint32(&o.GENCTRL[idx].Reg, volatile.LoadUint32(&o.GENCTRL[idx].Reg)&^(0x100)|value<<8)
}
func (o *GCLK_Type) GetGENCTRL_GENEN(idx int) uint32 {
	return (volatile.LoadUint32(&o.GENCTRL[idx].Reg) & 0x100) >> 8
}
func (o *GCLK_Type) SetGENCTRL_IDC(idx int, value uint32) {
	volatile.StoreUint32(&o.GENCTRL[idx].Reg, volatile.LoadUint32(&o.GENCTRL[idx].Reg)&^(0x200)|value<<9)
}
func (o *GCLK_Type) GetGENCTRL_IDC(idx int) uint32 {
	return (volatile.LoadUint32(&o.GENCTRL[idx].Reg) & 0x200) >> 9
}
func (o *GCLK_Type) SetGENCTRL_OOV(idx int, value uint32) {
	volatile.StoreUint32(&o.GENCTRL[idx].Reg, volatile.LoadUint32(&o.GENCTRL[idx].Reg)&^(0x400)|value<<10)
}
func (o *GCLK_Type) GetGENCTRL_OOV(idx int) uint32 {
	return (volatile.LoadUint32(&o.GENCTRL[idx].Reg) & 0x400) >> 10
}
func (o *GCLK_Type) SetGENCTRL_OE(idx int, value uint32) {
	volatile.StoreUint32(&o.GENCTRL[idx].Reg, volatile.LoadUint32(&o.GENCTRL[idx].Reg)&^(0x800)|value<<11)
}
func (o *GCLK_Type) GetGENCTRL_OE(idx int) uint32 {
	return (volatile.LoadUint32(&o.GENCTRL[idx].Reg) & 0x800) >> 11
}
func (o *GCLK_Type) SetGENCTRL_DIVSEL(idx int, value uint32) {
	volatile.StoreUint32(&o.GENCTRL[idx].Reg, volatile.LoadUint32(&o.GENCTRL[idx].Reg)&^(0x1000)|value<<12)
}
func (o *GCLK_Type) GetGENCTRL_DIVSEL(idx int) uint32 {
	return (volatile.LoadUint32(&o.GENCTRL[idx].Reg) & 0x1000) >> 12
}
func (o *GCLK_Type) SetGENCTRL_RUNSTDBY(idx int, value uint32) {
	volatile.StoreUint32(&o.GENCTRL[idx].Reg, volatile.LoadUint32(&o.GENCTRL[idx].Reg)&^(0x2000)|value<<13)
}
func (o *GCLK_Type) GetGENCTRL_RUNSTDBY(idx int) uint32 {
	return (volatile.LoadUint32(&o.GENCTRL[idx].Reg) & 0x2000) >> 13
}
func (o *GCLK_Type) SetGENCTRL_DIV(idx int, value uint32) {
	volatile.StoreUint32(&o.GENCTRL[idx].Reg, volatile.LoadUint32(&o.GENCTRL[idx].Reg)&^(0xffff0000)|value<<16)
}
func (o *GCLK_Type) GetGENCTRL_DIV(idx int) uint32 {
	return (volatile.LoadUint32(&o.GENCTRL[idx].Reg) & 0xffff0000) >> 16
}

// GCLK.PCHCTRL: Peripheral Clock Control
func (o *GCLK_Type) SetPCHCTRL_GEN(idx int, value uint32) {
	volatile.StoreUint32(&o.PCHCTRL[idx].Reg, volatile.LoadUint32(&o.PCHCTRL[idx].Reg)&^(0xf)|value)
}
func (o *GCLK_Type) GetPCHCTRL_GEN(idx int) uint32 {
	return volatile.LoadUint32(&o.PCHCTRL[idx].Reg) & 0xf
}
func (o *GCLK_Type) SetPCHCTRL_CHEN(idx int, value uint32) {
	volatile.StoreUint32(&o.PCHCTRL[idx].Reg, volatile.LoadUint32(&o.PCHCTRL[idx].Reg)&^(0x40)|value<<6)
}
func (o *GCLK_Type) GetPCHCTRL_CHEN(idx int) uint32 {
	return (volatile.LoadUint32(&o.PCHCTRL[idx].Reg) & 0x40) >> 6
}
func (o *GCLK_Type) SetPCHCTRL_WRTLOCK(idx int, value uint32) {
	volatile.StoreUint32(&o.PCHCTRL[idx].Reg, volatile.LoadUint32(&o.PCHCTRL[idx].Reg)&^(0x80)|value<<7)
}
func (o *GCLK_Type) GetPCHCTRL_WRTLOCK(idx int) uint32 {
	return (volatile.LoadUint32(&o.PCHCTRL[idx].Reg) & 0x80) >> 7
}

// Ethernet MAC
type GMAC_Type struct {
	NCR       volatile.Register32 // 0x0
	NCFGR     volatile.Register32 // 0x4
	NSR       volatile.Register32 // 0x8
	UR        volatile.Register32 // 0xC
	DCFGR     volatile.Register32 // 0x10
	TSR       volatile.Register32 // 0x14
	RBQB      volatile.Register32 // 0x18
	TBQB      volatile.Register32 // 0x1C
	RSR       volatile.Register32 // 0x20
	ISR       volatile.Register32 // 0x24
	IER       volatile.Register32 // 0x28
	IDR       volatile.Register32 // 0x2C
	IMR       volatile.Register32 // 0x30
	MAN       volatile.Register32 // 0x34
	RPQ       volatile.Register32 // 0x38
	TPQ       volatile.Register32 // 0x3C
	TPSF      volatile.Register32 // 0x40
	RPSF      volatile.Register32 // 0x44
	RJFML     volatile.Register32 // 0x48
	_         [52]byte
	HRB       volatile.Register32    // 0x80
	HRT       volatile.Register32    // 0x84
	SA        [4]GMAC_SA_Type        // 0x88
	TIDM      [4]volatile.Register32 // 0xA8
	WOL       volatile.Register32    // 0xB8
	IPGS      volatile.Register32    // 0xBC
	SVLAN     volatile.Register32    // 0xC0
	TPFCP     volatile.Register32    // 0xC4
	SAMB1     volatile.Register32    // 0xC8
	SAMT1     volatile.Register32    // 0xCC
	_         [12]byte
	NSC       volatile.Register32 // 0xDC
	SCL       volatile.Register32 // 0xE0
	SCH       volatile.Register32 // 0xE4
	EFTSH     volatile.Register32 // 0xE8
	EFRSH     volatile.Register32 // 0xEC
	PEFTSH    volatile.Register32 // 0xF0
	PEFRSH    volatile.Register32 // 0xF4
	_         [8]byte
	OTLO      volatile.Register32 // 0x100
	OTHI      volatile.Register32 // 0x104
	FT        volatile.Register32 // 0x108
	BCFT      volatile.Register32 // 0x10C
	MFT       volatile.Register32 // 0x110
	PFT       volatile.Register32 // 0x114
	BFT64     volatile.Register32 // 0x118
	TBFT127   volatile.Register32 // 0x11C
	TBFT255   volatile.Register32 // 0x120
	TBFT511   volatile.Register32 // 0x124
	TBFT1023  volatile.Register32 // 0x128
	TBFT1518  volatile.Register32 // 0x12C
	GTBFT1518 volatile.Register32 // 0x130
	TUR       volatile.Register32 // 0x134
	SCF       volatile.Register32 // 0x138
	MCF       volatile.Register32 // 0x13C
	EC        volatile.Register32 // 0x140
	LC        volatile.Register32 // 0x144
	DTF       volatile.Register32 // 0x148
	CSE       volatile.Register32 // 0x14C
	ORLO      volatile.Register32 // 0x150
	ORHI      volatile.Register32 // 0x154
	FR        volatile.Register32 // 0x158
	BCFR      volatile.Register32 // 0x15C
	MFR       volatile.Register32 // 0x160
	PFR       volatile.Register32 // 0x164
	BFR64     volatile.Register32 // 0x168
	TBFR127   volatile.Register32 // 0x16C
	TBFR255   volatile.Register32 // 0x170
	TBFR511   volatile.Register32 // 0x174
	TBFR1023  volatile.Register32 // 0x178
	TBFR1518  volatile.Register32 // 0x17C
	TMXBFR    volatile.Register32 // 0x180
	UFR       volatile.Register32 // 0x184
	OFR       volatile.Register32 // 0x188
	JR        volatile.Register32 // 0x18C
	FCSE      volatile.Register32 // 0x190
	LFFE      volatile.Register32 // 0x194
	RSE       volatile.Register32 // 0x198
	AE        volatile.Register32 // 0x19C
	RRE       volatile.Register32 // 0x1A0
	ROE       volatile.Register32 // 0x1A4
	IHCE      volatile.Register32 // 0x1A8
	TCE       volatile.Register32 // 0x1AC
	UCE       volatile.Register32 // 0x1B0
	_         [8]byte
	TISUBN    volatile.Register32 // 0x1BC
	TSH       volatile.Register32 // 0x1C0
	_         [4]byte
	TSSSL     volatile.Register32 // 0x1C8
	TSSN      volatile.Register32 // 0x1CC
	TSL       volatile.Register32 // 0x1D0
	TN        volatile.Register32 // 0x1D4
	TA        volatile.Register32 // 0x1D8
	TI        volatile.Register32 // 0x1DC
	EFTSL     volatile.Register32 // 0x1E0
	EFTN      volatile.Register32 // 0x1E4
	EFRSL     volatile.Register32 // 0x1E8
	EFRN      volatile.Register32 // 0x1EC
	PEFTSL    volatile.Register32 // 0x1F0
	PEFTN     volatile.Register32 // 0x1F4
	PEFRSL    volatile.Register32 // 0x1F8
	PEFRN     volatile.Register32 // 0x1FC
	_         [112]byte
	RLPITR    volatile.Register32 // 0x270
	RLPITI    volatile.Register32 // 0x274
	TLPITR    volatile.Register32 // 0x278
	TLPITI    volatile.Register32 // 0x27C
}

// GMAC.NCR: Network Control Register
func (o *GMAC_Type) SetNCR_LBL(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetNCR_LBL() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetNCR_RXEN(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetNCR_RXEN() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetNCR_TXEN(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetNCR_TXEN() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x8) >> 3
}
func (o *GMAC_Type) SetNCR_MPE(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x10)|value<<4)
}
func (o *GMAC_Type) GetNCR_MPE() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x10) >> 4
}
func (o *GMAC_Type) SetNCR_CLRSTAT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetNCR_CLRSTAT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetNCR_INCSTAT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetNCR_INCSTAT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetNCR_WESTAT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetNCR_WESTAT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetNCR_BP(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x100)|value<<8)
}
func (o *GMAC_Type) GetNCR_BP() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x100) >> 8
}
func (o *GMAC_Type) SetNCR_TSTART(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x200)|value<<9)
}
func (o *GMAC_Type) GetNCR_TSTART() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x200) >> 9
}
func (o *GMAC_Type) SetNCR_THALT(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetNCR_THALT() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetNCR_TXPF(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetNCR_TXPF() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x800) >> 11
}
func (o *GMAC_Type) SetNCR_TXZQPF(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x1000)|value<<12)
}
func (o *GMAC_Type) GetNCR_TXZQPF() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x1000) >> 12
}
func (o *GMAC_Type) SetNCR_SRTSM(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x8000)|value<<15)
}
func (o *GMAC_Type) GetNCR_SRTSM() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x8000) >> 15
}
func (o *GMAC_Type) SetNCR_ENPBPR(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x10000)|value<<16)
}
func (o *GMAC_Type) GetNCR_ENPBPR() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x10000) >> 16
}
func (o *GMAC_Type) SetNCR_TXPBPF(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x20000)|value<<17)
}
func (o *GMAC_Type) GetNCR_TXPBPF() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x20000) >> 17
}
func (o *GMAC_Type) SetNCR_FNP(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x40000)|value<<18)
}
func (o *GMAC_Type) GetNCR_FNP() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x40000) >> 18
}
func (o *GMAC_Type) SetNCR_LPI(value uint32) {
	volatile.StoreUint32(&o.NCR.Reg, volatile.LoadUint32(&o.NCR.Reg)&^(0x80000)|value<<19)
}
func (o *GMAC_Type) GetNCR_LPI() uint32 {
	return (volatile.LoadUint32(&o.NCR.Reg) & 0x80000) >> 19
}

// GMAC.NCFGR: Network Configuration Register
func (o *GMAC_Type) SetNCFGR_SPD(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetNCFGR_SPD() uint32 {
	return volatile.LoadUint32(&o.NCFGR.Reg) & 0x1
}
func (o *GMAC_Type) SetNCFGR_FD(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetNCFGR_FD() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetNCFGR_DNVLAN(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetNCFGR_DNVLAN() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetNCFGR_JFRAME(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetNCFGR_JFRAME() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x8) >> 3
}
func (o *GMAC_Type) SetNCFGR_CAF(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x10)|value<<4)
}
func (o *GMAC_Type) GetNCFGR_CAF() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x10) >> 4
}
func (o *GMAC_Type) SetNCFGR_NBC(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetNCFGR_NBC() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetNCFGR_MTIHEN(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetNCFGR_MTIHEN() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetNCFGR_UNIHEN(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetNCFGR_UNIHEN() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetNCFGR_MAXFS(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x100)|value<<8)
}
func (o *GMAC_Type) GetNCFGR_MAXFS() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x100) >> 8
}
func (o *GMAC_Type) SetNCFGR_RTY(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x1000)|value<<12)
}
func (o *GMAC_Type) GetNCFGR_RTY() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x1000) >> 12
}
func (o *GMAC_Type) SetNCFGR_PEN(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x2000)|value<<13)
}
func (o *GMAC_Type) GetNCFGR_PEN() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x2000) >> 13
}
func (o *GMAC_Type) SetNCFGR_RXBUFO(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0xc000)|value<<14)
}
func (o *GMAC_Type) GetNCFGR_RXBUFO() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0xc000) >> 14
}
func (o *GMAC_Type) SetNCFGR_LFERD(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x10000)|value<<16)
}
func (o *GMAC_Type) GetNCFGR_LFERD() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x10000) >> 16
}
func (o *GMAC_Type) SetNCFGR_RFCS(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x20000)|value<<17)
}
func (o *GMAC_Type) GetNCFGR_RFCS() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x20000) >> 17
}
func (o *GMAC_Type) SetNCFGR_CLK(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x1c0000)|value<<18)
}
func (o *GMAC_Type) GetNCFGR_CLK() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x1c0000) >> 18
}
func (o *GMAC_Type) SetNCFGR_DBW(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x600000)|value<<21)
}
func (o *GMAC_Type) GetNCFGR_DBW() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x600000) >> 21
}
func (o *GMAC_Type) SetNCFGR_DCPF(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x800000)|value<<23)
}
func (o *GMAC_Type) GetNCFGR_DCPF() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x800000) >> 23
}
func (o *GMAC_Type) SetNCFGR_RXCOEN(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x1000000)|value<<24)
}
func (o *GMAC_Type) GetNCFGR_RXCOEN() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x1000000) >> 24
}
func (o *GMAC_Type) SetNCFGR_EFRHD(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x2000000)|value<<25)
}
func (o *GMAC_Type) GetNCFGR_EFRHD() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x2000000) >> 25
}
func (o *GMAC_Type) SetNCFGR_IRXFCS(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x4000000)|value<<26)
}
func (o *GMAC_Type) GetNCFGR_IRXFCS() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x4000000) >> 26
}
func (o *GMAC_Type) SetNCFGR_IPGSEN(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x10000000)|value<<28)
}
func (o *GMAC_Type) GetNCFGR_IPGSEN() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x10000000) >> 28
}
func (o *GMAC_Type) SetNCFGR_RXBP(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x20000000)|value<<29)
}
func (o *GMAC_Type) GetNCFGR_RXBP() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x20000000) >> 29
}
func (o *GMAC_Type) SetNCFGR_IRXER(value uint32) {
	volatile.StoreUint32(&o.NCFGR.Reg, volatile.LoadUint32(&o.NCFGR.Reg)&^(0x40000000)|value<<30)
}
func (o *GMAC_Type) GetNCFGR_IRXER() uint32 {
	return (volatile.LoadUint32(&o.NCFGR.Reg) & 0x40000000) >> 30
}

// GMAC.NSR: Network Status Register
func (o *GMAC_Type) SetNSR_MDIO(value uint32) {
	volatile.StoreUint32(&o.NSR.Reg, volatile.LoadUint32(&o.NSR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetNSR_MDIO() uint32 {
	return (volatile.LoadUint32(&o.NSR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetNSR_IDLE(value uint32) {
	volatile.StoreUint32(&o.NSR.Reg, volatile.LoadUint32(&o.NSR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetNSR_IDLE() uint32 {
	return (volatile.LoadUint32(&o.NSR.Reg) & 0x4) >> 2
}

// GMAC.UR: User Register
func (o *GMAC_Type) SetUR_MII(value uint32) {
	volatile.StoreUint32(&o.UR.Reg, volatile.LoadUint32(&o.UR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetUR_MII() uint32 {
	return volatile.LoadUint32(&o.UR.Reg) & 0x1
}

// GMAC.DCFGR: DMA Configuration Register
func (o *GMAC_Type) SetDCFGR_FBLDO(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0x1f)|value)
}
func (o *GMAC_Type) GetDCFGR_FBLDO() uint32 {
	return volatile.LoadUint32(&o.DCFGR.Reg) & 0x1f
}
func (o *GMAC_Type) SetDCFGR_ESMA(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetDCFGR_ESMA() uint32 {
	return (volatile.LoadUint32(&o.DCFGR.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetDCFGR_ESPA(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetDCFGR_ESPA() uint32 {
	return (volatile.LoadUint32(&o.DCFGR.Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetDCFGR_RXBMS(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0x300)|value<<8)
}
func (o *GMAC_Type) GetDCFGR_RXBMS() uint32 {
	return (volatile.LoadUint32(&o.DCFGR.Reg) & 0x300) >> 8
}
func (o *GMAC_Type) SetDCFGR_TXPBMS(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetDCFGR_TXPBMS() uint32 {
	return (volatile.LoadUint32(&o.DCFGR.Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetDCFGR_TXCOEN(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetDCFGR_TXCOEN() uint32 {
	return (volatile.LoadUint32(&o.DCFGR.Reg) & 0x800) >> 11
}
func (o *GMAC_Type) SetDCFGR_DRBS(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0xff0000)|value<<16)
}
func (o *GMAC_Type) GetDCFGR_DRBS() uint32 {
	return (volatile.LoadUint32(&o.DCFGR.Reg) & 0xff0000) >> 16
}
func (o *GMAC_Type) SetDCFGR_DDRP(value uint32) {
	volatile.StoreUint32(&o.DCFGR.Reg, volatile.LoadUint32(&o.DCFGR.Reg)&^(0x1000000)|value<<24)
}
func (o *GMAC_Type) GetDCFGR_DDRP() uint32 {
	return (volatile.LoadUint32(&o.DCFGR.Reg) & 0x1000000) >> 24
}

// GMAC.TSR: Transmit Status Register
func (o *GMAC_Type) SetTSR_UBR(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetTSR_UBR() uint32 {
	return volatile.LoadUint32(&o.TSR.Reg) & 0x1
}
func (o *GMAC_Type) SetTSR_COL(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetTSR_COL() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetTSR_RLE(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetTSR_RLE() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetTSR_TXGO(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetTSR_TXGO() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x8) >> 3
}
func (o *GMAC_Type) SetTSR_TFC(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x10)|value<<4)
}
func (o *GMAC_Type) GetTSR_TFC() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x10) >> 4
}
func (o *GMAC_Type) SetTSR_TXCOMP(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetTSR_TXCOMP() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetTSR_UND(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetTSR_UND() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetTSR_HRESP(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x100)|value<<8)
}
func (o *GMAC_Type) GetTSR_HRESP() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x100) >> 8
}

// GMAC.RBQB: Receive Buffer Queue Base Address
func (o *GMAC_Type) SetRBQB_ADDR(value uint32) {
	volatile.StoreUint32(&o.RBQB.Reg, volatile.LoadUint32(&o.RBQB.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GMAC_Type) GetRBQB_ADDR() uint32 {
	return (volatile.LoadUint32(&o.RBQB.Reg) & 0xfffffffc) >> 2
}

// GMAC.TBQB: Transmit Buffer Queue Base Address
func (o *GMAC_Type) SetTBQB_ADDR(value uint32) {
	volatile.StoreUint32(&o.TBQB.Reg, volatile.LoadUint32(&o.TBQB.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GMAC_Type) GetTBQB_ADDR() uint32 {
	return (volatile.LoadUint32(&o.TBQB.Reg) & 0xfffffffc) >> 2
}

// GMAC.RSR: Receive Status Register
func (o *GMAC_Type) SetRSR_BNA(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetRSR_BNA() uint32 {
	return volatile.LoadUint32(&o.RSR.Reg) & 0x1
}
func (o *GMAC_Type) SetRSR_REC(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetRSR_REC() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetRSR_RXOVR(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetRSR_RXOVR() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetRSR_HNO(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetRSR_HNO() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x8) >> 3
}

// GMAC.ISR: Interrupt Status Register
func (o *GMAC_Type) SetISR_MFS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetISR_MFS() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *GMAC_Type) SetISR_RCOMP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetISR_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetISR_RXUBR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetISR_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetISR_TXUBR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetISR_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *GMAC_Type) SetISR_TUR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *GMAC_Type) GetISR_TUR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *GMAC_Type) SetISR_RLEX(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetISR_RLEX() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetISR_TFC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetISR_TFC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetISR_TCOMP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetISR_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetISR_ROVR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetISR_ROVR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetISR_HRESP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetISR_HRESP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *GMAC_Type) SetISR_PFNZ(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *GMAC_Type) GetISR_PFNZ() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *GMAC_Type) SetISR_PTZ(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *GMAC_Type) GetISR_PTZ() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *GMAC_Type) SetISR_PFTR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000)|value<<14)
}
func (o *GMAC_Type) GetISR_PFTR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000) >> 14
}
func (o *GMAC_Type) SetISR_DRQFR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000)|value<<18)
}
func (o *GMAC_Type) GetISR_DRQFR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000) >> 18
}
func (o *GMAC_Type) SetISR_SFR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000)|value<<19)
}
func (o *GMAC_Type) GetISR_SFR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000) >> 19
}
func (o *GMAC_Type) SetISR_DRQFT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100000)|value<<20)
}
func (o *GMAC_Type) GetISR_DRQFT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100000) >> 20
}
func (o *GMAC_Type) SetISR_SFT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200000)|value<<21)
}
func (o *GMAC_Type) GetISR_SFT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200000) >> 21
}
func (o *GMAC_Type) SetISR_PDRQFR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400000)|value<<22)
}
func (o *GMAC_Type) GetISR_PDRQFR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400000) >> 22
}
func (o *GMAC_Type) SetISR_PDRSFR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800000)|value<<23)
}
func (o *GMAC_Type) GetISR_PDRSFR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800000) >> 23
}
func (o *GMAC_Type) SetISR_PDRQFT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000000)|value<<24)
}
func (o *GMAC_Type) GetISR_PDRQFT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000000) >> 24
}
func (o *GMAC_Type) SetISR_PDRSFT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000000)|value<<25)
}
func (o *GMAC_Type) GetISR_PDRSFT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000000) >> 25
}
func (o *GMAC_Type) SetISR_SRI(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000000)|value<<26)
}
func (o *GMAC_Type) GetISR_SRI() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000000) >> 26
}
func (o *GMAC_Type) SetISR_WOL(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000000)|value<<28)
}
func (o *GMAC_Type) GetISR_WOL() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000000) >> 28
}
func (o *GMAC_Type) SetISR_TSUCMP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000000)|value<<29)
}
func (o *GMAC_Type) GetISR_TSUCMP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000000) >> 29
}

// GMAC.IER: Interrupt Enable Register
func (o *GMAC_Type) SetIER_MFS(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetIER_MFS() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *GMAC_Type) SetIER_RCOMP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetIER_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetIER_RXUBR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetIER_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetIER_TXUBR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetIER_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *GMAC_Type) SetIER_TUR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *GMAC_Type) GetIER_TUR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *GMAC_Type) SetIER_RLEX(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetIER_RLEX() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetIER_TFC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetIER_TFC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetIER_TCOMP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetIER_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetIER_ROVR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetIER_ROVR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetIER_HRESP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetIER_HRESP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *GMAC_Type) SetIER_PFNZ(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000)|value<<12)
}
func (o *GMAC_Type) GetIER_PFNZ() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000) >> 12
}
func (o *GMAC_Type) SetIER_PTZ(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000)|value<<13)
}
func (o *GMAC_Type) GetIER_PTZ() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000) >> 13
}
func (o *GMAC_Type) SetIER_PFTR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000)|value<<14)
}
func (o *GMAC_Type) GetIER_PFTR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000) >> 14
}
func (o *GMAC_Type) SetIER_EXINT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8000)|value<<15)
}
func (o *GMAC_Type) GetIER_EXINT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8000) >> 15
}
func (o *GMAC_Type) SetIER_DRQFR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40000)|value<<18)
}
func (o *GMAC_Type) GetIER_DRQFR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40000) >> 18
}
func (o *GMAC_Type) SetIER_SFR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80000)|value<<19)
}
func (o *GMAC_Type) GetIER_SFR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80000) >> 19
}
func (o *GMAC_Type) SetIER_DRQFT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100000)|value<<20)
}
func (o *GMAC_Type) GetIER_DRQFT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100000) >> 20
}
func (o *GMAC_Type) SetIER_SFT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200000)|value<<21)
}
func (o *GMAC_Type) GetIER_SFT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200000) >> 21
}
func (o *GMAC_Type) SetIER_PDRQFR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400000)|value<<22)
}
func (o *GMAC_Type) GetIER_PDRQFR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400000) >> 22
}
func (o *GMAC_Type) SetIER_PDRSFR(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800000)|value<<23)
}
func (o *GMAC_Type) GetIER_PDRSFR() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800000) >> 23
}
func (o *GMAC_Type) SetIER_PDRQFT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *GMAC_Type) GetIER_PDRQFT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}
func (o *GMAC_Type) SetIER_PDRSFT(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000000)|value<<25)
}
func (o *GMAC_Type) GetIER_PDRSFT() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000000) >> 25
}
func (o *GMAC_Type) SetIER_SRI(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4000000)|value<<26)
}
func (o *GMAC_Type) GetIER_SRI() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4000000) >> 26
}
func (o *GMAC_Type) SetIER_WOL(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000000)|value<<28)
}
func (o *GMAC_Type) GetIER_WOL() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000000) >> 28
}
func (o *GMAC_Type) SetIER_TSUCMP(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000000)|value<<29)
}
func (o *GMAC_Type) GetIER_TSUCMP() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000000) >> 29
}

// GMAC.IDR: Interrupt Disable Register
func (o *GMAC_Type) SetIDR_MFS(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetIDR_MFS() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *GMAC_Type) SetIDR_RCOMP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetIDR_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetIDR_RXUBR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetIDR_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetIDR_TXUBR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetIDR_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *GMAC_Type) SetIDR_TUR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *GMAC_Type) GetIDR_TUR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *GMAC_Type) SetIDR_RLEX(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetIDR_RLEX() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetIDR_TFC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetIDR_TFC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetIDR_TCOMP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetIDR_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetIDR_ROVR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetIDR_ROVR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetIDR_HRESP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetIDR_HRESP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *GMAC_Type) SetIDR_PFNZ(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000)|value<<12)
}
func (o *GMAC_Type) GetIDR_PFNZ() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000) >> 12
}
func (o *GMAC_Type) SetIDR_PTZ(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *GMAC_Type) GetIDR_PTZ() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}
func (o *GMAC_Type) SetIDR_PFTR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000)|value<<14)
}
func (o *GMAC_Type) GetIDR_PFTR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000) >> 14
}
func (o *GMAC_Type) SetIDR_EXINT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000)|value<<15)
}
func (o *GMAC_Type) GetIDR_EXINT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000) >> 15
}
func (o *GMAC_Type) SetIDR_DRQFR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40000)|value<<18)
}
func (o *GMAC_Type) GetIDR_DRQFR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40000) >> 18
}
func (o *GMAC_Type) SetIDR_SFR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80000)|value<<19)
}
func (o *GMAC_Type) GetIDR_SFR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80000) >> 19
}
func (o *GMAC_Type) SetIDR_DRQFT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100000)|value<<20)
}
func (o *GMAC_Type) GetIDR_DRQFT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100000) >> 20
}
func (o *GMAC_Type) SetIDR_SFT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200000)|value<<21)
}
func (o *GMAC_Type) GetIDR_SFT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200000) >> 21
}
func (o *GMAC_Type) SetIDR_PDRQFR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400000)|value<<22)
}
func (o *GMAC_Type) GetIDR_PDRQFR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400000) >> 22
}
func (o *GMAC_Type) SetIDR_PDRSFR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800000)|value<<23)
}
func (o *GMAC_Type) GetIDR_PDRSFR() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800000) >> 23
}
func (o *GMAC_Type) SetIDR_PDRQFT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *GMAC_Type) GetIDR_PDRQFT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}
func (o *GMAC_Type) SetIDR_PDRSFT(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000000)|value<<25)
}
func (o *GMAC_Type) GetIDR_PDRSFT() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000000) >> 25
}
func (o *GMAC_Type) SetIDR_SRI(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000000)|value<<26)
}
func (o *GMAC_Type) GetIDR_SRI() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000000) >> 26
}
func (o *GMAC_Type) SetIDR_WOL(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10000000)|value<<28)
}
func (o *GMAC_Type) GetIDR_WOL() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10000000) >> 28
}
func (o *GMAC_Type) SetIDR_TSUCMP(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20000000)|value<<29)
}
func (o *GMAC_Type) GetIDR_TSUCMP() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20000000) >> 29
}

// GMAC.IMR: Interrupt Mask Register
func (o *GMAC_Type) SetIMR_MFS(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *GMAC_Type) GetIMR_MFS() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *GMAC_Type) SetIMR_RCOMP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *GMAC_Type) GetIMR_RCOMP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *GMAC_Type) SetIMR_RXUBR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *GMAC_Type) GetIMR_RXUBR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *GMAC_Type) SetIMR_TXUBR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *GMAC_Type) GetIMR_TXUBR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *GMAC_Type) SetIMR_TUR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *GMAC_Type) GetIMR_TUR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *GMAC_Type) SetIMR_RLEX(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *GMAC_Type) GetIMR_RLEX() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *GMAC_Type) SetIMR_TFC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *GMAC_Type) GetIMR_TFC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *GMAC_Type) SetIMR_TCOMP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *GMAC_Type) GetIMR_TCOMP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *GMAC_Type) SetIMR_ROVR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *GMAC_Type) GetIMR_ROVR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *GMAC_Type) SetIMR_HRESP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *GMAC_Type) GetIMR_HRESP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}
func (o *GMAC_Type) SetIMR_PFNZ(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000)|value<<12)
}
func (o *GMAC_Type) GetIMR_PFNZ() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000) >> 12
}
func (o *GMAC_Type) SetIMR_PTZ(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000)|value<<13)
}
func (o *GMAC_Type) GetIMR_PTZ() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000) >> 13
}
func (o *GMAC_Type) SetIMR_PFTR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000)|value<<14)
}
func (o *GMAC_Type) GetIMR_PFTR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000) >> 14
}
func (o *GMAC_Type) SetIMR_EXINT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000)|value<<15)
}
func (o *GMAC_Type) GetIMR_EXINT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000) >> 15
}
func (o *GMAC_Type) SetIMR_DRQFR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000)|value<<18)
}
func (o *GMAC_Type) GetIMR_DRQFR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000) >> 18
}
func (o *GMAC_Type) SetIMR_SFR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000)|value<<19)
}
func (o *GMAC_Type) GetIMR_SFR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000) >> 19
}
func (o *GMAC_Type) SetIMR_DRQFT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100000)|value<<20)
}
func (o *GMAC_Type) GetIMR_DRQFT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100000) >> 20
}
func (o *GMAC_Type) SetIMR_SFT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200000)|value<<21)
}
func (o *GMAC_Type) GetIMR_SFT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200000) >> 21
}
func (o *GMAC_Type) SetIMR_PDRQFR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400000)|value<<22)
}
func (o *GMAC_Type) GetIMR_PDRQFR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400000) >> 22
}
func (o *GMAC_Type) SetIMR_PDRSFR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800000)|value<<23)
}
func (o *GMAC_Type) GetIMR_PDRSFR() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800000) >> 23
}
func (o *GMAC_Type) SetIMR_PDRQFT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *GMAC_Type) GetIMR_PDRQFT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}
func (o *GMAC_Type) SetIMR_PDRSFT(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000000)|value<<25)
}
func (o *GMAC_Type) GetIMR_PDRSFT() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000000) >> 25
}
func (o *GMAC_Type) SetIMR_SRI(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000000)|value<<26)
}
func (o *GMAC_Type) GetIMR_SRI() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000000) >> 26
}
func (o *GMAC_Type) SetIMR_WOL(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000000)|value<<28)
}
func (o *GMAC_Type) GetIMR_WOL() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000000) >> 28
}
func (o *GMAC_Type) SetIMR_TSUCMP(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000000)|value<<29)
}
func (o *GMAC_Type) GetIMR_TSUCMP() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000000) >> 29
}

// GMAC.MAN: PHY Maintenance Register
func (o *GMAC_Type) SetMAN_DATA(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetMAN_DATA() uint32 {
	return volatile.LoadUint32(&o.MAN.Reg) & 0xffff
}
func (o *GMAC_Type) SetMAN_WTN(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x30000)|value<<16)
}
func (o *GMAC_Type) GetMAN_WTN() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x30000) >> 16
}
func (o *GMAC_Type) SetMAN_REGA(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x7c0000)|value<<18)
}
func (o *GMAC_Type) GetMAN_REGA() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x7c0000) >> 18
}
func (o *GMAC_Type) SetMAN_PHYA(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0xf800000)|value<<23)
}
func (o *GMAC_Type) GetMAN_PHYA() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0xf800000) >> 23
}
func (o *GMAC_Type) SetMAN_OP(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x30000000)|value<<28)
}
func (o *GMAC_Type) GetMAN_OP() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x30000000) >> 28
}
func (o *GMAC_Type) SetMAN_CLTTO(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x40000000)|value<<30)
}
func (o *GMAC_Type) GetMAN_CLTTO() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x40000000) >> 30
}
func (o *GMAC_Type) SetMAN_WZO(value uint32) {
	volatile.StoreUint32(&o.MAN.Reg, volatile.LoadUint32(&o.MAN.Reg)&^(0x80000000)|value<<31)
}
func (o *GMAC_Type) GetMAN_WZO() uint32 {
	return (volatile.LoadUint32(&o.MAN.Reg) & 0x80000000) >> 31
}

// GMAC.RPQ: Received Pause Quantum Register
func (o *GMAC_Type) SetRPQ(value uint32) {
	volatile.StoreUint32(&o.RPQ.Reg, volatile.LoadUint32(&o.RPQ.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetRPQ() uint32 {
	return volatile.LoadUint32(&o.RPQ.Reg) & 0xffff
}

// GMAC.TPQ: Transmit Pause Quantum Register
func (o *GMAC_Type) SetTPQ(value uint32) {
	volatile.StoreUint32(&o.TPQ.Reg, volatile.LoadUint32(&o.TPQ.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetTPQ() uint32 {
	return volatile.LoadUint32(&o.TPQ.Reg) & 0xffff
}

// GMAC.TPSF: TX partial store and forward Register
func (o *GMAC_Type) SetTPSF_TPB1ADR(value uint32) {
	volatile.StoreUint32(&o.TPSF.Reg, volatile.LoadUint32(&o.TPSF.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetTPSF_TPB1ADR() uint32 {
	return volatile.LoadUint32(&o.TPSF.Reg) & 0x3ff
}
func (o *GMAC_Type) SetTPSF_ENTXP(value uint32) {
	volatile.StoreUint32(&o.TPSF.Reg, volatile.LoadUint32(&o.TPSF.Reg)&^(0x80000000)|value<<31)
}
func (o *GMAC_Type) GetTPSF_ENTXP() uint32 {
	return (volatile.LoadUint32(&o.TPSF.Reg) & 0x80000000) >> 31
}

// GMAC.RPSF: RX partial store and forward Register
func (o *GMAC_Type) SetRPSF_RPB1ADR(value uint32) {
	volatile.StoreUint32(&o.RPSF.Reg, volatile.LoadUint32(&o.RPSF.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetRPSF_RPB1ADR() uint32 {
	return volatile.LoadUint32(&o.RPSF.Reg) & 0x3ff
}
func (o *GMAC_Type) SetRPSF_ENRXP(value uint32) {
	volatile.StoreUint32(&o.RPSF.Reg, volatile.LoadUint32(&o.RPSF.Reg)&^(0x80000000)|value<<31)
}
func (o *GMAC_Type) GetRPSF_ENRXP() uint32 {
	return (volatile.LoadUint32(&o.RPSF.Reg) & 0x80000000) >> 31
}

// GMAC.RJFML: RX Jumbo Frame Max Length Register
func (o *GMAC_Type) SetRJFML_FML(value uint32) {
	volatile.StoreUint32(&o.RJFML.Reg, volatile.LoadUint32(&o.RJFML.Reg)&^(0x3fff)|value)
}
func (o *GMAC_Type) GetRJFML_FML() uint32 {
	return volatile.LoadUint32(&o.RJFML.Reg) & 0x3fff
}

// GMAC.HRB: Hash Register Bottom [31:0]
func (o *GMAC_Type) SetHRB(value uint32) {
	volatile.StoreUint32(&o.HRB.Reg, value)
}
func (o *GMAC_Type) GetHRB() uint32 {
	return volatile.LoadUint32(&o.HRB.Reg)
}

// GMAC.HRT: Hash Register Top [63:32]
func (o *GMAC_Type) SetHRT(value uint32) {
	volatile.StoreUint32(&o.HRT.Reg, value)
}
func (o *GMAC_Type) GetHRT() uint32 {
	return volatile.LoadUint32(&o.HRT.Reg)
}

// GMAC.TIDM: Type ID Match Register
func (o *GMAC_Type) SetTIDM_TID(idx int, value uint32) {
	volatile.StoreUint32(&o.TIDM[idx].Reg, volatile.LoadUint32(&o.TIDM[idx].Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetTIDM_TID(idx int) uint32 {
	return volatile.LoadUint32(&o.TIDM[idx].Reg) & 0xffff
}

// GMAC.WOL: Wake on LAN
func (o *GMAC_Type) SetWOL_IP(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetWOL_IP() uint32 {
	return volatile.LoadUint32(&o.WOL.Reg) & 0xffff
}
func (o *GMAC_Type) SetWOL_MAG(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0x10000)|value<<16)
}
func (o *GMAC_Type) GetWOL_MAG() uint32 {
	return (volatile.LoadUint32(&o.WOL.Reg) & 0x10000) >> 16
}
func (o *GMAC_Type) SetWOL_ARP(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0x20000)|value<<17)
}
func (o *GMAC_Type) GetWOL_ARP() uint32 {
	return (volatile.LoadUint32(&o.WOL.Reg) & 0x20000) >> 17
}
func (o *GMAC_Type) SetWOL_SA1(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0x40000)|value<<18)
}
func (o *GMAC_Type) GetWOL_SA1() uint32 {
	return (volatile.LoadUint32(&o.WOL.Reg) & 0x40000) >> 18
}
func (o *GMAC_Type) SetWOL_MTI(value uint32) {
	volatile.StoreUint32(&o.WOL.Reg, volatile.LoadUint32(&o.WOL.Reg)&^(0x80000)|value<<19)
}
func (o *GMAC_Type) GetWOL_MTI() uint32 {
	return (volatile.LoadUint32(&o.WOL.Reg) & 0x80000) >> 19
}

// GMAC.IPGS: IPG Stretch Register
func (o *GMAC_Type) SetIPGS_FL(value uint32) {
	volatile.StoreUint32(&o.IPGS.Reg, volatile.LoadUint32(&o.IPGS.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetIPGS_FL() uint32 {
	return volatile.LoadUint32(&o.IPGS.Reg) & 0xffff
}

// GMAC.SVLAN: Stacked VLAN Register
func (o *GMAC_Type) SetSVLAN_VLAN_TYPE(value uint32) {
	volatile.StoreUint32(&o.SVLAN.Reg, volatile.LoadUint32(&o.SVLAN.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetSVLAN_VLAN_TYPE() uint32 {
	return volatile.LoadUint32(&o.SVLAN.Reg) & 0xffff
}
func (o *GMAC_Type) SetSVLAN_ESVLAN(value uint32) {
	volatile.StoreUint32(&o.SVLAN.Reg, volatile.LoadUint32(&o.SVLAN.Reg)&^(0x80000000)|value<<31)
}
func (o *GMAC_Type) GetSVLAN_ESVLAN() uint32 {
	return (volatile.LoadUint32(&o.SVLAN.Reg) & 0x80000000) >> 31
}

// GMAC.TPFCP: Transmit PFC Pause Register
func (o *GMAC_Type) SetTPFCP_PEV(value uint32) {
	volatile.StoreUint32(&o.TPFCP.Reg, volatile.LoadUint32(&o.TPFCP.Reg)&^(0xff)|value)
}
func (o *GMAC_Type) GetTPFCP_PEV() uint32 {
	return volatile.LoadUint32(&o.TPFCP.Reg) & 0xff
}
func (o *GMAC_Type) SetTPFCP_PQ(value uint32) {
	volatile.StoreUint32(&o.TPFCP.Reg, volatile.LoadUint32(&o.TPFCP.Reg)&^(0xff00)|value<<8)
}
func (o *GMAC_Type) GetTPFCP_PQ() uint32 {
	return (volatile.LoadUint32(&o.TPFCP.Reg) & 0xff00) >> 8
}

// GMAC.SAMB1: Specific Address 1 Mask Bottom [31:0] Register
func (o *GMAC_Type) SetSAMB1(value uint32) {
	volatile.StoreUint32(&o.SAMB1.Reg, value)
}
func (o *GMAC_Type) GetSAMB1() uint32 {
	return volatile.LoadUint32(&o.SAMB1.Reg)
}

// GMAC.SAMT1: Specific Address 1 Mask Top [47:32] Register
func (o *GMAC_Type) SetSAMT1_ADDR(value uint32) {
	volatile.StoreUint32(&o.SAMT1.Reg, volatile.LoadUint32(&o.SAMT1.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetSAMT1_ADDR() uint32 {
	return volatile.LoadUint32(&o.SAMT1.Reg) & 0xffff
}

// GMAC.NSC: Tsu timer comparison nanoseconds Register
func (o *GMAC_Type) SetNSC_NANOSEC(value uint32) {
	volatile.StoreUint32(&o.NSC.Reg, volatile.LoadUint32(&o.NSC.Reg)&^(0x1fffff)|value)
}
func (o *GMAC_Type) GetNSC_NANOSEC() uint32 {
	return volatile.LoadUint32(&o.NSC.Reg) & 0x1fffff
}

// GMAC.SCL: Tsu timer second comparison Register
func (o *GMAC_Type) SetSCL(value uint32) {
	volatile.StoreUint32(&o.SCL.Reg, value)
}
func (o *GMAC_Type) GetSCL() uint32 {
	return volatile.LoadUint32(&o.SCL.Reg)
}

// GMAC.SCH: Tsu timer second comparison Register
func (o *GMAC_Type) SetSCH_SEC(value uint32) {
	volatile.StoreUint32(&o.SCH.Reg, volatile.LoadUint32(&o.SCH.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetSCH_SEC() uint32 {
	return volatile.LoadUint32(&o.SCH.Reg) & 0xffff
}

// GMAC.EFTSH: PTP Event Frame Transmitted Seconds High Register
func (o *GMAC_Type) SetEFTSH_RUD(value uint32) {
	volatile.StoreUint32(&o.EFTSH.Reg, volatile.LoadUint32(&o.EFTSH.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetEFTSH_RUD() uint32 {
	return volatile.LoadUint32(&o.EFTSH.Reg) & 0xffff
}

// GMAC.EFRSH: PTP Event Frame Received Seconds High Register
func (o *GMAC_Type) SetEFRSH_RUD(value uint32) {
	volatile.StoreUint32(&o.EFRSH.Reg, volatile.LoadUint32(&o.EFRSH.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetEFRSH_RUD() uint32 {
	return volatile.LoadUint32(&o.EFRSH.Reg) & 0xffff
}

// GMAC.PEFTSH: PTP Peer Event Frame Transmitted Seconds High Register
func (o *GMAC_Type) SetPEFTSH_RUD(value uint32) {
	volatile.StoreUint32(&o.PEFTSH.Reg, volatile.LoadUint32(&o.PEFTSH.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetPEFTSH_RUD() uint32 {
	return volatile.LoadUint32(&o.PEFTSH.Reg) & 0xffff
}

// GMAC.PEFRSH: PTP Peer Event Frame Received Seconds High Register
func (o *GMAC_Type) SetPEFRSH_RUD(value uint32) {
	volatile.StoreUint32(&o.PEFRSH.Reg, volatile.LoadUint32(&o.PEFRSH.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetPEFRSH_RUD() uint32 {
	return volatile.LoadUint32(&o.PEFRSH.Reg) & 0xffff
}

// GMAC.OTLO: Octets Transmitted [31:0] Register
func (o *GMAC_Type) SetOTLO(value uint32) {
	volatile.StoreUint32(&o.OTLO.Reg, value)
}
func (o *GMAC_Type) GetOTLO() uint32 {
	return volatile.LoadUint32(&o.OTLO.Reg)
}

// GMAC.OTHI: Octets Transmitted [47:32] Register
func (o *GMAC_Type) SetOTHI_TXO(value uint32) {
	volatile.StoreUint32(&o.OTHI.Reg, volatile.LoadUint32(&o.OTHI.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetOTHI_TXO() uint32 {
	return volatile.LoadUint32(&o.OTHI.Reg) & 0xffff
}

// GMAC.FT: Frames Transmitted Register
func (o *GMAC_Type) SetFT(value uint32) {
	volatile.StoreUint32(&o.FT.Reg, value)
}
func (o *GMAC_Type) GetFT() uint32 {
	return volatile.LoadUint32(&o.FT.Reg)
}

// GMAC.BCFT: Broadcast Frames Transmitted Register
func (o *GMAC_Type) SetBCFT(value uint32) {
	volatile.StoreUint32(&o.BCFT.Reg, value)
}
func (o *GMAC_Type) GetBCFT() uint32 {
	return volatile.LoadUint32(&o.BCFT.Reg)
}

// GMAC.MFT: Multicast Frames Transmitted Register
func (o *GMAC_Type) SetMFT(value uint32) {
	volatile.StoreUint32(&o.MFT.Reg, value)
}
func (o *GMAC_Type) GetMFT() uint32 {
	return volatile.LoadUint32(&o.MFT.Reg)
}

// GMAC.PFT: Pause Frames Transmitted Register
func (o *GMAC_Type) SetPFT_PFTX(value uint32) {
	volatile.StoreUint32(&o.PFT.Reg, volatile.LoadUint32(&o.PFT.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetPFT_PFTX() uint32 {
	return volatile.LoadUint32(&o.PFT.Reg) & 0xffff
}

// GMAC.BFT64: 64 Byte Frames Transmitted Register
func (o *GMAC_Type) SetBFT64(value uint32) {
	volatile.StoreUint32(&o.BFT64.Reg, value)
}
func (o *GMAC_Type) GetBFT64() uint32 {
	return volatile.LoadUint32(&o.BFT64.Reg)
}

// GMAC.TBFT127: 65 to 127 Byte Frames Transmitted Register
func (o *GMAC_Type) SetTBFT127(value uint32) {
	volatile.StoreUint32(&o.TBFT127.Reg, value)
}
func (o *GMAC_Type) GetTBFT127() uint32 {
	return volatile.LoadUint32(&o.TBFT127.Reg)
}

// GMAC.TBFT255: 128 to 255 Byte Frames Transmitted Register
func (o *GMAC_Type) SetTBFT255(value uint32) {
	volatile.StoreUint32(&o.TBFT255.Reg, value)
}
func (o *GMAC_Type) GetTBFT255() uint32 {
	return volatile.LoadUint32(&o.TBFT255.Reg)
}

// GMAC.TBFT511: 256 to 511 Byte Frames Transmitted Register
func (o *GMAC_Type) SetTBFT511(value uint32) {
	volatile.StoreUint32(&o.TBFT511.Reg, value)
}
func (o *GMAC_Type) GetTBFT511() uint32 {
	return volatile.LoadUint32(&o.TBFT511.Reg)
}

// GMAC.TBFT1023: 512 to 1023 Byte Frames Transmitted Register
func (o *GMAC_Type) SetTBFT1023(value uint32) {
	volatile.StoreUint32(&o.TBFT1023.Reg, value)
}
func (o *GMAC_Type) GetTBFT1023() uint32 {
	return volatile.LoadUint32(&o.TBFT1023.Reg)
}

// GMAC.TBFT1518: 1024 to 1518 Byte Frames Transmitted Register
func (o *GMAC_Type) SetTBFT1518(value uint32) {
	volatile.StoreUint32(&o.TBFT1518.Reg, value)
}
func (o *GMAC_Type) GetTBFT1518() uint32 {
	return volatile.LoadUint32(&o.TBFT1518.Reg)
}

// GMAC.GTBFT1518: Greater Than 1518 Byte Frames Transmitted Register
func (o *GMAC_Type) SetGTBFT1518(value uint32) {
	volatile.StoreUint32(&o.GTBFT1518.Reg, value)
}
func (o *GMAC_Type) GetGTBFT1518() uint32 {
	return volatile.LoadUint32(&o.GTBFT1518.Reg)
}

// GMAC.TUR: Transmit Underruns Register
func (o *GMAC_Type) SetTUR_TXUNR(value uint32) {
	volatile.StoreUint32(&o.TUR.Reg, volatile.LoadUint32(&o.TUR.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetTUR_TXUNR() uint32 {
	return volatile.LoadUint32(&o.TUR.Reg) & 0x3ff
}

// GMAC.SCF: Single Collision Frames Register
func (o *GMAC_Type) SetSCF_SCOL(value uint32) {
	volatile.StoreUint32(&o.SCF.Reg, volatile.LoadUint32(&o.SCF.Reg)&^(0x3ffff)|value)
}
func (o *GMAC_Type) GetSCF_SCOL() uint32 {
	return volatile.LoadUint32(&o.SCF.Reg) & 0x3ffff
}

// GMAC.MCF: Multiple Collision Frames Register
func (o *GMAC_Type) SetMCF_MCOL(value uint32) {
	volatile.StoreUint32(&o.MCF.Reg, volatile.LoadUint32(&o.MCF.Reg)&^(0x3ffff)|value)
}
func (o *GMAC_Type) GetMCF_MCOL() uint32 {
	return volatile.LoadUint32(&o.MCF.Reg) & 0x3ffff
}

// GMAC.EC: Excessive Collisions Register
func (o *GMAC_Type) SetEC_XCOL(value uint32) {
	volatile.StoreUint32(&o.EC.Reg, volatile.LoadUint32(&o.EC.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetEC_XCOL() uint32 {
	return volatile.LoadUint32(&o.EC.Reg) & 0x3ff
}

// GMAC.LC: Late Collisions Register
func (o *GMAC_Type) SetLC_LCOL(value uint32) {
	volatile.StoreUint32(&o.LC.Reg, volatile.LoadUint32(&o.LC.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetLC_LCOL() uint32 {
	return volatile.LoadUint32(&o.LC.Reg) & 0x3ff
}

// GMAC.DTF: Deferred Transmission Frames Register
func (o *GMAC_Type) SetDTF_DEFT(value uint32) {
	volatile.StoreUint32(&o.DTF.Reg, volatile.LoadUint32(&o.DTF.Reg)&^(0x3ffff)|value)
}
func (o *GMAC_Type) GetDTF_DEFT() uint32 {
	return volatile.LoadUint32(&o.DTF.Reg) & 0x3ffff
}

// GMAC.CSE: Carrier Sense Errors Register
func (o *GMAC_Type) SetCSE_CSR(value uint32) {
	volatile.StoreUint32(&o.CSE.Reg, volatile.LoadUint32(&o.CSE.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetCSE_CSR() uint32 {
	return volatile.LoadUint32(&o.CSE.Reg) & 0x3ff
}

// GMAC.ORLO: Octets Received [31:0] Received
func (o *GMAC_Type) SetORLO(value uint32) {
	volatile.StoreUint32(&o.ORLO.Reg, value)
}
func (o *GMAC_Type) GetORLO() uint32 {
	return volatile.LoadUint32(&o.ORLO.Reg)
}

// GMAC.ORHI: Octets Received [47:32] Received
func (o *GMAC_Type) SetORHI_RXO(value uint32) {
	volatile.StoreUint32(&o.ORHI.Reg, volatile.LoadUint32(&o.ORHI.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetORHI_RXO() uint32 {
	return volatile.LoadUint32(&o.ORHI.Reg) & 0xffff
}

// GMAC.FR: Frames Received Register
func (o *GMAC_Type) SetFR(value uint32) {
	volatile.StoreUint32(&o.FR.Reg, value)
}
func (o *GMAC_Type) GetFR() uint32 {
	return volatile.LoadUint32(&o.FR.Reg)
}

// GMAC.BCFR: Broadcast Frames Received Register
func (o *GMAC_Type) SetBCFR(value uint32) {
	volatile.StoreUint32(&o.BCFR.Reg, value)
}
func (o *GMAC_Type) GetBCFR() uint32 {
	return volatile.LoadUint32(&o.BCFR.Reg)
}

// GMAC.MFR: Multicast Frames Received Register
func (o *GMAC_Type) SetMFR(value uint32) {
	volatile.StoreUint32(&o.MFR.Reg, value)
}
func (o *GMAC_Type) GetMFR() uint32 {
	return volatile.LoadUint32(&o.MFR.Reg)
}

// GMAC.PFR: Pause Frames Received Register
func (o *GMAC_Type) SetPFR_PFRX(value uint32) {
	volatile.StoreUint32(&o.PFR.Reg, volatile.LoadUint32(&o.PFR.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetPFR_PFRX() uint32 {
	return volatile.LoadUint32(&o.PFR.Reg) & 0xffff
}

// GMAC.BFR64: 64 Byte Frames Received Register
func (o *GMAC_Type) SetBFR64(value uint32) {
	volatile.StoreUint32(&o.BFR64.Reg, value)
}
func (o *GMAC_Type) GetBFR64() uint32 {
	return volatile.LoadUint32(&o.BFR64.Reg)
}

// GMAC.TBFR127: 65 to 127 Byte Frames Received Register
func (o *GMAC_Type) SetTBFR127(value uint32) {
	volatile.StoreUint32(&o.TBFR127.Reg, value)
}
func (o *GMAC_Type) GetTBFR127() uint32 {
	return volatile.LoadUint32(&o.TBFR127.Reg)
}

// GMAC.TBFR255: 128 to 255 Byte Frames Received Register
func (o *GMAC_Type) SetTBFR255(value uint32) {
	volatile.StoreUint32(&o.TBFR255.Reg, value)
}
func (o *GMAC_Type) GetTBFR255() uint32 {
	return volatile.LoadUint32(&o.TBFR255.Reg)
}

// GMAC.TBFR511: 256 to 511Byte Frames Received Register
func (o *GMAC_Type) SetTBFR511(value uint32) {
	volatile.StoreUint32(&o.TBFR511.Reg, value)
}
func (o *GMAC_Type) GetTBFR511() uint32 {
	return volatile.LoadUint32(&o.TBFR511.Reg)
}

// GMAC.TBFR1023: 512 to 1023 Byte Frames Received Register
func (o *GMAC_Type) SetTBFR1023(value uint32) {
	volatile.StoreUint32(&o.TBFR1023.Reg, value)
}
func (o *GMAC_Type) GetTBFR1023() uint32 {
	return volatile.LoadUint32(&o.TBFR1023.Reg)
}

// GMAC.TBFR1518: 1024 to 1518 Byte Frames Received Register
func (o *GMAC_Type) SetTBFR1518(value uint32) {
	volatile.StoreUint32(&o.TBFR1518.Reg, value)
}
func (o *GMAC_Type) GetTBFR1518() uint32 {
	return volatile.LoadUint32(&o.TBFR1518.Reg)
}

// GMAC.TMXBFR: 1519 to Maximum Byte Frames Received Register
func (o *GMAC_Type) SetTMXBFR(value uint32) {
	volatile.StoreUint32(&o.TMXBFR.Reg, value)
}
func (o *GMAC_Type) GetTMXBFR() uint32 {
	return volatile.LoadUint32(&o.TMXBFR.Reg)
}

// GMAC.UFR: Undersize Frames Received Register
func (o *GMAC_Type) SetUFR_UFRX(value uint32) {
	volatile.StoreUint32(&o.UFR.Reg, volatile.LoadUint32(&o.UFR.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetUFR_UFRX() uint32 {
	return volatile.LoadUint32(&o.UFR.Reg) & 0x3ff
}

// GMAC.OFR: Oversize Frames Received Register
func (o *GMAC_Type) SetOFR_OFRX(value uint32) {
	volatile.StoreUint32(&o.OFR.Reg, volatile.LoadUint32(&o.OFR.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetOFR_OFRX() uint32 {
	return volatile.LoadUint32(&o.OFR.Reg) & 0x3ff
}

// GMAC.JR: Jabbers Received Register
func (o *GMAC_Type) SetJR_JRX(value uint32) {
	volatile.StoreUint32(&o.JR.Reg, volatile.LoadUint32(&o.JR.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetJR_JRX() uint32 {
	return volatile.LoadUint32(&o.JR.Reg) & 0x3ff
}

// GMAC.FCSE: Frame Check Sequence Errors Register
func (o *GMAC_Type) SetFCSE_FCKR(value uint32) {
	volatile.StoreUint32(&o.FCSE.Reg, volatile.LoadUint32(&o.FCSE.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetFCSE_FCKR() uint32 {
	return volatile.LoadUint32(&o.FCSE.Reg) & 0x3ff
}

// GMAC.LFFE: Length Field Frame Errors Register
func (o *GMAC_Type) SetLFFE_LFER(value uint32) {
	volatile.StoreUint32(&o.LFFE.Reg, volatile.LoadUint32(&o.LFFE.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetLFFE_LFER() uint32 {
	return volatile.LoadUint32(&o.LFFE.Reg) & 0x3ff
}

// GMAC.RSE: Receive Symbol Errors Register
func (o *GMAC_Type) SetRSE_RXSE(value uint32) {
	volatile.StoreUint32(&o.RSE.Reg, volatile.LoadUint32(&o.RSE.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetRSE_RXSE() uint32 {
	return volatile.LoadUint32(&o.RSE.Reg) & 0x3ff
}

// GMAC.AE: Alignment Errors Register
func (o *GMAC_Type) SetAE_AER(value uint32) {
	volatile.StoreUint32(&o.AE.Reg, volatile.LoadUint32(&o.AE.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetAE_AER() uint32 {
	return volatile.LoadUint32(&o.AE.Reg) & 0x3ff
}

// GMAC.RRE: Receive Resource Errors Register
func (o *GMAC_Type) SetRRE_RXRER(value uint32) {
	volatile.StoreUint32(&o.RRE.Reg, volatile.LoadUint32(&o.RRE.Reg)&^(0x3ffff)|value)
}
func (o *GMAC_Type) GetRRE_RXRER() uint32 {
	return volatile.LoadUint32(&o.RRE.Reg) & 0x3ffff
}

// GMAC.ROE: Receive Overrun Register
func (o *GMAC_Type) SetROE_RXOVR(value uint32) {
	volatile.StoreUint32(&o.ROE.Reg, volatile.LoadUint32(&o.ROE.Reg)&^(0x3ff)|value)
}
func (o *GMAC_Type) GetROE_RXOVR() uint32 {
	return volatile.LoadUint32(&o.ROE.Reg) & 0x3ff
}

// GMAC.IHCE: IP Header Checksum Errors Register
func (o *GMAC_Type) SetIHCE_HCKER(value uint32) {
	volatile.StoreUint32(&o.IHCE.Reg, volatile.LoadUint32(&o.IHCE.Reg)&^(0xff)|value)
}
func (o *GMAC_Type) GetIHCE_HCKER() uint32 {
	return volatile.LoadUint32(&o.IHCE.Reg) & 0xff
}

// GMAC.TCE: TCP Checksum Errors Register
func (o *GMAC_Type) SetTCE_TCKER(value uint32) {
	volatile.StoreUint32(&o.TCE.Reg, volatile.LoadUint32(&o.TCE.Reg)&^(0xff)|value)
}
func (o *GMAC_Type) GetTCE_TCKER() uint32 {
	return volatile.LoadUint32(&o.TCE.Reg) & 0xff
}

// GMAC.UCE: UDP Checksum Errors Register
func (o *GMAC_Type) SetUCE_UCKER(value uint32) {
	volatile.StoreUint32(&o.UCE.Reg, volatile.LoadUint32(&o.UCE.Reg)&^(0xff)|value)
}
func (o *GMAC_Type) GetUCE_UCKER() uint32 {
	return volatile.LoadUint32(&o.UCE.Reg) & 0xff
}

// GMAC.TISUBN: 1588 Timer Increment [15:0] Sub-Nanoseconds Register
func (o *GMAC_Type) SetTISUBN_LSBTIR(value uint32) {
	volatile.StoreUint32(&o.TISUBN.Reg, volatile.LoadUint32(&o.TISUBN.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetTISUBN_LSBTIR() uint32 {
	return volatile.LoadUint32(&o.TISUBN.Reg) & 0xffff
}

// GMAC.TSH: 1588 Timer Seconds High [15:0] Register
func (o *GMAC_Type) SetTSH_TCS(value uint32) {
	volatile.StoreUint32(&o.TSH.Reg, volatile.LoadUint32(&o.TSH.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetTSH_TCS() uint32 {
	return volatile.LoadUint32(&o.TSH.Reg) & 0xffff
}

// GMAC.TSSSL: 1588 Timer Sync Strobe Seconds [31:0] Register
func (o *GMAC_Type) SetTSSSL(value uint32) {
	volatile.StoreUint32(&o.TSSSL.Reg, value)
}
func (o *GMAC_Type) GetTSSSL() uint32 {
	return volatile.LoadUint32(&o.TSSSL.Reg)
}

// GMAC.TSSN: 1588 Timer Sync Strobe Nanoseconds Register
func (o *GMAC_Type) SetTSSN_VTN(value uint32) {
	volatile.StoreUint32(&o.TSSN.Reg, volatile.LoadUint32(&o.TSSN.Reg)&^(0x3fffffff)|value)
}
func (o *GMAC_Type) GetTSSN_VTN() uint32 {
	return volatile.LoadUint32(&o.TSSN.Reg) & 0x3fffffff
}

// GMAC.TSL: 1588 Timer Seconds [31:0] Register
func (o *GMAC_Type) SetTSL(value uint32) {
	volatile.StoreUint32(&o.TSL.Reg, value)
}
func (o *GMAC_Type) GetTSL() uint32 {
	return volatile.LoadUint32(&o.TSL.Reg)
}

// GMAC.TN: 1588 Timer Nanoseconds Register
func (o *GMAC_Type) SetTN_TNS(value uint32) {
	volatile.StoreUint32(&o.TN.Reg, volatile.LoadUint32(&o.TN.Reg)&^(0x3fffffff)|value)
}
func (o *GMAC_Type) GetTN_TNS() uint32 {
	return volatile.LoadUint32(&o.TN.Reg) & 0x3fffffff
}

// GMAC.TA: 1588 Timer Adjust Register
func (o *GMAC_Type) SetTA_ITDT(value uint32) {
	volatile.StoreUint32(&o.TA.Reg, volatile.LoadUint32(&o.TA.Reg)&^(0x3fffffff)|value)
}
func (o *GMAC_Type) GetTA_ITDT() uint32 {
	return volatile.LoadUint32(&o.TA.Reg) & 0x3fffffff
}
func (o *GMAC_Type) SetTA_ADJ(value uint32) {
	volatile.StoreUint32(&o.TA.Reg, volatile.LoadUint32(&o.TA.Reg)&^(0x80000000)|value<<31)
}
func (o *GMAC_Type) GetTA_ADJ() uint32 {
	return (volatile.LoadUint32(&o.TA.Reg) & 0x80000000) >> 31
}

// GMAC.TI: 1588 Timer Increment Register
func (o *GMAC_Type) SetTI_CNS(value uint32) {
	volatile.StoreUint32(&o.TI.Reg, volatile.LoadUint32(&o.TI.Reg)&^(0xff)|value)
}
func (o *GMAC_Type) GetTI_CNS() uint32 {
	return volatile.LoadUint32(&o.TI.Reg) & 0xff
}
func (o *GMAC_Type) SetTI_ACNS(value uint32) {
	volatile.StoreUint32(&o.TI.Reg, volatile.LoadUint32(&o.TI.Reg)&^(0xff00)|value<<8)
}
func (o *GMAC_Type) GetTI_ACNS() uint32 {
	return (volatile.LoadUint32(&o.TI.Reg) & 0xff00) >> 8
}
func (o *GMAC_Type) SetTI_NIT(value uint32) {
	volatile.StoreUint32(&o.TI.Reg, volatile.LoadUint32(&o.TI.Reg)&^(0xff0000)|value<<16)
}
func (o *GMAC_Type) GetTI_NIT() uint32 {
	return (volatile.LoadUint32(&o.TI.Reg) & 0xff0000) >> 16
}

// GMAC.EFTSL: PTP Event Frame Transmitted Seconds Low Register
func (o *GMAC_Type) SetEFTSL(value uint32) {
	volatile.StoreUint32(&o.EFTSL.Reg, value)
}
func (o *GMAC_Type) GetEFTSL() uint32 {
	return volatile.LoadUint32(&o.EFTSL.Reg)
}

// GMAC.EFTN: PTP Event Frame Transmitted Nanoseconds
func (o *GMAC_Type) SetEFTN_RUD(value uint32) {
	volatile.StoreUint32(&o.EFTN.Reg, volatile.LoadUint32(&o.EFTN.Reg)&^(0x3fffffff)|value)
}
func (o *GMAC_Type) GetEFTN_RUD() uint32 {
	return volatile.LoadUint32(&o.EFTN.Reg) & 0x3fffffff
}

// GMAC.EFRSL: PTP Event Frame Received Seconds Low Register
func (o *GMAC_Type) SetEFRSL(value uint32) {
	volatile.StoreUint32(&o.EFRSL.Reg, value)
}
func (o *GMAC_Type) GetEFRSL() uint32 {
	return volatile.LoadUint32(&o.EFRSL.Reg)
}

// GMAC.EFRN: PTP Event Frame Received Nanoseconds
func (o *GMAC_Type) SetEFRN_RUD(value uint32) {
	volatile.StoreUint32(&o.EFRN.Reg, volatile.LoadUint32(&o.EFRN.Reg)&^(0x3fffffff)|value)
}
func (o *GMAC_Type) GetEFRN_RUD() uint32 {
	return volatile.LoadUint32(&o.EFRN.Reg) & 0x3fffffff
}

// GMAC.PEFTSL: PTP Peer Event Frame Transmitted Seconds Low Register
func (o *GMAC_Type) SetPEFTSL(value uint32) {
	volatile.StoreUint32(&o.PEFTSL.Reg, value)
}
func (o *GMAC_Type) GetPEFTSL() uint32 {
	return volatile.LoadUint32(&o.PEFTSL.Reg)
}

// GMAC.PEFTN: PTP Peer Event Frame Transmitted Nanoseconds
func (o *GMAC_Type) SetPEFTN_RUD(value uint32) {
	volatile.StoreUint32(&o.PEFTN.Reg, volatile.LoadUint32(&o.PEFTN.Reg)&^(0x3fffffff)|value)
}
func (o *GMAC_Type) GetPEFTN_RUD() uint32 {
	return volatile.LoadUint32(&o.PEFTN.Reg) & 0x3fffffff
}

// GMAC.PEFRSL: PTP Peer Event Frame Received Seconds Low Register
func (o *GMAC_Type) SetPEFRSL(value uint32) {
	volatile.StoreUint32(&o.PEFRSL.Reg, value)
}
func (o *GMAC_Type) GetPEFRSL() uint32 {
	return volatile.LoadUint32(&o.PEFRSL.Reg)
}

// GMAC.PEFRN: PTP Peer Event Frame Received Nanoseconds
func (o *GMAC_Type) SetPEFRN_RUD(value uint32) {
	volatile.StoreUint32(&o.PEFRN.Reg, volatile.LoadUint32(&o.PEFRN.Reg)&^(0x3fffffff)|value)
}
func (o *GMAC_Type) GetPEFRN_RUD() uint32 {
	return volatile.LoadUint32(&o.PEFRN.Reg) & 0x3fffffff
}

// GMAC.RLPITR: Receive LPI transition Register
func (o *GMAC_Type) SetRLPITR(value uint32) {
	volatile.StoreUint32(&o.RLPITR.Reg, volatile.LoadUint32(&o.RLPITR.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetRLPITR() uint32 {
	return volatile.LoadUint32(&o.RLPITR.Reg) & 0xffff
}

// GMAC.RLPITI: Receive LPI Time Register
func (o *GMAC_Type) SetRLPITI(value uint32) {
	volatile.StoreUint32(&o.RLPITI.Reg, volatile.LoadUint32(&o.RLPITI.Reg)&^(0xffffff)|value)
}
func (o *GMAC_Type) GetRLPITI() uint32 {
	return volatile.LoadUint32(&o.RLPITI.Reg) & 0xffffff
}

// GMAC.TLPITR: Receive LPI transition Register
func (o *GMAC_Type) SetTLPITR(value uint32) {
	volatile.StoreUint32(&o.TLPITR.Reg, volatile.LoadUint32(&o.TLPITR.Reg)&^(0xffff)|value)
}
func (o *GMAC_Type) GetTLPITR() uint32 {
	return volatile.LoadUint32(&o.TLPITR.Reg) & 0xffff
}

// GMAC.TLPITI: Receive LPI Time Register
func (o *GMAC_Type) SetTLPITI(value uint32) {
	volatile.StoreUint32(&o.TLPITI.Reg, volatile.LoadUint32(&o.TLPITI.Reg)&^(0xffffff)|value)
}
func (o *GMAC_Type) GetTLPITI() uint32 {
	return volatile.LoadUint32(&o.TLPITI.Reg) & 0xffffff
}

type GMAC_SA_Type struct {
	SAB volatile.Register32 // 0x88
	SAT volatile.Register32 // 0x8C
}

// GMAC_SA.SAB: Specific Address Bottom [31:0] Register
func (o *GMAC_SA_Type) SetSAB(value uint32) {
	volatile.StoreUint32(&o.SAB.Reg, value)
}
func (o *GMAC_SA_Type) GetSAB() uint32 {
	return volatile.LoadUint32(&o.SAB.Reg)
}

// GMAC_SA.SAT: Specific Address Top [47:32] Register
func (o *GMAC_SA_Type) SetSAT_ADDR(value uint32) {
	volatile.StoreUint32(&o.SAT.Reg, volatile.LoadUint32(&o.SAT.Reg)&^(0xffff)|value)
}
func (o *GMAC_SA_Type) GetSAT_ADDR() uint32 {
	return volatile.LoadUint32(&o.SAT.Reg) & 0xffff
}

// HSB Matrix
type HMATRIXB_Type struct {
	_   [128]byte
	PRS [16]HMATRIXB_PRS_Type // 0x80
}

type HMATRIXB_PRS_Type struct {
	PRAS volatile.Register32 // 0x80
	PRBS volatile.Register32 // 0x84
}

// Integrity Check Monitor
type ICM_Type struct {
	CFG    volatile.Register32 // 0x0
	CTRL   volatile.Register32 // 0x4
	SR     volatile.Register32 // 0x8
	_      [4]byte
	IER    volatile.Register32 // 0x10
	IDR    volatile.Register32 // 0x14
	IMR    volatile.Register32 // 0x18
	ISR    volatile.Register32 // 0x1C
	UASR   volatile.Register32 // 0x20
	_      [12]byte
	DSCR   volatile.Register32    // 0x30
	HASH   volatile.Register32    // 0x34
	UIHVAL [8]volatile.Register32 // 0x38
}

// ICM.CFG: Configuration
func (o *ICM_Type) SetCFG_WBDIS(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x1)|value)
}
func (o *ICM_Type) GetCFG_WBDIS() uint32 {
	return volatile.LoadUint32(&o.CFG.Reg) & 0x1
}
func (o *ICM_Type) SetCFG_EOMDIS(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x2)|value<<1)
}
func (o *ICM_Type) GetCFG_EOMDIS() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x2) >> 1
}
func (o *ICM_Type) SetCFG_SLBDIS(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x4)|value<<2)
}
func (o *ICM_Type) GetCFG_SLBDIS() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x4) >> 2
}
func (o *ICM_Type) SetCFG_BBC(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0xf0)|value<<4)
}
func (o *ICM_Type) GetCFG_BBC() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0xf0) >> 4
}
func (o *ICM_Type) SetCFG_ASCD(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x100)|value<<8)
}
func (o *ICM_Type) GetCFG_ASCD() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x100) >> 8
}
func (o *ICM_Type) SetCFG_DUALBUFF(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x200)|value<<9)
}
func (o *ICM_Type) GetCFG_DUALBUFF() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x200) >> 9
}
func (o *ICM_Type) SetCFG_UIHASH(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x1000)|value<<12)
}
func (o *ICM_Type) GetCFG_UIHASH() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x1000) >> 12
}
func (o *ICM_Type) SetCFG_UALGO(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0xe000)|value<<13)
}
func (o *ICM_Type) GetCFG_UALGO() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0xe000) >> 13
}
func (o *ICM_Type) SetCFG_HAPROT(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x3f0000)|value<<16)
}
func (o *ICM_Type) GetCFG_HAPROT() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x3f0000) >> 16
}
func (o *ICM_Type) SetCFG_DAPROT(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x3f000000)|value<<24)
}
func (o *ICM_Type) GetCFG_DAPROT() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x3f000000) >> 24
}

// ICM.CTRL: Control
func (o *ICM_Type) SetCTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *ICM_Type) GetCTRL_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *ICM_Type) SetCTRL_DISABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *ICM_Type) GetCTRL_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *ICM_Type) SetCTRL_SWRST(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *ICM_Type) GetCTRL_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *ICM_Type) SetCTRL_REHASH(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xf0)|value<<4)
}
func (o *ICM_Type) GetCTRL_REHASH() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xf0) >> 4
}
func (o *ICM_Type) SetCTRL_RMDIS(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xf00)|value<<8)
}
func (o *ICM_Type) GetCTRL_RMDIS() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xf00) >> 8
}
func (o *ICM_Type) SetCTRL_RMEN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xf000)|value<<12)
}
func (o *ICM_Type) GetCTRL_RMEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xf000) >> 12
}

// ICM.SR: Status
func (o *ICM_Type) SetSR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *ICM_Type) GetSR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *ICM_Type) SetSR_RAWRMDIS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xf00)|value<<8)
}
func (o *ICM_Type) GetSR_RAWRMDIS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xf00) >> 8
}
func (o *ICM_Type) SetSR_RMDIS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xf000)|value<<12)
}
func (o *ICM_Type) GetSR_RMDIS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xf000) >> 12
}

// ICM.IER: Interrupt Enable
func (o *ICM_Type) SetIER_RHC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0xf)|value)
}
func (o *ICM_Type) GetIER_RHC() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0xf
}
func (o *ICM_Type) SetIER_RDM(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0xf0)|value<<4)
}
func (o *ICM_Type) GetIER_RDM() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0xf0) >> 4
}
func (o *ICM_Type) SetIER_RBE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0xf00)|value<<8)
}
func (o *ICM_Type) GetIER_RBE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0xf00) >> 8
}
func (o *ICM_Type) SetIER_RWC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0xf000)|value<<12)
}
func (o *ICM_Type) GetIER_RWC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0xf000) >> 12
}
func (o *ICM_Type) SetIER_REC(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0xf0000)|value<<16)
}
func (o *ICM_Type) GetIER_REC() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0xf0000) >> 16
}
func (o *ICM_Type) SetIER_RSU(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0xf00000)|value<<20)
}
func (o *ICM_Type) GetIER_RSU() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0xf00000) >> 20
}
func (o *ICM_Type) SetIER_URAD(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000000)|value<<24)
}
func (o *ICM_Type) GetIER_URAD() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000000) >> 24
}

// ICM.IDR: Interrupt Disable
func (o *ICM_Type) SetIDR_RHC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0xf)|value)
}
func (o *ICM_Type) GetIDR_RHC() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0xf
}
func (o *ICM_Type) SetIDR_RDM(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0xf0)|value<<4)
}
func (o *ICM_Type) GetIDR_RDM() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0xf0) >> 4
}
func (o *ICM_Type) SetIDR_RBE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0xf00)|value<<8)
}
func (o *ICM_Type) GetIDR_RBE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0xf00) >> 8
}
func (o *ICM_Type) SetIDR_RWC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0xf000)|value<<12)
}
func (o *ICM_Type) GetIDR_RWC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0xf000) >> 12
}
func (o *ICM_Type) SetIDR_REC(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0xf0000)|value<<16)
}
func (o *ICM_Type) GetIDR_REC() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0xf0000) >> 16
}
func (o *ICM_Type) SetIDR_RSU(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0xf00000)|value<<20)
}
func (o *ICM_Type) GetIDR_RSU() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0xf00000) >> 20
}
func (o *ICM_Type) SetIDR_URAD(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000000)|value<<24)
}
func (o *ICM_Type) GetIDR_URAD() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000000) >> 24
}

// ICM.IMR: Interrupt Mask
func (o *ICM_Type) SetIMR_RHC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0xf)|value)
}
func (o *ICM_Type) GetIMR_RHC() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0xf
}
func (o *ICM_Type) SetIMR_RDM(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0xf0)|value<<4)
}
func (o *ICM_Type) GetIMR_RDM() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0xf0) >> 4
}
func (o *ICM_Type) SetIMR_RBE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0xf00)|value<<8)
}
func (o *ICM_Type) GetIMR_RBE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0xf00) >> 8
}
func (o *ICM_Type) SetIMR_RWC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0xf000)|value<<12)
}
func (o *ICM_Type) GetIMR_RWC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0xf000) >> 12
}
func (o *ICM_Type) SetIMR_REC(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0xf0000)|value<<16)
}
func (o *ICM_Type) GetIMR_REC() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0xf0000) >> 16
}
func (o *ICM_Type) SetIMR_RSU(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0xf00000)|value<<20)
}
func (o *ICM_Type) GetIMR_RSU() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0xf00000) >> 20
}
func (o *ICM_Type) SetIMR_URAD(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000000)|value<<24)
}
func (o *ICM_Type) GetIMR_URAD() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000000) >> 24
}

// ICM.ISR: Interrupt Status
func (o *ICM_Type) SetISR_RHC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xf)|value)
}
func (o *ICM_Type) GetISR_RHC() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0xf
}
func (o *ICM_Type) SetISR_RDM(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xf0)|value<<4)
}
func (o *ICM_Type) GetISR_RDM() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0xf0) >> 4
}
func (o *ICM_Type) SetISR_RBE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xf00)|value<<8)
}
func (o *ICM_Type) GetISR_RBE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0xf00) >> 8
}
func (o *ICM_Type) SetISR_RWC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xf000)|value<<12)
}
func (o *ICM_Type) GetISR_RWC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0xf000) >> 12
}
func (o *ICM_Type) SetISR_REC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xf0000)|value<<16)
}
func (o *ICM_Type) GetISR_REC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0xf0000) >> 16
}
func (o *ICM_Type) SetISR_RSU(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xf00000)|value<<20)
}
func (o *ICM_Type) GetISR_RSU() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0xf00000) >> 20
}
func (o *ICM_Type) SetISR_URAD(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000000)|value<<24)
}
func (o *ICM_Type) GetISR_URAD() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000000) >> 24
}

// ICM.UASR: Undefined Access Status
func (o *ICM_Type) SetUASR_URAT(value uint32) {
	volatile.StoreUint32(&o.UASR.Reg, volatile.LoadUint32(&o.UASR.Reg)&^(0x7)|value)
}
func (o *ICM_Type) GetUASR_URAT() uint32 {
	return volatile.LoadUint32(&o.UASR.Reg) & 0x7
}

// ICM.DSCR: Region Descriptor Area Start Address
func (o *ICM_Type) SetDSCR_DASA(value uint32) {
	volatile.StoreUint32(&o.DSCR.Reg, volatile.LoadUint32(&o.DSCR.Reg)&^(0xffffffc0)|value<<6)
}
func (o *ICM_Type) GetDSCR_DASA() uint32 {
	return (volatile.LoadUint32(&o.DSCR.Reg) & 0xffffffc0) >> 6
}

// ICM.HASH: Region Hash Area Start Address
func (o *ICM_Type) SetHASH_HASA(value uint32) {
	volatile.StoreUint32(&o.HASH.Reg, volatile.LoadUint32(&o.HASH.Reg)&^(0xffffff80)|value<<7)
}
func (o *ICM_Type) GetHASH_HASA() uint32 {
	return (volatile.LoadUint32(&o.HASH.Reg) & 0xffffff80) >> 7
}

// ICM.UIHVAL: User Initial Hash Value n
func (o *ICM_Type) SetUIHVAL(idx int, value uint32) {
	volatile.StoreUint32(&o.UIHVAL[idx].Reg, value)
}
func (o *ICM_Type) GetUIHVAL(idx int) uint32 {
	return volatile.LoadUint32(&o.UIHVAL[idx].Reg)
}

// Inter-IC Sound Interface
type I2S_Type struct {
	CTRLA    volatile.Register8 // 0x0
	_        [3]byte
	CLKCTRL  [2]volatile.Register32 // 0x4
	INTENCLR volatile.Register16    // 0xC
	_        [2]byte
	INTENSET volatile.Register16 // 0x10
	_        [2]byte
	INTFLAG  volatile.Register16 // 0x14
	_        [2]byte
	SYNCBUSY volatile.Register16 // 0x18
	_        [6]byte
	TXCTRL   volatile.Register32 // 0x20
	RXCTRL   volatile.Register32 // 0x24
	_        [8]byte
	TXDATA   volatile.Register32 // 0x30
	RXDATA   volatile.Register32 // 0x34
}

// I2S.CTRLA: Control A
func (o *I2S_Type) SetCTRLA_SWRST(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetCTRLA_SWRST() uint8 {
	return volatile.LoadUint8(&o.CTRLA.Reg) & 0x1
}
func (o *I2S_Type) SetCTRLA_ENABLE(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetCTRLA_ENABLE() uint8 {
	return (volatile.LoadUint8(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetCTRLA_CKEN0(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetCTRLA_CKEN0() uint8 {
	return (volatile.LoadUint8(&o.CTRLA.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetCTRLA_CKEN1(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetCTRLA_CKEN1() uint8 {
	return (volatile.LoadUint8(&o.CTRLA.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetCTRLA_TXEN(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetCTRLA_TXEN() uint8 {
	return (volatile.LoadUint8(&o.CTRLA.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetCTRLA_RXEN(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetCTRLA_RXEN() uint8 {
	return (volatile.LoadUint8(&o.CTRLA.Reg) & 0x20) >> 5
}

// I2S.CLKCTRL: Clock Unit n Control
func (o *I2S_Type) SetCLKCTRL_SLOTSIZE(idx int, value uint32) {
	volatile.StoreUint32(&o.CLKCTRL[idx].Reg, volatile.LoadUint32(&o.CLKCTRL[idx].Reg)&^(0x3)|value)
}
func (o *I2S_Type) GetCLKCTRL_SLOTSIZE(idx int) uint32 {
	return volatile.LoadUint32(&o.CLKCTRL[idx].Reg) & 0x3
}
func (o *I2S_Type) SetCLKCTRL_NBSLOTS(idx int, value uint32) {
	volatile.StoreUint32(&o.CLKCTRL[idx].Reg, volatile.LoadUint32(&o.CLKCTRL[idx].Reg)&^(0x1c)|value<<2)
}
func (o *I2S_Type) GetCLKCTRL_NBSLOTS(idx int) uint32 {
	return (volatile.LoadUint32(&o.CLKCTRL[idx].Reg) & 0x1c) >> 2
}
func (o *I2S_Type) SetCLKCTRL_FSWIDTH(idx int, value uint32) {
	volatile.StoreUint32(&o.CLKCTRL[idx].Reg, volatile.LoadUint32(&o.CLKCTRL[idx].Reg)&^(0x60)|value<<5)
}
func (o *I2S_Type) GetCLKCTRL_FSWIDTH(idx int) uint32 {
	return (volatile.LoadUint32(&o.CLKCTRL[idx].Reg) & 0x60) >> 5
}
func (o *I2S_Type) SetCLKCTRL_BITDELAY(idx int, value uint32) {
	volatile.StoreUint32(&o.CLKCTRL[idx].Reg, volatile.LoadUint32(&o.CLKCTRL[idx].Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetCLKCTRL_BITDELAY(idx int) uint32 {
	return (volatile.LoadUint32(&o.CLKCTRL[idx].Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetCLKCTRL_FSSEL(idx int, value uint32) {
	volatile.StoreUint32(&o.CLKCTRL[idx].Reg, volatile.LoadUint32(&o.CLKCTRL[idx].Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetCLKCTRL_FSSEL(idx int) uint32 {
	return (volatile.LoadUint32(&o.CLKCTRL[idx].Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetCLKCTRL_FSINV(idx int, value uint32) {
	volatile.StoreUint32(&o.CLKCTRL[idx].Reg, volatile.LoadUint32(&o.CLKCTRL[idx].Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetCLKCTRL_FSINV(idx int) uint32 {
	return (volatile.LoadUint32(&o.CLKCTRL[idx].Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetCLKCTRL_FSOUTINV(idx int, value uint32) {
	volatile.StoreUint32(&o.CLKCTRL[idx].Reg, volatile.LoadUint32(&o.CLKCTRL[idx].Reg)&^(0x400)|value<<10)
}
func (o *I2S_Type) GetCLKCTRL_FSOUTINV(idx int) uint32 {
	return (volatile.LoadUint32(&o.CLKCTRL[idx].Reg) & 0x400) >> 10
}
func (o *I2S_Type) SetCLKCTRL_SCKSEL(idx int, value uint32) {
	volatile.StoreUint32(&o.CLKCTRL[idx].Reg, volatile.LoadUint32(&o.CLKCTRL[idx].Reg)&^(0x800)|value<<11)
}
func (o *I2S_Type) GetCLKCTRL_SCKSEL(idx int) uint32 {
	return (volatile.LoadUint32(&o.CLKCTRL[idx].Reg) & 0x800) >> 11
}
func (o *I2S_Type) SetCLKCTRL_SCKOUTINV(idx int, value uint32) {
	volatile.StoreUint32(&o.CLKCTRL[idx].Reg, volatile.LoadUint32(&o.CLKCTRL[idx].Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetCLKCTRL_SCKOUTINV(idx int) uint32 {
	return (volatile.LoadUint32(&o.CLKCTRL[idx].Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetCLKCTRL_MCKSEL(idx int, value uint32) {
	volatile.StoreUint32(&o.CLKCTRL[idx].Reg, volatile.LoadUint32(&o.CLKCTRL[idx].Reg)&^(0x2000)|value<<13)
}
func (o *I2S_Type) GetCLKCTRL_MCKSEL(idx int) uint32 {
	return (volatile.LoadUint32(&o.CLKCTRL[idx].Reg) & 0x2000) >> 13
}
func (o *I2S_Type) SetCLKCTRL_MCKEN(idx int, value uint32) {
	volatile.StoreUint32(&o.CLKCTRL[idx].Reg, volatile.LoadUint32(&o.CLKCTRL[idx].Reg)&^(0x4000)|value<<14)
}
func (o *I2S_Type) GetCLKCTRL_MCKEN(idx int) uint32 {
	return (volatile.LoadUint32(&o.CLKCTRL[idx].Reg) & 0x4000) >> 14
}
func (o *I2S_Type) SetCLKCTRL_MCKOUTINV(idx int, value uint32) {
	volatile.StoreUint32(&o.CLKCTRL[idx].Reg, volatile.LoadUint32(&o.CLKCTRL[idx].Reg)&^(0x8000)|value<<15)
}
func (o *I2S_Type) GetCLKCTRL_MCKOUTINV(idx int) uint32 {
	return (volatile.LoadUint32(&o.CLKCTRL[idx].Reg) & 0x8000) >> 15
}
func (o *I2S_Type) SetCLKCTRL_MCKDIV(idx int, value uint32) {
	volatile.StoreUint32(&o.CLKCTRL[idx].Reg, volatile.LoadUint32(&o.CLKCTRL[idx].Reg)&^(0x3f0000)|value<<16)
}
func (o *I2S_Type) GetCLKCTRL_MCKDIV(idx int) uint32 {
	return (volatile.LoadUint32(&o.CLKCTRL[idx].Reg) & 0x3f0000) >> 16
}
func (o *I2S_Type) SetCLKCTRL_MCKOUTDIV(idx int, value uint32) {
	volatile.StoreUint32(&o.CLKCTRL[idx].Reg, volatile.LoadUint32(&o.CLKCTRL[idx].Reg)&^(0x3f000000)|value<<24)
}
func (o *I2S_Type) GetCLKCTRL_MCKOUTDIV(idx int) uint32 {
	return (volatile.LoadUint32(&o.CLKCTRL[idx].Reg) & 0x3f000000) >> 24
}

// I2S.INTENCLR: Interrupt Enable Clear
func (o *I2S_Type) SetINTENCLR_RXRDY0(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetINTENCLR_RXRDY0() uint16 {
	return volatile.LoadUint16(&o.INTENCLR.Reg) & 0x1
}
func (o *I2S_Type) SetINTENCLR_RXRDY1(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetINTENCLR_RXRDY1() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetINTENCLR_RXOR0(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetINTENCLR_RXOR0() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetINTENCLR_RXOR1(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetINTENCLR_RXOR1() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetINTENCLR_TXRDY0(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetINTENCLR_TXRDY0() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetINTENCLR_TXRDY1(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetINTENCLR_TXRDY1() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetINTENCLR_TXUR0(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetINTENCLR_TXUR0() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetINTENCLR_TXUR1(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x2000)|value<<13)
}
func (o *I2S_Type) GetINTENCLR_TXUR1() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x2000) >> 13
}

// I2S.INTENSET: Interrupt Enable Set
func (o *I2S_Type) SetINTENSET_RXRDY0(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetINTENSET_RXRDY0() uint16 {
	return volatile.LoadUint16(&o.INTENSET.Reg) & 0x1
}
func (o *I2S_Type) SetINTENSET_RXRDY1(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetINTENSET_RXRDY1() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetINTENSET_RXOR0(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetINTENSET_RXOR0() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetINTENSET_RXOR1(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetINTENSET_RXOR1() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetINTENSET_TXRDY0(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetINTENSET_TXRDY0() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetINTENSET_TXRDY1(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetINTENSET_TXRDY1() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetINTENSET_TXUR0(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetINTENSET_TXUR0() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetINTENSET_TXUR1(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x2000)|value<<13)
}
func (o *I2S_Type) GetINTENSET_TXUR1() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x2000) >> 13
}

// I2S.INTFLAG: Interrupt Flag Status and Clear
func (o *I2S_Type) SetINTFLAG_RXRDY0(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetINTFLAG_RXRDY0() uint16 {
	return volatile.LoadUint16(&o.INTFLAG.Reg) & 0x1
}
func (o *I2S_Type) SetINTFLAG_RXRDY1(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetINTFLAG_RXRDY1() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetINTFLAG_RXOR0(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetINTFLAG_RXOR0() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetINTFLAG_RXOR1(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetINTFLAG_RXOR1() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetINTFLAG_TXRDY0(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetINTFLAG_TXRDY0() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetINTFLAG_TXRDY1(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetINTFLAG_TXRDY1() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetINTFLAG_TXUR0(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetINTFLAG_TXUR0() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetINTFLAG_TXUR1(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x2000)|value<<13)
}
func (o *I2S_Type) GetINTFLAG_TXUR1() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x2000) >> 13
}

// I2S.SYNCBUSY: Synchronization Status
func (o *I2S_Type) SetSYNCBUSY_SWRST(value uint16) {
	volatile.StoreUint16(&o.SYNCBUSY.Reg, volatile.LoadUint16(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetSYNCBUSY_SWRST() uint16 {
	return volatile.LoadUint16(&o.SYNCBUSY.Reg) & 0x1
}
func (o *I2S_Type) SetSYNCBUSY_ENABLE(value uint16) {
	volatile.StoreUint16(&o.SYNCBUSY.Reg, volatile.LoadUint16(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetSYNCBUSY_ENABLE() uint16 {
	return (volatile.LoadUint16(&o.SYNCBUSY.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetSYNCBUSY_CKEN0(value uint16) {
	volatile.StoreUint16(&o.SYNCBUSY.Reg, volatile.LoadUint16(&o.SYNCBUSY.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetSYNCBUSY_CKEN0() uint16 {
	return (volatile.LoadUint16(&o.SYNCBUSY.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetSYNCBUSY_CKEN1(value uint16) {
	volatile.StoreUint16(&o.SYNCBUSY.Reg, volatile.LoadUint16(&o.SYNCBUSY.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetSYNCBUSY_CKEN1() uint16 {
	return (volatile.LoadUint16(&o.SYNCBUSY.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetSYNCBUSY_TXEN(value uint16) {
	volatile.StoreUint16(&o.SYNCBUSY.Reg, volatile.LoadUint16(&o.SYNCBUSY.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetSYNCBUSY_TXEN() uint16 {
	return (volatile.LoadUint16(&o.SYNCBUSY.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetSYNCBUSY_RXEN(value uint16) {
	volatile.StoreUint16(&o.SYNCBUSY.Reg, volatile.LoadUint16(&o.SYNCBUSY.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetSYNCBUSY_RXEN() uint16 {
	return (volatile.LoadUint16(&o.SYNCBUSY.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetSYNCBUSY_TXDATA(value uint16) {
	volatile.StoreUint16(&o.SYNCBUSY.Reg, volatile.LoadUint16(&o.SYNCBUSY.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetSYNCBUSY_TXDATA() uint16 {
	return (volatile.LoadUint16(&o.SYNCBUSY.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetSYNCBUSY_RXDATA(value uint16) {
	volatile.StoreUint16(&o.SYNCBUSY.Reg, volatile.LoadUint16(&o.SYNCBUSY.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetSYNCBUSY_RXDATA() uint16 {
	return (volatile.LoadUint16(&o.SYNCBUSY.Reg) & 0x200) >> 9
}

// I2S.TXCTRL: Tx Serializer Control
func (o *I2S_Type) SetTXCTRL_SERMODE(value uint32) {
	volatile.StoreUint32(&o.TXCTRL.Reg, volatile.LoadUint32(&o.TXCTRL.Reg)&^(0x3)|value)
}
func (o *I2S_Type) GetTXCTRL_SERMODE() uint32 {
	return volatile.LoadUint32(&o.TXCTRL.Reg) & 0x3
}
func (o *I2S_Type) SetTXCTRL_TXDEFAULT(value uint32) {
	volatile.StoreUint32(&o.TXCTRL.Reg, volatile.LoadUint32(&o.TXCTRL.Reg)&^(0xc)|value<<2)
}
func (o *I2S_Type) GetTXCTRL_TXDEFAULT() uint32 {
	return (volatile.LoadUint32(&o.TXCTRL.Reg) & 0xc) >> 2
}
func (o *I2S_Type) SetTXCTRL_TXSAME(value uint32) {
	volatile.StoreUint32(&o.TXCTRL.Reg, volatile.LoadUint32(&o.TXCTRL.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetTXCTRL_TXSAME() uint32 {
	return (volatile.LoadUint32(&o.TXCTRL.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetTXCTRL_CLKSEL(value uint32) {
	volatile.StoreUint32(&o.TXCTRL.Reg, volatile.LoadUint32(&o.TXCTRL.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetTXCTRL_CLKSEL() uint32 {
	return (volatile.LoadUint32(&o.TXCTRL.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetTXCTRL_SLOTADJ(value uint32) {
	volatile.StoreUint32(&o.TXCTRL.Reg, volatile.LoadUint32(&o.TXCTRL.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetTXCTRL_SLOTADJ() uint32 {
	return (volatile.LoadUint32(&o.TXCTRL.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetTXCTRL_DATASIZE(value uint32) {
	volatile.StoreUint32(&o.TXCTRL.Reg, volatile.LoadUint32(&o.TXCTRL.Reg)&^(0x700)|value<<8)
}
func (o *I2S_Type) GetTXCTRL_DATASIZE() uint32 {
	return (volatile.LoadUint32(&o.TXCTRL.Reg) & 0x700) >> 8
}
func (o *I2S_Type) SetTXCTRL_WORDADJ(value uint32) {
	volatile.StoreUint32(&o.TXCTRL.Reg, volatile.LoadUint32(&o.TXCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetTXCTRL_WORDADJ() uint32 {
	return (volatile.LoadUint32(&o.TXCTRL.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetTXCTRL_EXTEND(value uint32) {
	volatile.StoreUint32(&o.TXCTRL.Reg, volatile.LoadUint32(&o.TXCTRL.Reg)&^(0x6000)|value<<13)
}
func (o *I2S_Type) GetTXCTRL_EXTEND() uint32 {
	return (volatile.LoadUint32(&o.TXCTRL.Reg) & 0x6000) >> 13
}
func (o *I2S_Type) SetTXCTRL_BITREV(value uint32) {
	volatile.StoreUint32(&o.TXCTRL.Reg, volatile.LoadUint32(&o.TXCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *I2S_Type) GetTXCTRL_BITREV() uint32 {
	return (volatile.LoadUint32(&o.TXCTRL.Reg) & 0x8000) >> 15
}
func (o *I2S_Type) SetTXCTRL_SLOTDIS0(value uint32) {
	volatile.StoreUint32(&o.TXCTRL.Reg, volatile.LoadUint32(&o.TXCTRL.Reg)&^(0x10000)|value<<16)
}
func (o *I2S_Type) GetTXCTRL_SLOTDIS0() uint32 {
	return (volatile.LoadUint32(&o.TXCTRL.Reg) & 0x10000) >> 16
}
func (o *I2S_Type) SetTXCTRL_SLOTDIS1(value uint32) {
	volatile.StoreUint32(&o.TXCTRL.Reg, volatile.LoadUint32(&o.TXCTRL.Reg)&^(0x20000)|value<<17)
}
func (o *I2S_Type) GetTXCTRL_SLOTDIS1() uint32 {
	return (volatile.LoadUint32(&o.TXCTRL.Reg) & 0x20000) >> 17
}
func (o *I2S_Type) SetTXCTRL_SLOTDIS2(value uint32) {
	volatile.StoreUint32(&o.TXCTRL.Reg, volatile.LoadUint32(&o.TXCTRL.Reg)&^(0x40000)|value<<18)
}
func (o *I2S_Type) GetTXCTRL_SLOTDIS2() uint32 {
	return (volatile.LoadUint32(&o.TXCTRL.Reg) & 0x40000) >> 18
}
func (o *I2S_Type) SetTXCTRL_SLOTDIS3(value uint32) {
	volatile.StoreUint32(&o.TXCTRL.Reg, volatile.LoadUint32(&o.TXCTRL.Reg)&^(0x80000)|value<<19)
}
func (o *I2S_Type) GetTXCTRL_SLOTDIS3() uint32 {
	return (volatile.LoadUint32(&o.TXCTRL.Reg) & 0x80000) >> 19
}
func (o *I2S_Type) SetTXCTRL_SLOTDIS4(value uint32) {
	volatile.StoreUint32(&o.TXCTRL.Reg, volatile.LoadUint32(&o.TXCTRL.Reg)&^(0x100000)|value<<20)
}
func (o *I2S_Type) GetTXCTRL_SLOTDIS4() uint32 {
	return (volatile.LoadUint32(&o.TXCTRL.Reg) & 0x100000) >> 20
}
func (o *I2S_Type) SetTXCTRL_SLOTDIS5(value uint32) {
	volatile.StoreUint32(&o.TXCTRL.Reg, volatile.LoadUint32(&o.TXCTRL.Reg)&^(0x200000)|value<<21)
}
func (o *I2S_Type) GetTXCTRL_SLOTDIS5() uint32 {
	return (volatile.LoadUint32(&o.TXCTRL.Reg) & 0x200000) >> 21
}
func (o *I2S_Type) SetTXCTRL_SLOTDIS6(value uint32) {
	volatile.StoreUint32(&o.TXCTRL.Reg, volatile.LoadUint32(&o.TXCTRL.Reg)&^(0x400000)|value<<22)
}
func (o *I2S_Type) GetTXCTRL_SLOTDIS6() uint32 {
	return (volatile.LoadUint32(&o.TXCTRL.Reg) & 0x400000) >> 22
}
func (o *I2S_Type) SetTXCTRL_SLOTDIS7(value uint32) {
	volatile.StoreUint32(&o.TXCTRL.Reg, volatile.LoadUint32(&o.TXCTRL.Reg)&^(0x800000)|value<<23)
}
func (o *I2S_Type) GetTXCTRL_SLOTDIS7() uint32 {
	return (volatile.LoadUint32(&o.TXCTRL.Reg) & 0x800000) >> 23
}
func (o *I2S_Type) SetTXCTRL_MONO(value uint32) {
	volatile.StoreUint32(&o.TXCTRL.Reg, volatile.LoadUint32(&o.TXCTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S_Type) GetTXCTRL_MONO() uint32 {
	return (volatile.LoadUint32(&o.TXCTRL.Reg) & 0x1000000) >> 24
}
func (o *I2S_Type) SetTXCTRL_DMA(value uint32) {
	volatile.StoreUint32(&o.TXCTRL.Reg, volatile.LoadUint32(&o.TXCTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S_Type) GetTXCTRL_DMA() uint32 {
	return (volatile.LoadUint32(&o.TXCTRL.Reg) & 0x2000000) >> 25
}

// I2S.RXCTRL: Rx Serializer Control
func (o *I2S_Type) SetRXCTRL_SERMODE(value uint32) {
	volatile.StoreUint32(&o.RXCTRL.Reg, volatile.LoadUint32(&o.RXCTRL.Reg)&^(0x3)|value)
}
func (o *I2S_Type) GetRXCTRL_SERMODE() uint32 {
	return volatile.LoadUint32(&o.RXCTRL.Reg) & 0x3
}
func (o *I2S_Type) SetRXCTRL_CLKSEL(value uint32) {
	volatile.StoreUint32(&o.RXCTRL.Reg, volatile.LoadUint32(&o.RXCTRL.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetRXCTRL_CLKSEL() uint32 {
	return (volatile.LoadUint32(&o.RXCTRL.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetRXCTRL_SLOTADJ(value uint32) {
	volatile.StoreUint32(&o.RXCTRL.Reg, volatile.LoadUint32(&o.RXCTRL.Reg)&^(0x80)|value<<7)
}
func (o *I2S_Type) GetRXCTRL_SLOTADJ() uint32 {
	return (volatile.LoadUint32(&o.RXCTRL.Reg) & 0x80) >> 7
}
func (o *I2S_Type) SetRXCTRL_DATASIZE(value uint32) {
	volatile.StoreUint32(&o.RXCTRL.Reg, volatile.LoadUint32(&o.RXCTRL.Reg)&^(0x700)|value<<8)
}
func (o *I2S_Type) GetRXCTRL_DATASIZE() uint32 {
	return (volatile.LoadUint32(&o.RXCTRL.Reg) & 0x700) >> 8
}
func (o *I2S_Type) SetRXCTRL_WORDADJ(value uint32) {
	volatile.StoreUint32(&o.RXCTRL.Reg, volatile.LoadUint32(&o.RXCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetRXCTRL_WORDADJ() uint32 {
	return (volatile.LoadUint32(&o.RXCTRL.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetRXCTRL_EXTEND(value uint32) {
	volatile.StoreUint32(&o.RXCTRL.Reg, volatile.LoadUint32(&o.RXCTRL.Reg)&^(0x6000)|value<<13)
}
func (o *I2S_Type) GetRXCTRL_EXTEND() uint32 {
	return (volatile.LoadUint32(&o.RXCTRL.Reg) & 0x6000) >> 13
}
func (o *I2S_Type) SetRXCTRL_BITREV(value uint32) {
	volatile.StoreUint32(&o.RXCTRL.Reg, volatile.LoadUint32(&o.RXCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *I2S_Type) GetRXCTRL_BITREV() uint32 {
	return (volatile.LoadUint32(&o.RXCTRL.Reg) & 0x8000) >> 15
}
func (o *I2S_Type) SetRXCTRL_SLOTDIS0(value uint32) {
	volatile.StoreUint32(&o.RXCTRL.Reg, volatile.LoadUint32(&o.RXCTRL.Reg)&^(0x10000)|value<<16)
}
func (o *I2S_Type) GetRXCTRL_SLOTDIS0() uint32 {
	return (volatile.LoadUint32(&o.RXCTRL.Reg) & 0x10000) >> 16
}
func (o *I2S_Type) SetRXCTRL_SLOTDIS1(value uint32) {
	volatile.StoreUint32(&o.RXCTRL.Reg, volatile.LoadUint32(&o.RXCTRL.Reg)&^(0x20000)|value<<17)
}
func (o *I2S_Type) GetRXCTRL_SLOTDIS1() uint32 {
	return (volatile.LoadUint32(&o.RXCTRL.Reg) & 0x20000) >> 17
}
func (o *I2S_Type) SetRXCTRL_SLOTDIS2(value uint32) {
	volatile.StoreUint32(&o.RXCTRL.Reg, volatile.LoadUint32(&o.RXCTRL.Reg)&^(0x40000)|value<<18)
}
func (o *I2S_Type) GetRXCTRL_SLOTDIS2() uint32 {
	return (volatile.LoadUint32(&o.RXCTRL.Reg) & 0x40000) >> 18
}
func (o *I2S_Type) SetRXCTRL_SLOTDIS3(value uint32) {
	volatile.StoreUint32(&o.RXCTRL.Reg, volatile.LoadUint32(&o.RXCTRL.Reg)&^(0x80000)|value<<19)
}
func (o *I2S_Type) GetRXCTRL_SLOTDIS3() uint32 {
	return (volatile.LoadUint32(&o.RXCTRL.Reg) & 0x80000) >> 19
}
func (o *I2S_Type) SetRXCTRL_SLOTDIS4(value uint32) {
	volatile.StoreUint32(&o.RXCTRL.Reg, volatile.LoadUint32(&o.RXCTRL.Reg)&^(0x100000)|value<<20)
}
func (o *I2S_Type) GetRXCTRL_SLOTDIS4() uint32 {
	return (volatile.LoadUint32(&o.RXCTRL.Reg) & 0x100000) >> 20
}
func (o *I2S_Type) SetRXCTRL_SLOTDIS5(value uint32) {
	volatile.StoreUint32(&o.RXCTRL.Reg, volatile.LoadUint32(&o.RXCTRL.Reg)&^(0x200000)|value<<21)
}
func (o *I2S_Type) GetRXCTRL_SLOTDIS5() uint32 {
	return (volatile.LoadUint32(&o.RXCTRL.Reg) & 0x200000) >> 21
}
func (o *I2S_Type) SetRXCTRL_SLOTDIS6(value uint32) {
	volatile.StoreUint32(&o.RXCTRL.Reg, volatile.LoadUint32(&o.RXCTRL.Reg)&^(0x400000)|value<<22)
}
func (o *I2S_Type) GetRXCTRL_SLOTDIS6() uint32 {
	return (volatile.LoadUint32(&o.RXCTRL.Reg) & 0x400000) >> 22
}
func (o *I2S_Type) SetRXCTRL_SLOTDIS7(value uint32) {
	volatile.StoreUint32(&o.RXCTRL.Reg, volatile.LoadUint32(&o.RXCTRL.Reg)&^(0x800000)|value<<23)
}
func (o *I2S_Type) GetRXCTRL_SLOTDIS7() uint32 {
	return (volatile.LoadUint32(&o.RXCTRL.Reg) & 0x800000) >> 23
}
func (o *I2S_Type) SetRXCTRL_MONO(value uint32) {
	volatile.StoreUint32(&o.RXCTRL.Reg, volatile.LoadUint32(&o.RXCTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S_Type) GetRXCTRL_MONO() uint32 {
	return (volatile.LoadUint32(&o.RXCTRL.Reg) & 0x1000000) >> 24
}
func (o *I2S_Type) SetRXCTRL_DMA(value uint32) {
	volatile.StoreUint32(&o.RXCTRL.Reg, volatile.LoadUint32(&o.RXCTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S_Type) GetRXCTRL_DMA() uint32 {
	return (volatile.LoadUint32(&o.RXCTRL.Reg) & 0x2000000) >> 25
}
func (o *I2S_Type) SetRXCTRL_RXLOOP(value uint32) {
	volatile.StoreUint32(&o.RXCTRL.Reg, volatile.LoadUint32(&o.RXCTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *I2S_Type) GetRXCTRL_RXLOOP() uint32 {
	return (volatile.LoadUint32(&o.RXCTRL.Reg) & 0x4000000) >> 26
}

// I2S.TXDATA: Tx Data
func (o *I2S_Type) SetTXDATA(value uint32) {
	volatile.StoreUint32(&o.TXDATA.Reg, value)
}
func (o *I2S_Type) GetTXDATA() uint32 {
	return volatile.LoadUint32(&o.TXDATA.Reg)
}

// I2S.RXDATA: Rx Data
func (o *I2S_Type) SetRXDATA(value uint32) {
	volatile.StoreUint32(&o.RXDATA.Reg, value)
}
func (o *I2S_Type) GetRXDATA() uint32 {
	return volatile.LoadUint32(&o.RXDATA.Reg)
}

// Main Clock
type MCLK_Type struct {
	_        byte
	INTENCLR volatile.Register8 // 0x1
	INTENSET volatile.Register8 // 0x2
	INTFLAG  volatile.Register8 // 0x3
	HSDIV    volatile.Register8 // 0x4
	CPUDIV   volatile.Register8 // 0x5
	_        [10]byte
	AHBMASK  volatile.Register32 // 0x10
	APBAMASK volatile.Register32 // 0x14
	APBBMASK volatile.Register32 // 0x18
	APBCMASK volatile.Register32 // 0x1C
	APBDMASK volatile.Register32 // 0x20
}

// MCLK.INTENCLR: Interrupt Enable Clear
func (o *MCLK_Type) SetINTENCLR_CKRDY(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *MCLK_Type) GetINTENCLR_CKRDY() uint8 {
	return volatile.LoadUint8(&o.INTENCLR.Reg) & 0x1
}

// MCLK.INTENSET: Interrupt Enable Set
func (o *MCLK_Type) SetINTENSET_CKRDY(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *MCLK_Type) GetINTENSET_CKRDY() uint8 {
	return volatile.LoadUint8(&o.INTENSET.Reg) & 0x1
}

// MCLK.INTFLAG: Interrupt Flag Status and Clear
func (o *MCLK_Type) SetINTFLAG_CKRDY(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *MCLK_Type) GetINTFLAG_CKRDY() uint8 {
	return volatile.LoadUint8(&o.INTFLAG.Reg) & 0x1
}

// MCLK.HSDIV: HS Clock Division
func (o *MCLK_Type) SetHSDIV(value uint8) {
	volatile.StoreUint8(&o.HSDIV.Reg, value)
}
func (o *MCLK_Type) GetHSDIV() uint8 {
	return volatile.LoadUint8(&o.HSDIV.Reg)
}

// MCLK.CPUDIV: CPU Clock Division
func (o *MCLK_Type) SetCPUDIV(value uint8) {
	volatile.StoreUint8(&o.CPUDIV.Reg, value)
}
func (o *MCLK_Type) GetCPUDIV() uint8 {
	return volatile.LoadUint8(&o.CPUDIV.Reg)
}

// MCLK.AHBMASK: AHB Mask
func (o *MCLK_Type) SetAHBMASK_HPB0_(value uint32) {
	volatile.StoreUint32(&o.AHBMASK.Reg, volatile.LoadUint32(&o.AHBMASK.Reg)&^(0x1)|value)
}
func (o *MCLK_Type) GetAHBMASK_HPB0_() uint32 {
	return volatile.LoadUint32(&o.AHBMASK.Reg) & 0x1
}
func (o *MCLK_Type) SetAHBMASK_HPB1_(value uint32) {
	volatile.StoreUint32(&o.AHBMASK.Reg, volatile.LoadUint32(&o.AHBMASK.Reg)&^(0x2)|value<<1)
}
func (o *MCLK_Type) GetAHBMASK_HPB1_() uint32 {
	return (volatile.LoadUint32(&o.AHBMASK.Reg) & 0x2) >> 1
}
func (o *MCLK_Type) SetAHBMASK_HPB2_(value uint32) {
	volatile.StoreUint32(&o.AHBMASK.Reg, volatile.LoadUint32(&o.AHBMASK.Reg)&^(0x4)|value<<2)
}
func (o *MCLK_Type) GetAHBMASK_HPB2_() uint32 {
	return (volatile.LoadUint32(&o.AHBMASK.Reg) & 0x4) >> 2
}
func (o *MCLK_Type) SetAHBMASK_HPB3_(value uint32) {
	volatile.StoreUint32(&o.AHBMASK.Reg, volatile.LoadUint32(&o.AHBMASK.Reg)&^(0x8)|value<<3)
}
func (o *MCLK_Type) GetAHBMASK_HPB3_() uint32 {
	return (volatile.LoadUint32(&o.AHBMASK.Reg) & 0x8) >> 3
}
func (o *MCLK_Type) SetAHBMASK_DSU_(value uint32) {
	volatile.StoreUint32(&o.AHBMASK.Reg, volatile.LoadUint32(&o.AHBMASK.Reg)&^(0x10)|value<<4)
}
func (o *MCLK_Type) GetAHBMASK_DSU_() uint32 {
	return (volatile.LoadUint32(&o.AHBMASK.Reg) & 0x10) >> 4
}
func (o *MCLK_Type) SetAHBMASK_HMATRIX_(value uint32) {
	volatile.StoreUint32(&o.AHBMASK.Reg, volatile.LoadUint32(&o.AHBMASK.Reg)&^(0x20)|value<<5)
}
func (o *MCLK_Type) GetAHBMASK_HMATRIX_() uint32 {
	return (volatile.LoadUint32(&o.AHBMASK.Reg) & 0x20) >> 5
}
func (o *MCLK_Type) SetAHBMASK_NVMCTRL_(value uint32) {
	volatile.StoreUint32(&o.AHBMASK.Reg, volatile.LoadUint32(&o.AHBMASK.Reg)&^(0x40)|value<<6)
}
func (o *MCLK_Type) GetAHBMASK_NVMCTRL_() uint32 {
	return (volatile.LoadUint32(&o.AHBMASK.Reg) & 0x40) >> 6
}
func (o *MCLK_Type) SetAHBMASK_HSRAM_(value uint32) {
	volatile.StoreUint32(&o.AHBMASK.Reg, volatile.LoadUint32(&o.AHBMASK.Reg)&^(0x80)|value<<7)
}
func (o *MCLK_Type) GetAHBMASK_HSRAM_() uint32 {
	return (volatile.LoadUint32(&o.AHBMASK.Reg) & 0x80) >> 7
}
func (o *MCLK_Type) SetAHBMASK_CMCC_(value uint32) {
	volatile.StoreUint32(&o.AHBMASK.Reg, volatile.LoadUint32(&o.AHBMASK.Reg)&^(0x100)|value<<8)
}
func (o *MCLK_Type) GetAHBMASK_CMCC_() uint32 {
	return (volatile.LoadUint32(&o.AHBMASK.Reg) & 0x100) >> 8
}
func (o *MCLK_Type) SetAHBMASK_DMAC_(value uint32) {
	volatile.StoreUint32(&o.AHBMASK.Reg, volatile.LoadUint32(&o.AHBMASK.Reg)&^(0x200)|value<<9)
}
func (o *MCLK_Type) GetAHBMASK_DMAC_() uint32 {
	return (volatile.LoadUint32(&o.AHBMASK.Reg) & 0x200) >> 9
}
func (o *MCLK_Type) SetAHBMASK_USB_(value uint32) {
	volatile.StoreUint32(&o.AHBMASK.Reg, volatile.LoadUint32(&o.AHBMASK.Reg)&^(0x400)|value<<10)
}
func (o *MCLK_Type) GetAHBMASK_USB_() uint32 {
	return (volatile.LoadUint32(&o.AHBMASK.Reg) & 0x400) >> 10
}
func (o *MCLK_Type) SetAHBMASK_BKUPRAM_(value uint32) {
	volatile.StoreUint32(&o.AHBMASK.Reg, volatile.LoadUint32(&o.AHBMASK.Reg)&^(0x800)|value<<11)
}
func (o *MCLK_Type) GetAHBMASK_BKUPRAM_() uint32 {
	return (volatile.LoadUint32(&o.AHBMASK.Reg) & 0x800) >> 11
}
func (o *MCLK_Type) SetAHBMASK_PAC_(value uint32) {
	volatile.StoreUint32(&o.AHBMASK.Reg, volatile.LoadUint32(&o.AHBMASK.Reg)&^(0x1000)|value<<12)
}
func (o *MCLK_Type) GetAHBMASK_PAC_() uint32 {
	return (volatile.LoadUint32(&o.AHBMASK.Reg) & 0x1000) >> 12
}
func (o *MCLK_Type) SetAHBMASK_QSPI_(value uint32) {
	volatile.StoreUint32(&o.AHBMASK.Reg, volatile.LoadUint32(&o.AHBMASK.Reg)&^(0x2000)|value<<13)
}
func (o *MCLK_Type) GetAHBMASK_QSPI_() uint32 {
	return (volatile.LoadUint32(&o.AHBMASK.Reg) & 0x2000) >> 13
}
func (o *MCLK_Type) SetAHBMASK_GMAC_(value uint32) {
	volatile.StoreUint32(&o.AHBMASK.Reg, volatile.LoadUint32(&o.AHBMASK.Reg)&^(0x4000)|value<<14)
}
func (o *MCLK_Type) GetAHBMASK_GMAC_() uint32 {
	return (volatile.LoadUint32(&o.AHBMASK.Reg) & 0x4000) >> 14
}
func (o *MCLK_Type) SetAHBMASK_SDHC0_(value uint32) {
	volatile.StoreUint32(&o.AHBMASK.Reg, volatile.LoadUint32(&o.AHBMASK.Reg)&^(0x8000)|value<<15)
}
func (o *MCLK_Type) GetAHBMASK_SDHC0_() uint32 {
	return (volatile.LoadUint32(&o.AHBMASK.Reg) & 0x8000) >> 15
}
func (o *MCLK_Type) SetAHBMASK_ICM_(value uint32) {
	volatile.StoreUint32(&o.AHBMASK.Reg, volatile.LoadUint32(&o.AHBMASK.Reg)&^(0x80000)|value<<19)
}
func (o *MCLK_Type) GetAHBMASK_ICM_() uint32 {
	return (volatile.LoadUint32(&o.AHBMASK.Reg) & 0x80000) >> 19
}
func (o *MCLK_Type) SetAHBMASK_PUKCC_(value uint32) {
	volatile.StoreUint32(&o.AHBMASK.Reg, volatile.LoadUint32(&o.AHBMASK.Reg)&^(0x100000)|value<<20)
}
func (o *MCLK_Type) GetAHBMASK_PUKCC_() uint32 {
	return (volatile.LoadUint32(&o.AHBMASK.Reg) & 0x100000) >> 20
}
func (o *MCLK_Type) SetAHBMASK_QSPI_2X_(value uint32) {
	volatile.StoreUint32(&o.AHBMASK.Reg, volatile.LoadUint32(&o.AHBMASK.Reg)&^(0x200000)|value<<21)
}
func (o *MCLK_Type) GetAHBMASK_QSPI_2X_() uint32 {
	return (volatile.LoadUint32(&o.AHBMASK.Reg) & 0x200000) >> 21
}
func (o *MCLK_Type) SetAHBMASK_NVMCTRL_SMEEPROM_(value uint32) {
	volatile.StoreUint32(&o.AHBMASK.Reg, volatile.LoadUint32(&o.AHBMASK.Reg)&^(0x400000)|value<<22)
}
func (o *MCLK_Type) GetAHBMASK_NVMCTRL_SMEEPROM_() uint32 {
	return (volatile.LoadUint32(&o.AHBMASK.Reg) & 0x400000) >> 22
}
func (o *MCLK_Type) SetAHBMASK_NVMCTRL_CACHE_(value uint32) {
	volatile.StoreUint32(&o.AHBMASK.Reg, volatile.LoadUint32(&o.AHBMASK.Reg)&^(0x800000)|value<<23)
}
func (o *MCLK_Type) GetAHBMASK_NVMCTRL_CACHE_() uint32 {
	return (volatile.LoadUint32(&o.AHBMASK.Reg) & 0x800000) >> 23
}

// MCLK.APBAMASK: APBA Mask
func (o *MCLK_Type) SetAPBAMASK_PAC_(value uint32) {
	volatile.StoreUint32(&o.APBAMASK.Reg, volatile.LoadUint32(&o.APBAMASK.Reg)&^(0x1)|value)
}
func (o *MCLK_Type) GetAPBAMASK_PAC_() uint32 {
	return volatile.LoadUint32(&o.APBAMASK.Reg) & 0x1
}
func (o *MCLK_Type) SetAPBAMASK_PM_(value uint32) {
	volatile.StoreUint32(&o.APBAMASK.Reg, volatile.LoadUint32(&o.APBAMASK.Reg)&^(0x2)|value<<1)
}
func (o *MCLK_Type) GetAPBAMASK_PM_() uint32 {
	return (volatile.LoadUint32(&o.APBAMASK.Reg) & 0x2) >> 1
}
func (o *MCLK_Type) SetAPBAMASK_MCLK_(value uint32) {
	volatile.StoreUint32(&o.APBAMASK.Reg, volatile.LoadUint32(&o.APBAMASK.Reg)&^(0x4)|value<<2)
}
func (o *MCLK_Type) GetAPBAMASK_MCLK_() uint32 {
	return (volatile.LoadUint32(&o.APBAMASK.Reg) & 0x4) >> 2
}
func (o *MCLK_Type) SetAPBAMASK_RSTC_(value uint32) {
	volatile.StoreUint32(&o.APBAMASK.Reg, volatile.LoadUint32(&o.APBAMASK.Reg)&^(0x8)|value<<3)
}
func (o *MCLK_Type) GetAPBAMASK_RSTC_() uint32 {
	return (volatile.LoadUint32(&o.APBAMASK.Reg) & 0x8) >> 3
}
func (o *MCLK_Type) SetAPBAMASK_OSCCTRL_(value uint32) {
	volatile.StoreUint32(&o.APBAMASK.Reg, volatile.LoadUint32(&o.APBAMASK.Reg)&^(0x10)|value<<4)
}
func (o *MCLK_Type) GetAPBAMASK_OSCCTRL_() uint32 {
	return (volatile.LoadUint32(&o.APBAMASK.Reg) & 0x10) >> 4
}
func (o *MCLK_Type) SetAPBAMASK_OSC32KCTRL_(value uint32) {
	volatile.StoreUint32(&o.APBAMASK.Reg, volatile.LoadUint32(&o.APBAMASK.Reg)&^(0x20)|value<<5)
}
func (o *MCLK_Type) GetAPBAMASK_OSC32KCTRL_() uint32 {
	return (volatile.LoadUint32(&o.APBAMASK.Reg) & 0x20) >> 5
}
func (o *MCLK_Type) SetAPBAMASK_SUPC_(value uint32) {
	volatile.StoreUint32(&o.APBAMASK.Reg, volatile.LoadUint32(&o.APBAMASK.Reg)&^(0x40)|value<<6)
}
func (o *MCLK_Type) GetAPBAMASK_SUPC_() uint32 {
	return (volatile.LoadUint32(&o.APBAMASK.Reg) & 0x40) >> 6
}
func (o *MCLK_Type) SetAPBAMASK_GCLK_(value uint32) {
	volatile.StoreUint32(&o.APBAMASK.Reg, volatile.LoadUint32(&o.APBAMASK.Reg)&^(0x80)|value<<7)
}
func (o *MCLK_Type) GetAPBAMASK_GCLK_() uint32 {
	return (volatile.LoadUint32(&o.APBAMASK.Reg) & 0x80) >> 7
}
func (o *MCLK_Type) SetAPBAMASK_WDT_(value uint32) {
	volatile.StoreUint32(&o.APBAMASK.Reg, volatile.LoadUint32(&o.APBAMASK.Reg)&^(0x100)|value<<8)
}
func (o *MCLK_Type) GetAPBAMASK_WDT_() uint32 {
	return (volatile.LoadUint32(&o.APBAMASK.Reg) & 0x100) >> 8
}
func (o *MCLK_Type) SetAPBAMASK_RTC_(value uint32) {
	volatile.StoreUint32(&o.APBAMASK.Reg, volatile.LoadUint32(&o.APBAMASK.Reg)&^(0x200)|value<<9)
}
func (o *MCLK_Type) GetAPBAMASK_RTC_() uint32 {
	return (volatile.LoadUint32(&o.APBAMASK.Reg) & 0x200) >> 9
}
func (o *MCLK_Type) SetAPBAMASK_EIC_(value uint32) {
	volatile.StoreUint32(&o.APBAMASK.Reg, volatile.LoadUint32(&o.APBAMASK.Reg)&^(0x400)|value<<10)
}
func (o *MCLK_Type) GetAPBAMASK_EIC_() uint32 {
	return (volatile.LoadUint32(&o.APBAMASK.Reg) & 0x400) >> 10
}
func (o *MCLK_Type) SetAPBAMASK_FREQM_(value uint32) {
	volatile.StoreUint32(&o.APBAMASK.Reg, volatile.LoadUint32(&o.APBAMASK.Reg)&^(0x800)|value<<11)
}
func (o *MCLK_Type) GetAPBAMASK_FREQM_() uint32 {
	return (volatile.LoadUint32(&o.APBAMASK.Reg) & 0x800) >> 11
}
func (o *MCLK_Type) SetAPBAMASK_SERCOM0_(value uint32) {
	volatile.StoreUint32(&o.APBAMASK.Reg, volatile.LoadUint32(&o.APBAMASK.Reg)&^(0x1000)|value<<12)
}
func (o *MCLK_Type) GetAPBAMASK_SERCOM0_() uint32 {
	return (volatile.LoadUint32(&o.APBAMASK.Reg) & 0x1000) >> 12
}
func (o *MCLK_Type) SetAPBAMASK_SERCOM1_(value uint32) {
	volatile.StoreUint32(&o.APBAMASK.Reg, volatile.LoadUint32(&o.APBAMASK.Reg)&^(0x2000)|value<<13)
}
func (o *MCLK_Type) GetAPBAMASK_SERCOM1_() uint32 {
	return (volatile.LoadUint32(&o.APBAMASK.Reg) & 0x2000) >> 13
}
func (o *MCLK_Type) SetAPBAMASK_TC0_(value uint32) {
	volatile.StoreUint32(&o.APBAMASK.Reg, volatile.LoadUint32(&o.APBAMASK.Reg)&^(0x4000)|value<<14)
}
func (o *MCLK_Type) GetAPBAMASK_TC0_() uint32 {
	return (volatile.LoadUint32(&o.APBAMASK.Reg) & 0x4000) >> 14
}
func (o *MCLK_Type) SetAPBAMASK_TC1_(value uint32) {
	volatile.StoreUint32(&o.APBAMASK.Reg, volatile.LoadUint32(&o.APBAMASK.Reg)&^(0x8000)|value<<15)
}
func (o *MCLK_Type) GetAPBAMASK_TC1_() uint32 {
	return (volatile.LoadUint32(&o.APBAMASK.Reg) & 0x8000) >> 15
}

// MCLK.APBBMASK: APBB Mask
func (o *MCLK_Type) SetAPBBMASK_USB_(value uint32) {
	volatile.StoreUint32(&o.APBBMASK.Reg, volatile.LoadUint32(&o.APBBMASK.Reg)&^(0x1)|value)
}
func (o *MCLK_Type) GetAPBBMASK_USB_() uint32 {
	return volatile.LoadUint32(&o.APBBMASK.Reg) & 0x1
}
func (o *MCLK_Type) SetAPBBMASK_DSU_(value uint32) {
	volatile.StoreUint32(&o.APBBMASK.Reg, volatile.LoadUint32(&o.APBBMASK.Reg)&^(0x2)|value<<1)
}
func (o *MCLK_Type) GetAPBBMASK_DSU_() uint32 {
	return (volatile.LoadUint32(&o.APBBMASK.Reg) & 0x2) >> 1
}
func (o *MCLK_Type) SetAPBBMASK_NVMCTRL_(value uint32) {
	volatile.StoreUint32(&o.APBBMASK.Reg, volatile.LoadUint32(&o.APBBMASK.Reg)&^(0x4)|value<<2)
}
func (o *MCLK_Type) GetAPBBMASK_NVMCTRL_() uint32 {
	return (volatile.LoadUint32(&o.APBBMASK.Reg) & 0x4) >> 2
}
func (o *MCLK_Type) SetAPBBMASK_PORT_(value uint32) {
	volatile.StoreUint32(&o.APBBMASK.Reg, volatile.LoadUint32(&o.APBBMASK.Reg)&^(0x10)|value<<4)
}
func (o *MCLK_Type) GetAPBBMASK_PORT_() uint32 {
	return (volatile.LoadUint32(&o.APBBMASK.Reg) & 0x10) >> 4
}
func (o *MCLK_Type) SetAPBBMASK_HMATRIX_(value uint32) {
	volatile.StoreUint32(&o.APBBMASK.Reg, volatile.LoadUint32(&o.APBBMASK.Reg)&^(0x40)|value<<6)
}
func (o *MCLK_Type) GetAPBBMASK_HMATRIX_() uint32 {
	return (volatile.LoadUint32(&o.APBBMASK.Reg) & 0x40) >> 6
}
func (o *MCLK_Type) SetAPBBMASK_EVSYS_(value uint32) {
	volatile.StoreUint32(&o.APBBMASK.Reg, volatile.LoadUint32(&o.APBBMASK.Reg)&^(0x80)|value<<7)
}
func (o *MCLK_Type) GetAPBBMASK_EVSYS_() uint32 {
	return (volatile.LoadUint32(&o.APBBMASK.Reg) & 0x80) >> 7
}
func (o *MCLK_Type) SetAPBBMASK_SERCOM2_(value uint32) {
	volatile.StoreUint32(&o.APBBMASK.Reg, volatile.LoadUint32(&o.APBBMASK.Reg)&^(0x200)|value<<9)
}
func (o *MCLK_Type) GetAPBBMASK_SERCOM2_() uint32 {
	return (volatile.LoadUint32(&o.APBBMASK.Reg) & 0x200) >> 9
}
func (o *MCLK_Type) SetAPBBMASK_SERCOM3_(value uint32) {
	volatile.StoreUint32(&o.APBBMASK.Reg, volatile.LoadUint32(&o.APBBMASK.Reg)&^(0x400)|value<<10)
}
func (o *MCLK_Type) GetAPBBMASK_SERCOM3_() uint32 {
	return (volatile.LoadUint32(&o.APBBMASK.Reg) & 0x400) >> 10
}
func (o *MCLK_Type) SetAPBBMASK_TCC0_(value uint32) {
	volatile.StoreUint32(&o.APBBMASK.Reg, volatile.LoadUint32(&o.APBBMASK.Reg)&^(0x800)|value<<11)
}
func (o *MCLK_Type) GetAPBBMASK_TCC0_() uint32 {
	return (volatile.LoadUint32(&o.APBBMASK.Reg) & 0x800) >> 11
}
func (o *MCLK_Type) SetAPBBMASK_TCC1_(value uint32) {
	volatile.StoreUint32(&o.APBBMASK.Reg, volatile.LoadUint32(&o.APBBMASK.Reg)&^(0x1000)|value<<12)
}
func (o *MCLK_Type) GetAPBBMASK_TCC1_() uint32 {
	return (volatile.LoadUint32(&o.APBBMASK.Reg) & 0x1000) >> 12
}
func (o *MCLK_Type) SetAPBBMASK_TC2_(value uint32) {
	volatile.StoreUint32(&o.APBBMASK.Reg, volatile.LoadUint32(&o.APBBMASK.Reg)&^(0x2000)|value<<13)
}
func (o *MCLK_Type) GetAPBBMASK_TC2_() uint32 {
	return (volatile.LoadUint32(&o.APBBMASK.Reg) & 0x2000) >> 13
}
func (o *MCLK_Type) SetAPBBMASK_TC3_(value uint32) {
	volatile.StoreUint32(&o.APBBMASK.Reg, volatile.LoadUint32(&o.APBBMASK.Reg)&^(0x4000)|value<<14)
}
func (o *MCLK_Type) GetAPBBMASK_TC3_() uint32 {
	return (volatile.LoadUint32(&o.APBBMASK.Reg) & 0x4000) >> 14
}
func (o *MCLK_Type) SetAPBBMASK_RAMECC_(value uint32) {
	volatile.StoreUint32(&o.APBBMASK.Reg, volatile.LoadUint32(&o.APBBMASK.Reg)&^(0x10000)|value<<16)
}
func (o *MCLK_Type) GetAPBBMASK_RAMECC_() uint32 {
	return (volatile.LoadUint32(&o.APBBMASK.Reg) & 0x10000) >> 16
}

// MCLK.APBCMASK: APBC Mask
func (o *MCLK_Type) SetAPBCMASK_GMAC_(value uint32) {
	volatile.StoreUint32(&o.APBCMASK.Reg, volatile.LoadUint32(&o.APBCMASK.Reg)&^(0x4)|value<<2)
}
func (o *MCLK_Type) GetAPBCMASK_GMAC_() uint32 {
	return (volatile.LoadUint32(&o.APBCMASK.Reg) & 0x4) >> 2
}
func (o *MCLK_Type) SetAPBCMASK_TCC2_(value uint32) {
	volatile.StoreUint32(&o.APBCMASK.Reg, volatile.LoadUint32(&o.APBCMASK.Reg)&^(0x8)|value<<3)
}
func (o *MCLK_Type) GetAPBCMASK_TCC2_() uint32 {
	return (volatile.LoadUint32(&o.APBCMASK.Reg) & 0x8) >> 3
}
func (o *MCLK_Type) SetAPBCMASK_TCC3_(value uint32) {
	volatile.StoreUint32(&o.APBCMASK.Reg, volatile.LoadUint32(&o.APBCMASK.Reg)&^(0x10)|value<<4)
}
func (o *MCLK_Type) GetAPBCMASK_TCC3_() uint32 {
	return (volatile.LoadUint32(&o.APBCMASK.Reg) & 0x10) >> 4
}
func (o *MCLK_Type) SetAPBCMASK_TC4_(value uint32) {
	volatile.StoreUint32(&o.APBCMASK.Reg, volatile.LoadUint32(&o.APBCMASK.Reg)&^(0x20)|value<<5)
}
func (o *MCLK_Type) GetAPBCMASK_TC4_() uint32 {
	return (volatile.LoadUint32(&o.APBCMASK.Reg) & 0x20) >> 5
}
func (o *MCLK_Type) SetAPBCMASK_TC5_(value uint32) {
	volatile.StoreUint32(&o.APBCMASK.Reg, volatile.LoadUint32(&o.APBCMASK.Reg)&^(0x40)|value<<6)
}
func (o *MCLK_Type) GetAPBCMASK_TC5_() uint32 {
	return (volatile.LoadUint32(&o.APBCMASK.Reg) & 0x40) >> 6
}
func (o *MCLK_Type) SetAPBCMASK_PDEC_(value uint32) {
	volatile.StoreUint32(&o.APBCMASK.Reg, volatile.LoadUint32(&o.APBCMASK.Reg)&^(0x80)|value<<7)
}
func (o *MCLK_Type) GetAPBCMASK_PDEC_() uint32 {
	return (volatile.LoadUint32(&o.APBCMASK.Reg) & 0x80) >> 7
}
func (o *MCLK_Type) SetAPBCMASK_AC_(value uint32) {
	volatile.StoreUint32(&o.APBCMASK.Reg, volatile.LoadUint32(&o.APBCMASK.Reg)&^(0x100)|value<<8)
}
func (o *MCLK_Type) GetAPBCMASK_AC_() uint32 {
	return (volatile.LoadUint32(&o.APBCMASK.Reg) & 0x100) >> 8
}
func (o *MCLK_Type) SetAPBCMASK_AES_(value uint32) {
	volatile.StoreUint32(&o.APBCMASK.Reg, volatile.LoadUint32(&o.APBCMASK.Reg)&^(0x200)|value<<9)
}
func (o *MCLK_Type) GetAPBCMASK_AES_() uint32 {
	return (volatile.LoadUint32(&o.APBCMASK.Reg) & 0x200) >> 9
}
func (o *MCLK_Type) SetAPBCMASK_TRNG_(value uint32) {
	volatile.StoreUint32(&o.APBCMASK.Reg, volatile.LoadUint32(&o.APBCMASK.Reg)&^(0x400)|value<<10)
}
func (o *MCLK_Type) GetAPBCMASK_TRNG_() uint32 {
	return (volatile.LoadUint32(&o.APBCMASK.Reg) & 0x400) >> 10
}
func (o *MCLK_Type) SetAPBCMASK_ICM_(value uint32) {
	volatile.StoreUint32(&o.APBCMASK.Reg, volatile.LoadUint32(&o.APBCMASK.Reg)&^(0x800)|value<<11)
}
func (o *MCLK_Type) GetAPBCMASK_ICM_() uint32 {
	return (volatile.LoadUint32(&o.APBCMASK.Reg) & 0x800) >> 11
}
func (o *MCLK_Type) SetAPBCMASK_QSPI_(value uint32) {
	volatile.StoreUint32(&o.APBCMASK.Reg, volatile.LoadUint32(&o.APBCMASK.Reg)&^(0x2000)|value<<13)
}
func (o *MCLK_Type) GetAPBCMASK_QSPI_() uint32 {
	return (volatile.LoadUint32(&o.APBCMASK.Reg) & 0x2000) >> 13
}
func (o *MCLK_Type) SetAPBCMASK_CCL_(value uint32) {
	volatile.StoreUint32(&o.APBCMASK.Reg, volatile.LoadUint32(&o.APBCMASK.Reg)&^(0x4000)|value<<14)
}
func (o *MCLK_Type) GetAPBCMASK_CCL_() uint32 {
	return (volatile.LoadUint32(&o.APBCMASK.Reg) & 0x4000) >> 14
}

// MCLK.APBDMASK: APBD Mask
func (o *MCLK_Type) SetAPBDMASK_SERCOM4_(value uint32) {
	volatile.StoreUint32(&o.APBDMASK.Reg, volatile.LoadUint32(&o.APBDMASK.Reg)&^(0x1)|value)
}
func (o *MCLK_Type) GetAPBDMASK_SERCOM4_() uint32 {
	return volatile.LoadUint32(&o.APBDMASK.Reg) & 0x1
}
func (o *MCLK_Type) SetAPBDMASK_SERCOM5_(value uint32) {
	volatile.StoreUint32(&o.APBDMASK.Reg, volatile.LoadUint32(&o.APBDMASK.Reg)&^(0x2)|value<<1)
}
func (o *MCLK_Type) GetAPBDMASK_SERCOM5_() uint32 {
	return (volatile.LoadUint32(&o.APBDMASK.Reg) & 0x2) >> 1
}
func (o *MCLK_Type) SetAPBDMASK_TCC4_(value uint32) {
	volatile.StoreUint32(&o.APBDMASK.Reg, volatile.LoadUint32(&o.APBDMASK.Reg)&^(0x10)|value<<4)
}
func (o *MCLK_Type) GetAPBDMASK_TCC4_() uint32 {
	return (volatile.LoadUint32(&o.APBDMASK.Reg) & 0x10) >> 4
}
func (o *MCLK_Type) SetAPBDMASK_ADC0_(value uint32) {
	volatile.StoreUint32(&o.APBDMASK.Reg, volatile.LoadUint32(&o.APBDMASK.Reg)&^(0x80)|value<<7)
}
func (o *MCLK_Type) GetAPBDMASK_ADC0_() uint32 {
	return (volatile.LoadUint32(&o.APBDMASK.Reg) & 0x80) >> 7
}
func (o *MCLK_Type) SetAPBDMASK_ADC1_(value uint32) {
	volatile.StoreUint32(&o.APBDMASK.Reg, volatile.LoadUint32(&o.APBDMASK.Reg)&^(0x100)|value<<8)
}
func (o *MCLK_Type) GetAPBDMASK_ADC1_() uint32 {
	return (volatile.LoadUint32(&o.APBDMASK.Reg) & 0x100) >> 8
}
func (o *MCLK_Type) SetAPBDMASK_DAC_(value uint32) {
	volatile.StoreUint32(&o.APBDMASK.Reg, volatile.LoadUint32(&o.APBDMASK.Reg)&^(0x200)|value<<9)
}
func (o *MCLK_Type) GetAPBDMASK_DAC_() uint32 {
	return (volatile.LoadUint32(&o.APBDMASK.Reg) & 0x200) >> 9
}
func (o *MCLK_Type) SetAPBDMASK_I2S_(value uint32) {
	volatile.StoreUint32(&o.APBDMASK.Reg, volatile.LoadUint32(&o.APBDMASK.Reg)&^(0x400)|value<<10)
}
func (o *MCLK_Type) GetAPBDMASK_I2S_() uint32 {
	return (volatile.LoadUint32(&o.APBDMASK.Reg) & 0x400) >> 10
}
func (o *MCLK_Type) SetAPBDMASK_PCC_(value uint32) {
	volatile.StoreUint32(&o.APBDMASK.Reg, volatile.LoadUint32(&o.APBDMASK.Reg)&^(0x800)|value<<11)
}
func (o *MCLK_Type) GetAPBDMASK_PCC_() uint32 {
	return (volatile.LoadUint32(&o.APBDMASK.Reg) & 0x800) >> 11
}

// Non-Volatile Memory Controller
type NVMCTRL_Type struct {
	CTRLA    volatile.Register16 // 0x0
	_        [2]byte
	CTRLB    volatile.Register16 // 0x4
	_        [2]byte
	PARAM    volatile.Register32    // 0x8
	INTENCLR volatile.Register16    // 0xC
	INTENSET volatile.Register16    // 0xE
	INTFLAG  volatile.Register16    // 0x10
	STATUS   volatile.Register16    // 0x12
	ADDR     volatile.Register32    // 0x14
	RUNLOCK  volatile.Register32    // 0x18
	PBLDATA  [2]volatile.Register32 // 0x1C
	ECCERR   volatile.Register32    // 0x24
	DBGCTRL  volatile.Register8     // 0x28
	_        byte
	SEECFG   volatile.Register8 // 0x2A
	_        byte
	SEESTAT  volatile.Register32 // 0x2C
}

// NVMCTRL.CTRLA: Control A
func (o *NVMCTRL_Type) SetCTRLA_AUTOWS(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x4)|value<<2)
}
func (o *NVMCTRL_Type) GetCTRLA_AUTOWS() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x4) >> 2
}
func (o *NVMCTRL_Type) SetCTRLA_SUSPEN(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x8)|value<<3)
}
func (o *NVMCTRL_Type) GetCTRLA_SUSPEN() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x8) >> 3
}
func (o *NVMCTRL_Type) SetCTRLA_WMODE(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x30)|value<<4)
}
func (o *NVMCTRL_Type) GetCTRLA_WMODE() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x30) >> 4
}
func (o *NVMCTRL_Type) SetCTRLA_PRM(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0xc0)|value<<6)
}
func (o *NVMCTRL_Type) GetCTRLA_PRM() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0xc0) >> 6
}
func (o *NVMCTRL_Type) SetCTRLA_RWS(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0xf00)|value<<8)
}
func (o *NVMCTRL_Type) GetCTRLA_RWS() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0xf00) >> 8
}
func (o *NVMCTRL_Type) SetCTRLA_AHBNS0(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x1000)|value<<12)
}
func (o *NVMCTRL_Type) GetCTRLA_AHBNS0() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x1000) >> 12
}
func (o *NVMCTRL_Type) SetCTRLA_AHBNS1(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x2000)|value<<13)
}
func (o *NVMCTRL_Type) GetCTRLA_AHBNS1() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x2000) >> 13
}
func (o *NVMCTRL_Type) SetCTRLA_CACHEDIS0(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x4000)|value<<14)
}
func (o *NVMCTRL_Type) GetCTRLA_CACHEDIS0() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x4000) >> 14
}
func (o *NVMCTRL_Type) SetCTRLA_CACHEDIS1(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x8000)|value<<15)
}
func (o *NVMCTRL_Type) GetCTRLA_CACHEDIS1() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x8000) >> 15
}

// NVMCTRL.CTRLB: Control B
func (o *NVMCTRL_Type) SetCTRLB_CMD(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x7f)|value)
}
func (o *NVMCTRL_Type) GetCTRLB_CMD() uint16 {
	return volatile.LoadUint16(&o.CTRLB.Reg) & 0x7f
}
func (o *NVMCTRL_Type) SetCTRLB_CMDEX(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0xff00)|value<<8)
}
func (o *NVMCTRL_Type) GetCTRLB_CMDEX() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0xff00) >> 8
}

// NVMCTRL.PARAM: NVM Parameter
func (o *NVMCTRL_Type) SetPARAM_NVMP(value uint32) {
	volatile.StoreUint32(&o.PARAM.Reg, volatile.LoadUint32(&o.PARAM.Reg)&^(0xffff)|value)
}
func (o *NVMCTRL_Type) GetPARAM_NVMP() uint32 {
	return volatile.LoadUint32(&o.PARAM.Reg) & 0xffff
}
func (o *NVMCTRL_Type) SetPARAM_PSZ(value uint32) {
	volatile.StoreUint32(&o.PARAM.Reg, volatile.LoadUint32(&o.PARAM.Reg)&^(0x70000)|value<<16)
}
func (o *NVMCTRL_Type) GetPARAM_PSZ() uint32 {
	return (volatile.LoadUint32(&o.PARAM.Reg) & 0x70000) >> 16
}
func (o *NVMCTRL_Type) SetPARAM_SEE(value uint32) {
	volatile.StoreUint32(&o.PARAM.Reg, volatile.LoadUint32(&o.PARAM.Reg)&^(0x80000000)|value<<31)
}
func (o *NVMCTRL_Type) GetPARAM_SEE() uint32 {
	return (volatile.LoadUint32(&o.PARAM.Reg) & 0x80000000) >> 31
}

// NVMCTRL.INTENCLR: Interrupt Enable Clear
func (o *NVMCTRL_Type) SetINTENCLR_DONE(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *NVMCTRL_Type) GetINTENCLR_DONE() uint16 {
	return volatile.LoadUint16(&o.INTENCLR.Reg) & 0x1
}
func (o *NVMCTRL_Type) SetINTENCLR_ADDRE(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *NVMCTRL_Type) GetINTENCLR_ADDRE() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *NVMCTRL_Type) SetINTENCLR_PROGE(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *NVMCTRL_Type) GetINTENCLR_PROGE() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *NVMCTRL_Type) SetINTENCLR_LOCKE(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *NVMCTRL_Type) GetINTENCLR_LOCKE() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *NVMCTRL_Type) SetINTENCLR_ECCSE(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *NVMCTRL_Type) GetINTENCLR_ECCSE() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *NVMCTRL_Type) SetINTENCLR_ECCDE(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *NVMCTRL_Type) GetINTENCLR_ECCDE() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *NVMCTRL_Type) SetINTENCLR_NVME(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *NVMCTRL_Type) GetINTENCLR_NVME() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *NVMCTRL_Type) SetINTENCLR_SUSP(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *NVMCTRL_Type) GetINTENCLR_SUSP() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *NVMCTRL_Type) SetINTENCLR_SEESFULL(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *NVMCTRL_Type) GetINTENCLR_SEESFULL() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *NVMCTRL_Type) SetINTENCLR_SEESOVF(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *NVMCTRL_Type) GetINTENCLR_SEESOVF() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *NVMCTRL_Type) SetINTENCLR_SEEWRC(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x400)|value<<10)
}
func (o *NVMCTRL_Type) GetINTENCLR_SEEWRC() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x400) >> 10
}

// NVMCTRL.INTENSET: Interrupt Enable Set
func (o *NVMCTRL_Type) SetINTENSET_DONE(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *NVMCTRL_Type) GetINTENSET_DONE() uint16 {
	return volatile.LoadUint16(&o.INTENSET.Reg) & 0x1
}
func (o *NVMCTRL_Type) SetINTENSET_ADDRE(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *NVMCTRL_Type) GetINTENSET_ADDRE() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *NVMCTRL_Type) SetINTENSET_PROGE(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *NVMCTRL_Type) GetINTENSET_PROGE() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *NVMCTRL_Type) SetINTENSET_LOCKE(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *NVMCTRL_Type) GetINTENSET_LOCKE() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *NVMCTRL_Type) SetINTENSET_ECCSE(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *NVMCTRL_Type) GetINTENSET_ECCSE() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *NVMCTRL_Type) SetINTENSET_ECCDE(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *NVMCTRL_Type) GetINTENSET_ECCDE() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *NVMCTRL_Type) SetINTENSET_NVME(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *NVMCTRL_Type) GetINTENSET_NVME() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *NVMCTRL_Type) SetINTENSET_SUSP(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *NVMCTRL_Type) GetINTENSET_SUSP() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *NVMCTRL_Type) SetINTENSET_SEESFULL(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *NVMCTRL_Type) GetINTENSET_SEESFULL() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *NVMCTRL_Type) SetINTENSET_SEESOVF(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *NVMCTRL_Type) GetINTENSET_SEESOVF() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *NVMCTRL_Type) SetINTENSET_SEEWRC(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x400)|value<<10)
}
func (o *NVMCTRL_Type) GetINTENSET_SEEWRC() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x400) >> 10
}

// NVMCTRL.INTFLAG: Interrupt Flag Status and Clear
func (o *NVMCTRL_Type) SetINTFLAG_DONE(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *NVMCTRL_Type) GetINTFLAG_DONE() uint16 {
	return volatile.LoadUint16(&o.INTFLAG.Reg) & 0x1
}
func (o *NVMCTRL_Type) SetINTFLAG_ADDRE(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *NVMCTRL_Type) GetINTFLAG_ADDRE() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *NVMCTRL_Type) SetINTFLAG_PROGE(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x4)|value<<2)
}
func (o *NVMCTRL_Type) GetINTFLAG_PROGE() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x4) >> 2
}
func (o *NVMCTRL_Type) SetINTFLAG_LOCKE(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x8)|value<<3)
}
func (o *NVMCTRL_Type) GetINTFLAG_LOCKE() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x8) >> 3
}
func (o *NVMCTRL_Type) SetINTFLAG_ECCSE(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x10)|value<<4)
}
func (o *NVMCTRL_Type) GetINTFLAG_ECCSE() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x10) >> 4
}
func (o *NVMCTRL_Type) SetINTFLAG_ECCDE(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x20)|value<<5)
}
func (o *NVMCTRL_Type) GetINTFLAG_ECCDE() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x20) >> 5
}
func (o *NVMCTRL_Type) SetINTFLAG_NVME(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x40)|value<<6)
}
func (o *NVMCTRL_Type) GetINTFLAG_NVME() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x40) >> 6
}
func (o *NVMCTRL_Type) SetINTFLAG_SUSP(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x80)|value<<7)
}
func (o *NVMCTRL_Type) GetINTFLAG_SUSP() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x80) >> 7
}
func (o *NVMCTRL_Type) SetINTFLAG_SEESFULL(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x100)|value<<8)
}
func (o *NVMCTRL_Type) GetINTFLAG_SEESFULL() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x100) >> 8
}
func (o *NVMCTRL_Type) SetINTFLAG_SEESOVF(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x200)|value<<9)
}
func (o *NVMCTRL_Type) GetINTFLAG_SEESOVF() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x200) >> 9
}
func (o *NVMCTRL_Type) SetINTFLAG_SEEWRC(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x400)|value<<10)
}
func (o *NVMCTRL_Type) GetINTFLAG_SEEWRC() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x400) >> 10
}

// NVMCTRL.STATUS: Status
func (o *NVMCTRL_Type) SetSTATUS_READY(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *NVMCTRL_Type) GetSTATUS_READY() uint16 {
	return volatile.LoadUint16(&o.STATUS.Reg) & 0x1
}
func (o *NVMCTRL_Type) SetSTATUS_PRM(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *NVMCTRL_Type) GetSTATUS_PRM() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *NVMCTRL_Type) SetSTATUS_LOAD(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *NVMCTRL_Type) GetSTATUS_LOAD() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *NVMCTRL_Type) SetSTATUS_SUSP(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *NVMCTRL_Type) GetSTATUS_SUSP() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x8) >> 3
}
func (o *NVMCTRL_Type) SetSTATUS_AFIRST(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x10)|value<<4)
}
func (o *NVMCTRL_Type) GetSTATUS_AFIRST() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x10) >> 4
}
func (o *NVMCTRL_Type) SetSTATUS_BPDIS(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x20)|value<<5)
}
func (o *NVMCTRL_Type) GetSTATUS_BPDIS() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x20) >> 5
}
func (o *NVMCTRL_Type) SetSTATUS_BOOTPROT(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0xf00)|value<<8)
}
func (o *NVMCTRL_Type) GetSTATUS_BOOTPROT() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0xf00) >> 8
}

// NVMCTRL.ADDR: Address
func (o *NVMCTRL_Type) SetADDR(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, volatile.LoadUint32(&o.ADDR.Reg)&^(0xffffff)|value)
}
func (o *NVMCTRL_Type) GetADDR() uint32 {
	return volatile.LoadUint32(&o.ADDR.Reg) & 0xffffff
}

// NVMCTRL.RUNLOCK: Lock Section
func (o *NVMCTRL_Type) SetRUNLOCK(value uint32) {
	volatile.StoreUint32(&o.RUNLOCK.Reg, value)
}
func (o *NVMCTRL_Type) GetRUNLOCK() uint32 {
	return volatile.LoadUint32(&o.RUNLOCK.Reg)
}

// NVMCTRL.PBLDATA: Page Buffer Load Data x
func (o *NVMCTRL_Type) SetPBLDATA(idx int, value uint32) {
	volatile.StoreUint32(&o.PBLDATA[idx].Reg, value)
}
func (o *NVMCTRL_Type) GetPBLDATA(idx int) uint32 {
	return volatile.LoadUint32(&o.PBLDATA[idx].Reg)
}

// NVMCTRL.ECCERR: ECC Error Status Register
func (o *NVMCTRL_Type) SetECCERR_ADDR(value uint32) {
	volatile.StoreUint32(&o.ECCERR.Reg, volatile.LoadUint32(&o.ECCERR.Reg)&^(0xffffff)|value)
}
func (o *NVMCTRL_Type) GetECCERR_ADDR() uint32 {
	return volatile.LoadUint32(&o.ECCERR.Reg) & 0xffffff
}
func (o *NVMCTRL_Type) SetECCERR_TYPEL(value uint32) {
	volatile.StoreUint32(&o.ECCERR.Reg, volatile.LoadUint32(&o.ECCERR.Reg)&^(0x30000000)|value<<28)
}
func (o *NVMCTRL_Type) GetECCERR_TYPEL() uint32 {
	return (volatile.LoadUint32(&o.ECCERR.Reg) & 0x30000000) >> 28
}
func (o *NVMCTRL_Type) SetECCERR_TYPEH(value uint32) {
	volatile.StoreUint32(&o.ECCERR.Reg, volatile.LoadUint32(&o.ECCERR.Reg)&^(0xc0000000)|value<<30)
}
func (o *NVMCTRL_Type) GetECCERR_TYPEH() uint32 {
	return (volatile.LoadUint32(&o.ECCERR.Reg) & 0xc0000000) >> 30
}

// NVMCTRL.DBGCTRL: Debug Control
func (o *NVMCTRL_Type) SetDBGCTRL_ECCDIS(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x1)|value)
}
func (o *NVMCTRL_Type) GetDBGCTRL_ECCDIS() uint8 {
	return volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x1
}
func (o *NVMCTRL_Type) SetDBGCTRL_ECCELOG(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x2)|value<<1)
}
func (o *NVMCTRL_Type) GetDBGCTRL_ECCELOG() uint8 {
	return (volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x2) >> 1
}

// NVMCTRL.SEECFG: SmartEEPROM Configuration Register
func (o *NVMCTRL_Type) SetSEECFG_WMODE(value uint8) {
	volatile.StoreUint8(&o.SEECFG.Reg, volatile.LoadUint8(&o.SEECFG.Reg)&^(0x1)|value)
}
func (o *NVMCTRL_Type) GetSEECFG_WMODE() uint8 {
	return volatile.LoadUint8(&o.SEECFG.Reg) & 0x1
}
func (o *NVMCTRL_Type) SetSEECFG_APRDIS(value uint8) {
	volatile.StoreUint8(&o.SEECFG.Reg, volatile.LoadUint8(&o.SEECFG.Reg)&^(0x2)|value<<1)
}
func (o *NVMCTRL_Type) GetSEECFG_APRDIS() uint8 {
	return (volatile.LoadUint8(&o.SEECFG.Reg) & 0x2) >> 1
}

// NVMCTRL.SEESTAT: SmartEEPROM Status Register
func (o *NVMCTRL_Type) SetSEESTAT_ASEES(value uint32) {
	volatile.StoreUint32(&o.SEESTAT.Reg, volatile.LoadUint32(&o.SEESTAT.Reg)&^(0x1)|value)
}
func (o *NVMCTRL_Type) GetSEESTAT_ASEES() uint32 {
	return volatile.LoadUint32(&o.SEESTAT.Reg) & 0x1
}
func (o *NVMCTRL_Type) SetSEESTAT_LOAD(value uint32) {
	volatile.StoreUint32(&o.SEESTAT.Reg, volatile.LoadUint32(&o.SEESTAT.Reg)&^(0x2)|value<<1)
}
func (o *NVMCTRL_Type) GetSEESTAT_LOAD() uint32 {
	return (volatile.LoadUint32(&o.SEESTAT.Reg) & 0x2) >> 1
}
func (o *NVMCTRL_Type) SetSEESTAT_BUSY(value uint32) {
	volatile.StoreUint32(&o.SEESTAT.Reg, volatile.LoadUint32(&o.SEESTAT.Reg)&^(0x4)|value<<2)
}
func (o *NVMCTRL_Type) GetSEESTAT_BUSY() uint32 {
	return (volatile.LoadUint32(&o.SEESTAT.Reg) & 0x4) >> 2
}
func (o *NVMCTRL_Type) SetSEESTAT_LOCK(value uint32) {
	volatile.StoreUint32(&o.SEESTAT.Reg, volatile.LoadUint32(&o.SEESTAT.Reg)&^(0x8)|value<<3)
}
func (o *NVMCTRL_Type) GetSEESTAT_LOCK() uint32 {
	return (volatile.LoadUint32(&o.SEESTAT.Reg) & 0x8) >> 3
}
func (o *NVMCTRL_Type) SetSEESTAT_RLOCK(value uint32) {
	volatile.StoreUint32(&o.SEESTAT.Reg, volatile.LoadUint32(&o.SEESTAT.Reg)&^(0x10)|value<<4)
}
func (o *NVMCTRL_Type) GetSEESTAT_RLOCK() uint32 {
	return (volatile.LoadUint32(&o.SEESTAT.Reg) & 0x10) >> 4
}
func (o *NVMCTRL_Type) SetSEESTAT_SBLK(value uint32) {
	volatile.StoreUint32(&o.SEESTAT.Reg, volatile.LoadUint32(&o.SEESTAT.Reg)&^(0xf00)|value<<8)
}
func (o *NVMCTRL_Type) GetSEESTAT_SBLK() uint32 {
	return (volatile.LoadUint32(&o.SEESTAT.Reg) & 0xf00) >> 8
}
func (o *NVMCTRL_Type) SetSEESTAT_PSZ(value uint32) {
	volatile.StoreUint32(&o.SEESTAT.Reg, volatile.LoadUint32(&o.SEESTAT.Reg)&^(0x70000)|value<<16)
}
func (o *NVMCTRL_Type) GetSEESTAT_PSZ() uint32 {
	return (volatile.LoadUint32(&o.SEESTAT.Reg) & 0x70000) >> 16
}

// Oscillators Control
type OSCCTRL_Type struct {
	EVCTRL    volatile.Register8 // 0x0
	_         [3]byte
	INTENCLR  volatile.Register32    // 0x4
	INTENSET  volatile.Register32    // 0x8
	INTFLAG   volatile.Register32    // 0xC
	STATUS    volatile.Register32    // 0x10
	XOSCCTRL  [2]volatile.Register32 // 0x14
	DFLLCTRLA volatile.Register8     // 0x1C
	_         [3]byte
	DFLLCTRLB volatile.Register8 // 0x20
	_         [3]byte
	DFLLVAL   volatile.Register32 // 0x24
	DFLLMUL   volatile.Register32 // 0x28
	DFLLSYNC  volatile.Register8  // 0x2C
	_         [3]byte
	DPLL      [2]OSCCTRL_DPLL_Type // 0x30
}

// OSCCTRL.EVCTRL: Event Control
func (o *OSCCTRL_Type) SetEVCTRL_CFDEO0(value uint8) {
	volatile.StoreUint8(&o.EVCTRL.Reg, volatile.LoadUint8(&o.EVCTRL.Reg)&^(0x1)|value)
}
func (o *OSCCTRL_Type) GetEVCTRL_CFDEO0() uint8 {
	return volatile.LoadUint8(&o.EVCTRL.Reg) & 0x1
}
func (o *OSCCTRL_Type) SetEVCTRL_CFDEO1(value uint8) {
	volatile.StoreUint8(&o.EVCTRL.Reg, volatile.LoadUint8(&o.EVCTRL.Reg)&^(0x2)|value<<1)
}
func (o *OSCCTRL_Type) GetEVCTRL_CFDEO1() uint8 {
	return (volatile.LoadUint8(&o.EVCTRL.Reg) & 0x2) >> 1
}

// OSCCTRL.INTENCLR: Interrupt Enable Clear
func (o *OSCCTRL_Type) SetINTENCLR_XOSCRDY0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *OSCCTRL_Type) GetINTENCLR_XOSCRDY0() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *OSCCTRL_Type) SetINTENCLR_XOSCRDY1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *OSCCTRL_Type) GetINTENCLR_XOSCRDY1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *OSCCTRL_Type) SetINTENCLR_XOSCFAIL0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *OSCCTRL_Type) GetINTENCLR_XOSCFAIL0() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *OSCCTRL_Type) SetINTENCLR_XOSCFAIL1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *OSCCTRL_Type) GetINTENCLR_XOSCFAIL1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *OSCCTRL_Type) SetINTENCLR_DFLLRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *OSCCTRL_Type) GetINTENCLR_DFLLRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *OSCCTRL_Type) SetINTENCLR_DFLLOOB(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *OSCCTRL_Type) GetINTENCLR_DFLLOOB() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *OSCCTRL_Type) SetINTENCLR_DFLLLCKF(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400)|value<<10)
}
func (o *OSCCTRL_Type) GetINTENCLR_DFLLLCKF() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400) >> 10
}
func (o *OSCCTRL_Type) SetINTENCLR_DFLLLCKC(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x800)|value<<11)
}
func (o *OSCCTRL_Type) GetINTENCLR_DFLLLCKC() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x800) >> 11
}
func (o *OSCCTRL_Type) SetINTENCLR_DFLLRCS(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000)|value<<12)
}
func (o *OSCCTRL_Type) GetINTENCLR_DFLLRCS() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000) >> 12
}
func (o *OSCCTRL_Type) SetINTENCLR_DPLL0LCKR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10000)|value<<16)
}
func (o *OSCCTRL_Type) GetINTENCLR_DPLL0LCKR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10000) >> 16
}
func (o *OSCCTRL_Type) SetINTENCLR_DPLL0LCKF(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *OSCCTRL_Type) GetINTENCLR_DPLL0LCKF() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20000) >> 17
}
func (o *OSCCTRL_Type) SetINTENCLR_DPLL0LTO(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *OSCCTRL_Type) GetINTENCLR_DPLL0LTO() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40000) >> 18
}
func (o *OSCCTRL_Type) SetINTENCLR_DPLL0LDRTO(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *OSCCTRL_Type) GetINTENCLR_DPLL0LDRTO() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}
func (o *OSCCTRL_Type) SetINTENCLR_DPLL1LCKR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *OSCCTRL_Type) GetINTENCLR_DPLL1LCKR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000000) >> 24
}
func (o *OSCCTRL_Type) SetINTENCLR_DPLL1LCKF(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *OSCCTRL_Type) GetINTENCLR_DPLL1LCKF() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2000000) >> 25
}
func (o *OSCCTRL_Type) SetINTENCLR_DPLL1LTO(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *OSCCTRL_Type) GetINTENCLR_DPLL1LTO() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4000000) >> 26
}
func (o *OSCCTRL_Type) SetINTENCLR_DPLL1LDRTO(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *OSCCTRL_Type) GetINTENCLR_DPLL1LDRTO() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8000000) >> 27
}

// OSCCTRL.INTENSET: Interrupt Enable Set
func (o *OSCCTRL_Type) SetINTENSET_XOSCRDY0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *OSCCTRL_Type) GetINTENSET_XOSCRDY0() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *OSCCTRL_Type) SetINTENSET_XOSCRDY1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *OSCCTRL_Type) GetINTENSET_XOSCRDY1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *OSCCTRL_Type) SetINTENSET_XOSCFAIL0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *OSCCTRL_Type) GetINTENSET_XOSCFAIL0() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *OSCCTRL_Type) SetINTENSET_XOSCFAIL1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *OSCCTRL_Type) GetINTENSET_XOSCFAIL1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *OSCCTRL_Type) SetINTENSET_DFLLRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *OSCCTRL_Type) GetINTENSET_DFLLRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *OSCCTRL_Type) SetINTENSET_DFLLOOB(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *OSCCTRL_Type) GetINTENSET_DFLLOOB() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *OSCCTRL_Type) SetINTENSET_DFLLLCKF(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400)|value<<10)
}
func (o *OSCCTRL_Type) GetINTENSET_DFLLLCKF() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400) >> 10
}
func (o *OSCCTRL_Type) SetINTENSET_DFLLLCKC(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x800)|value<<11)
}
func (o *OSCCTRL_Type) GetINTENSET_DFLLLCKC() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x800) >> 11
}
func (o *OSCCTRL_Type) SetINTENSET_DFLLRCS(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000)|value<<12)
}
func (o *OSCCTRL_Type) GetINTENSET_DFLLRCS() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000) >> 12
}
func (o *OSCCTRL_Type) SetINTENSET_DPLL0LCKR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10000)|value<<16)
}
func (o *OSCCTRL_Type) GetINTENSET_DPLL0LCKR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10000) >> 16
}
func (o *OSCCTRL_Type) SetINTENSET_DPLL0LCKF(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20000)|value<<17)
}
func (o *OSCCTRL_Type) GetINTENSET_DPLL0LCKF() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20000) >> 17
}
func (o *OSCCTRL_Type) SetINTENSET_DPLL0LTO(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *OSCCTRL_Type) GetINTENSET_DPLL0LTO() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40000) >> 18
}
func (o *OSCCTRL_Type) SetINTENSET_DPLL0LDRTO(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *OSCCTRL_Type) GetINTENSET_DPLL0LDRTO() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}
func (o *OSCCTRL_Type) SetINTENSET_DPLL1LCKR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000000)|value<<24)
}
func (o *OSCCTRL_Type) GetINTENSET_DPLL1LCKR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000000) >> 24
}
func (o *OSCCTRL_Type) SetINTENSET_DPLL1LCKF(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2000000)|value<<25)
}
func (o *OSCCTRL_Type) GetINTENSET_DPLL1LCKF() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2000000) >> 25
}
func (o *OSCCTRL_Type) SetINTENSET_DPLL1LTO(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4000000)|value<<26)
}
func (o *OSCCTRL_Type) GetINTENSET_DPLL1LTO() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4000000) >> 26
}
func (o *OSCCTRL_Type) SetINTENSET_DPLL1LDRTO(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8000000)|value<<27)
}
func (o *OSCCTRL_Type) GetINTENSET_DPLL1LDRTO() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8000000) >> 27
}

// OSCCTRL.INTFLAG: Interrupt Flag Status and Clear
func (o *OSCCTRL_Type) SetINTFLAG_XOSCRDY0(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *OSCCTRL_Type) GetINTFLAG_XOSCRDY0() uint32 {
	return volatile.LoadUint32(&o.INTFLAG.Reg) & 0x1
}
func (o *OSCCTRL_Type) SetINTFLAG_XOSCRDY1(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *OSCCTRL_Type) GetINTFLAG_XOSCRDY1() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *OSCCTRL_Type) SetINTFLAG_XOSCFAIL0(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x4)|value<<2)
}
func (o *OSCCTRL_Type) GetINTFLAG_XOSCFAIL0() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x4) >> 2
}
func (o *OSCCTRL_Type) SetINTFLAG_XOSCFAIL1(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x8)|value<<3)
}
func (o *OSCCTRL_Type) GetINTFLAG_XOSCFAIL1() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x8) >> 3
}
func (o *OSCCTRL_Type) SetINTFLAG_DFLLRDY(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x100)|value<<8)
}
func (o *OSCCTRL_Type) GetINTFLAG_DFLLRDY() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x100) >> 8
}
func (o *OSCCTRL_Type) SetINTFLAG_DFLLOOB(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x200)|value<<9)
}
func (o *OSCCTRL_Type) GetINTFLAG_DFLLOOB() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x200) >> 9
}
func (o *OSCCTRL_Type) SetINTFLAG_DFLLLCKF(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x400)|value<<10)
}
func (o *OSCCTRL_Type) GetINTFLAG_DFLLLCKF() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x400) >> 10
}
func (o *OSCCTRL_Type) SetINTFLAG_DFLLLCKC(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x800)|value<<11)
}
func (o *OSCCTRL_Type) GetINTFLAG_DFLLLCKC() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x800) >> 11
}
func (o *OSCCTRL_Type) SetINTFLAG_DFLLRCS(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x1000)|value<<12)
}
func (o *OSCCTRL_Type) GetINTFLAG_DFLLRCS() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x1000) >> 12
}
func (o *OSCCTRL_Type) SetINTFLAG_DPLL0LCKR(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x10000)|value<<16)
}
func (o *OSCCTRL_Type) GetINTFLAG_DPLL0LCKR() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x10000) >> 16
}
func (o *OSCCTRL_Type) SetINTFLAG_DPLL0LCKF(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x20000)|value<<17)
}
func (o *OSCCTRL_Type) GetINTFLAG_DPLL0LCKF() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x20000) >> 17
}
func (o *OSCCTRL_Type) SetINTFLAG_DPLL0LTO(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x40000)|value<<18)
}
func (o *OSCCTRL_Type) GetINTFLAG_DPLL0LTO() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x40000) >> 18
}
func (o *OSCCTRL_Type) SetINTFLAG_DPLL0LDRTO(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x80000)|value<<19)
}
func (o *OSCCTRL_Type) GetINTFLAG_DPLL0LDRTO() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x80000) >> 19
}
func (o *OSCCTRL_Type) SetINTFLAG_DPLL1LCKR(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x1000000)|value<<24)
}
func (o *OSCCTRL_Type) GetINTFLAG_DPLL1LCKR() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x1000000) >> 24
}
func (o *OSCCTRL_Type) SetINTFLAG_DPLL1LCKF(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x2000000)|value<<25)
}
func (o *OSCCTRL_Type) GetINTFLAG_DPLL1LCKF() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x2000000) >> 25
}
func (o *OSCCTRL_Type) SetINTFLAG_DPLL1LTO(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x4000000)|value<<26)
}
func (o *OSCCTRL_Type) GetINTFLAG_DPLL1LTO() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x4000000) >> 26
}
func (o *OSCCTRL_Type) SetINTFLAG_DPLL1LDRTO(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x8000000)|value<<27)
}
func (o *OSCCTRL_Type) GetINTFLAG_DPLL1LDRTO() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x8000000) >> 27
}

// OSCCTRL.STATUS: Status
func (o *OSCCTRL_Type) SetSTATUS_XOSCRDY0(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *OSCCTRL_Type) GetSTATUS_XOSCRDY0() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *OSCCTRL_Type) SetSTATUS_XOSCRDY1(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *OSCCTRL_Type) GetSTATUS_XOSCRDY1() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *OSCCTRL_Type) SetSTATUS_XOSCFAIL0(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *OSCCTRL_Type) GetSTATUS_XOSCFAIL0() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *OSCCTRL_Type) SetSTATUS_XOSCFAIL1(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *OSCCTRL_Type) GetSTATUS_XOSCFAIL1() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8) >> 3
}
func (o *OSCCTRL_Type) SetSTATUS_XOSCCKSW0(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x10)|value<<4)
}
func (o *OSCCTRL_Type) GetSTATUS_XOSCCKSW0() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x10) >> 4
}
func (o *OSCCTRL_Type) SetSTATUS_XOSCCKSW1(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x20)|value<<5)
}
func (o *OSCCTRL_Type) GetSTATUS_XOSCCKSW1() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x20) >> 5
}
func (o *OSCCTRL_Type) SetSTATUS_DFLLRDY(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x100)|value<<8)
}
func (o *OSCCTRL_Type) GetSTATUS_DFLLRDY() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x100) >> 8
}
func (o *OSCCTRL_Type) SetSTATUS_DFLLOOB(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x200)|value<<9)
}
func (o *OSCCTRL_Type) GetSTATUS_DFLLOOB() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x200) >> 9
}
func (o *OSCCTRL_Type) SetSTATUS_DFLLLCKF(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x400)|value<<10)
}
func (o *OSCCTRL_Type) GetSTATUS_DFLLLCKF() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x400) >> 10
}
func (o *OSCCTRL_Type) SetSTATUS_DFLLLCKC(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x800)|value<<11)
}
func (o *OSCCTRL_Type) GetSTATUS_DFLLLCKC() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x800) >> 11
}
func (o *OSCCTRL_Type) SetSTATUS_DFLLRCS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *OSCCTRL_Type) GetSTATUS_DFLLRCS() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x1000) >> 12
}
func (o *OSCCTRL_Type) SetSTATUS_DPLL0LCKR(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x10000)|value<<16)
}
func (o *OSCCTRL_Type) GetSTATUS_DPLL0LCKR() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x10000) >> 16
}
func (o *OSCCTRL_Type) SetSTATUS_DPLL0LCKF(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *OSCCTRL_Type) GetSTATUS_DPLL0LCKF() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x20000) >> 17
}
func (o *OSCCTRL_Type) SetSTATUS_DPLL0TO(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x40000)|value<<18)
}
func (o *OSCCTRL_Type) GetSTATUS_DPLL0TO() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x40000) >> 18
}
func (o *OSCCTRL_Type) SetSTATUS_DPLL0LDRTO(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *OSCCTRL_Type) GetSTATUS_DPLL0LDRTO() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80000) >> 19
}
func (o *OSCCTRL_Type) SetSTATUS_DPLL1LCKR(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *OSCCTRL_Type) GetSTATUS_DPLL1LCKR() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x1000000) >> 24
}
func (o *OSCCTRL_Type) SetSTATUS_DPLL1LCKF(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2000000)|value<<25)
}
func (o *OSCCTRL_Type) GetSTATUS_DPLL1LCKF() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2000000) >> 25
}
func (o *OSCCTRL_Type) SetSTATUS_DPLL1TO(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *OSCCTRL_Type) GetSTATUS_DPLL1TO() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4000000) >> 26
}
func (o *OSCCTRL_Type) SetSTATUS_DPLL1LDRTO(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8000000)|value<<27)
}
func (o *OSCCTRL_Type) GetSTATUS_DPLL1LDRTO() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8000000) >> 27
}

// OSCCTRL.XOSCCTRL: External Multipurpose Crystal Oscillator Control
func (o *OSCCTRL_Type) SetXOSCCTRL_ENABLE(idx int, value uint32) {
	volatile.StoreUint32(&o.XOSCCTRL[idx].Reg, volatile.LoadUint32(&o.XOSCCTRL[idx].Reg)&^(0x2)|value<<1)
}
func (o *OSCCTRL_Type) GetXOSCCTRL_ENABLE(idx int) uint32 {
	return (volatile.LoadUint32(&o.XOSCCTRL[idx].Reg) & 0x2) >> 1
}
func (o *OSCCTRL_Type) SetXOSCCTRL_XTALEN(idx int, value uint32) {
	volatile.StoreUint32(&o.XOSCCTRL[idx].Reg, volatile.LoadUint32(&o.XOSCCTRL[idx].Reg)&^(0x4)|value<<2)
}
func (o *OSCCTRL_Type) GetXOSCCTRL_XTALEN(idx int) uint32 {
	return (volatile.LoadUint32(&o.XOSCCTRL[idx].Reg) & 0x4) >> 2
}
func (o *OSCCTRL_Type) SetXOSCCTRL_RUNSTDBY(idx int, value uint32) {
	volatile.StoreUint32(&o.XOSCCTRL[idx].Reg, volatile.LoadUint32(&o.XOSCCTRL[idx].Reg)&^(0x40)|value<<6)
}
func (o *OSCCTRL_Type) GetXOSCCTRL_RUNSTDBY(idx int) uint32 {
	return (volatile.LoadUint32(&o.XOSCCTRL[idx].Reg) & 0x40) >> 6
}
func (o *OSCCTRL_Type) SetXOSCCTRL_ONDEMAND(idx int, value uint32) {
	volatile.StoreUint32(&o.XOSCCTRL[idx].Reg, volatile.LoadUint32(&o.XOSCCTRL[idx].Reg)&^(0x80)|value<<7)
}
func (o *OSCCTRL_Type) GetXOSCCTRL_ONDEMAND(idx int) uint32 {
	return (volatile.LoadUint32(&o.XOSCCTRL[idx].Reg) & 0x80) >> 7
}
func (o *OSCCTRL_Type) SetXOSCCTRL_LOWBUFGAIN(idx int, value uint32) {
	volatile.StoreUint32(&o.XOSCCTRL[idx].Reg, volatile.LoadUint32(&o.XOSCCTRL[idx].Reg)&^(0x100)|value<<8)
}
func (o *OSCCTRL_Type) GetXOSCCTRL_LOWBUFGAIN(idx int) uint32 {
	return (volatile.LoadUint32(&o.XOSCCTRL[idx].Reg) & 0x100) >> 8
}
func (o *OSCCTRL_Type) SetXOSCCTRL_IPTAT(idx int, value uint32) {
	volatile.StoreUint32(&o.XOSCCTRL[idx].Reg, volatile.LoadUint32(&o.XOSCCTRL[idx].Reg)&^(0x600)|value<<9)
}
func (o *OSCCTRL_Type) GetXOSCCTRL_IPTAT(idx int) uint32 {
	return (volatile.LoadUint32(&o.XOSCCTRL[idx].Reg) & 0x600) >> 9
}
func (o *OSCCTRL_Type) SetXOSCCTRL_IMULT(idx int, value uint32) {
	volatile.StoreUint32(&o.XOSCCTRL[idx].Reg, volatile.LoadUint32(&o.XOSCCTRL[idx].Reg)&^(0x7800)|value<<11)
}
func (o *OSCCTRL_Type) GetXOSCCTRL_IMULT(idx int) uint32 {
	return (volatile.LoadUint32(&o.XOSCCTRL[idx].Reg) & 0x7800) >> 11
}
func (o *OSCCTRL_Type) SetXOSCCTRL_ENALC(idx int, value uint32) {
	volatile.StoreUint32(&o.XOSCCTRL[idx].Reg, volatile.LoadUint32(&o.XOSCCTRL[idx].Reg)&^(0x8000)|value<<15)
}
func (o *OSCCTRL_Type) GetXOSCCTRL_ENALC(idx int) uint32 {
	return (volatile.LoadUint32(&o.XOSCCTRL[idx].Reg) & 0x8000) >> 15
}
func (o *OSCCTRL_Type) SetXOSCCTRL_CFDEN(idx int, value uint32) {
	volatile.StoreUint32(&o.XOSCCTRL[idx].Reg, volatile.LoadUint32(&o.XOSCCTRL[idx].Reg)&^(0x10000)|value<<16)
}
func (o *OSCCTRL_Type) GetXOSCCTRL_CFDEN(idx int) uint32 {
	return (volatile.LoadUint32(&o.XOSCCTRL[idx].Reg) & 0x10000) >> 16
}
func (o *OSCCTRL_Type) SetXOSCCTRL_SWBEN(idx int, value uint32) {
	volatile.StoreUint32(&o.XOSCCTRL[idx].Reg, volatile.LoadUint32(&o.XOSCCTRL[idx].Reg)&^(0x20000)|value<<17)
}
func (o *OSCCTRL_Type) GetXOSCCTRL_SWBEN(idx int) uint32 {
	return (volatile.LoadUint32(&o.XOSCCTRL[idx].Reg) & 0x20000) >> 17
}
func (o *OSCCTRL_Type) SetXOSCCTRL_STARTUP(idx int, value uint32) {
	volatile.StoreUint32(&o.XOSCCTRL[idx].Reg, volatile.LoadUint32(&o.XOSCCTRL[idx].Reg)&^(0xf00000)|value<<20)
}
func (o *OSCCTRL_Type) GetXOSCCTRL_STARTUP(idx int) uint32 {
	return (volatile.LoadUint32(&o.XOSCCTRL[idx].Reg) & 0xf00000) >> 20
}
func (o *OSCCTRL_Type) SetXOSCCTRL_CFDPRESC(idx int, value uint32) {
	volatile.StoreUint32(&o.XOSCCTRL[idx].Reg, volatile.LoadUint32(&o.XOSCCTRL[idx].Reg)&^(0xf000000)|value<<24)
}
func (o *OSCCTRL_Type) GetXOSCCTRL_CFDPRESC(idx int) uint32 {
	return (volatile.LoadUint32(&o.XOSCCTRL[idx].Reg) & 0xf000000) >> 24
}

// OSCCTRL.DFLLCTRLA: DFLL48M Control A
func (o *OSCCTRL_Type) SetDFLLCTRLA_ENABLE(value uint8) {
	volatile.StoreUint8(&o.DFLLCTRLA.Reg, volatile.LoadUint8(&o.DFLLCTRLA.Reg)&^(0x2)|value<<1)
}
func (o *OSCCTRL_Type) GetDFLLCTRLA_ENABLE() uint8 {
	return (volatile.LoadUint8(&o.DFLLCTRLA.Reg) & 0x2) >> 1
}
func (o *OSCCTRL_Type) SetDFLLCTRLA_RUNSTDBY(value uint8) {
	volatile.StoreUint8(&o.DFLLCTRLA.Reg, volatile.LoadUint8(&o.DFLLCTRLA.Reg)&^(0x40)|value<<6)
}
func (o *OSCCTRL_Type) GetDFLLCTRLA_RUNSTDBY() uint8 {
	return (volatile.LoadUint8(&o.DFLLCTRLA.Reg) & 0x40) >> 6
}
func (o *OSCCTRL_Type) SetDFLLCTRLA_ONDEMAND(value uint8) {
	volatile.StoreUint8(&o.DFLLCTRLA.Reg, volatile.LoadUint8(&o.DFLLCTRLA.Reg)&^(0x80)|value<<7)
}
func (o *OSCCTRL_Type) GetDFLLCTRLA_ONDEMAND() uint8 {
	return (volatile.LoadUint8(&o.DFLLCTRLA.Reg) & 0x80) >> 7
}

// OSCCTRL.DFLLCTRLB: DFLL48M Control B
func (o *OSCCTRL_Type) SetDFLLCTRLB_MODE(value uint8) {
	volatile.StoreUint8(&o.DFLLCTRLB.Reg, volatile.LoadUint8(&o.DFLLCTRLB.Reg)&^(0x1)|value)
}
func (o *OSCCTRL_Type) GetDFLLCTRLB_MODE() uint8 {
	return volatile.LoadUint8(&o.DFLLCTRLB.Reg) & 0x1
}
func (o *OSCCTRL_Type) SetDFLLCTRLB_STABLE(value uint8) {
	volatile.StoreUint8(&o.DFLLCTRLB.Reg, volatile.LoadUint8(&o.DFLLCTRLB.Reg)&^(0x2)|value<<1)
}
func (o *OSCCTRL_Type) GetDFLLCTRLB_STABLE() uint8 {
	return (volatile.LoadUint8(&o.DFLLCTRLB.Reg) & 0x2) >> 1
}
func (o *OSCCTRL_Type) SetDFLLCTRLB_LLAW(value uint8) {
	volatile.StoreUint8(&o.DFLLCTRLB.Reg, volatile.LoadUint8(&o.DFLLCTRLB.Reg)&^(0x4)|value<<2)
}
func (o *OSCCTRL_Type) GetDFLLCTRLB_LLAW() uint8 {
	return (volatile.LoadUint8(&o.DFLLCTRLB.Reg) & 0x4) >> 2
}
func (o *OSCCTRL_Type) SetDFLLCTRLB_USBCRM(value uint8) {
	volatile.StoreUint8(&o.DFLLCTRLB.Reg, volatile.LoadUint8(&o.DFLLCTRLB.Reg)&^(0x8)|value<<3)
}
func (o *OSCCTRL_Type) GetDFLLCTRLB_USBCRM() uint8 {
	return (volatile.LoadUint8(&o.DFLLCTRLB.Reg) & 0x8) >> 3
}
func (o *OSCCTRL_Type) SetDFLLCTRLB_CCDIS(value uint8) {
	volatile.StoreUint8(&o.DFLLCTRLB.Reg, volatile.LoadUint8(&o.DFLLCTRLB.Reg)&^(0x10)|value<<4)
}
func (o *OSCCTRL_Type) GetDFLLCTRLB_CCDIS() uint8 {
	return (volatile.LoadUint8(&o.DFLLCTRLB.Reg) & 0x10) >> 4
}
func (o *OSCCTRL_Type) SetDFLLCTRLB_QLDIS(value uint8) {
	volatile.StoreUint8(&o.DFLLCTRLB.Reg, volatile.LoadUint8(&o.DFLLCTRLB.Reg)&^(0x20)|value<<5)
}
func (o *OSCCTRL_Type) GetDFLLCTRLB_QLDIS() uint8 {
	return (volatile.LoadUint8(&o.DFLLCTRLB.Reg) & 0x20) >> 5
}
func (o *OSCCTRL_Type) SetDFLLCTRLB_BPLCKC(value uint8) {
	volatile.StoreUint8(&o.DFLLCTRLB.Reg, volatile.LoadUint8(&o.DFLLCTRLB.Reg)&^(0x40)|value<<6)
}
func (o *OSCCTRL_Type) GetDFLLCTRLB_BPLCKC() uint8 {
	return (volatile.LoadUint8(&o.DFLLCTRLB.Reg) & 0x40) >> 6
}
func (o *OSCCTRL_Type) SetDFLLCTRLB_WAITLOCK(value uint8) {
	volatile.StoreUint8(&o.DFLLCTRLB.Reg, volatile.LoadUint8(&o.DFLLCTRLB.Reg)&^(0x80)|value<<7)
}
func (o *OSCCTRL_Type) GetDFLLCTRLB_WAITLOCK() uint8 {
	return (volatile.LoadUint8(&o.DFLLCTRLB.Reg) & 0x80) >> 7
}

// OSCCTRL.DFLLVAL: DFLL48M Value
func (o *OSCCTRL_Type) SetDFLLVAL_FINE(value uint32) {
	volatile.StoreUint32(&o.DFLLVAL.Reg, volatile.LoadUint32(&o.DFLLVAL.Reg)&^(0xff)|value)
}
func (o *OSCCTRL_Type) GetDFLLVAL_FINE() uint32 {
	return volatile.LoadUint32(&o.DFLLVAL.Reg) & 0xff
}
func (o *OSCCTRL_Type) SetDFLLVAL_COARSE(value uint32) {
	volatile.StoreUint32(&o.DFLLVAL.Reg, volatile.LoadUint32(&o.DFLLVAL.Reg)&^(0xfc00)|value<<10)
}
func (o *OSCCTRL_Type) GetDFLLVAL_COARSE() uint32 {
	return (volatile.LoadUint32(&o.DFLLVAL.Reg) & 0xfc00) >> 10
}
func (o *OSCCTRL_Type) SetDFLLVAL_DIFF(value uint32) {
	volatile.StoreUint32(&o.DFLLVAL.Reg, volatile.LoadUint32(&o.DFLLVAL.Reg)&^(0xffff0000)|value<<16)
}
func (o *OSCCTRL_Type) GetDFLLVAL_DIFF() uint32 {
	return (volatile.LoadUint32(&o.DFLLVAL.Reg) & 0xffff0000) >> 16
}

// OSCCTRL.DFLLMUL: DFLL48M Multiplier
func (o *OSCCTRL_Type) SetDFLLMUL_MUL(value uint32) {
	volatile.StoreUint32(&o.DFLLMUL.Reg, volatile.LoadUint32(&o.DFLLMUL.Reg)&^(0xffff)|value)
}
func (o *OSCCTRL_Type) GetDFLLMUL_MUL() uint32 {
	return volatile.LoadUint32(&o.DFLLMUL.Reg) & 0xffff
}
func (o *OSCCTRL_Type) SetDFLLMUL_FSTEP(value uint32) {
	volatile.StoreUint32(&o.DFLLMUL.Reg, volatile.LoadUint32(&o.DFLLMUL.Reg)&^(0xff0000)|value<<16)
}
func (o *OSCCTRL_Type) GetDFLLMUL_FSTEP() uint32 {
	return (volatile.LoadUint32(&o.DFLLMUL.Reg) & 0xff0000) >> 16
}
func (o *OSCCTRL_Type) SetDFLLMUL_CSTEP(value uint32) {
	volatile.StoreUint32(&o.DFLLMUL.Reg, volatile.LoadUint32(&o.DFLLMUL.Reg)&^(0xfc000000)|value<<26)
}
func (o *OSCCTRL_Type) GetDFLLMUL_CSTEP() uint32 {
	return (volatile.LoadUint32(&o.DFLLMUL.Reg) & 0xfc000000) >> 26
}

// OSCCTRL.DFLLSYNC: DFLL48M Synchronization
func (o *OSCCTRL_Type) SetDFLLSYNC_ENABLE(value uint8) {
	volatile.StoreUint8(&o.DFLLSYNC.Reg, volatile.LoadUint8(&o.DFLLSYNC.Reg)&^(0x2)|value<<1)
}
func (o *OSCCTRL_Type) GetDFLLSYNC_ENABLE() uint8 {
	return (volatile.LoadUint8(&o.DFLLSYNC.Reg) & 0x2) >> 1
}
func (o *OSCCTRL_Type) SetDFLLSYNC_DFLLCTRLB(value uint8) {
	volatile.StoreUint8(&o.DFLLSYNC.Reg, volatile.LoadUint8(&o.DFLLSYNC.Reg)&^(0x4)|value<<2)
}
func (o *OSCCTRL_Type) GetDFLLSYNC_DFLLCTRLB() uint8 {
	return (volatile.LoadUint8(&o.DFLLSYNC.Reg) & 0x4) >> 2
}
func (o *OSCCTRL_Type) SetDFLLSYNC_DFLLVAL(value uint8) {
	volatile.StoreUint8(&o.DFLLSYNC.Reg, volatile.LoadUint8(&o.DFLLSYNC.Reg)&^(0x8)|value<<3)
}
func (o *OSCCTRL_Type) GetDFLLSYNC_DFLLVAL() uint8 {
	return (volatile.LoadUint8(&o.DFLLSYNC.Reg) & 0x8) >> 3
}
func (o *OSCCTRL_Type) SetDFLLSYNC_DFLLMUL(value uint8) {
	volatile.StoreUint8(&o.DFLLSYNC.Reg, volatile.LoadUint8(&o.DFLLSYNC.Reg)&^(0x10)|value<<4)
}
func (o *OSCCTRL_Type) GetDFLLSYNC_DFLLMUL() uint8 {
	return (volatile.LoadUint8(&o.DFLLSYNC.Reg) & 0x10) >> 4
}

type OSCCTRL_DPLL_Type struct {
	DPLLCTRLA    volatile.Register8 // 0x30
	_            [3]byte
	DPLLRATIO    volatile.Register32 // 0x34
	DPLLCTRLB    volatile.Register32 // 0x38
	DPLLSYNCBUSY volatile.Register32 // 0x3C
	DPLLSTATUS   volatile.Register32 // 0x40
}

// OSCCTRL_DPLL.DPLLCTRLA: DPLL Control A
func (o *OSCCTRL_DPLL_Type) SetDPLLCTRLA_ENABLE(value uint8) {
	volatile.StoreUint8(&o.DPLLCTRLA.Reg, volatile.LoadUint8(&o.DPLLCTRLA.Reg)&^(0x2)|value<<1)
}
func (o *OSCCTRL_DPLL_Type) GetDPLLCTRLA_ENABLE() uint8 {
	return (volatile.LoadUint8(&o.DPLLCTRLA.Reg) & 0x2) >> 1
}
func (o *OSCCTRL_DPLL_Type) SetDPLLCTRLA_RUNSTDBY(value uint8) {
	volatile.StoreUint8(&o.DPLLCTRLA.Reg, volatile.LoadUint8(&o.DPLLCTRLA.Reg)&^(0x40)|value<<6)
}
func (o *OSCCTRL_DPLL_Type) GetDPLLCTRLA_RUNSTDBY() uint8 {
	return (volatile.LoadUint8(&o.DPLLCTRLA.Reg) & 0x40) >> 6
}
func (o *OSCCTRL_DPLL_Type) SetDPLLCTRLA_ONDEMAND(value uint8) {
	volatile.StoreUint8(&o.DPLLCTRLA.Reg, volatile.LoadUint8(&o.DPLLCTRLA.Reg)&^(0x80)|value<<7)
}
func (o *OSCCTRL_DPLL_Type) GetDPLLCTRLA_ONDEMAND() uint8 {
	return (volatile.LoadUint8(&o.DPLLCTRLA.Reg) & 0x80) >> 7
}

// OSCCTRL_DPLL.DPLLRATIO: DPLL Ratio Control
func (o *OSCCTRL_DPLL_Type) SetDPLLRATIO_LDR(value uint32) {
	volatile.StoreUint32(&o.DPLLRATIO.Reg, volatile.LoadUint32(&o.DPLLRATIO.Reg)&^(0x1fff)|value)
}
func (o *OSCCTRL_DPLL_Type) GetDPLLRATIO_LDR() uint32 {
	return volatile.LoadUint32(&o.DPLLRATIO.Reg) & 0x1fff
}
func (o *OSCCTRL_DPLL_Type) SetDPLLRATIO_LDRFRAC(value uint32) {
	volatile.StoreUint32(&o.DPLLRATIO.Reg, volatile.LoadUint32(&o.DPLLRATIO.Reg)&^(0x1f0000)|value<<16)
}
func (o *OSCCTRL_DPLL_Type) GetDPLLRATIO_LDRFRAC() uint32 {
	return (volatile.LoadUint32(&o.DPLLRATIO.Reg) & 0x1f0000) >> 16
}

// OSCCTRL_DPLL.DPLLCTRLB: DPLL Control B
func (o *OSCCTRL_DPLL_Type) SetDPLLCTRLB_FILTER(value uint32) {
	volatile.StoreUint32(&o.DPLLCTRLB.Reg, volatile.LoadUint32(&o.DPLLCTRLB.Reg)&^(0xf)|value)
}
func (o *OSCCTRL_DPLL_Type) GetDPLLCTRLB_FILTER() uint32 {
	return volatile.LoadUint32(&o.DPLLCTRLB.Reg) & 0xf
}
func (o *OSCCTRL_DPLL_Type) SetDPLLCTRLB_WUF(value uint32) {
	volatile.StoreUint32(&o.DPLLCTRLB.Reg, volatile.LoadUint32(&o.DPLLCTRLB.Reg)&^(0x10)|value<<4)
}
func (o *OSCCTRL_DPLL_Type) GetDPLLCTRLB_WUF() uint32 {
	return (volatile.LoadUint32(&o.DPLLCTRLB.Reg) & 0x10) >> 4
}
func (o *OSCCTRL_DPLL_Type) SetDPLLCTRLB_REFCLK(value uint32) {
	volatile.StoreUint32(&o.DPLLCTRLB.Reg, volatile.LoadUint32(&o.DPLLCTRLB.Reg)&^(0xe0)|value<<5)
}
func (o *OSCCTRL_DPLL_Type) GetDPLLCTRLB_REFCLK() uint32 {
	return (volatile.LoadUint32(&o.DPLLCTRLB.Reg) & 0xe0) >> 5
}
func (o *OSCCTRL_DPLL_Type) SetDPLLCTRLB_LTIME(value uint32) {
	volatile.StoreUint32(&o.DPLLCTRLB.Reg, volatile.LoadUint32(&o.DPLLCTRLB.Reg)&^(0x700)|value<<8)
}
func (o *OSCCTRL_DPLL_Type) GetDPLLCTRLB_LTIME() uint32 {
	return (volatile.LoadUint32(&o.DPLLCTRLB.Reg) & 0x700) >> 8
}
func (o *OSCCTRL_DPLL_Type) SetDPLLCTRLB_LBYPASS(value uint32) {
	volatile.StoreUint32(&o.DPLLCTRLB.Reg, volatile.LoadUint32(&o.DPLLCTRLB.Reg)&^(0x800)|value<<11)
}
func (o *OSCCTRL_DPLL_Type) GetDPLLCTRLB_LBYPASS() uint32 {
	return (volatile.LoadUint32(&o.DPLLCTRLB.Reg) & 0x800) >> 11
}
func (o *OSCCTRL_DPLL_Type) SetDPLLCTRLB_DCOFILTER(value uint32) {
	volatile.StoreUint32(&o.DPLLCTRLB.Reg, volatile.LoadUint32(&o.DPLLCTRLB.Reg)&^(0x7000)|value<<12)
}
func (o *OSCCTRL_DPLL_Type) GetDPLLCTRLB_DCOFILTER() uint32 {
	return (volatile.LoadUint32(&o.DPLLCTRLB.Reg) & 0x7000) >> 12
}
func (o *OSCCTRL_DPLL_Type) SetDPLLCTRLB_DCOEN(value uint32) {
	volatile.StoreUint32(&o.DPLLCTRLB.Reg, volatile.LoadUint32(&o.DPLLCTRLB.Reg)&^(0x8000)|value<<15)
}
func (o *OSCCTRL_DPLL_Type) GetDPLLCTRLB_DCOEN() uint32 {
	return (volatile.LoadUint32(&o.DPLLCTRLB.Reg) & 0x8000) >> 15
}
func (o *OSCCTRL_DPLL_Type) SetDPLLCTRLB_DIV(value uint32) {
	volatile.StoreUint32(&o.DPLLCTRLB.Reg, volatile.LoadUint32(&o.DPLLCTRLB.Reg)&^(0x7ff0000)|value<<16)
}
func (o *OSCCTRL_DPLL_Type) GetDPLLCTRLB_DIV() uint32 {
	return (volatile.LoadUint32(&o.DPLLCTRLB.Reg) & 0x7ff0000) >> 16
}

// OSCCTRL_DPLL.DPLLSYNCBUSY: DPLL Synchronization Busy
func (o *OSCCTRL_DPLL_Type) SetDPLLSYNCBUSY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.DPLLSYNCBUSY.Reg, volatile.LoadUint32(&o.DPLLSYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *OSCCTRL_DPLL_Type) GetDPLLSYNCBUSY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.DPLLSYNCBUSY.Reg) & 0x2) >> 1
}
func (o *OSCCTRL_DPLL_Type) SetDPLLSYNCBUSY_DPLLRATIO(value uint32) {
	volatile.StoreUint32(&o.DPLLSYNCBUSY.Reg, volatile.LoadUint32(&o.DPLLSYNCBUSY.Reg)&^(0x4)|value<<2)
}
func (o *OSCCTRL_DPLL_Type) GetDPLLSYNCBUSY_DPLLRATIO() uint32 {
	return (volatile.LoadUint32(&o.DPLLSYNCBUSY.Reg) & 0x4) >> 2
}

// OSCCTRL_DPLL.DPLLSTATUS: DPLL Status
func (o *OSCCTRL_DPLL_Type) SetDPLLSTATUS_LOCK(value uint32) {
	volatile.StoreUint32(&o.DPLLSTATUS.Reg, volatile.LoadUint32(&o.DPLLSTATUS.Reg)&^(0x1)|value)
}
func (o *OSCCTRL_DPLL_Type) GetDPLLSTATUS_LOCK() uint32 {
	return volatile.LoadUint32(&o.DPLLSTATUS.Reg) & 0x1
}
func (o *OSCCTRL_DPLL_Type) SetDPLLSTATUS_CLKRDY(value uint32) {
	volatile.StoreUint32(&o.DPLLSTATUS.Reg, volatile.LoadUint32(&o.DPLLSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *OSCCTRL_DPLL_Type) GetDPLLSTATUS_CLKRDY() uint32 {
	return (volatile.LoadUint32(&o.DPLLSTATUS.Reg) & 0x2) >> 1
}

// 32kHz Oscillators Control
type OSC32KCTRL_Type struct {
	INTENCLR  volatile.Register32 // 0x0
	INTENSET  volatile.Register32 // 0x4
	INTFLAG   volatile.Register32 // 0x8
	STATUS    volatile.Register32 // 0xC
	RTCCTRL   volatile.Register8  // 0x10
	_         [3]byte
	XOSC32K   volatile.Register16 // 0x14
	CFDCTRL   volatile.Register8  // 0x16
	EVCTRL    volatile.Register8  // 0x17
	_         [4]byte
	OSCULP32K volatile.Register32 // 0x1C
}

// OSC32KCTRL.INTENCLR: Interrupt Enable Clear
func (o *OSC32KCTRL_Type) SetINTENCLR_XOSC32KRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *OSC32KCTRL_Type) GetINTENCLR_XOSC32KRDY() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *OSC32KCTRL_Type) SetINTENCLR_XOSC32KFAIL(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *OSC32KCTRL_Type) GetINTENCLR_XOSC32KFAIL() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}

// OSC32KCTRL.INTENSET: Interrupt Enable Set
func (o *OSC32KCTRL_Type) SetINTENSET_XOSC32KRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *OSC32KCTRL_Type) GetINTENSET_XOSC32KRDY() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *OSC32KCTRL_Type) SetINTENSET_XOSC32KFAIL(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *OSC32KCTRL_Type) GetINTENSET_XOSC32KFAIL() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}

// OSC32KCTRL.INTFLAG: Interrupt Flag Status and Clear
func (o *OSC32KCTRL_Type) SetINTFLAG_XOSC32KRDY(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *OSC32KCTRL_Type) GetINTFLAG_XOSC32KRDY() uint32 {
	return volatile.LoadUint32(&o.INTFLAG.Reg) & 0x1
}
func (o *OSC32KCTRL_Type) SetINTFLAG_XOSC32KFAIL(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x4)|value<<2)
}
func (o *OSC32KCTRL_Type) GetINTFLAG_XOSC32KFAIL() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x4) >> 2
}

// OSC32KCTRL.STATUS: Power and Clocks Status
func (o *OSC32KCTRL_Type) SetSTATUS_XOSC32KRDY(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *OSC32KCTRL_Type) GetSTATUS_XOSC32KRDY() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *OSC32KCTRL_Type) SetSTATUS_XOSC32KFAIL(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *OSC32KCTRL_Type) GetSTATUS_XOSC32KFAIL() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *OSC32KCTRL_Type) SetSTATUS_XOSC32KSW(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *OSC32KCTRL_Type) GetSTATUS_XOSC32KSW() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8) >> 3
}

// OSC32KCTRL.RTCCTRL: RTC Clock Selection
func (o *OSC32KCTRL_Type) SetRTCCTRL_RTCSEL(value uint8) {
	volatile.StoreUint8(&o.RTCCTRL.Reg, volatile.LoadUint8(&o.RTCCTRL.Reg)&^(0x7)|value)
}
func (o *OSC32KCTRL_Type) GetRTCCTRL_RTCSEL() uint8 {
	return volatile.LoadUint8(&o.RTCCTRL.Reg) & 0x7
}

// OSC32KCTRL.XOSC32K: 32kHz External Crystal Oscillator (XOSC32K) Control
func (o *OSC32KCTRL_Type) SetXOSC32K_ENABLE(value uint16) {
	volatile.StoreUint16(&o.XOSC32K.Reg, volatile.LoadUint16(&o.XOSC32K.Reg)&^(0x2)|value<<1)
}
func (o *OSC32KCTRL_Type) GetXOSC32K_ENABLE() uint16 {
	return (volatile.LoadUint16(&o.XOSC32K.Reg) & 0x2) >> 1
}
func (o *OSC32KCTRL_Type) SetXOSC32K_XTALEN(value uint16) {
	volatile.StoreUint16(&o.XOSC32K.Reg, volatile.LoadUint16(&o.XOSC32K.Reg)&^(0x4)|value<<2)
}
func (o *OSC32KCTRL_Type) GetXOSC32K_XTALEN() uint16 {
	return (volatile.LoadUint16(&o.XOSC32K.Reg) & 0x4) >> 2
}
func (o *OSC32KCTRL_Type) SetXOSC32K_EN32K(value uint16) {
	volatile.StoreUint16(&o.XOSC32K.Reg, volatile.LoadUint16(&o.XOSC32K.Reg)&^(0x8)|value<<3)
}
func (o *OSC32KCTRL_Type) GetXOSC32K_EN32K() uint16 {
	return (volatile.LoadUint16(&o.XOSC32K.Reg) & 0x8) >> 3
}
func (o *OSC32KCTRL_Type) SetXOSC32K_EN1K(value uint16) {
	volatile.StoreUint16(&o.XOSC32K.Reg, volatile.LoadUint16(&o.XOSC32K.Reg)&^(0x10)|value<<4)
}
func (o *OSC32KCTRL_Type) GetXOSC32K_EN1K() uint16 {
	return (volatile.LoadUint16(&o.XOSC32K.Reg) & 0x10) >> 4
}
func (o *OSC32KCTRL_Type) SetXOSC32K_RUNSTDBY(value uint16) {
	volatile.StoreUint16(&o.XOSC32K.Reg, volatile.LoadUint16(&o.XOSC32K.Reg)&^(0x40)|value<<6)
}
func (o *OSC32KCTRL_Type) GetXOSC32K_RUNSTDBY() uint16 {
	return (volatile.LoadUint16(&o.XOSC32K.Reg) & 0x40) >> 6
}
func (o *OSC32KCTRL_Type) SetXOSC32K_ONDEMAND(value uint16) {
	volatile.StoreUint16(&o.XOSC32K.Reg, volatile.LoadUint16(&o.XOSC32K.Reg)&^(0x80)|value<<7)
}
func (o *OSC32KCTRL_Type) GetXOSC32K_ONDEMAND() uint16 {
	return (volatile.LoadUint16(&o.XOSC32K.Reg) & 0x80) >> 7
}
func (o *OSC32KCTRL_Type) SetXOSC32K_STARTUP(value uint16) {
	volatile.StoreUint16(&o.XOSC32K.Reg, volatile.LoadUint16(&o.XOSC32K.Reg)&^(0x700)|value<<8)
}
func (o *OSC32KCTRL_Type) GetXOSC32K_STARTUP() uint16 {
	return (volatile.LoadUint16(&o.XOSC32K.Reg) & 0x700) >> 8
}
func (o *OSC32KCTRL_Type) SetXOSC32K_WRTLOCK(value uint16) {
	volatile.StoreUint16(&o.XOSC32K.Reg, volatile.LoadUint16(&o.XOSC32K.Reg)&^(0x1000)|value<<12)
}
func (o *OSC32KCTRL_Type) GetXOSC32K_WRTLOCK() uint16 {
	return (volatile.LoadUint16(&o.XOSC32K.Reg) & 0x1000) >> 12
}
func (o *OSC32KCTRL_Type) SetXOSC32K_CGM(value uint16) {
	volatile.StoreUint16(&o.XOSC32K.Reg, volatile.LoadUint16(&o.XOSC32K.Reg)&^(0x6000)|value<<13)
}
func (o *OSC32KCTRL_Type) GetXOSC32K_CGM() uint16 {
	return (volatile.LoadUint16(&o.XOSC32K.Reg) & 0x6000) >> 13
}

// OSC32KCTRL.CFDCTRL: Clock Failure Detector Control
func (o *OSC32KCTRL_Type) SetCFDCTRL_CFDEN(value uint8) {
	volatile.StoreUint8(&o.CFDCTRL.Reg, volatile.LoadUint8(&o.CFDCTRL.Reg)&^(0x1)|value)
}
func (o *OSC32KCTRL_Type) GetCFDCTRL_CFDEN() uint8 {
	return volatile.LoadUint8(&o.CFDCTRL.Reg) & 0x1
}
func (o *OSC32KCTRL_Type) SetCFDCTRL_SWBACK(value uint8) {
	volatile.StoreUint8(&o.CFDCTRL.Reg, volatile.LoadUint8(&o.CFDCTRL.Reg)&^(0x2)|value<<1)
}
func (o *OSC32KCTRL_Type) GetCFDCTRL_SWBACK() uint8 {
	return (volatile.LoadUint8(&o.CFDCTRL.Reg) & 0x2) >> 1
}
func (o *OSC32KCTRL_Type) SetCFDCTRL_CFDPRESC(value uint8) {
	volatile.StoreUint8(&o.CFDCTRL.Reg, volatile.LoadUint8(&o.CFDCTRL.Reg)&^(0x4)|value<<2)
}
func (o *OSC32KCTRL_Type) GetCFDCTRL_CFDPRESC() uint8 {
	return (volatile.LoadUint8(&o.CFDCTRL.Reg) & 0x4) >> 2
}

// OSC32KCTRL.EVCTRL: Event Control
func (o *OSC32KCTRL_Type) SetEVCTRL_CFDEO(value uint8) {
	volatile.StoreUint8(&o.EVCTRL.Reg, volatile.LoadUint8(&o.EVCTRL.Reg)&^(0x1)|value)
}
func (o *OSC32KCTRL_Type) GetEVCTRL_CFDEO() uint8 {
	return volatile.LoadUint8(&o.EVCTRL.Reg) & 0x1
}

// OSC32KCTRL.OSCULP32K: 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control
func (o *OSC32KCTRL_Type) SetOSCULP32K_EN32K(value uint32) {
	volatile.StoreUint32(&o.OSCULP32K.Reg, volatile.LoadUint32(&o.OSCULP32K.Reg)&^(0x2)|value<<1)
}
func (o *OSC32KCTRL_Type) GetOSCULP32K_EN32K() uint32 {
	return (volatile.LoadUint32(&o.OSCULP32K.Reg) & 0x2) >> 1
}
func (o *OSC32KCTRL_Type) SetOSCULP32K_EN1K(value uint32) {
	volatile.StoreUint32(&o.OSCULP32K.Reg, volatile.LoadUint32(&o.OSCULP32K.Reg)&^(0x4)|value<<2)
}
func (o *OSC32KCTRL_Type) GetOSCULP32K_EN1K() uint32 {
	return (volatile.LoadUint32(&o.OSCULP32K.Reg) & 0x4) >> 2
}
func (o *OSC32KCTRL_Type) SetOSCULP32K_CALIB(value uint32) {
	volatile.StoreUint32(&o.OSCULP32K.Reg, volatile.LoadUint32(&o.OSCULP32K.Reg)&^(0x3f00)|value<<8)
}
func (o *OSC32KCTRL_Type) GetOSCULP32K_CALIB() uint32 {
	return (volatile.LoadUint32(&o.OSCULP32K.Reg) & 0x3f00) >> 8
}
func (o *OSC32KCTRL_Type) SetOSCULP32K_WRTLOCK(value uint32) {
	volatile.StoreUint32(&o.OSCULP32K.Reg, volatile.LoadUint32(&o.OSCULP32K.Reg)&^(0x8000)|value<<15)
}
func (o *OSC32KCTRL_Type) GetOSCULP32K_WRTLOCK() uint32 {
	return (volatile.LoadUint32(&o.OSCULP32K.Reg) & 0x8000) >> 15
}

// Peripheral Access Controller
type PAC_Type struct {
	WRCTRL     volatile.Register32 // 0x0
	EVCTRL     volatile.Register8  // 0x4
	_          [3]byte
	INTENCLR   volatile.Register8 // 0x8
	INTENSET   volatile.Register8 // 0x9
	_          [6]byte
	INTFLAGAHB volatile.Register32 // 0x10
	INTFLAGA   volatile.Register32 // 0x14
	INTFLAGB   volatile.Register32 // 0x18
	INTFLAGC   volatile.Register32 // 0x1C
	INTFLAGD   volatile.Register32 // 0x20
	_          [16]byte
	STATUSA    volatile.Register32 // 0x34
	STATUSB    volatile.Register32 // 0x38
	STATUSC    volatile.Register32 // 0x3C
	STATUSD    volatile.Register32 // 0x40
}

// PAC.WRCTRL: Write control
func (o *PAC_Type) SetWRCTRL_PERID(value uint32) {
	volatile.StoreUint32(&o.WRCTRL.Reg, volatile.LoadUint32(&o.WRCTRL.Reg)&^(0xffff)|value)
}
func (o *PAC_Type) GetWRCTRL_PERID() uint32 {
	return volatile.LoadUint32(&o.WRCTRL.Reg) & 0xffff
}
func (o *PAC_Type) SetWRCTRL_KEY(value uint32) {
	volatile.StoreUint32(&o.WRCTRL.Reg, volatile.LoadUint32(&o.WRCTRL.Reg)&^(0xff0000)|value<<16)
}
func (o *PAC_Type) GetWRCTRL_KEY() uint32 {
	return (volatile.LoadUint32(&o.WRCTRL.Reg) & 0xff0000) >> 16
}

// PAC.EVCTRL: Event control
func (o *PAC_Type) SetEVCTRL_ERREO(value uint8) {
	volatile.StoreUint8(&o.EVCTRL.Reg, volatile.LoadUint8(&o.EVCTRL.Reg)&^(0x1)|value)
}
func (o *PAC_Type) GetEVCTRL_ERREO() uint8 {
	return volatile.LoadUint8(&o.EVCTRL.Reg) & 0x1
}

// PAC.INTENCLR: Interrupt enable clear
func (o *PAC_Type) SetINTENCLR_ERR(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *PAC_Type) GetINTENCLR_ERR() uint8 {
	return volatile.LoadUint8(&o.INTENCLR.Reg) & 0x1
}

// PAC.INTENSET: Interrupt enable set
func (o *PAC_Type) SetINTENSET_ERR(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *PAC_Type) GetINTENSET_ERR() uint8 {
	return volatile.LoadUint8(&o.INTENSET.Reg) & 0x1
}

// PAC.INTFLAGAHB: Bridge interrupt flag status
func (o *PAC_Type) SetINTFLAGAHB_FLASH_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGAHB.Reg, volatile.LoadUint32(&o.INTFLAGAHB.Reg)&^(0x1)|value)
}
func (o *PAC_Type) GetINTFLAGAHB_FLASH_() uint32 {
	return volatile.LoadUint32(&o.INTFLAGAHB.Reg) & 0x1
}
func (o *PAC_Type) SetINTFLAGAHB_FLASH_ALT_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGAHB.Reg, volatile.LoadUint32(&o.INTFLAGAHB.Reg)&^(0x2)|value<<1)
}
func (o *PAC_Type) GetINTFLAGAHB_FLASH_ALT_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGAHB.Reg) & 0x2) >> 1
}
func (o *PAC_Type) SetINTFLAGAHB_SEEPROM_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGAHB.Reg, volatile.LoadUint32(&o.INTFLAGAHB.Reg)&^(0x4)|value<<2)
}
func (o *PAC_Type) GetINTFLAGAHB_SEEPROM_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGAHB.Reg) & 0x4) >> 2
}
func (o *PAC_Type) SetINTFLAGAHB_RAMCM4S_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGAHB.Reg, volatile.LoadUint32(&o.INTFLAGAHB.Reg)&^(0x8)|value<<3)
}
func (o *PAC_Type) GetINTFLAGAHB_RAMCM4S_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGAHB.Reg) & 0x8) >> 3
}
func (o *PAC_Type) SetINTFLAGAHB_RAMPPPDSU_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGAHB.Reg, volatile.LoadUint32(&o.INTFLAGAHB.Reg)&^(0x10)|value<<4)
}
func (o *PAC_Type) GetINTFLAGAHB_RAMPPPDSU_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGAHB.Reg) & 0x10) >> 4
}
func (o *PAC_Type) SetINTFLAGAHB_RAMDMAWR_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGAHB.Reg, volatile.LoadUint32(&o.INTFLAGAHB.Reg)&^(0x20)|value<<5)
}
func (o *PAC_Type) GetINTFLAGAHB_RAMDMAWR_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGAHB.Reg) & 0x20) >> 5
}
func (o *PAC_Type) SetINTFLAGAHB_RAMDMACICM_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGAHB.Reg, volatile.LoadUint32(&o.INTFLAGAHB.Reg)&^(0x40)|value<<6)
}
func (o *PAC_Type) GetINTFLAGAHB_RAMDMACICM_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGAHB.Reg) & 0x40) >> 6
}
func (o *PAC_Type) SetINTFLAGAHB_HPB0_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGAHB.Reg, volatile.LoadUint32(&o.INTFLAGAHB.Reg)&^(0x80)|value<<7)
}
func (o *PAC_Type) GetINTFLAGAHB_HPB0_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGAHB.Reg) & 0x80) >> 7
}
func (o *PAC_Type) SetINTFLAGAHB_HPB1_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGAHB.Reg, volatile.LoadUint32(&o.INTFLAGAHB.Reg)&^(0x100)|value<<8)
}
func (o *PAC_Type) GetINTFLAGAHB_HPB1_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGAHB.Reg) & 0x100) >> 8
}
func (o *PAC_Type) SetINTFLAGAHB_HPB2_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGAHB.Reg, volatile.LoadUint32(&o.INTFLAGAHB.Reg)&^(0x200)|value<<9)
}
func (o *PAC_Type) GetINTFLAGAHB_HPB2_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGAHB.Reg) & 0x200) >> 9
}
func (o *PAC_Type) SetINTFLAGAHB_HPB3_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGAHB.Reg, volatile.LoadUint32(&o.INTFLAGAHB.Reg)&^(0x400)|value<<10)
}
func (o *PAC_Type) GetINTFLAGAHB_HPB3_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGAHB.Reg) & 0x400) >> 10
}
func (o *PAC_Type) SetINTFLAGAHB_PUKCC_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGAHB.Reg, volatile.LoadUint32(&o.INTFLAGAHB.Reg)&^(0x800)|value<<11)
}
func (o *PAC_Type) GetINTFLAGAHB_PUKCC_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGAHB.Reg) & 0x800) >> 11
}
func (o *PAC_Type) SetINTFLAGAHB_SDHC0_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGAHB.Reg, volatile.LoadUint32(&o.INTFLAGAHB.Reg)&^(0x1000)|value<<12)
}
func (o *PAC_Type) GetINTFLAGAHB_SDHC0_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGAHB.Reg) & 0x1000) >> 12
}
func (o *PAC_Type) SetINTFLAGAHB_QSPI_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGAHB.Reg, volatile.LoadUint32(&o.INTFLAGAHB.Reg)&^(0x4000)|value<<14)
}
func (o *PAC_Type) GetINTFLAGAHB_QSPI_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGAHB.Reg) & 0x4000) >> 14
}
func (o *PAC_Type) SetINTFLAGAHB_BKUPRAM_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGAHB.Reg, volatile.LoadUint32(&o.INTFLAGAHB.Reg)&^(0x8000)|value<<15)
}
func (o *PAC_Type) GetINTFLAGAHB_BKUPRAM_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGAHB.Reg) & 0x8000) >> 15
}

// PAC.INTFLAGA: Peripheral interrupt flag status - Bridge A
func (o *PAC_Type) SetINTFLAGA_PAC_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGA.Reg, volatile.LoadUint32(&o.INTFLAGA.Reg)&^(0x1)|value)
}
func (o *PAC_Type) GetINTFLAGA_PAC_() uint32 {
	return volatile.LoadUint32(&o.INTFLAGA.Reg) & 0x1
}
func (o *PAC_Type) SetINTFLAGA_PM_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGA.Reg, volatile.LoadUint32(&o.INTFLAGA.Reg)&^(0x2)|value<<1)
}
func (o *PAC_Type) GetINTFLAGA_PM_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGA.Reg) & 0x2) >> 1
}
func (o *PAC_Type) SetINTFLAGA_MCLK_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGA.Reg, volatile.LoadUint32(&o.INTFLAGA.Reg)&^(0x4)|value<<2)
}
func (o *PAC_Type) GetINTFLAGA_MCLK_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGA.Reg) & 0x4) >> 2
}
func (o *PAC_Type) SetINTFLAGA_RSTC_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGA.Reg, volatile.LoadUint32(&o.INTFLAGA.Reg)&^(0x8)|value<<3)
}
func (o *PAC_Type) GetINTFLAGA_RSTC_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGA.Reg) & 0x8) >> 3
}
func (o *PAC_Type) SetINTFLAGA_OSCCTRL_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGA.Reg, volatile.LoadUint32(&o.INTFLAGA.Reg)&^(0x10)|value<<4)
}
func (o *PAC_Type) GetINTFLAGA_OSCCTRL_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGA.Reg) & 0x10) >> 4
}
func (o *PAC_Type) SetINTFLAGA_OSC32KCTRL_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGA.Reg, volatile.LoadUint32(&o.INTFLAGA.Reg)&^(0x20)|value<<5)
}
func (o *PAC_Type) GetINTFLAGA_OSC32KCTRL_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGA.Reg) & 0x20) >> 5
}
func (o *PAC_Type) SetINTFLAGA_SUPC_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGA.Reg, volatile.LoadUint32(&o.INTFLAGA.Reg)&^(0x40)|value<<6)
}
func (o *PAC_Type) GetINTFLAGA_SUPC_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGA.Reg) & 0x40) >> 6
}
func (o *PAC_Type) SetINTFLAGA_GCLK_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGA.Reg, volatile.LoadUint32(&o.INTFLAGA.Reg)&^(0x80)|value<<7)
}
func (o *PAC_Type) GetINTFLAGA_GCLK_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGA.Reg) & 0x80) >> 7
}
func (o *PAC_Type) SetINTFLAGA_WDT_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGA.Reg, volatile.LoadUint32(&o.INTFLAGA.Reg)&^(0x100)|value<<8)
}
func (o *PAC_Type) GetINTFLAGA_WDT_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGA.Reg) & 0x100) >> 8
}
func (o *PAC_Type) SetINTFLAGA_RTC_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGA.Reg, volatile.LoadUint32(&o.INTFLAGA.Reg)&^(0x200)|value<<9)
}
func (o *PAC_Type) GetINTFLAGA_RTC_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGA.Reg) & 0x200) >> 9
}
func (o *PAC_Type) SetINTFLAGA_EIC_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGA.Reg, volatile.LoadUint32(&o.INTFLAGA.Reg)&^(0x400)|value<<10)
}
func (o *PAC_Type) GetINTFLAGA_EIC_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGA.Reg) & 0x400) >> 10
}
func (o *PAC_Type) SetINTFLAGA_FREQM_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGA.Reg, volatile.LoadUint32(&o.INTFLAGA.Reg)&^(0x800)|value<<11)
}
func (o *PAC_Type) GetINTFLAGA_FREQM_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGA.Reg) & 0x800) >> 11
}
func (o *PAC_Type) SetINTFLAGA_SERCOM0_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGA.Reg, volatile.LoadUint32(&o.INTFLAGA.Reg)&^(0x1000)|value<<12)
}
func (o *PAC_Type) GetINTFLAGA_SERCOM0_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGA.Reg) & 0x1000) >> 12
}
func (o *PAC_Type) SetINTFLAGA_SERCOM1_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGA.Reg, volatile.LoadUint32(&o.INTFLAGA.Reg)&^(0x2000)|value<<13)
}
func (o *PAC_Type) GetINTFLAGA_SERCOM1_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGA.Reg) & 0x2000) >> 13
}
func (o *PAC_Type) SetINTFLAGA_TC0_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGA.Reg, volatile.LoadUint32(&o.INTFLAGA.Reg)&^(0x4000)|value<<14)
}
func (o *PAC_Type) GetINTFLAGA_TC0_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGA.Reg) & 0x4000) >> 14
}
func (o *PAC_Type) SetINTFLAGA_TC1_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGA.Reg, volatile.LoadUint32(&o.INTFLAGA.Reg)&^(0x8000)|value<<15)
}
func (o *PAC_Type) GetINTFLAGA_TC1_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGA.Reg) & 0x8000) >> 15
}

// PAC.INTFLAGB: Peripheral interrupt flag status - Bridge B
func (o *PAC_Type) SetINTFLAGB_USB_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGB.Reg, volatile.LoadUint32(&o.INTFLAGB.Reg)&^(0x1)|value)
}
func (o *PAC_Type) GetINTFLAGB_USB_() uint32 {
	return volatile.LoadUint32(&o.INTFLAGB.Reg) & 0x1
}
func (o *PAC_Type) SetINTFLAGB_DSU_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGB.Reg, volatile.LoadUint32(&o.INTFLAGB.Reg)&^(0x2)|value<<1)
}
func (o *PAC_Type) GetINTFLAGB_DSU_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGB.Reg) & 0x2) >> 1
}
func (o *PAC_Type) SetINTFLAGB_NVMCTRL_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGB.Reg, volatile.LoadUint32(&o.INTFLAGB.Reg)&^(0x4)|value<<2)
}
func (o *PAC_Type) GetINTFLAGB_NVMCTRL_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGB.Reg) & 0x4) >> 2
}
func (o *PAC_Type) SetINTFLAGB_CMCC_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGB.Reg, volatile.LoadUint32(&o.INTFLAGB.Reg)&^(0x8)|value<<3)
}
func (o *PAC_Type) GetINTFLAGB_CMCC_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGB.Reg) & 0x8) >> 3
}
func (o *PAC_Type) SetINTFLAGB_PORT_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGB.Reg, volatile.LoadUint32(&o.INTFLAGB.Reg)&^(0x10)|value<<4)
}
func (o *PAC_Type) GetINTFLAGB_PORT_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGB.Reg) & 0x10) >> 4
}
func (o *PAC_Type) SetINTFLAGB_DMAC_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGB.Reg, volatile.LoadUint32(&o.INTFLAGB.Reg)&^(0x20)|value<<5)
}
func (o *PAC_Type) GetINTFLAGB_DMAC_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGB.Reg) & 0x20) >> 5
}
func (o *PAC_Type) SetINTFLAGB_HMATRIX_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGB.Reg, volatile.LoadUint32(&o.INTFLAGB.Reg)&^(0x40)|value<<6)
}
func (o *PAC_Type) GetINTFLAGB_HMATRIX_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGB.Reg) & 0x40) >> 6
}
func (o *PAC_Type) SetINTFLAGB_EVSYS_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGB.Reg, volatile.LoadUint32(&o.INTFLAGB.Reg)&^(0x80)|value<<7)
}
func (o *PAC_Type) GetINTFLAGB_EVSYS_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGB.Reg) & 0x80) >> 7
}
func (o *PAC_Type) SetINTFLAGB_SERCOM2_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGB.Reg, volatile.LoadUint32(&o.INTFLAGB.Reg)&^(0x200)|value<<9)
}
func (o *PAC_Type) GetINTFLAGB_SERCOM2_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGB.Reg) & 0x200) >> 9
}
func (o *PAC_Type) SetINTFLAGB_SERCOM3_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGB.Reg, volatile.LoadUint32(&o.INTFLAGB.Reg)&^(0x400)|value<<10)
}
func (o *PAC_Type) GetINTFLAGB_SERCOM3_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGB.Reg) & 0x400) >> 10
}
func (o *PAC_Type) SetINTFLAGB_TCC0_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGB.Reg, volatile.LoadUint32(&o.INTFLAGB.Reg)&^(0x800)|value<<11)
}
func (o *PAC_Type) GetINTFLAGB_TCC0_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGB.Reg) & 0x800) >> 11
}
func (o *PAC_Type) SetINTFLAGB_TCC1_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGB.Reg, volatile.LoadUint32(&o.INTFLAGB.Reg)&^(0x1000)|value<<12)
}
func (o *PAC_Type) GetINTFLAGB_TCC1_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGB.Reg) & 0x1000) >> 12
}
func (o *PAC_Type) SetINTFLAGB_TC2_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGB.Reg, volatile.LoadUint32(&o.INTFLAGB.Reg)&^(0x2000)|value<<13)
}
func (o *PAC_Type) GetINTFLAGB_TC2_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGB.Reg) & 0x2000) >> 13
}
func (o *PAC_Type) SetINTFLAGB_TC3_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGB.Reg, volatile.LoadUint32(&o.INTFLAGB.Reg)&^(0x4000)|value<<14)
}
func (o *PAC_Type) GetINTFLAGB_TC3_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGB.Reg) & 0x4000) >> 14
}
func (o *PAC_Type) SetINTFLAGB_RAMECC_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGB.Reg, volatile.LoadUint32(&o.INTFLAGB.Reg)&^(0x10000)|value<<16)
}
func (o *PAC_Type) GetINTFLAGB_RAMECC_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGB.Reg) & 0x10000) >> 16
}

// PAC.INTFLAGC: Peripheral interrupt flag status - Bridge C
func (o *PAC_Type) SetINTFLAGC_GMAC_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGC.Reg, volatile.LoadUint32(&o.INTFLAGC.Reg)&^(0x4)|value<<2)
}
func (o *PAC_Type) GetINTFLAGC_GMAC_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGC.Reg) & 0x4) >> 2
}
func (o *PAC_Type) SetINTFLAGC_TCC2_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGC.Reg, volatile.LoadUint32(&o.INTFLAGC.Reg)&^(0x8)|value<<3)
}
func (o *PAC_Type) GetINTFLAGC_TCC2_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGC.Reg) & 0x8) >> 3
}
func (o *PAC_Type) SetINTFLAGC_TCC3_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGC.Reg, volatile.LoadUint32(&o.INTFLAGC.Reg)&^(0x10)|value<<4)
}
func (o *PAC_Type) GetINTFLAGC_TCC3_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGC.Reg) & 0x10) >> 4
}
func (o *PAC_Type) SetINTFLAGC_TC4_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGC.Reg, volatile.LoadUint32(&o.INTFLAGC.Reg)&^(0x20)|value<<5)
}
func (o *PAC_Type) GetINTFLAGC_TC4_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGC.Reg) & 0x20) >> 5
}
func (o *PAC_Type) SetINTFLAGC_TC5_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGC.Reg, volatile.LoadUint32(&o.INTFLAGC.Reg)&^(0x40)|value<<6)
}
func (o *PAC_Type) GetINTFLAGC_TC5_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGC.Reg) & 0x40) >> 6
}
func (o *PAC_Type) SetINTFLAGC_PDEC_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGC.Reg, volatile.LoadUint32(&o.INTFLAGC.Reg)&^(0x80)|value<<7)
}
func (o *PAC_Type) GetINTFLAGC_PDEC_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGC.Reg) & 0x80) >> 7
}
func (o *PAC_Type) SetINTFLAGC_AC_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGC.Reg, volatile.LoadUint32(&o.INTFLAGC.Reg)&^(0x100)|value<<8)
}
func (o *PAC_Type) GetINTFLAGC_AC_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGC.Reg) & 0x100) >> 8
}
func (o *PAC_Type) SetINTFLAGC_AES_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGC.Reg, volatile.LoadUint32(&o.INTFLAGC.Reg)&^(0x200)|value<<9)
}
func (o *PAC_Type) GetINTFLAGC_AES_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGC.Reg) & 0x200) >> 9
}
func (o *PAC_Type) SetINTFLAGC_TRNG_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGC.Reg, volatile.LoadUint32(&o.INTFLAGC.Reg)&^(0x400)|value<<10)
}
func (o *PAC_Type) GetINTFLAGC_TRNG_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGC.Reg) & 0x400) >> 10
}
func (o *PAC_Type) SetINTFLAGC_ICM_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGC.Reg, volatile.LoadUint32(&o.INTFLAGC.Reg)&^(0x800)|value<<11)
}
func (o *PAC_Type) GetINTFLAGC_ICM_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGC.Reg) & 0x800) >> 11
}
func (o *PAC_Type) SetINTFLAGC_PUKCC_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGC.Reg, volatile.LoadUint32(&o.INTFLAGC.Reg)&^(0x1000)|value<<12)
}
func (o *PAC_Type) GetINTFLAGC_PUKCC_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGC.Reg) & 0x1000) >> 12
}
func (o *PAC_Type) SetINTFLAGC_QSPI_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGC.Reg, volatile.LoadUint32(&o.INTFLAGC.Reg)&^(0x2000)|value<<13)
}
func (o *PAC_Type) GetINTFLAGC_QSPI_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGC.Reg) & 0x2000) >> 13
}
func (o *PAC_Type) SetINTFLAGC_CCL_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGC.Reg, volatile.LoadUint32(&o.INTFLAGC.Reg)&^(0x4000)|value<<14)
}
func (o *PAC_Type) GetINTFLAGC_CCL_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGC.Reg) & 0x4000) >> 14
}

// PAC.INTFLAGD: Peripheral interrupt flag status - Bridge D
func (o *PAC_Type) SetINTFLAGD_SERCOM4_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGD.Reg, volatile.LoadUint32(&o.INTFLAGD.Reg)&^(0x1)|value)
}
func (o *PAC_Type) GetINTFLAGD_SERCOM4_() uint32 {
	return volatile.LoadUint32(&o.INTFLAGD.Reg) & 0x1
}
func (o *PAC_Type) SetINTFLAGD_SERCOM5_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGD.Reg, volatile.LoadUint32(&o.INTFLAGD.Reg)&^(0x2)|value<<1)
}
func (o *PAC_Type) GetINTFLAGD_SERCOM5_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGD.Reg) & 0x2) >> 1
}
func (o *PAC_Type) SetINTFLAGD_TCC4_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGD.Reg, volatile.LoadUint32(&o.INTFLAGD.Reg)&^(0x10)|value<<4)
}
func (o *PAC_Type) GetINTFLAGD_TCC4_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGD.Reg) & 0x10) >> 4
}
func (o *PAC_Type) SetINTFLAGD_ADC0_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGD.Reg, volatile.LoadUint32(&o.INTFLAGD.Reg)&^(0x80)|value<<7)
}
func (o *PAC_Type) GetINTFLAGD_ADC0_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGD.Reg) & 0x80) >> 7
}
func (o *PAC_Type) SetINTFLAGD_ADC1_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGD.Reg, volatile.LoadUint32(&o.INTFLAGD.Reg)&^(0x100)|value<<8)
}
func (o *PAC_Type) GetINTFLAGD_ADC1_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGD.Reg) & 0x100) >> 8
}
func (o *PAC_Type) SetINTFLAGD_DAC_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGD.Reg, volatile.LoadUint32(&o.INTFLAGD.Reg)&^(0x200)|value<<9)
}
func (o *PAC_Type) GetINTFLAGD_DAC_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGD.Reg) & 0x200) >> 9
}
func (o *PAC_Type) SetINTFLAGD_I2S_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGD.Reg, volatile.LoadUint32(&o.INTFLAGD.Reg)&^(0x400)|value<<10)
}
func (o *PAC_Type) GetINTFLAGD_I2S_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGD.Reg) & 0x400) >> 10
}
func (o *PAC_Type) SetINTFLAGD_PCC_(value uint32) {
	volatile.StoreUint32(&o.INTFLAGD.Reg, volatile.LoadUint32(&o.INTFLAGD.Reg)&^(0x800)|value<<11)
}
func (o *PAC_Type) GetINTFLAGD_PCC_() uint32 {
	return (volatile.LoadUint32(&o.INTFLAGD.Reg) & 0x800) >> 11
}

// PAC.STATUSA: Peripheral write protection status - Bridge A
func (o *PAC_Type) SetSTATUSA_PAC_(value uint32) {
	volatile.StoreUint32(&o.STATUSA.Reg, volatile.LoadUint32(&o.STATUSA.Reg)&^(0x1)|value)
}
func (o *PAC_Type) GetSTATUSA_PAC_() uint32 {
	return volatile.LoadUint32(&o.STATUSA.Reg) & 0x1
}
func (o *PAC_Type) SetSTATUSA_PM_(value uint32) {
	volatile.StoreUint32(&o.STATUSA.Reg, volatile.LoadUint32(&o.STATUSA.Reg)&^(0x2)|value<<1)
}
func (o *PAC_Type) GetSTATUSA_PM_() uint32 {
	return (volatile.LoadUint32(&o.STATUSA.Reg) & 0x2) >> 1
}
func (o *PAC_Type) SetSTATUSA_MCLK_(value uint32) {
	volatile.StoreUint32(&o.STATUSA.Reg, volatile.LoadUint32(&o.STATUSA.Reg)&^(0x4)|value<<2)
}
func (o *PAC_Type) GetSTATUSA_MCLK_() uint32 {
	return (volatile.LoadUint32(&o.STATUSA.Reg) & 0x4) >> 2
}
func (o *PAC_Type) SetSTATUSA_RSTC_(value uint32) {
	volatile.StoreUint32(&o.STATUSA.Reg, volatile.LoadUint32(&o.STATUSA.Reg)&^(0x8)|value<<3)
}
func (o *PAC_Type) GetSTATUSA_RSTC_() uint32 {
	return (volatile.LoadUint32(&o.STATUSA.Reg) & 0x8) >> 3
}
func (o *PAC_Type) SetSTATUSA_OSCCTRL_(value uint32) {
	volatile.StoreUint32(&o.STATUSA.Reg, volatile.LoadUint32(&o.STATUSA.Reg)&^(0x10)|value<<4)
}
func (o *PAC_Type) GetSTATUSA_OSCCTRL_() uint32 {
	return (volatile.LoadUint32(&o.STATUSA.Reg) & 0x10) >> 4
}
func (o *PAC_Type) SetSTATUSA_OSC32KCTRL_(value uint32) {
	volatile.StoreUint32(&o.STATUSA.Reg, volatile.LoadUint32(&o.STATUSA.Reg)&^(0x20)|value<<5)
}
func (o *PAC_Type) GetSTATUSA_OSC32KCTRL_() uint32 {
	return (volatile.LoadUint32(&o.STATUSA.Reg) & 0x20) >> 5
}
func (o *PAC_Type) SetSTATUSA_SUPC_(value uint32) {
	volatile.StoreUint32(&o.STATUSA.Reg, volatile.LoadUint32(&o.STATUSA.Reg)&^(0x40)|value<<6)
}
func (o *PAC_Type) GetSTATUSA_SUPC_() uint32 {
	return (volatile.LoadUint32(&o.STATUSA.Reg) & 0x40) >> 6
}
func (o *PAC_Type) SetSTATUSA_GCLK_(value uint32) {
	volatile.StoreUint32(&o.STATUSA.Reg, volatile.LoadUint32(&o.STATUSA.Reg)&^(0x80)|value<<7)
}
func (o *PAC_Type) GetSTATUSA_GCLK_() uint32 {
	return (volatile.LoadUint32(&o.STATUSA.Reg) & 0x80) >> 7
}
func (o *PAC_Type) SetSTATUSA_WDT_(value uint32) {
	volatile.StoreUint32(&o.STATUSA.Reg, volatile.LoadUint32(&o.STATUSA.Reg)&^(0x100)|value<<8)
}
func (o *PAC_Type) GetSTATUSA_WDT_() uint32 {
	return (volatile.LoadUint32(&o.STATUSA.Reg) & 0x100) >> 8
}
func (o *PAC_Type) SetSTATUSA_RTC_(value uint32) {
	volatile.StoreUint32(&o.STATUSA.Reg, volatile.LoadUint32(&o.STATUSA.Reg)&^(0x200)|value<<9)
}
func (o *PAC_Type) GetSTATUSA_RTC_() uint32 {
	return (volatile.LoadUint32(&o.STATUSA.Reg) & 0x200) >> 9
}
func (o *PAC_Type) SetSTATUSA_EIC_(value uint32) {
	volatile.StoreUint32(&o.STATUSA.Reg, volatile.LoadUint32(&o.STATUSA.Reg)&^(0x400)|value<<10)
}
func (o *PAC_Type) GetSTATUSA_EIC_() uint32 {
	return (volatile.LoadUint32(&o.STATUSA.Reg) & 0x400) >> 10
}
func (o *PAC_Type) SetSTATUSA_FREQM_(value uint32) {
	volatile.StoreUint32(&o.STATUSA.Reg, volatile.LoadUint32(&o.STATUSA.Reg)&^(0x800)|value<<11)
}
func (o *PAC_Type) GetSTATUSA_FREQM_() uint32 {
	return (volatile.LoadUint32(&o.STATUSA.Reg) & 0x800) >> 11
}
func (o *PAC_Type) SetSTATUSA_SERCOM0_(value uint32) {
	volatile.StoreUint32(&o.STATUSA.Reg, volatile.LoadUint32(&o.STATUSA.Reg)&^(0x1000)|value<<12)
}
func (o *PAC_Type) GetSTATUSA_SERCOM0_() uint32 {
	return (volatile.LoadUint32(&o.STATUSA.Reg) & 0x1000) >> 12
}
func (o *PAC_Type) SetSTATUSA_SERCOM1_(value uint32) {
	volatile.StoreUint32(&o.STATUSA.Reg, volatile.LoadUint32(&o.STATUSA.Reg)&^(0x2000)|value<<13)
}
func (o *PAC_Type) GetSTATUSA_SERCOM1_() uint32 {
	return (volatile.LoadUint32(&o.STATUSA.Reg) & 0x2000) >> 13
}
func (o *PAC_Type) SetSTATUSA_TC0_(value uint32) {
	volatile.StoreUint32(&o.STATUSA.Reg, volatile.LoadUint32(&o.STATUSA.Reg)&^(0x4000)|value<<14)
}
func (o *PAC_Type) GetSTATUSA_TC0_() uint32 {
	return (volatile.LoadUint32(&o.STATUSA.Reg) & 0x4000) >> 14
}
func (o *PAC_Type) SetSTATUSA_TC1_(value uint32) {
	volatile.StoreUint32(&o.STATUSA.Reg, volatile.LoadUint32(&o.STATUSA.Reg)&^(0x8000)|value<<15)
}
func (o *PAC_Type) GetSTATUSA_TC1_() uint32 {
	return (volatile.LoadUint32(&o.STATUSA.Reg) & 0x8000) >> 15
}

// PAC.STATUSB: Peripheral write protection status - Bridge B
func (o *PAC_Type) SetSTATUSB_USB_(value uint32) {
	volatile.StoreUint32(&o.STATUSB.Reg, volatile.LoadUint32(&o.STATUSB.Reg)&^(0x1)|value)
}
func (o *PAC_Type) GetSTATUSB_USB_() uint32 {
	return volatile.LoadUint32(&o.STATUSB.Reg) & 0x1
}
func (o *PAC_Type) SetSTATUSB_DSU_(value uint32) {
	volatile.StoreUint32(&o.STATUSB.Reg, volatile.LoadUint32(&o.STATUSB.Reg)&^(0x2)|value<<1)
}
func (o *PAC_Type) GetSTATUSB_DSU_() uint32 {
	return (volatile.LoadUint32(&o.STATUSB.Reg) & 0x2) >> 1
}
func (o *PAC_Type) SetSTATUSB_NVMCTRL_(value uint32) {
	volatile.StoreUint32(&o.STATUSB.Reg, volatile.LoadUint32(&o.STATUSB.Reg)&^(0x4)|value<<2)
}
func (o *PAC_Type) GetSTATUSB_NVMCTRL_() uint32 {
	return (volatile.LoadUint32(&o.STATUSB.Reg) & 0x4) >> 2
}
func (o *PAC_Type) SetSTATUSB_CMCC_(value uint32) {
	volatile.StoreUint32(&o.STATUSB.Reg, volatile.LoadUint32(&o.STATUSB.Reg)&^(0x8)|value<<3)
}
func (o *PAC_Type) GetSTATUSB_CMCC_() uint32 {
	return (volatile.LoadUint32(&o.STATUSB.Reg) & 0x8) >> 3
}
func (o *PAC_Type) SetSTATUSB_PORT_(value uint32) {
	volatile.StoreUint32(&o.STATUSB.Reg, volatile.LoadUint32(&o.STATUSB.Reg)&^(0x10)|value<<4)
}
func (o *PAC_Type) GetSTATUSB_PORT_() uint32 {
	return (volatile.LoadUint32(&o.STATUSB.Reg) & 0x10) >> 4
}
func (o *PAC_Type) SetSTATUSB_DMAC_(value uint32) {
	volatile.StoreUint32(&o.STATUSB.Reg, volatile.LoadUint32(&o.STATUSB.Reg)&^(0x20)|value<<5)
}
func (o *PAC_Type) GetSTATUSB_DMAC_() uint32 {
	return (volatile.LoadUint32(&o.STATUSB.Reg) & 0x20) >> 5
}
func (o *PAC_Type) SetSTATUSB_HMATRIX_(value uint32) {
	volatile.StoreUint32(&o.STATUSB.Reg, volatile.LoadUint32(&o.STATUSB.Reg)&^(0x40)|value<<6)
}
func (o *PAC_Type) GetSTATUSB_HMATRIX_() uint32 {
	return (volatile.LoadUint32(&o.STATUSB.Reg) & 0x40) >> 6
}
func (o *PAC_Type) SetSTATUSB_EVSYS_(value uint32) {
	volatile.StoreUint32(&o.STATUSB.Reg, volatile.LoadUint32(&o.STATUSB.Reg)&^(0x80)|value<<7)
}
func (o *PAC_Type) GetSTATUSB_EVSYS_() uint32 {
	return (volatile.LoadUint32(&o.STATUSB.Reg) & 0x80) >> 7
}
func (o *PAC_Type) SetSTATUSB_SERCOM2_(value uint32) {
	volatile.StoreUint32(&o.STATUSB.Reg, volatile.LoadUint32(&o.STATUSB.Reg)&^(0x200)|value<<9)
}
func (o *PAC_Type) GetSTATUSB_SERCOM2_() uint32 {
	return (volatile.LoadUint32(&o.STATUSB.Reg) & 0x200) >> 9
}
func (o *PAC_Type) SetSTATUSB_SERCOM3_(value uint32) {
	volatile.StoreUint32(&o.STATUSB.Reg, volatile.LoadUint32(&o.STATUSB.Reg)&^(0x400)|value<<10)
}
func (o *PAC_Type) GetSTATUSB_SERCOM3_() uint32 {
	return (volatile.LoadUint32(&o.STATUSB.Reg) & 0x400) >> 10
}
func (o *PAC_Type) SetSTATUSB_TCC0_(value uint32) {
	volatile.StoreUint32(&o.STATUSB.Reg, volatile.LoadUint32(&o.STATUSB.Reg)&^(0x800)|value<<11)
}
func (o *PAC_Type) GetSTATUSB_TCC0_() uint32 {
	return (volatile.LoadUint32(&o.STATUSB.Reg) & 0x800) >> 11
}
func (o *PAC_Type) SetSTATUSB_TCC1_(value uint32) {
	volatile.StoreUint32(&o.STATUSB.Reg, volatile.LoadUint32(&o.STATUSB.Reg)&^(0x1000)|value<<12)
}
func (o *PAC_Type) GetSTATUSB_TCC1_() uint32 {
	return (volatile.LoadUint32(&o.STATUSB.Reg) & 0x1000) >> 12
}
func (o *PAC_Type) SetSTATUSB_TC2_(value uint32) {
	volatile.StoreUint32(&o.STATUSB.Reg, volatile.LoadUint32(&o.STATUSB.Reg)&^(0x2000)|value<<13)
}
func (o *PAC_Type) GetSTATUSB_TC2_() uint32 {
	return (volatile.LoadUint32(&o.STATUSB.Reg) & 0x2000) >> 13
}
func (o *PAC_Type) SetSTATUSB_TC3_(value uint32) {
	volatile.StoreUint32(&o.STATUSB.Reg, volatile.LoadUint32(&o.STATUSB.Reg)&^(0x4000)|value<<14)
}
func (o *PAC_Type) GetSTATUSB_TC3_() uint32 {
	return (volatile.LoadUint32(&o.STATUSB.Reg) & 0x4000) >> 14
}
func (o *PAC_Type) SetSTATUSB_RAMECC_(value uint32) {
	volatile.StoreUint32(&o.STATUSB.Reg, volatile.LoadUint32(&o.STATUSB.Reg)&^(0x10000)|value<<16)
}
func (o *PAC_Type) GetSTATUSB_RAMECC_() uint32 {
	return (volatile.LoadUint32(&o.STATUSB.Reg) & 0x10000) >> 16
}

// PAC.STATUSC: Peripheral write protection status - Bridge C
func (o *PAC_Type) SetSTATUSC_GMAC_(value uint32) {
	volatile.StoreUint32(&o.STATUSC.Reg, volatile.LoadUint32(&o.STATUSC.Reg)&^(0x4)|value<<2)
}
func (o *PAC_Type) GetSTATUSC_GMAC_() uint32 {
	return (volatile.LoadUint32(&o.STATUSC.Reg) & 0x4) >> 2
}
func (o *PAC_Type) SetSTATUSC_TCC2_(value uint32) {
	volatile.StoreUint32(&o.STATUSC.Reg, volatile.LoadUint32(&o.STATUSC.Reg)&^(0x8)|value<<3)
}
func (o *PAC_Type) GetSTATUSC_TCC2_() uint32 {
	return (volatile.LoadUint32(&o.STATUSC.Reg) & 0x8) >> 3
}
func (o *PAC_Type) SetSTATUSC_TCC3_(value uint32) {
	volatile.StoreUint32(&o.STATUSC.Reg, volatile.LoadUint32(&o.STATUSC.Reg)&^(0x10)|value<<4)
}
func (o *PAC_Type) GetSTATUSC_TCC3_() uint32 {
	return (volatile.LoadUint32(&o.STATUSC.Reg) & 0x10) >> 4
}
func (o *PAC_Type) SetSTATUSC_TC4_(value uint32) {
	volatile.StoreUint32(&o.STATUSC.Reg, volatile.LoadUint32(&o.STATUSC.Reg)&^(0x20)|value<<5)
}
func (o *PAC_Type) GetSTATUSC_TC4_() uint32 {
	return (volatile.LoadUint32(&o.STATUSC.Reg) & 0x20) >> 5
}
func (o *PAC_Type) SetSTATUSC_TC5_(value uint32) {
	volatile.StoreUint32(&o.STATUSC.Reg, volatile.LoadUint32(&o.STATUSC.Reg)&^(0x40)|value<<6)
}
func (o *PAC_Type) GetSTATUSC_TC5_() uint32 {
	return (volatile.LoadUint32(&o.STATUSC.Reg) & 0x40) >> 6
}
func (o *PAC_Type) SetSTATUSC_PDEC_(value uint32) {
	volatile.StoreUint32(&o.STATUSC.Reg, volatile.LoadUint32(&o.STATUSC.Reg)&^(0x80)|value<<7)
}
func (o *PAC_Type) GetSTATUSC_PDEC_() uint32 {
	return (volatile.LoadUint32(&o.STATUSC.Reg) & 0x80) >> 7
}
func (o *PAC_Type) SetSTATUSC_AC_(value uint32) {
	volatile.StoreUint32(&o.STATUSC.Reg, volatile.LoadUint32(&o.STATUSC.Reg)&^(0x100)|value<<8)
}
func (o *PAC_Type) GetSTATUSC_AC_() uint32 {
	return (volatile.LoadUint32(&o.STATUSC.Reg) & 0x100) >> 8
}
func (o *PAC_Type) SetSTATUSC_AES_(value uint32) {
	volatile.StoreUint32(&o.STATUSC.Reg, volatile.LoadUint32(&o.STATUSC.Reg)&^(0x200)|value<<9)
}
func (o *PAC_Type) GetSTATUSC_AES_() uint32 {
	return (volatile.LoadUint32(&o.STATUSC.Reg) & 0x200) >> 9
}
func (o *PAC_Type) SetSTATUSC_TRNG_(value uint32) {
	volatile.StoreUint32(&o.STATUSC.Reg, volatile.LoadUint32(&o.STATUSC.Reg)&^(0x400)|value<<10)
}
func (o *PAC_Type) GetSTATUSC_TRNG_() uint32 {
	return (volatile.LoadUint32(&o.STATUSC.Reg) & 0x400) >> 10
}
func (o *PAC_Type) SetSTATUSC_ICM_(value uint32) {
	volatile.StoreUint32(&o.STATUSC.Reg, volatile.LoadUint32(&o.STATUSC.Reg)&^(0x800)|value<<11)
}
func (o *PAC_Type) GetSTATUSC_ICM_() uint32 {
	return (volatile.LoadUint32(&o.STATUSC.Reg) & 0x800) >> 11
}
func (o *PAC_Type) SetSTATUSC_PUKCC_(value uint32) {
	volatile.StoreUint32(&o.STATUSC.Reg, volatile.LoadUint32(&o.STATUSC.Reg)&^(0x1000)|value<<12)
}
func (o *PAC_Type) GetSTATUSC_PUKCC_() uint32 {
	return (volatile.LoadUint32(&o.STATUSC.Reg) & 0x1000) >> 12
}
func (o *PAC_Type) SetSTATUSC_QSPI_(value uint32) {
	volatile.StoreUint32(&o.STATUSC.Reg, volatile.LoadUint32(&o.STATUSC.Reg)&^(0x2000)|value<<13)
}
func (o *PAC_Type) GetSTATUSC_QSPI_() uint32 {
	return (volatile.LoadUint32(&o.STATUSC.Reg) & 0x2000) >> 13
}
func (o *PAC_Type) SetSTATUSC_CCL_(value uint32) {
	volatile.StoreUint32(&o.STATUSC.Reg, volatile.LoadUint32(&o.STATUSC.Reg)&^(0x4000)|value<<14)
}
func (o *PAC_Type) GetSTATUSC_CCL_() uint32 {
	return (volatile.LoadUint32(&o.STATUSC.Reg) & 0x4000) >> 14
}

// PAC.STATUSD: Peripheral write protection status - Bridge D
func (o *PAC_Type) SetSTATUSD_SERCOM4_(value uint32) {
	volatile.StoreUint32(&o.STATUSD.Reg, volatile.LoadUint32(&o.STATUSD.Reg)&^(0x1)|value)
}
func (o *PAC_Type) GetSTATUSD_SERCOM4_() uint32 {
	return volatile.LoadUint32(&o.STATUSD.Reg) & 0x1
}
func (o *PAC_Type) SetSTATUSD_SERCOM5_(value uint32) {
	volatile.StoreUint32(&o.STATUSD.Reg, volatile.LoadUint32(&o.STATUSD.Reg)&^(0x2)|value<<1)
}
func (o *PAC_Type) GetSTATUSD_SERCOM5_() uint32 {
	return (volatile.LoadUint32(&o.STATUSD.Reg) & 0x2) >> 1
}
func (o *PAC_Type) SetSTATUSD_TCC4_(value uint32) {
	volatile.StoreUint32(&o.STATUSD.Reg, volatile.LoadUint32(&o.STATUSD.Reg)&^(0x10)|value<<4)
}
func (o *PAC_Type) GetSTATUSD_TCC4_() uint32 {
	return (volatile.LoadUint32(&o.STATUSD.Reg) & 0x10) >> 4
}
func (o *PAC_Type) SetSTATUSD_ADC0_(value uint32) {
	volatile.StoreUint32(&o.STATUSD.Reg, volatile.LoadUint32(&o.STATUSD.Reg)&^(0x80)|value<<7)
}
func (o *PAC_Type) GetSTATUSD_ADC0_() uint32 {
	return (volatile.LoadUint32(&o.STATUSD.Reg) & 0x80) >> 7
}
func (o *PAC_Type) SetSTATUSD_ADC1_(value uint32) {
	volatile.StoreUint32(&o.STATUSD.Reg, volatile.LoadUint32(&o.STATUSD.Reg)&^(0x100)|value<<8)
}
func (o *PAC_Type) GetSTATUSD_ADC1_() uint32 {
	return (volatile.LoadUint32(&o.STATUSD.Reg) & 0x100) >> 8
}
func (o *PAC_Type) SetSTATUSD_DAC_(value uint32) {
	volatile.StoreUint32(&o.STATUSD.Reg, volatile.LoadUint32(&o.STATUSD.Reg)&^(0x200)|value<<9)
}
func (o *PAC_Type) GetSTATUSD_DAC_() uint32 {
	return (volatile.LoadUint32(&o.STATUSD.Reg) & 0x200) >> 9
}
func (o *PAC_Type) SetSTATUSD_I2S_(value uint32) {
	volatile.StoreUint32(&o.STATUSD.Reg, volatile.LoadUint32(&o.STATUSD.Reg)&^(0x400)|value<<10)
}
func (o *PAC_Type) GetSTATUSD_I2S_() uint32 {
	return (volatile.LoadUint32(&o.STATUSD.Reg) & 0x400) >> 10
}
func (o *PAC_Type) SetSTATUSD_PCC_(value uint32) {
	volatile.StoreUint32(&o.STATUSD.Reg, volatile.LoadUint32(&o.STATUSD.Reg)&^(0x800)|value<<11)
}
func (o *PAC_Type) GetSTATUSD_PCC_() uint32 {
	return (volatile.LoadUint32(&o.STATUSD.Reg) & 0x800) >> 11
}

// Parallel Capture Controller
type PCC_Type struct {
	MR   volatile.Register32 // 0x0
	IER  volatile.Register32 // 0x4
	IDR  volatile.Register32 // 0x8
	IMR  volatile.Register32 // 0xC
	ISR  volatile.Register32 // 0x10
	RHR  volatile.Register32 // 0x14
	_    [200]byte
	WPMR volatile.Register32 // 0xE0
	WPSR volatile.Register32 // 0xE4
}

// PCC.MR: Mode Register
func (o *PCC_Type) SetMR_PCEN(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x1)|value)
}
func (o *PCC_Type) GetMR_PCEN() uint32 {
	return volatile.LoadUint32(&o.MR.Reg) & 0x1
}
func (o *PCC_Type) SetMR_DSIZE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x30)|value<<4)
}
func (o *PCC_Type) GetMR_DSIZE() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x30) >> 4
}
func (o *PCC_Type) SetMR_SCALE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x100)|value<<8)
}
func (o *PCC_Type) GetMR_SCALE() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x100) >> 8
}
func (o *PCC_Type) SetMR_ALWYS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x200)|value<<9)
}
func (o *PCC_Type) GetMR_ALWYS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x200) >> 9
}
func (o *PCC_Type) SetMR_HALFS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x400)|value<<10)
}
func (o *PCC_Type) GetMR_HALFS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x400) >> 10
}
func (o *PCC_Type) SetMR_FRSTS(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x800)|value<<11)
}
func (o *PCC_Type) GetMR_FRSTS() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x800) >> 11
}
func (o *PCC_Type) SetMR_ISIZE(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0x70000)|value<<16)
}
func (o *PCC_Type) GetMR_ISIZE() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0x70000) >> 16
}
func (o *PCC_Type) SetMR_CID(value uint32) {
	volatile.StoreUint32(&o.MR.Reg, volatile.LoadUint32(&o.MR.Reg)&^(0xc0000000)|value<<30)
}
func (o *PCC_Type) GetMR_CID() uint32 {
	return (volatile.LoadUint32(&o.MR.Reg) & 0xc0000000) >> 30
}

// PCC.IER: Interrupt Enable Register
func (o *PCC_Type) SetIER_DRDY(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *PCC_Type) GetIER_DRDY() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *PCC_Type) SetIER_OVRE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *PCC_Type) GetIER_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}

// PCC.IDR: Interrupt Disable Register
func (o *PCC_Type) SetIDR_DRDY(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *PCC_Type) GetIDR_DRDY() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}
func (o *PCC_Type) SetIDR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *PCC_Type) GetIDR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}

// PCC.IMR: Interrupt Mask Register
func (o *PCC_Type) SetIMR_DRDY(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *PCC_Type) GetIMR_DRDY() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *PCC_Type) SetIMR_OVRE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *PCC_Type) GetIMR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}

// PCC.ISR: Interrupt Status Register
func (o *PCC_Type) SetISR_DRDY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *PCC_Type) GetISR_DRDY() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *PCC_Type) SetISR_OVRE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *PCC_Type) GetISR_OVRE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}

// PCC.RHR: Reception Holding Register
func (o *PCC_Type) SetRHR(value uint32) {
	volatile.StoreUint32(&o.RHR.Reg, value)
}
func (o *PCC_Type) GetRHR() uint32 {
	return volatile.LoadUint32(&o.RHR.Reg)
}

// PCC.WPMR: Write Protection Mode Register
func (o *PCC_Type) SetWPMR_WPEN(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0x1)|value)
}
func (o *PCC_Type) GetWPMR_WPEN() uint32 {
	return volatile.LoadUint32(&o.WPMR.Reg) & 0x1
}
func (o *PCC_Type) SetWPMR_WPKEY(value uint32) {
	volatile.StoreUint32(&o.WPMR.Reg, volatile.LoadUint32(&o.WPMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *PCC_Type) GetWPMR_WPKEY() uint32 {
	return (volatile.LoadUint32(&o.WPMR.Reg) & 0xffffff00) >> 8
}

// PCC.WPSR: Write Protection Status Register
func (o *PCC_Type) SetWPSR_WPVS(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0x1)|value)
}
func (o *PCC_Type) GetWPSR_WPVS() uint32 {
	return volatile.LoadUint32(&o.WPSR.Reg) & 0x1
}
func (o *PCC_Type) SetWPSR_WPVSRC(value uint32) {
	volatile.StoreUint32(&o.WPSR.Reg, volatile.LoadUint32(&o.WPSR.Reg)&^(0xffff00)|value<<8)
}
func (o *PCC_Type) GetWPSR_WPVSRC() uint32 {
	return (volatile.LoadUint32(&o.WPSR.Reg) & 0xffff00) >> 8
}

// Quadrature Decodeur
type PDEC_Type struct {
	CTRLA     volatile.Register32 // 0x0
	CTRLBCLR  volatile.Register8  // 0x4
	CTRLBSET  volatile.Register8  // 0x5
	EVCTRL    volatile.Register16 // 0x6
	INTENCLR  volatile.Register8  // 0x8
	INTENSET  volatile.Register8  // 0x9
	INTFLAG   volatile.Register8  // 0xA
	_         byte
	STATUS    volatile.Register16 // 0xC
	_         byte
	DBGCTRL   volatile.Register8  // 0xF
	SYNCBUSY  volatile.Register32 // 0x10
	PRESC     volatile.Register8  // 0x14
	FILTER    volatile.Register8  // 0x15
	_         [2]byte
	PRESCBUF  volatile.Register8 // 0x18
	FILTERBUF volatile.Register8 // 0x19
	_         [2]byte
	COUNT     volatile.Register32    // 0x1C
	CC        [2]volatile.Register32 // 0x20
	_         [8]byte
	CCBUF     [2]volatile.Register32 // 0x30
}

// PDEC.CTRLA: Control A
func (o *PDEC_Type) SetCTRLA_SWRST(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *PDEC_Type) GetCTRLA_SWRST() uint32 {
	return volatile.LoadUint32(&o.CTRLA.Reg) & 0x1
}
func (o *PDEC_Type) SetCTRLA_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *PDEC_Type) GetCTRLA_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *PDEC_Type) SetCTRLA_MODE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0xc)|value<<2)
}
func (o *PDEC_Type) GetCTRLA_MODE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0xc) >> 2
}
func (o *PDEC_Type) SetCTRLA_RUNSTDBY(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x40)|value<<6)
}
func (o *PDEC_Type) GetCTRLA_RUNSTDBY() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x40) >> 6
}
func (o *PDEC_Type) SetCTRLA_CONF(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x700)|value<<8)
}
func (o *PDEC_Type) GetCTRLA_CONF() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x700) >> 8
}
func (o *PDEC_Type) SetCTRLA_ALOCK(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x800)|value<<11)
}
func (o *PDEC_Type) GetCTRLA_ALOCK() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x800) >> 11
}
func (o *PDEC_Type) SetCTRLA_SWAP(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x4000)|value<<14)
}
func (o *PDEC_Type) GetCTRLA_SWAP() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x4000) >> 14
}
func (o *PDEC_Type) SetCTRLA_PEREN(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x8000)|value<<15)
}
func (o *PDEC_Type) GetCTRLA_PEREN() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x8000) >> 15
}
func (o *PDEC_Type) SetCTRLA_PINEN0(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x10000)|value<<16)
}
func (o *PDEC_Type) GetCTRLA_PINEN0() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x10000) >> 16
}
func (o *PDEC_Type) SetCTRLA_PINEN1(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x20000)|value<<17)
}
func (o *PDEC_Type) GetCTRLA_PINEN1() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x20000) >> 17
}
func (o *PDEC_Type) SetCTRLA_PINEN2(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x40000)|value<<18)
}
func (o *PDEC_Type) GetCTRLA_PINEN2() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x40000) >> 18
}
func (o *PDEC_Type) SetCTRLA_PINVEN0(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x100000)|value<<20)
}
func (o *PDEC_Type) GetCTRLA_PINVEN0() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x100000) >> 20
}
func (o *PDEC_Type) SetCTRLA_PINVEN1(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x200000)|value<<21)
}
func (o *PDEC_Type) GetCTRLA_PINVEN1() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x200000) >> 21
}
func (o *PDEC_Type) SetCTRLA_PINVEN2(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x400000)|value<<22)
}
func (o *PDEC_Type) GetCTRLA_PINVEN2() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x400000) >> 22
}
func (o *PDEC_Type) SetCTRLA_ANGULAR(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x7000000)|value<<24)
}
func (o *PDEC_Type) GetCTRLA_ANGULAR() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x7000000) >> 24
}
func (o *PDEC_Type) SetCTRLA_MAXCMP(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0xf0000000)|value<<28)
}
func (o *PDEC_Type) GetCTRLA_MAXCMP() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0xf0000000) >> 28
}

// PDEC.CTRLBCLR: Control B Clear
func (o *PDEC_Type) SetCTRLBCLR_LUPD(value uint8) {
	volatile.StoreUint8(&o.CTRLBCLR.Reg, volatile.LoadUint8(&o.CTRLBCLR.Reg)&^(0x2)|value<<1)
}
func (o *PDEC_Type) GetCTRLBCLR_LUPD() uint8 {
	return (volatile.LoadUint8(&o.CTRLBCLR.Reg) & 0x2) >> 1
}
func (o *PDEC_Type) SetCTRLBCLR_CMD(value uint8) {
	volatile.StoreUint8(&o.CTRLBCLR.Reg, volatile.LoadUint8(&o.CTRLBCLR.Reg)&^(0xe0)|value<<5)
}
func (o *PDEC_Type) GetCTRLBCLR_CMD() uint8 {
	return (volatile.LoadUint8(&o.CTRLBCLR.Reg) & 0xe0) >> 5
}

// PDEC.CTRLBSET: Control B Set
func (o *PDEC_Type) SetCTRLBSET_LUPD(value uint8) {
	volatile.StoreUint8(&o.CTRLBSET.Reg, volatile.LoadUint8(&o.CTRLBSET.Reg)&^(0x2)|value<<1)
}
func (o *PDEC_Type) GetCTRLBSET_LUPD() uint8 {
	return (volatile.LoadUint8(&o.CTRLBSET.Reg) & 0x2) >> 1
}
func (o *PDEC_Type) SetCTRLBSET_CMD(value uint8) {
	volatile.StoreUint8(&o.CTRLBSET.Reg, volatile.LoadUint8(&o.CTRLBSET.Reg)&^(0xe0)|value<<5)
}
func (o *PDEC_Type) GetCTRLBSET_CMD() uint8 {
	return (volatile.LoadUint8(&o.CTRLBSET.Reg) & 0xe0) >> 5
}

// PDEC.EVCTRL: Event Control
func (o *PDEC_Type) SetEVCTRL_EVACT(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x3)|value)
}
func (o *PDEC_Type) GetEVCTRL_EVACT() uint16 {
	return volatile.LoadUint16(&o.EVCTRL.Reg) & 0x3
}
func (o *PDEC_Type) SetEVCTRL_EVINV(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x1c)|value<<2)
}
func (o *PDEC_Type) GetEVCTRL_EVINV() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x1c) >> 2
}
func (o *PDEC_Type) SetEVCTRL_EVEI(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0xe0)|value<<5)
}
func (o *PDEC_Type) GetEVCTRL_EVEI() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0xe0) >> 5
}
func (o *PDEC_Type) SetEVCTRL_OVFEO(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x100)|value<<8)
}
func (o *PDEC_Type) GetEVCTRL_OVFEO() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x100) >> 8
}
func (o *PDEC_Type) SetEVCTRL_ERREO(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x200)|value<<9)
}
func (o *PDEC_Type) GetEVCTRL_ERREO() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x200) >> 9
}
func (o *PDEC_Type) SetEVCTRL_DIREO(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x400)|value<<10)
}
func (o *PDEC_Type) GetEVCTRL_DIREO() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x400) >> 10
}
func (o *PDEC_Type) SetEVCTRL_VLCEO(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x800)|value<<11)
}
func (o *PDEC_Type) GetEVCTRL_VLCEO() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x800) >> 11
}
func (o *PDEC_Type) SetEVCTRL_MCEO0(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *PDEC_Type) GetEVCTRL_MCEO0() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x1000) >> 12
}
func (o *PDEC_Type) SetEVCTRL_MCEO1(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *PDEC_Type) GetEVCTRL_MCEO1() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x2000) >> 13
}

// PDEC.INTENCLR: Interrupt Enable Clear
func (o *PDEC_Type) SetINTENCLR_OVF(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *PDEC_Type) GetINTENCLR_OVF() uint8 {
	return volatile.LoadUint8(&o.INTENCLR.Reg) & 0x1
}
func (o *PDEC_Type) SetINTENCLR_ERR(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *PDEC_Type) GetINTENCLR_ERR() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *PDEC_Type) SetINTENCLR_DIR(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *PDEC_Type) GetINTENCLR_DIR() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *PDEC_Type) SetINTENCLR_VLC(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *PDEC_Type) GetINTENCLR_VLC() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *PDEC_Type) SetINTENCLR_MC0(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *PDEC_Type) GetINTENCLR_MC0() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *PDEC_Type) SetINTENCLR_MC1(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *PDEC_Type) GetINTENCLR_MC1() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x20) >> 5
}

// PDEC.INTENSET: Interrupt Enable Set
func (o *PDEC_Type) SetINTENSET_OVF(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *PDEC_Type) GetINTENSET_OVF() uint8 {
	return volatile.LoadUint8(&o.INTENSET.Reg) & 0x1
}
func (o *PDEC_Type) SetINTENSET_ERR(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *PDEC_Type) GetINTENSET_ERR() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *PDEC_Type) SetINTENSET_DIR(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *PDEC_Type) GetINTENSET_DIR() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *PDEC_Type) SetINTENSET_VLC(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *PDEC_Type) GetINTENSET_VLC() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *PDEC_Type) SetINTENSET_MC0(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *PDEC_Type) GetINTENSET_MC0() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *PDEC_Type) SetINTENSET_MC1(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *PDEC_Type) GetINTENSET_MC1() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x20) >> 5
}

// PDEC.INTFLAG: Interrupt Flag Status and Clear
func (o *PDEC_Type) SetINTFLAG_OVF(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *PDEC_Type) GetINTFLAG_OVF() uint8 {
	return volatile.LoadUint8(&o.INTFLAG.Reg) & 0x1
}
func (o *PDEC_Type) SetINTFLAG_ERR(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *PDEC_Type) GetINTFLAG_ERR() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *PDEC_Type) SetINTFLAG_DIR(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x4)|value<<2)
}
func (o *PDEC_Type) GetINTFLAG_DIR() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x4) >> 2
}
func (o *PDEC_Type) SetINTFLAG_VLC(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x8)|value<<3)
}
func (o *PDEC_Type) GetINTFLAG_VLC() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x8) >> 3
}
func (o *PDEC_Type) SetINTFLAG_MC0(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x10)|value<<4)
}
func (o *PDEC_Type) GetINTFLAG_MC0() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x10) >> 4
}
func (o *PDEC_Type) SetINTFLAG_MC1(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x20)|value<<5)
}
func (o *PDEC_Type) GetINTFLAG_MC1() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x20) >> 5
}

// PDEC.STATUS: Status
func (o *PDEC_Type) SetSTATUS_QERR(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *PDEC_Type) GetSTATUS_QERR() uint16 {
	return volatile.LoadUint16(&o.STATUS.Reg) & 0x1
}
func (o *PDEC_Type) SetSTATUS_IDXERR(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *PDEC_Type) GetSTATUS_IDXERR() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *PDEC_Type) SetSTATUS_MPERR(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *PDEC_Type) GetSTATUS_MPERR() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *PDEC_Type) SetSTATUS_WINERR(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x10)|value<<4)
}
func (o *PDEC_Type) GetSTATUS_WINERR() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x10) >> 4
}
func (o *PDEC_Type) SetSTATUS_HERR(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x20)|value<<5)
}
func (o *PDEC_Type) GetSTATUS_HERR() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x20) >> 5
}
func (o *PDEC_Type) SetSTATUS_STOP(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x40)|value<<6)
}
func (o *PDEC_Type) GetSTATUS_STOP() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x40) >> 6
}
func (o *PDEC_Type) SetSTATUS_DIR(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x80)|value<<7)
}
func (o *PDEC_Type) GetSTATUS_DIR() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x80) >> 7
}
func (o *PDEC_Type) SetSTATUS_PRESCBUFV(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x100)|value<<8)
}
func (o *PDEC_Type) GetSTATUS_PRESCBUFV() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x100) >> 8
}
func (o *PDEC_Type) SetSTATUS_FILTERBUFV(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x200)|value<<9)
}
func (o *PDEC_Type) GetSTATUS_FILTERBUFV() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x200) >> 9
}
func (o *PDEC_Type) SetSTATUS_CCBUFV0(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *PDEC_Type) GetSTATUS_CCBUFV0() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x1000) >> 12
}
func (o *PDEC_Type) SetSTATUS_CCBUFV1(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *PDEC_Type) GetSTATUS_CCBUFV1() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x2000) >> 13
}

// PDEC.DBGCTRL: Debug Control
func (o *PDEC_Type) SetDBGCTRL_DBGRUN(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x1)|value)
}
func (o *PDEC_Type) GetDBGCTRL_DBGRUN() uint8 {
	return volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x1
}

// PDEC.SYNCBUSY: Synchronization Status
func (o *PDEC_Type) SetSYNCBUSY_SWRST(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *PDEC_Type) GetSYNCBUSY_SWRST() uint32 {
	return volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x1
}
func (o *PDEC_Type) SetSYNCBUSY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *PDEC_Type) GetSYNCBUSY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x2) >> 1
}
func (o *PDEC_Type) SetSYNCBUSY_CTRLB(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x4)|value<<2)
}
func (o *PDEC_Type) GetSYNCBUSY_CTRLB() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x4) >> 2
}
func (o *PDEC_Type) SetSYNCBUSY_STATUS(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x8)|value<<3)
}
func (o *PDEC_Type) GetSYNCBUSY_STATUS() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x8) >> 3
}
func (o *PDEC_Type) SetSYNCBUSY_PRESC(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x10)|value<<4)
}
func (o *PDEC_Type) GetSYNCBUSY_PRESC() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x10) >> 4
}
func (o *PDEC_Type) SetSYNCBUSY_FILTER(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x20)|value<<5)
}
func (o *PDEC_Type) GetSYNCBUSY_FILTER() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x20) >> 5
}
func (o *PDEC_Type) SetSYNCBUSY_COUNT(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x40)|value<<6)
}
func (o *PDEC_Type) GetSYNCBUSY_COUNT() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x40) >> 6
}
func (o *PDEC_Type) SetSYNCBUSY_CC0(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x80)|value<<7)
}
func (o *PDEC_Type) GetSYNCBUSY_CC0() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x80) >> 7
}
func (o *PDEC_Type) SetSYNCBUSY_CC1(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x100)|value<<8)
}
func (o *PDEC_Type) GetSYNCBUSY_CC1() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x100) >> 8
}

// PDEC.PRESC: Prescaler Value
func (o *PDEC_Type) SetPRESC(value uint8) {
	volatile.StoreUint8(&o.PRESC.Reg, volatile.LoadUint8(&o.PRESC.Reg)&^(0xf)|value)
}
func (o *PDEC_Type) GetPRESC() uint8 {
	return volatile.LoadUint8(&o.PRESC.Reg) & 0xf
}

// PDEC.FILTER: Filter Value
func (o *PDEC_Type) SetFILTER(value uint8) {
	volatile.StoreUint8(&o.FILTER.Reg, value)
}
func (o *PDEC_Type) GetFILTER() uint8 {
	return volatile.LoadUint8(&o.FILTER.Reg)
}

// PDEC.PRESCBUF: Prescaler Buffer Value
func (o *PDEC_Type) SetPRESCBUF(value uint8) {
	volatile.StoreUint8(&o.PRESCBUF.Reg, volatile.LoadUint8(&o.PRESCBUF.Reg)&^(0xf)|value)
}
func (o *PDEC_Type) GetPRESCBUF() uint8 {
	return volatile.LoadUint8(&o.PRESCBUF.Reg) & 0xf
}

// PDEC.FILTERBUF: Filter Buffer Value
func (o *PDEC_Type) SetFILTERBUF(value uint8) {
	volatile.StoreUint8(&o.FILTERBUF.Reg, value)
}
func (o *PDEC_Type) GetFILTERBUF() uint8 {
	return volatile.LoadUint8(&o.FILTERBUF.Reg)
}

// PDEC.COUNT: Counter Value
func (o *PDEC_Type) SetCOUNT(value uint32) {
	volatile.StoreUint32(&o.COUNT.Reg, volatile.LoadUint32(&o.COUNT.Reg)&^(0xffff)|value)
}
func (o *PDEC_Type) GetCOUNT() uint32 {
	return volatile.LoadUint32(&o.COUNT.Reg) & 0xffff
}

// PDEC.CC: Channel n Compare Value
func (o *PDEC_Type) SetCC(idx int, value uint32) {
	volatile.StoreUint32(&o.CC[idx].Reg, volatile.LoadUint32(&o.CC[idx].Reg)&^(0xffff)|value)
}
func (o *PDEC_Type) GetCC(idx int) uint32 {
	return volatile.LoadUint32(&o.CC[idx].Reg) & 0xffff
}

// PDEC.CCBUF: Channel Compare Buffer Value
func (o *PDEC_Type) SetCCBUF(idx int, value uint32) {
	volatile.StoreUint32(&o.CCBUF[idx].Reg, volatile.LoadUint32(&o.CCBUF[idx].Reg)&^(0xffff)|value)
}
func (o *PDEC_Type) GetCCBUF(idx int) uint32 {
	return volatile.LoadUint32(&o.CCBUF[idx].Reg) & 0xffff
}

// Power Manager
type PM_Type struct {
	CTRLA    volatile.Register8 // 0x0
	SLEEPCFG volatile.Register8 // 0x1
	_        [2]byte
	INTENCLR volatile.Register8 // 0x4
	INTENSET volatile.Register8 // 0x5
	INTFLAG  volatile.Register8 // 0x6
	_        byte
	STDBYCFG volatile.Register8 // 0x8
	HIBCFG   volatile.Register8 // 0x9
	BKUPCFG  volatile.Register8 // 0xA
	_        [7]byte
	PWSAKDLY volatile.Register8 // 0x12
}

// PM.CTRLA: Control A
func (o *PM_Type) SetCTRLA_IORET(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x4)|value<<2)
}
func (o *PM_Type) GetCTRLA_IORET() uint8 {
	return (volatile.LoadUint8(&o.CTRLA.Reg) & 0x4) >> 2
}

// PM.SLEEPCFG: Sleep Configuration
func (o *PM_Type) SetSLEEPCFG_SLEEPMODE(value uint8) {
	volatile.StoreUint8(&o.SLEEPCFG.Reg, volatile.LoadUint8(&o.SLEEPCFG.Reg)&^(0x7)|value)
}
func (o *PM_Type) GetSLEEPCFG_SLEEPMODE() uint8 {
	return volatile.LoadUint8(&o.SLEEPCFG.Reg) & 0x7
}

// PM.INTENCLR: Interrupt Enable Clear
func (o *PM_Type) SetINTENCLR_SLEEPRDY(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *PM_Type) GetINTENCLR_SLEEPRDY() uint8 {
	return volatile.LoadUint8(&o.INTENCLR.Reg) & 0x1
}

// PM.INTENSET: Interrupt Enable Set
func (o *PM_Type) SetINTENSET_SLEEPRDY(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *PM_Type) GetINTENSET_SLEEPRDY() uint8 {
	return volatile.LoadUint8(&o.INTENSET.Reg) & 0x1
}

// PM.INTFLAG: Interrupt Flag Status and Clear
func (o *PM_Type) SetINTFLAG_SLEEPRDY(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *PM_Type) GetINTFLAG_SLEEPRDY() uint8 {
	return volatile.LoadUint8(&o.INTFLAG.Reg) & 0x1
}

// PM.STDBYCFG: Standby Configuration
func (o *PM_Type) SetSTDBYCFG_RAMCFG(value uint8) {
	volatile.StoreUint8(&o.STDBYCFG.Reg, volatile.LoadUint8(&o.STDBYCFG.Reg)&^(0x3)|value)
}
func (o *PM_Type) GetSTDBYCFG_RAMCFG() uint8 {
	return volatile.LoadUint8(&o.STDBYCFG.Reg) & 0x3
}
func (o *PM_Type) SetSTDBYCFG_FASTWKUP(value uint8) {
	volatile.StoreUint8(&o.STDBYCFG.Reg, volatile.LoadUint8(&o.STDBYCFG.Reg)&^(0x30)|value<<4)
}
func (o *PM_Type) GetSTDBYCFG_FASTWKUP() uint8 {
	return (volatile.LoadUint8(&o.STDBYCFG.Reg) & 0x30) >> 4
}

// PM.HIBCFG: Hibernate Configuration
func (o *PM_Type) SetHIBCFG_RAMCFG(value uint8) {
	volatile.StoreUint8(&o.HIBCFG.Reg, volatile.LoadUint8(&o.HIBCFG.Reg)&^(0x3)|value)
}
func (o *PM_Type) GetHIBCFG_RAMCFG() uint8 {
	return volatile.LoadUint8(&o.HIBCFG.Reg) & 0x3
}
func (o *PM_Type) SetHIBCFG_BRAMCFG(value uint8) {
	volatile.StoreUint8(&o.HIBCFG.Reg, volatile.LoadUint8(&o.HIBCFG.Reg)&^(0xc)|value<<2)
}
func (o *PM_Type) GetHIBCFG_BRAMCFG() uint8 {
	return (volatile.LoadUint8(&o.HIBCFG.Reg) & 0xc) >> 2
}

// PM.BKUPCFG: Backup Configuration
func (o *PM_Type) SetBKUPCFG_BRAMCFG(value uint8) {
	volatile.StoreUint8(&o.BKUPCFG.Reg, volatile.LoadUint8(&o.BKUPCFG.Reg)&^(0x3)|value)
}
func (o *PM_Type) GetBKUPCFG_BRAMCFG() uint8 {
	return volatile.LoadUint8(&o.BKUPCFG.Reg) & 0x3
}

// PM.PWSAKDLY: Power Switch Acknowledge Delay
func (o *PM_Type) SetPWSAKDLY_DLYVAL(value uint8) {
	volatile.StoreUint8(&o.PWSAKDLY.Reg, volatile.LoadUint8(&o.PWSAKDLY.Reg)&^(0x7f)|value)
}
func (o *PM_Type) GetPWSAKDLY_DLYVAL() uint8 {
	return volatile.LoadUint8(&o.PWSAKDLY.Reg) & 0x7f
}
func (o *PM_Type) SetPWSAKDLY_IGNACK(value uint8) {
	volatile.StoreUint8(&o.PWSAKDLY.Reg, volatile.LoadUint8(&o.PWSAKDLY.Reg)&^(0x80)|value<<7)
}
func (o *PM_Type) GetPWSAKDLY_IGNACK() uint8 {
	return (volatile.LoadUint8(&o.PWSAKDLY.Reg) & 0x80) >> 7
}

// Port Module
type PORT_Type struct {
	GROUP [2]PORT_GROUP_Type // 0x0
}

type PORT_GROUP_Type struct {
	DIR      volatile.Register32    // 0x0
	DIRCLR   volatile.Register32    // 0x4
	DIRSET   volatile.Register32    // 0x8
	DIRTGL   volatile.Register32    // 0xC
	OUT      volatile.Register32    // 0x10
	OUTCLR   volatile.Register32    // 0x14
	OUTSET   volatile.Register32    // 0x18
	OUTTGL   volatile.Register32    // 0x1C
	IN       volatile.Register32    // 0x20
	CTRL     volatile.Register32    // 0x24
	WRCONFIG volatile.Register32    // 0x28
	EVCTRL   volatile.Register32    // 0x2C
	PMUX     [16]volatile.Register8 // 0x30
	PINCFG   [32]volatile.Register8 // 0x40
	_        [32]byte
}

// PORT_GROUP.DIR: Data Direction
func (o *PORT_GROUP_Type) SetDIR(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, value)
}
func (o *PORT_GROUP_Type) GetDIR() uint32 {
	return volatile.LoadUint32(&o.DIR.Reg)
}

// PORT_GROUP.DIRCLR: Data Direction Clear
func (o *PORT_GROUP_Type) SetDIRCLR(value uint32) {
	volatile.StoreUint32(&o.DIRCLR.Reg, value)
}
func (o *PORT_GROUP_Type) GetDIRCLR() uint32 {
	return volatile.LoadUint32(&o.DIRCLR.Reg)
}

// PORT_GROUP.DIRSET: Data Direction Set
func (o *PORT_GROUP_Type) SetDIRSET(value uint32) {
	volatile.StoreUint32(&o.DIRSET.Reg, value)
}
func (o *PORT_GROUP_Type) GetDIRSET() uint32 {
	return volatile.LoadUint32(&o.DIRSET.Reg)
}

// PORT_GROUP.DIRTGL: Data Direction Toggle
func (o *PORT_GROUP_Type) SetDIRTGL(value uint32) {
	volatile.StoreUint32(&o.DIRTGL.Reg, value)
}
func (o *PORT_GROUP_Type) GetDIRTGL() uint32 {
	return volatile.LoadUint32(&o.DIRTGL.Reg)
}

// PORT_GROUP.OUT: Data Output Value
func (o *PORT_GROUP_Type) SetOUT(value uint32) {
	volatile.StoreUint32(&o.OUT.Reg, value)
}
func (o *PORT_GROUP_Type) GetOUT() uint32 {
	return volatile.LoadUint32(&o.OUT.Reg)
}

// PORT_GROUP.OUTCLR: Data Output Value Clear
func (o *PORT_GROUP_Type) SetOUTCLR(value uint32) {
	volatile.StoreUint32(&o.OUTCLR.Reg, value)
}
func (o *PORT_GROUP_Type) GetOUTCLR() uint32 {
	return volatile.LoadUint32(&o.OUTCLR.Reg)
}

// PORT_GROUP.OUTSET: Data Output Value Set
func (o *PORT_GROUP_Type) SetOUTSET(value uint32) {
	volatile.StoreUint32(&o.OUTSET.Reg, value)
}
func (o *PORT_GROUP_Type) GetOUTSET() uint32 {
	return volatile.LoadUint32(&o.OUTSET.Reg)
}

// PORT_GROUP.OUTTGL: Data Output Value Toggle
func (o *PORT_GROUP_Type) SetOUTTGL(value uint32) {
	volatile.StoreUint32(&o.OUTTGL.Reg, value)
}
func (o *PORT_GROUP_Type) GetOUTTGL() uint32 {
	return volatile.LoadUint32(&o.OUTTGL.Reg)
}

// PORT_GROUP.IN: Data Input Value
func (o *PORT_GROUP_Type) SetIN(value uint32) {
	volatile.StoreUint32(&o.IN.Reg, value)
}
func (o *PORT_GROUP_Type) GetIN() uint32 {
	return volatile.LoadUint32(&o.IN.Reg)
}

// PORT_GROUP.CTRL: Control
func (o *PORT_GROUP_Type) SetCTRL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, value)
}
func (o *PORT_GROUP_Type) GetCTRL() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg)
}

// PORT_GROUP.WRCONFIG: Write Configuration
func (o *PORT_GROUP_Type) SetWRCONFIG_PINMASK(value uint32) {
	volatile.StoreUint32(&o.WRCONFIG.Reg, volatile.LoadUint32(&o.WRCONFIG.Reg)&^(0xffff)|value)
}
func (o *PORT_GROUP_Type) GetWRCONFIG_PINMASK() uint32 {
	return volatile.LoadUint32(&o.WRCONFIG.Reg) & 0xffff
}
func (o *PORT_GROUP_Type) SetWRCONFIG_PMUXEN(value uint32) {
	volatile.StoreUint32(&o.WRCONFIG.Reg, volatile.LoadUint32(&o.WRCONFIG.Reg)&^(0x10000)|value<<16)
}
func (o *PORT_GROUP_Type) GetWRCONFIG_PMUXEN() uint32 {
	return (volatile.LoadUint32(&o.WRCONFIG.Reg) & 0x10000) >> 16
}
func (o *PORT_GROUP_Type) SetWRCONFIG_INEN(value uint32) {
	volatile.StoreUint32(&o.WRCONFIG.Reg, volatile.LoadUint32(&o.WRCONFIG.Reg)&^(0x20000)|value<<17)
}
func (o *PORT_GROUP_Type) GetWRCONFIG_INEN() uint32 {
	return (volatile.LoadUint32(&o.WRCONFIG.Reg) & 0x20000) >> 17
}
func (o *PORT_GROUP_Type) SetWRCONFIG_PULLEN(value uint32) {
	volatile.StoreUint32(&o.WRCONFIG.Reg, volatile.LoadUint32(&o.WRCONFIG.Reg)&^(0x40000)|value<<18)
}
func (o *PORT_GROUP_Type) GetWRCONFIG_PULLEN() uint32 {
	return (volatile.LoadUint32(&o.WRCONFIG.Reg) & 0x40000) >> 18
}
func (o *PORT_GROUP_Type) SetWRCONFIG_DRVSTR(value uint32) {
	volatile.StoreUint32(&o.WRCONFIG.Reg, volatile.LoadUint32(&o.WRCONFIG.Reg)&^(0x400000)|value<<22)
}
func (o *PORT_GROUP_Type) GetWRCONFIG_DRVSTR() uint32 {
	return (volatile.LoadUint32(&o.WRCONFIG.Reg) & 0x400000) >> 22
}
func (o *PORT_GROUP_Type) SetWRCONFIG_PMUX(value uint32) {
	volatile.StoreUint32(&o.WRCONFIG.Reg, volatile.LoadUint32(&o.WRCONFIG.Reg)&^(0xf000000)|value<<24)
}
func (o *PORT_GROUP_Type) GetWRCONFIG_PMUX() uint32 {
	return (volatile.LoadUint32(&o.WRCONFIG.Reg) & 0xf000000) >> 24
}
func (o *PORT_GROUP_Type) SetWRCONFIG_WRPMUX(value uint32) {
	volatile.StoreUint32(&o.WRCONFIG.Reg, volatile.LoadUint32(&o.WRCONFIG.Reg)&^(0x10000000)|value<<28)
}
func (o *PORT_GROUP_Type) GetWRCONFIG_WRPMUX() uint32 {
	return (volatile.LoadUint32(&o.WRCONFIG.Reg) & 0x10000000) >> 28
}
func (o *PORT_GROUP_Type) SetWRCONFIG_WRPINCFG(value uint32) {
	volatile.StoreUint32(&o.WRCONFIG.Reg, volatile.LoadUint32(&o.WRCONFIG.Reg)&^(0x40000000)|value<<30)
}
func (o *PORT_GROUP_Type) GetWRCONFIG_WRPINCFG() uint32 {
	return (volatile.LoadUint32(&o.WRCONFIG.Reg) & 0x40000000) >> 30
}
func (o *PORT_GROUP_Type) SetWRCONFIG_HWSEL(value uint32) {
	volatile.StoreUint32(&o.WRCONFIG.Reg, volatile.LoadUint32(&o.WRCONFIG.Reg)&^(0x80000000)|value<<31)
}
func (o *PORT_GROUP_Type) GetWRCONFIG_HWSEL() uint32 {
	return (volatile.LoadUint32(&o.WRCONFIG.Reg) & 0x80000000) >> 31
}

// PORT_GROUP.EVCTRL: Event Input Control
func (o *PORT_GROUP_Type) SetEVCTRL_PID0(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x1f)|value)
}
func (o *PORT_GROUP_Type) GetEVCTRL_PID0() uint32 {
	return volatile.LoadUint32(&o.EVCTRL.Reg) & 0x1f
}
func (o *PORT_GROUP_Type) SetEVCTRL_EVACT0(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x60)|value<<5)
}
func (o *PORT_GROUP_Type) GetEVCTRL_EVACT0() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x60) >> 5
}
func (o *PORT_GROUP_Type) SetEVCTRL_PORTEI0(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x80)|value<<7)
}
func (o *PORT_GROUP_Type) GetEVCTRL_PORTEI0() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x80) >> 7
}
func (o *PORT_GROUP_Type) SetEVCTRL_PID1(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x1f00)|value<<8)
}
func (o *PORT_GROUP_Type) GetEVCTRL_PID1() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x1f00) >> 8
}
func (o *PORT_GROUP_Type) SetEVCTRL_EVACT1(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x6000)|value<<13)
}
func (o *PORT_GROUP_Type) GetEVCTRL_EVACT1() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x6000) >> 13
}
func (o *PORT_GROUP_Type) SetEVCTRL_PORTEI1(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *PORT_GROUP_Type) GetEVCTRL_PORTEI1() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x8000) >> 15
}
func (o *PORT_GROUP_Type) SetEVCTRL_PID2(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x1f0000)|value<<16)
}
func (o *PORT_GROUP_Type) GetEVCTRL_PID2() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x1f0000) >> 16
}
func (o *PORT_GROUP_Type) SetEVCTRL_EVACT2(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x600000)|value<<21)
}
func (o *PORT_GROUP_Type) GetEVCTRL_EVACT2() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x600000) >> 21
}
func (o *PORT_GROUP_Type) SetEVCTRL_PORTEI2(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x800000)|value<<23)
}
func (o *PORT_GROUP_Type) GetEVCTRL_PORTEI2() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x800000) >> 23
}
func (o *PORT_GROUP_Type) SetEVCTRL_PID3(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x1f000000)|value<<24)
}
func (o *PORT_GROUP_Type) GetEVCTRL_PID3() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x1f000000) >> 24
}
func (o *PORT_GROUP_Type) SetEVCTRL_EVACT3(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x60000000)|value<<29)
}
func (o *PORT_GROUP_Type) GetEVCTRL_EVACT3() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x60000000) >> 29
}
func (o *PORT_GROUP_Type) SetEVCTRL_PORTEI3(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *PORT_GROUP_Type) GetEVCTRL_PORTEI3() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x80000000) >> 31
}

// Quad SPI interface
type QSPI_Type struct {
	CTRLA      volatile.Register32 // 0x0
	CTRLB      volatile.Register32 // 0x4
	BAUD       volatile.Register32 // 0x8
	RXDATA     volatile.Register32 // 0xC
	TXDATA     volatile.Register32 // 0x10
	INTENCLR   volatile.Register32 // 0x14
	INTENSET   volatile.Register32 // 0x18
	INTFLAG    volatile.Register32 // 0x1C
	STATUS     volatile.Register32 // 0x20
	_          [12]byte
	INSTRADDR  volatile.Register32 // 0x30
	INSTRCTRL  volatile.Register32 // 0x34
	INSTRFRAME volatile.Register32 // 0x38
	_          [4]byte
	SCRAMBCTRL volatile.Register32 // 0x40
	SCRAMBKEY  volatile.Register32 // 0x44
}

// QSPI.CTRLA: Control A
func (o *QSPI_Type) SetCTRLA_SWRST(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetCTRLA_SWRST() uint32 {
	return volatile.LoadUint32(&o.CTRLA.Reg) & 0x1
}
func (o *QSPI_Type) SetCTRLA_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *QSPI_Type) GetCTRLA_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *QSPI_Type) SetCTRLA_LASTXFER(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1000000)|value<<24)
}
func (o *QSPI_Type) GetCTRLA_LASTXFER() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x1000000) >> 24
}

// QSPI.CTRLB: Control B
func (o *QSPI_Type) SetCTRLB_MODE(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetCTRLB_MODE() uint32 {
	return volatile.LoadUint32(&o.CTRLB.Reg) & 0x1
}
func (o *QSPI_Type) SetCTRLB_LOOPEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x2)|value<<1)
}
func (o *QSPI_Type) GetCTRLB_LOOPEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x2) >> 1
}
func (o *QSPI_Type) SetCTRLB_WDRBT(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x4)|value<<2)
}
func (o *QSPI_Type) GetCTRLB_WDRBT() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x4) >> 2
}
func (o *QSPI_Type) SetCTRLB_SMEMREG(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x8)|value<<3)
}
func (o *QSPI_Type) GetCTRLB_SMEMREG() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x8) >> 3
}
func (o *QSPI_Type) SetCTRLB_CSMODE(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x30)|value<<4)
}
func (o *QSPI_Type) GetCTRLB_CSMODE() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x30) >> 4
}
func (o *QSPI_Type) SetCTRLB_DATALEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0xf00)|value<<8)
}
func (o *QSPI_Type) GetCTRLB_DATALEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0xf00) >> 8
}
func (o *QSPI_Type) SetCTRLB_DLYBCT(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0xff0000)|value<<16)
}
func (o *QSPI_Type) GetCTRLB_DLYBCT() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0xff0000) >> 16
}
func (o *QSPI_Type) SetCTRLB_DLYCS(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0xff000000)|value<<24)
}
func (o *QSPI_Type) GetCTRLB_DLYCS() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0xff000000) >> 24
}

// QSPI.BAUD: Baud Rate
func (o *QSPI_Type) SetBAUD_CPOL(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetBAUD_CPOL() uint32 {
	return volatile.LoadUint32(&o.BAUD.Reg) & 0x1
}
func (o *QSPI_Type) SetBAUD_CPHA(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x2)|value<<1)
}
func (o *QSPI_Type) GetBAUD_CPHA() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x2) >> 1
}
func (o *QSPI_Type) SetBAUD(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0xff00)|value<<8)
}
func (o *QSPI_Type) GetBAUD() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0xff00) >> 8
}
func (o *QSPI_Type) SetBAUD_DLYBS(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0xff0000)|value<<16)
}
func (o *QSPI_Type) GetBAUD_DLYBS() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0xff0000) >> 16
}

// QSPI.RXDATA: Receive Data
func (o *QSPI_Type) SetRXDATA_DATA(value uint32) {
	volatile.StoreUint32(&o.RXDATA.Reg, volatile.LoadUint32(&o.RXDATA.Reg)&^(0xffff)|value)
}
func (o *QSPI_Type) GetRXDATA_DATA() uint32 {
	return volatile.LoadUint32(&o.RXDATA.Reg) & 0xffff
}

// QSPI.TXDATA: Transmit Data
func (o *QSPI_Type) SetTXDATA_DATA(value uint32) {
	volatile.StoreUint32(&o.TXDATA.Reg, volatile.LoadUint32(&o.TXDATA.Reg)&^(0xffff)|value)
}
func (o *QSPI_Type) GetTXDATA_DATA() uint32 {
	return volatile.LoadUint32(&o.TXDATA.Reg) & 0xffff
}

// QSPI.INTENCLR: Interrupt Enable Clear
func (o *QSPI_Type) SetINTENCLR_RXC(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetINTENCLR_RXC() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *QSPI_Type) SetINTENCLR_DRE(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *QSPI_Type) GetINTENCLR_DRE() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *QSPI_Type) SetINTENCLR_TXC(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *QSPI_Type) GetINTENCLR_TXC() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *QSPI_Type) SetINTENCLR_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *QSPI_Type) GetINTENCLR_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *QSPI_Type) SetINTENCLR_CSRISE(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *QSPI_Type) GetINTENCLR_CSRISE() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *QSPI_Type) SetINTENCLR_INSTREND(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400)|value<<10)
}
func (o *QSPI_Type) GetINTENCLR_INSTREND() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400) >> 10
}

// QSPI.INTENSET: Interrupt Enable Set
func (o *QSPI_Type) SetINTENSET_RXC(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetINTENSET_RXC() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *QSPI_Type) SetINTENSET_DRE(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *QSPI_Type) GetINTENSET_DRE() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *QSPI_Type) SetINTENSET_TXC(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *QSPI_Type) GetINTENSET_TXC() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *QSPI_Type) SetINTENSET_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *QSPI_Type) GetINTENSET_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *QSPI_Type) SetINTENSET_CSRISE(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *QSPI_Type) GetINTENSET_CSRISE() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *QSPI_Type) SetINTENSET_INSTREND(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400)|value<<10)
}
func (o *QSPI_Type) GetINTENSET_INSTREND() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400) >> 10
}

// QSPI.INTFLAG: Interrupt Flag Status and Clear
func (o *QSPI_Type) SetINTFLAG_RXC(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetINTFLAG_RXC() uint32 {
	return volatile.LoadUint32(&o.INTFLAG.Reg) & 0x1
}
func (o *QSPI_Type) SetINTFLAG_DRE(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *QSPI_Type) GetINTFLAG_DRE() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *QSPI_Type) SetINTFLAG_TXC(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x4)|value<<2)
}
func (o *QSPI_Type) GetINTFLAG_TXC() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x4) >> 2
}
func (o *QSPI_Type) SetINTFLAG_ERROR(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x8)|value<<3)
}
func (o *QSPI_Type) GetINTFLAG_ERROR() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x8) >> 3
}
func (o *QSPI_Type) SetINTFLAG_CSRISE(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x100)|value<<8)
}
func (o *QSPI_Type) GetINTFLAG_CSRISE() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x100) >> 8
}
func (o *QSPI_Type) SetINTFLAG_INSTREND(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x400)|value<<10)
}
func (o *QSPI_Type) GetINTFLAG_INSTREND() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x400) >> 10
}

// QSPI.STATUS: Status Register
func (o *QSPI_Type) SetSTATUS_ENABLE(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *QSPI_Type) GetSTATUS_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *QSPI_Type) SetSTATUS_CSSTATUS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x200)|value<<9)
}
func (o *QSPI_Type) GetSTATUS_CSSTATUS() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x200) >> 9
}

// QSPI.INSTRADDR: Instruction Address
func (o *QSPI_Type) SetINSTRADDR(value uint32) {
	volatile.StoreUint32(&o.INSTRADDR.Reg, value)
}
func (o *QSPI_Type) GetINSTRADDR() uint32 {
	return volatile.LoadUint32(&o.INSTRADDR.Reg)
}

// QSPI.INSTRCTRL: Instruction Code
func (o *QSPI_Type) SetINSTRCTRL_INSTR(value uint32) {
	volatile.StoreUint32(&o.INSTRCTRL.Reg, volatile.LoadUint32(&o.INSTRCTRL.Reg)&^(0xff)|value)
}
func (o *QSPI_Type) GetINSTRCTRL_INSTR() uint32 {
	return volatile.LoadUint32(&o.INSTRCTRL.Reg) & 0xff
}
func (o *QSPI_Type) SetINSTRCTRL_OPTCODE(value uint32) {
	volatile.StoreUint32(&o.INSTRCTRL.Reg, volatile.LoadUint32(&o.INSTRCTRL.Reg)&^(0xff0000)|value<<16)
}
func (o *QSPI_Type) GetINSTRCTRL_OPTCODE() uint32 {
	return (volatile.LoadUint32(&o.INSTRCTRL.Reg) & 0xff0000) >> 16
}

// QSPI.INSTRFRAME: Instruction Frame
func (o *QSPI_Type) SetINSTRFRAME_WIDTH(value uint32) {
	volatile.StoreUint32(&o.INSTRFRAME.Reg, volatile.LoadUint32(&o.INSTRFRAME.Reg)&^(0x7)|value)
}
func (o *QSPI_Type) GetINSTRFRAME_WIDTH() uint32 {
	return volatile.LoadUint32(&o.INSTRFRAME.Reg) & 0x7
}
func (o *QSPI_Type) SetINSTRFRAME_INSTREN(value uint32) {
	volatile.StoreUint32(&o.INSTRFRAME.Reg, volatile.LoadUint32(&o.INSTRFRAME.Reg)&^(0x10)|value<<4)
}
func (o *QSPI_Type) GetINSTRFRAME_INSTREN() uint32 {
	return (volatile.LoadUint32(&o.INSTRFRAME.Reg) & 0x10) >> 4
}
func (o *QSPI_Type) SetINSTRFRAME_ADDREN(value uint32) {
	volatile.StoreUint32(&o.INSTRFRAME.Reg, volatile.LoadUint32(&o.INSTRFRAME.Reg)&^(0x20)|value<<5)
}
func (o *QSPI_Type) GetINSTRFRAME_ADDREN() uint32 {
	return (volatile.LoadUint32(&o.INSTRFRAME.Reg) & 0x20) >> 5
}
func (o *QSPI_Type) SetINSTRFRAME_OPTCODEEN(value uint32) {
	volatile.StoreUint32(&o.INSTRFRAME.Reg, volatile.LoadUint32(&o.INSTRFRAME.Reg)&^(0x40)|value<<6)
}
func (o *QSPI_Type) GetINSTRFRAME_OPTCODEEN() uint32 {
	return (volatile.LoadUint32(&o.INSTRFRAME.Reg) & 0x40) >> 6
}
func (o *QSPI_Type) SetINSTRFRAME_DATAEN(value uint32) {
	volatile.StoreUint32(&o.INSTRFRAME.Reg, volatile.LoadUint32(&o.INSTRFRAME.Reg)&^(0x80)|value<<7)
}
func (o *QSPI_Type) GetINSTRFRAME_DATAEN() uint32 {
	return (volatile.LoadUint32(&o.INSTRFRAME.Reg) & 0x80) >> 7
}
func (o *QSPI_Type) SetINSTRFRAME_OPTCODELEN(value uint32) {
	volatile.StoreUint32(&o.INSTRFRAME.Reg, volatile.LoadUint32(&o.INSTRFRAME.Reg)&^(0x300)|value<<8)
}
func (o *QSPI_Type) GetINSTRFRAME_OPTCODELEN() uint32 {
	return (volatile.LoadUint32(&o.INSTRFRAME.Reg) & 0x300) >> 8
}
func (o *QSPI_Type) SetINSTRFRAME_ADDRLEN(value uint32) {
	volatile.StoreUint32(&o.INSTRFRAME.Reg, volatile.LoadUint32(&o.INSTRFRAME.Reg)&^(0x400)|value<<10)
}
func (o *QSPI_Type) GetINSTRFRAME_ADDRLEN() uint32 {
	return (volatile.LoadUint32(&o.INSTRFRAME.Reg) & 0x400) >> 10
}
func (o *QSPI_Type) SetINSTRFRAME_TFRTYPE(value uint32) {
	volatile.StoreUint32(&o.INSTRFRAME.Reg, volatile.LoadUint32(&o.INSTRFRAME.Reg)&^(0x3000)|value<<12)
}
func (o *QSPI_Type) GetINSTRFRAME_TFRTYPE() uint32 {
	return (volatile.LoadUint32(&o.INSTRFRAME.Reg) & 0x3000) >> 12
}
func (o *QSPI_Type) SetINSTRFRAME_CRMODE(value uint32) {
	volatile.StoreUint32(&o.INSTRFRAME.Reg, volatile.LoadUint32(&o.INSTRFRAME.Reg)&^(0x4000)|value<<14)
}
func (o *QSPI_Type) GetINSTRFRAME_CRMODE() uint32 {
	return (volatile.LoadUint32(&o.INSTRFRAME.Reg) & 0x4000) >> 14
}
func (o *QSPI_Type) SetINSTRFRAME_DDREN(value uint32) {
	volatile.StoreUint32(&o.INSTRFRAME.Reg, volatile.LoadUint32(&o.INSTRFRAME.Reg)&^(0x8000)|value<<15)
}
func (o *QSPI_Type) GetINSTRFRAME_DDREN() uint32 {
	return (volatile.LoadUint32(&o.INSTRFRAME.Reg) & 0x8000) >> 15
}
func (o *QSPI_Type) SetINSTRFRAME_DUMMYLEN(value uint32) {
	volatile.StoreUint32(&o.INSTRFRAME.Reg, volatile.LoadUint32(&o.INSTRFRAME.Reg)&^(0x1f0000)|value<<16)
}
func (o *QSPI_Type) GetINSTRFRAME_DUMMYLEN() uint32 {
	return (volatile.LoadUint32(&o.INSTRFRAME.Reg) & 0x1f0000) >> 16
}

// QSPI.SCRAMBCTRL: Scrambling Mode
func (o *QSPI_Type) SetSCRAMBCTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SCRAMBCTRL.Reg, volatile.LoadUint32(&o.SCRAMBCTRL.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetSCRAMBCTRL_ENABLE() uint32 {
	return volatile.LoadUint32(&o.SCRAMBCTRL.Reg) & 0x1
}
func (o *QSPI_Type) SetSCRAMBCTRL_RANDOMDIS(value uint32) {
	volatile.StoreUint32(&o.SCRAMBCTRL.Reg, volatile.LoadUint32(&o.SCRAMBCTRL.Reg)&^(0x2)|value<<1)
}
func (o *QSPI_Type) GetSCRAMBCTRL_RANDOMDIS() uint32 {
	return (volatile.LoadUint32(&o.SCRAMBCTRL.Reg) & 0x2) >> 1
}

// QSPI.SCRAMBKEY: Scrambling Key
func (o *QSPI_Type) SetSCRAMBKEY(value uint32) {
	volatile.StoreUint32(&o.SCRAMBKEY.Reg, value)
}
func (o *QSPI_Type) GetSCRAMBKEY() uint32 {
	return volatile.LoadUint32(&o.SCRAMBKEY.Reg)
}

// RAM ECC
type RAMECC_Type struct {
	INTENCLR volatile.Register8  // 0x0
	INTENSET volatile.Register8  // 0x1
	INTFLAG  volatile.Register8  // 0x2
	STATUS   volatile.Register8  // 0x3
	ERRADDR  volatile.Register32 // 0x4
	_        [7]byte
	DBGCTRL  volatile.Register8 // 0xF
}

// RAMECC.INTENCLR: Interrupt Enable Clear
func (o *RAMECC_Type) SetINTENCLR_SINGLEE(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *RAMECC_Type) GetINTENCLR_SINGLEE() uint8 {
	return volatile.LoadUint8(&o.INTENCLR.Reg) & 0x1
}
func (o *RAMECC_Type) SetINTENCLR_DUALE(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *RAMECC_Type) GetINTENCLR_DUALE() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x2) >> 1
}

// RAMECC.INTENSET: Interrupt Enable Set
func (o *RAMECC_Type) SetINTENSET_SINGLEE(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *RAMECC_Type) GetINTENSET_SINGLEE() uint8 {
	return volatile.LoadUint8(&o.INTENSET.Reg) & 0x1
}
func (o *RAMECC_Type) SetINTENSET_DUALE(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *RAMECC_Type) GetINTENSET_DUALE() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x2) >> 1
}

// RAMECC.INTFLAG: Interrupt Flag
func (o *RAMECC_Type) SetINTFLAG_SINGLEE(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *RAMECC_Type) GetINTFLAG_SINGLEE() uint8 {
	return volatile.LoadUint8(&o.INTFLAG.Reg) & 0x1
}
func (o *RAMECC_Type) SetINTFLAG_DUALE(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *RAMECC_Type) GetINTFLAG_DUALE() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x2) >> 1
}

// RAMECC.STATUS: Status
func (o *RAMECC_Type) SetSTATUS_ECCDIS(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *RAMECC_Type) GetSTATUS_ECCDIS() uint8 {
	return volatile.LoadUint8(&o.STATUS.Reg) & 0x1
}

// RAMECC.ERRADDR: Error Address
func (o *RAMECC_Type) SetERRADDR(value uint32) {
	volatile.StoreUint32(&o.ERRADDR.Reg, volatile.LoadUint32(&o.ERRADDR.Reg)&^(0x1ffff)|value)
}
func (o *RAMECC_Type) GetERRADDR() uint32 {
	return volatile.LoadUint32(&o.ERRADDR.Reg) & 0x1ffff
}

// RAMECC.DBGCTRL: Debug Control
func (o *RAMECC_Type) SetDBGCTRL_ECCDIS(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x1)|value)
}
func (o *RAMECC_Type) GetDBGCTRL_ECCDIS() uint8 {
	return volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x1
}
func (o *RAMECC_Type) SetDBGCTRL_ECCELOG(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x2)|value<<1)
}
func (o *RAMECC_Type) GetDBGCTRL_ECCELOG() uint8 {
	return (volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x2) >> 1
}

// Reset Controller
type RSTC_Type struct {
	RCAUSE   volatile.Register8 // 0x0
	_        byte
	BKUPEXIT volatile.Register8 // 0x2
}

// RSTC.RCAUSE: Reset Cause
func (o *RSTC_Type) SetRCAUSE_POR(value uint8) {
	volatile.StoreUint8(&o.RCAUSE.Reg, volatile.LoadUint8(&o.RCAUSE.Reg)&^(0x1)|value)
}
func (o *RSTC_Type) GetRCAUSE_POR() uint8 {
	return volatile.LoadUint8(&o.RCAUSE.Reg) & 0x1
}
func (o *RSTC_Type) SetRCAUSE_BODCORE(value uint8) {
	volatile.StoreUint8(&o.RCAUSE.Reg, volatile.LoadUint8(&o.RCAUSE.Reg)&^(0x2)|value<<1)
}
func (o *RSTC_Type) GetRCAUSE_BODCORE() uint8 {
	return (volatile.LoadUint8(&o.RCAUSE.Reg) & 0x2) >> 1
}
func (o *RSTC_Type) SetRCAUSE_BODVDD(value uint8) {
	volatile.StoreUint8(&o.RCAUSE.Reg, volatile.LoadUint8(&o.RCAUSE.Reg)&^(0x4)|value<<2)
}
func (o *RSTC_Type) GetRCAUSE_BODVDD() uint8 {
	return (volatile.LoadUint8(&o.RCAUSE.Reg) & 0x4) >> 2
}
func (o *RSTC_Type) SetRCAUSE_NVM(value uint8) {
	volatile.StoreUint8(&o.RCAUSE.Reg, volatile.LoadUint8(&o.RCAUSE.Reg)&^(0x8)|value<<3)
}
func (o *RSTC_Type) GetRCAUSE_NVM() uint8 {
	return (volatile.LoadUint8(&o.RCAUSE.Reg) & 0x8) >> 3
}
func (o *RSTC_Type) SetRCAUSE_EXT(value uint8) {
	volatile.StoreUint8(&o.RCAUSE.Reg, volatile.LoadUint8(&o.RCAUSE.Reg)&^(0x10)|value<<4)
}
func (o *RSTC_Type) GetRCAUSE_EXT() uint8 {
	return (volatile.LoadUint8(&o.RCAUSE.Reg) & 0x10) >> 4
}
func (o *RSTC_Type) SetRCAUSE_WDT(value uint8) {
	volatile.StoreUint8(&o.RCAUSE.Reg, volatile.LoadUint8(&o.RCAUSE.Reg)&^(0x20)|value<<5)
}
func (o *RSTC_Type) GetRCAUSE_WDT() uint8 {
	return (volatile.LoadUint8(&o.RCAUSE.Reg) & 0x20) >> 5
}
func (o *RSTC_Type) SetRCAUSE_SYST(value uint8) {
	volatile.StoreUint8(&o.RCAUSE.Reg, volatile.LoadUint8(&o.RCAUSE.Reg)&^(0x40)|value<<6)
}
func (o *RSTC_Type) GetRCAUSE_SYST() uint8 {
	return (volatile.LoadUint8(&o.RCAUSE.Reg) & 0x40) >> 6
}
func (o *RSTC_Type) SetRCAUSE_BACKUP(value uint8) {
	volatile.StoreUint8(&o.RCAUSE.Reg, volatile.LoadUint8(&o.RCAUSE.Reg)&^(0x80)|value<<7)
}
func (o *RSTC_Type) GetRCAUSE_BACKUP() uint8 {
	return (volatile.LoadUint8(&o.RCAUSE.Reg) & 0x80) >> 7
}

// RSTC.BKUPEXIT: Backup Exit Source
func (o *RSTC_Type) SetBKUPEXIT_RTC(value uint8) {
	volatile.StoreUint8(&o.BKUPEXIT.Reg, volatile.LoadUint8(&o.BKUPEXIT.Reg)&^(0x2)|value<<1)
}
func (o *RSTC_Type) GetBKUPEXIT_RTC() uint8 {
	return (volatile.LoadUint8(&o.BKUPEXIT.Reg) & 0x2) >> 1
}
func (o *RSTC_Type) SetBKUPEXIT_BBPS(value uint8) {
	volatile.StoreUint8(&o.BKUPEXIT.Reg, volatile.LoadUint8(&o.BKUPEXIT.Reg)&^(0x4)|value<<2)
}
func (o *RSTC_Type) GetBKUPEXIT_BBPS() uint8 {
	return (volatile.LoadUint8(&o.BKUPEXIT.Reg) & 0x4) >> 2
}
func (o *RSTC_Type) SetBKUPEXIT_HIB(value uint8) {
	volatile.StoreUint8(&o.BKUPEXIT.Reg, volatile.LoadUint8(&o.BKUPEXIT.Reg)&^(0x80)|value<<7)
}
func (o *RSTC_Type) GetBKUPEXIT_HIB() uint8 {
	return (volatile.LoadUint8(&o.BKUPEXIT.Reg) & 0x80) >> 7
}

// Real-Time Counter
type RTC_Type struct {
}

// Real-Time Counter - MODE0
type RTC_MODE0_Type struct {
	CTRLA     volatile.Register16 // 0x0
	CTRLB     volatile.Register16 // 0x2
	EVCTRL    volatile.Register32 // 0x4
	INTENCLR  volatile.Register16 // 0x8
	INTENSET  volatile.Register16 // 0xA
	INTFLAG   volatile.Register16 // 0xC
	DBGCTRL   volatile.Register8  // 0xE
	_         byte
	SYNCBUSY  volatile.Register32 // 0x10
	FREQCORR  volatile.Register8  // 0x14
	_         [3]byte
	COUNT     volatile.Register32 // 0x18
	_         [4]byte
	COMP      [2]volatile.Register32 // 0x20
	_         [24]byte
	GP        [4]volatile.Register32 // 0x40
	_         [16]byte
	TAMPCTRL  volatile.Register32 // 0x60
	TIMESTAMP volatile.Register32 // 0x64
	TAMPID    volatile.Register32 // 0x68
	_         [20]byte
	BKUP      [8]volatile.Register32 // 0x80
}

// RTC_MODE0.CTRLA: MODE0 Control A
func (o *RTC_MODE0_Type) SetCTRLA_SWRST(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *RTC_MODE0_Type) GetCTRLA_SWRST() uint16 {
	return volatile.LoadUint16(&o.CTRLA.Reg) & 0x1
}
func (o *RTC_MODE0_Type) SetCTRLA_ENABLE(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE0_Type) GetCTRLA_ENABLE() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *RTC_MODE0_Type) SetCTRLA_MODE(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0xc)|value<<2)
}
func (o *RTC_MODE0_Type) GetCTRLA_MODE() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0xc) >> 2
}
func (o *RTC_MODE0_Type) SetCTRLA_MATCHCLR(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x80)|value<<7)
}
func (o *RTC_MODE0_Type) GetCTRLA_MATCHCLR() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x80) >> 7
}
func (o *RTC_MODE0_Type) SetCTRLA_PRESCALER(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_MODE0_Type) GetCTRLA_PRESCALER() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0xf00) >> 8
}
func (o *RTC_MODE0_Type) SetCTRLA_BKTRST(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_MODE0_Type) GetCTRLA_BKTRST() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x2000) >> 13
}
func (o *RTC_MODE0_Type) SetCTRLA_GPTRST(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_MODE0_Type) GetCTRLA_GPTRST() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x4000) >> 14
}
func (o *RTC_MODE0_Type) SetCTRLA_COUNTSYNC(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_MODE0_Type) GetCTRLA_COUNTSYNC() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x8000) >> 15
}

// RTC_MODE0.CTRLB: MODE0 Control B
func (o *RTC_MODE0_Type) SetCTRLB_GP0EN(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x1)|value)
}
func (o *RTC_MODE0_Type) GetCTRLB_GP0EN() uint16 {
	return volatile.LoadUint16(&o.CTRLB.Reg) & 0x1
}
func (o *RTC_MODE0_Type) SetCTRLB_GP2EN(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE0_Type) GetCTRLB_GP2EN() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x2) >> 1
}
func (o *RTC_MODE0_Type) SetCTRLB_DEBMAJ(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x10)|value<<4)
}
func (o *RTC_MODE0_Type) GetCTRLB_DEBMAJ() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x10) >> 4
}
func (o *RTC_MODE0_Type) SetCTRLB_DEBASYNC(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x20)|value<<5)
}
func (o *RTC_MODE0_Type) GetCTRLB_DEBASYNC() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x20) >> 5
}
func (o *RTC_MODE0_Type) SetCTRLB_RTCOUT(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x40)|value<<6)
}
func (o *RTC_MODE0_Type) GetCTRLB_RTCOUT() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x40) >> 6
}
func (o *RTC_MODE0_Type) SetCTRLB_DMAEN(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x80)|value<<7)
}
func (o *RTC_MODE0_Type) GetCTRLB_DMAEN() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x80) >> 7
}
func (o *RTC_MODE0_Type) SetCTRLB_DEBF(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x700)|value<<8)
}
func (o *RTC_MODE0_Type) GetCTRLB_DEBF() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x700) >> 8
}
func (o *RTC_MODE0_Type) SetCTRLB_ACTF(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_MODE0_Type) GetCTRLB_ACTF() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x7000) >> 12
}

// RTC_MODE0.EVCTRL: MODE0 Event Control
func (o *RTC_MODE0_Type) SetEVCTRL_PEREO0(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x1)|value)
}
func (o *RTC_MODE0_Type) GetEVCTRL_PEREO0() uint32 {
	return volatile.LoadUint32(&o.EVCTRL.Reg) & 0x1
}
func (o *RTC_MODE0_Type) SetEVCTRL_PEREO1(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE0_Type) GetEVCTRL_PEREO1() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x2) >> 1
}
func (o *RTC_MODE0_Type) SetEVCTRL_PEREO2(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x4)|value<<2)
}
func (o *RTC_MODE0_Type) GetEVCTRL_PEREO2() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x4) >> 2
}
func (o *RTC_MODE0_Type) SetEVCTRL_PEREO3(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x8)|value<<3)
}
func (o *RTC_MODE0_Type) GetEVCTRL_PEREO3() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x8) >> 3
}
func (o *RTC_MODE0_Type) SetEVCTRL_PEREO4(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x10)|value<<4)
}
func (o *RTC_MODE0_Type) GetEVCTRL_PEREO4() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x10) >> 4
}
func (o *RTC_MODE0_Type) SetEVCTRL_PEREO5(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x20)|value<<5)
}
func (o *RTC_MODE0_Type) GetEVCTRL_PEREO5() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x20) >> 5
}
func (o *RTC_MODE0_Type) SetEVCTRL_PEREO6(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x40)|value<<6)
}
func (o *RTC_MODE0_Type) GetEVCTRL_PEREO6() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x40) >> 6
}
func (o *RTC_MODE0_Type) SetEVCTRL_PEREO7(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x80)|value<<7)
}
func (o *RTC_MODE0_Type) GetEVCTRL_PEREO7() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x80) >> 7
}
func (o *RTC_MODE0_Type) SetEVCTRL_CMPEO0(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x100)|value<<8)
}
func (o *RTC_MODE0_Type) GetEVCTRL_CMPEO0() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x100) >> 8
}
func (o *RTC_MODE0_Type) SetEVCTRL_CMPEO1(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x200)|value<<9)
}
func (o *RTC_MODE0_Type) GetEVCTRL_CMPEO1() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x200) >> 9
}
func (o *RTC_MODE0_Type) SetEVCTRL_TAMPEREO(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_MODE0_Type) GetEVCTRL_TAMPEREO() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x4000) >> 14
}
func (o *RTC_MODE0_Type) SetEVCTRL_OVFEO(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_MODE0_Type) GetEVCTRL_OVFEO() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x8000) >> 15
}
func (o *RTC_MODE0_Type) SetEVCTRL_TAMPEVEI(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_MODE0_Type) GetEVCTRL_TAMPEVEI() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x10000) >> 16
}

// RTC_MODE0.INTENCLR: MODE0 Interrupt Enable Clear
func (o *RTC_MODE0_Type) SetINTENCLR_PER0(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *RTC_MODE0_Type) GetINTENCLR_PER0() uint16 {
	return volatile.LoadUint16(&o.INTENCLR.Reg) & 0x1
}
func (o *RTC_MODE0_Type) SetINTENCLR_PER1(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE0_Type) GetINTENCLR_PER1() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *RTC_MODE0_Type) SetINTENCLR_PER2(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_MODE0_Type) GetINTENCLR_PER2() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *RTC_MODE0_Type) SetINTENCLR_PER3(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_MODE0_Type) GetINTENCLR_PER3() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *RTC_MODE0_Type) SetINTENCLR_PER4(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_MODE0_Type) GetINTENCLR_PER4() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *RTC_MODE0_Type) SetINTENCLR_PER5(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_MODE0_Type) GetINTENCLR_PER5() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *RTC_MODE0_Type) SetINTENCLR_PER6(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_MODE0_Type) GetINTENCLR_PER6() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *RTC_MODE0_Type) SetINTENCLR_PER7(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_MODE0_Type) GetINTENCLR_PER7() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *RTC_MODE0_Type) SetINTENCLR_CMP0(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *RTC_MODE0_Type) GetINTENCLR_CMP0() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *RTC_MODE0_Type) SetINTENCLR_CMP1(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *RTC_MODE0_Type) GetINTENCLR_CMP1() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *RTC_MODE0_Type) SetINTENCLR_TAMPER(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_MODE0_Type) GetINTENCLR_TAMPER() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x4000) >> 14
}
func (o *RTC_MODE0_Type) SetINTENCLR_OVF(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_MODE0_Type) GetINTENCLR_OVF() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x8000) >> 15
}

// RTC_MODE0.INTENSET: MODE0 Interrupt Enable Set
func (o *RTC_MODE0_Type) SetINTENSET_PER0(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *RTC_MODE0_Type) GetINTENSET_PER0() uint16 {
	return volatile.LoadUint16(&o.INTENSET.Reg) & 0x1
}
func (o *RTC_MODE0_Type) SetINTENSET_PER1(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE0_Type) GetINTENSET_PER1() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *RTC_MODE0_Type) SetINTENSET_PER2(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *RTC_MODE0_Type) GetINTENSET_PER2() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *RTC_MODE0_Type) SetINTENSET_PER3(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *RTC_MODE0_Type) GetINTENSET_PER3() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *RTC_MODE0_Type) SetINTENSET_PER4(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *RTC_MODE0_Type) GetINTENSET_PER4() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *RTC_MODE0_Type) SetINTENSET_PER5(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *RTC_MODE0_Type) GetINTENSET_PER5() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *RTC_MODE0_Type) SetINTENSET_PER6(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *RTC_MODE0_Type) GetINTENSET_PER6() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *RTC_MODE0_Type) SetINTENSET_PER7(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *RTC_MODE0_Type) GetINTENSET_PER7() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *RTC_MODE0_Type) SetINTENSET_CMP0(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *RTC_MODE0_Type) GetINTENSET_CMP0() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *RTC_MODE0_Type) SetINTENSET_CMP1(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *RTC_MODE0_Type) GetINTENSET_CMP1() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *RTC_MODE0_Type) SetINTENSET_TAMPER(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_MODE0_Type) GetINTENSET_TAMPER() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x4000) >> 14
}
func (o *RTC_MODE0_Type) SetINTENSET_OVF(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_MODE0_Type) GetINTENSET_OVF() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x8000) >> 15
}

// RTC_MODE0.INTFLAG: MODE0 Interrupt Flag Status and Clear
func (o *RTC_MODE0_Type) SetINTFLAG_PER0(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *RTC_MODE0_Type) GetINTFLAG_PER0() uint16 {
	return volatile.LoadUint16(&o.INTFLAG.Reg) & 0x1
}
func (o *RTC_MODE0_Type) SetINTFLAG_PER1(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE0_Type) GetINTFLAG_PER1() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *RTC_MODE0_Type) SetINTFLAG_PER2(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x4)|value<<2)
}
func (o *RTC_MODE0_Type) GetINTFLAG_PER2() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x4) >> 2
}
func (o *RTC_MODE0_Type) SetINTFLAG_PER3(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x8)|value<<3)
}
func (o *RTC_MODE0_Type) GetINTFLAG_PER3() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x8) >> 3
}
func (o *RTC_MODE0_Type) SetINTFLAG_PER4(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x10)|value<<4)
}
func (o *RTC_MODE0_Type) GetINTFLAG_PER4() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x10) >> 4
}
func (o *RTC_MODE0_Type) SetINTFLAG_PER5(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x20)|value<<5)
}
func (o *RTC_MODE0_Type) GetINTFLAG_PER5() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x20) >> 5
}
func (o *RTC_MODE0_Type) SetINTFLAG_PER6(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x40)|value<<6)
}
func (o *RTC_MODE0_Type) GetINTFLAG_PER6() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x40) >> 6
}
func (o *RTC_MODE0_Type) SetINTFLAG_PER7(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x80)|value<<7)
}
func (o *RTC_MODE0_Type) GetINTFLAG_PER7() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x80) >> 7
}
func (o *RTC_MODE0_Type) SetINTFLAG_CMP0(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x100)|value<<8)
}
func (o *RTC_MODE0_Type) GetINTFLAG_CMP0() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x100) >> 8
}
func (o *RTC_MODE0_Type) SetINTFLAG_CMP1(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x200)|value<<9)
}
func (o *RTC_MODE0_Type) GetINTFLAG_CMP1() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x200) >> 9
}
func (o *RTC_MODE0_Type) SetINTFLAG_TAMPER(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_MODE0_Type) GetINTFLAG_TAMPER() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x4000) >> 14
}
func (o *RTC_MODE0_Type) SetINTFLAG_OVF(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_MODE0_Type) GetINTFLAG_OVF() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x8000) >> 15
}

// RTC_MODE0.DBGCTRL: Debug Control
func (o *RTC_MODE0_Type) SetDBGCTRL_DBGRUN(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x1)|value)
}
func (o *RTC_MODE0_Type) GetDBGCTRL_DBGRUN() uint8 {
	return volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x1
}

// RTC_MODE0.SYNCBUSY: MODE0 Synchronization Busy Status
func (o *RTC_MODE0_Type) SetSYNCBUSY_SWRST(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *RTC_MODE0_Type) GetSYNCBUSY_SWRST() uint32 {
	return volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x1
}
func (o *RTC_MODE0_Type) SetSYNCBUSY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE0_Type) GetSYNCBUSY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x2) >> 1
}
func (o *RTC_MODE0_Type) SetSYNCBUSY_FREQCORR(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x4)|value<<2)
}
func (o *RTC_MODE0_Type) GetSYNCBUSY_FREQCORR() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x4) >> 2
}
func (o *RTC_MODE0_Type) SetSYNCBUSY_COUNT(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x8)|value<<3)
}
func (o *RTC_MODE0_Type) GetSYNCBUSY_COUNT() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x8) >> 3
}
func (o *RTC_MODE0_Type) SetSYNCBUSY_COMP0(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x20)|value<<5)
}
func (o *RTC_MODE0_Type) GetSYNCBUSY_COMP0() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x20) >> 5
}
func (o *RTC_MODE0_Type) SetSYNCBUSY_COMP1(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x40)|value<<6)
}
func (o *RTC_MODE0_Type) GetSYNCBUSY_COMP1() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x40) >> 6
}
func (o *RTC_MODE0_Type) SetSYNCBUSY_COUNTSYNC(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_MODE0_Type) GetSYNCBUSY_COUNTSYNC() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x8000) >> 15
}
func (o *RTC_MODE0_Type) SetSYNCBUSY_GP0(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_MODE0_Type) GetSYNCBUSY_GP0() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x10000) >> 16
}
func (o *RTC_MODE0_Type) SetSYNCBUSY_GP1(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_MODE0_Type) GetSYNCBUSY_GP1() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x20000) >> 17
}
func (o *RTC_MODE0_Type) SetSYNCBUSY_GP2(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_MODE0_Type) GetSYNCBUSY_GP2() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x40000) >> 18
}
func (o *RTC_MODE0_Type) SetSYNCBUSY_GP3(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_MODE0_Type) GetSYNCBUSY_GP3() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x80000) >> 19
}

// RTC_MODE0.FREQCORR: Frequency Correction
func (o *RTC_MODE0_Type) SetFREQCORR_VALUE(value uint8) {
	volatile.StoreUint8(&o.FREQCORR.Reg, volatile.LoadUint8(&o.FREQCORR.Reg)&^(0x7f)|value)
}
func (o *RTC_MODE0_Type) GetFREQCORR_VALUE() uint8 {
	return volatile.LoadUint8(&o.FREQCORR.Reg) & 0x7f
}
func (o *RTC_MODE0_Type) SetFREQCORR_SIGN(value uint8) {
	volatile.StoreUint8(&o.FREQCORR.Reg, volatile.LoadUint8(&o.FREQCORR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_MODE0_Type) GetFREQCORR_SIGN() uint8 {
	return (volatile.LoadUint8(&o.FREQCORR.Reg) & 0x80) >> 7
}

// RTC_MODE0.COUNT: MODE0 Counter Value
func (o *RTC_MODE0_Type) SetCOUNT(value uint32) {
	volatile.StoreUint32(&o.COUNT.Reg, value)
}
func (o *RTC_MODE0_Type) GetCOUNT() uint32 {
	return volatile.LoadUint32(&o.COUNT.Reg)
}

// RTC_MODE0.COMP: MODE0 Compare n Value
func (o *RTC_MODE0_Type) SetCOMP(idx int, value uint32) {
	volatile.StoreUint32(&o.COMP[idx].Reg, value)
}
func (o *RTC_MODE0_Type) GetCOMP(idx int) uint32 {
	return volatile.LoadUint32(&o.COMP[idx].Reg)
}

// RTC_MODE0.GP: General Purpose
func (o *RTC_MODE0_Type) SetGP(idx int, value uint32) {
	volatile.StoreUint32(&o.GP[idx].Reg, value)
}
func (o *RTC_MODE0_Type) GetGP(idx int) uint32 {
	return volatile.LoadUint32(&o.GP[idx].Reg)
}

// RTC_MODE0.TAMPCTRL: Tamper Control
func (o *RTC_MODE0_Type) SetTAMPCTRL_IN0ACT(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x3)|value)
}
func (o *RTC_MODE0_Type) GetTAMPCTRL_IN0ACT() uint32 {
	return volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x3
}
func (o *RTC_MODE0_Type) SetTAMPCTRL_IN1ACT(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0xc)|value<<2)
}
func (o *RTC_MODE0_Type) GetTAMPCTRL_IN1ACT() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0xc) >> 2
}
func (o *RTC_MODE0_Type) SetTAMPCTRL_IN2ACT(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x30)|value<<4)
}
func (o *RTC_MODE0_Type) GetTAMPCTRL_IN2ACT() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x30) >> 4
}
func (o *RTC_MODE0_Type) SetTAMPCTRL_IN3ACT(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0xc0)|value<<6)
}
func (o *RTC_MODE0_Type) GetTAMPCTRL_IN3ACT() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0xc0) >> 6
}
func (o *RTC_MODE0_Type) SetTAMPCTRL_IN4ACT(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x300)|value<<8)
}
func (o *RTC_MODE0_Type) GetTAMPCTRL_IN4ACT() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x300) >> 8
}
func (o *RTC_MODE0_Type) SetTAMPCTRL_TAMLVL0(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_MODE0_Type) GetTAMPCTRL_TAMLVL0() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x10000) >> 16
}
func (o *RTC_MODE0_Type) SetTAMPCTRL_TAMLVL1(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_MODE0_Type) GetTAMPCTRL_TAMLVL1() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x20000) >> 17
}
func (o *RTC_MODE0_Type) SetTAMPCTRL_TAMLVL2(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_MODE0_Type) GetTAMPCTRL_TAMLVL2() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x40000) >> 18
}
func (o *RTC_MODE0_Type) SetTAMPCTRL_TAMLVL3(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_MODE0_Type) GetTAMPCTRL_TAMLVL3() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x80000) >> 19
}
func (o *RTC_MODE0_Type) SetTAMPCTRL_TAMLVL4(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_MODE0_Type) GetTAMPCTRL_TAMLVL4() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x100000) >> 20
}
func (o *RTC_MODE0_Type) SetTAMPCTRL_DEBNC0(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_MODE0_Type) GetTAMPCTRL_DEBNC0() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x1000000) >> 24
}
func (o *RTC_MODE0_Type) SetTAMPCTRL_DEBNC1(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_MODE0_Type) GetTAMPCTRL_DEBNC1() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x2000000) >> 25
}
func (o *RTC_MODE0_Type) SetTAMPCTRL_DEBNC2(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_MODE0_Type) GetTAMPCTRL_DEBNC2() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x4000000) >> 26
}
func (o *RTC_MODE0_Type) SetTAMPCTRL_DEBNC3(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_MODE0_Type) GetTAMPCTRL_DEBNC3() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x8000000) >> 27
}
func (o *RTC_MODE0_Type) SetTAMPCTRL_DEBNC4(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_MODE0_Type) GetTAMPCTRL_DEBNC4() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x10000000) >> 28
}

// RTC_MODE0.TIMESTAMP: MODE0 Timestamp
func (o *RTC_MODE0_Type) SetTIMESTAMP(value uint32) {
	volatile.StoreUint32(&o.TIMESTAMP.Reg, value)
}
func (o *RTC_MODE0_Type) GetTIMESTAMP() uint32 {
	return volatile.LoadUint32(&o.TIMESTAMP.Reg)
}

// RTC_MODE0.TAMPID: Tamper ID
func (o *RTC_MODE0_Type) SetTAMPID_TAMPID0(value uint32) {
	volatile.StoreUint32(&o.TAMPID.Reg, volatile.LoadUint32(&o.TAMPID.Reg)&^(0x1)|value)
}
func (o *RTC_MODE0_Type) GetTAMPID_TAMPID0() uint32 {
	return volatile.LoadUint32(&o.TAMPID.Reg) & 0x1
}
func (o *RTC_MODE0_Type) SetTAMPID_TAMPID1(value uint32) {
	volatile.StoreUint32(&o.TAMPID.Reg, volatile.LoadUint32(&o.TAMPID.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE0_Type) GetTAMPID_TAMPID1() uint32 {
	return (volatile.LoadUint32(&o.TAMPID.Reg) & 0x2) >> 1
}
func (o *RTC_MODE0_Type) SetTAMPID_TAMPID2(value uint32) {
	volatile.StoreUint32(&o.TAMPID.Reg, volatile.LoadUint32(&o.TAMPID.Reg)&^(0x4)|value<<2)
}
func (o *RTC_MODE0_Type) GetTAMPID_TAMPID2() uint32 {
	return (volatile.LoadUint32(&o.TAMPID.Reg) & 0x4) >> 2
}
func (o *RTC_MODE0_Type) SetTAMPID_TAMPID3(value uint32) {
	volatile.StoreUint32(&o.TAMPID.Reg, volatile.LoadUint32(&o.TAMPID.Reg)&^(0x8)|value<<3)
}
func (o *RTC_MODE0_Type) GetTAMPID_TAMPID3() uint32 {
	return (volatile.LoadUint32(&o.TAMPID.Reg) & 0x8) >> 3
}
func (o *RTC_MODE0_Type) SetTAMPID_TAMPID4(value uint32) {
	volatile.StoreUint32(&o.TAMPID.Reg, volatile.LoadUint32(&o.TAMPID.Reg)&^(0x10)|value<<4)
}
func (o *RTC_MODE0_Type) GetTAMPID_TAMPID4() uint32 {
	return (volatile.LoadUint32(&o.TAMPID.Reg) & 0x10) >> 4
}
func (o *RTC_MODE0_Type) SetTAMPID_TAMPEVT(value uint32) {
	volatile.StoreUint32(&o.TAMPID.Reg, volatile.LoadUint32(&o.TAMPID.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_MODE0_Type) GetTAMPID_TAMPEVT() uint32 {
	return (volatile.LoadUint32(&o.TAMPID.Reg) & 0x80000000) >> 31
}

// RTC_MODE0.BKUP: Backup
func (o *RTC_MODE0_Type) SetBKUP(idx int, value uint32) {
	volatile.StoreUint32(&o.BKUP[idx].Reg, value)
}
func (o *RTC_MODE0_Type) GetBKUP(idx int) uint32 {
	return volatile.LoadUint32(&o.BKUP[idx].Reg)
}

// Real-Time Counter - MODE1
type RTC_MODE1_Type struct {
	CTRLA     volatile.Register16 // 0x0
	CTRLB     volatile.Register16 // 0x2
	EVCTRL    volatile.Register32 // 0x4
	INTENCLR  volatile.Register16 // 0x8
	INTENSET  volatile.Register16 // 0xA
	INTFLAG   volatile.Register16 // 0xC
	DBGCTRL   volatile.Register8  // 0xE
	_         byte
	SYNCBUSY  volatile.Register32 // 0x10
	FREQCORR  volatile.Register8  // 0x14
	_         [3]byte
	COUNT     volatile.Register16 // 0x18
	_         [2]byte
	PER       volatile.Register16 // 0x1C
	_         [2]byte
	COMP      [4]volatile.Register16 // 0x20
	_         [24]byte
	GP        [4]volatile.Register32 // 0x40
	_         [16]byte
	TAMPCTRL  volatile.Register32 // 0x60
	TIMESTAMP volatile.Register32 // 0x64
	TAMPID    volatile.Register32 // 0x68
	_         [20]byte
	BKUP      [8]volatile.Register32 // 0x80
}

// RTC_MODE1.CTRLA: MODE1 Control A
func (o *RTC_MODE1_Type) SetCTRLA_SWRST(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *RTC_MODE1_Type) GetCTRLA_SWRST() uint16 {
	return volatile.LoadUint16(&o.CTRLA.Reg) & 0x1
}
func (o *RTC_MODE1_Type) SetCTRLA_ENABLE(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE1_Type) GetCTRLA_ENABLE() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *RTC_MODE1_Type) SetCTRLA_MODE(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0xc)|value<<2)
}
func (o *RTC_MODE1_Type) GetCTRLA_MODE() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0xc) >> 2
}
func (o *RTC_MODE1_Type) SetCTRLA_PRESCALER(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_MODE1_Type) GetCTRLA_PRESCALER() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0xf00) >> 8
}
func (o *RTC_MODE1_Type) SetCTRLA_BKTRST(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_MODE1_Type) GetCTRLA_BKTRST() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x2000) >> 13
}
func (o *RTC_MODE1_Type) SetCTRLA_GPTRST(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_MODE1_Type) GetCTRLA_GPTRST() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x4000) >> 14
}
func (o *RTC_MODE1_Type) SetCTRLA_COUNTSYNC(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_MODE1_Type) GetCTRLA_COUNTSYNC() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x8000) >> 15
}

// RTC_MODE1.CTRLB: MODE1 Control B
func (o *RTC_MODE1_Type) SetCTRLB_GP0EN(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x1)|value)
}
func (o *RTC_MODE1_Type) GetCTRLB_GP0EN() uint16 {
	return volatile.LoadUint16(&o.CTRLB.Reg) & 0x1
}
func (o *RTC_MODE1_Type) SetCTRLB_GP2EN(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE1_Type) GetCTRLB_GP2EN() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x2) >> 1
}
func (o *RTC_MODE1_Type) SetCTRLB_DEBMAJ(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x10)|value<<4)
}
func (o *RTC_MODE1_Type) GetCTRLB_DEBMAJ() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x10) >> 4
}
func (o *RTC_MODE1_Type) SetCTRLB_DEBASYNC(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x20)|value<<5)
}
func (o *RTC_MODE1_Type) GetCTRLB_DEBASYNC() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x20) >> 5
}
func (o *RTC_MODE1_Type) SetCTRLB_RTCOUT(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x40)|value<<6)
}
func (o *RTC_MODE1_Type) GetCTRLB_RTCOUT() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x40) >> 6
}
func (o *RTC_MODE1_Type) SetCTRLB_DMAEN(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x80)|value<<7)
}
func (o *RTC_MODE1_Type) GetCTRLB_DMAEN() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x80) >> 7
}
func (o *RTC_MODE1_Type) SetCTRLB_DEBF(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x700)|value<<8)
}
func (o *RTC_MODE1_Type) GetCTRLB_DEBF() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x700) >> 8
}
func (o *RTC_MODE1_Type) SetCTRLB_ACTF(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_MODE1_Type) GetCTRLB_ACTF() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x7000) >> 12
}

// RTC_MODE1.EVCTRL: MODE1 Event Control
func (o *RTC_MODE1_Type) SetEVCTRL_PEREO0(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x1)|value)
}
func (o *RTC_MODE1_Type) GetEVCTRL_PEREO0() uint32 {
	return volatile.LoadUint32(&o.EVCTRL.Reg) & 0x1
}
func (o *RTC_MODE1_Type) SetEVCTRL_PEREO1(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE1_Type) GetEVCTRL_PEREO1() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x2) >> 1
}
func (o *RTC_MODE1_Type) SetEVCTRL_PEREO2(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x4)|value<<2)
}
func (o *RTC_MODE1_Type) GetEVCTRL_PEREO2() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x4) >> 2
}
func (o *RTC_MODE1_Type) SetEVCTRL_PEREO3(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x8)|value<<3)
}
func (o *RTC_MODE1_Type) GetEVCTRL_PEREO3() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x8) >> 3
}
func (o *RTC_MODE1_Type) SetEVCTRL_PEREO4(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x10)|value<<4)
}
func (o *RTC_MODE1_Type) GetEVCTRL_PEREO4() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x10) >> 4
}
func (o *RTC_MODE1_Type) SetEVCTRL_PEREO5(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x20)|value<<5)
}
func (o *RTC_MODE1_Type) GetEVCTRL_PEREO5() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x20) >> 5
}
func (o *RTC_MODE1_Type) SetEVCTRL_PEREO6(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x40)|value<<6)
}
func (o *RTC_MODE1_Type) GetEVCTRL_PEREO6() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x40) >> 6
}
func (o *RTC_MODE1_Type) SetEVCTRL_PEREO7(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x80)|value<<7)
}
func (o *RTC_MODE1_Type) GetEVCTRL_PEREO7() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x80) >> 7
}
func (o *RTC_MODE1_Type) SetEVCTRL_CMPEO0(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x100)|value<<8)
}
func (o *RTC_MODE1_Type) GetEVCTRL_CMPEO0() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x100) >> 8
}
func (o *RTC_MODE1_Type) SetEVCTRL_CMPEO1(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x200)|value<<9)
}
func (o *RTC_MODE1_Type) GetEVCTRL_CMPEO1() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x200) >> 9
}
func (o *RTC_MODE1_Type) SetEVCTRL_CMPEO2(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x400)|value<<10)
}
func (o *RTC_MODE1_Type) GetEVCTRL_CMPEO2() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x400) >> 10
}
func (o *RTC_MODE1_Type) SetEVCTRL_CMPEO3(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x800)|value<<11)
}
func (o *RTC_MODE1_Type) GetEVCTRL_CMPEO3() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x800) >> 11
}
func (o *RTC_MODE1_Type) SetEVCTRL_TAMPEREO(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_MODE1_Type) GetEVCTRL_TAMPEREO() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x4000) >> 14
}
func (o *RTC_MODE1_Type) SetEVCTRL_OVFEO(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_MODE1_Type) GetEVCTRL_OVFEO() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x8000) >> 15
}
func (o *RTC_MODE1_Type) SetEVCTRL_TAMPEVEI(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_MODE1_Type) GetEVCTRL_TAMPEVEI() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x10000) >> 16
}

// RTC_MODE1.INTENCLR: MODE1 Interrupt Enable Clear
func (o *RTC_MODE1_Type) SetINTENCLR_PER0(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *RTC_MODE1_Type) GetINTENCLR_PER0() uint16 {
	return volatile.LoadUint16(&o.INTENCLR.Reg) & 0x1
}
func (o *RTC_MODE1_Type) SetINTENCLR_PER1(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE1_Type) GetINTENCLR_PER1() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *RTC_MODE1_Type) SetINTENCLR_PER2(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_MODE1_Type) GetINTENCLR_PER2() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *RTC_MODE1_Type) SetINTENCLR_PER3(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_MODE1_Type) GetINTENCLR_PER3() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *RTC_MODE1_Type) SetINTENCLR_PER4(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_MODE1_Type) GetINTENCLR_PER4() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *RTC_MODE1_Type) SetINTENCLR_PER5(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_MODE1_Type) GetINTENCLR_PER5() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *RTC_MODE1_Type) SetINTENCLR_PER6(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_MODE1_Type) GetINTENCLR_PER6() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *RTC_MODE1_Type) SetINTENCLR_PER7(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_MODE1_Type) GetINTENCLR_PER7() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *RTC_MODE1_Type) SetINTENCLR_CMP0(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *RTC_MODE1_Type) GetINTENCLR_CMP0() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *RTC_MODE1_Type) SetINTENCLR_CMP1(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *RTC_MODE1_Type) GetINTENCLR_CMP1() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *RTC_MODE1_Type) SetINTENCLR_CMP2(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x400)|value<<10)
}
func (o *RTC_MODE1_Type) GetINTENCLR_CMP2() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x400) >> 10
}
func (o *RTC_MODE1_Type) SetINTENCLR_CMP3(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x800)|value<<11)
}
func (o *RTC_MODE1_Type) GetINTENCLR_CMP3() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x800) >> 11
}
func (o *RTC_MODE1_Type) SetINTENCLR_TAMPER(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_MODE1_Type) GetINTENCLR_TAMPER() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x4000) >> 14
}
func (o *RTC_MODE1_Type) SetINTENCLR_OVF(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_MODE1_Type) GetINTENCLR_OVF() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x8000) >> 15
}

// RTC_MODE1.INTENSET: MODE1 Interrupt Enable Set
func (o *RTC_MODE1_Type) SetINTENSET_PER0(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *RTC_MODE1_Type) GetINTENSET_PER0() uint16 {
	return volatile.LoadUint16(&o.INTENSET.Reg) & 0x1
}
func (o *RTC_MODE1_Type) SetINTENSET_PER1(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE1_Type) GetINTENSET_PER1() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *RTC_MODE1_Type) SetINTENSET_PER2(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *RTC_MODE1_Type) GetINTENSET_PER2() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *RTC_MODE1_Type) SetINTENSET_PER3(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *RTC_MODE1_Type) GetINTENSET_PER3() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *RTC_MODE1_Type) SetINTENSET_PER4(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *RTC_MODE1_Type) GetINTENSET_PER4() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *RTC_MODE1_Type) SetINTENSET_PER5(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *RTC_MODE1_Type) GetINTENSET_PER5() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *RTC_MODE1_Type) SetINTENSET_PER6(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *RTC_MODE1_Type) GetINTENSET_PER6() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *RTC_MODE1_Type) SetINTENSET_PER7(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *RTC_MODE1_Type) GetINTENSET_PER7() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *RTC_MODE1_Type) SetINTENSET_CMP0(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *RTC_MODE1_Type) GetINTENSET_CMP0() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *RTC_MODE1_Type) SetINTENSET_CMP1(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *RTC_MODE1_Type) GetINTENSET_CMP1() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *RTC_MODE1_Type) SetINTENSET_CMP2(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x400)|value<<10)
}
func (o *RTC_MODE1_Type) GetINTENSET_CMP2() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x400) >> 10
}
func (o *RTC_MODE1_Type) SetINTENSET_CMP3(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x800)|value<<11)
}
func (o *RTC_MODE1_Type) GetINTENSET_CMP3() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x800) >> 11
}
func (o *RTC_MODE1_Type) SetINTENSET_TAMPER(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_MODE1_Type) GetINTENSET_TAMPER() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x4000) >> 14
}
func (o *RTC_MODE1_Type) SetINTENSET_OVF(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_MODE1_Type) GetINTENSET_OVF() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x8000) >> 15
}

// RTC_MODE1.INTFLAG: MODE1 Interrupt Flag Status and Clear
func (o *RTC_MODE1_Type) SetINTFLAG_PER0(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *RTC_MODE1_Type) GetINTFLAG_PER0() uint16 {
	return volatile.LoadUint16(&o.INTFLAG.Reg) & 0x1
}
func (o *RTC_MODE1_Type) SetINTFLAG_PER1(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE1_Type) GetINTFLAG_PER1() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *RTC_MODE1_Type) SetINTFLAG_PER2(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x4)|value<<2)
}
func (o *RTC_MODE1_Type) GetINTFLAG_PER2() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x4) >> 2
}
func (o *RTC_MODE1_Type) SetINTFLAG_PER3(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x8)|value<<3)
}
func (o *RTC_MODE1_Type) GetINTFLAG_PER3() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x8) >> 3
}
func (o *RTC_MODE1_Type) SetINTFLAG_PER4(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x10)|value<<4)
}
func (o *RTC_MODE1_Type) GetINTFLAG_PER4() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x10) >> 4
}
func (o *RTC_MODE1_Type) SetINTFLAG_PER5(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x20)|value<<5)
}
func (o *RTC_MODE1_Type) GetINTFLAG_PER5() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x20) >> 5
}
func (o *RTC_MODE1_Type) SetINTFLAG_PER6(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x40)|value<<6)
}
func (o *RTC_MODE1_Type) GetINTFLAG_PER6() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x40) >> 6
}
func (o *RTC_MODE1_Type) SetINTFLAG_PER7(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x80)|value<<7)
}
func (o *RTC_MODE1_Type) GetINTFLAG_PER7() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x80) >> 7
}
func (o *RTC_MODE1_Type) SetINTFLAG_CMP0(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x100)|value<<8)
}
func (o *RTC_MODE1_Type) GetINTFLAG_CMP0() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x100) >> 8
}
func (o *RTC_MODE1_Type) SetINTFLAG_CMP1(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x200)|value<<9)
}
func (o *RTC_MODE1_Type) GetINTFLAG_CMP1() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x200) >> 9
}
func (o *RTC_MODE1_Type) SetINTFLAG_CMP2(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x400)|value<<10)
}
func (o *RTC_MODE1_Type) GetINTFLAG_CMP2() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x400) >> 10
}
func (o *RTC_MODE1_Type) SetINTFLAG_CMP3(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x800)|value<<11)
}
func (o *RTC_MODE1_Type) GetINTFLAG_CMP3() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x800) >> 11
}
func (o *RTC_MODE1_Type) SetINTFLAG_TAMPER(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_MODE1_Type) GetINTFLAG_TAMPER() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x4000) >> 14
}
func (o *RTC_MODE1_Type) SetINTFLAG_OVF(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_MODE1_Type) GetINTFLAG_OVF() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x8000) >> 15
}

// RTC_MODE1.DBGCTRL: Debug Control
func (o *RTC_MODE1_Type) SetDBGCTRL_DBGRUN(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x1)|value)
}
func (o *RTC_MODE1_Type) GetDBGCTRL_DBGRUN() uint8 {
	return volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x1
}

// RTC_MODE1.SYNCBUSY: MODE1 Synchronization Busy Status
func (o *RTC_MODE1_Type) SetSYNCBUSY_SWRST(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *RTC_MODE1_Type) GetSYNCBUSY_SWRST() uint32 {
	return volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x1
}
func (o *RTC_MODE1_Type) SetSYNCBUSY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE1_Type) GetSYNCBUSY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x2) >> 1
}
func (o *RTC_MODE1_Type) SetSYNCBUSY_FREQCORR(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x4)|value<<2)
}
func (o *RTC_MODE1_Type) GetSYNCBUSY_FREQCORR() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x4) >> 2
}
func (o *RTC_MODE1_Type) SetSYNCBUSY_COUNT(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x8)|value<<3)
}
func (o *RTC_MODE1_Type) GetSYNCBUSY_COUNT() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x8) >> 3
}
func (o *RTC_MODE1_Type) SetSYNCBUSY_PER(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x10)|value<<4)
}
func (o *RTC_MODE1_Type) GetSYNCBUSY_PER() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x10) >> 4
}
func (o *RTC_MODE1_Type) SetSYNCBUSY_COMP0(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x20)|value<<5)
}
func (o *RTC_MODE1_Type) GetSYNCBUSY_COMP0() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x20) >> 5
}
func (o *RTC_MODE1_Type) SetSYNCBUSY_COMP1(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x40)|value<<6)
}
func (o *RTC_MODE1_Type) GetSYNCBUSY_COMP1() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x40) >> 6
}
func (o *RTC_MODE1_Type) SetSYNCBUSY_COMP2(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x80)|value<<7)
}
func (o *RTC_MODE1_Type) GetSYNCBUSY_COMP2() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x80) >> 7
}
func (o *RTC_MODE1_Type) SetSYNCBUSY_COMP3(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x100)|value<<8)
}
func (o *RTC_MODE1_Type) GetSYNCBUSY_COMP3() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x100) >> 8
}
func (o *RTC_MODE1_Type) SetSYNCBUSY_COUNTSYNC(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_MODE1_Type) GetSYNCBUSY_COUNTSYNC() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x8000) >> 15
}
func (o *RTC_MODE1_Type) SetSYNCBUSY_GP0(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_MODE1_Type) GetSYNCBUSY_GP0() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x10000) >> 16
}
func (o *RTC_MODE1_Type) SetSYNCBUSY_GP1(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_MODE1_Type) GetSYNCBUSY_GP1() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x20000) >> 17
}
func (o *RTC_MODE1_Type) SetSYNCBUSY_GP2(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_MODE1_Type) GetSYNCBUSY_GP2() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x40000) >> 18
}
func (o *RTC_MODE1_Type) SetSYNCBUSY_GP3(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_MODE1_Type) GetSYNCBUSY_GP3() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x80000) >> 19
}

// RTC_MODE1.FREQCORR: Frequency Correction
func (o *RTC_MODE1_Type) SetFREQCORR_VALUE(value uint8) {
	volatile.StoreUint8(&o.FREQCORR.Reg, volatile.LoadUint8(&o.FREQCORR.Reg)&^(0x7f)|value)
}
func (o *RTC_MODE1_Type) GetFREQCORR_VALUE() uint8 {
	return volatile.LoadUint8(&o.FREQCORR.Reg) & 0x7f
}
func (o *RTC_MODE1_Type) SetFREQCORR_SIGN(value uint8) {
	volatile.StoreUint8(&o.FREQCORR.Reg, volatile.LoadUint8(&o.FREQCORR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_MODE1_Type) GetFREQCORR_SIGN() uint8 {
	return (volatile.LoadUint8(&o.FREQCORR.Reg) & 0x80) >> 7
}

// RTC_MODE1.COUNT: MODE1 Counter Value
func (o *RTC_MODE1_Type) SetCOUNT(value uint16) {
	volatile.StoreUint16(&o.COUNT.Reg, value)
}
func (o *RTC_MODE1_Type) GetCOUNT() uint16 {
	return volatile.LoadUint16(&o.COUNT.Reg)
}

// RTC_MODE1.PER: MODE1 Counter Period
func (o *RTC_MODE1_Type) SetPER(value uint16) {
	volatile.StoreUint16(&o.PER.Reg, value)
}
func (o *RTC_MODE1_Type) GetPER() uint16 {
	return volatile.LoadUint16(&o.PER.Reg)
}

// RTC_MODE1.COMP: MODE1 Compare n Value
func (o *RTC_MODE1_Type) SetCOMP(idx int, value uint16) {
	volatile.StoreUint16(&o.COMP[idx].Reg, value)
}
func (o *RTC_MODE1_Type) GetCOMP(idx int) uint16 {
	return volatile.LoadUint16(&o.COMP[idx].Reg)
}

// RTC_MODE1.GP: General Purpose
func (o *RTC_MODE1_Type) SetGP(idx int, value uint32) {
	volatile.StoreUint32(&o.GP[idx].Reg, value)
}
func (o *RTC_MODE1_Type) GetGP(idx int) uint32 {
	return volatile.LoadUint32(&o.GP[idx].Reg)
}

// RTC_MODE1.TAMPCTRL: Tamper Control
func (o *RTC_MODE1_Type) SetTAMPCTRL_IN0ACT(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x3)|value)
}
func (o *RTC_MODE1_Type) GetTAMPCTRL_IN0ACT() uint32 {
	return volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x3
}
func (o *RTC_MODE1_Type) SetTAMPCTRL_IN1ACT(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0xc)|value<<2)
}
func (o *RTC_MODE1_Type) GetTAMPCTRL_IN1ACT() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0xc) >> 2
}
func (o *RTC_MODE1_Type) SetTAMPCTRL_IN2ACT(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x30)|value<<4)
}
func (o *RTC_MODE1_Type) GetTAMPCTRL_IN2ACT() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x30) >> 4
}
func (o *RTC_MODE1_Type) SetTAMPCTRL_IN3ACT(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0xc0)|value<<6)
}
func (o *RTC_MODE1_Type) GetTAMPCTRL_IN3ACT() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0xc0) >> 6
}
func (o *RTC_MODE1_Type) SetTAMPCTRL_IN4ACT(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x300)|value<<8)
}
func (o *RTC_MODE1_Type) GetTAMPCTRL_IN4ACT() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x300) >> 8
}
func (o *RTC_MODE1_Type) SetTAMPCTRL_TAMLVL0(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_MODE1_Type) GetTAMPCTRL_TAMLVL0() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x10000) >> 16
}
func (o *RTC_MODE1_Type) SetTAMPCTRL_TAMLVL1(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_MODE1_Type) GetTAMPCTRL_TAMLVL1() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x20000) >> 17
}
func (o *RTC_MODE1_Type) SetTAMPCTRL_TAMLVL2(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_MODE1_Type) GetTAMPCTRL_TAMLVL2() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x40000) >> 18
}
func (o *RTC_MODE1_Type) SetTAMPCTRL_TAMLVL3(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_MODE1_Type) GetTAMPCTRL_TAMLVL3() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x80000) >> 19
}
func (o *RTC_MODE1_Type) SetTAMPCTRL_TAMLVL4(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_MODE1_Type) GetTAMPCTRL_TAMLVL4() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x100000) >> 20
}
func (o *RTC_MODE1_Type) SetTAMPCTRL_DEBNC0(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_MODE1_Type) GetTAMPCTRL_DEBNC0() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x1000000) >> 24
}
func (o *RTC_MODE1_Type) SetTAMPCTRL_DEBNC1(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_MODE1_Type) GetTAMPCTRL_DEBNC1() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x2000000) >> 25
}
func (o *RTC_MODE1_Type) SetTAMPCTRL_DEBNC2(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_MODE1_Type) GetTAMPCTRL_DEBNC2() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x4000000) >> 26
}
func (o *RTC_MODE1_Type) SetTAMPCTRL_DEBNC3(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_MODE1_Type) GetTAMPCTRL_DEBNC3() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x8000000) >> 27
}
func (o *RTC_MODE1_Type) SetTAMPCTRL_DEBNC4(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_MODE1_Type) GetTAMPCTRL_DEBNC4() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x10000000) >> 28
}

// RTC_MODE1.TIMESTAMP: MODE1 Timestamp
func (o *RTC_MODE1_Type) SetTIMESTAMP_COUNT(value uint32) {
	volatile.StoreUint32(&o.TIMESTAMP.Reg, volatile.LoadUint32(&o.TIMESTAMP.Reg)&^(0xffff)|value)
}
func (o *RTC_MODE1_Type) GetTIMESTAMP_COUNT() uint32 {
	return volatile.LoadUint32(&o.TIMESTAMP.Reg) & 0xffff
}

// RTC_MODE1.TAMPID: Tamper ID
func (o *RTC_MODE1_Type) SetTAMPID_TAMPID0(value uint32) {
	volatile.StoreUint32(&o.TAMPID.Reg, volatile.LoadUint32(&o.TAMPID.Reg)&^(0x1)|value)
}
func (o *RTC_MODE1_Type) GetTAMPID_TAMPID0() uint32 {
	return volatile.LoadUint32(&o.TAMPID.Reg) & 0x1
}
func (o *RTC_MODE1_Type) SetTAMPID_TAMPID1(value uint32) {
	volatile.StoreUint32(&o.TAMPID.Reg, volatile.LoadUint32(&o.TAMPID.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE1_Type) GetTAMPID_TAMPID1() uint32 {
	return (volatile.LoadUint32(&o.TAMPID.Reg) & 0x2) >> 1
}
func (o *RTC_MODE1_Type) SetTAMPID_TAMPID2(value uint32) {
	volatile.StoreUint32(&o.TAMPID.Reg, volatile.LoadUint32(&o.TAMPID.Reg)&^(0x4)|value<<2)
}
func (o *RTC_MODE1_Type) GetTAMPID_TAMPID2() uint32 {
	return (volatile.LoadUint32(&o.TAMPID.Reg) & 0x4) >> 2
}
func (o *RTC_MODE1_Type) SetTAMPID_TAMPID3(value uint32) {
	volatile.StoreUint32(&o.TAMPID.Reg, volatile.LoadUint32(&o.TAMPID.Reg)&^(0x8)|value<<3)
}
func (o *RTC_MODE1_Type) GetTAMPID_TAMPID3() uint32 {
	return (volatile.LoadUint32(&o.TAMPID.Reg) & 0x8) >> 3
}
func (o *RTC_MODE1_Type) SetTAMPID_TAMPID4(value uint32) {
	volatile.StoreUint32(&o.TAMPID.Reg, volatile.LoadUint32(&o.TAMPID.Reg)&^(0x10)|value<<4)
}
func (o *RTC_MODE1_Type) GetTAMPID_TAMPID4() uint32 {
	return (volatile.LoadUint32(&o.TAMPID.Reg) & 0x10) >> 4
}
func (o *RTC_MODE1_Type) SetTAMPID_TAMPEVT(value uint32) {
	volatile.StoreUint32(&o.TAMPID.Reg, volatile.LoadUint32(&o.TAMPID.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_MODE1_Type) GetTAMPID_TAMPEVT() uint32 {
	return (volatile.LoadUint32(&o.TAMPID.Reg) & 0x80000000) >> 31
}

// RTC_MODE1.BKUP: Backup
func (o *RTC_MODE1_Type) SetBKUP(idx int, value uint32) {
	volatile.StoreUint32(&o.BKUP[idx].Reg, value)
}
func (o *RTC_MODE1_Type) GetBKUP(idx int) uint32 {
	return volatile.LoadUint32(&o.BKUP[idx].Reg)
}

// Real-Time Counter - MODE2
type RTC_MODE2_Type struct {
	CTRLA     volatile.Register16 // 0x0
	CTRLB     volatile.Register16 // 0x2
	EVCTRL    volatile.Register32 // 0x4
	INTENCLR  volatile.Register16 // 0x8
	INTENSET  volatile.Register16 // 0xA
	INTFLAG   volatile.Register16 // 0xC
	DBGCTRL   volatile.Register8  // 0xE
	_         byte
	SYNCBUSY  volatile.Register32 // 0x10
	FREQCORR  volatile.Register8  // 0x14
	_         [3]byte
	CLOCK     volatile.Register32 // 0x18
	_         [4]byte
	ALARM0    volatile.Register32 // 0x20
	MASK0     volatile.Register8  // 0x24
	_         [3]byte
	ALARM1    volatile.Register32 // 0x28
	MASK1     volatile.Register8  // 0x2C
	_         [19]byte
	GP        [4]volatile.Register32 // 0x40
	_         [16]byte
	TAMPCTRL  volatile.Register32 // 0x60
	TIMESTAMP volatile.Register32 // 0x64
	TAMPID    volatile.Register32 // 0x68
	_         [20]byte
	BKUP      [8]volatile.Register32 // 0x80
}

// RTC_MODE2.CTRLA: MODE2 Control A
func (o *RTC_MODE2_Type) SetCTRLA_SWRST(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *RTC_MODE2_Type) GetCTRLA_SWRST() uint16 {
	return volatile.LoadUint16(&o.CTRLA.Reg) & 0x1
}
func (o *RTC_MODE2_Type) SetCTRLA_ENABLE(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE2_Type) GetCTRLA_ENABLE() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *RTC_MODE2_Type) SetCTRLA_MODE(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0xc)|value<<2)
}
func (o *RTC_MODE2_Type) GetCTRLA_MODE() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0xc) >> 2
}
func (o *RTC_MODE2_Type) SetCTRLA_CLKREP(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x40)|value<<6)
}
func (o *RTC_MODE2_Type) GetCTRLA_CLKREP() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x40) >> 6
}
func (o *RTC_MODE2_Type) SetCTRLA_MATCHCLR(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x80)|value<<7)
}
func (o *RTC_MODE2_Type) GetCTRLA_MATCHCLR() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x80) >> 7
}
func (o *RTC_MODE2_Type) SetCTRLA_PRESCALER(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_MODE2_Type) GetCTRLA_PRESCALER() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0xf00) >> 8
}
func (o *RTC_MODE2_Type) SetCTRLA_BKTRST(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_MODE2_Type) GetCTRLA_BKTRST() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x2000) >> 13
}
func (o *RTC_MODE2_Type) SetCTRLA_GPTRST(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_MODE2_Type) GetCTRLA_GPTRST() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x4000) >> 14
}
func (o *RTC_MODE2_Type) SetCTRLA_CLOCKSYNC(value uint16) {
	volatile.StoreUint16(&o.CTRLA.Reg, volatile.LoadUint16(&o.CTRLA.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_MODE2_Type) GetCTRLA_CLOCKSYNC() uint16 {
	return (volatile.LoadUint16(&o.CTRLA.Reg) & 0x8000) >> 15
}

// RTC_MODE2.CTRLB: MODE2 Control B
func (o *RTC_MODE2_Type) SetCTRLB_GP0EN(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x1)|value)
}
func (o *RTC_MODE2_Type) GetCTRLB_GP0EN() uint16 {
	return volatile.LoadUint16(&o.CTRLB.Reg) & 0x1
}
func (o *RTC_MODE2_Type) SetCTRLB_GP2EN(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE2_Type) GetCTRLB_GP2EN() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x2) >> 1
}
func (o *RTC_MODE2_Type) SetCTRLB_DEBMAJ(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x10)|value<<4)
}
func (o *RTC_MODE2_Type) GetCTRLB_DEBMAJ() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x10) >> 4
}
func (o *RTC_MODE2_Type) SetCTRLB_DEBASYNC(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x20)|value<<5)
}
func (o *RTC_MODE2_Type) GetCTRLB_DEBASYNC() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x20) >> 5
}
func (o *RTC_MODE2_Type) SetCTRLB_RTCOUT(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x40)|value<<6)
}
func (o *RTC_MODE2_Type) GetCTRLB_RTCOUT() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x40) >> 6
}
func (o *RTC_MODE2_Type) SetCTRLB_DMAEN(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x80)|value<<7)
}
func (o *RTC_MODE2_Type) GetCTRLB_DMAEN() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x80) >> 7
}
func (o *RTC_MODE2_Type) SetCTRLB_DEBF(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x700)|value<<8)
}
func (o *RTC_MODE2_Type) GetCTRLB_DEBF() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x700) >> 8
}
func (o *RTC_MODE2_Type) SetCTRLB_ACTF(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_MODE2_Type) GetCTRLB_ACTF() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x7000) >> 12
}

// RTC_MODE2.EVCTRL: MODE2 Event Control
func (o *RTC_MODE2_Type) SetEVCTRL_PEREO0(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x1)|value)
}
func (o *RTC_MODE2_Type) GetEVCTRL_PEREO0() uint32 {
	return volatile.LoadUint32(&o.EVCTRL.Reg) & 0x1
}
func (o *RTC_MODE2_Type) SetEVCTRL_PEREO1(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE2_Type) GetEVCTRL_PEREO1() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x2) >> 1
}
func (o *RTC_MODE2_Type) SetEVCTRL_PEREO2(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x4)|value<<2)
}
func (o *RTC_MODE2_Type) GetEVCTRL_PEREO2() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x4) >> 2
}
func (o *RTC_MODE2_Type) SetEVCTRL_PEREO3(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x8)|value<<3)
}
func (o *RTC_MODE2_Type) GetEVCTRL_PEREO3() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x8) >> 3
}
func (o *RTC_MODE2_Type) SetEVCTRL_PEREO4(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x10)|value<<4)
}
func (o *RTC_MODE2_Type) GetEVCTRL_PEREO4() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x10) >> 4
}
func (o *RTC_MODE2_Type) SetEVCTRL_PEREO5(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x20)|value<<5)
}
func (o *RTC_MODE2_Type) GetEVCTRL_PEREO5() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x20) >> 5
}
func (o *RTC_MODE2_Type) SetEVCTRL_PEREO6(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x40)|value<<6)
}
func (o *RTC_MODE2_Type) GetEVCTRL_PEREO6() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x40) >> 6
}
func (o *RTC_MODE2_Type) SetEVCTRL_PEREO7(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x80)|value<<7)
}
func (o *RTC_MODE2_Type) GetEVCTRL_PEREO7() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x80) >> 7
}
func (o *RTC_MODE2_Type) SetEVCTRL_ALARMEO0(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x100)|value<<8)
}
func (o *RTC_MODE2_Type) GetEVCTRL_ALARMEO0() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x100) >> 8
}
func (o *RTC_MODE2_Type) SetEVCTRL_ALARMEO1(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x200)|value<<9)
}
func (o *RTC_MODE2_Type) GetEVCTRL_ALARMEO1() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x200) >> 9
}
func (o *RTC_MODE2_Type) SetEVCTRL_TAMPEREO(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_MODE2_Type) GetEVCTRL_TAMPEREO() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x4000) >> 14
}
func (o *RTC_MODE2_Type) SetEVCTRL_OVFEO(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_MODE2_Type) GetEVCTRL_OVFEO() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x8000) >> 15
}
func (o *RTC_MODE2_Type) SetEVCTRL_TAMPEVEI(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_MODE2_Type) GetEVCTRL_TAMPEVEI() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x10000) >> 16
}

// RTC_MODE2.INTENCLR: MODE2 Interrupt Enable Clear
func (o *RTC_MODE2_Type) SetINTENCLR_PER0(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *RTC_MODE2_Type) GetINTENCLR_PER0() uint16 {
	return volatile.LoadUint16(&o.INTENCLR.Reg) & 0x1
}
func (o *RTC_MODE2_Type) SetINTENCLR_PER1(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE2_Type) GetINTENCLR_PER1() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *RTC_MODE2_Type) SetINTENCLR_PER2(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_MODE2_Type) GetINTENCLR_PER2() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *RTC_MODE2_Type) SetINTENCLR_PER3(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_MODE2_Type) GetINTENCLR_PER3() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *RTC_MODE2_Type) SetINTENCLR_PER4(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_MODE2_Type) GetINTENCLR_PER4() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *RTC_MODE2_Type) SetINTENCLR_PER5(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_MODE2_Type) GetINTENCLR_PER5() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *RTC_MODE2_Type) SetINTENCLR_PER6(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_MODE2_Type) GetINTENCLR_PER6() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *RTC_MODE2_Type) SetINTENCLR_PER7(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_MODE2_Type) GetINTENCLR_PER7() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *RTC_MODE2_Type) SetINTENCLR_ALARM0(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *RTC_MODE2_Type) GetINTENCLR_ALARM0() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *RTC_MODE2_Type) SetINTENCLR_ALARM1(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *RTC_MODE2_Type) GetINTENCLR_ALARM1() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x200) >> 9
}
func (o *RTC_MODE2_Type) SetINTENCLR_TAMPER(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_MODE2_Type) GetINTENCLR_TAMPER() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x4000) >> 14
}
func (o *RTC_MODE2_Type) SetINTENCLR_OVF(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_MODE2_Type) GetINTENCLR_OVF() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x8000) >> 15
}

// RTC_MODE2.INTENSET: MODE2 Interrupt Enable Set
func (o *RTC_MODE2_Type) SetINTENSET_PER0(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *RTC_MODE2_Type) GetINTENSET_PER0() uint16 {
	return volatile.LoadUint16(&o.INTENSET.Reg) & 0x1
}
func (o *RTC_MODE2_Type) SetINTENSET_PER1(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE2_Type) GetINTENSET_PER1() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *RTC_MODE2_Type) SetINTENSET_PER2(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *RTC_MODE2_Type) GetINTENSET_PER2() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *RTC_MODE2_Type) SetINTENSET_PER3(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *RTC_MODE2_Type) GetINTENSET_PER3() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *RTC_MODE2_Type) SetINTENSET_PER4(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *RTC_MODE2_Type) GetINTENSET_PER4() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *RTC_MODE2_Type) SetINTENSET_PER5(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *RTC_MODE2_Type) GetINTENSET_PER5() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *RTC_MODE2_Type) SetINTENSET_PER6(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *RTC_MODE2_Type) GetINTENSET_PER6() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *RTC_MODE2_Type) SetINTENSET_PER7(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *RTC_MODE2_Type) GetINTENSET_PER7() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *RTC_MODE2_Type) SetINTENSET_ALARM0(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *RTC_MODE2_Type) GetINTENSET_ALARM0() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *RTC_MODE2_Type) SetINTENSET_ALARM1(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *RTC_MODE2_Type) GetINTENSET_ALARM1() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x200) >> 9
}
func (o *RTC_MODE2_Type) SetINTENSET_TAMPER(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_MODE2_Type) GetINTENSET_TAMPER() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x4000) >> 14
}
func (o *RTC_MODE2_Type) SetINTENSET_OVF(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_MODE2_Type) GetINTENSET_OVF() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x8000) >> 15
}

// RTC_MODE2.INTFLAG: MODE2 Interrupt Flag Status and Clear
func (o *RTC_MODE2_Type) SetINTFLAG_PER0(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *RTC_MODE2_Type) GetINTFLAG_PER0() uint16 {
	return volatile.LoadUint16(&o.INTFLAG.Reg) & 0x1
}
func (o *RTC_MODE2_Type) SetINTFLAG_PER1(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE2_Type) GetINTFLAG_PER1() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *RTC_MODE2_Type) SetINTFLAG_PER2(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x4)|value<<2)
}
func (o *RTC_MODE2_Type) GetINTFLAG_PER2() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x4) >> 2
}
func (o *RTC_MODE2_Type) SetINTFLAG_PER3(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x8)|value<<3)
}
func (o *RTC_MODE2_Type) GetINTFLAG_PER3() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x8) >> 3
}
func (o *RTC_MODE2_Type) SetINTFLAG_PER4(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x10)|value<<4)
}
func (o *RTC_MODE2_Type) GetINTFLAG_PER4() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x10) >> 4
}
func (o *RTC_MODE2_Type) SetINTFLAG_PER5(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x20)|value<<5)
}
func (o *RTC_MODE2_Type) GetINTFLAG_PER5() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x20) >> 5
}
func (o *RTC_MODE2_Type) SetINTFLAG_PER6(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x40)|value<<6)
}
func (o *RTC_MODE2_Type) GetINTFLAG_PER6() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x40) >> 6
}
func (o *RTC_MODE2_Type) SetINTFLAG_PER7(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x80)|value<<7)
}
func (o *RTC_MODE2_Type) GetINTFLAG_PER7() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x80) >> 7
}
func (o *RTC_MODE2_Type) SetINTFLAG_ALARM0(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x100)|value<<8)
}
func (o *RTC_MODE2_Type) GetINTFLAG_ALARM0() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x100) >> 8
}
func (o *RTC_MODE2_Type) SetINTFLAG_ALARM1(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x200)|value<<9)
}
func (o *RTC_MODE2_Type) GetINTFLAG_ALARM1() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x200) >> 9
}
func (o *RTC_MODE2_Type) SetINTFLAG_TAMPER(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_MODE2_Type) GetINTFLAG_TAMPER() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x4000) >> 14
}
func (o *RTC_MODE2_Type) SetINTFLAG_OVF(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_MODE2_Type) GetINTFLAG_OVF() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x8000) >> 15
}

// RTC_MODE2.DBGCTRL: Debug Control
func (o *RTC_MODE2_Type) SetDBGCTRL_DBGRUN(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x1)|value)
}
func (o *RTC_MODE2_Type) GetDBGCTRL_DBGRUN() uint8 {
	return volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x1
}

// RTC_MODE2.SYNCBUSY: MODE2 Synchronization Busy Status
func (o *RTC_MODE2_Type) SetSYNCBUSY_SWRST(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *RTC_MODE2_Type) GetSYNCBUSY_SWRST() uint32 {
	return volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x1
}
func (o *RTC_MODE2_Type) SetSYNCBUSY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE2_Type) GetSYNCBUSY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x2) >> 1
}
func (o *RTC_MODE2_Type) SetSYNCBUSY_FREQCORR(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x4)|value<<2)
}
func (o *RTC_MODE2_Type) GetSYNCBUSY_FREQCORR() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x4) >> 2
}
func (o *RTC_MODE2_Type) SetSYNCBUSY_CLOCK(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x8)|value<<3)
}
func (o *RTC_MODE2_Type) GetSYNCBUSY_CLOCK() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x8) >> 3
}
func (o *RTC_MODE2_Type) SetSYNCBUSY_ALARM0(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x20)|value<<5)
}
func (o *RTC_MODE2_Type) GetSYNCBUSY_ALARM0() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x20) >> 5
}
func (o *RTC_MODE2_Type) SetSYNCBUSY_ALARM1(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x40)|value<<6)
}
func (o *RTC_MODE2_Type) GetSYNCBUSY_ALARM1() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x40) >> 6
}
func (o *RTC_MODE2_Type) SetSYNCBUSY_MASK0(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x800)|value<<11)
}
func (o *RTC_MODE2_Type) GetSYNCBUSY_MASK0() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x800) >> 11
}
func (o *RTC_MODE2_Type) SetSYNCBUSY_MASK1(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_MODE2_Type) GetSYNCBUSY_MASK1() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x1000) >> 12
}
func (o *RTC_MODE2_Type) SetSYNCBUSY_CLOCKSYNC(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_MODE2_Type) GetSYNCBUSY_CLOCKSYNC() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x8000) >> 15
}
func (o *RTC_MODE2_Type) SetSYNCBUSY_GP0(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_MODE2_Type) GetSYNCBUSY_GP0() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x10000) >> 16
}
func (o *RTC_MODE2_Type) SetSYNCBUSY_GP1(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_MODE2_Type) GetSYNCBUSY_GP1() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x20000) >> 17
}
func (o *RTC_MODE2_Type) SetSYNCBUSY_GP2(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_MODE2_Type) GetSYNCBUSY_GP2() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x40000) >> 18
}
func (o *RTC_MODE2_Type) SetSYNCBUSY_GP3(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_MODE2_Type) GetSYNCBUSY_GP3() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x80000) >> 19
}

// RTC_MODE2.FREQCORR: Frequency Correction
func (o *RTC_MODE2_Type) SetFREQCORR_VALUE(value uint8) {
	volatile.StoreUint8(&o.FREQCORR.Reg, volatile.LoadUint8(&o.FREQCORR.Reg)&^(0x7f)|value)
}
func (o *RTC_MODE2_Type) GetFREQCORR_VALUE() uint8 {
	return volatile.LoadUint8(&o.FREQCORR.Reg) & 0x7f
}
func (o *RTC_MODE2_Type) SetFREQCORR_SIGN(value uint8) {
	volatile.StoreUint8(&o.FREQCORR.Reg, volatile.LoadUint8(&o.FREQCORR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_MODE2_Type) GetFREQCORR_SIGN() uint8 {
	return (volatile.LoadUint8(&o.FREQCORR.Reg) & 0x80) >> 7
}

// RTC_MODE2.CLOCK: MODE2 Clock Value
func (o *RTC_MODE2_Type) SetCLOCK_SECOND(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0x3f)|value)
}
func (o *RTC_MODE2_Type) GetCLOCK_SECOND() uint32 {
	return volatile.LoadUint32(&o.CLOCK.Reg) & 0x3f
}
func (o *RTC_MODE2_Type) SetCLOCK_MINUTE(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0xfc0)|value<<6)
}
func (o *RTC_MODE2_Type) GetCLOCK_MINUTE() uint32 {
	return (volatile.LoadUint32(&o.CLOCK.Reg) & 0xfc0) >> 6
}
func (o *RTC_MODE2_Type) SetCLOCK_HOUR(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0x1f000)|value<<12)
}
func (o *RTC_MODE2_Type) GetCLOCK_HOUR() uint32 {
	return (volatile.LoadUint32(&o.CLOCK.Reg) & 0x1f000) >> 12
}
func (o *RTC_MODE2_Type) SetCLOCK_DAY(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0x3e0000)|value<<17)
}
func (o *RTC_MODE2_Type) GetCLOCK_DAY() uint32 {
	return (volatile.LoadUint32(&o.CLOCK.Reg) & 0x3e0000) >> 17
}
func (o *RTC_MODE2_Type) SetCLOCK_MONTH(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0x3c00000)|value<<22)
}
func (o *RTC_MODE2_Type) GetCLOCK_MONTH() uint32 {
	return (volatile.LoadUint32(&o.CLOCK.Reg) & 0x3c00000) >> 22
}
func (o *RTC_MODE2_Type) SetCLOCK_YEAR(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0xfc000000)|value<<26)
}
func (o *RTC_MODE2_Type) GetCLOCK_YEAR() uint32 {
	return (volatile.LoadUint32(&o.CLOCK.Reg) & 0xfc000000) >> 26
}

// RTC_MODE2.ALARM0: MODE2_ALARM Alarm n Value
func (o *RTC_MODE2_Type) SetALARM0_SECOND(value uint32) {
	volatile.StoreUint32(&o.ALARM0.Reg, volatile.LoadUint32(&o.ALARM0.Reg)&^(0x3f)|value)
}
func (o *RTC_MODE2_Type) GetALARM0_SECOND() uint32 {
	return volatile.LoadUint32(&o.ALARM0.Reg) & 0x3f
}
func (o *RTC_MODE2_Type) SetALARM0_MINUTE(value uint32) {
	volatile.StoreUint32(&o.ALARM0.Reg, volatile.LoadUint32(&o.ALARM0.Reg)&^(0xfc0)|value<<6)
}
func (o *RTC_MODE2_Type) GetALARM0_MINUTE() uint32 {
	return (volatile.LoadUint32(&o.ALARM0.Reg) & 0xfc0) >> 6
}
func (o *RTC_MODE2_Type) SetALARM0_HOUR(value uint32) {
	volatile.StoreUint32(&o.ALARM0.Reg, volatile.LoadUint32(&o.ALARM0.Reg)&^(0x1f000)|value<<12)
}
func (o *RTC_MODE2_Type) GetALARM0_HOUR() uint32 {
	return (volatile.LoadUint32(&o.ALARM0.Reg) & 0x1f000) >> 12
}
func (o *RTC_MODE2_Type) SetALARM0_DAY(value uint32) {
	volatile.StoreUint32(&o.ALARM0.Reg, volatile.LoadUint32(&o.ALARM0.Reg)&^(0x3e0000)|value<<17)
}
func (o *RTC_MODE2_Type) GetALARM0_DAY() uint32 {
	return (volatile.LoadUint32(&o.ALARM0.Reg) & 0x3e0000) >> 17
}
func (o *RTC_MODE2_Type) SetALARM0_MONTH(value uint32) {
	volatile.StoreUint32(&o.ALARM0.Reg, volatile.LoadUint32(&o.ALARM0.Reg)&^(0x3c00000)|value<<22)
}
func (o *RTC_MODE2_Type) GetALARM0_MONTH() uint32 {
	return (volatile.LoadUint32(&o.ALARM0.Reg) & 0x3c00000) >> 22
}
func (o *RTC_MODE2_Type) SetALARM0_YEAR(value uint32) {
	volatile.StoreUint32(&o.ALARM0.Reg, volatile.LoadUint32(&o.ALARM0.Reg)&^(0xfc000000)|value<<26)
}
func (o *RTC_MODE2_Type) GetALARM0_YEAR() uint32 {
	return (volatile.LoadUint32(&o.ALARM0.Reg) & 0xfc000000) >> 26
}

// RTC_MODE2.MASK0: MODE2_ALARM Alarm n Mask
func (o *RTC_MODE2_Type) SetMASK0_SEL(value uint8) {
	volatile.StoreUint8(&o.MASK0.Reg, volatile.LoadUint8(&o.MASK0.Reg)&^(0x7)|value)
}
func (o *RTC_MODE2_Type) GetMASK0_SEL() uint8 {
	return volatile.LoadUint8(&o.MASK0.Reg) & 0x7
}

// RTC_MODE2.ALARM1: MODE2_ALARM Alarm n Value
func (o *RTC_MODE2_Type) SetALARM1_SECOND(value uint32) {
	volatile.StoreUint32(&o.ALARM1.Reg, volatile.LoadUint32(&o.ALARM1.Reg)&^(0x3f)|value)
}
func (o *RTC_MODE2_Type) GetALARM1_SECOND() uint32 {
	return volatile.LoadUint32(&o.ALARM1.Reg) & 0x3f
}
func (o *RTC_MODE2_Type) SetALARM1_MINUTE(value uint32) {
	volatile.StoreUint32(&o.ALARM1.Reg, volatile.LoadUint32(&o.ALARM1.Reg)&^(0xfc0)|value<<6)
}
func (o *RTC_MODE2_Type) GetALARM1_MINUTE() uint32 {
	return (volatile.LoadUint32(&o.ALARM1.Reg) & 0xfc0) >> 6
}
func (o *RTC_MODE2_Type) SetALARM1_HOUR(value uint32) {
	volatile.StoreUint32(&o.ALARM1.Reg, volatile.LoadUint32(&o.ALARM1.Reg)&^(0x1f000)|value<<12)
}
func (o *RTC_MODE2_Type) GetALARM1_HOUR() uint32 {
	return (volatile.LoadUint32(&o.ALARM1.Reg) & 0x1f000) >> 12
}
func (o *RTC_MODE2_Type) SetALARM1_DAY(value uint32) {
	volatile.StoreUint32(&o.ALARM1.Reg, volatile.LoadUint32(&o.ALARM1.Reg)&^(0x3e0000)|value<<17)
}
func (o *RTC_MODE2_Type) GetALARM1_DAY() uint32 {
	return (volatile.LoadUint32(&o.ALARM1.Reg) & 0x3e0000) >> 17
}
func (o *RTC_MODE2_Type) SetALARM1_MONTH(value uint32) {
	volatile.StoreUint32(&o.ALARM1.Reg, volatile.LoadUint32(&o.ALARM1.Reg)&^(0x3c00000)|value<<22)
}
func (o *RTC_MODE2_Type) GetALARM1_MONTH() uint32 {
	return (volatile.LoadUint32(&o.ALARM1.Reg) & 0x3c00000) >> 22
}
func (o *RTC_MODE2_Type) SetALARM1_YEAR(value uint32) {
	volatile.StoreUint32(&o.ALARM1.Reg, volatile.LoadUint32(&o.ALARM1.Reg)&^(0xfc000000)|value<<26)
}
func (o *RTC_MODE2_Type) GetALARM1_YEAR() uint32 {
	return (volatile.LoadUint32(&o.ALARM1.Reg) & 0xfc000000) >> 26
}

// RTC_MODE2.MASK1: MODE2_ALARM Alarm n Mask
func (o *RTC_MODE2_Type) SetMASK1_SEL(value uint8) {
	volatile.StoreUint8(&o.MASK1.Reg, volatile.LoadUint8(&o.MASK1.Reg)&^(0x7)|value)
}
func (o *RTC_MODE2_Type) GetMASK1_SEL() uint8 {
	return volatile.LoadUint8(&o.MASK1.Reg) & 0x7
}

// RTC_MODE2.GP: General Purpose
func (o *RTC_MODE2_Type) SetGP(idx int, value uint32) {
	volatile.StoreUint32(&o.GP[idx].Reg, value)
}
func (o *RTC_MODE2_Type) GetGP(idx int) uint32 {
	return volatile.LoadUint32(&o.GP[idx].Reg)
}

// RTC_MODE2.TAMPCTRL: Tamper Control
func (o *RTC_MODE2_Type) SetTAMPCTRL_IN0ACT(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x3)|value)
}
func (o *RTC_MODE2_Type) GetTAMPCTRL_IN0ACT() uint32 {
	return volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x3
}
func (o *RTC_MODE2_Type) SetTAMPCTRL_IN1ACT(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0xc)|value<<2)
}
func (o *RTC_MODE2_Type) GetTAMPCTRL_IN1ACT() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0xc) >> 2
}
func (o *RTC_MODE2_Type) SetTAMPCTRL_IN2ACT(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x30)|value<<4)
}
func (o *RTC_MODE2_Type) GetTAMPCTRL_IN2ACT() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x30) >> 4
}
func (o *RTC_MODE2_Type) SetTAMPCTRL_IN3ACT(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0xc0)|value<<6)
}
func (o *RTC_MODE2_Type) GetTAMPCTRL_IN3ACT() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0xc0) >> 6
}
func (o *RTC_MODE2_Type) SetTAMPCTRL_IN4ACT(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x300)|value<<8)
}
func (o *RTC_MODE2_Type) GetTAMPCTRL_IN4ACT() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x300) >> 8
}
func (o *RTC_MODE2_Type) SetTAMPCTRL_TAMLVL0(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_MODE2_Type) GetTAMPCTRL_TAMLVL0() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x10000) >> 16
}
func (o *RTC_MODE2_Type) SetTAMPCTRL_TAMLVL1(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_MODE2_Type) GetTAMPCTRL_TAMLVL1() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x20000) >> 17
}
func (o *RTC_MODE2_Type) SetTAMPCTRL_TAMLVL2(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_MODE2_Type) GetTAMPCTRL_TAMLVL2() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x40000) >> 18
}
func (o *RTC_MODE2_Type) SetTAMPCTRL_TAMLVL3(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_MODE2_Type) GetTAMPCTRL_TAMLVL3() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x80000) >> 19
}
func (o *RTC_MODE2_Type) SetTAMPCTRL_TAMLVL4(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_MODE2_Type) GetTAMPCTRL_TAMLVL4() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x100000) >> 20
}
func (o *RTC_MODE2_Type) SetTAMPCTRL_DEBNC0(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_MODE2_Type) GetTAMPCTRL_DEBNC0() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x1000000) >> 24
}
func (o *RTC_MODE2_Type) SetTAMPCTRL_DEBNC1(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_MODE2_Type) GetTAMPCTRL_DEBNC1() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x2000000) >> 25
}
func (o *RTC_MODE2_Type) SetTAMPCTRL_DEBNC2(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_MODE2_Type) GetTAMPCTRL_DEBNC2() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x4000000) >> 26
}
func (o *RTC_MODE2_Type) SetTAMPCTRL_DEBNC3(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x8000000)|value<<27)
}
func (o *RTC_MODE2_Type) GetTAMPCTRL_DEBNC3() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x8000000) >> 27
}
func (o *RTC_MODE2_Type) SetTAMPCTRL_DEBNC4(value uint32) {
	volatile.StoreUint32(&o.TAMPCTRL.Reg, volatile.LoadUint32(&o.TAMPCTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_MODE2_Type) GetTAMPCTRL_DEBNC4() uint32 {
	return (volatile.LoadUint32(&o.TAMPCTRL.Reg) & 0x10000000) >> 28
}

// RTC_MODE2.TIMESTAMP: MODE2 Timestamp
func (o *RTC_MODE2_Type) SetTIMESTAMP_SECOND(value uint32) {
	volatile.StoreUint32(&o.TIMESTAMP.Reg, volatile.LoadUint32(&o.TIMESTAMP.Reg)&^(0x3f)|value)
}
func (o *RTC_MODE2_Type) GetTIMESTAMP_SECOND() uint32 {
	return volatile.LoadUint32(&o.TIMESTAMP.Reg) & 0x3f
}
func (o *RTC_MODE2_Type) SetTIMESTAMP_MINUTE(value uint32) {
	volatile.StoreUint32(&o.TIMESTAMP.Reg, volatile.LoadUint32(&o.TIMESTAMP.Reg)&^(0xfc0)|value<<6)
}
func (o *RTC_MODE2_Type) GetTIMESTAMP_MINUTE() uint32 {
	return (volatile.LoadUint32(&o.TIMESTAMP.Reg) & 0xfc0) >> 6
}
func (o *RTC_MODE2_Type) SetTIMESTAMP_HOUR(value uint32) {
	volatile.StoreUint32(&o.TIMESTAMP.Reg, volatile.LoadUint32(&o.TIMESTAMP.Reg)&^(0x1f000)|value<<12)
}
func (o *RTC_MODE2_Type) GetTIMESTAMP_HOUR() uint32 {
	return (volatile.LoadUint32(&o.TIMESTAMP.Reg) & 0x1f000) >> 12
}
func (o *RTC_MODE2_Type) SetTIMESTAMP_DAY(value uint32) {
	volatile.StoreUint32(&o.TIMESTAMP.Reg, volatile.LoadUint32(&o.TIMESTAMP.Reg)&^(0x3e0000)|value<<17)
}
func (o *RTC_MODE2_Type) GetTIMESTAMP_DAY() uint32 {
	return (volatile.LoadUint32(&o.TIMESTAMP.Reg) & 0x3e0000) >> 17
}
func (o *RTC_MODE2_Type) SetTIMESTAMP_MONTH(value uint32) {
	volatile.StoreUint32(&o.TIMESTAMP.Reg, volatile.LoadUint32(&o.TIMESTAMP.Reg)&^(0x3c00000)|value<<22)
}
func (o *RTC_MODE2_Type) GetTIMESTAMP_MONTH() uint32 {
	return (volatile.LoadUint32(&o.TIMESTAMP.Reg) & 0x3c00000) >> 22
}
func (o *RTC_MODE2_Type) SetTIMESTAMP_YEAR(value uint32) {
	volatile.StoreUint32(&o.TIMESTAMP.Reg, volatile.LoadUint32(&o.TIMESTAMP.Reg)&^(0xfc000000)|value<<26)
}
func (o *RTC_MODE2_Type) GetTIMESTAMP_YEAR() uint32 {
	return (volatile.LoadUint32(&o.TIMESTAMP.Reg) & 0xfc000000) >> 26
}

// RTC_MODE2.TAMPID: Tamper ID
func (o *RTC_MODE2_Type) SetTAMPID_TAMPID0(value uint32) {
	volatile.StoreUint32(&o.TAMPID.Reg, volatile.LoadUint32(&o.TAMPID.Reg)&^(0x1)|value)
}
func (o *RTC_MODE2_Type) GetTAMPID_TAMPID0() uint32 {
	return volatile.LoadUint32(&o.TAMPID.Reg) & 0x1
}
func (o *RTC_MODE2_Type) SetTAMPID_TAMPID1(value uint32) {
	volatile.StoreUint32(&o.TAMPID.Reg, volatile.LoadUint32(&o.TAMPID.Reg)&^(0x2)|value<<1)
}
func (o *RTC_MODE2_Type) GetTAMPID_TAMPID1() uint32 {
	return (volatile.LoadUint32(&o.TAMPID.Reg) & 0x2) >> 1
}
func (o *RTC_MODE2_Type) SetTAMPID_TAMPID2(value uint32) {
	volatile.StoreUint32(&o.TAMPID.Reg, volatile.LoadUint32(&o.TAMPID.Reg)&^(0x4)|value<<2)
}
func (o *RTC_MODE2_Type) GetTAMPID_TAMPID2() uint32 {
	return (volatile.LoadUint32(&o.TAMPID.Reg) & 0x4) >> 2
}
func (o *RTC_MODE2_Type) SetTAMPID_TAMPID3(value uint32) {
	volatile.StoreUint32(&o.TAMPID.Reg, volatile.LoadUint32(&o.TAMPID.Reg)&^(0x8)|value<<3)
}
func (o *RTC_MODE2_Type) GetTAMPID_TAMPID3() uint32 {
	return (volatile.LoadUint32(&o.TAMPID.Reg) & 0x8) >> 3
}
func (o *RTC_MODE2_Type) SetTAMPID_TAMPID4(value uint32) {
	volatile.StoreUint32(&o.TAMPID.Reg, volatile.LoadUint32(&o.TAMPID.Reg)&^(0x10)|value<<4)
}
func (o *RTC_MODE2_Type) GetTAMPID_TAMPID4() uint32 {
	return (volatile.LoadUint32(&o.TAMPID.Reg) & 0x10) >> 4
}
func (o *RTC_MODE2_Type) SetTAMPID_TAMPEVT(value uint32) {
	volatile.StoreUint32(&o.TAMPID.Reg, volatile.LoadUint32(&o.TAMPID.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_MODE2_Type) GetTAMPID_TAMPEVT() uint32 {
	return (volatile.LoadUint32(&o.TAMPID.Reg) & 0x80000000) >> 31
}

// RTC_MODE2.BKUP: Backup
func (o *RTC_MODE2_Type) SetBKUP(idx int, value uint32) {
	volatile.StoreUint32(&o.BKUP[idx].Reg, value)
}
func (o *RTC_MODE2_Type) GetBKUP(idx int) uint32 {
	return volatile.LoadUint32(&o.BKUP[idx].Reg)
}

// SD/MMC Host Controller
type SDHC_Type struct {
	SSAR    volatile.Register32    // 0x0
	BSR     volatile.Register16    // 0x4
	BCR     volatile.Register16    // 0x6
	ARG1R   volatile.Register32    // 0x8
	TMR     volatile.Register16    // 0xC
	CR      volatile.Register16    // 0xE
	RR      [4]volatile.Register32 // 0x10
	BDPR    volatile.Register32    // 0x20
	PSR     volatile.Register32    // 0x24
	HC1R    volatile.Register8     // 0x28
	PCR     volatile.Register8     // 0x29
	BGCR    volatile.Register8     // 0x2A
	WCR     volatile.Register8     // 0x2B
	CCR     volatile.Register16    // 0x2C
	TCR     volatile.Register8     // 0x2E
	SRR     volatile.Register8     // 0x2F
	NISTR   volatile.Register16    // 0x30
	EISTR   volatile.Register16    // 0x32
	NISTER  volatile.Register16    // 0x34
	EISTER  volatile.Register16    // 0x36
	NISIER  volatile.Register16    // 0x38
	EISIER  volatile.Register16    // 0x3A
	ACESR   volatile.Register16    // 0x3C
	HC2R    volatile.Register16    // 0x3E
	CA0R    volatile.Register32    // 0x40
	CA1R    volatile.Register32    // 0x44
	MCCAR   volatile.Register32    // 0x48
	_       [4]byte
	FERACES volatile.Register16 // 0x50
	FEREIS  volatile.Register16 // 0x52
	AESR    volatile.Register8  // 0x54
	_       [3]byte
	ASAR    [1]volatile.Register32 // 0x58
	_       [4]byte
	PVR     [8]volatile.Register16 // 0x60
	_       [140]byte
	SISR    volatile.Register16 // 0xFC
	HCVR    volatile.Register16 // 0xFE
	_       [260]byte
	MC1R    volatile.Register8 // 0x204
	MC2R    volatile.Register8 // 0x205
	_       [2]byte
	ACR     volatile.Register32 // 0x208
	CC2R    volatile.Register32 // 0x20C
	_       [32]byte
	CACR    volatile.Register32 // 0x230
	DBGR    volatile.Register8  // 0x234
}

// SDHC.SSAR: SDMA System Address / Argument 2
func (o *SDHC_Type) SetSSAR(value uint32) {
	volatile.StoreUint32(&o.SSAR.Reg, value)
}
func (o *SDHC_Type) GetSSAR() uint32 {
	return volatile.LoadUint32(&o.SSAR.Reg)
}

// SDHC.BSR: Block Size
func (o *SDHC_Type) SetBSR_BLOCKSIZE(value uint16) {
	volatile.StoreUint16(&o.BSR.Reg, volatile.LoadUint16(&o.BSR.Reg)&^(0x3ff)|value)
}
func (o *SDHC_Type) GetBSR_BLOCKSIZE() uint16 {
	return volatile.LoadUint16(&o.BSR.Reg) & 0x3ff
}
func (o *SDHC_Type) SetBSR_BOUNDARY(value uint16) {
	volatile.StoreUint16(&o.BSR.Reg, volatile.LoadUint16(&o.BSR.Reg)&^(0x7000)|value<<12)
}
func (o *SDHC_Type) GetBSR_BOUNDARY() uint16 {
	return (volatile.LoadUint16(&o.BSR.Reg) & 0x7000) >> 12
}

// SDHC.BCR: Block Count
func (o *SDHC_Type) SetBCR(value uint16) {
	volatile.StoreUint16(&o.BCR.Reg, value)
}
func (o *SDHC_Type) GetBCR() uint16 {
	return volatile.LoadUint16(&o.BCR.Reg)
}

// SDHC.ARG1R: Argument 1
func (o *SDHC_Type) SetARG1R(value uint32) {
	volatile.StoreUint32(&o.ARG1R.Reg, value)
}
func (o *SDHC_Type) GetARG1R() uint32 {
	return volatile.LoadUint32(&o.ARG1R.Reg)
}

// SDHC.TMR: Transfer Mode
func (o *SDHC_Type) SetTMR_DMAEN(value uint16) {
	volatile.StoreUint16(&o.TMR.Reg, volatile.LoadUint16(&o.TMR.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetTMR_DMAEN() uint16 {
	return volatile.LoadUint16(&o.TMR.Reg) & 0x1
}
func (o *SDHC_Type) SetTMR_BCEN(value uint16) {
	volatile.StoreUint16(&o.TMR.Reg, volatile.LoadUint16(&o.TMR.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetTMR_BCEN() uint16 {
	return (volatile.LoadUint16(&o.TMR.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetTMR_ACMDEN(value uint16) {
	volatile.StoreUint16(&o.TMR.Reg, volatile.LoadUint16(&o.TMR.Reg)&^(0xc)|value<<2)
}
func (o *SDHC_Type) GetTMR_ACMDEN() uint16 {
	return (volatile.LoadUint16(&o.TMR.Reg) & 0xc) >> 2
}
func (o *SDHC_Type) SetTMR_DTDSEL(value uint16) {
	volatile.StoreUint16(&o.TMR.Reg, volatile.LoadUint16(&o.TMR.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetTMR_DTDSEL() uint16 {
	return (volatile.LoadUint16(&o.TMR.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetTMR_MSBSEL(value uint16) {
	volatile.StoreUint16(&o.TMR.Reg, volatile.LoadUint16(&o.TMR.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetTMR_MSBSEL() uint16 {
	return (volatile.LoadUint16(&o.TMR.Reg) & 0x20) >> 5
}

// SDHC.CR: Command
func (o *SDHC_Type) SetCR_RESPTYP(value uint16) {
	volatile.StoreUint16(&o.CR.Reg, volatile.LoadUint16(&o.CR.Reg)&^(0x3)|value)
}
func (o *SDHC_Type) GetCR_RESPTYP() uint16 {
	return volatile.LoadUint16(&o.CR.Reg) & 0x3
}
func (o *SDHC_Type) SetCR_CMDCCEN(value uint16) {
	volatile.StoreUint16(&o.CR.Reg, volatile.LoadUint16(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetCR_CMDCCEN() uint16 {
	return (volatile.LoadUint16(&o.CR.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetCR_CMDICEN(value uint16) {
	volatile.StoreUint16(&o.CR.Reg, volatile.LoadUint16(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetCR_CMDICEN() uint16 {
	return (volatile.LoadUint16(&o.CR.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetCR_DPSEL(value uint16) {
	volatile.StoreUint16(&o.CR.Reg, volatile.LoadUint16(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetCR_DPSEL() uint16 {
	return (volatile.LoadUint16(&o.CR.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetCR_CMDTYP(value uint16) {
	volatile.StoreUint16(&o.CR.Reg, volatile.LoadUint16(&o.CR.Reg)&^(0xc0)|value<<6)
}
func (o *SDHC_Type) GetCR_CMDTYP() uint16 {
	return (volatile.LoadUint16(&o.CR.Reg) & 0xc0) >> 6
}
func (o *SDHC_Type) SetCR_CMDIDX(value uint16) {
	volatile.StoreUint16(&o.CR.Reg, volatile.LoadUint16(&o.CR.Reg)&^(0x3f00)|value<<8)
}
func (o *SDHC_Type) GetCR_CMDIDX() uint16 {
	return (volatile.LoadUint16(&o.CR.Reg) & 0x3f00) >> 8
}

// SDHC.RR: Response
func (o *SDHC_Type) SetRR(idx int, value uint32) {
	volatile.StoreUint32(&o.RR[idx].Reg, value)
}
func (o *SDHC_Type) GetRR(idx int) uint32 {
	return volatile.LoadUint32(&o.RR[idx].Reg)
}

// SDHC.BDPR: Buffer Data Port
func (o *SDHC_Type) SetBDPR(value uint32) {
	volatile.StoreUint32(&o.BDPR.Reg, value)
}
func (o *SDHC_Type) GetBDPR() uint32 {
	return volatile.LoadUint32(&o.BDPR.Reg)
}

// SDHC.PSR: Present State
func (o *SDHC_Type) SetPSR_CMDINHC(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetPSR_CMDINHC() uint32 {
	return volatile.LoadUint32(&o.PSR.Reg) & 0x1
}
func (o *SDHC_Type) SetPSR_CMDINHD(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetPSR_CMDINHD() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetPSR_DLACT(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetPSR_DLACT() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetPSR_RTREQ(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetPSR_RTREQ() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetPSR_WTACT(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x100)|value<<8)
}
func (o *SDHC_Type) GetPSR_WTACT() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x100) >> 8
}
func (o *SDHC_Type) SetPSR_RTACT(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x200)|value<<9)
}
func (o *SDHC_Type) GetPSR_RTACT() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x200) >> 9
}
func (o *SDHC_Type) SetPSR_BUFWREN(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x400)|value<<10)
}
func (o *SDHC_Type) GetPSR_BUFWREN() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x400) >> 10
}
func (o *SDHC_Type) SetPSR_BUFRDEN(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x800)|value<<11)
}
func (o *SDHC_Type) GetPSR_BUFRDEN() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x800) >> 11
}
func (o *SDHC_Type) SetPSR_CARDINS(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x10000)|value<<16)
}
func (o *SDHC_Type) GetPSR_CARDINS() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x10000) >> 16
}
func (o *SDHC_Type) SetPSR_CARDSS(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x20000)|value<<17)
}
func (o *SDHC_Type) GetPSR_CARDSS() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x20000) >> 17
}
func (o *SDHC_Type) SetPSR_CARDDPL(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x40000)|value<<18)
}
func (o *SDHC_Type) GetPSR_CARDDPL() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x40000) >> 18
}
func (o *SDHC_Type) SetPSR_WRPPL(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x80000)|value<<19)
}
func (o *SDHC_Type) GetPSR_WRPPL() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x80000) >> 19
}
func (o *SDHC_Type) SetPSR_DATLL(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0xf00000)|value<<20)
}
func (o *SDHC_Type) GetPSR_DATLL() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0xf00000) >> 20
}
func (o *SDHC_Type) SetPSR_CMDLL(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x1000000)|value<<24)
}
func (o *SDHC_Type) GetPSR_CMDLL() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x1000000) >> 24
}

// SDHC.HC1R: Host Control 1
func (o *SDHC_Type) SetHC1R_LEDCTRL(value uint8) {
	volatile.StoreUint8(&o.HC1R.Reg, volatile.LoadUint8(&o.HC1R.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetHC1R_LEDCTRL() uint8 {
	return volatile.LoadUint8(&o.HC1R.Reg) & 0x1
}
func (o *SDHC_Type) SetHC1R_DW(value uint8) {
	volatile.StoreUint8(&o.HC1R.Reg, volatile.LoadUint8(&o.HC1R.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetHC1R_DW() uint8 {
	return (volatile.LoadUint8(&o.HC1R.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetHC1R_HSEN(value uint8) {
	volatile.StoreUint8(&o.HC1R.Reg, volatile.LoadUint8(&o.HC1R.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetHC1R_HSEN() uint8 {
	return (volatile.LoadUint8(&o.HC1R.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetHC1R_DMASEL(value uint8) {
	volatile.StoreUint8(&o.HC1R.Reg, volatile.LoadUint8(&o.HC1R.Reg)&^(0x18)|value<<3)
}
func (o *SDHC_Type) GetHC1R_DMASEL() uint8 {
	return (volatile.LoadUint8(&o.HC1R.Reg) & 0x18) >> 3
}
func (o *SDHC_Type) SetHC1R_CARDDTL(value uint8) {
	volatile.StoreUint8(&o.HC1R.Reg, volatile.LoadUint8(&o.HC1R.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetHC1R_CARDDTL() uint8 {
	return (volatile.LoadUint8(&o.HC1R.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetHC1R_CARDDSEL(value uint8) {
	volatile.StoreUint8(&o.HC1R.Reg, volatile.LoadUint8(&o.HC1R.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetHC1R_CARDDSEL() uint8 {
	return (volatile.LoadUint8(&o.HC1R.Reg) & 0x80) >> 7
}

// SDHC.PCR: Power Control
func (o *SDHC_Type) SetPCR_SDBPWR(value uint8) {
	volatile.StoreUint8(&o.PCR.Reg, volatile.LoadUint8(&o.PCR.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetPCR_SDBPWR() uint8 {
	return volatile.LoadUint8(&o.PCR.Reg) & 0x1
}
func (o *SDHC_Type) SetPCR_SDBVSEL(value uint8) {
	volatile.StoreUint8(&o.PCR.Reg, volatile.LoadUint8(&o.PCR.Reg)&^(0xe)|value<<1)
}
func (o *SDHC_Type) GetPCR_SDBVSEL() uint8 {
	return (volatile.LoadUint8(&o.PCR.Reg) & 0xe) >> 1
}

// SDHC.BGCR: Block Gap Control
func (o *SDHC_Type) SetBGCR_STPBGR(value uint8) {
	volatile.StoreUint8(&o.BGCR.Reg, volatile.LoadUint8(&o.BGCR.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetBGCR_STPBGR() uint8 {
	return volatile.LoadUint8(&o.BGCR.Reg) & 0x1
}
func (o *SDHC_Type) SetBGCR_CONTR(value uint8) {
	volatile.StoreUint8(&o.BGCR.Reg, volatile.LoadUint8(&o.BGCR.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetBGCR_CONTR() uint8 {
	return (volatile.LoadUint8(&o.BGCR.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetBGCR_RWCTRL(value uint8) {
	volatile.StoreUint8(&o.BGCR.Reg, volatile.LoadUint8(&o.BGCR.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetBGCR_RWCTRL() uint8 {
	return (volatile.LoadUint8(&o.BGCR.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetBGCR_INTBG(value uint8) {
	volatile.StoreUint8(&o.BGCR.Reg, volatile.LoadUint8(&o.BGCR.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetBGCR_INTBG() uint8 {
	return (volatile.LoadUint8(&o.BGCR.Reg) & 0x8) >> 3
}

// SDHC.WCR: Wakeup Control
func (o *SDHC_Type) SetWCR_WKENCINT(value uint8) {
	volatile.StoreUint8(&o.WCR.Reg, volatile.LoadUint8(&o.WCR.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetWCR_WKENCINT() uint8 {
	return volatile.LoadUint8(&o.WCR.Reg) & 0x1
}
func (o *SDHC_Type) SetWCR_WKENCINS(value uint8) {
	volatile.StoreUint8(&o.WCR.Reg, volatile.LoadUint8(&o.WCR.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetWCR_WKENCINS() uint8 {
	return (volatile.LoadUint8(&o.WCR.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetWCR_WKENCREM(value uint8) {
	volatile.StoreUint8(&o.WCR.Reg, volatile.LoadUint8(&o.WCR.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetWCR_WKENCREM() uint8 {
	return (volatile.LoadUint8(&o.WCR.Reg) & 0x4) >> 2
}

// SDHC.CCR: Clock Control
func (o *SDHC_Type) SetCCR_INTCLKEN(value uint16) {
	volatile.StoreUint16(&o.CCR.Reg, volatile.LoadUint16(&o.CCR.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetCCR_INTCLKEN() uint16 {
	return volatile.LoadUint16(&o.CCR.Reg) & 0x1
}
func (o *SDHC_Type) SetCCR_INTCLKS(value uint16) {
	volatile.StoreUint16(&o.CCR.Reg, volatile.LoadUint16(&o.CCR.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetCCR_INTCLKS() uint16 {
	return (volatile.LoadUint16(&o.CCR.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetCCR_SDCLKEN(value uint16) {
	volatile.StoreUint16(&o.CCR.Reg, volatile.LoadUint16(&o.CCR.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetCCR_SDCLKEN() uint16 {
	return (volatile.LoadUint16(&o.CCR.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetCCR_CLKGSEL(value uint16) {
	volatile.StoreUint16(&o.CCR.Reg, volatile.LoadUint16(&o.CCR.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetCCR_CLKGSEL() uint16 {
	return (volatile.LoadUint16(&o.CCR.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetCCR_USDCLKFSEL(value uint16) {
	volatile.StoreUint16(&o.CCR.Reg, volatile.LoadUint16(&o.CCR.Reg)&^(0xc0)|value<<6)
}
func (o *SDHC_Type) GetCCR_USDCLKFSEL() uint16 {
	return (volatile.LoadUint16(&o.CCR.Reg) & 0xc0) >> 6
}
func (o *SDHC_Type) SetCCR_SDCLKFSEL(value uint16) {
	volatile.StoreUint16(&o.CCR.Reg, volatile.LoadUint16(&o.CCR.Reg)&^(0xff00)|value<<8)
}
func (o *SDHC_Type) GetCCR_SDCLKFSEL() uint16 {
	return (volatile.LoadUint16(&o.CCR.Reg) & 0xff00) >> 8
}

// SDHC.TCR: Timeout Control
func (o *SDHC_Type) SetTCR_DTCVAL(value uint8) {
	volatile.StoreUint8(&o.TCR.Reg, volatile.LoadUint8(&o.TCR.Reg)&^(0xf)|value)
}
func (o *SDHC_Type) GetTCR_DTCVAL() uint8 {
	return volatile.LoadUint8(&o.TCR.Reg) & 0xf
}

// SDHC.SRR: Software Reset
func (o *SDHC_Type) SetSRR_SWRSTALL(value uint8) {
	volatile.StoreUint8(&o.SRR.Reg, volatile.LoadUint8(&o.SRR.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetSRR_SWRSTALL() uint8 {
	return volatile.LoadUint8(&o.SRR.Reg) & 0x1
}
func (o *SDHC_Type) SetSRR_SWRSTCMD(value uint8) {
	volatile.StoreUint8(&o.SRR.Reg, volatile.LoadUint8(&o.SRR.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetSRR_SWRSTCMD() uint8 {
	return (volatile.LoadUint8(&o.SRR.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetSRR_SWRSTDAT(value uint8) {
	volatile.StoreUint8(&o.SRR.Reg, volatile.LoadUint8(&o.SRR.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetSRR_SWRSTDAT() uint8 {
	return (volatile.LoadUint8(&o.SRR.Reg) & 0x4) >> 2
}

// SDHC.NISTR: Normal Interrupt Status
func (o *SDHC_Type) SetNISTR_CMDC(value uint16) {
	volatile.StoreUint16(&o.NISTR.Reg, volatile.LoadUint16(&o.NISTR.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetNISTR_CMDC() uint16 {
	return volatile.LoadUint16(&o.NISTR.Reg) & 0x1
}
func (o *SDHC_Type) SetNISTR_TRFC(value uint16) {
	volatile.StoreUint16(&o.NISTR.Reg, volatile.LoadUint16(&o.NISTR.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetNISTR_TRFC() uint16 {
	return (volatile.LoadUint16(&o.NISTR.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetNISTR_BLKGE(value uint16) {
	volatile.StoreUint16(&o.NISTR.Reg, volatile.LoadUint16(&o.NISTR.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetNISTR_BLKGE() uint16 {
	return (volatile.LoadUint16(&o.NISTR.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetNISTR_DMAINT(value uint16) {
	volatile.StoreUint16(&o.NISTR.Reg, volatile.LoadUint16(&o.NISTR.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetNISTR_DMAINT() uint16 {
	return (volatile.LoadUint16(&o.NISTR.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetNISTR_BWRRDY(value uint16) {
	volatile.StoreUint16(&o.NISTR.Reg, volatile.LoadUint16(&o.NISTR.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetNISTR_BWRRDY() uint16 {
	return (volatile.LoadUint16(&o.NISTR.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetNISTR_BRDRDY(value uint16) {
	volatile.StoreUint16(&o.NISTR.Reg, volatile.LoadUint16(&o.NISTR.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetNISTR_BRDRDY() uint16 {
	return (volatile.LoadUint16(&o.NISTR.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetNISTR_CINS(value uint16) {
	volatile.StoreUint16(&o.NISTR.Reg, volatile.LoadUint16(&o.NISTR.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetNISTR_CINS() uint16 {
	return (volatile.LoadUint16(&o.NISTR.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetNISTR_CREM(value uint16) {
	volatile.StoreUint16(&o.NISTR.Reg, volatile.LoadUint16(&o.NISTR.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetNISTR_CREM() uint16 {
	return (volatile.LoadUint16(&o.NISTR.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetNISTR_CINT(value uint16) {
	volatile.StoreUint16(&o.NISTR.Reg, volatile.LoadUint16(&o.NISTR.Reg)&^(0x100)|value<<8)
}
func (o *SDHC_Type) GetNISTR_CINT() uint16 {
	return (volatile.LoadUint16(&o.NISTR.Reg) & 0x100) >> 8
}
func (o *SDHC_Type) SetNISTR_ERRINT(value uint16) {
	volatile.StoreUint16(&o.NISTR.Reg, volatile.LoadUint16(&o.NISTR.Reg)&^(0x8000)|value<<15)
}
func (o *SDHC_Type) GetNISTR_ERRINT() uint16 {
	return (volatile.LoadUint16(&o.NISTR.Reg) & 0x8000) >> 15
}

// SDHC.EISTR: Error Interrupt Status
func (o *SDHC_Type) SetEISTR_CMDTEO(value uint16) {
	volatile.StoreUint16(&o.EISTR.Reg, volatile.LoadUint16(&o.EISTR.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetEISTR_CMDTEO() uint16 {
	return volatile.LoadUint16(&o.EISTR.Reg) & 0x1
}
func (o *SDHC_Type) SetEISTR_CMDCRC(value uint16) {
	volatile.StoreUint16(&o.EISTR.Reg, volatile.LoadUint16(&o.EISTR.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetEISTR_CMDCRC() uint16 {
	return (volatile.LoadUint16(&o.EISTR.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetEISTR_CMDEND(value uint16) {
	volatile.StoreUint16(&o.EISTR.Reg, volatile.LoadUint16(&o.EISTR.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetEISTR_CMDEND() uint16 {
	return (volatile.LoadUint16(&o.EISTR.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetEISTR_CMDIDX(value uint16) {
	volatile.StoreUint16(&o.EISTR.Reg, volatile.LoadUint16(&o.EISTR.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetEISTR_CMDIDX() uint16 {
	return (volatile.LoadUint16(&o.EISTR.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetEISTR_DATTEO(value uint16) {
	volatile.StoreUint16(&o.EISTR.Reg, volatile.LoadUint16(&o.EISTR.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetEISTR_DATTEO() uint16 {
	return (volatile.LoadUint16(&o.EISTR.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetEISTR_DATCRC(value uint16) {
	volatile.StoreUint16(&o.EISTR.Reg, volatile.LoadUint16(&o.EISTR.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetEISTR_DATCRC() uint16 {
	return (volatile.LoadUint16(&o.EISTR.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetEISTR_DATEND(value uint16) {
	volatile.StoreUint16(&o.EISTR.Reg, volatile.LoadUint16(&o.EISTR.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetEISTR_DATEND() uint16 {
	return (volatile.LoadUint16(&o.EISTR.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetEISTR_CURLIM(value uint16) {
	volatile.StoreUint16(&o.EISTR.Reg, volatile.LoadUint16(&o.EISTR.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetEISTR_CURLIM() uint16 {
	return (volatile.LoadUint16(&o.EISTR.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetEISTR_ACMD(value uint16) {
	volatile.StoreUint16(&o.EISTR.Reg, volatile.LoadUint16(&o.EISTR.Reg)&^(0x100)|value<<8)
}
func (o *SDHC_Type) GetEISTR_ACMD() uint16 {
	return (volatile.LoadUint16(&o.EISTR.Reg) & 0x100) >> 8
}
func (o *SDHC_Type) SetEISTR_ADMA(value uint16) {
	volatile.StoreUint16(&o.EISTR.Reg, volatile.LoadUint16(&o.EISTR.Reg)&^(0x200)|value<<9)
}
func (o *SDHC_Type) GetEISTR_ADMA() uint16 {
	return (volatile.LoadUint16(&o.EISTR.Reg) & 0x200) >> 9
}

// SDHC.NISTER: Normal Interrupt Status Enable
func (o *SDHC_Type) SetNISTER_CMDC(value uint16) {
	volatile.StoreUint16(&o.NISTER.Reg, volatile.LoadUint16(&o.NISTER.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetNISTER_CMDC() uint16 {
	return volatile.LoadUint16(&o.NISTER.Reg) & 0x1
}
func (o *SDHC_Type) SetNISTER_TRFC(value uint16) {
	volatile.StoreUint16(&o.NISTER.Reg, volatile.LoadUint16(&o.NISTER.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetNISTER_TRFC() uint16 {
	return (volatile.LoadUint16(&o.NISTER.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetNISTER_BLKGE(value uint16) {
	volatile.StoreUint16(&o.NISTER.Reg, volatile.LoadUint16(&o.NISTER.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetNISTER_BLKGE() uint16 {
	return (volatile.LoadUint16(&o.NISTER.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetNISTER_DMAINT(value uint16) {
	volatile.StoreUint16(&o.NISTER.Reg, volatile.LoadUint16(&o.NISTER.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetNISTER_DMAINT() uint16 {
	return (volatile.LoadUint16(&o.NISTER.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetNISTER_BWRRDY(value uint16) {
	volatile.StoreUint16(&o.NISTER.Reg, volatile.LoadUint16(&o.NISTER.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetNISTER_BWRRDY() uint16 {
	return (volatile.LoadUint16(&o.NISTER.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetNISTER_BRDRDY(value uint16) {
	volatile.StoreUint16(&o.NISTER.Reg, volatile.LoadUint16(&o.NISTER.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetNISTER_BRDRDY() uint16 {
	return (volatile.LoadUint16(&o.NISTER.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetNISTER_CINS(value uint16) {
	volatile.StoreUint16(&o.NISTER.Reg, volatile.LoadUint16(&o.NISTER.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetNISTER_CINS() uint16 {
	return (volatile.LoadUint16(&o.NISTER.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetNISTER_CREM(value uint16) {
	volatile.StoreUint16(&o.NISTER.Reg, volatile.LoadUint16(&o.NISTER.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetNISTER_CREM() uint16 {
	return (volatile.LoadUint16(&o.NISTER.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetNISTER_CINT(value uint16) {
	volatile.StoreUint16(&o.NISTER.Reg, volatile.LoadUint16(&o.NISTER.Reg)&^(0x100)|value<<8)
}
func (o *SDHC_Type) GetNISTER_CINT() uint16 {
	return (volatile.LoadUint16(&o.NISTER.Reg) & 0x100) >> 8
}

// SDHC.EISTER: Error Interrupt Status Enable
func (o *SDHC_Type) SetEISTER_CMDTEO(value uint16) {
	volatile.StoreUint16(&o.EISTER.Reg, volatile.LoadUint16(&o.EISTER.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetEISTER_CMDTEO() uint16 {
	return volatile.LoadUint16(&o.EISTER.Reg) & 0x1
}
func (o *SDHC_Type) SetEISTER_CMDCRC(value uint16) {
	volatile.StoreUint16(&o.EISTER.Reg, volatile.LoadUint16(&o.EISTER.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetEISTER_CMDCRC() uint16 {
	return (volatile.LoadUint16(&o.EISTER.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetEISTER_CMDEND(value uint16) {
	volatile.StoreUint16(&o.EISTER.Reg, volatile.LoadUint16(&o.EISTER.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetEISTER_CMDEND() uint16 {
	return (volatile.LoadUint16(&o.EISTER.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetEISTER_CMDIDX(value uint16) {
	volatile.StoreUint16(&o.EISTER.Reg, volatile.LoadUint16(&o.EISTER.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetEISTER_CMDIDX() uint16 {
	return (volatile.LoadUint16(&o.EISTER.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetEISTER_DATTEO(value uint16) {
	volatile.StoreUint16(&o.EISTER.Reg, volatile.LoadUint16(&o.EISTER.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetEISTER_DATTEO() uint16 {
	return (volatile.LoadUint16(&o.EISTER.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetEISTER_DATCRC(value uint16) {
	volatile.StoreUint16(&o.EISTER.Reg, volatile.LoadUint16(&o.EISTER.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetEISTER_DATCRC() uint16 {
	return (volatile.LoadUint16(&o.EISTER.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetEISTER_DATEND(value uint16) {
	volatile.StoreUint16(&o.EISTER.Reg, volatile.LoadUint16(&o.EISTER.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetEISTER_DATEND() uint16 {
	return (volatile.LoadUint16(&o.EISTER.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetEISTER_CURLIM(value uint16) {
	volatile.StoreUint16(&o.EISTER.Reg, volatile.LoadUint16(&o.EISTER.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetEISTER_CURLIM() uint16 {
	return (volatile.LoadUint16(&o.EISTER.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetEISTER_ACMD(value uint16) {
	volatile.StoreUint16(&o.EISTER.Reg, volatile.LoadUint16(&o.EISTER.Reg)&^(0x100)|value<<8)
}
func (o *SDHC_Type) GetEISTER_ACMD() uint16 {
	return (volatile.LoadUint16(&o.EISTER.Reg) & 0x100) >> 8
}
func (o *SDHC_Type) SetEISTER_ADMA(value uint16) {
	volatile.StoreUint16(&o.EISTER.Reg, volatile.LoadUint16(&o.EISTER.Reg)&^(0x200)|value<<9)
}
func (o *SDHC_Type) GetEISTER_ADMA() uint16 {
	return (volatile.LoadUint16(&o.EISTER.Reg) & 0x200) >> 9
}

// SDHC.NISIER: Normal Interrupt Signal Enable
func (o *SDHC_Type) SetNISIER_CMDC(value uint16) {
	volatile.StoreUint16(&o.NISIER.Reg, volatile.LoadUint16(&o.NISIER.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetNISIER_CMDC() uint16 {
	return volatile.LoadUint16(&o.NISIER.Reg) & 0x1
}
func (o *SDHC_Type) SetNISIER_TRFC(value uint16) {
	volatile.StoreUint16(&o.NISIER.Reg, volatile.LoadUint16(&o.NISIER.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetNISIER_TRFC() uint16 {
	return (volatile.LoadUint16(&o.NISIER.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetNISIER_BLKGE(value uint16) {
	volatile.StoreUint16(&o.NISIER.Reg, volatile.LoadUint16(&o.NISIER.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetNISIER_BLKGE() uint16 {
	return (volatile.LoadUint16(&o.NISIER.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetNISIER_DMAINT(value uint16) {
	volatile.StoreUint16(&o.NISIER.Reg, volatile.LoadUint16(&o.NISIER.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetNISIER_DMAINT() uint16 {
	return (volatile.LoadUint16(&o.NISIER.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetNISIER_BWRRDY(value uint16) {
	volatile.StoreUint16(&o.NISIER.Reg, volatile.LoadUint16(&o.NISIER.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetNISIER_BWRRDY() uint16 {
	return (volatile.LoadUint16(&o.NISIER.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetNISIER_BRDRDY(value uint16) {
	volatile.StoreUint16(&o.NISIER.Reg, volatile.LoadUint16(&o.NISIER.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetNISIER_BRDRDY() uint16 {
	return (volatile.LoadUint16(&o.NISIER.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetNISIER_CINS(value uint16) {
	volatile.StoreUint16(&o.NISIER.Reg, volatile.LoadUint16(&o.NISIER.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetNISIER_CINS() uint16 {
	return (volatile.LoadUint16(&o.NISIER.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetNISIER_CREM(value uint16) {
	volatile.StoreUint16(&o.NISIER.Reg, volatile.LoadUint16(&o.NISIER.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetNISIER_CREM() uint16 {
	return (volatile.LoadUint16(&o.NISIER.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetNISIER_CINT(value uint16) {
	volatile.StoreUint16(&o.NISIER.Reg, volatile.LoadUint16(&o.NISIER.Reg)&^(0x100)|value<<8)
}
func (o *SDHC_Type) GetNISIER_CINT() uint16 {
	return (volatile.LoadUint16(&o.NISIER.Reg) & 0x100) >> 8
}

// SDHC.EISIER: Error Interrupt Signal Enable
func (o *SDHC_Type) SetEISIER_CMDTEO(value uint16) {
	volatile.StoreUint16(&o.EISIER.Reg, volatile.LoadUint16(&o.EISIER.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetEISIER_CMDTEO() uint16 {
	return volatile.LoadUint16(&o.EISIER.Reg) & 0x1
}
func (o *SDHC_Type) SetEISIER_CMDCRC(value uint16) {
	volatile.StoreUint16(&o.EISIER.Reg, volatile.LoadUint16(&o.EISIER.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetEISIER_CMDCRC() uint16 {
	return (volatile.LoadUint16(&o.EISIER.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetEISIER_CMDEND(value uint16) {
	volatile.StoreUint16(&o.EISIER.Reg, volatile.LoadUint16(&o.EISIER.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetEISIER_CMDEND() uint16 {
	return (volatile.LoadUint16(&o.EISIER.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetEISIER_CMDIDX(value uint16) {
	volatile.StoreUint16(&o.EISIER.Reg, volatile.LoadUint16(&o.EISIER.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetEISIER_CMDIDX() uint16 {
	return (volatile.LoadUint16(&o.EISIER.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetEISIER_DATTEO(value uint16) {
	volatile.StoreUint16(&o.EISIER.Reg, volatile.LoadUint16(&o.EISIER.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetEISIER_DATTEO() uint16 {
	return (volatile.LoadUint16(&o.EISIER.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetEISIER_DATCRC(value uint16) {
	volatile.StoreUint16(&o.EISIER.Reg, volatile.LoadUint16(&o.EISIER.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetEISIER_DATCRC() uint16 {
	return (volatile.LoadUint16(&o.EISIER.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetEISIER_DATEND(value uint16) {
	volatile.StoreUint16(&o.EISIER.Reg, volatile.LoadUint16(&o.EISIER.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetEISIER_DATEND() uint16 {
	return (volatile.LoadUint16(&o.EISIER.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetEISIER_CURLIM(value uint16) {
	volatile.StoreUint16(&o.EISIER.Reg, volatile.LoadUint16(&o.EISIER.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetEISIER_CURLIM() uint16 {
	return (volatile.LoadUint16(&o.EISIER.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetEISIER_ACMD(value uint16) {
	volatile.StoreUint16(&o.EISIER.Reg, volatile.LoadUint16(&o.EISIER.Reg)&^(0x100)|value<<8)
}
func (o *SDHC_Type) GetEISIER_ACMD() uint16 {
	return (volatile.LoadUint16(&o.EISIER.Reg) & 0x100) >> 8
}
func (o *SDHC_Type) SetEISIER_ADMA(value uint16) {
	volatile.StoreUint16(&o.EISIER.Reg, volatile.LoadUint16(&o.EISIER.Reg)&^(0x200)|value<<9)
}
func (o *SDHC_Type) GetEISIER_ADMA() uint16 {
	return (volatile.LoadUint16(&o.EISIER.Reg) & 0x200) >> 9
}

// SDHC.ACESR: Auto CMD Error Status
func (o *SDHC_Type) SetACESR_ACMD12NE(value uint16) {
	volatile.StoreUint16(&o.ACESR.Reg, volatile.LoadUint16(&o.ACESR.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetACESR_ACMD12NE() uint16 {
	return volatile.LoadUint16(&o.ACESR.Reg) & 0x1
}
func (o *SDHC_Type) SetACESR_ACMDTEO(value uint16) {
	volatile.StoreUint16(&o.ACESR.Reg, volatile.LoadUint16(&o.ACESR.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetACESR_ACMDTEO() uint16 {
	return (volatile.LoadUint16(&o.ACESR.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetACESR_ACMDCRC(value uint16) {
	volatile.StoreUint16(&o.ACESR.Reg, volatile.LoadUint16(&o.ACESR.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetACESR_ACMDCRC() uint16 {
	return (volatile.LoadUint16(&o.ACESR.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetACESR_ACMDEND(value uint16) {
	volatile.StoreUint16(&o.ACESR.Reg, volatile.LoadUint16(&o.ACESR.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetACESR_ACMDEND() uint16 {
	return (volatile.LoadUint16(&o.ACESR.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetACESR_ACMDIDX(value uint16) {
	volatile.StoreUint16(&o.ACESR.Reg, volatile.LoadUint16(&o.ACESR.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetACESR_ACMDIDX() uint16 {
	return (volatile.LoadUint16(&o.ACESR.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetACESR_CMDNI(value uint16) {
	volatile.StoreUint16(&o.ACESR.Reg, volatile.LoadUint16(&o.ACESR.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetACESR_CMDNI() uint16 {
	return (volatile.LoadUint16(&o.ACESR.Reg) & 0x80) >> 7
}

// SDHC.HC2R: Host Control 2
func (o *SDHC_Type) SetHC2R_UHSMS(value uint16) {
	volatile.StoreUint16(&o.HC2R.Reg, volatile.LoadUint16(&o.HC2R.Reg)&^(0x7)|value)
}
func (o *SDHC_Type) GetHC2R_UHSMS() uint16 {
	return volatile.LoadUint16(&o.HC2R.Reg) & 0x7
}
func (o *SDHC_Type) SetHC2R_VS18EN(value uint16) {
	volatile.StoreUint16(&o.HC2R.Reg, volatile.LoadUint16(&o.HC2R.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetHC2R_VS18EN() uint16 {
	return (volatile.LoadUint16(&o.HC2R.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetHC2R_DRVSEL(value uint16) {
	volatile.StoreUint16(&o.HC2R.Reg, volatile.LoadUint16(&o.HC2R.Reg)&^(0x30)|value<<4)
}
func (o *SDHC_Type) GetHC2R_DRVSEL() uint16 {
	return (volatile.LoadUint16(&o.HC2R.Reg) & 0x30) >> 4
}
func (o *SDHC_Type) SetHC2R_EXTUN(value uint16) {
	volatile.StoreUint16(&o.HC2R.Reg, volatile.LoadUint16(&o.HC2R.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetHC2R_EXTUN() uint16 {
	return (volatile.LoadUint16(&o.HC2R.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetHC2R_SLCKSEL(value uint16) {
	volatile.StoreUint16(&o.HC2R.Reg, volatile.LoadUint16(&o.HC2R.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetHC2R_SLCKSEL() uint16 {
	return (volatile.LoadUint16(&o.HC2R.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetHC2R_ASINTEN(value uint16) {
	volatile.StoreUint16(&o.HC2R.Reg, volatile.LoadUint16(&o.HC2R.Reg)&^(0x4000)|value<<14)
}
func (o *SDHC_Type) GetHC2R_ASINTEN() uint16 {
	return (volatile.LoadUint16(&o.HC2R.Reg) & 0x4000) >> 14
}
func (o *SDHC_Type) SetHC2R_PVALEN(value uint16) {
	volatile.StoreUint16(&o.HC2R.Reg, volatile.LoadUint16(&o.HC2R.Reg)&^(0x8000)|value<<15)
}
func (o *SDHC_Type) GetHC2R_PVALEN() uint16 {
	return (volatile.LoadUint16(&o.HC2R.Reg) & 0x8000) >> 15
}

// SDHC.CA0R: Capabilities 0
func (o *SDHC_Type) SetCA0R_TEOCLKF(value uint32) {
	volatile.StoreUint32(&o.CA0R.Reg, volatile.LoadUint32(&o.CA0R.Reg)&^(0x3f)|value)
}
func (o *SDHC_Type) GetCA0R_TEOCLKF() uint32 {
	return volatile.LoadUint32(&o.CA0R.Reg) & 0x3f
}
func (o *SDHC_Type) SetCA0R_TEOCLKU(value uint32) {
	volatile.StoreUint32(&o.CA0R.Reg, volatile.LoadUint32(&o.CA0R.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetCA0R_TEOCLKU() uint32 {
	return (volatile.LoadUint32(&o.CA0R.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetCA0R_BASECLKF(value uint32) {
	volatile.StoreUint32(&o.CA0R.Reg, volatile.LoadUint32(&o.CA0R.Reg)&^(0xff00)|value<<8)
}
func (o *SDHC_Type) GetCA0R_BASECLKF() uint32 {
	return (volatile.LoadUint32(&o.CA0R.Reg) & 0xff00) >> 8
}
func (o *SDHC_Type) SetCA0R_MAXBLKL(value uint32) {
	volatile.StoreUint32(&o.CA0R.Reg, volatile.LoadUint32(&o.CA0R.Reg)&^(0x30000)|value<<16)
}
func (o *SDHC_Type) GetCA0R_MAXBLKL() uint32 {
	return (volatile.LoadUint32(&o.CA0R.Reg) & 0x30000) >> 16
}
func (o *SDHC_Type) SetCA0R_ED8SUP(value uint32) {
	volatile.StoreUint32(&o.CA0R.Reg, volatile.LoadUint32(&o.CA0R.Reg)&^(0x40000)|value<<18)
}
func (o *SDHC_Type) GetCA0R_ED8SUP() uint32 {
	return (volatile.LoadUint32(&o.CA0R.Reg) & 0x40000) >> 18
}
func (o *SDHC_Type) SetCA0R_ADMA2SUP(value uint32) {
	volatile.StoreUint32(&o.CA0R.Reg, volatile.LoadUint32(&o.CA0R.Reg)&^(0x80000)|value<<19)
}
func (o *SDHC_Type) GetCA0R_ADMA2SUP() uint32 {
	return (volatile.LoadUint32(&o.CA0R.Reg) & 0x80000) >> 19
}
func (o *SDHC_Type) SetCA0R_HSSUP(value uint32) {
	volatile.StoreUint32(&o.CA0R.Reg, volatile.LoadUint32(&o.CA0R.Reg)&^(0x200000)|value<<21)
}
func (o *SDHC_Type) GetCA0R_HSSUP() uint32 {
	return (volatile.LoadUint32(&o.CA0R.Reg) & 0x200000) >> 21
}
func (o *SDHC_Type) SetCA0R_SDMASUP(value uint32) {
	volatile.StoreUint32(&o.CA0R.Reg, volatile.LoadUint32(&o.CA0R.Reg)&^(0x400000)|value<<22)
}
func (o *SDHC_Type) GetCA0R_SDMASUP() uint32 {
	return (volatile.LoadUint32(&o.CA0R.Reg) & 0x400000) >> 22
}
func (o *SDHC_Type) SetCA0R_SRSUP(value uint32) {
	volatile.StoreUint32(&o.CA0R.Reg, volatile.LoadUint32(&o.CA0R.Reg)&^(0x800000)|value<<23)
}
func (o *SDHC_Type) GetCA0R_SRSUP() uint32 {
	return (volatile.LoadUint32(&o.CA0R.Reg) & 0x800000) >> 23
}
func (o *SDHC_Type) SetCA0R_V33VSUP(value uint32) {
	volatile.StoreUint32(&o.CA0R.Reg, volatile.LoadUint32(&o.CA0R.Reg)&^(0x1000000)|value<<24)
}
func (o *SDHC_Type) GetCA0R_V33VSUP() uint32 {
	return (volatile.LoadUint32(&o.CA0R.Reg) & 0x1000000) >> 24
}
func (o *SDHC_Type) SetCA0R_V30VSUP(value uint32) {
	volatile.StoreUint32(&o.CA0R.Reg, volatile.LoadUint32(&o.CA0R.Reg)&^(0x2000000)|value<<25)
}
func (o *SDHC_Type) GetCA0R_V30VSUP() uint32 {
	return (volatile.LoadUint32(&o.CA0R.Reg) & 0x2000000) >> 25
}
func (o *SDHC_Type) SetCA0R_V18VSUP(value uint32) {
	volatile.StoreUint32(&o.CA0R.Reg, volatile.LoadUint32(&o.CA0R.Reg)&^(0x4000000)|value<<26)
}
func (o *SDHC_Type) GetCA0R_V18VSUP() uint32 {
	return (volatile.LoadUint32(&o.CA0R.Reg) & 0x4000000) >> 26
}
func (o *SDHC_Type) SetCA0R_SB64SUP(value uint32) {
	volatile.StoreUint32(&o.CA0R.Reg, volatile.LoadUint32(&o.CA0R.Reg)&^(0x10000000)|value<<28)
}
func (o *SDHC_Type) GetCA0R_SB64SUP() uint32 {
	return (volatile.LoadUint32(&o.CA0R.Reg) & 0x10000000) >> 28
}
func (o *SDHC_Type) SetCA0R_ASINTSUP(value uint32) {
	volatile.StoreUint32(&o.CA0R.Reg, volatile.LoadUint32(&o.CA0R.Reg)&^(0x20000000)|value<<29)
}
func (o *SDHC_Type) GetCA0R_ASINTSUP() uint32 {
	return (volatile.LoadUint32(&o.CA0R.Reg) & 0x20000000) >> 29
}
func (o *SDHC_Type) SetCA0R_SLTYPE(value uint32) {
	volatile.StoreUint32(&o.CA0R.Reg, volatile.LoadUint32(&o.CA0R.Reg)&^(0xc0000000)|value<<30)
}
func (o *SDHC_Type) GetCA0R_SLTYPE() uint32 {
	return (volatile.LoadUint32(&o.CA0R.Reg) & 0xc0000000) >> 30
}

// SDHC.CA1R: Capabilities 1
func (o *SDHC_Type) SetCA1R_SDR50SUP(value uint32) {
	volatile.StoreUint32(&o.CA1R.Reg, volatile.LoadUint32(&o.CA1R.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetCA1R_SDR50SUP() uint32 {
	return volatile.LoadUint32(&o.CA1R.Reg) & 0x1
}
func (o *SDHC_Type) SetCA1R_SDR104SUP(value uint32) {
	volatile.StoreUint32(&o.CA1R.Reg, volatile.LoadUint32(&o.CA1R.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetCA1R_SDR104SUP() uint32 {
	return (volatile.LoadUint32(&o.CA1R.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetCA1R_DDR50SUP(value uint32) {
	volatile.StoreUint32(&o.CA1R.Reg, volatile.LoadUint32(&o.CA1R.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetCA1R_DDR50SUP() uint32 {
	return (volatile.LoadUint32(&o.CA1R.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetCA1R_DRVASUP(value uint32) {
	volatile.StoreUint32(&o.CA1R.Reg, volatile.LoadUint32(&o.CA1R.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetCA1R_DRVASUP() uint32 {
	return (volatile.LoadUint32(&o.CA1R.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetCA1R_DRVCSUP(value uint32) {
	volatile.StoreUint32(&o.CA1R.Reg, volatile.LoadUint32(&o.CA1R.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetCA1R_DRVCSUP() uint32 {
	return (volatile.LoadUint32(&o.CA1R.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetCA1R_DRVDSUP(value uint32) {
	volatile.StoreUint32(&o.CA1R.Reg, volatile.LoadUint32(&o.CA1R.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetCA1R_DRVDSUP() uint32 {
	return (volatile.LoadUint32(&o.CA1R.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetCA1R_TCNTRT(value uint32) {
	volatile.StoreUint32(&o.CA1R.Reg, volatile.LoadUint32(&o.CA1R.Reg)&^(0xf00)|value<<8)
}
func (o *SDHC_Type) GetCA1R_TCNTRT() uint32 {
	return (volatile.LoadUint32(&o.CA1R.Reg) & 0xf00) >> 8
}
func (o *SDHC_Type) SetCA1R_TSDR50(value uint32) {
	volatile.StoreUint32(&o.CA1R.Reg, volatile.LoadUint32(&o.CA1R.Reg)&^(0x2000)|value<<13)
}
func (o *SDHC_Type) GetCA1R_TSDR50() uint32 {
	return (volatile.LoadUint32(&o.CA1R.Reg) & 0x2000) >> 13
}
func (o *SDHC_Type) SetCA1R_CLKMULT(value uint32) {
	volatile.StoreUint32(&o.CA1R.Reg, volatile.LoadUint32(&o.CA1R.Reg)&^(0xff0000)|value<<16)
}
func (o *SDHC_Type) GetCA1R_CLKMULT() uint32 {
	return (volatile.LoadUint32(&o.CA1R.Reg) & 0xff0000) >> 16
}

// SDHC.MCCAR: Maximum Current Capabilities
func (o *SDHC_Type) SetMCCAR_MAXCUR33V(value uint32) {
	volatile.StoreUint32(&o.MCCAR.Reg, volatile.LoadUint32(&o.MCCAR.Reg)&^(0xff)|value)
}
func (o *SDHC_Type) GetMCCAR_MAXCUR33V() uint32 {
	return volatile.LoadUint32(&o.MCCAR.Reg) & 0xff
}
func (o *SDHC_Type) SetMCCAR_MAXCUR30V(value uint32) {
	volatile.StoreUint32(&o.MCCAR.Reg, volatile.LoadUint32(&o.MCCAR.Reg)&^(0xff00)|value<<8)
}
func (o *SDHC_Type) GetMCCAR_MAXCUR30V() uint32 {
	return (volatile.LoadUint32(&o.MCCAR.Reg) & 0xff00) >> 8
}
func (o *SDHC_Type) SetMCCAR_MAXCUR18V(value uint32) {
	volatile.StoreUint32(&o.MCCAR.Reg, volatile.LoadUint32(&o.MCCAR.Reg)&^(0xff0000)|value<<16)
}
func (o *SDHC_Type) GetMCCAR_MAXCUR18V() uint32 {
	return (volatile.LoadUint32(&o.MCCAR.Reg) & 0xff0000) >> 16
}

// SDHC.FERACES: Force Event for Auto CMD Error Status
func (o *SDHC_Type) SetFERACES_ACMD12NE(value uint16) {
	volatile.StoreUint16(&o.FERACES.Reg, volatile.LoadUint16(&o.FERACES.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetFERACES_ACMD12NE() uint16 {
	return volatile.LoadUint16(&o.FERACES.Reg) & 0x1
}
func (o *SDHC_Type) SetFERACES_ACMDTEO(value uint16) {
	volatile.StoreUint16(&o.FERACES.Reg, volatile.LoadUint16(&o.FERACES.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetFERACES_ACMDTEO() uint16 {
	return (volatile.LoadUint16(&o.FERACES.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetFERACES_ACMDCRC(value uint16) {
	volatile.StoreUint16(&o.FERACES.Reg, volatile.LoadUint16(&o.FERACES.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetFERACES_ACMDCRC() uint16 {
	return (volatile.LoadUint16(&o.FERACES.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetFERACES_ACMDEND(value uint16) {
	volatile.StoreUint16(&o.FERACES.Reg, volatile.LoadUint16(&o.FERACES.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetFERACES_ACMDEND() uint16 {
	return (volatile.LoadUint16(&o.FERACES.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetFERACES_ACMDIDX(value uint16) {
	volatile.StoreUint16(&o.FERACES.Reg, volatile.LoadUint16(&o.FERACES.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetFERACES_ACMDIDX() uint16 {
	return (volatile.LoadUint16(&o.FERACES.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetFERACES_CMDNI(value uint16) {
	volatile.StoreUint16(&o.FERACES.Reg, volatile.LoadUint16(&o.FERACES.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetFERACES_CMDNI() uint16 {
	return (volatile.LoadUint16(&o.FERACES.Reg) & 0x80) >> 7
}

// SDHC.FEREIS: Force Event for Error Interrupt Status
func (o *SDHC_Type) SetFEREIS_CMDTEO(value uint16) {
	volatile.StoreUint16(&o.FEREIS.Reg, volatile.LoadUint16(&o.FEREIS.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetFEREIS_CMDTEO() uint16 {
	return volatile.LoadUint16(&o.FEREIS.Reg) & 0x1
}
func (o *SDHC_Type) SetFEREIS_CMDCRC(value uint16) {
	volatile.StoreUint16(&o.FEREIS.Reg, volatile.LoadUint16(&o.FEREIS.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetFEREIS_CMDCRC() uint16 {
	return (volatile.LoadUint16(&o.FEREIS.Reg) & 0x2) >> 1
}
func (o *SDHC_Type) SetFEREIS_CMDEND(value uint16) {
	volatile.StoreUint16(&o.FEREIS.Reg, volatile.LoadUint16(&o.FEREIS.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetFEREIS_CMDEND() uint16 {
	return (volatile.LoadUint16(&o.FEREIS.Reg) & 0x4) >> 2
}
func (o *SDHC_Type) SetFEREIS_CMDIDX(value uint16) {
	volatile.StoreUint16(&o.FEREIS.Reg, volatile.LoadUint16(&o.FEREIS.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetFEREIS_CMDIDX() uint16 {
	return (volatile.LoadUint16(&o.FEREIS.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetFEREIS_DATTEO(value uint16) {
	volatile.StoreUint16(&o.FEREIS.Reg, volatile.LoadUint16(&o.FEREIS.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetFEREIS_DATTEO() uint16 {
	return (volatile.LoadUint16(&o.FEREIS.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetFEREIS_DATCRC(value uint16) {
	volatile.StoreUint16(&o.FEREIS.Reg, volatile.LoadUint16(&o.FEREIS.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetFEREIS_DATCRC() uint16 {
	return (volatile.LoadUint16(&o.FEREIS.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetFEREIS_DATEND(value uint16) {
	volatile.StoreUint16(&o.FEREIS.Reg, volatile.LoadUint16(&o.FEREIS.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetFEREIS_DATEND() uint16 {
	return (volatile.LoadUint16(&o.FEREIS.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetFEREIS_CURLIM(value uint16) {
	volatile.StoreUint16(&o.FEREIS.Reg, volatile.LoadUint16(&o.FEREIS.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetFEREIS_CURLIM() uint16 {
	return (volatile.LoadUint16(&o.FEREIS.Reg) & 0x80) >> 7
}
func (o *SDHC_Type) SetFEREIS_ACMD(value uint16) {
	volatile.StoreUint16(&o.FEREIS.Reg, volatile.LoadUint16(&o.FEREIS.Reg)&^(0x100)|value<<8)
}
func (o *SDHC_Type) GetFEREIS_ACMD() uint16 {
	return (volatile.LoadUint16(&o.FEREIS.Reg) & 0x100) >> 8
}
func (o *SDHC_Type) SetFEREIS_ADMA(value uint16) {
	volatile.StoreUint16(&o.FEREIS.Reg, volatile.LoadUint16(&o.FEREIS.Reg)&^(0x200)|value<<9)
}
func (o *SDHC_Type) GetFEREIS_ADMA() uint16 {
	return (volatile.LoadUint16(&o.FEREIS.Reg) & 0x200) >> 9
}
func (o *SDHC_Type) SetFEREIS_BOOTAE(value uint16) {
	volatile.StoreUint16(&o.FEREIS.Reg, volatile.LoadUint16(&o.FEREIS.Reg)&^(0x1000)|value<<12)
}
func (o *SDHC_Type) GetFEREIS_BOOTAE() uint16 {
	return (volatile.LoadUint16(&o.FEREIS.Reg) & 0x1000) >> 12
}

// SDHC.AESR: ADMA Error Status
func (o *SDHC_Type) SetAESR_ERRST(value uint8) {
	volatile.StoreUint8(&o.AESR.Reg, volatile.LoadUint8(&o.AESR.Reg)&^(0x3)|value)
}
func (o *SDHC_Type) GetAESR_ERRST() uint8 {
	return volatile.LoadUint8(&o.AESR.Reg) & 0x3
}
func (o *SDHC_Type) SetAESR_LMIS(value uint8) {
	volatile.StoreUint8(&o.AESR.Reg, volatile.LoadUint8(&o.AESR.Reg)&^(0x4)|value<<2)
}
func (o *SDHC_Type) GetAESR_LMIS() uint8 {
	return (volatile.LoadUint8(&o.AESR.Reg) & 0x4) >> 2
}

// SDHC.ASAR: ADMA System Address n
func (o *SDHC_Type) SetASAR(idx int, value uint32) {
	volatile.StoreUint32(&o.ASAR[idx].Reg, value)
}
func (o *SDHC_Type) GetASAR(idx int) uint32 {
	return volatile.LoadUint32(&o.ASAR[idx].Reg)
}

// SDHC.PVR: Preset Value n
func (o *SDHC_Type) SetPVR_SDCLKFSEL(idx int, value uint16) {
	volatile.StoreUint16(&o.PVR[idx].Reg, volatile.LoadUint16(&o.PVR[idx].Reg)&^(0x3ff)|value)
}
func (o *SDHC_Type) GetPVR_SDCLKFSEL(idx int) uint16 {
	return volatile.LoadUint16(&o.PVR[idx].Reg) & 0x3ff
}
func (o *SDHC_Type) SetPVR_CLKGSEL(idx int, value uint16) {
	volatile.StoreUint16(&o.PVR[idx].Reg, volatile.LoadUint16(&o.PVR[idx].Reg)&^(0x400)|value<<10)
}
func (o *SDHC_Type) GetPVR_CLKGSEL(idx int) uint16 {
	return (volatile.LoadUint16(&o.PVR[idx].Reg) & 0x400) >> 10
}
func (o *SDHC_Type) SetPVR_DRVSEL(idx int, value uint16) {
	volatile.StoreUint16(&o.PVR[idx].Reg, volatile.LoadUint16(&o.PVR[idx].Reg)&^(0xc000)|value<<14)
}
func (o *SDHC_Type) GetPVR_DRVSEL(idx int) uint16 {
	return (volatile.LoadUint16(&o.PVR[idx].Reg) & 0xc000) >> 14
}

// SDHC.SISR: Slot Interrupt Status
func (o *SDHC_Type) SetSISR_INTSSL(value uint16) {
	volatile.StoreUint16(&o.SISR.Reg, volatile.LoadUint16(&o.SISR.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetSISR_INTSSL() uint16 {
	return volatile.LoadUint16(&o.SISR.Reg) & 0x1
}

// SDHC.HCVR: Host Controller Version
func (o *SDHC_Type) SetHCVR_SVER(value uint16) {
	volatile.StoreUint16(&o.HCVR.Reg, volatile.LoadUint16(&o.HCVR.Reg)&^(0xff)|value)
}
func (o *SDHC_Type) GetHCVR_SVER() uint16 {
	return volatile.LoadUint16(&o.HCVR.Reg) & 0xff
}
func (o *SDHC_Type) SetHCVR_VVER(value uint16) {
	volatile.StoreUint16(&o.HCVR.Reg, volatile.LoadUint16(&o.HCVR.Reg)&^(0xff00)|value<<8)
}
func (o *SDHC_Type) GetHCVR_VVER() uint16 {
	return (volatile.LoadUint16(&o.HCVR.Reg) & 0xff00) >> 8
}

// SDHC.MC1R: MMC Control 1
func (o *SDHC_Type) SetMC1R_CMDTYP(value uint8) {
	volatile.StoreUint8(&o.MC1R.Reg, volatile.LoadUint8(&o.MC1R.Reg)&^(0x3)|value)
}
func (o *SDHC_Type) GetMC1R_CMDTYP() uint8 {
	return volatile.LoadUint8(&o.MC1R.Reg) & 0x3
}
func (o *SDHC_Type) SetMC1R_DDR(value uint8) {
	volatile.StoreUint8(&o.MC1R.Reg, volatile.LoadUint8(&o.MC1R.Reg)&^(0x8)|value<<3)
}
func (o *SDHC_Type) GetMC1R_DDR() uint8 {
	return (volatile.LoadUint8(&o.MC1R.Reg) & 0x8) >> 3
}
func (o *SDHC_Type) SetMC1R_OPD(value uint8) {
	volatile.StoreUint8(&o.MC1R.Reg, volatile.LoadUint8(&o.MC1R.Reg)&^(0x10)|value<<4)
}
func (o *SDHC_Type) GetMC1R_OPD() uint8 {
	return (volatile.LoadUint8(&o.MC1R.Reg) & 0x10) >> 4
}
func (o *SDHC_Type) SetMC1R_BOOTA(value uint8) {
	volatile.StoreUint8(&o.MC1R.Reg, volatile.LoadUint8(&o.MC1R.Reg)&^(0x20)|value<<5)
}
func (o *SDHC_Type) GetMC1R_BOOTA() uint8 {
	return (volatile.LoadUint8(&o.MC1R.Reg) & 0x20) >> 5
}
func (o *SDHC_Type) SetMC1R_RSTN(value uint8) {
	volatile.StoreUint8(&o.MC1R.Reg, volatile.LoadUint8(&o.MC1R.Reg)&^(0x40)|value<<6)
}
func (o *SDHC_Type) GetMC1R_RSTN() uint8 {
	return (volatile.LoadUint8(&o.MC1R.Reg) & 0x40) >> 6
}
func (o *SDHC_Type) SetMC1R_FCD(value uint8) {
	volatile.StoreUint8(&o.MC1R.Reg, volatile.LoadUint8(&o.MC1R.Reg)&^(0x80)|value<<7)
}
func (o *SDHC_Type) GetMC1R_FCD() uint8 {
	return (volatile.LoadUint8(&o.MC1R.Reg) & 0x80) >> 7
}

// SDHC.MC2R: MMC Control 2
func (o *SDHC_Type) SetMC2R_SRESP(value uint8) {
	volatile.StoreUint8(&o.MC2R.Reg, volatile.LoadUint8(&o.MC2R.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetMC2R_SRESP() uint8 {
	return volatile.LoadUint8(&o.MC2R.Reg) & 0x1
}
func (o *SDHC_Type) SetMC2R_ABOOT(value uint8) {
	volatile.StoreUint8(&o.MC2R.Reg, volatile.LoadUint8(&o.MC2R.Reg)&^(0x2)|value<<1)
}
func (o *SDHC_Type) GetMC2R_ABOOT() uint8 {
	return (volatile.LoadUint8(&o.MC2R.Reg) & 0x2) >> 1
}

// SDHC.ACR: AHB Control
func (o *SDHC_Type) SetACR_BMAX(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x3)|value)
}
func (o *SDHC_Type) GetACR_BMAX() uint32 {
	return volatile.LoadUint32(&o.ACR.Reg) & 0x3
}

// SDHC.CC2R: Clock Control 2
func (o *SDHC_Type) SetCC2R_FSDCLKD(value uint32) {
	volatile.StoreUint32(&o.CC2R.Reg, volatile.LoadUint32(&o.CC2R.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetCC2R_FSDCLKD() uint32 {
	return volatile.LoadUint32(&o.CC2R.Reg) & 0x1
}

// SDHC.CACR: Capabilities Control
func (o *SDHC_Type) SetCACR_CAPWREN(value uint32) {
	volatile.StoreUint32(&o.CACR.Reg, volatile.LoadUint32(&o.CACR.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetCACR_CAPWREN() uint32 {
	return volatile.LoadUint32(&o.CACR.Reg) & 0x1
}
func (o *SDHC_Type) SetCACR_KEY(value uint32) {
	volatile.StoreUint32(&o.CACR.Reg, volatile.LoadUint32(&o.CACR.Reg)&^(0xff00)|value<<8)
}
func (o *SDHC_Type) GetCACR_KEY() uint32 {
	return (volatile.LoadUint32(&o.CACR.Reg) & 0xff00) >> 8
}

// SDHC.DBGR: Debug
func (o *SDHC_Type) SetDBGR_NIDBG(value uint8) {
	volatile.StoreUint8(&o.DBGR.Reg, volatile.LoadUint8(&o.DBGR.Reg)&^(0x1)|value)
}
func (o *SDHC_Type) GetDBGR_NIDBG() uint8 {
	return volatile.LoadUint8(&o.DBGR.Reg) & 0x1
}

// Serial Communication Interface
type SERCOM_Type struct {
}

// Serial Communication Interface - I2CM
type SERCOM_I2CM_Type struct {
	CTRLA    volatile.Register32 // 0x0
	CTRLB    volatile.Register32 // 0x4
	CTRLC    volatile.Register32 // 0x8
	BAUD     volatile.Register32 // 0xC
	_        [4]byte
	INTENCLR volatile.Register8 // 0x14
	_        byte
	INTENSET volatile.Register8 // 0x16
	_        byte
	INTFLAG  volatile.Register8 // 0x18
	_        byte
	STATUS   volatile.Register16 // 0x1A
	SYNCBUSY volatile.Register32 // 0x1C
	_        [4]byte
	ADDR     volatile.Register32 // 0x24
	DATA     volatile.Register8  // 0x28
	_        [7]byte
	DBGCTRL  volatile.Register8 // 0x30
}

// SERCOM_I2CM.CTRLA: I2CM Control A
func (o *SERCOM_I2CM_Type) SetCTRLA_SWRST(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *SERCOM_I2CM_Type) GetCTRLA_SWRST() uint32 {
	return volatile.LoadUint32(&o.CTRLA.Reg) & 0x1
}
func (o *SERCOM_I2CM_Type) SetCTRLA_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_I2CM_Type) GetCTRLA_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *SERCOM_I2CM_Type) SetCTRLA_MODE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1c)|value<<2)
}
func (o *SERCOM_I2CM_Type) GetCTRLA_MODE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x1c) >> 2
}
func (o *SERCOM_I2CM_Type) SetCTRLA_RUNSTDBY(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_I2CM_Type) GetCTRLA_RUNSTDBY() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x80) >> 7
}
func (o *SERCOM_I2CM_Type) SetCTRLA_PINOUT(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x10000)|value<<16)
}
func (o *SERCOM_I2CM_Type) GetCTRLA_PINOUT() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x10000) >> 16
}
func (o *SERCOM_I2CM_Type) SetCTRLA_SDAHOLD(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x300000)|value<<20)
}
func (o *SERCOM_I2CM_Type) GetCTRLA_SDAHOLD() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x300000) >> 20
}
func (o *SERCOM_I2CM_Type) SetCTRLA_MEXTTOEN(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x400000)|value<<22)
}
func (o *SERCOM_I2CM_Type) GetCTRLA_MEXTTOEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x400000) >> 22
}
func (o *SERCOM_I2CM_Type) SetCTRLA_SEXTTOEN(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x800000)|value<<23)
}
func (o *SERCOM_I2CM_Type) GetCTRLA_SEXTTOEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x800000) >> 23
}
func (o *SERCOM_I2CM_Type) SetCTRLA_SPEED(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x3000000)|value<<24)
}
func (o *SERCOM_I2CM_Type) GetCTRLA_SPEED() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x3000000) >> 24
}
func (o *SERCOM_I2CM_Type) SetCTRLA_SCLSM(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x8000000)|value<<27)
}
func (o *SERCOM_I2CM_Type) GetCTRLA_SCLSM() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x8000000) >> 27
}
func (o *SERCOM_I2CM_Type) SetCTRLA_INACTOUT(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x30000000)|value<<28)
}
func (o *SERCOM_I2CM_Type) GetCTRLA_INACTOUT() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x30000000) >> 28
}
func (o *SERCOM_I2CM_Type) SetCTRLA_LOWTOUTEN(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x40000000)|value<<30)
}
func (o *SERCOM_I2CM_Type) GetCTRLA_LOWTOUTEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x40000000) >> 30
}

// SERCOM_I2CM.CTRLB: I2CM Control B
func (o *SERCOM_I2CM_Type) SetCTRLB_SMEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x100)|value<<8)
}
func (o *SERCOM_I2CM_Type) GetCTRLB_SMEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x100) >> 8
}
func (o *SERCOM_I2CM_Type) SetCTRLB_QCEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x200)|value<<9)
}
func (o *SERCOM_I2CM_Type) GetCTRLB_QCEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x200) >> 9
}
func (o *SERCOM_I2CM_Type) SetCTRLB_CMD(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x30000)|value<<16)
}
func (o *SERCOM_I2CM_Type) GetCTRLB_CMD() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x30000) >> 16
}
func (o *SERCOM_I2CM_Type) SetCTRLB_ACKACT(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x40000)|value<<18)
}
func (o *SERCOM_I2CM_Type) GetCTRLB_ACKACT() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x40000) >> 18
}

// SERCOM_I2CM.CTRLC: I2CM Control C
func (o *SERCOM_I2CM_Type) SetCTRLC_DATA32B(value uint32) {
	volatile.StoreUint32(&o.CTRLC.Reg, volatile.LoadUint32(&o.CTRLC.Reg)&^(0x1000000)|value<<24)
}
func (o *SERCOM_I2CM_Type) GetCTRLC_DATA32B() uint32 {
	return (volatile.LoadUint32(&o.CTRLC.Reg) & 0x1000000) >> 24
}

// SERCOM_I2CM.BAUD: I2CM Baud Rate
func (o *SERCOM_I2CM_Type) SetBAUD(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0xff)|value)
}
func (o *SERCOM_I2CM_Type) GetBAUD() uint32 {
	return volatile.LoadUint32(&o.BAUD.Reg) & 0xff
}
func (o *SERCOM_I2CM_Type) SetBAUD_BAUDLOW(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0xff00)|value<<8)
}
func (o *SERCOM_I2CM_Type) GetBAUD_BAUDLOW() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0xff00) >> 8
}
func (o *SERCOM_I2CM_Type) SetBAUD_HSBAUD(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0xff0000)|value<<16)
}
func (o *SERCOM_I2CM_Type) GetBAUD_HSBAUD() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0xff0000) >> 16
}
func (o *SERCOM_I2CM_Type) SetBAUD_HSBAUDLOW(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0xff000000)|value<<24)
}
func (o *SERCOM_I2CM_Type) GetBAUD_HSBAUDLOW() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0xff000000) >> 24
}

// SERCOM_I2CM.INTENCLR: I2CM Interrupt Enable Clear
func (o *SERCOM_I2CM_Type) SetINTENCLR_MB(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *SERCOM_I2CM_Type) GetINTENCLR_MB() uint8 {
	return volatile.LoadUint8(&o.INTENCLR.Reg) & 0x1
}
func (o *SERCOM_I2CM_Type) SetINTENCLR_SB(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_I2CM_Type) GetINTENCLR_SB() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *SERCOM_I2CM_Type) SetINTENCLR_ERROR(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_I2CM_Type) GetINTENCLR_ERROR() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x80) >> 7
}

// SERCOM_I2CM.INTENSET: I2CM Interrupt Enable Set
func (o *SERCOM_I2CM_Type) SetINTENSET_MB(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *SERCOM_I2CM_Type) GetINTENSET_MB() uint8 {
	return volatile.LoadUint8(&o.INTENSET.Reg) & 0x1
}
func (o *SERCOM_I2CM_Type) SetINTENSET_SB(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_I2CM_Type) GetINTENSET_SB() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *SERCOM_I2CM_Type) SetINTENSET_ERROR(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_I2CM_Type) GetINTENSET_ERROR() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x80) >> 7
}

// SERCOM_I2CM.INTFLAG: I2CM Interrupt Flag Status and Clear
func (o *SERCOM_I2CM_Type) SetINTFLAG_MB(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *SERCOM_I2CM_Type) GetINTFLAG_MB() uint8 {
	return volatile.LoadUint8(&o.INTFLAG.Reg) & 0x1
}
func (o *SERCOM_I2CM_Type) SetINTFLAG_SB(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_I2CM_Type) GetINTFLAG_SB() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *SERCOM_I2CM_Type) SetINTFLAG_ERROR(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_I2CM_Type) GetINTFLAG_ERROR() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x80) >> 7
}

// SERCOM_I2CM.STATUS: I2CM Status
func (o *SERCOM_I2CM_Type) SetSTATUS_BUSERR(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *SERCOM_I2CM_Type) GetSTATUS_BUSERR() uint16 {
	return volatile.LoadUint16(&o.STATUS.Reg) & 0x1
}
func (o *SERCOM_I2CM_Type) SetSTATUS_ARBLOST(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_I2CM_Type) GetSTATUS_ARBLOST() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *SERCOM_I2CM_Type) SetSTATUS_RXNACK(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_I2CM_Type) GetSTATUS_RXNACK() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *SERCOM_I2CM_Type) SetSTATUS_BUSSTATE(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x30)|value<<4)
}
func (o *SERCOM_I2CM_Type) GetSTATUS_BUSSTATE() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x30) >> 4
}
func (o *SERCOM_I2CM_Type) SetSTATUS_LOWTOUT(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x40)|value<<6)
}
func (o *SERCOM_I2CM_Type) GetSTATUS_LOWTOUT() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x40) >> 6
}
func (o *SERCOM_I2CM_Type) SetSTATUS_CLKHOLD(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_I2CM_Type) GetSTATUS_CLKHOLD() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x80) >> 7
}
func (o *SERCOM_I2CM_Type) SetSTATUS_MEXTTOUT(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x100)|value<<8)
}
func (o *SERCOM_I2CM_Type) GetSTATUS_MEXTTOUT() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x100) >> 8
}
func (o *SERCOM_I2CM_Type) SetSTATUS_SEXTTOUT(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x200)|value<<9)
}
func (o *SERCOM_I2CM_Type) GetSTATUS_SEXTTOUT() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x200) >> 9
}
func (o *SERCOM_I2CM_Type) SetSTATUS_LENERR(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x400)|value<<10)
}
func (o *SERCOM_I2CM_Type) GetSTATUS_LENERR() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x400) >> 10
}

// SERCOM_I2CM.SYNCBUSY: I2CM Synchronization Busy
func (o *SERCOM_I2CM_Type) SetSYNCBUSY_SWRST(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *SERCOM_I2CM_Type) GetSYNCBUSY_SWRST() uint32 {
	return volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x1
}
func (o *SERCOM_I2CM_Type) SetSYNCBUSY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_I2CM_Type) GetSYNCBUSY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x2) >> 1
}
func (o *SERCOM_I2CM_Type) SetSYNCBUSY_SYSOP(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_I2CM_Type) GetSYNCBUSY_SYSOP() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x4) >> 2
}
func (o *SERCOM_I2CM_Type) SetSYNCBUSY_LENGTH(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x10)|value<<4)
}
func (o *SERCOM_I2CM_Type) GetSYNCBUSY_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x10) >> 4
}

// SERCOM_I2CM.ADDR: I2CM Address
func (o *SERCOM_I2CM_Type) SetADDR(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, volatile.LoadUint32(&o.ADDR.Reg)&^(0x7ff)|value)
}
func (o *SERCOM_I2CM_Type) GetADDR() uint32 {
	return volatile.LoadUint32(&o.ADDR.Reg) & 0x7ff
}
func (o *SERCOM_I2CM_Type) SetADDR_LENEN(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, volatile.LoadUint32(&o.ADDR.Reg)&^(0x2000)|value<<13)
}
func (o *SERCOM_I2CM_Type) GetADDR_LENEN() uint32 {
	return (volatile.LoadUint32(&o.ADDR.Reg) & 0x2000) >> 13
}
func (o *SERCOM_I2CM_Type) SetADDR_HS(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, volatile.LoadUint32(&o.ADDR.Reg)&^(0x4000)|value<<14)
}
func (o *SERCOM_I2CM_Type) GetADDR_HS() uint32 {
	return (volatile.LoadUint32(&o.ADDR.Reg) & 0x4000) >> 14
}
func (o *SERCOM_I2CM_Type) SetADDR_TENBITEN(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, volatile.LoadUint32(&o.ADDR.Reg)&^(0x8000)|value<<15)
}
func (o *SERCOM_I2CM_Type) GetADDR_TENBITEN() uint32 {
	return (volatile.LoadUint32(&o.ADDR.Reg) & 0x8000) >> 15
}
func (o *SERCOM_I2CM_Type) SetADDR_LEN(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, volatile.LoadUint32(&o.ADDR.Reg)&^(0xff0000)|value<<16)
}
func (o *SERCOM_I2CM_Type) GetADDR_LEN() uint32 {
	return (volatile.LoadUint32(&o.ADDR.Reg) & 0xff0000) >> 16
}

// SERCOM_I2CM.DATA: I2CM Data
func (o *SERCOM_I2CM_Type) SetDATA(value uint8) {
	volatile.StoreUint8(&o.DATA.Reg, value)
}
func (o *SERCOM_I2CM_Type) GetDATA() uint8 {
	return volatile.LoadUint8(&o.DATA.Reg)
}

// SERCOM_I2CM.DBGCTRL: I2CM Debug Control
func (o *SERCOM_I2CM_Type) SetDBGCTRL_DBGSTOP(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x1)|value)
}
func (o *SERCOM_I2CM_Type) GetDBGCTRL_DBGSTOP() uint8 {
	return volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x1
}

// Serial Communication Interface - I2CS
type SERCOM_I2CS_Type struct {
	CTRLA    volatile.Register32 // 0x0
	CTRLB    volatile.Register32 // 0x4
	CTRLC    volatile.Register32 // 0x8
	_        [8]byte
	INTENCLR volatile.Register8 // 0x14
	_        byte
	INTENSET volatile.Register8 // 0x16
	_        byte
	INTFLAG  volatile.Register8 // 0x18
	_        byte
	STATUS   volatile.Register16 // 0x1A
	SYNCBUSY volatile.Register32 // 0x1C
	_        [2]byte
	LENGTH   volatile.Register16 // 0x22
	ADDR     volatile.Register32 // 0x24
	DATA     volatile.Register32 // 0x28
}

// SERCOM_I2CS.CTRLA: I2CS Control A
func (o *SERCOM_I2CS_Type) SetCTRLA_SWRST(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *SERCOM_I2CS_Type) GetCTRLA_SWRST() uint32 {
	return volatile.LoadUint32(&o.CTRLA.Reg) & 0x1
}
func (o *SERCOM_I2CS_Type) SetCTRLA_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_I2CS_Type) GetCTRLA_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *SERCOM_I2CS_Type) SetCTRLA_MODE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1c)|value<<2)
}
func (o *SERCOM_I2CS_Type) GetCTRLA_MODE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x1c) >> 2
}
func (o *SERCOM_I2CS_Type) SetCTRLA_RUNSTDBY(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_I2CS_Type) GetCTRLA_RUNSTDBY() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x80) >> 7
}
func (o *SERCOM_I2CS_Type) SetCTRLA_PINOUT(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x10000)|value<<16)
}
func (o *SERCOM_I2CS_Type) GetCTRLA_PINOUT() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x10000) >> 16
}
func (o *SERCOM_I2CS_Type) SetCTRLA_SDAHOLD(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x300000)|value<<20)
}
func (o *SERCOM_I2CS_Type) GetCTRLA_SDAHOLD() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x300000) >> 20
}
func (o *SERCOM_I2CS_Type) SetCTRLA_SEXTTOEN(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x800000)|value<<23)
}
func (o *SERCOM_I2CS_Type) GetCTRLA_SEXTTOEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x800000) >> 23
}
func (o *SERCOM_I2CS_Type) SetCTRLA_SPEED(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x3000000)|value<<24)
}
func (o *SERCOM_I2CS_Type) GetCTRLA_SPEED() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x3000000) >> 24
}
func (o *SERCOM_I2CS_Type) SetCTRLA_SCLSM(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x8000000)|value<<27)
}
func (o *SERCOM_I2CS_Type) GetCTRLA_SCLSM() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x8000000) >> 27
}
func (o *SERCOM_I2CS_Type) SetCTRLA_LOWTOUTEN(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x40000000)|value<<30)
}
func (o *SERCOM_I2CS_Type) GetCTRLA_LOWTOUTEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x40000000) >> 30
}

// SERCOM_I2CS.CTRLB: I2CS Control B
func (o *SERCOM_I2CS_Type) SetCTRLB_SMEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x100)|value<<8)
}
func (o *SERCOM_I2CS_Type) GetCTRLB_SMEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x100) >> 8
}
func (o *SERCOM_I2CS_Type) SetCTRLB_GCMD(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x200)|value<<9)
}
func (o *SERCOM_I2CS_Type) GetCTRLB_GCMD() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x200) >> 9
}
func (o *SERCOM_I2CS_Type) SetCTRLB_AACKEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x400)|value<<10)
}
func (o *SERCOM_I2CS_Type) GetCTRLB_AACKEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x400) >> 10
}
func (o *SERCOM_I2CS_Type) SetCTRLB_AMODE(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0xc000)|value<<14)
}
func (o *SERCOM_I2CS_Type) GetCTRLB_AMODE() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0xc000) >> 14
}
func (o *SERCOM_I2CS_Type) SetCTRLB_CMD(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x30000)|value<<16)
}
func (o *SERCOM_I2CS_Type) GetCTRLB_CMD() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x30000) >> 16
}
func (o *SERCOM_I2CS_Type) SetCTRLB_ACKACT(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x40000)|value<<18)
}
func (o *SERCOM_I2CS_Type) GetCTRLB_ACKACT() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x40000) >> 18
}

// SERCOM_I2CS.CTRLC: I2CS Control C
func (o *SERCOM_I2CS_Type) SetCTRLC_SDASETUP(value uint32) {
	volatile.StoreUint32(&o.CTRLC.Reg, volatile.LoadUint32(&o.CTRLC.Reg)&^(0xf)|value)
}
func (o *SERCOM_I2CS_Type) GetCTRLC_SDASETUP() uint32 {
	return volatile.LoadUint32(&o.CTRLC.Reg) & 0xf
}
func (o *SERCOM_I2CS_Type) SetCTRLC_DATA32B(value uint32) {
	volatile.StoreUint32(&o.CTRLC.Reg, volatile.LoadUint32(&o.CTRLC.Reg)&^(0x1000000)|value<<24)
}
func (o *SERCOM_I2CS_Type) GetCTRLC_DATA32B() uint32 {
	return (volatile.LoadUint32(&o.CTRLC.Reg) & 0x1000000) >> 24
}

// SERCOM_I2CS.INTENCLR: I2CS Interrupt Enable Clear
func (o *SERCOM_I2CS_Type) SetINTENCLR_PREC(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *SERCOM_I2CS_Type) GetINTENCLR_PREC() uint8 {
	return volatile.LoadUint8(&o.INTENCLR.Reg) & 0x1
}
func (o *SERCOM_I2CS_Type) SetINTENCLR_AMATCH(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_I2CS_Type) GetINTENCLR_AMATCH() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *SERCOM_I2CS_Type) SetINTENCLR_DRDY(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_I2CS_Type) GetINTENCLR_DRDY() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *SERCOM_I2CS_Type) SetINTENCLR_ERROR(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_I2CS_Type) GetINTENCLR_ERROR() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x80) >> 7
}

// SERCOM_I2CS.INTENSET: I2CS Interrupt Enable Set
func (o *SERCOM_I2CS_Type) SetINTENSET_PREC(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *SERCOM_I2CS_Type) GetINTENSET_PREC() uint8 {
	return volatile.LoadUint8(&o.INTENSET.Reg) & 0x1
}
func (o *SERCOM_I2CS_Type) SetINTENSET_AMATCH(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_I2CS_Type) GetINTENSET_AMATCH() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *SERCOM_I2CS_Type) SetINTENSET_DRDY(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_I2CS_Type) GetINTENSET_DRDY() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *SERCOM_I2CS_Type) SetINTENSET_ERROR(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_I2CS_Type) GetINTENSET_ERROR() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x80) >> 7
}

// SERCOM_I2CS.INTFLAG: I2CS Interrupt Flag Status and Clear
func (o *SERCOM_I2CS_Type) SetINTFLAG_PREC(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *SERCOM_I2CS_Type) GetINTFLAG_PREC() uint8 {
	return volatile.LoadUint8(&o.INTFLAG.Reg) & 0x1
}
func (o *SERCOM_I2CS_Type) SetINTFLAG_AMATCH(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_I2CS_Type) GetINTFLAG_AMATCH() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *SERCOM_I2CS_Type) SetINTFLAG_DRDY(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_I2CS_Type) GetINTFLAG_DRDY() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x4) >> 2
}
func (o *SERCOM_I2CS_Type) SetINTFLAG_ERROR(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_I2CS_Type) GetINTFLAG_ERROR() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x80) >> 7
}

// SERCOM_I2CS.STATUS: I2CS Status
func (o *SERCOM_I2CS_Type) SetSTATUS_BUSERR(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *SERCOM_I2CS_Type) GetSTATUS_BUSERR() uint16 {
	return volatile.LoadUint16(&o.STATUS.Reg) & 0x1
}
func (o *SERCOM_I2CS_Type) SetSTATUS_COLL(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_I2CS_Type) GetSTATUS_COLL() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *SERCOM_I2CS_Type) SetSTATUS_RXNACK(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_I2CS_Type) GetSTATUS_RXNACK() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *SERCOM_I2CS_Type) SetSTATUS_DIR(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *SERCOM_I2CS_Type) GetSTATUS_DIR() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x8) >> 3
}
func (o *SERCOM_I2CS_Type) SetSTATUS_SR(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x10)|value<<4)
}
func (o *SERCOM_I2CS_Type) GetSTATUS_SR() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x10) >> 4
}
func (o *SERCOM_I2CS_Type) SetSTATUS_LOWTOUT(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x40)|value<<6)
}
func (o *SERCOM_I2CS_Type) GetSTATUS_LOWTOUT() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x40) >> 6
}
func (o *SERCOM_I2CS_Type) SetSTATUS_CLKHOLD(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_I2CS_Type) GetSTATUS_CLKHOLD() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x80) >> 7
}
func (o *SERCOM_I2CS_Type) SetSTATUS_SEXTTOUT(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x200)|value<<9)
}
func (o *SERCOM_I2CS_Type) GetSTATUS_SEXTTOUT() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x200) >> 9
}
func (o *SERCOM_I2CS_Type) SetSTATUS_HS(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x400)|value<<10)
}
func (o *SERCOM_I2CS_Type) GetSTATUS_HS() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x400) >> 10
}
func (o *SERCOM_I2CS_Type) SetSTATUS_LENERR(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x800)|value<<11)
}
func (o *SERCOM_I2CS_Type) GetSTATUS_LENERR() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x800) >> 11
}

// SERCOM_I2CS.SYNCBUSY: I2CS Synchronization Busy
func (o *SERCOM_I2CS_Type) SetSYNCBUSY_SWRST(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *SERCOM_I2CS_Type) GetSYNCBUSY_SWRST() uint32 {
	return volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x1
}
func (o *SERCOM_I2CS_Type) SetSYNCBUSY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_I2CS_Type) GetSYNCBUSY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x2) >> 1
}
func (o *SERCOM_I2CS_Type) SetSYNCBUSY_LENGTH(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x10)|value<<4)
}
func (o *SERCOM_I2CS_Type) GetSYNCBUSY_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x10) >> 4
}

// SERCOM_I2CS.LENGTH: I2CS Length
func (o *SERCOM_I2CS_Type) SetLENGTH_LEN(value uint16) {
	volatile.StoreUint16(&o.LENGTH.Reg, volatile.LoadUint16(&o.LENGTH.Reg)&^(0xff)|value)
}
func (o *SERCOM_I2CS_Type) GetLENGTH_LEN() uint16 {
	return volatile.LoadUint16(&o.LENGTH.Reg) & 0xff
}
func (o *SERCOM_I2CS_Type) SetLENGTH_LENEN(value uint16) {
	volatile.StoreUint16(&o.LENGTH.Reg, volatile.LoadUint16(&o.LENGTH.Reg)&^(0x100)|value<<8)
}
func (o *SERCOM_I2CS_Type) GetLENGTH_LENEN() uint16 {
	return (volatile.LoadUint16(&o.LENGTH.Reg) & 0x100) >> 8
}

// SERCOM_I2CS.ADDR: I2CS Address
func (o *SERCOM_I2CS_Type) SetADDR_GENCEN(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, volatile.LoadUint32(&o.ADDR.Reg)&^(0x1)|value)
}
func (o *SERCOM_I2CS_Type) GetADDR_GENCEN() uint32 {
	return volatile.LoadUint32(&o.ADDR.Reg) & 0x1
}
func (o *SERCOM_I2CS_Type) SetADDR(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, volatile.LoadUint32(&o.ADDR.Reg)&^(0x7fe)|value<<1)
}
func (o *SERCOM_I2CS_Type) GetADDR() uint32 {
	return (volatile.LoadUint32(&o.ADDR.Reg) & 0x7fe) >> 1
}
func (o *SERCOM_I2CS_Type) SetADDR_TENBITEN(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, volatile.LoadUint32(&o.ADDR.Reg)&^(0x8000)|value<<15)
}
func (o *SERCOM_I2CS_Type) GetADDR_TENBITEN() uint32 {
	return (volatile.LoadUint32(&o.ADDR.Reg) & 0x8000) >> 15
}
func (o *SERCOM_I2CS_Type) SetADDR_ADDRMASK(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, volatile.LoadUint32(&o.ADDR.Reg)&^(0x7fe0000)|value<<17)
}
func (o *SERCOM_I2CS_Type) GetADDR_ADDRMASK() uint32 {
	return (volatile.LoadUint32(&o.ADDR.Reg) & 0x7fe0000) >> 17
}

// SERCOM_I2CS.DATA: I2CS Data
func (o *SERCOM_I2CS_Type) SetDATA(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, value)
}
func (o *SERCOM_I2CS_Type) GetDATA() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg)
}

// Serial Communication Interface - SPIS
type SERCOM_SPIS_Type struct {
	CTRLA    volatile.Register32 // 0x0
	CTRLB    volatile.Register32 // 0x4
	CTRLC    volatile.Register32 // 0x8
	BAUD     volatile.Register8  // 0xC
	_        [7]byte
	INTENCLR volatile.Register8 // 0x14
	_        byte
	INTENSET volatile.Register8 // 0x16
	_        byte
	INTFLAG  volatile.Register8 // 0x18
	_        byte
	STATUS   volatile.Register16 // 0x1A
	SYNCBUSY volatile.Register32 // 0x1C
	_        [2]byte
	LENGTH   volatile.Register16 // 0x22
	ADDR     volatile.Register32 // 0x24
	DATA     volatile.Register32 // 0x28
	_        [4]byte
	DBGCTRL  volatile.Register8 // 0x30
}

// SERCOM_SPIS.CTRLA: SPIS Control A
func (o *SERCOM_SPIS_Type) SetCTRLA_SWRST(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *SERCOM_SPIS_Type) GetCTRLA_SWRST() uint32 {
	return volatile.LoadUint32(&o.CTRLA.Reg) & 0x1
}
func (o *SERCOM_SPIS_Type) SetCTRLA_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_SPIS_Type) GetCTRLA_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *SERCOM_SPIS_Type) SetCTRLA_MODE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1c)|value<<2)
}
func (o *SERCOM_SPIS_Type) GetCTRLA_MODE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x1c) >> 2
}
func (o *SERCOM_SPIS_Type) SetCTRLA_RUNSTDBY(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_SPIS_Type) GetCTRLA_RUNSTDBY() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x80) >> 7
}
func (o *SERCOM_SPIS_Type) SetCTRLA_IBON(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x100)|value<<8)
}
func (o *SERCOM_SPIS_Type) GetCTRLA_IBON() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x100) >> 8
}
func (o *SERCOM_SPIS_Type) SetCTRLA_DOPO(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x30000)|value<<16)
}
func (o *SERCOM_SPIS_Type) GetCTRLA_DOPO() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x30000) >> 16
}
func (o *SERCOM_SPIS_Type) SetCTRLA_DIPO(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x300000)|value<<20)
}
func (o *SERCOM_SPIS_Type) GetCTRLA_DIPO() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x300000) >> 20
}
func (o *SERCOM_SPIS_Type) SetCTRLA_FORM(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0xf000000)|value<<24)
}
func (o *SERCOM_SPIS_Type) GetCTRLA_FORM() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0xf000000) >> 24
}
func (o *SERCOM_SPIS_Type) SetCTRLA_CPHA(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x10000000)|value<<28)
}
func (o *SERCOM_SPIS_Type) GetCTRLA_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x10000000) >> 28
}
func (o *SERCOM_SPIS_Type) SetCTRLA_CPOL(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x20000000)|value<<29)
}
func (o *SERCOM_SPIS_Type) GetCTRLA_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x20000000) >> 29
}
func (o *SERCOM_SPIS_Type) SetCTRLA_DORD(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x40000000)|value<<30)
}
func (o *SERCOM_SPIS_Type) GetCTRLA_DORD() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x40000000) >> 30
}

// SERCOM_SPIS.CTRLB: SPIS Control B
func (o *SERCOM_SPIS_Type) SetCTRLB_CHSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x7)|value)
}
func (o *SERCOM_SPIS_Type) GetCTRLB_CHSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLB.Reg) & 0x7
}
func (o *SERCOM_SPIS_Type) SetCTRLB_PLOADEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x40)|value<<6)
}
func (o *SERCOM_SPIS_Type) GetCTRLB_PLOADEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x40) >> 6
}
func (o *SERCOM_SPIS_Type) SetCTRLB_SSDE(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x200)|value<<9)
}
func (o *SERCOM_SPIS_Type) GetCTRLB_SSDE() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x200) >> 9
}
func (o *SERCOM_SPIS_Type) SetCTRLB_MSSEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x2000)|value<<13)
}
func (o *SERCOM_SPIS_Type) GetCTRLB_MSSEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x2000) >> 13
}
func (o *SERCOM_SPIS_Type) SetCTRLB_AMODE(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0xc000)|value<<14)
}
func (o *SERCOM_SPIS_Type) GetCTRLB_AMODE() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0xc000) >> 14
}
func (o *SERCOM_SPIS_Type) SetCTRLB_RXEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x20000)|value<<17)
}
func (o *SERCOM_SPIS_Type) GetCTRLB_RXEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x20000) >> 17
}

// SERCOM_SPIS.CTRLC: SPIS Control C
func (o *SERCOM_SPIS_Type) SetCTRLC_ICSPACE(value uint32) {
	volatile.StoreUint32(&o.CTRLC.Reg, volatile.LoadUint32(&o.CTRLC.Reg)&^(0x3f)|value)
}
func (o *SERCOM_SPIS_Type) GetCTRLC_ICSPACE() uint32 {
	return volatile.LoadUint32(&o.CTRLC.Reg) & 0x3f
}
func (o *SERCOM_SPIS_Type) SetCTRLC_DATA32B(value uint32) {
	volatile.StoreUint32(&o.CTRLC.Reg, volatile.LoadUint32(&o.CTRLC.Reg)&^(0x1000000)|value<<24)
}
func (o *SERCOM_SPIS_Type) GetCTRLC_DATA32B() uint32 {
	return (volatile.LoadUint32(&o.CTRLC.Reg) & 0x1000000) >> 24
}

// SERCOM_SPIS.BAUD: SPIS Baud Rate
func (o *SERCOM_SPIS_Type) SetBAUD(value uint8) {
	volatile.StoreUint8(&o.BAUD.Reg, value)
}
func (o *SERCOM_SPIS_Type) GetBAUD() uint8 {
	return volatile.LoadUint8(&o.BAUD.Reg)
}

// SERCOM_SPIS.INTENCLR: SPIS Interrupt Enable Clear
func (o *SERCOM_SPIS_Type) SetINTENCLR_DRE(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *SERCOM_SPIS_Type) GetINTENCLR_DRE() uint8 {
	return volatile.LoadUint8(&o.INTENCLR.Reg) & 0x1
}
func (o *SERCOM_SPIS_Type) SetINTENCLR_TXC(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_SPIS_Type) GetINTENCLR_TXC() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *SERCOM_SPIS_Type) SetINTENCLR_RXC(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_SPIS_Type) GetINTENCLR_RXC() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *SERCOM_SPIS_Type) SetINTENCLR_SSL(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *SERCOM_SPIS_Type) GetINTENCLR_SSL() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *SERCOM_SPIS_Type) SetINTENCLR_ERROR(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_SPIS_Type) GetINTENCLR_ERROR() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x80) >> 7
}

// SERCOM_SPIS.INTENSET: SPIS Interrupt Enable Set
func (o *SERCOM_SPIS_Type) SetINTENSET_DRE(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *SERCOM_SPIS_Type) GetINTENSET_DRE() uint8 {
	return volatile.LoadUint8(&o.INTENSET.Reg) & 0x1
}
func (o *SERCOM_SPIS_Type) SetINTENSET_TXC(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_SPIS_Type) GetINTENSET_TXC() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *SERCOM_SPIS_Type) SetINTENSET_RXC(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_SPIS_Type) GetINTENSET_RXC() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *SERCOM_SPIS_Type) SetINTENSET_SSL(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *SERCOM_SPIS_Type) GetINTENSET_SSL() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *SERCOM_SPIS_Type) SetINTENSET_ERROR(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_SPIS_Type) GetINTENSET_ERROR() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x80) >> 7
}

// SERCOM_SPIS.INTFLAG: SPIS Interrupt Flag Status and Clear
func (o *SERCOM_SPIS_Type) SetINTFLAG_DRE(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *SERCOM_SPIS_Type) GetINTFLAG_DRE() uint8 {
	return volatile.LoadUint8(&o.INTFLAG.Reg) & 0x1
}
func (o *SERCOM_SPIS_Type) SetINTFLAG_TXC(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_SPIS_Type) GetINTFLAG_TXC() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *SERCOM_SPIS_Type) SetINTFLAG_RXC(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_SPIS_Type) GetINTFLAG_RXC() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x4) >> 2
}
func (o *SERCOM_SPIS_Type) SetINTFLAG_SSL(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x8)|value<<3)
}
func (o *SERCOM_SPIS_Type) GetINTFLAG_SSL() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x8) >> 3
}
func (o *SERCOM_SPIS_Type) SetINTFLAG_ERROR(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_SPIS_Type) GetINTFLAG_ERROR() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x80) >> 7
}

// SERCOM_SPIS.STATUS: SPIS Status
func (o *SERCOM_SPIS_Type) SetSTATUS_BUFOVF(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_SPIS_Type) GetSTATUS_BUFOVF() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *SERCOM_SPIS_Type) SetSTATUS_LENERR(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x800)|value<<11)
}
func (o *SERCOM_SPIS_Type) GetSTATUS_LENERR() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x800) >> 11
}

// SERCOM_SPIS.SYNCBUSY: SPIS Synchronization Busy
func (o *SERCOM_SPIS_Type) SetSYNCBUSY_SWRST(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *SERCOM_SPIS_Type) GetSYNCBUSY_SWRST() uint32 {
	return volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x1
}
func (o *SERCOM_SPIS_Type) SetSYNCBUSY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_SPIS_Type) GetSYNCBUSY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x2) >> 1
}
func (o *SERCOM_SPIS_Type) SetSYNCBUSY_CTRLB(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_SPIS_Type) GetSYNCBUSY_CTRLB() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x4) >> 2
}
func (o *SERCOM_SPIS_Type) SetSYNCBUSY_LENGTH(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x10)|value<<4)
}
func (o *SERCOM_SPIS_Type) GetSYNCBUSY_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x10) >> 4
}

// SERCOM_SPIS.LENGTH: SPIS Length
func (o *SERCOM_SPIS_Type) SetLENGTH_LEN(value uint16) {
	volatile.StoreUint16(&o.LENGTH.Reg, volatile.LoadUint16(&o.LENGTH.Reg)&^(0xff)|value)
}
func (o *SERCOM_SPIS_Type) GetLENGTH_LEN() uint16 {
	return volatile.LoadUint16(&o.LENGTH.Reg) & 0xff
}
func (o *SERCOM_SPIS_Type) SetLENGTH_LENEN(value uint16) {
	volatile.StoreUint16(&o.LENGTH.Reg, volatile.LoadUint16(&o.LENGTH.Reg)&^(0x100)|value<<8)
}
func (o *SERCOM_SPIS_Type) GetLENGTH_LENEN() uint16 {
	return (volatile.LoadUint16(&o.LENGTH.Reg) & 0x100) >> 8
}

// SERCOM_SPIS.ADDR: SPIS Address
func (o *SERCOM_SPIS_Type) SetADDR(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, volatile.LoadUint32(&o.ADDR.Reg)&^(0xff)|value)
}
func (o *SERCOM_SPIS_Type) GetADDR() uint32 {
	return volatile.LoadUint32(&o.ADDR.Reg) & 0xff
}
func (o *SERCOM_SPIS_Type) SetADDR_ADDRMASK(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, volatile.LoadUint32(&o.ADDR.Reg)&^(0xff0000)|value<<16)
}
func (o *SERCOM_SPIS_Type) GetADDR_ADDRMASK() uint32 {
	return (volatile.LoadUint32(&o.ADDR.Reg) & 0xff0000) >> 16
}

// SERCOM_SPIS.DATA: SPIS Data
func (o *SERCOM_SPIS_Type) SetDATA(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, value)
}
func (o *SERCOM_SPIS_Type) GetDATA() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg)
}

// SERCOM_SPIS.DBGCTRL: SPIS Debug Control
func (o *SERCOM_SPIS_Type) SetDBGCTRL_DBGSTOP(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x1)|value)
}
func (o *SERCOM_SPIS_Type) GetDBGCTRL_DBGSTOP() uint8 {
	return volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x1
}

// Serial Communication Interface - SPIM
type SERCOM_SPIM_Type struct {
	CTRLA    volatile.Register32 // 0x0
	CTRLB    volatile.Register32 // 0x4
	CTRLC    volatile.Register32 // 0x8
	BAUD     volatile.Register8  // 0xC
	_        [7]byte
	INTENCLR volatile.Register8 // 0x14
	_        byte
	INTENSET volatile.Register8 // 0x16
	_        byte
	INTFLAG  volatile.Register8 // 0x18
	_        byte
	STATUS   volatile.Register16 // 0x1A
	SYNCBUSY volatile.Register32 // 0x1C
	_        [2]byte
	LENGTH   volatile.Register16 // 0x22
	ADDR     volatile.Register32 // 0x24
	DATA     volatile.Register32 // 0x28
	_        [4]byte
	DBGCTRL  volatile.Register8 // 0x30
}

// SERCOM_SPIM.CTRLA: SPIM Control A
func (o *SERCOM_SPIM_Type) SetCTRLA_SWRST(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *SERCOM_SPIM_Type) GetCTRLA_SWRST() uint32 {
	return volatile.LoadUint32(&o.CTRLA.Reg) & 0x1
}
func (o *SERCOM_SPIM_Type) SetCTRLA_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_SPIM_Type) GetCTRLA_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *SERCOM_SPIM_Type) SetCTRLA_MODE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1c)|value<<2)
}
func (o *SERCOM_SPIM_Type) GetCTRLA_MODE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x1c) >> 2
}
func (o *SERCOM_SPIM_Type) SetCTRLA_RUNSTDBY(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_SPIM_Type) GetCTRLA_RUNSTDBY() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x80) >> 7
}
func (o *SERCOM_SPIM_Type) SetCTRLA_IBON(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x100)|value<<8)
}
func (o *SERCOM_SPIM_Type) GetCTRLA_IBON() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x100) >> 8
}
func (o *SERCOM_SPIM_Type) SetCTRLA_DOPO(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x30000)|value<<16)
}
func (o *SERCOM_SPIM_Type) GetCTRLA_DOPO() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x30000) >> 16
}
func (o *SERCOM_SPIM_Type) SetCTRLA_DIPO(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x300000)|value<<20)
}
func (o *SERCOM_SPIM_Type) GetCTRLA_DIPO() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x300000) >> 20
}
func (o *SERCOM_SPIM_Type) SetCTRLA_FORM(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0xf000000)|value<<24)
}
func (o *SERCOM_SPIM_Type) GetCTRLA_FORM() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0xf000000) >> 24
}
func (o *SERCOM_SPIM_Type) SetCTRLA_CPHA(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x10000000)|value<<28)
}
func (o *SERCOM_SPIM_Type) GetCTRLA_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x10000000) >> 28
}
func (o *SERCOM_SPIM_Type) SetCTRLA_CPOL(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x20000000)|value<<29)
}
func (o *SERCOM_SPIM_Type) GetCTRLA_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x20000000) >> 29
}
func (o *SERCOM_SPIM_Type) SetCTRLA_DORD(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x40000000)|value<<30)
}
func (o *SERCOM_SPIM_Type) GetCTRLA_DORD() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x40000000) >> 30
}

// SERCOM_SPIM.CTRLB: SPIM Control B
func (o *SERCOM_SPIM_Type) SetCTRLB_CHSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x7)|value)
}
func (o *SERCOM_SPIM_Type) GetCTRLB_CHSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLB.Reg) & 0x7
}
func (o *SERCOM_SPIM_Type) SetCTRLB_PLOADEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x40)|value<<6)
}
func (o *SERCOM_SPIM_Type) GetCTRLB_PLOADEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x40) >> 6
}
func (o *SERCOM_SPIM_Type) SetCTRLB_SSDE(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x200)|value<<9)
}
func (o *SERCOM_SPIM_Type) GetCTRLB_SSDE() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x200) >> 9
}
func (o *SERCOM_SPIM_Type) SetCTRLB_MSSEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x2000)|value<<13)
}
func (o *SERCOM_SPIM_Type) GetCTRLB_MSSEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x2000) >> 13
}
func (o *SERCOM_SPIM_Type) SetCTRLB_AMODE(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0xc000)|value<<14)
}
func (o *SERCOM_SPIM_Type) GetCTRLB_AMODE() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0xc000) >> 14
}
func (o *SERCOM_SPIM_Type) SetCTRLB_RXEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x20000)|value<<17)
}
func (o *SERCOM_SPIM_Type) GetCTRLB_RXEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x20000) >> 17
}

// SERCOM_SPIM.CTRLC: SPIM Control C
func (o *SERCOM_SPIM_Type) SetCTRLC_ICSPACE(value uint32) {
	volatile.StoreUint32(&o.CTRLC.Reg, volatile.LoadUint32(&o.CTRLC.Reg)&^(0x3f)|value)
}
func (o *SERCOM_SPIM_Type) GetCTRLC_ICSPACE() uint32 {
	return volatile.LoadUint32(&o.CTRLC.Reg) & 0x3f
}
func (o *SERCOM_SPIM_Type) SetCTRLC_DATA32B(value uint32) {
	volatile.StoreUint32(&o.CTRLC.Reg, volatile.LoadUint32(&o.CTRLC.Reg)&^(0x1000000)|value<<24)
}
func (o *SERCOM_SPIM_Type) GetCTRLC_DATA32B() uint32 {
	return (volatile.LoadUint32(&o.CTRLC.Reg) & 0x1000000) >> 24
}

// SERCOM_SPIM.BAUD: SPIM Baud Rate
func (o *SERCOM_SPIM_Type) SetBAUD(value uint8) {
	volatile.StoreUint8(&o.BAUD.Reg, value)
}
func (o *SERCOM_SPIM_Type) GetBAUD() uint8 {
	return volatile.LoadUint8(&o.BAUD.Reg)
}

// SERCOM_SPIM.INTENCLR: SPIM Interrupt Enable Clear
func (o *SERCOM_SPIM_Type) SetINTENCLR_DRE(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *SERCOM_SPIM_Type) GetINTENCLR_DRE() uint8 {
	return volatile.LoadUint8(&o.INTENCLR.Reg) & 0x1
}
func (o *SERCOM_SPIM_Type) SetINTENCLR_TXC(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_SPIM_Type) GetINTENCLR_TXC() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *SERCOM_SPIM_Type) SetINTENCLR_RXC(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_SPIM_Type) GetINTENCLR_RXC() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *SERCOM_SPIM_Type) SetINTENCLR_SSL(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *SERCOM_SPIM_Type) GetINTENCLR_SSL() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *SERCOM_SPIM_Type) SetINTENCLR_ERROR(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_SPIM_Type) GetINTENCLR_ERROR() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x80) >> 7
}

// SERCOM_SPIM.INTENSET: SPIM Interrupt Enable Set
func (o *SERCOM_SPIM_Type) SetINTENSET_DRE(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *SERCOM_SPIM_Type) GetINTENSET_DRE() uint8 {
	return volatile.LoadUint8(&o.INTENSET.Reg) & 0x1
}
func (o *SERCOM_SPIM_Type) SetINTENSET_TXC(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_SPIM_Type) GetINTENSET_TXC() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *SERCOM_SPIM_Type) SetINTENSET_RXC(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_SPIM_Type) GetINTENSET_RXC() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *SERCOM_SPIM_Type) SetINTENSET_SSL(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *SERCOM_SPIM_Type) GetINTENSET_SSL() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *SERCOM_SPIM_Type) SetINTENSET_ERROR(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_SPIM_Type) GetINTENSET_ERROR() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x80) >> 7
}

// SERCOM_SPIM.INTFLAG: SPIM Interrupt Flag Status and Clear
func (o *SERCOM_SPIM_Type) SetINTFLAG_DRE(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *SERCOM_SPIM_Type) GetINTFLAG_DRE() uint8 {
	return volatile.LoadUint8(&o.INTFLAG.Reg) & 0x1
}
func (o *SERCOM_SPIM_Type) SetINTFLAG_TXC(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_SPIM_Type) GetINTFLAG_TXC() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *SERCOM_SPIM_Type) SetINTFLAG_RXC(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_SPIM_Type) GetINTFLAG_RXC() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x4) >> 2
}
func (o *SERCOM_SPIM_Type) SetINTFLAG_SSL(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x8)|value<<3)
}
func (o *SERCOM_SPIM_Type) GetINTFLAG_SSL() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x8) >> 3
}
func (o *SERCOM_SPIM_Type) SetINTFLAG_ERROR(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_SPIM_Type) GetINTFLAG_ERROR() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x80) >> 7
}

// SERCOM_SPIM.STATUS: SPIM Status
func (o *SERCOM_SPIM_Type) SetSTATUS_BUFOVF(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_SPIM_Type) GetSTATUS_BUFOVF() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *SERCOM_SPIM_Type) SetSTATUS_LENERR(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x800)|value<<11)
}
func (o *SERCOM_SPIM_Type) GetSTATUS_LENERR() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x800) >> 11
}

// SERCOM_SPIM.SYNCBUSY: SPIM Synchronization Busy
func (o *SERCOM_SPIM_Type) SetSYNCBUSY_SWRST(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *SERCOM_SPIM_Type) GetSYNCBUSY_SWRST() uint32 {
	return volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x1
}
func (o *SERCOM_SPIM_Type) SetSYNCBUSY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_SPIM_Type) GetSYNCBUSY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x2) >> 1
}
func (o *SERCOM_SPIM_Type) SetSYNCBUSY_CTRLB(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_SPIM_Type) GetSYNCBUSY_CTRLB() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x4) >> 2
}
func (o *SERCOM_SPIM_Type) SetSYNCBUSY_LENGTH(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x10)|value<<4)
}
func (o *SERCOM_SPIM_Type) GetSYNCBUSY_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x10) >> 4
}

// SERCOM_SPIM.LENGTH: SPIM Length
func (o *SERCOM_SPIM_Type) SetLENGTH_LEN(value uint16) {
	volatile.StoreUint16(&o.LENGTH.Reg, volatile.LoadUint16(&o.LENGTH.Reg)&^(0xff)|value)
}
func (o *SERCOM_SPIM_Type) GetLENGTH_LEN() uint16 {
	return volatile.LoadUint16(&o.LENGTH.Reg) & 0xff
}
func (o *SERCOM_SPIM_Type) SetLENGTH_LENEN(value uint16) {
	volatile.StoreUint16(&o.LENGTH.Reg, volatile.LoadUint16(&o.LENGTH.Reg)&^(0x100)|value<<8)
}
func (o *SERCOM_SPIM_Type) GetLENGTH_LENEN() uint16 {
	return (volatile.LoadUint16(&o.LENGTH.Reg) & 0x100) >> 8
}

// SERCOM_SPIM.ADDR: SPIM Address
func (o *SERCOM_SPIM_Type) SetADDR(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, volatile.LoadUint32(&o.ADDR.Reg)&^(0xff)|value)
}
func (o *SERCOM_SPIM_Type) GetADDR() uint32 {
	return volatile.LoadUint32(&o.ADDR.Reg) & 0xff
}
func (o *SERCOM_SPIM_Type) SetADDR_ADDRMASK(value uint32) {
	volatile.StoreUint32(&o.ADDR.Reg, volatile.LoadUint32(&o.ADDR.Reg)&^(0xff0000)|value<<16)
}
func (o *SERCOM_SPIM_Type) GetADDR_ADDRMASK() uint32 {
	return (volatile.LoadUint32(&o.ADDR.Reg) & 0xff0000) >> 16
}

// SERCOM_SPIM.DATA: SPIM Data
func (o *SERCOM_SPIM_Type) SetDATA(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, value)
}
func (o *SERCOM_SPIM_Type) GetDATA() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg)
}

// SERCOM_SPIM.DBGCTRL: SPIM Debug Control
func (o *SERCOM_SPIM_Type) SetDBGCTRL_DBGSTOP(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x1)|value)
}
func (o *SERCOM_SPIM_Type) GetDBGCTRL_DBGSTOP() uint8 {
	return volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x1
}

// Serial Communication Interface - USART_EXT
type SERCOM_USART_EXT_Type struct {
	CTRLA    volatile.Register32 // 0x0
	CTRLB    volatile.Register32 // 0x4
	CTRLC    volatile.Register32 // 0x8
	BAUD     volatile.Register16 // 0xC
	RXPL     volatile.Register8  // 0xE
	_        [5]byte
	INTENCLR volatile.Register8 // 0x14
	_        byte
	INTENSET volatile.Register8 // 0x16
	_        byte
	INTFLAG  volatile.Register8 // 0x18
	_        byte
	STATUS   volatile.Register16 // 0x1A
	SYNCBUSY volatile.Register32 // 0x1C
	RXERRCNT volatile.Register8  // 0x20
	_        byte
	LENGTH   volatile.Register16 // 0x22
	_        [4]byte
	DATA     volatile.Register32 // 0x28
	_        [4]byte
	DBGCTRL  volatile.Register8 // 0x30
}

// SERCOM_USART_EXT.CTRLA: USART_EXT Control A
func (o *SERCOM_USART_EXT_Type) SetCTRLA_SWRST(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLA_SWRST() uint32 {
	return volatile.LoadUint32(&o.CTRLA.Reg) & 0x1
}
func (o *SERCOM_USART_EXT_Type) SetCTRLA_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLA_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *SERCOM_USART_EXT_Type) SetCTRLA_MODE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1c)|value<<2)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLA_MODE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x1c) >> 2
}
func (o *SERCOM_USART_EXT_Type) SetCTRLA_RUNSTDBY(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLA_RUNSTDBY() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x80) >> 7
}
func (o *SERCOM_USART_EXT_Type) SetCTRLA_IBON(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x100)|value<<8)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLA_IBON() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x100) >> 8
}
func (o *SERCOM_USART_EXT_Type) SetCTRLA_TXINV(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x200)|value<<9)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLA_TXINV() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x200) >> 9
}
func (o *SERCOM_USART_EXT_Type) SetCTRLA_RXINV(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x400)|value<<10)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLA_RXINV() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x400) >> 10
}
func (o *SERCOM_USART_EXT_Type) SetCTRLA_SAMPR(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0xe000)|value<<13)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLA_SAMPR() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0xe000) >> 13
}
func (o *SERCOM_USART_EXT_Type) SetCTRLA_TXPO(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x30000)|value<<16)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLA_TXPO() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x30000) >> 16
}
func (o *SERCOM_USART_EXT_Type) SetCTRLA_RXPO(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x300000)|value<<20)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLA_RXPO() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x300000) >> 20
}
func (o *SERCOM_USART_EXT_Type) SetCTRLA_SAMPA(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0xc00000)|value<<22)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLA_SAMPA() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0xc00000) >> 22
}
func (o *SERCOM_USART_EXT_Type) SetCTRLA_FORM(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0xf000000)|value<<24)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLA_FORM() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0xf000000) >> 24
}
func (o *SERCOM_USART_EXT_Type) SetCTRLA_CMODE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x10000000)|value<<28)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLA_CMODE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x10000000) >> 28
}
func (o *SERCOM_USART_EXT_Type) SetCTRLA_CPOL(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x20000000)|value<<29)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLA_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x20000000) >> 29
}
func (o *SERCOM_USART_EXT_Type) SetCTRLA_DORD(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x40000000)|value<<30)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLA_DORD() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x40000000) >> 30
}

// SERCOM_USART_EXT.CTRLB: USART_EXT Control B
func (o *SERCOM_USART_EXT_Type) SetCTRLB_CHSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x7)|value)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLB_CHSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLB.Reg) & 0x7
}
func (o *SERCOM_USART_EXT_Type) SetCTRLB_SBMODE(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x40)|value<<6)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLB_SBMODE() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x40) >> 6
}
func (o *SERCOM_USART_EXT_Type) SetCTRLB_COLDEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x100)|value<<8)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLB_COLDEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x100) >> 8
}
func (o *SERCOM_USART_EXT_Type) SetCTRLB_SFDE(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x200)|value<<9)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLB_SFDE() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x200) >> 9
}
func (o *SERCOM_USART_EXT_Type) SetCTRLB_ENC(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x400)|value<<10)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLB_ENC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x400) >> 10
}
func (o *SERCOM_USART_EXT_Type) SetCTRLB_PMODE(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x2000)|value<<13)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLB_PMODE() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x2000) >> 13
}
func (o *SERCOM_USART_EXT_Type) SetCTRLB_TXEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x10000)|value<<16)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLB_TXEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x10000) >> 16
}
func (o *SERCOM_USART_EXT_Type) SetCTRLB_RXEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x20000)|value<<17)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLB_RXEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x20000) >> 17
}
func (o *SERCOM_USART_EXT_Type) SetCTRLB_LINCMD(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x3000000)|value<<24)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLB_LINCMD() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x3000000) >> 24
}

// SERCOM_USART_EXT.CTRLC: USART_EXT Control C
func (o *SERCOM_USART_EXT_Type) SetCTRLC_GTIME(value uint32) {
	volatile.StoreUint32(&o.CTRLC.Reg, volatile.LoadUint32(&o.CTRLC.Reg)&^(0x7)|value)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLC_GTIME() uint32 {
	return volatile.LoadUint32(&o.CTRLC.Reg) & 0x7
}
func (o *SERCOM_USART_EXT_Type) SetCTRLC_BRKLEN(value uint32) {
	volatile.StoreUint32(&o.CTRLC.Reg, volatile.LoadUint32(&o.CTRLC.Reg)&^(0x300)|value<<8)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLC_BRKLEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLC.Reg) & 0x300) >> 8
}
func (o *SERCOM_USART_EXT_Type) SetCTRLC_HDRDLY(value uint32) {
	volatile.StoreUint32(&o.CTRLC.Reg, volatile.LoadUint32(&o.CTRLC.Reg)&^(0xc00)|value<<10)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLC_HDRDLY() uint32 {
	return (volatile.LoadUint32(&o.CTRLC.Reg) & 0xc00) >> 10
}
func (o *SERCOM_USART_EXT_Type) SetCTRLC_INACK(value uint32) {
	volatile.StoreUint32(&o.CTRLC.Reg, volatile.LoadUint32(&o.CTRLC.Reg)&^(0x10000)|value<<16)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLC_INACK() uint32 {
	return (volatile.LoadUint32(&o.CTRLC.Reg) & 0x10000) >> 16
}
func (o *SERCOM_USART_EXT_Type) SetCTRLC_DSNACK(value uint32) {
	volatile.StoreUint32(&o.CTRLC.Reg, volatile.LoadUint32(&o.CTRLC.Reg)&^(0x20000)|value<<17)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLC_DSNACK() uint32 {
	return (volatile.LoadUint32(&o.CTRLC.Reg) & 0x20000) >> 17
}
func (o *SERCOM_USART_EXT_Type) SetCTRLC_MAXITER(value uint32) {
	volatile.StoreUint32(&o.CTRLC.Reg, volatile.LoadUint32(&o.CTRLC.Reg)&^(0x700000)|value<<20)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLC_MAXITER() uint32 {
	return (volatile.LoadUint32(&o.CTRLC.Reg) & 0x700000) >> 20
}
func (o *SERCOM_USART_EXT_Type) SetCTRLC_DATA32B(value uint32) {
	volatile.StoreUint32(&o.CTRLC.Reg, volatile.LoadUint32(&o.CTRLC.Reg)&^(0x3000000)|value<<24)
}
func (o *SERCOM_USART_EXT_Type) GetCTRLC_DATA32B() uint32 {
	return (volatile.LoadUint32(&o.CTRLC.Reg) & 0x3000000) >> 24
}

// SERCOM_USART_EXT.BAUD: USART_EXT Baud Rate
func (o *SERCOM_USART_EXT_Type) SetBAUD(value uint16) {
	volatile.StoreUint16(&o.BAUD.Reg, value)
}
func (o *SERCOM_USART_EXT_Type) GetBAUD() uint16 {
	return volatile.LoadUint16(&o.BAUD.Reg)
}

// SERCOM_USART_EXT.RXPL: USART_EXT Receive Pulse Length
func (o *SERCOM_USART_EXT_Type) SetRXPL(value uint8) {
	volatile.StoreUint8(&o.RXPL.Reg, value)
}
func (o *SERCOM_USART_EXT_Type) GetRXPL() uint8 {
	return volatile.LoadUint8(&o.RXPL.Reg)
}

// SERCOM_USART_EXT.INTENCLR: USART_EXT Interrupt Enable Clear
func (o *SERCOM_USART_EXT_Type) SetINTENCLR_DRE(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *SERCOM_USART_EXT_Type) GetINTENCLR_DRE() uint8 {
	return volatile.LoadUint8(&o.INTENCLR.Reg) & 0x1
}
func (o *SERCOM_USART_EXT_Type) SetINTENCLR_TXC(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_USART_EXT_Type) GetINTENCLR_TXC() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *SERCOM_USART_EXT_Type) SetINTENCLR_RXC(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_USART_EXT_Type) GetINTENCLR_RXC() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *SERCOM_USART_EXT_Type) SetINTENCLR_RXS(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *SERCOM_USART_EXT_Type) GetINTENCLR_RXS() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *SERCOM_USART_EXT_Type) SetINTENCLR_CTSIC(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *SERCOM_USART_EXT_Type) GetINTENCLR_CTSIC() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *SERCOM_USART_EXT_Type) SetINTENCLR_RXBRK(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *SERCOM_USART_EXT_Type) GetINTENCLR_RXBRK() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *SERCOM_USART_EXT_Type) SetINTENCLR_ERROR(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_USART_EXT_Type) GetINTENCLR_ERROR() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x80) >> 7
}

// SERCOM_USART_EXT.INTENSET: USART_EXT Interrupt Enable Set
func (o *SERCOM_USART_EXT_Type) SetINTENSET_DRE(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *SERCOM_USART_EXT_Type) GetINTENSET_DRE() uint8 {
	return volatile.LoadUint8(&o.INTENSET.Reg) & 0x1
}
func (o *SERCOM_USART_EXT_Type) SetINTENSET_TXC(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_USART_EXT_Type) GetINTENSET_TXC() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *SERCOM_USART_EXT_Type) SetINTENSET_RXC(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_USART_EXT_Type) GetINTENSET_RXC() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *SERCOM_USART_EXT_Type) SetINTENSET_RXS(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *SERCOM_USART_EXT_Type) GetINTENSET_RXS() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *SERCOM_USART_EXT_Type) SetINTENSET_CTSIC(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *SERCOM_USART_EXT_Type) GetINTENSET_CTSIC() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *SERCOM_USART_EXT_Type) SetINTENSET_RXBRK(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *SERCOM_USART_EXT_Type) GetINTENSET_RXBRK() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *SERCOM_USART_EXT_Type) SetINTENSET_ERROR(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_USART_EXT_Type) GetINTENSET_ERROR() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x80) >> 7
}

// SERCOM_USART_EXT.INTFLAG: USART_EXT Interrupt Flag Status and Clear
func (o *SERCOM_USART_EXT_Type) SetINTFLAG_DRE(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *SERCOM_USART_EXT_Type) GetINTFLAG_DRE() uint8 {
	return volatile.LoadUint8(&o.INTFLAG.Reg) & 0x1
}
func (o *SERCOM_USART_EXT_Type) SetINTFLAG_TXC(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_USART_EXT_Type) GetINTFLAG_TXC() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *SERCOM_USART_EXT_Type) SetINTFLAG_RXC(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_USART_EXT_Type) GetINTFLAG_RXC() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x4) >> 2
}
func (o *SERCOM_USART_EXT_Type) SetINTFLAG_RXS(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x8)|value<<3)
}
func (o *SERCOM_USART_EXT_Type) GetINTFLAG_RXS() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x8) >> 3
}
func (o *SERCOM_USART_EXT_Type) SetINTFLAG_CTSIC(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x10)|value<<4)
}
func (o *SERCOM_USART_EXT_Type) GetINTFLAG_CTSIC() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x10) >> 4
}
func (o *SERCOM_USART_EXT_Type) SetINTFLAG_RXBRK(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x20)|value<<5)
}
func (o *SERCOM_USART_EXT_Type) GetINTFLAG_RXBRK() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x20) >> 5
}
func (o *SERCOM_USART_EXT_Type) SetINTFLAG_ERROR(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_USART_EXT_Type) GetINTFLAG_ERROR() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x80) >> 7
}

// SERCOM_USART_EXT.STATUS: USART_EXT Status
func (o *SERCOM_USART_EXT_Type) SetSTATUS_PERR(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *SERCOM_USART_EXT_Type) GetSTATUS_PERR() uint16 {
	return volatile.LoadUint16(&o.STATUS.Reg) & 0x1
}
func (o *SERCOM_USART_EXT_Type) SetSTATUS_FERR(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_USART_EXT_Type) GetSTATUS_FERR() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *SERCOM_USART_EXT_Type) SetSTATUS_BUFOVF(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_USART_EXT_Type) GetSTATUS_BUFOVF() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *SERCOM_USART_EXT_Type) SetSTATUS_CTS(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *SERCOM_USART_EXT_Type) GetSTATUS_CTS() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x8) >> 3
}
func (o *SERCOM_USART_EXT_Type) SetSTATUS_ISF(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x10)|value<<4)
}
func (o *SERCOM_USART_EXT_Type) GetSTATUS_ISF() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x10) >> 4
}
func (o *SERCOM_USART_EXT_Type) SetSTATUS_COLL(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x20)|value<<5)
}
func (o *SERCOM_USART_EXT_Type) GetSTATUS_COLL() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x20) >> 5
}
func (o *SERCOM_USART_EXT_Type) SetSTATUS_TXE(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x40)|value<<6)
}
func (o *SERCOM_USART_EXT_Type) GetSTATUS_TXE() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x40) >> 6
}
func (o *SERCOM_USART_EXT_Type) SetSTATUS_ITER(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_USART_EXT_Type) GetSTATUS_ITER() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x80) >> 7
}

// SERCOM_USART_EXT.SYNCBUSY: USART_EXT Synchronization Busy
func (o *SERCOM_USART_EXT_Type) SetSYNCBUSY_SWRST(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *SERCOM_USART_EXT_Type) GetSYNCBUSY_SWRST() uint32 {
	return volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x1
}
func (o *SERCOM_USART_EXT_Type) SetSYNCBUSY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_USART_EXT_Type) GetSYNCBUSY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x2) >> 1
}
func (o *SERCOM_USART_EXT_Type) SetSYNCBUSY_CTRLB(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_USART_EXT_Type) GetSYNCBUSY_CTRLB() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x4) >> 2
}
func (o *SERCOM_USART_EXT_Type) SetSYNCBUSY_RXERRCNT(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x8)|value<<3)
}
func (o *SERCOM_USART_EXT_Type) GetSYNCBUSY_RXERRCNT() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x8) >> 3
}
func (o *SERCOM_USART_EXT_Type) SetSYNCBUSY_LENGTH(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x10)|value<<4)
}
func (o *SERCOM_USART_EXT_Type) GetSYNCBUSY_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x10) >> 4
}

// SERCOM_USART_EXT.LENGTH: USART_EXT Length
func (o *SERCOM_USART_EXT_Type) SetLENGTH_LEN(value uint16) {
	volatile.StoreUint16(&o.LENGTH.Reg, volatile.LoadUint16(&o.LENGTH.Reg)&^(0xff)|value)
}
func (o *SERCOM_USART_EXT_Type) GetLENGTH_LEN() uint16 {
	return volatile.LoadUint16(&o.LENGTH.Reg) & 0xff
}
func (o *SERCOM_USART_EXT_Type) SetLENGTH_LENEN(value uint16) {
	volatile.StoreUint16(&o.LENGTH.Reg, volatile.LoadUint16(&o.LENGTH.Reg)&^(0x300)|value<<8)
}
func (o *SERCOM_USART_EXT_Type) GetLENGTH_LENEN() uint16 {
	return (volatile.LoadUint16(&o.LENGTH.Reg) & 0x300) >> 8
}

// SERCOM_USART_EXT.DATA: USART_EXT Data
func (o *SERCOM_USART_EXT_Type) SetDATA(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, value)
}
func (o *SERCOM_USART_EXT_Type) GetDATA() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg)
}

// SERCOM_USART_EXT.DBGCTRL: USART_EXT Debug Control
func (o *SERCOM_USART_EXT_Type) SetDBGCTRL_DBGSTOP(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x1)|value)
}
func (o *SERCOM_USART_EXT_Type) GetDBGCTRL_DBGSTOP() uint8 {
	return volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x1
}

// Serial Communication Interface - USART_INT
type SERCOM_USART_INT_Type struct {
	CTRLA    volatile.Register32 // 0x0
	CTRLB    volatile.Register32 // 0x4
	CTRLC    volatile.Register32 // 0x8
	BAUD     volatile.Register16 // 0xC
	RXPL     volatile.Register8  // 0xE
	_        [5]byte
	INTENCLR volatile.Register8 // 0x14
	_        byte
	INTENSET volatile.Register8 // 0x16
	_        byte
	INTFLAG  volatile.Register8 // 0x18
	_        byte
	STATUS   volatile.Register16 // 0x1A
	SYNCBUSY volatile.Register32 // 0x1C
	RXERRCNT volatile.Register8  // 0x20
	_        byte
	LENGTH   volatile.Register16 // 0x22
	_        [4]byte
	DATA     volatile.Register32 // 0x28
	_        [4]byte
	DBGCTRL  volatile.Register8 // 0x30
}

// SERCOM_USART_INT.CTRLA: USART_INT Control A
func (o *SERCOM_USART_INT_Type) SetCTRLA_SWRST(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *SERCOM_USART_INT_Type) GetCTRLA_SWRST() uint32 {
	return volatile.LoadUint32(&o.CTRLA.Reg) & 0x1
}
func (o *SERCOM_USART_INT_Type) SetCTRLA_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_USART_INT_Type) GetCTRLA_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *SERCOM_USART_INT_Type) SetCTRLA_MODE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1c)|value<<2)
}
func (o *SERCOM_USART_INT_Type) GetCTRLA_MODE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x1c) >> 2
}
func (o *SERCOM_USART_INT_Type) SetCTRLA_RUNSTDBY(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_USART_INT_Type) GetCTRLA_RUNSTDBY() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x80) >> 7
}
func (o *SERCOM_USART_INT_Type) SetCTRLA_IBON(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x100)|value<<8)
}
func (o *SERCOM_USART_INT_Type) GetCTRLA_IBON() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x100) >> 8
}
func (o *SERCOM_USART_INT_Type) SetCTRLA_TXINV(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x200)|value<<9)
}
func (o *SERCOM_USART_INT_Type) GetCTRLA_TXINV() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x200) >> 9
}
func (o *SERCOM_USART_INT_Type) SetCTRLA_RXINV(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x400)|value<<10)
}
func (o *SERCOM_USART_INT_Type) GetCTRLA_RXINV() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x400) >> 10
}
func (o *SERCOM_USART_INT_Type) SetCTRLA_SAMPR(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0xe000)|value<<13)
}
func (o *SERCOM_USART_INT_Type) GetCTRLA_SAMPR() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0xe000) >> 13
}
func (o *SERCOM_USART_INT_Type) SetCTRLA_TXPO(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x30000)|value<<16)
}
func (o *SERCOM_USART_INT_Type) GetCTRLA_TXPO() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x30000) >> 16
}
func (o *SERCOM_USART_INT_Type) SetCTRLA_RXPO(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x300000)|value<<20)
}
func (o *SERCOM_USART_INT_Type) GetCTRLA_RXPO() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x300000) >> 20
}
func (o *SERCOM_USART_INT_Type) SetCTRLA_SAMPA(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0xc00000)|value<<22)
}
func (o *SERCOM_USART_INT_Type) GetCTRLA_SAMPA() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0xc00000) >> 22
}
func (o *SERCOM_USART_INT_Type) SetCTRLA_FORM(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0xf000000)|value<<24)
}
func (o *SERCOM_USART_INT_Type) GetCTRLA_FORM() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0xf000000) >> 24
}
func (o *SERCOM_USART_INT_Type) SetCTRLA_CMODE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x10000000)|value<<28)
}
func (o *SERCOM_USART_INT_Type) GetCTRLA_CMODE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x10000000) >> 28
}
func (o *SERCOM_USART_INT_Type) SetCTRLA_CPOL(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x20000000)|value<<29)
}
func (o *SERCOM_USART_INT_Type) GetCTRLA_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x20000000) >> 29
}
func (o *SERCOM_USART_INT_Type) SetCTRLA_DORD(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x40000000)|value<<30)
}
func (o *SERCOM_USART_INT_Type) GetCTRLA_DORD() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x40000000) >> 30
}

// SERCOM_USART_INT.CTRLB: USART_INT Control B
func (o *SERCOM_USART_INT_Type) SetCTRLB_CHSIZE(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x7)|value)
}
func (o *SERCOM_USART_INT_Type) GetCTRLB_CHSIZE() uint32 {
	return volatile.LoadUint32(&o.CTRLB.Reg) & 0x7
}
func (o *SERCOM_USART_INT_Type) SetCTRLB_SBMODE(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x40)|value<<6)
}
func (o *SERCOM_USART_INT_Type) GetCTRLB_SBMODE() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x40) >> 6
}
func (o *SERCOM_USART_INT_Type) SetCTRLB_COLDEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x100)|value<<8)
}
func (o *SERCOM_USART_INT_Type) GetCTRLB_COLDEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x100) >> 8
}
func (o *SERCOM_USART_INT_Type) SetCTRLB_SFDE(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x200)|value<<9)
}
func (o *SERCOM_USART_INT_Type) GetCTRLB_SFDE() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x200) >> 9
}
func (o *SERCOM_USART_INT_Type) SetCTRLB_ENC(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x400)|value<<10)
}
func (o *SERCOM_USART_INT_Type) GetCTRLB_ENC() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x400) >> 10
}
func (o *SERCOM_USART_INT_Type) SetCTRLB_PMODE(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x2000)|value<<13)
}
func (o *SERCOM_USART_INT_Type) GetCTRLB_PMODE() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x2000) >> 13
}
func (o *SERCOM_USART_INT_Type) SetCTRLB_TXEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x10000)|value<<16)
}
func (o *SERCOM_USART_INT_Type) GetCTRLB_TXEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x10000) >> 16
}
func (o *SERCOM_USART_INT_Type) SetCTRLB_RXEN(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x20000)|value<<17)
}
func (o *SERCOM_USART_INT_Type) GetCTRLB_RXEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x20000) >> 17
}
func (o *SERCOM_USART_INT_Type) SetCTRLB_LINCMD(value uint32) {
	volatile.StoreUint32(&o.CTRLB.Reg, volatile.LoadUint32(&o.CTRLB.Reg)&^(0x3000000)|value<<24)
}
func (o *SERCOM_USART_INT_Type) GetCTRLB_LINCMD() uint32 {
	return (volatile.LoadUint32(&o.CTRLB.Reg) & 0x3000000) >> 24
}

// SERCOM_USART_INT.CTRLC: USART_INT Control C
func (o *SERCOM_USART_INT_Type) SetCTRLC_GTIME(value uint32) {
	volatile.StoreUint32(&o.CTRLC.Reg, volatile.LoadUint32(&o.CTRLC.Reg)&^(0x7)|value)
}
func (o *SERCOM_USART_INT_Type) GetCTRLC_GTIME() uint32 {
	return volatile.LoadUint32(&o.CTRLC.Reg) & 0x7
}
func (o *SERCOM_USART_INT_Type) SetCTRLC_BRKLEN(value uint32) {
	volatile.StoreUint32(&o.CTRLC.Reg, volatile.LoadUint32(&o.CTRLC.Reg)&^(0x300)|value<<8)
}
func (o *SERCOM_USART_INT_Type) GetCTRLC_BRKLEN() uint32 {
	return (volatile.LoadUint32(&o.CTRLC.Reg) & 0x300) >> 8
}
func (o *SERCOM_USART_INT_Type) SetCTRLC_HDRDLY(value uint32) {
	volatile.StoreUint32(&o.CTRLC.Reg, volatile.LoadUint32(&o.CTRLC.Reg)&^(0xc00)|value<<10)
}
func (o *SERCOM_USART_INT_Type) GetCTRLC_HDRDLY() uint32 {
	return (volatile.LoadUint32(&o.CTRLC.Reg) & 0xc00) >> 10
}
func (o *SERCOM_USART_INT_Type) SetCTRLC_INACK(value uint32) {
	volatile.StoreUint32(&o.CTRLC.Reg, volatile.LoadUint32(&o.CTRLC.Reg)&^(0x10000)|value<<16)
}
func (o *SERCOM_USART_INT_Type) GetCTRLC_INACK() uint32 {
	return (volatile.LoadUint32(&o.CTRLC.Reg) & 0x10000) >> 16
}
func (o *SERCOM_USART_INT_Type) SetCTRLC_DSNACK(value uint32) {
	volatile.StoreUint32(&o.CTRLC.Reg, volatile.LoadUint32(&o.CTRLC.Reg)&^(0x20000)|value<<17)
}
func (o *SERCOM_USART_INT_Type) GetCTRLC_DSNACK() uint32 {
	return (volatile.LoadUint32(&o.CTRLC.Reg) & 0x20000) >> 17
}
func (o *SERCOM_USART_INT_Type) SetCTRLC_MAXITER(value uint32) {
	volatile.StoreUint32(&o.CTRLC.Reg, volatile.LoadUint32(&o.CTRLC.Reg)&^(0x700000)|value<<20)
}
func (o *SERCOM_USART_INT_Type) GetCTRLC_MAXITER() uint32 {
	return (volatile.LoadUint32(&o.CTRLC.Reg) & 0x700000) >> 20
}
func (o *SERCOM_USART_INT_Type) SetCTRLC_DATA32B(value uint32) {
	volatile.StoreUint32(&o.CTRLC.Reg, volatile.LoadUint32(&o.CTRLC.Reg)&^(0x3000000)|value<<24)
}
func (o *SERCOM_USART_INT_Type) GetCTRLC_DATA32B() uint32 {
	return (volatile.LoadUint32(&o.CTRLC.Reg) & 0x3000000) >> 24
}

// SERCOM_USART_INT.BAUD: USART_INT Baud Rate
func (o *SERCOM_USART_INT_Type) SetBAUD(value uint16) {
	volatile.StoreUint16(&o.BAUD.Reg, value)
}
func (o *SERCOM_USART_INT_Type) GetBAUD() uint16 {
	return volatile.LoadUint16(&o.BAUD.Reg)
}

// SERCOM_USART_INT.RXPL: USART_INT Receive Pulse Length
func (o *SERCOM_USART_INT_Type) SetRXPL(value uint8) {
	volatile.StoreUint8(&o.RXPL.Reg, value)
}
func (o *SERCOM_USART_INT_Type) GetRXPL() uint8 {
	return volatile.LoadUint8(&o.RXPL.Reg)
}

// SERCOM_USART_INT.INTENCLR: USART_INT Interrupt Enable Clear
func (o *SERCOM_USART_INT_Type) SetINTENCLR_DRE(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *SERCOM_USART_INT_Type) GetINTENCLR_DRE() uint8 {
	return volatile.LoadUint8(&o.INTENCLR.Reg) & 0x1
}
func (o *SERCOM_USART_INT_Type) SetINTENCLR_TXC(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_USART_INT_Type) GetINTENCLR_TXC() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *SERCOM_USART_INT_Type) SetINTENCLR_RXC(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_USART_INT_Type) GetINTENCLR_RXC() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *SERCOM_USART_INT_Type) SetINTENCLR_RXS(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *SERCOM_USART_INT_Type) GetINTENCLR_RXS() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *SERCOM_USART_INT_Type) SetINTENCLR_CTSIC(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *SERCOM_USART_INT_Type) GetINTENCLR_CTSIC() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *SERCOM_USART_INT_Type) SetINTENCLR_RXBRK(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *SERCOM_USART_INT_Type) GetINTENCLR_RXBRK() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *SERCOM_USART_INT_Type) SetINTENCLR_ERROR(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_USART_INT_Type) GetINTENCLR_ERROR() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x80) >> 7
}

// SERCOM_USART_INT.INTENSET: USART_INT Interrupt Enable Set
func (o *SERCOM_USART_INT_Type) SetINTENSET_DRE(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *SERCOM_USART_INT_Type) GetINTENSET_DRE() uint8 {
	return volatile.LoadUint8(&o.INTENSET.Reg) & 0x1
}
func (o *SERCOM_USART_INT_Type) SetINTENSET_TXC(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_USART_INT_Type) GetINTENSET_TXC() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *SERCOM_USART_INT_Type) SetINTENSET_RXC(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_USART_INT_Type) GetINTENSET_RXC() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *SERCOM_USART_INT_Type) SetINTENSET_RXS(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *SERCOM_USART_INT_Type) GetINTENSET_RXS() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *SERCOM_USART_INT_Type) SetINTENSET_CTSIC(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *SERCOM_USART_INT_Type) GetINTENSET_CTSIC() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *SERCOM_USART_INT_Type) SetINTENSET_RXBRK(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *SERCOM_USART_INT_Type) GetINTENSET_RXBRK() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *SERCOM_USART_INT_Type) SetINTENSET_ERROR(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_USART_INT_Type) GetINTENSET_ERROR() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x80) >> 7
}

// SERCOM_USART_INT.INTFLAG: USART_INT Interrupt Flag Status and Clear
func (o *SERCOM_USART_INT_Type) SetINTFLAG_DRE(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *SERCOM_USART_INT_Type) GetINTFLAG_DRE() uint8 {
	return volatile.LoadUint8(&o.INTFLAG.Reg) & 0x1
}
func (o *SERCOM_USART_INT_Type) SetINTFLAG_TXC(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_USART_INT_Type) GetINTFLAG_TXC() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *SERCOM_USART_INT_Type) SetINTFLAG_RXC(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_USART_INT_Type) GetINTFLAG_RXC() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x4) >> 2
}
func (o *SERCOM_USART_INT_Type) SetINTFLAG_RXS(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x8)|value<<3)
}
func (o *SERCOM_USART_INT_Type) GetINTFLAG_RXS() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x8) >> 3
}
func (o *SERCOM_USART_INT_Type) SetINTFLAG_CTSIC(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x10)|value<<4)
}
func (o *SERCOM_USART_INT_Type) GetINTFLAG_CTSIC() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x10) >> 4
}
func (o *SERCOM_USART_INT_Type) SetINTFLAG_RXBRK(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x20)|value<<5)
}
func (o *SERCOM_USART_INT_Type) GetINTFLAG_RXBRK() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x20) >> 5
}
func (o *SERCOM_USART_INT_Type) SetINTFLAG_ERROR(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_USART_INT_Type) GetINTFLAG_ERROR() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x80) >> 7
}

// SERCOM_USART_INT.STATUS: USART_INT Status
func (o *SERCOM_USART_INT_Type) SetSTATUS_PERR(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *SERCOM_USART_INT_Type) GetSTATUS_PERR() uint16 {
	return volatile.LoadUint16(&o.STATUS.Reg) & 0x1
}
func (o *SERCOM_USART_INT_Type) SetSTATUS_FERR(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_USART_INT_Type) GetSTATUS_FERR() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *SERCOM_USART_INT_Type) SetSTATUS_BUFOVF(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_USART_INT_Type) GetSTATUS_BUFOVF() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *SERCOM_USART_INT_Type) SetSTATUS_CTS(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *SERCOM_USART_INT_Type) GetSTATUS_CTS() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x8) >> 3
}
func (o *SERCOM_USART_INT_Type) SetSTATUS_ISF(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x10)|value<<4)
}
func (o *SERCOM_USART_INT_Type) GetSTATUS_ISF() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x10) >> 4
}
func (o *SERCOM_USART_INT_Type) SetSTATUS_COLL(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x20)|value<<5)
}
func (o *SERCOM_USART_INT_Type) GetSTATUS_COLL() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x20) >> 5
}
func (o *SERCOM_USART_INT_Type) SetSTATUS_TXE(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x40)|value<<6)
}
func (o *SERCOM_USART_INT_Type) GetSTATUS_TXE() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x40) >> 6
}
func (o *SERCOM_USART_INT_Type) SetSTATUS_ITER(value uint16) {
	volatile.StoreUint16(&o.STATUS.Reg, volatile.LoadUint16(&o.STATUS.Reg)&^(0x80)|value<<7)
}
func (o *SERCOM_USART_INT_Type) GetSTATUS_ITER() uint16 {
	return (volatile.LoadUint16(&o.STATUS.Reg) & 0x80) >> 7
}

// SERCOM_USART_INT.SYNCBUSY: USART_INT Synchronization Busy
func (o *SERCOM_USART_INT_Type) SetSYNCBUSY_SWRST(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *SERCOM_USART_INT_Type) GetSYNCBUSY_SWRST() uint32 {
	return volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x1
}
func (o *SERCOM_USART_INT_Type) SetSYNCBUSY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *SERCOM_USART_INT_Type) GetSYNCBUSY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x2) >> 1
}
func (o *SERCOM_USART_INT_Type) SetSYNCBUSY_CTRLB(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x4)|value<<2)
}
func (o *SERCOM_USART_INT_Type) GetSYNCBUSY_CTRLB() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x4) >> 2
}
func (o *SERCOM_USART_INT_Type) SetSYNCBUSY_RXERRCNT(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x8)|value<<3)
}
func (o *SERCOM_USART_INT_Type) GetSYNCBUSY_RXERRCNT() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x8) >> 3
}
func (o *SERCOM_USART_INT_Type) SetSYNCBUSY_LENGTH(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x10)|value<<4)
}
func (o *SERCOM_USART_INT_Type) GetSYNCBUSY_LENGTH() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x10) >> 4
}

// SERCOM_USART_INT.LENGTH: USART_INT Length
func (o *SERCOM_USART_INT_Type) SetLENGTH_LEN(value uint16) {
	volatile.StoreUint16(&o.LENGTH.Reg, volatile.LoadUint16(&o.LENGTH.Reg)&^(0xff)|value)
}
func (o *SERCOM_USART_INT_Type) GetLENGTH_LEN() uint16 {
	return volatile.LoadUint16(&o.LENGTH.Reg) & 0xff
}
func (o *SERCOM_USART_INT_Type) SetLENGTH_LENEN(value uint16) {
	volatile.StoreUint16(&o.LENGTH.Reg, volatile.LoadUint16(&o.LENGTH.Reg)&^(0x300)|value<<8)
}
func (o *SERCOM_USART_INT_Type) GetLENGTH_LENEN() uint16 {
	return (volatile.LoadUint16(&o.LENGTH.Reg) & 0x300) >> 8
}

// SERCOM_USART_INT.DATA: USART_INT Data
func (o *SERCOM_USART_INT_Type) SetDATA(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, value)
}
func (o *SERCOM_USART_INT_Type) GetDATA() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg)
}

// SERCOM_USART_INT.DBGCTRL: USART_INT Debug Control
func (o *SERCOM_USART_INT_Type) SetDBGCTRL_DBGSTOP(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x1)|value)
}
func (o *SERCOM_USART_INT_Type) GetDBGCTRL_DBGSTOP() uint8 {
	return volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x1
}

// Supply Controller
type SUPC_Type struct {
	INTENCLR volatile.Register32 // 0x0
	INTENSET volatile.Register32 // 0x4
	INTFLAG  volatile.Register32 // 0x8
	STATUS   volatile.Register32 // 0xC
	BOD33    volatile.Register32 // 0x10
	_        [4]byte
	VREG     volatile.Register32 // 0x18
	VREF     volatile.Register32 // 0x1C
	BBPS     volatile.Register32 // 0x20
	BKOUT    volatile.Register32 // 0x24
	BKIN     volatile.Register32 // 0x28
}

// SUPC.INTENCLR: Interrupt Enable Clear
func (o *SUPC_Type) SetINTENCLR_BOD33RDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *SUPC_Type) GetINTENCLR_BOD33RDY() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *SUPC_Type) SetINTENCLR_BOD33DET(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *SUPC_Type) GetINTENCLR_BOD33DET() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *SUPC_Type) SetINTENCLR_B33SRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *SUPC_Type) GetINTENCLR_B33SRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *SUPC_Type) SetINTENCLR_VREGRDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *SUPC_Type) GetINTENCLR_VREGRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *SUPC_Type) SetINTENCLR_VCORERDY(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400)|value<<10)
}
func (o *SUPC_Type) GetINTENCLR_VCORERDY() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400) >> 10
}

// SUPC.INTENSET: Interrupt Enable Set
func (o *SUPC_Type) SetINTENSET_BOD33RDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *SUPC_Type) GetINTENSET_BOD33RDY() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *SUPC_Type) SetINTENSET_BOD33DET(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *SUPC_Type) GetINTENSET_BOD33DET() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *SUPC_Type) SetINTENSET_B33SRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *SUPC_Type) GetINTENSET_B33SRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *SUPC_Type) SetINTENSET_VREGRDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *SUPC_Type) GetINTENSET_VREGRDY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *SUPC_Type) SetINTENSET_VCORERDY(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400)|value<<10)
}
func (o *SUPC_Type) GetINTENSET_VCORERDY() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400) >> 10
}

// SUPC.INTFLAG: Interrupt Flag Status and Clear
func (o *SUPC_Type) SetINTFLAG_BOD33RDY(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *SUPC_Type) GetINTFLAG_BOD33RDY() uint32 {
	return volatile.LoadUint32(&o.INTFLAG.Reg) & 0x1
}
func (o *SUPC_Type) SetINTFLAG_BOD33DET(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *SUPC_Type) GetINTFLAG_BOD33DET() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *SUPC_Type) SetINTFLAG_B33SRDY(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x4)|value<<2)
}
func (o *SUPC_Type) GetINTFLAG_B33SRDY() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x4) >> 2
}
func (o *SUPC_Type) SetINTFLAG_VREGRDY(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x100)|value<<8)
}
func (o *SUPC_Type) GetINTFLAG_VREGRDY() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x100) >> 8
}
func (o *SUPC_Type) SetINTFLAG_VCORERDY(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x400)|value<<10)
}
func (o *SUPC_Type) GetINTFLAG_VCORERDY() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x400) >> 10
}

// SUPC.STATUS: Power and Clocks Status
func (o *SUPC_Type) SetSTATUS_BOD33RDY(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *SUPC_Type) GetSTATUS_BOD33RDY() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *SUPC_Type) SetSTATUS_BOD33DET(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *SUPC_Type) GetSTATUS_BOD33DET() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *SUPC_Type) SetSTATUS_B33SRDY(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *SUPC_Type) GetSTATUS_B33SRDY() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *SUPC_Type) SetSTATUS_VREGRDY(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x100)|value<<8)
}
func (o *SUPC_Type) GetSTATUS_VREGRDY() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x100) >> 8
}
func (o *SUPC_Type) SetSTATUS_VCORERDY(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x400)|value<<10)
}
func (o *SUPC_Type) GetSTATUS_VCORERDY() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x400) >> 10
}

// SUPC.BOD33: BOD33 Control
func (o *SUPC_Type) SetBOD33_ENABLE(value uint32) {
	volatile.StoreUint32(&o.BOD33.Reg, volatile.LoadUint32(&o.BOD33.Reg)&^(0x2)|value<<1)
}
func (o *SUPC_Type) GetBOD33_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.BOD33.Reg) & 0x2) >> 1
}
func (o *SUPC_Type) SetBOD33_ACTION(value uint32) {
	volatile.StoreUint32(&o.BOD33.Reg, volatile.LoadUint32(&o.BOD33.Reg)&^(0xc)|value<<2)
}
func (o *SUPC_Type) GetBOD33_ACTION() uint32 {
	return (volatile.LoadUint32(&o.BOD33.Reg) & 0xc) >> 2
}
func (o *SUPC_Type) SetBOD33_STDBYCFG(value uint32) {
	volatile.StoreUint32(&o.BOD33.Reg, volatile.LoadUint32(&o.BOD33.Reg)&^(0x10)|value<<4)
}
func (o *SUPC_Type) GetBOD33_STDBYCFG() uint32 {
	return (volatile.LoadUint32(&o.BOD33.Reg) & 0x10) >> 4
}
func (o *SUPC_Type) SetBOD33_RUNSTDBY(value uint32) {
	volatile.StoreUint32(&o.BOD33.Reg, volatile.LoadUint32(&o.BOD33.Reg)&^(0x20)|value<<5)
}
func (o *SUPC_Type) GetBOD33_RUNSTDBY() uint32 {
	return (volatile.LoadUint32(&o.BOD33.Reg) & 0x20) >> 5
}
func (o *SUPC_Type) SetBOD33_RUNHIB(value uint32) {
	volatile.StoreUint32(&o.BOD33.Reg, volatile.LoadUint32(&o.BOD33.Reg)&^(0x40)|value<<6)
}
func (o *SUPC_Type) GetBOD33_RUNHIB() uint32 {
	return (volatile.LoadUint32(&o.BOD33.Reg) & 0x40) >> 6
}
func (o *SUPC_Type) SetBOD33_RUNBKUP(value uint32) {
	volatile.StoreUint32(&o.BOD33.Reg, volatile.LoadUint32(&o.BOD33.Reg)&^(0x80)|value<<7)
}
func (o *SUPC_Type) GetBOD33_RUNBKUP() uint32 {
	return (volatile.LoadUint32(&o.BOD33.Reg) & 0x80) >> 7
}
func (o *SUPC_Type) SetBOD33_HYST(value uint32) {
	volatile.StoreUint32(&o.BOD33.Reg, volatile.LoadUint32(&o.BOD33.Reg)&^(0xf00)|value<<8)
}
func (o *SUPC_Type) GetBOD33_HYST() uint32 {
	return (volatile.LoadUint32(&o.BOD33.Reg) & 0xf00) >> 8
}
func (o *SUPC_Type) SetBOD33_PSEL(value uint32) {
	volatile.StoreUint32(&o.BOD33.Reg, volatile.LoadUint32(&o.BOD33.Reg)&^(0x7000)|value<<12)
}
func (o *SUPC_Type) GetBOD33_PSEL() uint32 {
	return (volatile.LoadUint32(&o.BOD33.Reg) & 0x7000) >> 12
}
func (o *SUPC_Type) SetBOD33_LEVEL(value uint32) {
	volatile.StoreUint32(&o.BOD33.Reg, volatile.LoadUint32(&o.BOD33.Reg)&^(0xff0000)|value<<16)
}
func (o *SUPC_Type) GetBOD33_LEVEL() uint32 {
	return (volatile.LoadUint32(&o.BOD33.Reg) & 0xff0000) >> 16
}
func (o *SUPC_Type) SetBOD33_VBATLEVEL(value uint32) {
	volatile.StoreUint32(&o.BOD33.Reg, volatile.LoadUint32(&o.BOD33.Reg)&^(0xff000000)|value<<24)
}
func (o *SUPC_Type) GetBOD33_VBATLEVEL() uint32 {
	return (volatile.LoadUint32(&o.BOD33.Reg) & 0xff000000) >> 24
}

// SUPC.VREG: VREG Control
func (o *SUPC_Type) SetVREG_ENABLE(value uint32) {
	volatile.StoreUint32(&o.VREG.Reg, volatile.LoadUint32(&o.VREG.Reg)&^(0x2)|value<<1)
}
func (o *SUPC_Type) GetVREG_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.VREG.Reg) & 0x2) >> 1
}
func (o *SUPC_Type) SetVREG_SEL(value uint32) {
	volatile.StoreUint32(&o.VREG.Reg, volatile.LoadUint32(&o.VREG.Reg)&^(0x4)|value<<2)
}
func (o *SUPC_Type) GetVREG_SEL() uint32 {
	return (volatile.LoadUint32(&o.VREG.Reg) & 0x4) >> 2
}
func (o *SUPC_Type) SetVREG_RUNBKUP(value uint32) {
	volatile.StoreUint32(&o.VREG.Reg, volatile.LoadUint32(&o.VREG.Reg)&^(0x80)|value<<7)
}
func (o *SUPC_Type) GetVREG_RUNBKUP() uint32 {
	return (volatile.LoadUint32(&o.VREG.Reg) & 0x80) >> 7
}
func (o *SUPC_Type) SetVREG_VSEN(value uint32) {
	volatile.StoreUint32(&o.VREG.Reg, volatile.LoadUint32(&o.VREG.Reg)&^(0x10000)|value<<16)
}
func (o *SUPC_Type) GetVREG_VSEN() uint32 {
	return (volatile.LoadUint32(&o.VREG.Reg) & 0x10000) >> 16
}
func (o *SUPC_Type) SetVREG_VSPER(value uint32) {
	volatile.StoreUint32(&o.VREG.Reg, volatile.LoadUint32(&o.VREG.Reg)&^(0x7000000)|value<<24)
}
func (o *SUPC_Type) GetVREG_VSPER() uint32 {
	return (volatile.LoadUint32(&o.VREG.Reg) & 0x7000000) >> 24
}

// SUPC.VREF: VREF Control
func (o *SUPC_Type) SetVREF_TSEN(value uint32) {
	volatile.StoreUint32(&o.VREF.Reg, volatile.LoadUint32(&o.VREF.Reg)&^(0x2)|value<<1)
}
func (o *SUPC_Type) GetVREF_TSEN() uint32 {
	return (volatile.LoadUint32(&o.VREF.Reg) & 0x2) >> 1
}
func (o *SUPC_Type) SetVREF_VREFOE(value uint32) {
	volatile.StoreUint32(&o.VREF.Reg, volatile.LoadUint32(&o.VREF.Reg)&^(0x4)|value<<2)
}
func (o *SUPC_Type) GetVREF_VREFOE() uint32 {
	return (volatile.LoadUint32(&o.VREF.Reg) & 0x4) >> 2
}
func (o *SUPC_Type) SetVREF_TSSEL(value uint32) {
	volatile.StoreUint32(&o.VREF.Reg, volatile.LoadUint32(&o.VREF.Reg)&^(0x8)|value<<3)
}
func (o *SUPC_Type) GetVREF_TSSEL() uint32 {
	return (volatile.LoadUint32(&o.VREF.Reg) & 0x8) >> 3
}
func (o *SUPC_Type) SetVREF_RUNSTDBY(value uint32) {
	volatile.StoreUint32(&o.VREF.Reg, volatile.LoadUint32(&o.VREF.Reg)&^(0x40)|value<<6)
}
func (o *SUPC_Type) GetVREF_RUNSTDBY() uint32 {
	return (volatile.LoadUint32(&o.VREF.Reg) & 0x40) >> 6
}
func (o *SUPC_Type) SetVREF_ONDEMAND(value uint32) {
	volatile.StoreUint32(&o.VREF.Reg, volatile.LoadUint32(&o.VREF.Reg)&^(0x80)|value<<7)
}
func (o *SUPC_Type) GetVREF_ONDEMAND() uint32 {
	return (volatile.LoadUint32(&o.VREF.Reg) & 0x80) >> 7
}
func (o *SUPC_Type) SetVREF_SEL(value uint32) {
	volatile.StoreUint32(&o.VREF.Reg, volatile.LoadUint32(&o.VREF.Reg)&^(0xf0000)|value<<16)
}
func (o *SUPC_Type) GetVREF_SEL() uint32 {
	return (volatile.LoadUint32(&o.VREF.Reg) & 0xf0000) >> 16
}

// SUPC.BBPS: Battery Backup Power Switch
func (o *SUPC_Type) SetBBPS_CONF(value uint32) {
	volatile.StoreUint32(&o.BBPS.Reg, volatile.LoadUint32(&o.BBPS.Reg)&^(0x1)|value)
}
func (o *SUPC_Type) GetBBPS_CONF() uint32 {
	return volatile.LoadUint32(&o.BBPS.Reg) & 0x1
}
func (o *SUPC_Type) SetBBPS_WAKEEN(value uint32) {
	volatile.StoreUint32(&o.BBPS.Reg, volatile.LoadUint32(&o.BBPS.Reg)&^(0x4)|value<<2)
}
func (o *SUPC_Type) GetBBPS_WAKEEN() uint32 {
	return (volatile.LoadUint32(&o.BBPS.Reg) & 0x4) >> 2
}

// SUPC.BKOUT: Backup Output Control
func (o *SUPC_Type) SetBKOUT_ENOUT0(value uint32) {
	volatile.StoreUint32(&o.BKOUT.Reg, volatile.LoadUint32(&o.BKOUT.Reg)&^(0x1)|value)
}
func (o *SUPC_Type) GetBKOUT_ENOUT0() uint32 {
	return volatile.LoadUint32(&o.BKOUT.Reg) & 0x1
}
func (o *SUPC_Type) SetBKOUT_ENOUT1(value uint32) {
	volatile.StoreUint32(&o.BKOUT.Reg, volatile.LoadUint32(&o.BKOUT.Reg)&^(0x2)|value<<1)
}
func (o *SUPC_Type) GetBKOUT_ENOUT1() uint32 {
	return (volatile.LoadUint32(&o.BKOUT.Reg) & 0x2) >> 1
}
func (o *SUPC_Type) SetBKOUT_CLROUT0(value uint32) {
	volatile.StoreUint32(&o.BKOUT.Reg, volatile.LoadUint32(&o.BKOUT.Reg)&^(0x100)|value<<8)
}
func (o *SUPC_Type) GetBKOUT_CLROUT0() uint32 {
	return (volatile.LoadUint32(&o.BKOUT.Reg) & 0x100) >> 8
}
func (o *SUPC_Type) SetBKOUT_CLROUT1(value uint32) {
	volatile.StoreUint32(&o.BKOUT.Reg, volatile.LoadUint32(&o.BKOUT.Reg)&^(0x200)|value<<9)
}
func (o *SUPC_Type) GetBKOUT_CLROUT1() uint32 {
	return (volatile.LoadUint32(&o.BKOUT.Reg) & 0x200) >> 9
}
func (o *SUPC_Type) SetBKOUT_SETOUT0(value uint32) {
	volatile.StoreUint32(&o.BKOUT.Reg, volatile.LoadUint32(&o.BKOUT.Reg)&^(0x10000)|value<<16)
}
func (o *SUPC_Type) GetBKOUT_SETOUT0() uint32 {
	return (volatile.LoadUint32(&o.BKOUT.Reg) & 0x10000) >> 16
}
func (o *SUPC_Type) SetBKOUT_SETOUT1(value uint32) {
	volatile.StoreUint32(&o.BKOUT.Reg, volatile.LoadUint32(&o.BKOUT.Reg)&^(0x20000)|value<<17)
}
func (o *SUPC_Type) GetBKOUT_SETOUT1() uint32 {
	return (volatile.LoadUint32(&o.BKOUT.Reg) & 0x20000) >> 17
}
func (o *SUPC_Type) SetBKOUT_RTCTGLOUT0(value uint32) {
	volatile.StoreUint32(&o.BKOUT.Reg, volatile.LoadUint32(&o.BKOUT.Reg)&^(0x1000000)|value<<24)
}
func (o *SUPC_Type) GetBKOUT_RTCTGLOUT0() uint32 {
	return (volatile.LoadUint32(&o.BKOUT.Reg) & 0x1000000) >> 24
}
func (o *SUPC_Type) SetBKOUT_RTCTGLOUT1(value uint32) {
	volatile.StoreUint32(&o.BKOUT.Reg, volatile.LoadUint32(&o.BKOUT.Reg)&^(0x2000000)|value<<25)
}
func (o *SUPC_Type) GetBKOUT_RTCTGLOUT1() uint32 {
	return (volatile.LoadUint32(&o.BKOUT.Reg) & 0x2000000) >> 25
}

// SUPC.BKIN: Backup Input Control
func (o *SUPC_Type) SetBKIN_BKIN0(value uint32) {
	volatile.StoreUint32(&o.BKIN.Reg, volatile.LoadUint32(&o.BKIN.Reg)&^(0x1)|value)
}
func (o *SUPC_Type) GetBKIN_BKIN0() uint32 {
	return volatile.LoadUint32(&o.BKIN.Reg) & 0x1
}
func (o *SUPC_Type) SetBKIN_BKIN1(value uint32) {
	volatile.StoreUint32(&o.BKIN.Reg, volatile.LoadUint32(&o.BKIN.Reg)&^(0x2)|value<<1)
}
func (o *SUPC_Type) GetBKIN_BKIN1() uint32 {
	return (volatile.LoadUint32(&o.BKIN.Reg) & 0x2) >> 1
}

// Basic Timer Counter
type TC_Type struct {
}

// Basic Timer Counter - COUNT8
type TC_COUNT8_Type struct {
	CTRLA    volatile.Register32 // 0x0
	CTRLBCLR volatile.Register8  // 0x4
	CTRLBSET volatile.Register8  // 0x5
	EVCTRL   volatile.Register16 // 0x6
	INTENCLR volatile.Register8  // 0x8
	INTENSET volatile.Register8  // 0x9
	INTFLAG  volatile.Register8  // 0xA
	STATUS   volatile.Register8  // 0xB
	WAVE     volatile.Register8  // 0xC
	DRVCTRL  volatile.Register8  // 0xD
	_        byte
	DBGCTRL  volatile.Register8  // 0xF
	SYNCBUSY volatile.Register32 // 0x10
	COUNT    volatile.Register8  // 0x14
	_        [6]byte
	PER      volatile.Register8    // 0x1B
	CC       [2]volatile.Register8 // 0x1C
	_        [17]byte
	PERBUF   volatile.Register8    // 0x2F
	CCBUF    [2]volatile.Register8 // 0x30
}

// TC_COUNT8.CTRLA: Control A
func (o *TC_COUNT8_Type) SetCTRLA_SWRST(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *TC_COUNT8_Type) GetCTRLA_SWRST() uint32 {
	return volatile.LoadUint32(&o.CTRLA.Reg) & 0x1
}
func (o *TC_COUNT8_Type) SetCTRLA_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT8_Type) GetCTRLA_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *TC_COUNT8_Type) SetCTRLA_MODE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0xc)|value<<2)
}
func (o *TC_COUNT8_Type) GetCTRLA_MODE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0xc) >> 2
}
func (o *TC_COUNT8_Type) SetCTRLA_PRESCSYNC(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x30)|value<<4)
}
func (o *TC_COUNT8_Type) GetCTRLA_PRESCSYNC() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x30) >> 4
}
func (o *TC_COUNT8_Type) SetCTRLA_RUNSTDBY(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x40)|value<<6)
}
func (o *TC_COUNT8_Type) GetCTRLA_RUNSTDBY() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x40) >> 6
}
func (o *TC_COUNT8_Type) SetCTRLA_ONDEMAND(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x80)|value<<7)
}
func (o *TC_COUNT8_Type) GetCTRLA_ONDEMAND() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x80) >> 7
}
func (o *TC_COUNT8_Type) SetCTRLA_PRESCALER(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x700)|value<<8)
}
func (o *TC_COUNT8_Type) GetCTRLA_PRESCALER() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x700) >> 8
}
func (o *TC_COUNT8_Type) SetCTRLA_ALOCK(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x800)|value<<11)
}
func (o *TC_COUNT8_Type) GetCTRLA_ALOCK() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x800) >> 11
}
func (o *TC_COUNT8_Type) SetCTRLA_CAPTEN0(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x10000)|value<<16)
}
func (o *TC_COUNT8_Type) GetCTRLA_CAPTEN0() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x10000) >> 16
}
func (o *TC_COUNT8_Type) SetCTRLA_CAPTEN1(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x20000)|value<<17)
}
func (o *TC_COUNT8_Type) GetCTRLA_CAPTEN1() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x20000) >> 17
}
func (o *TC_COUNT8_Type) SetCTRLA_COPEN0(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x100000)|value<<20)
}
func (o *TC_COUNT8_Type) GetCTRLA_COPEN0() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x100000) >> 20
}
func (o *TC_COUNT8_Type) SetCTRLA_COPEN1(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x200000)|value<<21)
}
func (o *TC_COUNT8_Type) GetCTRLA_COPEN1() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x200000) >> 21
}
func (o *TC_COUNT8_Type) SetCTRLA_CAPTMODE0(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x3000000)|value<<24)
}
func (o *TC_COUNT8_Type) GetCTRLA_CAPTMODE0() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x3000000) >> 24
}
func (o *TC_COUNT8_Type) SetCTRLA_CAPTMODE1(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x18000000)|value<<27)
}
func (o *TC_COUNT8_Type) GetCTRLA_CAPTMODE1() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x18000000) >> 27
}

// TC_COUNT8.CTRLBCLR: Control B Clear
func (o *TC_COUNT8_Type) SetCTRLBCLR_DIR(value uint8) {
	volatile.StoreUint8(&o.CTRLBCLR.Reg, volatile.LoadUint8(&o.CTRLBCLR.Reg)&^(0x1)|value)
}
func (o *TC_COUNT8_Type) GetCTRLBCLR_DIR() uint8 {
	return volatile.LoadUint8(&o.CTRLBCLR.Reg) & 0x1
}
func (o *TC_COUNT8_Type) SetCTRLBCLR_LUPD(value uint8) {
	volatile.StoreUint8(&o.CTRLBCLR.Reg, volatile.LoadUint8(&o.CTRLBCLR.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT8_Type) GetCTRLBCLR_LUPD() uint8 {
	return (volatile.LoadUint8(&o.CTRLBCLR.Reg) & 0x2) >> 1
}
func (o *TC_COUNT8_Type) SetCTRLBCLR_ONESHOT(value uint8) {
	volatile.StoreUint8(&o.CTRLBCLR.Reg, volatile.LoadUint8(&o.CTRLBCLR.Reg)&^(0x4)|value<<2)
}
func (o *TC_COUNT8_Type) GetCTRLBCLR_ONESHOT() uint8 {
	return (volatile.LoadUint8(&o.CTRLBCLR.Reg) & 0x4) >> 2
}
func (o *TC_COUNT8_Type) SetCTRLBCLR_CMD(value uint8) {
	volatile.StoreUint8(&o.CTRLBCLR.Reg, volatile.LoadUint8(&o.CTRLBCLR.Reg)&^(0xe0)|value<<5)
}
func (o *TC_COUNT8_Type) GetCTRLBCLR_CMD() uint8 {
	return (volatile.LoadUint8(&o.CTRLBCLR.Reg) & 0xe0) >> 5
}

// TC_COUNT8.CTRLBSET: Control B Set
func (o *TC_COUNT8_Type) SetCTRLBSET_DIR(value uint8) {
	volatile.StoreUint8(&o.CTRLBSET.Reg, volatile.LoadUint8(&o.CTRLBSET.Reg)&^(0x1)|value)
}
func (o *TC_COUNT8_Type) GetCTRLBSET_DIR() uint8 {
	return volatile.LoadUint8(&o.CTRLBSET.Reg) & 0x1
}
func (o *TC_COUNT8_Type) SetCTRLBSET_LUPD(value uint8) {
	volatile.StoreUint8(&o.CTRLBSET.Reg, volatile.LoadUint8(&o.CTRLBSET.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT8_Type) GetCTRLBSET_LUPD() uint8 {
	return (volatile.LoadUint8(&o.CTRLBSET.Reg) & 0x2) >> 1
}
func (o *TC_COUNT8_Type) SetCTRLBSET_ONESHOT(value uint8) {
	volatile.StoreUint8(&o.CTRLBSET.Reg, volatile.LoadUint8(&o.CTRLBSET.Reg)&^(0x4)|value<<2)
}
func (o *TC_COUNT8_Type) GetCTRLBSET_ONESHOT() uint8 {
	return (volatile.LoadUint8(&o.CTRLBSET.Reg) & 0x4) >> 2
}
func (o *TC_COUNT8_Type) SetCTRLBSET_CMD(value uint8) {
	volatile.StoreUint8(&o.CTRLBSET.Reg, volatile.LoadUint8(&o.CTRLBSET.Reg)&^(0xe0)|value<<5)
}
func (o *TC_COUNT8_Type) GetCTRLBSET_CMD() uint8 {
	return (volatile.LoadUint8(&o.CTRLBSET.Reg) & 0xe0) >> 5
}

// TC_COUNT8.EVCTRL: Event Control
func (o *TC_COUNT8_Type) SetEVCTRL_EVACT(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x7)|value)
}
func (o *TC_COUNT8_Type) GetEVCTRL_EVACT() uint16 {
	return volatile.LoadUint16(&o.EVCTRL.Reg) & 0x7
}
func (o *TC_COUNT8_Type) SetEVCTRL_TCINV(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x10)|value<<4)
}
func (o *TC_COUNT8_Type) GetEVCTRL_TCINV() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x10) >> 4
}
func (o *TC_COUNT8_Type) SetEVCTRL_TCEI(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x20)|value<<5)
}
func (o *TC_COUNT8_Type) GetEVCTRL_TCEI() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x20) >> 5
}
func (o *TC_COUNT8_Type) SetEVCTRL_OVFEO(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x100)|value<<8)
}
func (o *TC_COUNT8_Type) GetEVCTRL_OVFEO() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x100) >> 8
}
func (o *TC_COUNT8_Type) SetEVCTRL_MCEO0(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *TC_COUNT8_Type) GetEVCTRL_MCEO0() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x1000) >> 12
}
func (o *TC_COUNT8_Type) SetEVCTRL_MCEO1(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *TC_COUNT8_Type) GetEVCTRL_MCEO1() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x2000) >> 13
}

// TC_COUNT8.INTENCLR: Interrupt Enable Clear
func (o *TC_COUNT8_Type) SetINTENCLR_OVF(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *TC_COUNT8_Type) GetINTENCLR_OVF() uint8 {
	return volatile.LoadUint8(&o.INTENCLR.Reg) & 0x1
}
func (o *TC_COUNT8_Type) SetINTENCLR_ERR(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT8_Type) GetINTENCLR_ERR() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *TC_COUNT8_Type) SetINTENCLR_MC0(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *TC_COUNT8_Type) GetINTENCLR_MC0() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *TC_COUNT8_Type) SetINTENCLR_MC1(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *TC_COUNT8_Type) GetINTENCLR_MC1() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x20) >> 5
}

// TC_COUNT8.INTENSET: Interrupt Enable Set
func (o *TC_COUNT8_Type) SetINTENSET_OVF(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *TC_COUNT8_Type) GetINTENSET_OVF() uint8 {
	return volatile.LoadUint8(&o.INTENSET.Reg) & 0x1
}
func (o *TC_COUNT8_Type) SetINTENSET_ERR(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT8_Type) GetINTENSET_ERR() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *TC_COUNT8_Type) SetINTENSET_MC0(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *TC_COUNT8_Type) GetINTENSET_MC0() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *TC_COUNT8_Type) SetINTENSET_MC1(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *TC_COUNT8_Type) GetINTENSET_MC1() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x20) >> 5
}

// TC_COUNT8.INTFLAG: Interrupt Flag Status and Clear
func (o *TC_COUNT8_Type) SetINTFLAG_OVF(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *TC_COUNT8_Type) GetINTFLAG_OVF() uint8 {
	return volatile.LoadUint8(&o.INTFLAG.Reg) & 0x1
}
func (o *TC_COUNT8_Type) SetINTFLAG_ERR(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT8_Type) GetINTFLAG_ERR() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *TC_COUNT8_Type) SetINTFLAG_MC0(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x10)|value<<4)
}
func (o *TC_COUNT8_Type) GetINTFLAG_MC0() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x10) >> 4
}
func (o *TC_COUNT8_Type) SetINTFLAG_MC1(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x20)|value<<5)
}
func (o *TC_COUNT8_Type) GetINTFLAG_MC1() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x20) >> 5
}

// TC_COUNT8.STATUS: Status
func (o *TC_COUNT8_Type) SetSTATUS_STOP(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *TC_COUNT8_Type) GetSTATUS_STOP() uint8 {
	return volatile.LoadUint8(&o.STATUS.Reg) & 0x1
}
func (o *TC_COUNT8_Type) SetSTATUS_SLAVE(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT8_Type) GetSTATUS_SLAVE() uint8 {
	return (volatile.LoadUint8(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *TC_COUNT8_Type) SetSTATUS_PERBUFV(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *TC_COUNT8_Type) GetSTATUS_PERBUFV() uint8 {
	return (volatile.LoadUint8(&o.STATUS.Reg) & 0x8) >> 3
}
func (o *TC_COUNT8_Type) SetSTATUS_CCBUFV0(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x10)|value<<4)
}
func (o *TC_COUNT8_Type) GetSTATUS_CCBUFV0() uint8 {
	return (volatile.LoadUint8(&o.STATUS.Reg) & 0x10) >> 4
}
func (o *TC_COUNT8_Type) SetSTATUS_CCBUFV1(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x20)|value<<5)
}
func (o *TC_COUNT8_Type) GetSTATUS_CCBUFV1() uint8 {
	return (volatile.LoadUint8(&o.STATUS.Reg) & 0x20) >> 5
}

// TC_COUNT8.WAVE: Waveform Generation Control
func (o *TC_COUNT8_Type) SetWAVE_WAVEGEN(value uint8) {
	volatile.StoreUint8(&o.WAVE.Reg, volatile.LoadUint8(&o.WAVE.Reg)&^(0x3)|value)
}
func (o *TC_COUNT8_Type) GetWAVE_WAVEGEN() uint8 {
	return volatile.LoadUint8(&o.WAVE.Reg) & 0x3
}

// TC_COUNT8.DRVCTRL: Control C
func (o *TC_COUNT8_Type) SetDRVCTRL_INVEN0(value uint8) {
	volatile.StoreUint8(&o.DRVCTRL.Reg, volatile.LoadUint8(&o.DRVCTRL.Reg)&^(0x1)|value)
}
func (o *TC_COUNT8_Type) GetDRVCTRL_INVEN0() uint8 {
	return volatile.LoadUint8(&o.DRVCTRL.Reg) & 0x1
}
func (o *TC_COUNT8_Type) SetDRVCTRL_INVEN1(value uint8) {
	volatile.StoreUint8(&o.DRVCTRL.Reg, volatile.LoadUint8(&o.DRVCTRL.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT8_Type) GetDRVCTRL_INVEN1() uint8 {
	return (volatile.LoadUint8(&o.DRVCTRL.Reg) & 0x2) >> 1
}

// TC_COUNT8.DBGCTRL: Debug Control
func (o *TC_COUNT8_Type) SetDBGCTRL_DBGRUN(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x1)|value)
}
func (o *TC_COUNT8_Type) GetDBGCTRL_DBGRUN() uint8 {
	return volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x1
}

// TC_COUNT8.SYNCBUSY: Synchronization Status
func (o *TC_COUNT8_Type) SetSYNCBUSY_SWRST(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *TC_COUNT8_Type) GetSYNCBUSY_SWRST() uint32 {
	return volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x1
}
func (o *TC_COUNT8_Type) SetSYNCBUSY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT8_Type) GetSYNCBUSY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x2) >> 1
}
func (o *TC_COUNT8_Type) SetSYNCBUSY_CTRLB(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x4)|value<<2)
}
func (o *TC_COUNT8_Type) GetSYNCBUSY_CTRLB() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x4) >> 2
}
func (o *TC_COUNT8_Type) SetSYNCBUSY_STATUS(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x8)|value<<3)
}
func (o *TC_COUNT8_Type) GetSYNCBUSY_STATUS() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x8) >> 3
}
func (o *TC_COUNT8_Type) SetSYNCBUSY_COUNT(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x10)|value<<4)
}
func (o *TC_COUNT8_Type) GetSYNCBUSY_COUNT() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x10) >> 4
}
func (o *TC_COUNT8_Type) SetSYNCBUSY_PER(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x20)|value<<5)
}
func (o *TC_COUNT8_Type) GetSYNCBUSY_PER() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x20) >> 5
}
func (o *TC_COUNT8_Type) SetSYNCBUSY_CC0(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x40)|value<<6)
}
func (o *TC_COUNT8_Type) GetSYNCBUSY_CC0() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x40) >> 6
}
func (o *TC_COUNT8_Type) SetSYNCBUSY_CC1(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x80)|value<<7)
}
func (o *TC_COUNT8_Type) GetSYNCBUSY_CC1() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x80) >> 7
}

// TC_COUNT8.COUNT: COUNT8 Count
func (o *TC_COUNT8_Type) SetCOUNT(value uint8) {
	volatile.StoreUint8(&o.COUNT.Reg, value)
}
func (o *TC_COUNT8_Type) GetCOUNT() uint8 {
	return volatile.LoadUint8(&o.COUNT.Reg)
}

// TC_COUNT8.PER: COUNT8 Period
func (o *TC_COUNT8_Type) SetPER(value uint8) {
	volatile.StoreUint8(&o.PER.Reg, value)
}
func (o *TC_COUNT8_Type) GetPER() uint8 {
	return volatile.LoadUint8(&o.PER.Reg)
}

// TC_COUNT8.CC: COUNT8 Compare and Capture
func (o *TC_COUNT8_Type) SetCC(idx int, value uint8) {
	volatile.StoreUint8(&o.CC[idx].Reg, value)
}
func (o *TC_COUNT8_Type) GetCC(idx int) uint8 {
	return volatile.LoadUint8(&o.CC[idx].Reg)
}

// TC_COUNT8.PERBUF: COUNT8 Period Buffer
func (o *TC_COUNT8_Type) SetPERBUF(value uint8) {
	volatile.StoreUint8(&o.PERBUF.Reg, value)
}
func (o *TC_COUNT8_Type) GetPERBUF() uint8 {
	return volatile.LoadUint8(&o.PERBUF.Reg)
}

// TC_COUNT8.CCBUF: COUNT8 Compare and Capture Buffer
func (o *TC_COUNT8_Type) SetCCBUF(idx int, value uint8) {
	volatile.StoreUint8(&o.CCBUF[idx].Reg, value)
}
func (o *TC_COUNT8_Type) GetCCBUF(idx int) uint8 {
	return volatile.LoadUint8(&o.CCBUF[idx].Reg)
}

// Basic Timer Counter - COUNT16
type TC_COUNT16_Type struct {
	CTRLA    volatile.Register32 // 0x0
	CTRLBCLR volatile.Register8  // 0x4
	CTRLBSET volatile.Register8  // 0x5
	EVCTRL   volatile.Register16 // 0x6
	INTENCLR volatile.Register8  // 0x8
	INTENSET volatile.Register8  // 0x9
	INTFLAG  volatile.Register8  // 0xA
	STATUS   volatile.Register8  // 0xB
	WAVE     volatile.Register8  // 0xC
	DRVCTRL  volatile.Register8  // 0xD
	_        byte
	DBGCTRL  volatile.Register8  // 0xF
	SYNCBUSY volatile.Register32 // 0x10
	COUNT    volatile.Register16 // 0x14
	_        [6]byte
	CC       [2]volatile.Register16 // 0x1C
	_        [16]byte
	CCBUF    [2]volatile.Register16 // 0x30
}

// TC_COUNT16.CTRLA: Control A
func (o *TC_COUNT16_Type) SetCTRLA_SWRST(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *TC_COUNT16_Type) GetCTRLA_SWRST() uint32 {
	return volatile.LoadUint32(&o.CTRLA.Reg) & 0x1
}
func (o *TC_COUNT16_Type) SetCTRLA_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT16_Type) GetCTRLA_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *TC_COUNT16_Type) SetCTRLA_MODE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0xc)|value<<2)
}
func (o *TC_COUNT16_Type) GetCTRLA_MODE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0xc) >> 2
}
func (o *TC_COUNT16_Type) SetCTRLA_PRESCSYNC(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x30)|value<<4)
}
func (o *TC_COUNT16_Type) GetCTRLA_PRESCSYNC() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x30) >> 4
}
func (o *TC_COUNT16_Type) SetCTRLA_RUNSTDBY(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x40)|value<<6)
}
func (o *TC_COUNT16_Type) GetCTRLA_RUNSTDBY() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x40) >> 6
}
func (o *TC_COUNT16_Type) SetCTRLA_ONDEMAND(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x80)|value<<7)
}
func (o *TC_COUNT16_Type) GetCTRLA_ONDEMAND() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x80) >> 7
}
func (o *TC_COUNT16_Type) SetCTRLA_PRESCALER(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x700)|value<<8)
}
func (o *TC_COUNT16_Type) GetCTRLA_PRESCALER() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x700) >> 8
}
func (o *TC_COUNT16_Type) SetCTRLA_ALOCK(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x800)|value<<11)
}
func (o *TC_COUNT16_Type) GetCTRLA_ALOCK() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x800) >> 11
}
func (o *TC_COUNT16_Type) SetCTRLA_CAPTEN0(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x10000)|value<<16)
}
func (o *TC_COUNT16_Type) GetCTRLA_CAPTEN0() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x10000) >> 16
}
func (o *TC_COUNT16_Type) SetCTRLA_CAPTEN1(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x20000)|value<<17)
}
func (o *TC_COUNT16_Type) GetCTRLA_CAPTEN1() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x20000) >> 17
}
func (o *TC_COUNT16_Type) SetCTRLA_COPEN0(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x100000)|value<<20)
}
func (o *TC_COUNT16_Type) GetCTRLA_COPEN0() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x100000) >> 20
}
func (o *TC_COUNT16_Type) SetCTRLA_COPEN1(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x200000)|value<<21)
}
func (o *TC_COUNT16_Type) GetCTRLA_COPEN1() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x200000) >> 21
}
func (o *TC_COUNT16_Type) SetCTRLA_CAPTMODE0(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x3000000)|value<<24)
}
func (o *TC_COUNT16_Type) GetCTRLA_CAPTMODE0() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x3000000) >> 24
}
func (o *TC_COUNT16_Type) SetCTRLA_CAPTMODE1(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x18000000)|value<<27)
}
func (o *TC_COUNT16_Type) GetCTRLA_CAPTMODE1() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x18000000) >> 27
}

// TC_COUNT16.CTRLBCLR: Control B Clear
func (o *TC_COUNT16_Type) SetCTRLBCLR_DIR(value uint8) {
	volatile.StoreUint8(&o.CTRLBCLR.Reg, volatile.LoadUint8(&o.CTRLBCLR.Reg)&^(0x1)|value)
}
func (o *TC_COUNT16_Type) GetCTRLBCLR_DIR() uint8 {
	return volatile.LoadUint8(&o.CTRLBCLR.Reg) & 0x1
}
func (o *TC_COUNT16_Type) SetCTRLBCLR_LUPD(value uint8) {
	volatile.StoreUint8(&o.CTRLBCLR.Reg, volatile.LoadUint8(&o.CTRLBCLR.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT16_Type) GetCTRLBCLR_LUPD() uint8 {
	return (volatile.LoadUint8(&o.CTRLBCLR.Reg) & 0x2) >> 1
}
func (o *TC_COUNT16_Type) SetCTRLBCLR_ONESHOT(value uint8) {
	volatile.StoreUint8(&o.CTRLBCLR.Reg, volatile.LoadUint8(&o.CTRLBCLR.Reg)&^(0x4)|value<<2)
}
func (o *TC_COUNT16_Type) GetCTRLBCLR_ONESHOT() uint8 {
	return (volatile.LoadUint8(&o.CTRLBCLR.Reg) & 0x4) >> 2
}
func (o *TC_COUNT16_Type) SetCTRLBCLR_CMD(value uint8) {
	volatile.StoreUint8(&o.CTRLBCLR.Reg, volatile.LoadUint8(&o.CTRLBCLR.Reg)&^(0xe0)|value<<5)
}
func (o *TC_COUNT16_Type) GetCTRLBCLR_CMD() uint8 {
	return (volatile.LoadUint8(&o.CTRLBCLR.Reg) & 0xe0) >> 5
}

// TC_COUNT16.CTRLBSET: Control B Set
func (o *TC_COUNT16_Type) SetCTRLBSET_DIR(value uint8) {
	volatile.StoreUint8(&o.CTRLBSET.Reg, volatile.LoadUint8(&o.CTRLBSET.Reg)&^(0x1)|value)
}
func (o *TC_COUNT16_Type) GetCTRLBSET_DIR() uint8 {
	return volatile.LoadUint8(&o.CTRLBSET.Reg) & 0x1
}
func (o *TC_COUNT16_Type) SetCTRLBSET_LUPD(value uint8) {
	volatile.StoreUint8(&o.CTRLBSET.Reg, volatile.LoadUint8(&o.CTRLBSET.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT16_Type) GetCTRLBSET_LUPD() uint8 {
	return (volatile.LoadUint8(&o.CTRLBSET.Reg) & 0x2) >> 1
}
func (o *TC_COUNT16_Type) SetCTRLBSET_ONESHOT(value uint8) {
	volatile.StoreUint8(&o.CTRLBSET.Reg, volatile.LoadUint8(&o.CTRLBSET.Reg)&^(0x4)|value<<2)
}
func (o *TC_COUNT16_Type) GetCTRLBSET_ONESHOT() uint8 {
	return (volatile.LoadUint8(&o.CTRLBSET.Reg) & 0x4) >> 2
}
func (o *TC_COUNT16_Type) SetCTRLBSET_CMD(value uint8) {
	volatile.StoreUint8(&o.CTRLBSET.Reg, volatile.LoadUint8(&o.CTRLBSET.Reg)&^(0xe0)|value<<5)
}
func (o *TC_COUNT16_Type) GetCTRLBSET_CMD() uint8 {
	return (volatile.LoadUint8(&o.CTRLBSET.Reg) & 0xe0) >> 5
}

// TC_COUNT16.EVCTRL: Event Control
func (o *TC_COUNT16_Type) SetEVCTRL_EVACT(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x7)|value)
}
func (o *TC_COUNT16_Type) GetEVCTRL_EVACT() uint16 {
	return volatile.LoadUint16(&o.EVCTRL.Reg) & 0x7
}
func (o *TC_COUNT16_Type) SetEVCTRL_TCINV(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x10)|value<<4)
}
func (o *TC_COUNT16_Type) GetEVCTRL_TCINV() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x10) >> 4
}
func (o *TC_COUNT16_Type) SetEVCTRL_TCEI(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x20)|value<<5)
}
func (o *TC_COUNT16_Type) GetEVCTRL_TCEI() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x20) >> 5
}
func (o *TC_COUNT16_Type) SetEVCTRL_OVFEO(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x100)|value<<8)
}
func (o *TC_COUNT16_Type) GetEVCTRL_OVFEO() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x100) >> 8
}
func (o *TC_COUNT16_Type) SetEVCTRL_MCEO0(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *TC_COUNT16_Type) GetEVCTRL_MCEO0() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x1000) >> 12
}
func (o *TC_COUNT16_Type) SetEVCTRL_MCEO1(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *TC_COUNT16_Type) GetEVCTRL_MCEO1() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x2000) >> 13
}

// TC_COUNT16.INTENCLR: Interrupt Enable Clear
func (o *TC_COUNT16_Type) SetINTENCLR_OVF(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *TC_COUNT16_Type) GetINTENCLR_OVF() uint8 {
	return volatile.LoadUint8(&o.INTENCLR.Reg) & 0x1
}
func (o *TC_COUNT16_Type) SetINTENCLR_ERR(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT16_Type) GetINTENCLR_ERR() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *TC_COUNT16_Type) SetINTENCLR_MC0(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *TC_COUNT16_Type) GetINTENCLR_MC0() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *TC_COUNT16_Type) SetINTENCLR_MC1(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *TC_COUNT16_Type) GetINTENCLR_MC1() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x20) >> 5
}

// TC_COUNT16.INTENSET: Interrupt Enable Set
func (o *TC_COUNT16_Type) SetINTENSET_OVF(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *TC_COUNT16_Type) GetINTENSET_OVF() uint8 {
	return volatile.LoadUint8(&o.INTENSET.Reg) & 0x1
}
func (o *TC_COUNT16_Type) SetINTENSET_ERR(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT16_Type) GetINTENSET_ERR() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *TC_COUNT16_Type) SetINTENSET_MC0(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *TC_COUNT16_Type) GetINTENSET_MC0() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *TC_COUNT16_Type) SetINTENSET_MC1(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *TC_COUNT16_Type) GetINTENSET_MC1() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x20) >> 5
}

// TC_COUNT16.INTFLAG: Interrupt Flag Status and Clear
func (o *TC_COUNT16_Type) SetINTFLAG_OVF(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *TC_COUNT16_Type) GetINTFLAG_OVF() uint8 {
	return volatile.LoadUint8(&o.INTFLAG.Reg) & 0x1
}
func (o *TC_COUNT16_Type) SetINTFLAG_ERR(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT16_Type) GetINTFLAG_ERR() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *TC_COUNT16_Type) SetINTFLAG_MC0(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x10)|value<<4)
}
func (o *TC_COUNT16_Type) GetINTFLAG_MC0() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x10) >> 4
}
func (o *TC_COUNT16_Type) SetINTFLAG_MC1(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x20)|value<<5)
}
func (o *TC_COUNT16_Type) GetINTFLAG_MC1() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x20) >> 5
}

// TC_COUNT16.STATUS: Status
func (o *TC_COUNT16_Type) SetSTATUS_STOP(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *TC_COUNT16_Type) GetSTATUS_STOP() uint8 {
	return volatile.LoadUint8(&o.STATUS.Reg) & 0x1
}
func (o *TC_COUNT16_Type) SetSTATUS_SLAVE(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT16_Type) GetSTATUS_SLAVE() uint8 {
	return (volatile.LoadUint8(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *TC_COUNT16_Type) SetSTATUS_PERBUFV(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *TC_COUNT16_Type) GetSTATUS_PERBUFV() uint8 {
	return (volatile.LoadUint8(&o.STATUS.Reg) & 0x8) >> 3
}
func (o *TC_COUNT16_Type) SetSTATUS_CCBUFV0(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x10)|value<<4)
}
func (o *TC_COUNT16_Type) GetSTATUS_CCBUFV0() uint8 {
	return (volatile.LoadUint8(&o.STATUS.Reg) & 0x10) >> 4
}
func (o *TC_COUNT16_Type) SetSTATUS_CCBUFV1(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x20)|value<<5)
}
func (o *TC_COUNT16_Type) GetSTATUS_CCBUFV1() uint8 {
	return (volatile.LoadUint8(&o.STATUS.Reg) & 0x20) >> 5
}

// TC_COUNT16.WAVE: Waveform Generation Control
func (o *TC_COUNT16_Type) SetWAVE_WAVEGEN(value uint8) {
	volatile.StoreUint8(&o.WAVE.Reg, volatile.LoadUint8(&o.WAVE.Reg)&^(0x3)|value)
}
func (o *TC_COUNT16_Type) GetWAVE_WAVEGEN() uint8 {
	return volatile.LoadUint8(&o.WAVE.Reg) & 0x3
}

// TC_COUNT16.DRVCTRL: Control C
func (o *TC_COUNT16_Type) SetDRVCTRL_INVEN0(value uint8) {
	volatile.StoreUint8(&o.DRVCTRL.Reg, volatile.LoadUint8(&o.DRVCTRL.Reg)&^(0x1)|value)
}
func (o *TC_COUNT16_Type) GetDRVCTRL_INVEN0() uint8 {
	return volatile.LoadUint8(&o.DRVCTRL.Reg) & 0x1
}
func (o *TC_COUNT16_Type) SetDRVCTRL_INVEN1(value uint8) {
	volatile.StoreUint8(&o.DRVCTRL.Reg, volatile.LoadUint8(&o.DRVCTRL.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT16_Type) GetDRVCTRL_INVEN1() uint8 {
	return (volatile.LoadUint8(&o.DRVCTRL.Reg) & 0x2) >> 1
}

// TC_COUNT16.DBGCTRL: Debug Control
func (o *TC_COUNT16_Type) SetDBGCTRL_DBGRUN(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x1)|value)
}
func (o *TC_COUNT16_Type) GetDBGCTRL_DBGRUN() uint8 {
	return volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x1
}

// TC_COUNT16.SYNCBUSY: Synchronization Status
func (o *TC_COUNT16_Type) SetSYNCBUSY_SWRST(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *TC_COUNT16_Type) GetSYNCBUSY_SWRST() uint32 {
	return volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x1
}
func (o *TC_COUNT16_Type) SetSYNCBUSY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT16_Type) GetSYNCBUSY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x2) >> 1
}
func (o *TC_COUNT16_Type) SetSYNCBUSY_CTRLB(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x4)|value<<2)
}
func (o *TC_COUNT16_Type) GetSYNCBUSY_CTRLB() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x4) >> 2
}
func (o *TC_COUNT16_Type) SetSYNCBUSY_STATUS(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x8)|value<<3)
}
func (o *TC_COUNT16_Type) GetSYNCBUSY_STATUS() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x8) >> 3
}
func (o *TC_COUNT16_Type) SetSYNCBUSY_COUNT(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x10)|value<<4)
}
func (o *TC_COUNT16_Type) GetSYNCBUSY_COUNT() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x10) >> 4
}
func (o *TC_COUNT16_Type) SetSYNCBUSY_PER(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x20)|value<<5)
}
func (o *TC_COUNT16_Type) GetSYNCBUSY_PER() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x20) >> 5
}
func (o *TC_COUNT16_Type) SetSYNCBUSY_CC0(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x40)|value<<6)
}
func (o *TC_COUNT16_Type) GetSYNCBUSY_CC0() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x40) >> 6
}
func (o *TC_COUNT16_Type) SetSYNCBUSY_CC1(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x80)|value<<7)
}
func (o *TC_COUNT16_Type) GetSYNCBUSY_CC1() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x80) >> 7
}

// TC_COUNT16.COUNT: COUNT16 Count
func (o *TC_COUNT16_Type) SetCOUNT(value uint16) {
	volatile.StoreUint16(&o.COUNT.Reg, value)
}
func (o *TC_COUNT16_Type) GetCOUNT() uint16 {
	return volatile.LoadUint16(&o.COUNT.Reg)
}

// TC_COUNT16.CC: COUNT16 Compare and Capture
func (o *TC_COUNT16_Type) SetCC(idx int, value uint16) {
	volatile.StoreUint16(&o.CC[idx].Reg, value)
}
func (o *TC_COUNT16_Type) GetCC(idx int) uint16 {
	return volatile.LoadUint16(&o.CC[idx].Reg)
}

// TC_COUNT16.CCBUF: COUNT16 Compare and Capture Buffer
func (o *TC_COUNT16_Type) SetCCBUF(idx int, value uint16) {
	volatile.StoreUint16(&o.CCBUF[idx].Reg, value)
}
func (o *TC_COUNT16_Type) GetCCBUF(idx int) uint16 {
	return volatile.LoadUint16(&o.CCBUF[idx].Reg)
}

// Basic Timer Counter - COUNT32
type TC_COUNT32_Type struct {
	CTRLA    volatile.Register32 // 0x0
	CTRLBCLR volatile.Register8  // 0x4
	CTRLBSET volatile.Register8  // 0x5
	EVCTRL   volatile.Register16 // 0x6
	INTENCLR volatile.Register8  // 0x8
	INTENSET volatile.Register8  // 0x9
	INTFLAG  volatile.Register8  // 0xA
	STATUS   volatile.Register8  // 0xB
	WAVE     volatile.Register8  // 0xC
	DRVCTRL  volatile.Register8  // 0xD
	_        byte
	DBGCTRL  volatile.Register8  // 0xF
	SYNCBUSY volatile.Register32 // 0x10
	COUNT    volatile.Register32 // 0x14
	_        [4]byte
	CC       [2]volatile.Register32 // 0x1C
	_        [12]byte
	CCBUF    [2]volatile.Register32 // 0x30
}

// TC_COUNT32.CTRLA: Control A
func (o *TC_COUNT32_Type) SetCTRLA_SWRST(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *TC_COUNT32_Type) GetCTRLA_SWRST() uint32 {
	return volatile.LoadUint32(&o.CTRLA.Reg) & 0x1
}
func (o *TC_COUNT32_Type) SetCTRLA_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT32_Type) GetCTRLA_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *TC_COUNT32_Type) SetCTRLA_MODE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0xc)|value<<2)
}
func (o *TC_COUNT32_Type) GetCTRLA_MODE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0xc) >> 2
}
func (o *TC_COUNT32_Type) SetCTRLA_PRESCSYNC(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x30)|value<<4)
}
func (o *TC_COUNT32_Type) GetCTRLA_PRESCSYNC() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x30) >> 4
}
func (o *TC_COUNT32_Type) SetCTRLA_RUNSTDBY(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x40)|value<<6)
}
func (o *TC_COUNT32_Type) GetCTRLA_RUNSTDBY() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x40) >> 6
}
func (o *TC_COUNT32_Type) SetCTRLA_ONDEMAND(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x80)|value<<7)
}
func (o *TC_COUNT32_Type) GetCTRLA_ONDEMAND() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x80) >> 7
}
func (o *TC_COUNT32_Type) SetCTRLA_PRESCALER(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x700)|value<<8)
}
func (o *TC_COUNT32_Type) GetCTRLA_PRESCALER() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x700) >> 8
}
func (o *TC_COUNT32_Type) SetCTRLA_ALOCK(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x800)|value<<11)
}
func (o *TC_COUNT32_Type) GetCTRLA_ALOCK() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x800) >> 11
}
func (o *TC_COUNT32_Type) SetCTRLA_CAPTEN0(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x10000)|value<<16)
}
func (o *TC_COUNT32_Type) GetCTRLA_CAPTEN0() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x10000) >> 16
}
func (o *TC_COUNT32_Type) SetCTRLA_CAPTEN1(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x20000)|value<<17)
}
func (o *TC_COUNT32_Type) GetCTRLA_CAPTEN1() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x20000) >> 17
}
func (o *TC_COUNT32_Type) SetCTRLA_COPEN0(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x100000)|value<<20)
}
func (o *TC_COUNT32_Type) GetCTRLA_COPEN0() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x100000) >> 20
}
func (o *TC_COUNT32_Type) SetCTRLA_COPEN1(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x200000)|value<<21)
}
func (o *TC_COUNT32_Type) GetCTRLA_COPEN1() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x200000) >> 21
}
func (o *TC_COUNT32_Type) SetCTRLA_CAPTMODE0(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x3000000)|value<<24)
}
func (o *TC_COUNT32_Type) GetCTRLA_CAPTMODE0() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x3000000) >> 24
}
func (o *TC_COUNT32_Type) SetCTRLA_CAPTMODE1(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x18000000)|value<<27)
}
func (o *TC_COUNT32_Type) GetCTRLA_CAPTMODE1() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x18000000) >> 27
}

// TC_COUNT32.CTRLBCLR: Control B Clear
func (o *TC_COUNT32_Type) SetCTRLBCLR_DIR(value uint8) {
	volatile.StoreUint8(&o.CTRLBCLR.Reg, volatile.LoadUint8(&o.CTRLBCLR.Reg)&^(0x1)|value)
}
func (o *TC_COUNT32_Type) GetCTRLBCLR_DIR() uint8 {
	return volatile.LoadUint8(&o.CTRLBCLR.Reg) & 0x1
}
func (o *TC_COUNT32_Type) SetCTRLBCLR_LUPD(value uint8) {
	volatile.StoreUint8(&o.CTRLBCLR.Reg, volatile.LoadUint8(&o.CTRLBCLR.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT32_Type) GetCTRLBCLR_LUPD() uint8 {
	return (volatile.LoadUint8(&o.CTRLBCLR.Reg) & 0x2) >> 1
}
func (o *TC_COUNT32_Type) SetCTRLBCLR_ONESHOT(value uint8) {
	volatile.StoreUint8(&o.CTRLBCLR.Reg, volatile.LoadUint8(&o.CTRLBCLR.Reg)&^(0x4)|value<<2)
}
func (o *TC_COUNT32_Type) GetCTRLBCLR_ONESHOT() uint8 {
	return (volatile.LoadUint8(&o.CTRLBCLR.Reg) & 0x4) >> 2
}
func (o *TC_COUNT32_Type) SetCTRLBCLR_CMD(value uint8) {
	volatile.StoreUint8(&o.CTRLBCLR.Reg, volatile.LoadUint8(&o.CTRLBCLR.Reg)&^(0xe0)|value<<5)
}
func (o *TC_COUNT32_Type) GetCTRLBCLR_CMD() uint8 {
	return (volatile.LoadUint8(&o.CTRLBCLR.Reg) & 0xe0) >> 5
}

// TC_COUNT32.CTRLBSET: Control B Set
func (o *TC_COUNT32_Type) SetCTRLBSET_DIR(value uint8) {
	volatile.StoreUint8(&o.CTRLBSET.Reg, volatile.LoadUint8(&o.CTRLBSET.Reg)&^(0x1)|value)
}
func (o *TC_COUNT32_Type) GetCTRLBSET_DIR() uint8 {
	return volatile.LoadUint8(&o.CTRLBSET.Reg) & 0x1
}
func (o *TC_COUNT32_Type) SetCTRLBSET_LUPD(value uint8) {
	volatile.StoreUint8(&o.CTRLBSET.Reg, volatile.LoadUint8(&o.CTRLBSET.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT32_Type) GetCTRLBSET_LUPD() uint8 {
	return (volatile.LoadUint8(&o.CTRLBSET.Reg) & 0x2) >> 1
}
func (o *TC_COUNT32_Type) SetCTRLBSET_ONESHOT(value uint8) {
	volatile.StoreUint8(&o.CTRLBSET.Reg, volatile.LoadUint8(&o.CTRLBSET.Reg)&^(0x4)|value<<2)
}
func (o *TC_COUNT32_Type) GetCTRLBSET_ONESHOT() uint8 {
	return (volatile.LoadUint8(&o.CTRLBSET.Reg) & 0x4) >> 2
}
func (o *TC_COUNT32_Type) SetCTRLBSET_CMD(value uint8) {
	volatile.StoreUint8(&o.CTRLBSET.Reg, volatile.LoadUint8(&o.CTRLBSET.Reg)&^(0xe0)|value<<5)
}
func (o *TC_COUNT32_Type) GetCTRLBSET_CMD() uint8 {
	return (volatile.LoadUint8(&o.CTRLBSET.Reg) & 0xe0) >> 5
}

// TC_COUNT32.EVCTRL: Event Control
func (o *TC_COUNT32_Type) SetEVCTRL_EVACT(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x7)|value)
}
func (o *TC_COUNT32_Type) GetEVCTRL_EVACT() uint16 {
	return volatile.LoadUint16(&o.EVCTRL.Reg) & 0x7
}
func (o *TC_COUNT32_Type) SetEVCTRL_TCINV(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x10)|value<<4)
}
func (o *TC_COUNT32_Type) GetEVCTRL_TCINV() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x10) >> 4
}
func (o *TC_COUNT32_Type) SetEVCTRL_TCEI(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x20)|value<<5)
}
func (o *TC_COUNT32_Type) GetEVCTRL_TCEI() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x20) >> 5
}
func (o *TC_COUNT32_Type) SetEVCTRL_OVFEO(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x100)|value<<8)
}
func (o *TC_COUNT32_Type) GetEVCTRL_OVFEO() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x100) >> 8
}
func (o *TC_COUNT32_Type) SetEVCTRL_MCEO0(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *TC_COUNT32_Type) GetEVCTRL_MCEO0() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x1000) >> 12
}
func (o *TC_COUNT32_Type) SetEVCTRL_MCEO1(value uint16) {
	volatile.StoreUint16(&o.EVCTRL.Reg, volatile.LoadUint16(&o.EVCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *TC_COUNT32_Type) GetEVCTRL_MCEO1() uint16 {
	return (volatile.LoadUint16(&o.EVCTRL.Reg) & 0x2000) >> 13
}

// TC_COUNT32.INTENCLR: Interrupt Enable Clear
func (o *TC_COUNT32_Type) SetINTENCLR_OVF(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *TC_COUNT32_Type) GetINTENCLR_OVF() uint8 {
	return volatile.LoadUint8(&o.INTENCLR.Reg) & 0x1
}
func (o *TC_COUNT32_Type) SetINTENCLR_ERR(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT32_Type) GetINTENCLR_ERR() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *TC_COUNT32_Type) SetINTENCLR_MC0(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *TC_COUNT32_Type) GetINTENCLR_MC0() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *TC_COUNT32_Type) SetINTENCLR_MC1(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *TC_COUNT32_Type) GetINTENCLR_MC1() uint8 {
	return (volatile.LoadUint8(&o.INTENCLR.Reg) & 0x20) >> 5
}

// TC_COUNT32.INTENSET: Interrupt Enable Set
func (o *TC_COUNT32_Type) SetINTENSET_OVF(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *TC_COUNT32_Type) GetINTENSET_OVF() uint8 {
	return volatile.LoadUint8(&o.INTENSET.Reg) & 0x1
}
func (o *TC_COUNT32_Type) SetINTENSET_ERR(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT32_Type) GetINTENSET_ERR() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *TC_COUNT32_Type) SetINTENSET_MC0(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *TC_COUNT32_Type) GetINTENSET_MC0() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *TC_COUNT32_Type) SetINTENSET_MC1(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *TC_COUNT32_Type) GetINTENSET_MC1() uint8 {
	return (volatile.LoadUint8(&o.INTENSET.Reg) & 0x20) >> 5
}

// TC_COUNT32.INTFLAG: Interrupt Flag Status and Clear
func (o *TC_COUNT32_Type) SetINTFLAG_OVF(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *TC_COUNT32_Type) GetINTFLAG_OVF() uint8 {
	return volatile.LoadUint8(&o.INTFLAG.Reg) & 0x1
}
func (o *TC_COUNT32_Type) SetINTFLAG_ERR(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT32_Type) GetINTFLAG_ERR() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *TC_COUNT32_Type) SetINTFLAG_MC0(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x10)|value<<4)
}
func (o *TC_COUNT32_Type) GetINTFLAG_MC0() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x10) >> 4
}
func (o *TC_COUNT32_Type) SetINTFLAG_MC1(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x20)|value<<5)
}
func (o *TC_COUNT32_Type) GetINTFLAG_MC1() uint8 {
	return (volatile.LoadUint8(&o.INTFLAG.Reg) & 0x20) >> 5
}

// TC_COUNT32.STATUS: Status
func (o *TC_COUNT32_Type) SetSTATUS_STOP(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *TC_COUNT32_Type) GetSTATUS_STOP() uint8 {
	return volatile.LoadUint8(&o.STATUS.Reg) & 0x1
}
func (o *TC_COUNT32_Type) SetSTATUS_SLAVE(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT32_Type) GetSTATUS_SLAVE() uint8 {
	return (volatile.LoadUint8(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *TC_COUNT32_Type) SetSTATUS_PERBUFV(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *TC_COUNT32_Type) GetSTATUS_PERBUFV() uint8 {
	return (volatile.LoadUint8(&o.STATUS.Reg) & 0x8) >> 3
}
func (o *TC_COUNT32_Type) SetSTATUS_CCBUFV0(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x10)|value<<4)
}
func (o *TC_COUNT32_Type) GetSTATUS_CCBUFV0() uint8 {
	return (volatile.LoadUint8(&o.STATUS.Reg) & 0x10) >> 4
}
func (o *TC_COUNT32_Type) SetSTATUS_CCBUFV1(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0x20)|value<<5)
}
func (o *TC_COUNT32_Type) GetSTATUS_CCBUFV1() uint8 {
	return (volatile.LoadUint8(&o.STATUS.Reg) & 0x20) >> 5
}

// TC_COUNT32.WAVE: Waveform Generation Control
func (o *TC_COUNT32_Type) SetWAVE_WAVEGEN(value uint8) {
	volatile.StoreUint8(&o.WAVE.Reg, volatile.LoadUint8(&o.WAVE.Reg)&^(0x3)|value)
}
func (o *TC_COUNT32_Type) GetWAVE_WAVEGEN() uint8 {
	return volatile.LoadUint8(&o.WAVE.Reg) & 0x3
}

// TC_COUNT32.DRVCTRL: Control C
func (o *TC_COUNT32_Type) SetDRVCTRL_INVEN0(value uint8) {
	volatile.StoreUint8(&o.DRVCTRL.Reg, volatile.LoadUint8(&o.DRVCTRL.Reg)&^(0x1)|value)
}
func (o *TC_COUNT32_Type) GetDRVCTRL_INVEN0() uint8 {
	return volatile.LoadUint8(&o.DRVCTRL.Reg) & 0x1
}
func (o *TC_COUNT32_Type) SetDRVCTRL_INVEN1(value uint8) {
	volatile.StoreUint8(&o.DRVCTRL.Reg, volatile.LoadUint8(&o.DRVCTRL.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT32_Type) GetDRVCTRL_INVEN1() uint8 {
	return (volatile.LoadUint8(&o.DRVCTRL.Reg) & 0x2) >> 1
}

// TC_COUNT32.DBGCTRL: Debug Control
func (o *TC_COUNT32_Type) SetDBGCTRL_DBGRUN(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x1)|value)
}
func (o *TC_COUNT32_Type) GetDBGCTRL_DBGRUN() uint8 {
	return volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x1
}

// TC_COUNT32.SYNCBUSY: Synchronization Status
func (o *TC_COUNT32_Type) SetSYNCBUSY_SWRST(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *TC_COUNT32_Type) GetSYNCBUSY_SWRST() uint32 {
	return volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x1
}
func (o *TC_COUNT32_Type) SetSYNCBUSY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *TC_COUNT32_Type) GetSYNCBUSY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x2) >> 1
}
func (o *TC_COUNT32_Type) SetSYNCBUSY_CTRLB(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x4)|value<<2)
}
func (o *TC_COUNT32_Type) GetSYNCBUSY_CTRLB() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x4) >> 2
}
func (o *TC_COUNT32_Type) SetSYNCBUSY_STATUS(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x8)|value<<3)
}
func (o *TC_COUNT32_Type) GetSYNCBUSY_STATUS() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x8) >> 3
}
func (o *TC_COUNT32_Type) SetSYNCBUSY_COUNT(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x10)|value<<4)
}
func (o *TC_COUNT32_Type) GetSYNCBUSY_COUNT() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x10) >> 4
}
func (o *TC_COUNT32_Type) SetSYNCBUSY_PER(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x20)|value<<5)
}
func (o *TC_COUNT32_Type) GetSYNCBUSY_PER() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x20) >> 5
}
func (o *TC_COUNT32_Type) SetSYNCBUSY_CC0(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x40)|value<<6)
}
func (o *TC_COUNT32_Type) GetSYNCBUSY_CC0() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x40) >> 6
}
func (o *TC_COUNT32_Type) SetSYNCBUSY_CC1(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x80)|value<<7)
}
func (o *TC_COUNT32_Type) GetSYNCBUSY_CC1() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x80) >> 7
}

// TC_COUNT32.COUNT: COUNT32 Count
func (o *TC_COUNT32_Type) SetCOUNT(value uint32) {
	volatile.StoreUint32(&o.COUNT.Reg, value)
}
func (o *TC_COUNT32_Type) GetCOUNT() uint32 {
	return volatile.LoadUint32(&o.COUNT.Reg)
}

// TC_COUNT32.CC: COUNT32 Compare and Capture
func (o *TC_COUNT32_Type) SetCC(idx int, value uint32) {
	volatile.StoreUint32(&o.CC[idx].Reg, value)
}
func (o *TC_COUNT32_Type) GetCC(idx int) uint32 {
	return volatile.LoadUint32(&o.CC[idx].Reg)
}

// TC_COUNT32.CCBUF: COUNT32 Compare and Capture Buffer
func (o *TC_COUNT32_Type) SetCCBUF(idx int, value uint32) {
	volatile.StoreUint32(&o.CCBUF[idx].Reg, value)
}
func (o *TC_COUNT32_Type) GetCCBUF(idx int) uint32 {
	return volatile.LoadUint32(&o.CCBUF[idx].Reg)
}

// Timer Counter Control
type TCC_Type struct {
	CTRLA    volatile.Register32 // 0x0
	CTRLBCLR volatile.Register8  // 0x4
	CTRLBSET volatile.Register8  // 0x5
	_        [2]byte
	SYNCBUSY volatile.Register32 // 0x8
	FCTRLA   volatile.Register32 // 0xC
	FCTRLB   volatile.Register32 // 0x10
	WEXCTRL  volatile.Register32 // 0x14
	DRVCTRL  volatile.Register32 // 0x18
	_        [2]byte
	DBGCTRL  volatile.Register8 // 0x1E
	_        byte
	EVCTRL   volatile.Register32 // 0x20
	INTENCLR volatile.Register32 // 0x24
	INTENSET volatile.Register32 // 0x28
	INTFLAG  volatile.Register32 // 0x2C
	STATUS   volatile.Register32 // 0x30
	COUNT    volatile.Register32 // 0x34
	PATT     volatile.Register16 // 0x38
	_        [2]byte
	WAVE     volatile.Register32    // 0x3C
	PER      volatile.Register32    // 0x40
	CC       [6]volatile.Register32 // 0x44
	_        [8]byte
	PATTBUF  volatile.Register16 // 0x64
	_        [6]byte
	PERBUF   volatile.Register32    // 0x6C
	CCBUF    [6]volatile.Register32 // 0x70
}

// TCC.CTRLA: Control A
func (o *TCC_Type) SetCTRLA_SWRST(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *TCC_Type) GetCTRLA_SWRST() uint32 {
	return volatile.LoadUint32(&o.CTRLA.Reg) & 0x1
}
func (o *TCC_Type) SetCTRLA_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *TCC_Type) GetCTRLA_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *TCC_Type) SetCTRLA_RESOLUTION(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x60)|value<<5)
}
func (o *TCC_Type) GetCTRLA_RESOLUTION() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x60) >> 5
}
func (o *TCC_Type) SetCTRLA_PRESCALER(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x700)|value<<8)
}
func (o *TCC_Type) GetCTRLA_PRESCALER() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x700) >> 8
}
func (o *TCC_Type) SetCTRLA_RUNSTDBY(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x800)|value<<11)
}
func (o *TCC_Type) GetCTRLA_RUNSTDBY() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x800) >> 11
}
func (o *TCC_Type) SetCTRLA_PRESCSYNC(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x3000)|value<<12)
}
func (o *TCC_Type) GetCTRLA_PRESCSYNC() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x3000) >> 12
}
func (o *TCC_Type) SetCTRLA_ALOCK(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x4000)|value<<14)
}
func (o *TCC_Type) GetCTRLA_ALOCK() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x4000) >> 14
}
func (o *TCC_Type) SetCTRLA_MSYNC(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x8000)|value<<15)
}
func (o *TCC_Type) GetCTRLA_MSYNC() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x8000) >> 15
}
func (o *TCC_Type) SetCTRLA_DMAOS(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x800000)|value<<23)
}
func (o *TCC_Type) GetCTRLA_DMAOS() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x800000) >> 23
}
func (o *TCC_Type) SetCTRLA_CPTEN0(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x1000000)|value<<24)
}
func (o *TCC_Type) GetCTRLA_CPTEN0() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x1000000) >> 24
}
func (o *TCC_Type) SetCTRLA_CPTEN1(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x2000000)|value<<25)
}
func (o *TCC_Type) GetCTRLA_CPTEN1() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x2000000) >> 25
}
func (o *TCC_Type) SetCTRLA_CPTEN2(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x4000000)|value<<26)
}
func (o *TCC_Type) GetCTRLA_CPTEN2() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x4000000) >> 26
}
func (o *TCC_Type) SetCTRLA_CPTEN3(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x8000000)|value<<27)
}
func (o *TCC_Type) GetCTRLA_CPTEN3() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x8000000) >> 27
}
func (o *TCC_Type) SetCTRLA_CPTEN4(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x10000000)|value<<28)
}
func (o *TCC_Type) GetCTRLA_CPTEN4() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x10000000) >> 28
}
func (o *TCC_Type) SetCTRLA_CPTEN5(value uint32) {
	volatile.StoreUint32(&o.CTRLA.Reg, volatile.LoadUint32(&o.CTRLA.Reg)&^(0x20000000)|value<<29)
}
func (o *TCC_Type) GetCTRLA_CPTEN5() uint32 {
	return (volatile.LoadUint32(&o.CTRLA.Reg) & 0x20000000) >> 29
}

// TCC.CTRLBCLR: Control B Clear
func (o *TCC_Type) SetCTRLBCLR_DIR(value uint8) {
	volatile.StoreUint8(&o.CTRLBCLR.Reg, volatile.LoadUint8(&o.CTRLBCLR.Reg)&^(0x1)|value)
}
func (o *TCC_Type) GetCTRLBCLR_DIR() uint8 {
	return volatile.LoadUint8(&o.CTRLBCLR.Reg) & 0x1
}
func (o *TCC_Type) SetCTRLBCLR_LUPD(value uint8) {
	volatile.StoreUint8(&o.CTRLBCLR.Reg, volatile.LoadUint8(&o.CTRLBCLR.Reg)&^(0x2)|value<<1)
}
func (o *TCC_Type) GetCTRLBCLR_LUPD() uint8 {
	return (volatile.LoadUint8(&o.CTRLBCLR.Reg) & 0x2) >> 1
}
func (o *TCC_Type) SetCTRLBCLR_ONESHOT(value uint8) {
	volatile.StoreUint8(&o.CTRLBCLR.Reg, volatile.LoadUint8(&o.CTRLBCLR.Reg)&^(0x4)|value<<2)
}
func (o *TCC_Type) GetCTRLBCLR_ONESHOT() uint8 {
	return (volatile.LoadUint8(&o.CTRLBCLR.Reg) & 0x4) >> 2
}
func (o *TCC_Type) SetCTRLBCLR_IDXCMD(value uint8) {
	volatile.StoreUint8(&o.CTRLBCLR.Reg, volatile.LoadUint8(&o.CTRLBCLR.Reg)&^(0x18)|value<<3)
}
func (o *TCC_Type) GetCTRLBCLR_IDXCMD() uint8 {
	return (volatile.LoadUint8(&o.CTRLBCLR.Reg) & 0x18) >> 3
}
func (o *TCC_Type) SetCTRLBCLR_CMD(value uint8) {
	volatile.StoreUint8(&o.CTRLBCLR.Reg, volatile.LoadUint8(&o.CTRLBCLR.Reg)&^(0xe0)|value<<5)
}
func (o *TCC_Type) GetCTRLBCLR_CMD() uint8 {
	return (volatile.LoadUint8(&o.CTRLBCLR.Reg) & 0xe0) >> 5
}

// TCC.CTRLBSET: Control B Set
func (o *TCC_Type) SetCTRLBSET_DIR(value uint8) {
	volatile.StoreUint8(&o.CTRLBSET.Reg, volatile.LoadUint8(&o.CTRLBSET.Reg)&^(0x1)|value)
}
func (o *TCC_Type) GetCTRLBSET_DIR() uint8 {
	return volatile.LoadUint8(&o.CTRLBSET.Reg) & 0x1
}
func (o *TCC_Type) SetCTRLBSET_LUPD(value uint8) {
	volatile.StoreUint8(&o.CTRLBSET.Reg, volatile.LoadUint8(&o.CTRLBSET.Reg)&^(0x2)|value<<1)
}
func (o *TCC_Type) GetCTRLBSET_LUPD() uint8 {
	return (volatile.LoadUint8(&o.CTRLBSET.Reg) & 0x2) >> 1
}
func (o *TCC_Type) SetCTRLBSET_ONESHOT(value uint8) {
	volatile.StoreUint8(&o.CTRLBSET.Reg, volatile.LoadUint8(&o.CTRLBSET.Reg)&^(0x4)|value<<2)
}
func (o *TCC_Type) GetCTRLBSET_ONESHOT() uint8 {
	return (volatile.LoadUint8(&o.CTRLBSET.Reg) & 0x4) >> 2
}
func (o *TCC_Type) SetCTRLBSET_IDXCMD(value uint8) {
	volatile.StoreUint8(&o.CTRLBSET.Reg, volatile.LoadUint8(&o.CTRLBSET.Reg)&^(0x18)|value<<3)
}
func (o *TCC_Type) GetCTRLBSET_IDXCMD() uint8 {
	return (volatile.LoadUint8(&o.CTRLBSET.Reg) & 0x18) >> 3
}
func (o *TCC_Type) SetCTRLBSET_CMD(value uint8) {
	volatile.StoreUint8(&o.CTRLBSET.Reg, volatile.LoadUint8(&o.CTRLBSET.Reg)&^(0xe0)|value<<5)
}
func (o *TCC_Type) GetCTRLBSET_CMD() uint8 {
	return (volatile.LoadUint8(&o.CTRLBSET.Reg) & 0xe0) >> 5
}

// TCC.SYNCBUSY: Synchronization Busy
func (o *TCC_Type) SetSYNCBUSY_SWRST(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *TCC_Type) GetSYNCBUSY_SWRST() uint32 {
	return volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x1
}
func (o *TCC_Type) SetSYNCBUSY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *TCC_Type) GetSYNCBUSY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x2) >> 1
}
func (o *TCC_Type) SetSYNCBUSY_CTRLB(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x4)|value<<2)
}
func (o *TCC_Type) GetSYNCBUSY_CTRLB() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x4) >> 2
}
func (o *TCC_Type) SetSYNCBUSY_STATUS(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x8)|value<<3)
}
func (o *TCC_Type) GetSYNCBUSY_STATUS() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x8) >> 3
}
func (o *TCC_Type) SetSYNCBUSY_COUNT(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x10)|value<<4)
}
func (o *TCC_Type) GetSYNCBUSY_COUNT() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x10) >> 4
}
func (o *TCC_Type) SetSYNCBUSY_PATT(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x20)|value<<5)
}
func (o *TCC_Type) GetSYNCBUSY_PATT() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x20) >> 5
}
func (o *TCC_Type) SetSYNCBUSY_WAVE(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x40)|value<<6)
}
func (o *TCC_Type) GetSYNCBUSY_WAVE() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x40) >> 6
}
func (o *TCC_Type) SetSYNCBUSY_PER(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x80)|value<<7)
}
func (o *TCC_Type) GetSYNCBUSY_PER() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x80) >> 7
}
func (o *TCC_Type) SetSYNCBUSY_CC0(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x100)|value<<8)
}
func (o *TCC_Type) GetSYNCBUSY_CC0() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x100) >> 8
}
func (o *TCC_Type) SetSYNCBUSY_CC1(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x200)|value<<9)
}
func (o *TCC_Type) GetSYNCBUSY_CC1() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x200) >> 9
}
func (o *TCC_Type) SetSYNCBUSY_CC2(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x400)|value<<10)
}
func (o *TCC_Type) GetSYNCBUSY_CC2() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x400) >> 10
}
func (o *TCC_Type) SetSYNCBUSY_CC3(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x800)|value<<11)
}
func (o *TCC_Type) GetSYNCBUSY_CC3() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x800) >> 11
}
func (o *TCC_Type) SetSYNCBUSY_CC4(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x1000)|value<<12)
}
func (o *TCC_Type) GetSYNCBUSY_CC4() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x1000) >> 12
}
func (o *TCC_Type) SetSYNCBUSY_CC5(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x2000)|value<<13)
}
func (o *TCC_Type) GetSYNCBUSY_CC5() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x2000) >> 13
}

// TCC.FCTRLA: Recoverable Fault A Configuration
func (o *TCC_Type) SetFCTRLA_SRC(value uint32) {
	volatile.StoreUint32(&o.FCTRLA.Reg, volatile.LoadUint32(&o.FCTRLA.Reg)&^(0x3)|value)
}
func (o *TCC_Type) GetFCTRLA_SRC() uint32 {
	return volatile.LoadUint32(&o.FCTRLA.Reg) & 0x3
}
func (o *TCC_Type) SetFCTRLA_KEEP(value uint32) {
	volatile.StoreUint32(&o.FCTRLA.Reg, volatile.LoadUint32(&o.FCTRLA.Reg)&^(0x8)|value<<3)
}
func (o *TCC_Type) GetFCTRLA_KEEP() uint32 {
	return (volatile.LoadUint32(&o.FCTRLA.Reg) & 0x8) >> 3
}
func (o *TCC_Type) SetFCTRLA_QUAL(value uint32) {
	volatile.StoreUint32(&o.FCTRLA.Reg, volatile.LoadUint32(&o.FCTRLA.Reg)&^(0x10)|value<<4)
}
func (o *TCC_Type) GetFCTRLA_QUAL() uint32 {
	return (volatile.LoadUint32(&o.FCTRLA.Reg) & 0x10) >> 4
}
func (o *TCC_Type) SetFCTRLA_BLANK(value uint32) {
	volatile.StoreUint32(&o.FCTRLA.Reg, volatile.LoadUint32(&o.FCTRLA.Reg)&^(0x60)|value<<5)
}
func (o *TCC_Type) GetFCTRLA_BLANK() uint32 {
	return (volatile.LoadUint32(&o.FCTRLA.Reg) & 0x60) >> 5
}
func (o *TCC_Type) SetFCTRLA_RESTART(value uint32) {
	volatile.StoreUint32(&o.FCTRLA.Reg, volatile.LoadUint32(&o.FCTRLA.Reg)&^(0x80)|value<<7)
}
func (o *TCC_Type) GetFCTRLA_RESTART() uint32 {
	return (volatile.LoadUint32(&o.FCTRLA.Reg) & 0x80) >> 7
}
func (o *TCC_Type) SetFCTRLA_HALT(value uint32) {
	volatile.StoreUint32(&o.FCTRLA.Reg, volatile.LoadUint32(&o.FCTRLA.Reg)&^(0x300)|value<<8)
}
func (o *TCC_Type) GetFCTRLA_HALT() uint32 {
	return (volatile.LoadUint32(&o.FCTRLA.Reg) & 0x300) >> 8
}
func (o *TCC_Type) SetFCTRLA_CHSEL(value uint32) {
	volatile.StoreUint32(&o.FCTRLA.Reg, volatile.LoadUint32(&o.FCTRLA.Reg)&^(0xc00)|value<<10)
}
func (o *TCC_Type) GetFCTRLA_CHSEL() uint32 {
	return (volatile.LoadUint32(&o.FCTRLA.Reg) & 0xc00) >> 10
}
func (o *TCC_Type) SetFCTRLA_CAPTURE(value uint32) {
	volatile.StoreUint32(&o.FCTRLA.Reg, volatile.LoadUint32(&o.FCTRLA.Reg)&^(0x7000)|value<<12)
}
func (o *TCC_Type) GetFCTRLA_CAPTURE() uint32 {
	return (volatile.LoadUint32(&o.FCTRLA.Reg) & 0x7000) >> 12
}
func (o *TCC_Type) SetFCTRLA_BLANKPRESC(value uint32) {
	volatile.StoreUint32(&o.FCTRLA.Reg, volatile.LoadUint32(&o.FCTRLA.Reg)&^(0x8000)|value<<15)
}
func (o *TCC_Type) GetFCTRLA_BLANKPRESC() uint32 {
	return (volatile.LoadUint32(&o.FCTRLA.Reg) & 0x8000) >> 15
}
func (o *TCC_Type) SetFCTRLA_BLANKVAL(value uint32) {
	volatile.StoreUint32(&o.FCTRLA.Reg, volatile.LoadUint32(&o.FCTRLA.Reg)&^(0xff0000)|value<<16)
}
func (o *TCC_Type) GetFCTRLA_BLANKVAL() uint32 {
	return (volatile.LoadUint32(&o.FCTRLA.Reg) & 0xff0000) >> 16
}
func (o *TCC_Type) SetFCTRLA_FILTERVAL(value uint32) {
	volatile.StoreUint32(&o.FCTRLA.Reg, volatile.LoadUint32(&o.FCTRLA.Reg)&^(0xf000000)|value<<24)
}
func (o *TCC_Type) GetFCTRLA_FILTERVAL() uint32 {
	return (volatile.LoadUint32(&o.FCTRLA.Reg) & 0xf000000) >> 24
}

// TCC.FCTRLB: Recoverable Fault B Configuration
func (o *TCC_Type) SetFCTRLB_SRC(value uint32) {
	volatile.StoreUint32(&o.FCTRLB.Reg, volatile.LoadUint32(&o.FCTRLB.Reg)&^(0x3)|value)
}
func (o *TCC_Type) GetFCTRLB_SRC() uint32 {
	return volatile.LoadUint32(&o.FCTRLB.Reg) & 0x3
}
func (o *TCC_Type) SetFCTRLB_KEEP(value uint32) {
	volatile.StoreUint32(&o.FCTRLB.Reg, volatile.LoadUint32(&o.FCTRLB.Reg)&^(0x8)|value<<3)
}
func (o *TCC_Type) GetFCTRLB_KEEP() uint32 {
	return (volatile.LoadUint32(&o.FCTRLB.Reg) & 0x8) >> 3
}
func (o *TCC_Type) SetFCTRLB_QUAL(value uint32) {
	volatile.StoreUint32(&o.FCTRLB.Reg, volatile.LoadUint32(&o.FCTRLB.Reg)&^(0x10)|value<<4)
}
func (o *TCC_Type) GetFCTRLB_QUAL() uint32 {
	return (volatile.LoadUint32(&o.FCTRLB.Reg) & 0x10) >> 4
}
func (o *TCC_Type) SetFCTRLB_BLANK(value uint32) {
	volatile.StoreUint32(&o.FCTRLB.Reg, volatile.LoadUint32(&o.FCTRLB.Reg)&^(0x60)|value<<5)
}
func (o *TCC_Type) GetFCTRLB_BLANK() uint32 {
	return (volatile.LoadUint32(&o.FCTRLB.Reg) & 0x60) >> 5
}
func (o *TCC_Type) SetFCTRLB_RESTART(value uint32) {
	volatile.StoreUint32(&o.FCTRLB.Reg, volatile.LoadUint32(&o.FCTRLB.Reg)&^(0x80)|value<<7)
}
func (o *TCC_Type) GetFCTRLB_RESTART() uint32 {
	return (volatile.LoadUint32(&o.FCTRLB.Reg) & 0x80) >> 7
}
func (o *TCC_Type) SetFCTRLB_HALT(value uint32) {
	volatile.StoreUint32(&o.FCTRLB.Reg, volatile.LoadUint32(&o.FCTRLB.Reg)&^(0x300)|value<<8)
}
func (o *TCC_Type) GetFCTRLB_HALT() uint32 {
	return (volatile.LoadUint32(&o.FCTRLB.Reg) & 0x300) >> 8
}
func (o *TCC_Type) SetFCTRLB_CHSEL(value uint32) {
	volatile.StoreUint32(&o.FCTRLB.Reg, volatile.LoadUint32(&o.FCTRLB.Reg)&^(0xc00)|value<<10)
}
func (o *TCC_Type) GetFCTRLB_CHSEL() uint32 {
	return (volatile.LoadUint32(&o.FCTRLB.Reg) & 0xc00) >> 10
}
func (o *TCC_Type) SetFCTRLB_CAPTURE(value uint32) {
	volatile.StoreUint32(&o.FCTRLB.Reg, volatile.LoadUint32(&o.FCTRLB.Reg)&^(0x7000)|value<<12)
}
func (o *TCC_Type) GetFCTRLB_CAPTURE() uint32 {
	return (volatile.LoadUint32(&o.FCTRLB.Reg) & 0x7000) >> 12
}
func (o *TCC_Type) SetFCTRLB_BLANKPRESC(value uint32) {
	volatile.StoreUint32(&o.FCTRLB.Reg, volatile.LoadUint32(&o.FCTRLB.Reg)&^(0x8000)|value<<15)
}
func (o *TCC_Type) GetFCTRLB_BLANKPRESC() uint32 {
	return (volatile.LoadUint32(&o.FCTRLB.Reg) & 0x8000) >> 15
}
func (o *TCC_Type) SetFCTRLB_BLANKVAL(value uint32) {
	volatile.StoreUint32(&o.FCTRLB.Reg, volatile.LoadUint32(&o.FCTRLB.Reg)&^(0xff0000)|value<<16)
}
func (o *TCC_Type) GetFCTRLB_BLANKVAL() uint32 {
	return (volatile.LoadUint32(&o.FCTRLB.Reg) & 0xff0000) >> 16
}
func (o *TCC_Type) SetFCTRLB_FILTERVAL(value uint32) {
	volatile.StoreUint32(&o.FCTRLB.Reg, volatile.LoadUint32(&o.FCTRLB.Reg)&^(0xf000000)|value<<24)
}
func (o *TCC_Type) GetFCTRLB_FILTERVAL() uint32 {
	return (volatile.LoadUint32(&o.FCTRLB.Reg) & 0xf000000) >> 24
}

// TCC.WEXCTRL: Waveform Extension Configuration
func (o *TCC_Type) SetWEXCTRL_OTMX(value uint32) {
	volatile.StoreUint32(&o.WEXCTRL.Reg, volatile.LoadUint32(&o.WEXCTRL.Reg)&^(0x3)|value)
}
func (o *TCC_Type) GetWEXCTRL_OTMX() uint32 {
	return volatile.LoadUint32(&o.WEXCTRL.Reg) & 0x3
}
func (o *TCC_Type) SetWEXCTRL_DTIEN0(value uint32) {
	volatile.StoreUint32(&o.WEXCTRL.Reg, volatile.LoadUint32(&o.WEXCTRL.Reg)&^(0x100)|value<<8)
}
func (o *TCC_Type) GetWEXCTRL_DTIEN0() uint32 {
	return (volatile.LoadUint32(&o.WEXCTRL.Reg) & 0x100) >> 8
}
func (o *TCC_Type) SetWEXCTRL_DTIEN1(value uint32) {
	volatile.StoreUint32(&o.WEXCTRL.Reg, volatile.LoadUint32(&o.WEXCTRL.Reg)&^(0x200)|value<<9)
}
func (o *TCC_Type) GetWEXCTRL_DTIEN1() uint32 {
	return (volatile.LoadUint32(&o.WEXCTRL.Reg) & 0x200) >> 9
}
func (o *TCC_Type) SetWEXCTRL_DTIEN2(value uint32) {
	volatile.StoreUint32(&o.WEXCTRL.Reg, volatile.LoadUint32(&o.WEXCTRL.Reg)&^(0x400)|value<<10)
}
func (o *TCC_Type) GetWEXCTRL_DTIEN2() uint32 {
	return (volatile.LoadUint32(&o.WEXCTRL.Reg) & 0x400) >> 10
}
func (o *TCC_Type) SetWEXCTRL_DTIEN3(value uint32) {
	volatile.StoreUint32(&o.WEXCTRL.Reg, volatile.LoadUint32(&o.WEXCTRL.Reg)&^(0x800)|value<<11)
}
func (o *TCC_Type) GetWEXCTRL_DTIEN3() uint32 {
	return (volatile.LoadUint32(&o.WEXCTRL.Reg) & 0x800) >> 11
}
func (o *TCC_Type) SetWEXCTRL_DTLS(value uint32) {
	volatile.StoreUint32(&o.WEXCTRL.Reg, volatile.LoadUint32(&o.WEXCTRL.Reg)&^(0xff0000)|value<<16)
}
func (o *TCC_Type) GetWEXCTRL_DTLS() uint32 {
	return (volatile.LoadUint32(&o.WEXCTRL.Reg) & 0xff0000) >> 16
}
func (o *TCC_Type) SetWEXCTRL_DTHS(value uint32) {
	volatile.StoreUint32(&o.WEXCTRL.Reg, volatile.LoadUint32(&o.WEXCTRL.Reg)&^(0xff000000)|value<<24)
}
func (o *TCC_Type) GetWEXCTRL_DTHS() uint32 {
	return (volatile.LoadUint32(&o.WEXCTRL.Reg) & 0xff000000) >> 24
}

// TCC.DRVCTRL: Driver Control
func (o *TCC_Type) SetDRVCTRL_NRE0(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x1)|value)
}
func (o *TCC_Type) GetDRVCTRL_NRE0() uint32 {
	return volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x1
}
func (o *TCC_Type) SetDRVCTRL_NRE1(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x2)|value<<1)
}
func (o *TCC_Type) GetDRVCTRL_NRE1() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x2) >> 1
}
func (o *TCC_Type) SetDRVCTRL_NRE2(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x4)|value<<2)
}
func (o *TCC_Type) GetDRVCTRL_NRE2() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x4) >> 2
}
func (o *TCC_Type) SetDRVCTRL_NRE3(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x8)|value<<3)
}
func (o *TCC_Type) GetDRVCTRL_NRE3() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x8) >> 3
}
func (o *TCC_Type) SetDRVCTRL_NRE4(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x10)|value<<4)
}
func (o *TCC_Type) GetDRVCTRL_NRE4() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x10) >> 4
}
func (o *TCC_Type) SetDRVCTRL_NRE5(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x20)|value<<5)
}
func (o *TCC_Type) GetDRVCTRL_NRE5() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x20) >> 5
}
func (o *TCC_Type) SetDRVCTRL_NRE6(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x40)|value<<6)
}
func (o *TCC_Type) GetDRVCTRL_NRE6() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x40) >> 6
}
func (o *TCC_Type) SetDRVCTRL_NRE7(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x80)|value<<7)
}
func (o *TCC_Type) GetDRVCTRL_NRE7() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x80) >> 7
}
func (o *TCC_Type) SetDRVCTRL_NRV0(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x100)|value<<8)
}
func (o *TCC_Type) GetDRVCTRL_NRV0() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x100) >> 8
}
func (o *TCC_Type) SetDRVCTRL_NRV1(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x200)|value<<9)
}
func (o *TCC_Type) GetDRVCTRL_NRV1() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x200) >> 9
}
func (o *TCC_Type) SetDRVCTRL_NRV2(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x400)|value<<10)
}
func (o *TCC_Type) GetDRVCTRL_NRV2() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x400) >> 10
}
func (o *TCC_Type) SetDRVCTRL_NRV3(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x800)|value<<11)
}
func (o *TCC_Type) GetDRVCTRL_NRV3() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x800) >> 11
}
func (o *TCC_Type) SetDRVCTRL_NRV4(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *TCC_Type) GetDRVCTRL_NRV4() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x1000) >> 12
}
func (o *TCC_Type) SetDRVCTRL_NRV5(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *TCC_Type) GetDRVCTRL_NRV5() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x2000) >> 13
}
func (o *TCC_Type) SetDRVCTRL_NRV6(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x4000)|value<<14)
}
func (o *TCC_Type) GetDRVCTRL_NRV6() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x4000) >> 14
}
func (o *TCC_Type) SetDRVCTRL_NRV7(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *TCC_Type) GetDRVCTRL_NRV7() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x8000) >> 15
}
func (o *TCC_Type) SetDRVCTRL_INVEN0(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x10000)|value<<16)
}
func (o *TCC_Type) GetDRVCTRL_INVEN0() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x10000) >> 16
}
func (o *TCC_Type) SetDRVCTRL_INVEN1(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x20000)|value<<17)
}
func (o *TCC_Type) GetDRVCTRL_INVEN1() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x20000) >> 17
}
func (o *TCC_Type) SetDRVCTRL_INVEN2(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x40000)|value<<18)
}
func (o *TCC_Type) GetDRVCTRL_INVEN2() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x40000) >> 18
}
func (o *TCC_Type) SetDRVCTRL_INVEN3(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x80000)|value<<19)
}
func (o *TCC_Type) GetDRVCTRL_INVEN3() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x80000) >> 19
}
func (o *TCC_Type) SetDRVCTRL_INVEN4(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x100000)|value<<20)
}
func (o *TCC_Type) GetDRVCTRL_INVEN4() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x100000) >> 20
}
func (o *TCC_Type) SetDRVCTRL_INVEN5(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x200000)|value<<21)
}
func (o *TCC_Type) GetDRVCTRL_INVEN5() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x200000) >> 21
}
func (o *TCC_Type) SetDRVCTRL_INVEN6(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x400000)|value<<22)
}
func (o *TCC_Type) GetDRVCTRL_INVEN6() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x400000) >> 22
}
func (o *TCC_Type) SetDRVCTRL_INVEN7(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0x800000)|value<<23)
}
func (o *TCC_Type) GetDRVCTRL_INVEN7() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0x800000) >> 23
}
func (o *TCC_Type) SetDRVCTRL_FILTERVAL0(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0xf000000)|value<<24)
}
func (o *TCC_Type) GetDRVCTRL_FILTERVAL0() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0xf000000) >> 24
}
func (o *TCC_Type) SetDRVCTRL_FILTERVAL1(value uint32) {
	volatile.StoreUint32(&o.DRVCTRL.Reg, volatile.LoadUint32(&o.DRVCTRL.Reg)&^(0xf0000000)|value<<28)
}
func (o *TCC_Type) GetDRVCTRL_FILTERVAL1() uint32 {
	return (volatile.LoadUint32(&o.DRVCTRL.Reg) & 0xf0000000) >> 28
}

// TCC.DBGCTRL: Debug Control
func (o *TCC_Type) SetDBGCTRL_DBGRUN(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x1)|value)
}
func (o *TCC_Type) GetDBGCTRL_DBGRUN() uint8 {
	return volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x1
}
func (o *TCC_Type) SetDBGCTRL_FDDBD(value uint8) {
	volatile.StoreUint8(&o.DBGCTRL.Reg, volatile.LoadUint8(&o.DBGCTRL.Reg)&^(0x4)|value<<2)
}
func (o *TCC_Type) GetDBGCTRL_FDDBD() uint8 {
	return (volatile.LoadUint8(&o.DBGCTRL.Reg) & 0x4) >> 2
}

// TCC.EVCTRL: Event Control
func (o *TCC_Type) SetEVCTRL_EVACT0(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x7)|value)
}
func (o *TCC_Type) GetEVCTRL_EVACT0() uint32 {
	return volatile.LoadUint32(&o.EVCTRL.Reg) & 0x7
}
func (o *TCC_Type) SetEVCTRL_EVACT1(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x38)|value<<3)
}
func (o *TCC_Type) GetEVCTRL_EVACT1() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x38) >> 3
}
func (o *TCC_Type) SetEVCTRL_CNTSEL(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0xc0)|value<<6)
}
func (o *TCC_Type) GetEVCTRL_CNTSEL() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0xc0) >> 6
}
func (o *TCC_Type) SetEVCTRL_OVFEO(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x100)|value<<8)
}
func (o *TCC_Type) GetEVCTRL_OVFEO() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x100) >> 8
}
func (o *TCC_Type) SetEVCTRL_TRGEO(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x200)|value<<9)
}
func (o *TCC_Type) GetEVCTRL_TRGEO() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x200) >> 9
}
func (o *TCC_Type) SetEVCTRL_CNTEO(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x400)|value<<10)
}
func (o *TCC_Type) GetEVCTRL_CNTEO() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x400) >> 10
}
func (o *TCC_Type) SetEVCTRL_TCINV0(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *TCC_Type) GetEVCTRL_TCINV0() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x1000) >> 12
}
func (o *TCC_Type) SetEVCTRL_TCINV1(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *TCC_Type) GetEVCTRL_TCINV1() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x2000) >> 13
}
func (o *TCC_Type) SetEVCTRL_TCEI0(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x4000)|value<<14)
}
func (o *TCC_Type) GetEVCTRL_TCEI0() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x4000) >> 14
}
func (o *TCC_Type) SetEVCTRL_TCEI1(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *TCC_Type) GetEVCTRL_TCEI1() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x8000) >> 15
}
func (o *TCC_Type) SetEVCTRL_MCEI0(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x10000)|value<<16)
}
func (o *TCC_Type) GetEVCTRL_MCEI0() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x10000) >> 16
}
func (o *TCC_Type) SetEVCTRL_MCEI1(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x20000)|value<<17)
}
func (o *TCC_Type) GetEVCTRL_MCEI1() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x20000) >> 17
}
func (o *TCC_Type) SetEVCTRL_MCEI2(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x40000)|value<<18)
}
func (o *TCC_Type) GetEVCTRL_MCEI2() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x40000) >> 18
}
func (o *TCC_Type) SetEVCTRL_MCEI3(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x80000)|value<<19)
}
func (o *TCC_Type) GetEVCTRL_MCEI3() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x80000) >> 19
}
func (o *TCC_Type) SetEVCTRL_MCEI4(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x100000)|value<<20)
}
func (o *TCC_Type) GetEVCTRL_MCEI4() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x100000) >> 20
}
func (o *TCC_Type) SetEVCTRL_MCEI5(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x200000)|value<<21)
}
func (o *TCC_Type) GetEVCTRL_MCEI5() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x200000) >> 21
}
func (o *TCC_Type) SetEVCTRL_MCEO0(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *TCC_Type) GetEVCTRL_MCEO0() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x1000000) >> 24
}
func (o *TCC_Type) SetEVCTRL_MCEO1(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *TCC_Type) GetEVCTRL_MCEO1() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x2000000) >> 25
}
func (o *TCC_Type) SetEVCTRL_MCEO2(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *TCC_Type) GetEVCTRL_MCEO2() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x4000000) >> 26
}
func (o *TCC_Type) SetEVCTRL_MCEO3(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x8000000)|value<<27)
}
func (o *TCC_Type) GetEVCTRL_MCEO3() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x8000000) >> 27
}
func (o *TCC_Type) SetEVCTRL_MCEO4(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *TCC_Type) GetEVCTRL_MCEO4() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x10000000) >> 28
}
func (o *TCC_Type) SetEVCTRL_MCEO5(value uint32) {
	volatile.StoreUint32(&o.EVCTRL.Reg, volatile.LoadUint32(&o.EVCTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *TCC_Type) GetEVCTRL_MCEO5() uint32 {
	return (volatile.LoadUint32(&o.EVCTRL.Reg) & 0x20000000) >> 29
}

// TCC.INTENCLR: Interrupt Enable Clear
func (o *TCC_Type) SetINTENCLR_OVF(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *TCC_Type) GetINTENCLR_OVF() uint32 {
	return volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1
}
func (o *TCC_Type) SetINTENCLR_TRG(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *TCC_Type) GetINTENCLR_TRG() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *TCC_Type) SetINTENCLR_CNT(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *TCC_Type) GetINTENCLR_CNT() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *TCC_Type) SetINTENCLR_ERR(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *TCC_Type) GetINTENCLR_ERR() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *TCC_Type) SetINTENCLR_UFS(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x400)|value<<10)
}
func (o *TCC_Type) GetINTENCLR_UFS() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x400) >> 10
}
func (o *TCC_Type) SetINTENCLR_DFS(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x800)|value<<11)
}
func (o *TCC_Type) GetINTENCLR_DFS() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x800) >> 11
}
func (o *TCC_Type) SetINTENCLR_FAULTA(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x1000)|value<<12)
}
func (o *TCC_Type) GetINTENCLR_FAULTA() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x1000) >> 12
}
func (o *TCC_Type) SetINTENCLR_FAULTB(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x2000)|value<<13)
}
func (o *TCC_Type) GetINTENCLR_FAULTB() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x2000) >> 13
}
func (o *TCC_Type) SetINTENCLR_FAULT0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x4000)|value<<14)
}
func (o *TCC_Type) GetINTENCLR_FAULT0() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x4000) >> 14
}
func (o *TCC_Type) SetINTENCLR_FAULT1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x8000)|value<<15)
}
func (o *TCC_Type) GetINTENCLR_FAULT1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x8000) >> 15
}
func (o *TCC_Type) SetINTENCLR_MC0(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x10000)|value<<16)
}
func (o *TCC_Type) GetINTENCLR_MC0() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x10000) >> 16
}
func (o *TCC_Type) SetINTENCLR_MC1(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x20000)|value<<17)
}
func (o *TCC_Type) GetINTENCLR_MC1() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x20000) >> 17
}
func (o *TCC_Type) SetINTENCLR_MC2(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x40000)|value<<18)
}
func (o *TCC_Type) GetINTENCLR_MC2() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x40000) >> 18
}
func (o *TCC_Type) SetINTENCLR_MC3(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x80000)|value<<19)
}
func (o *TCC_Type) GetINTENCLR_MC3() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x80000) >> 19
}
func (o *TCC_Type) SetINTENCLR_MC4(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x100000)|value<<20)
}
func (o *TCC_Type) GetINTENCLR_MC4() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x100000) >> 20
}
func (o *TCC_Type) SetINTENCLR_MC5(value uint32) {
	volatile.StoreUint32(&o.INTENCLR.Reg, volatile.LoadUint32(&o.INTENCLR.Reg)&^(0x200000)|value<<21)
}
func (o *TCC_Type) GetINTENCLR_MC5() uint32 {
	return (volatile.LoadUint32(&o.INTENCLR.Reg) & 0x200000) >> 21
}

// TCC.INTENSET: Interrupt Enable Set
func (o *TCC_Type) SetINTENSET_OVF(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *TCC_Type) GetINTENSET_OVF() uint32 {
	return volatile.LoadUint32(&o.INTENSET.Reg) & 0x1
}
func (o *TCC_Type) SetINTENSET_TRG(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *TCC_Type) GetINTENSET_TRG() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *TCC_Type) SetINTENSET_CNT(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *TCC_Type) GetINTENSET_CNT() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *TCC_Type) SetINTENSET_ERR(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *TCC_Type) GetINTENSET_ERR() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *TCC_Type) SetINTENSET_UFS(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x400)|value<<10)
}
func (o *TCC_Type) GetINTENSET_UFS() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x400) >> 10
}
func (o *TCC_Type) SetINTENSET_DFS(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x800)|value<<11)
}
func (o *TCC_Type) GetINTENSET_DFS() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x800) >> 11
}
func (o *TCC_Type) SetINTENSET_FAULTA(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x1000)|value<<12)
}
func (o *TCC_Type) GetINTENSET_FAULTA() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x1000) >> 12
}
func (o *TCC_Type) SetINTENSET_FAULTB(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x2000)|value<<13)
}
func (o *TCC_Type) GetINTENSET_FAULTB() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x2000) >> 13
}
func (o *TCC_Type) SetINTENSET_FAULT0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x4000)|value<<14)
}
func (o *TCC_Type) GetINTENSET_FAULT0() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x4000) >> 14
}
func (o *TCC_Type) SetINTENSET_FAULT1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x8000)|value<<15)
}
func (o *TCC_Type) GetINTENSET_FAULT1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x8000) >> 15
}
func (o *TCC_Type) SetINTENSET_MC0(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x10000)|value<<16)
}
func (o *TCC_Type) GetINTENSET_MC0() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x10000) >> 16
}
func (o *TCC_Type) SetINTENSET_MC1(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x20000)|value<<17)
}
func (o *TCC_Type) GetINTENSET_MC1() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x20000) >> 17
}
func (o *TCC_Type) SetINTENSET_MC2(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x40000)|value<<18)
}
func (o *TCC_Type) GetINTENSET_MC2() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x40000) >> 18
}
func (o *TCC_Type) SetINTENSET_MC3(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x80000)|value<<19)
}
func (o *TCC_Type) GetINTENSET_MC3() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x80000) >> 19
}
func (o *TCC_Type) SetINTENSET_MC4(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x100000)|value<<20)
}
func (o *TCC_Type) GetINTENSET_MC4() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x100000) >> 20
}
func (o *TCC_Type) SetINTENSET_MC5(value uint32) {
	volatile.StoreUint32(&o.INTENSET.Reg, volatile.LoadUint32(&o.INTENSET.Reg)&^(0x200000)|value<<21)
}
func (o *TCC_Type) GetINTENSET_MC5() uint32 {
	return (volatile.LoadUint32(&o.INTENSET.Reg) & 0x200000) >> 21
}

// TCC.INTFLAG: Interrupt Flag Status and Clear
func (o *TCC_Type) SetINTFLAG_OVF(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *TCC_Type) GetINTFLAG_OVF() uint32 {
	return volatile.LoadUint32(&o.INTFLAG.Reg) & 0x1
}
func (o *TCC_Type) SetINTFLAG_TRG(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *TCC_Type) GetINTFLAG_TRG() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *TCC_Type) SetINTFLAG_CNT(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x4)|value<<2)
}
func (o *TCC_Type) GetINTFLAG_CNT() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x4) >> 2
}
func (o *TCC_Type) SetINTFLAG_ERR(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x8)|value<<3)
}
func (o *TCC_Type) GetINTFLAG_ERR() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x8) >> 3
}
func (o *TCC_Type) SetINTFLAG_UFS(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x400)|value<<10)
}
func (o *TCC_Type) GetINTFLAG_UFS() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x400) >> 10
}
func (o *TCC_Type) SetINTFLAG_DFS(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x800)|value<<11)
}
func (o *TCC_Type) GetINTFLAG_DFS() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x800) >> 11
}
func (o *TCC_Type) SetINTFLAG_FAULTA(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x1000)|value<<12)
}
func (o *TCC_Type) GetINTFLAG_FAULTA() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x1000) >> 12
}
func (o *TCC_Type) SetINTFLAG_FAULTB(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x2000)|value<<13)
}
func (o *TCC_Type) GetINTFLAG_FAULTB() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x2000) >> 13
}
func (o *TCC_Type) SetINTFLAG_FAULT0(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x4000)|value<<14)
}
func (o *TCC_Type) GetINTFLAG_FAULT0() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x4000) >> 14
}
func (o *TCC_Type) SetINTFLAG_FAULT1(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x8000)|value<<15)
}
func (o *TCC_Type) GetINTFLAG_FAULT1() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x8000) >> 15
}
func (o *TCC_Type) SetINTFLAG_MC0(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x10000)|value<<16)
}
func (o *TCC_Type) GetINTFLAG_MC0() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x10000) >> 16
}
func (o *TCC_Type) SetINTFLAG_MC1(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x20000)|value<<17)
}
func (o *TCC_Type) GetINTFLAG_MC1() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x20000) >> 17
}
func (o *TCC_Type) SetINTFLAG_MC2(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x40000)|value<<18)
}
func (o *TCC_Type) GetINTFLAG_MC2() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x40000) >> 18
}
func (o *TCC_Type) SetINTFLAG_MC3(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x80000)|value<<19)
}
func (o *TCC_Type) GetINTFLAG_MC3() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x80000) >> 19
}
func (o *TCC_Type) SetINTFLAG_MC4(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x100000)|value<<20)
}
func (o *TCC_Type) GetINTFLAG_MC4() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x100000) >> 20
}
func (o *TCC_Type) SetINTFLAG_MC5(value uint32) {
	volatile.StoreUint32(&o.INTFLAG.Reg, volatile.LoadUint32(&o.INTFLAG.Reg)&^(0x200000)|value<<21)
}
func (o *TCC_Type) GetINTFLAG_MC5() uint32 {
	return (volatile.LoadUint32(&o.INTFLAG.Reg) & 0x200000) >> 21
}

// TCC.STATUS: Status
func (o *TCC_Type) SetSTATUS_STOP(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *TCC_Type) GetSTATUS_STOP() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *TCC_Type) SetSTATUS_IDX(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *TCC_Type) GetSTATUS_IDX() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *TCC_Type) SetSTATUS_UFS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *TCC_Type) GetSTATUS_UFS() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *TCC_Type) SetSTATUS_DFS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *TCC_Type) GetSTATUS_DFS() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8) >> 3
}
func (o *TCC_Type) SetSTATUS_SLAVE(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x10)|value<<4)
}
func (o *TCC_Type) GetSTATUS_SLAVE() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x10) >> 4
}
func (o *TCC_Type) SetSTATUS_PATTBUFV(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x20)|value<<5)
}
func (o *TCC_Type) GetSTATUS_PATTBUFV() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x20) >> 5
}
func (o *TCC_Type) SetSTATUS_PERBUFV(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80)|value<<7)
}
func (o *TCC_Type) GetSTATUS_PERBUFV() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80) >> 7
}
func (o *TCC_Type) SetSTATUS_FAULTAIN(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x100)|value<<8)
}
func (o *TCC_Type) GetSTATUS_FAULTAIN() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x100) >> 8
}
func (o *TCC_Type) SetSTATUS_FAULTBIN(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x200)|value<<9)
}
func (o *TCC_Type) GetSTATUS_FAULTBIN() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x200) >> 9
}
func (o *TCC_Type) SetSTATUS_FAULT0IN(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x400)|value<<10)
}
func (o *TCC_Type) GetSTATUS_FAULT0IN() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x400) >> 10
}
func (o *TCC_Type) SetSTATUS_FAULT1IN(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x800)|value<<11)
}
func (o *TCC_Type) GetSTATUS_FAULT1IN() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x800) >> 11
}
func (o *TCC_Type) SetSTATUS_FAULTA(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *TCC_Type) GetSTATUS_FAULTA() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x1000) >> 12
}
func (o *TCC_Type) SetSTATUS_FAULTB(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *TCC_Type) GetSTATUS_FAULTB() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2000) >> 13
}
func (o *TCC_Type) SetSTATUS_FAULT0(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4000)|value<<14)
}
func (o *TCC_Type) GetSTATUS_FAULT0() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4000) >> 14
}
func (o *TCC_Type) SetSTATUS_FAULT1(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8000)|value<<15)
}
func (o *TCC_Type) GetSTATUS_FAULT1() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8000) >> 15
}
func (o *TCC_Type) SetSTATUS_CCBUFV0(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x10000)|value<<16)
}
func (o *TCC_Type) GetSTATUS_CCBUFV0() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x10000) >> 16
}
func (o *TCC_Type) SetSTATUS_CCBUFV1(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *TCC_Type) GetSTATUS_CCBUFV1() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x20000) >> 17
}
func (o *TCC_Type) SetSTATUS_CCBUFV2(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x40000)|value<<18)
}
func (o *TCC_Type) GetSTATUS_CCBUFV2() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x40000) >> 18
}
func (o *TCC_Type) SetSTATUS_CCBUFV3(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *TCC_Type) GetSTATUS_CCBUFV3() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80000) >> 19
}
func (o *TCC_Type) SetSTATUS_CCBUFV4(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x100000)|value<<20)
}
func (o *TCC_Type) GetSTATUS_CCBUFV4() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x100000) >> 20
}
func (o *TCC_Type) SetSTATUS_CCBUFV5(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x200000)|value<<21)
}
func (o *TCC_Type) GetSTATUS_CCBUFV5() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x200000) >> 21
}
func (o *TCC_Type) SetSTATUS_CMP0(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *TCC_Type) GetSTATUS_CMP0() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x1000000) >> 24
}
func (o *TCC_Type) SetSTATUS_CMP1(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2000000)|value<<25)
}
func (o *TCC_Type) GetSTATUS_CMP1() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2000000) >> 25
}
func (o *TCC_Type) SetSTATUS_CMP2(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *TCC_Type) GetSTATUS_CMP2() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4000000) >> 26
}
func (o *TCC_Type) SetSTATUS_CMP3(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8000000)|value<<27)
}
func (o *TCC_Type) GetSTATUS_CMP3() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8000000) >> 27
}
func (o *TCC_Type) SetSTATUS_CMP4(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x10000000)|value<<28)
}
func (o *TCC_Type) GetSTATUS_CMP4() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x10000000) >> 28
}
func (o *TCC_Type) SetSTATUS_CMP5(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x20000000)|value<<29)
}
func (o *TCC_Type) GetSTATUS_CMP5() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x20000000) >> 29
}

// TCC.COUNT: Count
func (o *TCC_Type) SetCOUNT(value uint32) {
	volatile.StoreUint32(&o.COUNT.Reg, volatile.LoadUint32(&o.COUNT.Reg)&^(0xffffff)|value)
}
func (o *TCC_Type) GetCOUNT() uint32 {
	return volatile.LoadUint32(&o.COUNT.Reg) & 0xffffff
}

// TCC.PATT: Pattern
func (o *TCC_Type) SetPATT_PGE0(value uint16) {
	volatile.StoreUint16(&o.PATT.Reg, volatile.LoadUint16(&o.PATT.Reg)&^(0x1)|value)
}
func (o *TCC_Type) GetPATT_PGE0() uint16 {
	return volatile.LoadUint16(&o.PATT.Reg) & 0x1
}
func (o *TCC_Type) SetPATT_PGE1(value uint16) {
	volatile.StoreUint16(&o.PATT.Reg, volatile.LoadUint16(&o.PATT.Reg)&^(0x2)|value<<1)
}
func (o *TCC_Type) GetPATT_PGE1() uint16 {
	return (volatile.LoadUint16(&o.PATT.Reg) & 0x2) >> 1
}
func (o *TCC_Type) SetPATT_PGE2(value uint16) {
	volatile.StoreUint16(&o.PATT.Reg, volatile.LoadUint16(&o.PATT.Reg)&^(0x4)|value<<2)
}
func (o *TCC_Type) GetPATT_PGE2() uint16 {
	return (volatile.LoadUint16(&o.PATT.Reg) & 0x4) >> 2
}
func (o *TCC_Type) SetPATT_PGE3(value uint16) {
	volatile.StoreUint16(&o.PATT.Reg, volatile.LoadUint16(&o.PATT.Reg)&^(0x8)|value<<3)
}
func (o *TCC_Type) GetPATT_PGE3() uint16 {
	return (volatile.LoadUint16(&o.PATT.Reg) & 0x8) >> 3
}
func (o *TCC_Type) SetPATT_PGE4(value uint16) {
	volatile.StoreUint16(&o.PATT.Reg, volatile.LoadUint16(&o.PATT.Reg)&^(0x10)|value<<4)
}
func (o *TCC_Type) GetPATT_PGE4() uint16 {
	return (volatile.LoadUint16(&o.PATT.Reg) & 0x10) >> 4
}
func (o *TCC_Type) SetPATT_PGE5(value uint16) {
	volatile.StoreUint16(&o.PATT.Reg, volatile.LoadUint16(&o.PATT.Reg)&^(0x20)|value<<5)
}
func (o *TCC_Type) GetPATT_PGE5() uint16 {
	return (volatile.LoadUint16(&o.PATT.Reg) & 0x20) >> 5
}
func (o *TCC_Type) SetPATT_PGE6(value uint16) {
	volatile.StoreUint16(&o.PATT.Reg, volatile.LoadUint16(&o.PATT.Reg)&^(0x40)|value<<6)
}
func (o *TCC_Type) GetPATT_PGE6() uint16 {
	return (volatile.LoadUint16(&o.PATT.Reg) & 0x40) >> 6
}
func (o *TCC_Type) SetPATT_PGE7(value uint16) {
	volatile.StoreUint16(&o.PATT.Reg, volatile.LoadUint16(&o.PATT.Reg)&^(0x80)|value<<7)
}
func (o *TCC_Type) GetPATT_PGE7() uint16 {
	return (volatile.LoadUint16(&o.PATT.Reg) & 0x80) >> 7
}
func (o *TCC_Type) SetPATT_PGV0(value uint16) {
	volatile.StoreUint16(&o.PATT.Reg, volatile.LoadUint16(&o.PATT.Reg)&^(0x100)|value<<8)
}
func (o *TCC_Type) GetPATT_PGV0() uint16 {
	return (volatile.LoadUint16(&o.PATT.Reg) & 0x100) >> 8
}
func (o *TCC_Type) SetPATT_PGV1(value uint16) {
	volatile.StoreUint16(&o.PATT.Reg, volatile.LoadUint16(&o.PATT.Reg)&^(0x200)|value<<9)
}
func (o *TCC_Type) GetPATT_PGV1() uint16 {
	return (volatile.LoadUint16(&o.PATT.Reg) & 0x200) >> 9
}
func (o *TCC_Type) SetPATT_PGV2(value uint16) {
	volatile.StoreUint16(&o.PATT.Reg, volatile.LoadUint16(&o.PATT.Reg)&^(0x400)|value<<10)
}
func (o *TCC_Type) GetPATT_PGV2() uint16 {
	return (volatile.LoadUint16(&o.PATT.Reg) & 0x400) >> 10
}
func (o *TCC_Type) SetPATT_PGV3(value uint16) {
	volatile.StoreUint16(&o.PATT.Reg, volatile.LoadUint16(&o.PATT.Reg)&^(0x800)|value<<11)
}
func (o *TCC_Type) GetPATT_PGV3() uint16 {
	return (volatile.LoadUint16(&o.PATT.Reg) & 0x800) >> 11
}
func (o *TCC_Type) SetPATT_PGV4(value uint16) {
	volatile.StoreUint16(&o.PATT.Reg, volatile.LoadUint16(&o.PATT.Reg)&^(0x1000)|value<<12)
}
func (o *TCC_Type) GetPATT_PGV4() uint16 {
	return (volatile.LoadUint16(&o.PATT.Reg) & 0x1000) >> 12
}
func (o *TCC_Type) SetPATT_PGV5(value uint16) {
	volatile.StoreUint16(&o.PATT.Reg, volatile.LoadUint16(&o.PATT.Reg)&^(0x2000)|value<<13)
}
func (o *TCC_Type) GetPATT_PGV5() uint16 {
	return (volatile.LoadUint16(&o.PATT.Reg) & 0x2000) >> 13
}
func (o *TCC_Type) SetPATT_PGV6(value uint16) {
	volatile.StoreUint16(&o.PATT.Reg, volatile.LoadUint16(&o.PATT.Reg)&^(0x4000)|value<<14)
}
func (o *TCC_Type) GetPATT_PGV6() uint16 {
	return (volatile.LoadUint16(&o.PATT.Reg) & 0x4000) >> 14
}
func (o *TCC_Type) SetPATT_PGV7(value uint16) {
	volatile.StoreUint16(&o.PATT.Reg, volatile.LoadUint16(&o.PATT.Reg)&^(0x8000)|value<<15)
}
func (o *TCC_Type) GetPATT_PGV7() uint16 {
	return (volatile.LoadUint16(&o.PATT.Reg) & 0x8000) >> 15
}

// TCC.WAVE: Waveform Control
func (o *TCC_Type) SetWAVE_WAVEGEN(value uint32) {
	volatile.StoreUint32(&o.WAVE.Reg, volatile.LoadUint32(&o.WAVE.Reg)&^(0x7)|value)
}
func (o *TCC_Type) GetWAVE_WAVEGEN() uint32 {
	return volatile.LoadUint32(&o.WAVE.Reg) & 0x7
}
func (o *TCC_Type) SetWAVE_RAMP(value uint32) {
	volatile.StoreUint32(&o.WAVE.Reg, volatile.LoadUint32(&o.WAVE.Reg)&^(0x30)|value<<4)
}
func (o *TCC_Type) GetWAVE_RAMP() uint32 {
	return (volatile.LoadUint32(&o.WAVE.Reg) & 0x30) >> 4
}
func (o *TCC_Type) SetWAVE_CIPEREN(value uint32) {
	volatile.StoreUint32(&o.WAVE.Reg, volatile.LoadUint32(&o.WAVE.Reg)&^(0x80)|value<<7)
}
func (o *TCC_Type) GetWAVE_CIPEREN() uint32 {
	return (volatile.LoadUint32(&o.WAVE.Reg) & 0x80) >> 7
}
func (o *TCC_Type) SetWAVE_CICCEN0(value uint32) {
	volatile.StoreUint32(&o.WAVE.Reg, volatile.LoadUint32(&o.WAVE.Reg)&^(0x100)|value<<8)
}
func (o *TCC_Type) GetWAVE_CICCEN0() uint32 {
	return (volatile.LoadUint32(&o.WAVE.Reg) & 0x100) >> 8
}
func (o *TCC_Type) SetWAVE_CICCEN1(value uint32) {
	volatile.StoreUint32(&o.WAVE.Reg, volatile.LoadUint32(&o.WAVE.Reg)&^(0x200)|value<<9)
}
func (o *TCC_Type) GetWAVE_CICCEN1() uint32 {
	return (volatile.LoadUint32(&o.WAVE.Reg) & 0x200) >> 9
}
func (o *TCC_Type) SetWAVE_CICCEN2(value uint32) {
	volatile.StoreUint32(&o.WAVE.Reg, volatile.LoadUint32(&o.WAVE.Reg)&^(0x400)|value<<10)
}
func (o *TCC_Type) GetWAVE_CICCEN2() uint32 {
	return (volatile.LoadUint32(&o.WAVE.Reg) & 0x400) >> 10
}
func (o *TCC_Type) SetWAVE_CICCEN3(value uint32) {
	volatile.StoreUint32(&o.WAVE.Reg, volatile.LoadUint32(&o.WAVE.Reg)&^(0x800)|value<<11)
}
func (o *TCC_Type) GetWAVE_CICCEN3() uint32 {
	return (volatile.LoadUint32(&o.WAVE.Reg) & 0x800) >> 11
}
func (o *TCC_Type) SetWAVE_POL0(value uint32) {
	volatile.StoreUint32(&o.WAVE.Reg, volatile.LoadUint32(&o.WAVE.Reg)&^(0x10000)|value<<16)
}
func (o *TCC_Type) GetWAVE_POL0() uint32 {
	return (volatile.LoadUint32(&o.WAVE.Reg) & 0x10000) >> 16
}
func (o *TCC_Type) SetWAVE_POL1(value uint32) {
	volatile.StoreUint32(&o.WAVE.Reg, volatile.LoadUint32(&o.WAVE.Reg)&^(0x20000)|value<<17)
}
func (o *TCC_Type) GetWAVE_POL1() uint32 {
	return (volatile.LoadUint32(&o.WAVE.Reg) & 0x20000) >> 17
}
func (o *TCC_Type) SetWAVE_POL2(value uint32) {
	volatile.StoreUint32(&o.WAVE.Reg, volatile.LoadUint32(&o.WAVE.Reg)&^(0x40000)|value<<18)
}
func (o *TCC_Type) GetWAVE_POL2() uint32 {
	return (volatile.LoadUint32(&o.WAVE.Reg) & 0x40000) >> 18
}
func (o *TCC_Type) SetWAVE_POL3(value uint32) {
	volatile.StoreUint32(&o.WAVE.Reg, volatile.LoadUint32(&o.WAVE.Reg)&^(0x80000)|value<<19)
}
func (o *TCC_Type) GetWAVE_POL3() uint32 {
	return (volatile.LoadUint32(&o.WAVE.Reg) & 0x80000) >> 19
}
func (o *TCC_Type) SetWAVE_POL4(value uint32) {
	volatile.StoreUint32(&o.WAVE.Reg, volatile.LoadUint32(&o.WAVE.Reg)&^(0x100000)|value<<20)
}
func (o *TCC_Type) GetWAVE_POL4() uint32 {
	return (volatile.LoadUint32(&o.WAVE.Reg) & 0x100000) >> 20
}
func (o *TCC_Type) SetWAVE_POL5(value uint32) {
	volatile.StoreUint32(&o.WAVE.Reg, volatile.LoadUint32(&o.WAVE.Reg)&^(0x200000)|value<<21)
}
func (o *TCC_Type) GetWAVE_POL5() uint32 {
	return (volatile.LoadUint32(&o.WAVE.Reg) & 0x200000) >> 21
}
func (o *TCC_Type) SetWAVE_SWAP0(value uint32) {
	volatile.StoreUint32(&o.WAVE.Reg, volatile.LoadUint32(&o.WAVE.Reg)&^(0x1000000)|value<<24)
}
func (o *TCC_Type) GetWAVE_SWAP0() uint32 {
	return (volatile.LoadUint32(&o.WAVE.Reg) & 0x1000000) >> 24
}
func (o *TCC_Type) SetWAVE_SWAP1(value uint32) {
	volatile.StoreUint32(&o.WAVE.Reg, volatile.LoadUint32(&o.WAVE.Reg)&^(0x2000000)|value<<25)
}
func (o *TCC_Type) GetWAVE_SWAP1() uint32 {
	return (volatile.LoadUint32(&o.WAVE.Reg) & 0x2000000) >> 25
}
func (o *TCC_Type) SetWAVE_SWAP2(value uint32) {
	volatile.StoreUint32(&o.WAVE.Reg, volatile.LoadUint32(&o.WAVE.Reg)&^(0x4000000)|value<<26)
}
func (o *TCC_Type) GetWAVE_SWAP2() uint32 {
	return (volatile.LoadUint32(&o.WAVE.Reg) & 0x4000000) >> 26
}
func (o *TCC_Type) SetWAVE_SWAP3(value uint32) {
	volatile.StoreUint32(&o.WAVE.Reg, volatile.LoadUint32(&o.WAVE.Reg)&^(0x8000000)|value<<27)
}
func (o *TCC_Type) GetWAVE_SWAP3() uint32 {
	return (volatile.LoadUint32(&o.WAVE.Reg) & 0x8000000) >> 27
}

// TCC.PER: Period
func (o *TCC_Type) SetPER(value uint32) {
	volatile.StoreUint32(&o.PER.Reg, volatile.LoadUint32(&o.PER.Reg)&^(0xffffff)|value)
}
func (o *TCC_Type) GetPER() uint32 {
	return volatile.LoadUint32(&o.PER.Reg) & 0xffffff
}

// TCC.CC: Compare and Capture
func (o *TCC_Type) SetCC(idx int, value uint32) {
	volatile.StoreUint32(&o.CC[idx].Reg, volatile.LoadUint32(&o.CC[idx].Reg)&^(0xffffff)|value)
}
func (o *TCC_Type) GetCC(idx int) uint32 {
	return volatile.LoadUint32(&o.CC[idx].Reg) & 0xffffff
}

// TCC.PATTBUF: Pattern Buffer
func (o *TCC_Type) SetPATTBUF_PGEB0(value uint16) {
	volatile.StoreUint16(&o.PATTBUF.Reg, volatile.LoadUint16(&o.PATTBUF.Reg)&^(0x1)|value)
}
func (o *TCC_Type) GetPATTBUF_PGEB0() uint16 {
	return volatile.LoadUint16(&o.PATTBUF.Reg) & 0x1
}
func (o *TCC_Type) SetPATTBUF_PGEB1(value uint16) {
	volatile.StoreUint16(&o.PATTBUF.Reg, volatile.LoadUint16(&o.PATTBUF.Reg)&^(0x2)|value<<1)
}
func (o *TCC_Type) GetPATTBUF_PGEB1() uint16 {
	return (volatile.LoadUint16(&o.PATTBUF.Reg) & 0x2) >> 1
}
func (o *TCC_Type) SetPATTBUF_PGEB2(value uint16) {
	volatile.StoreUint16(&o.PATTBUF.Reg, volatile.LoadUint16(&o.PATTBUF.Reg)&^(0x4)|value<<2)
}
func (o *TCC_Type) GetPATTBUF_PGEB2() uint16 {
	return (volatile.LoadUint16(&o.PATTBUF.Reg) & 0x4) >> 2
}
func (o *TCC_Type) SetPATTBUF_PGEB3(value uint16) {
	volatile.StoreUint16(&o.PATTBUF.Reg, volatile.LoadUint16(&o.PATTBUF.Reg)&^(0x8)|value<<3)
}
func (o *TCC_Type) GetPATTBUF_PGEB3() uint16 {
	return (volatile.LoadUint16(&o.PATTBUF.Reg) & 0x8) >> 3
}
func (o *TCC_Type) SetPATTBUF_PGEB4(value uint16) {
	volatile.StoreUint16(&o.PATTBUF.Reg, volatile.LoadUint16(&o.PATTBUF.Reg)&^(0x10)|value<<4)
}
func (o *TCC_Type) GetPATTBUF_PGEB4() uint16 {
	return (volatile.LoadUint16(&o.PATTBUF.Reg) & 0x10) >> 4
}
func (o *TCC_Type) SetPATTBUF_PGEB5(value uint16) {
	volatile.StoreUint16(&o.PATTBUF.Reg, volatile.LoadUint16(&o.PATTBUF.Reg)&^(0x20)|value<<5)
}
func (o *TCC_Type) GetPATTBUF_PGEB5() uint16 {
	return (volatile.LoadUint16(&o.PATTBUF.Reg) & 0x20) >> 5
}
func (o *TCC_Type) SetPATTBUF_PGEB6(value uint16) {
	volatile.StoreUint16(&o.PATTBUF.Reg, volatile.LoadUint16(&o.PATTBUF.Reg)&^(0x40)|value<<6)
}
func (o *TCC_Type) GetPATTBUF_PGEB6() uint16 {
	return (volatile.LoadUint16(&o.PATTBUF.Reg) & 0x40) >> 6
}
func (o *TCC_Type) SetPATTBUF_PGEB7(value uint16) {
	volatile.StoreUint16(&o.PATTBUF.Reg, volatile.LoadUint16(&o.PATTBUF.Reg)&^(0x80)|value<<7)
}
func (o *TCC_Type) GetPATTBUF_PGEB7() uint16 {
	return (volatile.LoadUint16(&o.PATTBUF.Reg) & 0x80) >> 7
}
func (o *TCC_Type) SetPATTBUF_PGVB0(value uint16) {
	volatile.StoreUint16(&o.PATTBUF.Reg, volatile.LoadUint16(&o.PATTBUF.Reg)&^(0x100)|value<<8)
}
func (o *TCC_Type) GetPATTBUF_PGVB0() uint16 {
	return (volatile.LoadUint16(&o.PATTBUF.Reg) & 0x100) >> 8
}
func (o *TCC_Type) SetPATTBUF_PGVB1(value uint16) {
	volatile.StoreUint16(&o.PATTBUF.Reg, volatile.LoadUint16(&o.PATTBUF.Reg)&^(0x200)|value<<9)
}
func (o *TCC_Type) GetPATTBUF_PGVB1() uint16 {
	return (volatile.LoadUint16(&o.PATTBUF.Reg) & 0x200) >> 9
}
func (o *TCC_Type) SetPATTBUF_PGVB2(value uint16) {
	volatile.StoreUint16(&o.PATTBUF.Reg, volatile.LoadUint16(&o.PATTBUF.Reg)&^(0x400)|value<<10)
}
func (o *TCC_Type) GetPATTBUF_PGVB2() uint16 {
	return (volatile.LoadUint16(&o.PATTBUF.Reg) & 0x400) >> 10
}
func (o *TCC_Type) SetPATTBUF_PGVB3(value uint16) {
	volatile.StoreUint16(&o.PATTBUF.Reg, volatile.LoadUint16(&o.PATTBUF.Reg)&^(0x800)|value<<11)
}
func (o *TCC_Type) GetPATTBUF_PGVB3() uint16 {
	return (volatile.LoadUint16(&o.PATTBUF.Reg) & 0x800) >> 11
}
func (o *TCC_Type) SetPATTBUF_PGVB4(value uint16) {
	volatile.StoreUint16(&o.PATTBUF.Reg, volatile.LoadUint16(&o.PATTBUF.Reg)&^(0x1000)|value<<12)
}
func (o *TCC_Type) GetPATTBUF_PGVB4() uint16 {
	return (volatile.LoadUint16(&o.PATTBUF.Reg) & 0x1000) >> 12
}
func (o *TCC_Type) SetPATTBUF_PGVB5(value uint16) {
	volatile.StoreUint16(&o.PATTBUF.Reg, volatile.LoadUint16(&o.PATTBUF.Reg)&^(0x2000)|value<<13)
}
func (o *TCC_Type) GetPATTBUF_PGVB5() uint16 {
	return (volatile.LoadUint16(&o.PATTBUF.Reg) & 0x2000) >> 13
}
func (o *TCC_Type) SetPATTBUF_PGVB6(value uint16) {
	volatile.StoreUint16(&o.PATTBUF.Reg, volatile.LoadUint16(&o.PATTBUF.Reg)&^(0x4000)|value<<14)
}
func (o *TCC_Type) GetPATTBUF_PGVB6() uint16 {
	return (volatile.LoadUint16(&o.PATTBUF.Reg) & 0x4000) >> 14
}
func (o *TCC_Type) SetPATTBUF_PGVB7(value uint16) {
	volatile.StoreUint16(&o.PATTBUF.Reg, volatile.LoadUint16(&o.PATTBUF.Reg)&^(0x8000)|value<<15)
}
func (o *TCC_Type) GetPATTBUF_PGVB7() uint16 {
	return (volatile.LoadUint16(&o.PATTBUF.Reg) & 0x8000) >> 15
}

// TCC.PERBUF: Period Buffer
func (o *TCC_Type) SetPERBUF(value uint32) {
	volatile.StoreUint32(&o.PERBUF.Reg, volatile.LoadUint32(&o.PERBUF.Reg)&^(0xffffff)|value)
}
func (o *TCC_Type) GetPERBUF() uint32 {
	return volatile.LoadUint32(&o.PERBUF.Reg) & 0xffffff
}

// TCC.CCBUF: Compare and Capture Buffer
func (o *TCC_Type) SetCCBUF(idx int, value uint32) {
	volatile.StoreUint32(&o.CCBUF[idx].Reg, volatile.LoadUint32(&o.CCBUF[idx].Reg)&^(0xffffff)|value)
}
func (o *TCC_Type) GetCCBUF(idx int) uint32 {
	return volatile.LoadUint32(&o.CCBUF[idx].Reg) & 0xffffff
}

// True Random Generator
type TRNG_Type struct {
	CTRLA    volatile.Register8 // 0x0
	_        [3]byte
	EVCTRL   volatile.Register8 // 0x4
	_        [3]byte
	INTENCLR volatile.Register8 // 0x8
	INTENSET volatile.Register8 // 0x9
	INTFLAG  volatile.Register8 // 0xA
	_        [21]byte
	DATA     volatile.Register32 // 0x20
}

// TRNG.CTRLA: Control A
func (o *TRNG_Type) SetCTRLA_ENABLE(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *TRNG_Type) GetCTRLA_ENABLE() uint8 {
	return (volatile.LoadUint8(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *TRNG_Type) SetCTRLA_RUNSTDBY(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x40)|value<<6)
}
func (o *TRNG_Type) GetCTRLA_RUNSTDBY() uint8 {
	return (volatile.LoadUint8(&o.CTRLA.Reg) & 0x40) >> 6
}

// TRNG.EVCTRL: Event Control
func (o *TRNG_Type) SetEVCTRL_DATARDYEO(value uint8) {
	volatile.StoreUint8(&o.EVCTRL.Reg, volatile.LoadUint8(&o.EVCTRL.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetEVCTRL_DATARDYEO() uint8 {
	return volatile.LoadUint8(&o.EVCTRL.Reg) & 0x1
}

// TRNG.INTENCLR: Interrupt Enable Clear
func (o *TRNG_Type) SetINTENCLR_DATARDY(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetINTENCLR_DATARDY() uint8 {
	return volatile.LoadUint8(&o.INTENCLR.Reg) & 0x1
}

// TRNG.INTENSET: Interrupt Enable Set
func (o *TRNG_Type) SetINTENSET_DATARDY(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetINTENSET_DATARDY() uint8 {
	return volatile.LoadUint8(&o.INTENSET.Reg) & 0x1
}

// TRNG.INTFLAG: Interrupt Flag Status and Clear
func (o *TRNG_Type) SetINTFLAG_DATARDY(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetINTFLAG_DATARDY() uint8 {
	return volatile.LoadUint8(&o.INTFLAG.Reg) & 0x1
}

// TRNG.DATA: Output Data
func (o *TRNG_Type) SetDATA(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, value)
}
func (o *TRNG_Type) GetDATA() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg)
}

// Universal Serial Bus
type USB_Type struct {
}

// Universal Serial Bus - DEVICE
type USB_DEVICE_Type struct {
	CTRLA           volatile.Register8 // 0x0
	_               byte
	SYNCBUSY        volatile.Register8 // 0x2
	QOSCTRL         volatile.Register8 // 0x3
	_               [4]byte
	CTRLB           volatile.Register16 // 0x8
	DADD            volatile.Register8  // 0xA
	_               byte
	STATUS          volatile.Register8 // 0xC
	FSMSTATUS       volatile.Register8 // 0xD
	_               [2]byte
	FNUM            volatile.Register16 // 0x10
	_               [2]byte
	INTENCLR        volatile.Register16 // 0x14
	_               [2]byte
	INTENSET        volatile.Register16 // 0x18
	_               [2]byte
	INTFLAG         volatile.Register16 // 0x1C
	_               [2]byte
	EPINTSMRY       volatile.Register16 // 0x20
	_               [2]byte
	DESCADD         volatile.Register32 // 0x24
	PADCAL          volatile.Register16 // 0x28
	_               [214]byte
	DEVICE_ENDPOINT [8]USB_DEVICE_DEVICE_ENDPOINT_Type // 0x100
}

// USB_DEVICE.CTRLA: Control A
func (o *USB_DEVICE_Type) SetCTRLA_SWRST(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_Type) GetCTRLA_SWRST() uint8 {
	return volatile.LoadUint8(&o.CTRLA.Reg) & 0x1
}
func (o *USB_DEVICE_Type) SetCTRLA_ENABLE(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_Type) GetCTRLA_ENABLE() uint8 {
	return (volatile.LoadUint8(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *USB_DEVICE_Type) SetCTRLA_RUNSTDBY(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x4)|value<<2)
}
func (o *USB_DEVICE_Type) GetCTRLA_RUNSTDBY() uint8 {
	return (volatile.LoadUint8(&o.CTRLA.Reg) & 0x4) >> 2
}
func (o *USB_DEVICE_Type) SetCTRLA_MODE(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x80)|value<<7)
}
func (o *USB_DEVICE_Type) GetCTRLA_MODE() uint8 {
	return (volatile.LoadUint8(&o.CTRLA.Reg) & 0x80) >> 7
}

// USB_DEVICE.SYNCBUSY: Synchronization Busy
func (o *USB_DEVICE_Type) SetSYNCBUSY_SWRST(value uint8) {
	volatile.StoreUint8(&o.SYNCBUSY.Reg, volatile.LoadUint8(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_Type) GetSYNCBUSY_SWRST() uint8 {
	return volatile.LoadUint8(&o.SYNCBUSY.Reg) & 0x1
}
func (o *USB_DEVICE_Type) SetSYNCBUSY_ENABLE(value uint8) {
	volatile.StoreUint8(&o.SYNCBUSY.Reg, volatile.LoadUint8(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_Type) GetSYNCBUSY_ENABLE() uint8 {
	return (volatile.LoadUint8(&o.SYNCBUSY.Reg) & 0x2) >> 1
}

// USB_DEVICE.QOSCTRL: USB Quality Of Service
func (o *USB_DEVICE_Type) SetQOSCTRL_CQOS(value uint8) {
	volatile.StoreUint8(&o.QOSCTRL.Reg, volatile.LoadUint8(&o.QOSCTRL.Reg)&^(0x3)|value)
}
func (o *USB_DEVICE_Type) GetQOSCTRL_CQOS() uint8 {
	return volatile.LoadUint8(&o.QOSCTRL.Reg) & 0x3
}
func (o *USB_DEVICE_Type) SetQOSCTRL_DQOS(value uint8) {
	volatile.StoreUint8(&o.QOSCTRL.Reg, volatile.LoadUint8(&o.QOSCTRL.Reg)&^(0xc)|value<<2)
}
func (o *USB_DEVICE_Type) GetQOSCTRL_DQOS() uint8 {
	return (volatile.LoadUint8(&o.QOSCTRL.Reg) & 0xc) >> 2
}

// USB_DEVICE.CTRLB: DEVICE Control B
func (o *USB_DEVICE_Type) SetCTRLB_DETACH(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_Type) GetCTRLB_DETACH() uint16 {
	return volatile.LoadUint16(&o.CTRLB.Reg) & 0x1
}
func (o *USB_DEVICE_Type) SetCTRLB_UPRSM(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_Type) GetCTRLB_UPRSM() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x2) >> 1
}
func (o *USB_DEVICE_Type) SetCTRLB_SPDCONF(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0xc)|value<<2)
}
func (o *USB_DEVICE_Type) GetCTRLB_SPDCONF() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0xc) >> 2
}
func (o *USB_DEVICE_Type) SetCTRLB_NREPLY(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x10)|value<<4)
}
func (o *USB_DEVICE_Type) GetCTRLB_NREPLY() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x10) >> 4
}
func (o *USB_DEVICE_Type) SetCTRLB_TSTJ(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x20)|value<<5)
}
func (o *USB_DEVICE_Type) GetCTRLB_TSTJ() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x20) >> 5
}
func (o *USB_DEVICE_Type) SetCTRLB_TSTK(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x40)|value<<6)
}
func (o *USB_DEVICE_Type) GetCTRLB_TSTK() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x40) >> 6
}
func (o *USB_DEVICE_Type) SetCTRLB_TSTPCKT(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x80)|value<<7)
}
func (o *USB_DEVICE_Type) GetCTRLB_TSTPCKT() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x80) >> 7
}
func (o *USB_DEVICE_Type) SetCTRLB_OPMODE2(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x100)|value<<8)
}
func (o *USB_DEVICE_Type) GetCTRLB_OPMODE2() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x100) >> 8
}
func (o *USB_DEVICE_Type) SetCTRLB_GNAK(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x200)|value<<9)
}
func (o *USB_DEVICE_Type) GetCTRLB_GNAK() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x200) >> 9
}
func (o *USB_DEVICE_Type) SetCTRLB_LPMHDSK(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0xc00)|value<<10)
}
func (o *USB_DEVICE_Type) GetCTRLB_LPMHDSK() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0xc00) >> 10
}

// USB_DEVICE.DADD: DEVICE Device Address
func (o *USB_DEVICE_Type) SetDADD(value uint8) {
	volatile.StoreUint8(&o.DADD.Reg, volatile.LoadUint8(&o.DADD.Reg)&^(0x7f)|value)
}
func (o *USB_DEVICE_Type) GetDADD() uint8 {
	return volatile.LoadUint8(&o.DADD.Reg) & 0x7f
}
func (o *USB_DEVICE_Type) SetDADD_ADDEN(value uint8) {
	volatile.StoreUint8(&o.DADD.Reg, volatile.LoadUint8(&o.DADD.Reg)&^(0x80)|value<<7)
}
func (o *USB_DEVICE_Type) GetDADD_ADDEN() uint8 {
	return (volatile.LoadUint8(&o.DADD.Reg) & 0x80) >> 7
}

// USB_DEVICE.STATUS: DEVICE Status
func (o *USB_DEVICE_Type) SetSTATUS_SPEED(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0xc)|value<<2)
}
func (o *USB_DEVICE_Type) GetSTATUS_SPEED() uint8 {
	return (volatile.LoadUint8(&o.STATUS.Reg) & 0xc) >> 2
}
func (o *USB_DEVICE_Type) SetSTATUS_LINESTATE(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0xc0)|value<<6)
}
func (o *USB_DEVICE_Type) GetSTATUS_LINESTATE() uint8 {
	return (volatile.LoadUint8(&o.STATUS.Reg) & 0xc0) >> 6
}

// USB_DEVICE.FSMSTATUS: Finite State Machine Status
func (o *USB_DEVICE_Type) SetFSMSTATUS_FSMSTATE(value uint8) {
	volatile.StoreUint8(&o.FSMSTATUS.Reg, volatile.LoadUint8(&o.FSMSTATUS.Reg)&^(0x7f)|value)
}
func (o *USB_DEVICE_Type) GetFSMSTATUS_FSMSTATE() uint8 {
	return volatile.LoadUint8(&o.FSMSTATUS.Reg) & 0x7f
}

// USB_DEVICE.FNUM: DEVICE Device Frame Number
func (o *USB_DEVICE_Type) SetFNUM_MFNUM(value uint16) {
	volatile.StoreUint16(&o.FNUM.Reg, volatile.LoadUint16(&o.FNUM.Reg)&^(0x7)|value)
}
func (o *USB_DEVICE_Type) GetFNUM_MFNUM() uint16 {
	return volatile.LoadUint16(&o.FNUM.Reg) & 0x7
}
func (o *USB_DEVICE_Type) SetFNUM(value uint16) {
	volatile.StoreUint16(&o.FNUM.Reg, volatile.LoadUint16(&o.FNUM.Reg)&^(0x3ff8)|value<<3)
}
func (o *USB_DEVICE_Type) GetFNUM() uint16 {
	return (volatile.LoadUint16(&o.FNUM.Reg) & 0x3ff8) >> 3
}
func (o *USB_DEVICE_Type) SetFNUM_FNCERR(value uint16) {
	volatile.StoreUint16(&o.FNUM.Reg, volatile.LoadUint16(&o.FNUM.Reg)&^(0x8000)|value<<15)
}
func (o *USB_DEVICE_Type) GetFNUM_FNCERR() uint16 {
	return (volatile.LoadUint16(&o.FNUM.Reg) & 0x8000) >> 15
}

// USB_DEVICE.INTENCLR: DEVICE Device Interrupt Enable Clear
func (o *USB_DEVICE_Type) SetINTENCLR_SUSPEND(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_Type) GetINTENCLR_SUSPEND() uint16 {
	return volatile.LoadUint16(&o.INTENCLR.Reg) & 0x1
}
func (o *USB_DEVICE_Type) SetINTENCLR_MSOF(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_Type) GetINTENCLR_MSOF() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x2) >> 1
}
func (o *USB_DEVICE_Type) SetINTENCLR_SOF(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *USB_DEVICE_Type) GetINTENCLR_SOF() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *USB_DEVICE_Type) SetINTENCLR_EORST(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *USB_DEVICE_Type) GetINTENCLR_EORST() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *USB_DEVICE_Type) SetINTENCLR_WAKEUP(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *USB_DEVICE_Type) GetINTENCLR_WAKEUP() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *USB_DEVICE_Type) SetINTENCLR_EORSM(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *USB_DEVICE_Type) GetINTENCLR_EORSM() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *USB_DEVICE_Type) SetINTENCLR_UPRSM(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *USB_DEVICE_Type) GetINTENCLR_UPRSM() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *USB_DEVICE_Type) SetINTENCLR_RAMACER(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *USB_DEVICE_Type) GetINTENCLR_RAMACER() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *USB_DEVICE_Type) SetINTENCLR_LPMNYET(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *USB_DEVICE_Type) GetINTENCLR_LPMNYET() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *USB_DEVICE_Type) SetINTENCLR_LPMSUSP(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *USB_DEVICE_Type) GetINTENCLR_LPMSUSP() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x200) >> 9
}

// USB_DEVICE.INTENSET: DEVICE Device Interrupt Enable Set
func (o *USB_DEVICE_Type) SetINTENSET_SUSPEND(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_Type) GetINTENSET_SUSPEND() uint16 {
	return volatile.LoadUint16(&o.INTENSET.Reg) & 0x1
}
func (o *USB_DEVICE_Type) SetINTENSET_MSOF(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_Type) GetINTENSET_MSOF() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x2) >> 1
}
func (o *USB_DEVICE_Type) SetINTENSET_SOF(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *USB_DEVICE_Type) GetINTENSET_SOF() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *USB_DEVICE_Type) SetINTENSET_EORST(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *USB_DEVICE_Type) GetINTENSET_EORST() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *USB_DEVICE_Type) SetINTENSET_WAKEUP(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *USB_DEVICE_Type) GetINTENSET_WAKEUP() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *USB_DEVICE_Type) SetINTENSET_EORSM(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *USB_DEVICE_Type) GetINTENSET_EORSM() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *USB_DEVICE_Type) SetINTENSET_UPRSM(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *USB_DEVICE_Type) GetINTENSET_UPRSM() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *USB_DEVICE_Type) SetINTENSET_RAMACER(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *USB_DEVICE_Type) GetINTENSET_RAMACER() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *USB_DEVICE_Type) SetINTENSET_LPMNYET(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *USB_DEVICE_Type) GetINTENSET_LPMNYET() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *USB_DEVICE_Type) SetINTENSET_LPMSUSP(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *USB_DEVICE_Type) GetINTENSET_LPMSUSP() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x200) >> 9
}

// USB_DEVICE.INTFLAG: DEVICE Device Interrupt Flag
func (o *USB_DEVICE_Type) SetINTFLAG_SUSPEND(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_Type) GetINTFLAG_SUSPEND() uint16 {
	return volatile.LoadUint16(&o.INTFLAG.Reg) & 0x1
}
func (o *USB_DEVICE_Type) SetINTFLAG_MSOF(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_Type) GetINTFLAG_MSOF() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x2) >> 1
}
func (o *USB_DEVICE_Type) SetINTFLAG_SOF(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x4)|value<<2)
}
func (o *USB_DEVICE_Type) GetINTFLAG_SOF() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x4) >> 2
}
func (o *USB_DEVICE_Type) SetINTFLAG_EORST(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x8)|value<<3)
}
func (o *USB_DEVICE_Type) GetINTFLAG_EORST() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x8) >> 3
}
func (o *USB_DEVICE_Type) SetINTFLAG_WAKEUP(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x10)|value<<4)
}
func (o *USB_DEVICE_Type) GetINTFLAG_WAKEUP() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x10) >> 4
}
func (o *USB_DEVICE_Type) SetINTFLAG_EORSM(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x20)|value<<5)
}
func (o *USB_DEVICE_Type) GetINTFLAG_EORSM() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x20) >> 5
}
func (o *USB_DEVICE_Type) SetINTFLAG_UPRSM(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x40)|value<<6)
}
func (o *USB_DEVICE_Type) GetINTFLAG_UPRSM() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x40) >> 6
}
func (o *USB_DEVICE_Type) SetINTFLAG_RAMACER(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x80)|value<<7)
}
func (o *USB_DEVICE_Type) GetINTFLAG_RAMACER() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x80) >> 7
}
func (o *USB_DEVICE_Type) SetINTFLAG_LPMNYET(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x100)|value<<8)
}
func (o *USB_DEVICE_Type) GetINTFLAG_LPMNYET() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x100) >> 8
}
func (o *USB_DEVICE_Type) SetINTFLAG_LPMSUSP(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x200)|value<<9)
}
func (o *USB_DEVICE_Type) GetINTFLAG_LPMSUSP() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x200) >> 9
}

// USB_DEVICE.EPINTSMRY: DEVICE End Point Interrupt Summary
func (o *USB_DEVICE_Type) SetEPINTSMRY_EPINT0(value uint16) {
	volatile.StoreUint16(&o.EPINTSMRY.Reg, volatile.LoadUint16(&o.EPINTSMRY.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_Type) GetEPINTSMRY_EPINT0() uint16 {
	return volatile.LoadUint16(&o.EPINTSMRY.Reg) & 0x1
}
func (o *USB_DEVICE_Type) SetEPINTSMRY_EPINT1(value uint16) {
	volatile.StoreUint16(&o.EPINTSMRY.Reg, volatile.LoadUint16(&o.EPINTSMRY.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_Type) GetEPINTSMRY_EPINT1() uint16 {
	return (volatile.LoadUint16(&o.EPINTSMRY.Reg) & 0x2) >> 1
}
func (o *USB_DEVICE_Type) SetEPINTSMRY_EPINT2(value uint16) {
	volatile.StoreUint16(&o.EPINTSMRY.Reg, volatile.LoadUint16(&o.EPINTSMRY.Reg)&^(0x4)|value<<2)
}
func (o *USB_DEVICE_Type) GetEPINTSMRY_EPINT2() uint16 {
	return (volatile.LoadUint16(&o.EPINTSMRY.Reg) & 0x4) >> 2
}
func (o *USB_DEVICE_Type) SetEPINTSMRY_EPINT3(value uint16) {
	volatile.StoreUint16(&o.EPINTSMRY.Reg, volatile.LoadUint16(&o.EPINTSMRY.Reg)&^(0x8)|value<<3)
}
func (o *USB_DEVICE_Type) GetEPINTSMRY_EPINT3() uint16 {
	return (volatile.LoadUint16(&o.EPINTSMRY.Reg) & 0x8) >> 3
}
func (o *USB_DEVICE_Type) SetEPINTSMRY_EPINT4(value uint16) {
	volatile.StoreUint16(&o.EPINTSMRY.Reg, volatile.LoadUint16(&o.EPINTSMRY.Reg)&^(0x10)|value<<4)
}
func (o *USB_DEVICE_Type) GetEPINTSMRY_EPINT4() uint16 {
	return (volatile.LoadUint16(&o.EPINTSMRY.Reg) & 0x10) >> 4
}
func (o *USB_DEVICE_Type) SetEPINTSMRY_EPINT5(value uint16) {
	volatile.StoreUint16(&o.EPINTSMRY.Reg, volatile.LoadUint16(&o.EPINTSMRY.Reg)&^(0x20)|value<<5)
}
func (o *USB_DEVICE_Type) GetEPINTSMRY_EPINT5() uint16 {
	return (volatile.LoadUint16(&o.EPINTSMRY.Reg) & 0x20) >> 5
}
func (o *USB_DEVICE_Type) SetEPINTSMRY_EPINT6(value uint16) {
	volatile.StoreUint16(&o.EPINTSMRY.Reg, volatile.LoadUint16(&o.EPINTSMRY.Reg)&^(0x40)|value<<6)
}
func (o *USB_DEVICE_Type) GetEPINTSMRY_EPINT6() uint16 {
	return (volatile.LoadUint16(&o.EPINTSMRY.Reg) & 0x40) >> 6
}
func (o *USB_DEVICE_Type) SetEPINTSMRY_EPINT7(value uint16) {
	volatile.StoreUint16(&o.EPINTSMRY.Reg, volatile.LoadUint16(&o.EPINTSMRY.Reg)&^(0x80)|value<<7)
}
func (o *USB_DEVICE_Type) GetEPINTSMRY_EPINT7() uint16 {
	return (volatile.LoadUint16(&o.EPINTSMRY.Reg) & 0x80) >> 7
}

// USB_DEVICE.DESCADD: Descriptor Address
func (o *USB_DEVICE_Type) SetDESCADD(value uint32) {
	volatile.StoreUint32(&o.DESCADD.Reg, value)
}
func (o *USB_DEVICE_Type) GetDESCADD() uint32 {
	return volatile.LoadUint32(&o.DESCADD.Reg)
}

// USB_DEVICE.PADCAL: USB PAD Calibration
func (o *USB_DEVICE_Type) SetPADCAL_TRANSP(value uint16) {
	volatile.StoreUint16(&o.PADCAL.Reg, volatile.LoadUint16(&o.PADCAL.Reg)&^(0x1f)|value)
}
func (o *USB_DEVICE_Type) GetPADCAL_TRANSP() uint16 {
	return volatile.LoadUint16(&o.PADCAL.Reg) & 0x1f
}
func (o *USB_DEVICE_Type) SetPADCAL_TRANSN(value uint16) {
	volatile.StoreUint16(&o.PADCAL.Reg, volatile.LoadUint16(&o.PADCAL.Reg)&^(0x7c0)|value<<6)
}
func (o *USB_DEVICE_Type) GetPADCAL_TRANSN() uint16 {
	return (volatile.LoadUint16(&o.PADCAL.Reg) & 0x7c0) >> 6
}
func (o *USB_DEVICE_Type) SetPADCAL_TRIM(value uint16) {
	volatile.StoreUint16(&o.PADCAL.Reg, volatile.LoadUint16(&o.PADCAL.Reg)&^(0x7000)|value<<12)
}
func (o *USB_DEVICE_Type) GetPADCAL_TRIM() uint16 {
	return (volatile.LoadUint16(&o.PADCAL.Reg) & 0x7000) >> 12
}

type USB_DEVICE_DEVICE_ENDPOINT_Type struct {
	EPCFG       volatile.Register8 // 0x100
	_           [3]byte
	EPSTATUSCLR volatile.Register8 // 0x104
	EPSTATUSSET volatile.Register8 // 0x105
	EPSTATUS    volatile.Register8 // 0x106
	EPINTFLAG   volatile.Register8 // 0x107
	EPINTENCLR  volatile.Register8 // 0x108
	EPINTENSET  volatile.Register8 // 0x109
	_           [22]byte
}

// USB_DEVICE_DEVICE_ENDPOINT.EPCFG: DEVICE_ENDPOINT End Point Configuration
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPCFG_EPTYPE0(value uint8) {
	volatile.StoreUint8(&o.EPCFG.Reg, volatile.LoadUint8(&o.EPCFG.Reg)&^(0x7)|value)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPCFG_EPTYPE0() uint8 {
	return volatile.LoadUint8(&o.EPCFG.Reg) & 0x7
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPCFG_EPTYPE1(value uint8) {
	volatile.StoreUint8(&o.EPCFG.Reg, volatile.LoadUint8(&o.EPCFG.Reg)&^(0x70)|value<<4)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPCFG_EPTYPE1() uint8 {
	return (volatile.LoadUint8(&o.EPCFG.Reg) & 0x70) >> 4
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPCFG_NYETDIS(value uint8) {
	volatile.StoreUint8(&o.EPCFG.Reg, volatile.LoadUint8(&o.EPCFG.Reg)&^(0x80)|value<<7)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPCFG_NYETDIS() uint8 {
	return (volatile.LoadUint8(&o.EPCFG.Reg) & 0x80) >> 7
}

// USB_DEVICE_DEVICE_ENDPOINT.EPSTATUSCLR: DEVICE_ENDPOINT End Point Pipe Status Clear
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPSTATUSCLR_DTGLOUT(value uint8) {
	volatile.StoreUint8(&o.EPSTATUSCLR.Reg, volatile.LoadUint8(&o.EPSTATUSCLR.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPSTATUSCLR_DTGLOUT() uint8 {
	return volatile.LoadUint8(&o.EPSTATUSCLR.Reg) & 0x1
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPSTATUSCLR_DTGLIN(value uint8) {
	volatile.StoreUint8(&o.EPSTATUSCLR.Reg, volatile.LoadUint8(&o.EPSTATUSCLR.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPSTATUSCLR_DTGLIN() uint8 {
	return (volatile.LoadUint8(&o.EPSTATUSCLR.Reg) & 0x2) >> 1
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPSTATUSCLR_CURBK(value uint8) {
	volatile.StoreUint8(&o.EPSTATUSCLR.Reg, volatile.LoadUint8(&o.EPSTATUSCLR.Reg)&^(0x4)|value<<2)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPSTATUSCLR_CURBK() uint8 {
	return (volatile.LoadUint8(&o.EPSTATUSCLR.Reg) & 0x4) >> 2
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPSTATUSCLR_STALLRQ0(value uint8) {
	volatile.StoreUint8(&o.EPSTATUSCLR.Reg, volatile.LoadUint8(&o.EPSTATUSCLR.Reg)&^(0x10)|value<<4)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPSTATUSCLR_STALLRQ0() uint8 {
	return (volatile.LoadUint8(&o.EPSTATUSCLR.Reg) & 0x10) >> 4
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPSTATUSCLR_STALLRQ1(value uint8) {
	volatile.StoreUint8(&o.EPSTATUSCLR.Reg, volatile.LoadUint8(&o.EPSTATUSCLR.Reg)&^(0x20)|value<<5)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPSTATUSCLR_STALLRQ1() uint8 {
	return (volatile.LoadUint8(&o.EPSTATUSCLR.Reg) & 0x20) >> 5
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPSTATUSCLR_BK0RDY(value uint8) {
	volatile.StoreUint8(&o.EPSTATUSCLR.Reg, volatile.LoadUint8(&o.EPSTATUSCLR.Reg)&^(0x40)|value<<6)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPSTATUSCLR_BK0RDY() uint8 {
	return (volatile.LoadUint8(&o.EPSTATUSCLR.Reg) & 0x40) >> 6
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPSTATUSCLR_BK1RDY(value uint8) {
	volatile.StoreUint8(&o.EPSTATUSCLR.Reg, volatile.LoadUint8(&o.EPSTATUSCLR.Reg)&^(0x80)|value<<7)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPSTATUSCLR_BK1RDY() uint8 {
	return (volatile.LoadUint8(&o.EPSTATUSCLR.Reg) & 0x80) >> 7
}

// USB_DEVICE_DEVICE_ENDPOINT.EPSTATUSSET: DEVICE_ENDPOINT End Point Pipe Status Set
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPSTATUSSET_DTGLOUT(value uint8) {
	volatile.StoreUint8(&o.EPSTATUSSET.Reg, volatile.LoadUint8(&o.EPSTATUSSET.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPSTATUSSET_DTGLOUT() uint8 {
	return volatile.LoadUint8(&o.EPSTATUSSET.Reg) & 0x1
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPSTATUSSET_DTGLIN(value uint8) {
	volatile.StoreUint8(&o.EPSTATUSSET.Reg, volatile.LoadUint8(&o.EPSTATUSSET.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPSTATUSSET_DTGLIN() uint8 {
	return (volatile.LoadUint8(&o.EPSTATUSSET.Reg) & 0x2) >> 1
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPSTATUSSET_CURBK(value uint8) {
	volatile.StoreUint8(&o.EPSTATUSSET.Reg, volatile.LoadUint8(&o.EPSTATUSSET.Reg)&^(0x4)|value<<2)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPSTATUSSET_CURBK() uint8 {
	return (volatile.LoadUint8(&o.EPSTATUSSET.Reg) & 0x4) >> 2
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPSTATUSSET_STALLRQ0(value uint8) {
	volatile.StoreUint8(&o.EPSTATUSSET.Reg, volatile.LoadUint8(&o.EPSTATUSSET.Reg)&^(0x10)|value<<4)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPSTATUSSET_STALLRQ0() uint8 {
	return (volatile.LoadUint8(&o.EPSTATUSSET.Reg) & 0x10) >> 4
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPSTATUSSET_STALLRQ1(value uint8) {
	volatile.StoreUint8(&o.EPSTATUSSET.Reg, volatile.LoadUint8(&o.EPSTATUSSET.Reg)&^(0x20)|value<<5)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPSTATUSSET_STALLRQ1() uint8 {
	return (volatile.LoadUint8(&o.EPSTATUSSET.Reg) & 0x20) >> 5
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPSTATUSSET_BK0RDY(value uint8) {
	volatile.StoreUint8(&o.EPSTATUSSET.Reg, volatile.LoadUint8(&o.EPSTATUSSET.Reg)&^(0x40)|value<<6)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPSTATUSSET_BK0RDY() uint8 {
	return (volatile.LoadUint8(&o.EPSTATUSSET.Reg) & 0x40) >> 6
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPSTATUSSET_BK1RDY(value uint8) {
	volatile.StoreUint8(&o.EPSTATUSSET.Reg, volatile.LoadUint8(&o.EPSTATUSSET.Reg)&^(0x80)|value<<7)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPSTATUSSET_BK1RDY() uint8 {
	return (volatile.LoadUint8(&o.EPSTATUSSET.Reg) & 0x80) >> 7
}

// USB_DEVICE_DEVICE_ENDPOINT.EPSTATUS: DEVICE_ENDPOINT End Point Pipe Status
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPSTATUS_DTGLOUT(value uint8) {
	volatile.StoreUint8(&o.EPSTATUS.Reg, volatile.LoadUint8(&o.EPSTATUS.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPSTATUS_DTGLOUT() uint8 {
	return volatile.LoadUint8(&o.EPSTATUS.Reg) & 0x1
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPSTATUS_DTGLIN(value uint8) {
	volatile.StoreUint8(&o.EPSTATUS.Reg, volatile.LoadUint8(&o.EPSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPSTATUS_DTGLIN() uint8 {
	return (volatile.LoadUint8(&o.EPSTATUS.Reg) & 0x2) >> 1
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPSTATUS_CURBK(value uint8) {
	volatile.StoreUint8(&o.EPSTATUS.Reg, volatile.LoadUint8(&o.EPSTATUS.Reg)&^(0x4)|value<<2)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPSTATUS_CURBK() uint8 {
	return (volatile.LoadUint8(&o.EPSTATUS.Reg) & 0x4) >> 2
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPSTATUS_STALLRQ0(value uint8) {
	volatile.StoreUint8(&o.EPSTATUS.Reg, volatile.LoadUint8(&o.EPSTATUS.Reg)&^(0x10)|value<<4)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPSTATUS_STALLRQ0() uint8 {
	return (volatile.LoadUint8(&o.EPSTATUS.Reg) & 0x10) >> 4
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPSTATUS_STALLRQ1(value uint8) {
	volatile.StoreUint8(&o.EPSTATUS.Reg, volatile.LoadUint8(&o.EPSTATUS.Reg)&^(0x20)|value<<5)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPSTATUS_STALLRQ1() uint8 {
	return (volatile.LoadUint8(&o.EPSTATUS.Reg) & 0x20) >> 5
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPSTATUS_BK0RDY(value uint8) {
	volatile.StoreUint8(&o.EPSTATUS.Reg, volatile.LoadUint8(&o.EPSTATUS.Reg)&^(0x40)|value<<6)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPSTATUS_BK0RDY() uint8 {
	return (volatile.LoadUint8(&o.EPSTATUS.Reg) & 0x40) >> 6
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPSTATUS_BK1RDY(value uint8) {
	volatile.StoreUint8(&o.EPSTATUS.Reg, volatile.LoadUint8(&o.EPSTATUS.Reg)&^(0x80)|value<<7)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPSTATUS_BK1RDY() uint8 {
	return (volatile.LoadUint8(&o.EPSTATUS.Reg) & 0x80) >> 7
}

// USB_DEVICE_DEVICE_ENDPOINT.EPINTFLAG: DEVICE_ENDPOINT End Point Interrupt Flag
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPINTFLAG_TRCPT0(value uint8) {
	volatile.StoreUint8(&o.EPINTFLAG.Reg, volatile.LoadUint8(&o.EPINTFLAG.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPINTFLAG_TRCPT0() uint8 {
	return volatile.LoadUint8(&o.EPINTFLAG.Reg) & 0x1
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPINTFLAG_TRCPT1(value uint8) {
	volatile.StoreUint8(&o.EPINTFLAG.Reg, volatile.LoadUint8(&o.EPINTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPINTFLAG_TRCPT1() uint8 {
	return (volatile.LoadUint8(&o.EPINTFLAG.Reg) & 0x2) >> 1
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPINTFLAG_TRFAIL0(value uint8) {
	volatile.StoreUint8(&o.EPINTFLAG.Reg, volatile.LoadUint8(&o.EPINTFLAG.Reg)&^(0x4)|value<<2)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPINTFLAG_TRFAIL0() uint8 {
	return (volatile.LoadUint8(&o.EPINTFLAG.Reg) & 0x4) >> 2
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPINTFLAG_TRFAIL1(value uint8) {
	volatile.StoreUint8(&o.EPINTFLAG.Reg, volatile.LoadUint8(&o.EPINTFLAG.Reg)&^(0x8)|value<<3)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPINTFLAG_TRFAIL1() uint8 {
	return (volatile.LoadUint8(&o.EPINTFLAG.Reg) & 0x8) >> 3
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPINTFLAG_RXSTP(value uint8) {
	volatile.StoreUint8(&o.EPINTFLAG.Reg, volatile.LoadUint8(&o.EPINTFLAG.Reg)&^(0x10)|value<<4)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPINTFLAG_RXSTP() uint8 {
	return (volatile.LoadUint8(&o.EPINTFLAG.Reg) & 0x10) >> 4
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPINTFLAG_STALL0(value uint8) {
	volatile.StoreUint8(&o.EPINTFLAG.Reg, volatile.LoadUint8(&o.EPINTFLAG.Reg)&^(0x20)|value<<5)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPINTFLAG_STALL0() uint8 {
	return (volatile.LoadUint8(&o.EPINTFLAG.Reg) & 0x20) >> 5
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPINTFLAG_STALL1(value uint8) {
	volatile.StoreUint8(&o.EPINTFLAG.Reg, volatile.LoadUint8(&o.EPINTFLAG.Reg)&^(0x40)|value<<6)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPINTFLAG_STALL1() uint8 {
	return (volatile.LoadUint8(&o.EPINTFLAG.Reg) & 0x40) >> 6
}

// USB_DEVICE_DEVICE_ENDPOINT.EPINTENCLR: DEVICE_ENDPOINT End Point Interrupt Clear Flag
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPINTENCLR_TRCPT0(value uint8) {
	volatile.StoreUint8(&o.EPINTENCLR.Reg, volatile.LoadUint8(&o.EPINTENCLR.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPINTENCLR_TRCPT0() uint8 {
	return volatile.LoadUint8(&o.EPINTENCLR.Reg) & 0x1
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPINTENCLR_TRCPT1(value uint8) {
	volatile.StoreUint8(&o.EPINTENCLR.Reg, volatile.LoadUint8(&o.EPINTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPINTENCLR_TRCPT1() uint8 {
	return (volatile.LoadUint8(&o.EPINTENCLR.Reg) & 0x2) >> 1
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPINTENCLR_TRFAIL0(value uint8) {
	volatile.StoreUint8(&o.EPINTENCLR.Reg, volatile.LoadUint8(&o.EPINTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPINTENCLR_TRFAIL0() uint8 {
	return (volatile.LoadUint8(&o.EPINTENCLR.Reg) & 0x4) >> 2
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPINTENCLR_TRFAIL1(value uint8) {
	volatile.StoreUint8(&o.EPINTENCLR.Reg, volatile.LoadUint8(&o.EPINTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPINTENCLR_TRFAIL1() uint8 {
	return (volatile.LoadUint8(&o.EPINTENCLR.Reg) & 0x8) >> 3
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPINTENCLR_RXSTP(value uint8) {
	volatile.StoreUint8(&o.EPINTENCLR.Reg, volatile.LoadUint8(&o.EPINTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPINTENCLR_RXSTP() uint8 {
	return (volatile.LoadUint8(&o.EPINTENCLR.Reg) & 0x10) >> 4
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPINTENCLR_STALL0(value uint8) {
	volatile.StoreUint8(&o.EPINTENCLR.Reg, volatile.LoadUint8(&o.EPINTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPINTENCLR_STALL0() uint8 {
	return (volatile.LoadUint8(&o.EPINTENCLR.Reg) & 0x20) >> 5
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPINTENCLR_STALL1(value uint8) {
	volatile.StoreUint8(&o.EPINTENCLR.Reg, volatile.LoadUint8(&o.EPINTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPINTENCLR_STALL1() uint8 {
	return (volatile.LoadUint8(&o.EPINTENCLR.Reg) & 0x40) >> 6
}

// USB_DEVICE_DEVICE_ENDPOINT.EPINTENSET: DEVICE_ENDPOINT End Point Interrupt Set Flag
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPINTENSET_TRCPT0(value uint8) {
	volatile.StoreUint8(&o.EPINTENSET.Reg, volatile.LoadUint8(&o.EPINTENSET.Reg)&^(0x1)|value)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPINTENSET_TRCPT0() uint8 {
	return volatile.LoadUint8(&o.EPINTENSET.Reg) & 0x1
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPINTENSET_TRCPT1(value uint8) {
	volatile.StoreUint8(&o.EPINTENSET.Reg, volatile.LoadUint8(&o.EPINTENSET.Reg)&^(0x2)|value<<1)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPINTENSET_TRCPT1() uint8 {
	return (volatile.LoadUint8(&o.EPINTENSET.Reg) & 0x2) >> 1
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPINTENSET_TRFAIL0(value uint8) {
	volatile.StoreUint8(&o.EPINTENSET.Reg, volatile.LoadUint8(&o.EPINTENSET.Reg)&^(0x4)|value<<2)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPINTENSET_TRFAIL0() uint8 {
	return (volatile.LoadUint8(&o.EPINTENSET.Reg) & 0x4) >> 2
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPINTENSET_TRFAIL1(value uint8) {
	volatile.StoreUint8(&o.EPINTENSET.Reg, volatile.LoadUint8(&o.EPINTENSET.Reg)&^(0x8)|value<<3)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPINTENSET_TRFAIL1() uint8 {
	return (volatile.LoadUint8(&o.EPINTENSET.Reg) & 0x8) >> 3
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPINTENSET_RXSTP(value uint8) {
	volatile.StoreUint8(&o.EPINTENSET.Reg, volatile.LoadUint8(&o.EPINTENSET.Reg)&^(0x10)|value<<4)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPINTENSET_RXSTP() uint8 {
	return (volatile.LoadUint8(&o.EPINTENSET.Reg) & 0x10) >> 4
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPINTENSET_STALL0(value uint8) {
	volatile.StoreUint8(&o.EPINTENSET.Reg, volatile.LoadUint8(&o.EPINTENSET.Reg)&^(0x20)|value<<5)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPINTENSET_STALL0() uint8 {
	return (volatile.LoadUint8(&o.EPINTENSET.Reg) & 0x20) >> 5
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) SetEPINTENSET_STALL1(value uint8) {
	volatile.StoreUint8(&o.EPINTENSET.Reg, volatile.LoadUint8(&o.EPINTENSET.Reg)&^(0x40)|value<<6)
}
func (o *USB_DEVICE_DEVICE_ENDPOINT_Type) GetEPINTENSET_STALL1() uint8 {
	return (volatile.LoadUint8(&o.EPINTENSET.Reg) & 0x40) >> 6
}

// Universal Serial Bus - HOST
type USB_HOST_Type struct {
	CTRLA     volatile.Register8 // 0x0
	_         byte
	SYNCBUSY  volatile.Register8 // 0x2
	QOSCTRL   volatile.Register8 // 0x3
	_         [4]byte
	CTRLB     volatile.Register16 // 0x8
	HSOFC     volatile.Register8  // 0xA
	_         byte
	STATUS    volatile.Register8 // 0xC
	FSMSTATUS volatile.Register8 // 0xD
	_         [2]byte
	FNUM      volatile.Register16 // 0x10
	FLENHIGH  volatile.Register8  // 0x12
	_         byte
	INTENCLR  volatile.Register16 // 0x14
	_         [2]byte
	INTENSET  volatile.Register16 // 0x18
	_         [2]byte
	INTFLAG   volatile.Register16 // 0x1C
	_         [2]byte
	PINTSMRY  volatile.Register16 // 0x20
	_         [2]byte
	DESCADD   volatile.Register32 // 0x24
	PADCAL    volatile.Register16 // 0x28
	_         [214]byte
	HOST_PIPE [8]USB_HOST_HOST_PIPE_Type // 0x100
}

// USB_HOST.CTRLA: Control A
func (o *USB_HOST_Type) SetCTRLA_SWRST(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x1)|value)
}
func (o *USB_HOST_Type) GetCTRLA_SWRST() uint8 {
	return volatile.LoadUint8(&o.CTRLA.Reg) & 0x1
}
func (o *USB_HOST_Type) SetCTRLA_ENABLE(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *USB_HOST_Type) GetCTRLA_ENABLE() uint8 {
	return (volatile.LoadUint8(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *USB_HOST_Type) SetCTRLA_RUNSTDBY(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x4)|value<<2)
}
func (o *USB_HOST_Type) GetCTRLA_RUNSTDBY() uint8 {
	return (volatile.LoadUint8(&o.CTRLA.Reg) & 0x4) >> 2
}
func (o *USB_HOST_Type) SetCTRLA_MODE(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x80)|value<<7)
}
func (o *USB_HOST_Type) GetCTRLA_MODE() uint8 {
	return (volatile.LoadUint8(&o.CTRLA.Reg) & 0x80) >> 7
}

// USB_HOST.SYNCBUSY: Synchronization Busy
func (o *USB_HOST_Type) SetSYNCBUSY_SWRST(value uint8) {
	volatile.StoreUint8(&o.SYNCBUSY.Reg, volatile.LoadUint8(&o.SYNCBUSY.Reg)&^(0x1)|value)
}
func (o *USB_HOST_Type) GetSYNCBUSY_SWRST() uint8 {
	return volatile.LoadUint8(&o.SYNCBUSY.Reg) & 0x1
}
func (o *USB_HOST_Type) SetSYNCBUSY_ENABLE(value uint8) {
	volatile.StoreUint8(&o.SYNCBUSY.Reg, volatile.LoadUint8(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *USB_HOST_Type) GetSYNCBUSY_ENABLE() uint8 {
	return (volatile.LoadUint8(&o.SYNCBUSY.Reg) & 0x2) >> 1
}

// USB_HOST.QOSCTRL: USB Quality Of Service
func (o *USB_HOST_Type) SetQOSCTRL_CQOS(value uint8) {
	volatile.StoreUint8(&o.QOSCTRL.Reg, volatile.LoadUint8(&o.QOSCTRL.Reg)&^(0x3)|value)
}
func (o *USB_HOST_Type) GetQOSCTRL_CQOS() uint8 {
	return volatile.LoadUint8(&o.QOSCTRL.Reg) & 0x3
}
func (o *USB_HOST_Type) SetQOSCTRL_DQOS(value uint8) {
	volatile.StoreUint8(&o.QOSCTRL.Reg, volatile.LoadUint8(&o.QOSCTRL.Reg)&^(0xc)|value<<2)
}
func (o *USB_HOST_Type) GetQOSCTRL_DQOS() uint8 {
	return (volatile.LoadUint8(&o.QOSCTRL.Reg) & 0xc) >> 2
}

// USB_HOST.CTRLB: HOST Control B
func (o *USB_HOST_Type) SetCTRLB_RESUME(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x2)|value<<1)
}
func (o *USB_HOST_Type) GetCTRLB_RESUME() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x2) >> 1
}
func (o *USB_HOST_Type) SetCTRLB_SPDCONF(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0xc)|value<<2)
}
func (o *USB_HOST_Type) GetCTRLB_SPDCONF() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0xc) >> 2
}
func (o *USB_HOST_Type) SetCTRLB_AUTORESUME(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x10)|value<<4)
}
func (o *USB_HOST_Type) GetCTRLB_AUTORESUME() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x10) >> 4
}
func (o *USB_HOST_Type) SetCTRLB_TSTJ(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x20)|value<<5)
}
func (o *USB_HOST_Type) GetCTRLB_TSTJ() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x20) >> 5
}
func (o *USB_HOST_Type) SetCTRLB_TSTK(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x40)|value<<6)
}
func (o *USB_HOST_Type) GetCTRLB_TSTK() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x40) >> 6
}
func (o *USB_HOST_Type) SetCTRLB_SOFE(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x100)|value<<8)
}
func (o *USB_HOST_Type) GetCTRLB_SOFE() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x100) >> 8
}
func (o *USB_HOST_Type) SetCTRLB_BUSRESET(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x200)|value<<9)
}
func (o *USB_HOST_Type) GetCTRLB_BUSRESET() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x200) >> 9
}
func (o *USB_HOST_Type) SetCTRLB_VBUSOK(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x400)|value<<10)
}
func (o *USB_HOST_Type) GetCTRLB_VBUSOK() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x400) >> 10
}
func (o *USB_HOST_Type) SetCTRLB_L1RESUME(value uint16) {
	volatile.StoreUint16(&o.CTRLB.Reg, volatile.LoadUint16(&o.CTRLB.Reg)&^(0x800)|value<<11)
}
func (o *USB_HOST_Type) GetCTRLB_L1RESUME() uint16 {
	return (volatile.LoadUint16(&o.CTRLB.Reg) & 0x800) >> 11
}

// USB_HOST.HSOFC: HOST Host Start Of Frame Control
func (o *USB_HOST_Type) SetHSOFC_FLENC(value uint8) {
	volatile.StoreUint8(&o.HSOFC.Reg, volatile.LoadUint8(&o.HSOFC.Reg)&^(0xf)|value)
}
func (o *USB_HOST_Type) GetHSOFC_FLENC() uint8 {
	return volatile.LoadUint8(&o.HSOFC.Reg) & 0xf
}
func (o *USB_HOST_Type) SetHSOFC_FLENCE(value uint8) {
	volatile.StoreUint8(&o.HSOFC.Reg, volatile.LoadUint8(&o.HSOFC.Reg)&^(0x80)|value<<7)
}
func (o *USB_HOST_Type) GetHSOFC_FLENCE() uint8 {
	return (volatile.LoadUint8(&o.HSOFC.Reg) & 0x80) >> 7
}

// USB_HOST.STATUS: HOST Status
func (o *USB_HOST_Type) SetSTATUS_SPEED(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0xc)|value<<2)
}
func (o *USB_HOST_Type) GetSTATUS_SPEED() uint8 {
	return (volatile.LoadUint8(&o.STATUS.Reg) & 0xc) >> 2
}
func (o *USB_HOST_Type) SetSTATUS_LINESTATE(value uint8) {
	volatile.StoreUint8(&o.STATUS.Reg, volatile.LoadUint8(&o.STATUS.Reg)&^(0xc0)|value<<6)
}
func (o *USB_HOST_Type) GetSTATUS_LINESTATE() uint8 {
	return (volatile.LoadUint8(&o.STATUS.Reg) & 0xc0) >> 6
}

// USB_HOST.FSMSTATUS: Finite State Machine Status
func (o *USB_HOST_Type) SetFSMSTATUS_FSMSTATE(value uint8) {
	volatile.StoreUint8(&o.FSMSTATUS.Reg, volatile.LoadUint8(&o.FSMSTATUS.Reg)&^(0x7f)|value)
}
func (o *USB_HOST_Type) GetFSMSTATUS_FSMSTATE() uint8 {
	return volatile.LoadUint8(&o.FSMSTATUS.Reg) & 0x7f
}

// USB_HOST.FNUM: HOST Host Frame Number
func (o *USB_HOST_Type) SetFNUM_MFNUM(value uint16) {
	volatile.StoreUint16(&o.FNUM.Reg, volatile.LoadUint16(&o.FNUM.Reg)&^(0x7)|value)
}
func (o *USB_HOST_Type) GetFNUM_MFNUM() uint16 {
	return volatile.LoadUint16(&o.FNUM.Reg) & 0x7
}
func (o *USB_HOST_Type) SetFNUM(value uint16) {
	volatile.StoreUint16(&o.FNUM.Reg, volatile.LoadUint16(&o.FNUM.Reg)&^(0x3ff8)|value<<3)
}
func (o *USB_HOST_Type) GetFNUM() uint16 {
	return (volatile.LoadUint16(&o.FNUM.Reg) & 0x3ff8) >> 3
}

// USB_HOST.FLENHIGH: HOST Host Frame Length
func (o *USB_HOST_Type) SetFLENHIGH(value uint8) {
	volatile.StoreUint8(&o.FLENHIGH.Reg, value)
}
func (o *USB_HOST_Type) GetFLENHIGH() uint8 {
	return volatile.LoadUint8(&o.FLENHIGH.Reg)
}

// USB_HOST.INTENCLR: HOST Host Interrupt Enable Clear
func (o *USB_HOST_Type) SetINTENCLR_HSOF(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *USB_HOST_Type) GetINTENCLR_HSOF() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x4) >> 2
}
func (o *USB_HOST_Type) SetINTENCLR_RST(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *USB_HOST_Type) GetINTENCLR_RST() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x8) >> 3
}
func (o *USB_HOST_Type) SetINTENCLR_WAKEUP(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *USB_HOST_Type) GetINTENCLR_WAKEUP() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x10) >> 4
}
func (o *USB_HOST_Type) SetINTENCLR_DNRSM(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *USB_HOST_Type) GetINTENCLR_DNRSM() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x20) >> 5
}
func (o *USB_HOST_Type) SetINTENCLR_UPRSM(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x40)|value<<6)
}
func (o *USB_HOST_Type) GetINTENCLR_UPRSM() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x40) >> 6
}
func (o *USB_HOST_Type) SetINTENCLR_RAMACER(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x80)|value<<7)
}
func (o *USB_HOST_Type) GetINTENCLR_RAMACER() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x80) >> 7
}
func (o *USB_HOST_Type) SetINTENCLR_DCONN(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x100)|value<<8)
}
func (o *USB_HOST_Type) GetINTENCLR_DCONN() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x100) >> 8
}
func (o *USB_HOST_Type) SetINTENCLR_DDISC(value uint16) {
	volatile.StoreUint16(&o.INTENCLR.Reg, volatile.LoadUint16(&o.INTENCLR.Reg)&^(0x200)|value<<9)
}
func (o *USB_HOST_Type) GetINTENCLR_DDISC() uint16 {
	return (volatile.LoadUint16(&o.INTENCLR.Reg) & 0x200) >> 9
}

// USB_HOST.INTENSET: HOST Host Interrupt Enable Set
func (o *USB_HOST_Type) SetINTENSET_HSOF(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x4)|value<<2)
}
func (o *USB_HOST_Type) GetINTENSET_HSOF() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x4) >> 2
}
func (o *USB_HOST_Type) SetINTENSET_RST(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x8)|value<<3)
}
func (o *USB_HOST_Type) GetINTENSET_RST() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x8) >> 3
}
func (o *USB_HOST_Type) SetINTENSET_WAKEUP(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x10)|value<<4)
}
func (o *USB_HOST_Type) GetINTENSET_WAKEUP() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x10) >> 4
}
func (o *USB_HOST_Type) SetINTENSET_DNRSM(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x20)|value<<5)
}
func (o *USB_HOST_Type) GetINTENSET_DNRSM() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x20) >> 5
}
func (o *USB_HOST_Type) SetINTENSET_UPRSM(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x40)|value<<6)
}
func (o *USB_HOST_Type) GetINTENSET_UPRSM() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x40) >> 6
}
func (o *USB_HOST_Type) SetINTENSET_RAMACER(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x80)|value<<7)
}
func (o *USB_HOST_Type) GetINTENSET_RAMACER() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x80) >> 7
}
func (o *USB_HOST_Type) SetINTENSET_DCONN(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x100)|value<<8)
}
func (o *USB_HOST_Type) GetINTENSET_DCONN() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x100) >> 8
}
func (o *USB_HOST_Type) SetINTENSET_DDISC(value uint16) {
	volatile.StoreUint16(&o.INTENSET.Reg, volatile.LoadUint16(&o.INTENSET.Reg)&^(0x200)|value<<9)
}
func (o *USB_HOST_Type) GetINTENSET_DDISC() uint16 {
	return (volatile.LoadUint16(&o.INTENSET.Reg) & 0x200) >> 9
}

// USB_HOST.INTFLAG: HOST Host Interrupt Flag
func (o *USB_HOST_Type) SetINTFLAG_HSOF(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x4)|value<<2)
}
func (o *USB_HOST_Type) GetINTFLAG_HSOF() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x4) >> 2
}
func (o *USB_HOST_Type) SetINTFLAG_RST(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x8)|value<<3)
}
func (o *USB_HOST_Type) GetINTFLAG_RST() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x8) >> 3
}
func (o *USB_HOST_Type) SetINTFLAG_WAKEUP(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x10)|value<<4)
}
func (o *USB_HOST_Type) GetINTFLAG_WAKEUP() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x10) >> 4
}
func (o *USB_HOST_Type) SetINTFLAG_DNRSM(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x20)|value<<5)
}
func (o *USB_HOST_Type) GetINTFLAG_DNRSM() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x20) >> 5
}
func (o *USB_HOST_Type) SetINTFLAG_UPRSM(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x40)|value<<6)
}
func (o *USB_HOST_Type) GetINTFLAG_UPRSM() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x40) >> 6
}
func (o *USB_HOST_Type) SetINTFLAG_RAMACER(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x80)|value<<7)
}
func (o *USB_HOST_Type) GetINTFLAG_RAMACER() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x80) >> 7
}
func (o *USB_HOST_Type) SetINTFLAG_DCONN(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x100)|value<<8)
}
func (o *USB_HOST_Type) GetINTFLAG_DCONN() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x100) >> 8
}
func (o *USB_HOST_Type) SetINTFLAG_DDISC(value uint16) {
	volatile.StoreUint16(&o.INTFLAG.Reg, volatile.LoadUint16(&o.INTFLAG.Reg)&^(0x200)|value<<9)
}
func (o *USB_HOST_Type) GetINTFLAG_DDISC() uint16 {
	return (volatile.LoadUint16(&o.INTFLAG.Reg) & 0x200) >> 9
}

// USB_HOST.PINTSMRY: HOST Pipe Interrupt Summary
func (o *USB_HOST_Type) SetPINTSMRY_EPINT0(value uint16) {
	volatile.StoreUint16(&o.PINTSMRY.Reg, volatile.LoadUint16(&o.PINTSMRY.Reg)&^(0x1)|value)
}
func (o *USB_HOST_Type) GetPINTSMRY_EPINT0() uint16 {
	return volatile.LoadUint16(&o.PINTSMRY.Reg) & 0x1
}
func (o *USB_HOST_Type) SetPINTSMRY_EPINT1(value uint16) {
	volatile.StoreUint16(&o.PINTSMRY.Reg, volatile.LoadUint16(&o.PINTSMRY.Reg)&^(0x2)|value<<1)
}
func (o *USB_HOST_Type) GetPINTSMRY_EPINT1() uint16 {
	return (volatile.LoadUint16(&o.PINTSMRY.Reg) & 0x2) >> 1
}
func (o *USB_HOST_Type) SetPINTSMRY_EPINT2(value uint16) {
	volatile.StoreUint16(&o.PINTSMRY.Reg, volatile.LoadUint16(&o.PINTSMRY.Reg)&^(0x4)|value<<2)
}
func (o *USB_HOST_Type) GetPINTSMRY_EPINT2() uint16 {
	return (volatile.LoadUint16(&o.PINTSMRY.Reg) & 0x4) >> 2
}
func (o *USB_HOST_Type) SetPINTSMRY_EPINT3(value uint16) {
	volatile.StoreUint16(&o.PINTSMRY.Reg, volatile.LoadUint16(&o.PINTSMRY.Reg)&^(0x8)|value<<3)
}
func (o *USB_HOST_Type) GetPINTSMRY_EPINT3() uint16 {
	return (volatile.LoadUint16(&o.PINTSMRY.Reg) & 0x8) >> 3
}
func (o *USB_HOST_Type) SetPINTSMRY_EPINT4(value uint16) {
	volatile.StoreUint16(&o.PINTSMRY.Reg, volatile.LoadUint16(&o.PINTSMRY.Reg)&^(0x10)|value<<4)
}
func (o *USB_HOST_Type) GetPINTSMRY_EPINT4() uint16 {
	return (volatile.LoadUint16(&o.PINTSMRY.Reg) & 0x10) >> 4
}
func (o *USB_HOST_Type) SetPINTSMRY_EPINT5(value uint16) {
	volatile.StoreUint16(&o.PINTSMRY.Reg, volatile.LoadUint16(&o.PINTSMRY.Reg)&^(0x20)|value<<5)
}
func (o *USB_HOST_Type) GetPINTSMRY_EPINT5() uint16 {
	return (volatile.LoadUint16(&o.PINTSMRY.Reg) & 0x20) >> 5
}
func (o *USB_HOST_Type) SetPINTSMRY_EPINT6(value uint16) {
	volatile.StoreUint16(&o.PINTSMRY.Reg, volatile.LoadUint16(&o.PINTSMRY.Reg)&^(0x40)|value<<6)
}
func (o *USB_HOST_Type) GetPINTSMRY_EPINT6() uint16 {
	return (volatile.LoadUint16(&o.PINTSMRY.Reg) & 0x40) >> 6
}
func (o *USB_HOST_Type) SetPINTSMRY_EPINT7(value uint16) {
	volatile.StoreUint16(&o.PINTSMRY.Reg, volatile.LoadUint16(&o.PINTSMRY.Reg)&^(0x80)|value<<7)
}
func (o *USB_HOST_Type) GetPINTSMRY_EPINT7() uint16 {
	return (volatile.LoadUint16(&o.PINTSMRY.Reg) & 0x80) >> 7
}

// USB_HOST.DESCADD: Descriptor Address
func (o *USB_HOST_Type) SetDESCADD(value uint32) {
	volatile.StoreUint32(&o.DESCADD.Reg, value)
}
func (o *USB_HOST_Type) GetDESCADD() uint32 {
	return volatile.LoadUint32(&o.DESCADD.Reg)
}

// USB_HOST.PADCAL: USB PAD Calibration
func (o *USB_HOST_Type) SetPADCAL_TRANSP(value uint16) {
	volatile.StoreUint16(&o.PADCAL.Reg, volatile.LoadUint16(&o.PADCAL.Reg)&^(0x1f)|value)
}
func (o *USB_HOST_Type) GetPADCAL_TRANSP() uint16 {
	return volatile.LoadUint16(&o.PADCAL.Reg) & 0x1f
}
func (o *USB_HOST_Type) SetPADCAL_TRANSN(value uint16) {
	volatile.StoreUint16(&o.PADCAL.Reg, volatile.LoadUint16(&o.PADCAL.Reg)&^(0x7c0)|value<<6)
}
func (o *USB_HOST_Type) GetPADCAL_TRANSN() uint16 {
	return (volatile.LoadUint16(&o.PADCAL.Reg) & 0x7c0) >> 6
}
func (o *USB_HOST_Type) SetPADCAL_TRIM(value uint16) {
	volatile.StoreUint16(&o.PADCAL.Reg, volatile.LoadUint16(&o.PADCAL.Reg)&^(0x7000)|value<<12)
}
func (o *USB_HOST_Type) GetPADCAL_TRIM() uint16 {
	return (volatile.LoadUint16(&o.PADCAL.Reg) & 0x7000) >> 12
}

type USB_HOST_HOST_PIPE_Type struct {
	PCFG       volatile.Register8 // 0x100
	_          [2]byte
	BINTERVAL  volatile.Register8 // 0x103
	PSTATUSCLR volatile.Register8 // 0x104
	PSTATUSSET volatile.Register8 // 0x105
	PSTATUS    volatile.Register8 // 0x106
	PINTFLAG   volatile.Register8 // 0x107
	PINTENCLR  volatile.Register8 // 0x108
	PINTENSET  volatile.Register8 // 0x109
	_          [22]byte
}

// USB_HOST_HOST_PIPE.PCFG: HOST_PIPE End Point Configuration
func (o *USB_HOST_HOST_PIPE_Type) SetPCFG_PTOKEN(value uint8) {
	volatile.StoreUint8(&o.PCFG.Reg, volatile.LoadUint8(&o.PCFG.Reg)&^(0x3)|value)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPCFG_PTOKEN() uint8 {
	return volatile.LoadUint8(&o.PCFG.Reg) & 0x3
}
func (o *USB_HOST_HOST_PIPE_Type) SetPCFG_BK(value uint8) {
	volatile.StoreUint8(&o.PCFG.Reg, volatile.LoadUint8(&o.PCFG.Reg)&^(0x4)|value<<2)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPCFG_BK() uint8 {
	return (volatile.LoadUint8(&o.PCFG.Reg) & 0x4) >> 2
}
func (o *USB_HOST_HOST_PIPE_Type) SetPCFG_PTYPE(value uint8) {
	volatile.StoreUint8(&o.PCFG.Reg, volatile.LoadUint8(&o.PCFG.Reg)&^(0x38)|value<<3)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPCFG_PTYPE() uint8 {
	return (volatile.LoadUint8(&o.PCFG.Reg) & 0x38) >> 3
}

// USB_HOST_HOST_PIPE.BINTERVAL: HOST_PIPE Bus Access Period of Pipe
func (o *USB_HOST_HOST_PIPE_Type) SetBINTERVAL(value uint8) {
	volatile.StoreUint8(&o.BINTERVAL.Reg, value)
}
func (o *USB_HOST_HOST_PIPE_Type) GetBINTERVAL() uint8 {
	return volatile.LoadUint8(&o.BINTERVAL.Reg)
}

// USB_HOST_HOST_PIPE.PSTATUSCLR: HOST_PIPE End Point Pipe Status Clear
func (o *USB_HOST_HOST_PIPE_Type) SetPSTATUSCLR_DTGL(value uint8) {
	volatile.StoreUint8(&o.PSTATUSCLR.Reg, volatile.LoadUint8(&o.PSTATUSCLR.Reg)&^(0x1)|value)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPSTATUSCLR_DTGL() uint8 {
	return volatile.LoadUint8(&o.PSTATUSCLR.Reg) & 0x1
}
func (o *USB_HOST_HOST_PIPE_Type) SetPSTATUSCLR_CURBK(value uint8) {
	volatile.StoreUint8(&o.PSTATUSCLR.Reg, volatile.LoadUint8(&o.PSTATUSCLR.Reg)&^(0x4)|value<<2)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPSTATUSCLR_CURBK() uint8 {
	return (volatile.LoadUint8(&o.PSTATUSCLR.Reg) & 0x4) >> 2
}
func (o *USB_HOST_HOST_PIPE_Type) SetPSTATUSCLR_PFREEZE(value uint8) {
	volatile.StoreUint8(&o.PSTATUSCLR.Reg, volatile.LoadUint8(&o.PSTATUSCLR.Reg)&^(0x10)|value<<4)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPSTATUSCLR_PFREEZE() uint8 {
	return (volatile.LoadUint8(&o.PSTATUSCLR.Reg) & 0x10) >> 4
}
func (o *USB_HOST_HOST_PIPE_Type) SetPSTATUSCLR_BK0RDY(value uint8) {
	volatile.StoreUint8(&o.PSTATUSCLR.Reg, volatile.LoadUint8(&o.PSTATUSCLR.Reg)&^(0x40)|value<<6)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPSTATUSCLR_BK0RDY() uint8 {
	return (volatile.LoadUint8(&o.PSTATUSCLR.Reg) & 0x40) >> 6
}
func (o *USB_HOST_HOST_PIPE_Type) SetPSTATUSCLR_BK1RDY(value uint8) {
	volatile.StoreUint8(&o.PSTATUSCLR.Reg, volatile.LoadUint8(&o.PSTATUSCLR.Reg)&^(0x80)|value<<7)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPSTATUSCLR_BK1RDY() uint8 {
	return (volatile.LoadUint8(&o.PSTATUSCLR.Reg) & 0x80) >> 7
}

// USB_HOST_HOST_PIPE.PSTATUSSET: HOST_PIPE End Point Pipe Status Set
func (o *USB_HOST_HOST_PIPE_Type) SetPSTATUSSET_DTGL(value uint8) {
	volatile.StoreUint8(&o.PSTATUSSET.Reg, volatile.LoadUint8(&o.PSTATUSSET.Reg)&^(0x1)|value)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPSTATUSSET_DTGL() uint8 {
	return volatile.LoadUint8(&o.PSTATUSSET.Reg) & 0x1
}
func (o *USB_HOST_HOST_PIPE_Type) SetPSTATUSSET_CURBK(value uint8) {
	volatile.StoreUint8(&o.PSTATUSSET.Reg, volatile.LoadUint8(&o.PSTATUSSET.Reg)&^(0x4)|value<<2)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPSTATUSSET_CURBK() uint8 {
	return (volatile.LoadUint8(&o.PSTATUSSET.Reg) & 0x4) >> 2
}
func (o *USB_HOST_HOST_PIPE_Type) SetPSTATUSSET_PFREEZE(value uint8) {
	volatile.StoreUint8(&o.PSTATUSSET.Reg, volatile.LoadUint8(&o.PSTATUSSET.Reg)&^(0x10)|value<<4)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPSTATUSSET_PFREEZE() uint8 {
	return (volatile.LoadUint8(&o.PSTATUSSET.Reg) & 0x10) >> 4
}
func (o *USB_HOST_HOST_PIPE_Type) SetPSTATUSSET_BK0RDY(value uint8) {
	volatile.StoreUint8(&o.PSTATUSSET.Reg, volatile.LoadUint8(&o.PSTATUSSET.Reg)&^(0x40)|value<<6)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPSTATUSSET_BK0RDY() uint8 {
	return (volatile.LoadUint8(&o.PSTATUSSET.Reg) & 0x40) >> 6
}
func (o *USB_HOST_HOST_PIPE_Type) SetPSTATUSSET_BK1RDY(value uint8) {
	volatile.StoreUint8(&o.PSTATUSSET.Reg, volatile.LoadUint8(&o.PSTATUSSET.Reg)&^(0x80)|value<<7)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPSTATUSSET_BK1RDY() uint8 {
	return (volatile.LoadUint8(&o.PSTATUSSET.Reg) & 0x80) >> 7
}

// USB_HOST_HOST_PIPE.PSTATUS: HOST_PIPE End Point Pipe Status
func (o *USB_HOST_HOST_PIPE_Type) SetPSTATUS_DTGL(value uint8) {
	volatile.StoreUint8(&o.PSTATUS.Reg, volatile.LoadUint8(&o.PSTATUS.Reg)&^(0x1)|value)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPSTATUS_DTGL() uint8 {
	return volatile.LoadUint8(&o.PSTATUS.Reg) & 0x1
}
func (o *USB_HOST_HOST_PIPE_Type) SetPSTATUS_CURBK(value uint8) {
	volatile.StoreUint8(&o.PSTATUS.Reg, volatile.LoadUint8(&o.PSTATUS.Reg)&^(0x4)|value<<2)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPSTATUS_CURBK() uint8 {
	return (volatile.LoadUint8(&o.PSTATUS.Reg) & 0x4) >> 2
}
func (o *USB_HOST_HOST_PIPE_Type) SetPSTATUS_PFREEZE(value uint8) {
	volatile.StoreUint8(&o.PSTATUS.Reg, volatile.LoadUint8(&o.PSTATUS.Reg)&^(0x10)|value<<4)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPSTATUS_PFREEZE() uint8 {
	return (volatile.LoadUint8(&o.PSTATUS.Reg) & 0x10) >> 4
}
func (o *USB_HOST_HOST_PIPE_Type) SetPSTATUS_BK0RDY(value uint8) {
	volatile.StoreUint8(&o.PSTATUS.Reg, volatile.LoadUint8(&o.PSTATUS.Reg)&^(0x40)|value<<6)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPSTATUS_BK0RDY() uint8 {
	return (volatile.LoadUint8(&o.PSTATUS.Reg) & 0x40) >> 6
}
func (o *USB_HOST_HOST_PIPE_Type) SetPSTATUS_BK1RDY(value uint8) {
	volatile.StoreUint8(&o.PSTATUS.Reg, volatile.LoadUint8(&o.PSTATUS.Reg)&^(0x80)|value<<7)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPSTATUS_BK1RDY() uint8 {
	return (volatile.LoadUint8(&o.PSTATUS.Reg) & 0x80) >> 7
}

// USB_HOST_HOST_PIPE.PINTFLAG: HOST_PIPE Pipe Interrupt Flag
func (o *USB_HOST_HOST_PIPE_Type) SetPINTFLAG_TRCPT0(value uint8) {
	volatile.StoreUint8(&o.PINTFLAG.Reg, volatile.LoadUint8(&o.PINTFLAG.Reg)&^(0x1)|value)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPINTFLAG_TRCPT0() uint8 {
	return volatile.LoadUint8(&o.PINTFLAG.Reg) & 0x1
}
func (o *USB_HOST_HOST_PIPE_Type) SetPINTFLAG_TRCPT1(value uint8) {
	volatile.StoreUint8(&o.PINTFLAG.Reg, volatile.LoadUint8(&o.PINTFLAG.Reg)&^(0x2)|value<<1)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPINTFLAG_TRCPT1() uint8 {
	return (volatile.LoadUint8(&o.PINTFLAG.Reg) & 0x2) >> 1
}
func (o *USB_HOST_HOST_PIPE_Type) SetPINTFLAG_TRFAIL(value uint8) {
	volatile.StoreUint8(&o.PINTFLAG.Reg, volatile.LoadUint8(&o.PINTFLAG.Reg)&^(0x4)|value<<2)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPINTFLAG_TRFAIL() uint8 {
	return (volatile.LoadUint8(&o.PINTFLAG.Reg) & 0x4) >> 2
}
func (o *USB_HOST_HOST_PIPE_Type) SetPINTFLAG_PERR(value uint8) {
	volatile.StoreUint8(&o.PINTFLAG.Reg, volatile.LoadUint8(&o.PINTFLAG.Reg)&^(0x8)|value<<3)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPINTFLAG_PERR() uint8 {
	return (volatile.LoadUint8(&o.PINTFLAG.Reg) & 0x8) >> 3
}
func (o *USB_HOST_HOST_PIPE_Type) SetPINTFLAG_TXSTP(value uint8) {
	volatile.StoreUint8(&o.PINTFLAG.Reg, volatile.LoadUint8(&o.PINTFLAG.Reg)&^(0x10)|value<<4)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPINTFLAG_TXSTP() uint8 {
	return (volatile.LoadUint8(&o.PINTFLAG.Reg) & 0x10) >> 4
}
func (o *USB_HOST_HOST_PIPE_Type) SetPINTFLAG_STALL(value uint8) {
	volatile.StoreUint8(&o.PINTFLAG.Reg, volatile.LoadUint8(&o.PINTFLAG.Reg)&^(0x20)|value<<5)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPINTFLAG_STALL() uint8 {
	return (volatile.LoadUint8(&o.PINTFLAG.Reg) & 0x20) >> 5
}

// USB_HOST_HOST_PIPE.PINTENCLR: HOST_PIPE Pipe Interrupt Flag Clear
func (o *USB_HOST_HOST_PIPE_Type) SetPINTENCLR_TRCPT0(value uint8) {
	volatile.StoreUint8(&o.PINTENCLR.Reg, volatile.LoadUint8(&o.PINTENCLR.Reg)&^(0x1)|value)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPINTENCLR_TRCPT0() uint8 {
	return volatile.LoadUint8(&o.PINTENCLR.Reg) & 0x1
}
func (o *USB_HOST_HOST_PIPE_Type) SetPINTENCLR_TRCPT1(value uint8) {
	volatile.StoreUint8(&o.PINTENCLR.Reg, volatile.LoadUint8(&o.PINTENCLR.Reg)&^(0x2)|value<<1)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPINTENCLR_TRCPT1() uint8 {
	return (volatile.LoadUint8(&o.PINTENCLR.Reg) & 0x2) >> 1
}
func (o *USB_HOST_HOST_PIPE_Type) SetPINTENCLR_TRFAIL(value uint8) {
	volatile.StoreUint8(&o.PINTENCLR.Reg, volatile.LoadUint8(&o.PINTENCLR.Reg)&^(0x4)|value<<2)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPINTENCLR_TRFAIL() uint8 {
	return (volatile.LoadUint8(&o.PINTENCLR.Reg) & 0x4) >> 2
}
func (o *USB_HOST_HOST_PIPE_Type) SetPINTENCLR_PERR(value uint8) {
	volatile.StoreUint8(&o.PINTENCLR.Reg, volatile.LoadUint8(&o.PINTENCLR.Reg)&^(0x8)|value<<3)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPINTENCLR_PERR() uint8 {
	return (volatile.LoadUint8(&o.PINTENCLR.Reg) & 0x8) >> 3
}
func (o *USB_HOST_HOST_PIPE_Type) SetPINTENCLR_TXSTP(value uint8) {
	volatile.StoreUint8(&o.PINTENCLR.Reg, volatile.LoadUint8(&o.PINTENCLR.Reg)&^(0x10)|value<<4)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPINTENCLR_TXSTP() uint8 {
	return (volatile.LoadUint8(&o.PINTENCLR.Reg) & 0x10) >> 4
}
func (o *USB_HOST_HOST_PIPE_Type) SetPINTENCLR_STALL(value uint8) {
	volatile.StoreUint8(&o.PINTENCLR.Reg, volatile.LoadUint8(&o.PINTENCLR.Reg)&^(0x20)|value<<5)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPINTENCLR_STALL() uint8 {
	return (volatile.LoadUint8(&o.PINTENCLR.Reg) & 0x20) >> 5
}

// USB_HOST_HOST_PIPE.PINTENSET: HOST_PIPE Pipe Interrupt Flag Set
func (o *USB_HOST_HOST_PIPE_Type) SetPINTENSET_TRCPT0(value uint8) {
	volatile.StoreUint8(&o.PINTENSET.Reg, volatile.LoadUint8(&o.PINTENSET.Reg)&^(0x1)|value)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPINTENSET_TRCPT0() uint8 {
	return volatile.LoadUint8(&o.PINTENSET.Reg) & 0x1
}
func (o *USB_HOST_HOST_PIPE_Type) SetPINTENSET_TRCPT1(value uint8) {
	volatile.StoreUint8(&o.PINTENSET.Reg, volatile.LoadUint8(&o.PINTENSET.Reg)&^(0x2)|value<<1)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPINTENSET_TRCPT1() uint8 {
	return (volatile.LoadUint8(&o.PINTENSET.Reg) & 0x2) >> 1
}
func (o *USB_HOST_HOST_PIPE_Type) SetPINTENSET_TRFAIL(value uint8) {
	volatile.StoreUint8(&o.PINTENSET.Reg, volatile.LoadUint8(&o.PINTENSET.Reg)&^(0x4)|value<<2)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPINTENSET_TRFAIL() uint8 {
	return (volatile.LoadUint8(&o.PINTENSET.Reg) & 0x4) >> 2
}
func (o *USB_HOST_HOST_PIPE_Type) SetPINTENSET_PERR(value uint8) {
	volatile.StoreUint8(&o.PINTENSET.Reg, volatile.LoadUint8(&o.PINTENSET.Reg)&^(0x8)|value<<3)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPINTENSET_PERR() uint8 {
	return (volatile.LoadUint8(&o.PINTENSET.Reg) & 0x8) >> 3
}
func (o *USB_HOST_HOST_PIPE_Type) SetPINTENSET_TXSTP(value uint8) {
	volatile.StoreUint8(&o.PINTENSET.Reg, volatile.LoadUint8(&o.PINTENSET.Reg)&^(0x10)|value<<4)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPINTENSET_TXSTP() uint8 {
	return (volatile.LoadUint8(&o.PINTENSET.Reg) & 0x10) >> 4
}
func (o *USB_HOST_HOST_PIPE_Type) SetPINTENSET_STALL(value uint8) {
	volatile.StoreUint8(&o.PINTENSET.Reg, volatile.LoadUint8(&o.PINTENSET.Reg)&^(0x20)|value<<5)
}
func (o *USB_HOST_HOST_PIPE_Type) GetPINTENSET_STALL() uint8 {
	return (volatile.LoadUint8(&o.PINTENSET.Reg) & 0x20) >> 5
}

// Watchdog Timer
type WDT_Type struct {
	CTRLA    volatile.Register8 // 0x0
	CONFIG   volatile.Register8 // 0x1
	EWCTRL   volatile.Register8 // 0x2
	_        byte
	INTENCLR volatile.Register8 // 0x4
	INTENSET volatile.Register8 // 0x5
	INTFLAG  volatile.Register8 // 0x6
	_        byte
	SYNCBUSY volatile.Register32 // 0x8
	CLEAR    volatile.Register8  // 0xC
}

// WDT.CTRLA: Control
func (o *WDT_Type) SetCTRLA_ENABLE(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x2)|value<<1)
}
func (o *WDT_Type) GetCTRLA_ENABLE() uint8 {
	return (volatile.LoadUint8(&o.CTRLA.Reg) & 0x2) >> 1
}
func (o *WDT_Type) SetCTRLA_WEN(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x4)|value<<2)
}
func (o *WDT_Type) GetCTRLA_WEN() uint8 {
	return (volatile.LoadUint8(&o.CTRLA.Reg) & 0x4) >> 2
}
func (o *WDT_Type) SetCTRLA_ALWAYSON(value uint8) {
	volatile.StoreUint8(&o.CTRLA.Reg, volatile.LoadUint8(&o.CTRLA.Reg)&^(0x80)|value<<7)
}
func (o *WDT_Type) GetCTRLA_ALWAYSON() uint8 {
	return (volatile.LoadUint8(&o.CTRLA.Reg) & 0x80) >> 7
}

// WDT.CONFIG: Configuration
func (o *WDT_Type) SetCONFIG_PER(value uint8) {
	volatile.StoreUint8(&o.CONFIG.Reg, volatile.LoadUint8(&o.CONFIG.Reg)&^(0xf)|value)
}
func (o *WDT_Type) GetCONFIG_PER() uint8 {
	return volatile.LoadUint8(&o.CONFIG.Reg) & 0xf
}
func (o *WDT_Type) SetCONFIG_WINDOW(value uint8) {
	volatile.StoreUint8(&o.CONFIG.Reg, volatile.LoadUint8(&o.CONFIG.Reg)&^(0xf0)|value<<4)
}
func (o *WDT_Type) GetCONFIG_WINDOW() uint8 {
	return (volatile.LoadUint8(&o.CONFIG.Reg) & 0xf0) >> 4
}

// WDT.EWCTRL: Early Warning Interrupt Control
func (o *WDT_Type) SetEWCTRL_EWOFFSET(value uint8) {
	volatile.StoreUint8(&o.EWCTRL.Reg, volatile.LoadUint8(&o.EWCTRL.Reg)&^(0xf)|value)
}
func (o *WDT_Type) GetEWCTRL_EWOFFSET() uint8 {
	return volatile.LoadUint8(&o.EWCTRL.Reg) & 0xf
}

// WDT.INTENCLR: Interrupt Enable Clear
func (o *WDT_Type) SetINTENCLR_EW(value uint8) {
	volatile.StoreUint8(&o.INTENCLR.Reg, volatile.LoadUint8(&o.INTENCLR.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetINTENCLR_EW() uint8 {
	return volatile.LoadUint8(&o.INTENCLR.Reg) & 0x1
}

// WDT.INTENSET: Interrupt Enable Set
func (o *WDT_Type) SetINTENSET_EW(value uint8) {
	volatile.StoreUint8(&o.INTENSET.Reg, volatile.LoadUint8(&o.INTENSET.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetINTENSET_EW() uint8 {
	return volatile.LoadUint8(&o.INTENSET.Reg) & 0x1
}

// WDT.INTFLAG: Interrupt Flag Status and Clear
func (o *WDT_Type) SetINTFLAG_EW(value uint8) {
	volatile.StoreUint8(&o.INTFLAG.Reg, volatile.LoadUint8(&o.INTFLAG.Reg)&^(0x1)|value)
}
func (o *WDT_Type) GetINTFLAG_EW() uint8 {
	return volatile.LoadUint8(&o.INTFLAG.Reg) & 0x1
}

// WDT.SYNCBUSY: Synchronization Busy
func (o *WDT_Type) SetSYNCBUSY_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x2)|value<<1)
}
func (o *WDT_Type) GetSYNCBUSY_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x2) >> 1
}
func (o *WDT_Type) SetSYNCBUSY_WEN(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x4)|value<<2)
}
func (o *WDT_Type) GetSYNCBUSY_WEN() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x4) >> 2
}
func (o *WDT_Type) SetSYNCBUSY_ALWAYSON(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x8)|value<<3)
}
func (o *WDT_Type) GetSYNCBUSY_ALWAYSON() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x8) >> 3
}
func (o *WDT_Type) SetSYNCBUSY_CLEAR(value uint32) {
	volatile.StoreUint32(&o.SYNCBUSY.Reg, volatile.LoadUint32(&o.SYNCBUSY.Reg)&^(0x10)|value<<4)
}
func (o *WDT_Type) GetSYNCBUSY_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.SYNCBUSY.Reg) & 0x10) >> 4
}

// WDT.CLEAR: Clear
func (o *WDT_Type) SetCLEAR(value uint8) {
	volatile.StoreUint8(&o.CLEAR.Reg, value)
}
func (o *WDT_Type) GetCLEAR() uint8 {
	return volatile.LoadUint8(&o.CLEAR.Reg)
}

// Core Debug Register
type CoreDebug_Type struct {
	DHCSR volatile.Register32 // 0x0
	DCRSR volatile.Register32 // 0x4
	DCRDR volatile.Register32 // 0x8
	DEMCR volatile.Register32 // 0xC
}

// CoreDebug.DHCSR: Debug Halting Control and Status Register
func (o *CoreDebug_Type) SetDHCSR_C_DEBUGEN(value uint32) {
	volatile.StoreUint32(&o.DHCSR.Reg, volatile.LoadUint32(&o.DHCSR.Reg)&^(0x1)|value)
}
func (o *CoreDebug_Type) GetDHCSR_C_DEBUGEN() uint32 {
	return volatile.LoadUint32(&o.DHCSR.Reg) & 0x1
}
func (o *CoreDebug_Type) SetDHCSR_C_HALT(value uint32) {
	volatile.StoreUint32(&o.DHCSR.Reg, volatile.LoadUint32(&o.DHCSR.Reg)&^(0x2)|value<<1)
}
func (o *CoreDebug_Type) GetDHCSR_C_HALT() uint32 {
	return (volatile.LoadUint32(&o.DHCSR.Reg) & 0x2) >> 1
}
func (o *CoreDebug_Type) SetDHCSR_C_STEP(value uint32) {
	volatile.StoreUint32(&o.DHCSR.Reg, volatile.LoadUint32(&o.DHCSR.Reg)&^(0x4)|value<<2)
}
func (o *CoreDebug_Type) GetDHCSR_C_STEP() uint32 {
	return (volatile.LoadUint32(&o.DHCSR.Reg) & 0x4) >> 2
}
func (o *CoreDebug_Type) SetDHCSR_C_MASKINTS(value uint32) {
	volatile.StoreUint32(&o.DHCSR.Reg, volatile.LoadUint32(&o.DHCSR.Reg)&^(0x8)|value<<3)
}
func (o *CoreDebug_Type) GetDHCSR_C_MASKINTS() uint32 {
	return (volatile.LoadUint32(&o.DHCSR.Reg) & 0x8) >> 3
}
func (o *CoreDebug_Type) SetDHCSR_C_SNAPSTALL(value uint32) {
	volatile.StoreUint32(&o.DHCSR.Reg, volatile.LoadUint32(&o.DHCSR.Reg)&^(0x20)|value<<5)
}
func (o *CoreDebug_Type) GetDHCSR_C_SNAPSTALL() uint32 {
	return (volatile.LoadUint32(&o.DHCSR.Reg) & 0x20) >> 5
}
func (o *CoreDebug_Type) SetDHCSR_S_REGRDY(value uint32) {
	volatile.StoreUint32(&o.DHCSR.Reg, volatile.LoadUint32(&o.DHCSR.Reg)&^(0x10000)|value<<16)
}
func (o *CoreDebug_Type) GetDHCSR_S_REGRDY() uint32 {
	return (volatile.LoadUint32(&o.DHCSR.Reg) & 0x10000) >> 16
}
func (o *CoreDebug_Type) SetDHCSR_S_HALT(value uint32) {
	volatile.StoreUint32(&o.DHCSR.Reg, volatile.LoadUint32(&o.DHCSR.Reg)&^(0x20000)|value<<17)
}
func (o *CoreDebug_Type) GetDHCSR_S_HALT() uint32 {
	return (volatile.LoadUint32(&o.DHCSR.Reg) & 0x20000) >> 17
}
func (o *CoreDebug_Type) SetDHCSR_S_SLEEP(value uint32) {
	volatile.StoreUint32(&o.DHCSR.Reg, volatile.LoadUint32(&o.DHCSR.Reg)&^(0x40000)|value<<18)
}
func (o *CoreDebug_Type) GetDHCSR_S_SLEEP() uint32 {
	return (volatile.LoadUint32(&o.DHCSR.Reg) & 0x40000) >> 18
}
func (o *CoreDebug_Type) SetDHCSR_S_LOCKUP(value uint32) {
	volatile.StoreUint32(&o.DHCSR.Reg, volatile.LoadUint32(&o.DHCSR.Reg)&^(0x80000)|value<<19)
}
func (o *CoreDebug_Type) GetDHCSR_S_LOCKUP() uint32 {
	return (volatile.LoadUint32(&o.DHCSR.Reg) & 0x80000) >> 19
}
func (o *CoreDebug_Type) SetDHCSR_S_RETIRE_ST(value uint32) {
	volatile.StoreUint32(&o.DHCSR.Reg, volatile.LoadUint32(&o.DHCSR.Reg)&^(0x1000000)|value<<24)
}
func (o *CoreDebug_Type) GetDHCSR_S_RETIRE_ST() uint32 {
	return (volatile.LoadUint32(&o.DHCSR.Reg) & 0x1000000) >> 24
}
func (o *CoreDebug_Type) SetDHCSR_S_RESET_ST(value uint32) {
	volatile.StoreUint32(&o.DHCSR.Reg, volatile.LoadUint32(&o.DHCSR.Reg)&^(0x2000000)|value<<25)
}
func (o *CoreDebug_Type) GetDHCSR_S_RESET_ST() uint32 {
	return (volatile.LoadUint32(&o.DHCSR.Reg) & 0x2000000) >> 25
}
func (o *CoreDebug_Type) SetDHCSR_DBGKEY(value uint32) {
	volatile.StoreUint32(&o.DHCSR.Reg, volatile.LoadUint32(&o.DHCSR.Reg)&^(0xffff0000)|value<<16)
}
func (o *CoreDebug_Type) GetDHCSR_DBGKEY() uint32 {
	return (volatile.LoadUint32(&o.DHCSR.Reg) & 0xffff0000) >> 16
}

// CoreDebug.DCRSR: Debug Core Register Selector Register
func (o *CoreDebug_Type) SetDCRSR_REGSEL(value uint32) {
	volatile.StoreUint32(&o.DCRSR.Reg, volatile.LoadUint32(&o.DCRSR.Reg)&^(0x1f)|value)
}
func (o *CoreDebug_Type) GetDCRSR_REGSEL() uint32 {
	return volatile.LoadUint32(&o.DCRSR.Reg) & 0x1f
}
func (o *CoreDebug_Type) SetDCRSR_REGWnR(value uint32) {
	volatile.StoreUint32(&o.DCRSR.Reg, volatile.LoadUint32(&o.DCRSR.Reg)&^(0x10000)|value<<16)
}
func (o *CoreDebug_Type) GetDCRSR_REGWnR() uint32 {
	return (volatile.LoadUint32(&o.DCRSR.Reg) & 0x10000) >> 16
}

// CoreDebug.DEMCR: Debug Exception and Monitor Control Register
func (o *CoreDebug_Type) SetDEMCR_VC_CORERESET(value uint32) {
	volatile.StoreUint32(&o.DEMCR.Reg, volatile.LoadUint32(&o.DEMCR.Reg)&^(0x1)|value)
}
func (o *CoreDebug_Type) GetDEMCR_VC_CORERESET() uint32 {
	return volatile.LoadUint32(&o.DEMCR.Reg) & 0x1
}
func (o *CoreDebug_Type) SetDEMCR_VC_MMERR(value uint32) {
	volatile.StoreUint32(&o.DEMCR.Reg, volatile.LoadUint32(&o.DEMCR.Reg)&^(0x10)|value<<4)
}
func (o *CoreDebug_Type) GetDEMCR_VC_MMERR() uint32 {
	return (volatile.LoadUint32(&o.DEMCR.Reg) & 0x10) >> 4
}
func (o *CoreDebug_Type) SetDEMCR_VC_NOCPERR(value uint32) {
	volatile.StoreUint32(&o.DEMCR.Reg, volatile.LoadUint32(&o.DEMCR.Reg)&^(0x20)|value<<5)
}
func (o *CoreDebug_Type) GetDEMCR_VC_NOCPERR() uint32 {
	return (volatile.LoadUint32(&o.DEMCR.Reg) & 0x20) >> 5
}
func (o *CoreDebug_Type) SetDEMCR_VC_CHKERR(value uint32) {
	volatile.StoreUint32(&o.DEMCR.Reg, volatile.LoadUint32(&o.DEMCR.Reg)&^(0x40)|value<<6)
}
func (o *CoreDebug_Type) GetDEMCR_VC_CHKERR() uint32 {
	return (volatile.LoadUint32(&o.DEMCR.Reg) & 0x40) >> 6
}
func (o *CoreDebug_Type) SetDEMCR_VC_STATERR(value uint32) {
	volatile.StoreUint32(&o.DEMCR.Reg, volatile.LoadUint32(&o.DEMCR.Reg)&^(0x80)|value<<7)
}
func (o *CoreDebug_Type) GetDEMCR_VC_STATERR() uint32 {
	return (volatile.LoadUint32(&o.DEMCR.Reg) & 0x80) >> 7
}
func (o *CoreDebug_Type) SetDEMCR_VC_BUSERR(value uint32) {
	volatile.StoreUint32(&o.DEMCR.Reg, volatile.LoadUint32(&o.DEMCR.Reg)&^(0x100)|value<<8)
}
func (o *CoreDebug_Type) GetDEMCR_VC_BUSERR() uint32 {
	return (volatile.LoadUint32(&o.DEMCR.Reg) & 0x100) >> 8
}
func (o *CoreDebug_Type) SetDEMCR_VC_INTERR(value uint32) {
	volatile.StoreUint32(&o.DEMCR.Reg, volatile.LoadUint32(&o.DEMCR.Reg)&^(0x200)|value<<9)
}
func (o *CoreDebug_Type) GetDEMCR_VC_INTERR() uint32 {
	return (volatile.LoadUint32(&o.DEMCR.Reg) & 0x200) >> 9
}
func (o *CoreDebug_Type) SetDEMCR_VC_HARDERR(value uint32) {
	volatile.StoreUint32(&o.DEMCR.Reg, volatile.LoadUint32(&o.DEMCR.Reg)&^(0x400)|value<<10)
}
func (o *CoreDebug_Type) GetDEMCR_VC_HARDERR() uint32 {
	return (volatile.LoadUint32(&o.DEMCR.Reg) & 0x400) >> 10
}
func (o *CoreDebug_Type) SetDEMCR_MON_EN(value uint32) {
	volatile.StoreUint32(&o.DEMCR.Reg, volatile.LoadUint32(&o.DEMCR.Reg)&^(0x10000)|value<<16)
}
func (o *CoreDebug_Type) GetDEMCR_MON_EN() uint32 {
	return (volatile.LoadUint32(&o.DEMCR.Reg) & 0x10000) >> 16
}
func (o *CoreDebug_Type) SetDEMCR_MON_PEND(value uint32) {
	volatile.StoreUint32(&o.DEMCR.Reg, volatile.LoadUint32(&o.DEMCR.Reg)&^(0x20000)|value<<17)
}
func (o *CoreDebug_Type) GetDEMCR_MON_PEND() uint32 {
	return (volatile.LoadUint32(&o.DEMCR.Reg) & 0x20000) >> 17
}
func (o *CoreDebug_Type) SetDEMCR_MON_STEP(value uint32) {
	volatile.StoreUint32(&o.DEMCR.Reg, volatile.LoadUint32(&o.DEMCR.Reg)&^(0x40000)|value<<18)
}
func (o *CoreDebug_Type) GetDEMCR_MON_STEP() uint32 {
	return (volatile.LoadUint32(&o.DEMCR.Reg) & 0x40000) >> 18
}
func (o *CoreDebug_Type) SetDEMCR_MON_REQ(value uint32) {
	volatile.StoreUint32(&o.DEMCR.Reg, volatile.LoadUint32(&o.DEMCR.Reg)&^(0x80000)|value<<19)
}
func (o *CoreDebug_Type) GetDEMCR_MON_REQ() uint32 {
	return (volatile.LoadUint32(&o.DEMCR.Reg) & 0x80000) >> 19
}
func (o *CoreDebug_Type) SetDEMCR_TRCENA(value uint32) {
	volatile.StoreUint32(&o.DEMCR.Reg, volatile.LoadUint32(&o.DEMCR.Reg)&^(0x1000000)|value<<24)
}
func (o *CoreDebug_Type) GetDEMCR_TRCENA() uint32 {
	return (volatile.LoadUint32(&o.DEMCR.Reg) & 0x1000000) >> 24
}

// Data Watchpoint and Trace Register
type DWT_Type struct {
	CTRL      volatile.Register32 // 0x0
	CYCCNT    volatile.Register32 // 0x4
	CPICNT    volatile.Register32 // 0x8
	EXCCNT    volatile.Register32 // 0xC
	SLEEPCNT  volatile.Register32 // 0x10
	LSUCNT    volatile.Register32 // 0x14
	FOLDCNT   volatile.Register32 // 0x18
	PCSR      volatile.Register32 // 0x1C
	COMP0     volatile.Register32 // 0x20
	MASK0     volatile.Register32 // 0x24
	FUNCTION0 volatile.Register32 // 0x28
	_         [4]byte
	COMP1     volatile.Register32 // 0x30
	MASK1     volatile.Register32 // 0x34
	FUNCTION1 volatile.Register32 // 0x38
	_         [4]byte
	COMP2     volatile.Register32 // 0x40
	MASK2     volatile.Register32 // 0x44
	FUNCTION2 volatile.Register32 // 0x48
	_         [4]byte
	COMP3     volatile.Register32 // 0x50
	MASK3     volatile.Register32 // 0x54
	FUNCTION3 volatile.Register32 // 0x58
}

// DWT.CTRL: Control Register
func (o *DWT_Type) SetCTRL_CYCCNTENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *DWT_Type) GetCTRL_CYCCNTENA() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *DWT_Type) SetCTRL_POSTPRESET(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1e)|value<<1)
}
func (o *DWT_Type) GetCTRL_POSTPRESET() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1e) >> 1
}
func (o *DWT_Type) SetCTRL_POSTINIT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1e0)|value<<5)
}
func (o *DWT_Type) GetCTRL_POSTINIT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1e0) >> 5
}
func (o *DWT_Type) SetCTRL_CYCTAP(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x200)|value<<9)
}
func (o *DWT_Type) GetCTRL_CYCTAP() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x200) >> 9
}
func (o *DWT_Type) SetCTRL_SYNCTAP(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xc00)|value<<10)
}
func (o *DWT_Type) GetCTRL_SYNCTAP() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xc00) >> 10
}
func (o *DWT_Type) SetCTRL_PCSAMPLENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *DWT_Type) GetCTRL_PCSAMPLENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1000) >> 12
}
func (o *DWT_Type) SetCTRL_EXCTRCENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *DWT_Type) GetCTRL_EXCTRCENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000) >> 16
}
func (o *DWT_Type) SetCTRL_CPIEVTENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20000)|value<<17)
}
func (o *DWT_Type) GetCTRL_CPIEVTENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20000) >> 17
}
func (o *DWT_Type) SetCTRL_EXCEVTENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *DWT_Type) GetCTRL_EXCEVTENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40000) >> 18
}
func (o *DWT_Type) SetCTRL_SLEEPEVTENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80000)|value<<19)
}
func (o *DWT_Type) GetCTRL_SLEEPEVTENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80000) >> 19
}
func (o *DWT_Type) SetCTRL_LSUEVTENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *DWT_Type) GetCTRL_LSUEVTENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100000) >> 20
}
func (o *DWT_Type) SetCTRL_FOLDEVTENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x200000)|value<<21)
}
func (o *DWT_Type) GetCTRL_FOLDEVTENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x200000) >> 21
}
func (o *DWT_Type) SetCTRL_CYCEVTENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *DWT_Type) GetCTRL_CYCEVTENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x400000) >> 22
}
func (o *DWT_Type) SetCTRL_NOPRFCNT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *DWT_Type) GetCTRL_NOPRFCNT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1000000) >> 24
}
func (o *DWT_Type) SetCTRL_NOCYCCNT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *DWT_Type) GetCTRL_NOCYCCNT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2000000) >> 25
}
func (o *DWT_Type) SetCTRL_NOEXTTRIG(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *DWT_Type) GetCTRL_NOEXTTRIG() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4000000) >> 26
}
func (o *DWT_Type) SetCTRL_NOTRCPKT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8000000)|value<<27)
}
func (o *DWT_Type) GetCTRL_NOTRCPKT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8000000) >> 27
}
func (o *DWT_Type) SetCTRL_NUMCOMP(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xf0000000)|value<<28)
}
func (o *DWT_Type) GetCTRL_NUMCOMP() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xf0000000) >> 28
}

// DWT.CPICNT: CPI Count Register
func (o *DWT_Type) SetCPICNT(value uint32) {
	volatile.StoreUint32(&o.CPICNT.Reg, volatile.LoadUint32(&o.CPICNT.Reg)&^(0xff)|value)
}
func (o *DWT_Type) GetCPICNT() uint32 {
	return volatile.LoadUint32(&o.CPICNT.Reg) & 0xff
}

// DWT.EXCCNT: Exception Overhead Count Register
func (o *DWT_Type) SetEXCCNT(value uint32) {
	volatile.StoreUint32(&o.EXCCNT.Reg, volatile.LoadUint32(&o.EXCCNT.Reg)&^(0xff)|value)
}
func (o *DWT_Type) GetEXCCNT() uint32 {
	return volatile.LoadUint32(&o.EXCCNT.Reg) & 0xff
}

// DWT.SLEEPCNT: Sleep Count Register
func (o *DWT_Type) SetSLEEPCNT(value uint32) {
	volatile.StoreUint32(&o.SLEEPCNT.Reg, volatile.LoadUint32(&o.SLEEPCNT.Reg)&^(0xff)|value)
}
func (o *DWT_Type) GetSLEEPCNT() uint32 {
	return volatile.LoadUint32(&o.SLEEPCNT.Reg) & 0xff
}

// DWT.LSUCNT: LSU Count Register
func (o *DWT_Type) SetLSUCNT(value uint32) {
	volatile.StoreUint32(&o.LSUCNT.Reg, volatile.LoadUint32(&o.LSUCNT.Reg)&^(0xff)|value)
}
func (o *DWT_Type) GetLSUCNT() uint32 {
	return volatile.LoadUint32(&o.LSUCNT.Reg) & 0xff
}

// DWT.FOLDCNT: Folded-instruction Count Register
func (o *DWT_Type) SetFOLDCNT(value uint32) {
	volatile.StoreUint32(&o.FOLDCNT.Reg, volatile.LoadUint32(&o.FOLDCNT.Reg)&^(0xff)|value)
}
func (o *DWT_Type) GetFOLDCNT() uint32 {
	return volatile.LoadUint32(&o.FOLDCNT.Reg) & 0xff
}

// DWT.MASK0: Mask Register 0
func (o *DWT_Type) SetMASK0_MASK(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x1f)|value)
}
func (o *DWT_Type) GetMASK0_MASK() uint32 {
	return volatile.LoadUint32(&o.MASK0.Reg) & 0x1f
}

// DWT.FUNCTION0: Function Register 0
func (o *DWT_Type) SetFUNCTION0_FUNCTION(value uint32) {
	volatile.StoreUint32(&o.FUNCTION0.Reg, volatile.LoadUint32(&o.FUNCTION0.Reg)&^(0xf)|value)
}
func (o *DWT_Type) GetFUNCTION0_FUNCTION() uint32 {
	return volatile.LoadUint32(&o.FUNCTION0.Reg) & 0xf
}
func (o *DWT_Type) SetFUNCTION0_EMITRANGE(value uint32) {
	volatile.StoreUint32(&o.FUNCTION0.Reg, volatile.LoadUint32(&o.FUNCTION0.Reg)&^(0x20)|value<<5)
}
func (o *DWT_Type) GetFUNCTION0_EMITRANGE() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION0.Reg) & 0x20) >> 5
}
func (o *DWT_Type) SetFUNCTION0_CYCMATCH(value uint32) {
	volatile.StoreUint32(&o.FUNCTION0.Reg, volatile.LoadUint32(&o.FUNCTION0.Reg)&^(0x80)|value<<7)
}
func (o *DWT_Type) GetFUNCTION0_CYCMATCH() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION0.Reg) & 0x80) >> 7
}
func (o *DWT_Type) SetFUNCTION0_DATAVMATCH(value uint32) {
	volatile.StoreUint32(&o.FUNCTION0.Reg, volatile.LoadUint32(&o.FUNCTION0.Reg)&^(0x100)|value<<8)
}
func (o *DWT_Type) GetFUNCTION0_DATAVMATCH() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION0.Reg) & 0x100) >> 8
}
func (o *DWT_Type) SetFUNCTION0_LNK1ENA(value uint32) {
	volatile.StoreUint32(&o.FUNCTION0.Reg, volatile.LoadUint32(&o.FUNCTION0.Reg)&^(0x200)|value<<9)
}
func (o *DWT_Type) GetFUNCTION0_LNK1ENA() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION0.Reg) & 0x200) >> 9
}
func (o *DWT_Type) SetFUNCTION0_DATAVSIZE(value uint32) {
	volatile.StoreUint32(&o.FUNCTION0.Reg, volatile.LoadUint32(&o.FUNCTION0.Reg)&^(0xc00)|value<<10)
}
func (o *DWT_Type) GetFUNCTION0_DATAVSIZE() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION0.Reg) & 0xc00) >> 10
}
func (o *DWT_Type) SetFUNCTION0_DATAVADDR0(value uint32) {
	volatile.StoreUint32(&o.FUNCTION0.Reg, volatile.LoadUint32(&o.FUNCTION0.Reg)&^(0xf000)|value<<12)
}
func (o *DWT_Type) GetFUNCTION0_DATAVADDR0() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION0.Reg) & 0xf000) >> 12
}
func (o *DWT_Type) SetFUNCTION0_DATAVADDR1(value uint32) {
	volatile.StoreUint32(&o.FUNCTION0.Reg, volatile.LoadUint32(&o.FUNCTION0.Reg)&^(0xf0000)|value<<16)
}
func (o *DWT_Type) GetFUNCTION0_DATAVADDR1() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION0.Reg) & 0xf0000) >> 16
}
func (o *DWT_Type) SetFUNCTION0_MATCHED(value uint32) {
	volatile.StoreUint32(&o.FUNCTION0.Reg, volatile.LoadUint32(&o.FUNCTION0.Reg)&^(0x1000000)|value<<24)
}
func (o *DWT_Type) GetFUNCTION0_MATCHED() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION0.Reg) & 0x1000000) >> 24
}

// DWT.MASK1: Mask Register 1
func (o *DWT_Type) SetMASK1_MASK(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x1f)|value)
}
func (o *DWT_Type) GetMASK1_MASK() uint32 {
	return volatile.LoadUint32(&o.MASK1.Reg) & 0x1f
}

// DWT.FUNCTION1: Function Register 1
func (o *DWT_Type) SetFUNCTION1_FUNCTION(value uint32) {
	volatile.StoreUint32(&o.FUNCTION1.Reg, volatile.LoadUint32(&o.FUNCTION1.Reg)&^(0xf)|value)
}
func (o *DWT_Type) GetFUNCTION1_FUNCTION() uint32 {
	return volatile.LoadUint32(&o.FUNCTION1.Reg) & 0xf
}
func (o *DWT_Type) SetFUNCTION1_EMITRANGE(value uint32) {
	volatile.StoreUint32(&o.FUNCTION1.Reg, volatile.LoadUint32(&o.FUNCTION1.Reg)&^(0x20)|value<<5)
}
func (o *DWT_Type) GetFUNCTION1_EMITRANGE() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION1.Reg) & 0x20) >> 5
}
func (o *DWT_Type) SetFUNCTION1_CYCMATCH(value uint32) {
	volatile.StoreUint32(&o.FUNCTION1.Reg, volatile.LoadUint32(&o.FUNCTION1.Reg)&^(0x80)|value<<7)
}
func (o *DWT_Type) GetFUNCTION1_CYCMATCH() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION1.Reg) & 0x80) >> 7
}
func (o *DWT_Type) SetFUNCTION1_DATAVMATCH(value uint32) {
	volatile.StoreUint32(&o.FUNCTION1.Reg, volatile.LoadUint32(&o.FUNCTION1.Reg)&^(0x100)|value<<8)
}
func (o *DWT_Type) GetFUNCTION1_DATAVMATCH() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION1.Reg) & 0x100) >> 8
}
func (o *DWT_Type) SetFUNCTION1_LNK1ENA(value uint32) {
	volatile.StoreUint32(&o.FUNCTION1.Reg, volatile.LoadUint32(&o.FUNCTION1.Reg)&^(0x200)|value<<9)
}
func (o *DWT_Type) GetFUNCTION1_LNK1ENA() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION1.Reg) & 0x200) >> 9
}
func (o *DWT_Type) SetFUNCTION1_DATAVSIZE(value uint32) {
	volatile.StoreUint32(&o.FUNCTION1.Reg, volatile.LoadUint32(&o.FUNCTION1.Reg)&^(0xc00)|value<<10)
}
func (o *DWT_Type) GetFUNCTION1_DATAVSIZE() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION1.Reg) & 0xc00) >> 10
}
func (o *DWT_Type) SetFUNCTION1_DATAVADDR0(value uint32) {
	volatile.StoreUint32(&o.FUNCTION1.Reg, volatile.LoadUint32(&o.FUNCTION1.Reg)&^(0xf000)|value<<12)
}
func (o *DWT_Type) GetFUNCTION1_DATAVADDR0() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION1.Reg) & 0xf000) >> 12
}
func (o *DWT_Type) SetFUNCTION1_DATAVADDR1(value uint32) {
	volatile.StoreUint32(&o.FUNCTION1.Reg, volatile.LoadUint32(&o.FUNCTION1.Reg)&^(0xf0000)|value<<16)
}
func (o *DWT_Type) GetFUNCTION1_DATAVADDR1() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION1.Reg) & 0xf0000) >> 16
}
func (o *DWT_Type) SetFUNCTION1_MATCHED(value uint32) {
	volatile.StoreUint32(&o.FUNCTION1.Reg, volatile.LoadUint32(&o.FUNCTION1.Reg)&^(0x1000000)|value<<24)
}
func (o *DWT_Type) GetFUNCTION1_MATCHED() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION1.Reg) & 0x1000000) >> 24
}

// DWT.MASK2: Mask Register 2
func (o *DWT_Type) SetMASK2_MASK(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x1f)|value)
}
func (o *DWT_Type) GetMASK2_MASK() uint32 {
	return volatile.LoadUint32(&o.MASK2.Reg) & 0x1f
}

// DWT.FUNCTION2: Function Register 2
func (o *DWT_Type) SetFUNCTION2_FUNCTION(value uint32) {
	volatile.StoreUint32(&o.FUNCTION2.Reg, volatile.LoadUint32(&o.FUNCTION2.Reg)&^(0xf)|value)
}
func (o *DWT_Type) GetFUNCTION2_FUNCTION() uint32 {
	return volatile.LoadUint32(&o.FUNCTION2.Reg) & 0xf
}
func (o *DWT_Type) SetFUNCTION2_EMITRANGE(value uint32) {
	volatile.StoreUint32(&o.FUNCTION2.Reg, volatile.LoadUint32(&o.FUNCTION2.Reg)&^(0x20)|value<<5)
}
func (o *DWT_Type) GetFUNCTION2_EMITRANGE() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION2.Reg) & 0x20) >> 5
}
func (o *DWT_Type) SetFUNCTION2_CYCMATCH(value uint32) {
	volatile.StoreUint32(&o.FUNCTION2.Reg, volatile.LoadUint32(&o.FUNCTION2.Reg)&^(0x80)|value<<7)
}
func (o *DWT_Type) GetFUNCTION2_CYCMATCH() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION2.Reg) & 0x80) >> 7
}
func (o *DWT_Type) SetFUNCTION2_DATAVMATCH(value uint32) {
	volatile.StoreUint32(&o.FUNCTION2.Reg, volatile.LoadUint32(&o.FUNCTION2.Reg)&^(0x100)|value<<8)
}
func (o *DWT_Type) GetFUNCTION2_DATAVMATCH() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION2.Reg) & 0x100) >> 8
}
func (o *DWT_Type) SetFUNCTION2_LNK1ENA(value uint32) {
	volatile.StoreUint32(&o.FUNCTION2.Reg, volatile.LoadUint32(&o.FUNCTION2.Reg)&^(0x200)|value<<9)
}
func (o *DWT_Type) GetFUNCTION2_LNK1ENA() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION2.Reg) & 0x200) >> 9
}
func (o *DWT_Type) SetFUNCTION2_DATAVSIZE(value uint32) {
	volatile.StoreUint32(&o.FUNCTION2.Reg, volatile.LoadUint32(&o.FUNCTION2.Reg)&^(0xc00)|value<<10)
}
func (o *DWT_Type) GetFUNCTION2_DATAVSIZE() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION2.Reg) & 0xc00) >> 10
}
func (o *DWT_Type) SetFUNCTION2_DATAVADDR0(value uint32) {
	volatile.StoreUint32(&o.FUNCTION2.Reg, volatile.LoadUint32(&o.FUNCTION2.Reg)&^(0xf000)|value<<12)
}
func (o *DWT_Type) GetFUNCTION2_DATAVADDR0() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION2.Reg) & 0xf000) >> 12
}
func (o *DWT_Type) SetFUNCTION2_DATAVADDR1(value uint32) {
	volatile.StoreUint32(&o.FUNCTION2.Reg, volatile.LoadUint32(&o.FUNCTION2.Reg)&^(0xf0000)|value<<16)
}
func (o *DWT_Type) GetFUNCTION2_DATAVADDR1() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION2.Reg) & 0xf0000) >> 16
}
func (o *DWT_Type) SetFUNCTION2_MATCHED(value uint32) {
	volatile.StoreUint32(&o.FUNCTION2.Reg, volatile.LoadUint32(&o.FUNCTION2.Reg)&^(0x1000000)|value<<24)
}
func (o *DWT_Type) GetFUNCTION2_MATCHED() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION2.Reg) & 0x1000000) >> 24
}

// DWT.MASK3: Mask Register 3
func (o *DWT_Type) SetMASK3_MASK(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x1f)|value)
}
func (o *DWT_Type) GetMASK3_MASK() uint32 {
	return volatile.LoadUint32(&o.MASK3.Reg) & 0x1f
}

// DWT.FUNCTION3: Function Register 3
func (o *DWT_Type) SetFUNCTION3_FUNCTION(value uint32) {
	volatile.StoreUint32(&o.FUNCTION3.Reg, volatile.LoadUint32(&o.FUNCTION3.Reg)&^(0xf)|value)
}
func (o *DWT_Type) GetFUNCTION3_FUNCTION() uint32 {
	return volatile.LoadUint32(&o.FUNCTION3.Reg) & 0xf
}
func (o *DWT_Type) SetFUNCTION3_EMITRANGE(value uint32) {
	volatile.StoreUint32(&o.FUNCTION3.Reg, volatile.LoadUint32(&o.FUNCTION3.Reg)&^(0x20)|value<<5)
}
func (o *DWT_Type) GetFUNCTION3_EMITRANGE() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION3.Reg) & 0x20) >> 5
}
func (o *DWT_Type) SetFUNCTION3_CYCMATCH(value uint32) {
	volatile.StoreUint32(&o.FUNCTION3.Reg, volatile.LoadUint32(&o.FUNCTION3.Reg)&^(0x80)|value<<7)
}
func (o *DWT_Type) GetFUNCTION3_CYCMATCH() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION3.Reg) & 0x80) >> 7
}
func (o *DWT_Type) SetFUNCTION3_DATAVMATCH(value uint32) {
	volatile.StoreUint32(&o.FUNCTION3.Reg, volatile.LoadUint32(&o.FUNCTION3.Reg)&^(0x100)|value<<8)
}
func (o *DWT_Type) GetFUNCTION3_DATAVMATCH() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION3.Reg) & 0x100) >> 8
}
func (o *DWT_Type) SetFUNCTION3_LNK1ENA(value uint32) {
	volatile.StoreUint32(&o.FUNCTION3.Reg, volatile.LoadUint32(&o.FUNCTION3.Reg)&^(0x200)|value<<9)
}
func (o *DWT_Type) GetFUNCTION3_LNK1ENA() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION3.Reg) & 0x200) >> 9
}
func (o *DWT_Type) SetFUNCTION3_DATAVSIZE(value uint32) {
	volatile.StoreUint32(&o.FUNCTION3.Reg, volatile.LoadUint32(&o.FUNCTION3.Reg)&^(0xc00)|value<<10)
}
func (o *DWT_Type) GetFUNCTION3_DATAVSIZE() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION3.Reg) & 0xc00) >> 10
}
func (o *DWT_Type) SetFUNCTION3_DATAVADDR0(value uint32) {
	volatile.StoreUint32(&o.FUNCTION3.Reg, volatile.LoadUint32(&o.FUNCTION3.Reg)&^(0xf000)|value<<12)
}
func (o *DWT_Type) GetFUNCTION3_DATAVADDR0() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION3.Reg) & 0xf000) >> 12
}
func (o *DWT_Type) SetFUNCTION3_DATAVADDR1(value uint32) {
	volatile.StoreUint32(&o.FUNCTION3.Reg, volatile.LoadUint32(&o.FUNCTION3.Reg)&^(0xf0000)|value<<16)
}
func (o *DWT_Type) GetFUNCTION3_DATAVADDR1() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION3.Reg) & 0xf0000) >> 16
}
func (o *DWT_Type) SetFUNCTION3_MATCHED(value uint32) {
	volatile.StoreUint32(&o.FUNCTION3.Reg, volatile.LoadUint32(&o.FUNCTION3.Reg)&^(0x1000000)|value<<24)
}
func (o *DWT_Type) GetFUNCTION3_MATCHED() uint32 {
	return (volatile.LoadUint32(&o.FUNCTION3.Reg) & 0x1000000) >> 24
}

// Embedded Trace Macrocell
type ETM_Type struct {
	CR         volatile.Register32 // 0x0
	CCR        volatile.Register32 // 0x4
	TRIGGER    volatile.Register32 // 0x8
	_          [4]byte
	SR         volatile.Register32 // 0x10
	SCR        volatile.Register32 // 0x14
	_          [8]byte
	TEEVR      volatile.Register32 // 0x20
	TECR1      volatile.Register32 // 0x24
	FFLR       volatile.Register32 // 0x28
	_          [276]byte
	CNTRLDVR1  volatile.Register32 // 0x140
	_          [156]byte
	SYNCFR     volatile.Register32 // 0x1E0
	IDR        volatile.Register32 // 0x1E4
	CCER       volatile.Register32 // 0x1E8
	_          [4]byte
	TESSEICR   volatile.Register32 // 0x1F0
	_          [4]byte
	TSEVT      volatile.Register32 // 0x1F8
	_          [4]byte
	TRACEIDR   volatile.Register32 // 0x200
	_          [4]byte
	IDR2       volatile.Register32 // 0x208
	_          [264]byte
	PDSR       volatile.Register32 // 0x314
	_          [3016]byte
	ITMISCIN   volatile.Register32 // 0xEE0
	_          [4]byte
	ITTRIGOUT  volatile.Register32 // 0xEE8
	_          [4]byte
	ITATBCTR2  volatile.Register32 // 0xEF0
	_          [4]byte
	ITATBCTR0  volatile.Register32 // 0xEF8
	_          [4]byte
	ITCTRL     volatile.Register32 // 0xF00
	_          [156]byte
	CLAIMSET   volatile.Register32 // 0xFA0
	CLAIMCLR   volatile.Register32 // 0xFA4
	_          [8]byte
	LAR        volatile.Register32 // 0xFB0
	LSR        volatile.Register32 // 0xFB4
	AUTHSTATUS volatile.Register32 // 0xFB8
	_          [16]byte
	DEVTYPE    volatile.Register32 // 0xFCC
	PIDR4      volatile.Register32 // 0xFD0
	PIDR5      volatile.Register32 // 0xFD4
	PIDR6      volatile.Register32 // 0xFD8
	PIDR7      volatile.Register32 // 0xFDC
	PIDR0      volatile.Register32 // 0xFE0
	PIDR1      volatile.Register32 // 0xFE4
	PIDR2      volatile.Register32 // 0xFE8
	PIDR3      volatile.Register32 // 0xFEC
	CIDR0      volatile.Register32 // 0xFF0
	CIDR1      volatile.Register32 // 0xFF4
	CIDR2      volatile.Register32 // 0xFF8
	CIDR3      volatile.Register32 // 0xFFC
}

// ETM.CR: ETM Main Control Register
func (o *ETM_Type) SetCR_ETMPD(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *ETM_Type) GetCR_ETMPD() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *ETM_Type) SetCR_PORTSIZE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x70)|value<<4)
}
func (o *ETM_Type) GetCR_PORTSIZE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x70) >> 4
}
func (o *ETM_Type) SetCR_STALL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *ETM_Type) GetCR_STALL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *ETM_Type) SetCR_BROUT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *ETM_Type) GetCR_BROUT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *ETM_Type) SetCR_DBGRQ(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *ETM_Type) GetCR_DBGRQ() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *ETM_Type) SetCR_PROG(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *ETM_Type) GetCR_PROG() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *ETM_Type) SetCR_PORTSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *ETM_Type) GetCR_PORTSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *ETM_Type) SetCR_PORTMODE2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *ETM_Type) GetCR_PORTMODE2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *ETM_Type) SetCR_PORTMODE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x30000)|value<<16)
}
func (o *ETM_Type) GetCR_PORTMODE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x30000) >> 16
}
func (o *ETM_Type) SetCR_PORTSIZE3(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200000)|value<<21)
}
func (o *ETM_Type) GetCR_PORTSIZE3() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200000) >> 21
}
func (o *ETM_Type) SetCR_TSEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000000)|value<<28)
}
func (o *ETM_Type) GetCR_TSEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000000) >> 28
}

// ETM.ITCTRL: ETM Integration Mode Control Register
func (o *ETM_Type) SetITCTRL_INTEGRATION(value uint32) {
	volatile.StoreUint32(&o.ITCTRL.Reg, volatile.LoadUint32(&o.ITCTRL.Reg)&^(0x1)|value)
}
func (o *ETM_Type) GetITCTRL_INTEGRATION() uint32 {
	return volatile.LoadUint32(&o.ITCTRL.Reg) & 0x1
}

// ETM.LSR: ETM Lock Status Register
func (o *ETM_Type) SetLSR_Present(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x1)|value)
}
func (o *ETM_Type) GetLSR_Present() uint32 {
	return volatile.LoadUint32(&o.LSR.Reg) & 0x1
}
func (o *ETM_Type) SetLSR_Access(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x2)|value<<1)
}
func (o *ETM_Type) GetLSR_Access() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x2) >> 1
}
func (o *ETM_Type) SetLSR_ByteAcc(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x4)|value<<2)
}
func (o *ETM_Type) GetLSR_ByteAcc() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x4) >> 2
}

// Floating Point Unit
type FPU_Type struct {
	_      [4]byte
	FPCCR  volatile.Register32 // 0x4
	FPCAR  volatile.Register32 // 0x8
	FPDSCR volatile.Register32 // 0xC
	MVFR0  volatile.Register32 // 0x10
	MVFR1  volatile.Register32 // 0x14
}

// FPU.FPCCR: Floating-Point Context Control Register
func (o *FPU_Type) SetFPCCR_LSPACT(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x1)|value)
}
func (o *FPU_Type) GetFPCCR_LSPACT() uint32 {
	return volatile.LoadUint32(&o.FPCCR.Reg) & 0x1
}
func (o *FPU_Type) SetFPCCR_USER(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x2)|value<<1)
}
func (o *FPU_Type) GetFPCCR_USER() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x2) >> 1
}
func (o *FPU_Type) SetFPCCR_THREAD(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x8)|value<<3)
}
func (o *FPU_Type) GetFPCCR_THREAD() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x8) >> 3
}
func (o *FPU_Type) SetFPCCR_HFRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x10)|value<<4)
}
func (o *FPU_Type) GetFPCCR_HFRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x10) >> 4
}
func (o *FPU_Type) SetFPCCR_MMRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x20)|value<<5)
}
func (o *FPU_Type) GetFPCCR_MMRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x20) >> 5
}
func (o *FPU_Type) SetFPCCR_BFRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x40)|value<<6)
}
func (o *FPU_Type) GetFPCCR_BFRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x40) >> 6
}
func (o *FPU_Type) SetFPCCR_MONRDY(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x100)|value<<8)
}
func (o *FPU_Type) GetFPCCR_MONRDY() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x100) >> 8
}
func (o *FPU_Type) SetFPCCR_LSPEN(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x40000000)|value<<30)
}
func (o *FPU_Type) GetFPCCR_LSPEN() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x40000000) >> 30
}
func (o *FPU_Type) SetFPCCR_ASPEN(value uint32) {
	volatile.StoreUint32(&o.FPCCR.Reg, volatile.LoadUint32(&o.FPCCR.Reg)&^(0x80000000)|value<<31)
}
func (o *FPU_Type) GetFPCCR_ASPEN() uint32 {
	return (volatile.LoadUint32(&o.FPCCR.Reg) & 0x80000000) >> 31
}

// FPU.FPCAR: Floating-Point Context Address Register
func (o *FPU_Type) SetFPCAR_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.FPCAR.Reg, volatile.LoadUint32(&o.FPCAR.Reg)&^(0xfffffff8)|value<<3)
}
func (o *FPU_Type) GetFPCAR_ADDRESS() uint32 {
	return (volatile.LoadUint32(&o.FPCAR.Reg) & 0xfffffff8) >> 3
}

// FPU.FPDSCR: Floating-Point Default Status Control Register
func (o *FPU_Type) SetFPDSCR_RMODE(value uint32) {
	volatile.StoreUint32(&o.FPDSCR.Reg, volatile.LoadUint32(&o.FPDSCR.Reg)&^(0xc00000)|value<<22)
}
func (o *FPU_Type) GetFPDSCR_RMODE() uint32 {
	return (volatile.LoadUint32(&o.FPDSCR.Reg) & 0xc00000) >> 22
}
func (o *FPU_Type) SetFPDSCR_FZ(value uint32) {
	volatile.StoreUint32(&o.FPDSCR.Reg, volatile.LoadUint32(&o.FPDSCR.Reg)&^(0x1000000)|value<<24)
}
func (o *FPU_Type) GetFPDSCR_FZ() uint32 {
	return (volatile.LoadUint32(&o.FPDSCR.Reg) & 0x1000000) >> 24
}
func (o *FPU_Type) SetFPDSCR_DN(value uint32) {
	volatile.StoreUint32(&o.FPDSCR.Reg, volatile.LoadUint32(&o.FPDSCR.Reg)&^(0x2000000)|value<<25)
}
func (o *FPU_Type) GetFPDSCR_DN() uint32 {
	return (volatile.LoadUint32(&o.FPDSCR.Reg) & 0x2000000) >> 25
}
func (o *FPU_Type) SetFPDSCR_AHP(value uint32) {
	volatile.StoreUint32(&o.FPDSCR.Reg, volatile.LoadUint32(&o.FPDSCR.Reg)&^(0x4000000)|value<<26)
}
func (o *FPU_Type) GetFPDSCR_AHP() uint32 {
	return (volatile.LoadUint32(&o.FPDSCR.Reg) & 0x4000000) >> 26
}

// FPU.MVFR0: Media and FP Feature Register 0
func (o *FPU_Type) SetMVFR0_A_SIMD_registers(value uint32) {
	volatile.StoreUint32(&o.MVFR0.Reg, volatile.LoadUint32(&o.MVFR0.Reg)&^(0xf)|value)
}
func (o *FPU_Type) GetMVFR0_A_SIMD_registers() uint32 {
	return volatile.LoadUint32(&o.MVFR0.Reg) & 0xf
}
func (o *FPU_Type) SetMVFR0_Single_precision(value uint32) {
	volatile.StoreUint32(&o.MVFR0.Reg, volatile.LoadUint32(&o.MVFR0.Reg)&^(0xf0)|value<<4)
}
func (o *FPU_Type) GetMVFR0_Single_precision() uint32 {
	return (volatile.LoadUint32(&o.MVFR0.Reg) & 0xf0) >> 4
}
func (o *FPU_Type) SetMVFR0_Double_precision(value uint32) {
	volatile.StoreUint32(&o.MVFR0.Reg, volatile.LoadUint32(&o.MVFR0.Reg)&^(0xf00)|value<<8)
}
func (o *FPU_Type) GetMVFR0_Double_precision() uint32 {
	return (volatile.LoadUint32(&o.MVFR0.Reg) & 0xf00) >> 8
}
func (o *FPU_Type) SetMVFR0_FP_excep_trapping(value uint32) {
	volatile.StoreUint32(&o.MVFR0.Reg, volatile.LoadUint32(&o.MVFR0.Reg)&^(0xf000)|value<<12)
}
func (o *FPU_Type) GetMVFR0_FP_excep_trapping() uint32 {
	return (volatile.LoadUint32(&o.MVFR0.Reg) & 0xf000) >> 12
}
func (o *FPU_Type) SetMVFR0_Divide(value uint32) {
	volatile.StoreUint32(&o.MVFR0.Reg, volatile.LoadUint32(&o.MVFR0.Reg)&^(0xf0000)|value<<16)
}
func (o *FPU_Type) GetMVFR0_Divide() uint32 {
	return (volatile.LoadUint32(&o.MVFR0.Reg) & 0xf0000) >> 16
}
func (o *FPU_Type) SetMVFR0_Square_root(value uint32) {
	volatile.StoreUint32(&o.MVFR0.Reg, volatile.LoadUint32(&o.MVFR0.Reg)&^(0xf00000)|value<<20)
}
func (o *FPU_Type) GetMVFR0_Square_root() uint32 {
	return (volatile.LoadUint32(&o.MVFR0.Reg) & 0xf00000) >> 20
}
func (o *FPU_Type) SetMVFR0_Short_vectors(value uint32) {
	volatile.StoreUint32(&o.MVFR0.Reg, volatile.LoadUint32(&o.MVFR0.Reg)&^(0xf000000)|value<<24)
}
func (o *FPU_Type) GetMVFR0_Short_vectors() uint32 {
	return (volatile.LoadUint32(&o.MVFR0.Reg) & 0xf000000) >> 24
}
func (o *FPU_Type) SetMVFR0_FP_rounding_modes(value uint32) {
	volatile.StoreUint32(&o.MVFR0.Reg, volatile.LoadUint32(&o.MVFR0.Reg)&^(0xf0000000)|value<<28)
}
func (o *FPU_Type) GetMVFR0_FP_rounding_modes() uint32 {
	return (volatile.LoadUint32(&o.MVFR0.Reg) & 0xf0000000) >> 28
}

// FPU.MVFR1: Media and FP Feature Register 1
func (o *FPU_Type) SetMVFR1_FtZ_mode(value uint32) {
	volatile.StoreUint32(&o.MVFR1.Reg, volatile.LoadUint32(&o.MVFR1.Reg)&^(0xf)|value)
}
func (o *FPU_Type) GetMVFR1_FtZ_mode() uint32 {
	return volatile.LoadUint32(&o.MVFR1.Reg) & 0xf
}
func (o *FPU_Type) SetMVFR1_D_NaN_mode(value uint32) {
	volatile.StoreUint32(&o.MVFR1.Reg, volatile.LoadUint32(&o.MVFR1.Reg)&^(0xf0)|value<<4)
}
func (o *FPU_Type) GetMVFR1_D_NaN_mode() uint32 {
	return (volatile.LoadUint32(&o.MVFR1.Reg) & 0xf0) >> 4
}
func (o *FPU_Type) SetMVFR1_FP_HPFP(value uint32) {
	volatile.StoreUint32(&o.MVFR1.Reg, volatile.LoadUint32(&o.MVFR1.Reg)&^(0xf000000)|value<<24)
}
func (o *FPU_Type) GetMVFR1_FP_HPFP() uint32 {
	return (volatile.LoadUint32(&o.MVFR1.Reg) & 0xf000000) >> 24
}
func (o *FPU_Type) SetMVFR1_FP_fused_MAC(value uint32) {
	volatile.StoreUint32(&o.MVFR1.Reg, volatile.LoadUint32(&o.MVFR1.Reg)&^(0xf0000000)|value<<28)
}
func (o *FPU_Type) GetMVFR1_FP_fused_MAC() uint32 {
	return (volatile.LoadUint32(&o.MVFR1.Reg) & 0xf0000000) >> 28
}

// Instrumentation Trace Macrocell
type ITM_Type struct {
	PORT_WORD_MODE [32]volatile.Register32 // 0x0
	_              [3456]byte
	TER            volatile.Register32 // 0xE00
	_              [60]byte
	TPR            volatile.Register32 // 0xE40
	_              [60]byte
	TCR            volatile.Register32 // 0xE80
	_              [116]byte
	IWR            volatile.Register32 // 0xEF8
	IRR            volatile.Register32 // 0xEFC
}

// ITM.PORT_WORD_MODE: ITM Stimulus Port Registers
func (o *ITM_Type) SetPORT_WORD_MODE(idx int, value uint32) {
	volatile.StoreUint32(&o.PORT_WORD_MODE[idx].Reg, value)
}
func (o *ITM_Type) GetPORT_WORD_MODE(idx int) uint32 {
	return volatile.LoadUint32(&o.PORT_WORD_MODE[idx].Reg)
}

// ITM.TPR: ITM Trace Privilege Register
func (o *ITM_Type) SetTPR_PRIVMASK(value uint32) {
	volatile.StoreUint32(&o.TPR.Reg, volatile.LoadUint32(&o.TPR.Reg)&^(0xf)|value)
}
func (o *ITM_Type) GetTPR_PRIVMASK() uint32 {
	return volatile.LoadUint32(&o.TPR.Reg) & 0xf
}

// ITM.TCR: ITM Trace Control Register
func (o *ITM_Type) SetTCR_ITMENA(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x1)|value)
}
func (o *ITM_Type) GetTCR_ITMENA() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0x1
}
func (o *ITM_Type) SetTCR_TSENA(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x2)|value<<1)
}
func (o *ITM_Type) GetTCR_TSENA() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x2) >> 1
}
func (o *ITM_Type) SetTCR_SYNCENA(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x4)|value<<2)
}
func (o *ITM_Type) GetTCR_SYNCENA() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x4) >> 2
}
func (o *ITM_Type) SetTCR_DWTENA(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x8)|value<<3)
}
func (o *ITM_Type) GetTCR_DWTENA() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x8) >> 3
}
func (o *ITM_Type) SetTCR_SWOENA(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x10)|value<<4)
}
func (o *ITM_Type) GetTCR_SWOENA() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x10) >> 4
}
func (o *ITM_Type) SetTCR_STALLENA(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x20)|value<<5)
}
func (o *ITM_Type) GetTCR_STALLENA() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x20) >> 5
}
func (o *ITM_Type) SetTCR_TSPrescale(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x300)|value<<8)
}
func (o *ITM_Type) GetTCR_TSPrescale() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x300) >> 8
}
func (o *ITM_Type) SetTCR_GTSFREQ(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xc00)|value<<10)
}
func (o *ITM_Type) GetTCR_GTSFREQ() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0xc00) >> 10
}
func (o *ITM_Type) SetTCR_TraceBusID(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x7f0000)|value<<16)
}
func (o *ITM_Type) GetTCR_TraceBusID() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x7f0000) >> 16
}
func (o *ITM_Type) SetTCR_BUSY(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x800000)|value<<23)
}
func (o *ITM_Type) GetTCR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x800000) >> 23
}

// ITM.IWR: ITM Integration Write Register
func (o *ITM_Type) SetIWR_ATVALIDM(value uint32) {
	volatile.StoreUint32(&o.IWR.Reg, volatile.LoadUint32(&o.IWR.Reg)&^(0x1)|value)
}
func (o *ITM_Type) GetIWR_ATVALIDM() uint32 {
	return volatile.LoadUint32(&o.IWR.Reg) & 0x1
}

// ITM.IRR: ITM Integration Read Register
func (o *ITM_Type) SetIRR_ATREADYM(value uint32) {
	volatile.StoreUint32(&o.IRR.Reg, volatile.LoadUint32(&o.IRR.Reg)&^(0x1)|value)
}
func (o *ITM_Type) GetIRR_ATREADYM() uint32 {
	return volatile.LoadUint32(&o.IRR.Reg) & 0x1
}

// Memory Protection Unit
type MPU_Type struct {
	TYPE    volatile.Register32 // 0x0
	CTRL    volatile.Register32 // 0x4
	RNR     volatile.Register32 // 0x8
	RBAR    volatile.Register32 // 0xC
	RASR    volatile.Register32 // 0x10
	RBAR_A1 volatile.Register32 // 0x14
	RASR_A1 volatile.Register32 // 0x18
	RBAR_A2 volatile.Register32 // 0x1C
	RASR_A2 volatile.Register32 // 0x20
	RBAR_A3 volatile.Register32 // 0x24
	RASR_A3 volatile.Register32 // 0x28
}

// MPU.TYPE: MPU Type Register
func (o *MPU_Type) SetTYPE_SEPARATE(value uint32) {
	volatile.StoreUint32(&o.TYPE.Reg, volatile.LoadUint32(&o.TYPE.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetTYPE_SEPARATE() uint32 {
	return volatile.LoadUint32(&o.TYPE.Reg) & 0x1
}
func (o *MPU_Type) SetTYPE_DREGION(value uint32) {
	volatile.StoreUint32(&o.TYPE.Reg, volatile.LoadUint32(&o.TYPE.Reg)&^(0xff00)|value<<8)
}
func (o *MPU_Type) GetTYPE_DREGION() uint32 {
	return (volatile.LoadUint32(&o.TYPE.Reg) & 0xff00) >> 8
}
func (o *MPU_Type) SetTYPE_IREGION(value uint32) {
	volatile.StoreUint32(&o.TYPE.Reg, volatile.LoadUint32(&o.TYPE.Reg)&^(0xff0000)|value<<16)
}
func (o *MPU_Type) GetTYPE_IREGION() uint32 {
	return (volatile.LoadUint32(&o.TYPE.Reg) & 0xff0000) >> 16
}

// MPU.CTRL: MPU Control Register
func (o *MPU_Type) SetCTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetCTRL_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *MPU_Type) SetCTRL_HFNMIENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *MPU_Type) GetCTRL_HFNMIENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *MPU_Type) SetCTRL_PRIVDEFENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *MPU_Type) GetCTRL_PRIVDEFENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}

// MPU.RNR: MPU Region Number Register
func (o *MPU_Type) SetRNR_REGION(value uint32) {
	volatile.StoreUint32(&o.RNR.Reg, volatile.LoadUint32(&o.RNR.Reg)&^(0xff)|value)
}
func (o *MPU_Type) GetRNR_REGION() uint32 {
	return volatile.LoadUint32(&o.RNR.Reg) & 0xff
}

// MPU.RBAR: MPU Region Base Address Register
func (o *MPU_Type) SetRBAR_REGION(value uint32) {
	volatile.StoreUint32(&o.RBAR.Reg, volatile.LoadUint32(&o.RBAR.Reg)&^(0xf)|value)
}
func (o *MPU_Type) GetRBAR_REGION() uint32 {
	return volatile.LoadUint32(&o.RBAR.Reg) & 0xf
}
func (o *MPU_Type) SetRBAR_VALID(value uint32) {
	volatile.StoreUint32(&o.RBAR.Reg, volatile.LoadUint32(&o.RBAR.Reg)&^(0x10)|value<<4)
}
func (o *MPU_Type) GetRBAR_VALID() uint32 {
	return (volatile.LoadUint32(&o.RBAR.Reg) & 0x10) >> 4
}
func (o *MPU_Type) SetRBAR_ADDR(value uint32) {
	volatile.StoreUint32(&o.RBAR.Reg, volatile.LoadUint32(&o.RBAR.Reg)&^(0xffffffe0)|value<<5)
}
func (o *MPU_Type) GetRBAR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.RBAR.Reg) & 0xffffffe0) >> 5
}

// MPU.RASR: MPU Region Attribute and Size Register
func (o *MPU_Type) SetRASR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetRASR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.RASR.Reg) & 0x1
}
func (o *MPU_Type) SetRASR_SIZE(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x2)|value<<1)
}
func (o *MPU_Type) GetRASR_SIZE() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x2) >> 1
}
func (o *MPU_Type) SetRASR_SRD(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0xff00)|value<<8)
}
func (o *MPU_Type) GetRASR_SRD() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0xff00) >> 8
}
func (o *MPU_Type) SetRASR_B(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x10000)|value<<16)
}
func (o *MPU_Type) GetRASR_B() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x10000) >> 16
}
func (o *MPU_Type) SetRASR_C(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x20000)|value<<17)
}
func (o *MPU_Type) GetRASR_C() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x20000) >> 17
}
func (o *MPU_Type) SetRASR_S(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x40000)|value<<18)
}
func (o *MPU_Type) GetRASR_S() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x40000) >> 18
}
func (o *MPU_Type) SetRASR_TEX(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x380000)|value<<19)
}
func (o *MPU_Type) GetRASR_TEX() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x380000) >> 19
}
func (o *MPU_Type) SetRASR_AP(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x7000000)|value<<24)
}
func (o *MPU_Type) GetRASR_AP() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x7000000) >> 24
}
func (o *MPU_Type) SetRASR_XN(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x10000000)|value<<28)
}
func (o *MPU_Type) GetRASR_XN() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x10000000) >> 28
}

// MPU.RBAR_A1: MPU Alias 1 Region Base Address Register
func (o *MPU_Type) SetRBAR_A1_REGION(value uint32) {
	volatile.StoreUint32(&o.RBAR_A1.Reg, volatile.LoadUint32(&o.RBAR_A1.Reg)&^(0xf)|value)
}
func (o *MPU_Type) GetRBAR_A1_REGION() uint32 {
	return volatile.LoadUint32(&o.RBAR_A1.Reg) & 0xf
}
func (o *MPU_Type) SetRBAR_A1_VALID(value uint32) {
	volatile.StoreUint32(&o.RBAR_A1.Reg, volatile.LoadUint32(&o.RBAR_A1.Reg)&^(0x10)|value<<4)
}
func (o *MPU_Type) GetRBAR_A1_VALID() uint32 {
	return (volatile.LoadUint32(&o.RBAR_A1.Reg) & 0x10) >> 4
}
func (o *MPU_Type) SetRBAR_A1_ADDR(value uint32) {
	volatile.StoreUint32(&o.RBAR_A1.Reg, volatile.LoadUint32(&o.RBAR_A1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *MPU_Type) GetRBAR_A1_ADDR() uint32 {
	return (volatile.LoadUint32(&o.RBAR_A1.Reg) & 0xffffffe0) >> 5
}

// MPU.RASR_A1: MPU Alias 1 Region Attribute and Size Register
func (o *MPU_Type) SetRASR_A1_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RASR_A1.Reg, volatile.LoadUint32(&o.RASR_A1.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetRASR_A1_ENABLE() uint32 {
	return volatile.LoadUint32(&o.RASR_A1.Reg) & 0x1
}
func (o *MPU_Type) SetRASR_A1_SIZE(value uint32) {
	volatile.StoreUint32(&o.RASR_A1.Reg, volatile.LoadUint32(&o.RASR_A1.Reg)&^(0x2)|value<<1)
}
func (o *MPU_Type) GetRASR_A1_SIZE() uint32 {
	return (volatile.LoadUint32(&o.RASR_A1.Reg) & 0x2) >> 1
}
func (o *MPU_Type) SetRASR_A1_SRD(value uint32) {
	volatile.StoreUint32(&o.RASR_A1.Reg, volatile.LoadUint32(&o.RASR_A1.Reg)&^(0xff00)|value<<8)
}
func (o *MPU_Type) GetRASR_A1_SRD() uint32 {
	return (volatile.LoadUint32(&o.RASR_A1.Reg) & 0xff00) >> 8
}
func (o *MPU_Type) SetRASR_A1_B(value uint32) {
	volatile.StoreUint32(&o.RASR_A1.Reg, volatile.LoadUint32(&o.RASR_A1.Reg)&^(0x10000)|value<<16)
}
func (o *MPU_Type) GetRASR_A1_B() uint32 {
	return (volatile.LoadUint32(&o.RASR_A1.Reg) & 0x10000) >> 16
}
func (o *MPU_Type) SetRASR_A1_C(value uint32) {
	volatile.StoreUint32(&o.RASR_A1.Reg, volatile.LoadUint32(&o.RASR_A1.Reg)&^(0x20000)|value<<17)
}
func (o *MPU_Type) GetRASR_A1_C() uint32 {
	return (volatile.LoadUint32(&o.RASR_A1.Reg) & 0x20000) >> 17
}
func (o *MPU_Type) SetRASR_A1_S(value uint32) {
	volatile.StoreUint32(&o.RASR_A1.Reg, volatile.LoadUint32(&o.RASR_A1.Reg)&^(0x40000)|value<<18)
}
func (o *MPU_Type) GetRASR_A1_S() uint32 {
	return (volatile.LoadUint32(&o.RASR_A1.Reg) & 0x40000) >> 18
}
func (o *MPU_Type) SetRASR_A1_TEX(value uint32) {
	volatile.StoreUint32(&o.RASR_A1.Reg, volatile.LoadUint32(&o.RASR_A1.Reg)&^(0x380000)|value<<19)
}
func (o *MPU_Type) GetRASR_A1_TEX() uint32 {
	return (volatile.LoadUint32(&o.RASR_A1.Reg) & 0x380000) >> 19
}
func (o *MPU_Type) SetRASR_A1_AP(value uint32) {
	volatile.StoreUint32(&o.RASR_A1.Reg, volatile.LoadUint32(&o.RASR_A1.Reg)&^(0x7000000)|value<<24)
}
func (o *MPU_Type) GetRASR_A1_AP() uint32 {
	return (volatile.LoadUint32(&o.RASR_A1.Reg) & 0x7000000) >> 24
}
func (o *MPU_Type) SetRASR_A1_XN(value uint32) {
	volatile.StoreUint32(&o.RASR_A1.Reg, volatile.LoadUint32(&o.RASR_A1.Reg)&^(0x10000000)|value<<28)
}
func (o *MPU_Type) GetRASR_A1_XN() uint32 {
	return (volatile.LoadUint32(&o.RASR_A1.Reg) & 0x10000000) >> 28
}

// MPU.RBAR_A2: MPU Alias 2 Region Base Address Register
func (o *MPU_Type) SetRBAR_A2_REGION(value uint32) {
	volatile.StoreUint32(&o.RBAR_A2.Reg, volatile.LoadUint32(&o.RBAR_A2.Reg)&^(0xf)|value)
}
func (o *MPU_Type) GetRBAR_A2_REGION() uint32 {
	return volatile.LoadUint32(&o.RBAR_A2.Reg) & 0xf
}
func (o *MPU_Type) SetRBAR_A2_VALID(value uint32) {
	volatile.StoreUint32(&o.RBAR_A2.Reg, volatile.LoadUint32(&o.RBAR_A2.Reg)&^(0x10)|value<<4)
}
func (o *MPU_Type) GetRBAR_A2_VALID() uint32 {
	return (volatile.LoadUint32(&o.RBAR_A2.Reg) & 0x10) >> 4
}
func (o *MPU_Type) SetRBAR_A2_ADDR(value uint32) {
	volatile.StoreUint32(&o.RBAR_A2.Reg, volatile.LoadUint32(&o.RBAR_A2.Reg)&^(0xffffffe0)|value<<5)
}
func (o *MPU_Type) GetRBAR_A2_ADDR() uint32 {
	return (volatile.LoadUint32(&o.RBAR_A2.Reg) & 0xffffffe0) >> 5
}

// MPU.RASR_A2: MPU Alias 2 Region Attribute and Size Register
func (o *MPU_Type) SetRASR_A2_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RASR_A2.Reg, volatile.LoadUint32(&o.RASR_A2.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetRASR_A2_ENABLE() uint32 {
	return volatile.LoadUint32(&o.RASR_A2.Reg) & 0x1
}
func (o *MPU_Type) SetRASR_A2_SIZE(value uint32) {
	volatile.StoreUint32(&o.RASR_A2.Reg, volatile.LoadUint32(&o.RASR_A2.Reg)&^(0x2)|value<<1)
}
func (o *MPU_Type) GetRASR_A2_SIZE() uint32 {
	return (volatile.LoadUint32(&o.RASR_A2.Reg) & 0x2) >> 1
}
func (o *MPU_Type) SetRASR_A2_SRD(value uint32) {
	volatile.StoreUint32(&o.RASR_A2.Reg, volatile.LoadUint32(&o.RASR_A2.Reg)&^(0xff00)|value<<8)
}
func (o *MPU_Type) GetRASR_A2_SRD() uint32 {
	return (volatile.LoadUint32(&o.RASR_A2.Reg) & 0xff00) >> 8
}
func (o *MPU_Type) SetRASR_A2_B(value uint32) {
	volatile.StoreUint32(&o.RASR_A2.Reg, volatile.LoadUint32(&o.RASR_A2.Reg)&^(0x10000)|value<<16)
}
func (o *MPU_Type) GetRASR_A2_B() uint32 {
	return (volatile.LoadUint32(&o.RASR_A2.Reg) & 0x10000) >> 16
}
func (o *MPU_Type) SetRASR_A2_C(value uint32) {
	volatile.StoreUint32(&o.RASR_A2.Reg, volatile.LoadUint32(&o.RASR_A2.Reg)&^(0x20000)|value<<17)
}
func (o *MPU_Type) GetRASR_A2_C() uint32 {
	return (volatile.LoadUint32(&o.RASR_A2.Reg) & 0x20000) >> 17
}
func (o *MPU_Type) SetRASR_A2_S(value uint32) {
	volatile.StoreUint32(&o.RASR_A2.Reg, volatile.LoadUint32(&o.RASR_A2.Reg)&^(0x40000)|value<<18)
}
func (o *MPU_Type) GetRASR_A2_S() uint32 {
	return (volatile.LoadUint32(&o.RASR_A2.Reg) & 0x40000) >> 18
}
func (o *MPU_Type) SetRASR_A2_TEX(value uint32) {
	volatile.StoreUint32(&o.RASR_A2.Reg, volatile.LoadUint32(&o.RASR_A2.Reg)&^(0x380000)|value<<19)
}
func (o *MPU_Type) GetRASR_A2_TEX() uint32 {
	return (volatile.LoadUint32(&o.RASR_A2.Reg) & 0x380000) >> 19
}
func (o *MPU_Type) SetRASR_A2_AP(value uint32) {
	volatile.StoreUint32(&o.RASR_A2.Reg, volatile.LoadUint32(&o.RASR_A2.Reg)&^(0x7000000)|value<<24)
}
func (o *MPU_Type) GetRASR_A2_AP() uint32 {
	return (volatile.LoadUint32(&o.RASR_A2.Reg) & 0x7000000) >> 24
}
func (o *MPU_Type) SetRASR_A2_XN(value uint32) {
	volatile.StoreUint32(&o.RASR_A2.Reg, volatile.LoadUint32(&o.RASR_A2.Reg)&^(0x10000000)|value<<28)
}
func (o *MPU_Type) GetRASR_A2_XN() uint32 {
	return (volatile.LoadUint32(&o.RASR_A2.Reg) & 0x10000000) >> 28
}

// MPU.RBAR_A3: MPU Alias 3 Region Base Address Register
func (o *MPU_Type) SetRBAR_A3_REGION(value uint32) {
	volatile.StoreUint32(&o.RBAR_A3.Reg, volatile.LoadUint32(&o.RBAR_A3.Reg)&^(0xf)|value)
}
func (o *MPU_Type) GetRBAR_A3_REGION() uint32 {
	return volatile.LoadUint32(&o.RBAR_A3.Reg) & 0xf
}
func (o *MPU_Type) SetRBAR_A3_VALID(value uint32) {
	volatile.StoreUint32(&o.RBAR_A3.Reg, volatile.LoadUint32(&o.RBAR_A3.Reg)&^(0x10)|value<<4)
}
func (o *MPU_Type) GetRBAR_A3_VALID() uint32 {
	return (volatile.LoadUint32(&o.RBAR_A3.Reg) & 0x10) >> 4
}
func (o *MPU_Type) SetRBAR_A3_ADDR(value uint32) {
	volatile.StoreUint32(&o.RBAR_A3.Reg, volatile.LoadUint32(&o.RBAR_A3.Reg)&^(0xffffffe0)|value<<5)
}
func (o *MPU_Type) GetRBAR_A3_ADDR() uint32 {
	return (volatile.LoadUint32(&o.RBAR_A3.Reg) & 0xffffffe0) >> 5
}

// MPU.RASR_A3: MPU Alias 3 Region Attribute and Size Register
func (o *MPU_Type) SetRASR_A3_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RASR_A3.Reg, volatile.LoadUint32(&o.RASR_A3.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetRASR_A3_ENABLE() uint32 {
	return volatile.LoadUint32(&o.RASR_A3.Reg) & 0x1
}
func (o *MPU_Type) SetRASR_A3_SIZE(value uint32) {
	volatile.StoreUint32(&o.RASR_A3.Reg, volatile.LoadUint32(&o.RASR_A3.Reg)&^(0x2)|value<<1)
}
func (o *MPU_Type) GetRASR_A3_SIZE() uint32 {
	return (volatile.LoadUint32(&o.RASR_A3.Reg) & 0x2) >> 1
}
func (o *MPU_Type) SetRASR_A3_SRD(value uint32) {
	volatile.StoreUint32(&o.RASR_A3.Reg, volatile.LoadUint32(&o.RASR_A3.Reg)&^(0xff00)|value<<8)
}
func (o *MPU_Type) GetRASR_A3_SRD() uint32 {
	return (volatile.LoadUint32(&o.RASR_A3.Reg) & 0xff00) >> 8
}
func (o *MPU_Type) SetRASR_A3_B(value uint32) {
	volatile.StoreUint32(&o.RASR_A3.Reg, volatile.LoadUint32(&o.RASR_A3.Reg)&^(0x10000)|value<<16)
}
func (o *MPU_Type) GetRASR_A3_B() uint32 {
	return (volatile.LoadUint32(&o.RASR_A3.Reg) & 0x10000) >> 16
}
func (o *MPU_Type) SetRASR_A3_C(value uint32) {
	volatile.StoreUint32(&o.RASR_A3.Reg, volatile.LoadUint32(&o.RASR_A3.Reg)&^(0x20000)|value<<17)
}
func (o *MPU_Type) GetRASR_A3_C() uint32 {
	return (volatile.LoadUint32(&o.RASR_A3.Reg) & 0x20000) >> 17
}
func (o *MPU_Type) SetRASR_A3_S(value uint32) {
	volatile.StoreUint32(&o.RASR_A3.Reg, volatile.LoadUint32(&o.RASR_A3.Reg)&^(0x40000)|value<<18)
}
func (o *MPU_Type) GetRASR_A3_S() uint32 {
	return (volatile.LoadUint32(&o.RASR_A3.Reg) & 0x40000) >> 18
}
func (o *MPU_Type) SetRASR_A3_TEX(value uint32) {
	volatile.StoreUint32(&o.RASR_A3.Reg, volatile.LoadUint32(&o.RASR_A3.Reg)&^(0x380000)|value<<19)
}
func (o *MPU_Type) GetRASR_A3_TEX() uint32 {
	return (volatile.LoadUint32(&o.RASR_A3.Reg) & 0x380000) >> 19
}
func (o *MPU_Type) SetRASR_A3_AP(value uint32) {
	volatile.StoreUint32(&o.RASR_A3.Reg, volatile.LoadUint32(&o.RASR_A3.Reg)&^(0x7000000)|value<<24)
}
func (o *MPU_Type) GetRASR_A3_AP() uint32 {
	return (volatile.LoadUint32(&o.RASR_A3.Reg) & 0x7000000) >> 24
}
func (o *MPU_Type) SetRASR_A3_XN(value uint32) {
	volatile.StoreUint32(&o.RASR_A3.Reg, volatile.LoadUint32(&o.RASR_A3.Reg)&^(0x10000000)|value<<28)
}
func (o *MPU_Type) GetRASR_A3_XN() uint32 {
	return (volatile.LoadUint32(&o.RASR_A3.Reg) & 0x10000000) >> 28
}

// Nested Vectored Interrupt Controller
type NVIC_Type struct {
	ISER [5]volatile.Register32 // 0x0
	_    [108]byte
	ICER [5]volatile.Register32 // 0x80
	_    [108]byte
	ISPR [5]volatile.Register32 // 0x100
	_    [108]byte
	ICPR [5]volatile.Register32 // 0x180
	_    [108]byte
	IABR [5]volatile.Register32 // 0x200
	_    [236]byte
	IP   [35]volatile.Register8 // 0x300
	_    [2781]byte
	STIR volatile.Register32 // 0xE00
}

// NVIC.ISER: Interrupt Set Enable Register
func (o *NVIC_Type) SetISER(idx int, value uint32) {
	volatile.StoreUint32(&o.ISER[idx].Reg, value)
}
func (o *NVIC_Type) GetISER(idx int) uint32 {
	return volatile.LoadUint32(&o.ISER[idx].Reg)
}

// NVIC.ICER: Interrupt Clear Enable Register
func (o *NVIC_Type) SetICER(idx int, value uint32) {
	volatile.StoreUint32(&o.ICER[idx].Reg, value)
}
func (o *NVIC_Type) GetICER(idx int) uint32 {
	return volatile.LoadUint32(&o.ICER[idx].Reg)
}

// NVIC.ISPR: Interrupt Set Pending Register
func (o *NVIC_Type) SetISPR(idx int, value uint32) {
	volatile.StoreUint32(&o.ISPR[idx].Reg, value)
}
func (o *NVIC_Type) GetISPR(idx int) uint32 {
	return volatile.LoadUint32(&o.ISPR[idx].Reg)
}

// NVIC.ICPR: Interrupt Clear Pending Register
func (o *NVIC_Type) SetICPR(idx int, value uint32) {
	volatile.StoreUint32(&o.ICPR[idx].Reg, value)
}
func (o *NVIC_Type) GetICPR(idx int) uint32 {
	return volatile.LoadUint32(&o.ICPR[idx].Reg)
}

// NVIC.IABR: Interrupt Active Bit Register
func (o *NVIC_Type) SetIABR(idx int, value uint32) {
	volatile.StoreUint32(&o.IABR[idx].Reg, value)
}
func (o *NVIC_Type) GetIABR(idx int) uint32 {
	return volatile.LoadUint32(&o.IABR[idx].Reg)
}

// NVIC.IP: Interrupt Priority Register n
func (o *NVIC_Type) SetIP_PRI0(idx int, value uint8) {
	volatile.StoreUint8(&o.IP[idx].Reg, volatile.LoadUint8(&o.IP[idx].Reg)&^(0x7)|value)
}
func (o *NVIC_Type) GetIP_PRI0(idx int) uint8 {
	return volatile.LoadUint8(&o.IP[idx].Reg) & 0x7
}

// NVIC.STIR: Software Trigger Interrupt Register
func (o *NVIC_Type) SetSTIR_INTID(value uint32) {
	volatile.StoreUint32(&o.STIR.Reg, volatile.LoadUint32(&o.STIR.Reg)&^(0x1ff)|value)
}
func (o *NVIC_Type) GetSTIR_INTID() uint32 {
	return volatile.LoadUint32(&o.STIR.Reg) & 0x1ff
}

// System timer
type SysTick_Type struct {
	CSR   volatile.Register32 // 0x0
	RVR   volatile.Register32 // 0x4
	CVR   volatile.Register32 // 0x8
	CALIB volatile.Register32 // 0xC
}

// SysTick.CSR: SysTick Control and Status Register
func (o *SysTick_Type) SetCSR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *SysTick_Type) GetCSR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}
func (o *SysTick_Type) SetCSR_TICKINT(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *SysTick_Type) GetCSR_TICKINT() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}
func (o *SysTick_Type) SetCSR_CLKSOURCE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4)|value<<2)
}
func (o *SysTick_Type) GetCSR_CLKSOURCE() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4) >> 2
}
func (o *SysTick_Type) SetCSR_COUNTFLAG(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x10000)|value<<16)
}
func (o *SysTick_Type) GetCSR_COUNTFLAG() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x10000) >> 16
}

// SysTick.RVR: SysTick Reload Value Register
func (o *SysTick_Type) SetRVR_RELOAD(value uint32) {
	volatile.StoreUint32(&o.RVR.Reg, volatile.LoadUint32(&o.RVR.Reg)&^(0xffffff)|value)
}
func (o *SysTick_Type) GetRVR_RELOAD() uint32 {
	return volatile.LoadUint32(&o.RVR.Reg) & 0xffffff
}

// SysTick.CVR: SysTick Current Value Register
func (o *SysTick_Type) SetCVR_CURRENT(value uint32) {
	volatile.StoreUint32(&o.CVR.Reg, volatile.LoadUint32(&o.CVR.Reg)&^(0xffffff)|value)
}
func (o *SysTick_Type) GetCVR_CURRENT() uint32 {
	return volatile.LoadUint32(&o.CVR.Reg) & 0xffffff
}

// SysTick.CALIB: SysTick Calibration Value Register
func (o *SysTick_Type) SetCALIB_TENMS(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0xffffff)|value)
}
func (o *SysTick_Type) GetCALIB_TENMS() uint32 {
	return volatile.LoadUint32(&o.CALIB.Reg) & 0xffffff
}
func (o *SysTick_Type) SetCALIB_SKEW(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0x40000000)|value<<30)
}
func (o *SysTick_Type) GetCALIB_SKEW() uint32 {
	return (volatile.LoadUint32(&o.CALIB.Reg) & 0x40000000) >> 30
}
func (o *SysTick_Type) SetCALIB_NOREF(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0x80000000)|value<<31)
}
func (o *SysTick_Type) GetCALIB_NOREF() uint32 {
	return (volatile.LoadUint32(&o.CALIB.Reg) & 0x80000000) >> 31
}

// System Control Registers
type SystemControl_Type struct {
	_     [4]byte
	ICTR  volatile.Register32 // 0x4
	ACTLR volatile.Register32 // 0x8
	_     [3316]byte
	CPUID volatile.Register32    // 0xD00
	ICSR  volatile.Register32    // 0xD04
	VTOR  volatile.Register32    // 0xD08
	AIRCR volatile.Register32    // 0xD0C
	SCR   volatile.Register32    // 0xD10
	CCR   volatile.Register32    // 0xD14
	SHPR1 volatile.Register32    // 0xD18
	SHPR2 volatile.Register32    // 0xD1C
	SHPR3 volatile.Register32    // 0xD20
	SHCSR volatile.Register32    // 0xD24
	CFSR  volatile.Register32    // 0xD28
	HFSR  volatile.Register32    // 0xD2C
	DFSR  volatile.Register32    // 0xD30
	MMFAR volatile.Register32    // 0xD34
	BFAR  volatile.Register32    // 0xD38
	AFSR  volatile.Register32    // 0xD3C
	PFR   [2]volatile.Register32 // 0xD40
	DFR   volatile.Register32    // 0xD48
	ADR   volatile.Register32    // 0xD4C
	MMFR  [4]volatile.Register32 // 0xD50
	ISAR  [5]volatile.Register32 // 0xD60
	_     [20]byte
	CPACR volatile.Register32 // 0xD88
}

// SystemControl.ICTR: Interrupt Controller Type Register
func (o *SystemControl_Type) SetICTR_INTLINESNUM(value uint32) {
	volatile.StoreUint32(&o.ICTR.Reg, volatile.LoadUint32(&o.ICTR.Reg)&^(0xf)|value)
}
func (o *SystemControl_Type) GetICTR_INTLINESNUM() uint32 {
	return volatile.LoadUint32(&o.ICTR.Reg) & 0xf
}

// SystemControl.ACTLR: Auxiliary Control Register
func (o *SystemControl_Type) SetACTLR_DISMCYCINT(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x1)|value)
}
func (o *SystemControl_Type) GetACTLR_DISMCYCINT() uint32 {
	return volatile.LoadUint32(&o.ACTLR.Reg) & 0x1
}
func (o *SystemControl_Type) SetACTLR_DISDEFWBUF(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetACTLR_DISDEFWBUF() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetACTLR_DISFOLD(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x4)|value<<2)
}
func (o *SystemControl_Type) GetACTLR_DISFOLD() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x4) >> 2
}
func (o *SystemControl_Type) SetACTLR_DISFPCA(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x100)|value<<8)
}
func (o *SystemControl_Type) GetACTLR_DISFPCA() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x100) >> 8
}
func (o *SystemControl_Type) SetACTLR_DISOOFP(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x200)|value<<9)
}
func (o *SystemControl_Type) GetACTLR_DISOOFP() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x200) >> 9
}

// SystemControl.CPUID: CPUID Base Register
func (o *SystemControl_Type) SetCPUID_REVISION(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf)|value)
}
func (o *SystemControl_Type) GetCPUID_REVISION() uint32 {
	return volatile.LoadUint32(&o.CPUID.Reg) & 0xf
}
func (o *SystemControl_Type) SetCPUID_PARTNO(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xfff0)|value<<4)
}
func (o *SystemControl_Type) GetCPUID_PARTNO() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xfff0) >> 4
}
func (o *SystemControl_Type) SetCPUID_CONSTANT(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf0000)|value<<16)
}
func (o *SystemControl_Type) GetCPUID_CONSTANT() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xf0000) >> 16
}
func (o *SystemControl_Type) SetCPUID_VARIANT(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf00000)|value<<20)
}
func (o *SystemControl_Type) GetCPUID_VARIANT() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xf00000) >> 20
}
func (o *SystemControl_Type) SetCPUID_IMPLEMENTER(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xff000000)|value<<24)
}
func (o *SystemControl_Type) GetCPUID_IMPLEMENTER() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xff000000) >> 24
}

// SystemControl.ICSR: Interrupt Control and State Register
func (o *SystemControl_Type) SetICSR_VECTACTIVE(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x1ff)|value)
}
func (o *SystemControl_Type) GetICSR_VECTACTIVE() uint32 {
	return volatile.LoadUint32(&o.ICSR.Reg) & 0x1ff
}
func (o *SystemControl_Type) SetICSR_RETTOBASE(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x800)|value<<11)
}
func (o *SystemControl_Type) GetICSR_RETTOBASE() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x800) >> 11
}
func (o *SystemControl_Type) SetICSR_VECTPENDING(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x3f000)|value<<12)
}
func (o *SystemControl_Type) GetICSR_VECTPENDING() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x3f000) >> 12
}
func (o *SystemControl_Type) SetICSR_ISRPENDING(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x400000)|value<<22)
}
func (o *SystemControl_Type) GetICSR_ISRPENDING() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x400000) >> 22
}
func (o *SystemControl_Type) SetICSR_ISRPREEMPT(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x800000)|value<<23)
}
func (o *SystemControl_Type) GetICSR_ISRPREEMPT() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x800000) >> 23
}
func (o *SystemControl_Type) SetICSR_PENDSTCLR(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x2000000)|value<<25)
}
func (o *SystemControl_Type) GetICSR_PENDSTCLR() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x2000000) >> 25
}
func (o *SystemControl_Type) SetICSR_PENDSTSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x4000000)|value<<26)
}
func (o *SystemControl_Type) GetICSR_PENDSTSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x4000000) >> 26
}
func (o *SystemControl_Type) SetICSR_PENDSVCLR(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x8000000)|value<<27)
}
func (o *SystemControl_Type) GetICSR_PENDSVCLR() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x8000000) >> 27
}
func (o *SystemControl_Type) SetICSR_PENDSVSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x10000000)|value<<28)
}
func (o *SystemControl_Type) GetICSR_PENDSVSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x10000000) >> 28
}
func (o *SystemControl_Type) SetICSR_NMIPENDSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x80000000)|value<<31)
}
func (o *SystemControl_Type) GetICSR_NMIPENDSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x80000000) >> 31
}

// SystemControl.VTOR: Vector Table Offset Register
func (o *SystemControl_Type) SetVTOR_TBLOFF(value uint32) {
	volatile.StoreUint32(&o.VTOR.Reg, volatile.LoadUint32(&o.VTOR.Reg)&^(0xffffff80)|value<<7)
}
func (o *SystemControl_Type) GetVTOR_TBLOFF() uint32 {
	return (volatile.LoadUint32(&o.VTOR.Reg) & 0xffffff80) >> 7
}

// SystemControl.AIRCR: Application Interrupt and Reset Control Register
func (o *SystemControl_Type) SetAIRCR_VECTRESET(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x1)|value)
}
func (o *SystemControl_Type) GetAIRCR_VECTRESET() uint32 {
	return volatile.LoadUint32(&o.AIRCR.Reg) & 0x1
}
func (o *SystemControl_Type) SetAIRCR_VECTCLRACTIVE(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetAIRCR_VECTCLRACTIVE() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetAIRCR_SYSRESETREQ(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x4)|value<<2)
}
func (o *SystemControl_Type) GetAIRCR_SYSRESETREQ() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x4) >> 2
}
func (o *SystemControl_Type) SetAIRCR_PRIGROUP(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x700)|value<<8)
}
func (o *SystemControl_Type) GetAIRCR_PRIGROUP() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x700) >> 8
}
func (o *SystemControl_Type) SetAIRCR_ENDIANNESS(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x8000)|value<<15)
}
func (o *SystemControl_Type) GetAIRCR_ENDIANNESS() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x8000) >> 15
}
func (o *SystemControl_Type) SetAIRCR_VECTKEY(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SystemControl_Type) GetAIRCR_VECTKEY() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0xffff0000) >> 16
}

// SystemControl.SCR: System Control Register
func (o *SystemControl_Type) SetSCR_SLEEPONEXIT(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetSCR_SLEEPONEXIT() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetSCR_SLEEPDEEP(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *SystemControl_Type) GetSCR_SLEEPDEEP() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x4) >> 2
}
func (o *SystemControl_Type) SetSCR_SEVONPEND(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *SystemControl_Type) GetSCR_SEVONPEND() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x10) >> 4
}

// SystemControl.CCR: Configuration and Control Register
func (o *SystemControl_Type) SetCCR_NONBASETHRDENA(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1)|value)
}
func (o *SystemControl_Type) GetCCR_NONBASETHRDENA() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x1
}
func (o *SystemControl_Type) SetCCR_USERSETMPEND(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetCCR_USERSETMPEND() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetCCR_UNALIGN_TRP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x8)|value<<3)
}
func (o *SystemControl_Type) GetCCR_UNALIGN_TRP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x8) >> 3
}
func (o *SystemControl_Type) SetCCR_DIV_0_TRP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x10)|value<<4)
}
func (o *SystemControl_Type) GetCCR_DIV_0_TRP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x10) >> 4
}
func (o *SystemControl_Type) SetCCR_BFHFNMIGN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x100)|value<<8)
}
func (o *SystemControl_Type) GetCCR_BFHFNMIGN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x100) >> 8
}
func (o *SystemControl_Type) SetCCR_STKALIGN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x200)|value<<9)
}
func (o *SystemControl_Type) GetCCR_STKALIGN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x200) >> 9
}

// SystemControl.SHPR1: System Handler Priority Register 1
func (o *SystemControl_Type) SetSHPR1_PRI_4(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff)|value)
}
func (o *SystemControl_Type) GetSHPR1_PRI_4() uint32 {
	return volatile.LoadUint32(&o.SHPR1.Reg) & 0xff
}
func (o *SystemControl_Type) SetSHPR1_PRI_5(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff00)|value<<8)
}
func (o *SystemControl_Type) GetSHPR1_PRI_5() uint32 {
	return (volatile.LoadUint32(&o.SHPR1.Reg) & 0xff00) >> 8
}
func (o *SystemControl_Type) SetSHPR1_PRI_6(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff0000)|value<<16)
}
func (o *SystemControl_Type) GetSHPR1_PRI_6() uint32 {
	return (volatile.LoadUint32(&o.SHPR1.Reg) & 0xff0000) >> 16
}

// SystemControl.SHPR2: System Handler Priority Register 2
func (o *SystemControl_Type) SetSHPR2_PRI_11(value uint32) {
	volatile.StoreUint32(&o.SHPR2.Reg, volatile.LoadUint32(&o.SHPR2.Reg)&^(0xff000000)|value<<24)
}
func (o *SystemControl_Type) GetSHPR2_PRI_11() uint32 {
	return (volatile.LoadUint32(&o.SHPR2.Reg) & 0xff000000) >> 24
}

// SystemControl.SHPR3: System Handler Priority Register 3
func (o *SystemControl_Type) SetSHPR3_PRI_14(value uint32) {
	volatile.StoreUint32(&o.SHPR3.Reg, volatile.LoadUint32(&o.SHPR3.Reg)&^(0xff0000)|value<<16)
}
func (o *SystemControl_Type) GetSHPR3_PRI_14() uint32 {
	return (volatile.LoadUint32(&o.SHPR3.Reg) & 0xff0000) >> 16
}
func (o *SystemControl_Type) SetSHPR3_PRI_15(value uint32) {
	volatile.StoreUint32(&o.SHPR3.Reg, volatile.LoadUint32(&o.SHPR3.Reg)&^(0xff000000)|value<<24)
}
func (o *SystemControl_Type) GetSHPR3_PRI_15() uint32 {
	return (volatile.LoadUint32(&o.SHPR3.Reg) & 0xff000000) >> 24
}

// SystemControl.SHCSR: System Handler Control and State Register
func (o *SystemControl_Type) SetSHCSR_MEMFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x1)|value)
}
func (o *SystemControl_Type) GetSHCSR_MEMFAULTACT() uint32 {
	return volatile.LoadUint32(&o.SHCSR.Reg) & 0x1
}
func (o *SystemControl_Type) SetSHCSR_BUSFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetSHCSR_BUSFAULTACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetSHCSR_USGFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x8)|value<<3)
}
func (o *SystemControl_Type) GetSHCSR_USGFAULTACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x8) >> 3
}
func (o *SystemControl_Type) SetSHCSR_SVCALLACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x80)|value<<7)
}
func (o *SystemControl_Type) GetSHCSR_SVCALLACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x80) >> 7
}
func (o *SystemControl_Type) SetSHCSR_MONITORACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x100)|value<<8)
}
func (o *SystemControl_Type) GetSHCSR_MONITORACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x100) >> 8
}
func (o *SystemControl_Type) SetSHCSR_PENDSVACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x400)|value<<10)
}
func (o *SystemControl_Type) GetSHCSR_PENDSVACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x400) >> 10
}
func (o *SystemControl_Type) SetSHCSR_SYSTICKACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x800)|value<<11)
}
func (o *SystemControl_Type) GetSHCSR_SYSTICKACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x800) >> 11
}
func (o *SystemControl_Type) SetSHCSR_USGFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x1000)|value<<12)
}
func (o *SystemControl_Type) GetSHCSR_USGFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x1000) >> 12
}
func (o *SystemControl_Type) SetSHCSR_MEMFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x2000)|value<<13)
}
func (o *SystemControl_Type) GetSHCSR_MEMFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x2000) >> 13
}
func (o *SystemControl_Type) SetSHCSR_BUSFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x4000)|value<<14)
}
func (o *SystemControl_Type) GetSHCSR_BUSFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x4000) >> 14
}
func (o *SystemControl_Type) SetSHCSR_SVCALLPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x8000)|value<<15)
}
func (o *SystemControl_Type) GetSHCSR_SVCALLPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x8000) >> 15
}
func (o *SystemControl_Type) SetSHCSR_MEMFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x10000)|value<<16)
}
func (o *SystemControl_Type) GetSHCSR_MEMFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x10000) >> 16
}
func (o *SystemControl_Type) SetSHCSR_BUSFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x20000)|value<<17)
}
func (o *SystemControl_Type) GetSHCSR_BUSFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x20000) >> 17
}
func (o *SystemControl_Type) SetSHCSR_USGFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x40000)|value<<18)
}
func (o *SystemControl_Type) GetSHCSR_USGFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x40000) >> 18
}

// SystemControl.CFSR: Configurable Fault Status Register
func (o *SystemControl_Type) SetCFSR_IACCVIOL(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x1)|value)
}
func (o *SystemControl_Type) GetCFSR_IACCVIOL() uint32 {
	return volatile.LoadUint32(&o.CFSR.Reg) & 0x1
}
func (o *SystemControl_Type) SetCFSR_DACCVIOL(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetCFSR_DACCVIOL() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetCFSR_MUNSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x8)|value<<3)
}
func (o *SystemControl_Type) GetCFSR_MUNSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x8) >> 3
}
func (o *SystemControl_Type) SetCFSR_MSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x10)|value<<4)
}
func (o *SystemControl_Type) GetCFSR_MSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x10) >> 4
}
func (o *SystemControl_Type) SetCFSR_MLSPERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x20)|value<<5)
}
func (o *SystemControl_Type) GetCFSR_MLSPERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x20) >> 5
}
func (o *SystemControl_Type) SetCFSR_MMARVALID(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x80)|value<<7)
}
func (o *SystemControl_Type) GetCFSR_MMARVALID() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x80) >> 7
}
func (o *SystemControl_Type) SetCFSR_IBUSERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x100)|value<<8)
}
func (o *SystemControl_Type) GetCFSR_IBUSERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x100) >> 8
}
func (o *SystemControl_Type) SetCFSR_PRECISERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x200)|value<<9)
}
func (o *SystemControl_Type) GetCFSR_PRECISERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x200) >> 9
}
func (o *SystemControl_Type) SetCFSR_IMPRECISERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x400)|value<<10)
}
func (o *SystemControl_Type) GetCFSR_IMPRECISERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x400) >> 10
}
func (o *SystemControl_Type) SetCFSR_UNSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x800)|value<<11)
}
func (o *SystemControl_Type) GetCFSR_UNSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x800) >> 11
}
func (o *SystemControl_Type) SetCFSR_STKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x1000)|value<<12)
}
func (o *SystemControl_Type) GetCFSR_STKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x1000) >> 12
}
func (o *SystemControl_Type) SetCFSR_LSPERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x2000)|value<<13)
}
func (o *SystemControl_Type) GetCFSR_LSPERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x2000) >> 13
}
func (o *SystemControl_Type) SetCFSR_BFARVALID(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x8000)|value<<15)
}
func (o *SystemControl_Type) GetCFSR_BFARVALID() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x8000) >> 15
}
func (o *SystemControl_Type) SetCFSR_UNDEFINSTR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x10000)|value<<16)
}
func (o *SystemControl_Type) GetCFSR_UNDEFINSTR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x10000) >> 16
}
func (o *SystemControl_Type) SetCFSR_INVSTATE(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x20000)|value<<17)
}
func (o *SystemControl_Type) GetCFSR_INVSTATE() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x20000) >> 17
}
func (o *SystemControl_Type) SetCFSR_INVPC(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x40000)|value<<18)
}
func (o *SystemControl_Type) GetCFSR_INVPC() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x40000) >> 18
}
func (o *SystemControl_Type) SetCFSR_NOCP(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x80000)|value<<19)
}
func (o *SystemControl_Type) GetCFSR_NOCP() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x80000) >> 19
}
func (o *SystemControl_Type) SetCFSR_UNALIGNED(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x1000000)|value<<24)
}
func (o *SystemControl_Type) GetCFSR_UNALIGNED() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x1000000) >> 24
}
func (o *SystemControl_Type) SetCFSR_DIVBYZERO(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x2000000)|value<<25)
}
func (o *SystemControl_Type) GetCFSR_DIVBYZERO() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x2000000) >> 25
}

// SystemControl.HFSR: HardFault Status Register
func (o *SystemControl_Type) SetHFSR_VECTTBL(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetHFSR_VECTTBL() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetHFSR_FORCED(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x40000000)|value<<30)
}
func (o *SystemControl_Type) GetHFSR_FORCED() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x40000000) >> 30
}
func (o *SystemControl_Type) SetHFSR_DEBUGEVT(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x80000000)|value<<31)
}
func (o *SystemControl_Type) GetHFSR_DEBUGEVT() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x80000000) >> 31
}

// SystemControl.DFSR: Debug Fault Status Register
func (o *SystemControl_Type) SetDFSR_HALTED(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x1)|value)
}
func (o *SystemControl_Type) GetDFSR_HALTED() uint32 {
	return volatile.LoadUint32(&o.DFSR.Reg) & 0x1
}
func (o *SystemControl_Type) SetDFSR_BKPT(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x2)|value<<1)
}
func (o *SystemControl_Type) GetDFSR_BKPT() uint32 {
	return (volatile.LoadUint32(&o.DFSR.Reg) & 0x2) >> 1
}
func (o *SystemControl_Type) SetDFSR_DWTTRAP(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x4)|value<<2)
}
func (o *SystemControl_Type) GetDFSR_DWTTRAP() uint32 {
	return (volatile.LoadUint32(&o.DFSR.Reg) & 0x4) >> 2
}
func (o *SystemControl_Type) SetDFSR_VCATCH(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x8)|value<<3)
}
func (o *SystemControl_Type) GetDFSR_VCATCH() uint32 {
	return (volatile.LoadUint32(&o.DFSR.Reg) & 0x8) >> 3
}
func (o *SystemControl_Type) SetDFSR_EXTERNAL(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x10)|value<<4)
}
func (o *SystemControl_Type) GetDFSR_EXTERNAL() uint32 {
	return (volatile.LoadUint32(&o.DFSR.Reg) & 0x10) >> 4
}

// SystemControl.MMFAR: MemManage Fault Address Register
func (o *SystemControl_Type) SetMMFAR(value uint32) {
	volatile.StoreUint32(&o.MMFAR.Reg, value)
}
func (o *SystemControl_Type) GetMMFAR() uint32 {
	return volatile.LoadUint32(&o.MMFAR.Reg)
}

// SystemControl.BFAR: BusFault Address Register
func (o *SystemControl_Type) SetBFAR(value uint32) {
	volatile.StoreUint32(&o.BFAR.Reg, value)
}
func (o *SystemControl_Type) GetBFAR() uint32 {
	return volatile.LoadUint32(&o.BFAR.Reg)
}

// SystemControl.AFSR: Auxiliary Fault Status Register
func (o *SystemControl_Type) SetAFSR(value uint32) {
	volatile.StoreUint32(&o.AFSR.Reg, value)
}
func (o *SystemControl_Type) GetAFSR() uint32 {
	return volatile.LoadUint32(&o.AFSR.Reg)
}

// SystemControl.CPACR: Coprocessor Access Control Register
func (o *SystemControl_Type) SetCPACR_CP10(value uint32) {
	volatile.StoreUint32(&o.CPACR.Reg, volatile.LoadUint32(&o.CPACR.Reg)&^(0x300000)|value<<20)
}
func (o *SystemControl_Type) GetCPACR_CP10() uint32 {
	return (volatile.LoadUint32(&o.CPACR.Reg) & 0x300000) >> 20
}
func (o *SystemControl_Type) SetCPACR_CP11(value uint32) {
	volatile.StoreUint32(&o.CPACR.Reg, volatile.LoadUint32(&o.CPACR.Reg)&^(0xc00000)|value<<22)
}
func (o *SystemControl_Type) GetCPACR_CP11() uint32 {
	return (volatile.LoadUint32(&o.CPACR.Reg) & 0xc00000) >> 22
}

// Trace Port Interface Register
type TPI_Type struct {
	SSPSR     volatile.Register32 // 0x0
	CSPSR     volatile.Register32 // 0x4
	_         [8]byte
	ACPR      volatile.Register32 // 0x10
	_         [220]byte
	SPPR      volatile.Register32 // 0xF0
	_         [524]byte
	FFSR      volatile.Register32 // 0x300
	FFCR      volatile.Register32 // 0x304
	FSCR      volatile.Register32 // 0x308
	_         [3036]byte
	TRIGGER   volatile.Register32 // 0xEE8
	FIFO0     volatile.Register32 // 0xEEC
	ITATBCTR2 volatile.Register32 // 0xEF0
	_         [4]byte
	ITATBCTR0 volatile.Register32 // 0xEF8
	FIFO1     volatile.Register32 // 0xEFC
	ITCTRL    volatile.Register32 // 0xF00
	_         [156]byte
	CLAIMSET  volatile.Register32 // 0xFA0
	CLAIMCLR  volatile.Register32 // 0xFA4
	_         [32]byte
	DEVID     volatile.Register32 // 0xFC8
	DEVTYPE   volatile.Register32 // 0xFCC
}

// TPI.ACPR: Asynchronous Clock Prescaler Register
func (o *TPI_Type) SetACPR_PRESCALER(value uint32) {
	volatile.StoreUint32(&o.ACPR.Reg, volatile.LoadUint32(&o.ACPR.Reg)&^(0x1fff)|value)
}
func (o *TPI_Type) GetACPR_PRESCALER() uint32 {
	return volatile.LoadUint32(&o.ACPR.Reg) & 0x1fff
}

// TPI.SPPR: Selected Pin Protocol Register
func (o *TPI_Type) SetSPPR_TXMODE(value uint32) {
	volatile.StoreUint32(&o.SPPR.Reg, volatile.LoadUint32(&o.SPPR.Reg)&^(0x3)|value)
}
func (o *TPI_Type) GetSPPR_TXMODE() uint32 {
	return volatile.LoadUint32(&o.SPPR.Reg) & 0x3
}

// TPI.FFSR: Formatter and Flush Status Register
func (o *TPI_Type) SetFFSR_FlInProg(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x1)|value)
}
func (o *TPI_Type) GetFFSR_FlInProg() uint32 {
	return volatile.LoadUint32(&o.FFSR.Reg) & 0x1
}
func (o *TPI_Type) SetFFSR_FtStopped(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x2)|value<<1)
}
func (o *TPI_Type) GetFFSR_FtStopped() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x2) >> 1
}
func (o *TPI_Type) SetFFSR_TCPresent(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x4)|value<<2)
}
func (o *TPI_Type) GetFFSR_TCPresent() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x4) >> 2
}
func (o *TPI_Type) SetFFSR_FtNonStop(value uint32) {
	volatile.StoreUint32(&o.FFSR.Reg, volatile.LoadUint32(&o.FFSR.Reg)&^(0x8)|value<<3)
}
func (o *TPI_Type) GetFFSR_FtNonStop() uint32 {
	return (volatile.LoadUint32(&o.FFSR.Reg) & 0x8) >> 3
}

// TPI.FFCR: Formatter and Flush Control Register
func (o *TPI_Type) SetFFCR_EnFCont(value uint32) {
	volatile.StoreUint32(&o.FFCR.Reg, volatile.LoadUint32(&o.FFCR.Reg)&^(0x2)|value<<1)
}
func (o *TPI_Type) GetFFCR_EnFCont() uint32 {
	return (volatile.LoadUint32(&o.FFCR.Reg) & 0x2) >> 1
}
func (o *TPI_Type) SetFFCR_TrigIn(value uint32) {
	volatile.StoreUint32(&o.FFCR.Reg, volatile.LoadUint32(&o.FFCR.Reg)&^(0x100)|value<<8)
}
func (o *TPI_Type) GetFFCR_TrigIn() uint32 {
	return (volatile.LoadUint32(&o.FFCR.Reg) & 0x100) >> 8
}

// TPI.TRIGGER: TRIGGER
func (o *TPI_Type) SetTRIGGER(value uint32) {
	volatile.StoreUint32(&o.TRIGGER.Reg, volatile.LoadUint32(&o.TRIGGER.Reg)&^(0x1)|value)
}
func (o *TPI_Type) GetTRIGGER() uint32 {
	return volatile.LoadUint32(&o.TRIGGER.Reg) & 0x1
}

// TPI.FIFO0: Integration ETM Data
func (o *TPI_Type) SetFIFO0_ETM0(value uint32) {
	volatile.StoreUint32(&o.FIFO0.Reg, volatile.LoadUint32(&o.FIFO0.Reg)&^(0xff)|value)
}
func (o *TPI_Type) GetFIFO0_ETM0() uint32 {
	return volatile.LoadUint32(&o.FIFO0.Reg) & 0xff
}
func (o *TPI_Type) SetFIFO0_ETM1(value uint32) {
	volatile.StoreUint32(&o.FIFO0.Reg, volatile.LoadUint32(&o.FIFO0.Reg)&^(0xff00)|value<<8)
}
func (o *TPI_Type) GetFIFO0_ETM1() uint32 {
	return (volatile.LoadUint32(&o.FIFO0.Reg) & 0xff00) >> 8
}
func (o *TPI_Type) SetFIFO0_ETM2(value uint32) {
	volatile.StoreUint32(&o.FIFO0.Reg, volatile.LoadUint32(&o.FIFO0.Reg)&^(0xff0000)|value<<16)
}
func (o *TPI_Type) GetFIFO0_ETM2() uint32 {
	return (volatile.LoadUint32(&o.FIFO0.Reg) & 0xff0000) >> 16
}
func (o *TPI_Type) SetFIFO0_ETM_bytecount(value uint32) {
	volatile.StoreUint32(&o.FIFO0.Reg, volatile.LoadUint32(&o.FIFO0.Reg)&^(0x3000000)|value<<24)
}
func (o *TPI_Type) GetFIFO0_ETM_bytecount() uint32 {
	return (volatile.LoadUint32(&o.FIFO0.Reg) & 0x3000000) >> 24
}
func (o *TPI_Type) SetFIFO0_ETM_ATVALID(value uint32) {
	volatile.StoreUint32(&o.FIFO0.Reg, volatile.LoadUint32(&o.FIFO0.Reg)&^(0x4000000)|value<<26)
}
func (o *TPI_Type) GetFIFO0_ETM_ATVALID() uint32 {
	return (volatile.LoadUint32(&o.FIFO0.Reg) & 0x4000000) >> 26
}
func (o *TPI_Type) SetFIFO0_ITM_bytecount(value uint32) {
	volatile.StoreUint32(&o.FIFO0.Reg, volatile.LoadUint32(&o.FIFO0.Reg)&^(0x18000000)|value<<27)
}
func (o *TPI_Type) GetFIFO0_ITM_bytecount() uint32 {
	return (volatile.LoadUint32(&o.FIFO0.Reg) & 0x18000000) >> 27
}
func (o *TPI_Type) SetFIFO0_ITM_ATVALID(value uint32) {
	volatile.StoreUint32(&o.FIFO0.Reg, volatile.LoadUint32(&o.FIFO0.Reg)&^(0x20000000)|value<<29)
}
func (o *TPI_Type) GetFIFO0_ITM_ATVALID() uint32 {
	return (volatile.LoadUint32(&o.FIFO0.Reg) & 0x20000000) >> 29
}

// TPI.ITATBCTR2: ITATBCTR2
func (o *TPI_Type) SetITATBCTR2_ATREADY(value uint32) {
	volatile.StoreUint32(&o.ITATBCTR2.Reg, volatile.LoadUint32(&o.ITATBCTR2.Reg)&^(0x1)|value)
}
func (o *TPI_Type) GetITATBCTR2_ATREADY() uint32 {
	return volatile.LoadUint32(&o.ITATBCTR2.Reg) & 0x1
}

// TPI.ITATBCTR0: ITATBCTR0
func (o *TPI_Type) SetITATBCTR0_ATREADY(value uint32) {
	volatile.StoreUint32(&o.ITATBCTR0.Reg, volatile.LoadUint32(&o.ITATBCTR0.Reg)&^(0x1)|value)
}
func (o *TPI_Type) GetITATBCTR0_ATREADY() uint32 {
	return volatile.LoadUint32(&o.ITATBCTR0.Reg) & 0x1
}

// TPI.FIFO1: Integration ITM Data
func (o *TPI_Type) SetFIFO1_ITM0(value uint32) {
	volatile.StoreUint32(&o.FIFO1.Reg, volatile.LoadUint32(&o.FIFO1.Reg)&^(0xff)|value)
}
func (o *TPI_Type) GetFIFO1_ITM0() uint32 {
	return volatile.LoadUint32(&o.FIFO1.Reg) & 0xff
}
func (o *TPI_Type) SetFIFO1_ITM1(value uint32) {
	volatile.StoreUint32(&o.FIFO1.Reg, volatile.LoadUint32(&o.FIFO1.Reg)&^(0xff00)|value<<8)
}
func (o *TPI_Type) GetFIFO1_ITM1() uint32 {
	return (volatile.LoadUint32(&o.FIFO1.Reg) & 0xff00) >> 8
}
func (o *TPI_Type) SetFIFO1_ITM2(value uint32) {
	volatile.StoreUint32(&o.FIFO1.Reg, volatile.LoadUint32(&o.FIFO1.Reg)&^(0xff0000)|value<<16)
}
func (o *TPI_Type) GetFIFO1_ITM2() uint32 {
	return (volatile.LoadUint32(&o.FIFO1.Reg) & 0xff0000) >> 16
}
func (o *TPI_Type) SetFIFO1_ETM_bytecount(value uint32) {
	volatile.StoreUint32(&o.FIFO1.Reg, volatile.LoadUint32(&o.FIFO1.Reg)&^(0x3000000)|value<<24)
}
func (o *TPI_Type) GetFIFO1_ETM_bytecount() uint32 {
	return (volatile.LoadUint32(&o.FIFO1.Reg) & 0x3000000) >> 24
}
func (o *TPI_Type) SetFIFO1_ETM_ATVALID(value uint32) {
	volatile.StoreUint32(&o.FIFO1.Reg, volatile.LoadUint32(&o.FIFO1.Reg)&^(0x4000000)|value<<26)
}
func (o *TPI_Type) GetFIFO1_ETM_ATVALID() uint32 {
	return (volatile.LoadUint32(&o.FIFO1.Reg) & 0x4000000) >> 26
}
func (o *TPI_Type) SetFIFO1_ITM_bytecount(value uint32) {
	volatile.StoreUint32(&o.FIFO1.Reg, volatile.LoadUint32(&o.FIFO1.Reg)&^(0x18000000)|value<<27)
}
func (o *TPI_Type) GetFIFO1_ITM_bytecount() uint32 {
	return (volatile.LoadUint32(&o.FIFO1.Reg) & 0x18000000) >> 27
}
func (o *TPI_Type) SetFIFO1_ITM_ATVALID(value uint32) {
	volatile.StoreUint32(&o.FIFO1.Reg, volatile.LoadUint32(&o.FIFO1.Reg)&^(0x20000000)|value<<29)
}
func (o *TPI_Type) GetFIFO1_ITM_ATVALID() uint32 {
	return (volatile.LoadUint32(&o.FIFO1.Reg) & 0x20000000) >> 29
}

// TPI.ITCTRL: Integration Mode Control
func (o *TPI_Type) SetITCTRL_Mode(value uint32) {
	volatile.StoreUint32(&o.ITCTRL.Reg, volatile.LoadUint32(&o.ITCTRL.Reg)&^(0x1)|value)
}
func (o *TPI_Type) GetITCTRL_Mode() uint32 {
	return volatile.LoadUint32(&o.ITCTRL.Reg) & 0x1
}

// TPI.DEVID: TPIU_DEVID
func (o *TPI_Type) SetDEVID_NrTraceInput(value uint32) {
	volatile.StoreUint32(&o.DEVID.Reg, volatile.LoadUint32(&o.DEVID.Reg)&^(0x1)|value)
}
func (o *TPI_Type) GetDEVID_NrTraceInput() uint32 {
	return volatile.LoadUint32(&o.DEVID.Reg) & 0x1
}
func (o *TPI_Type) SetDEVID_AsynClkIn(value uint32) {
	volatile.StoreUint32(&o.DEVID.Reg, volatile.LoadUint32(&o.DEVID.Reg)&^(0x20)|value<<5)
}
func (o *TPI_Type) GetDEVID_AsynClkIn() uint32 {
	return (volatile.LoadUint32(&o.DEVID.Reg) & 0x20) >> 5
}
func (o *TPI_Type) SetDEVID_MinBufSz(value uint32) {
	volatile.StoreUint32(&o.DEVID.Reg, volatile.LoadUint32(&o.DEVID.Reg)&^(0x1c0)|value<<6)
}
func (o *TPI_Type) GetDEVID_MinBufSz() uint32 {
	return (volatile.LoadUint32(&o.DEVID.Reg) & 0x1c0) >> 6
}
func (o *TPI_Type) SetDEVID_PTINVALID(value uint32) {
	volatile.StoreUint32(&o.DEVID.Reg, volatile.LoadUint32(&o.DEVID.Reg)&^(0x200)|value<<9)
}
func (o *TPI_Type) GetDEVID_PTINVALID() uint32 {
	return (volatile.LoadUint32(&o.DEVID.Reg) & 0x200) >> 9
}
func (o *TPI_Type) SetDEVID_MANCVALID(value uint32) {
	volatile.StoreUint32(&o.DEVID.Reg, volatile.LoadUint32(&o.DEVID.Reg)&^(0x400)|value<<10)
}
func (o *TPI_Type) GetDEVID_MANCVALID() uint32 {
	return (volatile.LoadUint32(&o.DEVID.Reg) & 0x400) >> 10
}
func (o *TPI_Type) SetDEVID_NRZVALID(value uint32) {
	volatile.StoreUint32(&o.DEVID.Reg, volatile.LoadUint32(&o.DEVID.Reg)&^(0x800)|value<<11)
}
func (o *TPI_Type) GetDEVID_NRZVALID() uint32 {
	return (volatile.LoadUint32(&o.DEVID.Reg) & 0x800) >> 11
}

// TPI.DEVTYPE: TPIU_DEVTYPE
func (o *TPI_Type) SetDEVTYPE_SubType(value uint32) {
	volatile.StoreUint32(&o.DEVTYPE.Reg, volatile.LoadUint32(&o.DEVTYPE.Reg)&^(0xf)|value)
}
func (o *TPI_Type) GetDEVTYPE_SubType() uint32 {
	return volatile.LoadUint32(&o.DEVTYPE.Reg) & 0xf
}
func (o *TPI_Type) SetDEVTYPE_MajorType(value uint32) {
	volatile.StoreUint32(&o.DEVTYPE.Reg, volatile.LoadUint32(&o.DEVTYPE.Reg)&^(0xf0)|value<<4)
}
func (o *TPI_Type) GetDEVTYPE_MajorType() uint32 {
	return (volatile.LoadUint32(&o.DEVTYPE.Reg) & 0xf0) >> 4
}

// Constants for AC: Analog Comparators
const (
	// CTRLA: Control A
	// Position of SWRST field.
	AC_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	AC_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	AC_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	AC_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	AC_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	AC_CTRLA_ENABLE = 0x2

	// CTRLB: Control B
	// Position of START0 field.
	AC_CTRLB_START0_Pos = 0x0
	// Bit mask of START0 field.
	AC_CTRLB_START0_Msk = 0x1
	// Bit START0.
	AC_CTRLB_START0 = 0x1
	// Position of START1 field.
	AC_CTRLB_START1_Pos = 0x1
	// Bit mask of START1 field.
	AC_CTRLB_START1_Msk = 0x2
	// Bit START1.
	AC_CTRLB_START1 = 0x2

	// EVCTRL: Event Control
	// Position of COMPEO0 field.
	AC_EVCTRL_COMPEO0_Pos = 0x0
	// Bit mask of COMPEO0 field.
	AC_EVCTRL_COMPEO0_Msk = 0x1
	// Bit COMPEO0.
	AC_EVCTRL_COMPEO0 = 0x1
	// Position of COMPEO1 field.
	AC_EVCTRL_COMPEO1_Pos = 0x1
	// Bit mask of COMPEO1 field.
	AC_EVCTRL_COMPEO1_Msk = 0x2
	// Bit COMPEO1.
	AC_EVCTRL_COMPEO1 = 0x2
	// Position of WINEO0 field.
	AC_EVCTRL_WINEO0_Pos = 0x4
	// Bit mask of WINEO0 field.
	AC_EVCTRL_WINEO0_Msk = 0x10
	// Bit WINEO0.
	AC_EVCTRL_WINEO0 = 0x10
	// Position of COMPEI0 field.
	AC_EVCTRL_COMPEI0_Pos = 0x8
	// Bit mask of COMPEI0 field.
	AC_EVCTRL_COMPEI0_Msk = 0x100
	// Bit COMPEI0.
	AC_EVCTRL_COMPEI0 = 0x100
	// Position of COMPEI1 field.
	AC_EVCTRL_COMPEI1_Pos = 0x9
	// Bit mask of COMPEI1 field.
	AC_EVCTRL_COMPEI1_Msk = 0x200
	// Bit COMPEI1.
	AC_EVCTRL_COMPEI1 = 0x200
	// Position of INVEI0 field.
	AC_EVCTRL_INVEI0_Pos = 0xc
	// Bit mask of INVEI0 field.
	AC_EVCTRL_INVEI0_Msk = 0x1000
	// Bit INVEI0.
	AC_EVCTRL_INVEI0 = 0x1000
	// Position of INVEI1 field.
	AC_EVCTRL_INVEI1_Pos = 0xd
	// Bit mask of INVEI1 field.
	AC_EVCTRL_INVEI1_Msk = 0x2000
	// Bit INVEI1.
	AC_EVCTRL_INVEI1 = 0x2000

	// INTENCLR: Interrupt Enable Clear
	// Position of COMP0 field.
	AC_INTENCLR_COMP0_Pos = 0x0
	// Bit mask of COMP0 field.
	AC_INTENCLR_COMP0_Msk = 0x1
	// Bit COMP0.
	AC_INTENCLR_COMP0 = 0x1
	// Position of COMP1 field.
	AC_INTENCLR_COMP1_Pos = 0x1
	// Bit mask of COMP1 field.
	AC_INTENCLR_COMP1_Msk = 0x2
	// Bit COMP1.
	AC_INTENCLR_COMP1 = 0x2
	// Position of WIN0 field.
	AC_INTENCLR_WIN0_Pos = 0x4
	// Bit mask of WIN0 field.
	AC_INTENCLR_WIN0_Msk = 0x10
	// Bit WIN0.
	AC_INTENCLR_WIN0 = 0x10

	// INTENSET: Interrupt Enable Set
	// Position of COMP0 field.
	AC_INTENSET_COMP0_Pos = 0x0
	// Bit mask of COMP0 field.
	AC_INTENSET_COMP0_Msk = 0x1
	// Bit COMP0.
	AC_INTENSET_COMP0 = 0x1
	// Position of COMP1 field.
	AC_INTENSET_COMP1_Pos = 0x1
	// Bit mask of COMP1 field.
	AC_INTENSET_COMP1_Msk = 0x2
	// Bit COMP1.
	AC_INTENSET_COMP1 = 0x2
	// Position of WIN0 field.
	AC_INTENSET_WIN0_Pos = 0x4
	// Bit mask of WIN0 field.
	AC_INTENSET_WIN0_Msk = 0x10
	// Bit WIN0.
	AC_INTENSET_WIN0 = 0x10

	// INTFLAG: Interrupt Flag Status and Clear
	// Position of COMP0 field.
	AC_INTFLAG_COMP0_Pos = 0x0
	// Bit mask of COMP0 field.
	AC_INTFLAG_COMP0_Msk = 0x1
	// Bit COMP0.
	AC_INTFLAG_COMP0 = 0x1
	// Position of COMP1 field.
	AC_INTFLAG_COMP1_Pos = 0x1
	// Bit mask of COMP1 field.
	AC_INTFLAG_COMP1_Msk = 0x2
	// Bit COMP1.
	AC_INTFLAG_COMP1 = 0x2
	// Position of WIN0 field.
	AC_INTFLAG_WIN0_Pos = 0x4
	// Bit mask of WIN0 field.
	AC_INTFLAG_WIN0_Msk = 0x10
	// Bit WIN0.
	AC_INTFLAG_WIN0 = 0x10

	// STATUSA: Status A
	// Position of STATE0 field.
	AC_STATUSA_STATE0_Pos = 0x0
	// Bit mask of STATE0 field.
	AC_STATUSA_STATE0_Msk = 0x1
	// Bit STATE0.
	AC_STATUSA_STATE0 = 0x1
	// Position of STATE1 field.
	AC_STATUSA_STATE1_Pos = 0x1
	// Bit mask of STATE1 field.
	AC_STATUSA_STATE1_Msk = 0x2
	// Bit STATE1.
	AC_STATUSA_STATE1 = 0x2
	// Position of WSTATE0 field.
	AC_STATUSA_WSTATE0_Pos = 0x4
	// Bit mask of WSTATE0 field.
	AC_STATUSA_WSTATE0_Msk = 0x30
	// Signal is above window
	AC_STATUSA_WSTATE0_ABOVE = 0x0
	// Signal is inside window
	AC_STATUSA_WSTATE0_INSIDE = 0x1
	// Signal is below window
	AC_STATUSA_WSTATE0_BELOW = 0x2

	// STATUSB: Status B
	// Position of READY0 field.
	AC_STATUSB_READY0_Pos = 0x0
	// Bit mask of READY0 field.
	AC_STATUSB_READY0_Msk = 0x1
	// Bit READY0.
	AC_STATUSB_READY0 = 0x1
	// Position of READY1 field.
	AC_STATUSB_READY1_Pos = 0x1
	// Bit mask of READY1 field.
	AC_STATUSB_READY1_Msk = 0x2
	// Bit READY1.
	AC_STATUSB_READY1 = 0x2

	// DBGCTRL: Debug Control
	// Position of DBGRUN field.
	AC_DBGCTRL_DBGRUN_Pos = 0x0
	// Bit mask of DBGRUN field.
	AC_DBGCTRL_DBGRUN_Msk = 0x1
	// Bit DBGRUN.
	AC_DBGCTRL_DBGRUN = 0x1

	// WINCTRL: Window Control
	// Position of WEN0 field.
	AC_WINCTRL_WEN0_Pos = 0x0
	// Bit mask of WEN0 field.
	AC_WINCTRL_WEN0_Msk = 0x1
	// Bit WEN0.
	AC_WINCTRL_WEN0 = 0x1
	// Position of WINTSEL0 field.
	AC_WINCTRL_WINTSEL0_Pos = 0x1
	// Bit mask of WINTSEL0 field.
	AC_WINCTRL_WINTSEL0_Msk = 0x6
	// Interrupt on signal above window
	AC_WINCTRL_WINTSEL0_ABOVE = 0x0
	// Interrupt on signal inside window
	AC_WINCTRL_WINTSEL0_INSIDE = 0x1
	// Interrupt on signal below window
	AC_WINCTRL_WINTSEL0_BELOW = 0x2
	// Interrupt on signal outside window
	AC_WINCTRL_WINTSEL0_OUTSIDE = 0x3

	// SCALER: Scaler n
	// Position of VALUE field.
	AC_SCALER_VALUE_Pos = 0x0
	// Bit mask of VALUE field.
	AC_SCALER_VALUE_Msk = 0x3f

	// COMPCTRL: Comparator Control n
	// Position of ENABLE field.
	AC_COMPCTRL_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	AC_COMPCTRL_ENABLE_Msk = 0x2
	// Bit ENABLE.
	AC_COMPCTRL_ENABLE = 0x2
	// Position of SINGLE field.
	AC_COMPCTRL_SINGLE_Pos = 0x2
	// Bit mask of SINGLE field.
	AC_COMPCTRL_SINGLE_Msk = 0x4
	// Bit SINGLE.
	AC_COMPCTRL_SINGLE = 0x4
	// Position of INTSEL field.
	AC_COMPCTRL_INTSEL_Pos = 0x3
	// Bit mask of INTSEL field.
	AC_COMPCTRL_INTSEL_Msk = 0x18
	// Interrupt on comparator output toggle
	AC_COMPCTRL_INTSEL_TOGGLE = 0x0
	// Interrupt on comparator output rising
	AC_COMPCTRL_INTSEL_RISING = 0x1
	// Interrupt on comparator output falling
	AC_COMPCTRL_INTSEL_FALLING = 0x2
	// Interrupt on end of comparison (single-shot mode only)
	AC_COMPCTRL_INTSEL_EOC = 0x3
	// Position of RUNSTDBY field.
	AC_COMPCTRL_RUNSTDBY_Pos = 0x6
	// Bit mask of RUNSTDBY field.
	AC_COMPCTRL_RUNSTDBY_Msk = 0x40
	// Bit RUNSTDBY.
	AC_COMPCTRL_RUNSTDBY = 0x40
	// Position of MUXNEG field.
	AC_COMPCTRL_MUXNEG_Pos = 0x8
	// Bit mask of MUXNEG field.
	AC_COMPCTRL_MUXNEG_Msk = 0x700
	// I/O pin 0
	AC_COMPCTRL_MUXNEG_PIN0 = 0x0
	// I/O pin 1
	AC_COMPCTRL_MUXNEG_PIN1 = 0x1
	// I/O pin 2
	AC_COMPCTRL_MUXNEG_PIN2 = 0x2
	// I/O pin 3
	AC_COMPCTRL_MUXNEG_PIN3 = 0x3
	// Ground
	AC_COMPCTRL_MUXNEG_GND = 0x4
	// VDD scaler
	AC_COMPCTRL_MUXNEG_VSCALE = 0x5
	// Internal bandgap voltage
	AC_COMPCTRL_MUXNEG_BANDGAP = 0x6
	// DAC output
	AC_COMPCTRL_MUXNEG_DAC = 0x7
	// Position of MUXPOS field.
	AC_COMPCTRL_MUXPOS_Pos = 0xc
	// Bit mask of MUXPOS field.
	AC_COMPCTRL_MUXPOS_Msk = 0x7000
	// I/O pin 0
	AC_COMPCTRL_MUXPOS_PIN0 = 0x0
	// I/O pin 1
	AC_COMPCTRL_MUXPOS_PIN1 = 0x1
	// I/O pin 2
	AC_COMPCTRL_MUXPOS_PIN2 = 0x2
	// I/O pin 3
	AC_COMPCTRL_MUXPOS_PIN3 = 0x3
	// VDD Scaler
	AC_COMPCTRL_MUXPOS_VSCALE = 0x4
	// Position of SWAP field.
	AC_COMPCTRL_SWAP_Pos = 0xf
	// Bit mask of SWAP field.
	AC_COMPCTRL_SWAP_Msk = 0x8000
	// Bit SWAP.
	AC_COMPCTRL_SWAP = 0x8000
	// Position of SPEED field.
	AC_COMPCTRL_SPEED_Pos = 0x10
	// Bit mask of SPEED field.
	AC_COMPCTRL_SPEED_Msk = 0x30000
	// High speed
	AC_COMPCTRL_SPEED_HIGH = 0x3
	// Position of HYSTEN field.
	AC_COMPCTRL_HYSTEN_Pos = 0x13
	// Bit mask of HYSTEN field.
	AC_COMPCTRL_HYSTEN_Msk = 0x80000
	// Bit HYSTEN.
	AC_COMPCTRL_HYSTEN = 0x80000
	// Position of HYST field.
	AC_COMPCTRL_HYST_Pos = 0x14
	// Bit mask of HYST field.
	AC_COMPCTRL_HYST_Msk = 0x300000
	// 50mV
	AC_COMPCTRL_HYST_HYST50 = 0x0
	// 100mV
	AC_COMPCTRL_HYST_HYST100 = 0x1
	// 150mV
	AC_COMPCTRL_HYST_HYST150 = 0x2
	// Position of FLEN field.
	AC_COMPCTRL_FLEN_Pos = 0x18
	// Bit mask of FLEN field.
	AC_COMPCTRL_FLEN_Msk = 0x7000000
	// No filtering
	AC_COMPCTRL_FLEN_OFF = 0x0
	// 3-bit majority function (2 of 3)
	AC_COMPCTRL_FLEN_MAJ3 = 0x1
	// 5-bit majority function (3 of 5)
	AC_COMPCTRL_FLEN_MAJ5 = 0x2
	// Position of OUT field.
	AC_COMPCTRL_OUT_Pos = 0x1c
	// Bit mask of OUT field.
	AC_COMPCTRL_OUT_Msk = 0x30000000
	// The output of COMPn is not routed to the COMPn I/O port
	AC_COMPCTRL_OUT_OFF = 0x0
	// The asynchronous output of COMPn is routed to the COMPn I/O port
	AC_COMPCTRL_OUT_ASYNC = 0x1
	// The synchronous output (including filtering) of COMPn is routed to the COMPn I/O port
	AC_COMPCTRL_OUT_SYNC = 0x2

	// SYNCBUSY: Synchronization Busy
	// Position of SWRST field.
	AC_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	AC_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	AC_SYNCBUSY_SWRST = 0x1
	// Position of ENABLE field.
	AC_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	AC_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	AC_SYNCBUSY_ENABLE = 0x2
	// Position of WINCTRL field.
	AC_SYNCBUSY_WINCTRL_Pos = 0x2
	// Bit mask of WINCTRL field.
	AC_SYNCBUSY_WINCTRL_Msk = 0x4
	// Bit WINCTRL.
	AC_SYNCBUSY_WINCTRL = 0x4
	// Position of COMPCTRL0 field.
	AC_SYNCBUSY_COMPCTRL0_Pos = 0x3
	// Bit mask of COMPCTRL0 field.
	AC_SYNCBUSY_COMPCTRL0_Msk = 0x8
	// Bit COMPCTRL0.
	AC_SYNCBUSY_COMPCTRL0 = 0x8
	// Position of COMPCTRL1 field.
	AC_SYNCBUSY_COMPCTRL1_Pos = 0x4
	// Bit mask of COMPCTRL1 field.
	AC_SYNCBUSY_COMPCTRL1_Msk = 0x10
	// Bit COMPCTRL1.
	AC_SYNCBUSY_COMPCTRL1 = 0x10

	// CALIB: Calibration
	// Position of BIAS0 field.
	AC_CALIB_BIAS0_Pos = 0x0
	// Bit mask of BIAS0 field.
	AC_CALIB_BIAS0_Msk = 0x3
)

// Constants for ADC0: Analog Digital Converter
const (
	// CTRLA: Control A
	// Position of SWRST field.
	ADC_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	ADC_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	ADC_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	ADC_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	ADC_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	ADC_CTRLA_ENABLE = 0x2
	// Position of DUALSEL field.
	ADC_CTRLA_DUALSEL_Pos = 0x3
	// Bit mask of DUALSEL field.
	ADC_CTRLA_DUALSEL_Msk = 0x18
	// Start event or software trigger will start a conversion on both ADCs
	ADC_CTRLA_DUALSEL_BOTH = 0x0
	// START event or software trigger will alternatingly start a conversion on ADC0 and ADC1
	ADC_CTRLA_DUALSEL_INTERLEAVE = 0x1
	// Position of SLAVEEN field.
	ADC_CTRLA_SLAVEEN_Pos = 0x5
	// Bit mask of SLAVEEN field.
	ADC_CTRLA_SLAVEEN_Msk = 0x20
	// Bit SLAVEEN.
	ADC_CTRLA_SLAVEEN = 0x20
	// Position of RUNSTDBY field.
	ADC_CTRLA_RUNSTDBY_Pos = 0x6
	// Bit mask of RUNSTDBY field.
	ADC_CTRLA_RUNSTDBY_Msk = 0x40
	// Bit RUNSTDBY.
	ADC_CTRLA_RUNSTDBY = 0x40
	// Position of ONDEMAND field.
	ADC_CTRLA_ONDEMAND_Pos = 0x7
	// Bit mask of ONDEMAND field.
	ADC_CTRLA_ONDEMAND_Msk = 0x80
	// Bit ONDEMAND.
	ADC_CTRLA_ONDEMAND = 0x80
	// Position of PRESCALER field.
	ADC_CTRLA_PRESCALER_Pos = 0x8
	// Bit mask of PRESCALER field.
	ADC_CTRLA_PRESCALER_Msk = 0x700
	// Peripheral clock divided by 2
	ADC_CTRLA_PRESCALER_DIV2 = 0x0
	// Peripheral clock divided by 4
	ADC_CTRLA_PRESCALER_DIV4 = 0x1
	// Peripheral clock divided by 8
	ADC_CTRLA_PRESCALER_DIV8 = 0x2
	// Peripheral clock divided by 16
	ADC_CTRLA_PRESCALER_DIV16 = 0x3
	// Peripheral clock divided by 32
	ADC_CTRLA_PRESCALER_DIV32 = 0x4
	// Peripheral clock divided by 64
	ADC_CTRLA_PRESCALER_DIV64 = 0x5
	// Peripheral clock divided by 128
	ADC_CTRLA_PRESCALER_DIV128 = 0x6
	// Peripheral clock divided by 256
	ADC_CTRLA_PRESCALER_DIV256 = 0x7
	// Position of R2R field.
	ADC_CTRLA_R2R_Pos = 0xf
	// Bit mask of R2R field.
	ADC_CTRLA_R2R_Msk = 0x8000
	// Bit R2R.
	ADC_CTRLA_R2R = 0x8000

	// EVCTRL: Event Control
	// Position of FLUSHEI field.
	ADC_EVCTRL_FLUSHEI_Pos = 0x0
	// Bit mask of FLUSHEI field.
	ADC_EVCTRL_FLUSHEI_Msk = 0x1
	// Bit FLUSHEI.
	ADC_EVCTRL_FLUSHEI = 0x1
	// Position of STARTEI field.
	ADC_EVCTRL_STARTEI_Pos = 0x1
	// Bit mask of STARTEI field.
	ADC_EVCTRL_STARTEI_Msk = 0x2
	// Bit STARTEI.
	ADC_EVCTRL_STARTEI = 0x2
	// Position of FLUSHINV field.
	ADC_EVCTRL_FLUSHINV_Pos = 0x2
	// Bit mask of FLUSHINV field.
	ADC_EVCTRL_FLUSHINV_Msk = 0x4
	// Bit FLUSHINV.
	ADC_EVCTRL_FLUSHINV = 0x4
	// Position of STARTINV field.
	ADC_EVCTRL_STARTINV_Pos = 0x3
	// Bit mask of STARTINV field.
	ADC_EVCTRL_STARTINV_Msk = 0x8
	// Bit STARTINV.
	ADC_EVCTRL_STARTINV = 0x8
	// Position of RESRDYEO field.
	ADC_EVCTRL_RESRDYEO_Pos = 0x4
	// Bit mask of RESRDYEO field.
	ADC_EVCTRL_RESRDYEO_Msk = 0x10
	// Bit RESRDYEO.
	ADC_EVCTRL_RESRDYEO = 0x10
	// Position of WINMONEO field.
	ADC_EVCTRL_WINMONEO_Pos = 0x5
	// Bit mask of WINMONEO field.
	ADC_EVCTRL_WINMONEO_Msk = 0x20
	// Bit WINMONEO.
	ADC_EVCTRL_WINMONEO = 0x20

	// DBGCTRL: Debug Control
	// Position of DBGRUN field.
	ADC_DBGCTRL_DBGRUN_Pos = 0x0
	// Bit mask of DBGRUN field.
	ADC_DBGCTRL_DBGRUN_Msk = 0x1
	// Bit DBGRUN.
	ADC_DBGCTRL_DBGRUN = 0x1

	// INPUTCTRL: Input Control
	// Position of MUXPOS field.
	ADC_INPUTCTRL_MUXPOS_Pos = 0x0
	// Bit mask of MUXPOS field.
	ADC_INPUTCTRL_MUXPOS_Msk = 0x1f
	// ADC AIN0 Pin
	ADC_INPUTCTRL_MUXPOS_AIN0 = 0x0
	// ADC AIN1 Pin
	ADC_INPUTCTRL_MUXPOS_AIN1 = 0x1
	// ADC AIN2 Pin
	ADC_INPUTCTRL_MUXPOS_AIN2 = 0x2
	// ADC AIN3 Pin
	ADC_INPUTCTRL_MUXPOS_AIN3 = 0x3
	// ADC AIN4 Pin
	ADC_INPUTCTRL_MUXPOS_AIN4 = 0x4
	// ADC AIN5 Pin
	ADC_INPUTCTRL_MUXPOS_AIN5 = 0x5
	// ADC AIN6 Pin
	ADC_INPUTCTRL_MUXPOS_AIN6 = 0x6
	// ADC AIN7 Pin
	ADC_INPUTCTRL_MUXPOS_AIN7 = 0x7
	// ADC AIN8 Pin
	ADC_INPUTCTRL_MUXPOS_AIN8 = 0x8
	// ADC AIN9 Pin
	ADC_INPUTCTRL_MUXPOS_AIN9 = 0x9
	// ADC AIN10 Pin
	ADC_INPUTCTRL_MUXPOS_AIN10 = 0xa
	// ADC AIN11 Pin
	ADC_INPUTCTRL_MUXPOS_AIN11 = 0xb
	// ADC AIN12 Pin
	ADC_INPUTCTRL_MUXPOS_AIN12 = 0xc
	// ADC AIN13 Pin
	ADC_INPUTCTRL_MUXPOS_AIN13 = 0xd
	// ADC AIN14 Pin
	ADC_INPUTCTRL_MUXPOS_AIN14 = 0xe
	// ADC AIN15 Pin
	ADC_INPUTCTRL_MUXPOS_AIN15 = 0xf
	// ADC AIN16 Pin
	ADC_INPUTCTRL_MUXPOS_AIN16 = 0x10
	// ADC AIN17 Pin
	ADC_INPUTCTRL_MUXPOS_AIN17 = 0x11
	// ADC AIN18 Pin
	ADC_INPUTCTRL_MUXPOS_AIN18 = 0x12
	// ADC AIN19 Pin
	ADC_INPUTCTRL_MUXPOS_AIN19 = 0x13
	// ADC AIN20 Pin
	ADC_INPUTCTRL_MUXPOS_AIN20 = 0x14
	// ADC AIN21 Pin
	ADC_INPUTCTRL_MUXPOS_AIN21 = 0x15
	// ADC AIN22 Pin
	ADC_INPUTCTRL_MUXPOS_AIN22 = 0x16
	// ADC AIN23 Pin
	ADC_INPUTCTRL_MUXPOS_AIN23 = 0x17
	// 1/4 Scaled Core Supply
	ADC_INPUTCTRL_MUXPOS_SCALEDCOREVCC = 0x18
	// 1/4 Scaled VBAT Supply
	ADC_INPUTCTRL_MUXPOS_SCALEDVBAT = 0x19
	// 1/4 Scaled I/O Supply
	ADC_INPUTCTRL_MUXPOS_SCALEDIOVCC = 0x1a
	// Bandgap Voltage
	ADC_INPUTCTRL_MUXPOS_BANDGAP = 0x1b
	// Temperature Sensor
	ADC_INPUTCTRL_MUXPOS_PTAT = 0x1c
	// Temperature Sensor
	ADC_INPUTCTRL_MUXPOS_CTAT = 0x1d
	// DAC Output
	ADC_INPUTCTRL_MUXPOS_DAC = 0x1e
	// PTC output (only on ADC0)
	ADC_INPUTCTRL_MUXPOS_PTC = 0x1f
	// Position of DIFFMODE field.
	ADC_INPUTCTRL_DIFFMODE_Pos = 0x7
	// Bit mask of DIFFMODE field.
	ADC_INPUTCTRL_DIFFMODE_Msk = 0x80
	// Bit DIFFMODE.
	ADC_INPUTCTRL_DIFFMODE = 0x80
	// Position of MUXNEG field.
	ADC_INPUTCTRL_MUXNEG_Pos = 0x8
	// Bit mask of MUXNEG field.
	ADC_INPUTCTRL_MUXNEG_Msk = 0x1f00
	// ADC AIN0 Pin
	ADC_INPUTCTRL_MUXNEG_AIN0 = 0x0
	// ADC AIN1 Pin
	ADC_INPUTCTRL_MUXNEG_AIN1 = 0x1
	// ADC AIN2 Pin
	ADC_INPUTCTRL_MUXNEG_AIN2 = 0x2
	// ADC AIN3 Pin
	ADC_INPUTCTRL_MUXNEG_AIN3 = 0x3
	// ADC AIN4 Pin
	ADC_INPUTCTRL_MUXNEG_AIN4 = 0x4
	// ADC AIN5 Pin
	ADC_INPUTCTRL_MUXNEG_AIN5 = 0x5
	// ADC AIN6 Pin
	ADC_INPUTCTRL_MUXNEG_AIN6 = 0x6
	// ADC AIN7 Pin
	ADC_INPUTCTRL_MUXNEG_AIN7 = 0x7
	// Internal Ground
	ADC_INPUTCTRL_MUXNEG_GND = 0x18
	// Position of DSEQSTOP field.
	ADC_INPUTCTRL_DSEQSTOP_Pos = 0xf
	// Bit mask of DSEQSTOP field.
	ADC_INPUTCTRL_DSEQSTOP_Msk = 0x8000
	// Bit DSEQSTOP.
	ADC_INPUTCTRL_DSEQSTOP = 0x8000

	// CTRLB: Control B
	// Position of LEFTADJ field.
	ADC_CTRLB_LEFTADJ_Pos = 0x0
	// Bit mask of LEFTADJ field.
	ADC_CTRLB_LEFTADJ_Msk = 0x1
	// Bit LEFTADJ.
	ADC_CTRLB_LEFTADJ = 0x1
	// Position of FREERUN field.
	ADC_CTRLB_FREERUN_Pos = 0x1
	// Bit mask of FREERUN field.
	ADC_CTRLB_FREERUN_Msk = 0x2
	// Bit FREERUN.
	ADC_CTRLB_FREERUN = 0x2
	// Position of CORREN field.
	ADC_CTRLB_CORREN_Pos = 0x2
	// Bit mask of CORREN field.
	ADC_CTRLB_CORREN_Msk = 0x4
	// Bit CORREN.
	ADC_CTRLB_CORREN = 0x4
	// Position of RESSEL field.
	ADC_CTRLB_RESSEL_Pos = 0x3
	// Bit mask of RESSEL field.
	ADC_CTRLB_RESSEL_Msk = 0x18
	// 12-bit result
	ADC_CTRLB_RESSEL_12BIT = 0x0
	// For averaging mode output
	ADC_CTRLB_RESSEL_16BIT = 0x1
	// 10-bit result
	ADC_CTRLB_RESSEL_10BIT = 0x2
	// 8-bit result
	ADC_CTRLB_RESSEL_8BIT = 0x3
	// Position of WINMODE field.
	ADC_CTRLB_WINMODE_Pos = 0x8
	// Bit mask of WINMODE field.
	ADC_CTRLB_WINMODE_Msk = 0x700
	// No window mode (default)
	ADC_CTRLB_WINMODE_DISABLE = 0x0
	// RESULT > WINLT
	ADC_CTRLB_WINMODE_MODE1 = 0x1
	// RESULT < WINUT
	ADC_CTRLB_WINMODE_MODE2 = 0x2
	// WINLT < RESULT < WINUT
	ADC_CTRLB_WINMODE_MODE3 = 0x3
	// !(WINLT < RESULT < WINUT)
	ADC_CTRLB_WINMODE_MODE4 = 0x4
	// Position of WINSS field.
	ADC_CTRLB_WINSS_Pos = 0xb
	// Bit mask of WINSS field.
	ADC_CTRLB_WINSS_Msk = 0x800
	// Bit WINSS.
	ADC_CTRLB_WINSS = 0x800

	// REFCTRL: Reference Control
	// Position of REFSEL field.
	ADC_REFCTRL_REFSEL_Pos = 0x0
	// Bit mask of REFSEL field.
	ADC_REFCTRL_REFSEL_Msk = 0xf
	// Internal Bandgap Reference
	ADC_REFCTRL_REFSEL_INTREF = 0x0
	// 1/2 VDDANA
	ADC_REFCTRL_REFSEL_INTVCC0 = 0x2
	// VDDANA
	ADC_REFCTRL_REFSEL_INTVCC1 = 0x3
	// External Reference
	ADC_REFCTRL_REFSEL_AREFA = 0x4
	// External Reference
	ADC_REFCTRL_REFSEL_AREFB = 0x5
	// External Reference (only on ADC1)
	ADC_REFCTRL_REFSEL_AREFC = 0x6
	// Position of REFCOMP field.
	ADC_REFCTRL_REFCOMP_Pos = 0x7
	// Bit mask of REFCOMP field.
	ADC_REFCTRL_REFCOMP_Msk = 0x80
	// Bit REFCOMP.
	ADC_REFCTRL_REFCOMP = 0x80

	// AVGCTRL: Average Control
	// Position of SAMPLENUM field.
	ADC_AVGCTRL_SAMPLENUM_Pos = 0x0
	// Bit mask of SAMPLENUM field.
	ADC_AVGCTRL_SAMPLENUM_Msk = 0xf
	// 1 sample
	ADC_AVGCTRL_SAMPLENUM_1 = 0x0
	// 2 samples
	ADC_AVGCTRL_SAMPLENUM_2 = 0x1
	// 4 samples
	ADC_AVGCTRL_SAMPLENUM_4 = 0x2
	// 8 samples
	ADC_AVGCTRL_SAMPLENUM_8 = 0x3
	// 16 samples
	ADC_AVGCTRL_SAMPLENUM_16 = 0x4
	// 32 samples
	ADC_AVGCTRL_SAMPLENUM_32 = 0x5
	// 64 samples
	ADC_AVGCTRL_SAMPLENUM_64 = 0x6
	// 128 samples
	ADC_AVGCTRL_SAMPLENUM_128 = 0x7
	// 256 samples
	ADC_AVGCTRL_SAMPLENUM_256 = 0x8
	// 512 samples
	ADC_AVGCTRL_SAMPLENUM_512 = 0x9
	// 1024 samples
	ADC_AVGCTRL_SAMPLENUM_1024 = 0xa
	// Position of ADJRES field.
	ADC_AVGCTRL_ADJRES_Pos = 0x4
	// Bit mask of ADJRES field.
	ADC_AVGCTRL_ADJRES_Msk = 0x70

	// SAMPCTRL: Sample Time Control
	// Position of SAMPLEN field.
	ADC_SAMPCTRL_SAMPLEN_Pos = 0x0
	// Bit mask of SAMPLEN field.
	ADC_SAMPCTRL_SAMPLEN_Msk = 0x3f
	// Position of OFFCOMP field.
	ADC_SAMPCTRL_OFFCOMP_Pos = 0x7
	// Bit mask of OFFCOMP field.
	ADC_SAMPCTRL_OFFCOMP_Msk = 0x80
	// Bit OFFCOMP.
	ADC_SAMPCTRL_OFFCOMP = 0x80

	// WINLT: Window Monitor Lower Threshold
	// Position of WINLT field.
	ADC_WINLT_WINLT_Pos = 0x0
	// Bit mask of WINLT field.
	ADC_WINLT_WINLT_Msk = 0xffff

	// WINUT: Window Monitor Upper Threshold
	// Position of WINUT field.
	ADC_WINUT_WINUT_Pos = 0x0
	// Bit mask of WINUT field.
	ADC_WINUT_WINUT_Msk = 0xffff

	// GAINCORR: Gain Correction
	// Position of GAINCORR field.
	ADC_GAINCORR_GAINCORR_Pos = 0x0
	// Bit mask of GAINCORR field.
	ADC_GAINCORR_GAINCORR_Msk = 0xfff

	// OFFSETCORR: Offset Correction
	// Position of OFFSETCORR field.
	ADC_OFFSETCORR_OFFSETCORR_Pos = 0x0
	// Bit mask of OFFSETCORR field.
	ADC_OFFSETCORR_OFFSETCORR_Msk = 0xfff

	// SWTRIG: Software Trigger
	// Position of FLUSH field.
	ADC_SWTRIG_FLUSH_Pos = 0x0
	// Bit mask of FLUSH field.
	ADC_SWTRIG_FLUSH_Msk = 0x1
	// Bit FLUSH.
	ADC_SWTRIG_FLUSH = 0x1
	// Position of START field.
	ADC_SWTRIG_START_Pos = 0x1
	// Bit mask of START field.
	ADC_SWTRIG_START_Msk = 0x2
	// Bit START.
	ADC_SWTRIG_START = 0x2

	// INTENCLR: Interrupt Enable Clear
	// Position of RESRDY field.
	ADC_INTENCLR_RESRDY_Pos = 0x0
	// Bit mask of RESRDY field.
	ADC_INTENCLR_RESRDY_Msk = 0x1
	// Bit RESRDY.
	ADC_INTENCLR_RESRDY = 0x1
	// Position of OVERRUN field.
	ADC_INTENCLR_OVERRUN_Pos = 0x1
	// Bit mask of OVERRUN field.
	ADC_INTENCLR_OVERRUN_Msk = 0x2
	// Bit OVERRUN.
	ADC_INTENCLR_OVERRUN = 0x2
	// Position of WINMON field.
	ADC_INTENCLR_WINMON_Pos = 0x2
	// Bit mask of WINMON field.
	ADC_INTENCLR_WINMON_Msk = 0x4
	// Bit WINMON.
	ADC_INTENCLR_WINMON = 0x4

	// INTENSET: Interrupt Enable Set
	// Position of RESRDY field.
	ADC_INTENSET_RESRDY_Pos = 0x0
	// Bit mask of RESRDY field.
	ADC_INTENSET_RESRDY_Msk = 0x1
	// Bit RESRDY.
	ADC_INTENSET_RESRDY = 0x1
	// Position of OVERRUN field.
	ADC_INTENSET_OVERRUN_Pos = 0x1
	// Bit mask of OVERRUN field.
	ADC_INTENSET_OVERRUN_Msk = 0x2
	// Bit OVERRUN.
	ADC_INTENSET_OVERRUN = 0x2
	// Position of WINMON field.
	ADC_INTENSET_WINMON_Pos = 0x2
	// Bit mask of WINMON field.
	ADC_INTENSET_WINMON_Msk = 0x4
	// Bit WINMON.
	ADC_INTENSET_WINMON = 0x4

	// INTFLAG: Interrupt Flag Status and Clear
	// Position of RESRDY field.
	ADC_INTFLAG_RESRDY_Pos = 0x0
	// Bit mask of RESRDY field.
	ADC_INTFLAG_RESRDY_Msk = 0x1
	// Bit RESRDY.
	ADC_INTFLAG_RESRDY = 0x1
	// Position of OVERRUN field.
	ADC_INTFLAG_OVERRUN_Pos = 0x1
	// Bit mask of OVERRUN field.
	ADC_INTFLAG_OVERRUN_Msk = 0x2
	// Bit OVERRUN.
	ADC_INTFLAG_OVERRUN = 0x2
	// Position of WINMON field.
	ADC_INTFLAG_WINMON_Pos = 0x2
	// Bit mask of WINMON field.
	ADC_INTFLAG_WINMON_Msk = 0x4
	// Bit WINMON.
	ADC_INTFLAG_WINMON = 0x4

	// STATUS: Status
	// Position of ADCBUSY field.
	ADC_STATUS_ADCBUSY_Pos = 0x0
	// Bit mask of ADCBUSY field.
	ADC_STATUS_ADCBUSY_Msk = 0x1
	// Bit ADCBUSY.
	ADC_STATUS_ADCBUSY = 0x1
	// Position of WCC field.
	ADC_STATUS_WCC_Pos = 0x2
	// Bit mask of WCC field.
	ADC_STATUS_WCC_Msk = 0xfc

	// SYNCBUSY: Synchronization Busy
	// Position of SWRST field.
	ADC_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	ADC_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	ADC_SYNCBUSY_SWRST = 0x1
	// Position of ENABLE field.
	ADC_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	ADC_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	ADC_SYNCBUSY_ENABLE = 0x2
	// Position of INPUTCTRL field.
	ADC_SYNCBUSY_INPUTCTRL_Pos = 0x2
	// Bit mask of INPUTCTRL field.
	ADC_SYNCBUSY_INPUTCTRL_Msk = 0x4
	// Bit INPUTCTRL.
	ADC_SYNCBUSY_INPUTCTRL = 0x4
	// Position of CTRLB field.
	ADC_SYNCBUSY_CTRLB_Pos = 0x3
	// Bit mask of CTRLB field.
	ADC_SYNCBUSY_CTRLB_Msk = 0x8
	// Bit CTRLB.
	ADC_SYNCBUSY_CTRLB = 0x8
	// Position of REFCTRL field.
	ADC_SYNCBUSY_REFCTRL_Pos = 0x4
	// Bit mask of REFCTRL field.
	ADC_SYNCBUSY_REFCTRL_Msk = 0x10
	// Bit REFCTRL.
	ADC_SYNCBUSY_REFCTRL = 0x10
	// Position of AVGCTRL field.
	ADC_SYNCBUSY_AVGCTRL_Pos = 0x5
	// Bit mask of AVGCTRL field.
	ADC_SYNCBUSY_AVGCTRL_Msk = 0x20
	// Bit AVGCTRL.
	ADC_SYNCBUSY_AVGCTRL = 0x20
	// Position of SAMPCTRL field.
	ADC_SYNCBUSY_SAMPCTRL_Pos = 0x6
	// Bit mask of SAMPCTRL field.
	ADC_SYNCBUSY_SAMPCTRL_Msk = 0x40
	// Bit SAMPCTRL.
	ADC_SYNCBUSY_SAMPCTRL = 0x40
	// Position of WINLT field.
	ADC_SYNCBUSY_WINLT_Pos = 0x7
	// Bit mask of WINLT field.
	ADC_SYNCBUSY_WINLT_Msk = 0x80
	// Bit WINLT.
	ADC_SYNCBUSY_WINLT = 0x80
	// Position of WINUT field.
	ADC_SYNCBUSY_WINUT_Pos = 0x8
	// Bit mask of WINUT field.
	ADC_SYNCBUSY_WINUT_Msk = 0x100
	// Bit WINUT.
	ADC_SYNCBUSY_WINUT = 0x100
	// Position of GAINCORR field.
	ADC_SYNCBUSY_GAINCORR_Pos = 0x9
	// Bit mask of GAINCORR field.
	ADC_SYNCBUSY_GAINCORR_Msk = 0x200
	// Bit GAINCORR.
	ADC_SYNCBUSY_GAINCORR = 0x200
	// Position of OFFSETCORR field.
	ADC_SYNCBUSY_OFFSETCORR_Pos = 0xa
	// Bit mask of OFFSETCORR field.
	ADC_SYNCBUSY_OFFSETCORR_Msk = 0x400
	// Bit OFFSETCORR.
	ADC_SYNCBUSY_OFFSETCORR = 0x400
	// Position of SWTRIG field.
	ADC_SYNCBUSY_SWTRIG_Pos = 0xb
	// Bit mask of SWTRIG field.
	ADC_SYNCBUSY_SWTRIG_Msk = 0x800
	// Bit SWTRIG.
	ADC_SYNCBUSY_SWTRIG = 0x800

	// DSEQDATA: DMA Sequencial Data
	// Position of DATA field.
	ADC_DSEQDATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	ADC_DSEQDATA_DATA_Msk = 0xffffffff

	// DSEQCTRL: DMA Sequential Control
	// Position of INPUTCTRL field.
	ADC_DSEQCTRL_INPUTCTRL_Pos = 0x0
	// Bit mask of INPUTCTRL field.
	ADC_DSEQCTRL_INPUTCTRL_Msk = 0x1
	// Bit INPUTCTRL.
	ADC_DSEQCTRL_INPUTCTRL = 0x1
	// Position of CTRLB field.
	ADC_DSEQCTRL_CTRLB_Pos = 0x1
	// Bit mask of CTRLB field.
	ADC_DSEQCTRL_CTRLB_Msk = 0x2
	// Bit CTRLB.
	ADC_DSEQCTRL_CTRLB = 0x2
	// Position of REFCTRL field.
	ADC_DSEQCTRL_REFCTRL_Pos = 0x2
	// Bit mask of REFCTRL field.
	ADC_DSEQCTRL_REFCTRL_Msk = 0x4
	// Bit REFCTRL.
	ADC_DSEQCTRL_REFCTRL = 0x4
	// Position of AVGCTRL field.
	ADC_DSEQCTRL_AVGCTRL_Pos = 0x3
	// Bit mask of AVGCTRL field.
	ADC_DSEQCTRL_AVGCTRL_Msk = 0x8
	// Bit AVGCTRL.
	ADC_DSEQCTRL_AVGCTRL = 0x8
	// Position of SAMPCTRL field.
	ADC_DSEQCTRL_SAMPCTRL_Pos = 0x4
	// Bit mask of SAMPCTRL field.
	ADC_DSEQCTRL_SAMPCTRL_Msk = 0x10
	// Bit SAMPCTRL.
	ADC_DSEQCTRL_SAMPCTRL = 0x10
	// Position of WINLT field.
	ADC_DSEQCTRL_WINLT_Pos = 0x5
	// Bit mask of WINLT field.
	ADC_DSEQCTRL_WINLT_Msk = 0x20
	// Bit WINLT.
	ADC_DSEQCTRL_WINLT = 0x20
	// Position of WINUT field.
	ADC_DSEQCTRL_WINUT_Pos = 0x6
	// Bit mask of WINUT field.
	ADC_DSEQCTRL_WINUT_Msk = 0x40
	// Bit WINUT.
	ADC_DSEQCTRL_WINUT = 0x40
	// Position of GAINCORR field.
	ADC_DSEQCTRL_GAINCORR_Pos = 0x7
	// Bit mask of GAINCORR field.
	ADC_DSEQCTRL_GAINCORR_Msk = 0x80
	// Bit GAINCORR.
	ADC_DSEQCTRL_GAINCORR = 0x80
	// Position of OFFSETCORR field.
	ADC_DSEQCTRL_OFFSETCORR_Pos = 0x8
	// Bit mask of OFFSETCORR field.
	ADC_DSEQCTRL_OFFSETCORR_Msk = 0x100
	// Bit OFFSETCORR.
	ADC_DSEQCTRL_OFFSETCORR = 0x100
	// Position of AUTOSTART field.
	ADC_DSEQCTRL_AUTOSTART_Pos = 0x1f
	// Bit mask of AUTOSTART field.
	ADC_DSEQCTRL_AUTOSTART_Msk = 0x80000000
	// Bit AUTOSTART.
	ADC_DSEQCTRL_AUTOSTART = 0x80000000

	// DSEQSTAT: DMA Sequencial Status
	// Position of INPUTCTRL field.
	ADC_DSEQSTAT_INPUTCTRL_Pos = 0x0
	// Bit mask of INPUTCTRL field.
	ADC_DSEQSTAT_INPUTCTRL_Msk = 0x1
	// Bit INPUTCTRL.
	ADC_DSEQSTAT_INPUTCTRL = 0x1
	// Position of CTRLB field.
	ADC_DSEQSTAT_CTRLB_Pos = 0x1
	// Bit mask of CTRLB field.
	ADC_DSEQSTAT_CTRLB_Msk = 0x2
	// Bit CTRLB.
	ADC_DSEQSTAT_CTRLB = 0x2
	// Position of REFCTRL field.
	ADC_DSEQSTAT_REFCTRL_Pos = 0x2
	// Bit mask of REFCTRL field.
	ADC_DSEQSTAT_REFCTRL_Msk = 0x4
	// Bit REFCTRL.
	ADC_DSEQSTAT_REFCTRL = 0x4
	// Position of AVGCTRL field.
	ADC_DSEQSTAT_AVGCTRL_Pos = 0x3
	// Bit mask of AVGCTRL field.
	ADC_DSEQSTAT_AVGCTRL_Msk = 0x8
	// Bit AVGCTRL.
	ADC_DSEQSTAT_AVGCTRL = 0x8
	// Position of SAMPCTRL field.
	ADC_DSEQSTAT_SAMPCTRL_Pos = 0x4
	// Bit mask of SAMPCTRL field.
	ADC_DSEQSTAT_SAMPCTRL_Msk = 0x10
	// Bit SAMPCTRL.
	ADC_DSEQSTAT_SAMPCTRL = 0x10
	// Position of WINLT field.
	ADC_DSEQSTAT_WINLT_Pos = 0x5
	// Bit mask of WINLT field.
	ADC_DSEQSTAT_WINLT_Msk = 0x20
	// Bit WINLT.
	ADC_DSEQSTAT_WINLT = 0x20
	// Position of WINUT field.
	ADC_DSEQSTAT_WINUT_Pos = 0x6
	// Bit mask of WINUT field.
	ADC_DSEQSTAT_WINUT_Msk = 0x40
	// Bit WINUT.
	ADC_DSEQSTAT_WINUT = 0x40
	// Position of GAINCORR field.
	ADC_DSEQSTAT_GAINCORR_Pos = 0x7
	// Bit mask of GAINCORR field.
	ADC_DSEQSTAT_GAINCORR_Msk = 0x80
	// Bit GAINCORR.
	ADC_DSEQSTAT_GAINCORR = 0x80
	// Position of OFFSETCORR field.
	ADC_DSEQSTAT_OFFSETCORR_Pos = 0x8
	// Bit mask of OFFSETCORR field.
	ADC_DSEQSTAT_OFFSETCORR_Msk = 0x100
	// Bit OFFSETCORR.
	ADC_DSEQSTAT_OFFSETCORR = 0x100
	// Position of BUSY field.
	ADC_DSEQSTAT_BUSY_Pos = 0x1f
	// Bit mask of BUSY field.
	ADC_DSEQSTAT_BUSY_Msk = 0x80000000
	// Bit BUSY.
	ADC_DSEQSTAT_BUSY = 0x80000000

	// RESULT: Result Conversion Value
	// Position of RESULT field.
	ADC_RESULT_RESULT_Pos = 0x0
	// Bit mask of RESULT field.
	ADC_RESULT_RESULT_Msk = 0xffff

	// RESS: Last Sample Result
	// Position of RESS field.
	ADC_RESS_RESS_Pos = 0x0
	// Bit mask of RESS field.
	ADC_RESS_RESS_Msk = 0xffff

	// CALIB: Calibration
	// Position of BIASCOMP field.
	ADC_CALIB_BIASCOMP_Pos = 0x0
	// Bit mask of BIASCOMP field.
	ADC_CALIB_BIASCOMP_Msk = 0x7
	// Position of BIASR2R field.
	ADC_CALIB_BIASR2R_Pos = 0x4
	// Bit mask of BIASR2R field.
	ADC_CALIB_BIASR2R_Msk = 0x70
	// Position of BIASREFBUF field.
	ADC_CALIB_BIASREFBUF_Pos = 0x8
	// Bit mask of BIASREFBUF field.
	ADC_CALIB_BIASREFBUF_Msk = 0x700
)

// Constants for AES: Advanced Encryption Standard
const (
	// CTRLA: Control A
	// Position of SWRST field.
	AES_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	AES_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	AES_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	AES_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	AES_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	AES_CTRLA_ENABLE = 0x2
	// Position of AESMODE field.
	AES_CTRLA_AESMODE_Pos = 0x2
	// Bit mask of AESMODE field.
	AES_CTRLA_AESMODE_Msk = 0x1c
	// Electronic code book mode
	AES_CTRLA_AESMODE_ECB = 0x0
	// Cipher block chaining mode
	AES_CTRLA_AESMODE_CBC = 0x1
	// Output feedback mode
	AES_CTRLA_AESMODE_OFB = 0x2
	// Cipher feedback mode
	AES_CTRLA_AESMODE_CFB = 0x3
	// Counter mode
	AES_CTRLA_AESMODE_COUNTER = 0x4
	// CCM mode
	AES_CTRLA_AESMODE_CCM = 0x5
	// Galois counter mode
	AES_CTRLA_AESMODE_GCM = 0x6
	// Position of CFBS field.
	AES_CTRLA_CFBS_Pos = 0x5
	// Bit mask of CFBS field.
	AES_CTRLA_CFBS_Msk = 0xe0
	// 128-bit Input data block for Encryption/Decryption in Cipher Feedback mode
	AES_CTRLA_CFBS_128BIT = 0x0
	// 64-bit Input data block for Encryption/Decryption in Cipher Feedback mode
	AES_CTRLA_CFBS_64BIT = 0x1
	// 32-bit Input data block for Encryption/Decryption in Cipher Feedback mode
	AES_CTRLA_CFBS_32BIT = 0x2
	// 16-bit Input data block for Encryption/Decryption in Cipher Feedback mode
	AES_CTRLA_CFBS_16BIT = 0x3
	// 8-bit Input data block for Encryption/Decryption in Cipher Feedback mode
	AES_CTRLA_CFBS_8BIT = 0x4
	// Position of KEYSIZE field.
	AES_CTRLA_KEYSIZE_Pos = 0x8
	// Bit mask of KEYSIZE field.
	AES_CTRLA_KEYSIZE_Msk = 0x300
	// 128-bit Key for Encryption / Decryption
	AES_CTRLA_KEYSIZE_128BIT = 0x0
	// 192-bit Key for Encryption / Decryption
	AES_CTRLA_KEYSIZE_192BIT = 0x1
	// 256-bit Key for Encryption / Decryption
	AES_CTRLA_KEYSIZE_256BIT = 0x2
	// Position of CIPHER field.
	AES_CTRLA_CIPHER_Pos = 0xa
	// Bit mask of CIPHER field.
	AES_CTRLA_CIPHER_Msk = 0x400
	// Bit CIPHER.
	AES_CTRLA_CIPHER = 0x400
	// Decryption
	AES_CTRLA_CIPHER_DEC = 0x0
	// Encryption
	AES_CTRLA_CIPHER_ENC = 0x1
	// Position of STARTMODE field.
	AES_CTRLA_STARTMODE_Pos = 0xb
	// Bit mask of STARTMODE field.
	AES_CTRLA_STARTMODE_Msk = 0x800
	// Bit STARTMODE.
	AES_CTRLA_STARTMODE = 0x800
	// Start Encryption / Decryption in Manual mode
	AES_CTRLA_STARTMODE_MANUAL = 0x0
	// Start Encryption / Decryption in Auto mode
	AES_CTRLA_STARTMODE_AUTO = 0x1
	// Position of LOD field.
	AES_CTRLA_LOD_Pos = 0xc
	// Bit mask of LOD field.
	AES_CTRLA_LOD_Msk = 0x1000
	// Bit LOD.
	AES_CTRLA_LOD = 0x1000
	// No effect
	AES_CTRLA_LOD_NONE = 0x0
	// Start encryption in Last Output Data mode
	AES_CTRLA_LOD_LAST = 0x1
	// Position of KEYGEN field.
	AES_CTRLA_KEYGEN_Pos = 0xd
	// Bit mask of KEYGEN field.
	AES_CTRLA_KEYGEN_Msk = 0x2000
	// Bit KEYGEN.
	AES_CTRLA_KEYGEN = 0x2000
	// No effect
	AES_CTRLA_KEYGEN_NONE = 0x0
	// Start Computation of the last NK words of the expanded key
	AES_CTRLA_KEYGEN_LAST = 0x1
	// Position of XORKEY field.
	AES_CTRLA_XORKEY_Pos = 0xe
	// Bit mask of XORKEY field.
	AES_CTRLA_XORKEY_Msk = 0x4000
	// Bit XORKEY.
	AES_CTRLA_XORKEY = 0x4000
	// No effect
	AES_CTRLA_XORKEY_NONE = 0x0
	// The user keyword gets XORed with the previous keyword register content.
	AES_CTRLA_XORKEY_XOR = 0x1
	// Position of CTYPE field.
	AES_CTRLA_CTYPE_Pos = 0x10
	// Bit mask of CTYPE field.
	AES_CTRLA_CTYPE_Msk = 0xf0000

	// CTRLB: Control B
	// Position of START field.
	AES_CTRLB_START_Pos = 0x0
	// Bit mask of START field.
	AES_CTRLB_START_Msk = 0x1
	// Bit START.
	AES_CTRLB_START = 0x1
	// Position of NEWMSG field.
	AES_CTRLB_NEWMSG_Pos = 0x1
	// Bit mask of NEWMSG field.
	AES_CTRLB_NEWMSG_Msk = 0x2
	// Bit NEWMSG.
	AES_CTRLB_NEWMSG = 0x2
	// Position of EOM field.
	AES_CTRLB_EOM_Pos = 0x2
	// Bit mask of EOM field.
	AES_CTRLB_EOM_Msk = 0x4
	// Bit EOM.
	AES_CTRLB_EOM = 0x4
	// Position of GFMUL field.
	AES_CTRLB_GFMUL_Pos = 0x3
	// Bit mask of GFMUL field.
	AES_CTRLB_GFMUL_Msk = 0x8
	// Bit GFMUL.
	AES_CTRLB_GFMUL = 0x8

	// INTENCLR: Interrupt Enable Clear
	// Position of ENCCMP field.
	AES_INTENCLR_ENCCMP_Pos = 0x0
	// Bit mask of ENCCMP field.
	AES_INTENCLR_ENCCMP_Msk = 0x1
	// Bit ENCCMP.
	AES_INTENCLR_ENCCMP = 0x1
	// Position of GFMCMP field.
	AES_INTENCLR_GFMCMP_Pos = 0x1
	// Bit mask of GFMCMP field.
	AES_INTENCLR_GFMCMP_Msk = 0x2
	// Bit GFMCMP.
	AES_INTENCLR_GFMCMP = 0x2

	// INTENSET: Interrupt Enable Set
	// Position of ENCCMP field.
	AES_INTENSET_ENCCMP_Pos = 0x0
	// Bit mask of ENCCMP field.
	AES_INTENSET_ENCCMP_Msk = 0x1
	// Bit ENCCMP.
	AES_INTENSET_ENCCMP = 0x1
	// Position of GFMCMP field.
	AES_INTENSET_GFMCMP_Pos = 0x1
	// Bit mask of GFMCMP field.
	AES_INTENSET_GFMCMP_Msk = 0x2
	// Bit GFMCMP.
	AES_INTENSET_GFMCMP = 0x2

	// INTFLAG: Interrupt Flag Status
	// Position of ENCCMP field.
	AES_INTFLAG_ENCCMP_Pos = 0x0
	// Bit mask of ENCCMP field.
	AES_INTFLAG_ENCCMP_Msk = 0x1
	// Bit ENCCMP.
	AES_INTFLAG_ENCCMP = 0x1
	// Position of GFMCMP field.
	AES_INTFLAG_GFMCMP_Pos = 0x1
	// Bit mask of GFMCMP field.
	AES_INTFLAG_GFMCMP_Msk = 0x2
	// Bit GFMCMP.
	AES_INTFLAG_GFMCMP = 0x2

	// DATABUFPTR: Data buffer pointer
	// Position of INDATAPTR field.
	AES_DATABUFPTR_INDATAPTR_Pos = 0x0
	// Bit mask of INDATAPTR field.
	AES_DATABUFPTR_INDATAPTR_Msk = 0x3

	// DBGCTRL: Debug control
	// Position of DBGRUN field.
	AES_DBGCTRL_DBGRUN_Pos = 0x0
	// Bit mask of DBGRUN field.
	AES_DBGCTRL_DBGRUN_Msk = 0x1
	// Bit DBGRUN.
	AES_DBGCTRL_DBGRUN = 0x1
)

// Constants for CCL: Configurable Custom Logic
const (
	// CTRL: Control
	// Position of SWRST field.
	CCL_CTRL_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	CCL_CTRL_SWRST_Msk = 0x1
	// Bit SWRST.
	CCL_CTRL_SWRST = 0x1
	// Position of ENABLE field.
	CCL_CTRL_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	CCL_CTRL_ENABLE_Msk = 0x2
	// Bit ENABLE.
	CCL_CTRL_ENABLE = 0x2
	// Position of RUNSTDBY field.
	CCL_CTRL_RUNSTDBY_Pos = 0x6
	// Bit mask of RUNSTDBY field.
	CCL_CTRL_RUNSTDBY_Msk = 0x40
	// Bit RUNSTDBY.
	CCL_CTRL_RUNSTDBY = 0x40

	// SEQCTRL: SEQ Control x
	// Position of SEQSEL field.
	CCL_SEQCTRL_SEQSEL_Pos = 0x0
	// Bit mask of SEQSEL field.
	CCL_SEQCTRL_SEQSEL_Msk = 0xf
	// Sequential logic is disabled
	CCL_SEQCTRL_SEQSEL_DISABLE = 0x0
	// D flip flop
	CCL_SEQCTRL_SEQSEL_DFF = 0x1
	// JK flip flop
	CCL_SEQCTRL_SEQSEL_JK = 0x2
	// D latch
	CCL_SEQCTRL_SEQSEL_LATCH = 0x3
	// RS latch
	CCL_SEQCTRL_SEQSEL_RS = 0x4

	// LUTCTRL: LUT Control x
	// Position of ENABLE field.
	CCL_LUTCTRL_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	CCL_LUTCTRL_ENABLE_Msk = 0x2
	// Bit ENABLE.
	CCL_LUTCTRL_ENABLE = 0x2
	// Position of FILTSEL field.
	CCL_LUTCTRL_FILTSEL_Pos = 0x4
	// Bit mask of FILTSEL field.
	CCL_LUTCTRL_FILTSEL_Msk = 0x30
	// Filter disabled
	CCL_LUTCTRL_FILTSEL_DISABLE = 0x0
	// Synchronizer enabled
	CCL_LUTCTRL_FILTSEL_SYNCH = 0x1
	// Filter enabled
	CCL_LUTCTRL_FILTSEL_FILTER = 0x2
	// Position of EDGESEL field.
	CCL_LUTCTRL_EDGESEL_Pos = 0x7
	// Bit mask of EDGESEL field.
	CCL_LUTCTRL_EDGESEL_Msk = 0x80
	// Bit EDGESEL.
	CCL_LUTCTRL_EDGESEL = 0x80
	// Position of INSEL0 field.
	CCL_LUTCTRL_INSEL0_Pos = 0x8
	// Bit mask of INSEL0 field.
	CCL_LUTCTRL_INSEL0_Msk = 0xf00
	// Masked input
	CCL_LUTCTRL_INSEL0_MASK = 0x0
	// Feedback input source
	CCL_LUTCTRL_INSEL0_FEEDBACK = 0x1
	// Linked LUT input source
	CCL_LUTCTRL_INSEL0_LINK = 0x2
	// Event input source
	CCL_LUTCTRL_INSEL0_EVENT = 0x3
	// I/O pin input source
	CCL_LUTCTRL_INSEL0_IO = 0x4
	// AC input source
	CCL_LUTCTRL_INSEL0_AC = 0x5
	// TC input source
	CCL_LUTCTRL_INSEL0_TC = 0x6
	// Alternate TC input source
	CCL_LUTCTRL_INSEL0_ALTTC = 0x7
	// TCC input source
	CCL_LUTCTRL_INSEL0_TCC = 0x8
	// SERCOM input source
	CCL_LUTCTRL_INSEL0_SERCOM = 0x9
	// Position of INSEL1 field.
	CCL_LUTCTRL_INSEL1_Pos = 0xc
	// Bit mask of INSEL1 field.
	CCL_LUTCTRL_INSEL1_Msk = 0xf000
	// Masked input
	CCL_LUTCTRL_INSEL1_MASK = 0x0
	// Feedback input source
	CCL_LUTCTRL_INSEL1_FEEDBACK = 0x1
	// Linked LUT input source
	CCL_LUTCTRL_INSEL1_LINK = 0x2
	// Event input source
	CCL_LUTCTRL_INSEL1_EVENT = 0x3
	// I/O pin input source
	CCL_LUTCTRL_INSEL1_IO = 0x4
	// AC input source
	CCL_LUTCTRL_INSEL1_AC = 0x5
	// TC input source
	CCL_LUTCTRL_INSEL1_TC = 0x6
	// Alternate TC input source
	CCL_LUTCTRL_INSEL1_ALTTC = 0x7
	// TCC input source
	CCL_LUTCTRL_INSEL1_TCC = 0x8
	// SERCOM input source
	CCL_LUTCTRL_INSEL1_SERCOM = 0x9
	// Position of INSEL2 field.
	CCL_LUTCTRL_INSEL2_Pos = 0x10
	// Bit mask of INSEL2 field.
	CCL_LUTCTRL_INSEL2_Msk = 0xf0000
	// Masked input
	CCL_LUTCTRL_INSEL2_MASK = 0x0
	// Feedback input source
	CCL_LUTCTRL_INSEL2_FEEDBACK = 0x1
	// Linked LUT input source
	CCL_LUTCTRL_INSEL2_LINK = 0x2
	// Event input source
	CCL_LUTCTRL_INSEL2_EVENT = 0x3
	// I/O pin input source
	CCL_LUTCTRL_INSEL2_IO = 0x4
	// AC input source
	CCL_LUTCTRL_INSEL2_AC = 0x5
	// TC input source
	CCL_LUTCTRL_INSEL2_TC = 0x6
	// Alternate TC input source
	CCL_LUTCTRL_INSEL2_ALTTC = 0x7
	// TCC input source
	CCL_LUTCTRL_INSEL2_TCC = 0x8
	// SERCOM input source
	CCL_LUTCTRL_INSEL2_SERCOM = 0x9
	// Position of INVEI field.
	CCL_LUTCTRL_INVEI_Pos = 0x14
	// Bit mask of INVEI field.
	CCL_LUTCTRL_INVEI_Msk = 0x100000
	// Bit INVEI.
	CCL_LUTCTRL_INVEI = 0x100000
	// Position of LUTEI field.
	CCL_LUTCTRL_LUTEI_Pos = 0x15
	// Bit mask of LUTEI field.
	CCL_LUTCTRL_LUTEI_Msk = 0x200000
	// Bit LUTEI.
	CCL_LUTCTRL_LUTEI = 0x200000
	// Position of LUTEO field.
	CCL_LUTCTRL_LUTEO_Pos = 0x16
	// Bit mask of LUTEO field.
	CCL_LUTCTRL_LUTEO_Msk = 0x400000
	// Bit LUTEO.
	CCL_LUTCTRL_LUTEO = 0x400000
	// Position of TRUTH field.
	CCL_LUTCTRL_TRUTH_Pos = 0x18
	// Bit mask of TRUTH field.
	CCL_LUTCTRL_TRUTH_Msk = 0xff000000
)

// Constants for CMCC: Cortex M Cache Controller
const (
	// TYPE: Cache Type Register
	// Position of GCLK field.
	CMCC_TYPE_GCLK_Pos = 0x1
	// Bit mask of GCLK field.
	CMCC_TYPE_GCLK_Msk = 0x2
	// Bit GCLK.
	CMCC_TYPE_GCLK = 0x2
	// Position of RRP field.
	CMCC_TYPE_RRP_Pos = 0x4
	// Bit mask of RRP field.
	CMCC_TYPE_RRP_Msk = 0x10
	// Bit RRP.
	CMCC_TYPE_RRP = 0x10
	// Position of WAYNUM field.
	CMCC_TYPE_WAYNUM_Pos = 0x5
	// Bit mask of WAYNUM field.
	CMCC_TYPE_WAYNUM_Msk = 0x60
	// Direct Mapped Cache
	CMCC_TYPE_WAYNUM_DMAPPED = 0x0
	// 2-WAY set associative
	CMCC_TYPE_WAYNUM_ARCH2WAY = 0x1
	// 4-WAY set associative
	CMCC_TYPE_WAYNUM_ARCH4WAY = 0x2
	// Position of LCKDOWN field.
	CMCC_TYPE_LCKDOWN_Pos = 0x7
	// Bit mask of LCKDOWN field.
	CMCC_TYPE_LCKDOWN_Msk = 0x80
	// Bit LCKDOWN.
	CMCC_TYPE_LCKDOWN = 0x80
	// Position of CSIZE field.
	CMCC_TYPE_CSIZE_Pos = 0x8
	// Bit mask of CSIZE field.
	CMCC_TYPE_CSIZE_Msk = 0x700
	// Cache Size is 1 KB
	CMCC_TYPE_CSIZE_CSIZE_1KB = 0x0
	// Cache Size is 2 KB
	CMCC_TYPE_CSIZE_CSIZE_2KB = 0x1
	// Cache Size is 4 KB
	CMCC_TYPE_CSIZE_CSIZE_4KB = 0x2
	// Cache Size is 8 KB
	CMCC_TYPE_CSIZE_CSIZE_8KB = 0x3
	// Cache Size is 16 KB
	CMCC_TYPE_CSIZE_CSIZE_16KB = 0x4
	// Cache Size is 32 KB
	CMCC_TYPE_CSIZE_CSIZE_32KB = 0x5
	// Cache Size is 64 KB
	CMCC_TYPE_CSIZE_CSIZE_64KB = 0x6
	// Position of CLSIZE field.
	CMCC_TYPE_CLSIZE_Pos = 0xb
	// Bit mask of CLSIZE field.
	CMCC_TYPE_CLSIZE_Msk = 0x3800
	// Cache Line Size is 4 bytes
	CMCC_TYPE_CLSIZE_CLSIZE_4B = 0x0
	// Cache Line Size is 8 bytes
	CMCC_TYPE_CLSIZE_CLSIZE_8B = 0x1
	// Cache Line Size is 16 bytes
	CMCC_TYPE_CLSIZE_CLSIZE_16B = 0x2
	// Cache Line Size is 32 bytes
	CMCC_TYPE_CLSIZE_CLSIZE_32B = 0x3
	// Cache Line Size is 64 bytes
	CMCC_TYPE_CLSIZE_CLSIZE_64B = 0x4
	// Cache Line Size is 128 bytes
	CMCC_TYPE_CLSIZE_CLSIZE_128B = 0x5

	// CFG: Cache Configuration Register
	// Position of ICDIS field.
	CMCC_CFG_ICDIS_Pos = 0x1
	// Bit mask of ICDIS field.
	CMCC_CFG_ICDIS_Msk = 0x2
	// Bit ICDIS.
	CMCC_CFG_ICDIS = 0x2
	// Position of DCDIS field.
	CMCC_CFG_DCDIS_Pos = 0x2
	// Bit mask of DCDIS field.
	CMCC_CFG_DCDIS_Msk = 0x4
	// Bit DCDIS.
	CMCC_CFG_DCDIS = 0x4
	// Position of CSIZESW field.
	CMCC_CFG_CSIZESW_Pos = 0x4
	// Bit mask of CSIZESW field.
	CMCC_CFG_CSIZESW_Msk = 0x70
	// The Cache Size is configured to 1KB
	CMCC_CFG_CSIZESW_CONF_CSIZE_1KB = 0x0
	// The Cache Size is configured to 2KB
	CMCC_CFG_CSIZESW_CONF_CSIZE_2KB = 0x1
	// The Cache Size is configured to 4KB
	CMCC_CFG_CSIZESW_CONF_CSIZE_4KB = 0x2
	// The Cache Size is configured to 8KB
	CMCC_CFG_CSIZESW_CONF_CSIZE_8KB = 0x3
	// The Cache Size is configured to 16KB
	CMCC_CFG_CSIZESW_CONF_CSIZE_16KB = 0x4
	// The Cache Size is configured to 32KB
	CMCC_CFG_CSIZESW_CONF_CSIZE_32KB = 0x5
	// The Cache Size is configured to 64KB
	CMCC_CFG_CSIZESW_CONF_CSIZE_64KB = 0x6

	// CTRL: Cache Control Register
	// Position of CEN field.
	CMCC_CTRL_CEN_Pos = 0x0
	// Bit mask of CEN field.
	CMCC_CTRL_CEN_Msk = 0x1
	// Bit CEN.
	CMCC_CTRL_CEN = 0x1

	// SR: Cache Status Register
	// Position of CSTS field.
	CMCC_SR_CSTS_Pos = 0x0
	// Bit mask of CSTS field.
	CMCC_SR_CSTS_Msk = 0x1
	// Bit CSTS.
	CMCC_SR_CSTS = 0x1

	// LCKWAY: Cache Lock per Way Register
	// Position of LCKWAY field.
	CMCC_LCKWAY_LCKWAY_Pos = 0x0
	// Bit mask of LCKWAY field.
	CMCC_LCKWAY_LCKWAY_Msk = 0xf

	// MAINT0: Cache Maintenance Register 0
	// Position of INVALL field.
	CMCC_MAINT0_INVALL_Pos = 0x0
	// Bit mask of INVALL field.
	CMCC_MAINT0_INVALL_Msk = 0x1
	// Bit INVALL.
	CMCC_MAINT0_INVALL = 0x1

	// MAINT1: Cache Maintenance Register 1
	// Position of INDEX field.
	CMCC_MAINT1_INDEX_Pos = 0x4
	// Bit mask of INDEX field.
	CMCC_MAINT1_INDEX_Msk = 0xff0
	// Position of WAY field.
	CMCC_MAINT1_WAY_Pos = 0x1c
	// Bit mask of WAY field.
	CMCC_MAINT1_WAY_Msk = 0xf0000000
	// Way 0 is selection for index invalidation
	CMCC_MAINT1_WAY_WAY0 = 0x0
	// Way 1 is selection for index invalidation
	CMCC_MAINT1_WAY_WAY1 = 0x1
	// Way 2 is selection for index invalidation
	CMCC_MAINT1_WAY_WAY2 = 0x2
	// Way 3 is selection for index invalidation
	CMCC_MAINT1_WAY_WAY3 = 0x3

	// MCFG: Cache Monitor Configuration Register
	// Position of MODE field.
	CMCC_MCFG_MODE_Pos = 0x0
	// Bit mask of MODE field.
	CMCC_MCFG_MODE_Msk = 0x3
	// Cycle counter
	CMCC_MCFG_MODE_CYCLE_COUNT = 0x0
	// Instruction hit counter
	CMCC_MCFG_MODE_IHIT_COUNT = 0x1
	// Data hit counter
	CMCC_MCFG_MODE_DHIT_COUNT = 0x2

	// MEN: Cache Monitor Enable Register
	// Position of MENABLE field.
	CMCC_MEN_MENABLE_Pos = 0x0
	// Bit mask of MENABLE field.
	CMCC_MEN_MENABLE_Msk = 0x1
	// Bit MENABLE.
	CMCC_MEN_MENABLE = 0x1

	// MCTRL: Cache Monitor Control Register
	// Position of SWRST field.
	CMCC_MCTRL_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	CMCC_MCTRL_SWRST_Msk = 0x1
	// Bit SWRST.
	CMCC_MCTRL_SWRST = 0x1

	// MSR: Cache Monitor Status Register
	// Position of EVENT_CNT field.
	CMCC_MSR_EVENT_CNT_Pos = 0x0
	// Bit mask of EVENT_CNT field.
	CMCC_MSR_EVENT_CNT_Msk = 0xffffffff
)

// Constants for DAC: Digital-to-Analog Converter
const (
	// CTRLA: Control A
	// Position of SWRST field.
	DAC_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	DAC_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	DAC_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	DAC_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	DAC_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	DAC_CTRLA_ENABLE = 0x2

	// CTRLB: Control B
	// Position of DIFF field.
	DAC_CTRLB_DIFF_Pos = 0x0
	// Bit mask of DIFF field.
	DAC_CTRLB_DIFF_Msk = 0x1
	// Bit DIFF.
	DAC_CTRLB_DIFF = 0x1
	// Position of REFSEL field.
	DAC_CTRLB_REFSEL_Pos = 0x1
	// Bit mask of REFSEL field.
	DAC_CTRLB_REFSEL_Msk = 0x6
	// External reference unbuffered
	DAC_CTRLB_REFSEL_VREFPU = 0x0
	// Analog supply
	DAC_CTRLB_REFSEL_VDDANA = 0x1
	// External reference buffered
	DAC_CTRLB_REFSEL_VREFPB = 0x2
	// Internal bandgap reference
	DAC_CTRLB_REFSEL_INTREF = 0x3

	// EVCTRL: Event Control
	// Position of STARTEI0 field.
	DAC_EVCTRL_STARTEI0_Pos = 0x0
	// Bit mask of STARTEI0 field.
	DAC_EVCTRL_STARTEI0_Msk = 0x1
	// Bit STARTEI0.
	DAC_EVCTRL_STARTEI0 = 0x1
	// Position of STARTEI1 field.
	DAC_EVCTRL_STARTEI1_Pos = 0x1
	// Bit mask of STARTEI1 field.
	DAC_EVCTRL_STARTEI1_Msk = 0x2
	// Bit STARTEI1.
	DAC_EVCTRL_STARTEI1 = 0x2
	// Position of EMPTYEO0 field.
	DAC_EVCTRL_EMPTYEO0_Pos = 0x2
	// Bit mask of EMPTYEO0 field.
	DAC_EVCTRL_EMPTYEO0_Msk = 0x4
	// Bit EMPTYEO0.
	DAC_EVCTRL_EMPTYEO0 = 0x4
	// Position of EMPTYEO1 field.
	DAC_EVCTRL_EMPTYEO1_Pos = 0x3
	// Bit mask of EMPTYEO1 field.
	DAC_EVCTRL_EMPTYEO1_Msk = 0x8
	// Bit EMPTYEO1.
	DAC_EVCTRL_EMPTYEO1 = 0x8
	// Position of INVEI0 field.
	DAC_EVCTRL_INVEI0_Pos = 0x4
	// Bit mask of INVEI0 field.
	DAC_EVCTRL_INVEI0_Msk = 0x10
	// Bit INVEI0.
	DAC_EVCTRL_INVEI0 = 0x10
	// Position of INVEI1 field.
	DAC_EVCTRL_INVEI1_Pos = 0x5
	// Bit mask of INVEI1 field.
	DAC_EVCTRL_INVEI1_Msk = 0x20
	// Bit INVEI1.
	DAC_EVCTRL_INVEI1 = 0x20
	// Position of RESRDYEO0 field.
	DAC_EVCTRL_RESRDYEO0_Pos = 0x6
	// Bit mask of RESRDYEO0 field.
	DAC_EVCTRL_RESRDYEO0_Msk = 0x40
	// Bit RESRDYEO0.
	DAC_EVCTRL_RESRDYEO0 = 0x40
	// Position of RESRDYEO1 field.
	DAC_EVCTRL_RESRDYEO1_Pos = 0x7
	// Bit mask of RESRDYEO1 field.
	DAC_EVCTRL_RESRDYEO1_Msk = 0x80
	// Bit RESRDYEO1.
	DAC_EVCTRL_RESRDYEO1 = 0x80

	// INTENCLR: Interrupt Enable Clear
	// Position of UNDERRUN0 field.
	DAC_INTENCLR_UNDERRUN0_Pos = 0x0
	// Bit mask of UNDERRUN0 field.
	DAC_INTENCLR_UNDERRUN0_Msk = 0x1
	// Bit UNDERRUN0.
	DAC_INTENCLR_UNDERRUN0 = 0x1
	// Position of UNDERRUN1 field.
	DAC_INTENCLR_UNDERRUN1_Pos = 0x1
	// Bit mask of UNDERRUN1 field.
	DAC_INTENCLR_UNDERRUN1_Msk = 0x2
	// Bit UNDERRUN1.
	DAC_INTENCLR_UNDERRUN1 = 0x2
	// Position of EMPTY0 field.
	DAC_INTENCLR_EMPTY0_Pos = 0x2
	// Bit mask of EMPTY0 field.
	DAC_INTENCLR_EMPTY0_Msk = 0x4
	// Bit EMPTY0.
	DAC_INTENCLR_EMPTY0 = 0x4
	// Position of EMPTY1 field.
	DAC_INTENCLR_EMPTY1_Pos = 0x3
	// Bit mask of EMPTY1 field.
	DAC_INTENCLR_EMPTY1_Msk = 0x8
	// Bit EMPTY1.
	DAC_INTENCLR_EMPTY1 = 0x8
	// Position of RESRDY0 field.
	DAC_INTENCLR_RESRDY0_Pos = 0x4
	// Bit mask of RESRDY0 field.
	DAC_INTENCLR_RESRDY0_Msk = 0x10
	// Bit RESRDY0.
	DAC_INTENCLR_RESRDY0 = 0x10
	// Position of RESRDY1 field.
	DAC_INTENCLR_RESRDY1_Pos = 0x5
	// Bit mask of RESRDY1 field.
	DAC_INTENCLR_RESRDY1_Msk = 0x20
	// Bit RESRDY1.
	DAC_INTENCLR_RESRDY1 = 0x20
	// Position of OVERRUN0 field.
	DAC_INTENCLR_OVERRUN0_Pos = 0x6
	// Bit mask of OVERRUN0 field.
	DAC_INTENCLR_OVERRUN0_Msk = 0x40
	// Bit OVERRUN0.
	DAC_INTENCLR_OVERRUN0 = 0x40
	// Position of OVERRUN1 field.
	DAC_INTENCLR_OVERRUN1_Pos = 0x7
	// Bit mask of OVERRUN1 field.
	DAC_INTENCLR_OVERRUN1_Msk = 0x80
	// Bit OVERRUN1.
	DAC_INTENCLR_OVERRUN1 = 0x80

	// INTENSET: Interrupt Enable Set
	// Position of UNDERRUN0 field.
	DAC_INTENSET_UNDERRUN0_Pos = 0x0
	// Bit mask of UNDERRUN0 field.
	DAC_INTENSET_UNDERRUN0_Msk = 0x1
	// Bit UNDERRUN0.
	DAC_INTENSET_UNDERRUN0 = 0x1
	// Position of UNDERRUN1 field.
	DAC_INTENSET_UNDERRUN1_Pos = 0x1
	// Bit mask of UNDERRUN1 field.
	DAC_INTENSET_UNDERRUN1_Msk = 0x2
	// Bit UNDERRUN1.
	DAC_INTENSET_UNDERRUN1 = 0x2
	// Position of EMPTY0 field.
	DAC_INTENSET_EMPTY0_Pos = 0x2
	// Bit mask of EMPTY0 field.
	DAC_INTENSET_EMPTY0_Msk = 0x4
	// Bit EMPTY0.
	DAC_INTENSET_EMPTY0 = 0x4
	// Position of EMPTY1 field.
	DAC_INTENSET_EMPTY1_Pos = 0x3
	// Bit mask of EMPTY1 field.
	DAC_INTENSET_EMPTY1_Msk = 0x8
	// Bit EMPTY1.
	DAC_INTENSET_EMPTY1 = 0x8
	// Position of RESRDY0 field.
	DAC_INTENSET_RESRDY0_Pos = 0x4
	// Bit mask of RESRDY0 field.
	DAC_INTENSET_RESRDY0_Msk = 0x10
	// Bit RESRDY0.
	DAC_INTENSET_RESRDY0 = 0x10
	// Position of RESRDY1 field.
	DAC_INTENSET_RESRDY1_Pos = 0x5
	// Bit mask of RESRDY1 field.
	DAC_INTENSET_RESRDY1_Msk = 0x20
	// Bit RESRDY1.
	DAC_INTENSET_RESRDY1 = 0x20
	// Position of OVERRUN0 field.
	DAC_INTENSET_OVERRUN0_Pos = 0x6
	// Bit mask of OVERRUN0 field.
	DAC_INTENSET_OVERRUN0_Msk = 0x40
	// Bit OVERRUN0.
	DAC_INTENSET_OVERRUN0 = 0x40
	// Position of OVERRUN1 field.
	DAC_INTENSET_OVERRUN1_Pos = 0x7
	// Bit mask of OVERRUN1 field.
	DAC_INTENSET_OVERRUN1_Msk = 0x80
	// Bit OVERRUN1.
	DAC_INTENSET_OVERRUN1 = 0x80

	// INTFLAG: Interrupt Flag Status and Clear
	// Position of UNDERRUN0 field.
	DAC_INTFLAG_UNDERRUN0_Pos = 0x0
	// Bit mask of UNDERRUN0 field.
	DAC_INTFLAG_UNDERRUN0_Msk = 0x1
	// Bit UNDERRUN0.
	DAC_INTFLAG_UNDERRUN0 = 0x1
	// Position of UNDERRUN1 field.
	DAC_INTFLAG_UNDERRUN1_Pos = 0x1
	// Bit mask of UNDERRUN1 field.
	DAC_INTFLAG_UNDERRUN1_Msk = 0x2
	// Bit UNDERRUN1.
	DAC_INTFLAG_UNDERRUN1 = 0x2
	// Position of EMPTY0 field.
	DAC_INTFLAG_EMPTY0_Pos = 0x2
	// Bit mask of EMPTY0 field.
	DAC_INTFLAG_EMPTY0_Msk = 0x4
	// Bit EMPTY0.
	DAC_INTFLAG_EMPTY0 = 0x4
	// Position of EMPTY1 field.
	DAC_INTFLAG_EMPTY1_Pos = 0x3
	// Bit mask of EMPTY1 field.
	DAC_INTFLAG_EMPTY1_Msk = 0x8
	// Bit EMPTY1.
	DAC_INTFLAG_EMPTY1 = 0x8
	// Position of RESRDY0 field.
	DAC_INTFLAG_RESRDY0_Pos = 0x4
	// Bit mask of RESRDY0 field.
	DAC_INTFLAG_RESRDY0_Msk = 0x10
	// Bit RESRDY0.
	DAC_INTFLAG_RESRDY0 = 0x10
	// Position of RESRDY1 field.
	DAC_INTFLAG_RESRDY1_Pos = 0x5
	// Bit mask of RESRDY1 field.
	DAC_INTFLAG_RESRDY1_Msk = 0x20
	// Bit RESRDY1.
	DAC_INTFLAG_RESRDY1 = 0x20
	// Position of OVERRUN0 field.
	DAC_INTFLAG_OVERRUN0_Pos = 0x6
	// Bit mask of OVERRUN0 field.
	DAC_INTFLAG_OVERRUN0_Msk = 0x40
	// Bit OVERRUN0.
	DAC_INTFLAG_OVERRUN0 = 0x40
	// Position of OVERRUN1 field.
	DAC_INTFLAG_OVERRUN1_Pos = 0x7
	// Bit mask of OVERRUN1 field.
	DAC_INTFLAG_OVERRUN1_Msk = 0x80
	// Bit OVERRUN1.
	DAC_INTFLAG_OVERRUN1 = 0x80

	// STATUS: Status
	// Position of READY0 field.
	DAC_STATUS_READY0_Pos = 0x0
	// Bit mask of READY0 field.
	DAC_STATUS_READY0_Msk = 0x1
	// Bit READY0.
	DAC_STATUS_READY0 = 0x1
	// Position of READY1 field.
	DAC_STATUS_READY1_Pos = 0x1
	// Bit mask of READY1 field.
	DAC_STATUS_READY1_Msk = 0x2
	// Bit READY1.
	DAC_STATUS_READY1 = 0x2
	// Position of EOC0 field.
	DAC_STATUS_EOC0_Pos = 0x2
	// Bit mask of EOC0 field.
	DAC_STATUS_EOC0_Msk = 0x4
	// Bit EOC0.
	DAC_STATUS_EOC0 = 0x4
	// Position of EOC1 field.
	DAC_STATUS_EOC1_Pos = 0x3
	// Bit mask of EOC1 field.
	DAC_STATUS_EOC1_Msk = 0x8
	// Bit EOC1.
	DAC_STATUS_EOC1 = 0x8

	// SYNCBUSY: Synchronization Busy
	// Position of SWRST field.
	DAC_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	DAC_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	DAC_SYNCBUSY_SWRST = 0x1
	// Position of ENABLE field.
	DAC_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	DAC_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	DAC_SYNCBUSY_ENABLE = 0x2
	// Position of DATA0 field.
	DAC_SYNCBUSY_DATA0_Pos = 0x2
	// Bit mask of DATA0 field.
	DAC_SYNCBUSY_DATA0_Msk = 0x4
	// Bit DATA0.
	DAC_SYNCBUSY_DATA0 = 0x4
	// Position of DATA1 field.
	DAC_SYNCBUSY_DATA1_Pos = 0x3
	// Bit mask of DATA1 field.
	DAC_SYNCBUSY_DATA1_Msk = 0x8
	// Bit DATA1.
	DAC_SYNCBUSY_DATA1 = 0x8
	// Position of DATABUF0 field.
	DAC_SYNCBUSY_DATABUF0_Pos = 0x4
	// Bit mask of DATABUF0 field.
	DAC_SYNCBUSY_DATABUF0_Msk = 0x10
	// Bit DATABUF0.
	DAC_SYNCBUSY_DATABUF0 = 0x10
	// Position of DATABUF1 field.
	DAC_SYNCBUSY_DATABUF1_Pos = 0x5
	// Bit mask of DATABUF1 field.
	DAC_SYNCBUSY_DATABUF1_Msk = 0x20
	// Bit DATABUF1.
	DAC_SYNCBUSY_DATABUF1 = 0x20

	// DACCTRL: DAC n Control
	// Position of LEFTADJ field.
	DAC_DACCTRL_LEFTADJ_Pos = 0x0
	// Bit mask of LEFTADJ field.
	DAC_DACCTRL_LEFTADJ_Msk = 0x1
	// Bit LEFTADJ.
	DAC_DACCTRL_LEFTADJ = 0x1
	// Position of ENABLE field.
	DAC_DACCTRL_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	DAC_DACCTRL_ENABLE_Msk = 0x2
	// Bit ENABLE.
	DAC_DACCTRL_ENABLE = 0x2
	// Position of CCTRL field.
	DAC_DACCTRL_CCTRL_Pos = 0x2
	// Bit mask of CCTRL field.
	DAC_DACCTRL_CCTRL_Msk = 0xc
	// 100kSPS
	DAC_DACCTRL_CCTRL_CC100K = 0x0
	// 500kSPS
	DAC_DACCTRL_CCTRL_CC1M = 0x1
	// 1MSPS
	DAC_DACCTRL_CCTRL_CC12M = 0x2
	// Position of FEXT field.
	DAC_DACCTRL_FEXT_Pos = 0x5
	// Bit mask of FEXT field.
	DAC_DACCTRL_FEXT_Msk = 0x20
	// Bit FEXT.
	DAC_DACCTRL_FEXT = 0x20
	// Position of RUNSTDBY field.
	DAC_DACCTRL_RUNSTDBY_Pos = 0x6
	// Bit mask of RUNSTDBY field.
	DAC_DACCTRL_RUNSTDBY_Msk = 0x40
	// Bit RUNSTDBY.
	DAC_DACCTRL_RUNSTDBY = 0x40
	// Position of DITHER field.
	DAC_DACCTRL_DITHER_Pos = 0x7
	// Bit mask of DITHER field.
	DAC_DACCTRL_DITHER_Msk = 0x80
	// Bit DITHER.
	DAC_DACCTRL_DITHER = 0x80
	// Position of REFRESH field.
	DAC_DACCTRL_REFRESH_Pos = 0x8
	// Bit mask of REFRESH field.
	DAC_DACCTRL_REFRESH_Msk = 0xf00
	// Do not Refresh
	DAC_DACCTRL_REFRESH_REFRESH_0 = 0x0
	// Refresh every 30 us
	DAC_DACCTRL_REFRESH_REFRESH_1 = 0x1
	// Refresh every 60 us
	DAC_DACCTRL_REFRESH_REFRESH_2 = 0x2
	// Refresh every 90 us
	DAC_DACCTRL_REFRESH_REFRESH_3 = 0x3
	// Refresh every 120 us
	DAC_DACCTRL_REFRESH_REFRESH_4 = 0x4
	// Refresh every 150 us
	DAC_DACCTRL_REFRESH_REFRESH_5 = 0x5
	// Refresh every 180 us
	DAC_DACCTRL_REFRESH_REFRESH_6 = 0x6
	// Refresh every 210 us
	DAC_DACCTRL_REFRESH_REFRESH_7 = 0x7
	// Refresh every 240 us
	DAC_DACCTRL_REFRESH_REFRESH_8 = 0x8
	// Refresh every 270 us
	DAC_DACCTRL_REFRESH_REFRESH_9 = 0x9
	// Refresh every 300 us
	DAC_DACCTRL_REFRESH_REFRESH_10 = 0xa
	// Refresh every 330 us
	DAC_DACCTRL_REFRESH_REFRESH_11 = 0xb
	// Refresh every 360 us
	DAC_DACCTRL_REFRESH_REFRESH_12 = 0xc
	// Refresh every 390 us
	DAC_DACCTRL_REFRESH_REFRESH_13 = 0xd
	// Refresh every 420 us
	DAC_DACCTRL_REFRESH_REFRESH_14 = 0xe
	// Refresh every 450 us
	DAC_DACCTRL_REFRESH_REFRESH_15 = 0xf
	// Position of OSR field.
	DAC_DACCTRL_OSR_Pos = 0xd
	// Bit mask of OSR field.
	DAC_DACCTRL_OSR_Msk = 0xe000
	// No Over Sampling
	DAC_DACCTRL_OSR_OSR_1 = 0x0
	// 2x Over Sampling Ratio
	DAC_DACCTRL_OSR_OSR_2 = 0x1
	// 4x Over Sampling Ratio
	DAC_DACCTRL_OSR_OSR_4 = 0x2
	// 8x Over Sampling Ratio
	DAC_DACCTRL_OSR_OSR_8 = 0x3
	// 16x Over Sampling Ratio
	DAC_DACCTRL_OSR_OSR_16 = 0x4
	// 32x Over Sampling Ratio
	DAC_DACCTRL_OSR_OSR_32 = 0x5

	// DATA: DAC n Data
	// Position of DATA field.
	DAC_DATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	DAC_DATA_DATA_Msk = 0xffff

	// DATABUF: DAC n Data Buffer
	// Position of DATABUF field.
	DAC_DATABUF_DATABUF_Pos = 0x0
	// Bit mask of DATABUF field.
	DAC_DATABUF_DATABUF_Msk = 0xffff

	// DBGCTRL: Debug Control
	// Position of DBGRUN field.
	DAC_DBGCTRL_DBGRUN_Pos = 0x0
	// Bit mask of DBGRUN field.
	DAC_DBGCTRL_DBGRUN_Msk = 0x1
	// Bit DBGRUN.
	DAC_DBGCTRL_DBGRUN = 0x1

	// RESULT: Filter Result
	// Position of RESULT field.
	DAC_RESULT_RESULT_Pos = 0x0
	// Bit mask of RESULT field.
	DAC_RESULT_RESULT_Msk = 0xffff
)

// Constants for DMAC: Direct Memory Access Controller
const (
	// CTRL: Control
	// Position of SWRST field.
	DMAC_CTRL_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	DMAC_CTRL_SWRST_Msk = 0x1
	// Bit SWRST.
	DMAC_CTRL_SWRST = 0x1
	// Position of DMAENABLE field.
	DMAC_CTRL_DMAENABLE_Pos = 0x1
	// Bit mask of DMAENABLE field.
	DMAC_CTRL_DMAENABLE_Msk = 0x2
	// Bit DMAENABLE.
	DMAC_CTRL_DMAENABLE = 0x2
	// Position of LVLEN0 field.
	DMAC_CTRL_LVLEN0_Pos = 0x8
	// Bit mask of LVLEN0 field.
	DMAC_CTRL_LVLEN0_Msk = 0x100
	// Bit LVLEN0.
	DMAC_CTRL_LVLEN0 = 0x100
	// Position of LVLEN1 field.
	DMAC_CTRL_LVLEN1_Pos = 0x9
	// Bit mask of LVLEN1 field.
	DMAC_CTRL_LVLEN1_Msk = 0x200
	// Bit LVLEN1.
	DMAC_CTRL_LVLEN1 = 0x200
	// Position of LVLEN2 field.
	DMAC_CTRL_LVLEN2_Pos = 0xa
	// Bit mask of LVLEN2 field.
	DMAC_CTRL_LVLEN2_Msk = 0x400
	// Bit LVLEN2.
	DMAC_CTRL_LVLEN2 = 0x400
	// Position of LVLEN3 field.
	DMAC_CTRL_LVLEN3_Pos = 0xb
	// Bit mask of LVLEN3 field.
	DMAC_CTRL_LVLEN3_Msk = 0x800
	// Bit LVLEN3.
	DMAC_CTRL_LVLEN3 = 0x800

	// CRCCTRL: CRC Control
	// Position of CRCBEATSIZE field.
	DMAC_CRCCTRL_CRCBEATSIZE_Pos = 0x0
	// Bit mask of CRCBEATSIZE field.
	DMAC_CRCCTRL_CRCBEATSIZE_Msk = 0x3
	// 8-bit bus transfer
	DMAC_CRCCTRL_CRCBEATSIZE_BYTE = 0x0
	// 16-bit bus transfer
	DMAC_CRCCTRL_CRCBEATSIZE_HWORD = 0x1
	// 32-bit bus transfer
	DMAC_CRCCTRL_CRCBEATSIZE_WORD = 0x2
	// Position of CRCPOLY field.
	DMAC_CRCCTRL_CRCPOLY_Pos = 0x2
	// Bit mask of CRCPOLY field.
	DMAC_CRCCTRL_CRCPOLY_Msk = 0xc
	// CRC-16 (CRC-CCITT)
	DMAC_CRCCTRL_CRCPOLY_CRC16 = 0x0
	// CRC32 (IEEE 802.3)
	DMAC_CRCCTRL_CRCPOLY_CRC32 = 0x1
	// Position of CRCSRC field.
	DMAC_CRCCTRL_CRCSRC_Pos = 0x8
	// Bit mask of CRCSRC field.
	DMAC_CRCCTRL_CRCSRC_Msk = 0x3f00
	// CRC Disabled
	DMAC_CRCCTRL_CRCSRC_DISABLE = 0x0
	// I/O interface
	DMAC_CRCCTRL_CRCSRC_IO = 0x1
	// Position of CRCMODE field.
	DMAC_CRCCTRL_CRCMODE_Pos = 0xe
	// Bit mask of CRCMODE field.
	DMAC_CRCCTRL_CRCMODE_Msk = 0xc000
	// Default operating mode
	DMAC_CRCCTRL_CRCMODE_DEFAULT = 0x0
	// Memory CRC monitor operating mode
	DMAC_CRCCTRL_CRCMODE_CRCMON = 0x2
	// Memory CRC generation operating mode
	DMAC_CRCCTRL_CRCMODE_CRCGEN = 0x3

	// CRCDATAIN: CRC Data Input
	// Position of CRCDATAIN field.
	DMAC_CRCDATAIN_CRCDATAIN_Pos = 0x0
	// Bit mask of CRCDATAIN field.
	DMAC_CRCDATAIN_CRCDATAIN_Msk = 0xffffffff

	// CRCCHKSUM: CRC Checksum
	// Position of CRCCHKSUM field.
	DMAC_CRCCHKSUM_CRCCHKSUM_Pos = 0x0
	// Bit mask of CRCCHKSUM field.
	DMAC_CRCCHKSUM_CRCCHKSUM_Msk = 0xffffffff

	// CRCSTATUS: CRC Status
	// Position of CRCBUSY field.
	DMAC_CRCSTATUS_CRCBUSY_Pos = 0x0
	// Bit mask of CRCBUSY field.
	DMAC_CRCSTATUS_CRCBUSY_Msk = 0x1
	// Bit CRCBUSY.
	DMAC_CRCSTATUS_CRCBUSY = 0x1
	// Position of CRCZERO field.
	DMAC_CRCSTATUS_CRCZERO_Pos = 0x1
	// Bit mask of CRCZERO field.
	DMAC_CRCSTATUS_CRCZERO_Msk = 0x2
	// Bit CRCZERO.
	DMAC_CRCSTATUS_CRCZERO = 0x2
	// Position of CRCERR field.
	DMAC_CRCSTATUS_CRCERR_Pos = 0x2
	// Bit mask of CRCERR field.
	DMAC_CRCSTATUS_CRCERR_Msk = 0x4
	// Bit CRCERR.
	DMAC_CRCSTATUS_CRCERR = 0x4

	// DBGCTRL: Debug Control
	// Position of DBGRUN field.
	DMAC_DBGCTRL_DBGRUN_Pos = 0x0
	// Bit mask of DBGRUN field.
	DMAC_DBGCTRL_DBGRUN_Msk = 0x1
	// Bit DBGRUN.
	DMAC_DBGCTRL_DBGRUN = 0x1

	// SWTRIGCTRL: Software Trigger Control
	// Position of SWTRIG0 field.
	DMAC_SWTRIGCTRL_SWTRIG0_Pos = 0x0
	// Bit mask of SWTRIG0 field.
	DMAC_SWTRIGCTRL_SWTRIG0_Msk = 0x1
	// Bit SWTRIG0.
	DMAC_SWTRIGCTRL_SWTRIG0 = 0x1
	// Position of SWTRIG1 field.
	DMAC_SWTRIGCTRL_SWTRIG1_Pos = 0x1
	// Bit mask of SWTRIG1 field.
	DMAC_SWTRIGCTRL_SWTRIG1_Msk = 0x2
	// Bit SWTRIG1.
	DMAC_SWTRIGCTRL_SWTRIG1 = 0x2
	// Position of SWTRIG2 field.
	DMAC_SWTRIGCTRL_SWTRIG2_Pos = 0x2
	// Bit mask of SWTRIG2 field.
	DMAC_SWTRIGCTRL_SWTRIG2_Msk = 0x4
	// Bit SWTRIG2.
	DMAC_SWTRIGCTRL_SWTRIG2 = 0x4
	// Position of SWTRIG3 field.
	DMAC_SWTRIGCTRL_SWTRIG3_Pos = 0x3
	// Bit mask of SWTRIG3 field.
	DMAC_SWTRIGCTRL_SWTRIG3_Msk = 0x8
	// Bit SWTRIG3.
	DMAC_SWTRIGCTRL_SWTRIG3 = 0x8
	// Position of SWTRIG4 field.
	DMAC_SWTRIGCTRL_SWTRIG4_Pos = 0x4
	// Bit mask of SWTRIG4 field.
	DMAC_SWTRIGCTRL_SWTRIG4_Msk = 0x10
	// Bit SWTRIG4.
	DMAC_SWTRIGCTRL_SWTRIG4 = 0x10
	// Position of SWTRIG5 field.
	DMAC_SWTRIGCTRL_SWTRIG5_Pos = 0x5
	// Bit mask of SWTRIG5 field.
	DMAC_SWTRIGCTRL_SWTRIG5_Msk = 0x20
	// Bit SWTRIG5.
	DMAC_SWTRIGCTRL_SWTRIG5 = 0x20
	// Position of SWTRIG6 field.
	DMAC_SWTRIGCTRL_SWTRIG6_Pos = 0x6
	// Bit mask of SWTRIG6 field.
	DMAC_SWTRIGCTRL_SWTRIG6_Msk = 0x40
	// Bit SWTRIG6.
	DMAC_SWTRIGCTRL_SWTRIG6 = 0x40
	// Position of SWTRIG7 field.
	DMAC_SWTRIGCTRL_SWTRIG7_Pos = 0x7
	// Bit mask of SWTRIG7 field.
	DMAC_SWTRIGCTRL_SWTRIG7_Msk = 0x80
	// Bit SWTRIG7.
	DMAC_SWTRIGCTRL_SWTRIG7 = 0x80
	// Position of SWTRIG8 field.
	DMAC_SWTRIGCTRL_SWTRIG8_Pos = 0x8
	// Bit mask of SWTRIG8 field.
	DMAC_SWTRIGCTRL_SWTRIG8_Msk = 0x100
	// Bit SWTRIG8.
	DMAC_SWTRIGCTRL_SWTRIG8 = 0x100
	// Position of SWTRIG9 field.
	DMAC_SWTRIGCTRL_SWTRIG9_Pos = 0x9
	// Bit mask of SWTRIG9 field.
	DMAC_SWTRIGCTRL_SWTRIG9_Msk = 0x200
	// Bit SWTRIG9.
	DMAC_SWTRIGCTRL_SWTRIG9 = 0x200
	// Position of SWTRIG10 field.
	DMAC_SWTRIGCTRL_SWTRIG10_Pos = 0xa
	// Bit mask of SWTRIG10 field.
	DMAC_SWTRIGCTRL_SWTRIG10_Msk = 0x400
	// Bit SWTRIG10.
	DMAC_SWTRIGCTRL_SWTRIG10 = 0x400
	// Position of SWTRIG11 field.
	DMAC_SWTRIGCTRL_SWTRIG11_Pos = 0xb
	// Bit mask of SWTRIG11 field.
	DMAC_SWTRIGCTRL_SWTRIG11_Msk = 0x800
	// Bit SWTRIG11.
	DMAC_SWTRIGCTRL_SWTRIG11 = 0x800
	// Position of SWTRIG12 field.
	DMAC_SWTRIGCTRL_SWTRIG12_Pos = 0xc
	// Bit mask of SWTRIG12 field.
	DMAC_SWTRIGCTRL_SWTRIG12_Msk = 0x1000
	// Bit SWTRIG12.
	DMAC_SWTRIGCTRL_SWTRIG12 = 0x1000
	// Position of SWTRIG13 field.
	DMAC_SWTRIGCTRL_SWTRIG13_Pos = 0xd
	// Bit mask of SWTRIG13 field.
	DMAC_SWTRIGCTRL_SWTRIG13_Msk = 0x2000
	// Bit SWTRIG13.
	DMAC_SWTRIGCTRL_SWTRIG13 = 0x2000
	// Position of SWTRIG14 field.
	DMAC_SWTRIGCTRL_SWTRIG14_Pos = 0xe
	// Bit mask of SWTRIG14 field.
	DMAC_SWTRIGCTRL_SWTRIG14_Msk = 0x4000
	// Bit SWTRIG14.
	DMAC_SWTRIGCTRL_SWTRIG14 = 0x4000
	// Position of SWTRIG15 field.
	DMAC_SWTRIGCTRL_SWTRIG15_Pos = 0xf
	// Bit mask of SWTRIG15 field.
	DMAC_SWTRIGCTRL_SWTRIG15_Msk = 0x8000
	// Bit SWTRIG15.
	DMAC_SWTRIGCTRL_SWTRIG15 = 0x8000
	// Position of SWTRIG16 field.
	DMAC_SWTRIGCTRL_SWTRIG16_Pos = 0x10
	// Bit mask of SWTRIG16 field.
	DMAC_SWTRIGCTRL_SWTRIG16_Msk = 0x10000
	// Bit SWTRIG16.
	DMAC_SWTRIGCTRL_SWTRIG16 = 0x10000
	// Position of SWTRIG17 field.
	DMAC_SWTRIGCTRL_SWTRIG17_Pos = 0x11
	// Bit mask of SWTRIG17 field.
	DMAC_SWTRIGCTRL_SWTRIG17_Msk = 0x20000
	// Bit SWTRIG17.
	DMAC_SWTRIGCTRL_SWTRIG17 = 0x20000
	// Position of SWTRIG18 field.
	DMAC_SWTRIGCTRL_SWTRIG18_Pos = 0x12
	// Bit mask of SWTRIG18 field.
	DMAC_SWTRIGCTRL_SWTRIG18_Msk = 0x40000
	// Bit SWTRIG18.
	DMAC_SWTRIGCTRL_SWTRIG18 = 0x40000
	// Position of SWTRIG19 field.
	DMAC_SWTRIGCTRL_SWTRIG19_Pos = 0x13
	// Bit mask of SWTRIG19 field.
	DMAC_SWTRIGCTRL_SWTRIG19_Msk = 0x80000
	// Bit SWTRIG19.
	DMAC_SWTRIGCTRL_SWTRIG19 = 0x80000
	// Position of SWTRIG20 field.
	DMAC_SWTRIGCTRL_SWTRIG20_Pos = 0x14
	// Bit mask of SWTRIG20 field.
	DMAC_SWTRIGCTRL_SWTRIG20_Msk = 0x100000
	// Bit SWTRIG20.
	DMAC_SWTRIGCTRL_SWTRIG20 = 0x100000
	// Position of SWTRIG21 field.
	DMAC_SWTRIGCTRL_SWTRIG21_Pos = 0x15
	// Bit mask of SWTRIG21 field.
	DMAC_SWTRIGCTRL_SWTRIG21_Msk = 0x200000
	// Bit SWTRIG21.
	DMAC_SWTRIGCTRL_SWTRIG21 = 0x200000
	// Position of SWTRIG22 field.
	DMAC_SWTRIGCTRL_SWTRIG22_Pos = 0x16
	// Bit mask of SWTRIG22 field.
	DMAC_SWTRIGCTRL_SWTRIG22_Msk = 0x400000
	// Bit SWTRIG22.
	DMAC_SWTRIGCTRL_SWTRIG22 = 0x400000
	// Position of SWTRIG23 field.
	DMAC_SWTRIGCTRL_SWTRIG23_Pos = 0x17
	// Bit mask of SWTRIG23 field.
	DMAC_SWTRIGCTRL_SWTRIG23_Msk = 0x800000
	// Bit SWTRIG23.
	DMAC_SWTRIGCTRL_SWTRIG23 = 0x800000
	// Position of SWTRIG24 field.
	DMAC_SWTRIGCTRL_SWTRIG24_Pos = 0x18
	// Bit mask of SWTRIG24 field.
	DMAC_SWTRIGCTRL_SWTRIG24_Msk = 0x1000000
	// Bit SWTRIG24.
	DMAC_SWTRIGCTRL_SWTRIG24 = 0x1000000
	// Position of SWTRIG25 field.
	DMAC_SWTRIGCTRL_SWTRIG25_Pos = 0x19
	// Bit mask of SWTRIG25 field.
	DMAC_SWTRIGCTRL_SWTRIG25_Msk = 0x2000000
	// Bit SWTRIG25.
	DMAC_SWTRIGCTRL_SWTRIG25 = 0x2000000
	// Position of SWTRIG26 field.
	DMAC_SWTRIGCTRL_SWTRIG26_Pos = 0x1a
	// Bit mask of SWTRIG26 field.
	DMAC_SWTRIGCTRL_SWTRIG26_Msk = 0x4000000
	// Bit SWTRIG26.
	DMAC_SWTRIGCTRL_SWTRIG26 = 0x4000000
	// Position of SWTRIG27 field.
	DMAC_SWTRIGCTRL_SWTRIG27_Pos = 0x1b
	// Bit mask of SWTRIG27 field.
	DMAC_SWTRIGCTRL_SWTRIG27_Msk = 0x8000000
	// Bit SWTRIG27.
	DMAC_SWTRIGCTRL_SWTRIG27 = 0x8000000
	// Position of SWTRIG28 field.
	DMAC_SWTRIGCTRL_SWTRIG28_Pos = 0x1c
	// Bit mask of SWTRIG28 field.
	DMAC_SWTRIGCTRL_SWTRIG28_Msk = 0x10000000
	// Bit SWTRIG28.
	DMAC_SWTRIGCTRL_SWTRIG28 = 0x10000000
	// Position of SWTRIG29 field.
	DMAC_SWTRIGCTRL_SWTRIG29_Pos = 0x1d
	// Bit mask of SWTRIG29 field.
	DMAC_SWTRIGCTRL_SWTRIG29_Msk = 0x20000000
	// Bit SWTRIG29.
	DMAC_SWTRIGCTRL_SWTRIG29 = 0x20000000
	// Position of SWTRIG30 field.
	DMAC_SWTRIGCTRL_SWTRIG30_Pos = 0x1e
	// Bit mask of SWTRIG30 field.
	DMAC_SWTRIGCTRL_SWTRIG30_Msk = 0x40000000
	// Bit SWTRIG30.
	DMAC_SWTRIGCTRL_SWTRIG30 = 0x40000000
	// Position of SWTRIG31 field.
	DMAC_SWTRIGCTRL_SWTRIG31_Pos = 0x1f
	// Bit mask of SWTRIG31 field.
	DMAC_SWTRIGCTRL_SWTRIG31_Msk = 0x80000000
	// Bit SWTRIG31.
	DMAC_SWTRIGCTRL_SWTRIG31 = 0x80000000

	// PRICTRL0: Priority Control 0
	// Position of LVLPRI0 field.
	DMAC_PRICTRL0_LVLPRI0_Pos = 0x0
	// Bit mask of LVLPRI0 field.
	DMAC_PRICTRL0_LVLPRI0_Msk = 0x1f
	// Position of QOS0 field.
	DMAC_PRICTRL0_QOS0_Pos = 0x5
	// Bit mask of QOS0 field.
	DMAC_PRICTRL0_QOS0_Msk = 0x60
	// Regular delivery
	DMAC_PRICTRL0_QOS0_REGULAR = 0x0
	// Bandwidth shortage
	DMAC_PRICTRL0_QOS0_SHORTAGE = 0x1
	// Latency sensitive
	DMAC_PRICTRL0_QOS0_SENSITIVE = 0x2
	// Latency critical
	DMAC_PRICTRL0_QOS0_CRITICAL = 0x3
	// Position of RRLVLEN0 field.
	DMAC_PRICTRL0_RRLVLEN0_Pos = 0x7
	// Bit mask of RRLVLEN0 field.
	DMAC_PRICTRL0_RRLVLEN0_Msk = 0x80
	// Bit RRLVLEN0.
	DMAC_PRICTRL0_RRLVLEN0 = 0x80
	// Position of LVLPRI1 field.
	DMAC_PRICTRL0_LVLPRI1_Pos = 0x8
	// Bit mask of LVLPRI1 field.
	DMAC_PRICTRL0_LVLPRI1_Msk = 0x1f00
	// Position of QOS1 field.
	DMAC_PRICTRL0_QOS1_Pos = 0xd
	// Bit mask of QOS1 field.
	DMAC_PRICTRL0_QOS1_Msk = 0x6000
	// Regular delivery
	DMAC_PRICTRL0_QOS1_REGULAR = 0x0
	// Bandwidth shortage
	DMAC_PRICTRL0_QOS1_SHORTAGE = 0x1
	// Latency sensitive
	DMAC_PRICTRL0_QOS1_SENSITIVE = 0x2
	// Latency critical
	DMAC_PRICTRL0_QOS1_CRITICAL = 0x3
	// Position of RRLVLEN1 field.
	DMAC_PRICTRL0_RRLVLEN1_Pos = 0xf
	// Bit mask of RRLVLEN1 field.
	DMAC_PRICTRL0_RRLVLEN1_Msk = 0x8000
	// Bit RRLVLEN1.
	DMAC_PRICTRL0_RRLVLEN1 = 0x8000
	// Position of LVLPRI2 field.
	DMAC_PRICTRL0_LVLPRI2_Pos = 0x10
	// Bit mask of LVLPRI2 field.
	DMAC_PRICTRL0_LVLPRI2_Msk = 0x1f0000
	// Position of QOS2 field.
	DMAC_PRICTRL0_QOS2_Pos = 0x15
	// Bit mask of QOS2 field.
	DMAC_PRICTRL0_QOS2_Msk = 0x600000
	// Regular delivery
	DMAC_PRICTRL0_QOS2_REGULAR = 0x0
	// Bandwidth shortage
	DMAC_PRICTRL0_QOS2_SHORTAGE = 0x1
	// Latency sensitive
	DMAC_PRICTRL0_QOS2_SENSITIVE = 0x2
	// Latency critical
	DMAC_PRICTRL0_QOS2_CRITICAL = 0x3
	// Position of RRLVLEN2 field.
	DMAC_PRICTRL0_RRLVLEN2_Pos = 0x17
	// Bit mask of RRLVLEN2 field.
	DMAC_PRICTRL0_RRLVLEN2_Msk = 0x800000
	// Bit RRLVLEN2.
	DMAC_PRICTRL0_RRLVLEN2 = 0x800000
	// Position of LVLPRI3 field.
	DMAC_PRICTRL0_LVLPRI3_Pos = 0x18
	// Bit mask of LVLPRI3 field.
	DMAC_PRICTRL0_LVLPRI3_Msk = 0x1f000000
	// Position of QOS3 field.
	DMAC_PRICTRL0_QOS3_Pos = 0x1d
	// Bit mask of QOS3 field.
	DMAC_PRICTRL0_QOS3_Msk = 0x60000000
	// Regular delivery
	DMAC_PRICTRL0_QOS3_REGULAR = 0x0
	// Bandwidth shortage
	DMAC_PRICTRL0_QOS3_SHORTAGE = 0x1
	// Latency sensitive
	DMAC_PRICTRL0_QOS3_SENSITIVE = 0x2
	// Latency critical
	DMAC_PRICTRL0_QOS3_CRITICAL = 0x3
	// Position of RRLVLEN3 field.
	DMAC_PRICTRL0_RRLVLEN3_Pos = 0x1f
	// Bit mask of RRLVLEN3 field.
	DMAC_PRICTRL0_RRLVLEN3_Msk = 0x80000000
	// Bit RRLVLEN3.
	DMAC_PRICTRL0_RRLVLEN3 = 0x80000000

	// INTPEND: Interrupt Pending
	// Position of ID field.
	DMAC_INTPEND_ID_Pos = 0x0
	// Bit mask of ID field.
	DMAC_INTPEND_ID_Msk = 0x1f
	// Position of TERR field.
	DMAC_INTPEND_TERR_Pos = 0x8
	// Bit mask of TERR field.
	DMAC_INTPEND_TERR_Msk = 0x100
	// Bit TERR.
	DMAC_INTPEND_TERR = 0x100
	// Position of TCMPL field.
	DMAC_INTPEND_TCMPL_Pos = 0x9
	// Bit mask of TCMPL field.
	DMAC_INTPEND_TCMPL_Msk = 0x200
	// Bit TCMPL.
	DMAC_INTPEND_TCMPL = 0x200
	// Position of SUSP field.
	DMAC_INTPEND_SUSP_Pos = 0xa
	// Bit mask of SUSP field.
	DMAC_INTPEND_SUSP_Msk = 0x400
	// Bit SUSP.
	DMAC_INTPEND_SUSP = 0x400
	// Position of CRCERR field.
	DMAC_INTPEND_CRCERR_Pos = 0xc
	// Bit mask of CRCERR field.
	DMAC_INTPEND_CRCERR_Msk = 0x1000
	// Bit CRCERR.
	DMAC_INTPEND_CRCERR = 0x1000
	// Position of FERR field.
	DMAC_INTPEND_FERR_Pos = 0xd
	// Bit mask of FERR field.
	DMAC_INTPEND_FERR_Msk = 0x2000
	// Bit FERR.
	DMAC_INTPEND_FERR = 0x2000
	// Position of BUSY field.
	DMAC_INTPEND_BUSY_Pos = 0xe
	// Bit mask of BUSY field.
	DMAC_INTPEND_BUSY_Msk = 0x4000
	// Bit BUSY.
	DMAC_INTPEND_BUSY = 0x4000
	// Position of PEND field.
	DMAC_INTPEND_PEND_Pos = 0xf
	// Bit mask of PEND field.
	DMAC_INTPEND_PEND_Msk = 0x8000
	// Bit PEND.
	DMAC_INTPEND_PEND = 0x8000

	// INTSTATUS: Interrupt Status
	// Position of CHINT0 field.
	DMAC_INTSTATUS_CHINT0_Pos = 0x0
	// Bit mask of CHINT0 field.
	DMAC_INTSTATUS_CHINT0_Msk = 0x1
	// Bit CHINT0.
	DMAC_INTSTATUS_CHINT0 = 0x1
	// Position of CHINT1 field.
	DMAC_INTSTATUS_CHINT1_Pos = 0x1
	// Bit mask of CHINT1 field.
	DMAC_INTSTATUS_CHINT1_Msk = 0x2
	// Bit CHINT1.
	DMAC_INTSTATUS_CHINT1 = 0x2
	// Position of CHINT2 field.
	DMAC_INTSTATUS_CHINT2_Pos = 0x2
	// Bit mask of CHINT2 field.
	DMAC_INTSTATUS_CHINT2_Msk = 0x4
	// Bit CHINT2.
	DMAC_INTSTATUS_CHINT2 = 0x4
	// Position of CHINT3 field.
	DMAC_INTSTATUS_CHINT3_Pos = 0x3
	// Bit mask of CHINT3 field.
	DMAC_INTSTATUS_CHINT3_Msk = 0x8
	// Bit CHINT3.
	DMAC_INTSTATUS_CHINT3 = 0x8
	// Position of CHINT4 field.
	DMAC_INTSTATUS_CHINT4_Pos = 0x4
	// Bit mask of CHINT4 field.
	DMAC_INTSTATUS_CHINT4_Msk = 0x10
	// Bit CHINT4.
	DMAC_INTSTATUS_CHINT4 = 0x10
	// Position of CHINT5 field.
	DMAC_INTSTATUS_CHINT5_Pos = 0x5
	// Bit mask of CHINT5 field.
	DMAC_INTSTATUS_CHINT5_Msk = 0x20
	// Bit CHINT5.
	DMAC_INTSTATUS_CHINT5 = 0x20
	// Position of CHINT6 field.
	DMAC_INTSTATUS_CHINT6_Pos = 0x6
	// Bit mask of CHINT6 field.
	DMAC_INTSTATUS_CHINT6_Msk = 0x40
	// Bit CHINT6.
	DMAC_INTSTATUS_CHINT6 = 0x40
	// Position of CHINT7 field.
	DMAC_INTSTATUS_CHINT7_Pos = 0x7
	// Bit mask of CHINT7 field.
	DMAC_INTSTATUS_CHINT7_Msk = 0x80
	// Bit CHINT7.
	DMAC_INTSTATUS_CHINT7 = 0x80
	// Position of CHINT8 field.
	DMAC_INTSTATUS_CHINT8_Pos = 0x8
	// Bit mask of CHINT8 field.
	DMAC_INTSTATUS_CHINT8_Msk = 0x100
	// Bit CHINT8.
	DMAC_INTSTATUS_CHINT8 = 0x100
	// Position of CHINT9 field.
	DMAC_INTSTATUS_CHINT9_Pos = 0x9
	// Bit mask of CHINT9 field.
	DMAC_INTSTATUS_CHINT9_Msk = 0x200
	// Bit CHINT9.
	DMAC_INTSTATUS_CHINT9 = 0x200
	// Position of CHINT10 field.
	DMAC_INTSTATUS_CHINT10_Pos = 0xa
	// Bit mask of CHINT10 field.
	DMAC_INTSTATUS_CHINT10_Msk = 0x400
	// Bit CHINT10.
	DMAC_INTSTATUS_CHINT10 = 0x400
	// Position of CHINT11 field.
	DMAC_INTSTATUS_CHINT11_Pos = 0xb
	// Bit mask of CHINT11 field.
	DMAC_INTSTATUS_CHINT11_Msk = 0x800
	// Bit CHINT11.
	DMAC_INTSTATUS_CHINT11 = 0x800
	// Position of CHINT12 field.
	DMAC_INTSTATUS_CHINT12_Pos = 0xc
	// Bit mask of CHINT12 field.
	DMAC_INTSTATUS_CHINT12_Msk = 0x1000
	// Bit CHINT12.
	DMAC_INTSTATUS_CHINT12 = 0x1000
	// Position of CHINT13 field.
	DMAC_INTSTATUS_CHINT13_Pos = 0xd
	// Bit mask of CHINT13 field.
	DMAC_INTSTATUS_CHINT13_Msk = 0x2000
	// Bit CHINT13.
	DMAC_INTSTATUS_CHINT13 = 0x2000
	// Position of CHINT14 field.
	DMAC_INTSTATUS_CHINT14_Pos = 0xe
	// Bit mask of CHINT14 field.
	DMAC_INTSTATUS_CHINT14_Msk = 0x4000
	// Bit CHINT14.
	DMAC_INTSTATUS_CHINT14 = 0x4000
	// Position of CHINT15 field.
	DMAC_INTSTATUS_CHINT15_Pos = 0xf
	// Bit mask of CHINT15 field.
	DMAC_INTSTATUS_CHINT15_Msk = 0x8000
	// Bit CHINT15.
	DMAC_INTSTATUS_CHINT15 = 0x8000
	// Position of CHINT16 field.
	DMAC_INTSTATUS_CHINT16_Pos = 0x10
	// Bit mask of CHINT16 field.
	DMAC_INTSTATUS_CHINT16_Msk = 0x10000
	// Bit CHINT16.
	DMAC_INTSTATUS_CHINT16 = 0x10000
	// Position of CHINT17 field.
	DMAC_INTSTATUS_CHINT17_Pos = 0x11
	// Bit mask of CHINT17 field.
	DMAC_INTSTATUS_CHINT17_Msk = 0x20000
	// Bit CHINT17.
	DMAC_INTSTATUS_CHINT17 = 0x20000
	// Position of CHINT18 field.
	DMAC_INTSTATUS_CHINT18_Pos = 0x12
	// Bit mask of CHINT18 field.
	DMAC_INTSTATUS_CHINT18_Msk = 0x40000
	// Bit CHINT18.
	DMAC_INTSTATUS_CHINT18 = 0x40000
	// Position of CHINT19 field.
	DMAC_INTSTATUS_CHINT19_Pos = 0x13
	// Bit mask of CHINT19 field.
	DMAC_INTSTATUS_CHINT19_Msk = 0x80000
	// Bit CHINT19.
	DMAC_INTSTATUS_CHINT19 = 0x80000
	// Position of CHINT20 field.
	DMAC_INTSTATUS_CHINT20_Pos = 0x14
	// Bit mask of CHINT20 field.
	DMAC_INTSTATUS_CHINT20_Msk = 0x100000
	// Bit CHINT20.
	DMAC_INTSTATUS_CHINT20 = 0x100000
	// Position of CHINT21 field.
	DMAC_INTSTATUS_CHINT21_Pos = 0x15
	// Bit mask of CHINT21 field.
	DMAC_INTSTATUS_CHINT21_Msk = 0x200000
	// Bit CHINT21.
	DMAC_INTSTATUS_CHINT21 = 0x200000
	// Position of CHINT22 field.
	DMAC_INTSTATUS_CHINT22_Pos = 0x16
	// Bit mask of CHINT22 field.
	DMAC_INTSTATUS_CHINT22_Msk = 0x400000
	// Bit CHINT22.
	DMAC_INTSTATUS_CHINT22 = 0x400000
	// Position of CHINT23 field.
	DMAC_INTSTATUS_CHINT23_Pos = 0x17
	// Bit mask of CHINT23 field.
	DMAC_INTSTATUS_CHINT23_Msk = 0x800000
	// Bit CHINT23.
	DMAC_INTSTATUS_CHINT23 = 0x800000
	// Position of CHINT24 field.
	DMAC_INTSTATUS_CHINT24_Pos = 0x18
	// Bit mask of CHINT24 field.
	DMAC_INTSTATUS_CHINT24_Msk = 0x1000000
	// Bit CHINT24.
	DMAC_INTSTATUS_CHINT24 = 0x1000000
	// Position of CHINT25 field.
	DMAC_INTSTATUS_CHINT25_Pos = 0x19
	// Bit mask of CHINT25 field.
	DMAC_INTSTATUS_CHINT25_Msk = 0x2000000
	// Bit CHINT25.
	DMAC_INTSTATUS_CHINT25 = 0x2000000
	// Position of CHINT26 field.
	DMAC_INTSTATUS_CHINT26_Pos = 0x1a
	// Bit mask of CHINT26 field.
	DMAC_INTSTATUS_CHINT26_Msk = 0x4000000
	// Bit CHINT26.
	DMAC_INTSTATUS_CHINT26 = 0x4000000
	// Position of CHINT27 field.
	DMAC_INTSTATUS_CHINT27_Pos = 0x1b
	// Bit mask of CHINT27 field.
	DMAC_INTSTATUS_CHINT27_Msk = 0x8000000
	// Bit CHINT27.
	DMAC_INTSTATUS_CHINT27 = 0x8000000
	// Position of CHINT28 field.
	DMAC_INTSTATUS_CHINT28_Pos = 0x1c
	// Bit mask of CHINT28 field.
	DMAC_INTSTATUS_CHINT28_Msk = 0x10000000
	// Bit CHINT28.
	DMAC_INTSTATUS_CHINT28 = 0x10000000
	// Position of CHINT29 field.
	DMAC_INTSTATUS_CHINT29_Pos = 0x1d
	// Bit mask of CHINT29 field.
	DMAC_INTSTATUS_CHINT29_Msk = 0x20000000
	// Bit CHINT29.
	DMAC_INTSTATUS_CHINT29 = 0x20000000
	// Position of CHINT30 field.
	DMAC_INTSTATUS_CHINT30_Pos = 0x1e
	// Bit mask of CHINT30 field.
	DMAC_INTSTATUS_CHINT30_Msk = 0x40000000
	// Bit CHINT30.
	DMAC_INTSTATUS_CHINT30 = 0x40000000
	// Position of CHINT31 field.
	DMAC_INTSTATUS_CHINT31_Pos = 0x1f
	// Bit mask of CHINT31 field.
	DMAC_INTSTATUS_CHINT31_Msk = 0x80000000
	// Bit CHINT31.
	DMAC_INTSTATUS_CHINT31 = 0x80000000

	// BUSYCH: Busy Channels
	// Position of BUSYCH0 field.
	DMAC_BUSYCH_BUSYCH0_Pos = 0x0
	// Bit mask of BUSYCH0 field.
	DMAC_BUSYCH_BUSYCH0_Msk = 0x1
	// Bit BUSYCH0.
	DMAC_BUSYCH_BUSYCH0 = 0x1
	// Position of BUSYCH1 field.
	DMAC_BUSYCH_BUSYCH1_Pos = 0x1
	// Bit mask of BUSYCH1 field.
	DMAC_BUSYCH_BUSYCH1_Msk = 0x2
	// Bit BUSYCH1.
	DMAC_BUSYCH_BUSYCH1 = 0x2
	// Position of BUSYCH2 field.
	DMAC_BUSYCH_BUSYCH2_Pos = 0x2
	// Bit mask of BUSYCH2 field.
	DMAC_BUSYCH_BUSYCH2_Msk = 0x4
	// Bit BUSYCH2.
	DMAC_BUSYCH_BUSYCH2 = 0x4
	// Position of BUSYCH3 field.
	DMAC_BUSYCH_BUSYCH3_Pos = 0x3
	// Bit mask of BUSYCH3 field.
	DMAC_BUSYCH_BUSYCH3_Msk = 0x8
	// Bit BUSYCH3.
	DMAC_BUSYCH_BUSYCH3 = 0x8
	// Position of BUSYCH4 field.
	DMAC_BUSYCH_BUSYCH4_Pos = 0x4
	// Bit mask of BUSYCH4 field.
	DMAC_BUSYCH_BUSYCH4_Msk = 0x10
	// Bit BUSYCH4.
	DMAC_BUSYCH_BUSYCH4 = 0x10
	// Position of BUSYCH5 field.
	DMAC_BUSYCH_BUSYCH5_Pos = 0x5
	// Bit mask of BUSYCH5 field.
	DMAC_BUSYCH_BUSYCH5_Msk = 0x20
	// Bit BUSYCH5.
	DMAC_BUSYCH_BUSYCH5 = 0x20
	// Position of BUSYCH6 field.
	DMAC_BUSYCH_BUSYCH6_Pos = 0x6
	// Bit mask of BUSYCH6 field.
	DMAC_BUSYCH_BUSYCH6_Msk = 0x40
	// Bit BUSYCH6.
	DMAC_BUSYCH_BUSYCH6 = 0x40
	// Position of BUSYCH7 field.
	DMAC_BUSYCH_BUSYCH7_Pos = 0x7
	// Bit mask of BUSYCH7 field.
	DMAC_BUSYCH_BUSYCH7_Msk = 0x80
	// Bit BUSYCH7.
	DMAC_BUSYCH_BUSYCH7 = 0x80
	// Position of BUSYCH8 field.
	DMAC_BUSYCH_BUSYCH8_Pos = 0x8
	// Bit mask of BUSYCH8 field.
	DMAC_BUSYCH_BUSYCH8_Msk = 0x100
	// Bit BUSYCH8.
	DMAC_BUSYCH_BUSYCH8 = 0x100
	// Position of BUSYCH9 field.
	DMAC_BUSYCH_BUSYCH9_Pos = 0x9
	// Bit mask of BUSYCH9 field.
	DMAC_BUSYCH_BUSYCH9_Msk = 0x200
	// Bit BUSYCH9.
	DMAC_BUSYCH_BUSYCH9 = 0x200
	// Position of BUSYCH10 field.
	DMAC_BUSYCH_BUSYCH10_Pos = 0xa
	// Bit mask of BUSYCH10 field.
	DMAC_BUSYCH_BUSYCH10_Msk = 0x400
	// Bit BUSYCH10.
	DMAC_BUSYCH_BUSYCH10 = 0x400
	// Position of BUSYCH11 field.
	DMAC_BUSYCH_BUSYCH11_Pos = 0xb
	// Bit mask of BUSYCH11 field.
	DMAC_BUSYCH_BUSYCH11_Msk = 0x800
	// Bit BUSYCH11.
	DMAC_BUSYCH_BUSYCH11 = 0x800
	// Position of BUSYCH12 field.
	DMAC_BUSYCH_BUSYCH12_Pos = 0xc
	// Bit mask of BUSYCH12 field.
	DMAC_BUSYCH_BUSYCH12_Msk = 0x1000
	// Bit BUSYCH12.
	DMAC_BUSYCH_BUSYCH12 = 0x1000
	// Position of BUSYCH13 field.
	DMAC_BUSYCH_BUSYCH13_Pos = 0xd
	// Bit mask of BUSYCH13 field.
	DMAC_BUSYCH_BUSYCH13_Msk = 0x2000
	// Bit BUSYCH13.
	DMAC_BUSYCH_BUSYCH13 = 0x2000
	// Position of BUSYCH14 field.
	DMAC_BUSYCH_BUSYCH14_Pos = 0xe
	// Bit mask of BUSYCH14 field.
	DMAC_BUSYCH_BUSYCH14_Msk = 0x4000
	// Bit BUSYCH14.
	DMAC_BUSYCH_BUSYCH14 = 0x4000
	// Position of BUSYCH15 field.
	DMAC_BUSYCH_BUSYCH15_Pos = 0xf
	// Bit mask of BUSYCH15 field.
	DMAC_BUSYCH_BUSYCH15_Msk = 0x8000
	// Bit BUSYCH15.
	DMAC_BUSYCH_BUSYCH15 = 0x8000
	// Position of BUSYCH16 field.
	DMAC_BUSYCH_BUSYCH16_Pos = 0x10
	// Bit mask of BUSYCH16 field.
	DMAC_BUSYCH_BUSYCH16_Msk = 0x10000
	// Bit BUSYCH16.
	DMAC_BUSYCH_BUSYCH16 = 0x10000
	// Position of BUSYCH17 field.
	DMAC_BUSYCH_BUSYCH17_Pos = 0x11
	// Bit mask of BUSYCH17 field.
	DMAC_BUSYCH_BUSYCH17_Msk = 0x20000
	// Bit BUSYCH17.
	DMAC_BUSYCH_BUSYCH17 = 0x20000
	// Position of BUSYCH18 field.
	DMAC_BUSYCH_BUSYCH18_Pos = 0x12
	// Bit mask of BUSYCH18 field.
	DMAC_BUSYCH_BUSYCH18_Msk = 0x40000
	// Bit BUSYCH18.
	DMAC_BUSYCH_BUSYCH18 = 0x40000
	// Position of BUSYCH19 field.
	DMAC_BUSYCH_BUSYCH19_Pos = 0x13
	// Bit mask of BUSYCH19 field.
	DMAC_BUSYCH_BUSYCH19_Msk = 0x80000
	// Bit BUSYCH19.
	DMAC_BUSYCH_BUSYCH19 = 0x80000
	// Position of BUSYCH20 field.
	DMAC_BUSYCH_BUSYCH20_Pos = 0x14
	// Bit mask of BUSYCH20 field.
	DMAC_BUSYCH_BUSYCH20_Msk = 0x100000
	// Bit BUSYCH20.
	DMAC_BUSYCH_BUSYCH20 = 0x100000
	// Position of BUSYCH21 field.
	DMAC_BUSYCH_BUSYCH21_Pos = 0x15
	// Bit mask of BUSYCH21 field.
	DMAC_BUSYCH_BUSYCH21_Msk = 0x200000
	// Bit BUSYCH21.
	DMAC_BUSYCH_BUSYCH21 = 0x200000
	// Position of BUSYCH22 field.
	DMAC_BUSYCH_BUSYCH22_Pos = 0x16
	// Bit mask of BUSYCH22 field.
	DMAC_BUSYCH_BUSYCH22_Msk = 0x400000
	// Bit BUSYCH22.
	DMAC_BUSYCH_BUSYCH22 = 0x400000
	// Position of BUSYCH23 field.
	DMAC_BUSYCH_BUSYCH23_Pos = 0x17
	// Bit mask of BUSYCH23 field.
	DMAC_BUSYCH_BUSYCH23_Msk = 0x800000
	// Bit BUSYCH23.
	DMAC_BUSYCH_BUSYCH23 = 0x800000
	// Position of BUSYCH24 field.
	DMAC_BUSYCH_BUSYCH24_Pos = 0x18
	// Bit mask of BUSYCH24 field.
	DMAC_BUSYCH_BUSYCH24_Msk = 0x1000000
	// Bit BUSYCH24.
	DMAC_BUSYCH_BUSYCH24 = 0x1000000
	// Position of BUSYCH25 field.
	DMAC_BUSYCH_BUSYCH25_Pos = 0x19
	// Bit mask of BUSYCH25 field.
	DMAC_BUSYCH_BUSYCH25_Msk = 0x2000000
	// Bit BUSYCH25.
	DMAC_BUSYCH_BUSYCH25 = 0x2000000
	// Position of BUSYCH26 field.
	DMAC_BUSYCH_BUSYCH26_Pos = 0x1a
	// Bit mask of BUSYCH26 field.
	DMAC_BUSYCH_BUSYCH26_Msk = 0x4000000
	// Bit BUSYCH26.
	DMAC_BUSYCH_BUSYCH26 = 0x4000000
	// Position of BUSYCH27 field.
	DMAC_BUSYCH_BUSYCH27_Pos = 0x1b
	// Bit mask of BUSYCH27 field.
	DMAC_BUSYCH_BUSYCH27_Msk = 0x8000000
	// Bit BUSYCH27.
	DMAC_BUSYCH_BUSYCH27 = 0x8000000
	// Position of BUSYCH28 field.
	DMAC_BUSYCH_BUSYCH28_Pos = 0x1c
	// Bit mask of BUSYCH28 field.
	DMAC_BUSYCH_BUSYCH28_Msk = 0x10000000
	// Bit BUSYCH28.
	DMAC_BUSYCH_BUSYCH28 = 0x10000000
	// Position of BUSYCH29 field.
	DMAC_BUSYCH_BUSYCH29_Pos = 0x1d
	// Bit mask of BUSYCH29 field.
	DMAC_BUSYCH_BUSYCH29_Msk = 0x20000000
	// Bit BUSYCH29.
	DMAC_BUSYCH_BUSYCH29 = 0x20000000
	// Position of BUSYCH30 field.
	DMAC_BUSYCH_BUSYCH30_Pos = 0x1e
	// Bit mask of BUSYCH30 field.
	DMAC_BUSYCH_BUSYCH30_Msk = 0x40000000
	// Bit BUSYCH30.
	DMAC_BUSYCH_BUSYCH30 = 0x40000000
	// Position of BUSYCH31 field.
	DMAC_BUSYCH_BUSYCH31_Pos = 0x1f
	// Bit mask of BUSYCH31 field.
	DMAC_BUSYCH_BUSYCH31_Msk = 0x80000000
	// Bit BUSYCH31.
	DMAC_BUSYCH_BUSYCH31 = 0x80000000

	// PENDCH: Pending Channels
	// Position of PENDCH0 field.
	DMAC_PENDCH_PENDCH0_Pos = 0x0
	// Bit mask of PENDCH0 field.
	DMAC_PENDCH_PENDCH0_Msk = 0x1
	// Bit PENDCH0.
	DMAC_PENDCH_PENDCH0 = 0x1
	// Position of PENDCH1 field.
	DMAC_PENDCH_PENDCH1_Pos = 0x1
	// Bit mask of PENDCH1 field.
	DMAC_PENDCH_PENDCH1_Msk = 0x2
	// Bit PENDCH1.
	DMAC_PENDCH_PENDCH1 = 0x2
	// Position of PENDCH2 field.
	DMAC_PENDCH_PENDCH2_Pos = 0x2
	// Bit mask of PENDCH2 field.
	DMAC_PENDCH_PENDCH2_Msk = 0x4
	// Bit PENDCH2.
	DMAC_PENDCH_PENDCH2 = 0x4
	// Position of PENDCH3 field.
	DMAC_PENDCH_PENDCH3_Pos = 0x3
	// Bit mask of PENDCH3 field.
	DMAC_PENDCH_PENDCH3_Msk = 0x8
	// Bit PENDCH3.
	DMAC_PENDCH_PENDCH3 = 0x8
	// Position of PENDCH4 field.
	DMAC_PENDCH_PENDCH4_Pos = 0x4
	// Bit mask of PENDCH4 field.
	DMAC_PENDCH_PENDCH4_Msk = 0x10
	// Bit PENDCH4.
	DMAC_PENDCH_PENDCH4 = 0x10
	// Position of PENDCH5 field.
	DMAC_PENDCH_PENDCH5_Pos = 0x5
	// Bit mask of PENDCH5 field.
	DMAC_PENDCH_PENDCH5_Msk = 0x20
	// Bit PENDCH5.
	DMAC_PENDCH_PENDCH5 = 0x20
	// Position of PENDCH6 field.
	DMAC_PENDCH_PENDCH6_Pos = 0x6
	// Bit mask of PENDCH6 field.
	DMAC_PENDCH_PENDCH6_Msk = 0x40
	// Bit PENDCH6.
	DMAC_PENDCH_PENDCH6 = 0x40
	// Position of PENDCH7 field.
	DMAC_PENDCH_PENDCH7_Pos = 0x7
	// Bit mask of PENDCH7 field.
	DMAC_PENDCH_PENDCH7_Msk = 0x80
	// Bit PENDCH7.
	DMAC_PENDCH_PENDCH7 = 0x80
	// Position of PENDCH8 field.
	DMAC_PENDCH_PENDCH8_Pos = 0x8
	// Bit mask of PENDCH8 field.
	DMAC_PENDCH_PENDCH8_Msk = 0x100
	// Bit PENDCH8.
	DMAC_PENDCH_PENDCH8 = 0x100
	// Position of PENDCH9 field.
	DMAC_PENDCH_PENDCH9_Pos = 0x9
	// Bit mask of PENDCH9 field.
	DMAC_PENDCH_PENDCH9_Msk = 0x200
	// Bit PENDCH9.
	DMAC_PENDCH_PENDCH9 = 0x200
	// Position of PENDCH10 field.
	DMAC_PENDCH_PENDCH10_Pos = 0xa
	// Bit mask of PENDCH10 field.
	DMAC_PENDCH_PENDCH10_Msk = 0x400
	// Bit PENDCH10.
	DMAC_PENDCH_PENDCH10 = 0x400
	// Position of PENDCH11 field.
	DMAC_PENDCH_PENDCH11_Pos = 0xb
	// Bit mask of PENDCH11 field.
	DMAC_PENDCH_PENDCH11_Msk = 0x800
	// Bit PENDCH11.
	DMAC_PENDCH_PENDCH11 = 0x800
	// Position of PENDCH12 field.
	DMAC_PENDCH_PENDCH12_Pos = 0xc
	// Bit mask of PENDCH12 field.
	DMAC_PENDCH_PENDCH12_Msk = 0x1000
	// Bit PENDCH12.
	DMAC_PENDCH_PENDCH12 = 0x1000
	// Position of PENDCH13 field.
	DMAC_PENDCH_PENDCH13_Pos = 0xd
	// Bit mask of PENDCH13 field.
	DMAC_PENDCH_PENDCH13_Msk = 0x2000
	// Bit PENDCH13.
	DMAC_PENDCH_PENDCH13 = 0x2000
	// Position of PENDCH14 field.
	DMAC_PENDCH_PENDCH14_Pos = 0xe
	// Bit mask of PENDCH14 field.
	DMAC_PENDCH_PENDCH14_Msk = 0x4000
	// Bit PENDCH14.
	DMAC_PENDCH_PENDCH14 = 0x4000
	// Position of PENDCH15 field.
	DMAC_PENDCH_PENDCH15_Pos = 0xf
	// Bit mask of PENDCH15 field.
	DMAC_PENDCH_PENDCH15_Msk = 0x8000
	// Bit PENDCH15.
	DMAC_PENDCH_PENDCH15 = 0x8000
	// Position of PENDCH16 field.
	DMAC_PENDCH_PENDCH16_Pos = 0x10
	// Bit mask of PENDCH16 field.
	DMAC_PENDCH_PENDCH16_Msk = 0x10000
	// Bit PENDCH16.
	DMAC_PENDCH_PENDCH16 = 0x10000
	// Position of PENDCH17 field.
	DMAC_PENDCH_PENDCH17_Pos = 0x11
	// Bit mask of PENDCH17 field.
	DMAC_PENDCH_PENDCH17_Msk = 0x20000
	// Bit PENDCH17.
	DMAC_PENDCH_PENDCH17 = 0x20000
	// Position of PENDCH18 field.
	DMAC_PENDCH_PENDCH18_Pos = 0x12
	// Bit mask of PENDCH18 field.
	DMAC_PENDCH_PENDCH18_Msk = 0x40000
	// Bit PENDCH18.
	DMAC_PENDCH_PENDCH18 = 0x40000
	// Position of PENDCH19 field.
	DMAC_PENDCH_PENDCH19_Pos = 0x13
	// Bit mask of PENDCH19 field.
	DMAC_PENDCH_PENDCH19_Msk = 0x80000
	// Bit PENDCH19.
	DMAC_PENDCH_PENDCH19 = 0x80000
	// Position of PENDCH20 field.
	DMAC_PENDCH_PENDCH20_Pos = 0x14
	// Bit mask of PENDCH20 field.
	DMAC_PENDCH_PENDCH20_Msk = 0x100000
	// Bit PENDCH20.
	DMAC_PENDCH_PENDCH20 = 0x100000
	// Position of PENDCH21 field.
	DMAC_PENDCH_PENDCH21_Pos = 0x15
	// Bit mask of PENDCH21 field.
	DMAC_PENDCH_PENDCH21_Msk = 0x200000
	// Bit PENDCH21.
	DMAC_PENDCH_PENDCH21 = 0x200000
	// Position of PENDCH22 field.
	DMAC_PENDCH_PENDCH22_Pos = 0x16
	// Bit mask of PENDCH22 field.
	DMAC_PENDCH_PENDCH22_Msk = 0x400000
	// Bit PENDCH22.
	DMAC_PENDCH_PENDCH22 = 0x400000
	// Position of PENDCH23 field.
	DMAC_PENDCH_PENDCH23_Pos = 0x17
	// Bit mask of PENDCH23 field.
	DMAC_PENDCH_PENDCH23_Msk = 0x800000
	// Bit PENDCH23.
	DMAC_PENDCH_PENDCH23 = 0x800000
	// Position of PENDCH24 field.
	DMAC_PENDCH_PENDCH24_Pos = 0x18
	// Bit mask of PENDCH24 field.
	DMAC_PENDCH_PENDCH24_Msk = 0x1000000
	// Bit PENDCH24.
	DMAC_PENDCH_PENDCH24 = 0x1000000
	// Position of PENDCH25 field.
	DMAC_PENDCH_PENDCH25_Pos = 0x19
	// Bit mask of PENDCH25 field.
	DMAC_PENDCH_PENDCH25_Msk = 0x2000000
	// Bit PENDCH25.
	DMAC_PENDCH_PENDCH25 = 0x2000000
	// Position of PENDCH26 field.
	DMAC_PENDCH_PENDCH26_Pos = 0x1a
	// Bit mask of PENDCH26 field.
	DMAC_PENDCH_PENDCH26_Msk = 0x4000000
	// Bit PENDCH26.
	DMAC_PENDCH_PENDCH26 = 0x4000000
	// Position of PENDCH27 field.
	DMAC_PENDCH_PENDCH27_Pos = 0x1b
	// Bit mask of PENDCH27 field.
	DMAC_PENDCH_PENDCH27_Msk = 0x8000000
	// Bit PENDCH27.
	DMAC_PENDCH_PENDCH27 = 0x8000000
	// Position of PENDCH28 field.
	DMAC_PENDCH_PENDCH28_Pos = 0x1c
	// Bit mask of PENDCH28 field.
	DMAC_PENDCH_PENDCH28_Msk = 0x10000000
	// Bit PENDCH28.
	DMAC_PENDCH_PENDCH28 = 0x10000000
	// Position of PENDCH29 field.
	DMAC_PENDCH_PENDCH29_Pos = 0x1d
	// Bit mask of PENDCH29 field.
	DMAC_PENDCH_PENDCH29_Msk = 0x20000000
	// Bit PENDCH29.
	DMAC_PENDCH_PENDCH29 = 0x20000000
	// Position of PENDCH30 field.
	DMAC_PENDCH_PENDCH30_Pos = 0x1e
	// Bit mask of PENDCH30 field.
	DMAC_PENDCH_PENDCH30_Msk = 0x40000000
	// Bit PENDCH30.
	DMAC_PENDCH_PENDCH30 = 0x40000000
	// Position of PENDCH31 field.
	DMAC_PENDCH_PENDCH31_Pos = 0x1f
	// Bit mask of PENDCH31 field.
	DMAC_PENDCH_PENDCH31_Msk = 0x80000000
	// Bit PENDCH31.
	DMAC_PENDCH_PENDCH31 = 0x80000000

	// ACTIVE: Active Channel and Levels
	// Position of LVLEX0 field.
	DMAC_ACTIVE_LVLEX0_Pos = 0x0
	// Bit mask of LVLEX0 field.
	DMAC_ACTIVE_LVLEX0_Msk = 0x1
	// Bit LVLEX0.
	DMAC_ACTIVE_LVLEX0 = 0x1
	// Position of LVLEX1 field.
	DMAC_ACTIVE_LVLEX1_Pos = 0x1
	// Bit mask of LVLEX1 field.
	DMAC_ACTIVE_LVLEX1_Msk = 0x2
	// Bit LVLEX1.
	DMAC_ACTIVE_LVLEX1 = 0x2
	// Position of LVLEX2 field.
	DMAC_ACTIVE_LVLEX2_Pos = 0x2
	// Bit mask of LVLEX2 field.
	DMAC_ACTIVE_LVLEX2_Msk = 0x4
	// Bit LVLEX2.
	DMAC_ACTIVE_LVLEX2 = 0x4
	// Position of LVLEX3 field.
	DMAC_ACTIVE_LVLEX3_Pos = 0x3
	// Bit mask of LVLEX3 field.
	DMAC_ACTIVE_LVLEX3_Msk = 0x8
	// Bit LVLEX3.
	DMAC_ACTIVE_LVLEX3 = 0x8
	// Position of ID field.
	DMAC_ACTIVE_ID_Pos = 0x8
	// Bit mask of ID field.
	DMAC_ACTIVE_ID_Msk = 0x1f00
	// Position of ABUSY field.
	DMAC_ACTIVE_ABUSY_Pos = 0xf
	// Bit mask of ABUSY field.
	DMAC_ACTIVE_ABUSY_Msk = 0x8000
	// Bit ABUSY.
	DMAC_ACTIVE_ABUSY = 0x8000
	// Position of BTCNT field.
	DMAC_ACTIVE_BTCNT_Pos = 0x10
	// Bit mask of BTCNT field.
	DMAC_ACTIVE_BTCNT_Msk = 0xffff0000

	// BASEADDR: Descriptor Memory Section Base Address
	// Position of BASEADDR field.
	DMAC_BASEADDR_BASEADDR_Pos = 0x0
	// Bit mask of BASEADDR field.
	DMAC_BASEADDR_BASEADDR_Msk = 0xffffffff

	// WRBADDR: Write-Back Memory Section Base Address
	// Position of WRBADDR field.
	DMAC_WRBADDR_WRBADDR_Pos = 0x0
	// Bit mask of WRBADDR field.
	DMAC_WRBADDR_WRBADDR_Msk = 0xffffffff

	// CHANNEL.CHCTRLA: Channel n Control A
	// Position of SWRST field.
	DMAC_CHANNEL_CHCTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	DMAC_CHANNEL_CHCTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	DMAC_CHANNEL_CHCTRLA_SWRST = 0x1
	// Position of ENABLE field.
	DMAC_CHANNEL_CHCTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	DMAC_CHANNEL_CHCTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	DMAC_CHANNEL_CHCTRLA_ENABLE = 0x2
	// Position of RUNSTDBY field.
	DMAC_CHANNEL_CHCTRLA_RUNSTDBY_Pos = 0x6
	// Bit mask of RUNSTDBY field.
	DMAC_CHANNEL_CHCTRLA_RUNSTDBY_Msk = 0x40
	// Bit RUNSTDBY.
	DMAC_CHANNEL_CHCTRLA_RUNSTDBY = 0x40
	// Position of TRIGSRC field.
	DMAC_CHANNEL_CHCTRLA_TRIGSRC_Pos = 0x8
	// Bit mask of TRIGSRC field.
	DMAC_CHANNEL_CHCTRLA_TRIGSRC_Msk = 0x7f00
	// Only software/event triggers
	DMAC_CHANNEL_CHCTRLA_TRIGSRC_DISABLE = 0x0
	// Position of TRIGACT field.
	DMAC_CHANNEL_CHCTRLA_TRIGACT_Pos = 0x14
	// Bit mask of TRIGACT field.
	DMAC_CHANNEL_CHCTRLA_TRIGACT_Msk = 0x300000
	// One trigger required for each block transfer
	DMAC_CHANNEL_CHCTRLA_TRIGACT_BLOCK = 0x0
	// One trigger required for each burst transfer
	DMAC_CHANNEL_CHCTRLA_TRIGACT_BURST = 0x2
	// One trigger required for each transaction
	DMAC_CHANNEL_CHCTRLA_TRIGACT_TRANSACTION = 0x3
	// Position of BURSTLEN field.
	DMAC_CHANNEL_CHCTRLA_BURSTLEN_Pos = 0x18
	// Bit mask of BURSTLEN field.
	DMAC_CHANNEL_CHCTRLA_BURSTLEN_Msk = 0xf000000
	// Single-beat burst length
	DMAC_CHANNEL_CHCTRLA_BURSTLEN_SINGLE = 0x0
	// 2-beats burst length
	DMAC_CHANNEL_CHCTRLA_BURSTLEN_2BEAT = 0x1
	// 3-beats burst length
	DMAC_CHANNEL_CHCTRLA_BURSTLEN_3BEAT = 0x2
	// 4-beats burst length
	DMAC_CHANNEL_CHCTRLA_BURSTLEN_4BEAT = 0x3
	// 5-beats burst length
	DMAC_CHANNEL_CHCTRLA_BURSTLEN_5BEAT = 0x4
	// 6-beats burst length
	DMAC_CHANNEL_CHCTRLA_BURSTLEN_6BEAT = 0x5
	// 7-beats burst length
	DMAC_CHANNEL_CHCTRLA_BURSTLEN_7BEAT = 0x6
	// 8-beats burst length
	DMAC_CHANNEL_CHCTRLA_BURSTLEN_8BEAT = 0x7
	// 9-beats burst length
	DMAC_CHANNEL_CHCTRLA_BURSTLEN_9BEAT = 0x8
	// 10-beats burst length
	DMAC_CHANNEL_CHCTRLA_BURSTLEN_10BEAT = 0x9
	// 11-beats burst length
	DMAC_CHANNEL_CHCTRLA_BURSTLEN_11BEAT = 0xa
	// 12-beats burst length
	DMAC_CHANNEL_CHCTRLA_BURSTLEN_12BEAT = 0xb
	// 13-beats burst length
	DMAC_CHANNEL_CHCTRLA_BURSTLEN_13BEAT = 0xc
	// 14-beats burst length
	DMAC_CHANNEL_CHCTRLA_BURSTLEN_14BEAT = 0xd
	// 15-beats burst length
	DMAC_CHANNEL_CHCTRLA_BURSTLEN_15BEAT = 0xe
	// 16-beats burst length
	DMAC_CHANNEL_CHCTRLA_BURSTLEN_16BEAT = 0xf
	// Position of THRESHOLD field.
	DMAC_CHANNEL_CHCTRLA_THRESHOLD_Pos = 0x1c
	// Bit mask of THRESHOLD field.
	DMAC_CHANNEL_CHCTRLA_THRESHOLD_Msk = 0x30000000
	// Destination write starts after each beat source address read
	DMAC_CHANNEL_CHCTRLA_THRESHOLD_1BEAT = 0x0
	// Destination write starts after 2-beats source address read
	DMAC_CHANNEL_CHCTRLA_THRESHOLD_2BEATS = 0x1
	// Destination write starts after 4-beats source address read
	DMAC_CHANNEL_CHCTRLA_THRESHOLD_4BEATS = 0x2
	// Destination write starts after 8-beats source address read
	DMAC_CHANNEL_CHCTRLA_THRESHOLD_8BEATS = 0x3

	// CHANNEL.CHCTRLB: Channel n Control B
	// Position of CMD field.
	DMAC_CHANNEL_CHCTRLB_CMD_Pos = 0x0
	// Bit mask of CMD field.
	DMAC_CHANNEL_CHCTRLB_CMD_Msk = 0x3
	// No action
	DMAC_CHANNEL_CHCTRLB_CMD_NOACT = 0x0
	// Channel suspend operation
	DMAC_CHANNEL_CHCTRLB_CMD_SUSPEND = 0x1
	// Channel resume operation
	DMAC_CHANNEL_CHCTRLB_CMD_RESUME = 0x2

	// CHANNEL.CHPRILVL: Channel n Priority Level
	// Position of PRILVL field.
	DMAC_CHANNEL_CHPRILVL_PRILVL_Pos = 0x0
	// Bit mask of PRILVL field.
	DMAC_CHANNEL_CHPRILVL_PRILVL_Msk = 0x3
	// Channel Priority Level 0 (Lowest Level)
	DMAC_CHANNEL_CHPRILVL_PRILVL_LVL0 = 0x0
	// Channel Priority Level 1
	DMAC_CHANNEL_CHPRILVL_PRILVL_LVL1 = 0x1
	// Channel Priority Level 2
	DMAC_CHANNEL_CHPRILVL_PRILVL_LVL2 = 0x2
	// Channel Priority Level 3 (Highest Level)
	DMAC_CHANNEL_CHPRILVL_PRILVL_LVL3 = 0x3

	// CHANNEL.CHEVCTRL: Channel n Event Control
	// Position of EVACT field.
	DMAC_CHANNEL_CHEVCTRL_EVACT_Pos = 0x0
	// Bit mask of EVACT field.
	DMAC_CHANNEL_CHEVCTRL_EVACT_Msk = 0x7
	// No action
	DMAC_CHANNEL_CHEVCTRL_EVACT_NOACT = 0x0
	// Transfer and periodic transfer trigger
	DMAC_CHANNEL_CHEVCTRL_EVACT_TRIG = 0x1
	// Conditional transfer trigger
	DMAC_CHANNEL_CHEVCTRL_EVACT_CTRIG = 0x2
	// Conditional block transfer
	DMAC_CHANNEL_CHEVCTRL_EVACT_CBLOCK = 0x3
	// Channel suspend operation
	DMAC_CHANNEL_CHEVCTRL_EVACT_SUSPEND = 0x4
	// Channel resume operation
	DMAC_CHANNEL_CHEVCTRL_EVACT_RESUME = 0x5
	// Skip next block suspend action
	DMAC_CHANNEL_CHEVCTRL_EVACT_SSKIP = 0x6
	// Increase priority
	DMAC_CHANNEL_CHEVCTRL_EVACT_INCPRI = 0x7
	// Position of EVOMODE field.
	DMAC_CHANNEL_CHEVCTRL_EVOMODE_Pos = 0x4
	// Bit mask of EVOMODE field.
	DMAC_CHANNEL_CHEVCTRL_EVOMODE_Msk = 0x30
	// Block event output selection. Refer to BTCTRL.EVOSEL for available selections.
	DMAC_CHANNEL_CHEVCTRL_EVOMODE_DEFAULT = 0x0
	// Ongoing trigger action
	DMAC_CHANNEL_CHEVCTRL_EVOMODE_TRIGACT = 0x1
	// Position of EVIE field.
	DMAC_CHANNEL_CHEVCTRL_EVIE_Pos = 0x6
	// Bit mask of EVIE field.
	DMAC_CHANNEL_CHEVCTRL_EVIE_Msk = 0x40
	// Bit EVIE.
	DMAC_CHANNEL_CHEVCTRL_EVIE = 0x40
	// Position of EVOE field.
	DMAC_CHANNEL_CHEVCTRL_EVOE_Pos = 0x7
	// Bit mask of EVOE field.
	DMAC_CHANNEL_CHEVCTRL_EVOE_Msk = 0x80
	// Bit EVOE.
	DMAC_CHANNEL_CHEVCTRL_EVOE = 0x80

	// CHANNEL.CHINTENCLR: Channel n Interrupt Enable Clear
	// Position of TERR field.
	DMAC_CHANNEL_CHINTENCLR_TERR_Pos = 0x0
	// Bit mask of TERR field.
	DMAC_CHANNEL_CHINTENCLR_TERR_Msk = 0x1
	// Bit TERR.
	DMAC_CHANNEL_CHINTENCLR_TERR = 0x1
	// Position of TCMPL field.
	DMAC_CHANNEL_CHINTENCLR_TCMPL_Pos = 0x1
	// Bit mask of TCMPL field.
	DMAC_CHANNEL_CHINTENCLR_TCMPL_Msk = 0x2
	// Bit TCMPL.
	DMAC_CHANNEL_CHINTENCLR_TCMPL = 0x2
	// Position of SUSP field.
	DMAC_CHANNEL_CHINTENCLR_SUSP_Pos = 0x2
	// Bit mask of SUSP field.
	DMAC_CHANNEL_CHINTENCLR_SUSP_Msk = 0x4
	// Bit SUSP.
	DMAC_CHANNEL_CHINTENCLR_SUSP = 0x4

	// CHANNEL.CHINTENSET: Channel n Interrupt Enable Set
	// Position of TERR field.
	DMAC_CHANNEL_CHINTENSET_TERR_Pos = 0x0
	// Bit mask of TERR field.
	DMAC_CHANNEL_CHINTENSET_TERR_Msk = 0x1
	// Bit TERR.
	DMAC_CHANNEL_CHINTENSET_TERR = 0x1
	// Position of TCMPL field.
	DMAC_CHANNEL_CHINTENSET_TCMPL_Pos = 0x1
	// Bit mask of TCMPL field.
	DMAC_CHANNEL_CHINTENSET_TCMPL_Msk = 0x2
	// Bit TCMPL.
	DMAC_CHANNEL_CHINTENSET_TCMPL = 0x2
	// Position of SUSP field.
	DMAC_CHANNEL_CHINTENSET_SUSP_Pos = 0x2
	// Bit mask of SUSP field.
	DMAC_CHANNEL_CHINTENSET_SUSP_Msk = 0x4
	// Bit SUSP.
	DMAC_CHANNEL_CHINTENSET_SUSP = 0x4

	// CHANNEL.CHINTFLAG: Channel n Interrupt Flag Status and Clear
	// Position of TERR field.
	DMAC_CHANNEL_CHINTFLAG_TERR_Pos = 0x0
	// Bit mask of TERR field.
	DMAC_CHANNEL_CHINTFLAG_TERR_Msk = 0x1
	// Bit TERR.
	DMAC_CHANNEL_CHINTFLAG_TERR = 0x1
	// Position of TCMPL field.
	DMAC_CHANNEL_CHINTFLAG_TCMPL_Pos = 0x1
	// Bit mask of TCMPL field.
	DMAC_CHANNEL_CHINTFLAG_TCMPL_Msk = 0x2
	// Bit TCMPL.
	DMAC_CHANNEL_CHINTFLAG_TCMPL = 0x2
	// Position of SUSP field.
	DMAC_CHANNEL_CHINTFLAG_SUSP_Pos = 0x2
	// Bit mask of SUSP field.
	DMAC_CHANNEL_CHINTFLAG_SUSP_Msk = 0x4
	// Bit SUSP.
	DMAC_CHANNEL_CHINTFLAG_SUSP = 0x4

	// CHANNEL.CHSTATUS: Channel n Status
	// Position of PEND field.
	DMAC_CHANNEL_CHSTATUS_PEND_Pos = 0x0
	// Bit mask of PEND field.
	DMAC_CHANNEL_CHSTATUS_PEND_Msk = 0x1
	// Bit PEND.
	DMAC_CHANNEL_CHSTATUS_PEND = 0x1
	// Position of BUSY field.
	DMAC_CHANNEL_CHSTATUS_BUSY_Pos = 0x1
	// Bit mask of BUSY field.
	DMAC_CHANNEL_CHSTATUS_BUSY_Msk = 0x2
	// Bit BUSY.
	DMAC_CHANNEL_CHSTATUS_BUSY = 0x2
	// Position of FERR field.
	DMAC_CHANNEL_CHSTATUS_FERR_Pos = 0x2
	// Bit mask of FERR field.
	DMAC_CHANNEL_CHSTATUS_FERR_Msk = 0x4
	// Bit FERR.
	DMAC_CHANNEL_CHSTATUS_FERR = 0x4
	// Position of CRCERR field.
	DMAC_CHANNEL_CHSTATUS_CRCERR_Pos = 0x3
	// Bit mask of CRCERR field.
	DMAC_CHANNEL_CHSTATUS_CRCERR_Msk = 0x8
	// Bit CRCERR.
	DMAC_CHANNEL_CHSTATUS_CRCERR = 0x8
)

// Constants for DSU: Device Service Unit
const (
	// CTRL: Control
	// Position of SWRST field.
	DSU_CTRL_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	DSU_CTRL_SWRST_Msk = 0x1
	// Bit SWRST.
	DSU_CTRL_SWRST = 0x1
	// Position of CRC field.
	DSU_CTRL_CRC_Pos = 0x2
	// Bit mask of CRC field.
	DSU_CTRL_CRC_Msk = 0x4
	// Bit CRC.
	DSU_CTRL_CRC = 0x4
	// Position of MBIST field.
	DSU_CTRL_MBIST_Pos = 0x3
	// Bit mask of MBIST field.
	DSU_CTRL_MBIST_Msk = 0x8
	// Bit MBIST.
	DSU_CTRL_MBIST = 0x8
	// Position of CE field.
	DSU_CTRL_CE_Pos = 0x4
	// Bit mask of CE field.
	DSU_CTRL_CE_Msk = 0x10
	// Bit CE.
	DSU_CTRL_CE = 0x10
	// Position of ARR field.
	DSU_CTRL_ARR_Pos = 0x6
	// Bit mask of ARR field.
	DSU_CTRL_ARR_Msk = 0x40
	// Bit ARR.
	DSU_CTRL_ARR = 0x40
	// Position of SMSA field.
	DSU_CTRL_SMSA_Pos = 0x7
	// Bit mask of SMSA field.
	DSU_CTRL_SMSA_Msk = 0x80
	// Bit SMSA.
	DSU_CTRL_SMSA = 0x80

	// STATUSA: Status A
	// Position of DONE field.
	DSU_STATUSA_DONE_Pos = 0x0
	// Bit mask of DONE field.
	DSU_STATUSA_DONE_Msk = 0x1
	// Bit DONE.
	DSU_STATUSA_DONE = 0x1
	// Position of CRSTEXT field.
	DSU_STATUSA_CRSTEXT_Pos = 0x1
	// Bit mask of CRSTEXT field.
	DSU_STATUSA_CRSTEXT_Msk = 0x2
	// Bit CRSTEXT.
	DSU_STATUSA_CRSTEXT = 0x2
	// Position of BERR field.
	DSU_STATUSA_BERR_Pos = 0x2
	// Bit mask of BERR field.
	DSU_STATUSA_BERR_Msk = 0x4
	// Bit BERR.
	DSU_STATUSA_BERR = 0x4
	// Position of FAIL field.
	DSU_STATUSA_FAIL_Pos = 0x3
	// Bit mask of FAIL field.
	DSU_STATUSA_FAIL_Msk = 0x8
	// Bit FAIL.
	DSU_STATUSA_FAIL = 0x8
	// Position of PERR field.
	DSU_STATUSA_PERR_Pos = 0x4
	// Bit mask of PERR field.
	DSU_STATUSA_PERR_Msk = 0x10
	// Bit PERR.
	DSU_STATUSA_PERR = 0x10

	// STATUSB: Status B
	// Position of PROT field.
	DSU_STATUSB_PROT_Pos = 0x0
	// Bit mask of PROT field.
	DSU_STATUSB_PROT_Msk = 0x1
	// Bit PROT.
	DSU_STATUSB_PROT = 0x1
	// Position of DBGPRES field.
	DSU_STATUSB_DBGPRES_Pos = 0x1
	// Bit mask of DBGPRES field.
	DSU_STATUSB_DBGPRES_Msk = 0x2
	// Bit DBGPRES.
	DSU_STATUSB_DBGPRES = 0x2
	// Position of DCCD0 field.
	DSU_STATUSB_DCCD0_Pos = 0x2
	// Bit mask of DCCD0 field.
	DSU_STATUSB_DCCD0_Msk = 0x4
	// Bit DCCD0.
	DSU_STATUSB_DCCD0 = 0x4
	// Position of DCCD1 field.
	DSU_STATUSB_DCCD1_Pos = 0x3
	// Bit mask of DCCD1 field.
	DSU_STATUSB_DCCD1_Msk = 0x8
	// Bit DCCD1.
	DSU_STATUSB_DCCD1 = 0x8
	// Position of HPE field.
	DSU_STATUSB_HPE_Pos = 0x4
	// Bit mask of HPE field.
	DSU_STATUSB_HPE_Msk = 0x10
	// Bit HPE.
	DSU_STATUSB_HPE = 0x10
	// Position of CELCK field.
	DSU_STATUSB_CELCK_Pos = 0x5
	// Bit mask of CELCK field.
	DSU_STATUSB_CELCK_Msk = 0x20
	// Bit CELCK.
	DSU_STATUSB_CELCK = 0x20
	// Position of TDCCD0 field.
	DSU_STATUSB_TDCCD0_Pos = 0x6
	// Bit mask of TDCCD0 field.
	DSU_STATUSB_TDCCD0_Msk = 0x40
	// Bit TDCCD0.
	DSU_STATUSB_TDCCD0 = 0x40
	// Position of TDCCD1 field.
	DSU_STATUSB_TDCCD1_Pos = 0x7
	// Bit mask of TDCCD1 field.
	DSU_STATUSB_TDCCD1_Msk = 0x80
	// Bit TDCCD1.
	DSU_STATUSB_TDCCD1 = 0x80

	// ADDR: Address
	// Position of AMOD field.
	DSU_ADDR_AMOD_Pos = 0x0
	// Bit mask of AMOD field.
	DSU_ADDR_AMOD_Msk = 0x3
	// Position of ADDR field.
	DSU_ADDR_ADDR_Pos = 0x2
	// Bit mask of ADDR field.
	DSU_ADDR_ADDR_Msk = 0xfffffffc

	// LENGTH: Length
	// Position of LENGTH field.
	DSU_LENGTH_LENGTH_Pos = 0x2
	// Bit mask of LENGTH field.
	DSU_LENGTH_LENGTH_Msk = 0xfffffffc

	// DATA: Data
	// Position of DATA field.
	DSU_DATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	DSU_DATA_DATA_Msk = 0xffffffff

	// DCC: Debug Communication Channel n
	// Position of DATA field.
	DSU_DCC_DATA_Pos = 0x0
	// Bit mask of DATA field.
	DSU_DCC_DATA_Msk = 0xffffffff

	// DID: Device Identification
	// Position of DEVSEL field.
	DSU_DID_DEVSEL_Pos = 0x0
	// Bit mask of DEVSEL field.
	DSU_DID_DEVSEL_Msk = 0xff
	// Position of REVISION field.
	DSU_DID_REVISION_Pos = 0x8
	// Bit mask of REVISION field.
	DSU_DID_REVISION_Msk = 0xf00
	// Position of DIE field.
	DSU_DID_DIE_Pos = 0xc
	// Bit mask of DIE field.
	DSU_DID_DIE_Msk = 0xf000
	// Position of SERIES field.
	DSU_DID_SERIES_Pos = 0x10
	// Bit mask of SERIES field.
	DSU_DID_SERIES_Msk = 0x3f0000
	// Cortex-M0+ processor, basic feature set
	DSU_DID_SERIES_0 = 0x0
	// Cortex-M0+ processor, USB
	DSU_DID_SERIES_1 = 0x1
	// Position of FAMILY field.
	DSU_DID_FAMILY_Pos = 0x17
	// Bit mask of FAMILY field.
	DSU_DID_FAMILY_Msk = 0xf800000
	// General purpose microcontroller
	DSU_DID_FAMILY_0 = 0x0
	// PicoPower
	DSU_DID_FAMILY_1 = 0x1
	// Position of PROCESSOR field.
	DSU_DID_PROCESSOR_Pos = 0x1c
	// Bit mask of PROCESSOR field.
	DSU_DID_PROCESSOR_Msk = 0xf0000000
	// Cortex-M0+
	DSU_DID_PROCESSOR_CM0P = 0x1
	// Cortex-M23
	DSU_DID_PROCESSOR_CM23 = 0x2
	// Cortex-M3
	DSU_DID_PROCESSOR_CM3 = 0x3
	// Cortex-M4
	DSU_DID_PROCESSOR_CM4 = 0x5
	// Cortex-M4 with FPU
	DSU_DID_PROCESSOR_CM4F = 0x6
	// Cortex-M33
	DSU_DID_PROCESSOR_CM33 = 0x7

	// CFG: Configuration
	// Position of LQOS field.
	DSU_CFG_LQOS_Pos = 0x0
	// Bit mask of LQOS field.
	DSU_CFG_LQOS_Msk = 0x3
	// Position of DCCDMALEVEL field.
	DSU_CFG_DCCDMALEVEL_Pos = 0x2
	// Bit mask of DCCDMALEVEL field.
	DSU_CFG_DCCDMALEVEL_Msk = 0xc
	// Trigger rises when DCC is empty
	DSU_CFG_DCCDMALEVEL_EMPTY = 0x0
	// Trigger rises when DCC is full
	DSU_CFG_DCCDMALEVEL_FULL = 0x1
	// Position of ETBRAMEN field.
	DSU_CFG_ETBRAMEN_Pos = 0x4
	// Bit mask of ETBRAMEN field.
	DSU_CFG_ETBRAMEN_Msk = 0x10
	// Bit ETBRAMEN.
	DSU_CFG_ETBRAMEN = 0x10

	// DCFG: Device Configuration
	// Position of DCFG field.
	DSU_DCFG_DCFG_Pos = 0x0
	// Bit mask of DCFG field.
	DSU_DCFG_DCFG_Msk = 0xffffffff

	// ENTRY0: CoreSight ROM Table Entry 0
	// Position of EPRES field.
	DSU_ENTRY0_EPRES_Pos = 0x0
	// Bit mask of EPRES field.
	DSU_ENTRY0_EPRES_Msk = 0x1
	// Bit EPRES.
	DSU_ENTRY0_EPRES = 0x1
	// Position of FMT field.
	DSU_ENTRY0_FMT_Pos = 0x1
	// Bit mask of FMT field.
	DSU_ENTRY0_FMT_Msk = 0x2
	// Bit FMT.
	DSU_ENTRY0_FMT = 0x2
	// Position of ADDOFF field.
	DSU_ENTRY0_ADDOFF_Pos = 0xc
	// Bit mask of ADDOFF field.
	DSU_ENTRY0_ADDOFF_Msk = 0xfffff000

	// END: CoreSight ROM Table End
	// Position of END field.
	DSU_END_END_Pos = 0x0
	// Bit mask of END field.
	DSU_END_END_Msk = 0xffffffff

	// MEMTYPE: CoreSight ROM Table Memory Type
	// Position of SMEMP field.
	DSU_MEMTYPE_SMEMP_Pos = 0x0
	// Bit mask of SMEMP field.
	DSU_MEMTYPE_SMEMP_Msk = 0x1
	// Bit SMEMP.
	DSU_MEMTYPE_SMEMP = 0x1

	// PID4: Peripheral Identification 4
	// Position of JEPCC field.
	DSU_PID4_JEPCC_Pos = 0x0
	// Bit mask of JEPCC field.
	DSU_PID4_JEPCC_Msk = 0xf
	// Position of FKBC field.
	DSU_PID4_FKBC_Pos = 0x4
	// Bit mask of FKBC field.
	DSU_PID4_FKBC_Msk = 0xf0

	// PID0: Peripheral Identification 0
	// Position of PARTNBL field.
	DSU_PID0_PARTNBL_Pos = 0x0
	// Bit mask of PARTNBL field.
	DSU_PID0_PARTNBL_Msk = 0xff

	// PID1: Peripheral Identification 1
	// Position of PARTNBH field.
	DSU_PID1_PARTNBH_Pos = 0x0
	// Bit mask of PARTNBH field.
	DSU_PID1_PARTNBH_Msk = 0xf
	// Position of JEPIDCL field.
	DSU_PID1_JEPIDCL_Pos = 0x4
	// Bit mask of JEPIDCL field.
	DSU_PID1_JEPIDCL_Msk = 0xf0

	// PID2: Peripheral Identification 2
	// Position of JEPIDCH field.
	DSU_PID2_JEPIDCH_Pos = 0x0
	// Bit mask of JEPIDCH field.
	DSU_PID2_JEPIDCH_Msk = 0x7
	// Position of JEPU field.
	DSU_PID2_JEPU_Pos = 0x3
	// Bit mask of JEPU field.
	DSU_PID2_JEPU_Msk = 0x8
	// Bit JEPU.
	DSU_PID2_JEPU = 0x8
	// Position of REVISION field.
	DSU_PID2_REVISION_Pos = 0x4
	// Bit mask of REVISION field.
	DSU_PID2_REVISION_Msk = 0xf0

	// PID3: Peripheral Identification 3
	// Position of CUSMOD field.
	DSU_PID3_CUSMOD_Pos = 0x0
	// Bit mask of CUSMOD field.
	DSU_PID3_CUSMOD_Msk = 0xf
	// Position of REVAND field.
	DSU_PID3_REVAND_Pos = 0x4
	// Bit mask of REVAND field.
	DSU_PID3_REVAND_Msk = 0xf0

	// CID0: Component Identification 0
	// Position of PREAMBLEB0 field.
	DSU_CID0_PREAMBLEB0_Pos = 0x0
	// Bit mask of PREAMBLEB0 field.
	DSU_CID0_PREAMBLEB0_Msk = 0xff

	// CID1: Component Identification 1
	// Position of PREAMBLE field.
	DSU_CID1_PREAMBLE_Pos = 0x0
	// Bit mask of PREAMBLE field.
	DSU_CID1_PREAMBLE_Msk = 0xf
	// Position of CCLASS field.
	DSU_CID1_CCLASS_Pos = 0x4
	// Bit mask of CCLASS field.
	DSU_CID1_CCLASS_Msk = 0xf0

	// CID2: Component Identification 2
	// Position of PREAMBLEB2 field.
	DSU_CID2_PREAMBLEB2_Pos = 0x0
	// Bit mask of PREAMBLEB2 field.
	DSU_CID2_PREAMBLEB2_Msk = 0xff

	// CID3: Component Identification 3
	// Position of PREAMBLEB3 field.
	DSU_CID3_PREAMBLEB3_Pos = 0x0
	// Bit mask of PREAMBLEB3 field.
	DSU_CID3_PREAMBLEB3_Msk = 0xff
)

// Constants for EIC: External Interrupt Controller
const (
	// CTRLA: Control A
	// Position of SWRST field.
	EIC_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	EIC_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	EIC_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	EIC_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	EIC_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	EIC_CTRLA_ENABLE = 0x2
	// Position of CKSEL field.
	EIC_CTRLA_CKSEL_Pos = 0x4
	// Bit mask of CKSEL field.
	EIC_CTRLA_CKSEL_Msk = 0x10
	// Bit CKSEL.
	EIC_CTRLA_CKSEL = 0x10
	// Clocked by GCLK
	EIC_CTRLA_CKSEL_CLK_GCLK = 0x0
	// Clocked by ULP32K
	EIC_CTRLA_CKSEL_CLK_ULP32K = 0x1

	// NMICTRL: Non-Maskable Interrupt Control
	// Position of NMISENSE field.
	EIC_NMICTRL_NMISENSE_Pos = 0x0
	// Bit mask of NMISENSE field.
	EIC_NMICTRL_NMISENSE_Msk = 0x7
	// No detection
	EIC_NMICTRL_NMISENSE_NONE = 0x0
	// Rising-edge detection
	EIC_NMICTRL_NMISENSE_RISE = 0x1
	// Falling-edge detection
	EIC_NMICTRL_NMISENSE_FALL = 0x2
	// Both-edges detection
	EIC_NMICTRL_NMISENSE_BOTH = 0x3
	// High-level detection
	EIC_NMICTRL_NMISENSE_HIGH = 0x4
	// Low-level detection
	EIC_NMICTRL_NMISENSE_LOW = 0x5
	// Position of NMIFILTEN field.
	EIC_NMICTRL_NMIFILTEN_Pos = 0x3
	// Bit mask of NMIFILTEN field.
	EIC_NMICTRL_NMIFILTEN_Msk = 0x8
	// Bit NMIFILTEN.
	EIC_NMICTRL_NMIFILTEN = 0x8
	// Position of NMIASYNCH field.
	EIC_NMICTRL_NMIASYNCH_Pos = 0x4
	// Bit mask of NMIASYNCH field.
	EIC_NMICTRL_NMIASYNCH_Msk = 0x10
	// Bit NMIASYNCH.
	EIC_NMICTRL_NMIASYNCH = 0x10
	// Edge detection is clock synchronously operated
	EIC_NMICTRL_NMIASYNCH_SYNC = 0x0
	// Edge detection is clock asynchronously operated
	EIC_NMICTRL_NMIASYNCH_ASYNC = 0x1

	// NMIFLAG: Non-Maskable Interrupt Flag Status and Clear
	// Position of NMI field.
	EIC_NMIFLAG_NMI_Pos = 0x0
	// Bit mask of NMI field.
	EIC_NMIFLAG_NMI_Msk = 0x1
	// Bit NMI.
	EIC_NMIFLAG_NMI = 0x1

	// SYNCBUSY: Synchronization Busy
	// Position of SWRST field.
	EIC_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	EIC_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	EIC_SYNCBUSY_SWRST = 0x1
	// Position of ENABLE field.
	EIC_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	EIC_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	EIC_SYNCBUSY_ENABLE = 0x2

	// EVCTRL: Event Control
	// Position of EXTINTEO field.
	EIC_EVCTRL_EXTINTEO_Pos = 0x0
	// Bit mask of EXTINTEO field.
	EIC_EVCTRL_EXTINTEO_Msk = 0xffff

	// INTENCLR: Interrupt Enable Clear
	// Position of EXTINT field.
	EIC_INTENCLR_EXTINT_Pos = 0x0
	// Bit mask of EXTINT field.
	EIC_INTENCLR_EXTINT_Msk = 0xffff

	// INTENSET: Interrupt Enable Set
	// Position of EXTINT field.
	EIC_INTENSET_EXTINT_Pos = 0x0
	// Bit mask of EXTINT field.
	EIC_INTENSET_EXTINT_Msk = 0xffff

	// INTFLAG: Interrupt Flag Status and Clear
	// Position of EXTINT field.
	EIC_INTFLAG_EXTINT_Pos = 0x0
	// Bit mask of EXTINT field.
	EIC_INTFLAG_EXTINT_Msk = 0xffff

	// ASYNCH: External Interrupt Asynchronous Mode
	// Position of ASYNCH field.
	EIC_ASYNCH_ASYNCH_Pos = 0x0
	// Bit mask of ASYNCH field.
	EIC_ASYNCH_ASYNCH_Msk = 0xffff
	// Edge detection is clock synchronously operated
	EIC_ASYNCH_ASYNCH_SYNC = 0x0
	// Edge detection is clock asynchronously operated
	EIC_ASYNCH_ASYNCH_ASYNC = 0x1

	// CONFIG: External Interrupt Sense Configuration
	// Position of SENSE0 field.
	EIC_CONFIG_SENSE0_Pos = 0x0
	// Bit mask of SENSE0 field.
	EIC_CONFIG_SENSE0_Msk = 0x7
	// No detection
	EIC_CONFIG_SENSE0_NONE = 0x0
	// Rising edge detection
	EIC_CONFIG_SENSE0_RISE = 0x1
	// Falling edge detection
	EIC_CONFIG_SENSE0_FALL = 0x2
	// Both edges detection
	EIC_CONFIG_SENSE0_BOTH = 0x3
	// High level detection
	EIC_CONFIG_SENSE0_HIGH = 0x4
	// Low level detection
	EIC_CONFIG_SENSE0_LOW = 0x5
	// Position of FILTEN0 field.
	EIC_CONFIG_FILTEN0_Pos = 0x3
	// Bit mask of FILTEN0 field.
	EIC_CONFIG_FILTEN0_Msk = 0x8
	// Bit FILTEN0.
	EIC_CONFIG_FILTEN0 = 0x8
	// Position of SENSE1 field.
	EIC_CONFIG_SENSE1_Pos = 0x4
	// Bit mask of SENSE1 field.
	EIC_CONFIG_SENSE1_Msk = 0x70
	// No detection
	EIC_CONFIG_SENSE1_NONE = 0x0
	// Rising edge detection
	EIC_CONFIG_SENSE1_RISE = 0x1
	// Falling edge detection
	EIC_CONFIG_SENSE1_FALL = 0x2
	// Both edges detection
	EIC_CONFIG_SENSE1_BOTH = 0x3
	// High level detection
	EIC_CONFIG_SENSE1_HIGH = 0x4
	// Low level detection
	EIC_CONFIG_SENSE1_LOW = 0x5
	// Position of FILTEN1 field.
	EIC_CONFIG_FILTEN1_Pos = 0x7
	// Bit mask of FILTEN1 field.
	EIC_CONFIG_FILTEN1_Msk = 0x80
	// Bit FILTEN1.
	EIC_CONFIG_FILTEN1 = 0x80
	// Position of SENSE2 field.
	EIC_CONFIG_SENSE2_Pos = 0x8
	// Bit mask of SENSE2 field.
	EIC_CONFIG_SENSE2_Msk = 0x700
	// No detection
	EIC_CONFIG_SENSE2_NONE = 0x0
	// Rising edge detection
	EIC_CONFIG_SENSE2_RISE = 0x1
	// Falling edge detection
	EIC_CONFIG_SENSE2_FALL = 0x2
	// Both edges detection
	EIC_CONFIG_SENSE2_BOTH = 0x3
	// High level detection
	EIC_CONFIG_SENSE2_HIGH = 0x4
	// Low level detection
	EIC_CONFIG_SENSE2_LOW = 0x5
	// Position of FILTEN2 field.
	EIC_CONFIG_FILTEN2_Pos = 0xb
	// Bit mask of FILTEN2 field.
	EIC_CONFIG_FILTEN2_Msk = 0x800
	// Bit FILTEN2.
	EIC_CONFIG_FILTEN2 = 0x800
	// Position of SENSE3 field.
	EIC_CONFIG_SENSE3_Pos = 0xc
	// Bit mask of SENSE3 field.
	EIC_CONFIG_SENSE3_Msk = 0x7000
	// No detection
	EIC_CONFIG_SENSE3_NONE = 0x0
	// Rising edge detection
	EIC_CONFIG_SENSE3_RISE = 0x1
	// Falling edge detection
	EIC_CONFIG_SENSE3_FALL = 0x2
	// Both edges detection
	EIC_CONFIG_SENSE3_BOTH = 0x3
	// High level detection
	EIC_CONFIG_SENSE3_HIGH = 0x4
	// Low level detection
	EIC_CONFIG_SENSE3_LOW = 0x5
	// Position of FILTEN3 field.
	EIC_CONFIG_FILTEN3_Pos = 0xf
	// Bit mask of FILTEN3 field.
	EIC_CONFIG_FILTEN3_Msk = 0x8000
	// Bit FILTEN3.
	EIC_CONFIG_FILTEN3 = 0x8000
	// Position of SENSE4 field.
	EIC_CONFIG_SENSE4_Pos = 0x10
	// Bit mask of SENSE4 field.
	EIC_CONFIG_SENSE4_Msk = 0x70000
	// No detection
	EIC_CONFIG_SENSE4_NONE = 0x0
	// Rising edge detection
	EIC_CONFIG_SENSE4_RISE = 0x1
	// Falling edge detection
	EIC_CONFIG_SENSE4_FALL = 0x2
	// Both edges detection
	EIC_CONFIG_SENSE4_BOTH = 0x3
	// High level detection
	EIC_CONFIG_SENSE4_HIGH = 0x4
	// Low level detection
	EIC_CONFIG_SENSE4_LOW = 0x5
	// Position of FILTEN4 field.
	EIC_CONFIG_FILTEN4_Pos = 0x13
	// Bit mask of FILTEN4 field.
	EIC_CONFIG_FILTEN4_Msk = 0x80000
	// Bit FILTEN4.
	EIC_CONFIG_FILTEN4 = 0x80000
	// Position of SENSE5 field.
	EIC_CONFIG_SENSE5_Pos = 0x14
	// Bit mask of SENSE5 field.
	EIC_CONFIG_SENSE5_Msk = 0x700000
	// No detection
	EIC_CONFIG_SENSE5_NONE = 0x0
	// Rising edge detection
	EIC_CONFIG_SENSE5_RISE = 0x1
	// Falling edge detection
	EIC_CONFIG_SENSE5_FALL = 0x2
	// Both edges detection
	EIC_CONFIG_SENSE5_BOTH = 0x3
	// High level detection
	EIC_CONFIG_SENSE5_HIGH = 0x4
	// Low level detection
	EIC_CONFIG_SENSE5_LOW = 0x5
	// Position of FILTEN5 field.
	EIC_CONFIG_FILTEN5_Pos = 0x17
	// Bit mask of FILTEN5 field.
	EIC_CONFIG_FILTEN5_Msk = 0x800000
	// Bit FILTEN5.
	EIC_CONFIG_FILTEN5 = 0x800000
	// Position of SENSE6 field.
	EIC_CONFIG_SENSE6_Pos = 0x18
	// Bit mask of SENSE6 field.
	EIC_CONFIG_SENSE6_Msk = 0x7000000
	// No detection
	EIC_CONFIG_SENSE6_NONE = 0x0
	// Rising edge detection
	EIC_CONFIG_SENSE6_RISE = 0x1
	// Falling edge detection
	EIC_CONFIG_SENSE6_FALL = 0x2
	// Both edges detection
	EIC_CONFIG_SENSE6_BOTH = 0x3
	// High level detection
	EIC_CONFIG_SENSE6_HIGH = 0x4
	// Low level detection
	EIC_CONFIG_SENSE6_LOW = 0x5
	// Position of FILTEN6 field.
	EIC_CONFIG_FILTEN6_Pos = 0x1b
	// Bit mask of FILTEN6 field.
	EIC_CONFIG_FILTEN6_Msk = 0x8000000
	// Bit FILTEN6.
	EIC_CONFIG_FILTEN6 = 0x8000000
	// Position of SENSE7 field.
	EIC_CONFIG_SENSE7_Pos = 0x1c
	// Bit mask of SENSE7 field.
	EIC_CONFIG_SENSE7_Msk = 0x70000000
	// No detection
	EIC_CONFIG_SENSE7_NONE = 0x0
	// Rising edge detection
	EIC_CONFIG_SENSE7_RISE = 0x1
	// Falling edge detection
	EIC_CONFIG_SENSE7_FALL = 0x2
	// Both edges detection
	EIC_CONFIG_SENSE7_BOTH = 0x3
	// High level detection
	EIC_CONFIG_SENSE7_HIGH = 0x4
	// Low level detection
	EIC_CONFIG_SENSE7_LOW = 0x5
	// Position of FILTEN7 field.
	EIC_CONFIG_FILTEN7_Pos = 0x1f
	// Bit mask of FILTEN7 field.
	EIC_CONFIG_FILTEN7_Msk = 0x80000000
	// Bit FILTEN7.
	EIC_CONFIG_FILTEN7 = 0x80000000

	// DEBOUNCEN: Debouncer Enable
	// Position of DEBOUNCEN field.
	EIC_DEBOUNCEN_DEBOUNCEN_Pos = 0x0
	// Bit mask of DEBOUNCEN field.
	EIC_DEBOUNCEN_DEBOUNCEN_Msk = 0xffff

	// DPRESCALER: Debouncer Prescaler
	// Position of PRESCALER0 field.
	EIC_DPRESCALER_PRESCALER0_Pos = 0x0
	// Bit mask of PRESCALER0 field.
	EIC_DPRESCALER_PRESCALER0_Msk = 0x7
	// EIC clock divided by 2
	EIC_DPRESCALER_PRESCALER0_DIV2 = 0x0
	// EIC clock divided by 4
	EIC_DPRESCALER_PRESCALER0_DIV4 = 0x1
	// EIC clock divided by 8
	EIC_DPRESCALER_PRESCALER0_DIV8 = 0x2
	// EIC clock divided by 16
	EIC_DPRESCALER_PRESCALER0_DIV16 = 0x3
	// EIC clock divided by 32
	EIC_DPRESCALER_PRESCALER0_DIV32 = 0x4
	// EIC clock divided by 64
	EIC_DPRESCALER_PRESCALER0_DIV64 = 0x5
	// EIC clock divided by 128
	EIC_DPRESCALER_PRESCALER0_DIV128 = 0x6
	// EIC clock divided by 256
	EIC_DPRESCALER_PRESCALER0_DIV256 = 0x7
	// Position of STATES0 field.
	EIC_DPRESCALER_STATES0_Pos = 0x3
	// Bit mask of STATES0 field.
	EIC_DPRESCALER_STATES0_Msk = 0x8
	// Bit STATES0.
	EIC_DPRESCALER_STATES0 = 0x8
	// 3 low frequency samples
	EIC_DPRESCALER_STATES0_LFREQ3 = 0x0
	// 7 low frequency samples
	EIC_DPRESCALER_STATES0_LFREQ7 = 0x1
	// Position of PRESCALER1 field.
	EIC_DPRESCALER_PRESCALER1_Pos = 0x4
	// Bit mask of PRESCALER1 field.
	EIC_DPRESCALER_PRESCALER1_Msk = 0x70
	// EIC clock divided by 2
	EIC_DPRESCALER_PRESCALER1_DIV2 = 0x0
	// EIC clock divided by 4
	EIC_DPRESCALER_PRESCALER1_DIV4 = 0x1
	// EIC clock divided by 8
	EIC_DPRESCALER_PRESCALER1_DIV8 = 0x2
	// EIC clock divided by 16
	EIC_DPRESCALER_PRESCALER1_DIV16 = 0x3
	// EIC clock divided by 32
	EIC_DPRESCALER_PRESCALER1_DIV32 = 0x4
	// EIC clock divided by 64
	EIC_DPRESCALER_PRESCALER1_DIV64 = 0x5
	// EIC clock divided by 128
	EIC_DPRESCALER_PRESCALER1_DIV128 = 0x6
	// EIC clock divided by 256
	EIC_DPRESCALER_PRESCALER1_DIV256 = 0x7
	// Position of STATES1 field.
	EIC_DPRESCALER_STATES1_Pos = 0x7
	// Bit mask of STATES1 field.
	EIC_DPRESCALER_STATES1_Msk = 0x80
	// Bit STATES1.
	EIC_DPRESCALER_STATES1 = 0x80
	// 3 low frequency samples
	EIC_DPRESCALER_STATES1_LFREQ3 = 0x0
	// 7 low frequency samples
	EIC_DPRESCALER_STATES1_LFREQ7 = 0x1
	// Position of TICKON field.
	EIC_DPRESCALER_TICKON_Pos = 0x10
	// Bit mask of TICKON field.
	EIC_DPRESCALER_TICKON_Msk = 0x10000
	// Bit TICKON.
	EIC_DPRESCALER_TICKON = 0x10000
	// Clocked by GCLK
	EIC_DPRESCALER_TICKON_CLK_GCLK_EIC = 0x0
	// Clocked by Low Frequency Clock
	EIC_DPRESCALER_TICKON_CLK_LFREQ = 0x1

	// PINSTATE: Pin State
	// Position of PINSTATE field.
	EIC_PINSTATE_PINSTATE_Pos = 0x0
	// Bit mask of PINSTATE field.
	EIC_PINSTATE_PINSTATE_Msk = 0xffff
)

// Constants for EVSYS: Event System Interface
const (
	// CTRLA: Control
	// Position of SWRST field.
	EVSYS_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	EVSYS_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	EVSYS_CTRLA_SWRST = 0x1

	// SWEVT: Software Event
	// Position of CHANNEL0 field.
	EVSYS_SWEVT_CHANNEL0_Pos = 0x0
	// Bit mask of CHANNEL0 field.
	EVSYS_SWEVT_CHANNEL0_Msk = 0x1
	// Bit CHANNEL0.
	EVSYS_SWEVT_CHANNEL0 = 0x1
	// Position of CHANNEL1 field.
	EVSYS_SWEVT_CHANNEL1_Pos = 0x1
	// Bit mask of CHANNEL1 field.
	EVSYS_SWEVT_CHANNEL1_Msk = 0x2
	// Bit CHANNEL1.
	EVSYS_SWEVT_CHANNEL1 = 0x2
	// Position of CHANNEL2 field.
	EVSYS_SWEVT_CHANNEL2_Pos = 0x2
	// Bit mask of CHANNEL2 field.
	EVSYS_SWEVT_CHANNEL2_Msk = 0x4
	// Bit CHANNEL2.
	EVSYS_SWEVT_CHANNEL2 = 0x4
	// Position of CHANNEL3 field.
	EVSYS_SWEVT_CHANNEL3_Pos = 0x3
	// Bit mask of CHANNEL3 field.
	EVSYS_SWEVT_CHANNEL3_Msk = 0x8
	// Bit CHANNEL3.
	EVSYS_SWEVT_CHANNEL3 = 0x8
	// Position of CHANNEL4 field.
	EVSYS_SWEVT_CHANNEL4_Pos = 0x4
	// Bit mask of CHANNEL4 field.
	EVSYS_SWEVT_CHANNEL4_Msk = 0x10
	// Bit CHANNEL4.
	EVSYS_SWEVT_CHANNEL4 = 0x10
	// Position of CHANNEL5 field.
	EVSYS_SWEVT_CHANNEL5_Pos = 0x5
	// Bit mask of CHANNEL5 field.
	EVSYS_SWEVT_CHANNEL5_Msk = 0x20
	// Bit CHANNEL5.
	EVSYS_SWEVT_CHANNEL5 = 0x20
	// Position of CHANNEL6 field.
	EVSYS_SWEVT_CHANNEL6_Pos = 0x6
	// Bit mask of CHANNEL6 field.
	EVSYS_SWEVT_CHANNEL6_Msk = 0x40
	// Bit CHANNEL6.
	EVSYS_SWEVT_CHANNEL6 = 0x40
	// Position of CHANNEL7 field.
	EVSYS_SWEVT_CHANNEL7_Pos = 0x7
	// Bit mask of CHANNEL7 field.
	EVSYS_SWEVT_CHANNEL7_Msk = 0x80
	// Bit CHANNEL7.
	EVSYS_SWEVT_CHANNEL7 = 0x80
	// Position of CHANNEL8 field.
	EVSYS_SWEVT_CHANNEL8_Pos = 0x8
	// Bit mask of CHANNEL8 field.
	EVSYS_SWEVT_CHANNEL8_Msk = 0x100
	// Bit CHANNEL8.
	EVSYS_SWEVT_CHANNEL8 = 0x100
	// Position of CHANNEL9 field.
	EVSYS_SWEVT_CHANNEL9_Pos = 0x9
	// Bit mask of CHANNEL9 field.
	EVSYS_SWEVT_CHANNEL9_Msk = 0x200
	// Bit CHANNEL9.
	EVSYS_SWEVT_CHANNEL9 = 0x200
	// Position of CHANNEL10 field.
	EVSYS_SWEVT_CHANNEL10_Pos = 0xa
	// Bit mask of CHANNEL10 field.
	EVSYS_SWEVT_CHANNEL10_Msk = 0x400
	// Bit CHANNEL10.
	EVSYS_SWEVT_CHANNEL10 = 0x400
	// Position of CHANNEL11 field.
	EVSYS_SWEVT_CHANNEL11_Pos = 0xb
	// Bit mask of CHANNEL11 field.
	EVSYS_SWEVT_CHANNEL11_Msk = 0x800
	// Bit CHANNEL11.
	EVSYS_SWEVT_CHANNEL11 = 0x800
	// Position of CHANNEL12 field.
	EVSYS_SWEVT_CHANNEL12_Pos = 0xc
	// Bit mask of CHANNEL12 field.
	EVSYS_SWEVT_CHANNEL12_Msk = 0x1000
	// Bit CHANNEL12.
	EVSYS_SWEVT_CHANNEL12 = 0x1000
	// Position of CHANNEL13 field.
	EVSYS_SWEVT_CHANNEL13_Pos = 0xd
	// Bit mask of CHANNEL13 field.
	EVSYS_SWEVT_CHANNEL13_Msk = 0x2000
	// Bit CHANNEL13.
	EVSYS_SWEVT_CHANNEL13 = 0x2000
	// Position of CHANNEL14 field.
	EVSYS_SWEVT_CHANNEL14_Pos = 0xe
	// Bit mask of CHANNEL14 field.
	EVSYS_SWEVT_CHANNEL14_Msk = 0x4000
	// Bit CHANNEL14.
	EVSYS_SWEVT_CHANNEL14 = 0x4000
	// Position of CHANNEL15 field.
	EVSYS_SWEVT_CHANNEL15_Pos = 0xf
	// Bit mask of CHANNEL15 field.
	EVSYS_SWEVT_CHANNEL15_Msk = 0x8000
	// Bit CHANNEL15.
	EVSYS_SWEVT_CHANNEL15 = 0x8000
	// Position of CHANNEL16 field.
	EVSYS_SWEVT_CHANNEL16_Pos = 0x10
	// Bit mask of CHANNEL16 field.
	EVSYS_SWEVT_CHANNEL16_Msk = 0x10000
	// Bit CHANNEL16.
	EVSYS_SWEVT_CHANNEL16 = 0x10000
	// Position of CHANNEL17 field.
	EVSYS_SWEVT_CHANNEL17_Pos = 0x11
	// Bit mask of CHANNEL17 field.
	EVSYS_SWEVT_CHANNEL17_Msk = 0x20000
	// Bit CHANNEL17.
	EVSYS_SWEVT_CHANNEL17 = 0x20000
	// Position of CHANNEL18 field.
	EVSYS_SWEVT_CHANNEL18_Pos = 0x12
	// Bit mask of CHANNEL18 field.
	EVSYS_SWEVT_CHANNEL18_Msk = 0x40000
	// Bit CHANNEL18.
	EVSYS_SWEVT_CHANNEL18 = 0x40000
	// Position of CHANNEL19 field.
	EVSYS_SWEVT_CHANNEL19_Pos = 0x13
	// Bit mask of CHANNEL19 field.
	EVSYS_SWEVT_CHANNEL19_Msk = 0x80000
	// Bit CHANNEL19.
	EVSYS_SWEVT_CHANNEL19 = 0x80000
	// Position of CHANNEL20 field.
	EVSYS_SWEVT_CHANNEL20_Pos = 0x14
	// Bit mask of CHANNEL20 field.
	EVSYS_SWEVT_CHANNEL20_Msk = 0x100000
	// Bit CHANNEL20.
	EVSYS_SWEVT_CHANNEL20 = 0x100000
	// Position of CHANNEL21 field.
	EVSYS_SWEVT_CHANNEL21_Pos = 0x15
	// Bit mask of CHANNEL21 field.
	EVSYS_SWEVT_CHANNEL21_Msk = 0x200000
	// Bit CHANNEL21.
	EVSYS_SWEVT_CHANNEL21 = 0x200000
	// Position of CHANNEL22 field.
	EVSYS_SWEVT_CHANNEL22_Pos = 0x16
	// Bit mask of CHANNEL22 field.
	EVSYS_SWEVT_CHANNEL22_Msk = 0x400000
	// Bit CHANNEL22.
	EVSYS_SWEVT_CHANNEL22 = 0x400000
	// Position of CHANNEL23 field.
	EVSYS_SWEVT_CHANNEL23_Pos = 0x17
	// Bit mask of CHANNEL23 field.
	EVSYS_SWEVT_CHANNEL23_Msk = 0x800000
	// Bit CHANNEL23.
	EVSYS_SWEVT_CHANNEL23 = 0x800000
	// Position of CHANNEL24 field.
	EVSYS_SWEVT_CHANNEL24_Pos = 0x18
	// Bit mask of CHANNEL24 field.
	EVSYS_SWEVT_CHANNEL24_Msk = 0x1000000
	// Bit CHANNEL24.
	EVSYS_SWEVT_CHANNEL24 = 0x1000000
	// Position of CHANNEL25 field.
	EVSYS_SWEVT_CHANNEL25_Pos = 0x19
	// Bit mask of CHANNEL25 field.
	EVSYS_SWEVT_CHANNEL25_Msk = 0x2000000
	// Bit CHANNEL25.
	EVSYS_SWEVT_CHANNEL25 = 0x2000000
	// Position of CHANNEL26 field.
	EVSYS_SWEVT_CHANNEL26_Pos = 0x1a
	// Bit mask of CHANNEL26 field.
	EVSYS_SWEVT_CHANNEL26_Msk = 0x4000000
	// Bit CHANNEL26.
	EVSYS_SWEVT_CHANNEL26 = 0x4000000
	// Position of CHANNEL27 field.
	EVSYS_SWEVT_CHANNEL27_Pos = 0x1b
	// Bit mask of CHANNEL27 field.
	EVSYS_SWEVT_CHANNEL27_Msk = 0x8000000
	// Bit CHANNEL27.
	EVSYS_SWEVT_CHANNEL27 = 0x8000000
	// Position of CHANNEL28 field.
	EVSYS_SWEVT_CHANNEL28_Pos = 0x1c
	// Bit mask of CHANNEL28 field.
	EVSYS_SWEVT_CHANNEL28_Msk = 0x10000000
	// Bit CHANNEL28.
	EVSYS_SWEVT_CHANNEL28 = 0x10000000
	// Position of CHANNEL29 field.
	EVSYS_SWEVT_CHANNEL29_Pos = 0x1d
	// Bit mask of CHANNEL29 field.
	EVSYS_SWEVT_CHANNEL29_Msk = 0x20000000
	// Bit CHANNEL29.
	EVSYS_SWEVT_CHANNEL29 = 0x20000000
	// Position of CHANNEL30 field.
	EVSYS_SWEVT_CHANNEL30_Pos = 0x1e
	// Bit mask of CHANNEL30 field.
	EVSYS_SWEVT_CHANNEL30_Msk = 0x40000000
	// Bit CHANNEL30.
	EVSYS_SWEVT_CHANNEL30 = 0x40000000
	// Position of CHANNEL31 field.
	EVSYS_SWEVT_CHANNEL31_Pos = 0x1f
	// Bit mask of CHANNEL31 field.
	EVSYS_SWEVT_CHANNEL31_Msk = 0x80000000
	// Bit CHANNEL31.
	EVSYS_SWEVT_CHANNEL31 = 0x80000000

	// PRICTRL: Priority Control
	// Position of PRI field.
	EVSYS_PRICTRL_PRI_Pos = 0x0
	// Bit mask of PRI field.
	EVSYS_PRICTRL_PRI_Msk = 0xf
	// Position of RREN field.
	EVSYS_PRICTRL_RREN_Pos = 0x7
	// Bit mask of RREN field.
	EVSYS_PRICTRL_RREN_Msk = 0x80
	// Bit RREN.
	EVSYS_PRICTRL_RREN = 0x80

	// INTPEND: Channel Pending Interrupt
	// Position of ID field.
	EVSYS_INTPEND_ID_Pos = 0x0
	// Bit mask of ID field.
	EVSYS_INTPEND_ID_Msk = 0xf
	// Position of OVR field.
	EVSYS_INTPEND_OVR_Pos = 0x8
	// Bit mask of OVR field.
	EVSYS_INTPEND_OVR_Msk = 0x100
	// Bit OVR.
	EVSYS_INTPEND_OVR = 0x100
	// Position of EVD field.
	EVSYS_INTPEND_EVD_Pos = 0x9
	// Bit mask of EVD field.
	EVSYS_INTPEND_EVD_Msk = 0x200
	// Bit EVD.
	EVSYS_INTPEND_EVD = 0x200
	// Position of READY field.
	EVSYS_INTPEND_READY_Pos = 0xe
	// Bit mask of READY field.
	EVSYS_INTPEND_READY_Msk = 0x4000
	// Bit READY.
	EVSYS_INTPEND_READY = 0x4000
	// Position of BUSY field.
	EVSYS_INTPEND_BUSY_Pos = 0xf
	// Bit mask of BUSY field.
	EVSYS_INTPEND_BUSY_Msk = 0x8000
	// Bit BUSY.
	EVSYS_INTPEND_BUSY = 0x8000

	// INTSTATUS: Interrupt Status
	// Position of CHINT0 field.
	EVSYS_INTSTATUS_CHINT0_Pos = 0x0
	// Bit mask of CHINT0 field.
	EVSYS_INTSTATUS_CHINT0_Msk = 0x1
	// Bit CHINT0.
	EVSYS_INTSTATUS_CHINT0 = 0x1
	// Position of CHINT1 field.
	EVSYS_INTSTATUS_CHINT1_Pos = 0x1
	// Bit mask of CHINT1 field.
	EVSYS_INTSTATUS_CHINT1_Msk = 0x2
	// Bit CHINT1.
	EVSYS_INTSTATUS_CHINT1 = 0x2
	// Position of CHINT2 field.
	EVSYS_INTSTATUS_CHINT2_Pos = 0x2
	// Bit mask of CHINT2 field.
	EVSYS_INTSTATUS_CHINT2_Msk = 0x4
	// Bit CHINT2.
	EVSYS_INTSTATUS_CHINT2 = 0x4
	// Position of CHINT3 field.
	EVSYS_INTSTATUS_CHINT3_Pos = 0x3
	// Bit mask of CHINT3 field.
	EVSYS_INTSTATUS_CHINT3_Msk = 0x8
	// Bit CHINT3.
	EVSYS_INTSTATUS_CHINT3 = 0x8
	// Position of CHINT4 field.
	EVSYS_INTSTATUS_CHINT4_Pos = 0x4
	// Bit mask of CHINT4 field.
	EVSYS_INTSTATUS_CHINT4_Msk = 0x10
	// Bit CHINT4.
	EVSYS_INTSTATUS_CHINT4 = 0x10
	// Position of CHINT5 field.
	EVSYS_INTSTATUS_CHINT5_Pos = 0x5
	// Bit mask of CHINT5 field.
	EVSYS_INTSTATUS_CHINT5_Msk = 0x20
	// Bit CHINT5.
	EVSYS_INTSTATUS_CHINT5 = 0x20
	// Position of CHINT6 field.
	EVSYS_INTSTATUS_CHINT6_Pos = 0x6
	// Bit mask of CHINT6 field.
	EVSYS_INTSTATUS_CHINT6_Msk = 0x40
	// Bit CHINT6.
	EVSYS_INTSTATUS_CHINT6 = 0x40
	// Position of CHINT7 field.
	EVSYS_INTSTATUS_CHINT7_Pos = 0x7
	// Bit mask of CHINT7 field.
	EVSYS_INTSTATUS_CHINT7_Msk = 0x80
	// Bit CHINT7.
	EVSYS_INTSTATUS_CHINT7 = 0x80
	// Position of CHINT8 field.
	EVSYS_INTSTATUS_CHINT8_Pos = 0x8
	// Bit mask of CHINT8 field.
	EVSYS_INTSTATUS_CHINT8_Msk = 0x100
	// Bit CHINT8.
	EVSYS_INTSTATUS_CHINT8 = 0x100
	// Position of CHINT9 field.
	EVSYS_INTSTATUS_CHINT9_Pos = 0x9
	// Bit mask of CHINT9 field.
	EVSYS_INTSTATUS_CHINT9_Msk = 0x200
	// Bit CHINT9.
	EVSYS_INTSTATUS_CHINT9 = 0x200
	// Position of CHINT10 field.
	EVSYS_INTSTATUS_CHINT10_Pos = 0xa
	// Bit mask of CHINT10 field.
	EVSYS_INTSTATUS_CHINT10_Msk = 0x400
	// Bit CHINT10.
	EVSYS_INTSTATUS_CHINT10 = 0x400
	// Position of CHINT11 field.
	EVSYS_INTSTATUS_CHINT11_Pos = 0xb
	// Bit mask of CHINT11 field.
	EVSYS_INTSTATUS_CHINT11_Msk = 0x800
	// Bit CHINT11.
	EVSYS_INTSTATUS_CHINT11 = 0x800

	// BUSYCH: Busy Channels
	// Position of BUSYCH0 field.
	EVSYS_BUSYCH_BUSYCH0_Pos = 0x0
	// Bit mask of BUSYCH0 field.
	EVSYS_BUSYCH_BUSYCH0_Msk = 0x1
	// Bit BUSYCH0.
	EVSYS_BUSYCH_BUSYCH0 = 0x1
	// Position of BUSYCH1 field.
	EVSYS_BUSYCH_BUSYCH1_Pos = 0x1
	// Bit mask of BUSYCH1 field.
	EVSYS_BUSYCH_BUSYCH1_Msk = 0x2
	// Bit BUSYCH1.
	EVSYS_BUSYCH_BUSYCH1 = 0x2
	// Position of BUSYCH2 field.
	EVSYS_BUSYCH_BUSYCH2_Pos = 0x2
	// Bit mask of BUSYCH2 field.
	EVSYS_BUSYCH_BUSYCH2_Msk = 0x4
	// Bit BUSYCH2.
	EVSYS_BUSYCH_BUSYCH2 = 0x4
	// Position of BUSYCH3 field.
	EVSYS_BUSYCH_BUSYCH3_Pos = 0x3
	// Bit mask of BUSYCH3 field.
	EVSYS_BUSYCH_BUSYCH3_Msk = 0x8
	// Bit BUSYCH3.
	EVSYS_BUSYCH_BUSYCH3 = 0x8
	// Position of BUSYCH4 field.
	EVSYS_BUSYCH_BUSYCH4_Pos = 0x4
	// Bit mask of BUSYCH4 field.
	EVSYS_BUSYCH_BUSYCH4_Msk = 0x10
	// Bit BUSYCH4.
	EVSYS_BUSYCH_BUSYCH4 = 0x10
	// Position of BUSYCH5 field.
	EVSYS_BUSYCH_BUSYCH5_Pos = 0x5
	// Bit mask of BUSYCH5 field.
	EVSYS_BUSYCH_BUSYCH5_Msk = 0x20
	// Bit BUSYCH5.
	EVSYS_BUSYCH_BUSYCH5 = 0x20
	// Position of BUSYCH6 field.
	EVSYS_BUSYCH_BUSYCH6_Pos = 0x6
	// Bit mask of BUSYCH6 field.
	EVSYS_BUSYCH_BUSYCH6_Msk = 0x40
	// Bit BUSYCH6.
	EVSYS_BUSYCH_BUSYCH6 = 0x40
	// Position of BUSYCH7 field.
	EVSYS_BUSYCH_BUSYCH7_Pos = 0x7
	// Bit mask of BUSYCH7 field.
	EVSYS_BUSYCH_BUSYCH7_Msk = 0x80
	// Bit BUSYCH7.
	EVSYS_BUSYCH_BUSYCH7 = 0x80
	// Position of BUSYCH8 field.
	EVSYS_BUSYCH_BUSYCH8_Pos = 0x8
	// Bit mask of BUSYCH8 field.
	EVSYS_BUSYCH_BUSYCH8_Msk = 0x100
	// Bit BUSYCH8.
	EVSYS_BUSYCH_BUSYCH8 = 0x100
	// Position of BUSYCH9 field.
	EVSYS_BUSYCH_BUSYCH9_Pos = 0x9
	// Bit mask of BUSYCH9 field.
	EVSYS_BUSYCH_BUSYCH9_Msk = 0x200
	// Bit BUSYCH9.
	EVSYS_BUSYCH_BUSYCH9 = 0x200
	// Position of BUSYCH10 field.
	EVSYS_BUSYCH_BUSYCH10_Pos = 0xa
	// Bit mask of BUSYCH10 field.
	EVSYS_BUSYCH_BUSYCH10_Msk = 0x400
	// Bit BUSYCH10.
	EVSYS_BUSYCH_BUSYCH10 = 0x400
	// Position of BUSYCH11 field.
	EVSYS_BUSYCH_BUSYCH11_Pos = 0xb
	// Bit mask of BUSYCH11 field.
	EVSYS_BUSYCH_BUSYCH11_Msk = 0x800
	// Bit BUSYCH11.
	EVSYS_BUSYCH_BUSYCH11 = 0x800

	// READYUSR: Ready Users
	// Position of READYUSR0 field.
	EVSYS_READYUSR_READYUSR0_Pos = 0x0
	// Bit mask of READYUSR0 field.
	EVSYS_READYUSR_READYUSR0_Msk = 0x1
	// Bit READYUSR0.
	EVSYS_READYUSR_READYUSR0 = 0x1
	// Position of READYUSR1 field.
	EVSYS_READYUSR_READYUSR1_Pos = 0x1
	// Bit mask of READYUSR1 field.
	EVSYS_READYUSR_READYUSR1_Msk = 0x2
	// Bit READYUSR1.
	EVSYS_READYUSR_READYUSR1 = 0x2
	// Position of READYUSR2 field.
	EVSYS_READYUSR_READYUSR2_Pos = 0x2
	// Bit mask of READYUSR2 field.
	EVSYS_READYUSR_READYUSR2_Msk = 0x4
	// Bit READYUSR2.
	EVSYS_READYUSR_READYUSR2 = 0x4
	// Position of READYUSR3 field.
	EVSYS_READYUSR_READYUSR3_Pos = 0x3
	// Bit mask of READYUSR3 field.
	EVSYS_READYUSR_READYUSR3_Msk = 0x8
	// Bit READYUSR3.
	EVSYS_READYUSR_READYUSR3 = 0x8
	// Position of READYUSR4 field.
	EVSYS_READYUSR_READYUSR4_Pos = 0x4
	// Bit mask of READYUSR4 field.
	EVSYS_READYUSR_READYUSR4_Msk = 0x10
	// Bit READYUSR4.
	EVSYS_READYUSR_READYUSR4 = 0x10
	// Position of READYUSR5 field.
	EVSYS_READYUSR_READYUSR5_Pos = 0x5
	// Bit mask of READYUSR5 field.
	EVSYS_READYUSR_READYUSR5_Msk = 0x20
	// Bit READYUSR5.
	EVSYS_READYUSR_READYUSR5 = 0x20
	// Position of READYUSR6 field.
	EVSYS_READYUSR_READYUSR6_Pos = 0x6
	// Bit mask of READYUSR6 field.
	EVSYS_READYUSR_READYUSR6_Msk = 0x40
	// Bit READYUSR6.
	EVSYS_READYUSR_READYUSR6 = 0x40
	// Position of READYUSR7 field.
	EVSYS_READYUSR_READYUSR7_Pos = 0x7
	// Bit mask of READYUSR7 field.
	EVSYS_READYUSR_READYUSR7_Msk = 0x80
	// Bit READYUSR7.
	EVSYS_READYUSR_READYUSR7 = 0x80
	// Position of READYUSR8 field.
	EVSYS_READYUSR_READYUSR8_Pos = 0x8
	// Bit mask of READYUSR8 field.
	EVSYS_READYUSR_READYUSR8_Msk = 0x100
	// Bit READYUSR8.
	EVSYS_READYUSR_READYUSR8 = 0x100
	// Position of READYUSR9 field.
	EVSYS_READYUSR_READYUSR9_Pos = 0x9
	// Bit mask of READYUSR9 field.
	EVSYS_READYUSR_READYUSR9_Msk = 0x200
	// Bit READYUSR9.
	EVSYS_READYUSR_READYUSR9 = 0x200
	// Position of READYUSR10 field.
	EVSYS_READYUSR_READYUSR10_Pos = 0xa
	// Bit mask of READYUSR10 field.
	EVSYS_READYUSR_READYUSR10_Msk = 0x400
	// Bit READYUSR10.
	EVSYS_READYUSR_READYUSR10 = 0x400
	// Position of READYUSR11 field.
	EVSYS_READYUSR_READYUSR11_Pos = 0xb
	// Bit mask of READYUSR11 field.
	EVSYS_READYUSR_READYUSR11_Msk = 0x800
	// Bit READYUSR11.
	EVSYS_READYUSR_READYUSR11 = 0x800

	// CHANNEL.CHANNEL: Channel n Control
	// Position of EVGEN field.
	EVSYS_CHANNEL_CHANNEL_EVGEN_Pos = 0x0
	// Bit mask of EVGEN field.
	EVSYS_CHANNEL_CHANNEL_EVGEN_Msk = 0x7f
	// Position of PATH field.
	EVSYS_CHANNEL_CHANNEL_PATH_Pos = 0x8
	// Bit mask of PATH field.
	EVSYS_CHANNEL_CHANNEL_PATH_Msk = 0x300
	// Synchronous path
	EVSYS_CHANNEL_CHANNEL_PATH_SYNCHRONOUS = 0x0
	// Resynchronized path
	EVSYS_CHANNEL_CHANNEL_PATH_RESYNCHRONIZED = 0x1
	// Asynchronous path
	EVSYS_CHANNEL_CHANNEL_PATH_ASYNCHRONOUS = 0x2
	// Position of EDGSEL field.
	EVSYS_CHANNEL_CHANNEL_EDGSEL_Pos = 0xa
	// Bit mask of EDGSEL field.
	EVSYS_CHANNEL_CHANNEL_EDGSEL_Msk = 0xc00
	// No event output when using the resynchronized or synchronous path
	EVSYS_CHANNEL_CHANNEL_EDGSEL_NO_EVT_OUTPUT = 0x0
	// Event detection only on the rising edge of the signal from the event generator when using the resynchronized or synchronous path
	EVSYS_CHANNEL_CHANNEL_EDGSEL_RISING_EDGE = 0x1
	// Event detection only on the falling edge of the signal from the event generator when using the resynchronized or synchronous path
	EVSYS_CHANNEL_CHANNEL_EDGSEL_FALLING_EDGE = 0x2
	// Event detection on rising and falling edges of the signal from the event generator when using the resynchronized or synchronous path
	EVSYS_CHANNEL_CHANNEL_EDGSEL_BOTH_EDGES = 0x3
	// Position of RUNSTDBY field.
	EVSYS_CHANNEL_CHANNEL_RUNSTDBY_Pos = 0xe
	// Bit mask of RUNSTDBY field.
	EVSYS_CHANNEL_CHANNEL_RUNSTDBY_Msk = 0x4000
	// Bit RUNSTDBY.
	EVSYS_CHANNEL_CHANNEL_RUNSTDBY = 0x4000
	// Position of ONDEMAND field.
	EVSYS_CHANNEL_CHANNEL_ONDEMAND_Pos = 0xf
	// Bit mask of ONDEMAND field.
	EVSYS_CHANNEL_CHANNEL_ONDEMAND_Msk = 0x8000
	// Bit ONDEMAND.
	EVSYS_CHANNEL_CHANNEL_ONDEMAND = 0x8000

	// CHANNEL.CHINTENCLR: Channel n Interrupt Enable Clear
	// Position of OVR field.
	EVSYS_CHANNEL_CHINTENCLR_OVR_Pos = 0x0
	// Bit mask of OVR field.
	EVSYS_CHANNEL_CHINTENCLR_OVR_Msk = 0x1
	// Bit OVR.
	EVSYS_CHANNEL_CHINTENCLR_OVR = 0x1
	// Position of EVD field.
	EVSYS_CHANNEL_CHINTENCLR_EVD_Pos = 0x1
	// Bit mask of EVD field.
	EVSYS_CHANNEL_CHINTENCLR_EVD_Msk = 0x2
	// Bit EVD.
	EVSYS_CHANNEL_CHINTENCLR_EVD = 0x2

	// CHANNEL.CHINTENSET: Channel n Interrupt Enable Set
	// Position of OVR field.
	EVSYS_CHANNEL_CHINTENSET_OVR_Pos = 0x0
	// Bit mask of OVR field.
	EVSYS_CHANNEL_CHINTENSET_OVR_Msk = 0x1
	// Bit OVR.
	EVSYS_CHANNEL_CHINTENSET_OVR = 0x1
	// Position of EVD field.
	EVSYS_CHANNEL_CHINTENSET_EVD_Pos = 0x1
	// Bit mask of EVD field.
	EVSYS_CHANNEL_CHINTENSET_EVD_Msk = 0x2
	// Bit EVD.
	EVSYS_CHANNEL_CHINTENSET_EVD = 0x2

	// CHANNEL.CHINTFLAG: Channel n Interrupt Flag Status and Clear
	// Position of OVR field.
	EVSYS_CHANNEL_CHINTFLAG_OVR_Pos = 0x0
	// Bit mask of OVR field.
	EVSYS_CHANNEL_CHINTFLAG_OVR_Msk = 0x1
	// Bit OVR.
	EVSYS_CHANNEL_CHINTFLAG_OVR = 0x1
	// Position of EVD field.
	EVSYS_CHANNEL_CHINTFLAG_EVD_Pos = 0x1
	// Bit mask of EVD field.
	EVSYS_CHANNEL_CHINTFLAG_EVD_Msk = 0x2
	// Bit EVD.
	EVSYS_CHANNEL_CHINTFLAG_EVD = 0x2

	// CHANNEL.CHSTATUS: Channel n Status
	// Position of RDYUSR field.
	EVSYS_CHANNEL_CHSTATUS_RDYUSR_Pos = 0x0
	// Bit mask of RDYUSR field.
	EVSYS_CHANNEL_CHSTATUS_RDYUSR_Msk = 0x1
	// Bit RDYUSR.
	EVSYS_CHANNEL_CHSTATUS_RDYUSR = 0x1
	// Position of BUSYCH field.
	EVSYS_CHANNEL_CHSTATUS_BUSYCH_Pos = 0x1
	// Bit mask of BUSYCH field.
	EVSYS_CHANNEL_CHSTATUS_BUSYCH_Msk = 0x2
	// Bit BUSYCH.
	EVSYS_CHANNEL_CHSTATUS_BUSYCH = 0x2

	// USER: User Multiplexer n
	// Position of CHANNEL field.
	EVSYS_USER_CHANNEL_Pos = 0x0
	// Bit mask of CHANNEL field.
	EVSYS_USER_CHANNEL_Msk = 0x3f
)

// Constants for FREQM: Frequency Meter
const (
	// CTRLA: Control A Register
	// Position of SWRST field.
	FREQM_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	FREQM_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	FREQM_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	FREQM_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	FREQM_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	FREQM_CTRLA_ENABLE = 0x2

	// CTRLB: Control B Register
	// Position of START field.
	FREQM_CTRLB_START_Pos = 0x0
	// Bit mask of START field.
	FREQM_CTRLB_START_Msk = 0x1
	// Bit START.
	FREQM_CTRLB_START = 0x1

	// CFGA: Config A register
	// Position of REFNUM field.
	FREQM_CFGA_REFNUM_Pos = 0x0
	// Bit mask of REFNUM field.
	FREQM_CFGA_REFNUM_Msk = 0xff

	// INTENCLR: Interrupt Enable Clear Register
	// Position of DONE field.
	FREQM_INTENCLR_DONE_Pos = 0x0
	// Bit mask of DONE field.
	FREQM_INTENCLR_DONE_Msk = 0x1
	// Bit DONE.
	FREQM_INTENCLR_DONE = 0x1

	// INTENSET: Interrupt Enable Set Register
	// Position of DONE field.
	FREQM_INTENSET_DONE_Pos = 0x0
	// Bit mask of DONE field.
	FREQM_INTENSET_DONE_Msk = 0x1
	// Bit DONE.
	FREQM_INTENSET_DONE = 0x1

	// INTFLAG: Interrupt Flag Register
	// Position of DONE field.
	FREQM_INTFLAG_DONE_Pos = 0x0
	// Bit mask of DONE field.
	FREQM_INTFLAG_DONE_Msk = 0x1
	// Bit DONE.
	FREQM_INTFLAG_DONE = 0x1

	// STATUS: Status Register
	// Position of BUSY field.
	FREQM_STATUS_BUSY_Pos = 0x0
	// Bit mask of BUSY field.
	FREQM_STATUS_BUSY_Msk = 0x1
	// Bit BUSY.
	FREQM_STATUS_BUSY = 0x1
	// Position of OVF field.
	FREQM_STATUS_OVF_Pos = 0x1
	// Bit mask of OVF field.
	FREQM_STATUS_OVF_Msk = 0x2
	// Bit OVF.
	FREQM_STATUS_OVF = 0x2

	// SYNCBUSY: Synchronization Busy Register
	// Position of SWRST field.
	FREQM_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	FREQM_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	FREQM_SYNCBUSY_SWRST = 0x1
	// Position of ENABLE field.
	FREQM_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	FREQM_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	FREQM_SYNCBUSY_ENABLE = 0x2

	// VALUE: Count Value Register
	// Position of VALUE field.
	FREQM_VALUE_VALUE_Pos = 0x0
	// Bit mask of VALUE field.
	FREQM_VALUE_VALUE_Msk = 0xffffff
)

// Constants for GCLK: Generic Clock Generator
const (
	// CTRLA: Control
	// Position of SWRST field.
	GCLK_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	GCLK_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	GCLK_CTRLA_SWRST = 0x1

	// SYNCBUSY: Synchronization Busy
	// Position of SWRST field.
	GCLK_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	GCLK_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	GCLK_SYNCBUSY_SWRST = 0x1
	// Position of GENCTRL field.
	GCLK_SYNCBUSY_GENCTRL_Pos = 0x2
	// Bit mask of GENCTRL field.
	GCLK_SYNCBUSY_GENCTRL_Msk = 0x3ffc
	// Generic clock generator 0
	GCLK_SYNCBUSY_GENCTRL_GCLK0 = 0x1
	// Generic clock generator 1
	GCLK_SYNCBUSY_GENCTRL_GCLK1 = 0x2
	// Generic clock generator 2
	GCLK_SYNCBUSY_GENCTRL_GCLK2 = 0x4
	// Generic clock generator 3
	GCLK_SYNCBUSY_GENCTRL_GCLK3 = 0x8
	// Generic clock generator 4
	GCLK_SYNCBUSY_GENCTRL_GCLK4 = 0x10
	// Generic clock generator 5
	GCLK_SYNCBUSY_GENCTRL_GCLK5 = 0x20
	// Generic clock generator 6
	GCLK_SYNCBUSY_GENCTRL_GCLK6 = 0x40
	// Generic clock generator 7
	GCLK_SYNCBUSY_GENCTRL_GCLK7 = 0x80
	// Generic clock generator 8
	GCLK_SYNCBUSY_GENCTRL_GCLK8 = 0x100
	// Generic clock generator 9
	GCLK_SYNCBUSY_GENCTRL_GCLK9 = 0x200
	// Generic clock generator 10
	GCLK_SYNCBUSY_GENCTRL_GCLK10 = 0x400
	// Generic clock generator 11
	GCLK_SYNCBUSY_GENCTRL_GCLK11 = 0x800

	// GENCTRL: Generic Clock Generator Control
	// Position of SRC field.
	GCLK_GENCTRL_SRC_Pos = 0x0
	// Bit mask of SRC field.
	GCLK_GENCTRL_SRC_Msk = 0xf
	// XOSC0 oscillator output
	GCLK_GENCTRL_SRC_XOSC0 = 0x0
	// XOSC1 oscillator output
	GCLK_GENCTRL_SRC_XOSC1 = 0x1
	// Generator input pad
	GCLK_GENCTRL_SRC_GCLKIN = 0x2
	// Generic clock generator 1 output
	GCLK_GENCTRL_SRC_GCLKGEN1 = 0x3
	// OSCULP32K oscillator output
	GCLK_GENCTRL_SRC_OSCULP32K = 0x4
	// XOSC32K oscillator output
	GCLK_GENCTRL_SRC_XOSC32K = 0x5
	// DFLL output
	GCLK_GENCTRL_SRC_DFLL = 0x6
	// DPLL0 output
	GCLK_GENCTRL_SRC_DPLL0 = 0x7
	// DPLL1 output
	GCLK_GENCTRL_SRC_DPLL1 = 0x8
	// Position of GENEN field.
	GCLK_GENCTRL_GENEN_Pos = 0x8
	// Bit mask of GENEN field.
	GCLK_GENCTRL_GENEN_Msk = 0x100
	// Bit GENEN.
	GCLK_GENCTRL_GENEN = 0x100
	// Position of IDC field.
	GCLK_GENCTRL_IDC_Pos = 0x9
	// Bit mask of IDC field.
	GCLK_GENCTRL_IDC_Msk = 0x200
	// Bit IDC.
	GCLK_GENCTRL_IDC = 0x200
	// Position of OOV field.
	GCLK_GENCTRL_OOV_Pos = 0xa
	// Bit mask of OOV field.
	GCLK_GENCTRL_OOV_Msk = 0x400
	// Bit OOV.
	GCLK_GENCTRL_OOV = 0x400
	// Position of OE field.
	GCLK_GENCTRL_OE_Pos = 0xb
	// Bit mask of OE field.
	GCLK_GENCTRL_OE_Msk = 0x800
	// Bit OE.
	GCLK_GENCTRL_OE = 0x800
	// Position of DIVSEL field.
	GCLK_GENCTRL_DIVSEL_Pos = 0xc
	// Bit mask of DIVSEL field.
	GCLK_GENCTRL_DIVSEL_Msk = 0x1000
	// Bit DIVSEL.
	GCLK_GENCTRL_DIVSEL = 0x1000
	// Divide input directly by divider factor
	GCLK_GENCTRL_DIVSEL_DIV1 = 0x0
	// Divide input by 2^(divider factor+ 1)
	GCLK_GENCTRL_DIVSEL_DIV2 = 0x1
	// Position of RUNSTDBY field.
	GCLK_GENCTRL_RUNSTDBY_Pos = 0xd
	// Bit mask of RUNSTDBY field.
	GCLK_GENCTRL_RUNSTDBY_Msk = 0x2000
	// Bit RUNSTDBY.
	GCLK_GENCTRL_RUNSTDBY = 0x2000
	// Position of DIV field.
	GCLK_GENCTRL_DIV_Pos = 0x10
	// Bit mask of DIV field.
	GCLK_GENCTRL_DIV_Msk = 0xffff0000

	// PCHCTRL: Peripheral Clock Control
	// Position of GEN field.
	GCLK_PCHCTRL_GEN_Pos = 0x0
	// Bit mask of GEN field.
	GCLK_PCHCTRL_GEN_Msk = 0xf
	// Generic clock generator 0
	GCLK_PCHCTRL_GEN_GCLK0 = 0x0
	// Generic clock generator 1
	GCLK_PCHCTRL_GEN_GCLK1 = 0x1
	// Generic clock generator 2
	GCLK_PCHCTRL_GEN_GCLK2 = 0x2
	// Generic clock generator 3
	GCLK_PCHCTRL_GEN_GCLK3 = 0x3
	// Generic clock generator 4
	GCLK_PCHCTRL_GEN_GCLK4 = 0x4
	// Generic clock generator 5
	GCLK_PCHCTRL_GEN_GCLK5 = 0x5
	// Generic clock generator 6
	GCLK_PCHCTRL_GEN_GCLK6 = 0x6
	// Generic clock generator 7
	GCLK_PCHCTRL_GEN_GCLK7 = 0x7
	// Generic clock generator 8
	GCLK_PCHCTRL_GEN_GCLK8 = 0x8
	// Generic clock generator 9
	GCLK_PCHCTRL_GEN_GCLK9 = 0x9
	// Generic clock generator 10
	GCLK_PCHCTRL_GEN_GCLK10 = 0xa
	// Generic clock generator 11
	GCLK_PCHCTRL_GEN_GCLK11 = 0xb
	// Position of CHEN field.
	GCLK_PCHCTRL_CHEN_Pos = 0x6
	// Bit mask of CHEN field.
	GCLK_PCHCTRL_CHEN_Msk = 0x40
	// Bit CHEN.
	GCLK_PCHCTRL_CHEN = 0x40
	// Position of WRTLOCK field.
	GCLK_PCHCTRL_WRTLOCK_Pos = 0x7
	// Bit mask of WRTLOCK field.
	GCLK_PCHCTRL_WRTLOCK_Msk = 0x80
	// Bit WRTLOCK.
	GCLK_PCHCTRL_WRTLOCK = 0x80
)

// Constants for GMAC: Ethernet MAC
const (
	// NCR: Network Control Register
	// Position of LBL field.
	GMAC_NCR_LBL_Pos = 0x1
	// Bit mask of LBL field.
	GMAC_NCR_LBL_Msk = 0x2
	// Bit LBL.
	GMAC_NCR_LBL = 0x2
	// Position of RXEN field.
	GMAC_NCR_RXEN_Pos = 0x2
	// Bit mask of RXEN field.
	GMAC_NCR_RXEN_Msk = 0x4
	// Bit RXEN.
	GMAC_NCR_RXEN = 0x4
	// Position of TXEN field.
	GMAC_NCR_TXEN_Pos = 0x3
	// Bit mask of TXEN field.
	GMAC_NCR_TXEN_Msk = 0x8
	// Bit TXEN.
	GMAC_NCR_TXEN = 0x8
	// Position of MPE field.
	GMAC_NCR_MPE_Pos = 0x4
	// Bit mask of MPE field.
	GMAC_NCR_MPE_Msk = 0x10
	// Bit MPE.
	GMAC_NCR_MPE = 0x10
	// Position of CLRSTAT field.
	GMAC_NCR_CLRSTAT_Pos = 0x5
	// Bit mask of CLRSTAT field.
	GMAC_NCR_CLRSTAT_Msk = 0x20
	// Bit CLRSTAT.
	GMAC_NCR_CLRSTAT = 0x20
	// Position of INCSTAT field.
	GMAC_NCR_INCSTAT_Pos = 0x6
	// Bit mask of INCSTAT field.
	GMAC_NCR_INCSTAT_Msk = 0x40
	// Bit INCSTAT.
	GMAC_NCR_INCSTAT = 0x40
	// Position of WESTAT field.
	GMAC_NCR_WESTAT_Pos = 0x7
	// Bit mask of WESTAT field.
	GMAC_NCR_WESTAT_Msk = 0x80
	// Bit WESTAT.
	GMAC_NCR_WESTAT = 0x80
	// Position of BP field.
	GMAC_NCR_BP_Pos = 0x8
	// Bit mask of BP field.
	GMAC_NCR_BP_Msk = 0x100
	// Bit BP.
	GMAC_NCR_BP = 0x100
	// Position of TSTART field.
	GMAC_NCR_TSTART_Pos = 0x9
	// Bit mask of TSTART field.
	GMAC_NCR_TSTART_Msk = 0x200
	// Bit TSTART.
	GMAC_NCR_TSTART = 0x200
	// Position of THALT field.
	GMAC_NCR_THALT_Pos = 0xa
	// Bit mask of THALT field.
	GMAC_NCR_THALT_Msk = 0x400
	// Bit THALT.
	GMAC_NCR_THALT = 0x400
	// Position of TXPF field.
	GMAC_NCR_TXPF_Pos = 0xb
	// Bit mask of TXPF field.
	GMAC_NCR_TXPF_Msk = 0x800
	// Bit TXPF.
	GMAC_NCR_TXPF = 0x800
	// Position of TXZQPF field.
	GMAC_NCR_TXZQPF_Pos = 0xc
	// Bit mask of TXZQPF field.
	GMAC_NCR_TXZQPF_Msk = 0x1000
	// Bit TXZQPF.
	GMAC_NCR_TXZQPF = 0x1000
	// Position of SRTSM field.
	GMAC_NCR_SRTSM_Pos = 0xf
	// Bit mask of SRTSM field.
	GMAC_NCR_SRTSM_Msk = 0x8000
	// Bit SRTSM.
	GMAC_NCR_SRTSM = 0x8000
	// Position of ENPBPR field.
	GMAC_NCR_ENPBPR_Pos = 0x10
	// Bit mask of ENPBPR field.
	GMAC_NCR_ENPBPR_Msk = 0x10000
	// Bit ENPBPR.
	GMAC_NCR_ENPBPR = 0x10000
	// Position of TXPBPF field.
	GMAC_NCR_TXPBPF_Pos = 0x11
	// Bit mask of TXPBPF field.
	GMAC_NCR_TXPBPF_Msk = 0x20000
	// Bit TXPBPF.
	GMAC_NCR_TXPBPF = 0x20000
	// Position of FNP field.
	GMAC_NCR_FNP_Pos = 0x12
	// Bit mask of FNP field.
	GMAC_NCR_FNP_Msk = 0x40000
	// Bit FNP.
	GMAC_NCR_FNP = 0x40000
	// Position of LPI field.
	GMAC_NCR_LPI_Pos = 0x13
	// Bit mask of LPI field.
	GMAC_NCR_LPI_Msk = 0x80000
	// Bit LPI.
	GMAC_NCR_LPI = 0x80000

	// NCFGR: Network Configuration Register
	// Position of SPD field.
	GMAC_NCFGR_SPD_Pos = 0x0
	// Bit mask of SPD field.
	GMAC_NCFGR_SPD_Msk = 0x1
	// Bit SPD.
	GMAC_NCFGR_SPD = 0x1
	// Position of FD field.
	GMAC_NCFGR_FD_Pos = 0x1
	// Bit mask of FD field.
	GMAC_NCFGR_FD_Msk = 0x2
	// Bit FD.
	GMAC_NCFGR_FD = 0x2
	// Position of DNVLAN field.
	GMAC_NCFGR_DNVLAN_Pos = 0x2
	// Bit mask of DNVLAN field.
	GMAC_NCFGR_DNVLAN_Msk = 0x4
	// Bit DNVLAN.
	GMAC_NCFGR_DNVLAN = 0x4
	// Position of JFRAME field.
	GMAC_NCFGR_JFRAME_Pos = 0x3
	// Bit mask of JFRAME field.
	GMAC_NCFGR_JFRAME_Msk = 0x8
	// Bit JFRAME.
	GMAC_NCFGR_JFRAME = 0x8
	// Position of CAF field.
	GMAC_NCFGR_CAF_Pos = 0x4
	// Bit mask of CAF field.
	GMAC_NCFGR_CAF_Msk = 0x10
	// Bit CAF.
	GMAC_NCFGR_CAF = 0x10
	// Position of NBC field.
	GMAC_NCFGR_NBC_Pos = 0x5
	// Bit mask of NBC field.
	GMAC_NCFGR_NBC_Msk = 0x20
	// Bit NBC.
	GMAC_NCFGR_NBC = 0x20
	// Position of MTIHEN field.
	GMAC_NCFGR_MTIHEN_Pos = 0x6
	// Bit mask of MTIHEN field.
	GMAC_NCFGR_MTIHEN_Msk = 0x40
	// Bit MTIHEN.
	GMAC_NCFGR_MTIHEN = 0x40
	// Position of UNIHEN field.
	GMAC_NCFGR_UNIHEN_Pos = 0x7
	// Bit mask of UNIHEN field.
	GMAC_NCFGR_UNIHEN_Msk = 0x80
	// Bit UNIHEN.
	GMAC_NCFGR_UNIHEN = 0x80
	// Position of MAXFS field.
	GMAC_NCFGR_MAXFS_Pos = 0x8
	// Bit mask of MAXFS field.
	GMAC_NCFGR_MAXFS_Msk = 0x100
	// Bit MAXFS.
	GMAC_NCFGR_MAXFS = 0x100
	// Position of RTY field.
	GMAC_NCFGR_RTY_Pos = 0xc
	// Bit mask of RTY field.
	GMAC_NCFGR_RTY_Msk = 0x1000
	// Bit RTY.
	GMAC_NCFGR_RTY = 0x1000
	// Position of PEN field.
	GMAC_NCFGR_PEN_Pos = 0xd
	// Bit mask of PEN field.
	GMAC_NCFGR_PEN_Msk = 0x2000
	// Bit PEN.
	GMAC_NCFGR_PEN = 0x2000
	// Position of RXBUFO field.
	GMAC_NCFGR_RXBUFO_Pos = 0xe
	// Bit mask of RXBUFO field.
	GMAC_NCFGR_RXBUFO_Msk = 0xc000
	// Position of LFERD field.
	GMAC_NCFGR_LFERD_Pos = 0x10
	// Bit mask of LFERD field.
	GMAC_NCFGR_LFERD_Msk = 0x10000
	// Bit LFERD.
	GMAC_NCFGR_LFERD = 0x10000
	// Position of RFCS field.
	GMAC_NCFGR_RFCS_Pos = 0x11
	// Bit mask of RFCS field.
	GMAC_NCFGR_RFCS_Msk = 0x20000
	// Bit RFCS.
	GMAC_NCFGR_RFCS = 0x20000
	// Position of CLK field.
	GMAC_NCFGR_CLK_Pos = 0x12
	// Bit mask of CLK field.
	GMAC_NCFGR_CLK_Msk = 0x1c0000
	// Position of DBW field.
	GMAC_NCFGR_DBW_Pos = 0x15
	// Bit mask of DBW field.
	GMAC_NCFGR_DBW_Msk = 0x600000
	// Position of DCPF field.
	GMAC_NCFGR_DCPF_Pos = 0x17
	// Bit mask of DCPF field.
	GMAC_NCFGR_DCPF_Msk = 0x800000
	// Bit DCPF.
	GMAC_NCFGR_DCPF = 0x800000
	// Position of RXCOEN field.
	GMAC_NCFGR_RXCOEN_Pos = 0x18
	// Bit mask of RXCOEN field.
	GMAC_NCFGR_RXCOEN_Msk = 0x1000000
	// Bit RXCOEN.
	GMAC_NCFGR_RXCOEN = 0x1000000
	// Position of EFRHD field.
	GMAC_NCFGR_EFRHD_Pos = 0x19
	// Bit mask of EFRHD field.
	GMAC_NCFGR_EFRHD_Msk = 0x2000000
	// Bit EFRHD.
	GMAC_NCFGR_EFRHD = 0x2000000
	// Position of IRXFCS field.
	GMAC_NCFGR_IRXFCS_Pos = 0x1a
	// Bit mask of IRXFCS field.
	GMAC_NCFGR_IRXFCS_Msk = 0x4000000
	// Bit IRXFCS.
	GMAC_NCFGR_IRXFCS = 0x4000000
	// Position of IPGSEN field.
	GMAC_NCFGR_IPGSEN_Pos = 0x1c
	// Bit mask of IPGSEN field.
	GMAC_NCFGR_IPGSEN_Msk = 0x10000000
	// Bit IPGSEN.
	GMAC_NCFGR_IPGSEN = 0x10000000
	// Position of RXBP field.
	GMAC_NCFGR_RXBP_Pos = 0x1d
	// Bit mask of RXBP field.
	GMAC_NCFGR_RXBP_Msk = 0x20000000
	// Bit RXBP.
	GMAC_NCFGR_RXBP = 0x20000000
	// Position of IRXER field.
	GMAC_NCFGR_IRXER_Pos = 0x1e
	// Bit mask of IRXER field.
	GMAC_NCFGR_IRXER_Msk = 0x40000000
	// Bit IRXER.
	GMAC_NCFGR_IRXER = 0x40000000

	// NSR: Network Status Register
	// Position of MDIO field.
	GMAC_NSR_MDIO_Pos = 0x1
	// Bit mask of MDIO field.
	GMAC_NSR_MDIO_Msk = 0x2
	// Bit MDIO.
	GMAC_NSR_MDIO = 0x2
	// Position of IDLE field.
	GMAC_NSR_IDLE_Pos = 0x2
	// Bit mask of IDLE field.
	GMAC_NSR_IDLE_Msk = 0x4
	// Bit IDLE.
	GMAC_NSR_IDLE = 0x4

	// UR: User Register
	// Position of MII field.
	GMAC_UR_MII_Pos = 0x0
	// Bit mask of MII field.
	GMAC_UR_MII_Msk = 0x1
	// Bit MII.
	GMAC_UR_MII = 0x1

	// DCFGR: DMA Configuration Register
	// Position of FBLDO field.
	GMAC_DCFGR_FBLDO_Pos = 0x0
	// Bit mask of FBLDO field.
	GMAC_DCFGR_FBLDO_Msk = 0x1f
	// Position of ESMA field.
	GMAC_DCFGR_ESMA_Pos = 0x6
	// Bit mask of ESMA field.
	GMAC_DCFGR_ESMA_Msk = 0x40
	// Bit ESMA.
	GMAC_DCFGR_ESMA = 0x40
	// Position of ESPA field.
	GMAC_DCFGR_ESPA_Pos = 0x7
	// Bit mask of ESPA field.
	GMAC_DCFGR_ESPA_Msk = 0x80
	// Bit ESPA.
	GMAC_DCFGR_ESPA = 0x80
	// Position of RXBMS field.
	GMAC_DCFGR_RXBMS_Pos = 0x8
	// Bit mask of RXBMS field.
	GMAC_DCFGR_RXBMS_Msk = 0x300
	// Position of TXPBMS field.
	GMAC_DCFGR_TXPBMS_Pos = 0xa
	// Bit mask of TXPBMS field.
	GMAC_DCFGR_TXPBMS_Msk = 0x400
	// Bit TXPBMS.
	GMAC_DCFGR_TXPBMS = 0x400
	// Position of TXCOEN field.
	GMAC_DCFGR_TXCOEN_Pos = 0xb
	// Bit mask of TXCOEN field.
	GMAC_DCFGR_TXCOEN_Msk = 0x800
	// Bit TXCOEN.
	GMAC_DCFGR_TXCOEN = 0x800
	// Position of DRBS field.
	GMAC_DCFGR_DRBS_Pos = 0x10
	// Bit mask of DRBS field.
	GMAC_DCFGR_DRBS_Msk = 0xff0000
	// Position of DDRP field.
	GMAC_DCFGR_DDRP_Pos = 0x18
	// Bit mask of DDRP field.
	GMAC_DCFGR_DDRP_Msk = 0x1000000
	// Bit DDRP.
	GMAC_DCFGR_DDRP = 0x1000000

	// TSR: Transmit Status Register
	// Position of UBR field.
	GMAC_TSR_UBR_Pos = 0x0
	// Bit mask of UBR field.
	GMAC_TSR_UBR_Msk = 0x1
	// Bit UBR.
	GMAC_TSR_UBR = 0x1
	// Position of COL field.
	GMAC_TSR_COL_Pos = 0x1
	// Bit mask of COL field.
	GMAC_TSR_COL_Msk = 0x2
	// Bit COL.
	GMAC_TSR_COL = 0x2
	// Position of RLE field.
	GMAC_TSR_RLE_Pos = 0x2
	// Bit mask of RLE field.
	GMAC_TSR_RLE_Msk = 0x4
	// Bit RLE.
	GMAC_TSR_RLE = 0x4
	// Position of TXGO field.
	GMAC_TSR_TXGO_Pos = 0x3
	// Bit mask of TXGO field.
	GMAC_TSR_TXGO_Msk = 0x8
	// Bit TXGO.
	GMAC_TSR_TXGO = 0x8
	// Position of TFC field.
	GMAC_TSR_TFC_Pos = 0x4
	// Bit mask of TFC field.
	GMAC_TSR_TFC_Msk = 0x10
	// Bit TFC.
	GMAC_TSR_TFC = 0x10
	// Position of TXCOMP field.
	GMAC_TSR_TXCOMP_Pos = 0x5
	// Bit mask of TXCOMP field.
	GMAC_TSR_TXCOMP_Msk = 0x20
	// Bit TXCOMP.
	GMAC_TSR_TXCOMP = 0x20
	// Position of UND field.
	GMAC_TSR_UND_Pos = 0x6
	// Bit mask of UND field.
	GMAC_TSR_UND_Msk = 0x40
	// Bit UND.
	GMAC_TSR_UND = 0x40
	// Position of HRESP field.
	GMAC_TSR_HRESP_Pos = 0x8
	// Bit mask of HRESP field.
	GMAC_TSR_HRESP_Msk = 0x100
	// Bit HRESP.
	GMAC_TSR_HRESP = 0x100

	// RBQB: Receive Buffer Queue Base Address
	// Position of ADDR field.
	GMAC_RBQB_ADDR_Pos = 0x2
	// Bit mask of ADDR field.
	GMAC_RBQB_ADDR_Msk = 0xfffffffc

	// TBQB: Transmit Buffer Queue Base Address
	// Position of ADDR field.
	GMAC_TBQB_ADDR_Pos = 0x2
	// Bit mask of ADDR field.
	GMAC_TBQB_ADDR_Msk = 0xfffffffc

	// RSR: Receive Status Register
	// Position of BNA field.
	GMAC_RSR_BNA_Pos = 0x0
	// Bit mask of BNA field.
	GMAC_RSR_BNA_Msk = 0x1
	// Bit BNA.
	GMAC_RSR_BNA = 0x1
	// Position of REC field.
	GMAC_RSR_REC_Pos = 0x1
	// Bit mask of REC field.
	GMAC_RSR_REC_Msk = 0x2
	// Bit REC.
	GMAC_RSR_REC = 0x2
	// Position of RXOVR field.
	GMAC_RSR_RXOVR_Pos = 0x2
	// Bit mask of RXOVR field.
	GMAC_RSR_RXOVR_Msk = 0x4
	// Bit RXOVR.
	GMAC_RSR_RXOVR = 0x4
	// Position of HNO field.
	GMAC_RSR_HNO_Pos = 0x3
	// Bit mask of HNO field.
	GMAC_RSR_HNO_Msk = 0x8
	// Bit HNO.
	GMAC_RSR_HNO = 0x8

	// ISR: Interrupt Status Register
	// Position of MFS field.
	GMAC_ISR_MFS_Pos = 0x0
	// Bit mask of MFS field.
	GMAC_ISR_MFS_Msk = 0x1
	// Bit MFS.
	GMAC_ISR_MFS = 0x1
	// Position of RCOMP field.
	GMAC_ISR_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	GMAC_ISR_RCOMP_Msk = 0x2
	// Bit RCOMP.
	GMAC_ISR_RCOMP = 0x2
	// Position of RXUBR field.
	GMAC_ISR_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	GMAC_ISR_RXUBR_Msk = 0x4
	// Bit RXUBR.
	GMAC_ISR_RXUBR = 0x4
	// Position of TXUBR field.
	GMAC_ISR_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	GMAC_ISR_TXUBR_Msk = 0x8
	// Bit TXUBR.
	GMAC_ISR_TXUBR = 0x8
	// Position of TUR field.
	GMAC_ISR_TUR_Pos = 0x4
	// Bit mask of TUR field.
	GMAC_ISR_TUR_Msk = 0x10
	// Bit TUR.
	GMAC_ISR_TUR = 0x10
	// Position of RLEX field.
	GMAC_ISR_RLEX_Pos = 0x5
	// Bit mask of RLEX field.
	GMAC_ISR_RLEX_Msk = 0x20
	// Bit RLEX.
	GMAC_ISR_RLEX = 0x20
	// Position of TFC field.
	GMAC_ISR_TFC_Pos = 0x6
	// Bit mask of TFC field.
	GMAC_ISR_TFC_Msk = 0x40
	// Bit TFC.
	GMAC_ISR_TFC = 0x40
	// Position of TCOMP field.
	GMAC_ISR_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	GMAC_ISR_TCOMP_Msk = 0x80
	// Bit TCOMP.
	GMAC_ISR_TCOMP = 0x80
	// Position of ROVR field.
	GMAC_ISR_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	GMAC_ISR_ROVR_Msk = 0x400
	// Bit ROVR.
	GMAC_ISR_ROVR = 0x400
	// Position of HRESP field.
	GMAC_ISR_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	GMAC_ISR_HRESP_Msk = 0x800
	// Bit HRESP.
	GMAC_ISR_HRESP = 0x800
	// Position of PFNZ field.
	GMAC_ISR_PFNZ_Pos = 0xc
	// Bit mask of PFNZ field.
	GMAC_ISR_PFNZ_Msk = 0x1000
	// Bit PFNZ.
	GMAC_ISR_PFNZ = 0x1000
	// Position of PTZ field.
	GMAC_ISR_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	GMAC_ISR_PTZ_Msk = 0x2000
	// Bit PTZ.
	GMAC_ISR_PTZ = 0x2000
	// Position of PFTR field.
	GMAC_ISR_PFTR_Pos = 0xe
	// Bit mask of PFTR field.
	GMAC_ISR_PFTR_Msk = 0x4000
	// Bit PFTR.
	GMAC_ISR_PFTR = 0x4000
	// Position of DRQFR field.
	GMAC_ISR_DRQFR_Pos = 0x12
	// Bit mask of DRQFR field.
	GMAC_ISR_DRQFR_Msk = 0x40000
	// Bit DRQFR.
	GMAC_ISR_DRQFR = 0x40000
	// Position of SFR field.
	GMAC_ISR_SFR_Pos = 0x13
	// Bit mask of SFR field.
	GMAC_ISR_SFR_Msk = 0x80000
	// Bit SFR.
	GMAC_ISR_SFR = 0x80000
	// Position of DRQFT field.
	GMAC_ISR_DRQFT_Pos = 0x14
	// Bit mask of DRQFT field.
	GMAC_ISR_DRQFT_Msk = 0x100000
	// Bit DRQFT.
	GMAC_ISR_DRQFT = 0x100000
	// Position of SFT field.
	GMAC_ISR_SFT_Pos = 0x15
	// Bit mask of SFT field.
	GMAC_ISR_SFT_Msk = 0x200000
	// Bit SFT.
	GMAC_ISR_SFT = 0x200000
	// Position of PDRQFR field.
	GMAC_ISR_PDRQFR_Pos = 0x16
	// Bit mask of PDRQFR field.
	GMAC_ISR_PDRQFR_Msk = 0x400000
	// Bit PDRQFR.
	GMAC_ISR_PDRQFR = 0x400000
	// Position of PDRSFR field.
	GMAC_ISR_PDRSFR_Pos = 0x17
	// Bit mask of PDRSFR field.
	GMAC_ISR_PDRSFR_Msk = 0x800000
	// Bit PDRSFR.
	GMAC_ISR_PDRSFR = 0x800000
	// Position of PDRQFT field.
	GMAC_ISR_PDRQFT_Pos = 0x18
	// Bit mask of PDRQFT field.
	GMAC_ISR_PDRQFT_Msk = 0x1000000
	// Bit PDRQFT.
	GMAC_ISR_PDRQFT = 0x1000000
	// Position of PDRSFT field.
	GMAC_ISR_PDRSFT_Pos = 0x19
	// Bit mask of PDRSFT field.
	GMAC_ISR_PDRSFT_Msk = 0x2000000
	// Bit PDRSFT.
	GMAC_ISR_PDRSFT = 0x2000000
	// Position of SRI field.
	GMAC_ISR_SRI_Pos = 0x1a
	// Bit mask of SRI field.
	GMAC_ISR_SRI_Msk = 0x4000000
	// Bit SRI.
	GMAC_ISR_SRI = 0x4000000
	// Position of WOL field.
	GMAC_ISR_WOL_Pos = 0x1c
	// Bit mask of WOL field.
	GMAC_ISR_WOL_Msk = 0x10000000
	// Bit WOL.
	GMAC_ISR_WOL = 0x10000000
	// Position of TSUCMP field.
	GMAC_ISR_TSUCMP_Pos = 0x1d
	// Bit mask of TSUCMP field.
	GMAC_ISR_TSUCMP_Msk = 0x20000000
	// Bit TSUCMP.
	GMAC_ISR_TSUCMP = 0x20000000

	// IER: Interrupt Enable Register
	// Position of MFS field.
	GMAC_IER_MFS_Pos = 0x0
	// Bit mask of MFS field.
	GMAC_IER_MFS_Msk = 0x1
	// Bit MFS.
	GMAC_IER_MFS = 0x1
	// Position of RCOMP field.
	GMAC_IER_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	GMAC_IER_RCOMP_Msk = 0x2
	// Bit RCOMP.
	GMAC_IER_RCOMP = 0x2
	// Position of RXUBR field.
	GMAC_IER_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	GMAC_IER_RXUBR_Msk = 0x4
	// Bit RXUBR.
	GMAC_IER_RXUBR = 0x4
	// Position of TXUBR field.
	GMAC_IER_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	GMAC_IER_TXUBR_Msk = 0x8
	// Bit TXUBR.
	GMAC_IER_TXUBR = 0x8
	// Position of TUR field.
	GMAC_IER_TUR_Pos = 0x4
	// Bit mask of TUR field.
	GMAC_IER_TUR_Msk = 0x10
	// Bit TUR.
	GMAC_IER_TUR = 0x10
	// Position of RLEX field.
	GMAC_IER_RLEX_Pos = 0x5
	// Bit mask of RLEX field.
	GMAC_IER_RLEX_Msk = 0x20
	// Bit RLEX.
	GMAC_IER_RLEX = 0x20
	// Position of TFC field.
	GMAC_IER_TFC_Pos = 0x6
	// Bit mask of TFC field.
	GMAC_IER_TFC_Msk = 0x40
	// Bit TFC.
	GMAC_IER_TFC = 0x40
	// Position of TCOMP field.
	GMAC_IER_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	GMAC_IER_TCOMP_Msk = 0x80
	// Bit TCOMP.
	GMAC_IER_TCOMP = 0x80
	// Position of ROVR field.
	GMAC_IER_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	GMAC_IER_ROVR_Msk = 0x400
	// Bit ROVR.
	GMAC_IER_ROVR = 0x400
	// Position of HRESP field.
	GMAC_IER_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	GMAC_IER_HRESP_Msk = 0x800
	// Bit HRESP.
	GMAC_IER_HRESP = 0x800
	// Position of PFNZ field.
	GMAC_IER_PFNZ_Pos = 0xc
	// Bit mask of PFNZ field.
	GMAC_IER_PFNZ_Msk = 0x1000
	// Bit PFNZ.
	GMAC_IER_PFNZ = 0x1000
	// Position of PTZ field.
	GMAC_IER_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	GMAC_IER_PTZ_Msk = 0x2000
	// Bit PTZ.
	GMAC_IER_PTZ = 0x2000
	// Position of PFTR field.
	GMAC_IER_PFTR_Pos = 0xe
	// Bit mask of PFTR field.
	GMAC_IER_PFTR_Msk = 0x4000
	// Bit PFTR.
	GMAC_IER_PFTR = 0x4000
	// Position of EXINT field.
	GMAC_IER_EXINT_Pos = 0xf
	// Bit mask of EXINT field.
	GMAC_IER_EXINT_Msk = 0x8000
	// Bit EXINT.
	GMAC_IER_EXINT = 0x8000
	// Position of DRQFR field.
	GMAC_IER_DRQFR_Pos = 0x12
	// Bit mask of DRQFR field.
	GMAC_IER_DRQFR_Msk = 0x40000
	// Bit DRQFR.
	GMAC_IER_DRQFR = 0x40000
	// Position of SFR field.
	GMAC_IER_SFR_Pos = 0x13
	// Bit mask of SFR field.
	GMAC_IER_SFR_Msk = 0x80000
	// Bit SFR.
	GMAC_IER_SFR = 0x80000
	// Position of DRQFT field.
	GMAC_IER_DRQFT_Pos = 0x14
	// Bit mask of DRQFT field.
	GMAC_IER_DRQFT_Msk = 0x100000
	// Bit DRQFT.
	GMAC_IER_DRQFT = 0x100000
	// Position of SFT field.
	GMAC_IER_SFT_Pos = 0x15
	// Bit mask of SFT field.
	GMAC_IER_SFT_Msk = 0x200000
	// Bit SFT.
	GMAC_IER_SFT = 0x200000
	// Position of PDRQFR field.
	GMAC_IER_PDRQFR_Pos = 0x16
	// Bit mask of PDRQFR field.
	GMAC_IER_PDRQFR_Msk = 0x400000
	// Bit PDRQFR.
	GMAC_IER_PDRQFR = 0x400000
	// Position of PDRSFR field.
	GMAC_IER_PDRSFR_Pos = 0x17
	// Bit mask of PDRSFR field.
	GMAC_IER_PDRSFR_Msk = 0x800000
	// Bit PDRSFR.
	GMAC_IER_PDRSFR = 0x800000
	// Position of PDRQFT field.
	GMAC_IER_PDRQFT_Pos = 0x18
	// Bit mask of PDRQFT field.
	GMAC_IER_PDRQFT_Msk = 0x1000000
	// Bit PDRQFT.
	GMAC_IER_PDRQFT = 0x1000000
	// Position of PDRSFT field.
	GMAC_IER_PDRSFT_Pos = 0x19
	// Bit mask of PDRSFT field.
	GMAC_IER_PDRSFT_Msk = 0x2000000
	// Bit PDRSFT.
	GMAC_IER_PDRSFT = 0x2000000
	// Position of SRI field.
	GMAC_IER_SRI_Pos = 0x1a
	// Bit mask of SRI field.
	GMAC_IER_SRI_Msk = 0x4000000
	// Bit SRI.
	GMAC_IER_SRI = 0x4000000
	// Position of WOL field.
	GMAC_IER_WOL_Pos = 0x1c
	// Bit mask of WOL field.
	GMAC_IER_WOL_Msk = 0x10000000
	// Bit WOL.
	GMAC_IER_WOL = 0x10000000
	// Position of TSUCMP field.
	GMAC_IER_TSUCMP_Pos = 0x1d
	// Bit mask of TSUCMP field.
	GMAC_IER_TSUCMP_Msk = 0x20000000
	// Bit TSUCMP.
	GMAC_IER_TSUCMP = 0x20000000

	// IDR: Interrupt Disable Register
	// Position of MFS field.
	GMAC_IDR_MFS_Pos = 0x0
	// Bit mask of MFS field.
	GMAC_IDR_MFS_Msk = 0x1
	// Bit MFS.
	GMAC_IDR_MFS = 0x1
	// Position of RCOMP field.
	GMAC_IDR_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	GMAC_IDR_RCOMP_Msk = 0x2
	// Bit RCOMP.
	GMAC_IDR_RCOMP = 0x2
	// Position of RXUBR field.
	GMAC_IDR_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	GMAC_IDR_RXUBR_Msk = 0x4
	// Bit RXUBR.
	GMAC_IDR_RXUBR = 0x4
	// Position of TXUBR field.
	GMAC_IDR_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	GMAC_IDR_TXUBR_Msk = 0x8
	// Bit TXUBR.
	GMAC_IDR_TXUBR = 0x8
	// Position of TUR field.
	GMAC_IDR_TUR_Pos = 0x4
	// Bit mask of TUR field.
	GMAC_IDR_TUR_Msk = 0x10
	// Bit TUR.
	GMAC_IDR_TUR = 0x10
	// Position of RLEX field.
	GMAC_IDR_RLEX_Pos = 0x5
	// Bit mask of RLEX field.
	GMAC_IDR_RLEX_Msk = 0x20
	// Bit RLEX.
	GMAC_IDR_RLEX = 0x20
	// Position of TFC field.
	GMAC_IDR_TFC_Pos = 0x6
	// Bit mask of TFC field.
	GMAC_IDR_TFC_Msk = 0x40
	// Bit TFC.
	GMAC_IDR_TFC = 0x40
	// Position of TCOMP field.
	GMAC_IDR_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	GMAC_IDR_TCOMP_Msk = 0x80
	// Bit TCOMP.
	GMAC_IDR_TCOMP = 0x80
	// Position of ROVR field.
	GMAC_IDR_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	GMAC_IDR_ROVR_Msk = 0x400
	// Bit ROVR.
	GMAC_IDR_ROVR = 0x400
	// Position of HRESP field.
	GMAC_IDR_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	GMAC_IDR_HRESP_Msk = 0x800
	// Bit HRESP.
	GMAC_IDR_HRESP = 0x800
	// Position of PFNZ field.
	GMAC_IDR_PFNZ_Pos = 0xc
	// Bit mask of PFNZ field.
	GMAC_IDR_PFNZ_Msk = 0x1000
	// Bit PFNZ.
	GMAC_IDR_PFNZ = 0x1000
	// Position of PTZ field.
	GMAC_IDR_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	GMAC_IDR_PTZ_Msk = 0x2000
	// Bit PTZ.
	GMAC_IDR_PTZ = 0x2000
	// Position of PFTR field.
	GMAC_IDR_PFTR_Pos = 0xe
	// Bit mask of PFTR field.
	GMAC_IDR_PFTR_Msk = 0x4000
	// Bit PFTR.
	GMAC_IDR_PFTR = 0x4000
	// Position of EXINT field.
	GMAC_IDR_EXINT_Pos = 0xf
	// Bit mask of EXINT field.
	GMAC_IDR_EXINT_Msk = 0x8000
	// Bit EXINT.
	GMAC_IDR_EXINT = 0x8000
	// Position of DRQFR field.
	GMAC_IDR_DRQFR_Pos = 0x12
	// Bit mask of DRQFR field.
	GMAC_IDR_DRQFR_Msk = 0x40000
	// Bit DRQFR.
	GMAC_IDR_DRQFR = 0x40000
	// Position of SFR field.
	GMAC_IDR_SFR_Pos = 0x13
	// Bit mask of SFR field.
	GMAC_IDR_SFR_Msk = 0x80000
	// Bit SFR.
	GMAC_IDR_SFR = 0x80000
	// Position of DRQFT field.
	GMAC_IDR_DRQFT_Pos = 0x14
	// Bit mask of DRQFT field.
	GMAC_IDR_DRQFT_Msk = 0x100000
	// Bit DRQFT.
	GMAC_IDR_DRQFT = 0x100000
	// Position of SFT field.
	GMAC_IDR_SFT_Pos = 0x15
	// Bit mask of SFT field.
	GMAC_IDR_SFT_Msk = 0x200000
	// Bit SFT.
	GMAC_IDR_SFT = 0x200000
	// Position of PDRQFR field.
	GMAC_IDR_PDRQFR_Pos = 0x16
	// Bit mask of PDRQFR field.
	GMAC_IDR_PDRQFR_Msk = 0x400000
	// Bit PDRQFR.
	GMAC_IDR_PDRQFR = 0x400000
	// Position of PDRSFR field.
	GMAC_IDR_PDRSFR_Pos = 0x17
	// Bit mask of PDRSFR field.
	GMAC_IDR_PDRSFR_Msk = 0x800000
	// Bit PDRSFR.
	GMAC_IDR_PDRSFR = 0x800000
	// Position of PDRQFT field.
	GMAC_IDR_PDRQFT_Pos = 0x18
	// Bit mask of PDRQFT field.
	GMAC_IDR_PDRQFT_Msk = 0x1000000
	// Bit PDRQFT.
	GMAC_IDR_PDRQFT = 0x1000000
	// Position of PDRSFT field.
	GMAC_IDR_PDRSFT_Pos = 0x19
	// Bit mask of PDRSFT field.
	GMAC_IDR_PDRSFT_Msk = 0x2000000
	// Bit PDRSFT.
	GMAC_IDR_PDRSFT = 0x2000000
	// Position of SRI field.
	GMAC_IDR_SRI_Pos = 0x1a
	// Bit mask of SRI field.
	GMAC_IDR_SRI_Msk = 0x4000000
	// Bit SRI.
	GMAC_IDR_SRI = 0x4000000
	// Position of WOL field.
	GMAC_IDR_WOL_Pos = 0x1c
	// Bit mask of WOL field.
	GMAC_IDR_WOL_Msk = 0x10000000
	// Bit WOL.
	GMAC_IDR_WOL = 0x10000000
	// Position of TSUCMP field.
	GMAC_IDR_TSUCMP_Pos = 0x1d
	// Bit mask of TSUCMP field.
	GMAC_IDR_TSUCMP_Msk = 0x20000000
	// Bit TSUCMP.
	GMAC_IDR_TSUCMP = 0x20000000

	// IMR: Interrupt Mask Register
	// Position of MFS field.
	GMAC_IMR_MFS_Pos = 0x0
	// Bit mask of MFS field.
	GMAC_IMR_MFS_Msk = 0x1
	// Bit MFS.
	GMAC_IMR_MFS = 0x1
	// Position of RCOMP field.
	GMAC_IMR_RCOMP_Pos = 0x1
	// Bit mask of RCOMP field.
	GMAC_IMR_RCOMP_Msk = 0x2
	// Bit RCOMP.
	GMAC_IMR_RCOMP = 0x2
	// Position of RXUBR field.
	GMAC_IMR_RXUBR_Pos = 0x2
	// Bit mask of RXUBR field.
	GMAC_IMR_RXUBR_Msk = 0x4
	// Bit RXUBR.
	GMAC_IMR_RXUBR = 0x4
	// Position of TXUBR field.
	GMAC_IMR_TXUBR_Pos = 0x3
	// Bit mask of TXUBR field.
	GMAC_IMR_TXUBR_Msk = 0x8
	// Bit TXUBR.
	GMAC_IMR_TXUBR = 0x8
	// Position of TUR field.
	GMAC_IMR_TUR_Pos = 0x4
	// Bit mask of TUR field.
	GMAC_IMR_TUR_Msk = 0x10
	// Bit TUR.
	GMAC_IMR_TUR = 0x10
	// Position of RLEX field.
	GMAC_IMR_RLEX_Pos = 0x5
	// Bit mask of RLEX field.
	GMAC_IMR_RLEX_Msk = 0x20
	// Bit RLEX.
	GMAC_IMR_RLEX = 0x20
	// Position of TFC field.
	GMAC_IMR_TFC_Pos = 0x6
	// Bit mask of TFC field.
	GMAC_IMR_TFC_Msk = 0x40
	// Bit TFC.
	GMAC_IMR_TFC = 0x40
	// Position of TCOMP field.
	GMAC_IMR_TCOMP_Pos = 0x7
	// Bit mask of TCOMP field.
	GMAC_IMR_TCOMP_Msk = 0x80
	// Bit TCOMP.
	GMAC_IMR_TCOMP = 0x80
	// Position of ROVR field.
	GMAC_IMR_ROVR_Pos = 0xa
	// Bit mask of ROVR field.
	GMAC_IMR_ROVR_Msk = 0x400
	// Bit ROVR.
	GMAC_IMR_ROVR = 0x400
	// Position of HRESP field.
	GMAC_IMR_HRESP_Pos = 0xb
	// Bit mask of HRESP field.
	GMAC_IMR_HRESP_Msk = 0x800
	// Bit HRESP.
	GMAC_IMR_HRESP = 0x800
	// Position of PFNZ field.
	GMAC_IMR_PFNZ_Pos = 0xc
	// Bit mask of PFNZ field.
	GMAC_IMR_PFNZ_Msk = 0x1000
	// Bit PFNZ.
	GMAC_IMR_PFNZ = 0x1000
	// Position of PTZ field.
	GMAC_IMR_PTZ_Pos = 0xd
	// Bit mask of PTZ field.
	GMAC_IMR_PTZ_Msk = 0x2000
	// Bit PTZ.
	GMAC_IMR_PTZ = 0x2000
	// Position of PFTR field.
	GMAC_IMR_PFTR_Pos = 0xe
	// Bit mask of PFTR field.
	GMAC_IMR_PFTR_Msk = 0x4000
	// Bit PFTR.
	GMAC_IMR_PFTR = 0x4000
	// Position of EXINT field.
	GMAC_IMR_EXINT_Pos = 0xf
	// Bit mask of EXINT field.
	GMAC_IMR_EXINT_Msk = 0x8000
	// Bit EXINT.
	GMAC_IMR_EXINT = 0x8000
	// Position of DRQFR field.
	GMAC_IMR_DRQFR_Pos = 0x12
	// Bit mask of DRQFR field.
	GMAC_IMR_DRQFR_Msk = 0x40000
	// Bit DRQFR.
	GMAC_IMR_DRQFR = 0x40000
	// Position of SFR field.
	GMAC_IMR_SFR_Pos = 0x13
	// Bit mask of SFR field.
	GMAC_IMR_SFR_Msk = 0x80000
	// Bit SFR.
	GMAC_IMR_SFR = 0x80000
	// Position of DRQFT field.
	GMAC_IMR_DRQFT_Pos = 0x14
	// Bit mask of DRQFT field.
	GMAC_IMR_DRQFT_Msk = 0x100000
	// Bit DRQFT.
	GMAC_IMR_DRQFT = 0x100000
	// Position of SFT field.
	GMAC_IMR_SFT_Pos = 0x15
	// Bit mask of SFT field.
	GMAC_IMR_SFT_Msk = 0x200000
	// Bit SFT.
	GMAC_IMR_SFT = 0x200000
	// Position of PDRQFR field.
	GMAC_IMR_PDRQFR_Pos = 0x16
	// Bit mask of PDRQFR field.
	GMAC_IMR_PDRQFR_Msk = 0x400000
	// Bit PDRQFR.
	GMAC_IMR_PDRQFR = 0x400000
	// Position of PDRSFR field.
	GMAC_IMR_PDRSFR_Pos = 0x17
	// Bit mask of PDRSFR field.
	GMAC_IMR_PDRSFR_Msk = 0x800000
	// Bit PDRSFR.
	GMAC_IMR_PDRSFR = 0x800000
	// Position of PDRQFT field.
	GMAC_IMR_PDRQFT_Pos = 0x18
	// Bit mask of PDRQFT field.
	GMAC_IMR_PDRQFT_Msk = 0x1000000
	// Bit PDRQFT.
	GMAC_IMR_PDRQFT = 0x1000000
	// Position of PDRSFT field.
	GMAC_IMR_PDRSFT_Pos = 0x19
	// Bit mask of PDRSFT field.
	GMAC_IMR_PDRSFT_Msk = 0x2000000
	// Bit PDRSFT.
	GMAC_IMR_PDRSFT = 0x2000000
	// Position of SRI field.
	GMAC_IMR_SRI_Pos = 0x1a
	// Bit mask of SRI field.
	GMAC_IMR_SRI_Msk = 0x4000000
	// Bit SRI.
	GMAC_IMR_SRI = 0x4000000
	// Position of WOL field.
	GMAC_IMR_WOL_Pos = 0x1c
	// Bit mask of WOL field.
	GMAC_IMR_WOL_Msk = 0x10000000
	// Bit WOL.
	GMAC_IMR_WOL = 0x10000000
	// Position of TSUCMP field.
	GMAC_IMR_TSUCMP_Pos = 0x1d
	// Bit mask of TSUCMP field.
	GMAC_IMR_TSUCMP_Msk = 0x20000000
	// Bit TSUCMP.
	GMAC_IMR_TSUCMP = 0x20000000

	// MAN: PHY Maintenance Register
	// Position of DATA field.
	GMAC_MAN_DATA_Pos = 0x0
	// Bit mask of DATA field.
	GMAC_MAN_DATA_Msk = 0xffff
	// Position of WTN field.
	GMAC_MAN_WTN_Pos = 0x10
	// Bit mask of WTN field.
	GMAC_MAN_WTN_Msk = 0x30000
	// Position of REGA field.
	GMAC_MAN_REGA_Pos = 0x12
	// Bit mask of REGA field.
	GMAC_MAN_REGA_Msk = 0x7c0000
	// Position of PHYA field.
	GMAC_MAN_PHYA_Pos = 0x17
	// Bit mask of PHYA field.
	GMAC_MAN_PHYA_Msk = 0xf800000
	// Position of OP field.
	GMAC_MAN_OP_Pos = 0x1c
	// Bit mask of OP field.
	GMAC_MAN_OP_Msk = 0x30000000
	// Position of CLTTO field.
	GMAC_MAN_CLTTO_Pos = 0x1e
	// Bit mask of CLTTO field.
	GMAC_MAN_CLTTO_Msk = 0x40000000
	// Bit CLTTO.
	GMAC_MAN_CLTTO = 0x40000000
	// Position of WZO field.
	GMAC_MAN_WZO_Pos = 0x1f
	// Bit mask of WZO field.
	GMAC_MAN_WZO_Msk = 0x80000000
	// Bit WZO.
	GMAC_MAN_WZO = 0x80000000

	// RPQ: Received Pause Quantum Register
	// Position of RPQ field.
	GMAC_RPQ_RPQ_Pos = 0x0
	// Bit mask of RPQ field.
	GMAC_RPQ_RPQ_Msk = 0xffff

	// TPQ: Transmit Pause Quantum Register
	// Position of TPQ field.
	GMAC_TPQ_TPQ_Pos = 0x0
	// Bit mask of TPQ field.
	GMAC_TPQ_TPQ_Msk = 0xffff

	// TPSF: TX partial store and forward Register
	// Position of TPB1ADR field.
	GMAC_TPSF_TPB1ADR_Pos = 0x0
	// Bit mask of TPB1ADR field.
	GMAC_TPSF_TPB1ADR_Msk = 0x3ff
	// Position of ENTXP field.
	GMAC_TPSF_ENTXP_Pos = 0x1f
	// Bit mask of ENTXP field.
	GMAC_TPSF_ENTXP_Msk = 0x80000000
	// Bit ENTXP.
	GMAC_TPSF_ENTXP = 0x80000000

	// RPSF: RX partial store and forward Register
	// Position of RPB1ADR field.
	GMAC_RPSF_RPB1ADR_Pos = 0x0
	// Bit mask of RPB1ADR field.
	GMAC_RPSF_RPB1ADR_Msk = 0x3ff
	// Position of ENRXP field.
	GMAC_RPSF_ENRXP_Pos = 0x1f
	// Bit mask of ENRXP field.
	GMAC_RPSF_ENRXP_Msk = 0x80000000
	// Bit ENRXP.
	GMAC_RPSF_ENRXP = 0x80000000

	// RJFML: RX Jumbo Frame Max Length Register
	// Position of FML field.
	GMAC_RJFML_FML_Pos = 0x0
	// Bit mask of FML field.
	GMAC_RJFML_FML_Msk = 0x3fff

	// HRB: Hash Register Bottom [31:0]
	// Position of ADDR field.
	GMAC_HRB_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_HRB_ADDR_Msk = 0xffffffff

	// HRT: Hash Register Top [63:32]
	// Position of ADDR field.
	GMAC_HRT_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_HRT_ADDR_Msk = 0xffffffff

	// SA.SAB: Specific Address Bottom [31:0] Register
	// Position of ADDR field.
	GMAC_SA_SAB_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_SA_SAB_ADDR_Msk = 0xffffffff

	// SA.SAT: Specific Address Top [47:32] Register
	// Position of ADDR field.
	GMAC_SA_SAT_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_SA_SAT_ADDR_Msk = 0xffff

	// TIDM: Type ID Match Register
	// Position of TID field.
	GMAC_TIDM_TID_Pos = 0x0
	// Bit mask of TID field.
	GMAC_TIDM_TID_Msk = 0xffff

	// WOL: Wake on LAN
	// Position of IP field.
	GMAC_WOL_IP_Pos = 0x0
	// Bit mask of IP field.
	GMAC_WOL_IP_Msk = 0xffff
	// Position of MAG field.
	GMAC_WOL_MAG_Pos = 0x10
	// Bit mask of MAG field.
	GMAC_WOL_MAG_Msk = 0x10000
	// Bit MAG.
	GMAC_WOL_MAG = 0x10000
	// Position of ARP field.
	GMAC_WOL_ARP_Pos = 0x11
	// Bit mask of ARP field.
	GMAC_WOL_ARP_Msk = 0x20000
	// Bit ARP.
	GMAC_WOL_ARP = 0x20000
	// Position of SA1 field.
	GMAC_WOL_SA1_Pos = 0x12
	// Bit mask of SA1 field.
	GMAC_WOL_SA1_Msk = 0x40000
	// Bit SA1.
	GMAC_WOL_SA1 = 0x40000
	// Position of MTI field.
	GMAC_WOL_MTI_Pos = 0x13
	// Bit mask of MTI field.
	GMAC_WOL_MTI_Msk = 0x80000
	// Bit MTI.
	GMAC_WOL_MTI = 0x80000

	// IPGS: IPG Stretch Register
	// Position of FL field.
	GMAC_IPGS_FL_Pos = 0x0
	// Bit mask of FL field.
	GMAC_IPGS_FL_Msk = 0xffff

	// SVLAN: Stacked VLAN Register
	// Position of VLAN_TYPE field.
	GMAC_SVLAN_VLAN_TYPE_Pos = 0x0
	// Bit mask of VLAN_TYPE field.
	GMAC_SVLAN_VLAN_TYPE_Msk = 0xffff
	// Position of ESVLAN field.
	GMAC_SVLAN_ESVLAN_Pos = 0x1f
	// Bit mask of ESVLAN field.
	GMAC_SVLAN_ESVLAN_Msk = 0x80000000
	// Bit ESVLAN.
	GMAC_SVLAN_ESVLAN = 0x80000000

	// TPFCP: Transmit PFC Pause Register
	// Position of PEV field.
	GMAC_TPFCP_PEV_Pos = 0x0
	// Bit mask of PEV field.
	GMAC_TPFCP_PEV_Msk = 0xff
	// Position of PQ field.
	GMAC_TPFCP_PQ_Pos = 0x8
	// Bit mask of PQ field.
	GMAC_TPFCP_PQ_Msk = 0xff00

	// SAMB1: Specific Address 1 Mask Bottom [31:0] Register
	// Position of ADDR field.
	GMAC_SAMB1_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_SAMB1_ADDR_Msk = 0xffffffff

	// SAMT1: Specific Address 1 Mask Top [47:32] Register
	// Position of ADDR field.
	GMAC_SAMT1_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	GMAC_SAMT1_ADDR_Msk = 0xffff

	// NSC: Tsu timer comparison nanoseconds Register
	// Position of NANOSEC field.
	GMAC_NSC_NANOSEC_Pos = 0x0
	// Bit mask of NANOSEC field.
	GMAC_NSC_NANOSEC_Msk = 0x1fffff

	// SCL: Tsu timer second comparison Register
	// Position of SEC field.
	GMAC_SCL_SEC_Pos = 0x0
	// Bit mask of SEC field.
	GMAC_SCL_SEC_Msk = 0xffffffff

	// SCH: Tsu timer second comparison Register
	// Position of SEC field.
	GMAC_SCH_SEC_Pos = 0x0
	// Bit mask of SEC field.
	GMAC_SCH_SEC_Msk = 0xffff

	// EFTSH: PTP Event Frame Transmitted Seconds High Register
	// Position of RUD field.
	GMAC_EFTSH_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_EFTSH_RUD_Msk = 0xffff

	// EFRSH: PTP Event Frame Received Seconds High Register
	// Position of RUD field.
	GMAC_EFRSH_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_EFRSH_RUD_Msk = 0xffff

	// PEFTSH: PTP Peer Event Frame Transmitted Seconds High Register
	// Position of RUD field.
	GMAC_PEFTSH_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_PEFTSH_RUD_Msk = 0xffff

	// PEFRSH: PTP Peer Event Frame Received Seconds High Register
	// Position of RUD field.
	GMAC_PEFRSH_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_PEFRSH_RUD_Msk = 0xffff

	// OTLO: Octets Transmitted [31:0] Register
	// Position of TXO field.
	GMAC_OTLO_TXO_Pos = 0x0
	// Bit mask of TXO field.
	GMAC_OTLO_TXO_Msk = 0xffffffff

	// OTHI: Octets Transmitted [47:32] Register
	// Position of TXO field.
	GMAC_OTHI_TXO_Pos = 0x0
	// Bit mask of TXO field.
	GMAC_OTHI_TXO_Msk = 0xffff

	// FT: Frames Transmitted Register
	// Position of FTX field.
	GMAC_FT_FTX_Pos = 0x0
	// Bit mask of FTX field.
	GMAC_FT_FTX_Msk = 0xffffffff

	// BCFT: Broadcast Frames Transmitted Register
	// Position of BFTX field.
	GMAC_BCFT_BFTX_Pos = 0x0
	// Bit mask of BFTX field.
	GMAC_BCFT_BFTX_Msk = 0xffffffff

	// MFT: Multicast Frames Transmitted Register
	// Position of MFTX field.
	GMAC_MFT_MFTX_Pos = 0x0
	// Bit mask of MFTX field.
	GMAC_MFT_MFTX_Msk = 0xffffffff

	// PFT: Pause Frames Transmitted Register
	// Position of PFTX field.
	GMAC_PFT_PFTX_Pos = 0x0
	// Bit mask of PFTX field.
	GMAC_PFT_PFTX_Msk = 0xffff

	// BFT64: 64 Byte Frames Transmitted Register
	// Position of NFTX field.
	GMAC_BFT64_NFTX_Pos = 0x0
	// Bit mask of NFTX field.
	GMAC_BFT64_NFTX_Msk = 0xffffffff

	// TBFT127: 65 to 127 Byte Frames Transmitted Register
	// Position of NFTX field.
	GMAC_TBFT127_NFTX_Pos = 0x0
	// Bit mask of NFTX field.
	GMAC_TBFT127_NFTX_Msk = 0xffffffff

	// TBFT255: 128 to 255 Byte Frames Transmitted Register
	// Position of NFTX field.
	GMAC_TBFT255_NFTX_Pos = 0x0
	// Bit mask of NFTX field.
	GMAC_TBFT255_NFTX_Msk = 0xffffffff

	// TBFT511: 256 to 511 Byte Frames Transmitted Register
	// Position of NFTX field.
	GMAC_TBFT511_NFTX_Pos = 0x0
	// Bit mask of NFTX field.
	GMAC_TBFT511_NFTX_Msk = 0xffffffff

	// TBFT1023: 512 to 1023 Byte Frames Transmitted Register
	// Position of NFTX field.
	GMAC_TBFT1023_NFTX_Pos = 0x0
	// Bit mask of NFTX field.
	GMAC_TBFT1023_NFTX_Msk = 0xffffffff

	// TBFT1518: 1024 to 1518 Byte Frames Transmitted Register
	// Position of NFTX field.
	GMAC_TBFT1518_NFTX_Pos = 0x0
	// Bit mask of NFTX field.
	GMAC_TBFT1518_NFTX_Msk = 0xffffffff

	// GTBFT1518: Greater Than 1518 Byte Frames Transmitted Register
	// Position of NFTX field.
	GMAC_GTBFT1518_NFTX_Pos = 0x0
	// Bit mask of NFTX field.
	GMAC_GTBFT1518_NFTX_Msk = 0xffffffff

	// TUR: Transmit Underruns Register
	// Position of TXUNR field.
	GMAC_TUR_TXUNR_Pos = 0x0
	// Bit mask of TXUNR field.
	GMAC_TUR_TXUNR_Msk = 0x3ff

	// SCF: Single Collision Frames Register
	// Position of SCOL field.
	GMAC_SCF_SCOL_Pos = 0x0
	// Bit mask of SCOL field.
	GMAC_SCF_SCOL_Msk = 0x3ffff

	// MCF: Multiple Collision Frames Register
	// Position of MCOL field.
	GMAC_MCF_MCOL_Pos = 0x0
	// Bit mask of MCOL field.
	GMAC_MCF_MCOL_Msk = 0x3ffff

	// EC: Excessive Collisions Register
	// Position of XCOL field.
	GMAC_EC_XCOL_Pos = 0x0
	// Bit mask of XCOL field.
	GMAC_EC_XCOL_Msk = 0x3ff

	// LC: Late Collisions Register
	// Position of LCOL field.
	GMAC_LC_LCOL_Pos = 0x0
	// Bit mask of LCOL field.
	GMAC_LC_LCOL_Msk = 0x3ff

	// DTF: Deferred Transmission Frames Register
	// Position of DEFT field.
	GMAC_DTF_DEFT_Pos = 0x0
	// Bit mask of DEFT field.
	GMAC_DTF_DEFT_Msk = 0x3ffff

	// CSE: Carrier Sense Errors Register
	// Position of CSR field.
	GMAC_CSE_CSR_Pos = 0x0
	// Bit mask of CSR field.
	GMAC_CSE_CSR_Msk = 0x3ff

	// ORLO: Octets Received [31:0] Received
	// Position of RXO field.
	GMAC_ORLO_RXO_Pos = 0x0
	// Bit mask of RXO field.
	GMAC_ORLO_RXO_Msk = 0xffffffff

	// ORHI: Octets Received [47:32] Received
	// Position of RXO field.
	GMAC_ORHI_RXO_Pos = 0x0
	// Bit mask of RXO field.
	GMAC_ORHI_RXO_Msk = 0xffff

	// FR: Frames Received Register
	// Position of FRX field.
	GMAC_FR_FRX_Pos = 0x0
	// Bit mask of FRX field.
	GMAC_FR_FRX_Msk = 0xffffffff

	// BCFR: Broadcast Frames Received Register
	// Position of BFRX field.
	GMAC_BCFR_BFRX_Pos = 0x0
	// Bit mask of BFRX field.
	GMAC_BCFR_BFRX_Msk = 0xffffffff

	// MFR: Multicast Frames Received Register
	// Position of MFRX field.
	GMAC_MFR_MFRX_Pos = 0x0
	// Bit mask of MFRX field.
	GMAC_MFR_MFRX_Msk = 0xffffffff

	// PFR: Pause Frames Received Register
	// Position of PFRX field.
	GMAC_PFR_PFRX_Pos = 0x0
	// Bit mask of PFRX field.
	GMAC_PFR_PFRX_Msk = 0xffff

	// BFR64: 64 Byte Frames Received Register
	// Position of NFRX field.
	GMAC_BFR64_NFRX_Pos = 0x0
	// Bit mask of NFRX field.
	GMAC_BFR64_NFRX_Msk = 0xffffffff

	// TBFR127: 65 to 127 Byte Frames Received Register
	// Position of NFRX field.
	GMAC_TBFR127_NFRX_Pos = 0x0
	// Bit mask of NFRX field.
	GMAC_TBFR127_NFRX_Msk = 0xffffffff

	// TBFR255: 128 to 255 Byte Frames Received Register
	// Position of NFRX field.
	GMAC_TBFR255_NFRX_Pos = 0x0
	// Bit mask of NFRX field.
	GMAC_TBFR255_NFRX_Msk = 0xffffffff

	// TBFR511: 256 to 511Byte Frames Received Register
	// Position of NFRX field.
	GMAC_TBFR511_NFRX_Pos = 0x0
	// Bit mask of NFRX field.
	GMAC_TBFR511_NFRX_Msk = 0xffffffff

	// TBFR1023: 512 to 1023 Byte Frames Received Register
	// Position of NFRX field.
	GMAC_TBFR1023_NFRX_Pos = 0x0
	// Bit mask of NFRX field.
	GMAC_TBFR1023_NFRX_Msk = 0xffffffff

	// TBFR1518: 1024 to 1518 Byte Frames Received Register
	// Position of NFRX field.
	GMAC_TBFR1518_NFRX_Pos = 0x0
	// Bit mask of NFRX field.
	GMAC_TBFR1518_NFRX_Msk = 0xffffffff

	// TMXBFR: 1519 to Maximum Byte Frames Received Register
	// Position of NFRX field.
	GMAC_TMXBFR_NFRX_Pos = 0x0
	// Bit mask of NFRX field.
	GMAC_TMXBFR_NFRX_Msk = 0xffffffff

	// UFR: Undersize Frames Received Register
	// Position of UFRX field.
	GMAC_UFR_UFRX_Pos = 0x0
	// Bit mask of UFRX field.
	GMAC_UFR_UFRX_Msk = 0x3ff

	// OFR: Oversize Frames Received Register
	// Position of OFRX field.
	GMAC_OFR_OFRX_Pos = 0x0
	// Bit mask of OFRX field.
	GMAC_OFR_OFRX_Msk = 0x3ff

	// JR: Jabbers Received Register
	// Position of JRX field.
	GMAC_JR_JRX_Pos = 0x0
	// Bit mask of JRX field.
	GMAC_JR_JRX_Msk = 0x3ff

	// FCSE: Frame Check Sequence Errors Register
	// Position of FCKR field.
	GMAC_FCSE_FCKR_Pos = 0x0
	// Bit mask of FCKR field.
	GMAC_FCSE_FCKR_Msk = 0x3ff

	// LFFE: Length Field Frame Errors Register
	// Position of LFER field.
	GMAC_LFFE_LFER_Pos = 0x0
	// Bit mask of LFER field.
	GMAC_LFFE_LFER_Msk = 0x3ff

	// RSE: Receive Symbol Errors Register
	// Position of RXSE field.
	GMAC_RSE_RXSE_Pos = 0x0
	// Bit mask of RXSE field.
	GMAC_RSE_RXSE_Msk = 0x3ff

	// AE: Alignment Errors Register
	// Position of AER field.
	GMAC_AE_AER_Pos = 0x0
	// Bit mask of AER field.
	GMAC_AE_AER_Msk = 0x3ff

	// RRE: Receive Resource Errors Register
	// Position of RXRER field.
	GMAC_RRE_RXRER_Pos = 0x0
	// Bit mask of RXRER field.
	GMAC_RRE_RXRER_Msk = 0x3ffff

	// ROE: Receive Overrun Register
	// Position of RXOVR field.
	GMAC_ROE_RXOVR_Pos = 0x0
	// Bit mask of RXOVR field.
	GMAC_ROE_RXOVR_Msk = 0x3ff

	// IHCE: IP Header Checksum Errors Register
	// Position of HCKER field.
	GMAC_IHCE_HCKER_Pos = 0x0
	// Bit mask of HCKER field.
	GMAC_IHCE_HCKER_Msk = 0xff

	// TCE: TCP Checksum Errors Register
	// Position of TCKER field.
	GMAC_TCE_TCKER_Pos = 0x0
	// Bit mask of TCKER field.
	GMAC_TCE_TCKER_Msk = 0xff

	// UCE: UDP Checksum Errors Register
	// Position of UCKER field.
	GMAC_UCE_UCKER_Pos = 0x0
	// Bit mask of UCKER field.
	GMAC_UCE_UCKER_Msk = 0xff

	// TISUBN: 1588 Timer Increment [15:0] Sub-Nanoseconds Register
	// Position of LSBTIR field.
	GMAC_TISUBN_LSBTIR_Pos = 0x0
	// Bit mask of LSBTIR field.
	GMAC_TISUBN_LSBTIR_Msk = 0xffff

	// TSH: 1588 Timer Seconds High [15:0] Register
	// Position of TCS field.
	GMAC_TSH_TCS_Pos = 0x0
	// Bit mask of TCS field.
	GMAC_TSH_TCS_Msk = 0xffff

	// TSSSL: 1588 Timer Sync Strobe Seconds [31:0] Register
	// Position of VTS field.
	GMAC_TSSSL_VTS_Pos = 0x0
	// Bit mask of VTS field.
	GMAC_TSSSL_VTS_Msk = 0xffffffff

	// TSSN: 1588 Timer Sync Strobe Nanoseconds Register
	// Position of VTN field.
	GMAC_TSSN_VTN_Pos = 0x0
	// Bit mask of VTN field.
	GMAC_TSSN_VTN_Msk = 0x3fffffff

	// TSL: 1588 Timer Seconds [31:0] Register
	// Position of TCS field.
	GMAC_TSL_TCS_Pos = 0x0
	// Bit mask of TCS field.
	GMAC_TSL_TCS_Msk = 0xffffffff

	// TN: 1588 Timer Nanoseconds Register
	// Position of TNS field.
	GMAC_TN_TNS_Pos = 0x0
	// Bit mask of TNS field.
	GMAC_TN_TNS_Msk = 0x3fffffff

	// TA: 1588 Timer Adjust Register
	// Position of ITDT field.
	GMAC_TA_ITDT_Pos = 0x0
	// Bit mask of ITDT field.
	GMAC_TA_ITDT_Msk = 0x3fffffff
	// Position of ADJ field.
	GMAC_TA_ADJ_Pos = 0x1f
	// Bit mask of ADJ field.
	GMAC_TA_ADJ_Msk = 0x80000000
	// Bit ADJ.
	GMAC_TA_ADJ = 0x80000000

	// TI: 1588 Timer Increment Register
	// Position of CNS field.
	GMAC_TI_CNS_Pos = 0x0
	// Bit mask of CNS field.
	GMAC_TI_CNS_Msk = 0xff
	// Position of ACNS field.
	GMAC_TI_ACNS_Pos = 0x8
	// Bit mask of ACNS field.
	GMAC_TI_ACNS_Msk = 0xff00
	// Position of NIT field.
	GMAC_TI_NIT_Pos = 0x10
	// Bit mask of NIT field.
	GMAC_TI_NIT_Msk = 0xff0000

	// EFTSL: PTP Event Frame Transmitted Seconds Low Register
	// Position of RUD field.
	GMAC_EFTSL_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_EFTSL_RUD_Msk = 0xffffffff

	// EFTN: PTP Event Frame Transmitted Nanoseconds
	// Position of RUD field.
	GMAC_EFTN_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_EFTN_RUD_Msk = 0x3fffffff

	// EFRSL: PTP Event Frame Received Seconds Low Register
	// Position of RUD field.
	GMAC_EFRSL_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_EFRSL_RUD_Msk = 0xffffffff

	// EFRN: PTP Event Frame Received Nanoseconds
	// Position of RUD field.
	GMAC_EFRN_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_EFRN_RUD_Msk = 0x3fffffff

	// PEFTSL: PTP Peer Event Frame Transmitted Seconds Low Register
	// Position of RUD field.
	GMAC_PEFTSL_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_PEFTSL_RUD_Msk = 0xffffffff

	// PEFTN: PTP Peer Event Frame Transmitted Nanoseconds
	// Position of RUD field.
	GMAC_PEFTN_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_PEFTN_RUD_Msk = 0x3fffffff

	// PEFRSL: PTP Peer Event Frame Received Seconds Low Register
	// Position of RUD field.
	GMAC_PEFRSL_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_PEFRSL_RUD_Msk = 0xffffffff

	// PEFRN: PTP Peer Event Frame Received Nanoseconds
	// Position of RUD field.
	GMAC_PEFRN_RUD_Pos = 0x0
	// Bit mask of RUD field.
	GMAC_PEFRN_RUD_Msk = 0x3fffffff

	// RLPITR: Receive LPI transition Register
	// Position of RLPITR field.
	GMAC_RLPITR_RLPITR_Pos = 0x0
	// Bit mask of RLPITR field.
	GMAC_RLPITR_RLPITR_Msk = 0xffff

	// RLPITI: Receive LPI Time Register
	// Position of RLPITI field.
	GMAC_RLPITI_RLPITI_Pos = 0x0
	// Bit mask of RLPITI field.
	GMAC_RLPITI_RLPITI_Msk = 0xffffff

	// TLPITR: Receive LPI transition Register
	// Position of TLPITR field.
	GMAC_TLPITR_TLPITR_Pos = 0x0
	// Bit mask of TLPITR field.
	GMAC_TLPITR_TLPITR_Msk = 0xffff

	// TLPITI: Receive LPI Time Register
	// Position of TLPITI field.
	GMAC_TLPITI_TLPITI_Pos = 0x0
	// Bit mask of TLPITI field.
	GMAC_TLPITI_TLPITI_Msk = 0xffffff
)

// Constants for HMATRIX: HSB Matrix
const (
// PRS.PRAS: Priority A for Slave

// PRS.PRBS: Priority B for Slave
)

// Constants for ICM: Integrity Check Monitor
const (
	// CFG: Configuration
	// Position of WBDIS field.
	ICM_CFG_WBDIS_Pos = 0x0
	// Bit mask of WBDIS field.
	ICM_CFG_WBDIS_Msk = 0x1
	// Bit WBDIS.
	ICM_CFG_WBDIS = 0x1
	// Position of EOMDIS field.
	ICM_CFG_EOMDIS_Pos = 0x1
	// Bit mask of EOMDIS field.
	ICM_CFG_EOMDIS_Msk = 0x2
	// Bit EOMDIS.
	ICM_CFG_EOMDIS = 0x2
	// Position of SLBDIS field.
	ICM_CFG_SLBDIS_Pos = 0x2
	// Bit mask of SLBDIS field.
	ICM_CFG_SLBDIS_Msk = 0x4
	// Bit SLBDIS.
	ICM_CFG_SLBDIS = 0x4
	// Position of BBC field.
	ICM_CFG_BBC_Pos = 0x4
	// Bit mask of BBC field.
	ICM_CFG_BBC_Msk = 0xf0
	// Position of ASCD field.
	ICM_CFG_ASCD_Pos = 0x8
	// Bit mask of ASCD field.
	ICM_CFG_ASCD_Msk = 0x100
	// Bit ASCD.
	ICM_CFG_ASCD = 0x100
	// Position of DUALBUFF field.
	ICM_CFG_DUALBUFF_Pos = 0x9
	// Bit mask of DUALBUFF field.
	ICM_CFG_DUALBUFF_Msk = 0x200
	// Bit DUALBUFF.
	ICM_CFG_DUALBUFF = 0x200
	// Position of UIHASH field.
	ICM_CFG_UIHASH_Pos = 0xc
	// Bit mask of UIHASH field.
	ICM_CFG_UIHASH_Msk = 0x1000
	// Bit UIHASH.
	ICM_CFG_UIHASH = 0x1000
	// Position of UALGO field.
	ICM_CFG_UALGO_Pos = 0xd
	// Bit mask of UALGO field.
	ICM_CFG_UALGO_Msk = 0xe000
	// SHA1 Algorithm
	ICM_CFG_UALGO_SHA1 = 0x0
	// SHA256 Algorithm
	ICM_CFG_UALGO_SHA256 = 0x1
	// SHA224 Algorithm
	ICM_CFG_UALGO_SHA224 = 0x4
	// Position of HAPROT field.
	ICM_CFG_HAPROT_Pos = 0x10
	// Bit mask of HAPROT field.
	ICM_CFG_HAPROT_Msk = 0x3f0000
	// Position of DAPROT field.
	ICM_CFG_DAPROT_Pos = 0x18
	// Bit mask of DAPROT field.
	ICM_CFG_DAPROT_Msk = 0x3f000000

	// CTRL: Control
	// Position of ENABLE field.
	ICM_CTRL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	ICM_CTRL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	ICM_CTRL_ENABLE = 0x1
	// Position of DISABLE field.
	ICM_CTRL_DISABLE_Pos = 0x1
	// Bit mask of DISABLE field.
	ICM_CTRL_DISABLE_Msk = 0x2
	// Bit DISABLE.
	ICM_CTRL_DISABLE = 0x2
	// Position of SWRST field.
	ICM_CTRL_SWRST_Pos = 0x2
	// Bit mask of SWRST field.
	ICM_CTRL_SWRST_Msk = 0x4
	// Bit SWRST.
	ICM_CTRL_SWRST = 0x4
	// Position of REHASH field.
	ICM_CTRL_REHASH_Pos = 0x4
	// Bit mask of REHASH field.
	ICM_CTRL_REHASH_Msk = 0xf0
	// Position of RMDIS field.
	ICM_CTRL_RMDIS_Pos = 0x8
	// Bit mask of RMDIS field.
	ICM_CTRL_RMDIS_Msk = 0xf00
	// Position of RMEN field.
	ICM_CTRL_RMEN_Pos = 0xc
	// Bit mask of RMEN field.
	ICM_CTRL_RMEN_Msk = 0xf000

	// SR: Status
	// Position of ENABLE field.
	ICM_SR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	ICM_SR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	ICM_SR_ENABLE = 0x1
	// Position of RAWRMDIS field.
	ICM_SR_RAWRMDIS_Pos = 0x8
	// Bit mask of RAWRMDIS field.
	ICM_SR_RAWRMDIS_Msk = 0xf00
	// Position of RMDIS field.
	ICM_SR_RMDIS_Pos = 0xc
	// Bit mask of RMDIS field.
	ICM_SR_RMDIS_Msk = 0xf000

	// IER: Interrupt Enable
	// Position of RHC field.
	ICM_IER_RHC_Pos = 0x0
	// Bit mask of RHC field.
	ICM_IER_RHC_Msk = 0xf
	// Position of RDM field.
	ICM_IER_RDM_Pos = 0x4
	// Bit mask of RDM field.
	ICM_IER_RDM_Msk = 0xf0
	// Position of RBE field.
	ICM_IER_RBE_Pos = 0x8
	// Bit mask of RBE field.
	ICM_IER_RBE_Msk = 0xf00
	// Position of RWC field.
	ICM_IER_RWC_Pos = 0xc
	// Bit mask of RWC field.
	ICM_IER_RWC_Msk = 0xf000
	// Position of REC field.
	ICM_IER_REC_Pos = 0x10
	// Bit mask of REC field.
	ICM_IER_REC_Msk = 0xf0000
	// Position of RSU field.
	ICM_IER_RSU_Pos = 0x14
	// Bit mask of RSU field.
	ICM_IER_RSU_Msk = 0xf00000
	// Position of URAD field.
	ICM_IER_URAD_Pos = 0x18
	// Bit mask of URAD field.
	ICM_IER_URAD_Msk = 0x1000000
	// Bit URAD.
	ICM_IER_URAD = 0x1000000

	// IDR: Interrupt Disable
	// Position of RHC field.
	ICM_IDR_RHC_Pos = 0x0
	// Bit mask of RHC field.
	ICM_IDR_RHC_Msk = 0xf
	// Position of RDM field.
	ICM_IDR_RDM_Pos = 0x4
	// Bit mask of RDM field.
	ICM_IDR_RDM_Msk = 0xf0
	// Position of RBE field.
	ICM_IDR_RBE_Pos = 0x8
	// Bit mask of RBE field.
	ICM_IDR_RBE_Msk = 0xf00
	// Position of RWC field.
	ICM_IDR_RWC_Pos = 0xc
	// Bit mask of RWC field.
	ICM_IDR_RWC_Msk = 0xf000
	// Position of REC field.
	ICM_IDR_REC_Pos = 0x10
	// Bit mask of REC field.
	ICM_IDR_REC_Msk = 0xf0000
	// Position of RSU field.
	ICM_IDR_RSU_Pos = 0x14
	// Bit mask of RSU field.
	ICM_IDR_RSU_Msk = 0xf00000
	// Position of URAD field.
	ICM_IDR_URAD_Pos = 0x18
	// Bit mask of URAD field.
	ICM_IDR_URAD_Msk = 0x1000000
	// Bit URAD.
	ICM_IDR_URAD = 0x1000000

	// IMR: Interrupt Mask
	// Position of RHC field.
	ICM_IMR_RHC_Pos = 0x0
	// Bit mask of RHC field.
	ICM_IMR_RHC_Msk = 0xf
	// Position of RDM field.
	ICM_IMR_RDM_Pos = 0x4
	// Bit mask of RDM field.
	ICM_IMR_RDM_Msk = 0xf0
	// Position of RBE field.
	ICM_IMR_RBE_Pos = 0x8
	// Bit mask of RBE field.
	ICM_IMR_RBE_Msk = 0xf00
	// Position of RWC field.
	ICM_IMR_RWC_Pos = 0xc
	// Bit mask of RWC field.
	ICM_IMR_RWC_Msk = 0xf000
	// Position of REC field.
	ICM_IMR_REC_Pos = 0x10
	// Bit mask of REC field.
	ICM_IMR_REC_Msk = 0xf0000
	// Position of RSU field.
	ICM_IMR_RSU_Pos = 0x14
	// Bit mask of RSU field.
	ICM_IMR_RSU_Msk = 0xf00000
	// Position of URAD field.
	ICM_IMR_URAD_Pos = 0x18
	// Bit mask of URAD field.
	ICM_IMR_URAD_Msk = 0x1000000
	// Bit URAD.
	ICM_IMR_URAD = 0x1000000

	// ISR: Interrupt Status
	// Position of RHC field.
	ICM_ISR_RHC_Pos = 0x0
	// Bit mask of RHC field.
	ICM_ISR_RHC_Msk = 0xf
	// Position of RDM field.
	ICM_ISR_RDM_Pos = 0x4
	// Bit mask of RDM field.
	ICM_ISR_RDM_Msk = 0xf0
	// Position of RBE field.
	ICM_ISR_RBE_Pos = 0x8
	// Bit mask of RBE field.
	ICM_ISR_RBE_Msk = 0xf00
	// Position of RWC field.
	ICM_ISR_RWC_Pos = 0xc
	// Bit mask of RWC field.
	ICM_ISR_RWC_Msk = 0xf000
	// Position of REC field.
	ICM_ISR_REC_Pos = 0x10
	// Bit mask of REC field.
	ICM_ISR_REC_Msk = 0xf0000
	// Position of RSU field.
	ICM_ISR_RSU_Pos = 0x14
	// Bit mask of RSU field.
	ICM_ISR_RSU_Msk = 0xf00000
	// Position of URAD field.
	ICM_ISR_URAD_Pos = 0x18
	// Bit mask of URAD field.
	ICM_ISR_URAD_Msk = 0x1000000
	// Bit URAD.
	ICM_ISR_URAD = 0x1000000

	// UASR: Undefined Access Status
	// Position of URAT field.
	ICM_UASR_URAT_Pos = 0x0
	// Bit mask of URAT field.
	ICM_UASR_URAT_Msk = 0x7
	// Unspecified structure member set to one detected when the descriptor is loaded
	ICM_UASR_URAT_UNSPEC_STRUCT_MEMBER = 0x0
	// CFG modified during active monitoring
	ICM_UASR_URAT_CFG_MODIFIED = 0x1
	// DSCR modified during active monitoring
	ICM_UASR_URAT_DSCR_MODIFIED = 0x2
	// HASH modified during active monitoring
	ICM_UASR_URAT_HASH_MODIFIED = 0x3
	// Write-only register read access
	ICM_UASR_URAT_READ_ACCESS = 0x4

	// DSCR: Region Descriptor Area Start Address
	// Position of DASA field.
	ICM_DSCR_DASA_Pos = 0x6
	// Bit mask of DASA field.
	ICM_DSCR_DASA_Msk = 0xffffffc0

	// HASH: Region Hash Area Start Address
	// Position of HASA field.
	ICM_HASH_HASA_Pos = 0x7
	// Bit mask of HASA field.
	ICM_HASH_HASA_Msk = 0xffffff80

	// UIHVAL: User Initial Hash Value n
	// Position of VAL field.
	ICM_UIHVAL_VAL_Pos = 0x0
	// Bit mask of VAL field.
	ICM_UIHVAL_VAL_Msk = 0xffffffff
)

// Constants for I2S: Inter-IC Sound Interface
const (
	// CTRLA: Control A
	// Position of SWRST field.
	I2S_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	I2S_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	I2S_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	I2S_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	I2S_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	I2S_CTRLA_ENABLE = 0x2
	// Position of CKEN0 field.
	I2S_CTRLA_CKEN0_Pos = 0x2
	// Bit mask of CKEN0 field.
	I2S_CTRLA_CKEN0_Msk = 0x4
	// Bit CKEN0.
	I2S_CTRLA_CKEN0 = 0x4
	// Position of CKEN1 field.
	I2S_CTRLA_CKEN1_Pos = 0x3
	// Bit mask of CKEN1 field.
	I2S_CTRLA_CKEN1_Msk = 0x8
	// Bit CKEN1.
	I2S_CTRLA_CKEN1 = 0x8
	// Position of TXEN field.
	I2S_CTRLA_TXEN_Pos = 0x4
	// Bit mask of TXEN field.
	I2S_CTRLA_TXEN_Msk = 0x10
	// Bit TXEN.
	I2S_CTRLA_TXEN = 0x10
	// Position of RXEN field.
	I2S_CTRLA_RXEN_Pos = 0x5
	// Bit mask of RXEN field.
	I2S_CTRLA_RXEN_Msk = 0x20
	// Bit RXEN.
	I2S_CTRLA_RXEN = 0x20

	// CLKCTRL: Clock Unit n Control
	// Position of SLOTSIZE field.
	I2S_CLKCTRL_SLOTSIZE_Pos = 0x0
	// Bit mask of SLOTSIZE field.
	I2S_CLKCTRL_SLOTSIZE_Msk = 0x3
	// 8-bit Slot for Clock Unit n
	I2S_CLKCTRL_SLOTSIZE_8 = 0x0
	// 16-bit Slot for Clock Unit n
	I2S_CLKCTRL_SLOTSIZE_16 = 0x1
	// 24-bit Slot for Clock Unit n
	I2S_CLKCTRL_SLOTSIZE_24 = 0x2
	// 32-bit Slot for Clock Unit n
	I2S_CLKCTRL_SLOTSIZE_32 = 0x3
	// Position of NBSLOTS field.
	I2S_CLKCTRL_NBSLOTS_Pos = 0x2
	// Bit mask of NBSLOTS field.
	I2S_CLKCTRL_NBSLOTS_Msk = 0x1c
	// Position of FSWIDTH field.
	I2S_CLKCTRL_FSWIDTH_Pos = 0x5
	// Bit mask of FSWIDTH field.
	I2S_CLKCTRL_FSWIDTH_Msk = 0x60
	// Frame Sync Pulse is 1 Slot wide (default for I2S protocol)
	I2S_CLKCTRL_FSWIDTH_SLOT = 0x0
	// Frame Sync Pulse is half a Frame wide
	I2S_CLKCTRL_FSWIDTH_HALF = 0x1
	// Frame Sync Pulse is 1 Bit wide
	I2S_CLKCTRL_FSWIDTH_BIT = 0x2
	// Clock Unit n operates in Burst mode, with a 1-bit wide Frame Sync pulse per Data sample, only when Data transfer is requested
	I2S_CLKCTRL_FSWIDTH_BURST = 0x3
	// Position of BITDELAY field.
	I2S_CLKCTRL_BITDELAY_Pos = 0x7
	// Bit mask of BITDELAY field.
	I2S_CLKCTRL_BITDELAY_Msk = 0x80
	// Bit BITDELAY.
	I2S_CLKCTRL_BITDELAY = 0x80
	// Left Justified (0 Bit Delay)
	I2S_CLKCTRL_BITDELAY_LJ = 0x0
	// I2S (1 Bit Delay)
	I2S_CLKCTRL_BITDELAY_I2S = 0x1
	// Position of FSSEL field.
	I2S_CLKCTRL_FSSEL_Pos = 0x8
	// Bit mask of FSSEL field.
	I2S_CLKCTRL_FSSEL_Msk = 0x100
	// Bit FSSEL.
	I2S_CLKCTRL_FSSEL = 0x100
	// Divided Serial Clock n is used as Frame Sync n source
	I2S_CLKCTRL_FSSEL_SCKDIV = 0x0
	// FSn input pin is used as Frame Sync n source
	I2S_CLKCTRL_FSSEL_FSPIN = 0x1
	// Position of FSINV field.
	I2S_CLKCTRL_FSINV_Pos = 0x9
	// Bit mask of FSINV field.
	I2S_CLKCTRL_FSINV_Msk = 0x200
	// Bit FSINV.
	I2S_CLKCTRL_FSINV = 0x200
	// Position of FSOUTINV field.
	I2S_CLKCTRL_FSOUTINV_Pos = 0xa
	// Bit mask of FSOUTINV field.
	I2S_CLKCTRL_FSOUTINV_Msk = 0x400
	// Bit FSOUTINV.
	I2S_CLKCTRL_FSOUTINV = 0x400
	// Position of SCKSEL field.
	I2S_CLKCTRL_SCKSEL_Pos = 0xb
	// Bit mask of SCKSEL field.
	I2S_CLKCTRL_SCKSEL_Msk = 0x800
	// Bit SCKSEL.
	I2S_CLKCTRL_SCKSEL = 0x800
	// Divided Master Clock n is used as Serial Clock n source
	I2S_CLKCTRL_SCKSEL_MCKDIV = 0x0
	// SCKn input pin is used as Serial Clock n source
	I2S_CLKCTRL_SCKSEL_SCKPIN = 0x1
	// Position of SCKOUTINV field.
	I2S_CLKCTRL_SCKOUTINV_Pos = 0xc
	// Bit mask of SCKOUTINV field.
	I2S_CLKCTRL_SCKOUTINV_Msk = 0x1000
	// Bit SCKOUTINV.
	I2S_CLKCTRL_SCKOUTINV = 0x1000
	// Position of MCKSEL field.
	I2S_CLKCTRL_MCKSEL_Pos = 0xd
	// Bit mask of MCKSEL field.
	I2S_CLKCTRL_MCKSEL_Msk = 0x2000
	// Bit MCKSEL.
	I2S_CLKCTRL_MCKSEL = 0x2000
	// GCLK_I2S_n is used as Master Clock n source
	I2S_CLKCTRL_MCKSEL_GCLK = 0x0
	// MCKn input pin is used as Master Clock n source
	I2S_CLKCTRL_MCKSEL_MCKPIN = 0x1
	// Position of MCKEN field.
	I2S_CLKCTRL_MCKEN_Pos = 0xe
	// Bit mask of MCKEN field.
	I2S_CLKCTRL_MCKEN_Msk = 0x4000
	// Bit MCKEN.
	I2S_CLKCTRL_MCKEN = 0x4000
	// Position of MCKOUTINV field.
	I2S_CLKCTRL_MCKOUTINV_Pos = 0xf
	// Bit mask of MCKOUTINV field.
	I2S_CLKCTRL_MCKOUTINV_Msk = 0x8000
	// Bit MCKOUTINV.
	I2S_CLKCTRL_MCKOUTINV = 0x8000
	// Position of MCKDIV field.
	I2S_CLKCTRL_MCKDIV_Pos = 0x10
	// Bit mask of MCKDIV field.
	I2S_CLKCTRL_MCKDIV_Msk = 0x3f0000
	// Position of MCKOUTDIV field.
	I2S_CLKCTRL_MCKOUTDIV_Pos = 0x18
	// Bit mask of MCKOUTDIV field.
	I2S_CLKCTRL_MCKOUTDIV_Msk = 0x3f000000

	// INTENCLR: Interrupt Enable Clear
	// Position of RXRDY0 field.
	I2S_INTENCLR_RXRDY0_Pos = 0x0
	// Bit mask of RXRDY0 field.
	I2S_INTENCLR_RXRDY0_Msk = 0x1
	// Bit RXRDY0.
	I2S_INTENCLR_RXRDY0 = 0x1
	// Position of RXRDY1 field.
	I2S_INTENCLR_RXRDY1_Pos = 0x1
	// Bit mask of RXRDY1 field.
	I2S_INTENCLR_RXRDY1_Msk = 0x2
	// Bit RXRDY1.
	I2S_INTENCLR_RXRDY1 = 0x2
	// Position of RXOR0 field.
	I2S_INTENCLR_RXOR0_Pos = 0x4
	// Bit mask of RXOR0 field.
	I2S_INTENCLR_RXOR0_Msk = 0x10
	// Bit RXOR0.
	I2S_INTENCLR_RXOR0 = 0x10
	// Position of RXOR1 field.
	I2S_INTENCLR_RXOR1_Pos = 0x5
	// Bit mask of RXOR1 field.
	I2S_INTENCLR_RXOR1_Msk = 0x20
	// Bit RXOR1.
	I2S_INTENCLR_RXOR1 = 0x20
	// Position of TXRDY0 field.
	I2S_INTENCLR_TXRDY0_Pos = 0x8
	// Bit mask of TXRDY0 field.
	I2S_INTENCLR_TXRDY0_Msk = 0x100
	// Bit TXRDY0.
	I2S_INTENCLR_TXRDY0 = 0x100
	// Position of TXRDY1 field.
	I2S_INTENCLR_TXRDY1_Pos = 0x9
	// Bit mask of TXRDY1 field.
	I2S_INTENCLR_TXRDY1_Msk = 0x200
	// Bit TXRDY1.
	I2S_INTENCLR_TXRDY1 = 0x200
	// Position of TXUR0 field.
	I2S_INTENCLR_TXUR0_Pos = 0xc
	// Bit mask of TXUR0 field.
	I2S_INTENCLR_TXUR0_Msk = 0x1000
	// Bit TXUR0.
	I2S_INTENCLR_TXUR0 = 0x1000
	// Position of TXUR1 field.
	I2S_INTENCLR_TXUR1_Pos = 0xd
	// Bit mask of TXUR1 field.
	I2S_INTENCLR_TXUR1_Msk = 0x2000
	// Bit TXUR1.
	I2S_INTENCLR_TXUR1 = 0x2000

	// INTENSET: Interrupt Enable Set
	// Position of RXRDY0 field.
	I2S_INTENSET_RXRDY0_Pos = 0x0
	// Bit mask of RXRDY0 field.
	I2S_INTENSET_RXRDY0_Msk = 0x1
	// Bit RXRDY0.
	I2S_INTENSET_RXRDY0 = 0x1
	// Position of RXRDY1 field.
	I2S_INTENSET_RXRDY1_Pos = 0x1
	// Bit mask of RXRDY1 field.
	I2S_INTENSET_RXRDY1_Msk = 0x2
	// Bit RXRDY1.
	I2S_INTENSET_RXRDY1 = 0x2
	// Position of RXOR0 field.
	I2S_INTENSET_RXOR0_Pos = 0x4
	// Bit mask of RXOR0 field.
	I2S_INTENSET_RXOR0_Msk = 0x10
	// Bit RXOR0.
	I2S_INTENSET_RXOR0 = 0x10
	// Position of RXOR1 field.
	I2S_INTENSET_RXOR1_Pos = 0x5
	// Bit mask of RXOR1 field.
	I2S_INTENSET_RXOR1_Msk = 0x20
	// Bit RXOR1.
	I2S_INTENSET_RXOR1 = 0x20
	// Position of TXRDY0 field.
	I2S_INTENSET_TXRDY0_Pos = 0x8
	// Bit mask of TXRDY0 field.
	I2S_INTENSET_TXRDY0_Msk = 0x100
	// Bit TXRDY0.
	I2S_INTENSET_TXRDY0 = 0x100
	// Position of TXRDY1 field.
	I2S_INTENSET_TXRDY1_Pos = 0x9
	// Bit mask of TXRDY1 field.
	I2S_INTENSET_TXRDY1_Msk = 0x200
	// Bit TXRDY1.
	I2S_INTENSET_TXRDY1 = 0x200
	// Position of TXUR0 field.
	I2S_INTENSET_TXUR0_Pos = 0xc
	// Bit mask of TXUR0 field.
	I2S_INTENSET_TXUR0_Msk = 0x1000
	// Bit TXUR0.
	I2S_INTENSET_TXUR0 = 0x1000
	// Position of TXUR1 field.
	I2S_INTENSET_TXUR1_Pos = 0xd
	// Bit mask of TXUR1 field.
	I2S_INTENSET_TXUR1_Msk = 0x2000
	// Bit TXUR1.
	I2S_INTENSET_TXUR1 = 0x2000

	// INTFLAG: Interrupt Flag Status and Clear
	// Position of RXRDY0 field.
	I2S_INTFLAG_RXRDY0_Pos = 0x0
	// Bit mask of RXRDY0 field.
	I2S_INTFLAG_RXRDY0_Msk = 0x1
	// Bit RXRDY0.
	I2S_INTFLAG_RXRDY0 = 0x1
	// Position of RXRDY1 field.
	I2S_INTFLAG_RXRDY1_Pos = 0x1
	// Bit mask of RXRDY1 field.
	I2S_INTFLAG_RXRDY1_Msk = 0x2
	// Bit RXRDY1.
	I2S_INTFLAG_RXRDY1 = 0x2
	// Position of RXOR0 field.
	I2S_INTFLAG_RXOR0_Pos = 0x4
	// Bit mask of RXOR0 field.
	I2S_INTFLAG_RXOR0_Msk = 0x10
	// Bit RXOR0.
	I2S_INTFLAG_RXOR0 = 0x10
	// Position of RXOR1 field.
	I2S_INTFLAG_RXOR1_Pos = 0x5
	// Bit mask of RXOR1 field.
	I2S_INTFLAG_RXOR1_Msk = 0x20
	// Bit RXOR1.
	I2S_INTFLAG_RXOR1 = 0x20
	// Position of TXRDY0 field.
	I2S_INTFLAG_TXRDY0_Pos = 0x8
	// Bit mask of TXRDY0 field.
	I2S_INTFLAG_TXRDY0_Msk = 0x100
	// Bit TXRDY0.
	I2S_INTFLAG_TXRDY0 = 0x100
	// Position of TXRDY1 field.
	I2S_INTFLAG_TXRDY1_Pos = 0x9
	// Bit mask of TXRDY1 field.
	I2S_INTFLAG_TXRDY1_Msk = 0x200
	// Bit TXRDY1.
	I2S_INTFLAG_TXRDY1 = 0x200
	// Position of TXUR0 field.
	I2S_INTFLAG_TXUR0_Pos = 0xc
	// Bit mask of TXUR0 field.
	I2S_INTFLAG_TXUR0_Msk = 0x1000
	// Bit TXUR0.
	I2S_INTFLAG_TXUR0 = 0x1000
	// Position of TXUR1 field.
	I2S_INTFLAG_TXUR1_Pos = 0xd
	// Bit mask of TXUR1 field.
	I2S_INTFLAG_TXUR1_Msk = 0x2000
	// Bit TXUR1.
	I2S_INTFLAG_TXUR1 = 0x2000

	// SYNCBUSY: Synchronization Status
	// Position of SWRST field.
	I2S_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	I2S_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	I2S_SYNCBUSY_SWRST = 0x1
	// Position of ENABLE field.
	I2S_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	I2S_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	I2S_SYNCBUSY_ENABLE = 0x2
	// Position of CKEN0 field.
	I2S_SYNCBUSY_CKEN0_Pos = 0x2
	// Bit mask of CKEN0 field.
	I2S_SYNCBUSY_CKEN0_Msk = 0x4
	// Bit CKEN0.
	I2S_SYNCBUSY_CKEN0 = 0x4
	// Position of CKEN1 field.
	I2S_SYNCBUSY_CKEN1_Pos = 0x3
	// Bit mask of CKEN1 field.
	I2S_SYNCBUSY_CKEN1_Msk = 0x8
	// Bit CKEN1.
	I2S_SYNCBUSY_CKEN1 = 0x8
	// Position of TXEN field.
	I2S_SYNCBUSY_TXEN_Pos = 0x4
	// Bit mask of TXEN field.
	I2S_SYNCBUSY_TXEN_Msk = 0x10
	// Bit TXEN.
	I2S_SYNCBUSY_TXEN = 0x10
	// Position of RXEN field.
	I2S_SYNCBUSY_RXEN_Pos = 0x5
	// Bit mask of RXEN field.
	I2S_SYNCBUSY_RXEN_Msk = 0x20
	// Bit RXEN.
	I2S_SYNCBUSY_RXEN = 0x20
	// Position of TXDATA field.
	I2S_SYNCBUSY_TXDATA_Pos = 0x8
	// Bit mask of TXDATA field.
	I2S_SYNCBUSY_TXDATA_Msk = 0x100
	// Bit TXDATA.
	I2S_SYNCBUSY_TXDATA = 0x100
	// Position of RXDATA field.
	I2S_SYNCBUSY_RXDATA_Pos = 0x9
	// Bit mask of RXDATA field.
	I2S_SYNCBUSY_RXDATA_Msk = 0x200
	// Bit RXDATA.
	I2S_SYNCBUSY_RXDATA = 0x200

	// TXCTRL: Tx Serializer Control
	// Position of SERMODE field.
	I2S_TXCTRL_SERMODE_Pos = 0x0
	// Bit mask of SERMODE field.
	I2S_TXCTRL_SERMODE_Msk = 0x3
	// Receive
	I2S_TXCTRL_SERMODE_RX = 0x0
	// Transmit
	I2S_TXCTRL_SERMODE_TX = 0x1
	// Receive one PDM data on each serial clock edge
	I2S_TXCTRL_SERMODE_PDM2 = 0x2
	// Position of TXDEFAULT field.
	I2S_TXCTRL_TXDEFAULT_Pos = 0x2
	// Bit mask of TXDEFAULT field.
	I2S_TXCTRL_TXDEFAULT_Msk = 0xc
	// Output Default Value is 0
	I2S_TXCTRL_TXDEFAULT_ZERO = 0x0
	// Output Default Value is 1
	I2S_TXCTRL_TXDEFAULT_ONE = 0x1
	// Output Default Value is high impedance
	I2S_TXCTRL_TXDEFAULT_HIZ = 0x3
	// Position of TXSAME field.
	I2S_TXCTRL_TXSAME_Pos = 0x4
	// Bit mask of TXSAME field.
	I2S_TXCTRL_TXSAME_Msk = 0x10
	// Bit TXSAME.
	I2S_TXCTRL_TXSAME = 0x10
	// Zero data transmitted in case of underrun
	I2S_TXCTRL_TXSAME_ZERO = 0x0
	// Last data transmitted in case of underrun
	I2S_TXCTRL_TXSAME_SAME = 0x1
	// Position of CLKSEL field.
	I2S_TXCTRL_CLKSEL_Pos = 0x5
	// Bit mask of CLKSEL field.
	I2S_TXCTRL_CLKSEL_Msk = 0x20
	// Bit CLKSEL.
	I2S_TXCTRL_CLKSEL = 0x20
	// Use Clock Unit 0
	I2S_TXCTRL_CLKSEL_CLK0 = 0x0
	// Use Clock Unit 1
	I2S_TXCTRL_CLKSEL_CLK1 = 0x1
	// Position of SLOTADJ field.
	I2S_TXCTRL_SLOTADJ_Pos = 0x7
	// Bit mask of SLOTADJ field.
	I2S_TXCTRL_SLOTADJ_Msk = 0x80
	// Bit SLOTADJ.
	I2S_TXCTRL_SLOTADJ = 0x80
	// Data is right adjusted in slot
	I2S_TXCTRL_SLOTADJ_RIGHT = 0x0
	// Data is left adjusted in slot
	I2S_TXCTRL_SLOTADJ_LEFT = 0x1
	// Position of DATASIZE field.
	I2S_TXCTRL_DATASIZE_Pos = 0x8
	// Bit mask of DATASIZE field.
	I2S_TXCTRL_DATASIZE_Msk = 0x700
	// 32 bits
	I2S_TXCTRL_DATASIZE_32 = 0x0
	// 24 bits
	I2S_TXCTRL_DATASIZE_24 = 0x1
	// 20 bits
	I2S_TXCTRL_DATASIZE_20 = 0x2
	// 18 bits
	I2S_TXCTRL_DATASIZE_18 = 0x3
	// 16 bits
	I2S_TXCTRL_DATASIZE_16 = 0x4
	// 16 bits compact stereo
	I2S_TXCTRL_DATASIZE_16C = 0x5
	// 8 bits
	I2S_TXCTRL_DATASIZE_8 = 0x6
	// 8 bits compact stereo
	I2S_TXCTRL_DATASIZE_8C = 0x7
	// Position of WORDADJ field.
	I2S_TXCTRL_WORDADJ_Pos = 0xc
	// Bit mask of WORDADJ field.
	I2S_TXCTRL_WORDADJ_Msk = 0x1000
	// Bit WORDADJ.
	I2S_TXCTRL_WORDADJ = 0x1000
	// Data is right adjusted in word
	I2S_TXCTRL_WORDADJ_RIGHT = 0x0
	// Data is left adjusted in word
	I2S_TXCTRL_WORDADJ_LEFT = 0x1
	// Position of EXTEND field.
	I2S_TXCTRL_EXTEND_Pos = 0xd
	// Bit mask of EXTEND field.
	I2S_TXCTRL_EXTEND_Msk = 0x6000
	// Extend with zeroes
	I2S_TXCTRL_EXTEND_ZERO = 0x0
	// Extend with ones
	I2S_TXCTRL_EXTEND_ONE = 0x1
	// Extend with Most Significant Bit
	I2S_TXCTRL_EXTEND_MSBIT = 0x2
	// Extend with Least Significant Bit
	I2S_TXCTRL_EXTEND_LSBIT = 0x3
	// Position of BITREV field.
	I2S_TXCTRL_BITREV_Pos = 0xf
	// Bit mask of BITREV field.
	I2S_TXCTRL_BITREV_Msk = 0x8000
	// Bit BITREV.
	I2S_TXCTRL_BITREV = 0x8000
	// Transfer Data Most Significant Bit (MSB) first (default for I2S protocol)
	I2S_TXCTRL_BITREV_MSBIT = 0x0
	// Transfer Data Least Significant Bit (LSB) first
	I2S_TXCTRL_BITREV_LSBIT = 0x1
	// Position of SLOTDIS0 field.
	I2S_TXCTRL_SLOTDIS0_Pos = 0x10
	// Bit mask of SLOTDIS0 field.
	I2S_TXCTRL_SLOTDIS0_Msk = 0x10000
	// Bit SLOTDIS0.
	I2S_TXCTRL_SLOTDIS0 = 0x10000
	// Position of SLOTDIS1 field.
	I2S_TXCTRL_SLOTDIS1_Pos = 0x11
	// Bit mask of SLOTDIS1 field.
	I2S_TXCTRL_SLOTDIS1_Msk = 0x20000
	// Bit SLOTDIS1.
	I2S_TXCTRL_SLOTDIS1 = 0x20000
	// Position of SLOTDIS2 field.
	I2S_TXCTRL_SLOTDIS2_Pos = 0x12
	// Bit mask of SLOTDIS2 field.
	I2S_TXCTRL_SLOTDIS2_Msk = 0x40000
	// Bit SLOTDIS2.
	I2S_TXCTRL_SLOTDIS2 = 0x40000
	// Position of SLOTDIS3 field.
	I2S_TXCTRL_SLOTDIS3_Pos = 0x13
	// Bit mask of SLOTDIS3 field.
	I2S_TXCTRL_SLOTDIS3_Msk = 0x80000
	// Bit SLOTDIS3.
	I2S_TXCTRL_SLOTDIS3 = 0x80000
	// Position of SLOTDIS4 field.
	I2S_TXCTRL_SLOTDIS4_Pos = 0x14
	// Bit mask of SLOTDIS4 field.
	I2S_TXCTRL_SLOTDIS4_Msk = 0x100000
	// Bit SLOTDIS4.
	I2S_TXCTRL_SLOTDIS4 = 0x100000
	// Position of SLOTDIS5 field.
	I2S_TXCTRL_SLOTDIS5_Pos = 0x15
	// Bit mask of SLOTDIS5 field.
	I2S_TXCTRL_SLOTDIS5_Msk = 0x200000
	// Bit SLOTDIS5.
	I2S_TXCTRL_SLOTDIS5 = 0x200000
	// Position of SLOTDIS6 field.
	I2S_TXCTRL_SLOTDIS6_Pos = 0x16
	// Bit mask of SLOTDIS6 field.
	I2S_TXCTRL_SLOTDIS6_Msk = 0x400000
	// Bit SLOTDIS6.
	I2S_TXCTRL_SLOTDIS6 = 0x400000
	// Position of SLOTDIS7 field.
	I2S_TXCTRL_SLOTDIS7_Pos = 0x17
	// Bit mask of SLOTDIS7 field.
	I2S_TXCTRL_SLOTDIS7_Msk = 0x800000
	// Bit SLOTDIS7.
	I2S_TXCTRL_SLOTDIS7 = 0x800000
	// Position of MONO field.
	I2S_TXCTRL_MONO_Pos = 0x18
	// Bit mask of MONO field.
	I2S_TXCTRL_MONO_Msk = 0x1000000
	// Bit MONO.
	I2S_TXCTRL_MONO = 0x1000000
	// Normal mode
	I2S_TXCTRL_MONO_STEREO = 0x0
	// Left channel data is duplicated to right channel
	I2S_TXCTRL_MONO_MONO = 0x1
	// Position of DMA field.
	I2S_TXCTRL_DMA_Pos = 0x19
	// Bit mask of DMA field.
	I2S_TXCTRL_DMA_Msk = 0x2000000
	// Bit DMA.
	I2S_TXCTRL_DMA = 0x2000000
	// Single DMA channel
	I2S_TXCTRL_DMA_SINGLE = 0x0
	// One DMA channel per data channel
	I2S_TXCTRL_DMA_MULTIPLE = 0x1

	// RXCTRL: Rx Serializer Control
	// Position of SERMODE field.
	I2S_RXCTRL_SERMODE_Pos = 0x0
	// Bit mask of SERMODE field.
	I2S_RXCTRL_SERMODE_Msk = 0x3
	// Receive
	I2S_RXCTRL_SERMODE_RX = 0x0
	// Receive one PDM data on each serial clock edge
	I2S_RXCTRL_SERMODE_PDM2 = 0x2
	// Position of CLKSEL field.
	I2S_RXCTRL_CLKSEL_Pos = 0x5
	// Bit mask of CLKSEL field.
	I2S_RXCTRL_CLKSEL_Msk = 0x20
	// Bit CLKSEL.
	I2S_RXCTRL_CLKSEL = 0x20
	// Use Clock Unit 0
	I2S_RXCTRL_CLKSEL_CLK0 = 0x0
	// Use Clock Unit 1
	I2S_RXCTRL_CLKSEL_CLK1 = 0x1
	// Position of SLOTADJ field.
	I2S_RXCTRL_SLOTADJ_Pos = 0x7
	// Bit mask of SLOTADJ field.
	I2S_RXCTRL_SLOTADJ_Msk = 0x80
	// Bit SLOTADJ.
	I2S_RXCTRL_SLOTADJ = 0x80
	// Data is right adjusted in slot
	I2S_RXCTRL_SLOTADJ_RIGHT = 0x0
	// Data is left adjusted in slot
	I2S_RXCTRL_SLOTADJ_LEFT = 0x1
	// Position of DATASIZE field.
	I2S_RXCTRL_DATASIZE_Pos = 0x8
	// Bit mask of DATASIZE field.
	I2S_RXCTRL_DATASIZE_Msk = 0x700
	// 32 bits
	I2S_RXCTRL_DATASIZE_32 = 0x0
	// 24 bits
	I2S_RXCTRL_DATASIZE_24 = 0x1
	// 20 bits
	I2S_RXCTRL_DATASIZE_20 = 0x2
	// 18 bits
	I2S_RXCTRL_DATASIZE_18 = 0x3
	// 16 bits
	I2S_RXCTRL_DATASIZE_16 = 0x4
	// 16 bits compact stereo
	I2S_RXCTRL_DATASIZE_16C = 0x5
	// 8 bits
	I2S_RXCTRL_DATASIZE_8 = 0x6
	// 8 bits compact stereo
	I2S_RXCTRL_DATASIZE_8C = 0x7
	// Position of WORDADJ field.
	I2S_RXCTRL_WORDADJ_Pos = 0xc
	// Bit mask of WORDADJ field.
	I2S_RXCTRL_WORDADJ_Msk = 0x1000
	// Bit WORDADJ.
	I2S_RXCTRL_WORDADJ = 0x1000
	// Data is right adjusted in word
	I2S_RXCTRL_WORDADJ_RIGHT = 0x0
	// Data is left adjusted in word
	I2S_RXCTRL_WORDADJ_LEFT = 0x1
	// Position of EXTEND field.
	I2S_RXCTRL_EXTEND_Pos = 0xd
	// Bit mask of EXTEND field.
	I2S_RXCTRL_EXTEND_Msk = 0x6000
	// Extend with zeroes
	I2S_RXCTRL_EXTEND_ZERO = 0x0
	// Extend with ones
	I2S_RXCTRL_EXTEND_ONE = 0x1
	// Extend with Most Significant Bit
	I2S_RXCTRL_EXTEND_MSBIT = 0x2
	// Extend with Least Significant Bit
	I2S_RXCTRL_EXTEND_LSBIT = 0x3
	// Position of BITREV field.
	I2S_RXCTRL_BITREV_Pos = 0xf
	// Bit mask of BITREV field.
	I2S_RXCTRL_BITREV_Msk = 0x8000
	// Bit BITREV.
	I2S_RXCTRL_BITREV = 0x8000
	// Transfer Data Most Significant Bit (MSB) first (default for I2S protocol)
	I2S_RXCTRL_BITREV_MSBIT = 0x0
	// Transfer Data Least Significant Bit (LSB) first
	I2S_RXCTRL_BITREV_LSBIT = 0x1
	// Position of SLOTDIS0 field.
	I2S_RXCTRL_SLOTDIS0_Pos = 0x10
	// Bit mask of SLOTDIS0 field.
	I2S_RXCTRL_SLOTDIS0_Msk = 0x10000
	// Bit SLOTDIS0.
	I2S_RXCTRL_SLOTDIS0 = 0x10000
	// Position of SLOTDIS1 field.
	I2S_RXCTRL_SLOTDIS1_Pos = 0x11
	// Bit mask of SLOTDIS1 field.
	I2S_RXCTRL_SLOTDIS1_Msk = 0x20000
	// Bit SLOTDIS1.
	I2S_RXCTRL_SLOTDIS1 = 0x20000
	// Position of SLOTDIS2 field.
	I2S_RXCTRL_SLOTDIS2_Pos = 0x12
	// Bit mask of SLOTDIS2 field.
	I2S_RXCTRL_SLOTDIS2_Msk = 0x40000
	// Bit SLOTDIS2.
	I2S_RXCTRL_SLOTDIS2 = 0x40000
	// Position of SLOTDIS3 field.
	I2S_RXCTRL_SLOTDIS3_Pos = 0x13
	// Bit mask of SLOTDIS3 field.
	I2S_RXCTRL_SLOTDIS3_Msk = 0x80000
	// Bit SLOTDIS3.
	I2S_RXCTRL_SLOTDIS3 = 0x80000
	// Position of SLOTDIS4 field.
	I2S_RXCTRL_SLOTDIS4_Pos = 0x14
	// Bit mask of SLOTDIS4 field.
	I2S_RXCTRL_SLOTDIS4_Msk = 0x100000
	// Bit SLOTDIS4.
	I2S_RXCTRL_SLOTDIS4 = 0x100000
	// Position of SLOTDIS5 field.
	I2S_RXCTRL_SLOTDIS5_Pos = 0x15
	// Bit mask of SLOTDIS5 field.
	I2S_RXCTRL_SLOTDIS5_Msk = 0x200000
	// Bit SLOTDIS5.
	I2S_RXCTRL_SLOTDIS5 = 0x200000
	// Position of SLOTDIS6 field.
	I2S_RXCTRL_SLOTDIS6_Pos = 0x16
	// Bit mask of SLOTDIS6 field.
	I2S_RXCTRL_SLOTDIS6_Msk = 0x400000
	// Bit SLOTDIS6.
	I2S_RXCTRL_SLOTDIS6 = 0x400000
	// Position of SLOTDIS7 field.
	I2S_RXCTRL_SLOTDIS7_Pos = 0x17
	// Bit mask of SLOTDIS7 field.
	I2S_RXCTRL_SLOTDIS7_Msk = 0x800000
	// Bit SLOTDIS7.
	I2S_RXCTRL_SLOTDIS7 = 0x800000
	// Position of MONO field.
	I2S_RXCTRL_MONO_Pos = 0x18
	// Bit mask of MONO field.
	I2S_RXCTRL_MONO_Msk = 0x1000000
	// Bit MONO.
	I2S_RXCTRL_MONO = 0x1000000
	// Normal mode
	I2S_RXCTRL_MONO_STEREO = 0x0
	// Left channel data is duplicated to right channel
	I2S_RXCTRL_MONO_MONO = 0x1
	// Position of DMA field.
	I2S_RXCTRL_DMA_Pos = 0x19
	// Bit mask of DMA field.
	I2S_RXCTRL_DMA_Msk = 0x2000000
	// Bit DMA.
	I2S_RXCTRL_DMA = 0x2000000
	// Single DMA channel
	I2S_RXCTRL_DMA_SINGLE = 0x0
	// One DMA channel per data channel
	I2S_RXCTRL_DMA_MULTIPLE = 0x1
	// Position of RXLOOP field.
	I2S_RXCTRL_RXLOOP_Pos = 0x1a
	// Bit mask of RXLOOP field.
	I2S_RXCTRL_RXLOOP_Msk = 0x4000000
	// Bit RXLOOP.
	I2S_RXCTRL_RXLOOP = 0x4000000

	// TXDATA: Tx Data
	// Position of DATA field.
	I2S_TXDATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	I2S_TXDATA_DATA_Msk = 0xffffffff

	// RXDATA: Rx Data
	// Position of DATA field.
	I2S_RXDATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	I2S_RXDATA_DATA_Msk = 0xffffffff
)

// Constants for MCLK: Main Clock
const (
	// INTENCLR: Interrupt Enable Clear
	// Position of CKRDY field.
	MCLK_INTENCLR_CKRDY_Pos = 0x0
	// Bit mask of CKRDY field.
	MCLK_INTENCLR_CKRDY_Msk = 0x1
	// Bit CKRDY.
	MCLK_INTENCLR_CKRDY = 0x1

	// INTENSET: Interrupt Enable Set
	// Position of CKRDY field.
	MCLK_INTENSET_CKRDY_Pos = 0x0
	// Bit mask of CKRDY field.
	MCLK_INTENSET_CKRDY_Msk = 0x1
	// Bit CKRDY.
	MCLK_INTENSET_CKRDY = 0x1

	// INTFLAG: Interrupt Flag Status and Clear
	// Position of CKRDY field.
	MCLK_INTFLAG_CKRDY_Pos = 0x0
	// Bit mask of CKRDY field.
	MCLK_INTFLAG_CKRDY_Msk = 0x1
	// Bit CKRDY.
	MCLK_INTFLAG_CKRDY = 0x1

	// HSDIV: HS Clock Division
	// Position of DIV field.
	MCLK_HSDIV_DIV_Pos = 0x0
	// Bit mask of DIV field.
	MCLK_HSDIV_DIV_Msk = 0xff
	// Divide by 1
	MCLK_HSDIV_DIV_DIV1 = 0x1

	// CPUDIV: CPU Clock Division
	// Position of DIV field.
	MCLK_CPUDIV_DIV_Pos = 0x0
	// Bit mask of DIV field.
	MCLK_CPUDIV_DIV_Msk = 0xff
	// Divide by 1
	MCLK_CPUDIV_DIV_DIV1 = 0x1
	// Divide by 2
	MCLK_CPUDIV_DIV_DIV2 = 0x2
	// Divide by 4
	MCLK_CPUDIV_DIV_DIV4 = 0x4
	// Divide by 8
	MCLK_CPUDIV_DIV_DIV8 = 0x8
	// Divide by 16
	MCLK_CPUDIV_DIV_DIV16 = 0x10
	// Divide by 32
	MCLK_CPUDIV_DIV_DIV32 = 0x20
	// Divide by 64
	MCLK_CPUDIV_DIV_DIV64 = 0x40
	// Divide by 128
	MCLK_CPUDIV_DIV_DIV128 = 0x80

	// AHBMASK: AHB Mask
	// Position of HPB0_ field.
	MCLK_AHBMASK_HPB0__Pos = 0x0
	// Bit mask of HPB0_ field.
	MCLK_AHBMASK_HPB0__Msk = 0x1
	// Bit HPB0_.
	MCLK_AHBMASK_HPB0_ = 0x1
	// Position of HPB1_ field.
	MCLK_AHBMASK_HPB1__Pos = 0x1
	// Bit mask of HPB1_ field.
	MCLK_AHBMASK_HPB1__Msk = 0x2
	// Bit HPB1_.
	MCLK_AHBMASK_HPB1_ = 0x2
	// Position of HPB2_ field.
	MCLK_AHBMASK_HPB2__Pos = 0x2
	// Bit mask of HPB2_ field.
	MCLK_AHBMASK_HPB2__Msk = 0x4
	// Bit HPB2_.
	MCLK_AHBMASK_HPB2_ = 0x4
	// Position of HPB3_ field.
	MCLK_AHBMASK_HPB3__Pos = 0x3
	// Bit mask of HPB3_ field.
	MCLK_AHBMASK_HPB3__Msk = 0x8
	// Bit HPB3_.
	MCLK_AHBMASK_HPB3_ = 0x8
	// Position of DSU_ field.
	MCLK_AHBMASK_DSU__Pos = 0x4
	// Bit mask of DSU_ field.
	MCLK_AHBMASK_DSU__Msk = 0x10
	// Bit DSU_.
	MCLK_AHBMASK_DSU_ = 0x10
	// Position of HMATRIX_ field.
	MCLK_AHBMASK_HMATRIX__Pos = 0x5
	// Bit mask of HMATRIX_ field.
	MCLK_AHBMASK_HMATRIX__Msk = 0x20
	// Bit HMATRIX_.
	MCLK_AHBMASK_HMATRIX_ = 0x20
	// Position of NVMCTRL_ field.
	MCLK_AHBMASK_NVMCTRL__Pos = 0x6
	// Bit mask of NVMCTRL_ field.
	MCLK_AHBMASK_NVMCTRL__Msk = 0x40
	// Bit NVMCTRL_.
	MCLK_AHBMASK_NVMCTRL_ = 0x40
	// Position of HSRAM_ field.
	MCLK_AHBMASK_HSRAM__Pos = 0x7
	// Bit mask of HSRAM_ field.
	MCLK_AHBMASK_HSRAM__Msk = 0x80
	// Bit HSRAM_.
	MCLK_AHBMASK_HSRAM_ = 0x80
	// Position of CMCC_ field.
	MCLK_AHBMASK_CMCC__Pos = 0x8
	// Bit mask of CMCC_ field.
	MCLK_AHBMASK_CMCC__Msk = 0x100
	// Bit CMCC_.
	MCLK_AHBMASK_CMCC_ = 0x100
	// Position of DMAC_ field.
	MCLK_AHBMASK_DMAC__Pos = 0x9
	// Bit mask of DMAC_ field.
	MCLK_AHBMASK_DMAC__Msk = 0x200
	// Bit DMAC_.
	MCLK_AHBMASK_DMAC_ = 0x200
	// Position of USB_ field.
	MCLK_AHBMASK_USB__Pos = 0xa
	// Bit mask of USB_ field.
	MCLK_AHBMASK_USB__Msk = 0x400
	// Bit USB_.
	MCLK_AHBMASK_USB_ = 0x400
	// Position of BKUPRAM_ field.
	MCLK_AHBMASK_BKUPRAM__Pos = 0xb
	// Bit mask of BKUPRAM_ field.
	MCLK_AHBMASK_BKUPRAM__Msk = 0x800
	// Bit BKUPRAM_.
	MCLK_AHBMASK_BKUPRAM_ = 0x800
	// Position of PAC_ field.
	MCLK_AHBMASK_PAC__Pos = 0xc
	// Bit mask of PAC_ field.
	MCLK_AHBMASK_PAC__Msk = 0x1000
	// Bit PAC_.
	MCLK_AHBMASK_PAC_ = 0x1000
	// Position of QSPI_ field.
	MCLK_AHBMASK_QSPI__Pos = 0xd
	// Bit mask of QSPI_ field.
	MCLK_AHBMASK_QSPI__Msk = 0x2000
	// Bit QSPI_.
	MCLK_AHBMASK_QSPI_ = 0x2000
	// Position of GMAC_ field.
	MCLK_AHBMASK_GMAC__Pos = 0xe
	// Bit mask of GMAC_ field.
	MCLK_AHBMASK_GMAC__Msk = 0x4000
	// Bit GMAC_.
	MCLK_AHBMASK_GMAC_ = 0x4000
	// Position of SDHC0_ field.
	MCLK_AHBMASK_SDHC0__Pos = 0xf
	// Bit mask of SDHC0_ field.
	MCLK_AHBMASK_SDHC0__Msk = 0x8000
	// Bit SDHC0_.
	MCLK_AHBMASK_SDHC0_ = 0x8000
	// Position of ICM_ field.
	MCLK_AHBMASK_ICM__Pos = 0x13
	// Bit mask of ICM_ field.
	MCLK_AHBMASK_ICM__Msk = 0x80000
	// Bit ICM_.
	MCLK_AHBMASK_ICM_ = 0x80000
	// Position of PUKCC_ field.
	MCLK_AHBMASK_PUKCC__Pos = 0x14
	// Bit mask of PUKCC_ field.
	MCLK_AHBMASK_PUKCC__Msk = 0x100000
	// Bit PUKCC_.
	MCLK_AHBMASK_PUKCC_ = 0x100000
	// Position of QSPI_2X_ field.
	MCLK_AHBMASK_QSPI_2X__Pos = 0x15
	// Bit mask of QSPI_2X_ field.
	MCLK_AHBMASK_QSPI_2X__Msk = 0x200000
	// Bit QSPI_2X_.
	MCLK_AHBMASK_QSPI_2X_ = 0x200000
	// Position of NVMCTRL_SMEEPROM_ field.
	MCLK_AHBMASK_NVMCTRL_SMEEPROM__Pos = 0x16
	// Bit mask of NVMCTRL_SMEEPROM_ field.
	MCLK_AHBMASK_NVMCTRL_SMEEPROM__Msk = 0x400000
	// Bit NVMCTRL_SMEEPROM_.
	MCLK_AHBMASK_NVMCTRL_SMEEPROM_ = 0x400000
	// Position of NVMCTRL_CACHE_ field.
	MCLK_AHBMASK_NVMCTRL_CACHE__Pos = 0x17
	// Bit mask of NVMCTRL_CACHE_ field.
	MCLK_AHBMASK_NVMCTRL_CACHE__Msk = 0x800000
	// Bit NVMCTRL_CACHE_.
	MCLK_AHBMASK_NVMCTRL_CACHE_ = 0x800000

	// APBAMASK: APBA Mask
	// Position of PAC_ field.
	MCLK_APBAMASK_PAC__Pos = 0x0
	// Bit mask of PAC_ field.
	MCLK_APBAMASK_PAC__Msk = 0x1
	// Bit PAC_.
	MCLK_APBAMASK_PAC_ = 0x1
	// Position of PM_ field.
	MCLK_APBAMASK_PM__Pos = 0x1
	// Bit mask of PM_ field.
	MCLK_APBAMASK_PM__Msk = 0x2
	// Bit PM_.
	MCLK_APBAMASK_PM_ = 0x2
	// Position of MCLK_ field.
	MCLK_APBAMASK_MCLK__Pos = 0x2
	// Bit mask of MCLK_ field.
	MCLK_APBAMASK_MCLK__Msk = 0x4
	// Bit MCLK_.
	MCLK_APBAMASK_MCLK_ = 0x4
	// Position of RSTC_ field.
	MCLK_APBAMASK_RSTC__Pos = 0x3
	// Bit mask of RSTC_ field.
	MCLK_APBAMASK_RSTC__Msk = 0x8
	// Bit RSTC_.
	MCLK_APBAMASK_RSTC_ = 0x8
	// Position of OSCCTRL_ field.
	MCLK_APBAMASK_OSCCTRL__Pos = 0x4
	// Bit mask of OSCCTRL_ field.
	MCLK_APBAMASK_OSCCTRL__Msk = 0x10
	// Bit OSCCTRL_.
	MCLK_APBAMASK_OSCCTRL_ = 0x10
	// Position of OSC32KCTRL_ field.
	MCLK_APBAMASK_OSC32KCTRL__Pos = 0x5
	// Bit mask of OSC32KCTRL_ field.
	MCLK_APBAMASK_OSC32KCTRL__Msk = 0x20
	// Bit OSC32KCTRL_.
	MCLK_APBAMASK_OSC32KCTRL_ = 0x20
	// Position of SUPC_ field.
	MCLK_APBAMASK_SUPC__Pos = 0x6
	// Bit mask of SUPC_ field.
	MCLK_APBAMASK_SUPC__Msk = 0x40
	// Bit SUPC_.
	MCLK_APBAMASK_SUPC_ = 0x40
	// Position of GCLK_ field.
	MCLK_APBAMASK_GCLK__Pos = 0x7
	// Bit mask of GCLK_ field.
	MCLK_APBAMASK_GCLK__Msk = 0x80
	// Bit GCLK_.
	MCLK_APBAMASK_GCLK_ = 0x80
	// Position of WDT_ field.
	MCLK_APBAMASK_WDT__Pos = 0x8
	// Bit mask of WDT_ field.
	MCLK_APBAMASK_WDT__Msk = 0x100
	// Bit WDT_.
	MCLK_APBAMASK_WDT_ = 0x100
	// Position of RTC_ field.
	MCLK_APBAMASK_RTC__Pos = 0x9
	// Bit mask of RTC_ field.
	MCLK_APBAMASK_RTC__Msk = 0x200
	// Bit RTC_.
	MCLK_APBAMASK_RTC_ = 0x200
	// Position of EIC_ field.
	MCLK_APBAMASK_EIC__Pos = 0xa
	// Bit mask of EIC_ field.
	MCLK_APBAMASK_EIC__Msk = 0x400
	// Bit EIC_.
	MCLK_APBAMASK_EIC_ = 0x400
	// Position of FREQM_ field.
	MCLK_APBAMASK_FREQM__Pos = 0xb
	// Bit mask of FREQM_ field.
	MCLK_APBAMASK_FREQM__Msk = 0x800
	// Bit FREQM_.
	MCLK_APBAMASK_FREQM_ = 0x800
	// Position of SERCOM0_ field.
	MCLK_APBAMASK_SERCOM0__Pos = 0xc
	// Bit mask of SERCOM0_ field.
	MCLK_APBAMASK_SERCOM0__Msk = 0x1000
	// Bit SERCOM0_.
	MCLK_APBAMASK_SERCOM0_ = 0x1000
	// Position of SERCOM1_ field.
	MCLK_APBAMASK_SERCOM1__Pos = 0xd
	// Bit mask of SERCOM1_ field.
	MCLK_APBAMASK_SERCOM1__Msk = 0x2000
	// Bit SERCOM1_.
	MCLK_APBAMASK_SERCOM1_ = 0x2000
	// Position of TC0_ field.
	MCLK_APBAMASK_TC0__Pos = 0xe
	// Bit mask of TC0_ field.
	MCLK_APBAMASK_TC0__Msk = 0x4000
	// Bit TC0_.
	MCLK_APBAMASK_TC0_ = 0x4000
	// Position of TC1_ field.
	MCLK_APBAMASK_TC1__Pos = 0xf
	// Bit mask of TC1_ field.
	MCLK_APBAMASK_TC1__Msk = 0x8000
	// Bit TC1_.
	MCLK_APBAMASK_TC1_ = 0x8000

	// APBBMASK: APBB Mask
	// Position of USB_ field.
	MCLK_APBBMASK_USB__Pos = 0x0
	// Bit mask of USB_ field.
	MCLK_APBBMASK_USB__Msk = 0x1
	// Bit USB_.
	MCLK_APBBMASK_USB_ = 0x1
	// Position of DSU_ field.
	MCLK_APBBMASK_DSU__Pos = 0x1
	// Bit mask of DSU_ field.
	MCLK_APBBMASK_DSU__Msk = 0x2
	// Bit DSU_.
	MCLK_APBBMASK_DSU_ = 0x2
	// Position of NVMCTRL_ field.
	MCLK_APBBMASK_NVMCTRL__Pos = 0x2
	// Bit mask of NVMCTRL_ field.
	MCLK_APBBMASK_NVMCTRL__Msk = 0x4
	// Bit NVMCTRL_.
	MCLK_APBBMASK_NVMCTRL_ = 0x4
	// Position of PORT_ field.
	MCLK_APBBMASK_PORT__Pos = 0x4
	// Bit mask of PORT_ field.
	MCLK_APBBMASK_PORT__Msk = 0x10
	// Bit PORT_.
	MCLK_APBBMASK_PORT_ = 0x10
	// Position of HMATRIX_ field.
	MCLK_APBBMASK_HMATRIX__Pos = 0x6
	// Bit mask of HMATRIX_ field.
	MCLK_APBBMASK_HMATRIX__Msk = 0x40
	// Bit HMATRIX_.
	MCLK_APBBMASK_HMATRIX_ = 0x40
	// Position of EVSYS_ field.
	MCLK_APBBMASK_EVSYS__Pos = 0x7
	// Bit mask of EVSYS_ field.
	MCLK_APBBMASK_EVSYS__Msk = 0x80
	// Bit EVSYS_.
	MCLK_APBBMASK_EVSYS_ = 0x80
	// Position of SERCOM2_ field.
	MCLK_APBBMASK_SERCOM2__Pos = 0x9
	// Bit mask of SERCOM2_ field.
	MCLK_APBBMASK_SERCOM2__Msk = 0x200
	// Bit SERCOM2_.
	MCLK_APBBMASK_SERCOM2_ = 0x200
	// Position of SERCOM3_ field.
	MCLK_APBBMASK_SERCOM3__Pos = 0xa
	// Bit mask of SERCOM3_ field.
	MCLK_APBBMASK_SERCOM3__Msk = 0x400
	// Bit SERCOM3_.
	MCLK_APBBMASK_SERCOM3_ = 0x400
	// Position of TCC0_ field.
	MCLK_APBBMASK_TCC0__Pos = 0xb
	// Bit mask of TCC0_ field.
	MCLK_APBBMASK_TCC0__Msk = 0x800
	// Bit TCC0_.
	MCLK_APBBMASK_TCC0_ = 0x800
	// Position of TCC1_ field.
	MCLK_APBBMASK_TCC1__Pos = 0xc
	// Bit mask of TCC1_ field.
	MCLK_APBBMASK_TCC1__Msk = 0x1000
	// Bit TCC1_.
	MCLK_APBBMASK_TCC1_ = 0x1000
	// Position of TC2_ field.
	MCLK_APBBMASK_TC2__Pos = 0xd
	// Bit mask of TC2_ field.
	MCLK_APBBMASK_TC2__Msk = 0x2000
	// Bit TC2_.
	MCLK_APBBMASK_TC2_ = 0x2000
	// Position of TC3_ field.
	MCLK_APBBMASK_TC3__Pos = 0xe
	// Bit mask of TC3_ field.
	MCLK_APBBMASK_TC3__Msk = 0x4000
	// Bit TC3_.
	MCLK_APBBMASK_TC3_ = 0x4000
	// Position of RAMECC_ field.
	MCLK_APBBMASK_RAMECC__Pos = 0x10
	// Bit mask of RAMECC_ field.
	MCLK_APBBMASK_RAMECC__Msk = 0x10000
	// Bit RAMECC_.
	MCLK_APBBMASK_RAMECC_ = 0x10000

	// APBCMASK: APBC Mask
	// Position of GMAC_ field.
	MCLK_APBCMASK_GMAC__Pos = 0x2
	// Bit mask of GMAC_ field.
	MCLK_APBCMASK_GMAC__Msk = 0x4
	// Bit GMAC_.
	MCLK_APBCMASK_GMAC_ = 0x4
	// Position of TCC2_ field.
	MCLK_APBCMASK_TCC2__Pos = 0x3
	// Bit mask of TCC2_ field.
	MCLK_APBCMASK_TCC2__Msk = 0x8
	// Bit TCC2_.
	MCLK_APBCMASK_TCC2_ = 0x8
	// Position of TCC3_ field.
	MCLK_APBCMASK_TCC3__Pos = 0x4
	// Bit mask of TCC3_ field.
	MCLK_APBCMASK_TCC3__Msk = 0x10
	// Bit TCC3_.
	MCLK_APBCMASK_TCC3_ = 0x10
	// Position of TC4_ field.
	MCLK_APBCMASK_TC4__Pos = 0x5
	// Bit mask of TC4_ field.
	MCLK_APBCMASK_TC4__Msk = 0x20
	// Bit TC4_.
	MCLK_APBCMASK_TC4_ = 0x20
	// Position of TC5_ field.
	MCLK_APBCMASK_TC5__Pos = 0x6
	// Bit mask of TC5_ field.
	MCLK_APBCMASK_TC5__Msk = 0x40
	// Bit TC5_.
	MCLK_APBCMASK_TC5_ = 0x40
	// Position of PDEC_ field.
	MCLK_APBCMASK_PDEC__Pos = 0x7
	// Bit mask of PDEC_ field.
	MCLK_APBCMASK_PDEC__Msk = 0x80
	// Bit PDEC_.
	MCLK_APBCMASK_PDEC_ = 0x80
	// Position of AC_ field.
	MCLK_APBCMASK_AC__Pos = 0x8
	// Bit mask of AC_ field.
	MCLK_APBCMASK_AC__Msk = 0x100
	// Bit AC_.
	MCLK_APBCMASK_AC_ = 0x100
	// Position of AES_ field.
	MCLK_APBCMASK_AES__Pos = 0x9
	// Bit mask of AES_ field.
	MCLK_APBCMASK_AES__Msk = 0x200
	// Bit AES_.
	MCLK_APBCMASK_AES_ = 0x200
	// Position of TRNG_ field.
	MCLK_APBCMASK_TRNG__Pos = 0xa
	// Bit mask of TRNG_ field.
	MCLK_APBCMASK_TRNG__Msk = 0x400
	// Bit TRNG_.
	MCLK_APBCMASK_TRNG_ = 0x400
	// Position of ICM_ field.
	MCLK_APBCMASK_ICM__Pos = 0xb
	// Bit mask of ICM_ field.
	MCLK_APBCMASK_ICM__Msk = 0x800
	// Bit ICM_.
	MCLK_APBCMASK_ICM_ = 0x800
	// Position of QSPI_ field.
	MCLK_APBCMASK_QSPI__Pos = 0xd
	// Bit mask of QSPI_ field.
	MCLK_APBCMASK_QSPI__Msk = 0x2000
	// Bit QSPI_.
	MCLK_APBCMASK_QSPI_ = 0x2000
	// Position of CCL_ field.
	MCLK_APBCMASK_CCL__Pos = 0xe
	// Bit mask of CCL_ field.
	MCLK_APBCMASK_CCL__Msk = 0x4000
	// Bit CCL_.
	MCLK_APBCMASK_CCL_ = 0x4000

	// APBDMASK: APBD Mask
	// Position of SERCOM4_ field.
	MCLK_APBDMASK_SERCOM4__Pos = 0x0
	// Bit mask of SERCOM4_ field.
	MCLK_APBDMASK_SERCOM4__Msk = 0x1
	// Bit SERCOM4_.
	MCLK_APBDMASK_SERCOM4_ = 0x1
	// Position of SERCOM5_ field.
	MCLK_APBDMASK_SERCOM5__Pos = 0x1
	// Bit mask of SERCOM5_ field.
	MCLK_APBDMASK_SERCOM5__Msk = 0x2
	// Bit SERCOM5_.
	MCLK_APBDMASK_SERCOM5_ = 0x2
	// Position of TCC4_ field.
	MCLK_APBDMASK_TCC4__Pos = 0x4
	// Bit mask of TCC4_ field.
	MCLK_APBDMASK_TCC4__Msk = 0x10
	// Bit TCC4_.
	MCLK_APBDMASK_TCC4_ = 0x10
	// Position of ADC0_ field.
	MCLK_APBDMASK_ADC0__Pos = 0x7
	// Bit mask of ADC0_ field.
	MCLK_APBDMASK_ADC0__Msk = 0x80
	// Bit ADC0_.
	MCLK_APBDMASK_ADC0_ = 0x80
	// Position of ADC1_ field.
	MCLK_APBDMASK_ADC1__Pos = 0x8
	// Bit mask of ADC1_ field.
	MCLK_APBDMASK_ADC1__Msk = 0x100
	// Bit ADC1_.
	MCLK_APBDMASK_ADC1_ = 0x100
	// Position of DAC_ field.
	MCLK_APBDMASK_DAC__Pos = 0x9
	// Bit mask of DAC_ field.
	MCLK_APBDMASK_DAC__Msk = 0x200
	// Bit DAC_.
	MCLK_APBDMASK_DAC_ = 0x200
	// Position of I2S_ field.
	MCLK_APBDMASK_I2S__Pos = 0xa
	// Bit mask of I2S_ field.
	MCLK_APBDMASK_I2S__Msk = 0x400
	// Bit I2S_.
	MCLK_APBDMASK_I2S_ = 0x400
	// Position of PCC_ field.
	MCLK_APBDMASK_PCC__Pos = 0xb
	// Bit mask of PCC_ field.
	MCLK_APBDMASK_PCC__Msk = 0x800
	// Bit PCC_.
	MCLK_APBDMASK_PCC_ = 0x800
)

// Constants for NVMCTRL: Non-Volatile Memory Controller
const (
	// CTRLA: Control A
	// Position of AUTOWS field.
	NVMCTRL_CTRLA_AUTOWS_Pos = 0x2
	// Bit mask of AUTOWS field.
	NVMCTRL_CTRLA_AUTOWS_Msk = 0x4
	// Bit AUTOWS.
	NVMCTRL_CTRLA_AUTOWS = 0x4
	// Position of SUSPEN field.
	NVMCTRL_CTRLA_SUSPEN_Pos = 0x3
	// Bit mask of SUSPEN field.
	NVMCTRL_CTRLA_SUSPEN_Msk = 0x8
	// Bit SUSPEN.
	NVMCTRL_CTRLA_SUSPEN = 0x8
	// Position of WMODE field.
	NVMCTRL_CTRLA_WMODE_Pos = 0x4
	// Bit mask of WMODE field.
	NVMCTRL_CTRLA_WMODE_Msk = 0x30
	// Manual Write
	NVMCTRL_CTRLA_WMODE_MAN = 0x0
	// Automatic Double Word Write
	NVMCTRL_CTRLA_WMODE_ADW = 0x1
	// Automatic Quad Word
	NVMCTRL_CTRLA_WMODE_AQW = 0x2
	// Automatic Page Write
	NVMCTRL_CTRLA_WMODE_AP = 0x3
	// Position of PRM field.
	NVMCTRL_CTRLA_PRM_Pos = 0x6
	// Bit mask of PRM field.
	NVMCTRL_CTRLA_PRM_Msk = 0xc0
	// NVM block enters low-power mode when entering standby mode. NVM block enters low-power mode when SPRM command is issued. NVM block exits low-power mode upon first access.
	NVMCTRL_CTRLA_PRM_SEMIAUTO = 0x0
	// NVM block enters low-power mode when entering standby mode. NVM block enters low-power mode when SPRM command is issued. NVM block exits low-power mode when system is not in standby mode.
	NVMCTRL_CTRLA_PRM_FULLAUTO = 0x1
	// NVM block does not enter low-power mode when entering standby mode. NVM block enters low-power mode when SPRM command is issued. NVM block exits low-power mode upon first access.
	NVMCTRL_CTRLA_PRM_MANUAL = 0x3
	// Position of RWS field.
	NVMCTRL_CTRLA_RWS_Pos = 0x8
	// Bit mask of RWS field.
	NVMCTRL_CTRLA_RWS_Msk = 0xf00
	// Position of AHBNS0 field.
	NVMCTRL_CTRLA_AHBNS0_Pos = 0xc
	// Bit mask of AHBNS0 field.
	NVMCTRL_CTRLA_AHBNS0_Msk = 0x1000
	// Bit AHBNS0.
	NVMCTRL_CTRLA_AHBNS0 = 0x1000
	// Position of AHBNS1 field.
	NVMCTRL_CTRLA_AHBNS1_Pos = 0xd
	// Bit mask of AHBNS1 field.
	NVMCTRL_CTRLA_AHBNS1_Msk = 0x2000
	// Bit AHBNS1.
	NVMCTRL_CTRLA_AHBNS1 = 0x2000
	// Position of CACHEDIS0 field.
	NVMCTRL_CTRLA_CACHEDIS0_Pos = 0xe
	// Bit mask of CACHEDIS0 field.
	NVMCTRL_CTRLA_CACHEDIS0_Msk = 0x4000
	// Bit CACHEDIS0.
	NVMCTRL_CTRLA_CACHEDIS0 = 0x4000
	// Position of CACHEDIS1 field.
	NVMCTRL_CTRLA_CACHEDIS1_Pos = 0xf
	// Bit mask of CACHEDIS1 field.
	NVMCTRL_CTRLA_CACHEDIS1_Msk = 0x8000
	// Bit CACHEDIS1.
	NVMCTRL_CTRLA_CACHEDIS1 = 0x8000

	// CTRLB: Control B
	// Position of CMD field.
	NVMCTRL_CTRLB_CMD_Pos = 0x0
	// Bit mask of CMD field.
	NVMCTRL_CTRLB_CMD_Msk = 0x7f
	// Erase Page - Only supported in the USER and AUX pages.
	NVMCTRL_CTRLB_CMD_EP = 0x0
	// Erase Block - Erases the block addressed by the ADDR register, not supported in the user page
	NVMCTRL_CTRLB_CMD_EB = 0x1
	// Write Page - Writes the contents of the page buffer to the page addressed by the ADDR register, not supported in the user page
	NVMCTRL_CTRLB_CMD_WP = 0x3
	// Write Quad Word - Writes a 128-bit word at the location addressed by the ADDR register.
	NVMCTRL_CTRLB_CMD_WQW = 0x4
	// Software Reset - Power-Cycle the NVM memory and replay the device automatic calibration procedure and resets the module configuration registers
	NVMCTRL_CTRLB_CMD_SWRST = 0x10
	// Lock Region - Locks the region containing the address location in the ADDR register.
	NVMCTRL_CTRLB_CMD_LR = 0x11
	// Unlock Region - Unlocks the region containing the address location in the ADDR register.
	NVMCTRL_CTRLB_CMD_UR = 0x12
	// Sets the power reduction mode.
	NVMCTRL_CTRLB_CMD_SPRM = 0x13
	// Clears the power reduction mode.
	NVMCTRL_CTRLB_CMD_CPRM = 0x14
	// Page Buffer Clear - Clears the page buffer.
	NVMCTRL_CTRLB_CMD_PBC = 0x15
	// Set Security Bit
	NVMCTRL_CTRLB_CMD_SSB = 0x16
	// Bank swap and system reset, if SMEE is used also reallocate SMEE data into the opposite BANK
	NVMCTRL_CTRLB_CMD_BKSWRST = 0x17
	// Chip Erase Lock - DSU.CE command is not available
	NVMCTRL_CTRLB_CMD_CELCK = 0x18
	// Chip Erase Unlock - DSU.CE command is available
	NVMCTRL_CTRLB_CMD_CEULCK = 0x19
	// Sets STATUS.BPDIS, Boot loader protection is discarded until CBPDIS is issued or next start-up sequence
	NVMCTRL_CTRLB_CMD_SBPDIS = 0x1a
	// Clears STATUS.BPDIS, Boot loader protection is not discarded
	NVMCTRL_CTRLB_CMD_CBPDIS = 0x1b
	// Activate SmartEEPROM Sector 0, deactivate Sector 1
	NVMCTRL_CTRLB_CMD_ASEES0 = 0x30
	// Activate SmartEEPROM Sector 1, deactivate Sector 0
	NVMCTRL_CTRLB_CMD_ASEES1 = 0x31
	// Starts SmartEEPROM sector reallocation algorithm
	NVMCTRL_CTRLB_CMD_SEERALOC = 0x32
	// Flush SMEE data when in buffered mode
	NVMCTRL_CTRLB_CMD_SEEFLUSH = 0x33
	// Lock access to SmartEEPROM data from any mean
	NVMCTRL_CTRLB_CMD_LSEE = 0x34
	// Unlock access to SmartEEPROM data
	NVMCTRL_CTRLB_CMD_USEE = 0x35
	// Lock access to the SmartEEPROM Register Address Space (above 64KB)
	NVMCTRL_CTRLB_CMD_LSEER = 0x36
	// Unlock access to the SmartEEPROM Register Address Space (above 64KB)
	NVMCTRL_CTRLB_CMD_USEER = 0x37
	// Position of CMDEX field.
	NVMCTRL_CTRLB_CMDEX_Pos = 0x8
	// Bit mask of CMDEX field.
	NVMCTRL_CTRLB_CMDEX_Msk = 0xff00
	// Execution Key
	NVMCTRL_CTRLB_CMDEX_KEY = 0xa5

	// PARAM: NVM Parameter
	// Position of NVMP field.
	NVMCTRL_PARAM_NVMP_Pos = 0x0
	// Bit mask of NVMP field.
	NVMCTRL_PARAM_NVMP_Msk = 0xffff
	// Position of PSZ field.
	NVMCTRL_PARAM_PSZ_Pos = 0x10
	// Bit mask of PSZ field.
	NVMCTRL_PARAM_PSZ_Msk = 0x70000
	// 8 bytes
	NVMCTRL_PARAM_PSZ_8 = 0x0
	// 16 bytes
	NVMCTRL_PARAM_PSZ_16 = 0x1
	// 32 bytes
	NVMCTRL_PARAM_PSZ_32 = 0x2
	// 64 bytes
	NVMCTRL_PARAM_PSZ_64 = 0x3
	// 128 bytes
	NVMCTRL_PARAM_PSZ_128 = 0x4
	// 256 bytes
	NVMCTRL_PARAM_PSZ_256 = 0x5
	// 512 bytes
	NVMCTRL_PARAM_PSZ_512 = 0x6
	// 1024 bytes
	NVMCTRL_PARAM_PSZ_1024 = 0x7
	// Position of SEE field.
	NVMCTRL_PARAM_SEE_Pos = 0x1f
	// Bit mask of SEE field.
	NVMCTRL_PARAM_SEE_Msk = 0x80000000
	// Bit SEE.
	NVMCTRL_PARAM_SEE = 0x80000000
	// 163840 bytes
	NVMCTRL_PARAM_SEE_A = 0xa
	// 147456 bytes
	NVMCTRL_PARAM_SEE_9 = 0x9
	// 131072 bytes
	NVMCTRL_PARAM_SEE_8 = 0x8
	// 114688 bytes
	NVMCTRL_PARAM_SEE_7 = 0x7
	// 98304 bytes
	NVMCTRL_PARAM_SEE_6 = 0x6
	// 81920 bytes
	NVMCTRL_PARAM_SEE_5 = 0x5
	// 65536 bytes
	NVMCTRL_PARAM_SEE_4 = 0x4
	// 49152 bytes
	NVMCTRL_PARAM_SEE_3 = 0x3
	// 32768 bytes
	NVMCTRL_PARAM_SEE_2 = 0x2
	// 16384 bytes
	NVMCTRL_PARAM_SEE_1 = 0x1
	// 0 bytes
	NVMCTRL_PARAM_SEE_0 = 0x0

	// INTENCLR: Interrupt Enable Clear
	// Position of DONE field.
	NVMCTRL_INTENCLR_DONE_Pos = 0x0
	// Bit mask of DONE field.
	NVMCTRL_INTENCLR_DONE_Msk = 0x1
	// Bit DONE.
	NVMCTRL_INTENCLR_DONE = 0x1
	// Position of ADDRE field.
	NVMCTRL_INTENCLR_ADDRE_Pos = 0x1
	// Bit mask of ADDRE field.
	NVMCTRL_INTENCLR_ADDRE_Msk = 0x2
	// Bit ADDRE.
	NVMCTRL_INTENCLR_ADDRE = 0x2
	// Position of PROGE field.
	NVMCTRL_INTENCLR_PROGE_Pos = 0x2
	// Bit mask of PROGE field.
	NVMCTRL_INTENCLR_PROGE_Msk = 0x4
	// Bit PROGE.
	NVMCTRL_INTENCLR_PROGE = 0x4
	// Position of LOCKE field.
	NVMCTRL_INTENCLR_LOCKE_Pos = 0x3
	// Bit mask of LOCKE field.
	NVMCTRL_INTENCLR_LOCKE_Msk = 0x8
	// Bit LOCKE.
	NVMCTRL_INTENCLR_LOCKE = 0x8
	// Position of ECCSE field.
	NVMCTRL_INTENCLR_ECCSE_Pos = 0x4
	// Bit mask of ECCSE field.
	NVMCTRL_INTENCLR_ECCSE_Msk = 0x10
	// Bit ECCSE.
	NVMCTRL_INTENCLR_ECCSE = 0x10
	// Position of ECCDE field.
	NVMCTRL_INTENCLR_ECCDE_Pos = 0x5
	// Bit mask of ECCDE field.
	NVMCTRL_INTENCLR_ECCDE_Msk = 0x20
	// Bit ECCDE.
	NVMCTRL_INTENCLR_ECCDE = 0x20
	// Position of NVME field.
	NVMCTRL_INTENCLR_NVME_Pos = 0x6
	// Bit mask of NVME field.
	NVMCTRL_INTENCLR_NVME_Msk = 0x40
	// Bit NVME.
	NVMCTRL_INTENCLR_NVME = 0x40
	// Position of SUSP field.
	NVMCTRL_INTENCLR_SUSP_Pos = 0x7
	// Bit mask of SUSP field.
	NVMCTRL_INTENCLR_SUSP_Msk = 0x80
	// Bit SUSP.
	NVMCTRL_INTENCLR_SUSP = 0x80
	// Position of SEESFULL field.
	NVMCTRL_INTENCLR_SEESFULL_Pos = 0x8
	// Bit mask of SEESFULL field.
	NVMCTRL_INTENCLR_SEESFULL_Msk = 0x100
	// Bit SEESFULL.
	NVMCTRL_INTENCLR_SEESFULL = 0x100
	// Position of SEESOVF field.
	NVMCTRL_INTENCLR_SEESOVF_Pos = 0x9
	// Bit mask of SEESOVF field.
	NVMCTRL_INTENCLR_SEESOVF_Msk = 0x200
	// Bit SEESOVF.
	NVMCTRL_INTENCLR_SEESOVF = 0x200
	// Position of SEEWRC field.
	NVMCTRL_INTENCLR_SEEWRC_Pos = 0xa
	// Bit mask of SEEWRC field.
	NVMCTRL_INTENCLR_SEEWRC_Msk = 0x400
	// Bit SEEWRC.
	NVMCTRL_INTENCLR_SEEWRC = 0x400

	// INTENSET: Interrupt Enable Set
	// Position of DONE field.
	NVMCTRL_INTENSET_DONE_Pos = 0x0
	// Bit mask of DONE field.
	NVMCTRL_INTENSET_DONE_Msk = 0x1
	// Bit DONE.
	NVMCTRL_INTENSET_DONE = 0x1
	// Position of ADDRE field.
	NVMCTRL_INTENSET_ADDRE_Pos = 0x1
	// Bit mask of ADDRE field.
	NVMCTRL_INTENSET_ADDRE_Msk = 0x2
	// Bit ADDRE.
	NVMCTRL_INTENSET_ADDRE = 0x2
	// Position of PROGE field.
	NVMCTRL_INTENSET_PROGE_Pos = 0x2
	// Bit mask of PROGE field.
	NVMCTRL_INTENSET_PROGE_Msk = 0x4
	// Bit PROGE.
	NVMCTRL_INTENSET_PROGE = 0x4
	// Position of LOCKE field.
	NVMCTRL_INTENSET_LOCKE_Pos = 0x3
	// Bit mask of LOCKE field.
	NVMCTRL_INTENSET_LOCKE_Msk = 0x8
	// Bit LOCKE.
	NVMCTRL_INTENSET_LOCKE = 0x8
	// Position of ECCSE field.
	NVMCTRL_INTENSET_ECCSE_Pos = 0x4
	// Bit mask of ECCSE field.
	NVMCTRL_INTENSET_ECCSE_Msk = 0x10
	// Bit ECCSE.
	NVMCTRL_INTENSET_ECCSE = 0x10
	// Position of ECCDE field.
	NVMCTRL_INTENSET_ECCDE_Pos = 0x5
	// Bit mask of ECCDE field.
	NVMCTRL_INTENSET_ECCDE_Msk = 0x20
	// Bit ECCDE.
	NVMCTRL_INTENSET_ECCDE = 0x20
	// Position of NVME field.
	NVMCTRL_INTENSET_NVME_Pos = 0x6
	// Bit mask of NVME field.
	NVMCTRL_INTENSET_NVME_Msk = 0x40
	// Bit NVME.
	NVMCTRL_INTENSET_NVME = 0x40
	// Position of SUSP field.
	NVMCTRL_INTENSET_SUSP_Pos = 0x7
	// Bit mask of SUSP field.
	NVMCTRL_INTENSET_SUSP_Msk = 0x80
	// Bit SUSP.
	NVMCTRL_INTENSET_SUSP = 0x80
	// Position of SEESFULL field.
	NVMCTRL_INTENSET_SEESFULL_Pos = 0x8
	// Bit mask of SEESFULL field.
	NVMCTRL_INTENSET_SEESFULL_Msk = 0x100
	// Bit SEESFULL.
	NVMCTRL_INTENSET_SEESFULL = 0x100
	// Position of SEESOVF field.
	NVMCTRL_INTENSET_SEESOVF_Pos = 0x9
	// Bit mask of SEESOVF field.
	NVMCTRL_INTENSET_SEESOVF_Msk = 0x200
	// Bit SEESOVF.
	NVMCTRL_INTENSET_SEESOVF = 0x200
	// Position of SEEWRC field.
	NVMCTRL_INTENSET_SEEWRC_Pos = 0xa
	// Bit mask of SEEWRC field.
	NVMCTRL_INTENSET_SEEWRC_Msk = 0x400
	// Bit SEEWRC.
	NVMCTRL_INTENSET_SEEWRC = 0x400

	// INTFLAG: Interrupt Flag Status and Clear
	// Position of DONE field.
	NVMCTRL_INTFLAG_DONE_Pos = 0x0
	// Bit mask of DONE field.
	NVMCTRL_INTFLAG_DONE_Msk = 0x1
	// Bit DONE.
	NVMCTRL_INTFLAG_DONE = 0x1
	// Position of ADDRE field.
	NVMCTRL_INTFLAG_ADDRE_Pos = 0x1
	// Bit mask of ADDRE field.
	NVMCTRL_INTFLAG_ADDRE_Msk = 0x2
	// Bit ADDRE.
	NVMCTRL_INTFLAG_ADDRE = 0x2
	// Position of PROGE field.
	NVMCTRL_INTFLAG_PROGE_Pos = 0x2
	// Bit mask of PROGE field.
	NVMCTRL_INTFLAG_PROGE_Msk = 0x4
	// Bit PROGE.
	NVMCTRL_INTFLAG_PROGE = 0x4
	// Position of LOCKE field.
	NVMCTRL_INTFLAG_LOCKE_Pos = 0x3
	// Bit mask of LOCKE field.
	NVMCTRL_INTFLAG_LOCKE_Msk = 0x8
	// Bit LOCKE.
	NVMCTRL_INTFLAG_LOCKE = 0x8
	// Position of ECCSE field.
	NVMCTRL_INTFLAG_ECCSE_Pos = 0x4
	// Bit mask of ECCSE field.
	NVMCTRL_INTFLAG_ECCSE_Msk = 0x10
	// Bit ECCSE.
	NVMCTRL_INTFLAG_ECCSE = 0x10
	// Position of ECCDE field.
	NVMCTRL_INTFLAG_ECCDE_Pos = 0x5
	// Bit mask of ECCDE field.
	NVMCTRL_INTFLAG_ECCDE_Msk = 0x20
	// Bit ECCDE.
	NVMCTRL_INTFLAG_ECCDE = 0x20
	// Position of NVME field.
	NVMCTRL_INTFLAG_NVME_Pos = 0x6
	// Bit mask of NVME field.
	NVMCTRL_INTFLAG_NVME_Msk = 0x40
	// Bit NVME.
	NVMCTRL_INTFLAG_NVME = 0x40
	// Position of SUSP field.
	NVMCTRL_INTFLAG_SUSP_Pos = 0x7
	// Bit mask of SUSP field.
	NVMCTRL_INTFLAG_SUSP_Msk = 0x80
	// Bit SUSP.
	NVMCTRL_INTFLAG_SUSP = 0x80
	// Position of SEESFULL field.
	NVMCTRL_INTFLAG_SEESFULL_Pos = 0x8
	// Bit mask of SEESFULL field.
	NVMCTRL_INTFLAG_SEESFULL_Msk = 0x100
	// Bit SEESFULL.
	NVMCTRL_INTFLAG_SEESFULL = 0x100
	// Position of SEESOVF field.
	NVMCTRL_INTFLAG_SEESOVF_Pos = 0x9
	// Bit mask of SEESOVF field.
	NVMCTRL_INTFLAG_SEESOVF_Msk = 0x200
	// Bit SEESOVF.
	NVMCTRL_INTFLAG_SEESOVF = 0x200
	// Position of SEEWRC field.
	NVMCTRL_INTFLAG_SEEWRC_Pos = 0xa
	// Bit mask of SEEWRC field.
	NVMCTRL_INTFLAG_SEEWRC_Msk = 0x400
	// Bit SEEWRC.
	NVMCTRL_INTFLAG_SEEWRC = 0x400

	// STATUS: Status
	// Position of READY field.
	NVMCTRL_STATUS_READY_Pos = 0x0
	// Bit mask of READY field.
	NVMCTRL_STATUS_READY_Msk = 0x1
	// Bit READY.
	NVMCTRL_STATUS_READY = 0x1
	// Position of PRM field.
	NVMCTRL_STATUS_PRM_Pos = 0x1
	// Bit mask of PRM field.
	NVMCTRL_STATUS_PRM_Msk = 0x2
	// Bit PRM.
	NVMCTRL_STATUS_PRM = 0x2
	// Position of LOAD field.
	NVMCTRL_STATUS_LOAD_Pos = 0x2
	// Bit mask of LOAD field.
	NVMCTRL_STATUS_LOAD_Msk = 0x4
	// Bit LOAD.
	NVMCTRL_STATUS_LOAD = 0x4
	// Position of SUSP field.
	NVMCTRL_STATUS_SUSP_Pos = 0x3
	// Bit mask of SUSP field.
	NVMCTRL_STATUS_SUSP_Msk = 0x8
	// Bit SUSP.
	NVMCTRL_STATUS_SUSP = 0x8
	// Position of AFIRST field.
	NVMCTRL_STATUS_AFIRST_Pos = 0x4
	// Bit mask of AFIRST field.
	NVMCTRL_STATUS_AFIRST_Msk = 0x10
	// Bit AFIRST.
	NVMCTRL_STATUS_AFIRST = 0x10
	// Position of BPDIS field.
	NVMCTRL_STATUS_BPDIS_Pos = 0x5
	// Bit mask of BPDIS field.
	NVMCTRL_STATUS_BPDIS_Msk = 0x20
	// Bit BPDIS.
	NVMCTRL_STATUS_BPDIS = 0x20
	// Position of BOOTPROT field.
	NVMCTRL_STATUS_BOOTPROT_Pos = 0x8
	// Bit mask of BOOTPROT field.
	NVMCTRL_STATUS_BOOTPROT_Msk = 0xf00
	// 0 kbytes
	NVMCTRL_STATUS_BOOTPROT_0 = 0xf
	// 8 kbytes
	NVMCTRL_STATUS_BOOTPROT_8 = 0xe
	// 16 kbytes
	NVMCTRL_STATUS_BOOTPROT_16 = 0xd
	// 24 kbytes
	NVMCTRL_STATUS_BOOTPROT_24 = 0xc
	// 32 kbytes
	NVMCTRL_STATUS_BOOTPROT_32 = 0xb
	// 40 kbytes
	NVMCTRL_STATUS_BOOTPROT_40 = 0xa
	// 48 kbytes
	NVMCTRL_STATUS_BOOTPROT_48 = 0x9
	// 56 kbytes
	NVMCTRL_STATUS_BOOTPROT_56 = 0x8
	// 64 kbytes
	NVMCTRL_STATUS_BOOTPROT_64 = 0x7
	// 72 kbytes
	NVMCTRL_STATUS_BOOTPROT_72 = 0x6
	// 80 kbytes
	NVMCTRL_STATUS_BOOTPROT_80 = 0x5
	// 88 kbytes
	NVMCTRL_STATUS_BOOTPROT_88 = 0x4
	// 96 kbytes
	NVMCTRL_STATUS_BOOTPROT_96 = 0x3
	// 104 kbytes
	NVMCTRL_STATUS_BOOTPROT_104 = 0x2
	// 112 kbytes
	NVMCTRL_STATUS_BOOTPROT_112 = 0x1
	// 120 kbytes
	NVMCTRL_STATUS_BOOTPROT_120 = 0x0

	// ADDR: Address
	// Position of ADDR field.
	NVMCTRL_ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	NVMCTRL_ADDR_ADDR_Msk = 0xffffff

	// RUNLOCK: Lock Section
	// Position of RUNLOCK field.
	NVMCTRL_RUNLOCK_RUNLOCK_Pos = 0x0
	// Bit mask of RUNLOCK field.
	NVMCTRL_RUNLOCK_RUNLOCK_Msk = 0xffffffff

	// PBLDATA: Page Buffer Load Data x
	// Position of DATA field.
	NVMCTRL_PBLDATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	NVMCTRL_PBLDATA_DATA_Msk = 0xffffffff

	// ECCERR: ECC Error Status Register
	// Position of ADDR field.
	NVMCTRL_ECCERR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	NVMCTRL_ECCERR_ADDR_Msk = 0xffffff
	// Position of TYPEL field.
	NVMCTRL_ECCERR_TYPEL_Pos = 0x1c
	// Bit mask of TYPEL field.
	NVMCTRL_ECCERR_TYPEL_Msk = 0x30000000
	// No Error Detected Since Last Read
	NVMCTRL_ECCERR_TYPEL_None = 0x0
	// At Least One Single Error Detected Since last Read
	NVMCTRL_ECCERR_TYPEL_Single = 0x1
	// At Least One Dual Error Detected Since Last Read
	NVMCTRL_ECCERR_TYPEL_Dual = 0x2
	// Position of TYPEH field.
	NVMCTRL_ECCERR_TYPEH_Pos = 0x1e
	// Bit mask of TYPEH field.
	NVMCTRL_ECCERR_TYPEH_Msk = 0xc0000000
	// No Error Detected Since Last Read
	NVMCTRL_ECCERR_TYPEH_None = 0x0
	// At Least One Single Error Detected Since last Read
	NVMCTRL_ECCERR_TYPEH_Single = 0x1
	// At Least One Dual Error Detected Since Last Read
	NVMCTRL_ECCERR_TYPEH_Dual = 0x2

	// DBGCTRL: Debug Control
	// Position of ECCDIS field.
	NVMCTRL_DBGCTRL_ECCDIS_Pos = 0x0
	// Bit mask of ECCDIS field.
	NVMCTRL_DBGCTRL_ECCDIS_Msk = 0x1
	// Bit ECCDIS.
	NVMCTRL_DBGCTRL_ECCDIS = 0x1
	// Position of ECCELOG field.
	NVMCTRL_DBGCTRL_ECCELOG_Pos = 0x1
	// Bit mask of ECCELOG field.
	NVMCTRL_DBGCTRL_ECCELOG_Msk = 0x2
	// Bit ECCELOG.
	NVMCTRL_DBGCTRL_ECCELOG = 0x2

	// SEECFG: SmartEEPROM Configuration Register
	// Position of WMODE field.
	NVMCTRL_SEECFG_WMODE_Pos = 0x0
	// Bit mask of WMODE field.
	NVMCTRL_SEECFG_WMODE_Msk = 0x1
	// Bit WMODE.
	NVMCTRL_SEECFG_WMODE = 0x1
	// A NVM write command is issued after each write in the pagebuffer
	NVMCTRL_SEECFG_WMODE_UNBUFFERED = 0x0
	// A NVM write command is issued when a write to a new page is requested
	NVMCTRL_SEECFG_WMODE_BUFFERED = 0x1
	// Position of APRDIS field.
	NVMCTRL_SEECFG_APRDIS_Pos = 0x1
	// Bit mask of APRDIS field.
	NVMCTRL_SEECFG_APRDIS_Msk = 0x2
	// Bit APRDIS.
	NVMCTRL_SEECFG_APRDIS = 0x2

	// SEESTAT: SmartEEPROM Status Register
	// Position of ASEES field.
	NVMCTRL_SEESTAT_ASEES_Pos = 0x0
	// Bit mask of ASEES field.
	NVMCTRL_SEESTAT_ASEES_Msk = 0x1
	// Bit ASEES.
	NVMCTRL_SEESTAT_ASEES = 0x1
	// Position of LOAD field.
	NVMCTRL_SEESTAT_LOAD_Pos = 0x1
	// Bit mask of LOAD field.
	NVMCTRL_SEESTAT_LOAD_Msk = 0x2
	// Bit LOAD.
	NVMCTRL_SEESTAT_LOAD = 0x2
	// Position of BUSY field.
	NVMCTRL_SEESTAT_BUSY_Pos = 0x2
	// Bit mask of BUSY field.
	NVMCTRL_SEESTAT_BUSY_Msk = 0x4
	// Bit BUSY.
	NVMCTRL_SEESTAT_BUSY = 0x4
	// Position of LOCK field.
	NVMCTRL_SEESTAT_LOCK_Pos = 0x3
	// Bit mask of LOCK field.
	NVMCTRL_SEESTAT_LOCK_Msk = 0x8
	// Bit LOCK.
	NVMCTRL_SEESTAT_LOCK = 0x8
	// Position of RLOCK field.
	NVMCTRL_SEESTAT_RLOCK_Pos = 0x4
	// Bit mask of RLOCK field.
	NVMCTRL_SEESTAT_RLOCK_Msk = 0x10
	// Bit RLOCK.
	NVMCTRL_SEESTAT_RLOCK = 0x10
	// Position of SBLK field.
	NVMCTRL_SEESTAT_SBLK_Pos = 0x8
	// Bit mask of SBLK field.
	NVMCTRL_SEESTAT_SBLK_Msk = 0xf00
	// Position of PSZ field.
	NVMCTRL_SEESTAT_PSZ_Pos = 0x10
	// Bit mask of PSZ field.
	NVMCTRL_SEESTAT_PSZ_Msk = 0x70000
)

// Constants for OSCCTRL: Oscillators Control
const (
	// EVCTRL: Event Control
	// Position of CFDEO0 field.
	OSCCTRL_EVCTRL_CFDEO0_Pos = 0x0
	// Bit mask of CFDEO0 field.
	OSCCTRL_EVCTRL_CFDEO0_Msk = 0x1
	// Bit CFDEO0.
	OSCCTRL_EVCTRL_CFDEO0 = 0x1
	// Position of CFDEO1 field.
	OSCCTRL_EVCTRL_CFDEO1_Pos = 0x1
	// Bit mask of CFDEO1 field.
	OSCCTRL_EVCTRL_CFDEO1_Msk = 0x2
	// Bit CFDEO1.
	OSCCTRL_EVCTRL_CFDEO1 = 0x2

	// INTENCLR: Interrupt Enable Clear
	// Position of XOSCRDY0 field.
	OSCCTRL_INTENCLR_XOSCRDY0_Pos = 0x0
	// Bit mask of XOSCRDY0 field.
	OSCCTRL_INTENCLR_XOSCRDY0_Msk = 0x1
	// Bit XOSCRDY0.
	OSCCTRL_INTENCLR_XOSCRDY0 = 0x1
	// Position of XOSCRDY1 field.
	OSCCTRL_INTENCLR_XOSCRDY1_Pos = 0x1
	// Bit mask of XOSCRDY1 field.
	OSCCTRL_INTENCLR_XOSCRDY1_Msk = 0x2
	// Bit XOSCRDY1.
	OSCCTRL_INTENCLR_XOSCRDY1 = 0x2
	// Position of XOSCFAIL0 field.
	OSCCTRL_INTENCLR_XOSCFAIL0_Pos = 0x2
	// Bit mask of XOSCFAIL0 field.
	OSCCTRL_INTENCLR_XOSCFAIL0_Msk = 0x4
	// Bit XOSCFAIL0.
	OSCCTRL_INTENCLR_XOSCFAIL0 = 0x4
	// Position of XOSCFAIL1 field.
	OSCCTRL_INTENCLR_XOSCFAIL1_Pos = 0x3
	// Bit mask of XOSCFAIL1 field.
	OSCCTRL_INTENCLR_XOSCFAIL1_Msk = 0x8
	// Bit XOSCFAIL1.
	OSCCTRL_INTENCLR_XOSCFAIL1 = 0x8
	// Position of DFLLRDY field.
	OSCCTRL_INTENCLR_DFLLRDY_Pos = 0x8
	// Bit mask of DFLLRDY field.
	OSCCTRL_INTENCLR_DFLLRDY_Msk = 0x100
	// Bit DFLLRDY.
	OSCCTRL_INTENCLR_DFLLRDY = 0x100
	// Position of DFLLOOB field.
	OSCCTRL_INTENCLR_DFLLOOB_Pos = 0x9
	// Bit mask of DFLLOOB field.
	OSCCTRL_INTENCLR_DFLLOOB_Msk = 0x200
	// Bit DFLLOOB.
	OSCCTRL_INTENCLR_DFLLOOB = 0x200
	// Position of DFLLLCKF field.
	OSCCTRL_INTENCLR_DFLLLCKF_Pos = 0xa
	// Bit mask of DFLLLCKF field.
	OSCCTRL_INTENCLR_DFLLLCKF_Msk = 0x400
	// Bit DFLLLCKF.
	OSCCTRL_INTENCLR_DFLLLCKF = 0x400
	// Position of DFLLLCKC field.
	OSCCTRL_INTENCLR_DFLLLCKC_Pos = 0xb
	// Bit mask of DFLLLCKC field.
	OSCCTRL_INTENCLR_DFLLLCKC_Msk = 0x800
	// Bit DFLLLCKC.
	OSCCTRL_INTENCLR_DFLLLCKC = 0x800
	// Position of DFLLRCS field.
	OSCCTRL_INTENCLR_DFLLRCS_Pos = 0xc
	// Bit mask of DFLLRCS field.
	OSCCTRL_INTENCLR_DFLLRCS_Msk = 0x1000
	// Bit DFLLRCS.
	OSCCTRL_INTENCLR_DFLLRCS = 0x1000
	// Position of DPLL0LCKR field.
	OSCCTRL_INTENCLR_DPLL0LCKR_Pos = 0x10
	// Bit mask of DPLL0LCKR field.
	OSCCTRL_INTENCLR_DPLL0LCKR_Msk = 0x10000
	// Bit DPLL0LCKR.
	OSCCTRL_INTENCLR_DPLL0LCKR = 0x10000
	// Position of DPLL0LCKF field.
	OSCCTRL_INTENCLR_DPLL0LCKF_Pos = 0x11
	// Bit mask of DPLL0LCKF field.
	OSCCTRL_INTENCLR_DPLL0LCKF_Msk = 0x20000
	// Bit DPLL0LCKF.
	OSCCTRL_INTENCLR_DPLL0LCKF = 0x20000
	// Position of DPLL0LTO field.
	OSCCTRL_INTENCLR_DPLL0LTO_Pos = 0x12
	// Bit mask of DPLL0LTO field.
	OSCCTRL_INTENCLR_DPLL0LTO_Msk = 0x40000
	// Bit DPLL0LTO.
	OSCCTRL_INTENCLR_DPLL0LTO = 0x40000
	// Position of DPLL0LDRTO field.
	OSCCTRL_INTENCLR_DPLL0LDRTO_Pos = 0x13
	// Bit mask of DPLL0LDRTO field.
	OSCCTRL_INTENCLR_DPLL0LDRTO_Msk = 0x80000
	// Bit DPLL0LDRTO.
	OSCCTRL_INTENCLR_DPLL0LDRTO = 0x80000
	// Position of DPLL1LCKR field.
	OSCCTRL_INTENCLR_DPLL1LCKR_Pos = 0x18
	// Bit mask of DPLL1LCKR field.
	OSCCTRL_INTENCLR_DPLL1LCKR_Msk = 0x1000000
	// Bit DPLL1LCKR.
	OSCCTRL_INTENCLR_DPLL1LCKR = 0x1000000
	// Position of DPLL1LCKF field.
	OSCCTRL_INTENCLR_DPLL1LCKF_Pos = 0x19
	// Bit mask of DPLL1LCKF field.
	OSCCTRL_INTENCLR_DPLL1LCKF_Msk = 0x2000000
	// Bit DPLL1LCKF.
	OSCCTRL_INTENCLR_DPLL1LCKF = 0x2000000
	// Position of DPLL1LTO field.
	OSCCTRL_INTENCLR_DPLL1LTO_Pos = 0x1a
	// Bit mask of DPLL1LTO field.
	OSCCTRL_INTENCLR_DPLL1LTO_Msk = 0x4000000
	// Bit DPLL1LTO.
	OSCCTRL_INTENCLR_DPLL1LTO = 0x4000000
	// Position of DPLL1LDRTO field.
	OSCCTRL_INTENCLR_DPLL1LDRTO_Pos = 0x1b
	// Bit mask of DPLL1LDRTO field.
	OSCCTRL_INTENCLR_DPLL1LDRTO_Msk = 0x8000000
	// Bit DPLL1LDRTO.
	OSCCTRL_INTENCLR_DPLL1LDRTO = 0x8000000

	// INTENSET: Interrupt Enable Set
	// Position of XOSCRDY0 field.
	OSCCTRL_INTENSET_XOSCRDY0_Pos = 0x0
	// Bit mask of XOSCRDY0 field.
	OSCCTRL_INTENSET_XOSCRDY0_Msk = 0x1
	// Bit XOSCRDY0.
	OSCCTRL_INTENSET_XOSCRDY0 = 0x1
	// Position of XOSCRDY1 field.
	OSCCTRL_INTENSET_XOSCRDY1_Pos = 0x1
	// Bit mask of XOSCRDY1 field.
	OSCCTRL_INTENSET_XOSCRDY1_Msk = 0x2
	// Bit XOSCRDY1.
	OSCCTRL_INTENSET_XOSCRDY1 = 0x2
	// Position of XOSCFAIL0 field.
	OSCCTRL_INTENSET_XOSCFAIL0_Pos = 0x2
	// Bit mask of XOSCFAIL0 field.
	OSCCTRL_INTENSET_XOSCFAIL0_Msk = 0x4
	// Bit XOSCFAIL0.
	OSCCTRL_INTENSET_XOSCFAIL0 = 0x4
	// Position of XOSCFAIL1 field.
	OSCCTRL_INTENSET_XOSCFAIL1_Pos = 0x3
	// Bit mask of XOSCFAIL1 field.
	OSCCTRL_INTENSET_XOSCFAIL1_Msk = 0x8
	// Bit XOSCFAIL1.
	OSCCTRL_INTENSET_XOSCFAIL1 = 0x8
	// Position of DFLLRDY field.
	OSCCTRL_INTENSET_DFLLRDY_Pos = 0x8
	// Bit mask of DFLLRDY field.
	OSCCTRL_INTENSET_DFLLRDY_Msk = 0x100
	// Bit DFLLRDY.
	OSCCTRL_INTENSET_DFLLRDY = 0x100
	// Position of DFLLOOB field.
	OSCCTRL_INTENSET_DFLLOOB_Pos = 0x9
	// Bit mask of DFLLOOB field.
	OSCCTRL_INTENSET_DFLLOOB_Msk = 0x200
	// Bit DFLLOOB.
	OSCCTRL_INTENSET_DFLLOOB = 0x200
	// Position of DFLLLCKF field.
	OSCCTRL_INTENSET_DFLLLCKF_Pos = 0xa
	// Bit mask of DFLLLCKF field.
	OSCCTRL_INTENSET_DFLLLCKF_Msk = 0x400
	// Bit DFLLLCKF.
	OSCCTRL_INTENSET_DFLLLCKF = 0x400
	// Position of DFLLLCKC field.
	OSCCTRL_INTENSET_DFLLLCKC_Pos = 0xb
	// Bit mask of DFLLLCKC field.
	OSCCTRL_INTENSET_DFLLLCKC_Msk = 0x800
	// Bit DFLLLCKC.
	OSCCTRL_INTENSET_DFLLLCKC = 0x800
	// Position of DFLLRCS field.
	OSCCTRL_INTENSET_DFLLRCS_Pos = 0xc
	// Bit mask of DFLLRCS field.
	OSCCTRL_INTENSET_DFLLRCS_Msk = 0x1000
	// Bit DFLLRCS.
	OSCCTRL_INTENSET_DFLLRCS = 0x1000
	// Position of DPLL0LCKR field.
	OSCCTRL_INTENSET_DPLL0LCKR_Pos = 0x10
	// Bit mask of DPLL0LCKR field.
	OSCCTRL_INTENSET_DPLL0LCKR_Msk = 0x10000
	// Bit DPLL0LCKR.
	OSCCTRL_INTENSET_DPLL0LCKR = 0x10000
	// Position of DPLL0LCKF field.
	OSCCTRL_INTENSET_DPLL0LCKF_Pos = 0x11
	// Bit mask of DPLL0LCKF field.
	OSCCTRL_INTENSET_DPLL0LCKF_Msk = 0x20000
	// Bit DPLL0LCKF.
	OSCCTRL_INTENSET_DPLL0LCKF = 0x20000
	// Position of DPLL0LTO field.
	OSCCTRL_INTENSET_DPLL0LTO_Pos = 0x12
	// Bit mask of DPLL0LTO field.
	OSCCTRL_INTENSET_DPLL0LTO_Msk = 0x40000
	// Bit DPLL0LTO.
	OSCCTRL_INTENSET_DPLL0LTO = 0x40000
	// Position of DPLL0LDRTO field.
	OSCCTRL_INTENSET_DPLL0LDRTO_Pos = 0x13
	// Bit mask of DPLL0LDRTO field.
	OSCCTRL_INTENSET_DPLL0LDRTO_Msk = 0x80000
	// Bit DPLL0LDRTO.
	OSCCTRL_INTENSET_DPLL0LDRTO = 0x80000
	// Position of DPLL1LCKR field.
	OSCCTRL_INTENSET_DPLL1LCKR_Pos = 0x18
	// Bit mask of DPLL1LCKR field.
	OSCCTRL_INTENSET_DPLL1LCKR_Msk = 0x1000000
	// Bit DPLL1LCKR.
	OSCCTRL_INTENSET_DPLL1LCKR = 0x1000000
	// Position of DPLL1LCKF field.
	OSCCTRL_INTENSET_DPLL1LCKF_Pos = 0x19
	// Bit mask of DPLL1LCKF field.
	OSCCTRL_INTENSET_DPLL1LCKF_Msk = 0x2000000
	// Bit DPLL1LCKF.
	OSCCTRL_INTENSET_DPLL1LCKF = 0x2000000
	// Position of DPLL1LTO field.
	OSCCTRL_INTENSET_DPLL1LTO_Pos = 0x1a
	// Bit mask of DPLL1LTO field.
	OSCCTRL_INTENSET_DPLL1LTO_Msk = 0x4000000
	// Bit DPLL1LTO.
	OSCCTRL_INTENSET_DPLL1LTO = 0x4000000
	// Position of DPLL1LDRTO field.
	OSCCTRL_INTENSET_DPLL1LDRTO_Pos = 0x1b
	// Bit mask of DPLL1LDRTO field.
	OSCCTRL_INTENSET_DPLL1LDRTO_Msk = 0x8000000
	// Bit DPLL1LDRTO.
	OSCCTRL_INTENSET_DPLL1LDRTO = 0x8000000

	// INTFLAG: Interrupt Flag Status and Clear
	// Position of XOSCRDY0 field.
	OSCCTRL_INTFLAG_XOSCRDY0_Pos = 0x0
	// Bit mask of XOSCRDY0 field.
	OSCCTRL_INTFLAG_XOSCRDY0_Msk = 0x1
	// Bit XOSCRDY0.
	OSCCTRL_INTFLAG_XOSCRDY0 = 0x1
	// Position of XOSCRDY1 field.
	OSCCTRL_INTFLAG_XOSCRDY1_Pos = 0x1
	// Bit mask of XOSCRDY1 field.
	OSCCTRL_INTFLAG_XOSCRDY1_Msk = 0x2
	// Bit XOSCRDY1.
	OSCCTRL_INTFLAG_XOSCRDY1 = 0x2
	// Position of XOSCFAIL0 field.
	OSCCTRL_INTFLAG_XOSCFAIL0_Pos = 0x2
	// Bit mask of XOSCFAIL0 field.
	OSCCTRL_INTFLAG_XOSCFAIL0_Msk = 0x4
	// Bit XOSCFAIL0.
	OSCCTRL_INTFLAG_XOSCFAIL0 = 0x4
	// Position of XOSCFAIL1 field.
	OSCCTRL_INTFLAG_XOSCFAIL1_Pos = 0x3
	// Bit mask of XOSCFAIL1 field.
	OSCCTRL_INTFLAG_XOSCFAIL1_Msk = 0x8
	// Bit XOSCFAIL1.
	OSCCTRL_INTFLAG_XOSCFAIL1 = 0x8
	// Position of DFLLRDY field.
	OSCCTRL_INTFLAG_DFLLRDY_Pos = 0x8
	// Bit mask of DFLLRDY field.
	OSCCTRL_INTFLAG_DFLLRDY_Msk = 0x100
	// Bit DFLLRDY.
	OSCCTRL_INTFLAG_DFLLRDY = 0x100
	// Position of DFLLOOB field.
	OSCCTRL_INTFLAG_DFLLOOB_Pos = 0x9
	// Bit mask of DFLLOOB field.
	OSCCTRL_INTFLAG_DFLLOOB_Msk = 0x200
	// Bit DFLLOOB.
	OSCCTRL_INTFLAG_DFLLOOB = 0x200
	// Position of DFLLLCKF field.
	OSCCTRL_INTFLAG_DFLLLCKF_Pos = 0xa
	// Bit mask of DFLLLCKF field.
	OSCCTRL_INTFLAG_DFLLLCKF_Msk = 0x400
	// Bit DFLLLCKF.
	OSCCTRL_INTFLAG_DFLLLCKF = 0x400
	// Position of DFLLLCKC field.
	OSCCTRL_INTFLAG_DFLLLCKC_Pos = 0xb
	// Bit mask of DFLLLCKC field.
	OSCCTRL_INTFLAG_DFLLLCKC_Msk = 0x800
	// Bit DFLLLCKC.
	OSCCTRL_INTFLAG_DFLLLCKC = 0x800
	// Position of DFLLRCS field.
	OSCCTRL_INTFLAG_DFLLRCS_Pos = 0xc
	// Bit mask of DFLLRCS field.
	OSCCTRL_INTFLAG_DFLLRCS_Msk = 0x1000
	// Bit DFLLRCS.
	OSCCTRL_INTFLAG_DFLLRCS = 0x1000
	// Position of DPLL0LCKR field.
	OSCCTRL_INTFLAG_DPLL0LCKR_Pos = 0x10
	// Bit mask of DPLL0LCKR field.
	OSCCTRL_INTFLAG_DPLL0LCKR_Msk = 0x10000
	// Bit DPLL0LCKR.
	OSCCTRL_INTFLAG_DPLL0LCKR = 0x10000
	// Position of DPLL0LCKF field.
	OSCCTRL_INTFLAG_DPLL0LCKF_Pos = 0x11
	// Bit mask of DPLL0LCKF field.
	OSCCTRL_INTFLAG_DPLL0LCKF_Msk = 0x20000
	// Bit DPLL0LCKF.
	OSCCTRL_INTFLAG_DPLL0LCKF = 0x20000
	// Position of DPLL0LTO field.
	OSCCTRL_INTFLAG_DPLL0LTO_Pos = 0x12
	// Bit mask of DPLL0LTO field.
	OSCCTRL_INTFLAG_DPLL0LTO_Msk = 0x40000
	// Bit DPLL0LTO.
	OSCCTRL_INTFLAG_DPLL0LTO = 0x40000
	// Position of DPLL0LDRTO field.
	OSCCTRL_INTFLAG_DPLL0LDRTO_Pos = 0x13
	// Bit mask of DPLL0LDRTO field.
	OSCCTRL_INTFLAG_DPLL0LDRTO_Msk = 0x80000
	// Bit DPLL0LDRTO.
	OSCCTRL_INTFLAG_DPLL0LDRTO = 0x80000
	// Position of DPLL1LCKR field.
	OSCCTRL_INTFLAG_DPLL1LCKR_Pos = 0x18
	// Bit mask of DPLL1LCKR field.
	OSCCTRL_INTFLAG_DPLL1LCKR_Msk = 0x1000000
	// Bit DPLL1LCKR.
	OSCCTRL_INTFLAG_DPLL1LCKR = 0x1000000
	// Position of DPLL1LCKF field.
	OSCCTRL_INTFLAG_DPLL1LCKF_Pos = 0x19
	// Bit mask of DPLL1LCKF field.
	OSCCTRL_INTFLAG_DPLL1LCKF_Msk = 0x2000000
	// Bit DPLL1LCKF.
	OSCCTRL_INTFLAG_DPLL1LCKF = 0x2000000
	// Position of DPLL1LTO field.
	OSCCTRL_INTFLAG_DPLL1LTO_Pos = 0x1a
	// Bit mask of DPLL1LTO field.
	OSCCTRL_INTFLAG_DPLL1LTO_Msk = 0x4000000
	// Bit DPLL1LTO.
	OSCCTRL_INTFLAG_DPLL1LTO = 0x4000000
	// Position of DPLL1LDRTO field.
	OSCCTRL_INTFLAG_DPLL1LDRTO_Pos = 0x1b
	// Bit mask of DPLL1LDRTO field.
	OSCCTRL_INTFLAG_DPLL1LDRTO_Msk = 0x8000000
	// Bit DPLL1LDRTO.
	OSCCTRL_INTFLAG_DPLL1LDRTO = 0x8000000

	// STATUS: Status
	// Position of XOSCRDY0 field.
	OSCCTRL_STATUS_XOSCRDY0_Pos = 0x0
	// Bit mask of XOSCRDY0 field.
	OSCCTRL_STATUS_XOSCRDY0_Msk = 0x1
	// Bit XOSCRDY0.
	OSCCTRL_STATUS_XOSCRDY0 = 0x1
	// Position of XOSCRDY1 field.
	OSCCTRL_STATUS_XOSCRDY1_Pos = 0x1
	// Bit mask of XOSCRDY1 field.
	OSCCTRL_STATUS_XOSCRDY1_Msk = 0x2
	// Bit XOSCRDY1.
	OSCCTRL_STATUS_XOSCRDY1 = 0x2
	// Position of XOSCFAIL0 field.
	OSCCTRL_STATUS_XOSCFAIL0_Pos = 0x2
	// Bit mask of XOSCFAIL0 field.
	OSCCTRL_STATUS_XOSCFAIL0_Msk = 0x4
	// Bit XOSCFAIL0.
	OSCCTRL_STATUS_XOSCFAIL0 = 0x4
	// Position of XOSCFAIL1 field.
	OSCCTRL_STATUS_XOSCFAIL1_Pos = 0x3
	// Bit mask of XOSCFAIL1 field.
	OSCCTRL_STATUS_XOSCFAIL1_Msk = 0x8
	// Bit XOSCFAIL1.
	OSCCTRL_STATUS_XOSCFAIL1 = 0x8
	// Position of XOSCCKSW0 field.
	OSCCTRL_STATUS_XOSCCKSW0_Pos = 0x4
	// Bit mask of XOSCCKSW0 field.
	OSCCTRL_STATUS_XOSCCKSW0_Msk = 0x10
	// Bit XOSCCKSW0.
	OSCCTRL_STATUS_XOSCCKSW0 = 0x10
	// Position of XOSCCKSW1 field.
	OSCCTRL_STATUS_XOSCCKSW1_Pos = 0x5
	// Bit mask of XOSCCKSW1 field.
	OSCCTRL_STATUS_XOSCCKSW1_Msk = 0x20
	// Bit XOSCCKSW1.
	OSCCTRL_STATUS_XOSCCKSW1 = 0x20
	// Position of DFLLRDY field.
	OSCCTRL_STATUS_DFLLRDY_Pos = 0x8
	// Bit mask of DFLLRDY field.
	OSCCTRL_STATUS_DFLLRDY_Msk = 0x100
	// Bit DFLLRDY.
	OSCCTRL_STATUS_DFLLRDY = 0x100
	// Position of DFLLOOB field.
	OSCCTRL_STATUS_DFLLOOB_Pos = 0x9
	// Bit mask of DFLLOOB field.
	OSCCTRL_STATUS_DFLLOOB_Msk = 0x200
	// Bit DFLLOOB.
	OSCCTRL_STATUS_DFLLOOB = 0x200
	// Position of DFLLLCKF field.
	OSCCTRL_STATUS_DFLLLCKF_Pos = 0xa
	// Bit mask of DFLLLCKF field.
	OSCCTRL_STATUS_DFLLLCKF_Msk = 0x400
	// Bit DFLLLCKF.
	OSCCTRL_STATUS_DFLLLCKF = 0x400
	// Position of DFLLLCKC field.
	OSCCTRL_STATUS_DFLLLCKC_Pos = 0xb
	// Bit mask of DFLLLCKC field.
	OSCCTRL_STATUS_DFLLLCKC_Msk = 0x800
	// Bit DFLLLCKC.
	OSCCTRL_STATUS_DFLLLCKC = 0x800
	// Position of DFLLRCS field.
	OSCCTRL_STATUS_DFLLRCS_Pos = 0xc
	// Bit mask of DFLLRCS field.
	OSCCTRL_STATUS_DFLLRCS_Msk = 0x1000
	// Bit DFLLRCS.
	OSCCTRL_STATUS_DFLLRCS = 0x1000
	// Position of DPLL0LCKR field.
	OSCCTRL_STATUS_DPLL0LCKR_Pos = 0x10
	// Bit mask of DPLL0LCKR field.
	OSCCTRL_STATUS_DPLL0LCKR_Msk = 0x10000
	// Bit DPLL0LCKR.
	OSCCTRL_STATUS_DPLL0LCKR = 0x10000
	// Position of DPLL0LCKF field.
	OSCCTRL_STATUS_DPLL0LCKF_Pos = 0x11
	// Bit mask of DPLL0LCKF field.
	OSCCTRL_STATUS_DPLL0LCKF_Msk = 0x20000
	// Bit DPLL0LCKF.
	OSCCTRL_STATUS_DPLL0LCKF = 0x20000
	// Position of DPLL0TO field.
	OSCCTRL_STATUS_DPLL0TO_Pos = 0x12
	// Bit mask of DPLL0TO field.
	OSCCTRL_STATUS_DPLL0TO_Msk = 0x40000
	// Bit DPLL0TO.
	OSCCTRL_STATUS_DPLL0TO = 0x40000
	// Position of DPLL0LDRTO field.
	OSCCTRL_STATUS_DPLL0LDRTO_Pos = 0x13
	// Bit mask of DPLL0LDRTO field.
	OSCCTRL_STATUS_DPLL0LDRTO_Msk = 0x80000
	// Bit DPLL0LDRTO.
	OSCCTRL_STATUS_DPLL0LDRTO = 0x80000
	// Position of DPLL1LCKR field.
	OSCCTRL_STATUS_DPLL1LCKR_Pos = 0x18
	// Bit mask of DPLL1LCKR field.
	OSCCTRL_STATUS_DPLL1LCKR_Msk = 0x1000000
	// Bit DPLL1LCKR.
	OSCCTRL_STATUS_DPLL1LCKR = 0x1000000
	// Position of DPLL1LCKF field.
	OSCCTRL_STATUS_DPLL1LCKF_Pos = 0x19
	// Bit mask of DPLL1LCKF field.
	OSCCTRL_STATUS_DPLL1LCKF_Msk = 0x2000000
	// Bit DPLL1LCKF.
	OSCCTRL_STATUS_DPLL1LCKF = 0x2000000
	// Position of DPLL1TO field.
	OSCCTRL_STATUS_DPLL1TO_Pos = 0x1a
	// Bit mask of DPLL1TO field.
	OSCCTRL_STATUS_DPLL1TO_Msk = 0x4000000
	// Bit DPLL1TO.
	OSCCTRL_STATUS_DPLL1TO = 0x4000000
	// Position of DPLL1LDRTO field.
	OSCCTRL_STATUS_DPLL1LDRTO_Pos = 0x1b
	// Bit mask of DPLL1LDRTO field.
	OSCCTRL_STATUS_DPLL1LDRTO_Msk = 0x8000000
	// Bit DPLL1LDRTO.
	OSCCTRL_STATUS_DPLL1LDRTO = 0x8000000

	// XOSCCTRL: External Multipurpose Crystal Oscillator Control
	// Position of ENABLE field.
	OSCCTRL_XOSCCTRL_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	OSCCTRL_XOSCCTRL_ENABLE_Msk = 0x2
	// Bit ENABLE.
	OSCCTRL_XOSCCTRL_ENABLE = 0x2
	// Position of XTALEN field.
	OSCCTRL_XOSCCTRL_XTALEN_Pos = 0x2
	// Bit mask of XTALEN field.
	OSCCTRL_XOSCCTRL_XTALEN_Msk = 0x4
	// Bit XTALEN.
	OSCCTRL_XOSCCTRL_XTALEN = 0x4
	// Position of RUNSTDBY field.
	OSCCTRL_XOSCCTRL_RUNSTDBY_Pos = 0x6
	// Bit mask of RUNSTDBY field.
	OSCCTRL_XOSCCTRL_RUNSTDBY_Msk = 0x40
	// Bit RUNSTDBY.
	OSCCTRL_XOSCCTRL_RUNSTDBY = 0x40
	// Position of ONDEMAND field.
	OSCCTRL_XOSCCTRL_ONDEMAND_Pos = 0x7
	// Bit mask of ONDEMAND field.
	OSCCTRL_XOSCCTRL_ONDEMAND_Msk = 0x80
	// Bit ONDEMAND.
	OSCCTRL_XOSCCTRL_ONDEMAND = 0x80
	// Position of LOWBUFGAIN field.
	OSCCTRL_XOSCCTRL_LOWBUFGAIN_Pos = 0x8
	// Bit mask of LOWBUFGAIN field.
	OSCCTRL_XOSCCTRL_LOWBUFGAIN_Msk = 0x100
	// Bit LOWBUFGAIN.
	OSCCTRL_XOSCCTRL_LOWBUFGAIN = 0x100
	// Position of IPTAT field.
	OSCCTRL_XOSCCTRL_IPTAT_Pos = 0x9
	// Bit mask of IPTAT field.
	OSCCTRL_XOSCCTRL_IPTAT_Msk = 0x600
	// Position of IMULT field.
	OSCCTRL_XOSCCTRL_IMULT_Pos = 0xb
	// Bit mask of IMULT field.
	OSCCTRL_XOSCCTRL_IMULT_Msk = 0x7800
	// Position of ENALC field.
	OSCCTRL_XOSCCTRL_ENALC_Pos = 0xf
	// Bit mask of ENALC field.
	OSCCTRL_XOSCCTRL_ENALC_Msk = 0x8000
	// Bit ENALC.
	OSCCTRL_XOSCCTRL_ENALC = 0x8000
	// Position of CFDEN field.
	OSCCTRL_XOSCCTRL_CFDEN_Pos = 0x10
	// Bit mask of CFDEN field.
	OSCCTRL_XOSCCTRL_CFDEN_Msk = 0x10000
	// Bit CFDEN.
	OSCCTRL_XOSCCTRL_CFDEN = 0x10000
	// Position of SWBEN field.
	OSCCTRL_XOSCCTRL_SWBEN_Pos = 0x11
	// Bit mask of SWBEN field.
	OSCCTRL_XOSCCTRL_SWBEN_Msk = 0x20000
	// Bit SWBEN.
	OSCCTRL_XOSCCTRL_SWBEN = 0x20000
	// Position of STARTUP field.
	OSCCTRL_XOSCCTRL_STARTUP_Pos = 0x14
	// Bit mask of STARTUP field.
	OSCCTRL_XOSCCTRL_STARTUP_Msk = 0xf00000
	// 31 us
	OSCCTRL_XOSCCTRL_STARTUP_CYCLE1 = 0x0
	// 61 us
	OSCCTRL_XOSCCTRL_STARTUP_CYCLE2 = 0x1
	// 122 us
	OSCCTRL_XOSCCTRL_STARTUP_CYCLE4 = 0x2
	// 244 us
	OSCCTRL_XOSCCTRL_STARTUP_CYCLE8 = 0x3
	// 488 us
	OSCCTRL_XOSCCTRL_STARTUP_CYCLE16 = 0x4
	// 977 us
	OSCCTRL_XOSCCTRL_STARTUP_CYCLE32 = 0x5
	// 1953 us
	OSCCTRL_XOSCCTRL_STARTUP_CYCLE64 = 0x6
	// 3906 us
	OSCCTRL_XOSCCTRL_STARTUP_CYCLE128 = 0x7
	// 7813 us
	OSCCTRL_XOSCCTRL_STARTUP_CYCLE256 = 0x8
	// 15625 us
	OSCCTRL_XOSCCTRL_STARTUP_CYCLE512 = 0x9
	// 31250 us
	OSCCTRL_XOSCCTRL_STARTUP_CYCLE1024 = 0xa
	// 62500 us
	OSCCTRL_XOSCCTRL_STARTUP_CYCLE2048 = 0xb
	// 125000 us
	OSCCTRL_XOSCCTRL_STARTUP_CYCLE4096 = 0xc
	// 250000 us
	OSCCTRL_XOSCCTRL_STARTUP_CYCLE8192 = 0xd
	// 500000 us
	OSCCTRL_XOSCCTRL_STARTUP_CYCLE16384 = 0xe
	// 1000000 us
	OSCCTRL_XOSCCTRL_STARTUP_CYCLE32768 = 0xf
	// Position of CFDPRESC field.
	OSCCTRL_XOSCCTRL_CFDPRESC_Pos = 0x18
	// Bit mask of CFDPRESC field.
	OSCCTRL_XOSCCTRL_CFDPRESC_Msk = 0xf000000
	// 48 MHz
	OSCCTRL_XOSCCTRL_CFDPRESC_DIV1 = 0x0
	// 24 MHz
	OSCCTRL_XOSCCTRL_CFDPRESC_DIV2 = 0x1
	// 12 MHz
	OSCCTRL_XOSCCTRL_CFDPRESC_DIV4 = 0x2
	// 6 MHz
	OSCCTRL_XOSCCTRL_CFDPRESC_DIV8 = 0x3
	// 3 MHz
	OSCCTRL_XOSCCTRL_CFDPRESC_DIV16 = 0x4
	// 1.5 MHz
	OSCCTRL_XOSCCTRL_CFDPRESC_DIV32 = 0x5
	// 0.75 MHz
	OSCCTRL_XOSCCTRL_CFDPRESC_DIV64 = 0x6
	// 0.3125 MHz
	OSCCTRL_XOSCCTRL_CFDPRESC_DIV128 = 0x7

	// DFLLCTRLA: DFLL48M Control A
	// Position of ENABLE field.
	OSCCTRL_DFLLCTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	OSCCTRL_DFLLCTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	OSCCTRL_DFLLCTRLA_ENABLE = 0x2
	// Position of RUNSTDBY field.
	OSCCTRL_DFLLCTRLA_RUNSTDBY_Pos = 0x6
	// Bit mask of RUNSTDBY field.
	OSCCTRL_DFLLCTRLA_RUNSTDBY_Msk = 0x40
	// Bit RUNSTDBY.
	OSCCTRL_DFLLCTRLA_RUNSTDBY = 0x40
	// Position of ONDEMAND field.
	OSCCTRL_DFLLCTRLA_ONDEMAND_Pos = 0x7
	// Bit mask of ONDEMAND field.
	OSCCTRL_DFLLCTRLA_ONDEMAND_Msk = 0x80
	// Bit ONDEMAND.
	OSCCTRL_DFLLCTRLA_ONDEMAND = 0x80

	// DFLLCTRLB: DFLL48M Control B
	// Position of MODE field.
	OSCCTRL_DFLLCTRLB_MODE_Pos = 0x0
	// Bit mask of MODE field.
	OSCCTRL_DFLLCTRLB_MODE_Msk = 0x1
	// Bit MODE.
	OSCCTRL_DFLLCTRLB_MODE = 0x1
	// Position of STABLE field.
	OSCCTRL_DFLLCTRLB_STABLE_Pos = 0x1
	// Bit mask of STABLE field.
	OSCCTRL_DFLLCTRLB_STABLE_Msk = 0x2
	// Bit STABLE.
	OSCCTRL_DFLLCTRLB_STABLE = 0x2
	// Position of LLAW field.
	OSCCTRL_DFLLCTRLB_LLAW_Pos = 0x2
	// Bit mask of LLAW field.
	OSCCTRL_DFLLCTRLB_LLAW_Msk = 0x4
	// Bit LLAW.
	OSCCTRL_DFLLCTRLB_LLAW = 0x4
	// Position of USBCRM field.
	OSCCTRL_DFLLCTRLB_USBCRM_Pos = 0x3
	// Bit mask of USBCRM field.
	OSCCTRL_DFLLCTRLB_USBCRM_Msk = 0x8
	// Bit USBCRM.
	OSCCTRL_DFLLCTRLB_USBCRM = 0x8
	// Position of CCDIS field.
	OSCCTRL_DFLLCTRLB_CCDIS_Pos = 0x4
	// Bit mask of CCDIS field.
	OSCCTRL_DFLLCTRLB_CCDIS_Msk = 0x10
	// Bit CCDIS.
	OSCCTRL_DFLLCTRLB_CCDIS = 0x10
	// Position of QLDIS field.
	OSCCTRL_DFLLCTRLB_QLDIS_Pos = 0x5
	// Bit mask of QLDIS field.
	OSCCTRL_DFLLCTRLB_QLDIS_Msk = 0x20
	// Bit QLDIS.
	OSCCTRL_DFLLCTRLB_QLDIS = 0x20
	// Position of BPLCKC field.
	OSCCTRL_DFLLCTRLB_BPLCKC_Pos = 0x6
	// Bit mask of BPLCKC field.
	OSCCTRL_DFLLCTRLB_BPLCKC_Msk = 0x40
	// Bit BPLCKC.
	OSCCTRL_DFLLCTRLB_BPLCKC = 0x40
	// Position of WAITLOCK field.
	OSCCTRL_DFLLCTRLB_WAITLOCK_Pos = 0x7
	// Bit mask of WAITLOCK field.
	OSCCTRL_DFLLCTRLB_WAITLOCK_Msk = 0x80
	// Bit WAITLOCK.
	OSCCTRL_DFLLCTRLB_WAITLOCK = 0x80

	// DFLLVAL: DFLL48M Value
	// Position of FINE field.
	OSCCTRL_DFLLVAL_FINE_Pos = 0x0
	// Bit mask of FINE field.
	OSCCTRL_DFLLVAL_FINE_Msk = 0xff
	// Position of COARSE field.
	OSCCTRL_DFLLVAL_COARSE_Pos = 0xa
	// Bit mask of COARSE field.
	OSCCTRL_DFLLVAL_COARSE_Msk = 0xfc00
	// Position of DIFF field.
	OSCCTRL_DFLLVAL_DIFF_Pos = 0x10
	// Bit mask of DIFF field.
	OSCCTRL_DFLLVAL_DIFF_Msk = 0xffff0000

	// DFLLMUL: DFLL48M Multiplier
	// Position of MUL field.
	OSCCTRL_DFLLMUL_MUL_Pos = 0x0
	// Bit mask of MUL field.
	OSCCTRL_DFLLMUL_MUL_Msk = 0xffff
	// Position of FSTEP field.
	OSCCTRL_DFLLMUL_FSTEP_Pos = 0x10
	// Bit mask of FSTEP field.
	OSCCTRL_DFLLMUL_FSTEP_Msk = 0xff0000
	// Position of CSTEP field.
	OSCCTRL_DFLLMUL_CSTEP_Pos = 0x1a
	// Bit mask of CSTEP field.
	OSCCTRL_DFLLMUL_CSTEP_Msk = 0xfc000000

	// DFLLSYNC: DFLL48M Synchronization
	// Position of ENABLE field.
	OSCCTRL_DFLLSYNC_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	OSCCTRL_DFLLSYNC_ENABLE_Msk = 0x2
	// Bit ENABLE.
	OSCCTRL_DFLLSYNC_ENABLE = 0x2
	// Position of DFLLCTRLB field.
	OSCCTRL_DFLLSYNC_DFLLCTRLB_Pos = 0x2
	// Bit mask of DFLLCTRLB field.
	OSCCTRL_DFLLSYNC_DFLLCTRLB_Msk = 0x4
	// Bit DFLLCTRLB.
	OSCCTRL_DFLLSYNC_DFLLCTRLB = 0x4
	// Position of DFLLVAL field.
	OSCCTRL_DFLLSYNC_DFLLVAL_Pos = 0x3
	// Bit mask of DFLLVAL field.
	OSCCTRL_DFLLSYNC_DFLLVAL_Msk = 0x8
	// Bit DFLLVAL.
	OSCCTRL_DFLLSYNC_DFLLVAL = 0x8
	// Position of DFLLMUL field.
	OSCCTRL_DFLLSYNC_DFLLMUL_Pos = 0x4
	// Bit mask of DFLLMUL field.
	OSCCTRL_DFLLSYNC_DFLLMUL_Msk = 0x10
	// Bit DFLLMUL.
	OSCCTRL_DFLLSYNC_DFLLMUL = 0x10

	// DPLL.DPLLCTRLA: DPLL Control A
	// Position of ENABLE field.
	OSCCTRL_DPLL_DPLLCTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	OSCCTRL_DPLL_DPLLCTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	OSCCTRL_DPLL_DPLLCTRLA_ENABLE = 0x2
	// Position of RUNSTDBY field.
	OSCCTRL_DPLL_DPLLCTRLA_RUNSTDBY_Pos = 0x6
	// Bit mask of RUNSTDBY field.
	OSCCTRL_DPLL_DPLLCTRLA_RUNSTDBY_Msk = 0x40
	// Bit RUNSTDBY.
	OSCCTRL_DPLL_DPLLCTRLA_RUNSTDBY = 0x40
	// Position of ONDEMAND field.
	OSCCTRL_DPLL_DPLLCTRLA_ONDEMAND_Pos = 0x7
	// Bit mask of ONDEMAND field.
	OSCCTRL_DPLL_DPLLCTRLA_ONDEMAND_Msk = 0x80
	// Bit ONDEMAND.
	OSCCTRL_DPLL_DPLLCTRLA_ONDEMAND = 0x80

	// DPLL.DPLLRATIO: DPLL Ratio Control
	// Position of LDR field.
	OSCCTRL_DPLL_DPLLRATIO_LDR_Pos = 0x0
	// Bit mask of LDR field.
	OSCCTRL_DPLL_DPLLRATIO_LDR_Msk = 0x1fff
	// Position of LDRFRAC field.
	OSCCTRL_DPLL_DPLLRATIO_LDRFRAC_Pos = 0x10
	// Bit mask of LDRFRAC field.
	OSCCTRL_DPLL_DPLLRATIO_LDRFRAC_Msk = 0x1f0000

	// DPLL.DPLLCTRLB: DPLL Control B
	// Position of FILTER field.
	OSCCTRL_DPLL_DPLLCTRLB_FILTER_Pos = 0x0
	// Bit mask of FILTER field.
	OSCCTRL_DPLL_DPLLCTRLB_FILTER_Msk = 0xf
	// Bandwidth = 92.7Khz and Damping Factor = 0.76
	OSCCTRL_DPLL_DPLLCTRLB_FILTER_FILTER1 = 0x0
	// Bandwidth = 131Khz and Damping Factor = 1.08
	OSCCTRL_DPLL_DPLLCTRLB_FILTER_FILTER2 = 0x1
	// Bandwidth = 46.4Khz and Damping Factor = 0.38
	OSCCTRL_DPLL_DPLLCTRLB_FILTER_FILTER3 = 0x2
	// Bandwidth = 65.6Khz and Damping Factor = 0.54
	OSCCTRL_DPLL_DPLLCTRLB_FILTER_FILTER4 = 0x3
	// Bandwidth = 131Khz and Damping Factor = 0.56
	OSCCTRL_DPLL_DPLLCTRLB_FILTER_FILTER5 = 0x4
	// Bandwidth = 185Khz and Damping Factor = 0.79
	OSCCTRL_DPLL_DPLLCTRLB_FILTER_FILTER6 = 0x5
	// Bandwidth = 65.6Khz and Damping Factor = 0.28
	OSCCTRL_DPLL_DPLLCTRLB_FILTER_FILTER7 = 0x6
	// Bandwidth = 92.7Khz and Damping Factor = 0.39
	OSCCTRL_DPLL_DPLLCTRLB_FILTER_FILTER8 = 0x7
	// Bandwidth = 46.4Khz and Damping Factor = 1.49
	OSCCTRL_DPLL_DPLLCTRLB_FILTER_FILTER9 = 0x8
	// Bandwidth = 65.6Khz and Damping Factor = 2.11
	OSCCTRL_DPLL_DPLLCTRLB_FILTER_FILTER10 = 0x9
	// Bandwidth = 23.2Khz and Damping Factor = 0.75
	OSCCTRL_DPLL_DPLLCTRLB_FILTER_FILTER11 = 0xa
	// Bandwidth = 32.8Khz and Damping Factor = 1.06
	OSCCTRL_DPLL_DPLLCTRLB_FILTER_FILTER12 = 0xb
	// Bandwidth = 65.6Khz and Damping Factor = 1.07
	OSCCTRL_DPLL_DPLLCTRLB_FILTER_FILTER13 = 0xc
	// Bandwidth = 92.7Khz and Damping Factor = 1.51
	OSCCTRL_DPLL_DPLLCTRLB_FILTER_FILTER14 = 0xd
	// Bandwidth = 32.8Khz and Damping Factor = 0.53
	OSCCTRL_DPLL_DPLLCTRLB_FILTER_FILTER15 = 0xe
	// Bandwidth = 46.4Khz and Damping Factor = 0.75
	OSCCTRL_DPLL_DPLLCTRLB_FILTER_FILTER16 = 0xf
	// Position of WUF field.
	OSCCTRL_DPLL_DPLLCTRLB_WUF_Pos = 0x4
	// Bit mask of WUF field.
	OSCCTRL_DPLL_DPLLCTRLB_WUF_Msk = 0x10
	// Bit WUF.
	OSCCTRL_DPLL_DPLLCTRLB_WUF = 0x10
	// Position of REFCLK field.
	OSCCTRL_DPLL_DPLLCTRLB_REFCLK_Pos = 0x5
	// Bit mask of REFCLK field.
	OSCCTRL_DPLL_DPLLCTRLB_REFCLK_Msk = 0xe0
	// Dedicated GCLK clock reference
	OSCCTRL_DPLL_DPLLCTRLB_REFCLK_GCLK = 0x0
	// XOSC32K clock reference
	OSCCTRL_DPLL_DPLLCTRLB_REFCLK_XOSC32 = 0x1
	// XOSC0 clock reference
	OSCCTRL_DPLL_DPLLCTRLB_REFCLK_XOSC0 = 0x2
	// XOSC1 clock reference
	OSCCTRL_DPLL_DPLLCTRLB_REFCLK_XOSC1 = 0x3
	// Position of LTIME field.
	OSCCTRL_DPLL_DPLLCTRLB_LTIME_Pos = 0x8
	// Bit mask of LTIME field.
	OSCCTRL_DPLL_DPLLCTRLB_LTIME_Msk = 0x700
	// No time-out. Automatic lock
	OSCCTRL_DPLL_DPLLCTRLB_LTIME_DEFAULT = 0x0
	// Time-out if no lock within 800us
	OSCCTRL_DPLL_DPLLCTRLB_LTIME_800US = 0x4
	// Time-out if no lock within 900us
	OSCCTRL_DPLL_DPLLCTRLB_LTIME_900US = 0x5
	// Time-out if no lock within 1ms
	OSCCTRL_DPLL_DPLLCTRLB_LTIME_1MS = 0x6
	// Time-out if no lock within 1.1ms
	OSCCTRL_DPLL_DPLLCTRLB_LTIME_1P1MS = 0x7
	// Position of LBYPASS field.
	OSCCTRL_DPLL_DPLLCTRLB_LBYPASS_Pos = 0xb
	// Bit mask of LBYPASS field.
	OSCCTRL_DPLL_DPLLCTRLB_LBYPASS_Msk = 0x800
	// Bit LBYPASS.
	OSCCTRL_DPLL_DPLLCTRLB_LBYPASS = 0x800
	// Position of DCOFILTER field.
	OSCCTRL_DPLL_DPLLCTRLB_DCOFILTER_Pos = 0xc
	// Bit mask of DCOFILTER field.
	OSCCTRL_DPLL_DPLLCTRLB_DCOFILTER_Msk = 0x7000
	// Capacitor(pF) = 0.5 and Bandwidth Fn (MHz) = 3.21
	OSCCTRL_DPLL_DPLLCTRLB_DCOFILTER_FILTER1 = 0x0
	// Capacitor(pF) = 1 and Bandwidth Fn (MHz) = 1.6
	OSCCTRL_DPLL_DPLLCTRLB_DCOFILTER_FILTER2 = 0x1
	// Capacitor(pF) = 1.5 and Bandwidth Fn (MHz) = 1.1
	OSCCTRL_DPLL_DPLLCTRLB_DCOFILTER_FILTER3 = 0x2
	// Capacitor(pF) = 2 and Bandwidth Fn (MHz) = 0.8
	OSCCTRL_DPLL_DPLLCTRLB_DCOFILTER_FILTER4 = 0x3
	// Capacitor(pF) = 2.5 and Bandwidth Fn (MHz) = 0.64
	OSCCTRL_DPLL_DPLLCTRLB_DCOFILTER_FILTER5 = 0x4
	// Capacitor(pF) = 3 and Bandwidth Fn (MHz) = 0.55
	OSCCTRL_DPLL_DPLLCTRLB_DCOFILTER_FILTER6 = 0x5
	// Capacitor(pF) = 3.5 and Bandwidth Fn (MHz) = 0.45
	OSCCTRL_DPLL_DPLLCTRLB_DCOFILTER_FILTER7 = 0x6
	// Capacitor(pF) = 4 and Bandwidth Fn (MHz) = 0.4
	OSCCTRL_DPLL_DPLLCTRLB_DCOFILTER_FILTER8 = 0x7
	// Position of DCOEN field.
	OSCCTRL_DPLL_DPLLCTRLB_DCOEN_Pos = 0xf
	// Bit mask of DCOEN field.
	OSCCTRL_DPLL_DPLLCTRLB_DCOEN_Msk = 0x8000
	// Bit DCOEN.
	OSCCTRL_DPLL_DPLLCTRLB_DCOEN = 0x8000
	// Position of DIV field.
	OSCCTRL_DPLL_DPLLCTRLB_DIV_Pos = 0x10
	// Bit mask of DIV field.
	OSCCTRL_DPLL_DPLLCTRLB_DIV_Msk = 0x7ff0000

	// DPLL.DPLLSYNCBUSY: DPLL Synchronization Busy
	// Position of ENABLE field.
	OSCCTRL_DPLL_DPLLSYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	OSCCTRL_DPLL_DPLLSYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	OSCCTRL_DPLL_DPLLSYNCBUSY_ENABLE = 0x2
	// Position of DPLLRATIO field.
	OSCCTRL_DPLL_DPLLSYNCBUSY_DPLLRATIO_Pos = 0x2
	// Bit mask of DPLLRATIO field.
	OSCCTRL_DPLL_DPLLSYNCBUSY_DPLLRATIO_Msk = 0x4
	// Bit DPLLRATIO.
	OSCCTRL_DPLL_DPLLSYNCBUSY_DPLLRATIO = 0x4

	// DPLL.DPLLSTATUS: DPLL Status
	// Position of LOCK field.
	OSCCTRL_DPLL_DPLLSTATUS_LOCK_Pos = 0x0
	// Bit mask of LOCK field.
	OSCCTRL_DPLL_DPLLSTATUS_LOCK_Msk = 0x1
	// Bit LOCK.
	OSCCTRL_DPLL_DPLLSTATUS_LOCK = 0x1
	// Position of CLKRDY field.
	OSCCTRL_DPLL_DPLLSTATUS_CLKRDY_Pos = 0x1
	// Bit mask of CLKRDY field.
	OSCCTRL_DPLL_DPLLSTATUS_CLKRDY_Msk = 0x2
	// Bit CLKRDY.
	OSCCTRL_DPLL_DPLLSTATUS_CLKRDY = 0x2
)

// Constants for OSC32KCTRL: 32kHz Oscillators Control
const (
	// INTENCLR: Interrupt Enable Clear
	// Position of XOSC32KRDY field.
	OSC32KCTRL_INTENCLR_XOSC32KRDY_Pos = 0x0
	// Bit mask of XOSC32KRDY field.
	OSC32KCTRL_INTENCLR_XOSC32KRDY_Msk = 0x1
	// Bit XOSC32KRDY.
	OSC32KCTRL_INTENCLR_XOSC32KRDY = 0x1
	// Position of XOSC32KFAIL field.
	OSC32KCTRL_INTENCLR_XOSC32KFAIL_Pos = 0x2
	// Bit mask of XOSC32KFAIL field.
	OSC32KCTRL_INTENCLR_XOSC32KFAIL_Msk = 0x4
	// Bit XOSC32KFAIL.
	OSC32KCTRL_INTENCLR_XOSC32KFAIL = 0x4

	// INTENSET: Interrupt Enable Set
	// Position of XOSC32KRDY field.
	OSC32KCTRL_INTENSET_XOSC32KRDY_Pos = 0x0
	// Bit mask of XOSC32KRDY field.
	OSC32KCTRL_INTENSET_XOSC32KRDY_Msk = 0x1
	// Bit XOSC32KRDY.
	OSC32KCTRL_INTENSET_XOSC32KRDY = 0x1
	// Position of XOSC32KFAIL field.
	OSC32KCTRL_INTENSET_XOSC32KFAIL_Pos = 0x2
	// Bit mask of XOSC32KFAIL field.
	OSC32KCTRL_INTENSET_XOSC32KFAIL_Msk = 0x4
	// Bit XOSC32KFAIL.
	OSC32KCTRL_INTENSET_XOSC32KFAIL = 0x4

	// INTFLAG: Interrupt Flag Status and Clear
	// Position of XOSC32KRDY field.
	OSC32KCTRL_INTFLAG_XOSC32KRDY_Pos = 0x0
	// Bit mask of XOSC32KRDY field.
	OSC32KCTRL_INTFLAG_XOSC32KRDY_Msk = 0x1
	// Bit XOSC32KRDY.
	OSC32KCTRL_INTFLAG_XOSC32KRDY = 0x1
	// Position of XOSC32KFAIL field.
	OSC32KCTRL_INTFLAG_XOSC32KFAIL_Pos = 0x2
	// Bit mask of XOSC32KFAIL field.
	OSC32KCTRL_INTFLAG_XOSC32KFAIL_Msk = 0x4
	// Bit XOSC32KFAIL.
	OSC32KCTRL_INTFLAG_XOSC32KFAIL = 0x4

	// STATUS: Power and Clocks Status
	// Position of XOSC32KRDY field.
	OSC32KCTRL_STATUS_XOSC32KRDY_Pos = 0x0
	// Bit mask of XOSC32KRDY field.
	OSC32KCTRL_STATUS_XOSC32KRDY_Msk = 0x1
	// Bit XOSC32KRDY.
	OSC32KCTRL_STATUS_XOSC32KRDY = 0x1
	// Position of XOSC32KFAIL field.
	OSC32KCTRL_STATUS_XOSC32KFAIL_Pos = 0x2
	// Bit mask of XOSC32KFAIL field.
	OSC32KCTRL_STATUS_XOSC32KFAIL_Msk = 0x4
	// Bit XOSC32KFAIL.
	OSC32KCTRL_STATUS_XOSC32KFAIL = 0x4
	// Position of XOSC32KSW field.
	OSC32KCTRL_STATUS_XOSC32KSW_Pos = 0x3
	// Bit mask of XOSC32KSW field.
	OSC32KCTRL_STATUS_XOSC32KSW_Msk = 0x8
	// Bit XOSC32KSW.
	OSC32KCTRL_STATUS_XOSC32KSW = 0x8

	// RTCCTRL: RTC Clock Selection
	// Position of RTCSEL field.
	OSC32KCTRL_RTCCTRL_RTCSEL_Pos = 0x0
	// Bit mask of RTCSEL field.
	OSC32KCTRL_RTCCTRL_RTCSEL_Msk = 0x7
	// 1.024kHz from 32kHz internal ULP oscillator
	OSC32KCTRL_RTCCTRL_RTCSEL_ULP1K = 0x0
	// 32.768kHz from 32kHz internal ULP oscillator
	OSC32KCTRL_RTCCTRL_RTCSEL_ULP32K = 0x1
	// 1.024kHz from 32.768kHz internal oscillator
	OSC32KCTRL_RTCCTRL_RTCSEL_XOSC1K = 0x4
	// 32.768kHz from 32.768kHz external crystal oscillator
	OSC32KCTRL_RTCCTRL_RTCSEL_XOSC32K = 0x5

	// XOSC32K: 32kHz External Crystal Oscillator (XOSC32K) Control
	// Position of ENABLE field.
	OSC32KCTRL_XOSC32K_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	OSC32KCTRL_XOSC32K_ENABLE_Msk = 0x2
	// Bit ENABLE.
	OSC32KCTRL_XOSC32K_ENABLE = 0x2
	// Position of XTALEN field.
	OSC32KCTRL_XOSC32K_XTALEN_Pos = 0x2
	// Bit mask of XTALEN field.
	OSC32KCTRL_XOSC32K_XTALEN_Msk = 0x4
	// Bit XTALEN.
	OSC32KCTRL_XOSC32K_XTALEN = 0x4
	// Position of EN32K field.
	OSC32KCTRL_XOSC32K_EN32K_Pos = 0x3
	// Bit mask of EN32K field.
	OSC32KCTRL_XOSC32K_EN32K_Msk = 0x8
	// Bit EN32K.
	OSC32KCTRL_XOSC32K_EN32K = 0x8
	// Position of EN1K field.
	OSC32KCTRL_XOSC32K_EN1K_Pos = 0x4
	// Bit mask of EN1K field.
	OSC32KCTRL_XOSC32K_EN1K_Msk = 0x10
	// Bit EN1K.
	OSC32KCTRL_XOSC32K_EN1K = 0x10
	// Position of RUNSTDBY field.
	OSC32KCTRL_XOSC32K_RUNSTDBY_Pos = 0x6
	// Bit mask of RUNSTDBY field.
	OSC32KCTRL_XOSC32K_RUNSTDBY_Msk = 0x40
	// Bit RUNSTDBY.
	OSC32KCTRL_XOSC32K_RUNSTDBY = 0x40
	// Position of ONDEMAND field.
	OSC32KCTRL_XOSC32K_ONDEMAND_Pos = 0x7
	// Bit mask of ONDEMAND field.
	OSC32KCTRL_XOSC32K_ONDEMAND_Msk = 0x80
	// Bit ONDEMAND.
	OSC32KCTRL_XOSC32K_ONDEMAND = 0x80
	// Position of STARTUP field.
	OSC32KCTRL_XOSC32K_STARTUP_Pos = 0x8
	// Bit mask of STARTUP field.
	OSC32KCTRL_XOSC32K_STARTUP_Msk = 0x700
	// 62.6 ms
	OSC32KCTRL_XOSC32K_STARTUP_CYCLE2048 = 0x0
	// 125 ms
	OSC32KCTRL_XOSC32K_STARTUP_CYCLE4096 = 0x1
	// 500 ms
	OSC32KCTRL_XOSC32K_STARTUP_CYCLE16384 = 0x2
	// 1000 ms
	OSC32KCTRL_XOSC32K_STARTUP_CYCLE32768 = 0x3
	// 2000 ms
	OSC32KCTRL_XOSC32K_STARTUP_CYCLE65536 = 0x4
	// 4000 ms
	OSC32KCTRL_XOSC32K_STARTUP_CYCLE131072 = 0x5
	// 8000 ms
	OSC32KCTRL_XOSC32K_STARTUP_CYCLE262144 = 0x6
	// Position of WRTLOCK field.
	OSC32KCTRL_XOSC32K_WRTLOCK_Pos = 0xc
	// Bit mask of WRTLOCK field.
	OSC32KCTRL_XOSC32K_WRTLOCK_Msk = 0x1000
	// Bit WRTLOCK.
	OSC32KCTRL_XOSC32K_WRTLOCK = 0x1000
	// Position of CGM field.
	OSC32KCTRL_XOSC32K_CGM_Pos = 0xd
	// Bit mask of CGM field.
	OSC32KCTRL_XOSC32K_CGM_Msk = 0x6000
	// Standard mode
	OSC32KCTRL_XOSC32K_CGM_XT = 0x1
	// High Speed mode
	OSC32KCTRL_XOSC32K_CGM_HS = 0x2

	// CFDCTRL: Clock Failure Detector Control
	// Position of CFDEN field.
	OSC32KCTRL_CFDCTRL_CFDEN_Pos = 0x0
	// Bit mask of CFDEN field.
	OSC32KCTRL_CFDCTRL_CFDEN_Msk = 0x1
	// Bit CFDEN.
	OSC32KCTRL_CFDCTRL_CFDEN = 0x1
	// Position of SWBACK field.
	OSC32KCTRL_CFDCTRL_SWBACK_Pos = 0x1
	// Bit mask of SWBACK field.
	OSC32KCTRL_CFDCTRL_SWBACK_Msk = 0x2
	// Bit SWBACK.
	OSC32KCTRL_CFDCTRL_SWBACK = 0x2
	// Position of CFDPRESC field.
	OSC32KCTRL_CFDCTRL_CFDPRESC_Pos = 0x2
	// Bit mask of CFDPRESC field.
	OSC32KCTRL_CFDCTRL_CFDPRESC_Msk = 0x4
	// Bit CFDPRESC.
	OSC32KCTRL_CFDCTRL_CFDPRESC = 0x4

	// EVCTRL: Event Control
	// Position of CFDEO field.
	OSC32KCTRL_EVCTRL_CFDEO_Pos = 0x0
	// Bit mask of CFDEO field.
	OSC32KCTRL_EVCTRL_CFDEO_Msk = 0x1
	// Bit CFDEO.
	OSC32KCTRL_EVCTRL_CFDEO = 0x1

	// OSCULP32K: 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control
	// Position of EN32K field.
	OSC32KCTRL_OSCULP32K_EN32K_Pos = 0x1
	// Bit mask of EN32K field.
	OSC32KCTRL_OSCULP32K_EN32K_Msk = 0x2
	// Bit EN32K.
	OSC32KCTRL_OSCULP32K_EN32K = 0x2
	// Position of EN1K field.
	OSC32KCTRL_OSCULP32K_EN1K_Pos = 0x2
	// Bit mask of EN1K field.
	OSC32KCTRL_OSCULP32K_EN1K_Msk = 0x4
	// Bit EN1K.
	OSC32KCTRL_OSCULP32K_EN1K = 0x4
	// Position of CALIB field.
	OSC32KCTRL_OSCULP32K_CALIB_Pos = 0x8
	// Bit mask of CALIB field.
	OSC32KCTRL_OSCULP32K_CALIB_Msk = 0x3f00
	// Position of WRTLOCK field.
	OSC32KCTRL_OSCULP32K_WRTLOCK_Pos = 0xf
	// Bit mask of WRTLOCK field.
	OSC32KCTRL_OSCULP32K_WRTLOCK_Msk = 0x8000
	// Bit WRTLOCK.
	OSC32KCTRL_OSCULP32K_WRTLOCK = 0x8000
)

// Constants for PAC: Peripheral Access Controller
const (
	// WRCTRL: Write control
	// Position of PERID field.
	PAC_WRCTRL_PERID_Pos = 0x0
	// Bit mask of PERID field.
	PAC_WRCTRL_PERID_Msk = 0xffff
	// Position of KEY field.
	PAC_WRCTRL_KEY_Pos = 0x10
	// Bit mask of KEY field.
	PAC_WRCTRL_KEY_Msk = 0xff0000
	// No action
	PAC_WRCTRL_KEY_OFF = 0x0
	// Clear protection
	PAC_WRCTRL_KEY_CLR = 0x1
	// Set protection
	PAC_WRCTRL_KEY_SET = 0x2
	// Set and lock protection
	PAC_WRCTRL_KEY_SETLCK = 0x3

	// EVCTRL: Event control
	// Position of ERREO field.
	PAC_EVCTRL_ERREO_Pos = 0x0
	// Bit mask of ERREO field.
	PAC_EVCTRL_ERREO_Msk = 0x1
	// Bit ERREO.
	PAC_EVCTRL_ERREO = 0x1

	// INTENCLR: Interrupt enable clear
	// Position of ERR field.
	PAC_INTENCLR_ERR_Pos = 0x0
	// Bit mask of ERR field.
	PAC_INTENCLR_ERR_Msk = 0x1
	// Bit ERR.
	PAC_INTENCLR_ERR = 0x1

	// INTENSET: Interrupt enable set
	// Position of ERR field.
	PAC_INTENSET_ERR_Pos = 0x0
	// Bit mask of ERR field.
	PAC_INTENSET_ERR_Msk = 0x1
	// Bit ERR.
	PAC_INTENSET_ERR = 0x1

	// INTFLAGAHB: Bridge interrupt flag status
	// Position of FLASH_ field.
	PAC_INTFLAGAHB_FLASH__Pos = 0x0
	// Bit mask of FLASH_ field.
	PAC_INTFLAGAHB_FLASH__Msk = 0x1
	// Bit FLASH_.
	PAC_INTFLAGAHB_FLASH_ = 0x1
	// Position of FLASH_ALT_ field.
	PAC_INTFLAGAHB_FLASH_ALT__Pos = 0x1
	// Bit mask of FLASH_ALT_ field.
	PAC_INTFLAGAHB_FLASH_ALT__Msk = 0x2
	// Bit FLASH_ALT_.
	PAC_INTFLAGAHB_FLASH_ALT_ = 0x2
	// Position of SEEPROM_ field.
	PAC_INTFLAGAHB_SEEPROM__Pos = 0x2
	// Bit mask of SEEPROM_ field.
	PAC_INTFLAGAHB_SEEPROM__Msk = 0x4
	// Bit SEEPROM_.
	PAC_INTFLAGAHB_SEEPROM_ = 0x4
	// Position of RAMCM4S_ field.
	PAC_INTFLAGAHB_RAMCM4S__Pos = 0x3
	// Bit mask of RAMCM4S_ field.
	PAC_INTFLAGAHB_RAMCM4S__Msk = 0x8
	// Bit RAMCM4S_.
	PAC_INTFLAGAHB_RAMCM4S_ = 0x8
	// Position of RAMPPPDSU_ field.
	PAC_INTFLAGAHB_RAMPPPDSU__Pos = 0x4
	// Bit mask of RAMPPPDSU_ field.
	PAC_INTFLAGAHB_RAMPPPDSU__Msk = 0x10
	// Bit RAMPPPDSU_.
	PAC_INTFLAGAHB_RAMPPPDSU_ = 0x10
	// Position of RAMDMAWR_ field.
	PAC_INTFLAGAHB_RAMDMAWR__Pos = 0x5
	// Bit mask of RAMDMAWR_ field.
	PAC_INTFLAGAHB_RAMDMAWR__Msk = 0x20
	// Bit RAMDMAWR_.
	PAC_INTFLAGAHB_RAMDMAWR_ = 0x20
	// Position of RAMDMACICM_ field.
	PAC_INTFLAGAHB_RAMDMACICM__Pos = 0x6
	// Bit mask of RAMDMACICM_ field.
	PAC_INTFLAGAHB_RAMDMACICM__Msk = 0x40
	// Bit RAMDMACICM_.
	PAC_INTFLAGAHB_RAMDMACICM_ = 0x40
	// Position of HPB0_ field.
	PAC_INTFLAGAHB_HPB0__Pos = 0x7
	// Bit mask of HPB0_ field.
	PAC_INTFLAGAHB_HPB0__Msk = 0x80
	// Bit HPB0_.
	PAC_INTFLAGAHB_HPB0_ = 0x80
	// Position of HPB1_ field.
	PAC_INTFLAGAHB_HPB1__Pos = 0x8
	// Bit mask of HPB1_ field.
	PAC_INTFLAGAHB_HPB1__Msk = 0x100
	// Bit HPB1_.
	PAC_INTFLAGAHB_HPB1_ = 0x100
	// Position of HPB2_ field.
	PAC_INTFLAGAHB_HPB2__Pos = 0x9
	// Bit mask of HPB2_ field.
	PAC_INTFLAGAHB_HPB2__Msk = 0x200
	// Bit HPB2_.
	PAC_INTFLAGAHB_HPB2_ = 0x200
	// Position of HPB3_ field.
	PAC_INTFLAGAHB_HPB3__Pos = 0xa
	// Bit mask of HPB3_ field.
	PAC_INTFLAGAHB_HPB3__Msk = 0x400
	// Bit HPB3_.
	PAC_INTFLAGAHB_HPB3_ = 0x400
	// Position of PUKCC_ field.
	PAC_INTFLAGAHB_PUKCC__Pos = 0xb
	// Bit mask of PUKCC_ field.
	PAC_INTFLAGAHB_PUKCC__Msk = 0x800
	// Bit PUKCC_.
	PAC_INTFLAGAHB_PUKCC_ = 0x800
	// Position of SDHC0_ field.
	PAC_INTFLAGAHB_SDHC0__Pos = 0xc
	// Bit mask of SDHC0_ field.
	PAC_INTFLAGAHB_SDHC0__Msk = 0x1000
	// Bit SDHC0_.
	PAC_INTFLAGAHB_SDHC0_ = 0x1000
	// Position of QSPI_ field.
	PAC_INTFLAGAHB_QSPI__Pos = 0xe
	// Bit mask of QSPI_ field.
	PAC_INTFLAGAHB_QSPI__Msk = 0x4000
	// Bit QSPI_.
	PAC_INTFLAGAHB_QSPI_ = 0x4000
	// Position of BKUPRAM_ field.
	PAC_INTFLAGAHB_BKUPRAM__Pos = 0xf
	// Bit mask of BKUPRAM_ field.
	PAC_INTFLAGAHB_BKUPRAM__Msk = 0x8000
	// Bit BKUPRAM_.
	PAC_INTFLAGAHB_BKUPRAM_ = 0x8000

	// INTFLAGA: Peripheral interrupt flag status - Bridge A
	// Position of PAC_ field.
	PAC_INTFLAGA_PAC__Pos = 0x0
	// Bit mask of PAC_ field.
	PAC_INTFLAGA_PAC__Msk = 0x1
	// Bit PAC_.
	PAC_INTFLAGA_PAC_ = 0x1
	// Position of PM_ field.
	PAC_INTFLAGA_PM__Pos = 0x1
	// Bit mask of PM_ field.
	PAC_INTFLAGA_PM__Msk = 0x2
	// Bit PM_.
	PAC_INTFLAGA_PM_ = 0x2
	// Position of MCLK_ field.
	PAC_INTFLAGA_MCLK__Pos = 0x2
	// Bit mask of MCLK_ field.
	PAC_INTFLAGA_MCLK__Msk = 0x4
	// Bit MCLK_.
	PAC_INTFLAGA_MCLK_ = 0x4
	// Position of RSTC_ field.
	PAC_INTFLAGA_RSTC__Pos = 0x3
	// Bit mask of RSTC_ field.
	PAC_INTFLAGA_RSTC__Msk = 0x8
	// Bit RSTC_.
	PAC_INTFLAGA_RSTC_ = 0x8
	// Position of OSCCTRL_ field.
	PAC_INTFLAGA_OSCCTRL__Pos = 0x4
	// Bit mask of OSCCTRL_ field.
	PAC_INTFLAGA_OSCCTRL__Msk = 0x10
	// Bit OSCCTRL_.
	PAC_INTFLAGA_OSCCTRL_ = 0x10
	// Position of OSC32KCTRL_ field.
	PAC_INTFLAGA_OSC32KCTRL__Pos = 0x5
	// Bit mask of OSC32KCTRL_ field.
	PAC_INTFLAGA_OSC32KCTRL__Msk = 0x20
	// Bit OSC32KCTRL_.
	PAC_INTFLAGA_OSC32KCTRL_ = 0x20
	// Position of SUPC_ field.
	PAC_INTFLAGA_SUPC__Pos = 0x6
	// Bit mask of SUPC_ field.
	PAC_INTFLAGA_SUPC__Msk = 0x40
	// Bit SUPC_.
	PAC_INTFLAGA_SUPC_ = 0x40
	// Position of GCLK_ field.
	PAC_INTFLAGA_GCLK__Pos = 0x7
	// Bit mask of GCLK_ field.
	PAC_INTFLAGA_GCLK__Msk = 0x80
	// Bit GCLK_.
	PAC_INTFLAGA_GCLK_ = 0x80
	// Position of WDT_ field.
	PAC_INTFLAGA_WDT__Pos = 0x8
	// Bit mask of WDT_ field.
	PAC_INTFLAGA_WDT__Msk = 0x100
	// Bit WDT_.
	PAC_INTFLAGA_WDT_ = 0x100
	// Position of RTC_ field.
	PAC_INTFLAGA_RTC__Pos = 0x9
	// Bit mask of RTC_ field.
	PAC_INTFLAGA_RTC__Msk = 0x200
	// Bit RTC_.
	PAC_INTFLAGA_RTC_ = 0x200
	// Position of EIC_ field.
	PAC_INTFLAGA_EIC__Pos = 0xa
	// Bit mask of EIC_ field.
	PAC_INTFLAGA_EIC__Msk = 0x400
	// Bit EIC_.
	PAC_INTFLAGA_EIC_ = 0x400
	// Position of FREQM_ field.
	PAC_INTFLAGA_FREQM__Pos = 0xb
	// Bit mask of FREQM_ field.
	PAC_INTFLAGA_FREQM__Msk = 0x800
	// Bit FREQM_.
	PAC_INTFLAGA_FREQM_ = 0x800
	// Position of SERCOM0_ field.
	PAC_INTFLAGA_SERCOM0__Pos = 0xc
	// Bit mask of SERCOM0_ field.
	PAC_INTFLAGA_SERCOM0__Msk = 0x1000
	// Bit SERCOM0_.
	PAC_INTFLAGA_SERCOM0_ = 0x1000
	// Position of SERCOM1_ field.
	PAC_INTFLAGA_SERCOM1__Pos = 0xd
	// Bit mask of SERCOM1_ field.
	PAC_INTFLAGA_SERCOM1__Msk = 0x2000
	// Bit SERCOM1_.
	PAC_INTFLAGA_SERCOM1_ = 0x2000
	// Position of TC0_ field.
	PAC_INTFLAGA_TC0__Pos = 0xe
	// Bit mask of TC0_ field.
	PAC_INTFLAGA_TC0__Msk = 0x4000
	// Bit TC0_.
	PAC_INTFLAGA_TC0_ = 0x4000
	// Position of TC1_ field.
	PAC_INTFLAGA_TC1__Pos = 0xf
	// Bit mask of TC1_ field.
	PAC_INTFLAGA_TC1__Msk = 0x8000
	// Bit TC1_.
	PAC_INTFLAGA_TC1_ = 0x8000

	// INTFLAGB: Peripheral interrupt flag status - Bridge B
	// Position of USB_ field.
	PAC_INTFLAGB_USB__Pos = 0x0
	// Bit mask of USB_ field.
	PAC_INTFLAGB_USB__Msk = 0x1
	// Bit USB_.
	PAC_INTFLAGB_USB_ = 0x1
	// Position of DSU_ field.
	PAC_INTFLAGB_DSU__Pos = 0x1
	// Bit mask of DSU_ field.
	PAC_INTFLAGB_DSU__Msk = 0x2
	// Bit DSU_.
	PAC_INTFLAGB_DSU_ = 0x2
	// Position of NVMCTRL_ field.
	PAC_INTFLAGB_NVMCTRL__Pos = 0x2
	// Bit mask of NVMCTRL_ field.
	PAC_INTFLAGB_NVMCTRL__Msk = 0x4
	// Bit NVMCTRL_.
	PAC_INTFLAGB_NVMCTRL_ = 0x4
	// Position of CMCC_ field.
	PAC_INTFLAGB_CMCC__Pos = 0x3
	// Bit mask of CMCC_ field.
	PAC_INTFLAGB_CMCC__Msk = 0x8
	// Bit CMCC_.
	PAC_INTFLAGB_CMCC_ = 0x8
	// Position of PORT_ field.
	PAC_INTFLAGB_PORT__Pos = 0x4
	// Bit mask of PORT_ field.
	PAC_INTFLAGB_PORT__Msk = 0x10
	// Bit PORT_.
	PAC_INTFLAGB_PORT_ = 0x10
	// Position of DMAC_ field.
	PAC_INTFLAGB_DMAC__Pos = 0x5
	// Bit mask of DMAC_ field.
	PAC_INTFLAGB_DMAC__Msk = 0x20
	// Bit DMAC_.
	PAC_INTFLAGB_DMAC_ = 0x20
	// Position of HMATRIX_ field.
	PAC_INTFLAGB_HMATRIX__Pos = 0x6
	// Bit mask of HMATRIX_ field.
	PAC_INTFLAGB_HMATRIX__Msk = 0x40
	// Bit HMATRIX_.
	PAC_INTFLAGB_HMATRIX_ = 0x40
	// Position of EVSYS_ field.
	PAC_INTFLAGB_EVSYS__Pos = 0x7
	// Bit mask of EVSYS_ field.
	PAC_INTFLAGB_EVSYS__Msk = 0x80
	// Bit EVSYS_.
	PAC_INTFLAGB_EVSYS_ = 0x80
	// Position of SERCOM2_ field.
	PAC_INTFLAGB_SERCOM2__Pos = 0x9
	// Bit mask of SERCOM2_ field.
	PAC_INTFLAGB_SERCOM2__Msk = 0x200
	// Bit SERCOM2_.
	PAC_INTFLAGB_SERCOM2_ = 0x200
	// Position of SERCOM3_ field.
	PAC_INTFLAGB_SERCOM3__Pos = 0xa
	// Bit mask of SERCOM3_ field.
	PAC_INTFLAGB_SERCOM3__Msk = 0x400
	// Bit SERCOM3_.
	PAC_INTFLAGB_SERCOM3_ = 0x400
	// Position of TCC0_ field.
	PAC_INTFLAGB_TCC0__Pos = 0xb
	// Bit mask of TCC0_ field.
	PAC_INTFLAGB_TCC0__Msk = 0x800
	// Bit TCC0_.
	PAC_INTFLAGB_TCC0_ = 0x800
	// Position of TCC1_ field.
	PAC_INTFLAGB_TCC1__Pos = 0xc
	// Bit mask of TCC1_ field.
	PAC_INTFLAGB_TCC1__Msk = 0x1000
	// Bit TCC1_.
	PAC_INTFLAGB_TCC1_ = 0x1000
	// Position of TC2_ field.
	PAC_INTFLAGB_TC2__Pos = 0xd
	// Bit mask of TC2_ field.
	PAC_INTFLAGB_TC2__Msk = 0x2000
	// Bit TC2_.
	PAC_INTFLAGB_TC2_ = 0x2000
	// Position of TC3_ field.
	PAC_INTFLAGB_TC3__Pos = 0xe
	// Bit mask of TC3_ field.
	PAC_INTFLAGB_TC3__Msk = 0x4000
	// Bit TC3_.
	PAC_INTFLAGB_TC3_ = 0x4000
	// Position of RAMECC_ field.
	PAC_INTFLAGB_RAMECC__Pos = 0x10
	// Bit mask of RAMECC_ field.
	PAC_INTFLAGB_RAMECC__Msk = 0x10000
	// Bit RAMECC_.
	PAC_INTFLAGB_RAMECC_ = 0x10000

	// INTFLAGC: Peripheral interrupt flag status - Bridge C
	// Position of GMAC_ field.
	PAC_INTFLAGC_GMAC__Pos = 0x2
	// Bit mask of GMAC_ field.
	PAC_INTFLAGC_GMAC__Msk = 0x4
	// Bit GMAC_.
	PAC_INTFLAGC_GMAC_ = 0x4
	// Position of TCC2_ field.
	PAC_INTFLAGC_TCC2__Pos = 0x3
	// Bit mask of TCC2_ field.
	PAC_INTFLAGC_TCC2__Msk = 0x8
	// Bit TCC2_.
	PAC_INTFLAGC_TCC2_ = 0x8
	// Position of TCC3_ field.
	PAC_INTFLAGC_TCC3__Pos = 0x4
	// Bit mask of TCC3_ field.
	PAC_INTFLAGC_TCC3__Msk = 0x10
	// Bit TCC3_.
	PAC_INTFLAGC_TCC3_ = 0x10
	// Position of TC4_ field.
	PAC_INTFLAGC_TC4__Pos = 0x5
	// Bit mask of TC4_ field.
	PAC_INTFLAGC_TC4__Msk = 0x20
	// Bit TC4_.
	PAC_INTFLAGC_TC4_ = 0x20
	// Position of TC5_ field.
	PAC_INTFLAGC_TC5__Pos = 0x6
	// Bit mask of TC5_ field.
	PAC_INTFLAGC_TC5__Msk = 0x40
	// Bit TC5_.
	PAC_INTFLAGC_TC5_ = 0x40
	// Position of PDEC_ field.
	PAC_INTFLAGC_PDEC__Pos = 0x7
	// Bit mask of PDEC_ field.
	PAC_INTFLAGC_PDEC__Msk = 0x80
	// Bit PDEC_.
	PAC_INTFLAGC_PDEC_ = 0x80
	// Position of AC_ field.
	PAC_INTFLAGC_AC__Pos = 0x8
	// Bit mask of AC_ field.
	PAC_INTFLAGC_AC__Msk = 0x100
	// Bit AC_.
	PAC_INTFLAGC_AC_ = 0x100
	// Position of AES_ field.
	PAC_INTFLAGC_AES__Pos = 0x9
	// Bit mask of AES_ field.
	PAC_INTFLAGC_AES__Msk = 0x200
	// Bit AES_.
	PAC_INTFLAGC_AES_ = 0x200
	// Position of TRNG_ field.
	PAC_INTFLAGC_TRNG__Pos = 0xa
	// Bit mask of TRNG_ field.
	PAC_INTFLAGC_TRNG__Msk = 0x400
	// Bit TRNG_.
	PAC_INTFLAGC_TRNG_ = 0x400
	// Position of ICM_ field.
	PAC_INTFLAGC_ICM__Pos = 0xb
	// Bit mask of ICM_ field.
	PAC_INTFLAGC_ICM__Msk = 0x800
	// Bit ICM_.
	PAC_INTFLAGC_ICM_ = 0x800
	// Position of PUKCC_ field.
	PAC_INTFLAGC_PUKCC__Pos = 0xc
	// Bit mask of PUKCC_ field.
	PAC_INTFLAGC_PUKCC__Msk = 0x1000
	// Bit PUKCC_.
	PAC_INTFLAGC_PUKCC_ = 0x1000
	// Position of QSPI_ field.
	PAC_INTFLAGC_QSPI__Pos = 0xd
	// Bit mask of QSPI_ field.
	PAC_INTFLAGC_QSPI__Msk = 0x2000
	// Bit QSPI_.
	PAC_INTFLAGC_QSPI_ = 0x2000
	// Position of CCL_ field.
	PAC_INTFLAGC_CCL__Pos = 0xe
	// Bit mask of CCL_ field.
	PAC_INTFLAGC_CCL__Msk = 0x4000
	// Bit CCL_.
	PAC_INTFLAGC_CCL_ = 0x4000

	// INTFLAGD: Peripheral interrupt flag status - Bridge D
	// Position of SERCOM4_ field.
	PAC_INTFLAGD_SERCOM4__Pos = 0x0
	// Bit mask of SERCOM4_ field.
	PAC_INTFLAGD_SERCOM4__Msk = 0x1
	// Bit SERCOM4_.
	PAC_INTFLAGD_SERCOM4_ = 0x1
	// Position of SERCOM5_ field.
	PAC_INTFLAGD_SERCOM5__Pos = 0x1
	// Bit mask of SERCOM5_ field.
	PAC_INTFLAGD_SERCOM5__Msk = 0x2
	// Bit SERCOM5_.
	PAC_INTFLAGD_SERCOM5_ = 0x2
	// Position of TCC4_ field.
	PAC_INTFLAGD_TCC4__Pos = 0x4
	// Bit mask of TCC4_ field.
	PAC_INTFLAGD_TCC4__Msk = 0x10
	// Bit TCC4_.
	PAC_INTFLAGD_TCC4_ = 0x10
	// Position of ADC0_ field.
	PAC_INTFLAGD_ADC0__Pos = 0x7
	// Bit mask of ADC0_ field.
	PAC_INTFLAGD_ADC0__Msk = 0x80
	// Bit ADC0_.
	PAC_INTFLAGD_ADC0_ = 0x80
	// Position of ADC1_ field.
	PAC_INTFLAGD_ADC1__Pos = 0x8
	// Bit mask of ADC1_ field.
	PAC_INTFLAGD_ADC1__Msk = 0x100
	// Bit ADC1_.
	PAC_INTFLAGD_ADC1_ = 0x100
	// Position of DAC_ field.
	PAC_INTFLAGD_DAC__Pos = 0x9
	// Bit mask of DAC_ field.
	PAC_INTFLAGD_DAC__Msk = 0x200
	// Bit DAC_.
	PAC_INTFLAGD_DAC_ = 0x200
	// Position of I2S_ field.
	PAC_INTFLAGD_I2S__Pos = 0xa
	// Bit mask of I2S_ field.
	PAC_INTFLAGD_I2S__Msk = 0x400
	// Bit I2S_.
	PAC_INTFLAGD_I2S_ = 0x400
	// Position of PCC_ field.
	PAC_INTFLAGD_PCC__Pos = 0xb
	// Bit mask of PCC_ field.
	PAC_INTFLAGD_PCC__Msk = 0x800
	// Bit PCC_.
	PAC_INTFLAGD_PCC_ = 0x800

	// STATUSA: Peripheral write protection status - Bridge A
	// Position of PAC_ field.
	PAC_STATUSA_PAC__Pos = 0x0
	// Bit mask of PAC_ field.
	PAC_STATUSA_PAC__Msk = 0x1
	// Bit PAC_.
	PAC_STATUSA_PAC_ = 0x1
	// Position of PM_ field.
	PAC_STATUSA_PM__Pos = 0x1
	// Bit mask of PM_ field.
	PAC_STATUSA_PM__Msk = 0x2
	// Bit PM_.
	PAC_STATUSA_PM_ = 0x2
	// Position of MCLK_ field.
	PAC_STATUSA_MCLK__Pos = 0x2
	// Bit mask of MCLK_ field.
	PAC_STATUSA_MCLK__Msk = 0x4
	// Bit MCLK_.
	PAC_STATUSA_MCLK_ = 0x4
	// Position of RSTC_ field.
	PAC_STATUSA_RSTC__Pos = 0x3
	// Bit mask of RSTC_ field.
	PAC_STATUSA_RSTC__Msk = 0x8
	// Bit RSTC_.
	PAC_STATUSA_RSTC_ = 0x8
	// Position of OSCCTRL_ field.
	PAC_STATUSA_OSCCTRL__Pos = 0x4
	// Bit mask of OSCCTRL_ field.
	PAC_STATUSA_OSCCTRL__Msk = 0x10
	// Bit OSCCTRL_.
	PAC_STATUSA_OSCCTRL_ = 0x10
	// Position of OSC32KCTRL_ field.
	PAC_STATUSA_OSC32KCTRL__Pos = 0x5
	// Bit mask of OSC32KCTRL_ field.
	PAC_STATUSA_OSC32KCTRL__Msk = 0x20
	// Bit OSC32KCTRL_.
	PAC_STATUSA_OSC32KCTRL_ = 0x20
	// Position of SUPC_ field.
	PAC_STATUSA_SUPC__Pos = 0x6
	// Bit mask of SUPC_ field.
	PAC_STATUSA_SUPC__Msk = 0x40
	// Bit SUPC_.
	PAC_STATUSA_SUPC_ = 0x40
	// Position of GCLK_ field.
	PAC_STATUSA_GCLK__Pos = 0x7
	// Bit mask of GCLK_ field.
	PAC_STATUSA_GCLK__Msk = 0x80
	// Bit GCLK_.
	PAC_STATUSA_GCLK_ = 0x80
	// Position of WDT_ field.
	PAC_STATUSA_WDT__Pos = 0x8
	// Bit mask of WDT_ field.
	PAC_STATUSA_WDT__Msk = 0x100
	// Bit WDT_.
	PAC_STATUSA_WDT_ = 0x100
	// Position of RTC_ field.
	PAC_STATUSA_RTC__Pos = 0x9
	// Bit mask of RTC_ field.
	PAC_STATUSA_RTC__Msk = 0x200
	// Bit RTC_.
	PAC_STATUSA_RTC_ = 0x200
	// Position of EIC_ field.
	PAC_STATUSA_EIC__Pos = 0xa
	// Bit mask of EIC_ field.
	PAC_STATUSA_EIC__Msk = 0x400
	// Bit EIC_.
	PAC_STATUSA_EIC_ = 0x400
	// Position of FREQM_ field.
	PAC_STATUSA_FREQM__Pos = 0xb
	// Bit mask of FREQM_ field.
	PAC_STATUSA_FREQM__Msk = 0x800
	// Bit FREQM_.
	PAC_STATUSA_FREQM_ = 0x800
	// Position of SERCOM0_ field.
	PAC_STATUSA_SERCOM0__Pos = 0xc
	// Bit mask of SERCOM0_ field.
	PAC_STATUSA_SERCOM0__Msk = 0x1000
	// Bit SERCOM0_.
	PAC_STATUSA_SERCOM0_ = 0x1000
	// Position of SERCOM1_ field.
	PAC_STATUSA_SERCOM1__Pos = 0xd
	// Bit mask of SERCOM1_ field.
	PAC_STATUSA_SERCOM1__Msk = 0x2000
	// Bit SERCOM1_.
	PAC_STATUSA_SERCOM1_ = 0x2000
	// Position of TC0_ field.
	PAC_STATUSA_TC0__Pos = 0xe
	// Bit mask of TC0_ field.
	PAC_STATUSA_TC0__Msk = 0x4000
	// Bit TC0_.
	PAC_STATUSA_TC0_ = 0x4000
	// Position of TC1_ field.
	PAC_STATUSA_TC1__Pos = 0xf
	// Bit mask of TC1_ field.
	PAC_STATUSA_TC1__Msk = 0x8000
	// Bit TC1_.
	PAC_STATUSA_TC1_ = 0x8000

	// STATUSB: Peripheral write protection status - Bridge B
	// Position of USB_ field.
	PAC_STATUSB_USB__Pos = 0x0
	// Bit mask of USB_ field.
	PAC_STATUSB_USB__Msk = 0x1
	// Bit USB_.
	PAC_STATUSB_USB_ = 0x1
	// Position of DSU_ field.
	PAC_STATUSB_DSU__Pos = 0x1
	// Bit mask of DSU_ field.
	PAC_STATUSB_DSU__Msk = 0x2
	// Bit DSU_.
	PAC_STATUSB_DSU_ = 0x2
	// Position of NVMCTRL_ field.
	PAC_STATUSB_NVMCTRL__Pos = 0x2
	// Bit mask of NVMCTRL_ field.
	PAC_STATUSB_NVMCTRL__Msk = 0x4
	// Bit NVMCTRL_.
	PAC_STATUSB_NVMCTRL_ = 0x4
	// Position of CMCC_ field.
	PAC_STATUSB_CMCC__Pos = 0x3
	// Bit mask of CMCC_ field.
	PAC_STATUSB_CMCC__Msk = 0x8
	// Bit CMCC_.
	PAC_STATUSB_CMCC_ = 0x8
	// Position of PORT_ field.
	PAC_STATUSB_PORT__Pos = 0x4
	// Bit mask of PORT_ field.
	PAC_STATUSB_PORT__Msk = 0x10
	// Bit PORT_.
	PAC_STATUSB_PORT_ = 0x10
	// Position of DMAC_ field.
	PAC_STATUSB_DMAC__Pos = 0x5
	// Bit mask of DMAC_ field.
	PAC_STATUSB_DMAC__Msk = 0x20
	// Bit DMAC_.
	PAC_STATUSB_DMAC_ = 0x20
	// Position of HMATRIX_ field.
	PAC_STATUSB_HMATRIX__Pos = 0x6
	// Bit mask of HMATRIX_ field.
	PAC_STATUSB_HMATRIX__Msk = 0x40
	// Bit HMATRIX_.
	PAC_STATUSB_HMATRIX_ = 0x40
	// Position of EVSYS_ field.
	PAC_STATUSB_EVSYS__Pos = 0x7
	// Bit mask of EVSYS_ field.
	PAC_STATUSB_EVSYS__Msk = 0x80
	// Bit EVSYS_.
	PAC_STATUSB_EVSYS_ = 0x80
	// Position of SERCOM2_ field.
	PAC_STATUSB_SERCOM2__Pos = 0x9
	// Bit mask of SERCOM2_ field.
	PAC_STATUSB_SERCOM2__Msk = 0x200
	// Bit SERCOM2_.
	PAC_STATUSB_SERCOM2_ = 0x200
	// Position of SERCOM3_ field.
	PAC_STATUSB_SERCOM3__Pos = 0xa
	// Bit mask of SERCOM3_ field.
	PAC_STATUSB_SERCOM3__Msk = 0x400
	// Bit SERCOM3_.
	PAC_STATUSB_SERCOM3_ = 0x400
	// Position of TCC0_ field.
	PAC_STATUSB_TCC0__Pos = 0xb
	// Bit mask of TCC0_ field.
	PAC_STATUSB_TCC0__Msk = 0x800
	// Bit TCC0_.
	PAC_STATUSB_TCC0_ = 0x800
	// Position of TCC1_ field.
	PAC_STATUSB_TCC1__Pos = 0xc
	// Bit mask of TCC1_ field.
	PAC_STATUSB_TCC1__Msk = 0x1000
	// Bit TCC1_.
	PAC_STATUSB_TCC1_ = 0x1000
	// Position of TC2_ field.
	PAC_STATUSB_TC2__Pos = 0xd
	// Bit mask of TC2_ field.
	PAC_STATUSB_TC2__Msk = 0x2000
	// Bit TC2_.
	PAC_STATUSB_TC2_ = 0x2000
	// Position of TC3_ field.
	PAC_STATUSB_TC3__Pos = 0xe
	// Bit mask of TC3_ field.
	PAC_STATUSB_TC3__Msk = 0x4000
	// Bit TC3_.
	PAC_STATUSB_TC3_ = 0x4000
	// Position of RAMECC_ field.
	PAC_STATUSB_RAMECC__Pos = 0x10
	// Bit mask of RAMECC_ field.
	PAC_STATUSB_RAMECC__Msk = 0x10000
	// Bit RAMECC_.
	PAC_STATUSB_RAMECC_ = 0x10000

	// STATUSC: Peripheral write protection status - Bridge C
	// Position of GMAC_ field.
	PAC_STATUSC_GMAC__Pos = 0x2
	// Bit mask of GMAC_ field.
	PAC_STATUSC_GMAC__Msk = 0x4
	// Bit GMAC_.
	PAC_STATUSC_GMAC_ = 0x4
	// Position of TCC2_ field.
	PAC_STATUSC_TCC2__Pos = 0x3
	// Bit mask of TCC2_ field.
	PAC_STATUSC_TCC2__Msk = 0x8
	// Bit TCC2_.
	PAC_STATUSC_TCC2_ = 0x8
	// Position of TCC3_ field.
	PAC_STATUSC_TCC3__Pos = 0x4
	// Bit mask of TCC3_ field.
	PAC_STATUSC_TCC3__Msk = 0x10
	// Bit TCC3_.
	PAC_STATUSC_TCC3_ = 0x10
	// Position of TC4_ field.
	PAC_STATUSC_TC4__Pos = 0x5
	// Bit mask of TC4_ field.
	PAC_STATUSC_TC4__Msk = 0x20
	// Bit TC4_.
	PAC_STATUSC_TC4_ = 0x20
	// Position of TC5_ field.
	PAC_STATUSC_TC5__Pos = 0x6
	// Bit mask of TC5_ field.
	PAC_STATUSC_TC5__Msk = 0x40
	// Bit TC5_.
	PAC_STATUSC_TC5_ = 0x40
	// Position of PDEC_ field.
	PAC_STATUSC_PDEC__Pos = 0x7
	// Bit mask of PDEC_ field.
	PAC_STATUSC_PDEC__Msk = 0x80
	// Bit PDEC_.
	PAC_STATUSC_PDEC_ = 0x80
	// Position of AC_ field.
	PAC_STATUSC_AC__Pos = 0x8
	// Bit mask of AC_ field.
	PAC_STATUSC_AC__Msk = 0x100
	// Bit AC_.
	PAC_STATUSC_AC_ = 0x100
	// Position of AES_ field.
	PAC_STATUSC_AES__Pos = 0x9
	// Bit mask of AES_ field.
	PAC_STATUSC_AES__Msk = 0x200
	// Bit AES_.
	PAC_STATUSC_AES_ = 0x200
	// Position of TRNG_ field.
	PAC_STATUSC_TRNG__Pos = 0xa
	// Bit mask of TRNG_ field.
	PAC_STATUSC_TRNG__Msk = 0x400
	// Bit TRNG_.
	PAC_STATUSC_TRNG_ = 0x400
	// Position of ICM_ field.
	PAC_STATUSC_ICM__Pos = 0xb
	// Bit mask of ICM_ field.
	PAC_STATUSC_ICM__Msk = 0x800
	// Bit ICM_.
	PAC_STATUSC_ICM_ = 0x800
	// Position of PUKCC_ field.
	PAC_STATUSC_PUKCC__Pos = 0xc
	// Bit mask of PUKCC_ field.
	PAC_STATUSC_PUKCC__Msk = 0x1000
	// Bit PUKCC_.
	PAC_STATUSC_PUKCC_ = 0x1000
	// Position of QSPI_ field.
	PAC_STATUSC_QSPI__Pos = 0xd
	// Bit mask of QSPI_ field.
	PAC_STATUSC_QSPI__Msk = 0x2000
	// Bit QSPI_.
	PAC_STATUSC_QSPI_ = 0x2000
	// Position of CCL_ field.
	PAC_STATUSC_CCL__Pos = 0xe
	// Bit mask of CCL_ field.
	PAC_STATUSC_CCL__Msk = 0x4000
	// Bit CCL_.
	PAC_STATUSC_CCL_ = 0x4000

	// STATUSD: Peripheral write protection status - Bridge D
	// Position of SERCOM4_ field.
	PAC_STATUSD_SERCOM4__Pos = 0x0
	// Bit mask of SERCOM4_ field.
	PAC_STATUSD_SERCOM4__Msk = 0x1
	// Bit SERCOM4_.
	PAC_STATUSD_SERCOM4_ = 0x1
	// Position of SERCOM5_ field.
	PAC_STATUSD_SERCOM5__Pos = 0x1
	// Bit mask of SERCOM5_ field.
	PAC_STATUSD_SERCOM5__Msk = 0x2
	// Bit SERCOM5_.
	PAC_STATUSD_SERCOM5_ = 0x2
	// Position of TCC4_ field.
	PAC_STATUSD_TCC4__Pos = 0x4
	// Bit mask of TCC4_ field.
	PAC_STATUSD_TCC4__Msk = 0x10
	// Bit TCC4_.
	PAC_STATUSD_TCC4_ = 0x10
	// Position of ADC0_ field.
	PAC_STATUSD_ADC0__Pos = 0x7
	// Bit mask of ADC0_ field.
	PAC_STATUSD_ADC0__Msk = 0x80
	// Bit ADC0_.
	PAC_STATUSD_ADC0_ = 0x80
	// Position of ADC1_ field.
	PAC_STATUSD_ADC1__Pos = 0x8
	// Bit mask of ADC1_ field.
	PAC_STATUSD_ADC1__Msk = 0x100
	// Bit ADC1_.
	PAC_STATUSD_ADC1_ = 0x100
	// Position of DAC_ field.
	PAC_STATUSD_DAC__Pos = 0x9
	// Bit mask of DAC_ field.
	PAC_STATUSD_DAC__Msk = 0x200
	// Bit DAC_.
	PAC_STATUSD_DAC_ = 0x200
	// Position of I2S_ field.
	PAC_STATUSD_I2S__Pos = 0xa
	// Bit mask of I2S_ field.
	PAC_STATUSD_I2S__Msk = 0x400
	// Bit I2S_.
	PAC_STATUSD_I2S_ = 0x400
	// Position of PCC_ field.
	PAC_STATUSD_PCC__Pos = 0xb
	// Bit mask of PCC_ field.
	PAC_STATUSD_PCC__Msk = 0x800
	// Bit PCC_.
	PAC_STATUSD_PCC_ = 0x800
)

// Constants for PCC: Parallel Capture Controller
const (
	// MR: Mode Register
	// Position of PCEN field.
	PCC_MR_PCEN_Pos = 0x0
	// Bit mask of PCEN field.
	PCC_MR_PCEN_Msk = 0x1
	// Bit PCEN.
	PCC_MR_PCEN = 0x1
	// Position of DSIZE field.
	PCC_MR_DSIZE_Pos = 0x4
	// Bit mask of DSIZE field.
	PCC_MR_DSIZE_Msk = 0x30
	// Position of SCALE field.
	PCC_MR_SCALE_Pos = 0x8
	// Bit mask of SCALE field.
	PCC_MR_SCALE_Msk = 0x100
	// Bit SCALE.
	PCC_MR_SCALE = 0x100
	// Position of ALWYS field.
	PCC_MR_ALWYS_Pos = 0x9
	// Bit mask of ALWYS field.
	PCC_MR_ALWYS_Msk = 0x200
	// Bit ALWYS.
	PCC_MR_ALWYS = 0x200
	// Position of HALFS field.
	PCC_MR_HALFS_Pos = 0xa
	// Bit mask of HALFS field.
	PCC_MR_HALFS_Msk = 0x400
	// Bit HALFS.
	PCC_MR_HALFS = 0x400
	// Position of FRSTS field.
	PCC_MR_FRSTS_Pos = 0xb
	// Bit mask of FRSTS field.
	PCC_MR_FRSTS_Msk = 0x800
	// Bit FRSTS.
	PCC_MR_FRSTS = 0x800
	// Position of ISIZE field.
	PCC_MR_ISIZE_Pos = 0x10
	// Bit mask of ISIZE field.
	PCC_MR_ISIZE_Msk = 0x70000
	// Position of CID field.
	PCC_MR_CID_Pos = 0x1e
	// Bit mask of CID field.
	PCC_MR_CID_Msk = 0xc0000000

	// IER: Interrupt Enable Register
	// Position of DRDY field.
	PCC_IER_DRDY_Pos = 0x0
	// Bit mask of DRDY field.
	PCC_IER_DRDY_Msk = 0x1
	// Bit DRDY.
	PCC_IER_DRDY = 0x1
	// Position of OVRE field.
	PCC_IER_OVRE_Pos = 0x1
	// Bit mask of OVRE field.
	PCC_IER_OVRE_Msk = 0x2
	// Bit OVRE.
	PCC_IER_OVRE = 0x2

	// IDR: Interrupt Disable Register
	// Position of DRDY field.
	PCC_IDR_DRDY_Pos = 0x0
	// Bit mask of DRDY field.
	PCC_IDR_DRDY_Msk = 0x1
	// Bit DRDY.
	PCC_IDR_DRDY = 0x1
	// Position of OVRE field.
	PCC_IDR_OVRE_Pos = 0x1
	// Bit mask of OVRE field.
	PCC_IDR_OVRE_Msk = 0x2
	// Bit OVRE.
	PCC_IDR_OVRE = 0x2

	// IMR: Interrupt Mask Register
	// Position of DRDY field.
	PCC_IMR_DRDY_Pos = 0x0
	// Bit mask of DRDY field.
	PCC_IMR_DRDY_Msk = 0x1
	// Bit DRDY.
	PCC_IMR_DRDY = 0x1
	// Position of OVRE field.
	PCC_IMR_OVRE_Pos = 0x1
	// Bit mask of OVRE field.
	PCC_IMR_OVRE_Msk = 0x2
	// Bit OVRE.
	PCC_IMR_OVRE = 0x2

	// ISR: Interrupt Status Register
	// Position of DRDY field.
	PCC_ISR_DRDY_Pos = 0x0
	// Bit mask of DRDY field.
	PCC_ISR_DRDY_Msk = 0x1
	// Bit DRDY.
	PCC_ISR_DRDY = 0x1
	// Position of OVRE field.
	PCC_ISR_OVRE_Pos = 0x1
	// Bit mask of OVRE field.
	PCC_ISR_OVRE_Msk = 0x2
	// Bit OVRE.
	PCC_ISR_OVRE = 0x2

	// RHR: Reception Holding Register
	// Position of RDATA field.
	PCC_RHR_RDATA_Pos = 0x0
	// Bit mask of RDATA field.
	PCC_RHR_RDATA_Msk = 0xffffffff

	// WPMR: Write Protection Mode Register
	// Position of WPEN field.
	PCC_WPMR_WPEN_Pos = 0x0
	// Bit mask of WPEN field.
	PCC_WPMR_WPEN_Msk = 0x1
	// Bit WPEN.
	PCC_WPMR_WPEN = 0x1
	// Position of WPKEY field.
	PCC_WPMR_WPKEY_Pos = 0x8
	// Bit mask of WPKEY field.
	PCC_WPMR_WPKEY_Msk = 0xffffff00

	// WPSR: Write Protection Status Register
	// Position of WPVS field.
	PCC_WPSR_WPVS_Pos = 0x0
	// Bit mask of WPVS field.
	PCC_WPSR_WPVS_Msk = 0x1
	// Bit WPVS.
	PCC_WPSR_WPVS = 0x1
	// Position of WPVSRC field.
	PCC_WPSR_WPVSRC_Pos = 0x8
	// Bit mask of WPVSRC field.
	PCC_WPSR_WPVSRC_Msk = 0xffff00
)

// Constants for PDEC: Quadrature Decodeur
const (
	// CTRLA: Control A
	// Position of SWRST field.
	PDEC_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	PDEC_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	PDEC_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	PDEC_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	PDEC_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	PDEC_CTRLA_ENABLE = 0x2
	// Position of MODE field.
	PDEC_CTRLA_MODE_Pos = 0x2
	// Bit mask of MODE field.
	PDEC_CTRLA_MODE_Msk = 0xc
	// QDEC operating mode
	PDEC_CTRLA_MODE_QDEC = 0x0
	// HALL operating mode
	PDEC_CTRLA_MODE_HALL = 0x1
	// COUNTER operating mode
	PDEC_CTRLA_MODE_COUNTER = 0x2
	// Position of RUNSTDBY field.
	PDEC_CTRLA_RUNSTDBY_Pos = 0x6
	// Bit mask of RUNSTDBY field.
	PDEC_CTRLA_RUNSTDBY_Msk = 0x40
	// Bit RUNSTDBY.
	PDEC_CTRLA_RUNSTDBY = 0x40
	// Position of CONF field.
	PDEC_CTRLA_CONF_Pos = 0x8
	// Bit mask of CONF field.
	PDEC_CTRLA_CONF_Msk = 0x700
	// Quadrature decoder direction
	PDEC_CTRLA_CONF_X4 = 0x0
	// Secure Quadrature decoder direction
	PDEC_CTRLA_CONF_X4S = 0x1
	// Decoder direction
	PDEC_CTRLA_CONF_X2 = 0x2
	// Secure decoder direction
	PDEC_CTRLA_CONF_X2S = 0x3
	// Auto correction mode
	PDEC_CTRLA_CONF_AUTOC = 0x4
	// Position of ALOCK field.
	PDEC_CTRLA_ALOCK_Pos = 0xb
	// Bit mask of ALOCK field.
	PDEC_CTRLA_ALOCK_Msk = 0x800
	// Bit ALOCK.
	PDEC_CTRLA_ALOCK = 0x800
	// Position of SWAP field.
	PDEC_CTRLA_SWAP_Pos = 0xe
	// Bit mask of SWAP field.
	PDEC_CTRLA_SWAP_Msk = 0x4000
	// Bit SWAP.
	PDEC_CTRLA_SWAP = 0x4000
	// Position of PEREN field.
	PDEC_CTRLA_PEREN_Pos = 0xf
	// Bit mask of PEREN field.
	PDEC_CTRLA_PEREN_Msk = 0x8000
	// Bit PEREN.
	PDEC_CTRLA_PEREN = 0x8000
	// Position of PINEN0 field.
	PDEC_CTRLA_PINEN0_Pos = 0x10
	// Bit mask of PINEN0 field.
	PDEC_CTRLA_PINEN0_Msk = 0x10000
	// Bit PINEN0.
	PDEC_CTRLA_PINEN0 = 0x10000
	// Position of PINEN1 field.
	PDEC_CTRLA_PINEN1_Pos = 0x11
	// Bit mask of PINEN1 field.
	PDEC_CTRLA_PINEN1_Msk = 0x20000
	// Bit PINEN1.
	PDEC_CTRLA_PINEN1 = 0x20000
	// Position of PINEN2 field.
	PDEC_CTRLA_PINEN2_Pos = 0x12
	// Bit mask of PINEN2 field.
	PDEC_CTRLA_PINEN2_Msk = 0x40000
	// Bit PINEN2.
	PDEC_CTRLA_PINEN2 = 0x40000
	// Position of PINVEN0 field.
	PDEC_CTRLA_PINVEN0_Pos = 0x14
	// Bit mask of PINVEN0 field.
	PDEC_CTRLA_PINVEN0_Msk = 0x100000
	// Bit PINVEN0.
	PDEC_CTRLA_PINVEN0 = 0x100000
	// Position of PINVEN1 field.
	PDEC_CTRLA_PINVEN1_Pos = 0x15
	// Bit mask of PINVEN1 field.
	PDEC_CTRLA_PINVEN1_Msk = 0x200000
	// Bit PINVEN1.
	PDEC_CTRLA_PINVEN1 = 0x200000
	// Position of PINVEN2 field.
	PDEC_CTRLA_PINVEN2_Pos = 0x16
	// Bit mask of PINVEN2 field.
	PDEC_CTRLA_PINVEN2_Msk = 0x400000
	// Bit PINVEN2.
	PDEC_CTRLA_PINVEN2 = 0x400000
	// Position of ANGULAR field.
	PDEC_CTRLA_ANGULAR_Pos = 0x18
	// Bit mask of ANGULAR field.
	PDEC_CTRLA_ANGULAR_Msk = 0x7000000
	// Position of MAXCMP field.
	PDEC_CTRLA_MAXCMP_Pos = 0x1c
	// Bit mask of MAXCMP field.
	PDEC_CTRLA_MAXCMP_Msk = 0xf0000000

	// CTRLBCLR: Control B Clear
	// Position of LUPD field.
	PDEC_CTRLBCLR_LUPD_Pos = 0x1
	// Bit mask of LUPD field.
	PDEC_CTRLBCLR_LUPD_Msk = 0x2
	// Bit LUPD.
	PDEC_CTRLBCLR_LUPD = 0x2
	// Position of CMD field.
	PDEC_CTRLBCLR_CMD_Pos = 0x5
	// Bit mask of CMD field.
	PDEC_CTRLBCLR_CMD_Msk = 0xe0
	// No action
	PDEC_CTRLBCLR_CMD_NONE = 0x0
	// Force a counter restart or retrigger
	PDEC_CTRLBCLR_CMD_RETRIGGER = 0x1
	// Force update of double buffered registers
	PDEC_CTRLBCLR_CMD_UPDATE = 0x2
	// Force a read synchronization of COUNT
	PDEC_CTRLBCLR_CMD_READSYNC = 0x3
	// Start QDEC/HALL
	PDEC_CTRLBCLR_CMD_START = 0x4
	// Stop QDEC/HALL
	PDEC_CTRLBCLR_CMD_STOP = 0x5

	// CTRLBSET: Control B Set
	// Position of LUPD field.
	PDEC_CTRLBSET_LUPD_Pos = 0x1
	// Bit mask of LUPD field.
	PDEC_CTRLBSET_LUPD_Msk = 0x2
	// Bit LUPD.
	PDEC_CTRLBSET_LUPD = 0x2
	// Position of CMD field.
	PDEC_CTRLBSET_CMD_Pos = 0x5
	// Bit mask of CMD field.
	PDEC_CTRLBSET_CMD_Msk = 0xe0
	// No action
	PDEC_CTRLBSET_CMD_NONE = 0x0
	// Force a counter restart or retrigger
	PDEC_CTRLBSET_CMD_RETRIGGER = 0x1
	// Force update of double buffered registers
	PDEC_CTRLBSET_CMD_UPDATE = 0x2
	// Force a read synchronization of COUNT
	PDEC_CTRLBSET_CMD_READSYNC = 0x3
	// Start QDEC/HALL
	PDEC_CTRLBSET_CMD_START = 0x4
	// Stop QDEC/HALL
	PDEC_CTRLBSET_CMD_STOP = 0x5

	// EVCTRL: Event Control
	// Position of EVACT field.
	PDEC_EVCTRL_EVACT_Pos = 0x0
	// Bit mask of EVACT field.
	PDEC_EVCTRL_EVACT_Msk = 0x3
	// Event action disabled
	PDEC_EVCTRL_EVACT_OFF = 0x0
	// Start, restart or retrigger on event
	PDEC_EVCTRL_EVACT_RETRIGGER = 0x1
	// Count on event
	PDEC_EVCTRL_EVACT_COUNT = 0x2
	// Position of EVINV field.
	PDEC_EVCTRL_EVINV_Pos = 0x2
	// Bit mask of EVINV field.
	PDEC_EVCTRL_EVINV_Msk = 0x1c
	// Position of EVEI field.
	PDEC_EVCTRL_EVEI_Pos = 0x5
	// Bit mask of EVEI field.
	PDEC_EVCTRL_EVEI_Msk = 0xe0
	// Position of OVFEO field.
	PDEC_EVCTRL_OVFEO_Pos = 0x8
	// Bit mask of OVFEO field.
	PDEC_EVCTRL_OVFEO_Msk = 0x100
	// Bit OVFEO.
	PDEC_EVCTRL_OVFEO = 0x100
	// Position of ERREO field.
	PDEC_EVCTRL_ERREO_Pos = 0x9
	// Bit mask of ERREO field.
	PDEC_EVCTRL_ERREO_Msk = 0x200
	// Bit ERREO.
	PDEC_EVCTRL_ERREO = 0x200
	// Position of DIREO field.
	PDEC_EVCTRL_DIREO_Pos = 0xa
	// Bit mask of DIREO field.
	PDEC_EVCTRL_DIREO_Msk = 0x400
	// Bit DIREO.
	PDEC_EVCTRL_DIREO = 0x400
	// Position of VLCEO field.
	PDEC_EVCTRL_VLCEO_Pos = 0xb
	// Bit mask of VLCEO field.
	PDEC_EVCTRL_VLCEO_Msk = 0x800
	// Bit VLCEO.
	PDEC_EVCTRL_VLCEO = 0x800
	// Position of MCEO0 field.
	PDEC_EVCTRL_MCEO0_Pos = 0xc
	// Bit mask of MCEO0 field.
	PDEC_EVCTRL_MCEO0_Msk = 0x1000
	// Bit MCEO0.
	PDEC_EVCTRL_MCEO0 = 0x1000
	// Position of MCEO1 field.
	PDEC_EVCTRL_MCEO1_Pos = 0xd
	// Bit mask of MCEO1 field.
	PDEC_EVCTRL_MCEO1_Msk = 0x2000
	// Bit MCEO1.
	PDEC_EVCTRL_MCEO1 = 0x2000

	// INTENCLR: Interrupt Enable Clear
	// Position of OVF field.
	PDEC_INTENCLR_OVF_Pos = 0x0
	// Bit mask of OVF field.
	PDEC_INTENCLR_OVF_Msk = 0x1
	// Bit OVF.
	PDEC_INTENCLR_OVF = 0x1
	// Position of ERR field.
	PDEC_INTENCLR_ERR_Pos = 0x1
	// Bit mask of ERR field.
	PDEC_INTENCLR_ERR_Msk = 0x2
	// Bit ERR.
	PDEC_INTENCLR_ERR = 0x2
	// Position of DIR field.
	PDEC_INTENCLR_DIR_Pos = 0x2
	// Bit mask of DIR field.
	PDEC_INTENCLR_DIR_Msk = 0x4
	// Bit DIR.
	PDEC_INTENCLR_DIR = 0x4
	// Position of VLC field.
	PDEC_INTENCLR_VLC_Pos = 0x3
	// Bit mask of VLC field.
	PDEC_INTENCLR_VLC_Msk = 0x8
	// Bit VLC.
	PDEC_INTENCLR_VLC = 0x8
	// Position of MC0 field.
	PDEC_INTENCLR_MC0_Pos = 0x4
	// Bit mask of MC0 field.
	PDEC_INTENCLR_MC0_Msk = 0x10
	// Bit MC0.
	PDEC_INTENCLR_MC0 = 0x10
	// Position of MC1 field.
	PDEC_INTENCLR_MC1_Pos = 0x5
	// Bit mask of MC1 field.
	PDEC_INTENCLR_MC1_Msk = 0x20
	// Bit MC1.
	PDEC_INTENCLR_MC1 = 0x20

	// INTENSET: Interrupt Enable Set
	// Position of OVF field.
	PDEC_INTENSET_OVF_Pos = 0x0
	// Bit mask of OVF field.
	PDEC_INTENSET_OVF_Msk = 0x1
	// Bit OVF.
	PDEC_INTENSET_OVF = 0x1
	// Position of ERR field.
	PDEC_INTENSET_ERR_Pos = 0x1
	// Bit mask of ERR field.
	PDEC_INTENSET_ERR_Msk = 0x2
	// Bit ERR.
	PDEC_INTENSET_ERR = 0x2
	// Position of DIR field.
	PDEC_INTENSET_DIR_Pos = 0x2
	// Bit mask of DIR field.
	PDEC_INTENSET_DIR_Msk = 0x4
	// Bit DIR.
	PDEC_INTENSET_DIR = 0x4
	// Position of VLC field.
	PDEC_INTENSET_VLC_Pos = 0x3
	// Bit mask of VLC field.
	PDEC_INTENSET_VLC_Msk = 0x8
	// Bit VLC.
	PDEC_INTENSET_VLC = 0x8
	// Position of MC0 field.
	PDEC_INTENSET_MC0_Pos = 0x4
	// Bit mask of MC0 field.
	PDEC_INTENSET_MC0_Msk = 0x10
	// Bit MC0.
	PDEC_INTENSET_MC0 = 0x10
	// Position of MC1 field.
	PDEC_INTENSET_MC1_Pos = 0x5
	// Bit mask of MC1 field.
	PDEC_INTENSET_MC1_Msk = 0x20
	// Bit MC1.
	PDEC_INTENSET_MC1 = 0x20

	// INTFLAG: Interrupt Flag Status and Clear
	// Position of OVF field.
	PDEC_INTFLAG_OVF_Pos = 0x0
	// Bit mask of OVF field.
	PDEC_INTFLAG_OVF_Msk = 0x1
	// Bit OVF.
	PDEC_INTFLAG_OVF = 0x1
	// Position of ERR field.
	PDEC_INTFLAG_ERR_Pos = 0x1
	// Bit mask of ERR field.
	PDEC_INTFLAG_ERR_Msk = 0x2
	// Bit ERR.
	PDEC_INTFLAG_ERR = 0x2
	// Position of DIR field.
	PDEC_INTFLAG_DIR_Pos = 0x2
	// Bit mask of DIR field.
	PDEC_INTFLAG_DIR_Msk = 0x4
	// Bit DIR.
	PDEC_INTFLAG_DIR = 0x4
	// Position of VLC field.
	PDEC_INTFLAG_VLC_Pos = 0x3
	// Bit mask of VLC field.
	PDEC_INTFLAG_VLC_Msk = 0x8
	// Bit VLC.
	PDEC_INTFLAG_VLC = 0x8
	// Position of MC0 field.
	PDEC_INTFLAG_MC0_Pos = 0x4
	// Bit mask of MC0 field.
	PDEC_INTFLAG_MC0_Msk = 0x10
	// Bit MC0.
	PDEC_INTFLAG_MC0 = 0x10
	// Position of MC1 field.
	PDEC_INTFLAG_MC1_Pos = 0x5
	// Bit mask of MC1 field.
	PDEC_INTFLAG_MC1_Msk = 0x20
	// Bit MC1.
	PDEC_INTFLAG_MC1 = 0x20

	// STATUS: Status
	// Position of QERR field.
	PDEC_STATUS_QERR_Pos = 0x0
	// Bit mask of QERR field.
	PDEC_STATUS_QERR_Msk = 0x1
	// Bit QERR.
	PDEC_STATUS_QERR = 0x1
	// Position of IDXERR field.
	PDEC_STATUS_IDXERR_Pos = 0x1
	// Bit mask of IDXERR field.
	PDEC_STATUS_IDXERR_Msk = 0x2
	// Bit IDXERR.
	PDEC_STATUS_IDXERR = 0x2
	// Position of MPERR field.
	PDEC_STATUS_MPERR_Pos = 0x2
	// Bit mask of MPERR field.
	PDEC_STATUS_MPERR_Msk = 0x4
	// Bit MPERR.
	PDEC_STATUS_MPERR = 0x4
	// Position of WINERR field.
	PDEC_STATUS_WINERR_Pos = 0x4
	// Bit mask of WINERR field.
	PDEC_STATUS_WINERR_Msk = 0x10
	// Bit WINERR.
	PDEC_STATUS_WINERR = 0x10
	// Position of HERR field.
	PDEC_STATUS_HERR_Pos = 0x5
	// Bit mask of HERR field.
	PDEC_STATUS_HERR_Msk = 0x20
	// Bit HERR.
	PDEC_STATUS_HERR = 0x20
	// Position of STOP field.
	PDEC_STATUS_STOP_Pos = 0x6
	// Bit mask of STOP field.
	PDEC_STATUS_STOP_Msk = 0x40
	// Bit STOP.
	PDEC_STATUS_STOP = 0x40
	// Position of DIR field.
	PDEC_STATUS_DIR_Pos = 0x7
	// Bit mask of DIR field.
	PDEC_STATUS_DIR_Msk = 0x80
	// Bit DIR.
	PDEC_STATUS_DIR = 0x80
	// Position of PRESCBUFV field.
	PDEC_STATUS_PRESCBUFV_Pos = 0x8
	// Bit mask of PRESCBUFV field.
	PDEC_STATUS_PRESCBUFV_Msk = 0x100
	// Bit PRESCBUFV.
	PDEC_STATUS_PRESCBUFV = 0x100
	// Position of FILTERBUFV field.
	PDEC_STATUS_FILTERBUFV_Pos = 0x9
	// Bit mask of FILTERBUFV field.
	PDEC_STATUS_FILTERBUFV_Msk = 0x200
	// Bit FILTERBUFV.
	PDEC_STATUS_FILTERBUFV = 0x200
	// Position of CCBUFV0 field.
	PDEC_STATUS_CCBUFV0_Pos = 0xc
	// Bit mask of CCBUFV0 field.
	PDEC_STATUS_CCBUFV0_Msk = 0x1000
	// Bit CCBUFV0.
	PDEC_STATUS_CCBUFV0 = 0x1000
	// Position of CCBUFV1 field.
	PDEC_STATUS_CCBUFV1_Pos = 0xd
	// Bit mask of CCBUFV1 field.
	PDEC_STATUS_CCBUFV1_Msk = 0x2000
	// Bit CCBUFV1.
	PDEC_STATUS_CCBUFV1 = 0x2000

	// DBGCTRL: Debug Control
	// Position of DBGRUN field.
	PDEC_DBGCTRL_DBGRUN_Pos = 0x0
	// Bit mask of DBGRUN field.
	PDEC_DBGCTRL_DBGRUN_Msk = 0x1
	// Bit DBGRUN.
	PDEC_DBGCTRL_DBGRUN = 0x1

	// SYNCBUSY: Synchronization Status
	// Position of SWRST field.
	PDEC_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	PDEC_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	PDEC_SYNCBUSY_SWRST = 0x1
	// Position of ENABLE field.
	PDEC_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	PDEC_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	PDEC_SYNCBUSY_ENABLE = 0x2
	// Position of CTRLB field.
	PDEC_SYNCBUSY_CTRLB_Pos = 0x2
	// Bit mask of CTRLB field.
	PDEC_SYNCBUSY_CTRLB_Msk = 0x4
	// Bit CTRLB.
	PDEC_SYNCBUSY_CTRLB = 0x4
	// Position of STATUS field.
	PDEC_SYNCBUSY_STATUS_Pos = 0x3
	// Bit mask of STATUS field.
	PDEC_SYNCBUSY_STATUS_Msk = 0x8
	// Bit STATUS.
	PDEC_SYNCBUSY_STATUS = 0x8
	// Position of PRESC field.
	PDEC_SYNCBUSY_PRESC_Pos = 0x4
	// Bit mask of PRESC field.
	PDEC_SYNCBUSY_PRESC_Msk = 0x10
	// Bit PRESC.
	PDEC_SYNCBUSY_PRESC = 0x10
	// Position of FILTER field.
	PDEC_SYNCBUSY_FILTER_Pos = 0x5
	// Bit mask of FILTER field.
	PDEC_SYNCBUSY_FILTER_Msk = 0x20
	// Bit FILTER.
	PDEC_SYNCBUSY_FILTER = 0x20
	// Position of COUNT field.
	PDEC_SYNCBUSY_COUNT_Pos = 0x6
	// Bit mask of COUNT field.
	PDEC_SYNCBUSY_COUNT_Msk = 0x40
	// Bit COUNT.
	PDEC_SYNCBUSY_COUNT = 0x40
	// Position of CC0 field.
	PDEC_SYNCBUSY_CC0_Pos = 0x7
	// Bit mask of CC0 field.
	PDEC_SYNCBUSY_CC0_Msk = 0x80
	// Bit CC0.
	PDEC_SYNCBUSY_CC0 = 0x80
	// Position of CC1 field.
	PDEC_SYNCBUSY_CC1_Pos = 0x8
	// Bit mask of CC1 field.
	PDEC_SYNCBUSY_CC1_Msk = 0x100
	// Bit CC1.
	PDEC_SYNCBUSY_CC1 = 0x100

	// PRESC: Prescaler Value
	// Position of PRESC field.
	PDEC_PRESC_PRESC_Pos = 0x0
	// Bit mask of PRESC field.
	PDEC_PRESC_PRESC_Msk = 0xf
	// No division
	PDEC_PRESC_PRESC_DIV1 = 0x0
	// Divide by 2
	PDEC_PRESC_PRESC_DIV2 = 0x1
	// Divide by 4
	PDEC_PRESC_PRESC_DIV4 = 0x2
	// Divide by 8
	PDEC_PRESC_PRESC_DIV8 = 0x3
	// Divide by 16
	PDEC_PRESC_PRESC_DIV16 = 0x4
	// Divide by 32
	PDEC_PRESC_PRESC_DIV32 = 0x5
	// Divide by 64
	PDEC_PRESC_PRESC_DIV64 = 0x6
	// Divide by 128
	PDEC_PRESC_PRESC_DIV128 = 0x7
	// Divide by 256
	PDEC_PRESC_PRESC_DIV256 = 0x8
	// Divide by 512
	PDEC_PRESC_PRESC_DIV512 = 0x9
	// Divide by 1024
	PDEC_PRESC_PRESC_DIV1024 = 0xa

	// FILTER: Filter Value
	// Position of FILTER field.
	PDEC_FILTER_FILTER_Pos = 0x0
	// Bit mask of FILTER field.
	PDEC_FILTER_FILTER_Msk = 0xff

	// PRESCBUF: Prescaler Buffer Value
	// Position of PRESCBUF field.
	PDEC_PRESCBUF_PRESCBUF_Pos = 0x0
	// Bit mask of PRESCBUF field.
	PDEC_PRESCBUF_PRESCBUF_Msk = 0xf
	// No division
	PDEC_PRESCBUF_PRESCBUF_DIV1 = 0x0
	// Divide by 2
	PDEC_PRESCBUF_PRESCBUF_DIV2 = 0x1
	// Divide by 4
	PDEC_PRESCBUF_PRESCBUF_DIV4 = 0x2
	// Divide by 8
	PDEC_PRESCBUF_PRESCBUF_DIV8 = 0x3
	// Divide by 16
	PDEC_PRESCBUF_PRESCBUF_DIV16 = 0x4
	// Divide by 32
	PDEC_PRESCBUF_PRESCBUF_DIV32 = 0x5
	// Divide by 64
	PDEC_PRESCBUF_PRESCBUF_DIV64 = 0x6
	// Divide by 128
	PDEC_PRESCBUF_PRESCBUF_DIV128 = 0x7
	// Divide by 256
	PDEC_PRESCBUF_PRESCBUF_DIV256 = 0x8
	// Divide by 512
	PDEC_PRESCBUF_PRESCBUF_DIV512 = 0x9
	// Divide by 1024
	PDEC_PRESCBUF_PRESCBUF_DIV1024 = 0xa

	// FILTERBUF: Filter Buffer Value
	// Position of FILTERBUF field.
	PDEC_FILTERBUF_FILTERBUF_Pos = 0x0
	// Bit mask of FILTERBUF field.
	PDEC_FILTERBUF_FILTERBUF_Msk = 0xff

	// COUNT: Counter Value
	// Position of COUNT field.
	PDEC_COUNT_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	PDEC_COUNT_COUNT_Msk = 0xffff

	// CC: Channel n Compare Value
	// Position of CC field.
	PDEC_CC_CC_Pos = 0x0
	// Bit mask of CC field.
	PDEC_CC_CC_Msk = 0xffff

	// CCBUF: Channel Compare Buffer Value
	// Position of CCBUF field.
	PDEC_CCBUF_CCBUF_Pos = 0x0
	// Bit mask of CCBUF field.
	PDEC_CCBUF_CCBUF_Msk = 0xffff
)

// Constants for PM: Power Manager
const (
	// CTRLA: Control A
	// Position of IORET field.
	PM_CTRLA_IORET_Pos = 0x2
	// Bit mask of IORET field.
	PM_CTRLA_IORET_Msk = 0x4
	// Bit IORET.
	PM_CTRLA_IORET = 0x4

	// SLEEPCFG: Sleep Configuration
	// Position of SLEEPMODE field.
	PM_SLEEPCFG_SLEEPMODE_Pos = 0x0
	// Bit mask of SLEEPMODE field.
	PM_SLEEPCFG_SLEEPMODE_Msk = 0x7
	// CPU, AHBx, and APBx clocks are OFF
	PM_SLEEPCFG_SLEEPMODE_IDLE = 0x2
	// All Clocks are OFF
	PM_SLEEPCFG_SLEEPMODE_STANDBY = 0x4
	// Backup domain is ON as well as some PDRAMs
	PM_SLEEPCFG_SLEEPMODE_HIBERNATE = 0x5
	// Only Backup domain is powered ON
	PM_SLEEPCFG_SLEEPMODE_BACKUP = 0x6
	// All power domains are powered OFF
	PM_SLEEPCFG_SLEEPMODE_OFF = 0x7

	// INTENCLR: Interrupt Enable Clear
	// Position of SLEEPRDY field.
	PM_INTENCLR_SLEEPRDY_Pos = 0x0
	// Bit mask of SLEEPRDY field.
	PM_INTENCLR_SLEEPRDY_Msk = 0x1
	// Bit SLEEPRDY.
	PM_INTENCLR_SLEEPRDY = 0x1

	// INTENSET: Interrupt Enable Set
	// Position of SLEEPRDY field.
	PM_INTENSET_SLEEPRDY_Pos = 0x0
	// Bit mask of SLEEPRDY field.
	PM_INTENSET_SLEEPRDY_Msk = 0x1
	// Bit SLEEPRDY.
	PM_INTENSET_SLEEPRDY = 0x1

	// INTFLAG: Interrupt Flag Status and Clear
	// Position of SLEEPRDY field.
	PM_INTFLAG_SLEEPRDY_Pos = 0x0
	// Bit mask of SLEEPRDY field.
	PM_INTFLAG_SLEEPRDY_Msk = 0x1
	// Bit SLEEPRDY.
	PM_INTFLAG_SLEEPRDY = 0x1

	// STDBYCFG: Standby Configuration
	// Position of RAMCFG field.
	PM_STDBYCFG_RAMCFG_Pos = 0x0
	// Bit mask of RAMCFG field.
	PM_STDBYCFG_RAMCFG_Msk = 0x3
	// All the system RAM is retained
	PM_STDBYCFG_RAMCFG_RET = 0x0
	// Only the first 32Kbytes of the system RAM is retained
	PM_STDBYCFG_RAMCFG_PARTIAL = 0x1
	// All the system RAM is turned OFF
	PM_STDBYCFG_RAMCFG_OFF = 0x2
	// Position of FASTWKUP field.
	PM_STDBYCFG_FASTWKUP_Pos = 0x4
	// Bit mask of FASTWKUP field.
	PM_STDBYCFG_FASTWKUP_Msk = 0x30
	// Fast Wakeup is disabled
	PM_STDBYCFG_FASTWKUP_NO = 0x0
	// Fast Wakeup is enabled on NVM
	PM_STDBYCFG_FASTWKUP_NVM = 0x1
	// Fast Wakeup is enabled on the main voltage regulator (MAINVREG)
	PM_STDBYCFG_FASTWKUP_MAINVREG = 0x2
	// Fast Wakeup is enabled on both NVM and MAINVREG
	PM_STDBYCFG_FASTWKUP_BOTH = 0x3

	// HIBCFG: Hibernate Configuration
	// Position of RAMCFG field.
	PM_HIBCFG_RAMCFG_Pos = 0x0
	// Bit mask of RAMCFG field.
	PM_HIBCFG_RAMCFG_Msk = 0x3
	// All the system RAM is retained
	PM_HIBCFG_RAMCFG_RET = 0x0
	// Only the first 32Kbytes of the system RAM is retained
	PM_HIBCFG_RAMCFG_PARTIAL = 0x1
	// All the system RAM is turned OFF
	PM_HIBCFG_RAMCFG_OFF = 0x2
	// Position of BRAMCFG field.
	PM_HIBCFG_BRAMCFG_Pos = 0x2
	// Bit mask of BRAMCFG field.
	PM_HIBCFG_BRAMCFG_Msk = 0xc
	// All the backup RAM is retained
	PM_HIBCFG_BRAMCFG_RET = 0x0
	// Only the first 4Kbytes of the backup RAM is retained
	PM_HIBCFG_BRAMCFG_PARTIAL = 0x1
	// All the backup RAM is turned OFF
	PM_HIBCFG_BRAMCFG_OFF = 0x2

	// BKUPCFG: Backup Configuration
	// Position of BRAMCFG field.
	PM_BKUPCFG_BRAMCFG_Pos = 0x0
	// Bit mask of BRAMCFG field.
	PM_BKUPCFG_BRAMCFG_Msk = 0x3
	// All the backup RAM is retained
	PM_BKUPCFG_BRAMCFG_RET = 0x0
	// Only the first 4Kbytes of the backup RAM is retained
	PM_BKUPCFG_BRAMCFG_PARTIAL = 0x1
	// All the backup RAM is turned OFF
	PM_BKUPCFG_BRAMCFG_OFF = 0x2

	// PWSAKDLY: Power Switch Acknowledge Delay
	// Position of DLYVAL field.
	PM_PWSAKDLY_DLYVAL_Pos = 0x0
	// Bit mask of DLYVAL field.
	PM_PWSAKDLY_DLYVAL_Msk = 0x7f
	// Position of IGNACK field.
	PM_PWSAKDLY_IGNACK_Pos = 0x7
	// Bit mask of IGNACK field.
	PM_PWSAKDLY_IGNACK_Msk = 0x80
	// Bit IGNACK.
	PM_PWSAKDLY_IGNACK = 0x80
)

// Constants for PORT: Port Module
const (
	// GROUP.DIR: Data Direction
	// Position of DIR field.
	PORT_GROUP_DIR_DIR_Pos = 0x0
	// Bit mask of DIR field.
	PORT_GROUP_DIR_DIR_Msk = 0xffffffff

	// GROUP.DIRCLR: Data Direction Clear
	// Position of DIRCLR field.
	PORT_GROUP_DIRCLR_DIRCLR_Pos = 0x0
	// Bit mask of DIRCLR field.
	PORT_GROUP_DIRCLR_DIRCLR_Msk = 0xffffffff

	// GROUP.DIRSET: Data Direction Set
	// Position of DIRSET field.
	PORT_GROUP_DIRSET_DIRSET_Pos = 0x0
	// Bit mask of DIRSET field.
	PORT_GROUP_DIRSET_DIRSET_Msk = 0xffffffff

	// GROUP.DIRTGL: Data Direction Toggle
	// Position of DIRTGL field.
	PORT_GROUP_DIRTGL_DIRTGL_Pos = 0x0
	// Bit mask of DIRTGL field.
	PORT_GROUP_DIRTGL_DIRTGL_Msk = 0xffffffff

	// GROUP.OUT: Data Output Value
	// Position of OUT field.
	PORT_GROUP_OUT_OUT_Pos = 0x0
	// Bit mask of OUT field.
	PORT_GROUP_OUT_OUT_Msk = 0xffffffff

	// GROUP.OUTCLR: Data Output Value Clear
	// Position of OUTCLR field.
	PORT_GROUP_OUTCLR_OUTCLR_Pos = 0x0
	// Bit mask of OUTCLR field.
	PORT_GROUP_OUTCLR_OUTCLR_Msk = 0xffffffff

	// GROUP.OUTSET: Data Output Value Set
	// Position of OUTSET field.
	PORT_GROUP_OUTSET_OUTSET_Pos = 0x0
	// Bit mask of OUTSET field.
	PORT_GROUP_OUTSET_OUTSET_Msk = 0xffffffff

	// GROUP.OUTTGL: Data Output Value Toggle
	// Position of OUTTGL field.
	PORT_GROUP_OUTTGL_OUTTGL_Pos = 0x0
	// Bit mask of OUTTGL field.
	PORT_GROUP_OUTTGL_OUTTGL_Msk = 0xffffffff

	// GROUP.IN: Data Input Value
	// Position of IN field.
	PORT_GROUP_IN_IN_Pos = 0x0
	// Bit mask of IN field.
	PORT_GROUP_IN_IN_Msk = 0xffffffff

	// GROUP.CTRL: Control
	// Position of SAMPLING field.
	PORT_GROUP_CTRL_SAMPLING_Pos = 0x0
	// Bit mask of SAMPLING field.
	PORT_GROUP_CTRL_SAMPLING_Msk = 0xffffffff

	// GROUP.WRCONFIG: Write Configuration
	// Position of PINMASK field.
	PORT_GROUP_WRCONFIG_PINMASK_Pos = 0x0
	// Bit mask of PINMASK field.
	PORT_GROUP_WRCONFIG_PINMASK_Msk = 0xffff
	// Position of PMUXEN field.
	PORT_GROUP_WRCONFIG_PMUXEN_Pos = 0x10
	// Bit mask of PMUXEN field.
	PORT_GROUP_WRCONFIG_PMUXEN_Msk = 0x10000
	// Bit PMUXEN.
	PORT_GROUP_WRCONFIG_PMUXEN = 0x10000
	// Position of INEN field.
	PORT_GROUP_WRCONFIG_INEN_Pos = 0x11
	// Bit mask of INEN field.
	PORT_GROUP_WRCONFIG_INEN_Msk = 0x20000
	// Bit INEN.
	PORT_GROUP_WRCONFIG_INEN = 0x20000
	// Position of PULLEN field.
	PORT_GROUP_WRCONFIG_PULLEN_Pos = 0x12
	// Bit mask of PULLEN field.
	PORT_GROUP_WRCONFIG_PULLEN_Msk = 0x40000
	// Bit PULLEN.
	PORT_GROUP_WRCONFIG_PULLEN = 0x40000
	// Position of DRVSTR field.
	PORT_GROUP_WRCONFIG_DRVSTR_Pos = 0x16
	// Bit mask of DRVSTR field.
	PORT_GROUP_WRCONFIG_DRVSTR_Msk = 0x400000
	// Bit DRVSTR.
	PORT_GROUP_WRCONFIG_DRVSTR = 0x400000
	// Position of PMUX field.
	PORT_GROUP_WRCONFIG_PMUX_Pos = 0x18
	// Bit mask of PMUX field.
	PORT_GROUP_WRCONFIG_PMUX_Msk = 0xf000000
	// Position of WRPMUX field.
	PORT_GROUP_WRCONFIG_WRPMUX_Pos = 0x1c
	// Bit mask of WRPMUX field.
	PORT_GROUP_WRCONFIG_WRPMUX_Msk = 0x10000000
	// Bit WRPMUX.
	PORT_GROUP_WRCONFIG_WRPMUX = 0x10000000
	// Position of WRPINCFG field.
	PORT_GROUP_WRCONFIG_WRPINCFG_Pos = 0x1e
	// Bit mask of WRPINCFG field.
	PORT_GROUP_WRCONFIG_WRPINCFG_Msk = 0x40000000
	// Bit WRPINCFG.
	PORT_GROUP_WRCONFIG_WRPINCFG = 0x40000000
	// Position of HWSEL field.
	PORT_GROUP_WRCONFIG_HWSEL_Pos = 0x1f
	// Bit mask of HWSEL field.
	PORT_GROUP_WRCONFIG_HWSEL_Msk = 0x80000000
	// Bit HWSEL.
	PORT_GROUP_WRCONFIG_HWSEL = 0x80000000

	// GROUP.EVCTRL: Event Input Control
	// Position of PID0 field.
	PORT_GROUP_EVCTRL_PID0_Pos = 0x0
	// Bit mask of PID0 field.
	PORT_GROUP_EVCTRL_PID0_Msk = 0x1f
	// Position of EVACT0 field.
	PORT_GROUP_EVCTRL_EVACT0_Pos = 0x5
	// Bit mask of EVACT0 field.
	PORT_GROUP_EVCTRL_EVACT0_Msk = 0x60
	// Event output to pin
	PORT_GROUP_EVCTRL_EVACT0_OUT = 0x0
	// Set output register of pin on event
	PORT_GROUP_EVCTRL_EVACT0_SET = 0x1
	// Clear output register of pin on event
	PORT_GROUP_EVCTRL_EVACT0_CLR = 0x2
	// Toggle output register of pin on event
	PORT_GROUP_EVCTRL_EVACT0_TGL = 0x3
	// Position of PORTEI0 field.
	PORT_GROUP_EVCTRL_PORTEI0_Pos = 0x7
	// Bit mask of PORTEI0 field.
	PORT_GROUP_EVCTRL_PORTEI0_Msk = 0x80
	// Bit PORTEI0.
	PORT_GROUP_EVCTRL_PORTEI0 = 0x80
	// Position of PID1 field.
	PORT_GROUP_EVCTRL_PID1_Pos = 0x8
	// Bit mask of PID1 field.
	PORT_GROUP_EVCTRL_PID1_Msk = 0x1f00
	// Position of EVACT1 field.
	PORT_GROUP_EVCTRL_EVACT1_Pos = 0xd
	// Bit mask of EVACT1 field.
	PORT_GROUP_EVCTRL_EVACT1_Msk = 0x6000
	// Position of PORTEI1 field.
	PORT_GROUP_EVCTRL_PORTEI1_Pos = 0xf
	// Bit mask of PORTEI1 field.
	PORT_GROUP_EVCTRL_PORTEI1_Msk = 0x8000
	// Bit PORTEI1.
	PORT_GROUP_EVCTRL_PORTEI1 = 0x8000
	// Position of PID2 field.
	PORT_GROUP_EVCTRL_PID2_Pos = 0x10
	// Bit mask of PID2 field.
	PORT_GROUP_EVCTRL_PID2_Msk = 0x1f0000
	// Position of EVACT2 field.
	PORT_GROUP_EVCTRL_EVACT2_Pos = 0x15
	// Bit mask of EVACT2 field.
	PORT_GROUP_EVCTRL_EVACT2_Msk = 0x600000
	// Position of PORTEI2 field.
	PORT_GROUP_EVCTRL_PORTEI2_Pos = 0x17
	// Bit mask of PORTEI2 field.
	PORT_GROUP_EVCTRL_PORTEI2_Msk = 0x800000
	// Bit PORTEI2.
	PORT_GROUP_EVCTRL_PORTEI2 = 0x800000
	// Position of PID3 field.
	PORT_GROUP_EVCTRL_PID3_Pos = 0x18
	// Bit mask of PID3 field.
	PORT_GROUP_EVCTRL_PID3_Msk = 0x1f000000
	// Position of EVACT3 field.
	PORT_GROUP_EVCTRL_EVACT3_Pos = 0x1d
	// Bit mask of EVACT3 field.
	PORT_GROUP_EVCTRL_EVACT3_Msk = 0x60000000
	// Position of PORTEI3 field.
	PORT_GROUP_EVCTRL_PORTEI3_Pos = 0x1f
	// Bit mask of PORTEI3 field.
	PORT_GROUP_EVCTRL_PORTEI3_Msk = 0x80000000
	// Bit PORTEI3.
	PORT_GROUP_EVCTRL_PORTEI3 = 0x80000000

	// GROUP.PMUX: Peripheral Multiplexing
	// Position of PMUXE field.
	PORT_GROUP_PMUX_PMUXE_Pos = 0x0
	// Bit mask of PMUXE field.
	PORT_GROUP_PMUX_PMUXE_Msk = 0xf
	// Position of PMUXO field.
	PORT_GROUP_PMUX_PMUXO_Pos = 0x4
	// Bit mask of PMUXO field.
	PORT_GROUP_PMUX_PMUXO_Msk = 0xf0

	// GROUP.PINCFG: Pin Configuration
	// Position of PMUXEN field.
	PORT_GROUP_PINCFG_PMUXEN_Pos = 0x0
	// Bit mask of PMUXEN field.
	PORT_GROUP_PINCFG_PMUXEN_Msk = 0x1
	// Bit PMUXEN.
	PORT_GROUP_PINCFG_PMUXEN = 0x1
	// Position of INEN field.
	PORT_GROUP_PINCFG_INEN_Pos = 0x1
	// Bit mask of INEN field.
	PORT_GROUP_PINCFG_INEN_Msk = 0x2
	// Bit INEN.
	PORT_GROUP_PINCFG_INEN = 0x2
	// Position of PULLEN field.
	PORT_GROUP_PINCFG_PULLEN_Pos = 0x2
	// Bit mask of PULLEN field.
	PORT_GROUP_PINCFG_PULLEN_Msk = 0x4
	// Bit PULLEN.
	PORT_GROUP_PINCFG_PULLEN = 0x4
	// Position of DRVSTR field.
	PORT_GROUP_PINCFG_DRVSTR_Pos = 0x6
	// Bit mask of DRVSTR field.
	PORT_GROUP_PINCFG_DRVSTR_Msk = 0x40
	// Bit DRVSTR.
	PORT_GROUP_PINCFG_DRVSTR = 0x40
)

// Constants for QSPI: Quad SPI interface
const (
	// CTRLA: Control A
	// Position of SWRST field.
	QSPI_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	QSPI_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	QSPI_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	QSPI_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	QSPI_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	QSPI_CTRLA_ENABLE = 0x2
	// Position of LASTXFER field.
	QSPI_CTRLA_LASTXFER_Pos = 0x18
	// Bit mask of LASTXFER field.
	QSPI_CTRLA_LASTXFER_Msk = 0x1000000
	// Bit LASTXFER.
	QSPI_CTRLA_LASTXFER = 0x1000000

	// CTRLB: Control B
	// Position of MODE field.
	QSPI_CTRLB_MODE_Pos = 0x0
	// Bit mask of MODE field.
	QSPI_CTRLB_MODE_Msk = 0x1
	// Bit MODE.
	QSPI_CTRLB_MODE = 0x1
	// SPI operating mode
	QSPI_CTRLB_MODE_SPI = 0x0
	// Serial Memory operating mode
	QSPI_CTRLB_MODE_MEMORY = 0x1
	// Position of LOOPEN field.
	QSPI_CTRLB_LOOPEN_Pos = 0x1
	// Bit mask of LOOPEN field.
	QSPI_CTRLB_LOOPEN_Msk = 0x2
	// Bit LOOPEN.
	QSPI_CTRLB_LOOPEN = 0x2
	// Position of WDRBT field.
	QSPI_CTRLB_WDRBT_Pos = 0x2
	// Bit mask of WDRBT field.
	QSPI_CTRLB_WDRBT_Msk = 0x4
	// Bit WDRBT.
	QSPI_CTRLB_WDRBT = 0x4
	// Position of SMEMREG field.
	QSPI_CTRLB_SMEMREG_Pos = 0x3
	// Bit mask of SMEMREG field.
	QSPI_CTRLB_SMEMREG_Msk = 0x8
	// Bit SMEMREG.
	QSPI_CTRLB_SMEMREG = 0x8
	// Position of CSMODE field.
	QSPI_CTRLB_CSMODE_Pos = 0x4
	// Bit mask of CSMODE field.
	QSPI_CTRLB_CSMODE_Msk = 0x30
	// The chip select is deasserted if TD has not been reloaded before the end of the current transfer.
	QSPI_CTRLB_CSMODE_NORELOAD = 0x0
	// The chip select is deasserted when the bit LASTXFER is written at 1 and the character written in TD has been transferred.
	QSPI_CTRLB_CSMODE_LASTXFER = 0x1
	// The chip select is deasserted systematically after each transfer.
	QSPI_CTRLB_CSMODE_SYSTEMATICALLY = 0x2
	// Position of DATALEN field.
	QSPI_CTRLB_DATALEN_Pos = 0x8
	// Bit mask of DATALEN field.
	QSPI_CTRLB_DATALEN_Msk = 0xf00
	// 8-bits transfer
	QSPI_CTRLB_DATALEN_8BITS = 0x0
	// 9 bits transfer
	QSPI_CTRLB_DATALEN_9BITS = 0x1
	// 10-bits transfer
	QSPI_CTRLB_DATALEN_10BITS = 0x2
	// 11-bits transfer
	QSPI_CTRLB_DATALEN_11BITS = 0x3
	// 12-bits transfer
	QSPI_CTRLB_DATALEN_12BITS = 0x4
	// 13-bits transfer
	QSPI_CTRLB_DATALEN_13BITS = 0x5
	// 14-bits transfer
	QSPI_CTRLB_DATALEN_14BITS = 0x6
	// 15-bits transfer
	QSPI_CTRLB_DATALEN_15BITS = 0x7
	// 16-bits transfer
	QSPI_CTRLB_DATALEN_16BITS = 0x8
	// Position of DLYBCT field.
	QSPI_CTRLB_DLYBCT_Pos = 0x10
	// Bit mask of DLYBCT field.
	QSPI_CTRLB_DLYBCT_Msk = 0xff0000
	// Position of DLYCS field.
	QSPI_CTRLB_DLYCS_Pos = 0x18
	// Bit mask of DLYCS field.
	QSPI_CTRLB_DLYCS_Msk = 0xff000000

	// BAUD: Baud Rate
	// Position of CPOL field.
	QSPI_BAUD_CPOL_Pos = 0x0
	// Bit mask of CPOL field.
	QSPI_BAUD_CPOL_Msk = 0x1
	// Bit CPOL.
	QSPI_BAUD_CPOL = 0x1
	// Position of CPHA field.
	QSPI_BAUD_CPHA_Pos = 0x1
	// Bit mask of CPHA field.
	QSPI_BAUD_CPHA_Msk = 0x2
	// Bit CPHA.
	QSPI_BAUD_CPHA = 0x2
	// Position of BAUD field.
	QSPI_BAUD_BAUD_Pos = 0x8
	// Bit mask of BAUD field.
	QSPI_BAUD_BAUD_Msk = 0xff00
	// Position of DLYBS field.
	QSPI_BAUD_DLYBS_Pos = 0x10
	// Bit mask of DLYBS field.
	QSPI_BAUD_DLYBS_Msk = 0xff0000

	// RXDATA: Receive Data
	// Position of DATA field.
	QSPI_RXDATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	QSPI_RXDATA_DATA_Msk = 0xffff

	// TXDATA: Transmit Data
	// Position of DATA field.
	QSPI_TXDATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	QSPI_TXDATA_DATA_Msk = 0xffff

	// INTENCLR: Interrupt Enable Clear
	// Position of RXC field.
	QSPI_INTENCLR_RXC_Pos = 0x0
	// Bit mask of RXC field.
	QSPI_INTENCLR_RXC_Msk = 0x1
	// Bit RXC.
	QSPI_INTENCLR_RXC = 0x1
	// Position of DRE field.
	QSPI_INTENCLR_DRE_Pos = 0x1
	// Bit mask of DRE field.
	QSPI_INTENCLR_DRE_Msk = 0x2
	// Bit DRE.
	QSPI_INTENCLR_DRE = 0x2
	// Position of TXC field.
	QSPI_INTENCLR_TXC_Pos = 0x2
	// Bit mask of TXC field.
	QSPI_INTENCLR_TXC_Msk = 0x4
	// Bit TXC.
	QSPI_INTENCLR_TXC = 0x4
	// Position of ERROR field.
	QSPI_INTENCLR_ERROR_Pos = 0x3
	// Bit mask of ERROR field.
	QSPI_INTENCLR_ERROR_Msk = 0x8
	// Bit ERROR.
	QSPI_INTENCLR_ERROR = 0x8
	// Position of CSRISE field.
	QSPI_INTENCLR_CSRISE_Pos = 0x8
	// Bit mask of CSRISE field.
	QSPI_INTENCLR_CSRISE_Msk = 0x100
	// Bit CSRISE.
	QSPI_INTENCLR_CSRISE = 0x100
	// Position of INSTREND field.
	QSPI_INTENCLR_INSTREND_Pos = 0xa
	// Bit mask of INSTREND field.
	QSPI_INTENCLR_INSTREND_Msk = 0x400
	// Bit INSTREND.
	QSPI_INTENCLR_INSTREND = 0x400

	// INTENSET: Interrupt Enable Set
	// Position of RXC field.
	QSPI_INTENSET_RXC_Pos = 0x0
	// Bit mask of RXC field.
	QSPI_INTENSET_RXC_Msk = 0x1
	// Bit RXC.
	QSPI_INTENSET_RXC = 0x1
	// Position of DRE field.
	QSPI_INTENSET_DRE_Pos = 0x1
	// Bit mask of DRE field.
	QSPI_INTENSET_DRE_Msk = 0x2
	// Bit DRE.
	QSPI_INTENSET_DRE = 0x2
	// Position of TXC field.
	QSPI_INTENSET_TXC_Pos = 0x2
	// Bit mask of TXC field.
	QSPI_INTENSET_TXC_Msk = 0x4
	// Bit TXC.
	QSPI_INTENSET_TXC = 0x4
	// Position of ERROR field.
	QSPI_INTENSET_ERROR_Pos = 0x3
	// Bit mask of ERROR field.
	QSPI_INTENSET_ERROR_Msk = 0x8
	// Bit ERROR.
	QSPI_INTENSET_ERROR = 0x8
	// Position of CSRISE field.
	QSPI_INTENSET_CSRISE_Pos = 0x8
	// Bit mask of CSRISE field.
	QSPI_INTENSET_CSRISE_Msk = 0x100
	// Bit CSRISE.
	QSPI_INTENSET_CSRISE = 0x100
	// Position of INSTREND field.
	QSPI_INTENSET_INSTREND_Pos = 0xa
	// Bit mask of INSTREND field.
	QSPI_INTENSET_INSTREND_Msk = 0x400
	// Bit INSTREND.
	QSPI_INTENSET_INSTREND = 0x400

	// INTFLAG: Interrupt Flag Status and Clear
	// Position of RXC field.
	QSPI_INTFLAG_RXC_Pos = 0x0
	// Bit mask of RXC field.
	QSPI_INTFLAG_RXC_Msk = 0x1
	// Bit RXC.
	QSPI_INTFLAG_RXC = 0x1
	// Position of DRE field.
	QSPI_INTFLAG_DRE_Pos = 0x1
	// Bit mask of DRE field.
	QSPI_INTFLAG_DRE_Msk = 0x2
	// Bit DRE.
	QSPI_INTFLAG_DRE = 0x2
	// Position of TXC field.
	QSPI_INTFLAG_TXC_Pos = 0x2
	// Bit mask of TXC field.
	QSPI_INTFLAG_TXC_Msk = 0x4
	// Bit TXC.
	QSPI_INTFLAG_TXC = 0x4
	// Position of ERROR field.
	QSPI_INTFLAG_ERROR_Pos = 0x3
	// Bit mask of ERROR field.
	QSPI_INTFLAG_ERROR_Msk = 0x8
	// Bit ERROR.
	QSPI_INTFLAG_ERROR = 0x8
	// Position of CSRISE field.
	QSPI_INTFLAG_CSRISE_Pos = 0x8
	// Bit mask of CSRISE field.
	QSPI_INTFLAG_CSRISE_Msk = 0x100
	// Bit CSRISE.
	QSPI_INTFLAG_CSRISE = 0x100
	// Position of INSTREND field.
	QSPI_INTFLAG_INSTREND_Pos = 0xa
	// Bit mask of INSTREND field.
	QSPI_INTFLAG_INSTREND_Msk = 0x400
	// Bit INSTREND.
	QSPI_INTFLAG_INSTREND = 0x400

	// STATUS: Status Register
	// Position of ENABLE field.
	QSPI_STATUS_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	QSPI_STATUS_ENABLE_Msk = 0x2
	// Bit ENABLE.
	QSPI_STATUS_ENABLE = 0x2
	// Position of CSSTATUS field.
	QSPI_STATUS_CSSTATUS_Pos = 0x9
	// Bit mask of CSSTATUS field.
	QSPI_STATUS_CSSTATUS_Msk = 0x200
	// Bit CSSTATUS.
	QSPI_STATUS_CSSTATUS = 0x200

	// INSTRADDR: Instruction Address
	// Position of ADDR field.
	QSPI_INSTRADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	QSPI_INSTRADDR_ADDR_Msk = 0xffffffff

	// INSTRCTRL: Instruction Code
	// Position of INSTR field.
	QSPI_INSTRCTRL_INSTR_Pos = 0x0
	// Bit mask of INSTR field.
	QSPI_INSTRCTRL_INSTR_Msk = 0xff
	// Position of OPTCODE field.
	QSPI_INSTRCTRL_OPTCODE_Pos = 0x10
	// Bit mask of OPTCODE field.
	QSPI_INSTRCTRL_OPTCODE_Msk = 0xff0000

	// INSTRFRAME: Instruction Frame
	// Position of WIDTH field.
	QSPI_INSTRFRAME_WIDTH_Pos = 0x0
	// Bit mask of WIDTH field.
	QSPI_INSTRFRAME_WIDTH_Msk = 0x7
	// Instruction: Single-bit SPI / Address-Option: Single-bit SPI / Data: Single-bit SPI
	QSPI_INSTRFRAME_WIDTH_SINGLE_BIT_SPI = 0x0
	// Instruction: Single-bit SPI / Address-Option: Single-bit SPI / Data: Dual SPI
	QSPI_INSTRFRAME_WIDTH_DUAL_OUTPUT = 0x1
	// Instruction: Single-bit SPI / Address-Option: Single-bit SPI / Data: Quad SPI
	QSPI_INSTRFRAME_WIDTH_QUAD_OUTPUT = 0x2
	// Instruction: Single-bit SPI / Address-Option: Dual SPI / Data: Dual SPI
	QSPI_INSTRFRAME_WIDTH_DUAL_IO = 0x3
	// Instruction: Single-bit SPI / Address-Option: Quad SPI / Data: Quad SPI
	QSPI_INSTRFRAME_WIDTH_QUAD_IO = 0x4
	// Instruction: Dual SPI / Address-Option: Dual SPI / Data: Dual SPI
	QSPI_INSTRFRAME_WIDTH_DUAL_CMD = 0x5
	// Instruction: Quad SPI / Address-Option: Quad SPI / Data: Quad SPI
	QSPI_INSTRFRAME_WIDTH_QUAD_CMD = 0x6
	// Position of INSTREN field.
	QSPI_INSTRFRAME_INSTREN_Pos = 0x4
	// Bit mask of INSTREN field.
	QSPI_INSTRFRAME_INSTREN_Msk = 0x10
	// Bit INSTREN.
	QSPI_INSTRFRAME_INSTREN = 0x10
	// Position of ADDREN field.
	QSPI_INSTRFRAME_ADDREN_Pos = 0x5
	// Bit mask of ADDREN field.
	QSPI_INSTRFRAME_ADDREN_Msk = 0x20
	// Bit ADDREN.
	QSPI_INSTRFRAME_ADDREN = 0x20
	// Position of OPTCODEEN field.
	QSPI_INSTRFRAME_OPTCODEEN_Pos = 0x6
	// Bit mask of OPTCODEEN field.
	QSPI_INSTRFRAME_OPTCODEEN_Msk = 0x40
	// Bit OPTCODEEN.
	QSPI_INSTRFRAME_OPTCODEEN = 0x40
	// Position of DATAEN field.
	QSPI_INSTRFRAME_DATAEN_Pos = 0x7
	// Bit mask of DATAEN field.
	QSPI_INSTRFRAME_DATAEN_Msk = 0x80
	// Bit DATAEN.
	QSPI_INSTRFRAME_DATAEN = 0x80
	// Position of OPTCODELEN field.
	QSPI_INSTRFRAME_OPTCODELEN_Pos = 0x8
	// Bit mask of OPTCODELEN field.
	QSPI_INSTRFRAME_OPTCODELEN_Msk = 0x300
	// 1-bit length option code
	QSPI_INSTRFRAME_OPTCODELEN_1BIT = 0x0
	// 2-bits length option code
	QSPI_INSTRFRAME_OPTCODELEN_2BITS = 0x1
	// 4-bits length option code
	QSPI_INSTRFRAME_OPTCODELEN_4BITS = 0x2
	// 8-bits length option code
	QSPI_INSTRFRAME_OPTCODELEN_8BITS = 0x3
	// Position of ADDRLEN field.
	QSPI_INSTRFRAME_ADDRLEN_Pos = 0xa
	// Bit mask of ADDRLEN field.
	QSPI_INSTRFRAME_ADDRLEN_Msk = 0x400
	// Bit ADDRLEN.
	QSPI_INSTRFRAME_ADDRLEN = 0x400
	// 24-bits address length
	QSPI_INSTRFRAME_ADDRLEN_24BITS = 0x0
	// 32-bits address length
	QSPI_INSTRFRAME_ADDRLEN_32BITS = 0x1
	// Position of TFRTYPE field.
	QSPI_INSTRFRAME_TFRTYPE_Pos = 0xc
	// Bit mask of TFRTYPE field.
	QSPI_INSTRFRAME_TFRTYPE_Msk = 0x3000
	// Read transfer from the serial memory.Scrambling is not performed.Read at random location (fetch) in the serial flash memory is not possible.
	QSPI_INSTRFRAME_TFRTYPE_READ = 0x0
	// Read data transfer from the serial memory.If enabled, scrambling is performed.Read at random location (fetch) in the serial flash memory is possible.
	QSPI_INSTRFRAME_TFRTYPE_READMEMORY = 0x1
	// Write transfer into the serial memory.Scrambling is not performed.
	QSPI_INSTRFRAME_TFRTYPE_WRITE = 0x2
	// Write data transfer into the serial memory.If enabled, scrambling is performed.
	QSPI_INSTRFRAME_TFRTYPE_WRITEMEMORY = 0x3
	// Position of CRMODE field.
	QSPI_INSTRFRAME_CRMODE_Pos = 0xe
	// Bit mask of CRMODE field.
	QSPI_INSTRFRAME_CRMODE_Msk = 0x4000
	// Bit CRMODE.
	QSPI_INSTRFRAME_CRMODE = 0x4000
	// Position of DDREN field.
	QSPI_INSTRFRAME_DDREN_Pos = 0xf
	// Bit mask of DDREN field.
	QSPI_INSTRFRAME_DDREN_Msk = 0x8000
	// Bit DDREN.
	QSPI_INSTRFRAME_DDREN = 0x8000
	// Position of DUMMYLEN field.
	QSPI_INSTRFRAME_DUMMYLEN_Pos = 0x10
	// Bit mask of DUMMYLEN field.
	QSPI_INSTRFRAME_DUMMYLEN_Msk = 0x1f0000

	// SCRAMBCTRL: Scrambling Mode
	// Position of ENABLE field.
	QSPI_SCRAMBCTRL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	QSPI_SCRAMBCTRL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	QSPI_SCRAMBCTRL_ENABLE = 0x1
	// Position of RANDOMDIS field.
	QSPI_SCRAMBCTRL_RANDOMDIS_Pos = 0x1
	// Bit mask of RANDOMDIS field.
	QSPI_SCRAMBCTRL_RANDOMDIS_Msk = 0x2
	// Bit RANDOMDIS.
	QSPI_SCRAMBCTRL_RANDOMDIS = 0x2

	// SCRAMBKEY: Scrambling Key
	// Position of KEY field.
	QSPI_SCRAMBKEY_KEY_Pos = 0x0
	// Bit mask of KEY field.
	QSPI_SCRAMBKEY_KEY_Msk = 0xffffffff
)

// Constants for RAMECC: RAM ECC
const (
	// INTENCLR: Interrupt Enable Clear
	// Position of SINGLEE field.
	RAMECC_INTENCLR_SINGLEE_Pos = 0x0
	// Bit mask of SINGLEE field.
	RAMECC_INTENCLR_SINGLEE_Msk = 0x1
	// Bit SINGLEE.
	RAMECC_INTENCLR_SINGLEE = 0x1
	// Position of DUALE field.
	RAMECC_INTENCLR_DUALE_Pos = 0x1
	// Bit mask of DUALE field.
	RAMECC_INTENCLR_DUALE_Msk = 0x2
	// Bit DUALE.
	RAMECC_INTENCLR_DUALE = 0x2

	// INTENSET: Interrupt Enable Set
	// Position of SINGLEE field.
	RAMECC_INTENSET_SINGLEE_Pos = 0x0
	// Bit mask of SINGLEE field.
	RAMECC_INTENSET_SINGLEE_Msk = 0x1
	// Bit SINGLEE.
	RAMECC_INTENSET_SINGLEE = 0x1
	// Position of DUALE field.
	RAMECC_INTENSET_DUALE_Pos = 0x1
	// Bit mask of DUALE field.
	RAMECC_INTENSET_DUALE_Msk = 0x2
	// Bit DUALE.
	RAMECC_INTENSET_DUALE = 0x2

	// INTFLAG: Interrupt Flag
	// Position of SINGLEE field.
	RAMECC_INTFLAG_SINGLEE_Pos = 0x0
	// Bit mask of SINGLEE field.
	RAMECC_INTFLAG_SINGLEE_Msk = 0x1
	// Bit SINGLEE.
	RAMECC_INTFLAG_SINGLEE = 0x1
	// Position of DUALE field.
	RAMECC_INTFLAG_DUALE_Pos = 0x1
	// Bit mask of DUALE field.
	RAMECC_INTFLAG_DUALE_Msk = 0x2
	// Bit DUALE.
	RAMECC_INTFLAG_DUALE = 0x2

	// STATUS: Status
	// Position of ECCDIS field.
	RAMECC_STATUS_ECCDIS_Pos = 0x0
	// Bit mask of ECCDIS field.
	RAMECC_STATUS_ECCDIS_Msk = 0x1
	// Bit ECCDIS.
	RAMECC_STATUS_ECCDIS = 0x1

	// ERRADDR: Error Address
	// Position of ERRADDR field.
	RAMECC_ERRADDR_ERRADDR_Pos = 0x0
	// Bit mask of ERRADDR field.
	RAMECC_ERRADDR_ERRADDR_Msk = 0x1ffff

	// DBGCTRL: Debug Control
	// Position of ECCDIS field.
	RAMECC_DBGCTRL_ECCDIS_Pos = 0x0
	// Bit mask of ECCDIS field.
	RAMECC_DBGCTRL_ECCDIS_Msk = 0x1
	// Bit ECCDIS.
	RAMECC_DBGCTRL_ECCDIS = 0x1
	// Position of ECCELOG field.
	RAMECC_DBGCTRL_ECCELOG_Pos = 0x1
	// Bit mask of ECCELOG field.
	RAMECC_DBGCTRL_ECCELOG_Msk = 0x2
	// Bit ECCELOG.
	RAMECC_DBGCTRL_ECCELOG = 0x2
)

// Constants for RSTC: Reset Controller
const (
	// RCAUSE: Reset Cause
	// Position of POR field.
	RSTC_RCAUSE_POR_Pos = 0x0
	// Bit mask of POR field.
	RSTC_RCAUSE_POR_Msk = 0x1
	// Bit POR.
	RSTC_RCAUSE_POR = 0x1
	// Position of BODCORE field.
	RSTC_RCAUSE_BODCORE_Pos = 0x1
	// Bit mask of BODCORE field.
	RSTC_RCAUSE_BODCORE_Msk = 0x2
	// Bit BODCORE.
	RSTC_RCAUSE_BODCORE = 0x2
	// Position of BODVDD field.
	RSTC_RCAUSE_BODVDD_Pos = 0x2
	// Bit mask of BODVDD field.
	RSTC_RCAUSE_BODVDD_Msk = 0x4
	// Bit BODVDD.
	RSTC_RCAUSE_BODVDD = 0x4
	// Position of NVM field.
	RSTC_RCAUSE_NVM_Pos = 0x3
	// Bit mask of NVM field.
	RSTC_RCAUSE_NVM_Msk = 0x8
	// Bit NVM.
	RSTC_RCAUSE_NVM = 0x8
	// Position of EXT field.
	RSTC_RCAUSE_EXT_Pos = 0x4
	// Bit mask of EXT field.
	RSTC_RCAUSE_EXT_Msk = 0x10
	// Bit EXT.
	RSTC_RCAUSE_EXT = 0x10
	// Position of WDT field.
	RSTC_RCAUSE_WDT_Pos = 0x5
	// Bit mask of WDT field.
	RSTC_RCAUSE_WDT_Msk = 0x20
	// Bit WDT.
	RSTC_RCAUSE_WDT = 0x20
	// Position of SYST field.
	RSTC_RCAUSE_SYST_Pos = 0x6
	// Bit mask of SYST field.
	RSTC_RCAUSE_SYST_Msk = 0x40
	// Bit SYST.
	RSTC_RCAUSE_SYST = 0x40
	// Position of BACKUP field.
	RSTC_RCAUSE_BACKUP_Pos = 0x7
	// Bit mask of BACKUP field.
	RSTC_RCAUSE_BACKUP_Msk = 0x80
	// Bit BACKUP.
	RSTC_RCAUSE_BACKUP = 0x80

	// BKUPEXIT: Backup Exit Source
	// Position of RTC field.
	RSTC_BKUPEXIT_RTC_Pos = 0x1
	// Bit mask of RTC field.
	RSTC_BKUPEXIT_RTC_Msk = 0x2
	// Bit RTC.
	RSTC_BKUPEXIT_RTC = 0x2
	// Position of BBPS field.
	RSTC_BKUPEXIT_BBPS_Pos = 0x2
	// Bit mask of BBPS field.
	RSTC_BKUPEXIT_BBPS_Msk = 0x4
	// Bit BBPS.
	RSTC_BKUPEXIT_BBPS = 0x4
	// Position of HIB field.
	RSTC_BKUPEXIT_HIB_Pos = 0x7
	// Bit mask of HIB field.
	RSTC_BKUPEXIT_HIB_Msk = 0x80
	// Bit HIB.
	RSTC_BKUPEXIT_HIB = 0x80
)

// Constants for RTC: Real-Time Counter
const ()

// Constants for RTC_MODE0: Real-Time Counter - MODE0
const (
	// CTRLA: MODE0 Control A
	// Position of SWRST field.
	RTC_MODE0_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	RTC_MODE0_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	RTC_MODE0_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	RTC_MODE0_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	RTC_MODE0_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	RTC_MODE0_CTRLA_ENABLE = 0x2
	// Position of MODE field.
	RTC_MODE0_CTRLA_MODE_Pos = 0x2
	// Bit mask of MODE field.
	RTC_MODE0_CTRLA_MODE_Msk = 0xc
	// Mode 0: 32-bit Counter
	RTC_MODE0_CTRLA_MODE_COUNT32 = 0x0
	// Mode 1: 16-bit Counter
	RTC_MODE0_CTRLA_MODE_COUNT16 = 0x1
	// Mode 2: Clock/Calendar
	RTC_MODE0_CTRLA_MODE_CLOCK = 0x2
	// Position of MATCHCLR field.
	RTC_MODE0_CTRLA_MATCHCLR_Pos = 0x7
	// Bit mask of MATCHCLR field.
	RTC_MODE0_CTRLA_MATCHCLR_Msk = 0x80
	// Bit MATCHCLR.
	RTC_MODE0_CTRLA_MATCHCLR = 0x80
	// Position of PRESCALER field.
	RTC_MODE0_CTRLA_PRESCALER_Pos = 0x8
	// Bit mask of PRESCALER field.
	RTC_MODE0_CTRLA_PRESCALER_Msk = 0xf00
	// CLK_RTC_CNT = GCLK_RTC/1
	RTC_MODE0_CTRLA_PRESCALER_OFF = 0x0
	// CLK_RTC_CNT = GCLK_RTC/1
	RTC_MODE0_CTRLA_PRESCALER_DIV1 = 0x1
	// CLK_RTC_CNT = GCLK_RTC/2
	RTC_MODE0_CTRLA_PRESCALER_DIV2 = 0x2
	// CLK_RTC_CNT = GCLK_RTC/4
	RTC_MODE0_CTRLA_PRESCALER_DIV4 = 0x3
	// CLK_RTC_CNT = GCLK_RTC/8
	RTC_MODE0_CTRLA_PRESCALER_DIV8 = 0x4
	// CLK_RTC_CNT = GCLK_RTC/16
	RTC_MODE0_CTRLA_PRESCALER_DIV16 = 0x5
	// CLK_RTC_CNT = GCLK_RTC/32
	RTC_MODE0_CTRLA_PRESCALER_DIV32 = 0x6
	// CLK_RTC_CNT = GCLK_RTC/64
	RTC_MODE0_CTRLA_PRESCALER_DIV64 = 0x7
	// CLK_RTC_CNT = GCLK_RTC/128
	RTC_MODE0_CTRLA_PRESCALER_DIV128 = 0x8
	// CLK_RTC_CNT = GCLK_RTC/256
	RTC_MODE0_CTRLA_PRESCALER_DIV256 = 0x9
	// CLK_RTC_CNT = GCLK_RTC/512
	RTC_MODE0_CTRLA_PRESCALER_DIV512 = 0xa
	// CLK_RTC_CNT = GCLK_RTC/1024
	RTC_MODE0_CTRLA_PRESCALER_DIV1024 = 0xb
	// Position of BKTRST field.
	RTC_MODE0_CTRLA_BKTRST_Pos = 0xd
	// Bit mask of BKTRST field.
	RTC_MODE0_CTRLA_BKTRST_Msk = 0x2000
	// Bit BKTRST.
	RTC_MODE0_CTRLA_BKTRST = 0x2000
	// Position of GPTRST field.
	RTC_MODE0_CTRLA_GPTRST_Pos = 0xe
	// Bit mask of GPTRST field.
	RTC_MODE0_CTRLA_GPTRST_Msk = 0x4000
	// Bit GPTRST.
	RTC_MODE0_CTRLA_GPTRST = 0x4000
	// Position of COUNTSYNC field.
	RTC_MODE0_CTRLA_COUNTSYNC_Pos = 0xf
	// Bit mask of COUNTSYNC field.
	RTC_MODE0_CTRLA_COUNTSYNC_Msk = 0x8000
	// Bit COUNTSYNC.
	RTC_MODE0_CTRLA_COUNTSYNC = 0x8000

	// CTRLB: MODE0 Control B
	// Position of GP0EN field.
	RTC_MODE0_CTRLB_GP0EN_Pos = 0x0
	// Bit mask of GP0EN field.
	RTC_MODE0_CTRLB_GP0EN_Msk = 0x1
	// Bit GP0EN.
	RTC_MODE0_CTRLB_GP0EN = 0x1
	// Position of GP2EN field.
	RTC_MODE0_CTRLB_GP2EN_Pos = 0x1
	// Bit mask of GP2EN field.
	RTC_MODE0_CTRLB_GP2EN_Msk = 0x2
	// Bit GP2EN.
	RTC_MODE0_CTRLB_GP2EN = 0x2
	// Position of DEBMAJ field.
	RTC_MODE0_CTRLB_DEBMAJ_Pos = 0x4
	// Bit mask of DEBMAJ field.
	RTC_MODE0_CTRLB_DEBMAJ_Msk = 0x10
	// Bit DEBMAJ.
	RTC_MODE0_CTRLB_DEBMAJ = 0x10
	// Position of DEBASYNC field.
	RTC_MODE0_CTRLB_DEBASYNC_Pos = 0x5
	// Bit mask of DEBASYNC field.
	RTC_MODE0_CTRLB_DEBASYNC_Msk = 0x20
	// Bit DEBASYNC.
	RTC_MODE0_CTRLB_DEBASYNC = 0x20
	// Position of RTCOUT field.
	RTC_MODE0_CTRLB_RTCOUT_Pos = 0x6
	// Bit mask of RTCOUT field.
	RTC_MODE0_CTRLB_RTCOUT_Msk = 0x40
	// Bit RTCOUT.
	RTC_MODE0_CTRLB_RTCOUT = 0x40
	// Position of DMAEN field.
	RTC_MODE0_CTRLB_DMAEN_Pos = 0x7
	// Bit mask of DMAEN field.
	RTC_MODE0_CTRLB_DMAEN_Msk = 0x80
	// Bit DMAEN.
	RTC_MODE0_CTRLB_DMAEN = 0x80
	// Position of DEBF field.
	RTC_MODE0_CTRLB_DEBF_Pos = 0x8
	// Bit mask of DEBF field.
	RTC_MODE0_CTRLB_DEBF_Msk = 0x700
	// CLK_RTC_DEB = CLK_RTC/2
	RTC_MODE0_CTRLB_DEBF_DIV2 = 0x0
	// CLK_RTC_DEB = CLK_RTC/4
	RTC_MODE0_CTRLB_DEBF_DIV4 = 0x1
	// CLK_RTC_DEB = CLK_RTC/8
	RTC_MODE0_CTRLB_DEBF_DIV8 = 0x2
	// CLK_RTC_DEB = CLK_RTC/16
	RTC_MODE0_CTRLB_DEBF_DIV16 = 0x3
	// CLK_RTC_DEB = CLK_RTC/32
	RTC_MODE0_CTRLB_DEBF_DIV32 = 0x4
	// CLK_RTC_DEB = CLK_RTC/64
	RTC_MODE0_CTRLB_DEBF_DIV64 = 0x5
	// CLK_RTC_DEB = CLK_RTC/128
	RTC_MODE0_CTRLB_DEBF_DIV128 = 0x6
	// CLK_RTC_DEB = CLK_RTC/256
	RTC_MODE0_CTRLB_DEBF_DIV256 = 0x7
	// Position of ACTF field.
	RTC_MODE0_CTRLB_ACTF_Pos = 0xc
	// Bit mask of ACTF field.
	RTC_MODE0_CTRLB_ACTF_Msk = 0x7000
	// CLK_RTC_OUT = CLK_RTC/2
	RTC_MODE0_CTRLB_ACTF_DIV2 = 0x0
	// CLK_RTC_OUT = CLK_RTC/4
	RTC_MODE0_CTRLB_ACTF_DIV4 = 0x1
	// CLK_RTC_OUT = CLK_RTC/8
	RTC_MODE0_CTRLB_ACTF_DIV8 = 0x2
	// CLK_RTC_OUT = CLK_RTC/16
	RTC_MODE0_CTRLB_ACTF_DIV16 = 0x3
	// CLK_RTC_OUT = CLK_RTC/32
	RTC_MODE0_CTRLB_ACTF_DIV32 = 0x4
	// CLK_RTC_OUT = CLK_RTC/64
	RTC_MODE0_CTRLB_ACTF_DIV64 = 0x5
	// CLK_RTC_OUT = CLK_RTC/128
	RTC_MODE0_CTRLB_ACTF_DIV128 = 0x6
	// CLK_RTC_OUT = CLK_RTC/256
	RTC_MODE0_CTRLB_ACTF_DIV256 = 0x7

	// EVCTRL: MODE0 Event Control
	// Position of PEREO0 field.
	RTC_MODE0_EVCTRL_PEREO0_Pos = 0x0
	// Bit mask of PEREO0 field.
	RTC_MODE0_EVCTRL_PEREO0_Msk = 0x1
	// Bit PEREO0.
	RTC_MODE0_EVCTRL_PEREO0 = 0x1
	// Position of PEREO1 field.
	RTC_MODE0_EVCTRL_PEREO1_Pos = 0x1
	// Bit mask of PEREO1 field.
	RTC_MODE0_EVCTRL_PEREO1_Msk = 0x2
	// Bit PEREO1.
	RTC_MODE0_EVCTRL_PEREO1 = 0x2
	// Position of PEREO2 field.
	RTC_MODE0_EVCTRL_PEREO2_Pos = 0x2
	// Bit mask of PEREO2 field.
	RTC_MODE0_EVCTRL_PEREO2_Msk = 0x4
	// Bit PEREO2.
	RTC_MODE0_EVCTRL_PEREO2 = 0x4
	// Position of PEREO3 field.
	RTC_MODE0_EVCTRL_PEREO3_Pos = 0x3
	// Bit mask of PEREO3 field.
	RTC_MODE0_EVCTRL_PEREO3_Msk = 0x8
	// Bit PEREO3.
	RTC_MODE0_EVCTRL_PEREO3 = 0x8
	// Position of PEREO4 field.
	RTC_MODE0_EVCTRL_PEREO4_Pos = 0x4
	// Bit mask of PEREO4 field.
	RTC_MODE0_EVCTRL_PEREO4_Msk = 0x10
	// Bit PEREO4.
	RTC_MODE0_EVCTRL_PEREO4 = 0x10
	// Position of PEREO5 field.
	RTC_MODE0_EVCTRL_PEREO5_Pos = 0x5
	// Bit mask of PEREO5 field.
	RTC_MODE0_EVCTRL_PEREO5_Msk = 0x20
	// Bit PEREO5.
	RTC_MODE0_EVCTRL_PEREO5 = 0x20
	// Position of PEREO6 field.
	RTC_MODE0_EVCTRL_PEREO6_Pos = 0x6
	// Bit mask of PEREO6 field.
	RTC_MODE0_EVCTRL_PEREO6_Msk = 0x40
	// Bit PEREO6.
	RTC_MODE0_EVCTRL_PEREO6 = 0x40
	// Position of PEREO7 field.
	RTC_MODE0_EVCTRL_PEREO7_Pos = 0x7
	// Bit mask of PEREO7 field.
	RTC_MODE0_EVCTRL_PEREO7_Msk = 0x80
	// Bit PEREO7.
	RTC_MODE0_EVCTRL_PEREO7 = 0x80
	// Position of CMPEO0 field.
	RTC_MODE0_EVCTRL_CMPEO0_Pos = 0x8
	// Bit mask of CMPEO0 field.
	RTC_MODE0_EVCTRL_CMPEO0_Msk = 0x100
	// Bit CMPEO0.
	RTC_MODE0_EVCTRL_CMPEO0 = 0x100
	// Position of CMPEO1 field.
	RTC_MODE0_EVCTRL_CMPEO1_Pos = 0x9
	// Bit mask of CMPEO1 field.
	RTC_MODE0_EVCTRL_CMPEO1_Msk = 0x200
	// Bit CMPEO1.
	RTC_MODE0_EVCTRL_CMPEO1 = 0x200
	// Position of TAMPEREO field.
	RTC_MODE0_EVCTRL_TAMPEREO_Pos = 0xe
	// Bit mask of TAMPEREO field.
	RTC_MODE0_EVCTRL_TAMPEREO_Msk = 0x4000
	// Bit TAMPEREO.
	RTC_MODE0_EVCTRL_TAMPEREO = 0x4000
	// Position of OVFEO field.
	RTC_MODE0_EVCTRL_OVFEO_Pos = 0xf
	// Bit mask of OVFEO field.
	RTC_MODE0_EVCTRL_OVFEO_Msk = 0x8000
	// Bit OVFEO.
	RTC_MODE0_EVCTRL_OVFEO = 0x8000
	// Position of TAMPEVEI field.
	RTC_MODE0_EVCTRL_TAMPEVEI_Pos = 0x10
	// Bit mask of TAMPEVEI field.
	RTC_MODE0_EVCTRL_TAMPEVEI_Msk = 0x10000
	// Bit TAMPEVEI.
	RTC_MODE0_EVCTRL_TAMPEVEI = 0x10000

	// INTENCLR: MODE0 Interrupt Enable Clear
	// Position of PER0 field.
	RTC_MODE0_INTENCLR_PER0_Pos = 0x0
	// Bit mask of PER0 field.
	RTC_MODE0_INTENCLR_PER0_Msk = 0x1
	// Bit PER0.
	RTC_MODE0_INTENCLR_PER0 = 0x1
	// Position of PER1 field.
	RTC_MODE0_INTENCLR_PER1_Pos = 0x1
	// Bit mask of PER1 field.
	RTC_MODE0_INTENCLR_PER1_Msk = 0x2
	// Bit PER1.
	RTC_MODE0_INTENCLR_PER1 = 0x2
	// Position of PER2 field.
	RTC_MODE0_INTENCLR_PER2_Pos = 0x2
	// Bit mask of PER2 field.
	RTC_MODE0_INTENCLR_PER2_Msk = 0x4
	// Bit PER2.
	RTC_MODE0_INTENCLR_PER2 = 0x4
	// Position of PER3 field.
	RTC_MODE0_INTENCLR_PER3_Pos = 0x3
	// Bit mask of PER3 field.
	RTC_MODE0_INTENCLR_PER3_Msk = 0x8
	// Bit PER3.
	RTC_MODE0_INTENCLR_PER3 = 0x8
	// Position of PER4 field.
	RTC_MODE0_INTENCLR_PER4_Pos = 0x4
	// Bit mask of PER4 field.
	RTC_MODE0_INTENCLR_PER4_Msk = 0x10
	// Bit PER4.
	RTC_MODE0_INTENCLR_PER4 = 0x10
	// Position of PER5 field.
	RTC_MODE0_INTENCLR_PER5_Pos = 0x5
	// Bit mask of PER5 field.
	RTC_MODE0_INTENCLR_PER5_Msk = 0x20
	// Bit PER5.
	RTC_MODE0_INTENCLR_PER5 = 0x20
	// Position of PER6 field.
	RTC_MODE0_INTENCLR_PER6_Pos = 0x6
	// Bit mask of PER6 field.
	RTC_MODE0_INTENCLR_PER6_Msk = 0x40
	// Bit PER6.
	RTC_MODE0_INTENCLR_PER6 = 0x40
	// Position of PER7 field.
	RTC_MODE0_INTENCLR_PER7_Pos = 0x7
	// Bit mask of PER7 field.
	RTC_MODE0_INTENCLR_PER7_Msk = 0x80
	// Bit PER7.
	RTC_MODE0_INTENCLR_PER7 = 0x80
	// Position of CMP0 field.
	RTC_MODE0_INTENCLR_CMP0_Pos = 0x8
	// Bit mask of CMP0 field.
	RTC_MODE0_INTENCLR_CMP0_Msk = 0x100
	// Bit CMP0.
	RTC_MODE0_INTENCLR_CMP0 = 0x100
	// Position of CMP1 field.
	RTC_MODE0_INTENCLR_CMP1_Pos = 0x9
	// Bit mask of CMP1 field.
	RTC_MODE0_INTENCLR_CMP1_Msk = 0x200
	// Bit CMP1.
	RTC_MODE0_INTENCLR_CMP1 = 0x200
	// Position of TAMPER field.
	RTC_MODE0_INTENCLR_TAMPER_Pos = 0xe
	// Bit mask of TAMPER field.
	RTC_MODE0_INTENCLR_TAMPER_Msk = 0x4000
	// Bit TAMPER.
	RTC_MODE0_INTENCLR_TAMPER = 0x4000
	// Position of OVF field.
	RTC_MODE0_INTENCLR_OVF_Pos = 0xf
	// Bit mask of OVF field.
	RTC_MODE0_INTENCLR_OVF_Msk = 0x8000
	// Bit OVF.
	RTC_MODE0_INTENCLR_OVF = 0x8000

	// INTENSET: MODE0 Interrupt Enable Set
	// Position of PER0 field.
	RTC_MODE0_INTENSET_PER0_Pos = 0x0
	// Bit mask of PER0 field.
	RTC_MODE0_INTENSET_PER0_Msk = 0x1
	// Bit PER0.
	RTC_MODE0_INTENSET_PER0 = 0x1
	// Position of PER1 field.
	RTC_MODE0_INTENSET_PER1_Pos = 0x1
	// Bit mask of PER1 field.
	RTC_MODE0_INTENSET_PER1_Msk = 0x2
	// Bit PER1.
	RTC_MODE0_INTENSET_PER1 = 0x2
	// Position of PER2 field.
	RTC_MODE0_INTENSET_PER2_Pos = 0x2
	// Bit mask of PER2 field.
	RTC_MODE0_INTENSET_PER2_Msk = 0x4
	// Bit PER2.
	RTC_MODE0_INTENSET_PER2 = 0x4
	// Position of PER3 field.
	RTC_MODE0_INTENSET_PER3_Pos = 0x3
	// Bit mask of PER3 field.
	RTC_MODE0_INTENSET_PER3_Msk = 0x8
	// Bit PER3.
	RTC_MODE0_INTENSET_PER3 = 0x8
	// Position of PER4 field.
	RTC_MODE0_INTENSET_PER4_Pos = 0x4
	// Bit mask of PER4 field.
	RTC_MODE0_INTENSET_PER4_Msk = 0x10
	// Bit PER4.
	RTC_MODE0_INTENSET_PER4 = 0x10
	// Position of PER5 field.
	RTC_MODE0_INTENSET_PER5_Pos = 0x5
	// Bit mask of PER5 field.
	RTC_MODE0_INTENSET_PER5_Msk = 0x20
	// Bit PER5.
	RTC_MODE0_INTENSET_PER5 = 0x20
	// Position of PER6 field.
	RTC_MODE0_INTENSET_PER6_Pos = 0x6
	// Bit mask of PER6 field.
	RTC_MODE0_INTENSET_PER6_Msk = 0x40
	// Bit PER6.
	RTC_MODE0_INTENSET_PER6 = 0x40
	// Position of PER7 field.
	RTC_MODE0_INTENSET_PER7_Pos = 0x7
	// Bit mask of PER7 field.
	RTC_MODE0_INTENSET_PER7_Msk = 0x80
	// Bit PER7.
	RTC_MODE0_INTENSET_PER7 = 0x80
	// Position of CMP0 field.
	RTC_MODE0_INTENSET_CMP0_Pos = 0x8
	// Bit mask of CMP0 field.
	RTC_MODE0_INTENSET_CMP0_Msk = 0x100
	// Bit CMP0.
	RTC_MODE0_INTENSET_CMP0 = 0x100
	// Position of CMP1 field.
	RTC_MODE0_INTENSET_CMP1_Pos = 0x9
	// Bit mask of CMP1 field.
	RTC_MODE0_INTENSET_CMP1_Msk = 0x200
	// Bit CMP1.
	RTC_MODE0_INTENSET_CMP1 = 0x200
	// Position of TAMPER field.
	RTC_MODE0_INTENSET_TAMPER_Pos = 0xe
	// Bit mask of TAMPER field.
	RTC_MODE0_INTENSET_TAMPER_Msk = 0x4000
	// Bit TAMPER.
	RTC_MODE0_INTENSET_TAMPER = 0x4000
	// Position of OVF field.
	RTC_MODE0_INTENSET_OVF_Pos = 0xf
	// Bit mask of OVF field.
	RTC_MODE0_INTENSET_OVF_Msk = 0x8000
	// Bit OVF.
	RTC_MODE0_INTENSET_OVF = 0x8000

	// INTFLAG: MODE0 Interrupt Flag Status and Clear
	// Position of PER0 field.
	RTC_MODE0_INTFLAG_PER0_Pos = 0x0
	// Bit mask of PER0 field.
	RTC_MODE0_INTFLAG_PER0_Msk = 0x1
	// Bit PER0.
	RTC_MODE0_INTFLAG_PER0 = 0x1
	// Position of PER1 field.
	RTC_MODE0_INTFLAG_PER1_Pos = 0x1
	// Bit mask of PER1 field.
	RTC_MODE0_INTFLAG_PER1_Msk = 0x2
	// Bit PER1.
	RTC_MODE0_INTFLAG_PER1 = 0x2
	// Position of PER2 field.
	RTC_MODE0_INTFLAG_PER2_Pos = 0x2
	// Bit mask of PER2 field.
	RTC_MODE0_INTFLAG_PER2_Msk = 0x4
	// Bit PER2.
	RTC_MODE0_INTFLAG_PER2 = 0x4
	// Position of PER3 field.
	RTC_MODE0_INTFLAG_PER3_Pos = 0x3
	// Bit mask of PER3 field.
	RTC_MODE0_INTFLAG_PER3_Msk = 0x8
	// Bit PER3.
	RTC_MODE0_INTFLAG_PER3 = 0x8
	// Position of PER4 field.
	RTC_MODE0_INTFLAG_PER4_Pos = 0x4
	// Bit mask of PER4 field.
	RTC_MODE0_INTFLAG_PER4_Msk = 0x10
	// Bit PER4.
	RTC_MODE0_INTFLAG_PER4 = 0x10
	// Position of PER5 field.
	RTC_MODE0_INTFLAG_PER5_Pos = 0x5
	// Bit mask of PER5 field.
	RTC_MODE0_INTFLAG_PER5_Msk = 0x20
	// Bit PER5.
	RTC_MODE0_INTFLAG_PER5 = 0x20
	// Position of PER6 field.
	RTC_MODE0_INTFLAG_PER6_Pos = 0x6
	// Bit mask of PER6 field.
	RTC_MODE0_INTFLAG_PER6_Msk = 0x40
	// Bit PER6.
	RTC_MODE0_INTFLAG_PER6 = 0x40
	// Position of PER7 field.
	RTC_MODE0_INTFLAG_PER7_Pos = 0x7
	// Bit mask of PER7 field.
	RTC_MODE0_INTFLAG_PER7_Msk = 0x80
	// Bit PER7.
	RTC_MODE0_INTFLAG_PER7 = 0x80
	// Position of CMP0 field.
	RTC_MODE0_INTFLAG_CMP0_Pos = 0x8
	// Bit mask of CMP0 field.
	RTC_MODE0_INTFLAG_CMP0_Msk = 0x100
	// Bit CMP0.
	RTC_MODE0_INTFLAG_CMP0 = 0x100
	// Position of CMP1 field.
	RTC_MODE0_INTFLAG_CMP1_Pos = 0x9
	// Bit mask of CMP1 field.
	RTC_MODE0_INTFLAG_CMP1_Msk = 0x200
	// Bit CMP1.
	RTC_MODE0_INTFLAG_CMP1 = 0x200
	// Position of TAMPER field.
	RTC_MODE0_INTFLAG_TAMPER_Pos = 0xe
	// Bit mask of TAMPER field.
	RTC_MODE0_INTFLAG_TAMPER_Msk = 0x4000
	// Bit TAMPER.
	RTC_MODE0_INTFLAG_TAMPER = 0x4000
	// Position of OVF field.
	RTC_MODE0_INTFLAG_OVF_Pos = 0xf
	// Bit mask of OVF field.
	RTC_MODE0_INTFLAG_OVF_Msk = 0x8000
	// Bit OVF.
	RTC_MODE0_INTFLAG_OVF = 0x8000

	// DBGCTRL: Debug Control
	// Position of DBGRUN field.
	RTC_MODE0_DBGCTRL_DBGRUN_Pos = 0x0
	// Bit mask of DBGRUN field.
	RTC_MODE0_DBGCTRL_DBGRUN_Msk = 0x1
	// Bit DBGRUN.
	RTC_MODE0_DBGCTRL_DBGRUN = 0x1

	// SYNCBUSY: MODE0 Synchronization Busy Status
	// Position of SWRST field.
	RTC_MODE0_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	RTC_MODE0_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	RTC_MODE0_SYNCBUSY_SWRST = 0x1
	// Position of ENABLE field.
	RTC_MODE0_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	RTC_MODE0_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	RTC_MODE0_SYNCBUSY_ENABLE = 0x2
	// Position of FREQCORR field.
	RTC_MODE0_SYNCBUSY_FREQCORR_Pos = 0x2
	// Bit mask of FREQCORR field.
	RTC_MODE0_SYNCBUSY_FREQCORR_Msk = 0x4
	// Bit FREQCORR.
	RTC_MODE0_SYNCBUSY_FREQCORR = 0x4
	// Position of COUNT field.
	RTC_MODE0_SYNCBUSY_COUNT_Pos = 0x3
	// Bit mask of COUNT field.
	RTC_MODE0_SYNCBUSY_COUNT_Msk = 0x8
	// Bit COUNT.
	RTC_MODE0_SYNCBUSY_COUNT = 0x8
	// Position of COMP0 field.
	RTC_MODE0_SYNCBUSY_COMP0_Pos = 0x5
	// Bit mask of COMP0 field.
	RTC_MODE0_SYNCBUSY_COMP0_Msk = 0x20
	// Bit COMP0.
	RTC_MODE0_SYNCBUSY_COMP0 = 0x20
	// Position of COMP1 field.
	RTC_MODE0_SYNCBUSY_COMP1_Pos = 0x6
	// Bit mask of COMP1 field.
	RTC_MODE0_SYNCBUSY_COMP1_Msk = 0x40
	// Bit COMP1.
	RTC_MODE0_SYNCBUSY_COMP1 = 0x40
	// Position of COUNTSYNC field.
	RTC_MODE0_SYNCBUSY_COUNTSYNC_Pos = 0xf
	// Bit mask of COUNTSYNC field.
	RTC_MODE0_SYNCBUSY_COUNTSYNC_Msk = 0x8000
	// Bit COUNTSYNC.
	RTC_MODE0_SYNCBUSY_COUNTSYNC = 0x8000
	// Position of GP0 field.
	RTC_MODE0_SYNCBUSY_GP0_Pos = 0x10
	// Bit mask of GP0 field.
	RTC_MODE0_SYNCBUSY_GP0_Msk = 0x10000
	// Bit GP0.
	RTC_MODE0_SYNCBUSY_GP0 = 0x10000
	// Position of GP1 field.
	RTC_MODE0_SYNCBUSY_GP1_Pos = 0x11
	// Bit mask of GP1 field.
	RTC_MODE0_SYNCBUSY_GP1_Msk = 0x20000
	// Bit GP1.
	RTC_MODE0_SYNCBUSY_GP1 = 0x20000
	// Position of GP2 field.
	RTC_MODE0_SYNCBUSY_GP2_Pos = 0x12
	// Bit mask of GP2 field.
	RTC_MODE0_SYNCBUSY_GP2_Msk = 0x40000
	// Bit GP2.
	RTC_MODE0_SYNCBUSY_GP2 = 0x40000
	// Position of GP3 field.
	RTC_MODE0_SYNCBUSY_GP3_Pos = 0x13
	// Bit mask of GP3 field.
	RTC_MODE0_SYNCBUSY_GP3_Msk = 0x80000
	// Bit GP3.
	RTC_MODE0_SYNCBUSY_GP3 = 0x80000

	// FREQCORR: Frequency Correction
	// Position of VALUE field.
	RTC_MODE0_FREQCORR_VALUE_Pos = 0x0
	// Bit mask of VALUE field.
	RTC_MODE0_FREQCORR_VALUE_Msk = 0x7f
	// Position of SIGN field.
	RTC_MODE0_FREQCORR_SIGN_Pos = 0x7
	// Bit mask of SIGN field.
	RTC_MODE0_FREQCORR_SIGN_Msk = 0x80
	// Bit SIGN.
	RTC_MODE0_FREQCORR_SIGN = 0x80

	// COUNT: MODE0 Counter Value
	// Position of COUNT field.
	RTC_MODE0_COUNT_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	RTC_MODE0_COUNT_COUNT_Msk = 0xffffffff

	// COMP: MODE0 Compare n Value
	// Position of COMP field.
	RTC_MODE0_COMP_COMP_Pos = 0x0
	// Bit mask of COMP field.
	RTC_MODE0_COMP_COMP_Msk = 0xffffffff

	// GP: General Purpose
	// Position of GP field.
	RTC_MODE0_GP_GP_Pos = 0x0
	// Bit mask of GP field.
	RTC_MODE0_GP_GP_Msk = 0xffffffff

	// TAMPCTRL: Tamper Control
	// Position of IN0ACT field.
	RTC_MODE0_TAMPCTRL_IN0ACT_Pos = 0x0
	// Bit mask of IN0ACT field.
	RTC_MODE0_TAMPCTRL_IN0ACT_Msk = 0x3
	// Off (Disabled)
	RTC_MODE0_TAMPCTRL_IN0ACT_OFF = 0x0
	// Wake without timestamp
	RTC_MODE0_TAMPCTRL_IN0ACT_WAKE = 0x1
	// Capture timestamp
	RTC_MODE0_TAMPCTRL_IN0ACT_CAPTURE = 0x2
	// Compare IN0 to OUT
	RTC_MODE0_TAMPCTRL_IN0ACT_ACTL = 0x3
	// Position of IN1ACT field.
	RTC_MODE0_TAMPCTRL_IN1ACT_Pos = 0x2
	// Bit mask of IN1ACT field.
	RTC_MODE0_TAMPCTRL_IN1ACT_Msk = 0xc
	// Off (Disabled)
	RTC_MODE0_TAMPCTRL_IN1ACT_OFF = 0x0
	// Wake without timestamp
	RTC_MODE0_TAMPCTRL_IN1ACT_WAKE = 0x1
	// Capture timestamp
	RTC_MODE0_TAMPCTRL_IN1ACT_CAPTURE = 0x2
	// Compare IN1 to OUT
	RTC_MODE0_TAMPCTRL_IN1ACT_ACTL = 0x3
	// Position of IN2ACT field.
	RTC_MODE0_TAMPCTRL_IN2ACT_Pos = 0x4
	// Bit mask of IN2ACT field.
	RTC_MODE0_TAMPCTRL_IN2ACT_Msk = 0x30
	// Off (Disabled)
	RTC_MODE0_TAMPCTRL_IN2ACT_OFF = 0x0
	// Wake without timestamp
	RTC_MODE0_TAMPCTRL_IN2ACT_WAKE = 0x1
	// Capture timestamp
	RTC_MODE0_TAMPCTRL_IN2ACT_CAPTURE = 0x2
	// Compare IN2 to OUT
	RTC_MODE0_TAMPCTRL_IN2ACT_ACTL = 0x3
	// Position of IN3ACT field.
	RTC_MODE0_TAMPCTRL_IN3ACT_Pos = 0x6
	// Bit mask of IN3ACT field.
	RTC_MODE0_TAMPCTRL_IN3ACT_Msk = 0xc0
	// Off (Disabled)
	RTC_MODE0_TAMPCTRL_IN3ACT_OFF = 0x0
	// Wake without timestamp
	RTC_MODE0_TAMPCTRL_IN3ACT_WAKE = 0x1
	// Capture timestamp
	RTC_MODE0_TAMPCTRL_IN3ACT_CAPTURE = 0x2
	// Compare IN3 to OUT
	RTC_MODE0_TAMPCTRL_IN3ACT_ACTL = 0x3
	// Position of IN4ACT field.
	RTC_MODE0_TAMPCTRL_IN4ACT_Pos = 0x8
	// Bit mask of IN4ACT field.
	RTC_MODE0_TAMPCTRL_IN4ACT_Msk = 0x300
	// Off (Disabled)
	RTC_MODE0_TAMPCTRL_IN4ACT_OFF = 0x0
	// Wake without timestamp
	RTC_MODE0_TAMPCTRL_IN4ACT_WAKE = 0x1
	// Capture timestamp
	RTC_MODE0_TAMPCTRL_IN4ACT_CAPTURE = 0x2
	// Compare IN4 to OUT
	RTC_MODE0_TAMPCTRL_IN4ACT_ACTL = 0x3
	// Position of TAMLVL0 field.
	RTC_MODE0_TAMPCTRL_TAMLVL0_Pos = 0x10
	// Bit mask of TAMLVL0 field.
	RTC_MODE0_TAMPCTRL_TAMLVL0_Msk = 0x10000
	// Bit TAMLVL0.
	RTC_MODE0_TAMPCTRL_TAMLVL0 = 0x10000
	// Position of TAMLVL1 field.
	RTC_MODE0_TAMPCTRL_TAMLVL1_Pos = 0x11
	// Bit mask of TAMLVL1 field.
	RTC_MODE0_TAMPCTRL_TAMLVL1_Msk = 0x20000
	// Bit TAMLVL1.
	RTC_MODE0_TAMPCTRL_TAMLVL1 = 0x20000
	// Position of TAMLVL2 field.
	RTC_MODE0_TAMPCTRL_TAMLVL2_Pos = 0x12
	// Bit mask of TAMLVL2 field.
	RTC_MODE0_TAMPCTRL_TAMLVL2_Msk = 0x40000
	// Bit TAMLVL2.
	RTC_MODE0_TAMPCTRL_TAMLVL2 = 0x40000
	// Position of TAMLVL3 field.
	RTC_MODE0_TAMPCTRL_TAMLVL3_Pos = 0x13
	// Bit mask of TAMLVL3 field.
	RTC_MODE0_TAMPCTRL_TAMLVL3_Msk = 0x80000
	// Bit TAMLVL3.
	RTC_MODE0_TAMPCTRL_TAMLVL3 = 0x80000
	// Position of TAMLVL4 field.
	RTC_MODE0_TAMPCTRL_TAMLVL4_Pos = 0x14
	// Bit mask of TAMLVL4 field.
	RTC_MODE0_TAMPCTRL_TAMLVL4_Msk = 0x100000
	// Bit TAMLVL4.
	RTC_MODE0_TAMPCTRL_TAMLVL4 = 0x100000
	// Position of DEBNC0 field.
	RTC_MODE0_TAMPCTRL_DEBNC0_Pos = 0x18
	// Bit mask of DEBNC0 field.
	RTC_MODE0_TAMPCTRL_DEBNC0_Msk = 0x1000000
	// Bit DEBNC0.
	RTC_MODE0_TAMPCTRL_DEBNC0 = 0x1000000
	// Position of DEBNC1 field.
	RTC_MODE0_TAMPCTRL_DEBNC1_Pos = 0x19
	// Bit mask of DEBNC1 field.
	RTC_MODE0_TAMPCTRL_DEBNC1_Msk = 0x2000000
	// Bit DEBNC1.
	RTC_MODE0_TAMPCTRL_DEBNC1 = 0x2000000
	// Position of DEBNC2 field.
	RTC_MODE0_TAMPCTRL_DEBNC2_Pos = 0x1a
	// Bit mask of DEBNC2 field.
	RTC_MODE0_TAMPCTRL_DEBNC2_Msk = 0x4000000
	// Bit DEBNC2.
	RTC_MODE0_TAMPCTRL_DEBNC2 = 0x4000000
	// Position of DEBNC3 field.
	RTC_MODE0_TAMPCTRL_DEBNC3_Pos = 0x1b
	// Bit mask of DEBNC3 field.
	RTC_MODE0_TAMPCTRL_DEBNC3_Msk = 0x8000000
	// Bit DEBNC3.
	RTC_MODE0_TAMPCTRL_DEBNC3 = 0x8000000
	// Position of DEBNC4 field.
	RTC_MODE0_TAMPCTRL_DEBNC4_Pos = 0x1c
	// Bit mask of DEBNC4 field.
	RTC_MODE0_TAMPCTRL_DEBNC4_Msk = 0x10000000
	// Bit DEBNC4.
	RTC_MODE0_TAMPCTRL_DEBNC4 = 0x10000000

	// TIMESTAMP: MODE0 Timestamp
	// Position of COUNT field.
	RTC_MODE0_TIMESTAMP_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	RTC_MODE0_TIMESTAMP_COUNT_Msk = 0xffffffff

	// TAMPID: Tamper ID
	// Position of TAMPID0 field.
	RTC_MODE0_TAMPID_TAMPID0_Pos = 0x0
	// Bit mask of TAMPID0 field.
	RTC_MODE0_TAMPID_TAMPID0_Msk = 0x1
	// Bit TAMPID0.
	RTC_MODE0_TAMPID_TAMPID0 = 0x1
	// Position of TAMPID1 field.
	RTC_MODE0_TAMPID_TAMPID1_Pos = 0x1
	// Bit mask of TAMPID1 field.
	RTC_MODE0_TAMPID_TAMPID1_Msk = 0x2
	// Bit TAMPID1.
	RTC_MODE0_TAMPID_TAMPID1 = 0x2
	// Position of TAMPID2 field.
	RTC_MODE0_TAMPID_TAMPID2_Pos = 0x2
	// Bit mask of TAMPID2 field.
	RTC_MODE0_TAMPID_TAMPID2_Msk = 0x4
	// Bit TAMPID2.
	RTC_MODE0_TAMPID_TAMPID2 = 0x4
	// Position of TAMPID3 field.
	RTC_MODE0_TAMPID_TAMPID3_Pos = 0x3
	// Bit mask of TAMPID3 field.
	RTC_MODE0_TAMPID_TAMPID3_Msk = 0x8
	// Bit TAMPID3.
	RTC_MODE0_TAMPID_TAMPID3 = 0x8
	// Position of TAMPID4 field.
	RTC_MODE0_TAMPID_TAMPID4_Pos = 0x4
	// Bit mask of TAMPID4 field.
	RTC_MODE0_TAMPID_TAMPID4_Msk = 0x10
	// Bit TAMPID4.
	RTC_MODE0_TAMPID_TAMPID4 = 0x10
	// Position of TAMPEVT field.
	RTC_MODE0_TAMPID_TAMPEVT_Pos = 0x1f
	// Bit mask of TAMPEVT field.
	RTC_MODE0_TAMPID_TAMPEVT_Msk = 0x80000000
	// Bit TAMPEVT.
	RTC_MODE0_TAMPID_TAMPEVT = 0x80000000

	// BKUP: Backup
	// Position of BKUP field.
	RTC_MODE0_BKUP_BKUP_Pos = 0x0
	// Bit mask of BKUP field.
	RTC_MODE0_BKUP_BKUP_Msk = 0xffffffff
)

// Constants for RTC_MODE1: Real-Time Counter - MODE1
const (
	// CTRLA: MODE1 Control A
	// Position of SWRST field.
	RTC_MODE1_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	RTC_MODE1_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	RTC_MODE1_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	RTC_MODE1_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	RTC_MODE1_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	RTC_MODE1_CTRLA_ENABLE = 0x2
	// Position of MODE field.
	RTC_MODE1_CTRLA_MODE_Pos = 0x2
	// Bit mask of MODE field.
	RTC_MODE1_CTRLA_MODE_Msk = 0xc
	// Mode 0: 32-bit Counter
	RTC_MODE1_CTRLA_MODE_COUNT32 = 0x0
	// Mode 1: 16-bit Counter
	RTC_MODE1_CTRLA_MODE_COUNT16 = 0x1
	// Mode 2: Clock/Calendar
	RTC_MODE1_CTRLA_MODE_CLOCK = 0x2
	// Position of PRESCALER field.
	RTC_MODE1_CTRLA_PRESCALER_Pos = 0x8
	// Bit mask of PRESCALER field.
	RTC_MODE1_CTRLA_PRESCALER_Msk = 0xf00
	// CLK_RTC_CNT = GCLK_RTC/1
	RTC_MODE1_CTRLA_PRESCALER_OFF = 0x0
	// CLK_RTC_CNT = GCLK_RTC/1
	RTC_MODE1_CTRLA_PRESCALER_DIV1 = 0x1
	// CLK_RTC_CNT = GCLK_RTC/2
	RTC_MODE1_CTRLA_PRESCALER_DIV2 = 0x2
	// CLK_RTC_CNT = GCLK_RTC/4
	RTC_MODE1_CTRLA_PRESCALER_DIV4 = 0x3
	// CLK_RTC_CNT = GCLK_RTC/8
	RTC_MODE1_CTRLA_PRESCALER_DIV8 = 0x4
	// CLK_RTC_CNT = GCLK_RTC/16
	RTC_MODE1_CTRLA_PRESCALER_DIV16 = 0x5
	// CLK_RTC_CNT = GCLK_RTC/32
	RTC_MODE1_CTRLA_PRESCALER_DIV32 = 0x6
	// CLK_RTC_CNT = GCLK_RTC/64
	RTC_MODE1_CTRLA_PRESCALER_DIV64 = 0x7
	// CLK_RTC_CNT = GCLK_RTC/128
	RTC_MODE1_CTRLA_PRESCALER_DIV128 = 0x8
	// CLK_RTC_CNT = GCLK_RTC/256
	RTC_MODE1_CTRLA_PRESCALER_DIV256 = 0x9
	// CLK_RTC_CNT = GCLK_RTC/512
	RTC_MODE1_CTRLA_PRESCALER_DIV512 = 0xa
	// CLK_RTC_CNT = GCLK_RTC/1024
	RTC_MODE1_CTRLA_PRESCALER_DIV1024 = 0xb
	// Position of BKTRST field.
	RTC_MODE1_CTRLA_BKTRST_Pos = 0xd
	// Bit mask of BKTRST field.
	RTC_MODE1_CTRLA_BKTRST_Msk = 0x2000
	// Bit BKTRST.
	RTC_MODE1_CTRLA_BKTRST = 0x2000
	// Position of GPTRST field.
	RTC_MODE1_CTRLA_GPTRST_Pos = 0xe
	// Bit mask of GPTRST field.
	RTC_MODE1_CTRLA_GPTRST_Msk = 0x4000
	// Bit GPTRST.
	RTC_MODE1_CTRLA_GPTRST = 0x4000
	// Position of COUNTSYNC field.
	RTC_MODE1_CTRLA_COUNTSYNC_Pos = 0xf
	// Bit mask of COUNTSYNC field.
	RTC_MODE1_CTRLA_COUNTSYNC_Msk = 0x8000
	// Bit COUNTSYNC.
	RTC_MODE1_CTRLA_COUNTSYNC = 0x8000

	// CTRLB: MODE1 Control B
	// Position of GP0EN field.
	RTC_MODE1_CTRLB_GP0EN_Pos = 0x0
	// Bit mask of GP0EN field.
	RTC_MODE1_CTRLB_GP0EN_Msk = 0x1
	// Bit GP0EN.
	RTC_MODE1_CTRLB_GP0EN = 0x1
	// Position of GP2EN field.
	RTC_MODE1_CTRLB_GP2EN_Pos = 0x1
	// Bit mask of GP2EN field.
	RTC_MODE1_CTRLB_GP2EN_Msk = 0x2
	// Bit GP2EN.
	RTC_MODE1_CTRLB_GP2EN = 0x2
	// Position of DEBMAJ field.
	RTC_MODE1_CTRLB_DEBMAJ_Pos = 0x4
	// Bit mask of DEBMAJ field.
	RTC_MODE1_CTRLB_DEBMAJ_Msk = 0x10
	// Bit DEBMAJ.
	RTC_MODE1_CTRLB_DEBMAJ = 0x10
	// Position of DEBASYNC field.
	RTC_MODE1_CTRLB_DEBASYNC_Pos = 0x5
	// Bit mask of DEBASYNC field.
	RTC_MODE1_CTRLB_DEBASYNC_Msk = 0x20
	// Bit DEBASYNC.
	RTC_MODE1_CTRLB_DEBASYNC = 0x20
	// Position of RTCOUT field.
	RTC_MODE1_CTRLB_RTCOUT_Pos = 0x6
	// Bit mask of RTCOUT field.
	RTC_MODE1_CTRLB_RTCOUT_Msk = 0x40
	// Bit RTCOUT.
	RTC_MODE1_CTRLB_RTCOUT = 0x40
	// Position of DMAEN field.
	RTC_MODE1_CTRLB_DMAEN_Pos = 0x7
	// Bit mask of DMAEN field.
	RTC_MODE1_CTRLB_DMAEN_Msk = 0x80
	// Bit DMAEN.
	RTC_MODE1_CTRLB_DMAEN = 0x80
	// Position of DEBF field.
	RTC_MODE1_CTRLB_DEBF_Pos = 0x8
	// Bit mask of DEBF field.
	RTC_MODE1_CTRLB_DEBF_Msk = 0x700
	// CLK_RTC_DEB = CLK_RTC/2
	RTC_MODE1_CTRLB_DEBF_DIV2 = 0x0
	// CLK_RTC_DEB = CLK_RTC/4
	RTC_MODE1_CTRLB_DEBF_DIV4 = 0x1
	// CLK_RTC_DEB = CLK_RTC/8
	RTC_MODE1_CTRLB_DEBF_DIV8 = 0x2
	// CLK_RTC_DEB = CLK_RTC/16
	RTC_MODE1_CTRLB_DEBF_DIV16 = 0x3
	// CLK_RTC_DEB = CLK_RTC/32
	RTC_MODE1_CTRLB_DEBF_DIV32 = 0x4
	// CLK_RTC_DEB = CLK_RTC/64
	RTC_MODE1_CTRLB_DEBF_DIV64 = 0x5
	// CLK_RTC_DEB = CLK_RTC/128
	RTC_MODE1_CTRLB_DEBF_DIV128 = 0x6
	// CLK_RTC_DEB = CLK_RTC/256
	RTC_MODE1_CTRLB_DEBF_DIV256 = 0x7
	// Position of ACTF field.
	RTC_MODE1_CTRLB_ACTF_Pos = 0xc
	// Bit mask of ACTF field.
	RTC_MODE1_CTRLB_ACTF_Msk = 0x7000
	// CLK_RTC_OUT = CLK_RTC/2
	RTC_MODE1_CTRLB_ACTF_DIV2 = 0x0
	// CLK_RTC_OUT = CLK_RTC/4
	RTC_MODE1_CTRLB_ACTF_DIV4 = 0x1
	// CLK_RTC_OUT = CLK_RTC/8
	RTC_MODE1_CTRLB_ACTF_DIV8 = 0x2
	// CLK_RTC_OUT = CLK_RTC/16
	RTC_MODE1_CTRLB_ACTF_DIV16 = 0x3
	// CLK_RTC_OUT = CLK_RTC/32
	RTC_MODE1_CTRLB_ACTF_DIV32 = 0x4
	// CLK_RTC_OUT = CLK_RTC/64
	RTC_MODE1_CTRLB_ACTF_DIV64 = 0x5
	// CLK_RTC_OUT = CLK_RTC/128
	RTC_MODE1_CTRLB_ACTF_DIV128 = 0x6
	// CLK_RTC_OUT = CLK_RTC/256
	RTC_MODE1_CTRLB_ACTF_DIV256 = 0x7

	// EVCTRL: MODE1 Event Control
	// Position of PEREO0 field.
	RTC_MODE1_EVCTRL_PEREO0_Pos = 0x0
	// Bit mask of PEREO0 field.
	RTC_MODE1_EVCTRL_PEREO0_Msk = 0x1
	// Bit PEREO0.
	RTC_MODE1_EVCTRL_PEREO0 = 0x1
	// Position of PEREO1 field.
	RTC_MODE1_EVCTRL_PEREO1_Pos = 0x1
	// Bit mask of PEREO1 field.
	RTC_MODE1_EVCTRL_PEREO1_Msk = 0x2
	// Bit PEREO1.
	RTC_MODE1_EVCTRL_PEREO1 = 0x2
	// Position of PEREO2 field.
	RTC_MODE1_EVCTRL_PEREO2_Pos = 0x2
	// Bit mask of PEREO2 field.
	RTC_MODE1_EVCTRL_PEREO2_Msk = 0x4
	// Bit PEREO2.
	RTC_MODE1_EVCTRL_PEREO2 = 0x4
	// Position of PEREO3 field.
	RTC_MODE1_EVCTRL_PEREO3_Pos = 0x3
	// Bit mask of PEREO3 field.
	RTC_MODE1_EVCTRL_PEREO3_Msk = 0x8
	// Bit PEREO3.
	RTC_MODE1_EVCTRL_PEREO3 = 0x8
	// Position of PEREO4 field.
	RTC_MODE1_EVCTRL_PEREO4_Pos = 0x4
	// Bit mask of PEREO4 field.
	RTC_MODE1_EVCTRL_PEREO4_Msk = 0x10
	// Bit PEREO4.
	RTC_MODE1_EVCTRL_PEREO4 = 0x10
	// Position of PEREO5 field.
	RTC_MODE1_EVCTRL_PEREO5_Pos = 0x5
	// Bit mask of PEREO5 field.
	RTC_MODE1_EVCTRL_PEREO5_Msk = 0x20
	// Bit PEREO5.
	RTC_MODE1_EVCTRL_PEREO5 = 0x20
	// Position of PEREO6 field.
	RTC_MODE1_EVCTRL_PEREO6_Pos = 0x6
	// Bit mask of PEREO6 field.
	RTC_MODE1_EVCTRL_PEREO6_Msk = 0x40
	// Bit PEREO6.
	RTC_MODE1_EVCTRL_PEREO6 = 0x40
	// Position of PEREO7 field.
	RTC_MODE1_EVCTRL_PEREO7_Pos = 0x7
	// Bit mask of PEREO7 field.
	RTC_MODE1_EVCTRL_PEREO7_Msk = 0x80
	// Bit PEREO7.
	RTC_MODE1_EVCTRL_PEREO7 = 0x80
	// Position of CMPEO0 field.
	RTC_MODE1_EVCTRL_CMPEO0_Pos = 0x8
	// Bit mask of CMPEO0 field.
	RTC_MODE1_EVCTRL_CMPEO0_Msk = 0x100
	// Bit CMPEO0.
	RTC_MODE1_EVCTRL_CMPEO0 = 0x100
	// Position of CMPEO1 field.
	RTC_MODE1_EVCTRL_CMPEO1_Pos = 0x9
	// Bit mask of CMPEO1 field.
	RTC_MODE1_EVCTRL_CMPEO1_Msk = 0x200
	// Bit CMPEO1.
	RTC_MODE1_EVCTRL_CMPEO1 = 0x200
	// Position of CMPEO2 field.
	RTC_MODE1_EVCTRL_CMPEO2_Pos = 0xa
	// Bit mask of CMPEO2 field.
	RTC_MODE1_EVCTRL_CMPEO2_Msk = 0x400
	// Bit CMPEO2.
	RTC_MODE1_EVCTRL_CMPEO2 = 0x400
	// Position of CMPEO3 field.
	RTC_MODE1_EVCTRL_CMPEO3_Pos = 0xb
	// Bit mask of CMPEO3 field.
	RTC_MODE1_EVCTRL_CMPEO3_Msk = 0x800
	// Bit CMPEO3.
	RTC_MODE1_EVCTRL_CMPEO3 = 0x800
	// Position of TAMPEREO field.
	RTC_MODE1_EVCTRL_TAMPEREO_Pos = 0xe
	// Bit mask of TAMPEREO field.
	RTC_MODE1_EVCTRL_TAMPEREO_Msk = 0x4000
	// Bit TAMPEREO.
	RTC_MODE1_EVCTRL_TAMPEREO = 0x4000
	// Position of OVFEO field.
	RTC_MODE1_EVCTRL_OVFEO_Pos = 0xf
	// Bit mask of OVFEO field.
	RTC_MODE1_EVCTRL_OVFEO_Msk = 0x8000
	// Bit OVFEO.
	RTC_MODE1_EVCTRL_OVFEO = 0x8000
	// Position of TAMPEVEI field.
	RTC_MODE1_EVCTRL_TAMPEVEI_Pos = 0x10
	// Bit mask of TAMPEVEI field.
	RTC_MODE1_EVCTRL_TAMPEVEI_Msk = 0x10000
	// Bit TAMPEVEI.
	RTC_MODE1_EVCTRL_TAMPEVEI = 0x10000

	// INTENCLR: MODE1 Interrupt Enable Clear
	// Position of PER0 field.
	RTC_MODE1_INTENCLR_PER0_Pos = 0x0
	// Bit mask of PER0 field.
	RTC_MODE1_INTENCLR_PER0_Msk = 0x1
	// Bit PER0.
	RTC_MODE1_INTENCLR_PER0 = 0x1
	// Position of PER1 field.
	RTC_MODE1_INTENCLR_PER1_Pos = 0x1
	// Bit mask of PER1 field.
	RTC_MODE1_INTENCLR_PER1_Msk = 0x2
	// Bit PER1.
	RTC_MODE1_INTENCLR_PER1 = 0x2
	// Position of PER2 field.
	RTC_MODE1_INTENCLR_PER2_Pos = 0x2
	// Bit mask of PER2 field.
	RTC_MODE1_INTENCLR_PER2_Msk = 0x4
	// Bit PER2.
	RTC_MODE1_INTENCLR_PER2 = 0x4
	// Position of PER3 field.
	RTC_MODE1_INTENCLR_PER3_Pos = 0x3
	// Bit mask of PER3 field.
	RTC_MODE1_INTENCLR_PER3_Msk = 0x8
	// Bit PER3.
	RTC_MODE1_INTENCLR_PER3 = 0x8
	// Position of PER4 field.
	RTC_MODE1_INTENCLR_PER4_Pos = 0x4
	// Bit mask of PER4 field.
	RTC_MODE1_INTENCLR_PER4_Msk = 0x10
	// Bit PER4.
	RTC_MODE1_INTENCLR_PER4 = 0x10
	// Position of PER5 field.
	RTC_MODE1_INTENCLR_PER5_Pos = 0x5
	// Bit mask of PER5 field.
	RTC_MODE1_INTENCLR_PER5_Msk = 0x20
	// Bit PER5.
	RTC_MODE1_INTENCLR_PER5 = 0x20
	// Position of PER6 field.
	RTC_MODE1_INTENCLR_PER6_Pos = 0x6
	// Bit mask of PER6 field.
	RTC_MODE1_INTENCLR_PER6_Msk = 0x40
	// Bit PER6.
	RTC_MODE1_INTENCLR_PER6 = 0x40
	// Position of PER7 field.
	RTC_MODE1_INTENCLR_PER7_Pos = 0x7
	// Bit mask of PER7 field.
	RTC_MODE1_INTENCLR_PER7_Msk = 0x80
	// Bit PER7.
	RTC_MODE1_INTENCLR_PER7 = 0x80
	// Position of CMP0 field.
	RTC_MODE1_INTENCLR_CMP0_Pos = 0x8
	// Bit mask of CMP0 field.
	RTC_MODE1_INTENCLR_CMP0_Msk = 0x100
	// Bit CMP0.
	RTC_MODE1_INTENCLR_CMP0 = 0x100
	// Position of CMP1 field.
	RTC_MODE1_INTENCLR_CMP1_Pos = 0x9
	// Bit mask of CMP1 field.
	RTC_MODE1_INTENCLR_CMP1_Msk = 0x200
	// Bit CMP1.
	RTC_MODE1_INTENCLR_CMP1 = 0x200
	// Position of CMP2 field.
	RTC_MODE1_INTENCLR_CMP2_Pos = 0xa
	// Bit mask of CMP2 field.
	RTC_MODE1_INTENCLR_CMP2_Msk = 0x400
	// Bit CMP2.
	RTC_MODE1_INTENCLR_CMP2 = 0x400
	// Position of CMP3 field.
	RTC_MODE1_INTENCLR_CMP3_Pos = 0xb
	// Bit mask of CMP3 field.
	RTC_MODE1_INTENCLR_CMP3_Msk = 0x800
	// Bit CMP3.
	RTC_MODE1_INTENCLR_CMP3 = 0x800
	// Position of TAMPER field.
	RTC_MODE1_INTENCLR_TAMPER_Pos = 0xe
	// Bit mask of TAMPER field.
	RTC_MODE1_INTENCLR_TAMPER_Msk = 0x4000
	// Bit TAMPER.
	RTC_MODE1_INTENCLR_TAMPER = 0x4000
	// Position of OVF field.
	RTC_MODE1_INTENCLR_OVF_Pos = 0xf
	// Bit mask of OVF field.
	RTC_MODE1_INTENCLR_OVF_Msk = 0x8000
	// Bit OVF.
	RTC_MODE1_INTENCLR_OVF = 0x8000

	// INTENSET: MODE1 Interrupt Enable Set
	// Position of PER0 field.
	RTC_MODE1_INTENSET_PER0_Pos = 0x0
	// Bit mask of PER0 field.
	RTC_MODE1_INTENSET_PER0_Msk = 0x1
	// Bit PER0.
	RTC_MODE1_INTENSET_PER0 = 0x1
	// Position of PER1 field.
	RTC_MODE1_INTENSET_PER1_Pos = 0x1
	// Bit mask of PER1 field.
	RTC_MODE1_INTENSET_PER1_Msk = 0x2
	// Bit PER1.
	RTC_MODE1_INTENSET_PER1 = 0x2
	// Position of PER2 field.
	RTC_MODE1_INTENSET_PER2_Pos = 0x2
	// Bit mask of PER2 field.
	RTC_MODE1_INTENSET_PER2_Msk = 0x4
	// Bit PER2.
	RTC_MODE1_INTENSET_PER2 = 0x4
	// Position of PER3 field.
	RTC_MODE1_INTENSET_PER3_Pos = 0x3
	// Bit mask of PER3 field.
	RTC_MODE1_INTENSET_PER3_Msk = 0x8
	// Bit PER3.
	RTC_MODE1_INTENSET_PER3 = 0x8
	// Position of PER4 field.
	RTC_MODE1_INTENSET_PER4_Pos = 0x4
	// Bit mask of PER4 field.
	RTC_MODE1_INTENSET_PER4_Msk = 0x10
	// Bit PER4.
	RTC_MODE1_INTENSET_PER4 = 0x10
	// Position of PER5 field.
	RTC_MODE1_INTENSET_PER5_Pos = 0x5
	// Bit mask of PER5 field.
	RTC_MODE1_INTENSET_PER5_Msk = 0x20
	// Bit PER5.
	RTC_MODE1_INTENSET_PER5 = 0x20
	// Position of PER6 field.
	RTC_MODE1_INTENSET_PER6_Pos = 0x6
	// Bit mask of PER6 field.
	RTC_MODE1_INTENSET_PER6_Msk = 0x40
	// Bit PER6.
	RTC_MODE1_INTENSET_PER6 = 0x40
	// Position of PER7 field.
	RTC_MODE1_INTENSET_PER7_Pos = 0x7
	// Bit mask of PER7 field.
	RTC_MODE1_INTENSET_PER7_Msk = 0x80
	// Bit PER7.
	RTC_MODE1_INTENSET_PER7 = 0x80
	// Position of CMP0 field.
	RTC_MODE1_INTENSET_CMP0_Pos = 0x8
	// Bit mask of CMP0 field.
	RTC_MODE1_INTENSET_CMP0_Msk = 0x100
	// Bit CMP0.
	RTC_MODE1_INTENSET_CMP0 = 0x100
	// Position of CMP1 field.
	RTC_MODE1_INTENSET_CMP1_Pos = 0x9
	// Bit mask of CMP1 field.
	RTC_MODE1_INTENSET_CMP1_Msk = 0x200
	// Bit CMP1.
	RTC_MODE1_INTENSET_CMP1 = 0x200
	// Position of CMP2 field.
	RTC_MODE1_INTENSET_CMP2_Pos = 0xa
	// Bit mask of CMP2 field.
	RTC_MODE1_INTENSET_CMP2_Msk = 0x400
	// Bit CMP2.
	RTC_MODE1_INTENSET_CMP2 = 0x400
	// Position of CMP3 field.
	RTC_MODE1_INTENSET_CMP3_Pos = 0xb
	// Bit mask of CMP3 field.
	RTC_MODE1_INTENSET_CMP3_Msk = 0x800
	// Bit CMP3.
	RTC_MODE1_INTENSET_CMP3 = 0x800
	// Position of TAMPER field.
	RTC_MODE1_INTENSET_TAMPER_Pos = 0xe
	// Bit mask of TAMPER field.
	RTC_MODE1_INTENSET_TAMPER_Msk = 0x4000
	// Bit TAMPER.
	RTC_MODE1_INTENSET_TAMPER = 0x4000
	// Position of OVF field.
	RTC_MODE1_INTENSET_OVF_Pos = 0xf
	// Bit mask of OVF field.
	RTC_MODE1_INTENSET_OVF_Msk = 0x8000
	// Bit OVF.
	RTC_MODE1_INTENSET_OVF = 0x8000

	// INTFLAG: MODE1 Interrupt Flag Status and Clear
	// Position of PER0 field.
	RTC_MODE1_INTFLAG_PER0_Pos = 0x0
	// Bit mask of PER0 field.
	RTC_MODE1_INTFLAG_PER0_Msk = 0x1
	// Bit PER0.
	RTC_MODE1_INTFLAG_PER0 = 0x1
	// Position of PER1 field.
	RTC_MODE1_INTFLAG_PER1_Pos = 0x1
	// Bit mask of PER1 field.
	RTC_MODE1_INTFLAG_PER1_Msk = 0x2
	// Bit PER1.
	RTC_MODE1_INTFLAG_PER1 = 0x2
	// Position of PER2 field.
	RTC_MODE1_INTFLAG_PER2_Pos = 0x2
	// Bit mask of PER2 field.
	RTC_MODE1_INTFLAG_PER2_Msk = 0x4
	// Bit PER2.
	RTC_MODE1_INTFLAG_PER2 = 0x4
	// Position of PER3 field.
	RTC_MODE1_INTFLAG_PER3_Pos = 0x3
	// Bit mask of PER3 field.
	RTC_MODE1_INTFLAG_PER3_Msk = 0x8
	// Bit PER3.
	RTC_MODE1_INTFLAG_PER3 = 0x8
	// Position of PER4 field.
	RTC_MODE1_INTFLAG_PER4_Pos = 0x4
	// Bit mask of PER4 field.
	RTC_MODE1_INTFLAG_PER4_Msk = 0x10
	// Bit PER4.
	RTC_MODE1_INTFLAG_PER4 = 0x10
	// Position of PER5 field.
	RTC_MODE1_INTFLAG_PER5_Pos = 0x5
	// Bit mask of PER5 field.
	RTC_MODE1_INTFLAG_PER5_Msk = 0x20
	// Bit PER5.
	RTC_MODE1_INTFLAG_PER5 = 0x20
	// Position of PER6 field.
	RTC_MODE1_INTFLAG_PER6_Pos = 0x6
	// Bit mask of PER6 field.
	RTC_MODE1_INTFLAG_PER6_Msk = 0x40
	// Bit PER6.
	RTC_MODE1_INTFLAG_PER6 = 0x40
	// Position of PER7 field.
	RTC_MODE1_INTFLAG_PER7_Pos = 0x7
	// Bit mask of PER7 field.
	RTC_MODE1_INTFLAG_PER7_Msk = 0x80
	// Bit PER7.
	RTC_MODE1_INTFLAG_PER7 = 0x80
	// Position of CMP0 field.
	RTC_MODE1_INTFLAG_CMP0_Pos = 0x8
	// Bit mask of CMP0 field.
	RTC_MODE1_INTFLAG_CMP0_Msk = 0x100
	// Bit CMP0.
	RTC_MODE1_INTFLAG_CMP0 = 0x100
	// Position of CMP1 field.
	RTC_MODE1_INTFLAG_CMP1_Pos = 0x9
	// Bit mask of CMP1 field.
	RTC_MODE1_INTFLAG_CMP1_Msk = 0x200
	// Bit CMP1.
	RTC_MODE1_INTFLAG_CMP1 = 0x200
	// Position of CMP2 field.
	RTC_MODE1_INTFLAG_CMP2_Pos = 0xa
	// Bit mask of CMP2 field.
	RTC_MODE1_INTFLAG_CMP2_Msk = 0x400
	// Bit CMP2.
	RTC_MODE1_INTFLAG_CMP2 = 0x400
	// Position of CMP3 field.
	RTC_MODE1_INTFLAG_CMP3_Pos = 0xb
	// Bit mask of CMP3 field.
	RTC_MODE1_INTFLAG_CMP3_Msk = 0x800
	// Bit CMP3.
	RTC_MODE1_INTFLAG_CMP3 = 0x800
	// Position of TAMPER field.
	RTC_MODE1_INTFLAG_TAMPER_Pos = 0xe
	// Bit mask of TAMPER field.
	RTC_MODE1_INTFLAG_TAMPER_Msk = 0x4000
	// Bit TAMPER.
	RTC_MODE1_INTFLAG_TAMPER = 0x4000
	// Position of OVF field.
	RTC_MODE1_INTFLAG_OVF_Pos = 0xf
	// Bit mask of OVF field.
	RTC_MODE1_INTFLAG_OVF_Msk = 0x8000
	// Bit OVF.
	RTC_MODE1_INTFLAG_OVF = 0x8000

	// DBGCTRL: Debug Control
	// Position of DBGRUN field.
	RTC_MODE1_DBGCTRL_DBGRUN_Pos = 0x0
	// Bit mask of DBGRUN field.
	RTC_MODE1_DBGCTRL_DBGRUN_Msk = 0x1
	// Bit DBGRUN.
	RTC_MODE1_DBGCTRL_DBGRUN = 0x1

	// SYNCBUSY: MODE1 Synchronization Busy Status
	// Position of SWRST field.
	RTC_MODE1_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	RTC_MODE1_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	RTC_MODE1_SYNCBUSY_SWRST = 0x1
	// Position of ENABLE field.
	RTC_MODE1_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	RTC_MODE1_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	RTC_MODE1_SYNCBUSY_ENABLE = 0x2
	// Position of FREQCORR field.
	RTC_MODE1_SYNCBUSY_FREQCORR_Pos = 0x2
	// Bit mask of FREQCORR field.
	RTC_MODE1_SYNCBUSY_FREQCORR_Msk = 0x4
	// Bit FREQCORR.
	RTC_MODE1_SYNCBUSY_FREQCORR = 0x4
	// Position of COUNT field.
	RTC_MODE1_SYNCBUSY_COUNT_Pos = 0x3
	// Bit mask of COUNT field.
	RTC_MODE1_SYNCBUSY_COUNT_Msk = 0x8
	// Bit COUNT.
	RTC_MODE1_SYNCBUSY_COUNT = 0x8
	// Position of PER field.
	RTC_MODE1_SYNCBUSY_PER_Pos = 0x4
	// Bit mask of PER field.
	RTC_MODE1_SYNCBUSY_PER_Msk = 0x10
	// Bit PER.
	RTC_MODE1_SYNCBUSY_PER = 0x10
	// Position of COMP0 field.
	RTC_MODE1_SYNCBUSY_COMP0_Pos = 0x5
	// Bit mask of COMP0 field.
	RTC_MODE1_SYNCBUSY_COMP0_Msk = 0x20
	// Bit COMP0.
	RTC_MODE1_SYNCBUSY_COMP0 = 0x20
	// Position of COMP1 field.
	RTC_MODE1_SYNCBUSY_COMP1_Pos = 0x6
	// Bit mask of COMP1 field.
	RTC_MODE1_SYNCBUSY_COMP1_Msk = 0x40
	// Bit COMP1.
	RTC_MODE1_SYNCBUSY_COMP1 = 0x40
	// Position of COMP2 field.
	RTC_MODE1_SYNCBUSY_COMP2_Pos = 0x7
	// Bit mask of COMP2 field.
	RTC_MODE1_SYNCBUSY_COMP2_Msk = 0x80
	// Bit COMP2.
	RTC_MODE1_SYNCBUSY_COMP2 = 0x80
	// Position of COMP3 field.
	RTC_MODE1_SYNCBUSY_COMP3_Pos = 0x8
	// Bit mask of COMP3 field.
	RTC_MODE1_SYNCBUSY_COMP3_Msk = 0x100
	// Bit COMP3.
	RTC_MODE1_SYNCBUSY_COMP3 = 0x100
	// Position of COUNTSYNC field.
	RTC_MODE1_SYNCBUSY_COUNTSYNC_Pos = 0xf
	// Bit mask of COUNTSYNC field.
	RTC_MODE1_SYNCBUSY_COUNTSYNC_Msk = 0x8000
	// Bit COUNTSYNC.
	RTC_MODE1_SYNCBUSY_COUNTSYNC = 0x8000
	// Position of GP0 field.
	RTC_MODE1_SYNCBUSY_GP0_Pos = 0x10
	// Bit mask of GP0 field.
	RTC_MODE1_SYNCBUSY_GP0_Msk = 0x10000
	// Bit GP0.
	RTC_MODE1_SYNCBUSY_GP0 = 0x10000
	// Position of GP1 field.
	RTC_MODE1_SYNCBUSY_GP1_Pos = 0x11
	// Bit mask of GP1 field.
	RTC_MODE1_SYNCBUSY_GP1_Msk = 0x20000
	// Bit GP1.
	RTC_MODE1_SYNCBUSY_GP1 = 0x20000
	// Position of GP2 field.
	RTC_MODE1_SYNCBUSY_GP2_Pos = 0x12
	// Bit mask of GP2 field.
	RTC_MODE1_SYNCBUSY_GP2_Msk = 0x40000
	// Bit GP2.
	RTC_MODE1_SYNCBUSY_GP2 = 0x40000
	// Position of GP3 field.
	RTC_MODE1_SYNCBUSY_GP3_Pos = 0x13
	// Bit mask of GP3 field.
	RTC_MODE1_SYNCBUSY_GP3_Msk = 0x80000
	// Bit GP3.
	RTC_MODE1_SYNCBUSY_GP3 = 0x80000

	// FREQCORR: Frequency Correction
	// Position of VALUE field.
	RTC_MODE1_FREQCORR_VALUE_Pos = 0x0
	// Bit mask of VALUE field.
	RTC_MODE1_FREQCORR_VALUE_Msk = 0x7f
	// Position of SIGN field.
	RTC_MODE1_FREQCORR_SIGN_Pos = 0x7
	// Bit mask of SIGN field.
	RTC_MODE1_FREQCORR_SIGN_Msk = 0x80
	// Bit SIGN.
	RTC_MODE1_FREQCORR_SIGN = 0x80

	// COUNT: MODE1 Counter Value
	// Position of COUNT field.
	RTC_MODE1_COUNT_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	RTC_MODE1_COUNT_COUNT_Msk = 0xffff

	// PER: MODE1 Counter Period
	// Position of PER field.
	RTC_MODE1_PER_PER_Pos = 0x0
	// Bit mask of PER field.
	RTC_MODE1_PER_PER_Msk = 0xffff

	// COMP: MODE1 Compare n Value
	// Position of COMP field.
	RTC_MODE1_COMP_COMP_Pos = 0x0
	// Bit mask of COMP field.
	RTC_MODE1_COMP_COMP_Msk = 0xffff

	// GP: General Purpose
	// Position of GP field.
	RTC_MODE1_GP_GP_Pos = 0x0
	// Bit mask of GP field.
	RTC_MODE1_GP_GP_Msk = 0xffffffff

	// TAMPCTRL: Tamper Control
	// Position of IN0ACT field.
	RTC_MODE1_TAMPCTRL_IN0ACT_Pos = 0x0
	// Bit mask of IN0ACT field.
	RTC_MODE1_TAMPCTRL_IN0ACT_Msk = 0x3
	// Off (Disabled)
	RTC_MODE1_TAMPCTRL_IN0ACT_OFF = 0x0
	// Wake without timestamp
	RTC_MODE1_TAMPCTRL_IN0ACT_WAKE = 0x1
	// Capture timestamp
	RTC_MODE1_TAMPCTRL_IN0ACT_CAPTURE = 0x2
	// Compare IN0 to OUT
	RTC_MODE1_TAMPCTRL_IN0ACT_ACTL = 0x3
	// Position of IN1ACT field.
	RTC_MODE1_TAMPCTRL_IN1ACT_Pos = 0x2
	// Bit mask of IN1ACT field.
	RTC_MODE1_TAMPCTRL_IN1ACT_Msk = 0xc
	// Off (Disabled)
	RTC_MODE1_TAMPCTRL_IN1ACT_OFF = 0x0
	// Wake without timestamp
	RTC_MODE1_TAMPCTRL_IN1ACT_WAKE = 0x1
	// Capture timestamp
	RTC_MODE1_TAMPCTRL_IN1ACT_CAPTURE = 0x2
	// Compare IN1 to OUT
	RTC_MODE1_TAMPCTRL_IN1ACT_ACTL = 0x3
	// Position of IN2ACT field.
	RTC_MODE1_TAMPCTRL_IN2ACT_Pos = 0x4
	// Bit mask of IN2ACT field.
	RTC_MODE1_TAMPCTRL_IN2ACT_Msk = 0x30
	// Off (Disabled)
	RTC_MODE1_TAMPCTRL_IN2ACT_OFF = 0x0
	// Wake without timestamp
	RTC_MODE1_TAMPCTRL_IN2ACT_WAKE = 0x1
	// Capture timestamp
	RTC_MODE1_TAMPCTRL_IN2ACT_CAPTURE = 0x2
	// Compare IN2 to OUT
	RTC_MODE1_TAMPCTRL_IN2ACT_ACTL = 0x3
	// Position of IN3ACT field.
	RTC_MODE1_TAMPCTRL_IN3ACT_Pos = 0x6
	// Bit mask of IN3ACT field.
	RTC_MODE1_TAMPCTRL_IN3ACT_Msk = 0xc0
	// Off (Disabled)
	RTC_MODE1_TAMPCTRL_IN3ACT_OFF = 0x0
	// Wake without timestamp
	RTC_MODE1_TAMPCTRL_IN3ACT_WAKE = 0x1
	// Capture timestamp
	RTC_MODE1_TAMPCTRL_IN3ACT_CAPTURE = 0x2
	// Compare IN3 to OUT
	RTC_MODE1_TAMPCTRL_IN3ACT_ACTL = 0x3
	// Position of IN4ACT field.
	RTC_MODE1_TAMPCTRL_IN4ACT_Pos = 0x8
	// Bit mask of IN4ACT field.
	RTC_MODE1_TAMPCTRL_IN4ACT_Msk = 0x300
	// Off (Disabled)
	RTC_MODE1_TAMPCTRL_IN4ACT_OFF = 0x0
	// Wake without timestamp
	RTC_MODE1_TAMPCTRL_IN4ACT_WAKE = 0x1
	// Capture timestamp
	RTC_MODE1_TAMPCTRL_IN4ACT_CAPTURE = 0x2
	// Compare IN4 to OUT
	RTC_MODE1_TAMPCTRL_IN4ACT_ACTL = 0x3
	// Position of TAMLVL0 field.
	RTC_MODE1_TAMPCTRL_TAMLVL0_Pos = 0x10
	// Bit mask of TAMLVL0 field.
	RTC_MODE1_TAMPCTRL_TAMLVL0_Msk = 0x10000
	// Bit TAMLVL0.
	RTC_MODE1_TAMPCTRL_TAMLVL0 = 0x10000
	// Position of TAMLVL1 field.
	RTC_MODE1_TAMPCTRL_TAMLVL1_Pos = 0x11
	// Bit mask of TAMLVL1 field.
	RTC_MODE1_TAMPCTRL_TAMLVL1_Msk = 0x20000
	// Bit TAMLVL1.
	RTC_MODE1_TAMPCTRL_TAMLVL1 = 0x20000
	// Position of TAMLVL2 field.
	RTC_MODE1_TAMPCTRL_TAMLVL2_Pos = 0x12
	// Bit mask of TAMLVL2 field.
	RTC_MODE1_TAMPCTRL_TAMLVL2_Msk = 0x40000
	// Bit TAMLVL2.
	RTC_MODE1_TAMPCTRL_TAMLVL2 = 0x40000
	// Position of TAMLVL3 field.
	RTC_MODE1_TAMPCTRL_TAMLVL3_Pos = 0x13
	// Bit mask of TAMLVL3 field.
	RTC_MODE1_TAMPCTRL_TAMLVL3_Msk = 0x80000
	// Bit TAMLVL3.
	RTC_MODE1_TAMPCTRL_TAMLVL3 = 0x80000
	// Position of TAMLVL4 field.
	RTC_MODE1_TAMPCTRL_TAMLVL4_Pos = 0x14
	// Bit mask of TAMLVL4 field.
	RTC_MODE1_TAMPCTRL_TAMLVL4_Msk = 0x100000
	// Bit TAMLVL4.
	RTC_MODE1_TAMPCTRL_TAMLVL4 = 0x100000
	// Position of DEBNC0 field.
	RTC_MODE1_TAMPCTRL_DEBNC0_Pos = 0x18
	// Bit mask of DEBNC0 field.
	RTC_MODE1_TAMPCTRL_DEBNC0_Msk = 0x1000000
	// Bit DEBNC0.
	RTC_MODE1_TAMPCTRL_DEBNC0 = 0x1000000
	// Position of DEBNC1 field.
	RTC_MODE1_TAMPCTRL_DEBNC1_Pos = 0x19
	// Bit mask of DEBNC1 field.
	RTC_MODE1_TAMPCTRL_DEBNC1_Msk = 0x2000000
	// Bit DEBNC1.
	RTC_MODE1_TAMPCTRL_DEBNC1 = 0x2000000
	// Position of DEBNC2 field.
	RTC_MODE1_TAMPCTRL_DEBNC2_Pos = 0x1a
	// Bit mask of DEBNC2 field.
	RTC_MODE1_TAMPCTRL_DEBNC2_Msk = 0x4000000
	// Bit DEBNC2.
	RTC_MODE1_TAMPCTRL_DEBNC2 = 0x4000000
	// Position of DEBNC3 field.
	RTC_MODE1_TAMPCTRL_DEBNC3_Pos = 0x1b
	// Bit mask of DEBNC3 field.
	RTC_MODE1_TAMPCTRL_DEBNC3_Msk = 0x8000000
	// Bit DEBNC3.
	RTC_MODE1_TAMPCTRL_DEBNC3 = 0x8000000
	// Position of DEBNC4 field.
	RTC_MODE1_TAMPCTRL_DEBNC4_Pos = 0x1c
	// Bit mask of DEBNC4 field.
	RTC_MODE1_TAMPCTRL_DEBNC4_Msk = 0x10000000
	// Bit DEBNC4.
	RTC_MODE1_TAMPCTRL_DEBNC4 = 0x10000000

	// TIMESTAMP: MODE1 Timestamp
	// Position of COUNT field.
	RTC_MODE1_TIMESTAMP_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	RTC_MODE1_TIMESTAMP_COUNT_Msk = 0xffff

	// TAMPID: Tamper ID
	// Position of TAMPID0 field.
	RTC_MODE1_TAMPID_TAMPID0_Pos = 0x0
	// Bit mask of TAMPID0 field.
	RTC_MODE1_TAMPID_TAMPID0_Msk = 0x1
	// Bit TAMPID0.
	RTC_MODE1_TAMPID_TAMPID0 = 0x1
	// Position of TAMPID1 field.
	RTC_MODE1_TAMPID_TAMPID1_Pos = 0x1
	// Bit mask of TAMPID1 field.
	RTC_MODE1_TAMPID_TAMPID1_Msk = 0x2
	// Bit TAMPID1.
	RTC_MODE1_TAMPID_TAMPID1 = 0x2
	// Position of TAMPID2 field.
	RTC_MODE1_TAMPID_TAMPID2_Pos = 0x2
	// Bit mask of TAMPID2 field.
	RTC_MODE1_TAMPID_TAMPID2_Msk = 0x4
	// Bit TAMPID2.
	RTC_MODE1_TAMPID_TAMPID2 = 0x4
	// Position of TAMPID3 field.
	RTC_MODE1_TAMPID_TAMPID3_Pos = 0x3
	// Bit mask of TAMPID3 field.
	RTC_MODE1_TAMPID_TAMPID3_Msk = 0x8
	// Bit TAMPID3.
	RTC_MODE1_TAMPID_TAMPID3 = 0x8
	// Position of TAMPID4 field.
	RTC_MODE1_TAMPID_TAMPID4_Pos = 0x4
	// Bit mask of TAMPID4 field.
	RTC_MODE1_TAMPID_TAMPID4_Msk = 0x10
	// Bit TAMPID4.
	RTC_MODE1_TAMPID_TAMPID4 = 0x10
	// Position of TAMPEVT field.
	RTC_MODE1_TAMPID_TAMPEVT_Pos = 0x1f
	// Bit mask of TAMPEVT field.
	RTC_MODE1_TAMPID_TAMPEVT_Msk = 0x80000000
	// Bit TAMPEVT.
	RTC_MODE1_TAMPID_TAMPEVT = 0x80000000

	// BKUP: Backup
	// Position of BKUP field.
	RTC_MODE1_BKUP_BKUP_Pos = 0x0
	// Bit mask of BKUP field.
	RTC_MODE1_BKUP_BKUP_Msk = 0xffffffff
)

// Constants for RTC_MODE2: Real-Time Counter - MODE2
const (
	// CTRLA: MODE2 Control A
	// Position of SWRST field.
	RTC_MODE2_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	RTC_MODE2_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	RTC_MODE2_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	RTC_MODE2_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	RTC_MODE2_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	RTC_MODE2_CTRLA_ENABLE = 0x2
	// Position of MODE field.
	RTC_MODE2_CTRLA_MODE_Pos = 0x2
	// Bit mask of MODE field.
	RTC_MODE2_CTRLA_MODE_Msk = 0xc
	// Mode 0: 32-bit Counter
	RTC_MODE2_CTRLA_MODE_COUNT32 = 0x0
	// Mode 1: 16-bit Counter
	RTC_MODE2_CTRLA_MODE_COUNT16 = 0x1
	// Mode 2: Clock/Calendar
	RTC_MODE2_CTRLA_MODE_CLOCK = 0x2
	// Position of CLKREP field.
	RTC_MODE2_CTRLA_CLKREP_Pos = 0x6
	// Bit mask of CLKREP field.
	RTC_MODE2_CTRLA_CLKREP_Msk = 0x40
	// Bit CLKREP.
	RTC_MODE2_CTRLA_CLKREP = 0x40
	// Position of MATCHCLR field.
	RTC_MODE2_CTRLA_MATCHCLR_Pos = 0x7
	// Bit mask of MATCHCLR field.
	RTC_MODE2_CTRLA_MATCHCLR_Msk = 0x80
	// Bit MATCHCLR.
	RTC_MODE2_CTRLA_MATCHCLR = 0x80
	// Position of PRESCALER field.
	RTC_MODE2_CTRLA_PRESCALER_Pos = 0x8
	// Bit mask of PRESCALER field.
	RTC_MODE2_CTRLA_PRESCALER_Msk = 0xf00
	// CLK_RTC_CNT = GCLK_RTC/1
	RTC_MODE2_CTRLA_PRESCALER_OFF = 0x0
	// CLK_RTC_CNT = GCLK_RTC/1
	RTC_MODE2_CTRLA_PRESCALER_DIV1 = 0x1
	// CLK_RTC_CNT = GCLK_RTC/2
	RTC_MODE2_CTRLA_PRESCALER_DIV2 = 0x2
	// CLK_RTC_CNT = GCLK_RTC/4
	RTC_MODE2_CTRLA_PRESCALER_DIV4 = 0x3
	// CLK_RTC_CNT = GCLK_RTC/8
	RTC_MODE2_CTRLA_PRESCALER_DIV8 = 0x4
	// CLK_RTC_CNT = GCLK_RTC/16
	RTC_MODE2_CTRLA_PRESCALER_DIV16 = 0x5
	// CLK_RTC_CNT = GCLK_RTC/32
	RTC_MODE2_CTRLA_PRESCALER_DIV32 = 0x6
	// CLK_RTC_CNT = GCLK_RTC/64
	RTC_MODE2_CTRLA_PRESCALER_DIV64 = 0x7
	// CLK_RTC_CNT = GCLK_RTC/128
	RTC_MODE2_CTRLA_PRESCALER_DIV128 = 0x8
	// CLK_RTC_CNT = GCLK_RTC/256
	RTC_MODE2_CTRLA_PRESCALER_DIV256 = 0x9
	// CLK_RTC_CNT = GCLK_RTC/512
	RTC_MODE2_CTRLA_PRESCALER_DIV512 = 0xa
	// CLK_RTC_CNT = GCLK_RTC/1024
	RTC_MODE2_CTRLA_PRESCALER_DIV1024 = 0xb
	// Position of BKTRST field.
	RTC_MODE2_CTRLA_BKTRST_Pos = 0xd
	// Bit mask of BKTRST field.
	RTC_MODE2_CTRLA_BKTRST_Msk = 0x2000
	// Bit BKTRST.
	RTC_MODE2_CTRLA_BKTRST = 0x2000
	// Position of GPTRST field.
	RTC_MODE2_CTRLA_GPTRST_Pos = 0xe
	// Bit mask of GPTRST field.
	RTC_MODE2_CTRLA_GPTRST_Msk = 0x4000
	// Bit GPTRST.
	RTC_MODE2_CTRLA_GPTRST = 0x4000
	// Position of CLOCKSYNC field.
	RTC_MODE2_CTRLA_CLOCKSYNC_Pos = 0xf
	// Bit mask of CLOCKSYNC field.
	RTC_MODE2_CTRLA_CLOCKSYNC_Msk = 0x8000
	// Bit CLOCKSYNC.
	RTC_MODE2_CTRLA_CLOCKSYNC = 0x8000

	// CTRLB: MODE2 Control B
	// Position of GP0EN field.
	RTC_MODE2_CTRLB_GP0EN_Pos = 0x0
	// Bit mask of GP0EN field.
	RTC_MODE2_CTRLB_GP0EN_Msk = 0x1
	// Bit GP0EN.
	RTC_MODE2_CTRLB_GP0EN = 0x1
	// Position of GP2EN field.
	RTC_MODE2_CTRLB_GP2EN_Pos = 0x1
	// Bit mask of GP2EN field.
	RTC_MODE2_CTRLB_GP2EN_Msk = 0x2
	// Bit GP2EN.
	RTC_MODE2_CTRLB_GP2EN = 0x2
	// Position of DEBMAJ field.
	RTC_MODE2_CTRLB_DEBMAJ_Pos = 0x4
	// Bit mask of DEBMAJ field.
	RTC_MODE2_CTRLB_DEBMAJ_Msk = 0x10
	// Bit DEBMAJ.
	RTC_MODE2_CTRLB_DEBMAJ = 0x10
	// Position of DEBASYNC field.
	RTC_MODE2_CTRLB_DEBASYNC_Pos = 0x5
	// Bit mask of DEBASYNC field.
	RTC_MODE2_CTRLB_DEBASYNC_Msk = 0x20
	// Bit DEBASYNC.
	RTC_MODE2_CTRLB_DEBASYNC = 0x20
	// Position of RTCOUT field.
	RTC_MODE2_CTRLB_RTCOUT_Pos = 0x6
	// Bit mask of RTCOUT field.
	RTC_MODE2_CTRLB_RTCOUT_Msk = 0x40
	// Bit RTCOUT.
	RTC_MODE2_CTRLB_RTCOUT = 0x40
	// Position of DMAEN field.
	RTC_MODE2_CTRLB_DMAEN_Pos = 0x7
	// Bit mask of DMAEN field.
	RTC_MODE2_CTRLB_DMAEN_Msk = 0x80
	// Bit DMAEN.
	RTC_MODE2_CTRLB_DMAEN = 0x80
	// Position of DEBF field.
	RTC_MODE2_CTRLB_DEBF_Pos = 0x8
	// Bit mask of DEBF field.
	RTC_MODE2_CTRLB_DEBF_Msk = 0x700
	// CLK_RTC_DEB = CLK_RTC/2
	RTC_MODE2_CTRLB_DEBF_DIV2 = 0x0
	// CLK_RTC_DEB = CLK_RTC/4
	RTC_MODE2_CTRLB_DEBF_DIV4 = 0x1
	// CLK_RTC_DEB = CLK_RTC/8
	RTC_MODE2_CTRLB_DEBF_DIV8 = 0x2
	// CLK_RTC_DEB = CLK_RTC/16
	RTC_MODE2_CTRLB_DEBF_DIV16 = 0x3
	// CLK_RTC_DEB = CLK_RTC/32
	RTC_MODE2_CTRLB_DEBF_DIV32 = 0x4
	// CLK_RTC_DEB = CLK_RTC/64
	RTC_MODE2_CTRLB_DEBF_DIV64 = 0x5
	// CLK_RTC_DEB = CLK_RTC/128
	RTC_MODE2_CTRLB_DEBF_DIV128 = 0x6
	// CLK_RTC_DEB = CLK_RTC/256
	RTC_MODE2_CTRLB_DEBF_DIV256 = 0x7
	// Position of ACTF field.
	RTC_MODE2_CTRLB_ACTF_Pos = 0xc
	// Bit mask of ACTF field.
	RTC_MODE2_CTRLB_ACTF_Msk = 0x7000
	// CLK_RTC_OUT = CLK_RTC/2
	RTC_MODE2_CTRLB_ACTF_DIV2 = 0x0
	// CLK_RTC_OUT = CLK_RTC/4
	RTC_MODE2_CTRLB_ACTF_DIV4 = 0x1
	// CLK_RTC_OUT = CLK_RTC/8
	RTC_MODE2_CTRLB_ACTF_DIV8 = 0x2
	// CLK_RTC_OUT = CLK_RTC/16
	RTC_MODE2_CTRLB_ACTF_DIV16 = 0x3
	// CLK_RTC_OUT = CLK_RTC/32
	RTC_MODE2_CTRLB_ACTF_DIV32 = 0x4
	// CLK_RTC_OUT = CLK_RTC/64
	RTC_MODE2_CTRLB_ACTF_DIV64 = 0x5
	// CLK_RTC_OUT = CLK_RTC/128
	RTC_MODE2_CTRLB_ACTF_DIV128 = 0x6
	// CLK_RTC_OUT = CLK_RTC/256
	RTC_MODE2_CTRLB_ACTF_DIV256 = 0x7

	// EVCTRL: MODE2 Event Control
	// Position of PEREO0 field.
	RTC_MODE2_EVCTRL_PEREO0_Pos = 0x0
	// Bit mask of PEREO0 field.
	RTC_MODE2_EVCTRL_PEREO0_Msk = 0x1
	// Bit PEREO0.
	RTC_MODE2_EVCTRL_PEREO0 = 0x1
	// Position of PEREO1 field.
	RTC_MODE2_EVCTRL_PEREO1_Pos = 0x1
	// Bit mask of PEREO1 field.
	RTC_MODE2_EVCTRL_PEREO1_Msk = 0x2
	// Bit PEREO1.
	RTC_MODE2_EVCTRL_PEREO1 = 0x2
	// Position of PEREO2 field.
	RTC_MODE2_EVCTRL_PEREO2_Pos = 0x2
	// Bit mask of PEREO2 field.
	RTC_MODE2_EVCTRL_PEREO2_Msk = 0x4
	// Bit PEREO2.
	RTC_MODE2_EVCTRL_PEREO2 = 0x4
	// Position of PEREO3 field.
	RTC_MODE2_EVCTRL_PEREO3_Pos = 0x3
	// Bit mask of PEREO3 field.
	RTC_MODE2_EVCTRL_PEREO3_Msk = 0x8
	// Bit PEREO3.
	RTC_MODE2_EVCTRL_PEREO3 = 0x8
	// Position of PEREO4 field.
	RTC_MODE2_EVCTRL_PEREO4_Pos = 0x4
	// Bit mask of PEREO4 field.
	RTC_MODE2_EVCTRL_PEREO4_Msk = 0x10
	// Bit PEREO4.
	RTC_MODE2_EVCTRL_PEREO4 = 0x10
	// Position of PEREO5 field.
	RTC_MODE2_EVCTRL_PEREO5_Pos = 0x5
	// Bit mask of PEREO5 field.
	RTC_MODE2_EVCTRL_PEREO5_Msk = 0x20
	// Bit PEREO5.
	RTC_MODE2_EVCTRL_PEREO5 = 0x20
	// Position of PEREO6 field.
	RTC_MODE2_EVCTRL_PEREO6_Pos = 0x6
	// Bit mask of PEREO6 field.
	RTC_MODE2_EVCTRL_PEREO6_Msk = 0x40
	// Bit PEREO6.
	RTC_MODE2_EVCTRL_PEREO6 = 0x40
	// Position of PEREO7 field.
	RTC_MODE2_EVCTRL_PEREO7_Pos = 0x7
	// Bit mask of PEREO7 field.
	RTC_MODE2_EVCTRL_PEREO7_Msk = 0x80
	// Bit PEREO7.
	RTC_MODE2_EVCTRL_PEREO7 = 0x80
	// Position of ALARMEO0 field.
	RTC_MODE2_EVCTRL_ALARMEO0_Pos = 0x8
	// Bit mask of ALARMEO0 field.
	RTC_MODE2_EVCTRL_ALARMEO0_Msk = 0x100
	// Bit ALARMEO0.
	RTC_MODE2_EVCTRL_ALARMEO0 = 0x100
	// Position of ALARMEO1 field.
	RTC_MODE2_EVCTRL_ALARMEO1_Pos = 0x9
	// Bit mask of ALARMEO1 field.
	RTC_MODE2_EVCTRL_ALARMEO1_Msk = 0x200
	// Bit ALARMEO1.
	RTC_MODE2_EVCTRL_ALARMEO1 = 0x200
	// Position of TAMPEREO field.
	RTC_MODE2_EVCTRL_TAMPEREO_Pos = 0xe
	// Bit mask of TAMPEREO field.
	RTC_MODE2_EVCTRL_TAMPEREO_Msk = 0x4000
	// Bit TAMPEREO.
	RTC_MODE2_EVCTRL_TAMPEREO = 0x4000
	// Position of OVFEO field.
	RTC_MODE2_EVCTRL_OVFEO_Pos = 0xf
	// Bit mask of OVFEO field.
	RTC_MODE2_EVCTRL_OVFEO_Msk = 0x8000
	// Bit OVFEO.
	RTC_MODE2_EVCTRL_OVFEO = 0x8000
	// Position of TAMPEVEI field.
	RTC_MODE2_EVCTRL_TAMPEVEI_Pos = 0x10
	// Bit mask of TAMPEVEI field.
	RTC_MODE2_EVCTRL_TAMPEVEI_Msk = 0x10000
	// Bit TAMPEVEI.
	RTC_MODE2_EVCTRL_TAMPEVEI = 0x10000

	// INTENCLR: MODE2 Interrupt Enable Clear
	// Position of PER0 field.
	RTC_MODE2_INTENCLR_PER0_Pos = 0x0
	// Bit mask of PER0 field.
	RTC_MODE2_INTENCLR_PER0_Msk = 0x1
	// Bit PER0.
	RTC_MODE2_INTENCLR_PER0 = 0x1
	// Position of PER1 field.
	RTC_MODE2_INTENCLR_PER1_Pos = 0x1
	// Bit mask of PER1 field.
	RTC_MODE2_INTENCLR_PER1_Msk = 0x2
	// Bit PER1.
	RTC_MODE2_INTENCLR_PER1 = 0x2
	// Position of PER2 field.
	RTC_MODE2_INTENCLR_PER2_Pos = 0x2
	// Bit mask of PER2 field.
	RTC_MODE2_INTENCLR_PER2_Msk = 0x4
	// Bit PER2.
	RTC_MODE2_INTENCLR_PER2 = 0x4
	// Position of PER3 field.
	RTC_MODE2_INTENCLR_PER3_Pos = 0x3
	// Bit mask of PER3 field.
	RTC_MODE2_INTENCLR_PER3_Msk = 0x8
	// Bit PER3.
	RTC_MODE2_INTENCLR_PER3 = 0x8
	// Position of PER4 field.
	RTC_MODE2_INTENCLR_PER4_Pos = 0x4
	// Bit mask of PER4 field.
	RTC_MODE2_INTENCLR_PER4_Msk = 0x10
	// Bit PER4.
	RTC_MODE2_INTENCLR_PER4 = 0x10
	// Position of PER5 field.
	RTC_MODE2_INTENCLR_PER5_Pos = 0x5
	// Bit mask of PER5 field.
	RTC_MODE2_INTENCLR_PER5_Msk = 0x20
	// Bit PER5.
	RTC_MODE2_INTENCLR_PER5 = 0x20
	// Position of PER6 field.
	RTC_MODE2_INTENCLR_PER6_Pos = 0x6
	// Bit mask of PER6 field.
	RTC_MODE2_INTENCLR_PER6_Msk = 0x40
	// Bit PER6.
	RTC_MODE2_INTENCLR_PER6 = 0x40
	// Position of PER7 field.
	RTC_MODE2_INTENCLR_PER7_Pos = 0x7
	// Bit mask of PER7 field.
	RTC_MODE2_INTENCLR_PER7_Msk = 0x80
	// Bit PER7.
	RTC_MODE2_INTENCLR_PER7 = 0x80
	// Position of ALARM0 field.
	RTC_MODE2_INTENCLR_ALARM0_Pos = 0x8
	// Bit mask of ALARM0 field.
	RTC_MODE2_INTENCLR_ALARM0_Msk = 0x100
	// Bit ALARM0.
	RTC_MODE2_INTENCLR_ALARM0 = 0x100
	// Position of ALARM1 field.
	RTC_MODE2_INTENCLR_ALARM1_Pos = 0x9
	// Bit mask of ALARM1 field.
	RTC_MODE2_INTENCLR_ALARM1_Msk = 0x200
	// Bit ALARM1.
	RTC_MODE2_INTENCLR_ALARM1 = 0x200
	// Position of TAMPER field.
	RTC_MODE2_INTENCLR_TAMPER_Pos = 0xe
	// Bit mask of TAMPER field.
	RTC_MODE2_INTENCLR_TAMPER_Msk = 0x4000
	// Bit TAMPER.
	RTC_MODE2_INTENCLR_TAMPER = 0x4000
	// Position of OVF field.
	RTC_MODE2_INTENCLR_OVF_Pos = 0xf
	// Bit mask of OVF field.
	RTC_MODE2_INTENCLR_OVF_Msk = 0x8000
	// Bit OVF.
	RTC_MODE2_INTENCLR_OVF = 0x8000

	// INTENSET: MODE2 Interrupt Enable Set
	// Position of PER0 field.
	RTC_MODE2_INTENSET_PER0_Pos = 0x0
	// Bit mask of PER0 field.
	RTC_MODE2_INTENSET_PER0_Msk = 0x1
	// Bit PER0.
	RTC_MODE2_INTENSET_PER0 = 0x1
	// Position of PER1 field.
	RTC_MODE2_INTENSET_PER1_Pos = 0x1
	// Bit mask of PER1 field.
	RTC_MODE2_INTENSET_PER1_Msk = 0x2
	// Bit PER1.
	RTC_MODE2_INTENSET_PER1 = 0x2
	// Position of PER2 field.
	RTC_MODE2_INTENSET_PER2_Pos = 0x2
	// Bit mask of PER2 field.
	RTC_MODE2_INTENSET_PER2_Msk = 0x4
	// Bit PER2.
	RTC_MODE2_INTENSET_PER2 = 0x4
	// Position of PER3 field.
	RTC_MODE2_INTENSET_PER3_Pos = 0x3
	// Bit mask of PER3 field.
	RTC_MODE2_INTENSET_PER3_Msk = 0x8
	// Bit PER3.
	RTC_MODE2_INTENSET_PER3 = 0x8
	// Position of PER4 field.
	RTC_MODE2_INTENSET_PER4_Pos = 0x4
	// Bit mask of PER4 field.
	RTC_MODE2_INTENSET_PER4_Msk = 0x10
	// Bit PER4.
	RTC_MODE2_INTENSET_PER4 = 0x10
	// Position of PER5 field.
	RTC_MODE2_INTENSET_PER5_Pos = 0x5
	// Bit mask of PER5 field.
	RTC_MODE2_INTENSET_PER5_Msk = 0x20
	// Bit PER5.
	RTC_MODE2_INTENSET_PER5 = 0x20
	// Position of PER6 field.
	RTC_MODE2_INTENSET_PER6_Pos = 0x6
	// Bit mask of PER6 field.
	RTC_MODE2_INTENSET_PER6_Msk = 0x40
	// Bit PER6.
	RTC_MODE2_INTENSET_PER6 = 0x40
	// Position of PER7 field.
	RTC_MODE2_INTENSET_PER7_Pos = 0x7
	// Bit mask of PER7 field.
	RTC_MODE2_INTENSET_PER7_Msk = 0x80
	// Bit PER7.
	RTC_MODE2_INTENSET_PER7 = 0x80
	// Position of ALARM0 field.
	RTC_MODE2_INTENSET_ALARM0_Pos = 0x8
	// Bit mask of ALARM0 field.
	RTC_MODE2_INTENSET_ALARM0_Msk = 0x100
	// Bit ALARM0.
	RTC_MODE2_INTENSET_ALARM0 = 0x100
	// Position of ALARM1 field.
	RTC_MODE2_INTENSET_ALARM1_Pos = 0x9
	// Bit mask of ALARM1 field.
	RTC_MODE2_INTENSET_ALARM1_Msk = 0x200
	// Bit ALARM1.
	RTC_MODE2_INTENSET_ALARM1 = 0x200
	// Position of TAMPER field.
	RTC_MODE2_INTENSET_TAMPER_Pos = 0xe
	// Bit mask of TAMPER field.
	RTC_MODE2_INTENSET_TAMPER_Msk = 0x4000
	// Bit TAMPER.
	RTC_MODE2_INTENSET_TAMPER = 0x4000
	// Position of OVF field.
	RTC_MODE2_INTENSET_OVF_Pos = 0xf
	// Bit mask of OVF field.
	RTC_MODE2_INTENSET_OVF_Msk = 0x8000
	// Bit OVF.
	RTC_MODE2_INTENSET_OVF = 0x8000

	// INTFLAG: MODE2 Interrupt Flag Status and Clear
	// Position of PER0 field.
	RTC_MODE2_INTFLAG_PER0_Pos = 0x0
	// Bit mask of PER0 field.
	RTC_MODE2_INTFLAG_PER0_Msk = 0x1
	// Bit PER0.
	RTC_MODE2_INTFLAG_PER0 = 0x1
	// Position of PER1 field.
	RTC_MODE2_INTFLAG_PER1_Pos = 0x1
	// Bit mask of PER1 field.
	RTC_MODE2_INTFLAG_PER1_Msk = 0x2
	// Bit PER1.
	RTC_MODE2_INTFLAG_PER1 = 0x2
	// Position of PER2 field.
	RTC_MODE2_INTFLAG_PER2_Pos = 0x2
	// Bit mask of PER2 field.
	RTC_MODE2_INTFLAG_PER2_Msk = 0x4
	// Bit PER2.
	RTC_MODE2_INTFLAG_PER2 = 0x4
	// Position of PER3 field.
	RTC_MODE2_INTFLAG_PER3_Pos = 0x3
	// Bit mask of PER3 field.
	RTC_MODE2_INTFLAG_PER3_Msk = 0x8
	// Bit PER3.
	RTC_MODE2_INTFLAG_PER3 = 0x8
	// Position of PER4 field.
	RTC_MODE2_INTFLAG_PER4_Pos = 0x4
	// Bit mask of PER4 field.
	RTC_MODE2_INTFLAG_PER4_Msk = 0x10
	// Bit PER4.
	RTC_MODE2_INTFLAG_PER4 = 0x10
	// Position of PER5 field.
	RTC_MODE2_INTFLAG_PER5_Pos = 0x5
	// Bit mask of PER5 field.
	RTC_MODE2_INTFLAG_PER5_Msk = 0x20
	// Bit PER5.
	RTC_MODE2_INTFLAG_PER5 = 0x20
	// Position of PER6 field.
	RTC_MODE2_INTFLAG_PER6_Pos = 0x6
	// Bit mask of PER6 field.
	RTC_MODE2_INTFLAG_PER6_Msk = 0x40
	// Bit PER6.
	RTC_MODE2_INTFLAG_PER6 = 0x40
	// Position of PER7 field.
	RTC_MODE2_INTFLAG_PER7_Pos = 0x7
	// Bit mask of PER7 field.
	RTC_MODE2_INTFLAG_PER7_Msk = 0x80
	// Bit PER7.
	RTC_MODE2_INTFLAG_PER7 = 0x80
	// Position of ALARM0 field.
	RTC_MODE2_INTFLAG_ALARM0_Pos = 0x8
	// Bit mask of ALARM0 field.
	RTC_MODE2_INTFLAG_ALARM0_Msk = 0x100
	// Bit ALARM0.
	RTC_MODE2_INTFLAG_ALARM0 = 0x100
	// Position of ALARM1 field.
	RTC_MODE2_INTFLAG_ALARM1_Pos = 0x9
	// Bit mask of ALARM1 field.
	RTC_MODE2_INTFLAG_ALARM1_Msk = 0x200
	// Bit ALARM1.
	RTC_MODE2_INTFLAG_ALARM1 = 0x200
	// Position of TAMPER field.
	RTC_MODE2_INTFLAG_TAMPER_Pos = 0xe
	// Bit mask of TAMPER field.
	RTC_MODE2_INTFLAG_TAMPER_Msk = 0x4000
	// Bit TAMPER.
	RTC_MODE2_INTFLAG_TAMPER = 0x4000
	// Position of OVF field.
	RTC_MODE2_INTFLAG_OVF_Pos = 0xf
	// Bit mask of OVF field.
	RTC_MODE2_INTFLAG_OVF_Msk = 0x8000
	// Bit OVF.
	RTC_MODE2_INTFLAG_OVF = 0x8000

	// DBGCTRL: Debug Control
	// Position of DBGRUN field.
	RTC_MODE2_DBGCTRL_DBGRUN_Pos = 0x0
	// Bit mask of DBGRUN field.
	RTC_MODE2_DBGCTRL_DBGRUN_Msk = 0x1
	// Bit DBGRUN.
	RTC_MODE2_DBGCTRL_DBGRUN = 0x1

	// SYNCBUSY: MODE2 Synchronization Busy Status
	// Position of SWRST field.
	RTC_MODE2_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	RTC_MODE2_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	RTC_MODE2_SYNCBUSY_SWRST = 0x1
	// Position of ENABLE field.
	RTC_MODE2_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	RTC_MODE2_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	RTC_MODE2_SYNCBUSY_ENABLE = 0x2
	// Position of FREQCORR field.
	RTC_MODE2_SYNCBUSY_FREQCORR_Pos = 0x2
	// Bit mask of FREQCORR field.
	RTC_MODE2_SYNCBUSY_FREQCORR_Msk = 0x4
	// Bit FREQCORR.
	RTC_MODE2_SYNCBUSY_FREQCORR = 0x4
	// Position of CLOCK field.
	RTC_MODE2_SYNCBUSY_CLOCK_Pos = 0x3
	// Bit mask of CLOCK field.
	RTC_MODE2_SYNCBUSY_CLOCK_Msk = 0x8
	// Bit CLOCK.
	RTC_MODE2_SYNCBUSY_CLOCK = 0x8
	// Position of ALARM0 field.
	RTC_MODE2_SYNCBUSY_ALARM0_Pos = 0x5
	// Bit mask of ALARM0 field.
	RTC_MODE2_SYNCBUSY_ALARM0_Msk = 0x20
	// Bit ALARM0.
	RTC_MODE2_SYNCBUSY_ALARM0 = 0x20
	// Position of ALARM1 field.
	RTC_MODE2_SYNCBUSY_ALARM1_Pos = 0x6
	// Bit mask of ALARM1 field.
	RTC_MODE2_SYNCBUSY_ALARM1_Msk = 0x40
	// Bit ALARM1.
	RTC_MODE2_SYNCBUSY_ALARM1 = 0x40
	// Position of MASK0 field.
	RTC_MODE2_SYNCBUSY_MASK0_Pos = 0xb
	// Bit mask of MASK0 field.
	RTC_MODE2_SYNCBUSY_MASK0_Msk = 0x800
	// Bit MASK0.
	RTC_MODE2_SYNCBUSY_MASK0 = 0x800
	// Position of MASK1 field.
	RTC_MODE2_SYNCBUSY_MASK1_Pos = 0xc
	// Bit mask of MASK1 field.
	RTC_MODE2_SYNCBUSY_MASK1_Msk = 0x1000
	// Bit MASK1.
	RTC_MODE2_SYNCBUSY_MASK1 = 0x1000
	// Position of CLOCKSYNC field.
	RTC_MODE2_SYNCBUSY_CLOCKSYNC_Pos = 0xf
	// Bit mask of CLOCKSYNC field.
	RTC_MODE2_SYNCBUSY_CLOCKSYNC_Msk = 0x8000
	// Bit CLOCKSYNC.
	RTC_MODE2_SYNCBUSY_CLOCKSYNC = 0x8000
	// Position of GP0 field.
	RTC_MODE2_SYNCBUSY_GP0_Pos = 0x10
	// Bit mask of GP0 field.
	RTC_MODE2_SYNCBUSY_GP0_Msk = 0x10000
	// Bit GP0.
	RTC_MODE2_SYNCBUSY_GP0 = 0x10000
	// Position of GP1 field.
	RTC_MODE2_SYNCBUSY_GP1_Pos = 0x11
	// Bit mask of GP1 field.
	RTC_MODE2_SYNCBUSY_GP1_Msk = 0x20000
	// Bit GP1.
	RTC_MODE2_SYNCBUSY_GP1 = 0x20000
	// Position of GP2 field.
	RTC_MODE2_SYNCBUSY_GP2_Pos = 0x12
	// Bit mask of GP2 field.
	RTC_MODE2_SYNCBUSY_GP2_Msk = 0x40000
	// Bit GP2.
	RTC_MODE2_SYNCBUSY_GP2 = 0x40000
	// Position of GP3 field.
	RTC_MODE2_SYNCBUSY_GP3_Pos = 0x13
	// Bit mask of GP3 field.
	RTC_MODE2_SYNCBUSY_GP3_Msk = 0x80000
	// Bit GP3.
	RTC_MODE2_SYNCBUSY_GP3 = 0x80000

	// FREQCORR: Frequency Correction
	// Position of VALUE field.
	RTC_MODE2_FREQCORR_VALUE_Pos = 0x0
	// Bit mask of VALUE field.
	RTC_MODE2_FREQCORR_VALUE_Msk = 0x7f
	// Position of SIGN field.
	RTC_MODE2_FREQCORR_SIGN_Pos = 0x7
	// Bit mask of SIGN field.
	RTC_MODE2_FREQCORR_SIGN_Msk = 0x80
	// Bit SIGN.
	RTC_MODE2_FREQCORR_SIGN = 0x80

	// CLOCK: MODE2 Clock Value
	// Position of SECOND field.
	RTC_MODE2_CLOCK_SECOND_Pos = 0x0
	// Bit mask of SECOND field.
	RTC_MODE2_CLOCK_SECOND_Msk = 0x3f
	// Position of MINUTE field.
	RTC_MODE2_CLOCK_MINUTE_Pos = 0x6
	// Bit mask of MINUTE field.
	RTC_MODE2_CLOCK_MINUTE_Msk = 0xfc0
	// Position of HOUR field.
	RTC_MODE2_CLOCK_HOUR_Pos = 0xc
	// Bit mask of HOUR field.
	RTC_MODE2_CLOCK_HOUR_Msk = 0x1f000
	// AM when CLKREP in 12-hour
	RTC_MODE2_CLOCK_HOUR_AM = 0x0
	// PM when CLKREP in 12-hour
	RTC_MODE2_CLOCK_HOUR_PM = 0x10
	// Position of DAY field.
	RTC_MODE2_CLOCK_DAY_Pos = 0x11
	// Bit mask of DAY field.
	RTC_MODE2_CLOCK_DAY_Msk = 0x3e0000
	// Position of MONTH field.
	RTC_MODE2_CLOCK_MONTH_Pos = 0x16
	// Bit mask of MONTH field.
	RTC_MODE2_CLOCK_MONTH_Msk = 0x3c00000
	// Position of YEAR field.
	RTC_MODE2_CLOCK_YEAR_Pos = 0x1a
	// Bit mask of YEAR field.
	RTC_MODE2_CLOCK_YEAR_Msk = 0xfc000000

	// ALARM0: MODE2_ALARM Alarm n Value
	// Position of SECOND field.
	RTC_MODE2_ALARM0_SECOND_Pos = 0x0
	// Bit mask of SECOND field.
	RTC_MODE2_ALARM0_SECOND_Msk = 0x3f
	// Position of MINUTE field.
	RTC_MODE2_ALARM0_MINUTE_Pos = 0x6
	// Bit mask of MINUTE field.
	RTC_MODE2_ALARM0_MINUTE_Msk = 0xfc0
	// Position of HOUR field.
	RTC_MODE2_ALARM0_HOUR_Pos = 0xc
	// Bit mask of HOUR field.
	RTC_MODE2_ALARM0_HOUR_Msk = 0x1f000
	// Morning hour
	RTC_MODE2_ALARM0_HOUR_AM = 0x0
	// Afternoon hour
	RTC_MODE2_ALARM0_HOUR_PM = 0x10
	// Position of DAY field.
	RTC_MODE2_ALARM0_DAY_Pos = 0x11
	// Bit mask of DAY field.
	RTC_MODE2_ALARM0_DAY_Msk = 0x3e0000
	// Position of MONTH field.
	RTC_MODE2_ALARM0_MONTH_Pos = 0x16
	// Bit mask of MONTH field.
	RTC_MODE2_ALARM0_MONTH_Msk = 0x3c00000
	// Position of YEAR field.
	RTC_MODE2_ALARM0_YEAR_Pos = 0x1a
	// Bit mask of YEAR field.
	RTC_MODE2_ALARM0_YEAR_Msk = 0xfc000000

	// MASK0: MODE2_ALARM Alarm n Mask
	// Position of SEL field.
	RTC_MODE2_MASK0_SEL_Pos = 0x0
	// Bit mask of SEL field.
	RTC_MODE2_MASK0_SEL_Msk = 0x7
	// Alarm Disabled
	RTC_MODE2_MASK0_SEL_OFF = 0x0
	// Match seconds only
	RTC_MODE2_MASK0_SEL_SS = 0x1
	// Match seconds and minutes only
	RTC_MODE2_MASK0_SEL_MMSS = 0x2
	// Match seconds, minutes, and hours only
	RTC_MODE2_MASK0_SEL_HHMMSS = 0x3
	// Match seconds, minutes, hours, and days only
	RTC_MODE2_MASK0_SEL_DDHHMMSS = 0x4
	// Match seconds, minutes, hours, days, and months only
	RTC_MODE2_MASK0_SEL_MMDDHHMMSS = 0x5
	// Match seconds, minutes, hours, days, months, and years
	RTC_MODE2_MASK0_SEL_YYMMDDHHMMSS = 0x6

	// ALARM1: MODE2_ALARM Alarm n Value
	// Position of SECOND field.
	RTC_MODE2_ALARM1_SECOND_Pos = 0x0
	// Bit mask of SECOND field.
	RTC_MODE2_ALARM1_SECOND_Msk = 0x3f
	// Position of MINUTE field.
	RTC_MODE2_ALARM1_MINUTE_Pos = 0x6
	// Bit mask of MINUTE field.
	RTC_MODE2_ALARM1_MINUTE_Msk = 0xfc0
	// Position of HOUR field.
	RTC_MODE2_ALARM1_HOUR_Pos = 0xc
	// Bit mask of HOUR field.
	RTC_MODE2_ALARM1_HOUR_Msk = 0x1f000
	// Morning hour
	RTC_MODE2_ALARM1_HOUR_AM = 0x0
	// Afternoon hour
	RTC_MODE2_ALARM1_HOUR_PM = 0x10
	// Position of DAY field.
	RTC_MODE2_ALARM1_DAY_Pos = 0x11
	// Bit mask of DAY field.
	RTC_MODE2_ALARM1_DAY_Msk = 0x3e0000
	// Position of MONTH field.
	RTC_MODE2_ALARM1_MONTH_Pos = 0x16
	// Bit mask of MONTH field.
	RTC_MODE2_ALARM1_MONTH_Msk = 0x3c00000
	// Position of YEAR field.
	RTC_MODE2_ALARM1_YEAR_Pos = 0x1a
	// Bit mask of YEAR field.
	RTC_MODE2_ALARM1_YEAR_Msk = 0xfc000000

	// MASK1: MODE2_ALARM Alarm n Mask
	// Position of SEL field.
	RTC_MODE2_MASK1_SEL_Pos = 0x0
	// Bit mask of SEL field.
	RTC_MODE2_MASK1_SEL_Msk = 0x7
	// Alarm Disabled
	RTC_MODE2_MASK1_SEL_OFF = 0x0
	// Match seconds only
	RTC_MODE2_MASK1_SEL_SS = 0x1
	// Match seconds and minutes only
	RTC_MODE2_MASK1_SEL_MMSS = 0x2
	// Match seconds, minutes, and hours only
	RTC_MODE2_MASK1_SEL_HHMMSS = 0x3
	// Match seconds, minutes, hours, and days only
	RTC_MODE2_MASK1_SEL_DDHHMMSS = 0x4
	// Match seconds, minutes, hours, days, and months only
	RTC_MODE2_MASK1_SEL_MMDDHHMMSS = 0x5
	// Match seconds, minutes, hours, days, months, and years
	RTC_MODE2_MASK1_SEL_YYMMDDHHMMSS = 0x6

	// GP: General Purpose
	// Position of GP field.
	RTC_MODE2_GP_GP_Pos = 0x0
	// Bit mask of GP field.
	RTC_MODE2_GP_GP_Msk = 0xffffffff

	// TAMPCTRL: Tamper Control
	// Position of IN0ACT field.
	RTC_MODE2_TAMPCTRL_IN0ACT_Pos = 0x0
	// Bit mask of IN0ACT field.
	RTC_MODE2_TAMPCTRL_IN0ACT_Msk = 0x3
	// Off (Disabled)
	RTC_MODE2_TAMPCTRL_IN0ACT_OFF = 0x0
	// Wake without timestamp
	RTC_MODE2_TAMPCTRL_IN0ACT_WAKE = 0x1
	// Capture timestamp
	RTC_MODE2_TAMPCTRL_IN0ACT_CAPTURE = 0x2
	// Compare IN0 to OUT
	RTC_MODE2_TAMPCTRL_IN0ACT_ACTL = 0x3
	// Position of IN1ACT field.
	RTC_MODE2_TAMPCTRL_IN1ACT_Pos = 0x2
	// Bit mask of IN1ACT field.
	RTC_MODE2_TAMPCTRL_IN1ACT_Msk = 0xc
	// Off (Disabled)
	RTC_MODE2_TAMPCTRL_IN1ACT_OFF = 0x0
	// Wake without timestamp
	RTC_MODE2_TAMPCTRL_IN1ACT_WAKE = 0x1
	// Capture timestamp
	RTC_MODE2_TAMPCTRL_IN1ACT_CAPTURE = 0x2
	// Compare IN1 to OUT
	RTC_MODE2_TAMPCTRL_IN1ACT_ACTL = 0x3
	// Position of IN2ACT field.
	RTC_MODE2_TAMPCTRL_IN2ACT_Pos = 0x4
	// Bit mask of IN2ACT field.
	RTC_MODE2_TAMPCTRL_IN2ACT_Msk = 0x30
	// Off (Disabled)
	RTC_MODE2_TAMPCTRL_IN2ACT_OFF = 0x0
	// Wake without timestamp
	RTC_MODE2_TAMPCTRL_IN2ACT_WAKE = 0x1
	// Capture timestamp
	RTC_MODE2_TAMPCTRL_IN2ACT_CAPTURE = 0x2
	// Compare IN2 to OUT
	RTC_MODE2_TAMPCTRL_IN2ACT_ACTL = 0x3
	// Position of IN3ACT field.
	RTC_MODE2_TAMPCTRL_IN3ACT_Pos = 0x6
	// Bit mask of IN3ACT field.
	RTC_MODE2_TAMPCTRL_IN3ACT_Msk = 0xc0
	// Off (Disabled)
	RTC_MODE2_TAMPCTRL_IN3ACT_OFF = 0x0
	// Wake without timestamp
	RTC_MODE2_TAMPCTRL_IN3ACT_WAKE = 0x1
	// Capture timestamp
	RTC_MODE2_TAMPCTRL_IN3ACT_CAPTURE = 0x2
	// Compare IN3 to OUT
	RTC_MODE2_TAMPCTRL_IN3ACT_ACTL = 0x3
	// Position of IN4ACT field.
	RTC_MODE2_TAMPCTRL_IN4ACT_Pos = 0x8
	// Bit mask of IN4ACT field.
	RTC_MODE2_TAMPCTRL_IN4ACT_Msk = 0x300
	// Off (Disabled)
	RTC_MODE2_TAMPCTRL_IN4ACT_OFF = 0x0
	// Wake without timestamp
	RTC_MODE2_TAMPCTRL_IN4ACT_WAKE = 0x1
	// Capture timestamp
	RTC_MODE2_TAMPCTRL_IN4ACT_CAPTURE = 0x2
	// Compare IN4 to OUT
	RTC_MODE2_TAMPCTRL_IN4ACT_ACTL = 0x3
	// Position of TAMLVL0 field.
	RTC_MODE2_TAMPCTRL_TAMLVL0_Pos = 0x10
	// Bit mask of TAMLVL0 field.
	RTC_MODE2_TAMPCTRL_TAMLVL0_Msk = 0x10000
	// Bit TAMLVL0.
	RTC_MODE2_TAMPCTRL_TAMLVL0 = 0x10000
	// Position of TAMLVL1 field.
	RTC_MODE2_TAMPCTRL_TAMLVL1_Pos = 0x11
	// Bit mask of TAMLVL1 field.
	RTC_MODE2_TAMPCTRL_TAMLVL1_Msk = 0x20000
	// Bit TAMLVL1.
	RTC_MODE2_TAMPCTRL_TAMLVL1 = 0x20000
	// Position of TAMLVL2 field.
	RTC_MODE2_TAMPCTRL_TAMLVL2_Pos = 0x12
	// Bit mask of TAMLVL2 field.
	RTC_MODE2_TAMPCTRL_TAMLVL2_Msk = 0x40000
	// Bit TAMLVL2.
	RTC_MODE2_TAMPCTRL_TAMLVL2 = 0x40000
	// Position of TAMLVL3 field.
	RTC_MODE2_TAMPCTRL_TAMLVL3_Pos = 0x13
	// Bit mask of TAMLVL3 field.
	RTC_MODE2_TAMPCTRL_TAMLVL3_Msk = 0x80000
	// Bit TAMLVL3.
	RTC_MODE2_TAMPCTRL_TAMLVL3 = 0x80000
	// Position of TAMLVL4 field.
	RTC_MODE2_TAMPCTRL_TAMLVL4_Pos = 0x14
	// Bit mask of TAMLVL4 field.
	RTC_MODE2_TAMPCTRL_TAMLVL4_Msk = 0x100000
	// Bit TAMLVL4.
	RTC_MODE2_TAMPCTRL_TAMLVL4 = 0x100000
	// Position of DEBNC0 field.
	RTC_MODE2_TAMPCTRL_DEBNC0_Pos = 0x18
	// Bit mask of DEBNC0 field.
	RTC_MODE2_TAMPCTRL_DEBNC0_Msk = 0x1000000
	// Bit DEBNC0.
	RTC_MODE2_TAMPCTRL_DEBNC0 = 0x1000000
	// Position of DEBNC1 field.
	RTC_MODE2_TAMPCTRL_DEBNC1_Pos = 0x19
	// Bit mask of DEBNC1 field.
	RTC_MODE2_TAMPCTRL_DEBNC1_Msk = 0x2000000
	// Bit DEBNC1.
	RTC_MODE2_TAMPCTRL_DEBNC1 = 0x2000000
	// Position of DEBNC2 field.
	RTC_MODE2_TAMPCTRL_DEBNC2_Pos = 0x1a
	// Bit mask of DEBNC2 field.
	RTC_MODE2_TAMPCTRL_DEBNC2_Msk = 0x4000000
	// Bit DEBNC2.
	RTC_MODE2_TAMPCTRL_DEBNC2 = 0x4000000
	// Position of DEBNC3 field.
	RTC_MODE2_TAMPCTRL_DEBNC3_Pos = 0x1b
	// Bit mask of DEBNC3 field.
	RTC_MODE2_TAMPCTRL_DEBNC3_Msk = 0x8000000
	// Bit DEBNC3.
	RTC_MODE2_TAMPCTRL_DEBNC3 = 0x8000000
	// Position of DEBNC4 field.
	RTC_MODE2_TAMPCTRL_DEBNC4_Pos = 0x1c
	// Bit mask of DEBNC4 field.
	RTC_MODE2_TAMPCTRL_DEBNC4_Msk = 0x10000000
	// Bit DEBNC4.
	RTC_MODE2_TAMPCTRL_DEBNC4 = 0x10000000

	// TIMESTAMP: MODE2 Timestamp
	// Position of SECOND field.
	RTC_MODE2_TIMESTAMP_SECOND_Pos = 0x0
	// Bit mask of SECOND field.
	RTC_MODE2_TIMESTAMP_SECOND_Msk = 0x3f
	// Position of MINUTE field.
	RTC_MODE2_TIMESTAMP_MINUTE_Pos = 0x6
	// Bit mask of MINUTE field.
	RTC_MODE2_TIMESTAMP_MINUTE_Msk = 0xfc0
	// Position of HOUR field.
	RTC_MODE2_TIMESTAMP_HOUR_Pos = 0xc
	// Bit mask of HOUR field.
	RTC_MODE2_TIMESTAMP_HOUR_Msk = 0x1f000
	// AM when CLKREP in 12-hour
	RTC_MODE2_TIMESTAMP_HOUR_AM = 0x0
	// PM when CLKREP in 12-hour
	RTC_MODE2_TIMESTAMP_HOUR_PM = 0x10
	// Position of DAY field.
	RTC_MODE2_TIMESTAMP_DAY_Pos = 0x11
	// Bit mask of DAY field.
	RTC_MODE2_TIMESTAMP_DAY_Msk = 0x3e0000
	// Position of MONTH field.
	RTC_MODE2_TIMESTAMP_MONTH_Pos = 0x16
	// Bit mask of MONTH field.
	RTC_MODE2_TIMESTAMP_MONTH_Msk = 0x3c00000
	// Position of YEAR field.
	RTC_MODE2_TIMESTAMP_YEAR_Pos = 0x1a
	// Bit mask of YEAR field.
	RTC_MODE2_TIMESTAMP_YEAR_Msk = 0xfc000000

	// TAMPID: Tamper ID
	// Position of TAMPID0 field.
	RTC_MODE2_TAMPID_TAMPID0_Pos = 0x0
	// Bit mask of TAMPID0 field.
	RTC_MODE2_TAMPID_TAMPID0_Msk = 0x1
	// Bit TAMPID0.
	RTC_MODE2_TAMPID_TAMPID0 = 0x1
	// Position of TAMPID1 field.
	RTC_MODE2_TAMPID_TAMPID1_Pos = 0x1
	// Bit mask of TAMPID1 field.
	RTC_MODE2_TAMPID_TAMPID1_Msk = 0x2
	// Bit TAMPID1.
	RTC_MODE2_TAMPID_TAMPID1 = 0x2
	// Position of TAMPID2 field.
	RTC_MODE2_TAMPID_TAMPID2_Pos = 0x2
	// Bit mask of TAMPID2 field.
	RTC_MODE2_TAMPID_TAMPID2_Msk = 0x4
	// Bit TAMPID2.
	RTC_MODE2_TAMPID_TAMPID2 = 0x4
	// Position of TAMPID3 field.
	RTC_MODE2_TAMPID_TAMPID3_Pos = 0x3
	// Bit mask of TAMPID3 field.
	RTC_MODE2_TAMPID_TAMPID3_Msk = 0x8
	// Bit TAMPID3.
	RTC_MODE2_TAMPID_TAMPID3 = 0x8
	// Position of TAMPID4 field.
	RTC_MODE2_TAMPID_TAMPID4_Pos = 0x4
	// Bit mask of TAMPID4 field.
	RTC_MODE2_TAMPID_TAMPID4_Msk = 0x10
	// Bit TAMPID4.
	RTC_MODE2_TAMPID_TAMPID4 = 0x10
	// Position of TAMPEVT field.
	RTC_MODE2_TAMPID_TAMPEVT_Pos = 0x1f
	// Bit mask of TAMPEVT field.
	RTC_MODE2_TAMPID_TAMPEVT_Msk = 0x80000000
	// Bit TAMPEVT.
	RTC_MODE2_TAMPID_TAMPEVT = 0x80000000

	// BKUP: Backup
	// Position of BKUP field.
	RTC_MODE2_BKUP_BKUP_Pos = 0x0
	// Bit mask of BKUP field.
	RTC_MODE2_BKUP_BKUP_Msk = 0xffffffff
)

// Constants for SDHC0: SD/MMC Host Controller
const (
	// SSAR: SDMA System Address / Argument 2
	// Position of ADDR field.
	SDHC_SSAR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	SDHC_SSAR_ADDR_Msk = 0xffffffff

	// SSAR_CMD23_MODE: SDMA System Address / Argument 2
	// Position of ARG2 field.
	SDHC_SSAR_CMD23_MODE_ARG2_Pos = 0x0
	// Bit mask of ARG2 field.
	SDHC_SSAR_CMD23_MODE_ARG2_Msk = 0xffffffff

	// BSR: Block Size
	// Position of BLOCKSIZE field.
	SDHC_BSR_BLOCKSIZE_Pos = 0x0
	// Bit mask of BLOCKSIZE field.
	SDHC_BSR_BLOCKSIZE_Msk = 0x3ff
	// Position of BOUNDARY field.
	SDHC_BSR_BOUNDARY_Pos = 0xc
	// Bit mask of BOUNDARY field.
	SDHC_BSR_BOUNDARY_Msk = 0x7000
	// 4k bytes
	SDHC_BSR_BOUNDARY_4K = 0x0
	// 8k bytes
	SDHC_BSR_BOUNDARY_8K = 0x1
	// 16k bytes
	SDHC_BSR_BOUNDARY_16K = 0x2
	// 32k bytes
	SDHC_BSR_BOUNDARY_32K = 0x3
	// 64k bytes
	SDHC_BSR_BOUNDARY_64K = 0x4
	// 128k bytes
	SDHC_BSR_BOUNDARY_128K = 0x5
	// 256k bytes
	SDHC_BSR_BOUNDARY_256K = 0x6
	// 512k bytes
	SDHC_BSR_BOUNDARY_512K = 0x7

	// BCR: Block Count
	// Position of BCNT field.
	SDHC_BCR_BCNT_Pos = 0x0
	// Bit mask of BCNT field.
	SDHC_BCR_BCNT_Msk = 0xffff

	// ARG1R: Argument 1
	// Position of ARG field.
	SDHC_ARG1R_ARG_Pos = 0x0
	// Bit mask of ARG field.
	SDHC_ARG1R_ARG_Msk = 0xffffffff

	// TMR: Transfer Mode
	// Position of DMAEN field.
	SDHC_TMR_DMAEN_Pos = 0x0
	// Bit mask of DMAEN field.
	SDHC_TMR_DMAEN_Msk = 0x1
	// Bit DMAEN.
	SDHC_TMR_DMAEN = 0x1
	// No data transfer or Non DMA data transfer
	SDHC_TMR_DMAEN_DISABLE = 0x0
	// DMA data transfer
	SDHC_TMR_DMAEN_ENABLE = 0x1
	// Position of BCEN field.
	SDHC_TMR_BCEN_Pos = 0x1
	// Bit mask of BCEN field.
	SDHC_TMR_BCEN_Msk = 0x2
	// Bit BCEN.
	SDHC_TMR_BCEN = 0x2
	// Disable
	SDHC_TMR_BCEN_DISABLE = 0x0
	// Enable
	SDHC_TMR_BCEN_ENABLE = 0x1
	// Position of ACMDEN field.
	SDHC_TMR_ACMDEN_Pos = 0x2
	// Bit mask of ACMDEN field.
	SDHC_TMR_ACMDEN_Msk = 0xc
	// Auto Command Disabled
	SDHC_TMR_ACMDEN_DISABLED = 0x0
	// Auto CMD12 Enable
	SDHC_TMR_ACMDEN_CMD12 = 0x1
	// Auto CMD23 Enable
	SDHC_TMR_ACMDEN_CMD23 = 0x2
	// Position of DTDSEL field.
	SDHC_TMR_DTDSEL_Pos = 0x4
	// Bit mask of DTDSEL field.
	SDHC_TMR_DTDSEL_Msk = 0x10
	// Bit DTDSEL.
	SDHC_TMR_DTDSEL = 0x10
	// Write (Host to Card)
	SDHC_TMR_DTDSEL_WRITE = 0x0
	// Read (Card to Host)
	SDHC_TMR_DTDSEL_READ = 0x1
	// Position of MSBSEL field.
	SDHC_TMR_MSBSEL_Pos = 0x5
	// Bit mask of MSBSEL field.
	SDHC_TMR_MSBSEL_Msk = 0x20
	// Bit MSBSEL.
	SDHC_TMR_MSBSEL = 0x20
	// Single Block
	SDHC_TMR_MSBSEL_SINGLE = 0x0
	// Multiple Block
	SDHC_TMR_MSBSEL_MULTIPLE = 0x1

	// CR: Command
	// Position of RESPTYP field.
	SDHC_CR_RESPTYP_Pos = 0x0
	// Bit mask of RESPTYP field.
	SDHC_CR_RESPTYP_Msk = 0x3
	// No response
	SDHC_CR_RESPTYP_NONE = 0x0
	// 136-bit response
	SDHC_CR_RESPTYP_136_BIT = 0x1
	// 48-bit response
	SDHC_CR_RESPTYP_48_BIT = 0x2
	// 48-bit response check busy after response
	SDHC_CR_RESPTYP_48_BIT_BUSY = 0x3
	// Position of CMDCCEN field.
	SDHC_CR_CMDCCEN_Pos = 0x3
	// Bit mask of CMDCCEN field.
	SDHC_CR_CMDCCEN_Msk = 0x8
	// Bit CMDCCEN.
	SDHC_CR_CMDCCEN = 0x8
	// Disable
	SDHC_CR_CMDCCEN_DISABLE = 0x0
	// Enable
	SDHC_CR_CMDCCEN_ENABLE = 0x1
	// Position of CMDICEN field.
	SDHC_CR_CMDICEN_Pos = 0x4
	// Bit mask of CMDICEN field.
	SDHC_CR_CMDICEN_Msk = 0x10
	// Bit CMDICEN.
	SDHC_CR_CMDICEN = 0x10
	// Disable
	SDHC_CR_CMDICEN_DISABLE = 0x0
	// Enable
	SDHC_CR_CMDICEN_ENABLE = 0x1
	// Position of DPSEL field.
	SDHC_CR_DPSEL_Pos = 0x5
	// Bit mask of DPSEL field.
	SDHC_CR_DPSEL_Msk = 0x20
	// Bit DPSEL.
	SDHC_CR_DPSEL = 0x20
	// No Data Present
	SDHC_CR_DPSEL_NO_DATA = 0x0
	// Data Present
	SDHC_CR_DPSEL_DATA = 0x1
	// Position of CMDTYP field.
	SDHC_CR_CMDTYP_Pos = 0x6
	// Bit mask of CMDTYP field.
	SDHC_CR_CMDTYP_Msk = 0xc0
	// Other commands
	SDHC_CR_CMDTYP_NORMAL = 0x0
	// CMD52 for writing Bus Suspend in CCCR
	SDHC_CR_CMDTYP_SUSPEND = 0x1
	// CMD52 for writing Function Select in CCCR
	SDHC_CR_CMDTYP_RESUME = 0x2
	// CMD12, CMD52 for writing I/O Abort in CCCR
	SDHC_CR_CMDTYP_ABORT = 0x3
	// Position of CMDIDX field.
	SDHC_CR_CMDIDX_Pos = 0x8
	// Bit mask of CMDIDX field.
	SDHC_CR_CMDIDX_Msk = 0x3f00

	// RR: Response
	// Position of CMDRESP field.
	SDHC_RR_CMDRESP_Pos = 0x0
	// Bit mask of CMDRESP field.
	SDHC_RR_CMDRESP_Msk = 0xffffffff

	// BDPR: Buffer Data Port
	// Position of BUFDATA field.
	SDHC_BDPR_BUFDATA_Pos = 0x0
	// Bit mask of BUFDATA field.
	SDHC_BDPR_BUFDATA_Msk = 0xffffffff

	// PSR: Present State
	// Position of CMDINHC field.
	SDHC_PSR_CMDINHC_Pos = 0x0
	// Bit mask of CMDINHC field.
	SDHC_PSR_CMDINHC_Msk = 0x1
	// Bit CMDINHC.
	SDHC_PSR_CMDINHC = 0x1
	// Can issue command using only CMD line
	SDHC_PSR_CMDINHC_CAN = 0x0
	// Cannot issue command
	SDHC_PSR_CMDINHC_CANNOT = 0x1
	// Position of CMDINHD field.
	SDHC_PSR_CMDINHD_Pos = 0x1
	// Bit mask of CMDINHD field.
	SDHC_PSR_CMDINHD_Msk = 0x2
	// Bit CMDINHD.
	SDHC_PSR_CMDINHD = 0x2
	// Can issue command which uses the DAT line
	SDHC_PSR_CMDINHD_CAN = 0x0
	// Cannot issue command which uses the DAT line
	SDHC_PSR_CMDINHD_CANNOT = 0x1
	// Position of DLACT field.
	SDHC_PSR_DLACT_Pos = 0x2
	// Bit mask of DLACT field.
	SDHC_PSR_DLACT_Msk = 0x4
	// Bit DLACT.
	SDHC_PSR_DLACT = 0x4
	// DAT Line Inactive
	SDHC_PSR_DLACT_INACTIVE = 0x0
	// DAT Line Active
	SDHC_PSR_DLACT_ACTIVE = 0x1
	// Position of RTREQ field.
	SDHC_PSR_RTREQ_Pos = 0x3
	// Bit mask of RTREQ field.
	SDHC_PSR_RTREQ_Msk = 0x8
	// Bit RTREQ.
	SDHC_PSR_RTREQ = 0x8
	// Fixed or well-tuned sampling clock
	SDHC_PSR_RTREQ_OK = 0x0
	// Sampling clock needs re-tuning
	SDHC_PSR_RTREQ_REQUIRED = 0x1
	// Position of WTACT field.
	SDHC_PSR_WTACT_Pos = 0x8
	// Bit mask of WTACT field.
	SDHC_PSR_WTACT_Msk = 0x100
	// Bit WTACT.
	SDHC_PSR_WTACT = 0x100
	// No valid data
	SDHC_PSR_WTACT_NO = 0x0
	// Transferring data
	SDHC_PSR_WTACT_YES = 0x1
	// Position of RTACT field.
	SDHC_PSR_RTACT_Pos = 0x9
	// Bit mask of RTACT field.
	SDHC_PSR_RTACT_Msk = 0x200
	// Bit RTACT.
	SDHC_PSR_RTACT = 0x200
	// No valid data
	SDHC_PSR_RTACT_NO = 0x0
	// Transferring data
	SDHC_PSR_RTACT_YES = 0x1
	// Position of BUFWREN field.
	SDHC_PSR_BUFWREN_Pos = 0xa
	// Bit mask of BUFWREN field.
	SDHC_PSR_BUFWREN_Msk = 0x400
	// Bit BUFWREN.
	SDHC_PSR_BUFWREN = 0x400
	// Write disable
	SDHC_PSR_BUFWREN_DISABLE = 0x0
	// Write enable
	SDHC_PSR_BUFWREN_ENABLE = 0x1
	// Position of BUFRDEN field.
	SDHC_PSR_BUFRDEN_Pos = 0xb
	// Bit mask of BUFRDEN field.
	SDHC_PSR_BUFRDEN_Msk = 0x800
	// Bit BUFRDEN.
	SDHC_PSR_BUFRDEN = 0x800
	// Read disable
	SDHC_PSR_BUFRDEN_DISABLE = 0x0
	// Read enable
	SDHC_PSR_BUFRDEN_ENABLE = 0x1
	// Position of CARDINS field.
	SDHC_PSR_CARDINS_Pos = 0x10
	// Bit mask of CARDINS field.
	SDHC_PSR_CARDINS_Msk = 0x10000
	// Bit CARDINS.
	SDHC_PSR_CARDINS = 0x10000
	// Reset or Debouncing or No Card
	SDHC_PSR_CARDINS_NO = 0x0
	// Card inserted
	SDHC_PSR_CARDINS_YES = 0x1
	// Position of CARDSS field.
	SDHC_PSR_CARDSS_Pos = 0x11
	// Bit mask of CARDSS field.
	SDHC_PSR_CARDSS_Msk = 0x20000
	// Bit CARDSS.
	SDHC_PSR_CARDSS = 0x20000
	// Reset or Debouncing
	SDHC_PSR_CARDSS_NO = 0x0
	// No Card or Insered
	SDHC_PSR_CARDSS_YES = 0x1
	// Position of CARDDPL field.
	SDHC_PSR_CARDDPL_Pos = 0x12
	// Bit mask of CARDDPL field.
	SDHC_PSR_CARDDPL_Msk = 0x40000
	// Bit CARDDPL.
	SDHC_PSR_CARDDPL = 0x40000
	// No card present (SDCD#=1)
	SDHC_PSR_CARDDPL_NO = 0x0
	// Card present (SDCD#=0)
	SDHC_PSR_CARDDPL_YES = 0x1
	// Position of WRPPL field.
	SDHC_PSR_WRPPL_Pos = 0x13
	// Bit mask of WRPPL field.
	SDHC_PSR_WRPPL_Msk = 0x80000
	// Bit WRPPL.
	SDHC_PSR_WRPPL = 0x80000
	// Write protected (SDWP#=0)
	SDHC_PSR_WRPPL_PROTECTED = 0x0
	// Write enabled (SDWP#=1)
	SDHC_PSR_WRPPL_ENABLED = 0x1
	// Position of DATLL field.
	SDHC_PSR_DATLL_Pos = 0x14
	// Bit mask of DATLL field.
	SDHC_PSR_DATLL_Msk = 0xf00000
	// Position of CMDLL field.
	SDHC_PSR_CMDLL_Pos = 0x18
	// Bit mask of CMDLL field.
	SDHC_PSR_CMDLL_Msk = 0x1000000
	// Bit CMDLL.
	SDHC_PSR_CMDLL = 0x1000000

	// HC1R: Host Control 1
	// Position of LEDCTRL field.
	SDHC_HC1R_LEDCTRL_Pos = 0x0
	// Bit mask of LEDCTRL field.
	SDHC_HC1R_LEDCTRL_Msk = 0x1
	// Bit LEDCTRL.
	SDHC_HC1R_LEDCTRL = 0x1
	// LED off
	SDHC_HC1R_LEDCTRL_OFF = 0x0
	// LED on
	SDHC_HC1R_LEDCTRL_ON = 0x1
	// Position of DW field.
	SDHC_HC1R_DW_Pos = 0x1
	// Bit mask of DW field.
	SDHC_HC1R_DW_Msk = 0x2
	// Bit DW.
	SDHC_HC1R_DW = 0x2
	// 1-bit mode
	SDHC_HC1R_DW_1BIT = 0x0
	// 4-bit mode
	SDHC_HC1R_DW_4BIT = 0x1
	// Position of HSEN field.
	SDHC_HC1R_HSEN_Pos = 0x2
	// Bit mask of HSEN field.
	SDHC_HC1R_HSEN_Msk = 0x4
	// Bit HSEN.
	SDHC_HC1R_HSEN = 0x4
	// Normal Speed mode
	SDHC_HC1R_HSEN_NORMAL = 0x0
	// High Speed mode
	SDHC_HC1R_HSEN_HIGH = 0x1
	// Position of DMASEL field.
	SDHC_HC1R_DMASEL_Pos = 0x3
	// Bit mask of DMASEL field.
	SDHC_HC1R_DMASEL_Msk = 0x18
	// SDMA is selected
	SDHC_HC1R_DMASEL_SDMA = 0x0
	// 32-bit Address ADMA2 is selected
	SDHC_HC1R_DMASEL_32BIT = 0x2
	// Position of CARDDTL field.
	SDHC_HC1R_CARDDTL_Pos = 0x6
	// Bit mask of CARDDTL field.
	SDHC_HC1R_CARDDTL_Msk = 0x40
	// Bit CARDDTL.
	SDHC_HC1R_CARDDTL = 0x40
	// No Card
	SDHC_HC1R_CARDDTL_NO = 0x0
	// Card Inserted
	SDHC_HC1R_CARDDTL_YES = 0x1
	// Position of CARDDSEL field.
	SDHC_HC1R_CARDDSEL_Pos = 0x7
	// Bit mask of CARDDSEL field.
	SDHC_HC1R_CARDDSEL_Msk = 0x80
	// Bit CARDDSEL.
	SDHC_HC1R_CARDDSEL = 0x80
	// SDCD# is selected (for normal use)
	SDHC_HC1R_CARDDSEL_NORMAL = 0x0
	// The Card Select Test Level is selected (for test purpose)
	SDHC_HC1R_CARDDSEL_TEST = 0x1

	// HC1R_EMMC_MODE: Host Control 1
	// Position of DW field.
	SDHC_HC1R_EMMC_MODE_DW_Pos = 0x1
	// Bit mask of DW field.
	SDHC_HC1R_EMMC_MODE_DW_Msk = 0x2
	// Bit DW.
	SDHC_HC1R_EMMC_MODE_DW = 0x2
	// 1-bit mode
	SDHC_HC1R_EMMC_MODE_DW_1BIT = 0x0
	// 4-bit mode
	SDHC_HC1R_EMMC_MODE_DW_4BIT = 0x1
	// Position of HSEN field.
	SDHC_HC1R_EMMC_MODE_HSEN_Pos = 0x2
	// Bit mask of HSEN field.
	SDHC_HC1R_EMMC_MODE_HSEN_Msk = 0x4
	// Bit HSEN.
	SDHC_HC1R_EMMC_MODE_HSEN = 0x4
	// Normal Speed mode
	SDHC_HC1R_EMMC_MODE_HSEN_NORMAL = 0x0
	// High Speed mode
	SDHC_HC1R_EMMC_MODE_HSEN_HIGH = 0x1
	// Position of DMASEL field.
	SDHC_HC1R_EMMC_MODE_DMASEL_Pos = 0x3
	// Bit mask of DMASEL field.
	SDHC_HC1R_EMMC_MODE_DMASEL_Msk = 0x18
	// SDMA is selected
	SDHC_HC1R_EMMC_MODE_DMASEL_SDMA = 0x0
	// 32-bit Address ADMA2 is selected
	SDHC_HC1R_EMMC_MODE_DMASEL_32BIT = 0x2

	// PCR: Power Control
	// Position of SDBPWR field.
	SDHC_PCR_SDBPWR_Pos = 0x0
	// Bit mask of SDBPWR field.
	SDHC_PCR_SDBPWR_Msk = 0x1
	// Bit SDBPWR.
	SDHC_PCR_SDBPWR = 0x1
	// Power off
	SDHC_PCR_SDBPWR_OFF = 0x0
	// Power on
	SDHC_PCR_SDBPWR_ON = 0x1
	// Position of SDBVSEL field.
	SDHC_PCR_SDBVSEL_Pos = 0x1
	// Bit mask of SDBVSEL field.
	SDHC_PCR_SDBVSEL_Msk = 0xe
	// 1.8V (Typ.)
	SDHC_PCR_SDBVSEL_1V8 = 0x5
	// 3.0V (Typ.)
	SDHC_PCR_SDBVSEL_3V0 = 0x6
	// 3.3V (Typ.)
	SDHC_PCR_SDBVSEL_3V3 = 0x7

	// BGCR: Block Gap Control
	// Position of STPBGR field.
	SDHC_BGCR_STPBGR_Pos = 0x0
	// Bit mask of STPBGR field.
	SDHC_BGCR_STPBGR_Msk = 0x1
	// Bit STPBGR.
	SDHC_BGCR_STPBGR = 0x1
	// Transfer
	SDHC_BGCR_STPBGR_TRANSFER = 0x0
	// Stop
	SDHC_BGCR_STPBGR_STOP = 0x1
	// Position of CONTR field.
	SDHC_BGCR_CONTR_Pos = 0x1
	// Bit mask of CONTR field.
	SDHC_BGCR_CONTR_Msk = 0x2
	// Bit CONTR.
	SDHC_BGCR_CONTR = 0x2
	// Not affected
	SDHC_BGCR_CONTR_GO_ON = 0x0
	// Restart
	SDHC_BGCR_CONTR_RESTART = 0x1
	// Position of RWCTRL field.
	SDHC_BGCR_RWCTRL_Pos = 0x2
	// Bit mask of RWCTRL field.
	SDHC_BGCR_RWCTRL_Msk = 0x4
	// Bit RWCTRL.
	SDHC_BGCR_RWCTRL = 0x4
	// Disable Read Wait Control
	SDHC_BGCR_RWCTRL_DISABLE = 0x0
	// Enable Read Wait Control
	SDHC_BGCR_RWCTRL_ENABLE = 0x1
	// Position of INTBG field.
	SDHC_BGCR_INTBG_Pos = 0x3
	// Bit mask of INTBG field.
	SDHC_BGCR_INTBG_Msk = 0x8
	// Bit INTBG.
	SDHC_BGCR_INTBG = 0x8
	// Disabled
	SDHC_BGCR_INTBG_DISABLED = 0x0
	// Enabled
	SDHC_BGCR_INTBG_ENABLED = 0x1

	// BGCR_EMMC_MODE: Block Gap Control
	// Position of STPBGR field.
	SDHC_BGCR_EMMC_MODE_STPBGR_Pos = 0x0
	// Bit mask of STPBGR field.
	SDHC_BGCR_EMMC_MODE_STPBGR_Msk = 0x1
	// Bit STPBGR.
	SDHC_BGCR_EMMC_MODE_STPBGR = 0x1
	// Transfer
	SDHC_BGCR_EMMC_MODE_STPBGR_TRANSFER = 0x0
	// Stop
	SDHC_BGCR_EMMC_MODE_STPBGR_STOP = 0x1
	// Position of CONTR field.
	SDHC_BGCR_EMMC_MODE_CONTR_Pos = 0x1
	// Bit mask of CONTR field.
	SDHC_BGCR_EMMC_MODE_CONTR_Msk = 0x2
	// Bit CONTR.
	SDHC_BGCR_EMMC_MODE_CONTR = 0x2
	// Not affected
	SDHC_BGCR_EMMC_MODE_CONTR_GO_ON = 0x0
	// Restart
	SDHC_BGCR_EMMC_MODE_CONTR_RESTART = 0x1

	// WCR: Wakeup Control
	// Position of WKENCINT field.
	SDHC_WCR_WKENCINT_Pos = 0x0
	// Bit mask of WKENCINT field.
	SDHC_WCR_WKENCINT_Msk = 0x1
	// Bit WKENCINT.
	SDHC_WCR_WKENCINT = 0x1
	// Disable
	SDHC_WCR_WKENCINT_DISABLE = 0x0
	// Enable
	SDHC_WCR_WKENCINT_ENABLE = 0x1
	// Position of WKENCINS field.
	SDHC_WCR_WKENCINS_Pos = 0x1
	// Bit mask of WKENCINS field.
	SDHC_WCR_WKENCINS_Msk = 0x2
	// Bit WKENCINS.
	SDHC_WCR_WKENCINS = 0x2
	// Disable
	SDHC_WCR_WKENCINS_DISABLE = 0x0
	// Enable
	SDHC_WCR_WKENCINS_ENABLE = 0x1
	// Position of WKENCREM field.
	SDHC_WCR_WKENCREM_Pos = 0x2
	// Bit mask of WKENCREM field.
	SDHC_WCR_WKENCREM_Msk = 0x4
	// Bit WKENCREM.
	SDHC_WCR_WKENCREM = 0x4
	// Disable
	SDHC_WCR_WKENCREM_DISABLE = 0x0
	// Enable
	SDHC_WCR_WKENCREM_ENABLE = 0x1

	// CCR: Clock Control
	// Position of INTCLKEN field.
	SDHC_CCR_INTCLKEN_Pos = 0x0
	// Bit mask of INTCLKEN field.
	SDHC_CCR_INTCLKEN_Msk = 0x1
	// Bit INTCLKEN.
	SDHC_CCR_INTCLKEN = 0x1
	// Stop
	SDHC_CCR_INTCLKEN_OFF = 0x0
	// Oscillate
	SDHC_CCR_INTCLKEN_ON = 0x1
	// Position of INTCLKS field.
	SDHC_CCR_INTCLKS_Pos = 0x1
	// Bit mask of INTCLKS field.
	SDHC_CCR_INTCLKS_Msk = 0x2
	// Bit INTCLKS.
	SDHC_CCR_INTCLKS = 0x2
	// Not Ready
	SDHC_CCR_INTCLKS_NOT_READY = 0x0
	// Ready
	SDHC_CCR_INTCLKS_READY = 0x1
	// Position of SDCLKEN field.
	SDHC_CCR_SDCLKEN_Pos = 0x2
	// Bit mask of SDCLKEN field.
	SDHC_CCR_SDCLKEN_Msk = 0x4
	// Bit SDCLKEN.
	SDHC_CCR_SDCLKEN = 0x4
	// Disable
	SDHC_CCR_SDCLKEN_DISABLE = 0x0
	// Enable
	SDHC_CCR_SDCLKEN_ENABLE = 0x1
	// Position of CLKGSEL field.
	SDHC_CCR_CLKGSEL_Pos = 0x5
	// Bit mask of CLKGSEL field.
	SDHC_CCR_CLKGSEL_Msk = 0x20
	// Bit CLKGSEL.
	SDHC_CCR_CLKGSEL = 0x20
	// Divided Clock Mode
	SDHC_CCR_CLKGSEL_DIV = 0x0
	// Programmable Clock Mode
	SDHC_CCR_CLKGSEL_PROG = 0x1
	// Position of USDCLKFSEL field.
	SDHC_CCR_USDCLKFSEL_Pos = 0x6
	// Bit mask of USDCLKFSEL field.
	SDHC_CCR_USDCLKFSEL_Msk = 0xc0
	// Position of SDCLKFSEL field.
	SDHC_CCR_SDCLKFSEL_Pos = 0x8
	// Bit mask of SDCLKFSEL field.
	SDHC_CCR_SDCLKFSEL_Msk = 0xff00

	// TCR: Timeout Control
	// Position of DTCVAL field.
	SDHC_TCR_DTCVAL_Pos = 0x0
	// Bit mask of DTCVAL field.
	SDHC_TCR_DTCVAL_Msk = 0xf

	// SRR: Software Reset
	// Position of SWRSTALL field.
	SDHC_SRR_SWRSTALL_Pos = 0x0
	// Bit mask of SWRSTALL field.
	SDHC_SRR_SWRSTALL_Msk = 0x1
	// Bit SWRSTALL.
	SDHC_SRR_SWRSTALL = 0x1
	// Work
	SDHC_SRR_SWRSTALL_WORK = 0x0
	// Reset
	SDHC_SRR_SWRSTALL_RESET = 0x1
	// Position of SWRSTCMD field.
	SDHC_SRR_SWRSTCMD_Pos = 0x1
	// Bit mask of SWRSTCMD field.
	SDHC_SRR_SWRSTCMD_Msk = 0x2
	// Bit SWRSTCMD.
	SDHC_SRR_SWRSTCMD = 0x2
	// Work
	SDHC_SRR_SWRSTCMD_WORK = 0x0
	// Reset
	SDHC_SRR_SWRSTCMD_RESET = 0x1
	// Position of SWRSTDAT field.
	SDHC_SRR_SWRSTDAT_Pos = 0x2
	// Bit mask of SWRSTDAT field.
	SDHC_SRR_SWRSTDAT_Msk = 0x4
	// Bit SWRSTDAT.
	SDHC_SRR_SWRSTDAT = 0x4
	// Work
	SDHC_SRR_SWRSTDAT_WORK = 0x0
	// Reset
	SDHC_SRR_SWRSTDAT_RESET = 0x1

	// NISTR: Normal Interrupt Status
	// Position of CMDC field.
	SDHC_NISTR_CMDC_Pos = 0x0
	// Bit mask of CMDC field.
	SDHC_NISTR_CMDC_Msk = 0x1
	// Bit CMDC.
	SDHC_NISTR_CMDC = 0x1
	// No command complete
	SDHC_NISTR_CMDC_NO = 0x0
	// Command complete
	SDHC_NISTR_CMDC_YES = 0x1
	// Position of TRFC field.
	SDHC_NISTR_TRFC_Pos = 0x1
	// Bit mask of TRFC field.
	SDHC_NISTR_TRFC_Msk = 0x2
	// Bit TRFC.
	SDHC_NISTR_TRFC = 0x2
	// Not complete
	SDHC_NISTR_TRFC_NO = 0x0
	// Command execution is completed
	SDHC_NISTR_TRFC_YES = 0x1
	// Position of BLKGE field.
	SDHC_NISTR_BLKGE_Pos = 0x2
	// Bit mask of BLKGE field.
	SDHC_NISTR_BLKGE_Msk = 0x4
	// Bit BLKGE.
	SDHC_NISTR_BLKGE = 0x4
	// No Block Gap Event
	SDHC_NISTR_BLKGE_NO = 0x0
	// Transaction stopped at block gap
	SDHC_NISTR_BLKGE_STOP = 0x1
	// Position of DMAINT field.
	SDHC_NISTR_DMAINT_Pos = 0x3
	// Bit mask of DMAINT field.
	SDHC_NISTR_DMAINT_Msk = 0x8
	// Bit DMAINT.
	SDHC_NISTR_DMAINT = 0x8
	// No DMA Interrupt
	SDHC_NISTR_DMAINT_NO = 0x0
	// DMA Interrupt is generated
	SDHC_NISTR_DMAINT_YES = 0x1
	// Position of BWRRDY field.
	SDHC_NISTR_BWRRDY_Pos = 0x4
	// Bit mask of BWRRDY field.
	SDHC_NISTR_BWRRDY_Msk = 0x10
	// Bit BWRRDY.
	SDHC_NISTR_BWRRDY = 0x10
	// Not ready to write buffer
	SDHC_NISTR_BWRRDY_NO = 0x0
	// Ready to write buffer
	SDHC_NISTR_BWRRDY_YES = 0x1
	// Position of BRDRDY field.
	SDHC_NISTR_BRDRDY_Pos = 0x5
	// Bit mask of BRDRDY field.
	SDHC_NISTR_BRDRDY_Msk = 0x20
	// Bit BRDRDY.
	SDHC_NISTR_BRDRDY = 0x20
	// Not ready to read buffer
	SDHC_NISTR_BRDRDY_NO = 0x0
	// Ready to read buffer
	SDHC_NISTR_BRDRDY_YES = 0x1
	// Position of CINS field.
	SDHC_NISTR_CINS_Pos = 0x6
	// Bit mask of CINS field.
	SDHC_NISTR_CINS_Msk = 0x40
	// Bit CINS.
	SDHC_NISTR_CINS = 0x40
	// Card state stable or Debouncing
	SDHC_NISTR_CINS_NO = 0x0
	// Card inserted
	SDHC_NISTR_CINS_YES = 0x1
	// Position of CREM field.
	SDHC_NISTR_CREM_Pos = 0x7
	// Bit mask of CREM field.
	SDHC_NISTR_CREM_Msk = 0x80
	// Bit CREM.
	SDHC_NISTR_CREM = 0x80
	// Card state stable or Debouncing
	SDHC_NISTR_CREM_NO = 0x0
	// Card Removed
	SDHC_NISTR_CREM_YES = 0x1
	// Position of CINT field.
	SDHC_NISTR_CINT_Pos = 0x8
	// Bit mask of CINT field.
	SDHC_NISTR_CINT_Msk = 0x100
	// Bit CINT.
	SDHC_NISTR_CINT = 0x100
	// No Card Interrupt
	SDHC_NISTR_CINT_NO = 0x0
	// Generate Card Interrupt
	SDHC_NISTR_CINT_YES = 0x1
	// Position of ERRINT field.
	SDHC_NISTR_ERRINT_Pos = 0xf
	// Bit mask of ERRINT field.
	SDHC_NISTR_ERRINT_Msk = 0x8000
	// Bit ERRINT.
	SDHC_NISTR_ERRINT = 0x8000
	// No Error
	SDHC_NISTR_ERRINT_NO = 0x0
	// Error
	SDHC_NISTR_ERRINT_YES = 0x1

	// NISTR_EMMC_MODE: Normal Interrupt Status
	// Position of CMDC field.
	SDHC_NISTR_EMMC_MODE_CMDC_Pos = 0x0
	// Bit mask of CMDC field.
	SDHC_NISTR_EMMC_MODE_CMDC_Msk = 0x1
	// Bit CMDC.
	SDHC_NISTR_EMMC_MODE_CMDC = 0x1
	// No command complete
	SDHC_NISTR_EMMC_MODE_CMDC_NO = 0x0
	// Command complete
	SDHC_NISTR_EMMC_MODE_CMDC_YES = 0x1
	// Position of TRFC field.
	SDHC_NISTR_EMMC_MODE_TRFC_Pos = 0x1
	// Bit mask of TRFC field.
	SDHC_NISTR_EMMC_MODE_TRFC_Msk = 0x2
	// Bit TRFC.
	SDHC_NISTR_EMMC_MODE_TRFC = 0x2
	// Not complete
	SDHC_NISTR_EMMC_MODE_TRFC_NO = 0x0
	// Command execution is completed
	SDHC_NISTR_EMMC_MODE_TRFC_YES = 0x1
	// Position of BLKGE field.
	SDHC_NISTR_EMMC_MODE_BLKGE_Pos = 0x2
	// Bit mask of BLKGE field.
	SDHC_NISTR_EMMC_MODE_BLKGE_Msk = 0x4
	// Bit BLKGE.
	SDHC_NISTR_EMMC_MODE_BLKGE = 0x4
	// No Block Gap Event
	SDHC_NISTR_EMMC_MODE_BLKGE_NO = 0x0
	// Transaction stopped at block gap
	SDHC_NISTR_EMMC_MODE_BLKGE_STOP = 0x1
	// Position of DMAINT field.
	SDHC_NISTR_EMMC_MODE_DMAINT_Pos = 0x3
	// Bit mask of DMAINT field.
	SDHC_NISTR_EMMC_MODE_DMAINT_Msk = 0x8
	// Bit DMAINT.
	SDHC_NISTR_EMMC_MODE_DMAINT = 0x8
	// No DMA Interrupt
	SDHC_NISTR_EMMC_MODE_DMAINT_NO = 0x0
	// DMA Interrupt is generated
	SDHC_NISTR_EMMC_MODE_DMAINT_YES = 0x1
	// Position of BWRRDY field.
	SDHC_NISTR_EMMC_MODE_BWRRDY_Pos = 0x4
	// Bit mask of BWRRDY field.
	SDHC_NISTR_EMMC_MODE_BWRRDY_Msk = 0x10
	// Bit BWRRDY.
	SDHC_NISTR_EMMC_MODE_BWRRDY = 0x10
	// Not ready to write buffer
	SDHC_NISTR_EMMC_MODE_BWRRDY_NO = 0x0
	// Ready to write buffer
	SDHC_NISTR_EMMC_MODE_BWRRDY_YES = 0x1
	// Position of BRDRDY field.
	SDHC_NISTR_EMMC_MODE_BRDRDY_Pos = 0x5
	// Bit mask of BRDRDY field.
	SDHC_NISTR_EMMC_MODE_BRDRDY_Msk = 0x20
	// Bit BRDRDY.
	SDHC_NISTR_EMMC_MODE_BRDRDY = 0x20
	// Not ready to read buffer
	SDHC_NISTR_EMMC_MODE_BRDRDY_NO = 0x0
	// Ready to read buffer
	SDHC_NISTR_EMMC_MODE_BRDRDY_YES = 0x1
	// Position of BOOTAR field.
	SDHC_NISTR_EMMC_MODE_BOOTAR_Pos = 0xe
	// Bit mask of BOOTAR field.
	SDHC_NISTR_EMMC_MODE_BOOTAR_Msk = 0x4000
	// Bit BOOTAR.
	SDHC_NISTR_EMMC_MODE_BOOTAR = 0x4000
	// Position of ERRINT field.
	SDHC_NISTR_EMMC_MODE_ERRINT_Pos = 0xf
	// Bit mask of ERRINT field.
	SDHC_NISTR_EMMC_MODE_ERRINT_Msk = 0x8000
	// Bit ERRINT.
	SDHC_NISTR_EMMC_MODE_ERRINT = 0x8000
	// No Error
	SDHC_NISTR_EMMC_MODE_ERRINT_NO = 0x0
	// Error
	SDHC_NISTR_EMMC_MODE_ERRINT_YES = 0x1

	// EISTR: Error Interrupt Status
	// Position of CMDTEO field.
	SDHC_EISTR_CMDTEO_Pos = 0x0
	// Bit mask of CMDTEO field.
	SDHC_EISTR_CMDTEO_Msk = 0x1
	// Bit CMDTEO.
	SDHC_EISTR_CMDTEO = 0x1
	// No Error
	SDHC_EISTR_CMDTEO_NO = 0x0
	// Timeout
	SDHC_EISTR_CMDTEO_YES = 0x1
	// Position of CMDCRC field.
	SDHC_EISTR_CMDCRC_Pos = 0x1
	// Bit mask of CMDCRC field.
	SDHC_EISTR_CMDCRC_Msk = 0x2
	// Bit CMDCRC.
	SDHC_EISTR_CMDCRC = 0x2
	// No Error
	SDHC_EISTR_CMDCRC_NO = 0x0
	// CRC Error Generated
	SDHC_EISTR_CMDCRC_YES = 0x1
	// Position of CMDEND field.
	SDHC_EISTR_CMDEND_Pos = 0x2
	// Bit mask of CMDEND field.
	SDHC_EISTR_CMDEND_Msk = 0x4
	// Bit CMDEND.
	SDHC_EISTR_CMDEND = 0x4
	// No error
	SDHC_EISTR_CMDEND_NO = 0x0
	// End Bit Error Generated
	SDHC_EISTR_CMDEND_YES = 0x1
	// Position of CMDIDX field.
	SDHC_EISTR_CMDIDX_Pos = 0x3
	// Bit mask of CMDIDX field.
	SDHC_EISTR_CMDIDX_Msk = 0x8
	// Bit CMDIDX.
	SDHC_EISTR_CMDIDX = 0x8
	// No Error
	SDHC_EISTR_CMDIDX_NO = 0x0
	// Error
	SDHC_EISTR_CMDIDX_YES = 0x1
	// Position of DATTEO field.
	SDHC_EISTR_DATTEO_Pos = 0x4
	// Bit mask of DATTEO field.
	SDHC_EISTR_DATTEO_Msk = 0x10
	// Bit DATTEO.
	SDHC_EISTR_DATTEO = 0x10
	// No Error
	SDHC_EISTR_DATTEO_NO = 0x0
	// Timeout
	SDHC_EISTR_DATTEO_YES = 0x1
	// Position of DATCRC field.
	SDHC_EISTR_DATCRC_Pos = 0x5
	// Bit mask of DATCRC field.
	SDHC_EISTR_DATCRC_Msk = 0x20
	// Bit DATCRC.
	SDHC_EISTR_DATCRC = 0x20
	// No Error
	SDHC_EISTR_DATCRC_NO = 0x0
	// Error
	SDHC_EISTR_DATCRC_YES = 0x1
	// Position of DATEND field.
	SDHC_EISTR_DATEND_Pos = 0x6
	// Bit mask of DATEND field.
	SDHC_EISTR_DATEND_Msk = 0x40
	// Bit DATEND.
	SDHC_EISTR_DATEND = 0x40
	// No Error
	SDHC_EISTR_DATEND_NO = 0x0
	// Error
	SDHC_EISTR_DATEND_YES = 0x1
	// Position of CURLIM field.
	SDHC_EISTR_CURLIM_Pos = 0x7
	// Bit mask of CURLIM field.
	SDHC_EISTR_CURLIM_Msk = 0x80
	// Bit CURLIM.
	SDHC_EISTR_CURLIM = 0x80
	// No Error
	SDHC_EISTR_CURLIM_NO = 0x0
	// Power Fail
	SDHC_EISTR_CURLIM_YES = 0x1
	// Position of ACMD field.
	SDHC_EISTR_ACMD_Pos = 0x8
	// Bit mask of ACMD field.
	SDHC_EISTR_ACMD_Msk = 0x100
	// Bit ACMD.
	SDHC_EISTR_ACMD = 0x100
	// No Error
	SDHC_EISTR_ACMD_NO = 0x0
	// Error
	SDHC_EISTR_ACMD_YES = 0x1
	// Position of ADMA field.
	SDHC_EISTR_ADMA_Pos = 0x9
	// Bit mask of ADMA field.
	SDHC_EISTR_ADMA_Msk = 0x200
	// Bit ADMA.
	SDHC_EISTR_ADMA = 0x200
	// No Error
	SDHC_EISTR_ADMA_NO = 0x0
	// Error
	SDHC_EISTR_ADMA_YES = 0x1

	// EISTR_EMMC_MODE: Error Interrupt Status
	// Position of CMDTEO field.
	SDHC_EISTR_EMMC_MODE_CMDTEO_Pos = 0x0
	// Bit mask of CMDTEO field.
	SDHC_EISTR_EMMC_MODE_CMDTEO_Msk = 0x1
	// Bit CMDTEO.
	SDHC_EISTR_EMMC_MODE_CMDTEO = 0x1
	// No Error
	SDHC_EISTR_EMMC_MODE_CMDTEO_NO = 0x0
	// Timeout
	SDHC_EISTR_EMMC_MODE_CMDTEO_YES = 0x1
	// Position of CMDCRC field.
	SDHC_EISTR_EMMC_MODE_CMDCRC_Pos = 0x1
	// Bit mask of CMDCRC field.
	SDHC_EISTR_EMMC_MODE_CMDCRC_Msk = 0x2
	// Bit CMDCRC.
	SDHC_EISTR_EMMC_MODE_CMDCRC = 0x2
	// No Error
	SDHC_EISTR_EMMC_MODE_CMDCRC_NO = 0x0
	// CRC Error Generated
	SDHC_EISTR_EMMC_MODE_CMDCRC_YES = 0x1
	// Position of CMDEND field.
	SDHC_EISTR_EMMC_MODE_CMDEND_Pos = 0x2
	// Bit mask of CMDEND field.
	SDHC_EISTR_EMMC_MODE_CMDEND_Msk = 0x4
	// Bit CMDEND.
	SDHC_EISTR_EMMC_MODE_CMDEND = 0x4
	// No error
	SDHC_EISTR_EMMC_MODE_CMDEND_NO = 0x0
	// End Bit Error Generated
	SDHC_EISTR_EMMC_MODE_CMDEND_YES = 0x1
	// Position of CMDIDX field.
	SDHC_EISTR_EMMC_MODE_CMDIDX_Pos = 0x3
	// Bit mask of CMDIDX field.
	SDHC_EISTR_EMMC_MODE_CMDIDX_Msk = 0x8
	// Bit CMDIDX.
	SDHC_EISTR_EMMC_MODE_CMDIDX = 0x8
	// No Error
	SDHC_EISTR_EMMC_MODE_CMDIDX_NO = 0x0
	// Error
	SDHC_EISTR_EMMC_MODE_CMDIDX_YES = 0x1
	// Position of DATTEO field.
	SDHC_EISTR_EMMC_MODE_DATTEO_Pos = 0x4
	// Bit mask of DATTEO field.
	SDHC_EISTR_EMMC_MODE_DATTEO_Msk = 0x10
	// Bit DATTEO.
	SDHC_EISTR_EMMC_MODE_DATTEO = 0x10
	// No Error
	SDHC_EISTR_EMMC_MODE_DATTEO_NO = 0x0
	// Timeout
	SDHC_EISTR_EMMC_MODE_DATTEO_YES = 0x1
	// Position of DATCRC field.
	SDHC_EISTR_EMMC_MODE_DATCRC_Pos = 0x5
	// Bit mask of DATCRC field.
	SDHC_EISTR_EMMC_MODE_DATCRC_Msk = 0x20
	// Bit DATCRC.
	SDHC_EISTR_EMMC_MODE_DATCRC = 0x20
	// No Error
	SDHC_EISTR_EMMC_MODE_DATCRC_NO = 0x0
	// Error
	SDHC_EISTR_EMMC_MODE_DATCRC_YES = 0x1
	// Position of DATEND field.
	SDHC_EISTR_EMMC_MODE_DATEND_Pos = 0x6
	// Bit mask of DATEND field.
	SDHC_EISTR_EMMC_MODE_DATEND_Msk = 0x40
	// Bit DATEND.
	SDHC_EISTR_EMMC_MODE_DATEND = 0x40
	// No Error
	SDHC_EISTR_EMMC_MODE_DATEND_NO = 0x0
	// Error
	SDHC_EISTR_EMMC_MODE_DATEND_YES = 0x1
	// Position of CURLIM field.
	SDHC_EISTR_EMMC_MODE_CURLIM_Pos = 0x7
	// Bit mask of CURLIM field.
	SDHC_EISTR_EMMC_MODE_CURLIM_Msk = 0x80
	// Bit CURLIM.
	SDHC_EISTR_EMMC_MODE_CURLIM = 0x80
	// No Error
	SDHC_EISTR_EMMC_MODE_CURLIM_NO = 0x0
	// Power Fail
	SDHC_EISTR_EMMC_MODE_CURLIM_YES = 0x1
	// Position of ACMD field.
	SDHC_EISTR_EMMC_MODE_ACMD_Pos = 0x8
	// Bit mask of ACMD field.
	SDHC_EISTR_EMMC_MODE_ACMD_Msk = 0x100
	// Bit ACMD.
	SDHC_EISTR_EMMC_MODE_ACMD = 0x100
	// No Error
	SDHC_EISTR_EMMC_MODE_ACMD_NO = 0x0
	// Error
	SDHC_EISTR_EMMC_MODE_ACMD_YES = 0x1
	// Position of ADMA field.
	SDHC_EISTR_EMMC_MODE_ADMA_Pos = 0x9
	// Bit mask of ADMA field.
	SDHC_EISTR_EMMC_MODE_ADMA_Msk = 0x200
	// Bit ADMA.
	SDHC_EISTR_EMMC_MODE_ADMA = 0x200
	// No Error
	SDHC_EISTR_EMMC_MODE_ADMA_NO = 0x0
	// Error
	SDHC_EISTR_EMMC_MODE_ADMA_YES = 0x1
	// Position of BOOTAE field.
	SDHC_EISTR_EMMC_MODE_BOOTAE_Pos = 0xc
	// Bit mask of BOOTAE field.
	SDHC_EISTR_EMMC_MODE_BOOTAE_Msk = 0x1000
	// Bit BOOTAE.
	SDHC_EISTR_EMMC_MODE_BOOTAE = 0x1000
	// FIFO contains at least one byte
	SDHC_EISTR_EMMC_MODE_BOOTAE_0 = 0x0
	// FIFO is empty
	SDHC_EISTR_EMMC_MODE_BOOTAE_1 = 0x1

	// NISTER: Normal Interrupt Status Enable
	// Position of CMDC field.
	SDHC_NISTER_CMDC_Pos = 0x0
	// Bit mask of CMDC field.
	SDHC_NISTER_CMDC_Msk = 0x1
	// Bit CMDC.
	SDHC_NISTER_CMDC = 0x1
	// Masked
	SDHC_NISTER_CMDC_MASKED = 0x0
	// Enabled
	SDHC_NISTER_CMDC_ENABLED = 0x1
	// Position of TRFC field.
	SDHC_NISTER_TRFC_Pos = 0x1
	// Bit mask of TRFC field.
	SDHC_NISTER_TRFC_Msk = 0x2
	// Bit TRFC.
	SDHC_NISTER_TRFC = 0x2
	// Masked
	SDHC_NISTER_TRFC_MASKED = 0x0
	// Enabled
	SDHC_NISTER_TRFC_ENABLED = 0x1
	// Position of BLKGE field.
	SDHC_NISTER_BLKGE_Pos = 0x2
	// Bit mask of BLKGE field.
	SDHC_NISTER_BLKGE_Msk = 0x4
	// Bit BLKGE.
	SDHC_NISTER_BLKGE = 0x4
	// Masked
	SDHC_NISTER_BLKGE_MASKED = 0x0
	// Enabled
	SDHC_NISTER_BLKGE_ENABLED = 0x1
	// Position of DMAINT field.
	SDHC_NISTER_DMAINT_Pos = 0x3
	// Bit mask of DMAINT field.
	SDHC_NISTER_DMAINT_Msk = 0x8
	// Bit DMAINT.
	SDHC_NISTER_DMAINT = 0x8
	// Masked
	SDHC_NISTER_DMAINT_MASKED = 0x0
	// Enabled
	SDHC_NISTER_DMAINT_ENABLED = 0x1
	// Position of BWRRDY field.
	SDHC_NISTER_BWRRDY_Pos = 0x4
	// Bit mask of BWRRDY field.
	SDHC_NISTER_BWRRDY_Msk = 0x10
	// Bit BWRRDY.
	SDHC_NISTER_BWRRDY = 0x10
	// Masked
	SDHC_NISTER_BWRRDY_MASKED = 0x0
	// Enabled
	SDHC_NISTER_BWRRDY_ENABLED = 0x1
	// Position of BRDRDY field.
	SDHC_NISTER_BRDRDY_Pos = 0x5
	// Bit mask of BRDRDY field.
	SDHC_NISTER_BRDRDY_Msk = 0x20
	// Bit BRDRDY.
	SDHC_NISTER_BRDRDY = 0x20
	// Masked
	SDHC_NISTER_BRDRDY_MASKED = 0x0
	// Enabled
	SDHC_NISTER_BRDRDY_ENABLED = 0x1
	// Position of CINS field.
	SDHC_NISTER_CINS_Pos = 0x6
	// Bit mask of CINS field.
	SDHC_NISTER_CINS_Msk = 0x40
	// Bit CINS.
	SDHC_NISTER_CINS = 0x40
	// Masked
	SDHC_NISTER_CINS_MASKED = 0x0
	// Enabled
	SDHC_NISTER_CINS_ENABLED = 0x1
	// Position of CREM field.
	SDHC_NISTER_CREM_Pos = 0x7
	// Bit mask of CREM field.
	SDHC_NISTER_CREM_Msk = 0x80
	// Bit CREM.
	SDHC_NISTER_CREM = 0x80
	// Masked
	SDHC_NISTER_CREM_MASKED = 0x0
	// Enabled
	SDHC_NISTER_CREM_ENABLED = 0x1
	// Position of CINT field.
	SDHC_NISTER_CINT_Pos = 0x8
	// Bit mask of CINT field.
	SDHC_NISTER_CINT_Msk = 0x100
	// Bit CINT.
	SDHC_NISTER_CINT = 0x100
	// Masked
	SDHC_NISTER_CINT_MASKED = 0x0
	// Enabled
	SDHC_NISTER_CINT_ENABLED = 0x1

	// NISTER_EMMC_MODE: Normal Interrupt Status Enable
	// Position of CMDC field.
	SDHC_NISTER_EMMC_MODE_CMDC_Pos = 0x0
	// Bit mask of CMDC field.
	SDHC_NISTER_EMMC_MODE_CMDC_Msk = 0x1
	// Bit CMDC.
	SDHC_NISTER_EMMC_MODE_CMDC = 0x1
	// Masked
	SDHC_NISTER_EMMC_MODE_CMDC_MASKED = 0x0
	// Enabled
	SDHC_NISTER_EMMC_MODE_CMDC_ENABLED = 0x1
	// Position of TRFC field.
	SDHC_NISTER_EMMC_MODE_TRFC_Pos = 0x1
	// Bit mask of TRFC field.
	SDHC_NISTER_EMMC_MODE_TRFC_Msk = 0x2
	// Bit TRFC.
	SDHC_NISTER_EMMC_MODE_TRFC = 0x2
	// Masked
	SDHC_NISTER_EMMC_MODE_TRFC_MASKED = 0x0
	// Enabled
	SDHC_NISTER_EMMC_MODE_TRFC_ENABLED = 0x1
	// Position of BLKGE field.
	SDHC_NISTER_EMMC_MODE_BLKGE_Pos = 0x2
	// Bit mask of BLKGE field.
	SDHC_NISTER_EMMC_MODE_BLKGE_Msk = 0x4
	// Bit BLKGE.
	SDHC_NISTER_EMMC_MODE_BLKGE = 0x4
	// Masked
	SDHC_NISTER_EMMC_MODE_BLKGE_MASKED = 0x0
	// Enabled
	SDHC_NISTER_EMMC_MODE_BLKGE_ENABLED = 0x1
	// Position of DMAINT field.
	SDHC_NISTER_EMMC_MODE_DMAINT_Pos = 0x3
	// Bit mask of DMAINT field.
	SDHC_NISTER_EMMC_MODE_DMAINT_Msk = 0x8
	// Bit DMAINT.
	SDHC_NISTER_EMMC_MODE_DMAINT = 0x8
	// Masked
	SDHC_NISTER_EMMC_MODE_DMAINT_MASKED = 0x0
	// Enabled
	SDHC_NISTER_EMMC_MODE_DMAINT_ENABLED = 0x1
	// Position of BWRRDY field.
	SDHC_NISTER_EMMC_MODE_BWRRDY_Pos = 0x4
	// Bit mask of BWRRDY field.
	SDHC_NISTER_EMMC_MODE_BWRRDY_Msk = 0x10
	// Bit BWRRDY.
	SDHC_NISTER_EMMC_MODE_BWRRDY = 0x10
	// Masked
	SDHC_NISTER_EMMC_MODE_BWRRDY_MASKED = 0x0
	// Enabled
	SDHC_NISTER_EMMC_MODE_BWRRDY_ENABLED = 0x1
	// Position of BRDRDY field.
	SDHC_NISTER_EMMC_MODE_BRDRDY_Pos = 0x5
	// Bit mask of BRDRDY field.
	SDHC_NISTER_EMMC_MODE_BRDRDY_Msk = 0x20
	// Bit BRDRDY.
	SDHC_NISTER_EMMC_MODE_BRDRDY = 0x20
	// Masked
	SDHC_NISTER_EMMC_MODE_BRDRDY_MASKED = 0x0
	// Enabled
	SDHC_NISTER_EMMC_MODE_BRDRDY_ENABLED = 0x1
	// Position of BOOTAR field.
	SDHC_NISTER_EMMC_MODE_BOOTAR_Pos = 0xe
	// Bit mask of BOOTAR field.
	SDHC_NISTER_EMMC_MODE_BOOTAR_Msk = 0x4000
	// Bit BOOTAR.
	SDHC_NISTER_EMMC_MODE_BOOTAR = 0x4000

	// EISTER: Error Interrupt Status Enable
	// Position of CMDTEO field.
	SDHC_EISTER_CMDTEO_Pos = 0x0
	// Bit mask of CMDTEO field.
	SDHC_EISTER_CMDTEO_Msk = 0x1
	// Bit CMDTEO.
	SDHC_EISTER_CMDTEO = 0x1
	// Masked
	SDHC_EISTER_CMDTEO_MASKED = 0x0
	// Enabled
	SDHC_EISTER_CMDTEO_ENABLED = 0x1
	// Position of CMDCRC field.
	SDHC_EISTER_CMDCRC_Pos = 0x1
	// Bit mask of CMDCRC field.
	SDHC_EISTER_CMDCRC_Msk = 0x2
	// Bit CMDCRC.
	SDHC_EISTER_CMDCRC = 0x2
	// Masked
	SDHC_EISTER_CMDCRC_MASKED = 0x0
	// Enabled
	SDHC_EISTER_CMDCRC_ENABLED = 0x1
	// Position of CMDEND field.
	SDHC_EISTER_CMDEND_Pos = 0x2
	// Bit mask of CMDEND field.
	SDHC_EISTER_CMDEND_Msk = 0x4
	// Bit CMDEND.
	SDHC_EISTER_CMDEND = 0x4
	// Masked
	SDHC_EISTER_CMDEND_MASKED = 0x0
	// Enabled
	SDHC_EISTER_CMDEND_ENABLED = 0x1
	// Position of CMDIDX field.
	SDHC_EISTER_CMDIDX_Pos = 0x3
	// Bit mask of CMDIDX field.
	SDHC_EISTER_CMDIDX_Msk = 0x8
	// Bit CMDIDX.
	SDHC_EISTER_CMDIDX = 0x8
	// Masked
	SDHC_EISTER_CMDIDX_MASKED = 0x0
	// Enabled
	SDHC_EISTER_CMDIDX_ENABLED = 0x1
	// Position of DATTEO field.
	SDHC_EISTER_DATTEO_Pos = 0x4
	// Bit mask of DATTEO field.
	SDHC_EISTER_DATTEO_Msk = 0x10
	// Bit DATTEO.
	SDHC_EISTER_DATTEO = 0x10
	// Masked
	SDHC_EISTER_DATTEO_MASKED = 0x0
	// Enabled
	SDHC_EISTER_DATTEO_ENABLED = 0x1
	// Position of DATCRC field.
	SDHC_EISTER_DATCRC_Pos = 0x5
	// Bit mask of DATCRC field.
	SDHC_EISTER_DATCRC_Msk = 0x20
	// Bit DATCRC.
	SDHC_EISTER_DATCRC = 0x20
	// Masked
	SDHC_EISTER_DATCRC_MASKED = 0x0
	// Enabled
	SDHC_EISTER_DATCRC_ENABLED = 0x1
	// Position of DATEND field.
	SDHC_EISTER_DATEND_Pos = 0x6
	// Bit mask of DATEND field.
	SDHC_EISTER_DATEND_Msk = 0x40
	// Bit DATEND.
	SDHC_EISTER_DATEND = 0x40
	// Masked
	SDHC_EISTER_DATEND_MASKED = 0x0
	// Enabled
	SDHC_EISTER_DATEND_ENABLED = 0x1
	// Position of CURLIM field.
	SDHC_EISTER_CURLIM_Pos = 0x7
	// Bit mask of CURLIM field.
	SDHC_EISTER_CURLIM_Msk = 0x80
	// Bit CURLIM.
	SDHC_EISTER_CURLIM = 0x80
	// Masked
	SDHC_EISTER_CURLIM_MASKED = 0x0
	// Enabled
	SDHC_EISTER_CURLIM_ENABLED = 0x1
	// Position of ACMD field.
	SDHC_EISTER_ACMD_Pos = 0x8
	// Bit mask of ACMD field.
	SDHC_EISTER_ACMD_Msk = 0x100
	// Bit ACMD.
	SDHC_EISTER_ACMD = 0x100
	// Masked
	SDHC_EISTER_ACMD_MASKED = 0x0
	// Enabled
	SDHC_EISTER_ACMD_ENABLED = 0x1
	// Position of ADMA field.
	SDHC_EISTER_ADMA_Pos = 0x9
	// Bit mask of ADMA field.
	SDHC_EISTER_ADMA_Msk = 0x200
	// Bit ADMA.
	SDHC_EISTER_ADMA = 0x200
	// Masked
	SDHC_EISTER_ADMA_MASKED = 0x0
	// Enabled
	SDHC_EISTER_ADMA_ENABLED = 0x1

	// EISTER_EMMC_MODE: Error Interrupt Status Enable
	// Position of CMDTEO field.
	SDHC_EISTER_EMMC_MODE_CMDTEO_Pos = 0x0
	// Bit mask of CMDTEO field.
	SDHC_EISTER_EMMC_MODE_CMDTEO_Msk = 0x1
	// Bit CMDTEO.
	SDHC_EISTER_EMMC_MODE_CMDTEO = 0x1
	// Masked
	SDHC_EISTER_EMMC_MODE_CMDTEO_MASKED = 0x0
	// Enabled
	SDHC_EISTER_EMMC_MODE_CMDTEO_ENABLED = 0x1
	// Position of CMDCRC field.
	SDHC_EISTER_EMMC_MODE_CMDCRC_Pos = 0x1
	// Bit mask of CMDCRC field.
	SDHC_EISTER_EMMC_MODE_CMDCRC_Msk = 0x2
	// Bit CMDCRC.
	SDHC_EISTER_EMMC_MODE_CMDCRC = 0x2
	// Masked
	SDHC_EISTER_EMMC_MODE_CMDCRC_MASKED = 0x0
	// Enabled
	SDHC_EISTER_EMMC_MODE_CMDCRC_ENABLED = 0x1
	// Position of CMDEND field.
	SDHC_EISTER_EMMC_MODE_CMDEND_Pos = 0x2
	// Bit mask of CMDEND field.
	SDHC_EISTER_EMMC_MODE_CMDEND_Msk = 0x4
	// Bit CMDEND.
	SDHC_EISTER_EMMC_MODE_CMDEND = 0x4
	// Masked
	SDHC_EISTER_EMMC_MODE_CMDEND_MASKED = 0x0
	// Enabled
	SDHC_EISTER_EMMC_MODE_CMDEND_ENABLED = 0x1
	// Position of CMDIDX field.
	SDHC_EISTER_EMMC_MODE_CMDIDX_Pos = 0x3
	// Bit mask of CMDIDX field.
	SDHC_EISTER_EMMC_MODE_CMDIDX_Msk = 0x8
	// Bit CMDIDX.
	SDHC_EISTER_EMMC_MODE_CMDIDX = 0x8
	// Masked
	SDHC_EISTER_EMMC_MODE_CMDIDX_MASKED = 0x0
	// Enabled
	SDHC_EISTER_EMMC_MODE_CMDIDX_ENABLED = 0x1
	// Position of DATTEO field.
	SDHC_EISTER_EMMC_MODE_DATTEO_Pos = 0x4
	// Bit mask of DATTEO field.
	SDHC_EISTER_EMMC_MODE_DATTEO_Msk = 0x10
	// Bit DATTEO.
	SDHC_EISTER_EMMC_MODE_DATTEO = 0x10
	// Masked
	SDHC_EISTER_EMMC_MODE_DATTEO_MASKED = 0x0
	// Enabled
	SDHC_EISTER_EMMC_MODE_DATTEO_ENABLED = 0x1
	// Position of DATCRC field.
	SDHC_EISTER_EMMC_MODE_DATCRC_Pos = 0x5
	// Bit mask of DATCRC field.
	SDHC_EISTER_EMMC_MODE_DATCRC_Msk = 0x20
	// Bit DATCRC.
	SDHC_EISTER_EMMC_MODE_DATCRC = 0x20
	// Masked
	SDHC_EISTER_EMMC_MODE_DATCRC_MASKED = 0x0
	// Enabled
	SDHC_EISTER_EMMC_MODE_DATCRC_ENABLED = 0x1
	// Position of DATEND field.
	SDHC_EISTER_EMMC_MODE_DATEND_Pos = 0x6
	// Bit mask of DATEND field.
	SDHC_EISTER_EMMC_MODE_DATEND_Msk = 0x40
	// Bit DATEND.
	SDHC_EISTER_EMMC_MODE_DATEND = 0x40
	// Masked
	SDHC_EISTER_EMMC_MODE_DATEND_MASKED = 0x0
	// Enabled
	SDHC_EISTER_EMMC_MODE_DATEND_ENABLED = 0x1
	// Position of CURLIM field.
	SDHC_EISTER_EMMC_MODE_CURLIM_Pos = 0x7
	// Bit mask of CURLIM field.
	SDHC_EISTER_EMMC_MODE_CURLIM_Msk = 0x80
	// Bit CURLIM.
	SDHC_EISTER_EMMC_MODE_CURLIM = 0x80
	// Masked
	SDHC_EISTER_EMMC_MODE_CURLIM_MASKED = 0x0
	// Enabled
	SDHC_EISTER_EMMC_MODE_CURLIM_ENABLED = 0x1
	// Position of ACMD field.
	SDHC_EISTER_EMMC_MODE_ACMD_Pos = 0x8
	// Bit mask of ACMD field.
	SDHC_EISTER_EMMC_MODE_ACMD_Msk = 0x100
	// Bit ACMD.
	SDHC_EISTER_EMMC_MODE_ACMD = 0x100
	// Masked
	SDHC_EISTER_EMMC_MODE_ACMD_MASKED = 0x0
	// Enabled
	SDHC_EISTER_EMMC_MODE_ACMD_ENABLED = 0x1
	// Position of ADMA field.
	SDHC_EISTER_EMMC_MODE_ADMA_Pos = 0x9
	// Bit mask of ADMA field.
	SDHC_EISTER_EMMC_MODE_ADMA_Msk = 0x200
	// Bit ADMA.
	SDHC_EISTER_EMMC_MODE_ADMA = 0x200
	// Masked
	SDHC_EISTER_EMMC_MODE_ADMA_MASKED = 0x0
	// Enabled
	SDHC_EISTER_EMMC_MODE_ADMA_ENABLED = 0x1
	// Position of BOOTAE field.
	SDHC_EISTER_EMMC_MODE_BOOTAE_Pos = 0xc
	// Bit mask of BOOTAE field.
	SDHC_EISTER_EMMC_MODE_BOOTAE_Msk = 0x1000
	// Bit BOOTAE.
	SDHC_EISTER_EMMC_MODE_BOOTAE = 0x1000

	// NISIER: Normal Interrupt Signal Enable
	// Position of CMDC field.
	SDHC_NISIER_CMDC_Pos = 0x0
	// Bit mask of CMDC field.
	SDHC_NISIER_CMDC_Msk = 0x1
	// Bit CMDC.
	SDHC_NISIER_CMDC = 0x1
	// Masked
	SDHC_NISIER_CMDC_MASKED = 0x0
	// Enabled
	SDHC_NISIER_CMDC_ENABLED = 0x1
	// Position of TRFC field.
	SDHC_NISIER_TRFC_Pos = 0x1
	// Bit mask of TRFC field.
	SDHC_NISIER_TRFC_Msk = 0x2
	// Bit TRFC.
	SDHC_NISIER_TRFC = 0x2
	// Masked
	SDHC_NISIER_TRFC_MASKED = 0x0
	// Enabled
	SDHC_NISIER_TRFC_ENABLED = 0x1
	// Position of BLKGE field.
	SDHC_NISIER_BLKGE_Pos = 0x2
	// Bit mask of BLKGE field.
	SDHC_NISIER_BLKGE_Msk = 0x4
	// Bit BLKGE.
	SDHC_NISIER_BLKGE = 0x4
	// Masked
	SDHC_NISIER_BLKGE_MASKED = 0x0
	// Enabled
	SDHC_NISIER_BLKGE_ENABLED = 0x1
	// Position of DMAINT field.
	SDHC_NISIER_DMAINT_Pos = 0x3
	// Bit mask of DMAINT field.
	SDHC_NISIER_DMAINT_Msk = 0x8
	// Bit DMAINT.
	SDHC_NISIER_DMAINT = 0x8
	// Masked
	SDHC_NISIER_DMAINT_MASKED = 0x0
	// Enabled
	SDHC_NISIER_DMAINT_ENABLED = 0x1
	// Position of BWRRDY field.
	SDHC_NISIER_BWRRDY_Pos = 0x4
	// Bit mask of BWRRDY field.
	SDHC_NISIER_BWRRDY_Msk = 0x10
	// Bit BWRRDY.
	SDHC_NISIER_BWRRDY = 0x10
	// Masked
	SDHC_NISIER_BWRRDY_MASKED = 0x0
	// Enabled
	SDHC_NISIER_BWRRDY_ENABLED = 0x1
	// Position of BRDRDY field.
	SDHC_NISIER_BRDRDY_Pos = 0x5
	// Bit mask of BRDRDY field.
	SDHC_NISIER_BRDRDY_Msk = 0x20
	// Bit BRDRDY.
	SDHC_NISIER_BRDRDY = 0x20
	// Masked
	SDHC_NISIER_BRDRDY_MASKED = 0x0
	// Enabled
	SDHC_NISIER_BRDRDY_ENABLED = 0x1
	// Position of CINS field.
	SDHC_NISIER_CINS_Pos = 0x6
	// Bit mask of CINS field.
	SDHC_NISIER_CINS_Msk = 0x40
	// Bit CINS.
	SDHC_NISIER_CINS = 0x40
	// Masked
	SDHC_NISIER_CINS_MASKED = 0x0
	// Enabled
	SDHC_NISIER_CINS_ENABLED = 0x1
	// Position of CREM field.
	SDHC_NISIER_CREM_Pos = 0x7
	// Bit mask of CREM field.
	SDHC_NISIER_CREM_Msk = 0x80
	// Bit CREM.
	SDHC_NISIER_CREM = 0x80
	// Masked
	SDHC_NISIER_CREM_MASKED = 0x0
	// Enabled
	SDHC_NISIER_CREM_ENABLED = 0x1
	// Position of CINT field.
	SDHC_NISIER_CINT_Pos = 0x8
	// Bit mask of CINT field.
	SDHC_NISIER_CINT_Msk = 0x100
	// Bit CINT.
	SDHC_NISIER_CINT = 0x100
	// Masked
	SDHC_NISIER_CINT_MASKED = 0x0
	// Enabled
	SDHC_NISIER_CINT_ENABLED = 0x1

	// NISIER_EMMC_MODE: Normal Interrupt Signal Enable
	// Position of CMDC field.
	SDHC_NISIER_EMMC_MODE_CMDC_Pos = 0x0
	// Bit mask of CMDC field.
	SDHC_NISIER_EMMC_MODE_CMDC_Msk = 0x1
	// Bit CMDC.
	SDHC_NISIER_EMMC_MODE_CMDC = 0x1
	// Masked
	SDHC_NISIER_EMMC_MODE_CMDC_MASKED = 0x0
	// Enabled
	SDHC_NISIER_EMMC_MODE_CMDC_ENABLED = 0x1
	// Position of TRFC field.
	SDHC_NISIER_EMMC_MODE_TRFC_Pos = 0x1
	// Bit mask of TRFC field.
	SDHC_NISIER_EMMC_MODE_TRFC_Msk = 0x2
	// Bit TRFC.
	SDHC_NISIER_EMMC_MODE_TRFC = 0x2
	// Masked
	SDHC_NISIER_EMMC_MODE_TRFC_MASKED = 0x0
	// Enabled
	SDHC_NISIER_EMMC_MODE_TRFC_ENABLED = 0x1
	// Position of BLKGE field.
	SDHC_NISIER_EMMC_MODE_BLKGE_Pos = 0x2
	// Bit mask of BLKGE field.
	SDHC_NISIER_EMMC_MODE_BLKGE_Msk = 0x4
	// Bit BLKGE.
	SDHC_NISIER_EMMC_MODE_BLKGE = 0x4
	// Masked
	SDHC_NISIER_EMMC_MODE_BLKGE_MASKED = 0x0
	// Enabled
	SDHC_NISIER_EMMC_MODE_BLKGE_ENABLED = 0x1
	// Position of DMAINT field.
	SDHC_NISIER_EMMC_MODE_DMAINT_Pos = 0x3
	// Bit mask of DMAINT field.
	SDHC_NISIER_EMMC_MODE_DMAINT_Msk = 0x8
	// Bit DMAINT.
	SDHC_NISIER_EMMC_MODE_DMAINT = 0x8
	// Masked
	SDHC_NISIER_EMMC_MODE_DMAINT_MASKED = 0x0
	// Enabled
	SDHC_NISIER_EMMC_MODE_DMAINT_ENABLED = 0x1
	// Position of BWRRDY field.
	SDHC_NISIER_EMMC_MODE_BWRRDY_Pos = 0x4
	// Bit mask of BWRRDY field.
	SDHC_NISIER_EMMC_MODE_BWRRDY_Msk = 0x10
	// Bit BWRRDY.
	SDHC_NISIER_EMMC_MODE_BWRRDY = 0x10
	// Masked
	SDHC_NISIER_EMMC_MODE_BWRRDY_MASKED = 0x0
	// Enabled
	SDHC_NISIER_EMMC_MODE_BWRRDY_ENABLED = 0x1
	// Position of BRDRDY field.
	SDHC_NISIER_EMMC_MODE_BRDRDY_Pos = 0x5
	// Bit mask of BRDRDY field.
	SDHC_NISIER_EMMC_MODE_BRDRDY_Msk = 0x20
	// Bit BRDRDY.
	SDHC_NISIER_EMMC_MODE_BRDRDY = 0x20
	// Masked
	SDHC_NISIER_EMMC_MODE_BRDRDY_MASKED = 0x0
	// Enabled
	SDHC_NISIER_EMMC_MODE_BRDRDY_ENABLED = 0x1
	// Position of BOOTAR field.
	SDHC_NISIER_EMMC_MODE_BOOTAR_Pos = 0xe
	// Bit mask of BOOTAR field.
	SDHC_NISIER_EMMC_MODE_BOOTAR_Msk = 0x4000
	// Bit BOOTAR.
	SDHC_NISIER_EMMC_MODE_BOOTAR = 0x4000

	// EISIER: Error Interrupt Signal Enable
	// Position of CMDTEO field.
	SDHC_EISIER_CMDTEO_Pos = 0x0
	// Bit mask of CMDTEO field.
	SDHC_EISIER_CMDTEO_Msk = 0x1
	// Bit CMDTEO.
	SDHC_EISIER_CMDTEO = 0x1
	// Masked
	SDHC_EISIER_CMDTEO_MASKED = 0x0
	// Enabled
	SDHC_EISIER_CMDTEO_ENABLED = 0x1
	// Position of CMDCRC field.
	SDHC_EISIER_CMDCRC_Pos = 0x1
	// Bit mask of CMDCRC field.
	SDHC_EISIER_CMDCRC_Msk = 0x2
	// Bit CMDCRC.
	SDHC_EISIER_CMDCRC = 0x2
	// Masked
	SDHC_EISIER_CMDCRC_MASKED = 0x0
	// Enabled
	SDHC_EISIER_CMDCRC_ENABLED = 0x1
	// Position of CMDEND field.
	SDHC_EISIER_CMDEND_Pos = 0x2
	// Bit mask of CMDEND field.
	SDHC_EISIER_CMDEND_Msk = 0x4
	// Bit CMDEND.
	SDHC_EISIER_CMDEND = 0x4
	// Masked
	SDHC_EISIER_CMDEND_MASKED = 0x0
	// Enabled
	SDHC_EISIER_CMDEND_ENABLED = 0x1
	// Position of CMDIDX field.
	SDHC_EISIER_CMDIDX_Pos = 0x3
	// Bit mask of CMDIDX field.
	SDHC_EISIER_CMDIDX_Msk = 0x8
	// Bit CMDIDX.
	SDHC_EISIER_CMDIDX = 0x8
	// Masked
	SDHC_EISIER_CMDIDX_MASKED = 0x0
	// Enabled
	SDHC_EISIER_CMDIDX_ENABLED = 0x1
	// Position of DATTEO field.
	SDHC_EISIER_DATTEO_Pos = 0x4
	// Bit mask of DATTEO field.
	SDHC_EISIER_DATTEO_Msk = 0x10
	// Bit DATTEO.
	SDHC_EISIER_DATTEO = 0x10
	// Masked
	SDHC_EISIER_DATTEO_MASKED = 0x0
	// Enabled
	SDHC_EISIER_DATTEO_ENABLED = 0x1
	// Position of DATCRC field.
	SDHC_EISIER_DATCRC_Pos = 0x5
	// Bit mask of DATCRC field.
	SDHC_EISIER_DATCRC_Msk = 0x20
	// Bit DATCRC.
	SDHC_EISIER_DATCRC = 0x20
	// Masked
	SDHC_EISIER_DATCRC_MASKED = 0x0
	// Enabled
	SDHC_EISIER_DATCRC_ENABLED = 0x1
	// Position of DATEND field.
	SDHC_EISIER_DATEND_Pos = 0x6
	// Bit mask of DATEND field.
	SDHC_EISIER_DATEND_Msk = 0x40
	// Bit DATEND.
	SDHC_EISIER_DATEND = 0x40
	// Masked
	SDHC_EISIER_DATEND_MASKED = 0x0
	// Enabled
	SDHC_EISIER_DATEND_ENABLED = 0x1
	// Position of CURLIM field.
	SDHC_EISIER_CURLIM_Pos = 0x7
	// Bit mask of CURLIM field.
	SDHC_EISIER_CURLIM_Msk = 0x80
	// Bit CURLIM.
	SDHC_EISIER_CURLIM = 0x80
	// Masked
	SDHC_EISIER_CURLIM_MASKED = 0x0
	// Enabled
	SDHC_EISIER_CURLIM_ENABLED = 0x1
	// Position of ACMD field.
	SDHC_EISIER_ACMD_Pos = 0x8
	// Bit mask of ACMD field.
	SDHC_EISIER_ACMD_Msk = 0x100
	// Bit ACMD.
	SDHC_EISIER_ACMD = 0x100
	// Masked
	SDHC_EISIER_ACMD_MASKED = 0x0
	// Enabled
	SDHC_EISIER_ACMD_ENABLED = 0x1
	// Position of ADMA field.
	SDHC_EISIER_ADMA_Pos = 0x9
	// Bit mask of ADMA field.
	SDHC_EISIER_ADMA_Msk = 0x200
	// Bit ADMA.
	SDHC_EISIER_ADMA = 0x200
	// Masked
	SDHC_EISIER_ADMA_MASKED = 0x0
	// Enabled
	SDHC_EISIER_ADMA_ENABLED = 0x1

	// EISIER_EMMC_MODE: Error Interrupt Signal Enable
	// Position of CMDTEO field.
	SDHC_EISIER_EMMC_MODE_CMDTEO_Pos = 0x0
	// Bit mask of CMDTEO field.
	SDHC_EISIER_EMMC_MODE_CMDTEO_Msk = 0x1
	// Bit CMDTEO.
	SDHC_EISIER_EMMC_MODE_CMDTEO = 0x1
	// Masked
	SDHC_EISIER_EMMC_MODE_CMDTEO_MASKED = 0x0
	// Enabled
	SDHC_EISIER_EMMC_MODE_CMDTEO_ENABLED = 0x1
	// Position of CMDCRC field.
	SDHC_EISIER_EMMC_MODE_CMDCRC_Pos = 0x1
	// Bit mask of CMDCRC field.
	SDHC_EISIER_EMMC_MODE_CMDCRC_Msk = 0x2
	// Bit CMDCRC.
	SDHC_EISIER_EMMC_MODE_CMDCRC = 0x2
	// Masked
	SDHC_EISIER_EMMC_MODE_CMDCRC_MASKED = 0x0
	// Enabled
	SDHC_EISIER_EMMC_MODE_CMDCRC_ENABLED = 0x1
	// Position of CMDEND field.
	SDHC_EISIER_EMMC_MODE_CMDEND_Pos = 0x2
	// Bit mask of CMDEND field.
	SDHC_EISIER_EMMC_MODE_CMDEND_Msk = 0x4
	// Bit CMDEND.
	SDHC_EISIER_EMMC_MODE_CMDEND = 0x4
	// Masked
	SDHC_EISIER_EMMC_MODE_CMDEND_MASKED = 0x0
	// Enabled
	SDHC_EISIER_EMMC_MODE_CMDEND_ENABLED = 0x1
	// Position of CMDIDX field.
	SDHC_EISIER_EMMC_MODE_CMDIDX_Pos = 0x3
	// Bit mask of CMDIDX field.
	SDHC_EISIER_EMMC_MODE_CMDIDX_Msk = 0x8
	// Bit CMDIDX.
	SDHC_EISIER_EMMC_MODE_CMDIDX = 0x8
	// Masked
	SDHC_EISIER_EMMC_MODE_CMDIDX_MASKED = 0x0
	// Enabled
	SDHC_EISIER_EMMC_MODE_CMDIDX_ENABLED = 0x1
	// Position of DATTEO field.
	SDHC_EISIER_EMMC_MODE_DATTEO_Pos = 0x4
	// Bit mask of DATTEO field.
	SDHC_EISIER_EMMC_MODE_DATTEO_Msk = 0x10
	// Bit DATTEO.
	SDHC_EISIER_EMMC_MODE_DATTEO = 0x10
	// Masked
	SDHC_EISIER_EMMC_MODE_DATTEO_MASKED = 0x0
	// Enabled
	SDHC_EISIER_EMMC_MODE_DATTEO_ENABLED = 0x1
	// Position of DATCRC field.
	SDHC_EISIER_EMMC_MODE_DATCRC_Pos = 0x5
	// Bit mask of DATCRC field.
	SDHC_EISIER_EMMC_MODE_DATCRC_Msk = 0x20
	// Bit DATCRC.
	SDHC_EISIER_EMMC_MODE_DATCRC = 0x20
	// Masked
	SDHC_EISIER_EMMC_MODE_DATCRC_MASKED = 0x0
	// Enabled
	SDHC_EISIER_EMMC_MODE_DATCRC_ENABLED = 0x1
	// Position of DATEND field.
	SDHC_EISIER_EMMC_MODE_DATEND_Pos = 0x6
	// Bit mask of DATEND field.
	SDHC_EISIER_EMMC_MODE_DATEND_Msk = 0x40
	// Bit DATEND.
	SDHC_EISIER_EMMC_MODE_DATEND = 0x40
	// Masked
	SDHC_EISIER_EMMC_MODE_DATEND_MASKED = 0x0
	// Enabled
	SDHC_EISIER_EMMC_MODE_DATEND_ENABLED = 0x1
	// Position of CURLIM field.
	SDHC_EISIER_EMMC_MODE_CURLIM_Pos = 0x7
	// Bit mask of CURLIM field.
	SDHC_EISIER_EMMC_MODE_CURLIM_Msk = 0x80
	// Bit CURLIM.
	SDHC_EISIER_EMMC_MODE_CURLIM = 0x80
	// Masked
	SDHC_EISIER_EMMC_MODE_CURLIM_MASKED = 0x0
	// Enabled
	SDHC_EISIER_EMMC_MODE_CURLIM_ENABLED = 0x1
	// Position of ACMD field.
	SDHC_EISIER_EMMC_MODE_ACMD_Pos = 0x8
	// Bit mask of ACMD field.
	SDHC_EISIER_EMMC_MODE_ACMD_Msk = 0x100
	// Bit ACMD.
	SDHC_EISIER_EMMC_MODE_ACMD = 0x100
	// Masked
	SDHC_EISIER_EMMC_MODE_ACMD_MASKED = 0x0
	// Enabled
	SDHC_EISIER_EMMC_MODE_ACMD_ENABLED = 0x1
	// Position of ADMA field.
	SDHC_EISIER_EMMC_MODE_ADMA_Pos = 0x9
	// Bit mask of ADMA field.
	SDHC_EISIER_EMMC_MODE_ADMA_Msk = 0x200
	// Bit ADMA.
	SDHC_EISIER_EMMC_MODE_ADMA = 0x200
	// Masked
	SDHC_EISIER_EMMC_MODE_ADMA_MASKED = 0x0
	// Enabled
	SDHC_EISIER_EMMC_MODE_ADMA_ENABLED = 0x1
	// Position of BOOTAE field.
	SDHC_EISIER_EMMC_MODE_BOOTAE_Pos = 0xc
	// Bit mask of BOOTAE field.
	SDHC_EISIER_EMMC_MODE_BOOTAE_Msk = 0x1000
	// Bit BOOTAE.
	SDHC_EISIER_EMMC_MODE_BOOTAE = 0x1000

	// ACESR: Auto CMD Error Status
	// Position of ACMD12NE field.
	SDHC_ACESR_ACMD12NE_Pos = 0x0
	// Bit mask of ACMD12NE field.
	SDHC_ACESR_ACMD12NE_Msk = 0x1
	// Bit ACMD12NE.
	SDHC_ACESR_ACMD12NE = 0x1
	// Executed
	SDHC_ACESR_ACMD12NE_EXEC = 0x0
	// Not executed
	SDHC_ACESR_ACMD12NE_NOT_EXEC = 0x1
	// Position of ACMDTEO field.
	SDHC_ACESR_ACMDTEO_Pos = 0x1
	// Bit mask of ACMDTEO field.
	SDHC_ACESR_ACMDTEO_Msk = 0x2
	// Bit ACMDTEO.
	SDHC_ACESR_ACMDTEO = 0x2
	// No error
	SDHC_ACESR_ACMDTEO_NO = 0x0
	// Timeout
	SDHC_ACESR_ACMDTEO_YES = 0x1
	// Position of ACMDCRC field.
	SDHC_ACESR_ACMDCRC_Pos = 0x2
	// Bit mask of ACMDCRC field.
	SDHC_ACESR_ACMDCRC_Msk = 0x4
	// Bit ACMDCRC.
	SDHC_ACESR_ACMDCRC = 0x4
	// No error
	SDHC_ACESR_ACMDCRC_NO = 0x0
	// CRC Error Generated
	SDHC_ACESR_ACMDCRC_YES = 0x1
	// Position of ACMDEND field.
	SDHC_ACESR_ACMDEND_Pos = 0x3
	// Bit mask of ACMDEND field.
	SDHC_ACESR_ACMDEND_Msk = 0x8
	// Bit ACMDEND.
	SDHC_ACESR_ACMDEND = 0x8
	// No error
	SDHC_ACESR_ACMDEND_NO = 0x0
	// End Bit Error Generated
	SDHC_ACESR_ACMDEND_YES = 0x1
	// Position of ACMDIDX field.
	SDHC_ACESR_ACMDIDX_Pos = 0x4
	// Bit mask of ACMDIDX field.
	SDHC_ACESR_ACMDIDX_Msk = 0x10
	// Bit ACMDIDX.
	SDHC_ACESR_ACMDIDX = 0x10
	// No error
	SDHC_ACESR_ACMDIDX_NO = 0x0
	// Error
	SDHC_ACESR_ACMDIDX_YES = 0x1
	// Position of CMDNI field.
	SDHC_ACESR_CMDNI_Pos = 0x7
	// Bit mask of CMDNI field.
	SDHC_ACESR_CMDNI_Msk = 0x80
	// Bit CMDNI.
	SDHC_ACESR_CMDNI = 0x80
	// No error
	SDHC_ACESR_CMDNI_OK = 0x0
	// Not Issued
	SDHC_ACESR_CMDNI_NOT_ISSUED = 0x1

	// HC2R: Host Control 2
	// Position of UHSMS field.
	SDHC_HC2R_UHSMS_Pos = 0x0
	// Bit mask of UHSMS field.
	SDHC_HC2R_UHSMS_Msk = 0x7
	// SDR12
	SDHC_HC2R_UHSMS_SDR12 = 0x0
	// SDR25
	SDHC_HC2R_UHSMS_SDR25 = 0x1
	// SDR50
	SDHC_HC2R_UHSMS_SDR50 = 0x2
	// SDR104
	SDHC_HC2R_UHSMS_SDR104 = 0x3
	// DDR50
	SDHC_HC2R_UHSMS_DDR50 = 0x4
	// Position of VS18EN field.
	SDHC_HC2R_VS18EN_Pos = 0x3
	// Bit mask of VS18EN field.
	SDHC_HC2R_VS18EN_Msk = 0x8
	// Bit VS18EN.
	SDHC_HC2R_VS18EN = 0x8
	// 3.3V Signaling
	SDHC_HC2R_VS18EN_S33V = 0x0
	// 1.8V Signaling
	SDHC_HC2R_VS18EN_S18V = 0x1
	// Position of DRVSEL field.
	SDHC_HC2R_DRVSEL_Pos = 0x4
	// Bit mask of DRVSEL field.
	SDHC_HC2R_DRVSEL_Msk = 0x30
	// Driver Type B is Selected (Default)
	SDHC_HC2R_DRVSEL_B = 0x0
	// Driver Type A is Selected
	SDHC_HC2R_DRVSEL_A = 0x1
	// Driver Type C is Selected
	SDHC_HC2R_DRVSEL_C = 0x2
	// Driver Type D is Selected
	SDHC_HC2R_DRVSEL_D = 0x3
	// Position of EXTUN field.
	SDHC_HC2R_EXTUN_Pos = 0x6
	// Bit mask of EXTUN field.
	SDHC_HC2R_EXTUN_Msk = 0x40
	// Bit EXTUN.
	SDHC_HC2R_EXTUN = 0x40
	// Not Tuned or Tuning Completed
	SDHC_HC2R_EXTUN_NO = 0x0
	// Execute Tuning
	SDHC_HC2R_EXTUN_REQUESTED = 0x1
	// Position of SLCKSEL field.
	SDHC_HC2R_SLCKSEL_Pos = 0x7
	// Bit mask of SLCKSEL field.
	SDHC_HC2R_SLCKSEL_Msk = 0x80
	// Bit SLCKSEL.
	SDHC_HC2R_SLCKSEL = 0x80
	// Fixed clock is used to sample data
	SDHC_HC2R_SLCKSEL_FIXED = 0x0
	// Tuned clock is used to sample data
	SDHC_HC2R_SLCKSEL_TUNED = 0x1
	// Position of ASINTEN field.
	SDHC_HC2R_ASINTEN_Pos = 0xe
	// Bit mask of ASINTEN field.
	SDHC_HC2R_ASINTEN_Msk = 0x4000
	// Bit ASINTEN.
	SDHC_HC2R_ASINTEN = 0x4000
	// Disabled
	SDHC_HC2R_ASINTEN_DISABLED = 0x0
	// Enabled
	SDHC_HC2R_ASINTEN_ENABLED = 0x1
	// Position of PVALEN field.
	SDHC_HC2R_PVALEN_Pos = 0xf
	// Bit mask of PVALEN field.
	SDHC_HC2R_PVALEN_Msk = 0x8000
	// Bit PVALEN.
	SDHC_HC2R_PVALEN = 0x8000
	// SDCLK and Driver Strength are controlled by Host Controller
	SDHC_HC2R_PVALEN_HOST = 0x0
	// Automatic Selection by Preset Value is Enabled
	SDHC_HC2R_PVALEN_AUTO = 0x1

	// HC2R_EMMC_MODE: Host Control 2
	// Position of HS200EN field.
	SDHC_HC2R_EMMC_MODE_HS200EN_Pos = 0x0
	// Bit mask of HS200EN field.
	SDHC_HC2R_EMMC_MODE_HS200EN_Msk = 0xf
	// SDR12
	SDHC_HC2R_EMMC_MODE_HS200EN_SDR12 = 0x0
	// SDR25
	SDHC_HC2R_EMMC_MODE_HS200EN_SDR25 = 0x1
	// SDR50
	SDHC_HC2R_EMMC_MODE_HS200EN_SDR50 = 0x2
	// SDR104
	SDHC_HC2R_EMMC_MODE_HS200EN_SDR104 = 0x3
	// DDR50
	SDHC_HC2R_EMMC_MODE_HS200EN_DDR50 = 0x4
	// Position of DRVSEL field.
	SDHC_HC2R_EMMC_MODE_DRVSEL_Pos = 0x4
	// Bit mask of DRVSEL field.
	SDHC_HC2R_EMMC_MODE_DRVSEL_Msk = 0x30
	// Driver Type B is Selected (Default)
	SDHC_HC2R_EMMC_MODE_DRVSEL_B = 0x0
	// Driver Type A is Selected
	SDHC_HC2R_EMMC_MODE_DRVSEL_A = 0x1
	// Driver Type C is Selected
	SDHC_HC2R_EMMC_MODE_DRVSEL_C = 0x2
	// Driver Type D is Selected
	SDHC_HC2R_EMMC_MODE_DRVSEL_D = 0x3
	// Position of EXTUN field.
	SDHC_HC2R_EMMC_MODE_EXTUN_Pos = 0x6
	// Bit mask of EXTUN field.
	SDHC_HC2R_EMMC_MODE_EXTUN_Msk = 0x40
	// Bit EXTUN.
	SDHC_HC2R_EMMC_MODE_EXTUN = 0x40
	// Not Tuned or Tuning Completed
	SDHC_HC2R_EMMC_MODE_EXTUN_NO = 0x0
	// Execute Tuning
	SDHC_HC2R_EMMC_MODE_EXTUN_REQUESTED = 0x1
	// Position of SLCKSEL field.
	SDHC_HC2R_EMMC_MODE_SLCKSEL_Pos = 0x7
	// Bit mask of SLCKSEL field.
	SDHC_HC2R_EMMC_MODE_SLCKSEL_Msk = 0x80
	// Bit SLCKSEL.
	SDHC_HC2R_EMMC_MODE_SLCKSEL = 0x80
	// Fixed clock is used to sample data
	SDHC_HC2R_EMMC_MODE_SLCKSEL_FIXED = 0x0
	// Tuned clock is used to sample data
	SDHC_HC2R_EMMC_MODE_SLCKSEL_TUNED = 0x1
	// Position of PVALEN field.
	SDHC_HC2R_EMMC_MODE_PVALEN_Pos = 0xf
	// Bit mask of PVALEN field.
	SDHC_HC2R_EMMC_MODE_PVALEN_Msk = 0x8000
	// Bit PVALEN.
	SDHC_HC2R_EMMC_MODE_PVALEN = 0x8000
	// SDCLK and Driver Strength are controlled by Host Controller
	SDHC_HC2R_EMMC_MODE_PVALEN_HOST = 0x0
	// Automatic Selection by Preset Value is Enabled
	SDHC_HC2R_EMMC_MODE_PVALEN_AUTO = 0x1

	// CA0R: Capabilities 0
	// Position of TEOCLKF field.
	SDHC_CA0R_TEOCLKF_Pos = 0x0
	// Bit mask of TEOCLKF field.
	SDHC_CA0R_TEOCLKF_Msk = 0x3f
	// Get information via another method
	SDHC_CA0R_TEOCLKF_OTHER = 0x0
	// Position of TEOCLKU field.
	SDHC_CA0R_TEOCLKU_Pos = 0x7
	// Bit mask of TEOCLKU field.
	SDHC_CA0R_TEOCLKU_Msk = 0x80
	// Bit TEOCLKU.
	SDHC_CA0R_TEOCLKU = 0x80
	// KHz
	SDHC_CA0R_TEOCLKU_KHZ = 0x0
	// MHz
	SDHC_CA0R_TEOCLKU_MHZ = 0x1
	// Position of BASECLKF field.
	SDHC_CA0R_BASECLKF_Pos = 0x8
	// Bit mask of BASECLKF field.
	SDHC_CA0R_BASECLKF_Msk = 0xff00
	// Get information via another method
	SDHC_CA0R_BASECLKF_OTHER = 0x0
	// Position of MAXBLKL field.
	SDHC_CA0R_MAXBLKL_Pos = 0x10
	// Bit mask of MAXBLKL field.
	SDHC_CA0R_MAXBLKL_Msk = 0x30000
	// 512 bytes
	SDHC_CA0R_MAXBLKL_512 = 0x0
	// 1024 bytes
	SDHC_CA0R_MAXBLKL_1024 = 0x1
	// 2048 bytes
	SDHC_CA0R_MAXBLKL_2048 = 0x2
	// Position of ED8SUP field.
	SDHC_CA0R_ED8SUP_Pos = 0x12
	// Bit mask of ED8SUP field.
	SDHC_CA0R_ED8SUP_Msk = 0x40000
	// Bit ED8SUP.
	SDHC_CA0R_ED8SUP = 0x40000
	// 8-bit Bus Width not Supported
	SDHC_CA0R_ED8SUP_NO = 0x0
	// 8-bit Bus Width Supported
	SDHC_CA0R_ED8SUP_YES = 0x1
	// Position of ADMA2SUP field.
	SDHC_CA0R_ADMA2SUP_Pos = 0x13
	// Bit mask of ADMA2SUP field.
	SDHC_CA0R_ADMA2SUP_Msk = 0x80000
	// Bit ADMA2SUP.
	SDHC_CA0R_ADMA2SUP = 0x80000
	// ADMA2 not Supported
	SDHC_CA0R_ADMA2SUP_NO = 0x0
	// ADMA2 Supported
	SDHC_CA0R_ADMA2SUP_YES = 0x1
	// Position of HSSUP field.
	SDHC_CA0R_HSSUP_Pos = 0x15
	// Bit mask of HSSUP field.
	SDHC_CA0R_HSSUP_Msk = 0x200000
	// Bit HSSUP.
	SDHC_CA0R_HSSUP = 0x200000
	// High Speed not Supported
	SDHC_CA0R_HSSUP_NO = 0x0
	// High Speed Supported
	SDHC_CA0R_HSSUP_YES = 0x1
	// Position of SDMASUP field.
	SDHC_CA0R_SDMASUP_Pos = 0x16
	// Bit mask of SDMASUP field.
	SDHC_CA0R_SDMASUP_Msk = 0x400000
	// Bit SDMASUP.
	SDHC_CA0R_SDMASUP = 0x400000
	// SDMA not Supported
	SDHC_CA0R_SDMASUP_NO = 0x0
	// SDMA Supported
	SDHC_CA0R_SDMASUP_YES = 0x1
	// Position of SRSUP field.
	SDHC_CA0R_SRSUP_Pos = 0x17
	// Bit mask of SRSUP field.
	SDHC_CA0R_SRSUP_Msk = 0x800000
	// Bit SRSUP.
	SDHC_CA0R_SRSUP = 0x800000
	// Suspend/Resume not Supported
	SDHC_CA0R_SRSUP_NO = 0x0
	// Suspend/Resume Supported
	SDHC_CA0R_SRSUP_YES = 0x1
	// Position of V33VSUP field.
	SDHC_CA0R_V33VSUP_Pos = 0x18
	// Bit mask of V33VSUP field.
	SDHC_CA0R_V33VSUP_Msk = 0x1000000
	// Bit V33VSUP.
	SDHC_CA0R_V33VSUP = 0x1000000
	// 3.3V Not Supported
	SDHC_CA0R_V33VSUP_NO = 0x0
	// 3.3V Supported
	SDHC_CA0R_V33VSUP_YES = 0x1
	// Position of V30VSUP field.
	SDHC_CA0R_V30VSUP_Pos = 0x19
	// Bit mask of V30VSUP field.
	SDHC_CA0R_V30VSUP_Msk = 0x2000000
	// Bit V30VSUP.
	SDHC_CA0R_V30VSUP = 0x2000000
	// 3.0V Not Supported
	SDHC_CA0R_V30VSUP_NO = 0x0
	// 3.0V Supported
	SDHC_CA0R_V30VSUP_YES = 0x1
	// Position of V18VSUP field.
	SDHC_CA0R_V18VSUP_Pos = 0x1a
	// Bit mask of V18VSUP field.
	SDHC_CA0R_V18VSUP_Msk = 0x4000000
	// Bit V18VSUP.
	SDHC_CA0R_V18VSUP = 0x4000000
	// 1.8V Not Supported
	SDHC_CA0R_V18VSUP_NO = 0x0
	// 1.8V Supported
	SDHC_CA0R_V18VSUP_YES = 0x1
	// Position of SB64SUP field.
	SDHC_CA0R_SB64SUP_Pos = 0x1c
	// Bit mask of SB64SUP field.
	SDHC_CA0R_SB64SUP_Msk = 0x10000000
	// Bit SB64SUP.
	SDHC_CA0R_SB64SUP = 0x10000000
	// 32-bit Address Descriptors and System Bus
	SDHC_CA0R_SB64SUP_NO = 0x0
	// 64-bit Address Descriptors and System Bus
	SDHC_CA0R_SB64SUP_YES = 0x1
	// Position of ASINTSUP field.
	SDHC_CA0R_ASINTSUP_Pos = 0x1d
	// Bit mask of ASINTSUP field.
	SDHC_CA0R_ASINTSUP_Msk = 0x20000000
	// Bit ASINTSUP.
	SDHC_CA0R_ASINTSUP = 0x20000000
	// Asynchronous Interrupt not Supported
	SDHC_CA0R_ASINTSUP_NO = 0x0
	// Asynchronous Interrupt supported
	SDHC_CA0R_ASINTSUP_YES = 0x1
	// Position of SLTYPE field.
	SDHC_CA0R_SLTYPE_Pos = 0x1e
	// Bit mask of SLTYPE field.
	SDHC_CA0R_SLTYPE_Msk = 0xc0000000
	// Removable Card Slot
	SDHC_CA0R_SLTYPE_REMOVABLE = 0x0
	// Embedded Slot for One Device
	SDHC_CA0R_SLTYPE_EMBEDDED = 0x1

	// CA1R: Capabilities 1
	// Position of SDR50SUP field.
	SDHC_CA1R_SDR50SUP_Pos = 0x0
	// Bit mask of SDR50SUP field.
	SDHC_CA1R_SDR50SUP_Msk = 0x1
	// Bit SDR50SUP.
	SDHC_CA1R_SDR50SUP = 0x1
	// SDR50 is Not Supported
	SDHC_CA1R_SDR50SUP_NO = 0x0
	// SDR50 is Supported
	SDHC_CA1R_SDR50SUP_YES = 0x1
	// Position of SDR104SUP field.
	SDHC_CA1R_SDR104SUP_Pos = 0x1
	// Bit mask of SDR104SUP field.
	SDHC_CA1R_SDR104SUP_Msk = 0x2
	// Bit SDR104SUP.
	SDHC_CA1R_SDR104SUP = 0x2
	// SDR104 is Not Supported
	SDHC_CA1R_SDR104SUP_NO = 0x0
	// SDR104 is Supported
	SDHC_CA1R_SDR104SUP_YES = 0x1
	// Position of DDR50SUP field.
	SDHC_CA1R_DDR50SUP_Pos = 0x2
	// Bit mask of DDR50SUP field.
	SDHC_CA1R_DDR50SUP_Msk = 0x4
	// Bit DDR50SUP.
	SDHC_CA1R_DDR50SUP = 0x4
	// DDR50 is Not Supported
	SDHC_CA1R_DDR50SUP_NO = 0x0
	// DDR50 is Supported
	SDHC_CA1R_DDR50SUP_YES = 0x1
	// Position of DRVASUP field.
	SDHC_CA1R_DRVASUP_Pos = 0x4
	// Bit mask of DRVASUP field.
	SDHC_CA1R_DRVASUP_Msk = 0x10
	// Bit DRVASUP.
	SDHC_CA1R_DRVASUP = 0x10
	// Driver Type A is Not Supported
	SDHC_CA1R_DRVASUP_NO = 0x0
	// Driver Type A is Supported
	SDHC_CA1R_DRVASUP_YES = 0x1
	// Position of DRVCSUP field.
	SDHC_CA1R_DRVCSUP_Pos = 0x5
	// Bit mask of DRVCSUP field.
	SDHC_CA1R_DRVCSUP_Msk = 0x20
	// Bit DRVCSUP.
	SDHC_CA1R_DRVCSUP = 0x20
	// Driver Type C is Not Supported
	SDHC_CA1R_DRVCSUP_NO = 0x0
	// Driver Type C is Supported
	SDHC_CA1R_DRVCSUP_YES = 0x1
	// Position of DRVDSUP field.
	SDHC_CA1R_DRVDSUP_Pos = 0x6
	// Bit mask of DRVDSUP field.
	SDHC_CA1R_DRVDSUP_Msk = 0x40
	// Bit DRVDSUP.
	SDHC_CA1R_DRVDSUP = 0x40
	// Driver Type D is Not Supported
	SDHC_CA1R_DRVDSUP_NO = 0x0
	// Driver Type D is Supported
	SDHC_CA1R_DRVDSUP_YES = 0x1
	// Position of TCNTRT field.
	SDHC_CA1R_TCNTRT_Pos = 0x8
	// Bit mask of TCNTRT field.
	SDHC_CA1R_TCNTRT_Msk = 0xf00
	// Re-Tuning Timer disabled
	SDHC_CA1R_TCNTRT_DISABLED = 0x0
	// 1 second
	SDHC_CA1R_TCNTRT_1S = 0x1
	// 2 seconds
	SDHC_CA1R_TCNTRT_2S = 0x2
	// 4 seconds
	SDHC_CA1R_TCNTRT_4S = 0x3
	// 8 seconds
	SDHC_CA1R_TCNTRT_8S = 0x4
	// 16 seconds
	SDHC_CA1R_TCNTRT_16S = 0x5
	// 32 seconds
	SDHC_CA1R_TCNTRT_32S = 0x6
	// 64 seconds
	SDHC_CA1R_TCNTRT_64S = 0x7
	// 128 seconds
	SDHC_CA1R_TCNTRT_128S = 0x8
	// 256 seconds
	SDHC_CA1R_TCNTRT_256S = 0x9
	// 512 seconds
	SDHC_CA1R_TCNTRT_512S = 0xa
	// 1024 seconds
	SDHC_CA1R_TCNTRT_1024S = 0xb
	// Get information from other source
	SDHC_CA1R_TCNTRT_OTHER = 0xf
	// Position of TSDR50 field.
	SDHC_CA1R_TSDR50_Pos = 0xd
	// Bit mask of TSDR50 field.
	SDHC_CA1R_TSDR50_Msk = 0x2000
	// Bit TSDR50.
	SDHC_CA1R_TSDR50 = 0x2000
	// SDR50 does not require tuning
	SDHC_CA1R_TSDR50_NO = 0x0
	// SDR50 requires tuning
	SDHC_CA1R_TSDR50_YES = 0x1
	// Position of CLKMULT field.
	SDHC_CA1R_CLKMULT_Pos = 0x10
	// Bit mask of CLKMULT field.
	SDHC_CA1R_CLKMULT_Msk = 0xff0000
	// Clock Multiplier is Not Supported
	SDHC_CA1R_CLKMULT_NO = 0x0

	// MCCAR: Maximum Current Capabilities
	// Position of MAXCUR33V field.
	SDHC_MCCAR_MAXCUR33V_Pos = 0x0
	// Bit mask of MAXCUR33V field.
	SDHC_MCCAR_MAXCUR33V_Msk = 0xff
	// Get information via another method
	SDHC_MCCAR_MAXCUR33V_OTHER = 0x0
	// 4mA
	SDHC_MCCAR_MAXCUR33V_4MA = 0x1
	// 8mA
	SDHC_MCCAR_MAXCUR33V_8MA = 0x2
	// 12mA
	SDHC_MCCAR_MAXCUR33V_12MA = 0x3
	// Position of MAXCUR30V field.
	SDHC_MCCAR_MAXCUR30V_Pos = 0x8
	// Bit mask of MAXCUR30V field.
	SDHC_MCCAR_MAXCUR30V_Msk = 0xff00
	// Get information via another method
	SDHC_MCCAR_MAXCUR30V_OTHER = 0x0
	// 4mA
	SDHC_MCCAR_MAXCUR30V_4MA = 0x1
	// 8mA
	SDHC_MCCAR_MAXCUR30V_8MA = 0x2
	// 12mA
	SDHC_MCCAR_MAXCUR30V_12MA = 0x3
	// Position of MAXCUR18V field.
	SDHC_MCCAR_MAXCUR18V_Pos = 0x10
	// Bit mask of MAXCUR18V field.
	SDHC_MCCAR_MAXCUR18V_Msk = 0xff0000
	// Get information via another method
	SDHC_MCCAR_MAXCUR18V_OTHER = 0x0
	// 4mA
	SDHC_MCCAR_MAXCUR18V_4MA = 0x1
	// 8mA
	SDHC_MCCAR_MAXCUR18V_8MA = 0x2
	// 12mA
	SDHC_MCCAR_MAXCUR18V_12MA = 0x3

	// FERACES: Force Event for Auto CMD Error Status
	// Position of ACMD12NE field.
	SDHC_FERACES_ACMD12NE_Pos = 0x0
	// Bit mask of ACMD12NE field.
	SDHC_FERACES_ACMD12NE_Msk = 0x1
	// Bit ACMD12NE.
	SDHC_FERACES_ACMD12NE = 0x1
	// No Interrupt
	SDHC_FERACES_ACMD12NE_NO = 0x0
	// Interrupt is generated
	SDHC_FERACES_ACMD12NE_YES = 0x1
	// Position of ACMDTEO field.
	SDHC_FERACES_ACMDTEO_Pos = 0x1
	// Bit mask of ACMDTEO field.
	SDHC_FERACES_ACMDTEO_Msk = 0x2
	// Bit ACMDTEO.
	SDHC_FERACES_ACMDTEO = 0x2
	// No Interrupt
	SDHC_FERACES_ACMDTEO_NO = 0x0
	// Interrupt is generated
	SDHC_FERACES_ACMDTEO_YES = 0x1
	// Position of ACMDCRC field.
	SDHC_FERACES_ACMDCRC_Pos = 0x2
	// Bit mask of ACMDCRC field.
	SDHC_FERACES_ACMDCRC_Msk = 0x4
	// Bit ACMDCRC.
	SDHC_FERACES_ACMDCRC = 0x4
	// No Interrupt
	SDHC_FERACES_ACMDCRC_NO = 0x0
	// Interrupt is generated
	SDHC_FERACES_ACMDCRC_YES = 0x1
	// Position of ACMDEND field.
	SDHC_FERACES_ACMDEND_Pos = 0x3
	// Bit mask of ACMDEND field.
	SDHC_FERACES_ACMDEND_Msk = 0x8
	// Bit ACMDEND.
	SDHC_FERACES_ACMDEND = 0x8
	// No Interrupt
	SDHC_FERACES_ACMDEND_NO = 0x0
	// Interrupt is generated
	SDHC_FERACES_ACMDEND_YES = 0x1
	// Position of ACMDIDX field.
	SDHC_FERACES_ACMDIDX_Pos = 0x4
	// Bit mask of ACMDIDX field.
	SDHC_FERACES_ACMDIDX_Msk = 0x10
	// Bit ACMDIDX.
	SDHC_FERACES_ACMDIDX = 0x10
	// No Interrupt
	SDHC_FERACES_ACMDIDX_NO = 0x0
	// Interrupt is generated
	SDHC_FERACES_ACMDIDX_YES = 0x1
	// Position of CMDNI field.
	SDHC_FERACES_CMDNI_Pos = 0x7
	// Bit mask of CMDNI field.
	SDHC_FERACES_CMDNI_Msk = 0x80
	// Bit CMDNI.
	SDHC_FERACES_CMDNI = 0x80
	// No Interrupt
	SDHC_FERACES_CMDNI_NO = 0x0
	// Interrupt is generated
	SDHC_FERACES_CMDNI_YES = 0x1

	// FEREIS: Force Event for Error Interrupt Status
	// Position of CMDTEO field.
	SDHC_FEREIS_CMDTEO_Pos = 0x0
	// Bit mask of CMDTEO field.
	SDHC_FEREIS_CMDTEO_Msk = 0x1
	// Bit CMDTEO.
	SDHC_FEREIS_CMDTEO = 0x1
	// No Interrupt
	SDHC_FEREIS_CMDTEO_NO = 0x0
	// Interrupt is generated
	SDHC_FEREIS_CMDTEO_YES = 0x1
	// Position of CMDCRC field.
	SDHC_FEREIS_CMDCRC_Pos = 0x1
	// Bit mask of CMDCRC field.
	SDHC_FEREIS_CMDCRC_Msk = 0x2
	// Bit CMDCRC.
	SDHC_FEREIS_CMDCRC = 0x2
	// No Interrupt
	SDHC_FEREIS_CMDCRC_NO = 0x0
	// Interrupt is generated
	SDHC_FEREIS_CMDCRC_YES = 0x1
	// Position of CMDEND field.
	SDHC_FEREIS_CMDEND_Pos = 0x2
	// Bit mask of CMDEND field.
	SDHC_FEREIS_CMDEND_Msk = 0x4
	// Bit CMDEND.
	SDHC_FEREIS_CMDEND = 0x4
	// No Interrupt
	SDHC_FEREIS_CMDEND_NO = 0x0
	// Interrupt is generated
	SDHC_FEREIS_CMDEND_YES = 0x1
	// Position of CMDIDX field.
	SDHC_FEREIS_CMDIDX_Pos = 0x3
	// Bit mask of CMDIDX field.
	SDHC_FEREIS_CMDIDX_Msk = 0x8
	// Bit CMDIDX.
	SDHC_FEREIS_CMDIDX = 0x8
	// No Interrupt
	SDHC_FEREIS_CMDIDX_NO = 0x0
	// Interrupt is generated
	SDHC_FEREIS_CMDIDX_YES = 0x1
	// Position of DATTEO field.
	SDHC_FEREIS_DATTEO_Pos = 0x4
	// Bit mask of DATTEO field.
	SDHC_FEREIS_DATTEO_Msk = 0x10
	// Bit DATTEO.
	SDHC_FEREIS_DATTEO = 0x10
	// No Interrupt
	SDHC_FEREIS_DATTEO_NO = 0x0
	// Interrupt is generated
	SDHC_FEREIS_DATTEO_YES = 0x1
	// Position of DATCRC field.
	SDHC_FEREIS_DATCRC_Pos = 0x5
	// Bit mask of DATCRC field.
	SDHC_FEREIS_DATCRC_Msk = 0x20
	// Bit DATCRC.
	SDHC_FEREIS_DATCRC = 0x20
	// No Interrupt
	SDHC_FEREIS_DATCRC_NO = 0x0
	// Interrupt is generated
	SDHC_FEREIS_DATCRC_YES = 0x1
	// Position of DATEND field.
	SDHC_FEREIS_DATEND_Pos = 0x6
	// Bit mask of DATEND field.
	SDHC_FEREIS_DATEND_Msk = 0x40
	// Bit DATEND.
	SDHC_FEREIS_DATEND = 0x40
	// No Interrupt
	SDHC_FEREIS_DATEND_NO = 0x0
	// Interrupt is generated
	SDHC_FEREIS_DATEND_YES = 0x1
	// Position of CURLIM field.
	SDHC_FEREIS_CURLIM_Pos = 0x7
	// Bit mask of CURLIM field.
	SDHC_FEREIS_CURLIM_Msk = 0x80
	// Bit CURLIM.
	SDHC_FEREIS_CURLIM = 0x80
	// No Interrupt
	SDHC_FEREIS_CURLIM_NO = 0x0
	// Interrupt is generated
	SDHC_FEREIS_CURLIM_YES = 0x1
	// Position of ACMD field.
	SDHC_FEREIS_ACMD_Pos = 0x8
	// Bit mask of ACMD field.
	SDHC_FEREIS_ACMD_Msk = 0x100
	// Bit ACMD.
	SDHC_FEREIS_ACMD = 0x100
	// No Interrupt
	SDHC_FEREIS_ACMD_NO = 0x0
	// Interrupt is generated
	SDHC_FEREIS_ACMD_YES = 0x1
	// Position of ADMA field.
	SDHC_FEREIS_ADMA_Pos = 0x9
	// Bit mask of ADMA field.
	SDHC_FEREIS_ADMA_Msk = 0x200
	// Bit ADMA.
	SDHC_FEREIS_ADMA = 0x200
	// No Interrupt
	SDHC_FEREIS_ADMA_NO = 0x0
	// Interrupt is generated
	SDHC_FEREIS_ADMA_YES = 0x1
	// Position of BOOTAE field.
	SDHC_FEREIS_BOOTAE_Pos = 0xc
	// Bit mask of BOOTAE field.
	SDHC_FEREIS_BOOTAE_Msk = 0x1000
	// Bit BOOTAE.
	SDHC_FEREIS_BOOTAE = 0x1000
	// No Interrupt
	SDHC_FEREIS_BOOTAE_NO = 0x0
	// Interrupt is generated
	SDHC_FEREIS_BOOTAE_YES = 0x1

	// AESR: ADMA Error Status
	// Position of ERRST field.
	SDHC_AESR_ERRST_Pos = 0x0
	// Bit mask of ERRST field.
	SDHC_AESR_ERRST_Msk = 0x3
	// ST_STOP (Stop DMA)
	SDHC_AESR_ERRST_STOP = 0x0
	// ST_FDS (Fetch Descriptor)
	SDHC_AESR_ERRST_FDS = 0x1
	// ST_TFR (Transfer Data)
	SDHC_AESR_ERRST_TFR = 0x3
	// Position of LMIS field.
	SDHC_AESR_LMIS_Pos = 0x2
	// Bit mask of LMIS field.
	SDHC_AESR_LMIS_Msk = 0x4
	// Bit LMIS.
	SDHC_AESR_LMIS = 0x4
	// No Error
	SDHC_AESR_LMIS_NO = 0x0
	// Error
	SDHC_AESR_LMIS_YES = 0x1

	// ASAR: ADMA System Address n
	// Position of ADMASA field.
	SDHC_ASAR_ADMASA_Pos = 0x0
	// Bit mask of ADMASA field.
	SDHC_ASAR_ADMASA_Msk = 0xffffffff

	// PVR: Preset Value n
	// Position of SDCLKFSEL field.
	SDHC_PVR_SDCLKFSEL_Pos = 0x0
	// Bit mask of SDCLKFSEL field.
	SDHC_PVR_SDCLKFSEL_Msk = 0x3ff
	// Position of CLKGSEL field.
	SDHC_PVR_CLKGSEL_Pos = 0xa
	// Bit mask of CLKGSEL field.
	SDHC_PVR_CLKGSEL_Msk = 0x400
	// Bit CLKGSEL.
	SDHC_PVR_CLKGSEL = 0x400
	// Host Controller Ver2.00 Compatible Clock Generator (Divider)
	SDHC_PVR_CLKGSEL_DIV = 0x0
	// Programmable Clock Generator
	SDHC_PVR_CLKGSEL_PROG = 0x1
	// Position of DRVSEL field.
	SDHC_PVR_DRVSEL_Pos = 0xe
	// Bit mask of DRVSEL field.
	SDHC_PVR_DRVSEL_Msk = 0xc000
	// Driver Type B is Selected
	SDHC_PVR_DRVSEL_B = 0x0
	// Driver Type A is Selected
	SDHC_PVR_DRVSEL_A = 0x1
	// Driver Type C is Selected
	SDHC_PVR_DRVSEL_C = 0x2
	// Driver Type D is Selected
	SDHC_PVR_DRVSEL_D = 0x3

	// SISR: Slot Interrupt Status
	// Position of INTSSL field.
	SDHC_SISR_INTSSL_Pos = 0x0
	// Bit mask of INTSSL field.
	SDHC_SISR_INTSSL_Msk = 0x1
	// Bit INTSSL.
	SDHC_SISR_INTSSL = 0x1

	// HCVR: Host Controller Version
	// Position of SVER field.
	SDHC_HCVR_SVER_Pos = 0x0
	// Bit mask of SVER field.
	SDHC_HCVR_SVER_Msk = 0xff
	// Position of VVER field.
	SDHC_HCVR_VVER_Pos = 0x8
	// Bit mask of VVER field.
	SDHC_HCVR_VVER_Msk = 0xff00

	// MC1R: MMC Control 1
	// Position of CMDTYP field.
	SDHC_MC1R_CMDTYP_Pos = 0x0
	// Bit mask of CMDTYP field.
	SDHC_MC1R_CMDTYP_Msk = 0x3
	// Not a MMC specific command
	SDHC_MC1R_CMDTYP_NORMAL = 0x0
	// Wait IRQ Command
	SDHC_MC1R_CMDTYP_WAITIRQ = 0x1
	// Stream Command
	SDHC_MC1R_CMDTYP_STREAM = 0x2
	// Boot Command
	SDHC_MC1R_CMDTYP_BOOT = 0x3
	// Position of DDR field.
	SDHC_MC1R_DDR_Pos = 0x3
	// Bit mask of DDR field.
	SDHC_MC1R_DDR_Msk = 0x8
	// Bit DDR.
	SDHC_MC1R_DDR = 0x8
	// Position of OPD field.
	SDHC_MC1R_OPD_Pos = 0x4
	// Bit mask of OPD field.
	SDHC_MC1R_OPD_Msk = 0x10
	// Bit OPD.
	SDHC_MC1R_OPD = 0x10
	// Position of BOOTA field.
	SDHC_MC1R_BOOTA_Pos = 0x5
	// Bit mask of BOOTA field.
	SDHC_MC1R_BOOTA_Msk = 0x20
	// Bit BOOTA.
	SDHC_MC1R_BOOTA = 0x20
	// Position of RSTN field.
	SDHC_MC1R_RSTN_Pos = 0x6
	// Bit mask of RSTN field.
	SDHC_MC1R_RSTN_Msk = 0x40
	// Bit RSTN.
	SDHC_MC1R_RSTN = 0x40
	// Position of FCD field.
	SDHC_MC1R_FCD_Pos = 0x7
	// Bit mask of FCD field.
	SDHC_MC1R_FCD_Msk = 0x80
	// Bit FCD.
	SDHC_MC1R_FCD = 0x80

	// MC2R: MMC Control 2
	// Position of SRESP field.
	SDHC_MC2R_SRESP_Pos = 0x0
	// Bit mask of SRESP field.
	SDHC_MC2R_SRESP_Msk = 0x1
	// Bit SRESP.
	SDHC_MC2R_SRESP = 0x1
	// Position of ABOOT field.
	SDHC_MC2R_ABOOT_Pos = 0x1
	// Bit mask of ABOOT field.
	SDHC_MC2R_ABOOT_Msk = 0x2
	// Bit ABOOT.
	SDHC_MC2R_ABOOT = 0x2

	// ACR: AHB Control
	// Position of BMAX field.
	SDHC_ACR_BMAX_Pos = 0x0
	// Bit mask of BMAX field.
	SDHC_ACR_BMAX_Msk    = 0x3
	SDHC_ACR_BMAX_INCR16 = 0x0
	SDHC_ACR_BMAX_INCR8  = 0x1
	SDHC_ACR_BMAX_INCR4  = 0x2
	SDHC_ACR_BMAX_SINGLE = 0x3

	// CC2R: Clock Control 2
	// Position of FSDCLKD field.
	SDHC_CC2R_FSDCLKD_Pos = 0x0
	// Bit mask of FSDCLKD field.
	SDHC_CC2R_FSDCLKD_Msk = 0x1
	// Bit FSDCLKD.
	SDHC_CC2R_FSDCLKD = 0x1
	// No effect
	SDHC_CC2R_FSDCLKD_NOEFFECT = 0x0
	// SDCLK can be stopped at any time after DATA transfer.SDCLK enable forcing for 8 SDCLK cycles is disabled
	SDHC_CC2R_FSDCLKD_DISABLE = 0x1

	// CACR: Capabilities Control
	// Position of CAPWREN field.
	SDHC_CACR_CAPWREN_Pos = 0x0
	// Bit mask of CAPWREN field.
	SDHC_CACR_CAPWREN_Msk = 0x1
	// Bit CAPWREN.
	SDHC_CACR_CAPWREN = 0x1
	// Position of KEY field.
	SDHC_CACR_KEY_Pos = 0x8
	// Bit mask of KEY field.
	SDHC_CACR_KEY_Msk = 0xff00

	// DBGR: Debug
	// Position of NIDBG field.
	SDHC_DBGR_NIDBG_Pos = 0x0
	// Bit mask of NIDBG field.
	SDHC_DBGR_NIDBG_Msk = 0x1
	// Bit NIDBG.
	SDHC_DBGR_NIDBG = 0x1
	// Debugging is intrusive (reads of BDPR from debugger are considered and increment the internal buffer pointer)
	SDHC_DBGR_NIDBG_IDBG = 0x0
	// Debugging is not intrusive (reads of BDPR from debugger are discarded and do not increment the internal buffer pointer)
	SDHC_DBGR_NIDBG_NIDBG = 0x1
)

// Constants for SERCOM0: Serial Communication Interface
const ()

// Constants for SERCOM0_I2CM: Serial Communication Interface - I2CM
const (
	// CTRLA: I2CM Control A
	// Position of SWRST field.
	SERCOM_I2CM_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	SERCOM_I2CM_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	SERCOM_I2CM_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	SERCOM_I2CM_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	SERCOM_I2CM_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	SERCOM_I2CM_CTRLA_ENABLE = 0x2
	// Position of MODE field.
	SERCOM_I2CM_CTRLA_MODE_Pos = 0x2
	// Bit mask of MODE field.
	SERCOM_I2CM_CTRLA_MODE_Msk = 0x1c
	// USART with external clock
	SERCOM_I2CM_CTRLA_MODE_USART_EXT_CLK = 0x0
	// USART with internal clock
	SERCOM_I2CM_CTRLA_MODE_USART_INT_CLK = 0x1
	// SPI in slave operation
	SERCOM_I2CM_CTRLA_MODE_SPI_SLAVE = 0x2
	// SPI in master operation
	SERCOM_I2CM_CTRLA_MODE_SPI_MASTER = 0x3
	// I2C slave operation
	SERCOM_I2CM_CTRLA_MODE_I2C_SLAVE = 0x4
	// I2C master operation
	SERCOM_I2CM_CTRLA_MODE_I2C_MASTER = 0x5
	// Position of RUNSTDBY field.
	SERCOM_I2CM_CTRLA_RUNSTDBY_Pos = 0x7
	// Bit mask of RUNSTDBY field.
	SERCOM_I2CM_CTRLA_RUNSTDBY_Msk = 0x80
	// Bit RUNSTDBY.
	SERCOM_I2CM_CTRLA_RUNSTDBY = 0x80
	// Position of PINOUT field.
	SERCOM_I2CM_CTRLA_PINOUT_Pos = 0x10
	// Bit mask of PINOUT field.
	SERCOM_I2CM_CTRLA_PINOUT_Msk = 0x10000
	// Bit PINOUT.
	SERCOM_I2CM_CTRLA_PINOUT = 0x10000
	// Position of SDAHOLD field.
	SERCOM_I2CM_CTRLA_SDAHOLD_Pos = 0x14
	// Bit mask of SDAHOLD field.
	SERCOM_I2CM_CTRLA_SDAHOLD_Msk = 0x300000
	// Disabled
	SERCOM_I2CM_CTRLA_SDAHOLD_DISABLE = 0x0
	// 50-100ns hold time
	SERCOM_I2CM_CTRLA_SDAHOLD_75NS = 0x1
	// 300-600ns hold time
	SERCOM_I2CM_CTRLA_SDAHOLD_450NS = 0x2
	// 400-800ns hold time
	SERCOM_I2CM_CTRLA_SDAHOLD_600NS = 0x3
	// Position of MEXTTOEN field.
	SERCOM_I2CM_CTRLA_MEXTTOEN_Pos = 0x16
	// Bit mask of MEXTTOEN field.
	SERCOM_I2CM_CTRLA_MEXTTOEN_Msk = 0x400000
	// Bit MEXTTOEN.
	SERCOM_I2CM_CTRLA_MEXTTOEN = 0x400000
	// Position of SEXTTOEN field.
	SERCOM_I2CM_CTRLA_SEXTTOEN_Pos = 0x17
	// Bit mask of SEXTTOEN field.
	SERCOM_I2CM_CTRLA_SEXTTOEN_Msk = 0x800000
	// Bit SEXTTOEN.
	SERCOM_I2CM_CTRLA_SEXTTOEN = 0x800000
	// Position of SPEED field.
	SERCOM_I2CM_CTRLA_SPEED_Pos = 0x18
	// Bit mask of SPEED field.
	SERCOM_I2CM_CTRLA_SPEED_Msk = 0x3000000
	// Standard Mode(Sm) Upto 100kHz and Fast Mode(Fm) Upto 400kHz
	SERCOM_I2CM_CTRLA_SPEED_STANDARD_AND_FAST_MODE = 0x0
	// Fast-mode Plus Upto 1MHz
	SERCOM_I2CM_CTRLA_SPEED_FASTPLUS_MODE = 0x1
	// High-speed mode Upto 3.4MHz
	SERCOM_I2CM_CTRLA_SPEED_HIGH_SPEED_MODE = 0x2
	// Position of SCLSM field.
	SERCOM_I2CM_CTRLA_SCLSM_Pos = 0x1b
	// Bit mask of SCLSM field.
	SERCOM_I2CM_CTRLA_SCLSM_Msk = 0x8000000
	// Bit SCLSM.
	SERCOM_I2CM_CTRLA_SCLSM = 0x8000000
	// Position of INACTOUT field.
	SERCOM_I2CM_CTRLA_INACTOUT_Pos = 0x1c
	// Bit mask of INACTOUT field.
	SERCOM_I2CM_CTRLA_INACTOUT_Msk = 0x30000000
	// Disabled
	SERCOM_I2CM_CTRLA_INACTOUT_DISABLE = 0x0
	// 5-6 SCL Time-Out(50-60us)
	SERCOM_I2CM_CTRLA_INACTOUT_55US = 0x1
	// 10-11 SCL Time-Out(100-110us)
	SERCOM_I2CM_CTRLA_INACTOUT_105US = 0x2
	// 20-21 SCL Time-Out(200-210us)
	SERCOM_I2CM_CTRLA_INACTOUT_205US = 0x3
	// Position of LOWTOUTEN field.
	SERCOM_I2CM_CTRLA_LOWTOUTEN_Pos = 0x1e
	// Bit mask of LOWTOUTEN field.
	SERCOM_I2CM_CTRLA_LOWTOUTEN_Msk = 0x40000000
	// Bit LOWTOUTEN.
	SERCOM_I2CM_CTRLA_LOWTOUTEN = 0x40000000

	// CTRLB: I2CM Control B
	// Position of SMEN field.
	SERCOM_I2CM_CTRLB_SMEN_Pos = 0x8
	// Bit mask of SMEN field.
	SERCOM_I2CM_CTRLB_SMEN_Msk = 0x100
	// Bit SMEN.
	SERCOM_I2CM_CTRLB_SMEN = 0x100
	// Position of QCEN field.
	SERCOM_I2CM_CTRLB_QCEN_Pos = 0x9
	// Bit mask of QCEN field.
	SERCOM_I2CM_CTRLB_QCEN_Msk = 0x200
	// Bit QCEN.
	SERCOM_I2CM_CTRLB_QCEN = 0x200
	// Position of CMD field.
	SERCOM_I2CM_CTRLB_CMD_Pos = 0x10
	// Bit mask of CMD field.
	SERCOM_I2CM_CTRLB_CMD_Msk = 0x30000
	// Position of ACKACT field.
	SERCOM_I2CM_CTRLB_ACKACT_Pos = 0x12
	// Bit mask of ACKACT field.
	SERCOM_I2CM_CTRLB_ACKACT_Msk = 0x40000
	// Bit ACKACT.
	SERCOM_I2CM_CTRLB_ACKACT = 0x40000

	// CTRLC: I2CM Control C
	// Position of DATA32B field.
	SERCOM_I2CM_CTRLC_DATA32B_Pos = 0x18
	// Bit mask of DATA32B field.
	SERCOM_I2CM_CTRLC_DATA32B_Msk = 0x1000000
	// Bit DATA32B.
	SERCOM_I2CM_CTRLC_DATA32B = 0x1000000
	// Data transaction from/to DATA register are 8-bit
	SERCOM_I2CM_CTRLC_DATA32B_DATA_TRANS_8BIT = 0x0
	// Data transaction from/to DATA register are 32-bit
	SERCOM_I2CM_CTRLC_DATA32B_DATA_TRANS_32BIT = 0x1

	// BAUD: I2CM Baud Rate
	// Position of BAUD field.
	SERCOM_I2CM_BAUD_BAUD_Pos = 0x0
	// Bit mask of BAUD field.
	SERCOM_I2CM_BAUD_BAUD_Msk = 0xff
	// Position of BAUDLOW field.
	SERCOM_I2CM_BAUD_BAUDLOW_Pos = 0x8
	// Bit mask of BAUDLOW field.
	SERCOM_I2CM_BAUD_BAUDLOW_Msk = 0xff00
	// Position of HSBAUD field.
	SERCOM_I2CM_BAUD_HSBAUD_Pos = 0x10
	// Bit mask of HSBAUD field.
	SERCOM_I2CM_BAUD_HSBAUD_Msk = 0xff0000
	// Position of HSBAUDLOW field.
	SERCOM_I2CM_BAUD_HSBAUDLOW_Pos = 0x18
	// Bit mask of HSBAUDLOW field.
	SERCOM_I2CM_BAUD_HSBAUDLOW_Msk = 0xff000000

	// INTENCLR: I2CM Interrupt Enable Clear
	// Position of MB field.
	SERCOM_I2CM_INTENCLR_MB_Pos = 0x0
	// Bit mask of MB field.
	SERCOM_I2CM_INTENCLR_MB_Msk = 0x1
	// Bit MB.
	SERCOM_I2CM_INTENCLR_MB = 0x1
	// Position of SB field.
	SERCOM_I2CM_INTENCLR_SB_Pos = 0x1
	// Bit mask of SB field.
	SERCOM_I2CM_INTENCLR_SB_Msk = 0x2
	// Bit SB.
	SERCOM_I2CM_INTENCLR_SB = 0x2
	// Position of ERROR field.
	SERCOM_I2CM_INTENCLR_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	SERCOM_I2CM_INTENCLR_ERROR_Msk = 0x80
	// Bit ERROR.
	SERCOM_I2CM_INTENCLR_ERROR = 0x80

	// INTENSET: I2CM Interrupt Enable Set
	// Position of MB field.
	SERCOM_I2CM_INTENSET_MB_Pos = 0x0
	// Bit mask of MB field.
	SERCOM_I2CM_INTENSET_MB_Msk = 0x1
	// Bit MB.
	SERCOM_I2CM_INTENSET_MB = 0x1
	// Position of SB field.
	SERCOM_I2CM_INTENSET_SB_Pos = 0x1
	// Bit mask of SB field.
	SERCOM_I2CM_INTENSET_SB_Msk = 0x2
	// Bit SB.
	SERCOM_I2CM_INTENSET_SB = 0x2
	// Position of ERROR field.
	SERCOM_I2CM_INTENSET_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	SERCOM_I2CM_INTENSET_ERROR_Msk = 0x80
	// Bit ERROR.
	SERCOM_I2CM_INTENSET_ERROR = 0x80

	// INTFLAG: I2CM Interrupt Flag Status and Clear
	// Position of MB field.
	SERCOM_I2CM_INTFLAG_MB_Pos = 0x0
	// Bit mask of MB field.
	SERCOM_I2CM_INTFLAG_MB_Msk = 0x1
	// Bit MB.
	SERCOM_I2CM_INTFLAG_MB = 0x1
	// Position of SB field.
	SERCOM_I2CM_INTFLAG_SB_Pos = 0x1
	// Bit mask of SB field.
	SERCOM_I2CM_INTFLAG_SB_Msk = 0x2
	// Bit SB.
	SERCOM_I2CM_INTFLAG_SB = 0x2
	// Position of ERROR field.
	SERCOM_I2CM_INTFLAG_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	SERCOM_I2CM_INTFLAG_ERROR_Msk = 0x80
	// Bit ERROR.
	SERCOM_I2CM_INTFLAG_ERROR = 0x80

	// STATUS: I2CM Status
	// Position of BUSERR field.
	SERCOM_I2CM_STATUS_BUSERR_Pos = 0x0
	// Bit mask of BUSERR field.
	SERCOM_I2CM_STATUS_BUSERR_Msk = 0x1
	// Bit BUSERR.
	SERCOM_I2CM_STATUS_BUSERR = 0x1
	// Position of ARBLOST field.
	SERCOM_I2CM_STATUS_ARBLOST_Pos = 0x1
	// Bit mask of ARBLOST field.
	SERCOM_I2CM_STATUS_ARBLOST_Msk = 0x2
	// Bit ARBLOST.
	SERCOM_I2CM_STATUS_ARBLOST = 0x2
	// Position of RXNACK field.
	SERCOM_I2CM_STATUS_RXNACK_Pos = 0x2
	// Bit mask of RXNACK field.
	SERCOM_I2CM_STATUS_RXNACK_Msk = 0x4
	// Bit RXNACK.
	SERCOM_I2CM_STATUS_RXNACK = 0x4
	// Position of BUSSTATE field.
	SERCOM_I2CM_STATUS_BUSSTATE_Pos = 0x4
	// Bit mask of BUSSTATE field.
	SERCOM_I2CM_STATUS_BUSSTATE_Msk = 0x30
	// Position of LOWTOUT field.
	SERCOM_I2CM_STATUS_LOWTOUT_Pos = 0x6
	// Bit mask of LOWTOUT field.
	SERCOM_I2CM_STATUS_LOWTOUT_Msk = 0x40
	// Bit LOWTOUT.
	SERCOM_I2CM_STATUS_LOWTOUT = 0x40
	// Position of CLKHOLD field.
	SERCOM_I2CM_STATUS_CLKHOLD_Pos = 0x7
	// Bit mask of CLKHOLD field.
	SERCOM_I2CM_STATUS_CLKHOLD_Msk = 0x80
	// Bit CLKHOLD.
	SERCOM_I2CM_STATUS_CLKHOLD = 0x80
	// Position of MEXTTOUT field.
	SERCOM_I2CM_STATUS_MEXTTOUT_Pos = 0x8
	// Bit mask of MEXTTOUT field.
	SERCOM_I2CM_STATUS_MEXTTOUT_Msk = 0x100
	// Bit MEXTTOUT.
	SERCOM_I2CM_STATUS_MEXTTOUT = 0x100
	// Position of SEXTTOUT field.
	SERCOM_I2CM_STATUS_SEXTTOUT_Pos = 0x9
	// Bit mask of SEXTTOUT field.
	SERCOM_I2CM_STATUS_SEXTTOUT_Msk = 0x200
	// Bit SEXTTOUT.
	SERCOM_I2CM_STATUS_SEXTTOUT = 0x200
	// Position of LENERR field.
	SERCOM_I2CM_STATUS_LENERR_Pos = 0xa
	// Bit mask of LENERR field.
	SERCOM_I2CM_STATUS_LENERR_Msk = 0x400
	// Bit LENERR.
	SERCOM_I2CM_STATUS_LENERR = 0x400

	// SYNCBUSY: I2CM Synchronization Busy
	// Position of SWRST field.
	SERCOM_I2CM_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	SERCOM_I2CM_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	SERCOM_I2CM_SYNCBUSY_SWRST = 0x1
	// Position of ENABLE field.
	SERCOM_I2CM_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	SERCOM_I2CM_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	SERCOM_I2CM_SYNCBUSY_ENABLE = 0x2
	// Position of SYSOP field.
	SERCOM_I2CM_SYNCBUSY_SYSOP_Pos = 0x2
	// Bit mask of SYSOP field.
	SERCOM_I2CM_SYNCBUSY_SYSOP_Msk = 0x4
	// Bit SYSOP.
	SERCOM_I2CM_SYNCBUSY_SYSOP = 0x4
	// Position of LENGTH field.
	SERCOM_I2CM_SYNCBUSY_LENGTH_Pos = 0x4
	// Bit mask of LENGTH field.
	SERCOM_I2CM_SYNCBUSY_LENGTH_Msk = 0x10
	// Bit LENGTH.
	SERCOM_I2CM_SYNCBUSY_LENGTH = 0x10

	// ADDR: I2CM Address
	// Position of ADDR field.
	SERCOM_I2CM_ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	SERCOM_I2CM_ADDR_ADDR_Msk = 0x7ff
	// Position of LENEN field.
	SERCOM_I2CM_ADDR_LENEN_Pos = 0xd
	// Bit mask of LENEN field.
	SERCOM_I2CM_ADDR_LENEN_Msk = 0x2000
	// Bit LENEN.
	SERCOM_I2CM_ADDR_LENEN = 0x2000
	// Position of HS field.
	SERCOM_I2CM_ADDR_HS_Pos = 0xe
	// Bit mask of HS field.
	SERCOM_I2CM_ADDR_HS_Msk = 0x4000
	// Bit HS.
	SERCOM_I2CM_ADDR_HS = 0x4000
	// Position of TENBITEN field.
	SERCOM_I2CM_ADDR_TENBITEN_Pos = 0xf
	// Bit mask of TENBITEN field.
	SERCOM_I2CM_ADDR_TENBITEN_Msk = 0x8000
	// Bit TENBITEN.
	SERCOM_I2CM_ADDR_TENBITEN = 0x8000
	// Position of LEN field.
	SERCOM_I2CM_ADDR_LEN_Pos = 0x10
	// Bit mask of LEN field.
	SERCOM_I2CM_ADDR_LEN_Msk = 0xff0000

	// DATA: I2CM Data
	// Position of DATA field.
	SERCOM_I2CM_DATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	SERCOM_I2CM_DATA_DATA_Msk = 0xff

	// DBGCTRL: I2CM Debug Control
	// Position of DBGSTOP field.
	SERCOM_I2CM_DBGCTRL_DBGSTOP_Pos = 0x0
	// Bit mask of DBGSTOP field.
	SERCOM_I2CM_DBGCTRL_DBGSTOP_Msk = 0x1
	// Bit DBGSTOP.
	SERCOM_I2CM_DBGCTRL_DBGSTOP = 0x1
)

// Constants for SERCOM0_I2CS: Serial Communication Interface - I2CS
const (
	// CTRLA: I2CS Control A
	// Position of SWRST field.
	SERCOM_I2CS_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	SERCOM_I2CS_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	SERCOM_I2CS_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	SERCOM_I2CS_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	SERCOM_I2CS_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	SERCOM_I2CS_CTRLA_ENABLE = 0x2
	// Position of MODE field.
	SERCOM_I2CS_CTRLA_MODE_Pos = 0x2
	// Bit mask of MODE field.
	SERCOM_I2CS_CTRLA_MODE_Msk = 0x1c
	// USART with external clock
	SERCOM_I2CS_CTRLA_MODE_USART_EXT_CLK = 0x0
	// USART with internal clock
	SERCOM_I2CS_CTRLA_MODE_USART_INT_CLK = 0x1
	// SPI in slave operation
	SERCOM_I2CS_CTRLA_MODE_SPI_SLAVE = 0x2
	// SPI in master operation
	SERCOM_I2CS_CTRLA_MODE_SPI_MASTER = 0x3
	// I2C slave operation
	SERCOM_I2CS_CTRLA_MODE_I2C_SLAVE = 0x4
	// I2C master operation
	SERCOM_I2CS_CTRLA_MODE_I2C_MASTER = 0x5
	// Position of RUNSTDBY field.
	SERCOM_I2CS_CTRLA_RUNSTDBY_Pos = 0x7
	// Bit mask of RUNSTDBY field.
	SERCOM_I2CS_CTRLA_RUNSTDBY_Msk = 0x80
	// Bit RUNSTDBY.
	SERCOM_I2CS_CTRLA_RUNSTDBY = 0x80
	// Position of PINOUT field.
	SERCOM_I2CS_CTRLA_PINOUT_Pos = 0x10
	// Bit mask of PINOUT field.
	SERCOM_I2CS_CTRLA_PINOUT_Msk = 0x10000
	// Bit PINOUT.
	SERCOM_I2CS_CTRLA_PINOUT = 0x10000
	// Position of SDAHOLD field.
	SERCOM_I2CS_CTRLA_SDAHOLD_Pos = 0x14
	// Bit mask of SDAHOLD field.
	SERCOM_I2CS_CTRLA_SDAHOLD_Msk = 0x300000
	// Disabled
	SERCOM_I2CS_CTRLA_SDAHOLD_DISABLE = 0x0
	// 50-100ns hold time
	SERCOM_I2CS_CTRLA_SDAHOLD_75NS = 0x1
	// 300-600ns hold time
	SERCOM_I2CS_CTRLA_SDAHOLD_450NS = 0x2
	// 400-800ns hold time
	SERCOM_I2CS_CTRLA_SDAHOLD_600NS = 0x3
	// Position of SEXTTOEN field.
	SERCOM_I2CS_CTRLA_SEXTTOEN_Pos = 0x17
	// Bit mask of SEXTTOEN field.
	SERCOM_I2CS_CTRLA_SEXTTOEN_Msk = 0x800000
	// Bit SEXTTOEN.
	SERCOM_I2CS_CTRLA_SEXTTOEN = 0x800000
	// Position of SPEED field.
	SERCOM_I2CS_CTRLA_SPEED_Pos = 0x18
	// Bit mask of SPEED field.
	SERCOM_I2CS_CTRLA_SPEED_Msk = 0x3000000
	// Standard Mode(Sm) Upto 100kHz and Fast Mode(Fm) Upto 400kHz
	SERCOM_I2CS_CTRLA_SPEED_STANDARD_AND_FAST_MODE = 0x0
	// Fast-mode Plus Upto 1MHz
	SERCOM_I2CS_CTRLA_SPEED_FASTPLUS_MODE = 0x1
	// High-speed mode Upto 3.4MHz
	SERCOM_I2CS_CTRLA_SPEED_HIGH_SPEED_MODE = 0x2
	// Position of SCLSM field.
	SERCOM_I2CS_CTRLA_SCLSM_Pos = 0x1b
	// Bit mask of SCLSM field.
	SERCOM_I2CS_CTRLA_SCLSM_Msk = 0x8000000
	// Bit SCLSM.
	SERCOM_I2CS_CTRLA_SCLSM = 0x8000000
	// Position of LOWTOUTEN field.
	SERCOM_I2CS_CTRLA_LOWTOUTEN_Pos = 0x1e
	// Bit mask of LOWTOUTEN field.
	SERCOM_I2CS_CTRLA_LOWTOUTEN_Msk = 0x40000000
	// Bit LOWTOUTEN.
	SERCOM_I2CS_CTRLA_LOWTOUTEN = 0x40000000

	// CTRLB: I2CS Control B
	// Position of SMEN field.
	SERCOM_I2CS_CTRLB_SMEN_Pos = 0x8
	// Bit mask of SMEN field.
	SERCOM_I2CS_CTRLB_SMEN_Msk = 0x100
	// Bit SMEN.
	SERCOM_I2CS_CTRLB_SMEN = 0x100
	// Position of GCMD field.
	SERCOM_I2CS_CTRLB_GCMD_Pos = 0x9
	// Bit mask of GCMD field.
	SERCOM_I2CS_CTRLB_GCMD_Msk = 0x200
	// Bit GCMD.
	SERCOM_I2CS_CTRLB_GCMD = 0x200
	// Position of AACKEN field.
	SERCOM_I2CS_CTRLB_AACKEN_Pos = 0xa
	// Bit mask of AACKEN field.
	SERCOM_I2CS_CTRLB_AACKEN_Msk = 0x400
	// Bit AACKEN.
	SERCOM_I2CS_CTRLB_AACKEN = 0x400
	// Position of AMODE field.
	SERCOM_I2CS_CTRLB_AMODE_Pos = 0xe
	// Bit mask of AMODE field.
	SERCOM_I2CS_CTRLB_AMODE_Msk = 0xc000
	// Position of CMD field.
	SERCOM_I2CS_CTRLB_CMD_Pos = 0x10
	// Bit mask of CMD field.
	SERCOM_I2CS_CTRLB_CMD_Msk = 0x30000
	// Position of ACKACT field.
	SERCOM_I2CS_CTRLB_ACKACT_Pos = 0x12
	// Bit mask of ACKACT field.
	SERCOM_I2CS_CTRLB_ACKACT_Msk = 0x40000
	// Bit ACKACT.
	SERCOM_I2CS_CTRLB_ACKACT = 0x40000

	// CTRLC: I2CS Control C
	// Position of SDASETUP field.
	SERCOM_I2CS_CTRLC_SDASETUP_Pos = 0x0
	// Bit mask of SDASETUP field.
	SERCOM_I2CS_CTRLC_SDASETUP_Msk = 0xf
	// Position of DATA32B field.
	SERCOM_I2CS_CTRLC_DATA32B_Pos = 0x18
	// Bit mask of DATA32B field.
	SERCOM_I2CS_CTRLC_DATA32B_Msk = 0x1000000
	// Bit DATA32B.
	SERCOM_I2CS_CTRLC_DATA32B = 0x1000000
	// Data transaction from/to DATA register are 8-bit
	SERCOM_I2CS_CTRLC_DATA32B_DATA_TRANS_8BIT = 0x0
	// Data transaction from/to DATA register are 32-bit
	SERCOM_I2CS_CTRLC_DATA32B_DATA_TRANS_32BIT = 0x1

	// INTENCLR: I2CS Interrupt Enable Clear
	// Position of PREC field.
	SERCOM_I2CS_INTENCLR_PREC_Pos = 0x0
	// Bit mask of PREC field.
	SERCOM_I2CS_INTENCLR_PREC_Msk = 0x1
	// Bit PREC.
	SERCOM_I2CS_INTENCLR_PREC = 0x1
	// Position of AMATCH field.
	SERCOM_I2CS_INTENCLR_AMATCH_Pos = 0x1
	// Bit mask of AMATCH field.
	SERCOM_I2CS_INTENCLR_AMATCH_Msk = 0x2
	// Bit AMATCH.
	SERCOM_I2CS_INTENCLR_AMATCH = 0x2
	// Position of DRDY field.
	SERCOM_I2CS_INTENCLR_DRDY_Pos = 0x2
	// Bit mask of DRDY field.
	SERCOM_I2CS_INTENCLR_DRDY_Msk = 0x4
	// Bit DRDY.
	SERCOM_I2CS_INTENCLR_DRDY = 0x4
	// Position of ERROR field.
	SERCOM_I2CS_INTENCLR_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	SERCOM_I2CS_INTENCLR_ERROR_Msk = 0x80
	// Bit ERROR.
	SERCOM_I2CS_INTENCLR_ERROR = 0x80

	// INTENSET: I2CS Interrupt Enable Set
	// Position of PREC field.
	SERCOM_I2CS_INTENSET_PREC_Pos = 0x0
	// Bit mask of PREC field.
	SERCOM_I2CS_INTENSET_PREC_Msk = 0x1
	// Bit PREC.
	SERCOM_I2CS_INTENSET_PREC = 0x1
	// Position of AMATCH field.
	SERCOM_I2CS_INTENSET_AMATCH_Pos = 0x1
	// Bit mask of AMATCH field.
	SERCOM_I2CS_INTENSET_AMATCH_Msk = 0x2
	// Bit AMATCH.
	SERCOM_I2CS_INTENSET_AMATCH = 0x2
	// Position of DRDY field.
	SERCOM_I2CS_INTENSET_DRDY_Pos = 0x2
	// Bit mask of DRDY field.
	SERCOM_I2CS_INTENSET_DRDY_Msk = 0x4
	// Bit DRDY.
	SERCOM_I2CS_INTENSET_DRDY = 0x4
	// Position of ERROR field.
	SERCOM_I2CS_INTENSET_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	SERCOM_I2CS_INTENSET_ERROR_Msk = 0x80
	// Bit ERROR.
	SERCOM_I2CS_INTENSET_ERROR = 0x80

	// INTFLAG: I2CS Interrupt Flag Status and Clear
	// Position of PREC field.
	SERCOM_I2CS_INTFLAG_PREC_Pos = 0x0
	// Bit mask of PREC field.
	SERCOM_I2CS_INTFLAG_PREC_Msk = 0x1
	// Bit PREC.
	SERCOM_I2CS_INTFLAG_PREC = 0x1
	// Position of AMATCH field.
	SERCOM_I2CS_INTFLAG_AMATCH_Pos = 0x1
	// Bit mask of AMATCH field.
	SERCOM_I2CS_INTFLAG_AMATCH_Msk = 0x2
	// Bit AMATCH.
	SERCOM_I2CS_INTFLAG_AMATCH = 0x2
	// Position of DRDY field.
	SERCOM_I2CS_INTFLAG_DRDY_Pos = 0x2
	// Bit mask of DRDY field.
	SERCOM_I2CS_INTFLAG_DRDY_Msk = 0x4
	// Bit DRDY.
	SERCOM_I2CS_INTFLAG_DRDY = 0x4
	// Position of ERROR field.
	SERCOM_I2CS_INTFLAG_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	SERCOM_I2CS_INTFLAG_ERROR_Msk = 0x80
	// Bit ERROR.
	SERCOM_I2CS_INTFLAG_ERROR = 0x80

	// STATUS: I2CS Status
	// Position of BUSERR field.
	SERCOM_I2CS_STATUS_BUSERR_Pos = 0x0
	// Bit mask of BUSERR field.
	SERCOM_I2CS_STATUS_BUSERR_Msk = 0x1
	// Bit BUSERR.
	SERCOM_I2CS_STATUS_BUSERR = 0x1
	// Position of COLL field.
	SERCOM_I2CS_STATUS_COLL_Pos = 0x1
	// Bit mask of COLL field.
	SERCOM_I2CS_STATUS_COLL_Msk = 0x2
	// Bit COLL.
	SERCOM_I2CS_STATUS_COLL = 0x2
	// Position of RXNACK field.
	SERCOM_I2CS_STATUS_RXNACK_Pos = 0x2
	// Bit mask of RXNACK field.
	SERCOM_I2CS_STATUS_RXNACK_Msk = 0x4
	// Bit RXNACK.
	SERCOM_I2CS_STATUS_RXNACK = 0x4
	// Position of DIR field.
	SERCOM_I2CS_STATUS_DIR_Pos = 0x3
	// Bit mask of DIR field.
	SERCOM_I2CS_STATUS_DIR_Msk = 0x8
	// Bit DIR.
	SERCOM_I2CS_STATUS_DIR = 0x8
	// Position of SR field.
	SERCOM_I2CS_STATUS_SR_Pos = 0x4
	// Bit mask of SR field.
	SERCOM_I2CS_STATUS_SR_Msk = 0x10
	// Bit SR.
	SERCOM_I2CS_STATUS_SR = 0x10
	// Position of LOWTOUT field.
	SERCOM_I2CS_STATUS_LOWTOUT_Pos = 0x6
	// Bit mask of LOWTOUT field.
	SERCOM_I2CS_STATUS_LOWTOUT_Msk = 0x40
	// Bit LOWTOUT.
	SERCOM_I2CS_STATUS_LOWTOUT = 0x40
	// Position of CLKHOLD field.
	SERCOM_I2CS_STATUS_CLKHOLD_Pos = 0x7
	// Bit mask of CLKHOLD field.
	SERCOM_I2CS_STATUS_CLKHOLD_Msk = 0x80
	// Bit CLKHOLD.
	SERCOM_I2CS_STATUS_CLKHOLD = 0x80
	// Position of SEXTTOUT field.
	SERCOM_I2CS_STATUS_SEXTTOUT_Pos = 0x9
	// Bit mask of SEXTTOUT field.
	SERCOM_I2CS_STATUS_SEXTTOUT_Msk = 0x200
	// Bit SEXTTOUT.
	SERCOM_I2CS_STATUS_SEXTTOUT = 0x200
	// Position of HS field.
	SERCOM_I2CS_STATUS_HS_Pos = 0xa
	// Bit mask of HS field.
	SERCOM_I2CS_STATUS_HS_Msk = 0x400
	// Bit HS.
	SERCOM_I2CS_STATUS_HS = 0x400
	// Position of LENERR field.
	SERCOM_I2CS_STATUS_LENERR_Pos = 0xb
	// Bit mask of LENERR field.
	SERCOM_I2CS_STATUS_LENERR_Msk = 0x800
	// Bit LENERR.
	SERCOM_I2CS_STATUS_LENERR = 0x800

	// SYNCBUSY: I2CS Synchronization Busy
	// Position of SWRST field.
	SERCOM_I2CS_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	SERCOM_I2CS_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	SERCOM_I2CS_SYNCBUSY_SWRST = 0x1
	// Position of ENABLE field.
	SERCOM_I2CS_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	SERCOM_I2CS_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	SERCOM_I2CS_SYNCBUSY_ENABLE = 0x2
	// Position of LENGTH field.
	SERCOM_I2CS_SYNCBUSY_LENGTH_Pos = 0x4
	// Bit mask of LENGTH field.
	SERCOM_I2CS_SYNCBUSY_LENGTH_Msk = 0x10
	// Bit LENGTH.
	SERCOM_I2CS_SYNCBUSY_LENGTH = 0x10

	// LENGTH: I2CS Length
	// Position of LEN field.
	SERCOM_I2CS_LENGTH_LEN_Pos = 0x0
	// Bit mask of LEN field.
	SERCOM_I2CS_LENGTH_LEN_Msk = 0xff
	// Position of LENEN field.
	SERCOM_I2CS_LENGTH_LENEN_Pos = 0x8
	// Bit mask of LENEN field.
	SERCOM_I2CS_LENGTH_LENEN_Msk = 0x100
	// Bit LENEN.
	SERCOM_I2CS_LENGTH_LENEN = 0x100

	// ADDR: I2CS Address
	// Position of GENCEN field.
	SERCOM_I2CS_ADDR_GENCEN_Pos = 0x0
	// Bit mask of GENCEN field.
	SERCOM_I2CS_ADDR_GENCEN_Msk = 0x1
	// Bit GENCEN.
	SERCOM_I2CS_ADDR_GENCEN = 0x1
	// Position of ADDR field.
	SERCOM_I2CS_ADDR_ADDR_Pos = 0x1
	// Bit mask of ADDR field.
	SERCOM_I2CS_ADDR_ADDR_Msk = 0x7fe
	// Position of TENBITEN field.
	SERCOM_I2CS_ADDR_TENBITEN_Pos = 0xf
	// Bit mask of TENBITEN field.
	SERCOM_I2CS_ADDR_TENBITEN_Msk = 0x8000
	// Bit TENBITEN.
	SERCOM_I2CS_ADDR_TENBITEN = 0x8000
	// Position of ADDRMASK field.
	SERCOM_I2CS_ADDR_ADDRMASK_Pos = 0x11
	// Bit mask of ADDRMASK field.
	SERCOM_I2CS_ADDR_ADDRMASK_Msk = 0x7fe0000

	// DATA: I2CS Data
	// Position of DATA field.
	SERCOM_I2CS_DATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	SERCOM_I2CS_DATA_DATA_Msk = 0xffffffff
)

// Constants for SERCOM0_SPIS: Serial Communication Interface - SPIS
const (
	// CTRLA: SPIS Control A
	// Position of SWRST field.
	SERCOM_SPIS_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	SERCOM_SPIS_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	SERCOM_SPIS_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	SERCOM_SPIS_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	SERCOM_SPIS_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	SERCOM_SPIS_CTRLA_ENABLE = 0x2
	// Position of MODE field.
	SERCOM_SPIS_CTRLA_MODE_Pos = 0x2
	// Bit mask of MODE field.
	SERCOM_SPIS_CTRLA_MODE_Msk = 0x1c
	// USART with external clock
	SERCOM_SPIS_CTRLA_MODE_USART_EXT_CLK = 0x0
	// USART with internal clock
	SERCOM_SPIS_CTRLA_MODE_USART_INT_CLK = 0x1
	// SPI in slave operation
	SERCOM_SPIS_CTRLA_MODE_SPI_SLAVE = 0x2
	// SPI in master operation
	SERCOM_SPIS_CTRLA_MODE_SPI_MASTER = 0x3
	// I2C slave operation
	SERCOM_SPIS_CTRLA_MODE_I2C_SLAVE = 0x4
	// I2C master operation
	SERCOM_SPIS_CTRLA_MODE_I2C_MASTER = 0x5
	// Position of RUNSTDBY field.
	SERCOM_SPIS_CTRLA_RUNSTDBY_Pos = 0x7
	// Bit mask of RUNSTDBY field.
	SERCOM_SPIS_CTRLA_RUNSTDBY_Msk = 0x80
	// Bit RUNSTDBY.
	SERCOM_SPIS_CTRLA_RUNSTDBY = 0x80
	// Position of IBON field.
	SERCOM_SPIS_CTRLA_IBON_Pos = 0x8
	// Bit mask of IBON field.
	SERCOM_SPIS_CTRLA_IBON_Msk = 0x100
	// Bit IBON.
	SERCOM_SPIS_CTRLA_IBON = 0x100
	// Position of DOPO field.
	SERCOM_SPIS_CTRLA_DOPO_Pos = 0x10
	// Bit mask of DOPO field.
	SERCOM_SPIS_CTRLA_DOPO_Msk = 0x30000
	// DO on PAD[0], SCK on PAD[1] and SS on PAD[2]
	SERCOM_SPIS_CTRLA_DOPO_PAD0 = 0x0
	// DO on PAD[3], SCK on PAD[1] and SS on PAD[2]
	SERCOM_SPIS_CTRLA_DOPO_PAD2 = 0x2
	// Position of DIPO field.
	SERCOM_SPIS_CTRLA_DIPO_Pos = 0x14
	// Bit mask of DIPO field.
	SERCOM_SPIS_CTRLA_DIPO_Msk = 0x300000
	// SERCOM PAD[0] is used as data input
	SERCOM_SPIS_CTRLA_DIPO_PAD0 = 0x0
	// SERCOM PAD[1] is used as data input
	SERCOM_SPIS_CTRLA_DIPO_PAD1 = 0x1
	// SERCOM PAD[2] is used as data input
	SERCOM_SPIS_CTRLA_DIPO_PAD2 = 0x2
	// SERCOM PAD[3] is used as data input
	SERCOM_SPIS_CTRLA_DIPO_PAD3 = 0x3
	// Position of FORM field.
	SERCOM_SPIS_CTRLA_FORM_Pos = 0x18
	// Bit mask of FORM field.
	SERCOM_SPIS_CTRLA_FORM_Msk = 0xf000000
	// SPI Frame
	SERCOM_SPIS_CTRLA_FORM_SPI_FRAME = 0x0
	// SPI Frame with Addr
	SERCOM_SPIS_CTRLA_FORM_SPI_FRAME_WITH_ADDR = 0x2
	// Position of CPHA field.
	SERCOM_SPIS_CTRLA_CPHA_Pos = 0x1c
	// Bit mask of CPHA field.
	SERCOM_SPIS_CTRLA_CPHA_Msk = 0x10000000
	// Bit CPHA.
	SERCOM_SPIS_CTRLA_CPHA = 0x10000000
	// The data is sampled on a leading SCK edge and changed on a trailing SCK edge
	SERCOM_SPIS_CTRLA_CPHA_LEADING_EDGE = 0x0
	// The data is sampled on a trailing SCK edge and changed on a leading SCK edge
	SERCOM_SPIS_CTRLA_CPHA_TRAILING_EDGE = 0x1
	// Position of CPOL field.
	SERCOM_SPIS_CTRLA_CPOL_Pos = 0x1d
	// Bit mask of CPOL field.
	SERCOM_SPIS_CTRLA_CPOL_Msk = 0x20000000
	// Bit CPOL.
	SERCOM_SPIS_CTRLA_CPOL = 0x20000000
	// SCK is low when idle
	SERCOM_SPIS_CTRLA_CPOL_IDLE_LOW = 0x0
	// SCK is high when idle
	SERCOM_SPIS_CTRLA_CPOL_IDLE_HIGH = 0x1
	// Position of DORD field.
	SERCOM_SPIS_CTRLA_DORD_Pos = 0x1e
	// Bit mask of DORD field.
	SERCOM_SPIS_CTRLA_DORD_Msk = 0x40000000
	// Bit DORD.
	SERCOM_SPIS_CTRLA_DORD = 0x40000000
	// MSB is transferred first
	SERCOM_SPIS_CTRLA_DORD_MSB = 0x0
	// LSB is transferred first
	SERCOM_SPIS_CTRLA_DORD_LSB = 0x1

	// CTRLB: SPIS Control B
	// Position of CHSIZE field.
	SERCOM_SPIS_CTRLB_CHSIZE_Pos = 0x0
	// Bit mask of CHSIZE field.
	SERCOM_SPIS_CTRLB_CHSIZE_Msk = 0x7
	// 8 bits
	SERCOM_SPIS_CTRLB_CHSIZE_8_BIT = 0x0
	// 9 bits
	SERCOM_SPIS_CTRLB_CHSIZE_9_BIT = 0x1
	// Position of PLOADEN field.
	SERCOM_SPIS_CTRLB_PLOADEN_Pos = 0x6
	// Bit mask of PLOADEN field.
	SERCOM_SPIS_CTRLB_PLOADEN_Msk = 0x40
	// Bit PLOADEN.
	SERCOM_SPIS_CTRLB_PLOADEN = 0x40
	// Position of SSDE field.
	SERCOM_SPIS_CTRLB_SSDE_Pos = 0x9
	// Bit mask of SSDE field.
	SERCOM_SPIS_CTRLB_SSDE_Msk = 0x200
	// Bit SSDE.
	SERCOM_SPIS_CTRLB_SSDE = 0x200
	// Position of MSSEN field.
	SERCOM_SPIS_CTRLB_MSSEN_Pos = 0xd
	// Bit mask of MSSEN field.
	SERCOM_SPIS_CTRLB_MSSEN_Msk = 0x2000
	// Bit MSSEN.
	SERCOM_SPIS_CTRLB_MSSEN = 0x2000
	// Position of AMODE field.
	SERCOM_SPIS_CTRLB_AMODE_Pos = 0xe
	// Bit mask of AMODE field.
	SERCOM_SPIS_CTRLB_AMODE_Msk = 0xc000
	// SPI Address mask
	SERCOM_SPIS_CTRLB_AMODE_MASK = 0x0
	// Two unique Addressess
	SERCOM_SPIS_CTRLB_AMODE_2_ADDRESSES = 0x1
	// Address Range
	SERCOM_SPIS_CTRLB_AMODE_RANGE = 0x2
	// Position of RXEN field.
	SERCOM_SPIS_CTRLB_RXEN_Pos = 0x11
	// Bit mask of RXEN field.
	SERCOM_SPIS_CTRLB_RXEN_Msk = 0x20000
	// Bit RXEN.
	SERCOM_SPIS_CTRLB_RXEN = 0x20000

	// CTRLC: SPIS Control C
	// Position of ICSPACE field.
	SERCOM_SPIS_CTRLC_ICSPACE_Pos = 0x0
	// Bit mask of ICSPACE field.
	SERCOM_SPIS_CTRLC_ICSPACE_Msk = 0x3f
	// Position of DATA32B field.
	SERCOM_SPIS_CTRLC_DATA32B_Pos = 0x18
	// Bit mask of DATA32B field.
	SERCOM_SPIS_CTRLC_DATA32B_Msk = 0x1000000
	// Bit DATA32B.
	SERCOM_SPIS_CTRLC_DATA32B = 0x1000000
	// Transaction from and to DATA register are 8-bit
	SERCOM_SPIS_CTRLC_DATA32B_DATA_TRANS_8BIT = 0x0
	// Transaction from and to DATA register are 32-bit
	SERCOM_SPIS_CTRLC_DATA32B_DATA_TRANS_32BIT = 0x1

	// BAUD: SPIS Baud Rate
	// Position of BAUD field.
	SERCOM_SPIS_BAUD_BAUD_Pos = 0x0
	// Bit mask of BAUD field.
	SERCOM_SPIS_BAUD_BAUD_Msk = 0xff

	// INTENCLR: SPIS Interrupt Enable Clear
	// Position of DRE field.
	SERCOM_SPIS_INTENCLR_DRE_Pos = 0x0
	// Bit mask of DRE field.
	SERCOM_SPIS_INTENCLR_DRE_Msk = 0x1
	// Bit DRE.
	SERCOM_SPIS_INTENCLR_DRE = 0x1
	// Position of TXC field.
	SERCOM_SPIS_INTENCLR_TXC_Pos = 0x1
	// Bit mask of TXC field.
	SERCOM_SPIS_INTENCLR_TXC_Msk = 0x2
	// Bit TXC.
	SERCOM_SPIS_INTENCLR_TXC = 0x2
	// Position of RXC field.
	SERCOM_SPIS_INTENCLR_RXC_Pos = 0x2
	// Bit mask of RXC field.
	SERCOM_SPIS_INTENCLR_RXC_Msk = 0x4
	// Bit RXC.
	SERCOM_SPIS_INTENCLR_RXC = 0x4
	// Position of SSL field.
	SERCOM_SPIS_INTENCLR_SSL_Pos = 0x3
	// Bit mask of SSL field.
	SERCOM_SPIS_INTENCLR_SSL_Msk = 0x8
	// Bit SSL.
	SERCOM_SPIS_INTENCLR_SSL = 0x8
	// Position of ERROR field.
	SERCOM_SPIS_INTENCLR_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	SERCOM_SPIS_INTENCLR_ERROR_Msk = 0x80
	// Bit ERROR.
	SERCOM_SPIS_INTENCLR_ERROR = 0x80

	// INTENSET: SPIS Interrupt Enable Set
	// Position of DRE field.
	SERCOM_SPIS_INTENSET_DRE_Pos = 0x0
	// Bit mask of DRE field.
	SERCOM_SPIS_INTENSET_DRE_Msk = 0x1
	// Bit DRE.
	SERCOM_SPIS_INTENSET_DRE = 0x1
	// Position of TXC field.
	SERCOM_SPIS_INTENSET_TXC_Pos = 0x1
	// Bit mask of TXC field.
	SERCOM_SPIS_INTENSET_TXC_Msk = 0x2
	// Bit TXC.
	SERCOM_SPIS_INTENSET_TXC = 0x2
	// Position of RXC field.
	SERCOM_SPIS_INTENSET_RXC_Pos = 0x2
	// Bit mask of RXC field.
	SERCOM_SPIS_INTENSET_RXC_Msk = 0x4
	// Bit RXC.
	SERCOM_SPIS_INTENSET_RXC = 0x4
	// Position of SSL field.
	SERCOM_SPIS_INTENSET_SSL_Pos = 0x3
	// Bit mask of SSL field.
	SERCOM_SPIS_INTENSET_SSL_Msk = 0x8
	// Bit SSL.
	SERCOM_SPIS_INTENSET_SSL = 0x8
	// Position of ERROR field.
	SERCOM_SPIS_INTENSET_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	SERCOM_SPIS_INTENSET_ERROR_Msk = 0x80
	// Bit ERROR.
	SERCOM_SPIS_INTENSET_ERROR = 0x80

	// INTFLAG: SPIS Interrupt Flag Status and Clear
	// Position of DRE field.
	SERCOM_SPIS_INTFLAG_DRE_Pos = 0x0
	// Bit mask of DRE field.
	SERCOM_SPIS_INTFLAG_DRE_Msk = 0x1
	// Bit DRE.
	SERCOM_SPIS_INTFLAG_DRE = 0x1
	// Position of TXC field.
	SERCOM_SPIS_INTFLAG_TXC_Pos = 0x1
	// Bit mask of TXC field.
	SERCOM_SPIS_INTFLAG_TXC_Msk = 0x2
	// Bit TXC.
	SERCOM_SPIS_INTFLAG_TXC = 0x2
	// Position of RXC field.
	SERCOM_SPIS_INTFLAG_RXC_Pos = 0x2
	// Bit mask of RXC field.
	SERCOM_SPIS_INTFLAG_RXC_Msk = 0x4
	// Bit RXC.
	SERCOM_SPIS_INTFLAG_RXC = 0x4
	// Position of SSL field.
	SERCOM_SPIS_INTFLAG_SSL_Pos = 0x3
	// Bit mask of SSL field.
	SERCOM_SPIS_INTFLAG_SSL_Msk = 0x8
	// Bit SSL.
	SERCOM_SPIS_INTFLAG_SSL = 0x8
	// Position of ERROR field.
	SERCOM_SPIS_INTFLAG_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	SERCOM_SPIS_INTFLAG_ERROR_Msk = 0x80
	// Bit ERROR.
	SERCOM_SPIS_INTFLAG_ERROR = 0x80

	// STATUS: SPIS Status
	// Position of BUFOVF field.
	SERCOM_SPIS_STATUS_BUFOVF_Pos = 0x2
	// Bit mask of BUFOVF field.
	SERCOM_SPIS_STATUS_BUFOVF_Msk = 0x4
	// Bit BUFOVF.
	SERCOM_SPIS_STATUS_BUFOVF = 0x4
	// Position of LENERR field.
	SERCOM_SPIS_STATUS_LENERR_Pos = 0xb
	// Bit mask of LENERR field.
	SERCOM_SPIS_STATUS_LENERR_Msk = 0x800
	// Bit LENERR.
	SERCOM_SPIS_STATUS_LENERR = 0x800

	// SYNCBUSY: SPIS Synchronization Busy
	// Position of SWRST field.
	SERCOM_SPIS_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	SERCOM_SPIS_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	SERCOM_SPIS_SYNCBUSY_SWRST = 0x1
	// Position of ENABLE field.
	SERCOM_SPIS_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	SERCOM_SPIS_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	SERCOM_SPIS_SYNCBUSY_ENABLE = 0x2
	// Position of CTRLB field.
	SERCOM_SPIS_SYNCBUSY_CTRLB_Pos = 0x2
	// Bit mask of CTRLB field.
	SERCOM_SPIS_SYNCBUSY_CTRLB_Msk = 0x4
	// Bit CTRLB.
	SERCOM_SPIS_SYNCBUSY_CTRLB = 0x4
	// Position of LENGTH field.
	SERCOM_SPIS_SYNCBUSY_LENGTH_Pos = 0x4
	// Bit mask of LENGTH field.
	SERCOM_SPIS_SYNCBUSY_LENGTH_Msk = 0x10
	// Bit LENGTH.
	SERCOM_SPIS_SYNCBUSY_LENGTH = 0x10

	// LENGTH: SPIS Length
	// Position of LEN field.
	SERCOM_SPIS_LENGTH_LEN_Pos = 0x0
	// Bit mask of LEN field.
	SERCOM_SPIS_LENGTH_LEN_Msk = 0xff
	// Position of LENEN field.
	SERCOM_SPIS_LENGTH_LENEN_Pos = 0x8
	// Bit mask of LENEN field.
	SERCOM_SPIS_LENGTH_LENEN_Msk = 0x100
	// Bit LENEN.
	SERCOM_SPIS_LENGTH_LENEN = 0x100

	// ADDR: SPIS Address
	// Position of ADDR field.
	SERCOM_SPIS_ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	SERCOM_SPIS_ADDR_ADDR_Msk = 0xff
	// Position of ADDRMASK field.
	SERCOM_SPIS_ADDR_ADDRMASK_Pos = 0x10
	// Bit mask of ADDRMASK field.
	SERCOM_SPIS_ADDR_ADDRMASK_Msk = 0xff0000

	// DATA: SPIS Data
	// Position of DATA field.
	SERCOM_SPIS_DATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	SERCOM_SPIS_DATA_DATA_Msk = 0xffffffff

	// DBGCTRL: SPIS Debug Control
	// Position of DBGSTOP field.
	SERCOM_SPIS_DBGCTRL_DBGSTOP_Pos = 0x0
	// Bit mask of DBGSTOP field.
	SERCOM_SPIS_DBGCTRL_DBGSTOP_Msk = 0x1
	// Bit DBGSTOP.
	SERCOM_SPIS_DBGCTRL_DBGSTOP = 0x1
)

// Constants for SERCOM0_SPIM: Serial Communication Interface - SPIM
const (
	// CTRLA: SPIM Control A
	// Position of SWRST field.
	SERCOM_SPIM_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	SERCOM_SPIM_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	SERCOM_SPIM_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	SERCOM_SPIM_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	SERCOM_SPIM_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	SERCOM_SPIM_CTRLA_ENABLE = 0x2
	// Position of MODE field.
	SERCOM_SPIM_CTRLA_MODE_Pos = 0x2
	// Bit mask of MODE field.
	SERCOM_SPIM_CTRLA_MODE_Msk = 0x1c
	// USART with external clock
	SERCOM_SPIM_CTRLA_MODE_USART_EXT_CLK = 0x0
	// USART with internal clock
	SERCOM_SPIM_CTRLA_MODE_USART_INT_CLK = 0x1
	// SPI in slave operation
	SERCOM_SPIM_CTRLA_MODE_SPI_SLAVE = 0x2
	// SPI in master operation
	SERCOM_SPIM_CTRLA_MODE_SPI_MASTER = 0x3
	// I2C slave operation
	SERCOM_SPIM_CTRLA_MODE_I2C_SLAVE = 0x4
	// I2C master operation
	SERCOM_SPIM_CTRLA_MODE_I2C_MASTER = 0x5
	// Position of RUNSTDBY field.
	SERCOM_SPIM_CTRLA_RUNSTDBY_Pos = 0x7
	// Bit mask of RUNSTDBY field.
	SERCOM_SPIM_CTRLA_RUNSTDBY_Msk = 0x80
	// Bit RUNSTDBY.
	SERCOM_SPIM_CTRLA_RUNSTDBY = 0x80
	// Position of IBON field.
	SERCOM_SPIM_CTRLA_IBON_Pos = 0x8
	// Bit mask of IBON field.
	SERCOM_SPIM_CTRLA_IBON_Msk = 0x100
	// Bit IBON.
	SERCOM_SPIM_CTRLA_IBON = 0x100
	// Position of DOPO field.
	SERCOM_SPIM_CTRLA_DOPO_Pos = 0x10
	// Bit mask of DOPO field.
	SERCOM_SPIM_CTRLA_DOPO_Msk = 0x30000
	// DO on PAD[0], SCK on PAD[1] and SS on PAD[2]
	SERCOM_SPIM_CTRLA_DOPO_PAD0 = 0x0
	// DO on PAD[3], SCK on PAD[1] and SS on PAD[2]
	SERCOM_SPIM_CTRLA_DOPO_PAD2 = 0x2
	// Position of DIPO field.
	SERCOM_SPIM_CTRLA_DIPO_Pos = 0x14
	// Bit mask of DIPO field.
	SERCOM_SPIM_CTRLA_DIPO_Msk = 0x300000
	// SERCOM PAD[0] is used as data input
	SERCOM_SPIM_CTRLA_DIPO_PAD0 = 0x0
	// SERCOM PAD[1] is used as data input
	SERCOM_SPIM_CTRLA_DIPO_PAD1 = 0x1
	// SERCOM PAD[2] is used as data input
	SERCOM_SPIM_CTRLA_DIPO_PAD2 = 0x2
	// SERCOM PAD[3] is used as data input
	SERCOM_SPIM_CTRLA_DIPO_PAD3 = 0x3
	// Position of FORM field.
	SERCOM_SPIM_CTRLA_FORM_Pos = 0x18
	// Bit mask of FORM field.
	SERCOM_SPIM_CTRLA_FORM_Msk = 0xf000000
	// SPI Frame
	SERCOM_SPIM_CTRLA_FORM_SPI_FRAME = 0x0
	// SPI Frame with Addr
	SERCOM_SPIM_CTRLA_FORM_SPI_FRAME_WITH_ADDR = 0x2
	// Position of CPHA field.
	SERCOM_SPIM_CTRLA_CPHA_Pos = 0x1c
	// Bit mask of CPHA field.
	SERCOM_SPIM_CTRLA_CPHA_Msk = 0x10000000
	// Bit CPHA.
	SERCOM_SPIM_CTRLA_CPHA = 0x10000000
	// The data is sampled on a leading SCK edge and changed on a trailing SCK edge
	SERCOM_SPIM_CTRLA_CPHA_LEADING_EDGE = 0x0
	// The data is sampled on a trailing SCK edge and changed on a leading SCK edge
	SERCOM_SPIM_CTRLA_CPHA_TRAILING_EDGE = 0x1
	// Position of CPOL field.
	SERCOM_SPIM_CTRLA_CPOL_Pos = 0x1d
	// Bit mask of CPOL field.
	SERCOM_SPIM_CTRLA_CPOL_Msk = 0x20000000
	// Bit CPOL.
	SERCOM_SPIM_CTRLA_CPOL = 0x20000000
	// SCK is low when idle
	SERCOM_SPIM_CTRLA_CPOL_IDLE_LOW = 0x0
	// SCK is high when idle
	SERCOM_SPIM_CTRLA_CPOL_IDLE_HIGH = 0x1
	// Position of DORD field.
	SERCOM_SPIM_CTRLA_DORD_Pos = 0x1e
	// Bit mask of DORD field.
	SERCOM_SPIM_CTRLA_DORD_Msk = 0x40000000
	// Bit DORD.
	SERCOM_SPIM_CTRLA_DORD = 0x40000000
	// MSB is transferred first
	SERCOM_SPIM_CTRLA_DORD_MSB = 0x0
	// LSB is transferred first
	SERCOM_SPIM_CTRLA_DORD_LSB = 0x1

	// CTRLB: SPIM Control B
	// Position of CHSIZE field.
	SERCOM_SPIM_CTRLB_CHSIZE_Pos = 0x0
	// Bit mask of CHSIZE field.
	SERCOM_SPIM_CTRLB_CHSIZE_Msk = 0x7
	// 8 bits
	SERCOM_SPIM_CTRLB_CHSIZE_8_BIT = 0x0
	// 9 bits
	SERCOM_SPIM_CTRLB_CHSIZE_9_BIT = 0x1
	// Position of PLOADEN field.
	SERCOM_SPIM_CTRLB_PLOADEN_Pos = 0x6
	// Bit mask of PLOADEN field.
	SERCOM_SPIM_CTRLB_PLOADEN_Msk = 0x40
	// Bit PLOADEN.
	SERCOM_SPIM_CTRLB_PLOADEN = 0x40
	// Position of SSDE field.
	SERCOM_SPIM_CTRLB_SSDE_Pos = 0x9
	// Bit mask of SSDE field.
	SERCOM_SPIM_CTRLB_SSDE_Msk = 0x200
	// Bit SSDE.
	SERCOM_SPIM_CTRLB_SSDE = 0x200
	// Position of MSSEN field.
	SERCOM_SPIM_CTRLB_MSSEN_Pos = 0xd
	// Bit mask of MSSEN field.
	SERCOM_SPIM_CTRLB_MSSEN_Msk = 0x2000
	// Bit MSSEN.
	SERCOM_SPIM_CTRLB_MSSEN = 0x2000
	// Position of AMODE field.
	SERCOM_SPIM_CTRLB_AMODE_Pos = 0xe
	// Bit mask of AMODE field.
	SERCOM_SPIM_CTRLB_AMODE_Msk = 0xc000
	// SPI Address mask
	SERCOM_SPIM_CTRLB_AMODE_MASK = 0x0
	// Two unique Addressess
	SERCOM_SPIM_CTRLB_AMODE_2_ADDRESSES = 0x1
	// Address Range
	SERCOM_SPIM_CTRLB_AMODE_RANGE = 0x2
	// Position of RXEN field.
	SERCOM_SPIM_CTRLB_RXEN_Pos = 0x11
	// Bit mask of RXEN field.
	SERCOM_SPIM_CTRLB_RXEN_Msk = 0x20000
	// Bit RXEN.
	SERCOM_SPIM_CTRLB_RXEN = 0x20000

	// CTRLC: SPIM Control C
	// Position of ICSPACE field.
	SERCOM_SPIM_CTRLC_ICSPACE_Pos = 0x0
	// Bit mask of ICSPACE field.
	SERCOM_SPIM_CTRLC_ICSPACE_Msk = 0x3f
	// Position of DATA32B field.
	SERCOM_SPIM_CTRLC_DATA32B_Pos = 0x18
	// Bit mask of DATA32B field.
	SERCOM_SPIM_CTRLC_DATA32B_Msk = 0x1000000
	// Bit DATA32B.
	SERCOM_SPIM_CTRLC_DATA32B = 0x1000000
	// Transaction from and to DATA register are 8-bit
	SERCOM_SPIM_CTRLC_DATA32B_DATA_TRANS_8BIT = 0x0
	// Transaction from and to DATA register are 32-bit
	SERCOM_SPIM_CTRLC_DATA32B_DATA_TRANS_32BIT = 0x1

	// BAUD: SPIM Baud Rate
	// Position of BAUD field.
	SERCOM_SPIM_BAUD_BAUD_Pos = 0x0
	// Bit mask of BAUD field.
	SERCOM_SPIM_BAUD_BAUD_Msk = 0xff

	// INTENCLR: SPIM Interrupt Enable Clear
	// Position of DRE field.
	SERCOM_SPIM_INTENCLR_DRE_Pos = 0x0
	// Bit mask of DRE field.
	SERCOM_SPIM_INTENCLR_DRE_Msk = 0x1
	// Bit DRE.
	SERCOM_SPIM_INTENCLR_DRE = 0x1
	// Position of TXC field.
	SERCOM_SPIM_INTENCLR_TXC_Pos = 0x1
	// Bit mask of TXC field.
	SERCOM_SPIM_INTENCLR_TXC_Msk = 0x2
	// Bit TXC.
	SERCOM_SPIM_INTENCLR_TXC = 0x2
	// Position of RXC field.
	SERCOM_SPIM_INTENCLR_RXC_Pos = 0x2
	// Bit mask of RXC field.
	SERCOM_SPIM_INTENCLR_RXC_Msk = 0x4
	// Bit RXC.
	SERCOM_SPIM_INTENCLR_RXC = 0x4
	// Position of SSL field.
	SERCOM_SPIM_INTENCLR_SSL_Pos = 0x3
	// Bit mask of SSL field.
	SERCOM_SPIM_INTENCLR_SSL_Msk = 0x8
	// Bit SSL.
	SERCOM_SPIM_INTENCLR_SSL = 0x8
	// Position of ERROR field.
	SERCOM_SPIM_INTENCLR_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	SERCOM_SPIM_INTENCLR_ERROR_Msk = 0x80
	// Bit ERROR.
	SERCOM_SPIM_INTENCLR_ERROR = 0x80

	// INTENSET: SPIM Interrupt Enable Set
	// Position of DRE field.
	SERCOM_SPIM_INTENSET_DRE_Pos = 0x0
	// Bit mask of DRE field.
	SERCOM_SPIM_INTENSET_DRE_Msk = 0x1
	// Bit DRE.
	SERCOM_SPIM_INTENSET_DRE = 0x1
	// Position of TXC field.
	SERCOM_SPIM_INTENSET_TXC_Pos = 0x1
	// Bit mask of TXC field.
	SERCOM_SPIM_INTENSET_TXC_Msk = 0x2
	// Bit TXC.
	SERCOM_SPIM_INTENSET_TXC = 0x2
	// Position of RXC field.
	SERCOM_SPIM_INTENSET_RXC_Pos = 0x2
	// Bit mask of RXC field.
	SERCOM_SPIM_INTENSET_RXC_Msk = 0x4
	// Bit RXC.
	SERCOM_SPIM_INTENSET_RXC = 0x4
	// Position of SSL field.
	SERCOM_SPIM_INTENSET_SSL_Pos = 0x3
	// Bit mask of SSL field.
	SERCOM_SPIM_INTENSET_SSL_Msk = 0x8
	// Bit SSL.
	SERCOM_SPIM_INTENSET_SSL = 0x8
	// Position of ERROR field.
	SERCOM_SPIM_INTENSET_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	SERCOM_SPIM_INTENSET_ERROR_Msk = 0x80
	// Bit ERROR.
	SERCOM_SPIM_INTENSET_ERROR = 0x80

	// INTFLAG: SPIM Interrupt Flag Status and Clear
	// Position of DRE field.
	SERCOM_SPIM_INTFLAG_DRE_Pos = 0x0
	// Bit mask of DRE field.
	SERCOM_SPIM_INTFLAG_DRE_Msk = 0x1
	// Bit DRE.
	SERCOM_SPIM_INTFLAG_DRE = 0x1
	// Position of TXC field.
	SERCOM_SPIM_INTFLAG_TXC_Pos = 0x1
	// Bit mask of TXC field.
	SERCOM_SPIM_INTFLAG_TXC_Msk = 0x2
	// Bit TXC.
	SERCOM_SPIM_INTFLAG_TXC = 0x2
	// Position of RXC field.
	SERCOM_SPIM_INTFLAG_RXC_Pos = 0x2
	// Bit mask of RXC field.
	SERCOM_SPIM_INTFLAG_RXC_Msk = 0x4
	// Bit RXC.
	SERCOM_SPIM_INTFLAG_RXC = 0x4
	// Position of SSL field.
	SERCOM_SPIM_INTFLAG_SSL_Pos = 0x3
	// Bit mask of SSL field.
	SERCOM_SPIM_INTFLAG_SSL_Msk = 0x8
	// Bit SSL.
	SERCOM_SPIM_INTFLAG_SSL = 0x8
	// Position of ERROR field.
	SERCOM_SPIM_INTFLAG_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	SERCOM_SPIM_INTFLAG_ERROR_Msk = 0x80
	// Bit ERROR.
	SERCOM_SPIM_INTFLAG_ERROR = 0x80

	// STATUS: SPIM Status
	// Position of BUFOVF field.
	SERCOM_SPIM_STATUS_BUFOVF_Pos = 0x2
	// Bit mask of BUFOVF field.
	SERCOM_SPIM_STATUS_BUFOVF_Msk = 0x4
	// Bit BUFOVF.
	SERCOM_SPIM_STATUS_BUFOVF = 0x4
	// Position of LENERR field.
	SERCOM_SPIM_STATUS_LENERR_Pos = 0xb
	// Bit mask of LENERR field.
	SERCOM_SPIM_STATUS_LENERR_Msk = 0x800
	// Bit LENERR.
	SERCOM_SPIM_STATUS_LENERR = 0x800

	// SYNCBUSY: SPIM Synchronization Busy
	// Position of SWRST field.
	SERCOM_SPIM_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	SERCOM_SPIM_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	SERCOM_SPIM_SYNCBUSY_SWRST = 0x1
	// Position of ENABLE field.
	SERCOM_SPIM_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	SERCOM_SPIM_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	SERCOM_SPIM_SYNCBUSY_ENABLE = 0x2
	// Position of CTRLB field.
	SERCOM_SPIM_SYNCBUSY_CTRLB_Pos = 0x2
	// Bit mask of CTRLB field.
	SERCOM_SPIM_SYNCBUSY_CTRLB_Msk = 0x4
	// Bit CTRLB.
	SERCOM_SPIM_SYNCBUSY_CTRLB = 0x4
	// Position of LENGTH field.
	SERCOM_SPIM_SYNCBUSY_LENGTH_Pos = 0x4
	// Bit mask of LENGTH field.
	SERCOM_SPIM_SYNCBUSY_LENGTH_Msk = 0x10
	// Bit LENGTH.
	SERCOM_SPIM_SYNCBUSY_LENGTH = 0x10

	// LENGTH: SPIM Length
	// Position of LEN field.
	SERCOM_SPIM_LENGTH_LEN_Pos = 0x0
	// Bit mask of LEN field.
	SERCOM_SPIM_LENGTH_LEN_Msk = 0xff
	// Position of LENEN field.
	SERCOM_SPIM_LENGTH_LENEN_Pos = 0x8
	// Bit mask of LENEN field.
	SERCOM_SPIM_LENGTH_LENEN_Msk = 0x100
	// Bit LENEN.
	SERCOM_SPIM_LENGTH_LENEN = 0x100

	// ADDR: SPIM Address
	// Position of ADDR field.
	SERCOM_SPIM_ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	SERCOM_SPIM_ADDR_ADDR_Msk = 0xff
	// Position of ADDRMASK field.
	SERCOM_SPIM_ADDR_ADDRMASK_Pos = 0x10
	// Bit mask of ADDRMASK field.
	SERCOM_SPIM_ADDR_ADDRMASK_Msk = 0xff0000

	// DATA: SPIM Data
	// Position of DATA field.
	SERCOM_SPIM_DATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	SERCOM_SPIM_DATA_DATA_Msk = 0xffffffff

	// DBGCTRL: SPIM Debug Control
	// Position of DBGSTOP field.
	SERCOM_SPIM_DBGCTRL_DBGSTOP_Pos = 0x0
	// Bit mask of DBGSTOP field.
	SERCOM_SPIM_DBGCTRL_DBGSTOP_Msk = 0x1
	// Bit DBGSTOP.
	SERCOM_SPIM_DBGCTRL_DBGSTOP = 0x1
)

// Constants for SERCOM0_USART_EXT: Serial Communication Interface - USART_EXT
const (
	// CTRLA: USART_EXT Control A
	// Position of SWRST field.
	SERCOM_USART_EXT_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	SERCOM_USART_EXT_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	SERCOM_USART_EXT_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	SERCOM_USART_EXT_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	SERCOM_USART_EXT_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	SERCOM_USART_EXT_CTRLA_ENABLE = 0x2
	// Position of MODE field.
	SERCOM_USART_EXT_CTRLA_MODE_Pos = 0x2
	// Bit mask of MODE field.
	SERCOM_USART_EXT_CTRLA_MODE_Msk = 0x1c
	// USART with external clock
	SERCOM_USART_EXT_CTRLA_MODE_USART_EXT_CLK = 0x0
	// USART with internal clock
	SERCOM_USART_EXT_CTRLA_MODE_USART_INT_CLK = 0x1
	// SPI in slave operation
	SERCOM_USART_EXT_CTRLA_MODE_SPI_SLAVE = 0x2
	// SPI in master operation
	SERCOM_USART_EXT_CTRLA_MODE_SPI_MASTER = 0x3
	// I2C slave operation
	SERCOM_USART_EXT_CTRLA_MODE_I2C_SLAVE = 0x4
	// I2C master operation
	SERCOM_USART_EXT_CTRLA_MODE_I2C_MASTER = 0x5
	// Position of RUNSTDBY field.
	SERCOM_USART_EXT_CTRLA_RUNSTDBY_Pos = 0x7
	// Bit mask of RUNSTDBY field.
	SERCOM_USART_EXT_CTRLA_RUNSTDBY_Msk = 0x80
	// Bit RUNSTDBY.
	SERCOM_USART_EXT_CTRLA_RUNSTDBY = 0x80
	// Position of IBON field.
	SERCOM_USART_EXT_CTRLA_IBON_Pos = 0x8
	// Bit mask of IBON field.
	SERCOM_USART_EXT_CTRLA_IBON_Msk = 0x100
	// Bit IBON.
	SERCOM_USART_EXT_CTRLA_IBON = 0x100
	// Position of TXINV field.
	SERCOM_USART_EXT_CTRLA_TXINV_Pos = 0x9
	// Bit mask of TXINV field.
	SERCOM_USART_EXT_CTRLA_TXINV_Msk = 0x200
	// Bit TXINV.
	SERCOM_USART_EXT_CTRLA_TXINV = 0x200
	// Position of RXINV field.
	SERCOM_USART_EXT_CTRLA_RXINV_Pos = 0xa
	// Bit mask of RXINV field.
	SERCOM_USART_EXT_CTRLA_RXINV_Msk = 0x400
	// Bit RXINV.
	SERCOM_USART_EXT_CTRLA_RXINV = 0x400
	// Position of SAMPR field.
	SERCOM_USART_EXT_CTRLA_SAMPR_Pos = 0xd
	// Bit mask of SAMPR field.
	SERCOM_USART_EXT_CTRLA_SAMPR_Msk = 0xe000
	// 16x over-sampling using arithmetic baudrate generation
	SERCOM_USART_EXT_CTRLA_SAMPR_16X_ARITHMETIC = 0x0
	// 16x over-sampling using fractional baudrate generation
	SERCOM_USART_EXT_CTRLA_SAMPR_16X_FRACTIONAL = 0x1
	// 8x over-sampling using arithmetic baudrate generation
	SERCOM_USART_EXT_CTRLA_SAMPR_8X_ARITHMETIC = 0x2
	// 8x over-sampling using fractional baudrate generation
	SERCOM_USART_EXT_CTRLA_SAMPR_8X_FRACTIONAL = 0x3
	// 3x over-sampling using arithmetic baudrate generation
	SERCOM_USART_EXT_CTRLA_SAMPR_3X_ARITHMETIC = 0x4
	// Position of TXPO field.
	SERCOM_USART_EXT_CTRLA_TXPO_Pos = 0x10
	// Bit mask of TXPO field.
	SERCOM_USART_EXT_CTRLA_TXPO_Msk = 0x30000
	// SERCOM PAD[0] is used for data transmission
	SERCOM_USART_EXT_CTRLA_TXPO_PAD0 = 0x0
	// SERCOM_PAD[0] is used for data transmission
	SERCOM_USART_EXT_CTRLA_TXPO_PAD3 = 0x3
	// Position of RXPO field.
	SERCOM_USART_EXT_CTRLA_RXPO_Pos = 0x14
	// Bit mask of RXPO field.
	SERCOM_USART_EXT_CTRLA_RXPO_Msk = 0x300000
	// SERCOM PAD[0] is used for data reception
	SERCOM_USART_EXT_CTRLA_RXPO_PAD0 = 0x0
	// SERCOM PAD[1] is used for data reception
	SERCOM_USART_EXT_CTRLA_RXPO_PAD1 = 0x1
	// SERCOM PAD[2] is used for data reception
	SERCOM_USART_EXT_CTRLA_RXPO_PAD2 = 0x2
	// SERCOM PAD[3] is used for data reception
	SERCOM_USART_EXT_CTRLA_RXPO_PAD3 = 0x3
	// Position of SAMPA field.
	SERCOM_USART_EXT_CTRLA_SAMPA_Pos = 0x16
	// Bit mask of SAMPA field.
	SERCOM_USART_EXT_CTRLA_SAMPA_Msk = 0xc00000
	// Position of FORM field.
	SERCOM_USART_EXT_CTRLA_FORM_Pos = 0x18
	// Bit mask of FORM field.
	SERCOM_USART_EXT_CTRLA_FORM_Msk = 0xf000000
	// USART frame
	SERCOM_USART_EXT_CTRLA_FORM_USART_FRAME_NO_PARITY = 0x0
	// USART frame with parity
	SERCOM_USART_EXT_CTRLA_FORM_USART_FRAME_WITH_PARITY = 0x1
	// LIN Master - Break and sync generation
	SERCOM_USART_EXT_CTRLA_FORM_USART_FRAME_LIN_MASTER_MODE = 0x2
	// Auto-baud - break detection and auto-baud
	SERCOM_USART_EXT_CTRLA_FORM_USART_FRAME_AUTO_BAUD_NO_PARITY = 0x4
	// Auto-baud - break detection and auto-baud with parity
	SERCOM_USART_EXT_CTRLA_FORM_USART_FRAME_AUTO_BAUD_WITH_PARITY = 0x5
	// ISO 7816
	SERCOM_USART_EXT_CTRLA_FORM_USART_FRAME_ISO_7816 = 0x7
	// Position of CMODE field.
	SERCOM_USART_EXT_CTRLA_CMODE_Pos = 0x1c
	// Bit mask of CMODE field.
	SERCOM_USART_EXT_CTRLA_CMODE_Msk = 0x10000000
	// Bit CMODE.
	SERCOM_USART_EXT_CTRLA_CMODE = 0x10000000
	// Asynchronous Communication
	SERCOM_USART_EXT_CTRLA_CMODE_ASYNC = 0x0
	// Synchronous Communication
	SERCOM_USART_EXT_CTRLA_CMODE_SYNC = 0x1
	// Position of CPOL field.
	SERCOM_USART_EXT_CTRLA_CPOL_Pos = 0x1d
	// Bit mask of CPOL field.
	SERCOM_USART_EXT_CTRLA_CPOL_Msk = 0x20000000
	// Bit CPOL.
	SERCOM_USART_EXT_CTRLA_CPOL = 0x20000000
	// TxD Change:- Rising XCK edge, RxD Sample:- Falling XCK edge
	SERCOM_USART_EXT_CTRLA_CPOL_IDLE_LOW = 0x0
	// TxD Change:- Falling XCK edge, RxD Sample:- Rising XCK edge
	SERCOM_USART_EXT_CTRLA_CPOL_IDLE_HIGH = 0x1
	// Position of DORD field.
	SERCOM_USART_EXT_CTRLA_DORD_Pos = 0x1e
	// Bit mask of DORD field.
	SERCOM_USART_EXT_CTRLA_DORD_Msk = 0x40000000
	// Bit DORD.
	SERCOM_USART_EXT_CTRLA_DORD = 0x40000000
	// MSB is transmitted first
	SERCOM_USART_EXT_CTRLA_DORD_MSB = 0x0
	// LSB is transmitted first
	SERCOM_USART_EXT_CTRLA_DORD_LSB = 0x1

	// CTRLB: USART_EXT Control B
	// Position of CHSIZE field.
	SERCOM_USART_EXT_CTRLB_CHSIZE_Pos = 0x0
	// Bit mask of CHSIZE field.
	SERCOM_USART_EXT_CTRLB_CHSIZE_Msk = 0x7
	// 8 Bits
	SERCOM_USART_EXT_CTRLB_CHSIZE_8_BIT = 0x0
	// 9 Bits
	SERCOM_USART_EXT_CTRLB_CHSIZE_9_BIT = 0x1
	// 5 Bits
	SERCOM_USART_EXT_CTRLB_CHSIZE_5_BIT = 0x5
	// 6 Bits
	SERCOM_USART_EXT_CTRLB_CHSIZE_6_BIT = 0x6
	// 7 Bits
	SERCOM_USART_EXT_CTRLB_CHSIZE_7_BIT = 0x7
	// Position of SBMODE field.
	SERCOM_USART_EXT_CTRLB_SBMODE_Pos = 0x6
	// Bit mask of SBMODE field.
	SERCOM_USART_EXT_CTRLB_SBMODE_Msk = 0x40
	// Bit SBMODE.
	SERCOM_USART_EXT_CTRLB_SBMODE = 0x40
	// One Stop Bit
	SERCOM_USART_EXT_CTRLB_SBMODE_1_BIT = 0x0
	// Two Stop Bits
	SERCOM_USART_EXT_CTRLB_SBMODE_2_BIT = 0x1
	// Position of COLDEN field.
	SERCOM_USART_EXT_CTRLB_COLDEN_Pos = 0x8
	// Bit mask of COLDEN field.
	SERCOM_USART_EXT_CTRLB_COLDEN_Msk = 0x100
	// Bit COLDEN.
	SERCOM_USART_EXT_CTRLB_COLDEN = 0x100
	// Position of SFDE field.
	SERCOM_USART_EXT_CTRLB_SFDE_Pos = 0x9
	// Bit mask of SFDE field.
	SERCOM_USART_EXT_CTRLB_SFDE_Msk = 0x200
	// Bit SFDE.
	SERCOM_USART_EXT_CTRLB_SFDE = 0x200
	// Position of ENC field.
	SERCOM_USART_EXT_CTRLB_ENC_Pos = 0xa
	// Bit mask of ENC field.
	SERCOM_USART_EXT_CTRLB_ENC_Msk = 0x400
	// Bit ENC.
	SERCOM_USART_EXT_CTRLB_ENC = 0x400
	// Position of PMODE field.
	SERCOM_USART_EXT_CTRLB_PMODE_Pos = 0xd
	// Bit mask of PMODE field.
	SERCOM_USART_EXT_CTRLB_PMODE_Msk = 0x2000
	// Bit PMODE.
	SERCOM_USART_EXT_CTRLB_PMODE = 0x2000
	// Even Parity
	SERCOM_USART_EXT_CTRLB_PMODE_EVEN = 0x0
	// Odd Parity
	SERCOM_USART_EXT_CTRLB_PMODE_ODD = 0x1
	// Position of TXEN field.
	SERCOM_USART_EXT_CTRLB_TXEN_Pos = 0x10
	// Bit mask of TXEN field.
	SERCOM_USART_EXT_CTRLB_TXEN_Msk = 0x10000
	// Bit TXEN.
	SERCOM_USART_EXT_CTRLB_TXEN = 0x10000
	// Position of RXEN field.
	SERCOM_USART_EXT_CTRLB_RXEN_Pos = 0x11
	// Bit mask of RXEN field.
	SERCOM_USART_EXT_CTRLB_RXEN_Msk = 0x20000
	// Bit RXEN.
	SERCOM_USART_EXT_CTRLB_RXEN = 0x20000
	// Position of LINCMD field.
	SERCOM_USART_EXT_CTRLB_LINCMD_Pos = 0x18
	// Bit mask of LINCMD field.
	SERCOM_USART_EXT_CTRLB_LINCMD_Msk = 0x3000000

	// CTRLC: USART_EXT Control C
	// Position of GTIME field.
	SERCOM_USART_EXT_CTRLC_GTIME_Pos = 0x0
	// Bit mask of GTIME field.
	SERCOM_USART_EXT_CTRLC_GTIME_Msk = 0x7
	// Position of BRKLEN field.
	SERCOM_USART_EXT_CTRLC_BRKLEN_Pos = 0x8
	// Bit mask of BRKLEN field.
	SERCOM_USART_EXT_CTRLC_BRKLEN_Msk = 0x300
	// Position of HDRDLY field.
	SERCOM_USART_EXT_CTRLC_HDRDLY_Pos = 0xa
	// Bit mask of HDRDLY field.
	SERCOM_USART_EXT_CTRLC_HDRDLY_Msk = 0xc00
	// Position of INACK field.
	SERCOM_USART_EXT_CTRLC_INACK_Pos = 0x10
	// Bit mask of INACK field.
	SERCOM_USART_EXT_CTRLC_INACK_Msk = 0x10000
	// Bit INACK.
	SERCOM_USART_EXT_CTRLC_INACK = 0x10000
	// Position of DSNACK field.
	SERCOM_USART_EXT_CTRLC_DSNACK_Pos = 0x11
	// Bit mask of DSNACK field.
	SERCOM_USART_EXT_CTRLC_DSNACK_Msk = 0x20000
	// Bit DSNACK.
	SERCOM_USART_EXT_CTRLC_DSNACK = 0x20000
	// Position of MAXITER field.
	SERCOM_USART_EXT_CTRLC_MAXITER_Pos = 0x14
	// Bit mask of MAXITER field.
	SERCOM_USART_EXT_CTRLC_MAXITER_Msk = 0x700000
	// Position of DATA32B field.
	SERCOM_USART_EXT_CTRLC_DATA32B_Pos = 0x18
	// Bit mask of DATA32B field.
	SERCOM_USART_EXT_CTRLC_DATA32B_Msk = 0x3000000
	// Data reads and writes according CTRLB.CHSIZE
	SERCOM_USART_EXT_CTRLC_DATA32B_DATA_READ_WRITE_CHSIZE = 0x0
	// Data reads according CTRLB.CHSIZE and writes according 32-bit extension
	SERCOM_USART_EXT_CTRLC_DATA32B_DATA_READ_CHSIZE_WRITE_32BIT = 0x1
	// Data reads according 32-bit extension and writes according CTRLB.CHSIZE
	SERCOM_USART_EXT_CTRLC_DATA32B_DATA_READ_32BIT_WRITE_CHSIZE = 0x2
	// Data reads and writes according 32-bit extension
	SERCOM_USART_EXT_CTRLC_DATA32B_DATA_READ_WRITE_32BIT = 0x3

	// BAUD: USART_EXT Baud Rate
	// Position of BAUD field.
	SERCOM_USART_EXT_BAUD_BAUD_Pos = 0x0
	// Bit mask of BAUD field.
	SERCOM_USART_EXT_BAUD_BAUD_Msk = 0xffff

	// BAUD_FRAC_MODE: USART_EXT Baud Rate
	// Position of BAUD field.
	SERCOM_USART_EXT_BAUD_FRAC_MODE_BAUD_Pos = 0x0
	// Bit mask of BAUD field.
	SERCOM_USART_EXT_BAUD_FRAC_MODE_BAUD_Msk = 0x1fff
	// Position of FP field.
	SERCOM_USART_EXT_BAUD_FRAC_MODE_FP_Pos = 0xd
	// Bit mask of FP field.
	SERCOM_USART_EXT_BAUD_FRAC_MODE_FP_Msk = 0xe000

	// BAUD_FRACFP_MODE: USART_EXT Baud Rate
	// Position of BAUD field.
	SERCOM_USART_EXT_BAUD_FRACFP_MODE_BAUD_Pos = 0x0
	// Bit mask of BAUD field.
	SERCOM_USART_EXT_BAUD_FRACFP_MODE_BAUD_Msk = 0x1fff
	// Position of FP field.
	SERCOM_USART_EXT_BAUD_FRACFP_MODE_FP_Pos = 0xd
	// Bit mask of FP field.
	SERCOM_USART_EXT_BAUD_FRACFP_MODE_FP_Msk = 0xe000

	// BAUD_USARTFP_MODE: USART_EXT Baud Rate
	// Position of BAUD field.
	SERCOM_USART_EXT_BAUD_USARTFP_MODE_BAUD_Pos = 0x0
	// Bit mask of BAUD field.
	SERCOM_USART_EXT_BAUD_USARTFP_MODE_BAUD_Msk = 0xffff

	// RXPL: USART_EXT Receive Pulse Length
	// Position of RXPL field.
	SERCOM_USART_EXT_RXPL_RXPL_Pos = 0x0
	// Bit mask of RXPL field.
	SERCOM_USART_EXT_RXPL_RXPL_Msk = 0xff

	// INTENCLR: USART_EXT Interrupt Enable Clear
	// Position of DRE field.
	SERCOM_USART_EXT_INTENCLR_DRE_Pos = 0x0
	// Bit mask of DRE field.
	SERCOM_USART_EXT_INTENCLR_DRE_Msk = 0x1
	// Bit DRE.
	SERCOM_USART_EXT_INTENCLR_DRE = 0x1
	// Position of TXC field.
	SERCOM_USART_EXT_INTENCLR_TXC_Pos = 0x1
	// Bit mask of TXC field.
	SERCOM_USART_EXT_INTENCLR_TXC_Msk = 0x2
	// Bit TXC.
	SERCOM_USART_EXT_INTENCLR_TXC = 0x2
	// Position of RXC field.
	SERCOM_USART_EXT_INTENCLR_RXC_Pos = 0x2
	// Bit mask of RXC field.
	SERCOM_USART_EXT_INTENCLR_RXC_Msk = 0x4
	// Bit RXC.
	SERCOM_USART_EXT_INTENCLR_RXC = 0x4
	// Position of RXS field.
	SERCOM_USART_EXT_INTENCLR_RXS_Pos = 0x3
	// Bit mask of RXS field.
	SERCOM_USART_EXT_INTENCLR_RXS_Msk = 0x8
	// Bit RXS.
	SERCOM_USART_EXT_INTENCLR_RXS = 0x8
	// Position of CTSIC field.
	SERCOM_USART_EXT_INTENCLR_CTSIC_Pos = 0x4
	// Bit mask of CTSIC field.
	SERCOM_USART_EXT_INTENCLR_CTSIC_Msk = 0x10
	// Bit CTSIC.
	SERCOM_USART_EXT_INTENCLR_CTSIC = 0x10
	// Position of RXBRK field.
	SERCOM_USART_EXT_INTENCLR_RXBRK_Pos = 0x5
	// Bit mask of RXBRK field.
	SERCOM_USART_EXT_INTENCLR_RXBRK_Msk = 0x20
	// Bit RXBRK.
	SERCOM_USART_EXT_INTENCLR_RXBRK = 0x20
	// Position of ERROR field.
	SERCOM_USART_EXT_INTENCLR_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	SERCOM_USART_EXT_INTENCLR_ERROR_Msk = 0x80
	// Bit ERROR.
	SERCOM_USART_EXT_INTENCLR_ERROR = 0x80

	// INTENSET: USART_EXT Interrupt Enable Set
	// Position of DRE field.
	SERCOM_USART_EXT_INTENSET_DRE_Pos = 0x0
	// Bit mask of DRE field.
	SERCOM_USART_EXT_INTENSET_DRE_Msk = 0x1
	// Bit DRE.
	SERCOM_USART_EXT_INTENSET_DRE = 0x1
	// Position of TXC field.
	SERCOM_USART_EXT_INTENSET_TXC_Pos = 0x1
	// Bit mask of TXC field.
	SERCOM_USART_EXT_INTENSET_TXC_Msk = 0x2
	// Bit TXC.
	SERCOM_USART_EXT_INTENSET_TXC = 0x2
	// Position of RXC field.
	SERCOM_USART_EXT_INTENSET_RXC_Pos = 0x2
	// Bit mask of RXC field.
	SERCOM_USART_EXT_INTENSET_RXC_Msk = 0x4
	// Bit RXC.
	SERCOM_USART_EXT_INTENSET_RXC = 0x4
	// Position of RXS field.
	SERCOM_USART_EXT_INTENSET_RXS_Pos = 0x3
	// Bit mask of RXS field.
	SERCOM_USART_EXT_INTENSET_RXS_Msk = 0x8
	// Bit RXS.
	SERCOM_USART_EXT_INTENSET_RXS = 0x8
	// Position of CTSIC field.
	SERCOM_USART_EXT_INTENSET_CTSIC_Pos = 0x4
	// Bit mask of CTSIC field.
	SERCOM_USART_EXT_INTENSET_CTSIC_Msk = 0x10
	// Bit CTSIC.
	SERCOM_USART_EXT_INTENSET_CTSIC = 0x10
	// Position of RXBRK field.
	SERCOM_USART_EXT_INTENSET_RXBRK_Pos = 0x5
	// Bit mask of RXBRK field.
	SERCOM_USART_EXT_INTENSET_RXBRK_Msk = 0x20
	// Bit RXBRK.
	SERCOM_USART_EXT_INTENSET_RXBRK = 0x20
	// Position of ERROR field.
	SERCOM_USART_EXT_INTENSET_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	SERCOM_USART_EXT_INTENSET_ERROR_Msk = 0x80
	// Bit ERROR.
	SERCOM_USART_EXT_INTENSET_ERROR = 0x80

	// INTFLAG: USART_EXT Interrupt Flag Status and Clear
	// Position of DRE field.
	SERCOM_USART_EXT_INTFLAG_DRE_Pos = 0x0
	// Bit mask of DRE field.
	SERCOM_USART_EXT_INTFLAG_DRE_Msk = 0x1
	// Bit DRE.
	SERCOM_USART_EXT_INTFLAG_DRE = 0x1
	// Position of TXC field.
	SERCOM_USART_EXT_INTFLAG_TXC_Pos = 0x1
	// Bit mask of TXC field.
	SERCOM_USART_EXT_INTFLAG_TXC_Msk = 0x2
	// Bit TXC.
	SERCOM_USART_EXT_INTFLAG_TXC = 0x2
	// Position of RXC field.
	SERCOM_USART_EXT_INTFLAG_RXC_Pos = 0x2
	// Bit mask of RXC field.
	SERCOM_USART_EXT_INTFLAG_RXC_Msk = 0x4
	// Bit RXC.
	SERCOM_USART_EXT_INTFLAG_RXC = 0x4
	// Position of RXS field.
	SERCOM_USART_EXT_INTFLAG_RXS_Pos = 0x3
	// Bit mask of RXS field.
	SERCOM_USART_EXT_INTFLAG_RXS_Msk = 0x8
	// Bit RXS.
	SERCOM_USART_EXT_INTFLAG_RXS = 0x8
	// Position of CTSIC field.
	SERCOM_USART_EXT_INTFLAG_CTSIC_Pos = 0x4
	// Bit mask of CTSIC field.
	SERCOM_USART_EXT_INTFLAG_CTSIC_Msk = 0x10
	// Bit CTSIC.
	SERCOM_USART_EXT_INTFLAG_CTSIC = 0x10
	// Position of RXBRK field.
	SERCOM_USART_EXT_INTFLAG_RXBRK_Pos = 0x5
	// Bit mask of RXBRK field.
	SERCOM_USART_EXT_INTFLAG_RXBRK_Msk = 0x20
	// Bit RXBRK.
	SERCOM_USART_EXT_INTFLAG_RXBRK = 0x20
	// Position of ERROR field.
	SERCOM_USART_EXT_INTFLAG_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	SERCOM_USART_EXT_INTFLAG_ERROR_Msk = 0x80
	// Bit ERROR.
	SERCOM_USART_EXT_INTFLAG_ERROR = 0x80

	// STATUS: USART_EXT Status
	// Position of PERR field.
	SERCOM_USART_EXT_STATUS_PERR_Pos = 0x0
	// Bit mask of PERR field.
	SERCOM_USART_EXT_STATUS_PERR_Msk = 0x1
	// Bit PERR.
	SERCOM_USART_EXT_STATUS_PERR = 0x1
	// Position of FERR field.
	SERCOM_USART_EXT_STATUS_FERR_Pos = 0x1
	// Bit mask of FERR field.
	SERCOM_USART_EXT_STATUS_FERR_Msk = 0x2
	// Bit FERR.
	SERCOM_USART_EXT_STATUS_FERR = 0x2
	// Position of BUFOVF field.
	SERCOM_USART_EXT_STATUS_BUFOVF_Pos = 0x2
	// Bit mask of BUFOVF field.
	SERCOM_USART_EXT_STATUS_BUFOVF_Msk = 0x4
	// Bit BUFOVF.
	SERCOM_USART_EXT_STATUS_BUFOVF = 0x4
	// Position of CTS field.
	SERCOM_USART_EXT_STATUS_CTS_Pos = 0x3
	// Bit mask of CTS field.
	SERCOM_USART_EXT_STATUS_CTS_Msk = 0x8
	// Bit CTS.
	SERCOM_USART_EXT_STATUS_CTS = 0x8
	// Position of ISF field.
	SERCOM_USART_EXT_STATUS_ISF_Pos = 0x4
	// Bit mask of ISF field.
	SERCOM_USART_EXT_STATUS_ISF_Msk = 0x10
	// Bit ISF.
	SERCOM_USART_EXT_STATUS_ISF = 0x10
	// Position of COLL field.
	SERCOM_USART_EXT_STATUS_COLL_Pos = 0x5
	// Bit mask of COLL field.
	SERCOM_USART_EXT_STATUS_COLL_Msk = 0x20
	// Bit COLL.
	SERCOM_USART_EXT_STATUS_COLL = 0x20
	// Position of TXE field.
	SERCOM_USART_EXT_STATUS_TXE_Pos = 0x6
	// Bit mask of TXE field.
	SERCOM_USART_EXT_STATUS_TXE_Msk = 0x40
	// Bit TXE.
	SERCOM_USART_EXT_STATUS_TXE = 0x40
	// Position of ITER field.
	SERCOM_USART_EXT_STATUS_ITER_Pos = 0x7
	// Bit mask of ITER field.
	SERCOM_USART_EXT_STATUS_ITER_Msk = 0x80
	// Bit ITER.
	SERCOM_USART_EXT_STATUS_ITER = 0x80

	// SYNCBUSY: USART_EXT Synchronization Busy
	// Position of SWRST field.
	SERCOM_USART_EXT_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	SERCOM_USART_EXT_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	SERCOM_USART_EXT_SYNCBUSY_SWRST = 0x1
	// Position of ENABLE field.
	SERCOM_USART_EXT_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	SERCOM_USART_EXT_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	SERCOM_USART_EXT_SYNCBUSY_ENABLE = 0x2
	// Position of CTRLB field.
	SERCOM_USART_EXT_SYNCBUSY_CTRLB_Pos = 0x2
	// Bit mask of CTRLB field.
	SERCOM_USART_EXT_SYNCBUSY_CTRLB_Msk = 0x4
	// Bit CTRLB.
	SERCOM_USART_EXT_SYNCBUSY_CTRLB = 0x4
	// Position of RXERRCNT field.
	SERCOM_USART_EXT_SYNCBUSY_RXERRCNT_Pos = 0x3
	// Bit mask of RXERRCNT field.
	SERCOM_USART_EXT_SYNCBUSY_RXERRCNT_Msk = 0x8
	// Bit RXERRCNT.
	SERCOM_USART_EXT_SYNCBUSY_RXERRCNT = 0x8
	// Position of LENGTH field.
	SERCOM_USART_EXT_SYNCBUSY_LENGTH_Pos = 0x4
	// Bit mask of LENGTH field.
	SERCOM_USART_EXT_SYNCBUSY_LENGTH_Msk = 0x10
	// Bit LENGTH.
	SERCOM_USART_EXT_SYNCBUSY_LENGTH = 0x10

	// LENGTH: USART_EXT Length
	// Position of LEN field.
	SERCOM_USART_EXT_LENGTH_LEN_Pos = 0x0
	// Bit mask of LEN field.
	SERCOM_USART_EXT_LENGTH_LEN_Msk = 0xff
	// Position of LENEN field.
	SERCOM_USART_EXT_LENGTH_LENEN_Pos = 0x8
	// Bit mask of LENEN field.
	SERCOM_USART_EXT_LENGTH_LENEN_Msk = 0x300

	// DATA: USART_EXT Data
	// Position of DATA field.
	SERCOM_USART_EXT_DATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	SERCOM_USART_EXT_DATA_DATA_Msk = 0xffffffff

	// DBGCTRL: USART_EXT Debug Control
	// Position of DBGSTOP field.
	SERCOM_USART_EXT_DBGCTRL_DBGSTOP_Pos = 0x0
	// Bit mask of DBGSTOP field.
	SERCOM_USART_EXT_DBGCTRL_DBGSTOP_Msk = 0x1
	// Bit DBGSTOP.
	SERCOM_USART_EXT_DBGCTRL_DBGSTOP = 0x1
)

// Constants for SERCOM0_USART_INT: Serial Communication Interface - USART_INT
const (
	// CTRLA: USART_INT Control A
	// Position of SWRST field.
	SERCOM_USART_INT_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	SERCOM_USART_INT_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	SERCOM_USART_INT_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	SERCOM_USART_INT_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	SERCOM_USART_INT_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	SERCOM_USART_INT_CTRLA_ENABLE = 0x2
	// Position of MODE field.
	SERCOM_USART_INT_CTRLA_MODE_Pos = 0x2
	// Bit mask of MODE field.
	SERCOM_USART_INT_CTRLA_MODE_Msk = 0x1c
	// USART with external clock
	SERCOM_USART_INT_CTRLA_MODE_USART_EXT_CLK = 0x0
	// USART with internal clock
	SERCOM_USART_INT_CTRLA_MODE_USART_INT_CLK = 0x1
	// SPI in slave operation
	SERCOM_USART_INT_CTRLA_MODE_SPI_SLAVE = 0x2
	// SPI in master operation
	SERCOM_USART_INT_CTRLA_MODE_SPI_MASTER = 0x3
	// I2C slave operation
	SERCOM_USART_INT_CTRLA_MODE_I2C_SLAVE = 0x4
	// I2C master operation
	SERCOM_USART_INT_CTRLA_MODE_I2C_MASTER = 0x5
	// Position of RUNSTDBY field.
	SERCOM_USART_INT_CTRLA_RUNSTDBY_Pos = 0x7
	// Bit mask of RUNSTDBY field.
	SERCOM_USART_INT_CTRLA_RUNSTDBY_Msk = 0x80
	// Bit RUNSTDBY.
	SERCOM_USART_INT_CTRLA_RUNSTDBY = 0x80
	// Position of IBON field.
	SERCOM_USART_INT_CTRLA_IBON_Pos = 0x8
	// Bit mask of IBON field.
	SERCOM_USART_INT_CTRLA_IBON_Msk = 0x100
	// Bit IBON.
	SERCOM_USART_INT_CTRLA_IBON = 0x100
	// Position of TXINV field.
	SERCOM_USART_INT_CTRLA_TXINV_Pos = 0x9
	// Bit mask of TXINV field.
	SERCOM_USART_INT_CTRLA_TXINV_Msk = 0x200
	// Bit TXINV.
	SERCOM_USART_INT_CTRLA_TXINV = 0x200
	// Position of RXINV field.
	SERCOM_USART_INT_CTRLA_RXINV_Pos = 0xa
	// Bit mask of RXINV field.
	SERCOM_USART_INT_CTRLA_RXINV_Msk = 0x400
	// Bit RXINV.
	SERCOM_USART_INT_CTRLA_RXINV = 0x400
	// Position of SAMPR field.
	SERCOM_USART_INT_CTRLA_SAMPR_Pos = 0xd
	// Bit mask of SAMPR field.
	SERCOM_USART_INT_CTRLA_SAMPR_Msk = 0xe000
	// 16x over-sampling using arithmetic baudrate generation
	SERCOM_USART_INT_CTRLA_SAMPR_16X_ARITHMETIC = 0x0
	// 16x over-sampling using fractional baudrate generation
	SERCOM_USART_INT_CTRLA_SAMPR_16X_FRACTIONAL = 0x1
	// 8x over-sampling using arithmetic baudrate generation
	SERCOM_USART_INT_CTRLA_SAMPR_8X_ARITHMETIC = 0x2
	// 8x over-sampling using fractional baudrate generation
	SERCOM_USART_INT_CTRLA_SAMPR_8X_FRACTIONAL = 0x3
	// 3x over-sampling using arithmetic baudrate generation
	SERCOM_USART_INT_CTRLA_SAMPR_3X_ARITHMETIC = 0x4
	// Position of TXPO field.
	SERCOM_USART_INT_CTRLA_TXPO_Pos = 0x10
	// Bit mask of TXPO field.
	SERCOM_USART_INT_CTRLA_TXPO_Msk = 0x30000
	// SERCOM PAD[0] is used for data transmission
	SERCOM_USART_INT_CTRLA_TXPO_PAD0 = 0x0
	// SERCOM_PAD[0] is used for data transmission
	SERCOM_USART_INT_CTRLA_TXPO_PAD3 = 0x3
	// Position of RXPO field.
	SERCOM_USART_INT_CTRLA_RXPO_Pos = 0x14
	// Bit mask of RXPO field.
	SERCOM_USART_INT_CTRLA_RXPO_Msk = 0x300000
	// SERCOM PAD[0] is used for data reception
	SERCOM_USART_INT_CTRLA_RXPO_PAD0 = 0x0
	// SERCOM PAD[1] is used for data reception
	SERCOM_USART_INT_CTRLA_RXPO_PAD1 = 0x1
	// SERCOM PAD[2] is used for data reception
	SERCOM_USART_INT_CTRLA_RXPO_PAD2 = 0x2
	// SERCOM PAD[3] is used for data reception
	SERCOM_USART_INT_CTRLA_RXPO_PAD3 = 0x3
	// Position of SAMPA field.
	SERCOM_USART_INT_CTRLA_SAMPA_Pos = 0x16
	// Bit mask of SAMPA field.
	SERCOM_USART_INT_CTRLA_SAMPA_Msk = 0xc00000
	// Position of FORM field.
	SERCOM_USART_INT_CTRLA_FORM_Pos = 0x18
	// Bit mask of FORM field.
	SERCOM_USART_INT_CTRLA_FORM_Msk = 0xf000000
	// USART frame
	SERCOM_USART_INT_CTRLA_FORM_USART_FRAME_NO_PARITY = 0x0
	// USART frame with parity
	SERCOM_USART_INT_CTRLA_FORM_USART_FRAME_WITH_PARITY = 0x1
	// LIN Master - Break and sync generation
	SERCOM_USART_INT_CTRLA_FORM_USART_FRAME_LIN_MASTER_MODE = 0x2
	// Auto-baud - break detection and auto-baud
	SERCOM_USART_INT_CTRLA_FORM_USART_FRAME_AUTO_BAUD_NO_PARITY = 0x4
	// Auto-baud - break detection and auto-baud with parity
	SERCOM_USART_INT_CTRLA_FORM_USART_FRAME_AUTO_BAUD_WITH_PARITY = 0x5
	// ISO 7816
	SERCOM_USART_INT_CTRLA_FORM_USART_FRAME_ISO_7816 = 0x7
	// Position of CMODE field.
	SERCOM_USART_INT_CTRLA_CMODE_Pos = 0x1c
	// Bit mask of CMODE field.
	SERCOM_USART_INT_CTRLA_CMODE_Msk = 0x10000000
	// Bit CMODE.
	SERCOM_USART_INT_CTRLA_CMODE = 0x10000000
	// Asynchronous Communication
	SERCOM_USART_INT_CTRLA_CMODE_ASYNC = 0x0
	// Synchronous Communication
	SERCOM_USART_INT_CTRLA_CMODE_SYNC = 0x1
	// Position of CPOL field.
	SERCOM_USART_INT_CTRLA_CPOL_Pos = 0x1d
	// Bit mask of CPOL field.
	SERCOM_USART_INT_CTRLA_CPOL_Msk = 0x20000000
	// Bit CPOL.
	SERCOM_USART_INT_CTRLA_CPOL = 0x20000000
	// TxD Change:- Rising XCK edge, RxD Sample:- Falling XCK edge
	SERCOM_USART_INT_CTRLA_CPOL_IDLE_LOW = 0x0
	// TxD Change:- Falling XCK edge, RxD Sample:- Rising XCK edge
	SERCOM_USART_INT_CTRLA_CPOL_IDLE_HIGH = 0x1
	// Position of DORD field.
	SERCOM_USART_INT_CTRLA_DORD_Pos = 0x1e
	// Bit mask of DORD field.
	SERCOM_USART_INT_CTRLA_DORD_Msk = 0x40000000
	// Bit DORD.
	SERCOM_USART_INT_CTRLA_DORD = 0x40000000
	// MSB is transmitted first
	SERCOM_USART_INT_CTRLA_DORD_MSB = 0x0
	// LSB is transmitted first
	SERCOM_USART_INT_CTRLA_DORD_LSB = 0x1

	// CTRLB: USART_INT Control B
	// Position of CHSIZE field.
	SERCOM_USART_INT_CTRLB_CHSIZE_Pos = 0x0
	// Bit mask of CHSIZE field.
	SERCOM_USART_INT_CTRLB_CHSIZE_Msk = 0x7
	// 8 Bits
	SERCOM_USART_INT_CTRLB_CHSIZE_8_BIT = 0x0
	// 9 Bits
	SERCOM_USART_INT_CTRLB_CHSIZE_9_BIT = 0x1
	// 5 Bits
	SERCOM_USART_INT_CTRLB_CHSIZE_5_BIT = 0x5
	// 6 Bits
	SERCOM_USART_INT_CTRLB_CHSIZE_6_BIT = 0x6
	// 7 Bits
	SERCOM_USART_INT_CTRLB_CHSIZE_7_BIT = 0x7
	// Position of SBMODE field.
	SERCOM_USART_INT_CTRLB_SBMODE_Pos = 0x6
	// Bit mask of SBMODE field.
	SERCOM_USART_INT_CTRLB_SBMODE_Msk = 0x40
	// Bit SBMODE.
	SERCOM_USART_INT_CTRLB_SBMODE = 0x40
	// One Stop Bit
	SERCOM_USART_INT_CTRLB_SBMODE_1_BIT = 0x0
	// Two Stop Bits
	SERCOM_USART_INT_CTRLB_SBMODE_2_BIT = 0x1
	// Position of COLDEN field.
	SERCOM_USART_INT_CTRLB_COLDEN_Pos = 0x8
	// Bit mask of COLDEN field.
	SERCOM_USART_INT_CTRLB_COLDEN_Msk = 0x100
	// Bit COLDEN.
	SERCOM_USART_INT_CTRLB_COLDEN = 0x100
	// Position of SFDE field.
	SERCOM_USART_INT_CTRLB_SFDE_Pos = 0x9
	// Bit mask of SFDE field.
	SERCOM_USART_INT_CTRLB_SFDE_Msk = 0x200
	// Bit SFDE.
	SERCOM_USART_INT_CTRLB_SFDE = 0x200
	// Position of ENC field.
	SERCOM_USART_INT_CTRLB_ENC_Pos = 0xa
	// Bit mask of ENC field.
	SERCOM_USART_INT_CTRLB_ENC_Msk = 0x400
	// Bit ENC.
	SERCOM_USART_INT_CTRLB_ENC = 0x400
	// Position of PMODE field.
	SERCOM_USART_INT_CTRLB_PMODE_Pos = 0xd
	// Bit mask of PMODE field.
	SERCOM_USART_INT_CTRLB_PMODE_Msk = 0x2000
	// Bit PMODE.
	SERCOM_USART_INT_CTRLB_PMODE = 0x2000
	// Even Parity
	SERCOM_USART_INT_CTRLB_PMODE_EVEN = 0x0
	// Odd Parity
	SERCOM_USART_INT_CTRLB_PMODE_ODD = 0x1
	// Position of TXEN field.
	SERCOM_USART_INT_CTRLB_TXEN_Pos = 0x10
	// Bit mask of TXEN field.
	SERCOM_USART_INT_CTRLB_TXEN_Msk = 0x10000
	// Bit TXEN.
	SERCOM_USART_INT_CTRLB_TXEN = 0x10000
	// Position of RXEN field.
	SERCOM_USART_INT_CTRLB_RXEN_Pos = 0x11
	// Bit mask of RXEN field.
	SERCOM_USART_INT_CTRLB_RXEN_Msk = 0x20000
	// Bit RXEN.
	SERCOM_USART_INT_CTRLB_RXEN = 0x20000
	// Position of LINCMD field.
	SERCOM_USART_INT_CTRLB_LINCMD_Pos = 0x18
	// Bit mask of LINCMD field.
	SERCOM_USART_INT_CTRLB_LINCMD_Msk = 0x3000000

	// CTRLC: USART_INT Control C
	// Position of GTIME field.
	SERCOM_USART_INT_CTRLC_GTIME_Pos = 0x0
	// Bit mask of GTIME field.
	SERCOM_USART_INT_CTRLC_GTIME_Msk = 0x7
	// Position of BRKLEN field.
	SERCOM_USART_INT_CTRLC_BRKLEN_Pos = 0x8
	// Bit mask of BRKLEN field.
	SERCOM_USART_INT_CTRLC_BRKLEN_Msk = 0x300
	// Position of HDRDLY field.
	SERCOM_USART_INT_CTRLC_HDRDLY_Pos = 0xa
	// Bit mask of HDRDLY field.
	SERCOM_USART_INT_CTRLC_HDRDLY_Msk = 0xc00
	// Position of INACK field.
	SERCOM_USART_INT_CTRLC_INACK_Pos = 0x10
	// Bit mask of INACK field.
	SERCOM_USART_INT_CTRLC_INACK_Msk = 0x10000
	// Bit INACK.
	SERCOM_USART_INT_CTRLC_INACK = 0x10000
	// Position of DSNACK field.
	SERCOM_USART_INT_CTRLC_DSNACK_Pos = 0x11
	// Bit mask of DSNACK field.
	SERCOM_USART_INT_CTRLC_DSNACK_Msk = 0x20000
	// Bit DSNACK.
	SERCOM_USART_INT_CTRLC_DSNACK = 0x20000
	// Position of MAXITER field.
	SERCOM_USART_INT_CTRLC_MAXITER_Pos = 0x14
	// Bit mask of MAXITER field.
	SERCOM_USART_INT_CTRLC_MAXITER_Msk = 0x700000
	// Position of DATA32B field.
	SERCOM_USART_INT_CTRLC_DATA32B_Pos = 0x18
	// Bit mask of DATA32B field.
	SERCOM_USART_INT_CTRLC_DATA32B_Msk = 0x3000000
	// Data reads and writes according CTRLB.CHSIZE
	SERCOM_USART_INT_CTRLC_DATA32B_DATA_READ_WRITE_CHSIZE = 0x0
	// Data reads according CTRLB.CHSIZE and writes according 32-bit extension
	SERCOM_USART_INT_CTRLC_DATA32B_DATA_READ_CHSIZE_WRITE_32BIT = 0x1
	// Data reads according 32-bit extension and writes according CTRLB.CHSIZE
	SERCOM_USART_INT_CTRLC_DATA32B_DATA_READ_32BIT_WRITE_CHSIZE = 0x2
	// Data reads and writes according 32-bit extension
	SERCOM_USART_INT_CTRLC_DATA32B_DATA_READ_WRITE_32BIT = 0x3

	// BAUD: USART_INT Baud Rate
	// Position of BAUD field.
	SERCOM_USART_INT_BAUD_BAUD_Pos = 0x0
	// Bit mask of BAUD field.
	SERCOM_USART_INT_BAUD_BAUD_Msk = 0xffff

	// BAUD_FRAC_MODE: USART_INT Baud Rate
	// Position of BAUD field.
	SERCOM_USART_INT_BAUD_FRAC_MODE_BAUD_Pos = 0x0
	// Bit mask of BAUD field.
	SERCOM_USART_INT_BAUD_FRAC_MODE_BAUD_Msk = 0x1fff
	// Position of FP field.
	SERCOM_USART_INT_BAUD_FRAC_MODE_FP_Pos = 0xd
	// Bit mask of FP field.
	SERCOM_USART_INT_BAUD_FRAC_MODE_FP_Msk = 0xe000

	// BAUD_FRACFP_MODE: USART_INT Baud Rate
	// Position of BAUD field.
	SERCOM_USART_INT_BAUD_FRACFP_MODE_BAUD_Pos = 0x0
	// Bit mask of BAUD field.
	SERCOM_USART_INT_BAUD_FRACFP_MODE_BAUD_Msk = 0x1fff
	// Position of FP field.
	SERCOM_USART_INT_BAUD_FRACFP_MODE_FP_Pos = 0xd
	// Bit mask of FP field.
	SERCOM_USART_INT_BAUD_FRACFP_MODE_FP_Msk = 0xe000

	// BAUD_USARTFP_MODE: USART_INT Baud Rate
	// Position of BAUD field.
	SERCOM_USART_INT_BAUD_USARTFP_MODE_BAUD_Pos = 0x0
	// Bit mask of BAUD field.
	SERCOM_USART_INT_BAUD_USARTFP_MODE_BAUD_Msk = 0xffff

	// RXPL: USART_INT Receive Pulse Length
	// Position of RXPL field.
	SERCOM_USART_INT_RXPL_RXPL_Pos = 0x0
	// Bit mask of RXPL field.
	SERCOM_USART_INT_RXPL_RXPL_Msk = 0xff

	// INTENCLR: USART_INT Interrupt Enable Clear
	// Position of DRE field.
	SERCOM_USART_INT_INTENCLR_DRE_Pos = 0x0
	// Bit mask of DRE field.
	SERCOM_USART_INT_INTENCLR_DRE_Msk = 0x1
	// Bit DRE.
	SERCOM_USART_INT_INTENCLR_DRE = 0x1
	// Position of TXC field.
	SERCOM_USART_INT_INTENCLR_TXC_Pos = 0x1
	// Bit mask of TXC field.
	SERCOM_USART_INT_INTENCLR_TXC_Msk = 0x2
	// Bit TXC.
	SERCOM_USART_INT_INTENCLR_TXC = 0x2
	// Position of RXC field.
	SERCOM_USART_INT_INTENCLR_RXC_Pos = 0x2
	// Bit mask of RXC field.
	SERCOM_USART_INT_INTENCLR_RXC_Msk = 0x4
	// Bit RXC.
	SERCOM_USART_INT_INTENCLR_RXC = 0x4
	// Position of RXS field.
	SERCOM_USART_INT_INTENCLR_RXS_Pos = 0x3
	// Bit mask of RXS field.
	SERCOM_USART_INT_INTENCLR_RXS_Msk = 0x8
	// Bit RXS.
	SERCOM_USART_INT_INTENCLR_RXS = 0x8
	// Position of CTSIC field.
	SERCOM_USART_INT_INTENCLR_CTSIC_Pos = 0x4
	// Bit mask of CTSIC field.
	SERCOM_USART_INT_INTENCLR_CTSIC_Msk = 0x10
	// Bit CTSIC.
	SERCOM_USART_INT_INTENCLR_CTSIC = 0x10
	// Position of RXBRK field.
	SERCOM_USART_INT_INTENCLR_RXBRK_Pos = 0x5
	// Bit mask of RXBRK field.
	SERCOM_USART_INT_INTENCLR_RXBRK_Msk = 0x20
	// Bit RXBRK.
	SERCOM_USART_INT_INTENCLR_RXBRK = 0x20
	// Position of ERROR field.
	SERCOM_USART_INT_INTENCLR_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	SERCOM_USART_INT_INTENCLR_ERROR_Msk = 0x80
	// Bit ERROR.
	SERCOM_USART_INT_INTENCLR_ERROR = 0x80

	// INTENSET: USART_INT Interrupt Enable Set
	// Position of DRE field.
	SERCOM_USART_INT_INTENSET_DRE_Pos = 0x0
	// Bit mask of DRE field.
	SERCOM_USART_INT_INTENSET_DRE_Msk = 0x1
	// Bit DRE.
	SERCOM_USART_INT_INTENSET_DRE = 0x1
	// Position of TXC field.
	SERCOM_USART_INT_INTENSET_TXC_Pos = 0x1
	// Bit mask of TXC field.
	SERCOM_USART_INT_INTENSET_TXC_Msk = 0x2
	// Bit TXC.
	SERCOM_USART_INT_INTENSET_TXC = 0x2
	// Position of RXC field.
	SERCOM_USART_INT_INTENSET_RXC_Pos = 0x2
	// Bit mask of RXC field.
	SERCOM_USART_INT_INTENSET_RXC_Msk = 0x4
	// Bit RXC.
	SERCOM_USART_INT_INTENSET_RXC = 0x4
	// Position of RXS field.
	SERCOM_USART_INT_INTENSET_RXS_Pos = 0x3
	// Bit mask of RXS field.
	SERCOM_USART_INT_INTENSET_RXS_Msk = 0x8
	// Bit RXS.
	SERCOM_USART_INT_INTENSET_RXS = 0x8
	// Position of CTSIC field.
	SERCOM_USART_INT_INTENSET_CTSIC_Pos = 0x4
	// Bit mask of CTSIC field.
	SERCOM_USART_INT_INTENSET_CTSIC_Msk = 0x10
	// Bit CTSIC.
	SERCOM_USART_INT_INTENSET_CTSIC = 0x10
	// Position of RXBRK field.
	SERCOM_USART_INT_INTENSET_RXBRK_Pos = 0x5
	// Bit mask of RXBRK field.
	SERCOM_USART_INT_INTENSET_RXBRK_Msk = 0x20
	// Bit RXBRK.
	SERCOM_USART_INT_INTENSET_RXBRK = 0x20
	// Position of ERROR field.
	SERCOM_USART_INT_INTENSET_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	SERCOM_USART_INT_INTENSET_ERROR_Msk = 0x80
	// Bit ERROR.
	SERCOM_USART_INT_INTENSET_ERROR = 0x80

	// INTFLAG: USART_INT Interrupt Flag Status and Clear
	// Position of DRE field.
	SERCOM_USART_INT_INTFLAG_DRE_Pos = 0x0
	// Bit mask of DRE field.
	SERCOM_USART_INT_INTFLAG_DRE_Msk = 0x1
	// Bit DRE.
	SERCOM_USART_INT_INTFLAG_DRE = 0x1
	// Position of TXC field.
	SERCOM_USART_INT_INTFLAG_TXC_Pos = 0x1
	// Bit mask of TXC field.
	SERCOM_USART_INT_INTFLAG_TXC_Msk = 0x2
	// Bit TXC.
	SERCOM_USART_INT_INTFLAG_TXC = 0x2
	// Position of RXC field.
	SERCOM_USART_INT_INTFLAG_RXC_Pos = 0x2
	// Bit mask of RXC field.
	SERCOM_USART_INT_INTFLAG_RXC_Msk = 0x4
	// Bit RXC.
	SERCOM_USART_INT_INTFLAG_RXC = 0x4
	// Position of RXS field.
	SERCOM_USART_INT_INTFLAG_RXS_Pos = 0x3
	// Bit mask of RXS field.
	SERCOM_USART_INT_INTFLAG_RXS_Msk = 0x8
	// Bit RXS.
	SERCOM_USART_INT_INTFLAG_RXS = 0x8
	// Position of CTSIC field.
	SERCOM_USART_INT_INTFLAG_CTSIC_Pos = 0x4
	// Bit mask of CTSIC field.
	SERCOM_USART_INT_INTFLAG_CTSIC_Msk = 0x10
	// Bit CTSIC.
	SERCOM_USART_INT_INTFLAG_CTSIC = 0x10
	// Position of RXBRK field.
	SERCOM_USART_INT_INTFLAG_RXBRK_Pos = 0x5
	// Bit mask of RXBRK field.
	SERCOM_USART_INT_INTFLAG_RXBRK_Msk = 0x20
	// Bit RXBRK.
	SERCOM_USART_INT_INTFLAG_RXBRK = 0x20
	// Position of ERROR field.
	SERCOM_USART_INT_INTFLAG_ERROR_Pos = 0x7
	// Bit mask of ERROR field.
	SERCOM_USART_INT_INTFLAG_ERROR_Msk = 0x80
	// Bit ERROR.
	SERCOM_USART_INT_INTFLAG_ERROR = 0x80

	// STATUS: USART_INT Status
	// Position of PERR field.
	SERCOM_USART_INT_STATUS_PERR_Pos = 0x0
	// Bit mask of PERR field.
	SERCOM_USART_INT_STATUS_PERR_Msk = 0x1
	// Bit PERR.
	SERCOM_USART_INT_STATUS_PERR = 0x1
	// Position of FERR field.
	SERCOM_USART_INT_STATUS_FERR_Pos = 0x1
	// Bit mask of FERR field.
	SERCOM_USART_INT_STATUS_FERR_Msk = 0x2
	// Bit FERR.
	SERCOM_USART_INT_STATUS_FERR = 0x2
	// Position of BUFOVF field.
	SERCOM_USART_INT_STATUS_BUFOVF_Pos = 0x2
	// Bit mask of BUFOVF field.
	SERCOM_USART_INT_STATUS_BUFOVF_Msk = 0x4
	// Bit BUFOVF.
	SERCOM_USART_INT_STATUS_BUFOVF = 0x4
	// Position of CTS field.
	SERCOM_USART_INT_STATUS_CTS_Pos = 0x3
	// Bit mask of CTS field.
	SERCOM_USART_INT_STATUS_CTS_Msk = 0x8
	// Bit CTS.
	SERCOM_USART_INT_STATUS_CTS = 0x8
	// Position of ISF field.
	SERCOM_USART_INT_STATUS_ISF_Pos = 0x4
	// Bit mask of ISF field.
	SERCOM_USART_INT_STATUS_ISF_Msk = 0x10
	// Bit ISF.
	SERCOM_USART_INT_STATUS_ISF = 0x10
	// Position of COLL field.
	SERCOM_USART_INT_STATUS_COLL_Pos = 0x5
	// Bit mask of COLL field.
	SERCOM_USART_INT_STATUS_COLL_Msk = 0x20
	// Bit COLL.
	SERCOM_USART_INT_STATUS_COLL = 0x20
	// Position of TXE field.
	SERCOM_USART_INT_STATUS_TXE_Pos = 0x6
	// Bit mask of TXE field.
	SERCOM_USART_INT_STATUS_TXE_Msk = 0x40
	// Bit TXE.
	SERCOM_USART_INT_STATUS_TXE = 0x40
	// Position of ITER field.
	SERCOM_USART_INT_STATUS_ITER_Pos = 0x7
	// Bit mask of ITER field.
	SERCOM_USART_INT_STATUS_ITER_Msk = 0x80
	// Bit ITER.
	SERCOM_USART_INT_STATUS_ITER = 0x80

	// SYNCBUSY: USART_INT Synchronization Busy
	// Position of SWRST field.
	SERCOM_USART_INT_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	SERCOM_USART_INT_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	SERCOM_USART_INT_SYNCBUSY_SWRST = 0x1
	// Position of ENABLE field.
	SERCOM_USART_INT_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	SERCOM_USART_INT_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	SERCOM_USART_INT_SYNCBUSY_ENABLE = 0x2
	// Position of CTRLB field.
	SERCOM_USART_INT_SYNCBUSY_CTRLB_Pos = 0x2
	// Bit mask of CTRLB field.
	SERCOM_USART_INT_SYNCBUSY_CTRLB_Msk = 0x4
	// Bit CTRLB.
	SERCOM_USART_INT_SYNCBUSY_CTRLB = 0x4
	// Position of RXERRCNT field.
	SERCOM_USART_INT_SYNCBUSY_RXERRCNT_Pos = 0x3
	// Bit mask of RXERRCNT field.
	SERCOM_USART_INT_SYNCBUSY_RXERRCNT_Msk = 0x8
	// Bit RXERRCNT.
	SERCOM_USART_INT_SYNCBUSY_RXERRCNT = 0x8
	// Position of LENGTH field.
	SERCOM_USART_INT_SYNCBUSY_LENGTH_Pos = 0x4
	// Bit mask of LENGTH field.
	SERCOM_USART_INT_SYNCBUSY_LENGTH_Msk = 0x10
	// Bit LENGTH.
	SERCOM_USART_INT_SYNCBUSY_LENGTH = 0x10

	// LENGTH: USART_INT Length
	// Position of LEN field.
	SERCOM_USART_INT_LENGTH_LEN_Pos = 0x0
	// Bit mask of LEN field.
	SERCOM_USART_INT_LENGTH_LEN_Msk = 0xff
	// Position of LENEN field.
	SERCOM_USART_INT_LENGTH_LENEN_Pos = 0x8
	// Bit mask of LENEN field.
	SERCOM_USART_INT_LENGTH_LENEN_Msk = 0x300

	// DATA: USART_INT Data
	// Position of DATA field.
	SERCOM_USART_INT_DATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	SERCOM_USART_INT_DATA_DATA_Msk = 0xffffffff

	// DBGCTRL: USART_INT Debug Control
	// Position of DBGSTOP field.
	SERCOM_USART_INT_DBGCTRL_DBGSTOP_Pos = 0x0
	// Bit mask of DBGSTOP field.
	SERCOM_USART_INT_DBGCTRL_DBGSTOP_Msk = 0x1
	// Bit DBGSTOP.
	SERCOM_USART_INT_DBGCTRL_DBGSTOP = 0x1
)

// Constants for SUPC: Supply Controller
const (
	// INTENCLR: Interrupt Enable Clear
	// Position of BOD33RDY field.
	SUPC_INTENCLR_BOD33RDY_Pos = 0x0
	// Bit mask of BOD33RDY field.
	SUPC_INTENCLR_BOD33RDY_Msk = 0x1
	// Bit BOD33RDY.
	SUPC_INTENCLR_BOD33RDY = 0x1
	// Position of BOD33DET field.
	SUPC_INTENCLR_BOD33DET_Pos = 0x1
	// Bit mask of BOD33DET field.
	SUPC_INTENCLR_BOD33DET_Msk = 0x2
	// Bit BOD33DET.
	SUPC_INTENCLR_BOD33DET = 0x2
	// Position of B33SRDY field.
	SUPC_INTENCLR_B33SRDY_Pos = 0x2
	// Bit mask of B33SRDY field.
	SUPC_INTENCLR_B33SRDY_Msk = 0x4
	// Bit B33SRDY.
	SUPC_INTENCLR_B33SRDY = 0x4
	// Position of VREGRDY field.
	SUPC_INTENCLR_VREGRDY_Pos = 0x8
	// Bit mask of VREGRDY field.
	SUPC_INTENCLR_VREGRDY_Msk = 0x100
	// Bit VREGRDY.
	SUPC_INTENCLR_VREGRDY = 0x100
	// Position of VCORERDY field.
	SUPC_INTENCLR_VCORERDY_Pos = 0xa
	// Bit mask of VCORERDY field.
	SUPC_INTENCLR_VCORERDY_Msk = 0x400
	// Bit VCORERDY.
	SUPC_INTENCLR_VCORERDY = 0x400

	// INTENSET: Interrupt Enable Set
	// Position of BOD33RDY field.
	SUPC_INTENSET_BOD33RDY_Pos = 0x0
	// Bit mask of BOD33RDY field.
	SUPC_INTENSET_BOD33RDY_Msk = 0x1
	// Bit BOD33RDY.
	SUPC_INTENSET_BOD33RDY = 0x1
	// Position of BOD33DET field.
	SUPC_INTENSET_BOD33DET_Pos = 0x1
	// Bit mask of BOD33DET field.
	SUPC_INTENSET_BOD33DET_Msk = 0x2
	// Bit BOD33DET.
	SUPC_INTENSET_BOD33DET = 0x2
	// Position of B33SRDY field.
	SUPC_INTENSET_B33SRDY_Pos = 0x2
	// Bit mask of B33SRDY field.
	SUPC_INTENSET_B33SRDY_Msk = 0x4
	// Bit B33SRDY.
	SUPC_INTENSET_B33SRDY = 0x4
	// Position of VREGRDY field.
	SUPC_INTENSET_VREGRDY_Pos = 0x8
	// Bit mask of VREGRDY field.
	SUPC_INTENSET_VREGRDY_Msk = 0x100
	// Bit VREGRDY.
	SUPC_INTENSET_VREGRDY = 0x100
	// Position of VCORERDY field.
	SUPC_INTENSET_VCORERDY_Pos = 0xa
	// Bit mask of VCORERDY field.
	SUPC_INTENSET_VCORERDY_Msk = 0x400
	// Bit VCORERDY.
	SUPC_INTENSET_VCORERDY = 0x400

	// INTFLAG: Interrupt Flag Status and Clear
	// Position of BOD33RDY field.
	SUPC_INTFLAG_BOD33RDY_Pos = 0x0
	// Bit mask of BOD33RDY field.
	SUPC_INTFLAG_BOD33RDY_Msk = 0x1
	// Bit BOD33RDY.
	SUPC_INTFLAG_BOD33RDY = 0x1
	// Position of BOD33DET field.
	SUPC_INTFLAG_BOD33DET_Pos = 0x1
	// Bit mask of BOD33DET field.
	SUPC_INTFLAG_BOD33DET_Msk = 0x2
	// Bit BOD33DET.
	SUPC_INTFLAG_BOD33DET = 0x2
	// Position of B33SRDY field.
	SUPC_INTFLAG_B33SRDY_Pos = 0x2
	// Bit mask of B33SRDY field.
	SUPC_INTFLAG_B33SRDY_Msk = 0x4
	// Bit B33SRDY.
	SUPC_INTFLAG_B33SRDY = 0x4
	// Position of VREGRDY field.
	SUPC_INTFLAG_VREGRDY_Pos = 0x8
	// Bit mask of VREGRDY field.
	SUPC_INTFLAG_VREGRDY_Msk = 0x100
	// Bit VREGRDY.
	SUPC_INTFLAG_VREGRDY = 0x100
	// Position of VCORERDY field.
	SUPC_INTFLAG_VCORERDY_Pos = 0xa
	// Bit mask of VCORERDY field.
	SUPC_INTFLAG_VCORERDY_Msk = 0x400
	// Bit VCORERDY.
	SUPC_INTFLAG_VCORERDY = 0x400

	// STATUS: Power and Clocks Status
	// Position of BOD33RDY field.
	SUPC_STATUS_BOD33RDY_Pos = 0x0
	// Bit mask of BOD33RDY field.
	SUPC_STATUS_BOD33RDY_Msk = 0x1
	// Bit BOD33RDY.
	SUPC_STATUS_BOD33RDY = 0x1
	// Position of BOD33DET field.
	SUPC_STATUS_BOD33DET_Pos = 0x1
	// Bit mask of BOD33DET field.
	SUPC_STATUS_BOD33DET_Msk = 0x2
	// Bit BOD33DET.
	SUPC_STATUS_BOD33DET = 0x2
	// Position of B33SRDY field.
	SUPC_STATUS_B33SRDY_Pos = 0x2
	// Bit mask of B33SRDY field.
	SUPC_STATUS_B33SRDY_Msk = 0x4
	// Bit B33SRDY.
	SUPC_STATUS_B33SRDY = 0x4
	// Position of VREGRDY field.
	SUPC_STATUS_VREGRDY_Pos = 0x8
	// Bit mask of VREGRDY field.
	SUPC_STATUS_VREGRDY_Msk = 0x100
	// Bit VREGRDY.
	SUPC_STATUS_VREGRDY = 0x100
	// Position of VCORERDY field.
	SUPC_STATUS_VCORERDY_Pos = 0xa
	// Bit mask of VCORERDY field.
	SUPC_STATUS_VCORERDY_Msk = 0x400
	// Bit VCORERDY.
	SUPC_STATUS_VCORERDY = 0x400

	// BOD33: BOD33 Control
	// Position of ENABLE field.
	SUPC_BOD33_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	SUPC_BOD33_ENABLE_Msk = 0x2
	// Bit ENABLE.
	SUPC_BOD33_ENABLE = 0x2
	// Position of ACTION field.
	SUPC_BOD33_ACTION_Pos = 0x2
	// Bit mask of ACTION field.
	SUPC_BOD33_ACTION_Msk = 0xc
	// No action
	SUPC_BOD33_ACTION_NONE = 0x0
	// The BOD33 generates a reset
	SUPC_BOD33_ACTION_RESET = 0x1
	// The BOD33 generates an interrupt
	SUPC_BOD33_ACTION_INT = 0x2
	// The BOD33 puts the device in backup sleep mode
	SUPC_BOD33_ACTION_BKUP = 0x3
	// Position of STDBYCFG field.
	SUPC_BOD33_STDBYCFG_Pos = 0x4
	// Bit mask of STDBYCFG field.
	SUPC_BOD33_STDBYCFG_Msk = 0x10
	// Bit STDBYCFG.
	SUPC_BOD33_STDBYCFG = 0x10
	// Position of RUNSTDBY field.
	SUPC_BOD33_RUNSTDBY_Pos = 0x5
	// Bit mask of RUNSTDBY field.
	SUPC_BOD33_RUNSTDBY_Msk = 0x20
	// Bit RUNSTDBY.
	SUPC_BOD33_RUNSTDBY = 0x20
	// Position of RUNHIB field.
	SUPC_BOD33_RUNHIB_Pos = 0x6
	// Bit mask of RUNHIB field.
	SUPC_BOD33_RUNHIB_Msk = 0x40
	// Bit RUNHIB.
	SUPC_BOD33_RUNHIB = 0x40
	// Position of RUNBKUP field.
	SUPC_BOD33_RUNBKUP_Pos = 0x7
	// Bit mask of RUNBKUP field.
	SUPC_BOD33_RUNBKUP_Msk = 0x80
	// Bit RUNBKUP.
	SUPC_BOD33_RUNBKUP = 0x80
	// Position of HYST field.
	SUPC_BOD33_HYST_Pos = 0x8
	// Bit mask of HYST field.
	SUPC_BOD33_HYST_Msk = 0xf00
	// Position of PSEL field.
	SUPC_BOD33_PSEL_Pos = 0xc
	// Bit mask of PSEL field.
	SUPC_BOD33_PSEL_Msk = 0x7000
	// Not divided
	SUPC_BOD33_PSEL_NODIV = 0x0
	// Divide clock by 4
	SUPC_BOD33_PSEL_DIV4 = 0x1
	// Divide clock by 8
	SUPC_BOD33_PSEL_DIV8 = 0x2
	// Divide clock by 16
	SUPC_BOD33_PSEL_DIV16 = 0x3
	// Divide clock by 32
	SUPC_BOD33_PSEL_DIV32 = 0x4
	// Divide clock by 64
	SUPC_BOD33_PSEL_DIV64 = 0x5
	// Divide clock by 128
	SUPC_BOD33_PSEL_DIV128 = 0x6
	// Divide clock by 256
	SUPC_BOD33_PSEL_DIV256 = 0x7
	// Position of LEVEL field.
	SUPC_BOD33_LEVEL_Pos = 0x10
	// Bit mask of LEVEL field.
	SUPC_BOD33_LEVEL_Msk = 0xff0000
	// Position of VBATLEVEL field.
	SUPC_BOD33_VBATLEVEL_Pos = 0x18
	// Bit mask of VBATLEVEL field.
	SUPC_BOD33_VBATLEVEL_Msk = 0xff000000

	// VREG: VREG Control
	// Position of ENABLE field.
	SUPC_VREG_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	SUPC_VREG_ENABLE_Msk = 0x2
	// Bit ENABLE.
	SUPC_VREG_ENABLE = 0x2
	// Position of SEL field.
	SUPC_VREG_SEL_Pos = 0x2
	// Bit mask of SEL field.
	SUPC_VREG_SEL_Msk = 0x4
	// Bit SEL.
	SUPC_VREG_SEL = 0x4
	// LDO selection
	SUPC_VREG_SEL_LDO = 0x0
	// Buck selection
	SUPC_VREG_SEL_BUCK = 0x1
	// Position of RUNBKUP field.
	SUPC_VREG_RUNBKUP_Pos = 0x7
	// Bit mask of RUNBKUP field.
	SUPC_VREG_RUNBKUP_Msk = 0x80
	// Bit RUNBKUP.
	SUPC_VREG_RUNBKUP = 0x80
	// Position of VSEN field.
	SUPC_VREG_VSEN_Pos = 0x10
	// Bit mask of VSEN field.
	SUPC_VREG_VSEN_Msk = 0x10000
	// Bit VSEN.
	SUPC_VREG_VSEN = 0x10000
	// Position of VSPER field.
	SUPC_VREG_VSPER_Pos = 0x18
	// Bit mask of VSPER field.
	SUPC_VREG_VSPER_Msk = 0x7000000

	// VREF: VREF Control
	// Position of TSEN field.
	SUPC_VREF_TSEN_Pos = 0x1
	// Bit mask of TSEN field.
	SUPC_VREF_TSEN_Msk = 0x2
	// Bit TSEN.
	SUPC_VREF_TSEN = 0x2
	// Position of VREFOE field.
	SUPC_VREF_VREFOE_Pos = 0x2
	// Bit mask of VREFOE field.
	SUPC_VREF_VREFOE_Msk = 0x4
	// Bit VREFOE.
	SUPC_VREF_VREFOE = 0x4
	// Position of TSSEL field.
	SUPC_VREF_TSSEL_Pos = 0x3
	// Bit mask of TSSEL field.
	SUPC_VREF_TSSEL_Msk = 0x8
	// Bit TSSEL.
	SUPC_VREF_TSSEL = 0x8
	// Position of RUNSTDBY field.
	SUPC_VREF_RUNSTDBY_Pos = 0x6
	// Bit mask of RUNSTDBY field.
	SUPC_VREF_RUNSTDBY_Msk = 0x40
	// Bit RUNSTDBY.
	SUPC_VREF_RUNSTDBY = 0x40
	// Position of ONDEMAND field.
	SUPC_VREF_ONDEMAND_Pos = 0x7
	// Bit mask of ONDEMAND field.
	SUPC_VREF_ONDEMAND_Msk = 0x80
	// Bit ONDEMAND.
	SUPC_VREF_ONDEMAND = 0x80
	// Position of SEL field.
	SUPC_VREF_SEL_Pos = 0x10
	// Bit mask of SEL field.
	SUPC_VREF_SEL_Msk = 0xf0000
	// 1.0V voltage reference typical value
	SUPC_VREF_SEL_1V0 = 0x0
	// 1.1V voltage reference typical value
	SUPC_VREF_SEL_1V1 = 0x1
	// 1.2V voltage reference typical value
	SUPC_VREF_SEL_1V2 = 0x2
	// 1.25V voltage reference typical value
	SUPC_VREF_SEL_1V25 = 0x3
	// 2.0V voltage reference typical value
	SUPC_VREF_SEL_2V0 = 0x4
	// 2.2V voltage reference typical value
	SUPC_VREF_SEL_2V2 = 0x5
	// 2.4V voltage reference typical value
	SUPC_VREF_SEL_2V4 = 0x6
	// 2.5V voltage reference typical value
	SUPC_VREF_SEL_2V5 = 0x7

	// BBPS: Battery Backup Power Switch
	// Position of CONF field.
	SUPC_BBPS_CONF_Pos = 0x0
	// Bit mask of CONF field.
	SUPC_BBPS_CONF_Msk = 0x1
	// Bit CONF.
	SUPC_BBPS_CONF = 0x1
	// The power switch is handled by the BOD33
	SUPC_BBPS_CONF_BOD33 = 0x0
	// In Backup Domain, the backup domain is always supplied by battery backup power
	SUPC_BBPS_CONF_FORCED = 0x1
	// Position of WAKEEN field.
	SUPC_BBPS_WAKEEN_Pos = 0x2
	// Bit mask of WAKEEN field.
	SUPC_BBPS_WAKEEN_Msk = 0x4
	// Bit WAKEEN.
	SUPC_BBPS_WAKEEN = 0x4

	// BKOUT: Backup Output Control
	// Position of ENOUT0 field.
	SUPC_BKOUT_ENOUT0_Pos = 0x0
	// Bit mask of ENOUT0 field.
	SUPC_BKOUT_ENOUT0_Msk = 0x1
	// Bit ENOUT0.
	SUPC_BKOUT_ENOUT0 = 0x1
	// Position of ENOUT1 field.
	SUPC_BKOUT_ENOUT1_Pos = 0x1
	// Bit mask of ENOUT1 field.
	SUPC_BKOUT_ENOUT1_Msk = 0x2
	// Bit ENOUT1.
	SUPC_BKOUT_ENOUT1 = 0x2
	// Position of CLROUT0 field.
	SUPC_BKOUT_CLROUT0_Pos = 0x8
	// Bit mask of CLROUT0 field.
	SUPC_BKOUT_CLROUT0_Msk = 0x100
	// Bit CLROUT0.
	SUPC_BKOUT_CLROUT0 = 0x100
	// Position of CLROUT1 field.
	SUPC_BKOUT_CLROUT1_Pos = 0x9
	// Bit mask of CLROUT1 field.
	SUPC_BKOUT_CLROUT1_Msk = 0x200
	// Bit CLROUT1.
	SUPC_BKOUT_CLROUT1 = 0x200
	// Position of SETOUT0 field.
	SUPC_BKOUT_SETOUT0_Pos = 0x10
	// Bit mask of SETOUT0 field.
	SUPC_BKOUT_SETOUT0_Msk = 0x10000
	// Bit SETOUT0.
	SUPC_BKOUT_SETOUT0 = 0x10000
	// Position of SETOUT1 field.
	SUPC_BKOUT_SETOUT1_Pos = 0x11
	// Bit mask of SETOUT1 field.
	SUPC_BKOUT_SETOUT1_Msk = 0x20000
	// Bit SETOUT1.
	SUPC_BKOUT_SETOUT1 = 0x20000
	// Position of RTCTGLOUT0 field.
	SUPC_BKOUT_RTCTGLOUT0_Pos = 0x18
	// Bit mask of RTCTGLOUT0 field.
	SUPC_BKOUT_RTCTGLOUT0_Msk = 0x1000000
	// Bit RTCTGLOUT0.
	SUPC_BKOUT_RTCTGLOUT0 = 0x1000000
	// Position of RTCTGLOUT1 field.
	SUPC_BKOUT_RTCTGLOUT1_Pos = 0x19
	// Bit mask of RTCTGLOUT1 field.
	SUPC_BKOUT_RTCTGLOUT1_Msk = 0x2000000
	// Bit RTCTGLOUT1.
	SUPC_BKOUT_RTCTGLOUT1 = 0x2000000

	// BKIN: Backup Input Control
	// Position of BKIN0 field.
	SUPC_BKIN_BKIN0_Pos = 0x0
	// Bit mask of BKIN0 field.
	SUPC_BKIN_BKIN0_Msk = 0x1
	// Bit BKIN0.
	SUPC_BKIN_BKIN0 = 0x1
	// Position of BKIN1 field.
	SUPC_BKIN_BKIN1_Pos = 0x1
	// Bit mask of BKIN1 field.
	SUPC_BKIN_BKIN1_Msk = 0x2
	// Bit BKIN1.
	SUPC_BKIN_BKIN1 = 0x2
)

// Constants for TC0: Basic Timer Counter
const ()

// Constants for TC0_COUNT8: Basic Timer Counter - COUNT8
const (
	// CTRLA: Control A
	// Position of SWRST field.
	TC_COUNT8_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	TC_COUNT8_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	TC_COUNT8_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	TC_COUNT8_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	TC_COUNT8_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	TC_COUNT8_CTRLA_ENABLE = 0x2
	// Position of MODE field.
	TC_COUNT8_CTRLA_MODE_Pos = 0x2
	// Bit mask of MODE field.
	TC_COUNT8_CTRLA_MODE_Msk = 0xc
	// Counter in 16-bit mode
	TC_COUNT8_CTRLA_MODE_COUNT16 = 0x0
	// Counter in 8-bit mode
	TC_COUNT8_CTRLA_MODE_COUNT8 = 0x1
	// Counter in 32-bit mode
	TC_COUNT8_CTRLA_MODE_COUNT32 = 0x2
	// Position of PRESCSYNC field.
	TC_COUNT8_CTRLA_PRESCSYNC_Pos = 0x4
	// Bit mask of PRESCSYNC field.
	TC_COUNT8_CTRLA_PRESCSYNC_Msk = 0x30
	// Reload or reset the counter on next generic clock
	TC_COUNT8_CTRLA_PRESCSYNC_GCLK = 0x0
	// Reload or reset the counter on next prescaler clock
	TC_COUNT8_CTRLA_PRESCSYNC_PRESC = 0x1
	// Reload or reset the counter on next generic clock and reset the prescaler counter
	TC_COUNT8_CTRLA_PRESCSYNC_RESYNC = 0x2
	// Position of RUNSTDBY field.
	TC_COUNT8_CTRLA_RUNSTDBY_Pos = 0x6
	// Bit mask of RUNSTDBY field.
	TC_COUNT8_CTRLA_RUNSTDBY_Msk = 0x40
	// Bit RUNSTDBY.
	TC_COUNT8_CTRLA_RUNSTDBY = 0x40
	// Position of ONDEMAND field.
	TC_COUNT8_CTRLA_ONDEMAND_Pos = 0x7
	// Bit mask of ONDEMAND field.
	TC_COUNT8_CTRLA_ONDEMAND_Msk = 0x80
	// Bit ONDEMAND.
	TC_COUNT8_CTRLA_ONDEMAND = 0x80
	// Position of PRESCALER field.
	TC_COUNT8_CTRLA_PRESCALER_Pos = 0x8
	// Bit mask of PRESCALER field.
	TC_COUNT8_CTRLA_PRESCALER_Msk = 0x700
	// Prescaler: GCLK_TC
	TC_COUNT8_CTRLA_PRESCALER_DIV1 = 0x0
	// Prescaler: GCLK_TC/2
	TC_COUNT8_CTRLA_PRESCALER_DIV2 = 0x1
	// Prescaler: GCLK_TC/4
	TC_COUNT8_CTRLA_PRESCALER_DIV4 = 0x2
	// Prescaler: GCLK_TC/8
	TC_COUNT8_CTRLA_PRESCALER_DIV8 = 0x3
	// Prescaler: GCLK_TC/16
	TC_COUNT8_CTRLA_PRESCALER_DIV16 = 0x4
	// Prescaler: GCLK_TC/64
	TC_COUNT8_CTRLA_PRESCALER_DIV64 = 0x5
	// Prescaler: GCLK_TC/256
	TC_COUNT8_CTRLA_PRESCALER_DIV256 = 0x6
	// Prescaler: GCLK_TC/1024
	TC_COUNT8_CTRLA_PRESCALER_DIV1024 = 0x7
	// Position of ALOCK field.
	TC_COUNT8_CTRLA_ALOCK_Pos = 0xb
	// Bit mask of ALOCK field.
	TC_COUNT8_CTRLA_ALOCK_Msk = 0x800
	// Bit ALOCK.
	TC_COUNT8_CTRLA_ALOCK = 0x800
	// Position of CAPTEN0 field.
	TC_COUNT8_CTRLA_CAPTEN0_Pos = 0x10
	// Bit mask of CAPTEN0 field.
	TC_COUNT8_CTRLA_CAPTEN0_Msk = 0x10000
	// Bit CAPTEN0.
	TC_COUNT8_CTRLA_CAPTEN0 = 0x10000
	// Position of CAPTEN1 field.
	TC_COUNT8_CTRLA_CAPTEN1_Pos = 0x11
	// Bit mask of CAPTEN1 field.
	TC_COUNT8_CTRLA_CAPTEN1_Msk = 0x20000
	// Bit CAPTEN1.
	TC_COUNT8_CTRLA_CAPTEN1 = 0x20000
	// Position of COPEN0 field.
	TC_COUNT8_CTRLA_COPEN0_Pos = 0x14
	// Bit mask of COPEN0 field.
	TC_COUNT8_CTRLA_COPEN0_Msk = 0x100000
	// Bit COPEN0.
	TC_COUNT8_CTRLA_COPEN0 = 0x100000
	// Position of COPEN1 field.
	TC_COUNT8_CTRLA_COPEN1_Pos = 0x15
	// Bit mask of COPEN1 field.
	TC_COUNT8_CTRLA_COPEN1_Msk = 0x200000
	// Bit COPEN1.
	TC_COUNT8_CTRLA_COPEN1 = 0x200000
	// Position of CAPTMODE0 field.
	TC_COUNT8_CTRLA_CAPTMODE0_Pos = 0x18
	// Bit mask of CAPTMODE0 field.
	TC_COUNT8_CTRLA_CAPTMODE0_Msk = 0x3000000
	// Default capture
	TC_COUNT8_CTRLA_CAPTMODE0_DEFAULT = 0x0
	// Minimum capture
	TC_COUNT8_CTRLA_CAPTMODE0_CAPTMIN = 0x1
	// Maximum capture
	TC_COUNT8_CTRLA_CAPTMODE0_CAPTMAX = 0x2
	// Position of CAPTMODE1 field.
	TC_COUNT8_CTRLA_CAPTMODE1_Pos = 0x1b
	// Bit mask of CAPTMODE1 field.
	TC_COUNT8_CTRLA_CAPTMODE1_Msk = 0x18000000
	// Default capture
	TC_COUNT8_CTRLA_CAPTMODE1_DEFAULT = 0x0
	// Minimum capture
	TC_COUNT8_CTRLA_CAPTMODE1_CAPTMIN = 0x1
	// Maximum capture
	TC_COUNT8_CTRLA_CAPTMODE1_CAPTMAX = 0x2

	// CTRLBCLR: Control B Clear
	// Position of DIR field.
	TC_COUNT8_CTRLBCLR_DIR_Pos = 0x0
	// Bit mask of DIR field.
	TC_COUNT8_CTRLBCLR_DIR_Msk = 0x1
	// Bit DIR.
	TC_COUNT8_CTRLBCLR_DIR = 0x1
	// Position of LUPD field.
	TC_COUNT8_CTRLBCLR_LUPD_Pos = 0x1
	// Bit mask of LUPD field.
	TC_COUNT8_CTRLBCLR_LUPD_Msk = 0x2
	// Bit LUPD.
	TC_COUNT8_CTRLBCLR_LUPD = 0x2
	// Position of ONESHOT field.
	TC_COUNT8_CTRLBCLR_ONESHOT_Pos = 0x2
	// Bit mask of ONESHOT field.
	TC_COUNT8_CTRLBCLR_ONESHOT_Msk = 0x4
	// Bit ONESHOT.
	TC_COUNT8_CTRLBCLR_ONESHOT = 0x4
	// Position of CMD field.
	TC_COUNT8_CTRLBCLR_CMD_Pos = 0x5
	// Bit mask of CMD field.
	TC_COUNT8_CTRLBCLR_CMD_Msk = 0xe0
	// No action
	TC_COUNT8_CTRLBCLR_CMD_NONE = 0x0
	// Force a start, restart or retrigger
	TC_COUNT8_CTRLBCLR_CMD_RETRIGGER = 0x1
	// Force a stop
	TC_COUNT8_CTRLBCLR_CMD_STOP = 0x2
	// Force update of double-buffered register
	TC_COUNT8_CTRLBCLR_CMD_UPDATE = 0x3
	// Force a read synchronization of COUNT
	TC_COUNT8_CTRLBCLR_CMD_READSYNC = 0x4
	// One-shot DMA trigger
	TC_COUNT8_CTRLBCLR_CMD_DMAOS = 0x5

	// CTRLBSET: Control B Set
	// Position of DIR field.
	TC_COUNT8_CTRLBSET_DIR_Pos = 0x0
	// Bit mask of DIR field.
	TC_COUNT8_CTRLBSET_DIR_Msk = 0x1
	// Bit DIR.
	TC_COUNT8_CTRLBSET_DIR = 0x1
	// Position of LUPD field.
	TC_COUNT8_CTRLBSET_LUPD_Pos = 0x1
	// Bit mask of LUPD field.
	TC_COUNT8_CTRLBSET_LUPD_Msk = 0x2
	// Bit LUPD.
	TC_COUNT8_CTRLBSET_LUPD = 0x2
	// Position of ONESHOT field.
	TC_COUNT8_CTRLBSET_ONESHOT_Pos = 0x2
	// Bit mask of ONESHOT field.
	TC_COUNT8_CTRLBSET_ONESHOT_Msk = 0x4
	// Bit ONESHOT.
	TC_COUNT8_CTRLBSET_ONESHOT = 0x4
	// Position of CMD field.
	TC_COUNT8_CTRLBSET_CMD_Pos = 0x5
	// Bit mask of CMD field.
	TC_COUNT8_CTRLBSET_CMD_Msk = 0xe0
	// No action
	TC_COUNT8_CTRLBSET_CMD_NONE = 0x0
	// Force a start, restart or retrigger
	TC_COUNT8_CTRLBSET_CMD_RETRIGGER = 0x1
	// Force a stop
	TC_COUNT8_CTRLBSET_CMD_STOP = 0x2
	// Force update of double-buffered register
	TC_COUNT8_CTRLBSET_CMD_UPDATE = 0x3
	// Force a read synchronization of COUNT
	TC_COUNT8_CTRLBSET_CMD_READSYNC = 0x4
	// One-shot DMA trigger
	TC_COUNT8_CTRLBSET_CMD_DMAOS = 0x5

	// EVCTRL: Event Control
	// Position of EVACT field.
	TC_COUNT8_EVCTRL_EVACT_Pos = 0x0
	// Bit mask of EVACT field.
	TC_COUNT8_EVCTRL_EVACT_Msk = 0x7
	// Event action disabled
	TC_COUNT8_EVCTRL_EVACT_OFF = 0x0
	// Start, restart or retrigger TC on event
	TC_COUNT8_EVCTRL_EVACT_RETRIGGER = 0x1
	// Count on event
	TC_COUNT8_EVCTRL_EVACT_COUNT = 0x2
	// Start TC on event
	TC_COUNT8_EVCTRL_EVACT_START = 0x3
	// Time stamp capture
	TC_COUNT8_EVCTRL_EVACT_STAMP = 0x4
	// Period catured in CC0, pulse width in CC1
	TC_COUNT8_EVCTRL_EVACT_PPW = 0x5
	// Period catured in CC1, pulse width in CC0
	TC_COUNT8_EVCTRL_EVACT_PWP = 0x6
	// Pulse width capture
	TC_COUNT8_EVCTRL_EVACT_PW = 0x7
	// Position of TCINV field.
	TC_COUNT8_EVCTRL_TCINV_Pos = 0x4
	// Bit mask of TCINV field.
	TC_COUNT8_EVCTRL_TCINV_Msk = 0x10
	// Bit TCINV.
	TC_COUNT8_EVCTRL_TCINV = 0x10
	// Position of TCEI field.
	TC_COUNT8_EVCTRL_TCEI_Pos = 0x5
	// Bit mask of TCEI field.
	TC_COUNT8_EVCTRL_TCEI_Msk = 0x20
	// Bit TCEI.
	TC_COUNT8_EVCTRL_TCEI = 0x20
	// Position of OVFEO field.
	TC_COUNT8_EVCTRL_OVFEO_Pos = 0x8
	// Bit mask of OVFEO field.
	TC_COUNT8_EVCTRL_OVFEO_Msk = 0x100
	// Bit OVFEO.
	TC_COUNT8_EVCTRL_OVFEO = 0x100
	// Position of MCEO0 field.
	TC_COUNT8_EVCTRL_MCEO0_Pos = 0xc
	// Bit mask of MCEO0 field.
	TC_COUNT8_EVCTRL_MCEO0_Msk = 0x1000
	// Bit MCEO0.
	TC_COUNT8_EVCTRL_MCEO0 = 0x1000
	// Position of MCEO1 field.
	TC_COUNT8_EVCTRL_MCEO1_Pos = 0xd
	// Bit mask of MCEO1 field.
	TC_COUNT8_EVCTRL_MCEO1_Msk = 0x2000
	// Bit MCEO1.
	TC_COUNT8_EVCTRL_MCEO1 = 0x2000

	// INTENCLR: Interrupt Enable Clear
	// Position of OVF field.
	TC_COUNT8_INTENCLR_OVF_Pos = 0x0
	// Bit mask of OVF field.
	TC_COUNT8_INTENCLR_OVF_Msk = 0x1
	// Bit OVF.
	TC_COUNT8_INTENCLR_OVF = 0x1
	// Position of ERR field.
	TC_COUNT8_INTENCLR_ERR_Pos = 0x1
	// Bit mask of ERR field.
	TC_COUNT8_INTENCLR_ERR_Msk = 0x2
	// Bit ERR.
	TC_COUNT8_INTENCLR_ERR = 0x2
	// Position of MC0 field.
	TC_COUNT8_INTENCLR_MC0_Pos = 0x4
	// Bit mask of MC0 field.
	TC_COUNT8_INTENCLR_MC0_Msk = 0x10
	// Bit MC0.
	TC_COUNT8_INTENCLR_MC0 = 0x10
	// Position of MC1 field.
	TC_COUNT8_INTENCLR_MC1_Pos = 0x5
	// Bit mask of MC1 field.
	TC_COUNT8_INTENCLR_MC1_Msk = 0x20
	// Bit MC1.
	TC_COUNT8_INTENCLR_MC1 = 0x20

	// INTENSET: Interrupt Enable Set
	// Position of OVF field.
	TC_COUNT8_INTENSET_OVF_Pos = 0x0
	// Bit mask of OVF field.
	TC_COUNT8_INTENSET_OVF_Msk = 0x1
	// Bit OVF.
	TC_COUNT8_INTENSET_OVF = 0x1
	// Position of ERR field.
	TC_COUNT8_INTENSET_ERR_Pos = 0x1
	// Bit mask of ERR field.
	TC_COUNT8_INTENSET_ERR_Msk = 0x2
	// Bit ERR.
	TC_COUNT8_INTENSET_ERR = 0x2
	// Position of MC0 field.
	TC_COUNT8_INTENSET_MC0_Pos = 0x4
	// Bit mask of MC0 field.
	TC_COUNT8_INTENSET_MC0_Msk = 0x10
	// Bit MC0.
	TC_COUNT8_INTENSET_MC0 = 0x10
	// Position of MC1 field.
	TC_COUNT8_INTENSET_MC1_Pos = 0x5
	// Bit mask of MC1 field.
	TC_COUNT8_INTENSET_MC1_Msk = 0x20
	// Bit MC1.
	TC_COUNT8_INTENSET_MC1 = 0x20

	// INTFLAG: Interrupt Flag Status and Clear
	// Position of OVF field.
	TC_COUNT8_INTFLAG_OVF_Pos = 0x0
	// Bit mask of OVF field.
	TC_COUNT8_INTFLAG_OVF_Msk = 0x1
	// Bit OVF.
	TC_COUNT8_INTFLAG_OVF = 0x1
	// Position of ERR field.
	TC_COUNT8_INTFLAG_ERR_Pos = 0x1
	// Bit mask of ERR field.
	TC_COUNT8_INTFLAG_ERR_Msk = 0x2
	// Bit ERR.
	TC_COUNT8_INTFLAG_ERR = 0x2
	// Position of MC0 field.
	TC_COUNT8_INTFLAG_MC0_Pos = 0x4
	// Bit mask of MC0 field.
	TC_COUNT8_INTFLAG_MC0_Msk = 0x10
	// Bit MC0.
	TC_COUNT8_INTFLAG_MC0 = 0x10
	// Position of MC1 field.
	TC_COUNT8_INTFLAG_MC1_Pos = 0x5
	// Bit mask of MC1 field.
	TC_COUNT8_INTFLAG_MC1_Msk = 0x20
	// Bit MC1.
	TC_COUNT8_INTFLAG_MC1 = 0x20

	// STATUS: Status
	// Position of STOP field.
	TC_COUNT8_STATUS_STOP_Pos = 0x0
	// Bit mask of STOP field.
	TC_COUNT8_STATUS_STOP_Msk = 0x1
	// Bit STOP.
	TC_COUNT8_STATUS_STOP = 0x1
	// Position of SLAVE field.
	TC_COUNT8_STATUS_SLAVE_Pos = 0x1
	// Bit mask of SLAVE field.
	TC_COUNT8_STATUS_SLAVE_Msk = 0x2
	// Bit SLAVE.
	TC_COUNT8_STATUS_SLAVE = 0x2
	// Position of PERBUFV field.
	TC_COUNT8_STATUS_PERBUFV_Pos = 0x3
	// Bit mask of PERBUFV field.
	TC_COUNT8_STATUS_PERBUFV_Msk = 0x8
	// Bit PERBUFV.
	TC_COUNT8_STATUS_PERBUFV = 0x8
	// Position of CCBUFV0 field.
	TC_COUNT8_STATUS_CCBUFV0_Pos = 0x4
	// Bit mask of CCBUFV0 field.
	TC_COUNT8_STATUS_CCBUFV0_Msk = 0x10
	// Bit CCBUFV0.
	TC_COUNT8_STATUS_CCBUFV0 = 0x10
	// Position of CCBUFV1 field.
	TC_COUNT8_STATUS_CCBUFV1_Pos = 0x5
	// Bit mask of CCBUFV1 field.
	TC_COUNT8_STATUS_CCBUFV1_Msk = 0x20
	// Bit CCBUFV1.
	TC_COUNT8_STATUS_CCBUFV1 = 0x20

	// WAVE: Waveform Generation Control
	// Position of WAVEGEN field.
	TC_COUNT8_WAVE_WAVEGEN_Pos = 0x0
	// Bit mask of WAVEGEN field.
	TC_COUNT8_WAVE_WAVEGEN_Msk = 0x3
	// Normal frequency
	TC_COUNT8_WAVE_WAVEGEN_NFRQ = 0x0
	// Match frequency
	TC_COUNT8_WAVE_WAVEGEN_MFRQ = 0x1
	// Normal PWM
	TC_COUNT8_WAVE_WAVEGEN_NPWM = 0x2
	// Match PWM
	TC_COUNT8_WAVE_WAVEGEN_MPWM = 0x3

	// DRVCTRL: Control C
	// Position of INVEN0 field.
	TC_COUNT8_DRVCTRL_INVEN0_Pos = 0x0
	// Bit mask of INVEN0 field.
	TC_COUNT8_DRVCTRL_INVEN0_Msk = 0x1
	// Bit INVEN0.
	TC_COUNT8_DRVCTRL_INVEN0 = 0x1
	// Position of INVEN1 field.
	TC_COUNT8_DRVCTRL_INVEN1_Pos = 0x1
	// Bit mask of INVEN1 field.
	TC_COUNT8_DRVCTRL_INVEN1_Msk = 0x2
	// Bit INVEN1.
	TC_COUNT8_DRVCTRL_INVEN1 = 0x2

	// DBGCTRL: Debug Control
	// Position of DBGRUN field.
	TC_COUNT8_DBGCTRL_DBGRUN_Pos = 0x0
	// Bit mask of DBGRUN field.
	TC_COUNT8_DBGCTRL_DBGRUN_Msk = 0x1
	// Bit DBGRUN.
	TC_COUNT8_DBGCTRL_DBGRUN = 0x1

	// SYNCBUSY: Synchronization Status
	// Position of SWRST field.
	TC_COUNT8_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	TC_COUNT8_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	TC_COUNT8_SYNCBUSY_SWRST = 0x1
	// Position of ENABLE field.
	TC_COUNT8_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	TC_COUNT8_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	TC_COUNT8_SYNCBUSY_ENABLE = 0x2
	// Position of CTRLB field.
	TC_COUNT8_SYNCBUSY_CTRLB_Pos = 0x2
	// Bit mask of CTRLB field.
	TC_COUNT8_SYNCBUSY_CTRLB_Msk = 0x4
	// Bit CTRLB.
	TC_COUNT8_SYNCBUSY_CTRLB = 0x4
	// Position of STATUS field.
	TC_COUNT8_SYNCBUSY_STATUS_Pos = 0x3
	// Bit mask of STATUS field.
	TC_COUNT8_SYNCBUSY_STATUS_Msk = 0x8
	// Bit STATUS.
	TC_COUNT8_SYNCBUSY_STATUS = 0x8
	// Position of COUNT field.
	TC_COUNT8_SYNCBUSY_COUNT_Pos = 0x4
	// Bit mask of COUNT field.
	TC_COUNT8_SYNCBUSY_COUNT_Msk = 0x10
	// Bit COUNT.
	TC_COUNT8_SYNCBUSY_COUNT = 0x10
	// Position of PER field.
	TC_COUNT8_SYNCBUSY_PER_Pos = 0x5
	// Bit mask of PER field.
	TC_COUNT8_SYNCBUSY_PER_Msk = 0x20
	// Bit PER.
	TC_COUNT8_SYNCBUSY_PER = 0x20
	// Position of CC0 field.
	TC_COUNT8_SYNCBUSY_CC0_Pos = 0x6
	// Bit mask of CC0 field.
	TC_COUNT8_SYNCBUSY_CC0_Msk = 0x40
	// Bit CC0.
	TC_COUNT8_SYNCBUSY_CC0 = 0x40
	// Position of CC1 field.
	TC_COUNT8_SYNCBUSY_CC1_Pos = 0x7
	// Bit mask of CC1 field.
	TC_COUNT8_SYNCBUSY_CC1_Msk = 0x80
	// Bit CC1.
	TC_COUNT8_SYNCBUSY_CC1 = 0x80

	// COUNT: COUNT8 Count
	// Position of COUNT field.
	TC_COUNT8_COUNT_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	TC_COUNT8_COUNT_COUNT_Msk = 0xff

	// PER: COUNT8 Period
	// Position of PER field.
	TC_COUNT8_PER_PER_Pos = 0x0
	// Bit mask of PER field.
	TC_COUNT8_PER_PER_Msk = 0xff

	// CC: COUNT8 Compare and Capture
	// Position of CC field.
	TC_COUNT8_CC_CC_Pos = 0x0
	// Bit mask of CC field.
	TC_COUNT8_CC_CC_Msk = 0xff

	// PERBUF: COUNT8 Period Buffer
	// Position of PERBUF field.
	TC_COUNT8_PERBUF_PERBUF_Pos = 0x0
	// Bit mask of PERBUF field.
	TC_COUNT8_PERBUF_PERBUF_Msk = 0xff

	// CCBUF: COUNT8 Compare and Capture Buffer
	// Position of CCBUF field.
	TC_COUNT8_CCBUF_CCBUF_Pos = 0x0
	// Bit mask of CCBUF field.
	TC_COUNT8_CCBUF_CCBUF_Msk = 0xff
)

// Constants for TC0_COUNT16: Basic Timer Counter - COUNT16
const (
	// CTRLA: Control A
	// Position of SWRST field.
	TC_COUNT16_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	TC_COUNT16_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	TC_COUNT16_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	TC_COUNT16_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	TC_COUNT16_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	TC_COUNT16_CTRLA_ENABLE = 0x2
	// Position of MODE field.
	TC_COUNT16_CTRLA_MODE_Pos = 0x2
	// Bit mask of MODE field.
	TC_COUNT16_CTRLA_MODE_Msk = 0xc
	// Counter in 16-bit mode
	TC_COUNT16_CTRLA_MODE_COUNT16 = 0x0
	// Counter in 8-bit mode
	TC_COUNT16_CTRLA_MODE_COUNT8 = 0x1
	// Counter in 32-bit mode
	TC_COUNT16_CTRLA_MODE_COUNT32 = 0x2
	// Position of PRESCSYNC field.
	TC_COUNT16_CTRLA_PRESCSYNC_Pos = 0x4
	// Bit mask of PRESCSYNC field.
	TC_COUNT16_CTRLA_PRESCSYNC_Msk = 0x30
	// Reload or reset the counter on next generic clock
	TC_COUNT16_CTRLA_PRESCSYNC_GCLK = 0x0
	// Reload or reset the counter on next prescaler clock
	TC_COUNT16_CTRLA_PRESCSYNC_PRESC = 0x1
	// Reload or reset the counter on next generic clock and reset the prescaler counter
	TC_COUNT16_CTRLA_PRESCSYNC_RESYNC = 0x2
	// Position of RUNSTDBY field.
	TC_COUNT16_CTRLA_RUNSTDBY_Pos = 0x6
	// Bit mask of RUNSTDBY field.
	TC_COUNT16_CTRLA_RUNSTDBY_Msk = 0x40
	// Bit RUNSTDBY.
	TC_COUNT16_CTRLA_RUNSTDBY = 0x40
	// Position of ONDEMAND field.
	TC_COUNT16_CTRLA_ONDEMAND_Pos = 0x7
	// Bit mask of ONDEMAND field.
	TC_COUNT16_CTRLA_ONDEMAND_Msk = 0x80
	// Bit ONDEMAND.
	TC_COUNT16_CTRLA_ONDEMAND = 0x80
	// Position of PRESCALER field.
	TC_COUNT16_CTRLA_PRESCALER_Pos = 0x8
	// Bit mask of PRESCALER field.
	TC_COUNT16_CTRLA_PRESCALER_Msk = 0x700
	// Prescaler: GCLK_TC
	TC_COUNT16_CTRLA_PRESCALER_DIV1 = 0x0
	// Prescaler: GCLK_TC/2
	TC_COUNT16_CTRLA_PRESCALER_DIV2 = 0x1
	// Prescaler: GCLK_TC/4
	TC_COUNT16_CTRLA_PRESCALER_DIV4 = 0x2
	// Prescaler: GCLK_TC/8
	TC_COUNT16_CTRLA_PRESCALER_DIV8 = 0x3
	// Prescaler: GCLK_TC/16
	TC_COUNT16_CTRLA_PRESCALER_DIV16 = 0x4
	// Prescaler: GCLK_TC/64
	TC_COUNT16_CTRLA_PRESCALER_DIV64 = 0x5
	// Prescaler: GCLK_TC/256
	TC_COUNT16_CTRLA_PRESCALER_DIV256 = 0x6
	// Prescaler: GCLK_TC/1024
	TC_COUNT16_CTRLA_PRESCALER_DIV1024 = 0x7
	// Position of ALOCK field.
	TC_COUNT16_CTRLA_ALOCK_Pos = 0xb
	// Bit mask of ALOCK field.
	TC_COUNT16_CTRLA_ALOCK_Msk = 0x800
	// Bit ALOCK.
	TC_COUNT16_CTRLA_ALOCK = 0x800
	// Position of CAPTEN0 field.
	TC_COUNT16_CTRLA_CAPTEN0_Pos = 0x10
	// Bit mask of CAPTEN0 field.
	TC_COUNT16_CTRLA_CAPTEN0_Msk = 0x10000
	// Bit CAPTEN0.
	TC_COUNT16_CTRLA_CAPTEN0 = 0x10000
	// Position of CAPTEN1 field.
	TC_COUNT16_CTRLA_CAPTEN1_Pos = 0x11
	// Bit mask of CAPTEN1 field.
	TC_COUNT16_CTRLA_CAPTEN1_Msk = 0x20000
	// Bit CAPTEN1.
	TC_COUNT16_CTRLA_CAPTEN1 = 0x20000
	// Position of COPEN0 field.
	TC_COUNT16_CTRLA_COPEN0_Pos = 0x14
	// Bit mask of COPEN0 field.
	TC_COUNT16_CTRLA_COPEN0_Msk = 0x100000
	// Bit COPEN0.
	TC_COUNT16_CTRLA_COPEN0 = 0x100000
	// Position of COPEN1 field.
	TC_COUNT16_CTRLA_COPEN1_Pos = 0x15
	// Bit mask of COPEN1 field.
	TC_COUNT16_CTRLA_COPEN1_Msk = 0x200000
	// Bit COPEN1.
	TC_COUNT16_CTRLA_COPEN1 = 0x200000
	// Position of CAPTMODE0 field.
	TC_COUNT16_CTRLA_CAPTMODE0_Pos = 0x18
	// Bit mask of CAPTMODE0 field.
	TC_COUNT16_CTRLA_CAPTMODE0_Msk = 0x3000000
	// Default capture
	TC_COUNT16_CTRLA_CAPTMODE0_DEFAULT = 0x0
	// Minimum capture
	TC_COUNT16_CTRLA_CAPTMODE0_CAPTMIN = 0x1
	// Maximum capture
	TC_COUNT16_CTRLA_CAPTMODE0_CAPTMAX = 0x2
	// Position of CAPTMODE1 field.
	TC_COUNT16_CTRLA_CAPTMODE1_Pos = 0x1b
	// Bit mask of CAPTMODE1 field.
	TC_COUNT16_CTRLA_CAPTMODE1_Msk = 0x18000000
	// Default capture
	TC_COUNT16_CTRLA_CAPTMODE1_DEFAULT = 0x0
	// Minimum capture
	TC_COUNT16_CTRLA_CAPTMODE1_CAPTMIN = 0x1
	// Maximum capture
	TC_COUNT16_CTRLA_CAPTMODE1_CAPTMAX = 0x2

	// CTRLBCLR: Control B Clear
	// Position of DIR field.
	TC_COUNT16_CTRLBCLR_DIR_Pos = 0x0
	// Bit mask of DIR field.
	TC_COUNT16_CTRLBCLR_DIR_Msk = 0x1
	// Bit DIR.
	TC_COUNT16_CTRLBCLR_DIR = 0x1
	// Position of LUPD field.
	TC_COUNT16_CTRLBCLR_LUPD_Pos = 0x1
	// Bit mask of LUPD field.
	TC_COUNT16_CTRLBCLR_LUPD_Msk = 0x2
	// Bit LUPD.
	TC_COUNT16_CTRLBCLR_LUPD = 0x2
	// Position of ONESHOT field.
	TC_COUNT16_CTRLBCLR_ONESHOT_Pos = 0x2
	// Bit mask of ONESHOT field.
	TC_COUNT16_CTRLBCLR_ONESHOT_Msk = 0x4
	// Bit ONESHOT.
	TC_COUNT16_CTRLBCLR_ONESHOT = 0x4
	// Position of CMD field.
	TC_COUNT16_CTRLBCLR_CMD_Pos = 0x5
	// Bit mask of CMD field.
	TC_COUNT16_CTRLBCLR_CMD_Msk = 0xe0
	// No action
	TC_COUNT16_CTRLBCLR_CMD_NONE = 0x0
	// Force a start, restart or retrigger
	TC_COUNT16_CTRLBCLR_CMD_RETRIGGER = 0x1
	// Force a stop
	TC_COUNT16_CTRLBCLR_CMD_STOP = 0x2
	// Force update of double-buffered register
	TC_COUNT16_CTRLBCLR_CMD_UPDATE = 0x3
	// Force a read synchronization of COUNT
	TC_COUNT16_CTRLBCLR_CMD_READSYNC = 0x4
	// One-shot DMA trigger
	TC_COUNT16_CTRLBCLR_CMD_DMAOS = 0x5

	// CTRLBSET: Control B Set
	// Position of DIR field.
	TC_COUNT16_CTRLBSET_DIR_Pos = 0x0
	// Bit mask of DIR field.
	TC_COUNT16_CTRLBSET_DIR_Msk = 0x1
	// Bit DIR.
	TC_COUNT16_CTRLBSET_DIR = 0x1
	// Position of LUPD field.
	TC_COUNT16_CTRLBSET_LUPD_Pos = 0x1
	// Bit mask of LUPD field.
	TC_COUNT16_CTRLBSET_LUPD_Msk = 0x2
	// Bit LUPD.
	TC_COUNT16_CTRLBSET_LUPD = 0x2
	// Position of ONESHOT field.
	TC_COUNT16_CTRLBSET_ONESHOT_Pos = 0x2
	// Bit mask of ONESHOT field.
	TC_COUNT16_CTRLBSET_ONESHOT_Msk = 0x4
	// Bit ONESHOT.
	TC_COUNT16_CTRLBSET_ONESHOT = 0x4
	// Position of CMD field.
	TC_COUNT16_CTRLBSET_CMD_Pos = 0x5
	// Bit mask of CMD field.
	TC_COUNT16_CTRLBSET_CMD_Msk = 0xe0
	// No action
	TC_COUNT16_CTRLBSET_CMD_NONE = 0x0
	// Force a start, restart or retrigger
	TC_COUNT16_CTRLBSET_CMD_RETRIGGER = 0x1
	// Force a stop
	TC_COUNT16_CTRLBSET_CMD_STOP = 0x2
	// Force update of double-buffered register
	TC_COUNT16_CTRLBSET_CMD_UPDATE = 0x3
	// Force a read synchronization of COUNT
	TC_COUNT16_CTRLBSET_CMD_READSYNC = 0x4
	// One-shot DMA trigger
	TC_COUNT16_CTRLBSET_CMD_DMAOS = 0x5

	// EVCTRL: Event Control
	// Position of EVACT field.
	TC_COUNT16_EVCTRL_EVACT_Pos = 0x0
	// Bit mask of EVACT field.
	TC_COUNT16_EVCTRL_EVACT_Msk = 0x7
	// Event action disabled
	TC_COUNT16_EVCTRL_EVACT_OFF = 0x0
	// Start, restart or retrigger TC on event
	TC_COUNT16_EVCTRL_EVACT_RETRIGGER = 0x1
	// Count on event
	TC_COUNT16_EVCTRL_EVACT_COUNT = 0x2
	// Start TC on event
	TC_COUNT16_EVCTRL_EVACT_START = 0x3
	// Time stamp capture
	TC_COUNT16_EVCTRL_EVACT_STAMP = 0x4
	// Period catured in CC0, pulse width in CC1
	TC_COUNT16_EVCTRL_EVACT_PPW = 0x5
	// Period catured in CC1, pulse width in CC0
	TC_COUNT16_EVCTRL_EVACT_PWP = 0x6
	// Pulse width capture
	TC_COUNT16_EVCTRL_EVACT_PW = 0x7
	// Position of TCINV field.
	TC_COUNT16_EVCTRL_TCINV_Pos = 0x4
	// Bit mask of TCINV field.
	TC_COUNT16_EVCTRL_TCINV_Msk = 0x10
	// Bit TCINV.
	TC_COUNT16_EVCTRL_TCINV = 0x10
	// Position of TCEI field.
	TC_COUNT16_EVCTRL_TCEI_Pos = 0x5
	// Bit mask of TCEI field.
	TC_COUNT16_EVCTRL_TCEI_Msk = 0x20
	// Bit TCEI.
	TC_COUNT16_EVCTRL_TCEI = 0x20
	// Position of OVFEO field.
	TC_COUNT16_EVCTRL_OVFEO_Pos = 0x8
	// Bit mask of OVFEO field.
	TC_COUNT16_EVCTRL_OVFEO_Msk = 0x100
	// Bit OVFEO.
	TC_COUNT16_EVCTRL_OVFEO = 0x100
	// Position of MCEO0 field.
	TC_COUNT16_EVCTRL_MCEO0_Pos = 0xc
	// Bit mask of MCEO0 field.
	TC_COUNT16_EVCTRL_MCEO0_Msk = 0x1000
	// Bit MCEO0.
	TC_COUNT16_EVCTRL_MCEO0 = 0x1000
	// Position of MCEO1 field.
	TC_COUNT16_EVCTRL_MCEO1_Pos = 0xd
	// Bit mask of MCEO1 field.
	TC_COUNT16_EVCTRL_MCEO1_Msk = 0x2000
	// Bit MCEO1.
	TC_COUNT16_EVCTRL_MCEO1 = 0x2000

	// INTENCLR: Interrupt Enable Clear
	// Position of OVF field.
	TC_COUNT16_INTENCLR_OVF_Pos = 0x0
	// Bit mask of OVF field.
	TC_COUNT16_INTENCLR_OVF_Msk = 0x1
	// Bit OVF.
	TC_COUNT16_INTENCLR_OVF = 0x1
	// Position of ERR field.
	TC_COUNT16_INTENCLR_ERR_Pos = 0x1
	// Bit mask of ERR field.
	TC_COUNT16_INTENCLR_ERR_Msk = 0x2
	// Bit ERR.
	TC_COUNT16_INTENCLR_ERR = 0x2
	// Position of MC0 field.
	TC_COUNT16_INTENCLR_MC0_Pos = 0x4
	// Bit mask of MC0 field.
	TC_COUNT16_INTENCLR_MC0_Msk = 0x10
	// Bit MC0.
	TC_COUNT16_INTENCLR_MC0 = 0x10
	// Position of MC1 field.
	TC_COUNT16_INTENCLR_MC1_Pos = 0x5
	// Bit mask of MC1 field.
	TC_COUNT16_INTENCLR_MC1_Msk = 0x20
	// Bit MC1.
	TC_COUNT16_INTENCLR_MC1 = 0x20

	// INTENSET: Interrupt Enable Set
	// Position of OVF field.
	TC_COUNT16_INTENSET_OVF_Pos = 0x0
	// Bit mask of OVF field.
	TC_COUNT16_INTENSET_OVF_Msk = 0x1
	// Bit OVF.
	TC_COUNT16_INTENSET_OVF = 0x1
	// Position of ERR field.
	TC_COUNT16_INTENSET_ERR_Pos = 0x1
	// Bit mask of ERR field.
	TC_COUNT16_INTENSET_ERR_Msk = 0x2
	// Bit ERR.
	TC_COUNT16_INTENSET_ERR = 0x2
	// Position of MC0 field.
	TC_COUNT16_INTENSET_MC0_Pos = 0x4
	// Bit mask of MC0 field.
	TC_COUNT16_INTENSET_MC0_Msk = 0x10
	// Bit MC0.
	TC_COUNT16_INTENSET_MC0 = 0x10
	// Position of MC1 field.
	TC_COUNT16_INTENSET_MC1_Pos = 0x5
	// Bit mask of MC1 field.
	TC_COUNT16_INTENSET_MC1_Msk = 0x20
	// Bit MC1.
	TC_COUNT16_INTENSET_MC1 = 0x20

	// INTFLAG: Interrupt Flag Status and Clear
	// Position of OVF field.
	TC_COUNT16_INTFLAG_OVF_Pos = 0x0
	// Bit mask of OVF field.
	TC_COUNT16_INTFLAG_OVF_Msk = 0x1
	// Bit OVF.
	TC_COUNT16_INTFLAG_OVF = 0x1
	// Position of ERR field.
	TC_COUNT16_INTFLAG_ERR_Pos = 0x1
	// Bit mask of ERR field.
	TC_COUNT16_INTFLAG_ERR_Msk = 0x2
	// Bit ERR.
	TC_COUNT16_INTFLAG_ERR = 0x2
	// Position of MC0 field.
	TC_COUNT16_INTFLAG_MC0_Pos = 0x4
	// Bit mask of MC0 field.
	TC_COUNT16_INTFLAG_MC0_Msk = 0x10
	// Bit MC0.
	TC_COUNT16_INTFLAG_MC0 = 0x10
	// Position of MC1 field.
	TC_COUNT16_INTFLAG_MC1_Pos = 0x5
	// Bit mask of MC1 field.
	TC_COUNT16_INTFLAG_MC1_Msk = 0x20
	// Bit MC1.
	TC_COUNT16_INTFLAG_MC1 = 0x20

	// STATUS: Status
	// Position of STOP field.
	TC_COUNT16_STATUS_STOP_Pos = 0x0
	// Bit mask of STOP field.
	TC_COUNT16_STATUS_STOP_Msk = 0x1
	// Bit STOP.
	TC_COUNT16_STATUS_STOP = 0x1
	// Position of SLAVE field.
	TC_COUNT16_STATUS_SLAVE_Pos = 0x1
	// Bit mask of SLAVE field.
	TC_COUNT16_STATUS_SLAVE_Msk = 0x2
	// Bit SLAVE.
	TC_COUNT16_STATUS_SLAVE = 0x2
	// Position of PERBUFV field.
	TC_COUNT16_STATUS_PERBUFV_Pos = 0x3
	// Bit mask of PERBUFV field.
	TC_COUNT16_STATUS_PERBUFV_Msk = 0x8
	// Bit PERBUFV.
	TC_COUNT16_STATUS_PERBUFV = 0x8
	// Position of CCBUFV0 field.
	TC_COUNT16_STATUS_CCBUFV0_Pos = 0x4
	// Bit mask of CCBUFV0 field.
	TC_COUNT16_STATUS_CCBUFV0_Msk = 0x10
	// Bit CCBUFV0.
	TC_COUNT16_STATUS_CCBUFV0 = 0x10
	// Position of CCBUFV1 field.
	TC_COUNT16_STATUS_CCBUFV1_Pos = 0x5
	// Bit mask of CCBUFV1 field.
	TC_COUNT16_STATUS_CCBUFV1_Msk = 0x20
	// Bit CCBUFV1.
	TC_COUNT16_STATUS_CCBUFV1 = 0x20

	// WAVE: Waveform Generation Control
	// Position of WAVEGEN field.
	TC_COUNT16_WAVE_WAVEGEN_Pos = 0x0
	// Bit mask of WAVEGEN field.
	TC_COUNT16_WAVE_WAVEGEN_Msk = 0x3
	// Normal frequency
	TC_COUNT16_WAVE_WAVEGEN_NFRQ = 0x0
	// Match frequency
	TC_COUNT16_WAVE_WAVEGEN_MFRQ = 0x1
	// Normal PWM
	TC_COUNT16_WAVE_WAVEGEN_NPWM = 0x2
	// Match PWM
	TC_COUNT16_WAVE_WAVEGEN_MPWM = 0x3

	// DRVCTRL: Control C
	// Position of INVEN0 field.
	TC_COUNT16_DRVCTRL_INVEN0_Pos = 0x0
	// Bit mask of INVEN0 field.
	TC_COUNT16_DRVCTRL_INVEN0_Msk = 0x1
	// Bit INVEN0.
	TC_COUNT16_DRVCTRL_INVEN0 = 0x1
	// Position of INVEN1 field.
	TC_COUNT16_DRVCTRL_INVEN1_Pos = 0x1
	// Bit mask of INVEN1 field.
	TC_COUNT16_DRVCTRL_INVEN1_Msk = 0x2
	// Bit INVEN1.
	TC_COUNT16_DRVCTRL_INVEN1 = 0x2

	// DBGCTRL: Debug Control
	// Position of DBGRUN field.
	TC_COUNT16_DBGCTRL_DBGRUN_Pos = 0x0
	// Bit mask of DBGRUN field.
	TC_COUNT16_DBGCTRL_DBGRUN_Msk = 0x1
	// Bit DBGRUN.
	TC_COUNT16_DBGCTRL_DBGRUN = 0x1

	// SYNCBUSY: Synchronization Status
	// Position of SWRST field.
	TC_COUNT16_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	TC_COUNT16_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	TC_COUNT16_SYNCBUSY_SWRST = 0x1
	// Position of ENABLE field.
	TC_COUNT16_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	TC_COUNT16_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	TC_COUNT16_SYNCBUSY_ENABLE = 0x2
	// Position of CTRLB field.
	TC_COUNT16_SYNCBUSY_CTRLB_Pos = 0x2
	// Bit mask of CTRLB field.
	TC_COUNT16_SYNCBUSY_CTRLB_Msk = 0x4
	// Bit CTRLB.
	TC_COUNT16_SYNCBUSY_CTRLB = 0x4
	// Position of STATUS field.
	TC_COUNT16_SYNCBUSY_STATUS_Pos = 0x3
	// Bit mask of STATUS field.
	TC_COUNT16_SYNCBUSY_STATUS_Msk = 0x8
	// Bit STATUS.
	TC_COUNT16_SYNCBUSY_STATUS = 0x8
	// Position of COUNT field.
	TC_COUNT16_SYNCBUSY_COUNT_Pos = 0x4
	// Bit mask of COUNT field.
	TC_COUNT16_SYNCBUSY_COUNT_Msk = 0x10
	// Bit COUNT.
	TC_COUNT16_SYNCBUSY_COUNT = 0x10
	// Position of PER field.
	TC_COUNT16_SYNCBUSY_PER_Pos = 0x5
	// Bit mask of PER field.
	TC_COUNT16_SYNCBUSY_PER_Msk = 0x20
	// Bit PER.
	TC_COUNT16_SYNCBUSY_PER = 0x20
	// Position of CC0 field.
	TC_COUNT16_SYNCBUSY_CC0_Pos = 0x6
	// Bit mask of CC0 field.
	TC_COUNT16_SYNCBUSY_CC0_Msk = 0x40
	// Bit CC0.
	TC_COUNT16_SYNCBUSY_CC0 = 0x40
	// Position of CC1 field.
	TC_COUNT16_SYNCBUSY_CC1_Pos = 0x7
	// Bit mask of CC1 field.
	TC_COUNT16_SYNCBUSY_CC1_Msk = 0x80
	// Bit CC1.
	TC_COUNT16_SYNCBUSY_CC1 = 0x80

	// COUNT: COUNT16 Count
	// Position of COUNT field.
	TC_COUNT16_COUNT_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	TC_COUNT16_COUNT_COUNT_Msk = 0xffff

	// CC: COUNT16 Compare and Capture
	// Position of CC field.
	TC_COUNT16_CC_CC_Pos = 0x0
	// Bit mask of CC field.
	TC_COUNT16_CC_CC_Msk = 0xffff

	// CCBUF: COUNT16 Compare and Capture Buffer
	// Position of CCBUF field.
	TC_COUNT16_CCBUF_CCBUF_Pos = 0x0
	// Bit mask of CCBUF field.
	TC_COUNT16_CCBUF_CCBUF_Msk = 0xffff
)

// Constants for TC0_COUNT32: Basic Timer Counter - COUNT32
const (
	// CTRLA: Control A
	// Position of SWRST field.
	TC_COUNT32_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	TC_COUNT32_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	TC_COUNT32_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	TC_COUNT32_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	TC_COUNT32_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	TC_COUNT32_CTRLA_ENABLE = 0x2
	// Position of MODE field.
	TC_COUNT32_CTRLA_MODE_Pos = 0x2
	// Bit mask of MODE field.
	TC_COUNT32_CTRLA_MODE_Msk = 0xc
	// Counter in 16-bit mode
	TC_COUNT32_CTRLA_MODE_COUNT16 = 0x0
	// Counter in 8-bit mode
	TC_COUNT32_CTRLA_MODE_COUNT8 = 0x1
	// Counter in 32-bit mode
	TC_COUNT32_CTRLA_MODE_COUNT32 = 0x2
	// Position of PRESCSYNC field.
	TC_COUNT32_CTRLA_PRESCSYNC_Pos = 0x4
	// Bit mask of PRESCSYNC field.
	TC_COUNT32_CTRLA_PRESCSYNC_Msk = 0x30
	// Reload or reset the counter on next generic clock
	TC_COUNT32_CTRLA_PRESCSYNC_GCLK = 0x0
	// Reload or reset the counter on next prescaler clock
	TC_COUNT32_CTRLA_PRESCSYNC_PRESC = 0x1
	// Reload or reset the counter on next generic clock and reset the prescaler counter
	TC_COUNT32_CTRLA_PRESCSYNC_RESYNC = 0x2
	// Position of RUNSTDBY field.
	TC_COUNT32_CTRLA_RUNSTDBY_Pos = 0x6
	// Bit mask of RUNSTDBY field.
	TC_COUNT32_CTRLA_RUNSTDBY_Msk = 0x40
	// Bit RUNSTDBY.
	TC_COUNT32_CTRLA_RUNSTDBY = 0x40
	// Position of ONDEMAND field.
	TC_COUNT32_CTRLA_ONDEMAND_Pos = 0x7
	// Bit mask of ONDEMAND field.
	TC_COUNT32_CTRLA_ONDEMAND_Msk = 0x80
	// Bit ONDEMAND.
	TC_COUNT32_CTRLA_ONDEMAND = 0x80
	// Position of PRESCALER field.
	TC_COUNT32_CTRLA_PRESCALER_Pos = 0x8
	// Bit mask of PRESCALER field.
	TC_COUNT32_CTRLA_PRESCALER_Msk = 0x700
	// Prescaler: GCLK_TC
	TC_COUNT32_CTRLA_PRESCALER_DIV1 = 0x0
	// Prescaler: GCLK_TC/2
	TC_COUNT32_CTRLA_PRESCALER_DIV2 = 0x1
	// Prescaler: GCLK_TC/4
	TC_COUNT32_CTRLA_PRESCALER_DIV4 = 0x2
	// Prescaler: GCLK_TC/8
	TC_COUNT32_CTRLA_PRESCALER_DIV8 = 0x3
	// Prescaler: GCLK_TC/16
	TC_COUNT32_CTRLA_PRESCALER_DIV16 = 0x4
	// Prescaler: GCLK_TC/64
	TC_COUNT32_CTRLA_PRESCALER_DIV64 = 0x5
	// Prescaler: GCLK_TC/256
	TC_COUNT32_CTRLA_PRESCALER_DIV256 = 0x6
	// Prescaler: GCLK_TC/1024
	TC_COUNT32_CTRLA_PRESCALER_DIV1024 = 0x7
	// Position of ALOCK field.
	TC_COUNT32_CTRLA_ALOCK_Pos = 0xb
	// Bit mask of ALOCK field.
	TC_COUNT32_CTRLA_ALOCK_Msk = 0x800
	// Bit ALOCK.
	TC_COUNT32_CTRLA_ALOCK = 0x800
	// Position of CAPTEN0 field.
	TC_COUNT32_CTRLA_CAPTEN0_Pos = 0x10
	// Bit mask of CAPTEN0 field.
	TC_COUNT32_CTRLA_CAPTEN0_Msk = 0x10000
	// Bit CAPTEN0.
	TC_COUNT32_CTRLA_CAPTEN0 = 0x10000
	// Position of CAPTEN1 field.
	TC_COUNT32_CTRLA_CAPTEN1_Pos = 0x11
	// Bit mask of CAPTEN1 field.
	TC_COUNT32_CTRLA_CAPTEN1_Msk = 0x20000
	// Bit CAPTEN1.
	TC_COUNT32_CTRLA_CAPTEN1 = 0x20000
	// Position of COPEN0 field.
	TC_COUNT32_CTRLA_COPEN0_Pos = 0x14
	// Bit mask of COPEN0 field.
	TC_COUNT32_CTRLA_COPEN0_Msk = 0x100000
	// Bit COPEN0.
	TC_COUNT32_CTRLA_COPEN0 = 0x100000
	// Position of COPEN1 field.
	TC_COUNT32_CTRLA_COPEN1_Pos = 0x15
	// Bit mask of COPEN1 field.
	TC_COUNT32_CTRLA_COPEN1_Msk = 0x200000
	// Bit COPEN1.
	TC_COUNT32_CTRLA_COPEN1 = 0x200000
	// Position of CAPTMODE0 field.
	TC_COUNT32_CTRLA_CAPTMODE0_Pos = 0x18
	// Bit mask of CAPTMODE0 field.
	TC_COUNT32_CTRLA_CAPTMODE0_Msk = 0x3000000
	// Default capture
	TC_COUNT32_CTRLA_CAPTMODE0_DEFAULT = 0x0
	// Minimum capture
	TC_COUNT32_CTRLA_CAPTMODE0_CAPTMIN = 0x1
	// Maximum capture
	TC_COUNT32_CTRLA_CAPTMODE0_CAPTMAX = 0x2
	// Position of CAPTMODE1 field.
	TC_COUNT32_CTRLA_CAPTMODE1_Pos = 0x1b
	// Bit mask of CAPTMODE1 field.
	TC_COUNT32_CTRLA_CAPTMODE1_Msk = 0x18000000
	// Default capture
	TC_COUNT32_CTRLA_CAPTMODE1_DEFAULT = 0x0
	// Minimum capture
	TC_COUNT32_CTRLA_CAPTMODE1_CAPTMIN = 0x1
	// Maximum capture
	TC_COUNT32_CTRLA_CAPTMODE1_CAPTMAX = 0x2

	// CTRLBCLR: Control B Clear
	// Position of DIR field.
	TC_COUNT32_CTRLBCLR_DIR_Pos = 0x0
	// Bit mask of DIR field.
	TC_COUNT32_CTRLBCLR_DIR_Msk = 0x1
	// Bit DIR.
	TC_COUNT32_CTRLBCLR_DIR = 0x1
	// Position of LUPD field.
	TC_COUNT32_CTRLBCLR_LUPD_Pos = 0x1
	// Bit mask of LUPD field.
	TC_COUNT32_CTRLBCLR_LUPD_Msk = 0x2
	// Bit LUPD.
	TC_COUNT32_CTRLBCLR_LUPD = 0x2
	// Position of ONESHOT field.
	TC_COUNT32_CTRLBCLR_ONESHOT_Pos = 0x2
	// Bit mask of ONESHOT field.
	TC_COUNT32_CTRLBCLR_ONESHOT_Msk = 0x4
	// Bit ONESHOT.
	TC_COUNT32_CTRLBCLR_ONESHOT = 0x4
	// Position of CMD field.
	TC_COUNT32_CTRLBCLR_CMD_Pos = 0x5
	// Bit mask of CMD field.
	TC_COUNT32_CTRLBCLR_CMD_Msk = 0xe0
	// No action
	TC_COUNT32_CTRLBCLR_CMD_NONE = 0x0
	// Force a start, restart or retrigger
	TC_COUNT32_CTRLBCLR_CMD_RETRIGGER = 0x1
	// Force a stop
	TC_COUNT32_CTRLBCLR_CMD_STOP = 0x2
	// Force update of double-buffered register
	TC_COUNT32_CTRLBCLR_CMD_UPDATE = 0x3
	// Force a read synchronization of COUNT
	TC_COUNT32_CTRLBCLR_CMD_READSYNC = 0x4
	// One-shot DMA trigger
	TC_COUNT32_CTRLBCLR_CMD_DMAOS = 0x5

	// CTRLBSET: Control B Set
	// Position of DIR field.
	TC_COUNT32_CTRLBSET_DIR_Pos = 0x0
	// Bit mask of DIR field.
	TC_COUNT32_CTRLBSET_DIR_Msk = 0x1
	// Bit DIR.
	TC_COUNT32_CTRLBSET_DIR = 0x1
	// Position of LUPD field.
	TC_COUNT32_CTRLBSET_LUPD_Pos = 0x1
	// Bit mask of LUPD field.
	TC_COUNT32_CTRLBSET_LUPD_Msk = 0x2
	// Bit LUPD.
	TC_COUNT32_CTRLBSET_LUPD = 0x2
	// Position of ONESHOT field.
	TC_COUNT32_CTRLBSET_ONESHOT_Pos = 0x2
	// Bit mask of ONESHOT field.
	TC_COUNT32_CTRLBSET_ONESHOT_Msk = 0x4
	// Bit ONESHOT.
	TC_COUNT32_CTRLBSET_ONESHOT = 0x4
	// Position of CMD field.
	TC_COUNT32_CTRLBSET_CMD_Pos = 0x5
	// Bit mask of CMD field.
	TC_COUNT32_CTRLBSET_CMD_Msk = 0xe0
	// No action
	TC_COUNT32_CTRLBSET_CMD_NONE = 0x0
	// Force a start, restart or retrigger
	TC_COUNT32_CTRLBSET_CMD_RETRIGGER = 0x1
	// Force a stop
	TC_COUNT32_CTRLBSET_CMD_STOP = 0x2
	// Force update of double-buffered register
	TC_COUNT32_CTRLBSET_CMD_UPDATE = 0x3
	// Force a read synchronization of COUNT
	TC_COUNT32_CTRLBSET_CMD_READSYNC = 0x4
	// One-shot DMA trigger
	TC_COUNT32_CTRLBSET_CMD_DMAOS = 0x5

	// EVCTRL: Event Control
	// Position of EVACT field.
	TC_COUNT32_EVCTRL_EVACT_Pos = 0x0
	// Bit mask of EVACT field.
	TC_COUNT32_EVCTRL_EVACT_Msk = 0x7
	// Event action disabled
	TC_COUNT32_EVCTRL_EVACT_OFF = 0x0
	// Start, restart or retrigger TC on event
	TC_COUNT32_EVCTRL_EVACT_RETRIGGER = 0x1
	// Count on event
	TC_COUNT32_EVCTRL_EVACT_COUNT = 0x2
	// Start TC on event
	TC_COUNT32_EVCTRL_EVACT_START = 0x3
	// Time stamp capture
	TC_COUNT32_EVCTRL_EVACT_STAMP = 0x4
	// Period catured in CC0, pulse width in CC1
	TC_COUNT32_EVCTRL_EVACT_PPW = 0x5
	// Period catured in CC1, pulse width in CC0
	TC_COUNT32_EVCTRL_EVACT_PWP = 0x6
	// Pulse width capture
	TC_COUNT32_EVCTRL_EVACT_PW = 0x7
	// Position of TCINV field.
	TC_COUNT32_EVCTRL_TCINV_Pos = 0x4
	// Bit mask of TCINV field.
	TC_COUNT32_EVCTRL_TCINV_Msk = 0x10
	// Bit TCINV.
	TC_COUNT32_EVCTRL_TCINV = 0x10
	// Position of TCEI field.
	TC_COUNT32_EVCTRL_TCEI_Pos = 0x5
	// Bit mask of TCEI field.
	TC_COUNT32_EVCTRL_TCEI_Msk = 0x20
	// Bit TCEI.
	TC_COUNT32_EVCTRL_TCEI = 0x20
	// Position of OVFEO field.
	TC_COUNT32_EVCTRL_OVFEO_Pos = 0x8
	// Bit mask of OVFEO field.
	TC_COUNT32_EVCTRL_OVFEO_Msk = 0x100
	// Bit OVFEO.
	TC_COUNT32_EVCTRL_OVFEO = 0x100
	// Position of MCEO0 field.
	TC_COUNT32_EVCTRL_MCEO0_Pos = 0xc
	// Bit mask of MCEO0 field.
	TC_COUNT32_EVCTRL_MCEO0_Msk = 0x1000
	// Bit MCEO0.
	TC_COUNT32_EVCTRL_MCEO0 = 0x1000
	// Position of MCEO1 field.
	TC_COUNT32_EVCTRL_MCEO1_Pos = 0xd
	// Bit mask of MCEO1 field.
	TC_COUNT32_EVCTRL_MCEO1_Msk = 0x2000
	// Bit MCEO1.
	TC_COUNT32_EVCTRL_MCEO1 = 0x2000

	// INTENCLR: Interrupt Enable Clear
	// Position of OVF field.
	TC_COUNT32_INTENCLR_OVF_Pos = 0x0
	// Bit mask of OVF field.
	TC_COUNT32_INTENCLR_OVF_Msk = 0x1
	// Bit OVF.
	TC_COUNT32_INTENCLR_OVF = 0x1
	// Position of ERR field.
	TC_COUNT32_INTENCLR_ERR_Pos = 0x1
	// Bit mask of ERR field.
	TC_COUNT32_INTENCLR_ERR_Msk = 0x2
	// Bit ERR.
	TC_COUNT32_INTENCLR_ERR = 0x2
	// Position of MC0 field.
	TC_COUNT32_INTENCLR_MC0_Pos = 0x4
	// Bit mask of MC0 field.
	TC_COUNT32_INTENCLR_MC0_Msk = 0x10
	// Bit MC0.
	TC_COUNT32_INTENCLR_MC0 = 0x10
	// Position of MC1 field.
	TC_COUNT32_INTENCLR_MC1_Pos = 0x5
	// Bit mask of MC1 field.
	TC_COUNT32_INTENCLR_MC1_Msk = 0x20
	// Bit MC1.
	TC_COUNT32_INTENCLR_MC1 = 0x20

	// INTENSET: Interrupt Enable Set
	// Position of OVF field.
	TC_COUNT32_INTENSET_OVF_Pos = 0x0
	// Bit mask of OVF field.
	TC_COUNT32_INTENSET_OVF_Msk = 0x1
	// Bit OVF.
	TC_COUNT32_INTENSET_OVF = 0x1
	// Position of ERR field.
	TC_COUNT32_INTENSET_ERR_Pos = 0x1
	// Bit mask of ERR field.
	TC_COUNT32_INTENSET_ERR_Msk = 0x2
	// Bit ERR.
	TC_COUNT32_INTENSET_ERR = 0x2
	// Position of MC0 field.
	TC_COUNT32_INTENSET_MC0_Pos = 0x4
	// Bit mask of MC0 field.
	TC_COUNT32_INTENSET_MC0_Msk = 0x10
	// Bit MC0.
	TC_COUNT32_INTENSET_MC0 = 0x10
	// Position of MC1 field.
	TC_COUNT32_INTENSET_MC1_Pos = 0x5
	// Bit mask of MC1 field.
	TC_COUNT32_INTENSET_MC1_Msk = 0x20
	// Bit MC1.
	TC_COUNT32_INTENSET_MC1 = 0x20

	// INTFLAG: Interrupt Flag Status and Clear
	// Position of OVF field.
	TC_COUNT32_INTFLAG_OVF_Pos = 0x0
	// Bit mask of OVF field.
	TC_COUNT32_INTFLAG_OVF_Msk = 0x1
	// Bit OVF.
	TC_COUNT32_INTFLAG_OVF = 0x1
	// Position of ERR field.
	TC_COUNT32_INTFLAG_ERR_Pos = 0x1
	// Bit mask of ERR field.
	TC_COUNT32_INTFLAG_ERR_Msk = 0x2
	// Bit ERR.
	TC_COUNT32_INTFLAG_ERR = 0x2
	// Position of MC0 field.
	TC_COUNT32_INTFLAG_MC0_Pos = 0x4
	// Bit mask of MC0 field.
	TC_COUNT32_INTFLAG_MC0_Msk = 0x10
	// Bit MC0.
	TC_COUNT32_INTFLAG_MC0 = 0x10
	// Position of MC1 field.
	TC_COUNT32_INTFLAG_MC1_Pos = 0x5
	// Bit mask of MC1 field.
	TC_COUNT32_INTFLAG_MC1_Msk = 0x20
	// Bit MC1.
	TC_COUNT32_INTFLAG_MC1 = 0x20

	// STATUS: Status
	// Position of STOP field.
	TC_COUNT32_STATUS_STOP_Pos = 0x0
	// Bit mask of STOP field.
	TC_COUNT32_STATUS_STOP_Msk = 0x1
	// Bit STOP.
	TC_COUNT32_STATUS_STOP = 0x1
	// Position of SLAVE field.
	TC_COUNT32_STATUS_SLAVE_Pos = 0x1
	// Bit mask of SLAVE field.
	TC_COUNT32_STATUS_SLAVE_Msk = 0x2
	// Bit SLAVE.
	TC_COUNT32_STATUS_SLAVE = 0x2
	// Position of PERBUFV field.
	TC_COUNT32_STATUS_PERBUFV_Pos = 0x3
	// Bit mask of PERBUFV field.
	TC_COUNT32_STATUS_PERBUFV_Msk = 0x8
	// Bit PERBUFV.
	TC_COUNT32_STATUS_PERBUFV = 0x8
	// Position of CCBUFV0 field.
	TC_COUNT32_STATUS_CCBUFV0_Pos = 0x4
	// Bit mask of CCBUFV0 field.
	TC_COUNT32_STATUS_CCBUFV0_Msk = 0x10
	// Bit CCBUFV0.
	TC_COUNT32_STATUS_CCBUFV0 = 0x10
	// Position of CCBUFV1 field.
	TC_COUNT32_STATUS_CCBUFV1_Pos = 0x5
	// Bit mask of CCBUFV1 field.
	TC_COUNT32_STATUS_CCBUFV1_Msk = 0x20
	// Bit CCBUFV1.
	TC_COUNT32_STATUS_CCBUFV1 = 0x20

	// WAVE: Waveform Generation Control
	// Position of WAVEGEN field.
	TC_COUNT32_WAVE_WAVEGEN_Pos = 0x0
	// Bit mask of WAVEGEN field.
	TC_COUNT32_WAVE_WAVEGEN_Msk = 0x3
	// Normal frequency
	TC_COUNT32_WAVE_WAVEGEN_NFRQ = 0x0
	// Match frequency
	TC_COUNT32_WAVE_WAVEGEN_MFRQ = 0x1
	// Normal PWM
	TC_COUNT32_WAVE_WAVEGEN_NPWM = 0x2
	// Match PWM
	TC_COUNT32_WAVE_WAVEGEN_MPWM = 0x3

	// DRVCTRL: Control C
	// Position of INVEN0 field.
	TC_COUNT32_DRVCTRL_INVEN0_Pos = 0x0
	// Bit mask of INVEN0 field.
	TC_COUNT32_DRVCTRL_INVEN0_Msk = 0x1
	// Bit INVEN0.
	TC_COUNT32_DRVCTRL_INVEN0 = 0x1
	// Position of INVEN1 field.
	TC_COUNT32_DRVCTRL_INVEN1_Pos = 0x1
	// Bit mask of INVEN1 field.
	TC_COUNT32_DRVCTRL_INVEN1_Msk = 0x2
	// Bit INVEN1.
	TC_COUNT32_DRVCTRL_INVEN1 = 0x2

	// DBGCTRL: Debug Control
	// Position of DBGRUN field.
	TC_COUNT32_DBGCTRL_DBGRUN_Pos = 0x0
	// Bit mask of DBGRUN field.
	TC_COUNT32_DBGCTRL_DBGRUN_Msk = 0x1
	// Bit DBGRUN.
	TC_COUNT32_DBGCTRL_DBGRUN = 0x1

	// SYNCBUSY: Synchronization Status
	// Position of SWRST field.
	TC_COUNT32_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	TC_COUNT32_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	TC_COUNT32_SYNCBUSY_SWRST = 0x1
	// Position of ENABLE field.
	TC_COUNT32_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	TC_COUNT32_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	TC_COUNT32_SYNCBUSY_ENABLE = 0x2
	// Position of CTRLB field.
	TC_COUNT32_SYNCBUSY_CTRLB_Pos = 0x2
	// Bit mask of CTRLB field.
	TC_COUNT32_SYNCBUSY_CTRLB_Msk = 0x4
	// Bit CTRLB.
	TC_COUNT32_SYNCBUSY_CTRLB = 0x4
	// Position of STATUS field.
	TC_COUNT32_SYNCBUSY_STATUS_Pos = 0x3
	// Bit mask of STATUS field.
	TC_COUNT32_SYNCBUSY_STATUS_Msk = 0x8
	// Bit STATUS.
	TC_COUNT32_SYNCBUSY_STATUS = 0x8
	// Position of COUNT field.
	TC_COUNT32_SYNCBUSY_COUNT_Pos = 0x4
	// Bit mask of COUNT field.
	TC_COUNT32_SYNCBUSY_COUNT_Msk = 0x10
	// Bit COUNT.
	TC_COUNT32_SYNCBUSY_COUNT = 0x10
	// Position of PER field.
	TC_COUNT32_SYNCBUSY_PER_Pos = 0x5
	// Bit mask of PER field.
	TC_COUNT32_SYNCBUSY_PER_Msk = 0x20
	// Bit PER.
	TC_COUNT32_SYNCBUSY_PER = 0x20
	// Position of CC0 field.
	TC_COUNT32_SYNCBUSY_CC0_Pos = 0x6
	// Bit mask of CC0 field.
	TC_COUNT32_SYNCBUSY_CC0_Msk = 0x40
	// Bit CC0.
	TC_COUNT32_SYNCBUSY_CC0 = 0x40
	// Position of CC1 field.
	TC_COUNT32_SYNCBUSY_CC1_Pos = 0x7
	// Bit mask of CC1 field.
	TC_COUNT32_SYNCBUSY_CC1_Msk = 0x80
	// Bit CC1.
	TC_COUNT32_SYNCBUSY_CC1 = 0x80

	// COUNT: COUNT32 Count
	// Position of COUNT field.
	TC_COUNT32_COUNT_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	TC_COUNT32_COUNT_COUNT_Msk = 0xffffffff

	// CC: COUNT32 Compare and Capture
	// Position of CC field.
	TC_COUNT32_CC_CC_Pos = 0x0
	// Bit mask of CC field.
	TC_COUNT32_CC_CC_Msk = 0xffffffff

	// CCBUF: COUNT32 Compare and Capture Buffer
	// Position of CCBUF field.
	TC_COUNT32_CCBUF_CCBUF_Pos = 0x0
	// Bit mask of CCBUF field.
	TC_COUNT32_CCBUF_CCBUF_Msk = 0xffffffff
)

// Constants for TCC0: Timer Counter Control
const (
	// CTRLA: Control A
	// Position of SWRST field.
	TCC_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	TCC_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	TCC_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	TCC_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	TCC_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	TCC_CTRLA_ENABLE = 0x2
	// Position of RESOLUTION field.
	TCC_CTRLA_RESOLUTION_Pos = 0x5
	// Bit mask of RESOLUTION field.
	TCC_CTRLA_RESOLUTION_Msk = 0x60
	// Dithering is disabled
	TCC_CTRLA_RESOLUTION_NONE = 0x0
	// Dithering is done every 16 PWM frames
	TCC_CTRLA_RESOLUTION_DITH4 = 0x1
	// Dithering is done every 32 PWM frames
	TCC_CTRLA_RESOLUTION_DITH5 = 0x2
	// Dithering is done every 64 PWM frames
	TCC_CTRLA_RESOLUTION_DITH6 = 0x3
	// Position of PRESCALER field.
	TCC_CTRLA_PRESCALER_Pos = 0x8
	// Bit mask of PRESCALER field.
	TCC_CTRLA_PRESCALER_Msk = 0x700
	// No division
	TCC_CTRLA_PRESCALER_DIV1 = 0x0
	// Divide by 2
	TCC_CTRLA_PRESCALER_DIV2 = 0x1
	// Divide by 4
	TCC_CTRLA_PRESCALER_DIV4 = 0x2
	// Divide by 8
	TCC_CTRLA_PRESCALER_DIV8 = 0x3
	// Divide by 16
	TCC_CTRLA_PRESCALER_DIV16 = 0x4
	// Divide by 64
	TCC_CTRLA_PRESCALER_DIV64 = 0x5
	// Divide by 256
	TCC_CTRLA_PRESCALER_DIV256 = 0x6
	// Divide by 1024
	TCC_CTRLA_PRESCALER_DIV1024 = 0x7
	// Position of RUNSTDBY field.
	TCC_CTRLA_RUNSTDBY_Pos = 0xb
	// Bit mask of RUNSTDBY field.
	TCC_CTRLA_RUNSTDBY_Msk = 0x800
	// Bit RUNSTDBY.
	TCC_CTRLA_RUNSTDBY = 0x800
	// Position of PRESCSYNC field.
	TCC_CTRLA_PRESCSYNC_Pos = 0xc
	// Bit mask of PRESCSYNC field.
	TCC_CTRLA_PRESCSYNC_Msk = 0x3000
	// Reload or reset counter on next GCLK
	TCC_CTRLA_PRESCSYNC_GCLK = 0x0
	// Reload or reset counter on next prescaler clock
	TCC_CTRLA_PRESCSYNC_PRESC = 0x1
	// Reload or reset counter on next GCLK and reset prescaler counter
	TCC_CTRLA_PRESCSYNC_RESYNC = 0x2
	// Position of ALOCK field.
	TCC_CTRLA_ALOCK_Pos = 0xe
	// Bit mask of ALOCK field.
	TCC_CTRLA_ALOCK_Msk = 0x4000
	// Bit ALOCK.
	TCC_CTRLA_ALOCK = 0x4000
	// Position of MSYNC field.
	TCC_CTRLA_MSYNC_Pos = 0xf
	// Bit mask of MSYNC field.
	TCC_CTRLA_MSYNC_Msk = 0x8000
	// Bit MSYNC.
	TCC_CTRLA_MSYNC = 0x8000
	// Position of DMAOS field.
	TCC_CTRLA_DMAOS_Pos = 0x17
	// Bit mask of DMAOS field.
	TCC_CTRLA_DMAOS_Msk = 0x800000
	// Bit DMAOS.
	TCC_CTRLA_DMAOS = 0x800000
	// Position of CPTEN0 field.
	TCC_CTRLA_CPTEN0_Pos = 0x18
	// Bit mask of CPTEN0 field.
	TCC_CTRLA_CPTEN0_Msk = 0x1000000
	// Bit CPTEN0.
	TCC_CTRLA_CPTEN0 = 0x1000000
	// Position of CPTEN1 field.
	TCC_CTRLA_CPTEN1_Pos = 0x19
	// Bit mask of CPTEN1 field.
	TCC_CTRLA_CPTEN1_Msk = 0x2000000
	// Bit CPTEN1.
	TCC_CTRLA_CPTEN1 = 0x2000000
	// Position of CPTEN2 field.
	TCC_CTRLA_CPTEN2_Pos = 0x1a
	// Bit mask of CPTEN2 field.
	TCC_CTRLA_CPTEN2_Msk = 0x4000000
	// Bit CPTEN2.
	TCC_CTRLA_CPTEN2 = 0x4000000
	// Position of CPTEN3 field.
	TCC_CTRLA_CPTEN3_Pos = 0x1b
	// Bit mask of CPTEN3 field.
	TCC_CTRLA_CPTEN3_Msk = 0x8000000
	// Bit CPTEN3.
	TCC_CTRLA_CPTEN3 = 0x8000000
	// Position of CPTEN4 field.
	TCC_CTRLA_CPTEN4_Pos = 0x1c
	// Bit mask of CPTEN4 field.
	TCC_CTRLA_CPTEN4_Msk = 0x10000000
	// Bit CPTEN4.
	TCC_CTRLA_CPTEN4 = 0x10000000
	// Position of CPTEN5 field.
	TCC_CTRLA_CPTEN5_Pos = 0x1d
	// Bit mask of CPTEN5 field.
	TCC_CTRLA_CPTEN5_Msk = 0x20000000
	// Bit CPTEN5.
	TCC_CTRLA_CPTEN5 = 0x20000000

	// CTRLBCLR: Control B Clear
	// Position of DIR field.
	TCC_CTRLBCLR_DIR_Pos = 0x0
	// Bit mask of DIR field.
	TCC_CTRLBCLR_DIR_Msk = 0x1
	// Bit DIR.
	TCC_CTRLBCLR_DIR = 0x1
	// Position of LUPD field.
	TCC_CTRLBCLR_LUPD_Pos = 0x1
	// Bit mask of LUPD field.
	TCC_CTRLBCLR_LUPD_Msk = 0x2
	// Bit LUPD.
	TCC_CTRLBCLR_LUPD = 0x2
	// Position of ONESHOT field.
	TCC_CTRLBCLR_ONESHOT_Pos = 0x2
	// Bit mask of ONESHOT field.
	TCC_CTRLBCLR_ONESHOT_Msk = 0x4
	// Bit ONESHOT.
	TCC_CTRLBCLR_ONESHOT = 0x4
	// Position of IDXCMD field.
	TCC_CTRLBCLR_IDXCMD_Pos = 0x3
	// Bit mask of IDXCMD field.
	TCC_CTRLBCLR_IDXCMD_Msk = 0x18
	// Command disabled: Index toggles between cycles A and B
	TCC_CTRLBCLR_IDXCMD_DISABLE = 0x0
	// Set index: cycle B will be forced in the next cycle
	TCC_CTRLBCLR_IDXCMD_SET = 0x1
	// Clear index: cycle A will be forced in the next cycle
	TCC_CTRLBCLR_IDXCMD_CLEAR = 0x2
	// Hold index: the next cycle will be the same as the current cycle
	TCC_CTRLBCLR_IDXCMD_HOLD = 0x3
	// Position of CMD field.
	TCC_CTRLBCLR_CMD_Pos = 0x5
	// Bit mask of CMD field.
	TCC_CTRLBCLR_CMD_Msk = 0xe0
	// No action
	TCC_CTRLBCLR_CMD_NONE = 0x0
	// Clear start, restart or retrigger
	TCC_CTRLBCLR_CMD_RETRIGGER = 0x1
	// Force stop
	TCC_CTRLBCLR_CMD_STOP = 0x2
	// Force update or double buffered registers
	TCC_CTRLBCLR_CMD_UPDATE = 0x3
	// Force COUNT read synchronization
	TCC_CTRLBCLR_CMD_READSYNC = 0x4
	// One-shot DMA trigger
	TCC_CTRLBCLR_CMD_DMAOS = 0x5

	// CTRLBSET: Control B Set
	// Position of DIR field.
	TCC_CTRLBSET_DIR_Pos = 0x0
	// Bit mask of DIR field.
	TCC_CTRLBSET_DIR_Msk = 0x1
	// Bit DIR.
	TCC_CTRLBSET_DIR = 0x1
	// Position of LUPD field.
	TCC_CTRLBSET_LUPD_Pos = 0x1
	// Bit mask of LUPD field.
	TCC_CTRLBSET_LUPD_Msk = 0x2
	// Bit LUPD.
	TCC_CTRLBSET_LUPD = 0x2
	// Position of ONESHOT field.
	TCC_CTRLBSET_ONESHOT_Pos = 0x2
	// Bit mask of ONESHOT field.
	TCC_CTRLBSET_ONESHOT_Msk = 0x4
	// Bit ONESHOT.
	TCC_CTRLBSET_ONESHOT = 0x4
	// Position of IDXCMD field.
	TCC_CTRLBSET_IDXCMD_Pos = 0x3
	// Bit mask of IDXCMD field.
	TCC_CTRLBSET_IDXCMD_Msk = 0x18
	// Command disabled: Index toggles between cycles A and B
	TCC_CTRLBSET_IDXCMD_DISABLE = 0x0
	// Set index: cycle B will be forced in the next cycle
	TCC_CTRLBSET_IDXCMD_SET = 0x1
	// Clear index: cycle A will be forced in the next cycle
	TCC_CTRLBSET_IDXCMD_CLEAR = 0x2
	// Hold index: the next cycle will be the same as the current cycle
	TCC_CTRLBSET_IDXCMD_HOLD = 0x3
	// Position of CMD field.
	TCC_CTRLBSET_CMD_Pos = 0x5
	// Bit mask of CMD field.
	TCC_CTRLBSET_CMD_Msk = 0xe0
	// No action
	TCC_CTRLBSET_CMD_NONE = 0x0
	// Clear start, restart or retrigger
	TCC_CTRLBSET_CMD_RETRIGGER = 0x1
	// Force stop
	TCC_CTRLBSET_CMD_STOP = 0x2
	// Force update or double buffered registers
	TCC_CTRLBSET_CMD_UPDATE = 0x3
	// Force COUNT read synchronization
	TCC_CTRLBSET_CMD_READSYNC = 0x4
	// One-shot DMA trigger
	TCC_CTRLBSET_CMD_DMAOS = 0x5

	// SYNCBUSY: Synchronization Busy
	// Position of SWRST field.
	TCC_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	TCC_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	TCC_SYNCBUSY_SWRST = 0x1
	// Position of ENABLE field.
	TCC_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	TCC_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	TCC_SYNCBUSY_ENABLE = 0x2
	// Position of CTRLB field.
	TCC_SYNCBUSY_CTRLB_Pos = 0x2
	// Bit mask of CTRLB field.
	TCC_SYNCBUSY_CTRLB_Msk = 0x4
	// Bit CTRLB.
	TCC_SYNCBUSY_CTRLB = 0x4
	// Position of STATUS field.
	TCC_SYNCBUSY_STATUS_Pos = 0x3
	// Bit mask of STATUS field.
	TCC_SYNCBUSY_STATUS_Msk = 0x8
	// Bit STATUS.
	TCC_SYNCBUSY_STATUS = 0x8
	// Position of COUNT field.
	TCC_SYNCBUSY_COUNT_Pos = 0x4
	// Bit mask of COUNT field.
	TCC_SYNCBUSY_COUNT_Msk = 0x10
	// Bit COUNT.
	TCC_SYNCBUSY_COUNT = 0x10
	// Position of PATT field.
	TCC_SYNCBUSY_PATT_Pos = 0x5
	// Bit mask of PATT field.
	TCC_SYNCBUSY_PATT_Msk = 0x20
	// Bit PATT.
	TCC_SYNCBUSY_PATT = 0x20
	// Position of WAVE field.
	TCC_SYNCBUSY_WAVE_Pos = 0x6
	// Bit mask of WAVE field.
	TCC_SYNCBUSY_WAVE_Msk = 0x40
	// Bit WAVE.
	TCC_SYNCBUSY_WAVE = 0x40
	// Position of PER field.
	TCC_SYNCBUSY_PER_Pos = 0x7
	// Bit mask of PER field.
	TCC_SYNCBUSY_PER_Msk = 0x80
	// Bit PER.
	TCC_SYNCBUSY_PER = 0x80
	// Position of CC0 field.
	TCC_SYNCBUSY_CC0_Pos = 0x8
	// Bit mask of CC0 field.
	TCC_SYNCBUSY_CC0_Msk = 0x100
	// Bit CC0.
	TCC_SYNCBUSY_CC0 = 0x100
	// Position of CC1 field.
	TCC_SYNCBUSY_CC1_Pos = 0x9
	// Bit mask of CC1 field.
	TCC_SYNCBUSY_CC1_Msk = 0x200
	// Bit CC1.
	TCC_SYNCBUSY_CC1 = 0x200
	// Position of CC2 field.
	TCC_SYNCBUSY_CC2_Pos = 0xa
	// Bit mask of CC2 field.
	TCC_SYNCBUSY_CC2_Msk = 0x400
	// Bit CC2.
	TCC_SYNCBUSY_CC2 = 0x400
	// Position of CC3 field.
	TCC_SYNCBUSY_CC3_Pos = 0xb
	// Bit mask of CC3 field.
	TCC_SYNCBUSY_CC3_Msk = 0x800
	// Bit CC3.
	TCC_SYNCBUSY_CC3 = 0x800
	// Position of CC4 field.
	TCC_SYNCBUSY_CC4_Pos = 0xc
	// Bit mask of CC4 field.
	TCC_SYNCBUSY_CC4_Msk = 0x1000
	// Bit CC4.
	TCC_SYNCBUSY_CC4 = 0x1000
	// Position of CC5 field.
	TCC_SYNCBUSY_CC5_Pos = 0xd
	// Bit mask of CC5 field.
	TCC_SYNCBUSY_CC5_Msk = 0x2000
	// Bit CC5.
	TCC_SYNCBUSY_CC5 = 0x2000

	// FCTRLA: Recoverable Fault A Configuration
	// Position of SRC field.
	TCC_FCTRLA_SRC_Pos = 0x0
	// Bit mask of SRC field.
	TCC_FCTRLA_SRC_Msk = 0x3
	// Fault input disabled
	TCC_FCTRLA_SRC_DISABLE = 0x0
	// MCEx (x=0,1) event input
	TCC_FCTRLA_SRC_ENABLE = 0x1
	// Inverted MCEx (x=0,1) event input
	TCC_FCTRLA_SRC_INVERT = 0x2
	// Alternate fault (A or B) state at the end of the previous period
	TCC_FCTRLA_SRC_ALTFAULT = 0x3
	// Position of KEEP field.
	TCC_FCTRLA_KEEP_Pos = 0x3
	// Bit mask of KEEP field.
	TCC_FCTRLA_KEEP_Msk = 0x8
	// Bit KEEP.
	TCC_FCTRLA_KEEP = 0x8
	// Position of QUAL field.
	TCC_FCTRLA_QUAL_Pos = 0x4
	// Bit mask of QUAL field.
	TCC_FCTRLA_QUAL_Msk = 0x10
	// Bit QUAL.
	TCC_FCTRLA_QUAL = 0x10
	// Position of BLANK field.
	TCC_FCTRLA_BLANK_Pos = 0x5
	// Bit mask of BLANK field.
	TCC_FCTRLA_BLANK_Msk = 0x60
	// Blanking applied from start of the ramp
	TCC_FCTRLA_BLANK_START = 0x0
	// Blanking applied from rising edge of the output waveform
	TCC_FCTRLA_BLANK_RISE = 0x1
	// Blanking applied from falling edge of the output waveform
	TCC_FCTRLA_BLANK_FALL = 0x2
	// Blanking applied from each toggle of the output waveform
	TCC_FCTRLA_BLANK_BOTH = 0x3
	// Position of RESTART field.
	TCC_FCTRLA_RESTART_Pos = 0x7
	// Bit mask of RESTART field.
	TCC_FCTRLA_RESTART_Msk = 0x80
	// Bit RESTART.
	TCC_FCTRLA_RESTART = 0x80
	// Position of HALT field.
	TCC_FCTRLA_HALT_Pos = 0x8
	// Bit mask of HALT field.
	TCC_FCTRLA_HALT_Msk = 0x300
	// Halt action disabled
	TCC_FCTRLA_HALT_DISABLE = 0x0
	// Hardware halt action
	TCC_FCTRLA_HALT_HW = 0x1
	// Software halt action
	TCC_FCTRLA_HALT_SW = 0x2
	// Non-recoverable fault
	TCC_FCTRLA_HALT_NR = 0x3
	// Position of CHSEL field.
	TCC_FCTRLA_CHSEL_Pos = 0xa
	// Bit mask of CHSEL field.
	TCC_FCTRLA_CHSEL_Msk = 0xc00
	// Capture value stored in channel 0
	TCC_FCTRLA_CHSEL_CC0 = 0x0
	// Capture value stored in channel 1
	TCC_FCTRLA_CHSEL_CC1 = 0x1
	// Capture value stored in channel 2
	TCC_FCTRLA_CHSEL_CC2 = 0x2
	// Capture value stored in channel 3
	TCC_FCTRLA_CHSEL_CC3 = 0x3
	// Position of CAPTURE field.
	TCC_FCTRLA_CAPTURE_Pos = 0xc
	// Bit mask of CAPTURE field.
	TCC_FCTRLA_CAPTURE_Msk = 0x7000
	// No capture
	TCC_FCTRLA_CAPTURE_DISABLE = 0x0
	// Capture on fault
	TCC_FCTRLA_CAPTURE_CAPT = 0x1
	// Minimum capture
	TCC_FCTRLA_CAPTURE_CAPTMIN = 0x2
	// Maximum capture
	TCC_FCTRLA_CAPTURE_CAPTMAX = 0x3
	// Minimum local detection
	TCC_FCTRLA_CAPTURE_LOCMIN = 0x4
	// Maximum local detection
	TCC_FCTRLA_CAPTURE_LOCMAX = 0x5
	// Minimum and maximum local detection
	TCC_FCTRLA_CAPTURE_DERIV0 = 0x6
	// Capture with ramp index as MSB value
	TCC_FCTRLA_CAPTURE_CAPTMARK = 0x7
	// Position of BLANKPRESC field.
	TCC_FCTRLA_BLANKPRESC_Pos = 0xf
	// Bit mask of BLANKPRESC field.
	TCC_FCTRLA_BLANKPRESC_Msk = 0x8000
	// Bit BLANKPRESC.
	TCC_FCTRLA_BLANKPRESC = 0x8000
	// Position of BLANKVAL field.
	TCC_FCTRLA_BLANKVAL_Pos = 0x10
	// Bit mask of BLANKVAL field.
	TCC_FCTRLA_BLANKVAL_Msk = 0xff0000
	// Position of FILTERVAL field.
	TCC_FCTRLA_FILTERVAL_Pos = 0x18
	// Bit mask of FILTERVAL field.
	TCC_FCTRLA_FILTERVAL_Msk = 0xf000000

	// FCTRLB: Recoverable Fault B Configuration
	// Position of SRC field.
	TCC_FCTRLB_SRC_Pos = 0x0
	// Bit mask of SRC field.
	TCC_FCTRLB_SRC_Msk = 0x3
	// Fault input disabled
	TCC_FCTRLB_SRC_DISABLE = 0x0
	// MCEx (x=0,1) event input
	TCC_FCTRLB_SRC_ENABLE = 0x1
	// Inverted MCEx (x=0,1) event input
	TCC_FCTRLB_SRC_INVERT = 0x2
	// Alternate fault (A or B) state at the end of the previous period
	TCC_FCTRLB_SRC_ALTFAULT = 0x3
	// Position of KEEP field.
	TCC_FCTRLB_KEEP_Pos = 0x3
	// Bit mask of KEEP field.
	TCC_FCTRLB_KEEP_Msk = 0x8
	// Bit KEEP.
	TCC_FCTRLB_KEEP = 0x8
	// Position of QUAL field.
	TCC_FCTRLB_QUAL_Pos = 0x4
	// Bit mask of QUAL field.
	TCC_FCTRLB_QUAL_Msk = 0x10
	// Bit QUAL.
	TCC_FCTRLB_QUAL = 0x10
	// Position of BLANK field.
	TCC_FCTRLB_BLANK_Pos = 0x5
	// Bit mask of BLANK field.
	TCC_FCTRLB_BLANK_Msk = 0x60
	// Blanking applied from start of the ramp
	TCC_FCTRLB_BLANK_START = 0x0
	// Blanking applied from rising edge of the output waveform
	TCC_FCTRLB_BLANK_RISE = 0x1
	// Blanking applied from falling edge of the output waveform
	TCC_FCTRLB_BLANK_FALL = 0x2
	// Blanking applied from each toggle of the output waveform
	TCC_FCTRLB_BLANK_BOTH = 0x3
	// Position of RESTART field.
	TCC_FCTRLB_RESTART_Pos = 0x7
	// Bit mask of RESTART field.
	TCC_FCTRLB_RESTART_Msk = 0x80
	// Bit RESTART.
	TCC_FCTRLB_RESTART = 0x80
	// Position of HALT field.
	TCC_FCTRLB_HALT_Pos = 0x8
	// Bit mask of HALT field.
	TCC_FCTRLB_HALT_Msk = 0x300
	// Halt action disabled
	TCC_FCTRLB_HALT_DISABLE = 0x0
	// Hardware halt action
	TCC_FCTRLB_HALT_HW = 0x1
	// Software halt action
	TCC_FCTRLB_HALT_SW = 0x2
	// Non-recoverable fault
	TCC_FCTRLB_HALT_NR = 0x3
	// Position of CHSEL field.
	TCC_FCTRLB_CHSEL_Pos = 0xa
	// Bit mask of CHSEL field.
	TCC_FCTRLB_CHSEL_Msk = 0xc00
	// Capture value stored in channel 0
	TCC_FCTRLB_CHSEL_CC0 = 0x0
	// Capture value stored in channel 1
	TCC_FCTRLB_CHSEL_CC1 = 0x1
	// Capture value stored in channel 2
	TCC_FCTRLB_CHSEL_CC2 = 0x2
	// Capture value stored in channel 3
	TCC_FCTRLB_CHSEL_CC3 = 0x3
	// Position of CAPTURE field.
	TCC_FCTRLB_CAPTURE_Pos = 0xc
	// Bit mask of CAPTURE field.
	TCC_FCTRLB_CAPTURE_Msk = 0x7000
	// No capture
	TCC_FCTRLB_CAPTURE_DISABLE = 0x0
	// Capture on fault
	TCC_FCTRLB_CAPTURE_CAPT = 0x1
	// Minimum capture
	TCC_FCTRLB_CAPTURE_CAPTMIN = 0x2
	// Maximum capture
	TCC_FCTRLB_CAPTURE_CAPTMAX = 0x3
	// Minimum local detection
	TCC_FCTRLB_CAPTURE_LOCMIN = 0x4
	// Maximum local detection
	TCC_FCTRLB_CAPTURE_LOCMAX = 0x5
	// Minimum and maximum local detection
	TCC_FCTRLB_CAPTURE_DERIV0 = 0x6
	// Capture with ramp index as MSB value
	TCC_FCTRLB_CAPTURE_CAPTMARK = 0x7
	// Position of BLANKPRESC field.
	TCC_FCTRLB_BLANKPRESC_Pos = 0xf
	// Bit mask of BLANKPRESC field.
	TCC_FCTRLB_BLANKPRESC_Msk = 0x8000
	// Bit BLANKPRESC.
	TCC_FCTRLB_BLANKPRESC = 0x8000
	// Position of BLANKVAL field.
	TCC_FCTRLB_BLANKVAL_Pos = 0x10
	// Bit mask of BLANKVAL field.
	TCC_FCTRLB_BLANKVAL_Msk = 0xff0000
	// Position of FILTERVAL field.
	TCC_FCTRLB_FILTERVAL_Pos = 0x18
	// Bit mask of FILTERVAL field.
	TCC_FCTRLB_FILTERVAL_Msk = 0xf000000

	// WEXCTRL: Waveform Extension Configuration
	// Position of OTMX field.
	TCC_WEXCTRL_OTMX_Pos = 0x0
	// Bit mask of OTMX field.
	TCC_WEXCTRL_OTMX_Msk = 0x3
	// Position of DTIEN0 field.
	TCC_WEXCTRL_DTIEN0_Pos = 0x8
	// Bit mask of DTIEN0 field.
	TCC_WEXCTRL_DTIEN0_Msk = 0x100
	// Bit DTIEN0.
	TCC_WEXCTRL_DTIEN0 = 0x100
	// Position of DTIEN1 field.
	TCC_WEXCTRL_DTIEN1_Pos = 0x9
	// Bit mask of DTIEN1 field.
	TCC_WEXCTRL_DTIEN1_Msk = 0x200
	// Bit DTIEN1.
	TCC_WEXCTRL_DTIEN1 = 0x200
	// Position of DTIEN2 field.
	TCC_WEXCTRL_DTIEN2_Pos = 0xa
	// Bit mask of DTIEN2 field.
	TCC_WEXCTRL_DTIEN2_Msk = 0x400
	// Bit DTIEN2.
	TCC_WEXCTRL_DTIEN2 = 0x400
	// Position of DTIEN3 field.
	TCC_WEXCTRL_DTIEN3_Pos = 0xb
	// Bit mask of DTIEN3 field.
	TCC_WEXCTRL_DTIEN3_Msk = 0x800
	// Bit DTIEN3.
	TCC_WEXCTRL_DTIEN3 = 0x800
	// Position of DTLS field.
	TCC_WEXCTRL_DTLS_Pos = 0x10
	// Bit mask of DTLS field.
	TCC_WEXCTRL_DTLS_Msk = 0xff0000
	// Position of DTHS field.
	TCC_WEXCTRL_DTHS_Pos = 0x18
	// Bit mask of DTHS field.
	TCC_WEXCTRL_DTHS_Msk = 0xff000000

	// DRVCTRL: Driver Control
	// Position of NRE0 field.
	TCC_DRVCTRL_NRE0_Pos = 0x0
	// Bit mask of NRE0 field.
	TCC_DRVCTRL_NRE0_Msk = 0x1
	// Bit NRE0.
	TCC_DRVCTRL_NRE0 = 0x1
	// Position of NRE1 field.
	TCC_DRVCTRL_NRE1_Pos = 0x1
	// Bit mask of NRE1 field.
	TCC_DRVCTRL_NRE1_Msk = 0x2
	// Bit NRE1.
	TCC_DRVCTRL_NRE1 = 0x2
	// Position of NRE2 field.
	TCC_DRVCTRL_NRE2_Pos = 0x2
	// Bit mask of NRE2 field.
	TCC_DRVCTRL_NRE2_Msk = 0x4
	// Bit NRE2.
	TCC_DRVCTRL_NRE2 = 0x4
	// Position of NRE3 field.
	TCC_DRVCTRL_NRE3_Pos = 0x3
	// Bit mask of NRE3 field.
	TCC_DRVCTRL_NRE3_Msk = 0x8
	// Bit NRE3.
	TCC_DRVCTRL_NRE3 = 0x8
	// Position of NRE4 field.
	TCC_DRVCTRL_NRE4_Pos = 0x4
	// Bit mask of NRE4 field.
	TCC_DRVCTRL_NRE4_Msk = 0x10
	// Bit NRE4.
	TCC_DRVCTRL_NRE4 = 0x10
	// Position of NRE5 field.
	TCC_DRVCTRL_NRE5_Pos = 0x5
	// Bit mask of NRE5 field.
	TCC_DRVCTRL_NRE5_Msk = 0x20
	// Bit NRE5.
	TCC_DRVCTRL_NRE5 = 0x20
	// Position of NRE6 field.
	TCC_DRVCTRL_NRE6_Pos = 0x6
	// Bit mask of NRE6 field.
	TCC_DRVCTRL_NRE6_Msk = 0x40
	// Bit NRE6.
	TCC_DRVCTRL_NRE6 = 0x40
	// Position of NRE7 field.
	TCC_DRVCTRL_NRE7_Pos = 0x7
	// Bit mask of NRE7 field.
	TCC_DRVCTRL_NRE7_Msk = 0x80
	// Bit NRE7.
	TCC_DRVCTRL_NRE7 = 0x80
	// Position of NRV0 field.
	TCC_DRVCTRL_NRV0_Pos = 0x8
	// Bit mask of NRV0 field.
	TCC_DRVCTRL_NRV0_Msk = 0x100
	// Bit NRV0.
	TCC_DRVCTRL_NRV0 = 0x100
	// Position of NRV1 field.
	TCC_DRVCTRL_NRV1_Pos = 0x9
	// Bit mask of NRV1 field.
	TCC_DRVCTRL_NRV1_Msk = 0x200
	// Bit NRV1.
	TCC_DRVCTRL_NRV1 = 0x200
	// Position of NRV2 field.
	TCC_DRVCTRL_NRV2_Pos = 0xa
	// Bit mask of NRV2 field.
	TCC_DRVCTRL_NRV2_Msk = 0x400
	// Bit NRV2.
	TCC_DRVCTRL_NRV2 = 0x400
	// Position of NRV3 field.
	TCC_DRVCTRL_NRV3_Pos = 0xb
	// Bit mask of NRV3 field.
	TCC_DRVCTRL_NRV3_Msk = 0x800
	// Bit NRV3.
	TCC_DRVCTRL_NRV3 = 0x800
	// Position of NRV4 field.
	TCC_DRVCTRL_NRV4_Pos = 0xc
	// Bit mask of NRV4 field.
	TCC_DRVCTRL_NRV4_Msk = 0x1000
	// Bit NRV4.
	TCC_DRVCTRL_NRV4 = 0x1000
	// Position of NRV5 field.
	TCC_DRVCTRL_NRV5_Pos = 0xd
	// Bit mask of NRV5 field.
	TCC_DRVCTRL_NRV5_Msk = 0x2000
	// Bit NRV5.
	TCC_DRVCTRL_NRV5 = 0x2000
	// Position of NRV6 field.
	TCC_DRVCTRL_NRV6_Pos = 0xe
	// Bit mask of NRV6 field.
	TCC_DRVCTRL_NRV6_Msk = 0x4000
	// Bit NRV6.
	TCC_DRVCTRL_NRV6 = 0x4000
	// Position of NRV7 field.
	TCC_DRVCTRL_NRV7_Pos = 0xf
	// Bit mask of NRV7 field.
	TCC_DRVCTRL_NRV7_Msk = 0x8000
	// Bit NRV7.
	TCC_DRVCTRL_NRV7 = 0x8000
	// Position of INVEN0 field.
	TCC_DRVCTRL_INVEN0_Pos = 0x10
	// Bit mask of INVEN0 field.
	TCC_DRVCTRL_INVEN0_Msk = 0x10000
	// Bit INVEN0.
	TCC_DRVCTRL_INVEN0 = 0x10000
	// Position of INVEN1 field.
	TCC_DRVCTRL_INVEN1_Pos = 0x11
	// Bit mask of INVEN1 field.
	TCC_DRVCTRL_INVEN1_Msk = 0x20000
	// Bit INVEN1.
	TCC_DRVCTRL_INVEN1 = 0x20000
	// Position of INVEN2 field.
	TCC_DRVCTRL_INVEN2_Pos = 0x12
	// Bit mask of INVEN2 field.
	TCC_DRVCTRL_INVEN2_Msk = 0x40000
	// Bit INVEN2.
	TCC_DRVCTRL_INVEN2 = 0x40000
	// Position of INVEN3 field.
	TCC_DRVCTRL_INVEN3_Pos = 0x13
	// Bit mask of INVEN3 field.
	TCC_DRVCTRL_INVEN3_Msk = 0x80000
	// Bit INVEN3.
	TCC_DRVCTRL_INVEN3 = 0x80000
	// Position of INVEN4 field.
	TCC_DRVCTRL_INVEN4_Pos = 0x14
	// Bit mask of INVEN4 field.
	TCC_DRVCTRL_INVEN4_Msk = 0x100000
	// Bit INVEN4.
	TCC_DRVCTRL_INVEN4 = 0x100000
	// Position of INVEN5 field.
	TCC_DRVCTRL_INVEN5_Pos = 0x15
	// Bit mask of INVEN5 field.
	TCC_DRVCTRL_INVEN5_Msk = 0x200000
	// Bit INVEN5.
	TCC_DRVCTRL_INVEN5 = 0x200000
	// Position of INVEN6 field.
	TCC_DRVCTRL_INVEN6_Pos = 0x16
	// Bit mask of INVEN6 field.
	TCC_DRVCTRL_INVEN6_Msk = 0x400000
	// Bit INVEN6.
	TCC_DRVCTRL_INVEN6 = 0x400000
	// Position of INVEN7 field.
	TCC_DRVCTRL_INVEN7_Pos = 0x17
	// Bit mask of INVEN7 field.
	TCC_DRVCTRL_INVEN7_Msk = 0x800000
	// Bit INVEN7.
	TCC_DRVCTRL_INVEN7 = 0x800000
	// Position of FILTERVAL0 field.
	TCC_DRVCTRL_FILTERVAL0_Pos = 0x18
	// Bit mask of FILTERVAL0 field.
	TCC_DRVCTRL_FILTERVAL0_Msk = 0xf000000
	// Position of FILTERVAL1 field.
	TCC_DRVCTRL_FILTERVAL1_Pos = 0x1c
	// Bit mask of FILTERVAL1 field.
	TCC_DRVCTRL_FILTERVAL1_Msk = 0xf0000000

	// DBGCTRL: Debug Control
	// Position of DBGRUN field.
	TCC_DBGCTRL_DBGRUN_Pos = 0x0
	// Bit mask of DBGRUN field.
	TCC_DBGCTRL_DBGRUN_Msk = 0x1
	// Bit DBGRUN.
	TCC_DBGCTRL_DBGRUN = 0x1
	// Position of FDDBD field.
	TCC_DBGCTRL_FDDBD_Pos = 0x2
	// Bit mask of FDDBD field.
	TCC_DBGCTRL_FDDBD_Msk = 0x4
	// Bit FDDBD.
	TCC_DBGCTRL_FDDBD = 0x4

	// EVCTRL: Event Control
	// Position of EVACT0 field.
	TCC_EVCTRL_EVACT0_Pos = 0x0
	// Bit mask of EVACT0 field.
	TCC_EVCTRL_EVACT0_Msk = 0x7
	// Event action disabled
	TCC_EVCTRL_EVACT0_OFF = 0x0
	// Start, restart or re-trigger counter on event
	TCC_EVCTRL_EVACT0_RETRIGGER = 0x1
	// Count on event
	TCC_EVCTRL_EVACT0_COUNTEV = 0x2
	// Start counter on event
	TCC_EVCTRL_EVACT0_START = 0x3
	// Increment counter on event
	TCC_EVCTRL_EVACT0_INC = 0x4
	// Count on active state of asynchronous event
	TCC_EVCTRL_EVACT0_COUNT = 0x5
	// Stamp capture
	TCC_EVCTRL_EVACT0_STAMP = 0x6
	// Non-recoverable fault
	TCC_EVCTRL_EVACT0_FAULT = 0x7
	// Position of EVACT1 field.
	TCC_EVCTRL_EVACT1_Pos = 0x3
	// Bit mask of EVACT1 field.
	TCC_EVCTRL_EVACT1_Msk = 0x38
	// Event action disabled
	TCC_EVCTRL_EVACT1_OFF = 0x0
	// Re-trigger counter on event
	TCC_EVCTRL_EVACT1_RETRIGGER = 0x1
	// Direction control
	TCC_EVCTRL_EVACT1_DIR = 0x2
	// Stop counter on event
	TCC_EVCTRL_EVACT1_STOP = 0x3
	// Decrement counter on event
	TCC_EVCTRL_EVACT1_DEC = 0x4
	// Period capture value in CC0 register, pulse width capture value in CC1 register
	TCC_EVCTRL_EVACT1_PPW = 0x5
	// Period capture value in CC1 register, pulse width capture value in CC0 register
	TCC_EVCTRL_EVACT1_PWP = 0x6
	// Non-recoverable fault
	TCC_EVCTRL_EVACT1_FAULT = 0x7
	// Position of CNTSEL field.
	TCC_EVCTRL_CNTSEL_Pos = 0x6
	// Bit mask of CNTSEL field.
	TCC_EVCTRL_CNTSEL_Msk = 0xc0
	// An interrupt/event is generated when a new counter cycle starts
	TCC_EVCTRL_CNTSEL_START = 0x0
	// An interrupt/event is generated when a counter cycle ends
	TCC_EVCTRL_CNTSEL_END = 0x1
	// An interrupt/event is generated when a counter cycle ends, except for the first and last cycles
	TCC_EVCTRL_CNTSEL_BETWEEN = 0x2
	// An interrupt/event is generated when a new counter cycle starts or a counter cycle ends
	TCC_EVCTRL_CNTSEL_BOUNDARY = 0x3
	// Position of OVFEO field.
	TCC_EVCTRL_OVFEO_Pos = 0x8
	// Bit mask of OVFEO field.
	TCC_EVCTRL_OVFEO_Msk = 0x100
	// Bit OVFEO.
	TCC_EVCTRL_OVFEO = 0x100
	// Position of TRGEO field.
	TCC_EVCTRL_TRGEO_Pos = 0x9
	// Bit mask of TRGEO field.
	TCC_EVCTRL_TRGEO_Msk = 0x200
	// Bit TRGEO.
	TCC_EVCTRL_TRGEO = 0x200
	// Position of CNTEO field.
	TCC_EVCTRL_CNTEO_Pos = 0xa
	// Bit mask of CNTEO field.
	TCC_EVCTRL_CNTEO_Msk = 0x400
	// Bit CNTEO.
	TCC_EVCTRL_CNTEO = 0x400
	// Position of TCINV0 field.
	TCC_EVCTRL_TCINV0_Pos = 0xc
	// Bit mask of TCINV0 field.
	TCC_EVCTRL_TCINV0_Msk = 0x1000
	// Bit TCINV0.
	TCC_EVCTRL_TCINV0 = 0x1000
	// Position of TCINV1 field.
	TCC_EVCTRL_TCINV1_Pos = 0xd
	// Bit mask of TCINV1 field.
	TCC_EVCTRL_TCINV1_Msk = 0x2000
	// Bit TCINV1.
	TCC_EVCTRL_TCINV1 = 0x2000
	// Position of TCEI0 field.
	TCC_EVCTRL_TCEI0_Pos = 0xe
	// Bit mask of TCEI0 field.
	TCC_EVCTRL_TCEI0_Msk = 0x4000
	// Bit TCEI0.
	TCC_EVCTRL_TCEI0 = 0x4000
	// Position of TCEI1 field.
	TCC_EVCTRL_TCEI1_Pos = 0xf
	// Bit mask of TCEI1 field.
	TCC_EVCTRL_TCEI1_Msk = 0x8000
	// Bit TCEI1.
	TCC_EVCTRL_TCEI1 = 0x8000
	// Position of MCEI0 field.
	TCC_EVCTRL_MCEI0_Pos = 0x10
	// Bit mask of MCEI0 field.
	TCC_EVCTRL_MCEI0_Msk = 0x10000
	// Bit MCEI0.
	TCC_EVCTRL_MCEI0 = 0x10000
	// Position of MCEI1 field.
	TCC_EVCTRL_MCEI1_Pos = 0x11
	// Bit mask of MCEI1 field.
	TCC_EVCTRL_MCEI1_Msk = 0x20000
	// Bit MCEI1.
	TCC_EVCTRL_MCEI1 = 0x20000
	// Position of MCEI2 field.
	TCC_EVCTRL_MCEI2_Pos = 0x12
	// Bit mask of MCEI2 field.
	TCC_EVCTRL_MCEI2_Msk = 0x40000
	// Bit MCEI2.
	TCC_EVCTRL_MCEI2 = 0x40000
	// Position of MCEI3 field.
	TCC_EVCTRL_MCEI3_Pos = 0x13
	// Bit mask of MCEI3 field.
	TCC_EVCTRL_MCEI3_Msk = 0x80000
	// Bit MCEI3.
	TCC_EVCTRL_MCEI3 = 0x80000
	// Position of MCEI4 field.
	TCC_EVCTRL_MCEI4_Pos = 0x14
	// Bit mask of MCEI4 field.
	TCC_EVCTRL_MCEI4_Msk = 0x100000
	// Bit MCEI4.
	TCC_EVCTRL_MCEI4 = 0x100000
	// Position of MCEI5 field.
	TCC_EVCTRL_MCEI5_Pos = 0x15
	// Bit mask of MCEI5 field.
	TCC_EVCTRL_MCEI5_Msk = 0x200000
	// Bit MCEI5.
	TCC_EVCTRL_MCEI5 = 0x200000
	// Position of MCEO0 field.
	TCC_EVCTRL_MCEO0_Pos = 0x18
	// Bit mask of MCEO0 field.
	TCC_EVCTRL_MCEO0_Msk = 0x1000000
	// Bit MCEO0.
	TCC_EVCTRL_MCEO0 = 0x1000000
	// Position of MCEO1 field.
	TCC_EVCTRL_MCEO1_Pos = 0x19
	// Bit mask of MCEO1 field.
	TCC_EVCTRL_MCEO1_Msk = 0x2000000
	// Bit MCEO1.
	TCC_EVCTRL_MCEO1 = 0x2000000
	// Position of MCEO2 field.
	TCC_EVCTRL_MCEO2_Pos = 0x1a
	// Bit mask of MCEO2 field.
	TCC_EVCTRL_MCEO2_Msk = 0x4000000
	// Bit MCEO2.
	TCC_EVCTRL_MCEO2 = 0x4000000
	// Position of MCEO3 field.
	TCC_EVCTRL_MCEO3_Pos = 0x1b
	// Bit mask of MCEO3 field.
	TCC_EVCTRL_MCEO3_Msk = 0x8000000
	// Bit MCEO3.
	TCC_EVCTRL_MCEO3 = 0x8000000
	// Position of MCEO4 field.
	TCC_EVCTRL_MCEO4_Pos = 0x1c
	// Bit mask of MCEO4 field.
	TCC_EVCTRL_MCEO4_Msk = 0x10000000
	// Bit MCEO4.
	TCC_EVCTRL_MCEO4 = 0x10000000
	// Position of MCEO5 field.
	TCC_EVCTRL_MCEO5_Pos = 0x1d
	// Bit mask of MCEO5 field.
	TCC_EVCTRL_MCEO5_Msk = 0x20000000
	// Bit MCEO5.
	TCC_EVCTRL_MCEO5 = 0x20000000

	// INTENCLR: Interrupt Enable Clear
	// Position of OVF field.
	TCC_INTENCLR_OVF_Pos = 0x0
	// Bit mask of OVF field.
	TCC_INTENCLR_OVF_Msk = 0x1
	// Bit OVF.
	TCC_INTENCLR_OVF = 0x1
	// Position of TRG field.
	TCC_INTENCLR_TRG_Pos = 0x1
	// Bit mask of TRG field.
	TCC_INTENCLR_TRG_Msk = 0x2
	// Bit TRG.
	TCC_INTENCLR_TRG = 0x2
	// Position of CNT field.
	TCC_INTENCLR_CNT_Pos = 0x2
	// Bit mask of CNT field.
	TCC_INTENCLR_CNT_Msk = 0x4
	// Bit CNT.
	TCC_INTENCLR_CNT = 0x4
	// Position of ERR field.
	TCC_INTENCLR_ERR_Pos = 0x3
	// Bit mask of ERR field.
	TCC_INTENCLR_ERR_Msk = 0x8
	// Bit ERR.
	TCC_INTENCLR_ERR = 0x8
	// Position of UFS field.
	TCC_INTENCLR_UFS_Pos = 0xa
	// Bit mask of UFS field.
	TCC_INTENCLR_UFS_Msk = 0x400
	// Bit UFS.
	TCC_INTENCLR_UFS = 0x400
	// Position of DFS field.
	TCC_INTENCLR_DFS_Pos = 0xb
	// Bit mask of DFS field.
	TCC_INTENCLR_DFS_Msk = 0x800
	// Bit DFS.
	TCC_INTENCLR_DFS = 0x800
	// Position of FAULTA field.
	TCC_INTENCLR_FAULTA_Pos = 0xc
	// Bit mask of FAULTA field.
	TCC_INTENCLR_FAULTA_Msk = 0x1000
	// Bit FAULTA.
	TCC_INTENCLR_FAULTA = 0x1000
	// Position of FAULTB field.
	TCC_INTENCLR_FAULTB_Pos = 0xd
	// Bit mask of FAULTB field.
	TCC_INTENCLR_FAULTB_Msk = 0x2000
	// Bit FAULTB.
	TCC_INTENCLR_FAULTB = 0x2000
	// Position of FAULT0 field.
	TCC_INTENCLR_FAULT0_Pos = 0xe
	// Bit mask of FAULT0 field.
	TCC_INTENCLR_FAULT0_Msk = 0x4000
	// Bit FAULT0.
	TCC_INTENCLR_FAULT0 = 0x4000
	// Position of FAULT1 field.
	TCC_INTENCLR_FAULT1_Pos = 0xf
	// Bit mask of FAULT1 field.
	TCC_INTENCLR_FAULT1_Msk = 0x8000
	// Bit FAULT1.
	TCC_INTENCLR_FAULT1 = 0x8000
	// Position of MC0 field.
	TCC_INTENCLR_MC0_Pos = 0x10
	// Bit mask of MC0 field.
	TCC_INTENCLR_MC0_Msk = 0x10000
	// Bit MC0.
	TCC_INTENCLR_MC0 = 0x10000
	// Position of MC1 field.
	TCC_INTENCLR_MC1_Pos = 0x11
	// Bit mask of MC1 field.
	TCC_INTENCLR_MC1_Msk = 0x20000
	// Bit MC1.
	TCC_INTENCLR_MC1 = 0x20000
	// Position of MC2 field.
	TCC_INTENCLR_MC2_Pos = 0x12
	// Bit mask of MC2 field.
	TCC_INTENCLR_MC2_Msk = 0x40000
	// Bit MC2.
	TCC_INTENCLR_MC2 = 0x40000
	// Position of MC3 field.
	TCC_INTENCLR_MC3_Pos = 0x13
	// Bit mask of MC3 field.
	TCC_INTENCLR_MC3_Msk = 0x80000
	// Bit MC3.
	TCC_INTENCLR_MC3 = 0x80000
	// Position of MC4 field.
	TCC_INTENCLR_MC4_Pos = 0x14
	// Bit mask of MC4 field.
	TCC_INTENCLR_MC4_Msk = 0x100000
	// Bit MC4.
	TCC_INTENCLR_MC4 = 0x100000
	// Position of MC5 field.
	TCC_INTENCLR_MC5_Pos = 0x15
	// Bit mask of MC5 field.
	TCC_INTENCLR_MC5_Msk = 0x200000
	// Bit MC5.
	TCC_INTENCLR_MC5 = 0x200000

	// INTENSET: Interrupt Enable Set
	// Position of OVF field.
	TCC_INTENSET_OVF_Pos = 0x0
	// Bit mask of OVF field.
	TCC_INTENSET_OVF_Msk = 0x1
	// Bit OVF.
	TCC_INTENSET_OVF = 0x1
	// Position of TRG field.
	TCC_INTENSET_TRG_Pos = 0x1
	// Bit mask of TRG field.
	TCC_INTENSET_TRG_Msk = 0x2
	// Bit TRG.
	TCC_INTENSET_TRG = 0x2
	// Position of CNT field.
	TCC_INTENSET_CNT_Pos = 0x2
	// Bit mask of CNT field.
	TCC_INTENSET_CNT_Msk = 0x4
	// Bit CNT.
	TCC_INTENSET_CNT = 0x4
	// Position of ERR field.
	TCC_INTENSET_ERR_Pos = 0x3
	// Bit mask of ERR field.
	TCC_INTENSET_ERR_Msk = 0x8
	// Bit ERR.
	TCC_INTENSET_ERR = 0x8
	// Position of UFS field.
	TCC_INTENSET_UFS_Pos = 0xa
	// Bit mask of UFS field.
	TCC_INTENSET_UFS_Msk = 0x400
	// Bit UFS.
	TCC_INTENSET_UFS = 0x400
	// Position of DFS field.
	TCC_INTENSET_DFS_Pos = 0xb
	// Bit mask of DFS field.
	TCC_INTENSET_DFS_Msk = 0x800
	// Bit DFS.
	TCC_INTENSET_DFS = 0x800
	// Position of FAULTA field.
	TCC_INTENSET_FAULTA_Pos = 0xc
	// Bit mask of FAULTA field.
	TCC_INTENSET_FAULTA_Msk = 0x1000
	// Bit FAULTA.
	TCC_INTENSET_FAULTA = 0x1000
	// Position of FAULTB field.
	TCC_INTENSET_FAULTB_Pos = 0xd
	// Bit mask of FAULTB field.
	TCC_INTENSET_FAULTB_Msk = 0x2000
	// Bit FAULTB.
	TCC_INTENSET_FAULTB = 0x2000
	// Position of FAULT0 field.
	TCC_INTENSET_FAULT0_Pos = 0xe
	// Bit mask of FAULT0 field.
	TCC_INTENSET_FAULT0_Msk = 0x4000
	// Bit FAULT0.
	TCC_INTENSET_FAULT0 = 0x4000
	// Position of FAULT1 field.
	TCC_INTENSET_FAULT1_Pos = 0xf
	// Bit mask of FAULT1 field.
	TCC_INTENSET_FAULT1_Msk = 0x8000
	// Bit FAULT1.
	TCC_INTENSET_FAULT1 = 0x8000
	// Position of MC0 field.
	TCC_INTENSET_MC0_Pos = 0x10
	// Bit mask of MC0 field.
	TCC_INTENSET_MC0_Msk = 0x10000
	// Bit MC0.
	TCC_INTENSET_MC0 = 0x10000
	// Position of MC1 field.
	TCC_INTENSET_MC1_Pos = 0x11
	// Bit mask of MC1 field.
	TCC_INTENSET_MC1_Msk = 0x20000
	// Bit MC1.
	TCC_INTENSET_MC1 = 0x20000
	// Position of MC2 field.
	TCC_INTENSET_MC2_Pos = 0x12
	// Bit mask of MC2 field.
	TCC_INTENSET_MC2_Msk = 0x40000
	// Bit MC2.
	TCC_INTENSET_MC2 = 0x40000
	// Position of MC3 field.
	TCC_INTENSET_MC3_Pos = 0x13
	// Bit mask of MC3 field.
	TCC_INTENSET_MC3_Msk = 0x80000
	// Bit MC3.
	TCC_INTENSET_MC3 = 0x80000
	// Position of MC4 field.
	TCC_INTENSET_MC4_Pos = 0x14
	// Bit mask of MC4 field.
	TCC_INTENSET_MC4_Msk = 0x100000
	// Bit MC4.
	TCC_INTENSET_MC4 = 0x100000
	// Position of MC5 field.
	TCC_INTENSET_MC5_Pos = 0x15
	// Bit mask of MC5 field.
	TCC_INTENSET_MC5_Msk = 0x200000
	// Bit MC5.
	TCC_INTENSET_MC5 = 0x200000

	// INTFLAG: Interrupt Flag Status and Clear
	// Position of OVF field.
	TCC_INTFLAG_OVF_Pos = 0x0
	// Bit mask of OVF field.
	TCC_INTFLAG_OVF_Msk = 0x1
	// Bit OVF.
	TCC_INTFLAG_OVF = 0x1
	// Position of TRG field.
	TCC_INTFLAG_TRG_Pos = 0x1
	// Bit mask of TRG field.
	TCC_INTFLAG_TRG_Msk = 0x2
	// Bit TRG.
	TCC_INTFLAG_TRG = 0x2
	// Position of CNT field.
	TCC_INTFLAG_CNT_Pos = 0x2
	// Bit mask of CNT field.
	TCC_INTFLAG_CNT_Msk = 0x4
	// Bit CNT.
	TCC_INTFLAG_CNT = 0x4
	// Position of ERR field.
	TCC_INTFLAG_ERR_Pos = 0x3
	// Bit mask of ERR field.
	TCC_INTFLAG_ERR_Msk = 0x8
	// Bit ERR.
	TCC_INTFLAG_ERR = 0x8
	// Position of UFS field.
	TCC_INTFLAG_UFS_Pos = 0xa
	// Bit mask of UFS field.
	TCC_INTFLAG_UFS_Msk = 0x400
	// Bit UFS.
	TCC_INTFLAG_UFS = 0x400
	// Position of DFS field.
	TCC_INTFLAG_DFS_Pos = 0xb
	// Bit mask of DFS field.
	TCC_INTFLAG_DFS_Msk = 0x800
	// Bit DFS.
	TCC_INTFLAG_DFS = 0x800
	// Position of FAULTA field.
	TCC_INTFLAG_FAULTA_Pos = 0xc
	// Bit mask of FAULTA field.
	TCC_INTFLAG_FAULTA_Msk = 0x1000
	// Bit FAULTA.
	TCC_INTFLAG_FAULTA = 0x1000
	// Position of FAULTB field.
	TCC_INTFLAG_FAULTB_Pos = 0xd
	// Bit mask of FAULTB field.
	TCC_INTFLAG_FAULTB_Msk = 0x2000
	// Bit FAULTB.
	TCC_INTFLAG_FAULTB = 0x2000
	// Position of FAULT0 field.
	TCC_INTFLAG_FAULT0_Pos = 0xe
	// Bit mask of FAULT0 field.
	TCC_INTFLAG_FAULT0_Msk = 0x4000
	// Bit FAULT0.
	TCC_INTFLAG_FAULT0 = 0x4000
	// Position of FAULT1 field.
	TCC_INTFLAG_FAULT1_Pos = 0xf
	// Bit mask of FAULT1 field.
	TCC_INTFLAG_FAULT1_Msk = 0x8000
	// Bit FAULT1.
	TCC_INTFLAG_FAULT1 = 0x8000
	// Position of MC0 field.
	TCC_INTFLAG_MC0_Pos = 0x10
	// Bit mask of MC0 field.
	TCC_INTFLAG_MC0_Msk = 0x10000
	// Bit MC0.
	TCC_INTFLAG_MC0 = 0x10000
	// Position of MC1 field.
	TCC_INTFLAG_MC1_Pos = 0x11
	// Bit mask of MC1 field.
	TCC_INTFLAG_MC1_Msk = 0x20000
	// Bit MC1.
	TCC_INTFLAG_MC1 = 0x20000
	// Position of MC2 field.
	TCC_INTFLAG_MC2_Pos = 0x12
	// Bit mask of MC2 field.
	TCC_INTFLAG_MC2_Msk = 0x40000
	// Bit MC2.
	TCC_INTFLAG_MC2 = 0x40000
	// Position of MC3 field.
	TCC_INTFLAG_MC3_Pos = 0x13
	// Bit mask of MC3 field.
	TCC_INTFLAG_MC3_Msk = 0x80000
	// Bit MC3.
	TCC_INTFLAG_MC3 = 0x80000
	// Position of MC4 field.
	TCC_INTFLAG_MC4_Pos = 0x14
	// Bit mask of MC4 field.
	TCC_INTFLAG_MC4_Msk = 0x100000
	// Bit MC4.
	TCC_INTFLAG_MC4 = 0x100000
	// Position of MC5 field.
	TCC_INTFLAG_MC5_Pos = 0x15
	// Bit mask of MC5 field.
	TCC_INTFLAG_MC5_Msk = 0x200000
	// Bit MC5.
	TCC_INTFLAG_MC5 = 0x200000

	// STATUS: Status
	// Position of STOP field.
	TCC_STATUS_STOP_Pos = 0x0
	// Bit mask of STOP field.
	TCC_STATUS_STOP_Msk = 0x1
	// Bit STOP.
	TCC_STATUS_STOP = 0x1
	// Position of IDX field.
	TCC_STATUS_IDX_Pos = 0x1
	// Bit mask of IDX field.
	TCC_STATUS_IDX_Msk = 0x2
	// Bit IDX.
	TCC_STATUS_IDX = 0x2
	// Position of UFS field.
	TCC_STATUS_UFS_Pos = 0x2
	// Bit mask of UFS field.
	TCC_STATUS_UFS_Msk = 0x4
	// Bit UFS.
	TCC_STATUS_UFS = 0x4
	// Position of DFS field.
	TCC_STATUS_DFS_Pos = 0x3
	// Bit mask of DFS field.
	TCC_STATUS_DFS_Msk = 0x8
	// Bit DFS.
	TCC_STATUS_DFS = 0x8
	// Position of SLAVE field.
	TCC_STATUS_SLAVE_Pos = 0x4
	// Bit mask of SLAVE field.
	TCC_STATUS_SLAVE_Msk = 0x10
	// Bit SLAVE.
	TCC_STATUS_SLAVE = 0x10
	// Position of PATTBUFV field.
	TCC_STATUS_PATTBUFV_Pos = 0x5
	// Bit mask of PATTBUFV field.
	TCC_STATUS_PATTBUFV_Msk = 0x20
	// Bit PATTBUFV.
	TCC_STATUS_PATTBUFV = 0x20
	// Position of PERBUFV field.
	TCC_STATUS_PERBUFV_Pos = 0x7
	// Bit mask of PERBUFV field.
	TCC_STATUS_PERBUFV_Msk = 0x80
	// Bit PERBUFV.
	TCC_STATUS_PERBUFV = 0x80
	// Position of FAULTAIN field.
	TCC_STATUS_FAULTAIN_Pos = 0x8
	// Bit mask of FAULTAIN field.
	TCC_STATUS_FAULTAIN_Msk = 0x100
	// Bit FAULTAIN.
	TCC_STATUS_FAULTAIN = 0x100
	// Position of FAULTBIN field.
	TCC_STATUS_FAULTBIN_Pos = 0x9
	// Bit mask of FAULTBIN field.
	TCC_STATUS_FAULTBIN_Msk = 0x200
	// Bit FAULTBIN.
	TCC_STATUS_FAULTBIN = 0x200
	// Position of FAULT0IN field.
	TCC_STATUS_FAULT0IN_Pos = 0xa
	// Bit mask of FAULT0IN field.
	TCC_STATUS_FAULT0IN_Msk = 0x400
	// Bit FAULT0IN.
	TCC_STATUS_FAULT0IN = 0x400
	// Position of FAULT1IN field.
	TCC_STATUS_FAULT1IN_Pos = 0xb
	// Bit mask of FAULT1IN field.
	TCC_STATUS_FAULT1IN_Msk = 0x800
	// Bit FAULT1IN.
	TCC_STATUS_FAULT1IN = 0x800
	// Position of FAULTA field.
	TCC_STATUS_FAULTA_Pos = 0xc
	// Bit mask of FAULTA field.
	TCC_STATUS_FAULTA_Msk = 0x1000
	// Bit FAULTA.
	TCC_STATUS_FAULTA = 0x1000
	// Position of FAULTB field.
	TCC_STATUS_FAULTB_Pos = 0xd
	// Bit mask of FAULTB field.
	TCC_STATUS_FAULTB_Msk = 0x2000
	// Bit FAULTB.
	TCC_STATUS_FAULTB = 0x2000
	// Position of FAULT0 field.
	TCC_STATUS_FAULT0_Pos = 0xe
	// Bit mask of FAULT0 field.
	TCC_STATUS_FAULT0_Msk = 0x4000
	// Bit FAULT0.
	TCC_STATUS_FAULT0 = 0x4000
	// Position of FAULT1 field.
	TCC_STATUS_FAULT1_Pos = 0xf
	// Bit mask of FAULT1 field.
	TCC_STATUS_FAULT1_Msk = 0x8000
	// Bit FAULT1.
	TCC_STATUS_FAULT1 = 0x8000
	// Position of CCBUFV0 field.
	TCC_STATUS_CCBUFV0_Pos = 0x10
	// Bit mask of CCBUFV0 field.
	TCC_STATUS_CCBUFV0_Msk = 0x10000
	// Bit CCBUFV0.
	TCC_STATUS_CCBUFV0 = 0x10000
	// Position of CCBUFV1 field.
	TCC_STATUS_CCBUFV1_Pos = 0x11
	// Bit mask of CCBUFV1 field.
	TCC_STATUS_CCBUFV1_Msk = 0x20000
	// Bit CCBUFV1.
	TCC_STATUS_CCBUFV1 = 0x20000
	// Position of CCBUFV2 field.
	TCC_STATUS_CCBUFV2_Pos = 0x12
	// Bit mask of CCBUFV2 field.
	TCC_STATUS_CCBUFV2_Msk = 0x40000
	// Bit CCBUFV2.
	TCC_STATUS_CCBUFV2 = 0x40000
	// Position of CCBUFV3 field.
	TCC_STATUS_CCBUFV3_Pos = 0x13
	// Bit mask of CCBUFV3 field.
	TCC_STATUS_CCBUFV3_Msk = 0x80000
	// Bit CCBUFV3.
	TCC_STATUS_CCBUFV3 = 0x80000
	// Position of CCBUFV4 field.
	TCC_STATUS_CCBUFV4_Pos = 0x14
	// Bit mask of CCBUFV4 field.
	TCC_STATUS_CCBUFV4_Msk = 0x100000
	// Bit CCBUFV4.
	TCC_STATUS_CCBUFV4 = 0x100000
	// Position of CCBUFV5 field.
	TCC_STATUS_CCBUFV5_Pos = 0x15
	// Bit mask of CCBUFV5 field.
	TCC_STATUS_CCBUFV5_Msk = 0x200000
	// Bit CCBUFV5.
	TCC_STATUS_CCBUFV5 = 0x200000
	// Position of CMP0 field.
	TCC_STATUS_CMP0_Pos = 0x18
	// Bit mask of CMP0 field.
	TCC_STATUS_CMP0_Msk = 0x1000000
	// Bit CMP0.
	TCC_STATUS_CMP0 = 0x1000000
	// Position of CMP1 field.
	TCC_STATUS_CMP1_Pos = 0x19
	// Bit mask of CMP1 field.
	TCC_STATUS_CMP1_Msk = 0x2000000
	// Bit CMP1.
	TCC_STATUS_CMP1 = 0x2000000
	// Position of CMP2 field.
	TCC_STATUS_CMP2_Pos = 0x1a
	// Bit mask of CMP2 field.
	TCC_STATUS_CMP2_Msk = 0x4000000
	// Bit CMP2.
	TCC_STATUS_CMP2 = 0x4000000
	// Position of CMP3 field.
	TCC_STATUS_CMP3_Pos = 0x1b
	// Bit mask of CMP3 field.
	TCC_STATUS_CMP3_Msk = 0x8000000
	// Bit CMP3.
	TCC_STATUS_CMP3 = 0x8000000
	// Position of CMP4 field.
	TCC_STATUS_CMP4_Pos = 0x1c
	// Bit mask of CMP4 field.
	TCC_STATUS_CMP4_Msk = 0x10000000
	// Bit CMP4.
	TCC_STATUS_CMP4 = 0x10000000
	// Position of CMP5 field.
	TCC_STATUS_CMP5_Pos = 0x1d
	// Bit mask of CMP5 field.
	TCC_STATUS_CMP5_Msk = 0x20000000
	// Bit CMP5.
	TCC_STATUS_CMP5 = 0x20000000

	// COUNT: Count
	// Position of COUNT field.
	TCC_COUNT_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	TCC_COUNT_COUNT_Msk = 0xffffff

	// COUNT_DITH4_MODE: Count
	// Position of COUNT field.
	TCC_COUNT_DITH4_MODE_COUNT_Pos = 0x4
	// Bit mask of COUNT field.
	TCC_COUNT_DITH4_MODE_COUNT_Msk = 0xfffff0

	// COUNT_DITH5_MODE: Count
	// Position of COUNT field.
	TCC_COUNT_DITH5_MODE_COUNT_Pos = 0x5
	// Bit mask of COUNT field.
	TCC_COUNT_DITH5_MODE_COUNT_Msk = 0xffffe0

	// COUNT_DITH6_MODE: Count
	// Position of COUNT field.
	TCC_COUNT_DITH6_MODE_COUNT_Pos = 0x6
	// Bit mask of COUNT field.
	TCC_COUNT_DITH6_MODE_COUNT_Msk = 0xffffc0

	// PATT: Pattern
	// Position of PGE0 field.
	TCC_PATT_PGE0_Pos = 0x0
	// Bit mask of PGE0 field.
	TCC_PATT_PGE0_Msk = 0x1
	// Bit PGE0.
	TCC_PATT_PGE0 = 0x1
	// Position of PGE1 field.
	TCC_PATT_PGE1_Pos = 0x1
	// Bit mask of PGE1 field.
	TCC_PATT_PGE1_Msk = 0x2
	// Bit PGE1.
	TCC_PATT_PGE1 = 0x2
	// Position of PGE2 field.
	TCC_PATT_PGE2_Pos = 0x2
	// Bit mask of PGE2 field.
	TCC_PATT_PGE2_Msk = 0x4
	// Bit PGE2.
	TCC_PATT_PGE2 = 0x4
	// Position of PGE3 field.
	TCC_PATT_PGE3_Pos = 0x3
	// Bit mask of PGE3 field.
	TCC_PATT_PGE3_Msk = 0x8
	// Bit PGE3.
	TCC_PATT_PGE3 = 0x8
	// Position of PGE4 field.
	TCC_PATT_PGE4_Pos = 0x4
	// Bit mask of PGE4 field.
	TCC_PATT_PGE4_Msk = 0x10
	// Bit PGE4.
	TCC_PATT_PGE4 = 0x10
	// Position of PGE5 field.
	TCC_PATT_PGE5_Pos = 0x5
	// Bit mask of PGE5 field.
	TCC_PATT_PGE5_Msk = 0x20
	// Bit PGE5.
	TCC_PATT_PGE5 = 0x20
	// Position of PGE6 field.
	TCC_PATT_PGE6_Pos = 0x6
	// Bit mask of PGE6 field.
	TCC_PATT_PGE6_Msk = 0x40
	// Bit PGE6.
	TCC_PATT_PGE6 = 0x40
	// Position of PGE7 field.
	TCC_PATT_PGE7_Pos = 0x7
	// Bit mask of PGE7 field.
	TCC_PATT_PGE7_Msk = 0x80
	// Bit PGE7.
	TCC_PATT_PGE7 = 0x80
	// Position of PGV0 field.
	TCC_PATT_PGV0_Pos = 0x8
	// Bit mask of PGV0 field.
	TCC_PATT_PGV0_Msk = 0x100
	// Bit PGV0.
	TCC_PATT_PGV0 = 0x100
	// Position of PGV1 field.
	TCC_PATT_PGV1_Pos = 0x9
	// Bit mask of PGV1 field.
	TCC_PATT_PGV1_Msk = 0x200
	// Bit PGV1.
	TCC_PATT_PGV1 = 0x200
	// Position of PGV2 field.
	TCC_PATT_PGV2_Pos = 0xa
	// Bit mask of PGV2 field.
	TCC_PATT_PGV2_Msk = 0x400
	// Bit PGV2.
	TCC_PATT_PGV2 = 0x400
	// Position of PGV3 field.
	TCC_PATT_PGV3_Pos = 0xb
	// Bit mask of PGV3 field.
	TCC_PATT_PGV3_Msk = 0x800
	// Bit PGV3.
	TCC_PATT_PGV3 = 0x800
	// Position of PGV4 field.
	TCC_PATT_PGV4_Pos = 0xc
	// Bit mask of PGV4 field.
	TCC_PATT_PGV4_Msk = 0x1000
	// Bit PGV4.
	TCC_PATT_PGV4 = 0x1000
	// Position of PGV5 field.
	TCC_PATT_PGV5_Pos = 0xd
	// Bit mask of PGV5 field.
	TCC_PATT_PGV5_Msk = 0x2000
	// Bit PGV5.
	TCC_PATT_PGV5 = 0x2000
	// Position of PGV6 field.
	TCC_PATT_PGV6_Pos = 0xe
	// Bit mask of PGV6 field.
	TCC_PATT_PGV6_Msk = 0x4000
	// Bit PGV6.
	TCC_PATT_PGV6 = 0x4000
	// Position of PGV7 field.
	TCC_PATT_PGV7_Pos = 0xf
	// Bit mask of PGV7 field.
	TCC_PATT_PGV7_Msk = 0x8000
	// Bit PGV7.
	TCC_PATT_PGV7 = 0x8000

	// WAVE: Waveform Control
	// Position of WAVEGEN field.
	TCC_WAVE_WAVEGEN_Pos = 0x0
	// Bit mask of WAVEGEN field.
	TCC_WAVE_WAVEGEN_Msk = 0x7
	// Normal frequency
	TCC_WAVE_WAVEGEN_NFRQ = 0x0
	// Match frequency
	TCC_WAVE_WAVEGEN_MFRQ = 0x1
	// Normal PWM
	TCC_WAVE_WAVEGEN_NPWM = 0x2
	// Dual-slope critical
	TCC_WAVE_WAVEGEN_DSCRITICAL = 0x4
	// Dual-slope with interrupt/event condition when COUNT reaches ZERO
	TCC_WAVE_WAVEGEN_DSBOTTOM = 0x5
	// Dual-slope with interrupt/event condition when COUNT reaches ZERO or TOP
	TCC_WAVE_WAVEGEN_DSBOTH = 0x6
	// Dual-slope with interrupt/event condition when COUNT reaches TOP
	TCC_WAVE_WAVEGEN_DSTOP = 0x7
	// Position of RAMP field.
	TCC_WAVE_RAMP_Pos = 0x4
	// Bit mask of RAMP field.
	TCC_WAVE_RAMP_Msk = 0x30
	// RAMP1 operation
	TCC_WAVE_RAMP_RAMP1 = 0x0
	// Alternative RAMP2 operation
	TCC_WAVE_RAMP_RAMP2A = 0x1
	// RAMP2 operation
	TCC_WAVE_RAMP_RAMP2 = 0x2
	// Critical RAMP2 operation
	TCC_WAVE_RAMP_RAMP2C = 0x3
	// Position of CIPEREN field.
	TCC_WAVE_CIPEREN_Pos = 0x7
	// Bit mask of CIPEREN field.
	TCC_WAVE_CIPEREN_Msk = 0x80
	// Bit CIPEREN.
	TCC_WAVE_CIPEREN = 0x80
	// Position of CICCEN0 field.
	TCC_WAVE_CICCEN0_Pos = 0x8
	// Bit mask of CICCEN0 field.
	TCC_WAVE_CICCEN0_Msk = 0x100
	// Bit CICCEN0.
	TCC_WAVE_CICCEN0 = 0x100
	// Position of CICCEN1 field.
	TCC_WAVE_CICCEN1_Pos = 0x9
	// Bit mask of CICCEN1 field.
	TCC_WAVE_CICCEN1_Msk = 0x200
	// Bit CICCEN1.
	TCC_WAVE_CICCEN1 = 0x200
	// Position of CICCEN2 field.
	TCC_WAVE_CICCEN2_Pos = 0xa
	// Bit mask of CICCEN2 field.
	TCC_WAVE_CICCEN2_Msk = 0x400
	// Bit CICCEN2.
	TCC_WAVE_CICCEN2 = 0x400
	// Position of CICCEN3 field.
	TCC_WAVE_CICCEN3_Pos = 0xb
	// Bit mask of CICCEN3 field.
	TCC_WAVE_CICCEN3_Msk = 0x800
	// Bit CICCEN3.
	TCC_WAVE_CICCEN3 = 0x800
	// Position of POL0 field.
	TCC_WAVE_POL0_Pos = 0x10
	// Bit mask of POL0 field.
	TCC_WAVE_POL0_Msk = 0x10000
	// Bit POL0.
	TCC_WAVE_POL0 = 0x10000
	// Position of POL1 field.
	TCC_WAVE_POL1_Pos = 0x11
	// Bit mask of POL1 field.
	TCC_WAVE_POL1_Msk = 0x20000
	// Bit POL1.
	TCC_WAVE_POL1 = 0x20000
	// Position of POL2 field.
	TCC_WAVE_POL2_Pos = 0x12
	// Bit mask of POL2 field.
	TCC_WAVE_POL2_Msk = 0x40000
	// Bit POL2.
	TCC_WAVE_POL2 = 0x40000
	// Position of POL3 field.
	TCC_WAVE_POL3_Pos = 0x13
	// Bit mask of POL3 field.
	TCC_WAVE_POL3_Msk = 0x80000
	// Bit POL3.
	TCC_WAVE_POL3 = 0x80000
	// Position of POL4 field.
	TCC_WAVE_POL4_Pos = 0x14
	// Bit mask of POL4 field.
	TCC_WAVE_POL4_Msk = 0x100000
	// Bit POL4.
	TCC_WAVE_POL4 = 0x100000
	// Position of POL5 field.
	TCC_WAVE_POL5_Pos = 0x15
	// Bit mask of POL5 field.
	TCC_WAVE_POL5_Msk = 0x200000
	// Bit POL5.
	TCC_WAVE_POL5 = 0x200000
	// Position of SWAP0 field.
	TCC_WAVE_SWAP0_Pos = 0x18
	// Bit mask of SWAP0 field.
	TCC_WAVE_SWAP0_Msk = 0x1000000
	// Bit SWAP0.
	TCC_WAVE_SWAP0 = 0x1000000
	// Position of SWAP1 field.
	TCC_WAVE_SWAP1_Pos = 0x19
	// Bit mask of SWAP1 field.
	TCC_WAVE_SWAP1_Msk = 0x2000000
	// Bit SWAP1.
	TCC_WAVE_SWAP1 = 0x2000000
	// Position of SWAP2 field.
	TCC_WAVE_SWAP2_Pos = 0x1a
	// Bit mask of SWAP2 field.
	TCC_WAVE_SWAP2_Msk = 0x4000000
	// Bit SWAP2.
	TCC_WAVE_SWAP2 = 0x4000000
	// Position of SWAP3 field.
	TCC_WAVE_SWAP3_Pos = 0x1b
	// Bit mask of SWAP3 field.
	TCC_WAVE_SWAP3_Msk = 0x8000000
	// Bit SWAP3.
	TCC_WAVE_SWAP3 = 0x8000000

	// PER: Period
	// Position of PER field.
	TCC_PER_PER_Pos = 0x0
	// Bit mask of PER field.
	TCC_PER_PER_Msk = 0xffffff

	// PER_DITH4_MODE: Period
	// Position of DITHER field.
	TCC_PER_DITH4_MODE_DITHER_Pos = 0x0
	// Bit mask of DITHER field.
	TCC_PER_DITH4_MODE_DITHER_Msk = 0xf
	// Position of PER field.
	TCC_PER_DITH4_MODE_PER_Pos = 0x4
	// Bit mask of PER field.
	TCC_PER_DITH4_MODE_PER_Msk = 0xfffff0

	// PER_DITH5_MODE: Period
	// Position of DITHER field.
	TCC_PER_DITH5_MODE_DITHER_Pos = 0x0
	// Bit mask of DITHER field.
	TCC_PER_DITH5_MODE_DITHER_Msk = 0x1f
	// Position of PER field.
	TCC_PER_DITH5_MODE_PER_Pos = 0x5
	// Bit mask of PER field.
	TCC_PER_DITH5_MODE_PER_Msk = 0xffffe0

	// PER_DITH6_MODE: Period
	// Position of DITHER field.
	TCC_PER_DITH6_MODE_DITHER_Pos = 0x0
	// Bit mask of DITHER field.
	TCC_PER_DITH6_MODE_DITHER_Msk = 0x3f
	// Position of PER field.
	TCC_PER_DITH6_MODE_PER_Pos = 0x6
	// Bit mask of PER field.
	TCC_PER_DITH6_MODE_PER_Msk = 0xffffc0

	// CC: Compare and Capture
	// Position of CC field.
	TCC_CC_CC_Pos = 0x0
	// Bit mask of CC field.
	TCC_CC_CC_Msk = 0xffffff

	// CC_DITH4_MODE: Compare and Capture
	// Position of DITHER field.
	TCC_CC_DITH4_MODE_DITHER_Pos = 0x0
	// Bit mask of DITHER field.
	TCC_CC_DITH4_MODE_DITHER_Msk = 0xf
	// Position of CC field.
	TCC_CC_DITH4_MODE_CC_Pos = 0x4
	// Bit mask of CC field.
	TCC_CC_DITH4_MODE_CC_Msk = 0xfffff0

	// CC_DITH5_MODE: Compare and Capture
	// Position of DITHER field.
	TCC_CC_DITH5_MODE_DITHER_Pos = 0x0
	// Bit mask of DITHER field.
	TCC_CC_DITH5_MODE_DITHER_Msk = 0x1f
	// Position of CC field.
	TCC_CC_DITH5_MODE_CC_Pos = 0x5
	// Bit mask of CC field.
	TCC_CC_DITH5_MODE_CC_Msk = 0xffffe0

	// CC_DITH6_MODE: Compare and Capture
	// Position of DITHER field.
	TCC_CC_DITH6_MODE_DITHER_Pos = 0x0
	// Bit mask of DITHER field.
	TCC_CC_DITH6_MODE_DITHER_Msk = 0x3f
	// Position of CC field.
	TCC_CC_DITH6_MODE_CC_Pos = 0x6
	// Bit mask of CC field.
	TCC_CC_DITH6_MODE_CC_Msk = 0xffffc0

	// PATTBUF: Pattern Buffer
	// Position of PGEB0 field.
	TCC_PATTBUF_PGEB0_Pos = 0x0
	// Bit mask of PGEB0 field.
	TCC_PATTBUF_PGEB0_Msk = 0x1
	// Bit PGEB0.
	TCC_PATTBUF_PGEB0 = 0x1
	// Position of PGEB1 field.
	TCC_PATTBUF_PGEB1_Pos = 0x1
	// Bit mask of PGEB1 field.
	TCC_PATTBUF_PGEB1_Msk = 0x2
	// Bit PGEB1.
	TCC_PATTBUF_PGEB1 = 0x2
	// Position of PGEB2 field.
	TCC_PATTBUF_PGEB2_Pos = 0x2
	// Bit mask of PGEB2 field.
	TCC_PATTBUF_PGEB2_Msk = 0x4
	// Bit PGEB2.
	TCC_PATTBUF_PGEB2 = 0x4
	// Position of PGEB3 field.
	TCC_PATTBUF_PGEB3_Pos = 0x3
	// Bit mask of PGEB3 field.
	TCC_PATTBUF_PGEB3_Msk = 0x8
	// Bit PGEB3.
	TCC_PATTBUF_PGEB3 = 0x8
	// Position of PGEB4 field.
	TCC_PATTBUF_PGEB4_Pos = 0x4
	// Bit mask of PGEB4 field.
	TCC_PATTBUF_PGEB4_Msk = 0x10
	// Bit PGEB4.
	TCC_PATTBUF_PGEB4 = 0x10
	// Position of PGEB5 field.
	TCC_PATTBUF_PGEB5_Pos = 0x5
	// Bit mask of PGEB5 field.
	TCC_PATTBUF_PGEB5_Msk = 0x20
	// Bit PGEB5.
	TCC_PATTBUF_PGEB5 = 0x20
	// Position of PGEB6 field.
	TCC_PATTBUF_PGEB6_Pos = 0x6
	// Bit mask of PGEB6 field.
	TCC_PATTBUF_PGEB6_Msk = 0x40
	// Bit PGEB6.
	TCC_PATTBUF_PGEB6 = 0x40
	// Position of PGEB7 field.
	TCC_PATTBUF_PGEB7_Pos = 0x7
	// Bit mask of PGEB7 field.
	TCC_PATTBUF_PGEB7_Msk = 0x80
	// Bit PGEB7.
	TCC_PATTBUF_PGEB7 = 0x80
	// Position of PGVB0 field.
	TCC_PATTBUF_PGVB0_Pos = 0x8
	// Bit mask of PGVB0 field.
	TCC_PATTBUF_PGVB0_Msk = 0x100
	// Bit PGVB0.
	TCC_PATTBUF_PGVB0 = 0x100
	// Position of PGVB1 field.
	TCC_PATTBUF_PGVB1_Pos = 0x9
	// Bit mask of PGVB1 field.
	TCC_PATTBUF_PGVB1_Msk = 0x200
	// Bit PGVB1.
	TCC_PATTBUF_PGVB1 = 0x200
	// Position of PGVB2 field.
	TCC_PATTBUF_PGVB2_Pos = 0xa
	// Bit mask of PGVB2 field.
	TCC_PATTBUF_PGVB2_Msk = 0x400
	// Bit PGVB2.
	TCC_PATTBUF_PGVB2 = 0x400
	// Position of PGVB3 field.
	TCC_PATTBUF_PGVB3_Pos = 0xb
	// Bit mask of PGVB3 field.
	TCC_PATTBUF_PGVB3_Msk = 0x800
	// Bit PGVB3.
	TCC_PATTBUF_PGVB3 = 0x800
	// Position of PGVB4 field.
	TCC_PATTBUF_PGVB4_Pos = 0xc
	// Bit mask of PGVB4 field.
	TCC_PATTBUF_PGVB4_Msk = 0x1000
	// Bit PGVB4.
	TCC_PATTBUF_PGVB4 = 0x1000
	// Position of PGVB5 field.
	TCC_PATTBUF_PGVB5_Pos = 0xd
	// Bit mask of PGVB5 field.
	TCC_PATTBUF_PGVB5_Msk = 0x2000
	// Bit PGVB5.
	TCC_PATTBUF_PGVB5 = 0x2000
	// Position of PGVB6 field.
	TCC_PATTBUF_PGVB6_Pos = 0xe
	// Bit mask of PGVB6 field.
	TCC_PATTBUF_PGVB6_Msk = 0x4000
	// Bit PGVB6.
	TCC_PATTBUF_PGVB6 = 0x4000
	// Position of PGVB7 field.
	TCC_PATTBUF_PGVB7_Pos = 0xf
	// Bit mask of PGVB7 field.
	TCC_PATTBUF_PGVB7_Msk = 0x8000
	// Bit PGVB7.
	TCC_PATTBUF_PGVB7 = 0x8000

	// PERBUF: Period Buffer
	// Position of PERBUF field.
	TCC_PERBUF_PERBUF_Pos = 0x0
	// Bit mask of PERBUF field.
	TCC_PERBUF_PERBUF_Msk = 0xffffff

	// PERBUF_DITH4_MODE: Period Buffer
	// Position of DITHERBUF field.
	TCC_PERBUF_DITH4_MODE_DITHERBUF_Pos = 0x0
	// Bit mask of DITHERBUF field.
	TCC_PERBUF_DITH4_MODE_DITHERBUF_Msk = 0xf
	// Position of PERBUF field.
	TCC_PERBUF_DITH4_MODE_PERBUF_Pos = 0x4
	// Bit mask of PERBUF field.
	TCC_PERBUF_DITH4_MODE_PERBUF_Msk = 0xfffff0

	// PERBUF_DITH5_MODE: Period Buffer
	// Position of DITHERBUF field.
	TCC_PERBUF_DITH5_MODE_DITHERBUF_Pos = 0x0
	// Bit mask of DITHERBUF field.
	TCC_PERBUF_DITH5_MODE_DITHERBUF_Msk = 0x1f
	// Position of PERBUF field.
	TCC_PERBUF_DITH5_MODE_PERBUF_Pos = 0x5
	// Bit mask of PERBUF field.
	TCC_PERBUF_DITH5_MODE_PERBUF_Msk = 0xffffe0

	// PERBUF_DITH6_MODE: Period Buffer
	// Position of DITHERBUF field.
	TCC_PERBUF_DITH6_MODE_DITHERBUF_Pos = 0x0
	// Bit mask of DITHERBUF field.
	TCC_PERBUF_DITH6_MODE_DITHERBUF_Msk = 0x3f
	// Position of PERBUF field.
	TCC_PERBUF_DITH6_MODE_PERBUF_Pos = 0x6
	// Bit mask of PERBUF field.
	TCC_PERBUF_DITH6_MODE_PERBUF_Msk = 0xffffc0

	// CCBUF: Compare and Capture Buffer
	// Position of CCBUF field.
	TCC_CCBUF_CCBUF_Pos = 0x0
	// Bit mask of CCBUF field.
	TCC_CCBUF_CCBUF_Msk = 0xffffff

	// CCBUF_DITH4_MODE: Compare and Capture Buffer
	// Position of CCBUF field.
	TCC_CCBUF_DITH4_MODE_CCBUF_Pos = 0x0
	// Bit mask of CCBUF field.
	TCC_CCBUF_DITH4_MODE_CCBUF_Msk = 0xf
	// Position of DITHERBUF field.
	TCC_CCBUF_DITH4_MODE_DITHERBUF_Pos = 0x4
	// Bit mask of DITHERBUF field.
	TCC_CCBUF_DITH4_MODE_DITHERBUF_Msk = 0xfffff0

	// CCBUF_DITH5_MODE: Compare and Capture Buffer
	// Position of DITHERBUF field.
	TCC_CCBUF_DITH5_MODE_DITHERBUF_Pos = 0x0
	// Bit mask of DITHERBUF field.
	TCC_CCBUF_DITH5_MODE_DITHERBUF_Msk = 0x1f
	// Position of CCBUF field.
	TCC_CCBUF_DITH5_MODE_CCBUF_Pos = 0x5
	// Bit mask of CCBUF field.
	TCC_CCBUF_DITH5_MODE_CCBUF_Msk = 0xffffe0

	// CCBUF_DITH6_MODE: Compare and Capture Buffer
	// Position of DITHERBUF field.
	TCC_CCBUF_DITH6_MODE_DITHERBUF_Pos = 0x0
	// Bit mask of DITHERBUF field.
	TCC_CCBUF_DITH6_MODE_DITHERBUF_Msk = 0x3f
	// Position of CCBUF field.
	TCC_CCBUF_DITH6_MODE_CCBUF_Pos = 0x6
	// Bit mask of CCBUF field.
	TCC_CCBUF_DITH6_MODE_CCBUF_Msk = 0xffffc0
)

// Constants for TRNG: True Random Generator
const (
	// CTRLA: Control A
	// Position of ENABLE field.
	TRNG_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	TRNG_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	TRNG_CTRLA_ENABLE = 0x2
	// Position of RUNSTDBY field.
	TRNG_CTRLA_RUNSTDBY_Pos = 0x6
	// Bit mask of RUNSTDBY field.
	TRNG_CTRLA_RUNSTDBY_Msk = 0x40
	// Bit RUNSTDBY.
	TRNG_CTRLA_RUNSTDBY = 0x40

	// EVCTRL: Event Control
	// Position of DATARDYEO field.
	TRNG_EVCTRL_DATARDYEO_Pos = 0x0
	// Bit mask of DATARDYEO field.
	TRNG_EVCTRL_DATARDYEO_Msk = 0x1
	// Bit DATARDYEO.
	TRNG_EVCTRL_DATARDYEO = 0x1

	// INTENCLR: Interrupt Enable Clear
	// Position of DATARDY field.
	TRNG_INTENCLR_DATARDY_Pos = 0x0
	// Bit mask of DATARDY field.
	TRNG_INTENCLR_DATARDY_Msk = 0x1
	// Bit DATARDY.
	TRNG_INTENCLR_DATARDY = 0x1

	// INTENSET: Interrupt Enable Set
	// Position of DATARDY field.
	TRNG_INTENSET_DATARDY_Pos = 0x0
	// Bit mask of DATARDY field.
	TRNG_INTENSET_DATARDY_Msk = 0x1
	// Bit DATARDY.
	TRNG_INTENSET_DATARDY = 0x1

	// INTFLAG: Interrupt Flag Status and Clear
	// Position of DATARDY field.
	TRNG_INTFLAG_DATARDY_Pos = 0x0
	// Bit mask of DATARDY field.
	TRNG_INTFLAG_DATARDY_Msk = 0x1
	// Bit DATARDY.
	TRNG_INTFLAG_DATARDY = 0x1

	// DATA: Output Data
	// Position of DATA field.
	TRNG_DATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	TRNG_DATA_DATA_Msk = 0xffffffff
)

// Constants for USB: Universal Serial Bus
const ()

// Constants for USB_DEVICE: Universal Serial Bus - DEVICE
const (
	// CTRLA: Control A
	// Position of SWRST field.
	USB_DEVICE_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	USB_DEVICE_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	USB_DEVICE_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	USB_DEVICE_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	USB_DEVICE_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	USB_DEVICE_CTRLA_ENABLE = 0x2
	// Position of RUNSTDBY field.
	USB_DEVICE_CTRLA_RUNSTDBY_Pos = 0x2
	// Bit mask of RUNSTDBY field.
	USB_DEVICE_CTRLA_RUNSTDBY_Msk = 0x4
	// Bit RUNSTDBY.
	USB_DEVICE_CTRLA_RUNSTDBY = 0x4
	// Position of MODE field.
	USB_DEVICE_CTRLA_MODE_Pos = 0x7
	// Bit mask of MODE field.
	USB_DEVICE_CTRLA_MODE_Msk = 0x80
	// Bit MODE.
	USB_DEVICE_CTRLA_MODE = 0x80
	// Device Mode
	USB_DEVICE_CTRLA_MODE_DEVICE = 0x0
	// Host Mode
	USB_DEVICE_CTRLA_MODE_HOST = 0x1

	// SYNCBUSY: Synchronization Busy
	// Position of SWRST field.
	USB_DEVICE_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	USB_DEVICE_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	USB_DEVICE_SYNCBUSY_SWRST = 0x1
	// Position of ENABLE field.
	USB_DEVICE_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	USB_DEVICE_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	USB_DEVICE_SYNCBUSY_ENABLE = 0x2

	// QOSCTRL: USB Quality Of Service
	// Position of CQOS field.
	USB_DEVICE_QOSCTRL_CQOS_Pos = 0x0
	// Bit mask of CQOS field.
	USB_DEVICE_QOSCTRL_CQOS_Msk = 0x3
	// Position of DQOS field.
	USB_DEVICE_QOSCTRL_DQOS_Pos = 0x2
	// Bit mask of DQOS field.
	USB_DEVICE_QOSCTRL_DQOS_Msk = 0xc

	// CTRLB: DEVICE Control B
	// Position of DETACH field.
	USB_DEVICE_CTRLB_DETACH_Pos = 0x0
	// Bit mask of DETACH field.
	USB_DEVICE_CTRLB_DETACH_Msk = 0x1
	// Bit DETACH.
	USB_DEVICE_CTRLB_DETACH = 0x1
	// Position of UPRSM field.
	USB_DEVICE_CTRLB_UPRSM_Pos = 0x1
	// Bit mask of UPRSM field.
	USB_DEVICE_CTRLB_UPRSM_Msk = 0x2
	// Bit UPRSM.
	USB_DEVICE_CTRLB_UPRSM = 0x2
	// Position of SPDCONF field.
	USB_DEVICE_CTRLB_SPDCONF_Pos = 0x2
	// Bit mask of SPDCONF field.
	USB_DEVICE_CTRLB_SPDCONF_Msk = 0xc
	// FS : Full Speed
	USB_DEVICE_CTRLB_SPDCONF_FS = 0x0
	// LS : Low Speed
	USB_DEVICE_CTRLB_SPDCONF_LS = 0x1
	// HS : High Speed capable
	USB_DEVICE_CTRLB_SPDCONF_HS = 0x2
	// HSTM: High Speed Test Mode (force high-speed mode for test mode)
	USB_DEVICE_CTRLB_SPDCONF_HSTM = 0x3
	// Position of NREPLY field.
	USB_DEVICE_CTRLB_NREPLY_Pos = 0x4
	// Bit mask of NREPLY field.
	USB_DEVICE_CTRLB_NREPLY_Msk = 0x10
	// Bit NREPLY.
	USB_DEVICE_CTRLB_NREPLY = 0x10
	// Position of TSTJ field.
	USB_DEVICE_CTRLB_TSTJ_Pos = 0x5
	// Bit mask of TSTJ field.
	USB_DEVICE_CTRLB_TSTJ_Msk = 0x20
	// Bit TSTJ.
	USB_DEVICE_CTRLB_TSTJ = 0x20
	// Position of TSTK field.
	USB_DEVICE_CTRLB_TSTK_Pos = 0x6
	// Bit mask of TSTK field.
	USB_DEVICE_CTRLB_TSTK_Msk = 0x40
	// Bit TSTK.
	USB_DEVICE_CTRLB_TSTK = 0x40
	// Position of TSTPCKT field.
	USB_DEVICE_CTRLB_TSTPCKT_Pos = 0x7
	// Bit mask of TSTPCKT field.
	USB_DEVICE_CTRLB_TSTPCKT_Msk = 0x80
	// Bit TSTPCKT.
	USB_DEVICE_CTRLB_TSTPCKT = 0x80
	// Position of OPMODE2 field.
	USB_DEVICE_CTRLB_OPMODE2_Pos = 0x8
	// Bit mask of OPMODE2 field.
	USB_DEVICE_CTRLB_OPMODE2_Msk = 0x100
	// Bit OPMODE2.
	USB_DEVICE_CTRLB_OPMODE2 = 0x100
	// Position of GNAK field.
	USB_DEVICE_CTRLB_GNAK_Pos = 0x9
	// Bit mask of GNAK field.
	USB_DEVICE_CTRLB_GNAK_Msk = 0x200
	// Bit GNAK.
	USB_DEVICE_CTRLB_GNAK = 0x200
	// Position of LPMHDSK field.
	USB_DEVICE_CTRLB_LPMHDSK_Pos = 0xa
	// Bit mask of LPMHDSK field.
	USB_DEVICE_CTRLB_LPMHDSK_Msk = 0xc00
	// No handshake. LPM is not supported
	USB_DEVICE_CTRLB_LPMHDSK_NO = 0x0
	// ACK
	USB_DEVICE_CTRLB_LPMHDSK_ACK = 0x1
	// NYET
	USB_DEVICE_CTRLB_LPMHDSK_NYET = 0x2
	// STALL
	USB_DEVICE_CTRLB_LPMHDSK_STALL = 0x3

	// DADD: DEVICE Device Address
	// Position of DADD field.
	USB_DEVICE_DADD_DADD_Pos = 0x0
	// Bit mask of DADD field.
	USB_DEVICE_DADD_DADD_Msk = 0x7f
	// Position of ADDEN field.
	USB_DEVICE_DADD_ADDEN_Pos = 0x7
	// Bit mask of ADDEN field.
	USB_DEVICE_DADD_ADDEN_Msk = 0x80
	// Bit ADDEN.
	USB_DEVICE_DADD_ADDEN = 0x80

	// STATUS: DEVICE Status
	// Position of SPEED field.
	USB_DEVICE_STATUS_SPEED_Pos = 0x2
	// Bit mask of SPEED field.
	USB_DEVICE_STATUS_SPEED_Msk = 0xc
	// Full-speed mode
	USB_DEVICE_STATUS_SPEED_FS = 0x0
	// Low-speed mode
	USB_DEVICE_STATUS_SPEED_LS = 0x1
	// High-speed mode
	USB_DEVICE_STATUS_SPEED_HS = 0x2
	// Position of LINESTATE field.
	USB_DEVICE_STATUS_LINESTATE_Pos = 0x6
	// Bit mask of LINESTATE field.
	USB_DEVICE_STATUS_LINESTATE_Msk = 0xc0
	// SE0/RESET
	USB_DEVICE_STATUS_LINESTATE_0 = 0x0
	// FS-J or LS-K State
	USB_DEVICE_STATUS_LINESTATE_1 = 0x1
	// FS-K or LS-J State
	USB_DEVICE_STATUS_LINESTATE_2 = 0x2

	// FSMSTATUS: Finite State Machine Status
	// Position of FSMSTATE field.
	USB_DEVICE_FSMSTATUS_FSMSTATE_Pos = 0x0
	// Bit mask of FSMSTATE field.
	USB_DEVICE_FSMSTATUS_FSMSTATE_Msk = 0x7f
	// OFF (L3). It corresponds to the powered-off, disconnected, and disabled state
	USB_DEVICE_FSMSTATUS_FSMSTATE_OFF = 0x1
	// ON (L0). It corresponds to the Idle and Active states
	USB_DEVICE_FSMSTATUS_FSMSTATE_ON = 0x2
	// SUSPEND (L2)
	USB_DEVICE_FSMSTATUS_FSMSTATE_SUSPEND = 0x4
	// SLEEP (L1)
	USB_DEVICE_FSMSTATUS_FSMSTATE_SLEEP = 0x8
	// DNRESUME. Down Stream Resume.
	USB_DEVICE_FSMSTATUS_FSMSTATE_DNRESUME = 0x10
	// UPRESUME. Up Stream Resume.
	USB_DEVICE_FSMSTATUS_FSMSTATE_UPRESUME = 0x20
	// RESET. USB lines Reset.
	USB_DEVICE_FSMSTATUS_FSMSTATE_RESET = 0x40

	// FNUM: DEVICE Device Frame Number
	// Position of MFNUM field.
	USB_DEVICE_FNUM_MFNUM_Pos = 0x0
	// Bit mask of MFNUM field.
	USB_DEVICE_FNUM_MFNUM_Msk = 0x7
	// Position of FNUM field.
	USB_DEVICE_FNUM_FNUM_Pos = 0x3
	// Bit mask of FNUM field.
	USB_DEVICE_FNUM_FNUM_Msk = 0x3ff8
	// Position of FNCERR field.
	USB_DEVICE_FNUM_FNCERR_Pos = 0xf
	// Bit mask of FNCERR field.
	USB_DEVICE_FNUM_FNCERR_Msk = 0x8000
	// Bit FNCERR.
	USB_DEVICE_FNUM_FNCERR = 0x8000

	// INTENCLR: DEVICE Device Interrupt Enable Clear
	// Position of SUSPEND field.
	USB_DEVICE_INTENCLR_SUSPEND_Pos = 0x0
	// Bit mask of SUSPEND field.
	USB_DEVICE_INTENCLR_SUSPEND_Msk = 0x1
	// Bit SUSPEND.
	USB_DEVICE_INTENCLR_SUSPEND = 0x1
	// Position of MSOF field.
	USB_DEVICE_INTENCLR_MSOF_Pos = 0x1
	// Bit mask of MSOF field.
	USB_DEVICE_INTENCLR_MSOF_Msk = 0x2
	// Bit MSOF.
	USB_DEVICE_INTENCLR_MSOF = 0x2
	// Position of SOF field.
	USB_DEVICE_INTENCLR_SOF_Pos = 0x2
	// Bit mask of SOF field.
	USB_DEVICE_INTENCLR_SOF_Msk = 0x4
	// Bit SOF.
	USB_DEVICE_INTENCLR_SOF = 0x4
	// Position of EORST field.
	USB_DEVICE_INTENCLR_EORST_Pos = 0x3
	// Bit mask of EORST field.
	USB_DEVICE_INTENCLR_EORST_Msk = 0x8
	// Bit EORST.
	USB_DEVICE_INTENCLR_EORST = 0x8
	// Position of WAKEUP field.
	USB_DEVICE_INTENCLR_WAKEUP_Pos = 0x4
	// Bit mask of WAKEUP field.
	USB_DEVICE_INTENCLR_WAKEUP_Msk = 0x10
	// Bit WAKEUP.
	USB_DEVICE_INTENCLR_WAKEUP = 0x10
	// Position of EORSM field.
	USB_DEVICE_INTENCLR_EORSM_Pos = 0x5
	// Bit mask of EORSM field.
	USB_DEVICE_INTENCLR_EORSM_Msk = 0x20
	// Bit EORSM.
	USB_DEVICE_INTENCLR_EORSM = 0x20
	// Position of UPRSM field.
	USB_DEVICE_INTENCLR_UPRSM_Pos = 0x6
	// Bit mask of UPRSM field.
	USB_DEVICE_INTENCLR_UPRSM_Msk = 0x40
	// Bit UPRSM.
	USB_DEVICE_INTENCLR_UPRSM = 0x40
	// Position of RAMACER field.
	USB_DEVICE_INTENCLR_RAMACER_Pos = 0x7
	// Bit mask of RAMACER field.
	USB_DEVICE_INTENCLR_RAMACER_Msk = 0x80
	// Bit RAMACER.
	USB_DEVICE_INTENCLR_RAMACER = 0x80
	// Position of LPMNYET field.
	USB_DEVICE_INTENCLR_LPMNYET_Pos = 0x8
	// Bit mask of LPMNYET field.
	USB_DEVICE_INTENCLR_LPMNYET_Msk = 0x100
	// Bit LPMNYET.
	USB_DEVICE_INTENCLR_LPMNYET = 0x100
	// Position of LPMSUSP field.
	USB_DEVICE_INTENCLR_LPMSUSP_Pos = 0x9
	// Bit mask of LPMSUSP field.
	USB_DEVICE_INTENCLR_LPMSUSP_Msk = 0x200
	// Bit LPMSUSP.
	USB_DEVICE_INTENCLR_LPMSUSP = 0x200

	// INTENSET: DEVICE Device Interrupt Enable Set
	// Position of SUSPEND field.
	USB_DEVICE_INTENSET_SUSPEND_Pos = 0x0
	// Bit mask of SUSPEND field.
	USB_DEVICE_INTENSET_SUSPEND_Msk = 0x1
	// Bit SUSPEND.
	USB_DEVICE_INTENSET_SUSPEND = 0x1
	// Position of MSOF field.
	USB_DEVICE_INTENSET_MSOF_Pos = 0x1
	// Bit mask of MSOF field.
	USB_DEVICE_INTENSET_MSOF_Msk = 0x2
	// Bit MSOF.
	USB_DEVICE_INTENSET_MSOF = 0x2
	// Position of SOF field.
	USB_DEVICE_INTENSET_SOF_Pos = 0x2
	// Bit mask of SOF field.
	USB_DEVICE_INTENSET_SOF_Msk = 0x4
	// Bit SOF.
	USB_DEVICE_INTENSET_SOF = 0x4
	// Position of EORST field.
	USB_DEVICE_INTENSET_EORST_Pos = 0x3
	// Bit mask of EORST field.
	USB_DEVICE_INTENSET_EORST_Msk = 0x8
	// Bit EORST.
	USB_DEVICE_INTENSET_EORST = 0x8
	// Position of WAKEUP field.
	USB_DEVICE_INTENSET_WAKEUP_Pos = 0x4
	// Bit mask of WAKEUP field.
	USB_DEVICE_INTENSET_WAKEUP_Msk = 0x10
	// Bit WAKEUP.
	USB_DEVICE_INTENSET_WAKEUP = 0x10
	// Position of EORSM field.
	USB_DEVICE_INTENSET_EORSM_Pos = 0x5
	// Bit mask of EORSM field.
	USB_DEVICE_INTENSET_EORSM_Msk = 0x20
	// Bit EORSM.
	USB_DEVICE_INTENSET_EORSM = 0x20
	// Position of UPRSM field.
	USB_DEVICE_INTENSET_UPRSM_Pos = 0x6
	// Bit mask of UPRSM field.
	USB_DEVICE_INTENSET_UPRSM_Msk = 0x40
	// Bit UPRSM.
	USB_DEVICE_INTENSET_UPRSM = 0x40
	// Position of RAMACER field.
	USB_DEVICE_INTENSET_RAMACER_Pos = 0x7
	// Bit mask of RAMACER field.
	USB_DEVICE_INTENSET_RAMACER_Msk = 0x80
	// Bit RAMACER.
	USB_DEVICE_INTENSET_RAMACER = 0x80
	// Position of LPMNYET field.
	USB_DEVICE_INTENSET_LPMNYET_Pos = 0x8
	// Bit mask of LPMNYET field.
	USB_DEVICE_INTENSET_LPMNYET_Msk = 0x100
	// Bit LPMNYET.
	USB_DEVICE_INTENSET_LPMNYET = 0x100
	// Position of LPMSUSP field.
	USB_DEVICE_INTENSET_LPMSUSP_Pos = 0x9
	// Bit mask of LPMSUSP field.
	USB_DEVICE_INTENSET_LPMSUSP_Msk = 0x200
	// Bit LPMSUSP.
	USB_DEVICE_INTENSET_LPMSUSP = 0x200

	// INTFLAG: DEVICE Device Interrupt Flag
	// Position of SUSPEND field.
	USB_DEVICE_INTFLAG_SUSPEND_Pos = 0x0
	// Bit mask of SUSPEND field.
	USB_DEVICE_INTFLAG_SUSPEND_Msk = 0x1
	// Bit SUSPEND.
	USB_DEVICE_INTFLAG_SUSPEND = 0x1
	// Position of MSOF field.
	USB_DEVICE_INTFLAG_MSOF_Pos = 0x1
	// Bit mask of MSOF field.
	USB_DEVICE_INTFLAG_MSOF_Msk = 0x2
	// Bit MSOF.
	USB_DEVICE_INTFLAG_MSOF = 0x2
	// Position of SOF field.
	USB_DEVICE_INTFLAG_SOF_Pos = 0x2
	// Bit mask of SOF field.
	USB_DEVICE_INTFLAG_SOF_Msk = 0x4
	// Bit SOF.
	USB_DEVICE_INTFLAG_SOF = 0x4
	// Position of EORST field.
	USB_DEVICE_INTFLAG_EORST_Pos = 0x3
	// Bit mask of EORST field.
	USB_DEVICE_INTFLAG_EORST_Msk = 0x8
	// Bit EORST.
	USB_DEVICE_INTFLAG_EORST = 0x8
	// Position of WAKEUP field.
	USB_DEVICE_INTFLAG_WAKEUP_Pos = 0x4
	// Bit mask of WAKEUP field.
	USB_DEVICE_INTFLAG_WAKEUP_Msk = 0x10
	// Bit WAKEUP.
	USB_DEVICE_INTFLAG_WAKEUP = 0x10
	// Position of EORSM field.
	USB_DEVICE_INTFLAG_EORSM_Pos = 0x5
	// Bit mask of EORSM field.
	USB_DEVICE_INTFLAG_EORSM_Msk = 0x20
	// Bit EORSM.
	USB_DEVICE_INTFLAG_EORSM = 0x20
	// Position of UPRSM field.
	USB_DEVICE_INTFLAG_UPRSM_Pos = 0x6
	// Bit mask of UPRSM field.
	USB_DEVICE_INTFLAG_UPRSM_Msk = 0x40
	// Bit UPRSM.
	USB_DEVICE_INTFLAG_UPRSM = 0x40
	// Position of RAMACER field.
	USB_DEVICE_INTFLAG_RAMACER_Pos = 0x7
	// Bit mask of RAMACER field.
	USB_DEVICE_INTFLAG_RAMACER_Msk = 0x80
	// Bit RAMACER.
	USB_DEVICE_INTFLAG_RAMACER = 0x80
	// Position of LPMNYET field.
	USB_DEVICE_INTFLAG_LPMNYET_Pos = 0x8
	// Bit mask of LPMNYET field.
	USB_DEVICE_INTFLAG_LPMNYET_Msk = 0x100
	// Bit LPMNYET.
	USB_DEVICE_INTFLAG_LPMNYET = 0x100
	// Position of LPMSUSP field.
	USB_DEVICE_INTFLAG_LPMSUSP_Pos = 0x9
	// Bit mask of LPMSUSP field.
	USB_DEVICE_INTFLAG_LPMSUSP_Msk = 0x200
	// Bit LPMSUSP.
	USB_DEVICE_INTFLAG_LPMSUSP = 0x200

	// EPINTSMRY: DEVICE End Point Interrupt Summary
	// Position of EPINT0 field.
	USB_DEVICE_EPINTSMRY_EPINT0_Pos = 0x0
	// Bit mask of EPINT0 field.
	USB_DEVICE_EPINTSMRY_EPINT0_Msk = 0x1
	// Bit EPINT0.
	USB_DEVICE_EPINTSMRY_EPINT0 = 0x1
	// Position of EPINT1 field.
	USB_DEVICE_EPINTSMRY_EPINT1_Pos = 0x1
	// Bit mask of EPINT1 field.
	USB_DEVICE_EPINTSMRY_EPINT1_Msk = 0x2
	// Bit EPINT1.
	USB_DEVICE_EPINTSMRY_EPINT1 = 0x2
	// Position of EPINT2 field.
	USB_DEVICE_EPINTSMRY_EPINT2_Pos = 0x2
	// Bit mask of EPINT2 field.
	USB_DEVICE_EPINTSMRY_EPINT2_Msk = 0x4
	// Bit EPINT2.
	USB_DEVICE_EPINTSMRY_EPINT2 = 0x4
	// Position of EPINT3 field.
	USB_DEVICE_EPINTSMRY_EPINT3_Pos = 0x3
	// Bit mask of EPINT3 field.
	USB_DEVICE_EPINTSMRY_EPINT3_Msk = 0x8
	// Bit EPINT3.
	USB_DEVICE_EPINTSMRY_EPINT3 = 0x8
	// Position of EPINT4 field.
	USB_DEVICE_EPINTSMRY_EPINT4_Pos = 0x4
	// Bit mask of EPINT4 field.
	USB_DEVICE_EPINTSMRY_EPINT4_Msk = 0x10
	// Bit EPINT4.
	USB_DEVICE_EPINTSMRY_EPINT4 = 0x10
	// Position of EPINT5 field.
	USB_DEVICE_EPINTSMRY_EPINT5_Pos = 0x5
	// Bit mask of EPINT5 field.
	USB_DEVICE_EPINTSMRY_EPINT5_Msk = 0x20
	// Bit EPINT5.
	USB_DEVICE_EPINTSMRY_EPINT5 = 0x20
	// Position of EPINT6 field.
	USB_DEVICE_EPINTSMRY_EPINT6_Pos = 0x6
	// Bit mask of EPINT6 field.
	USB_DEVICE_EPINTSMRY_EPINT6_Msk = 0x40
	// Bit EPINT6.
	USB_DEVICE_EPINTSMRY_EPINT6 = 0x40
	// Position of EPINT7 field.
	USB_DEVICE_EPINTSMRY_EPINT7_Pos = 0x7
	// Bit mask of EPINT7 field.
	USB_DEVICE_EPINTSMRY_EPINT7_Msk = 0x80
	// Bit EPINT7.
	USB_DEVICE_EPINTSMRY_EPINT7 = 0x80

	// DESCADD: Descriptor Address
	// Position of DESCADD field.
	USB_DEVICE_DESCADD_DESCADD_Pos = 0x0
	// Bit mask of DESCADD field.
	USB_DEVICE_DESCADD_DESCADD_Msk = 0xffffffff

	// PADCAL: USB PAD Calibration
	// Position of TRANSP field.
	USB_DEVICE_PADCAL_TRANSP_Pos = 0x0
	// Bit mask of TRANSP field.
	USB_DEVICE_PADCAL_TRANSP_Msk = 0x1f
	// Position of TRANSN field.
	USB_DEVICE_PADCAL_TRANSN_Pos = 0x6
	// Bit mask of TRANSN field.
	USB_DEVICE_PADCAL_TRANSN_Msk = 0x7c0
	// Position of TRIM field.
	USB_DEVICE_PADCAL_TRIM_Pos = 0xc
	// Bit mask of TRIM field.
	USB_DEVICE_PADCAL_TRIM_Msk = 0x7000

	// DEVICE_ENDPOINT.EPCFG: DEVICE_ENDPOINT End Point Configuration
	// Position of EPTYPE0 field.
	USB_DEVICE_ENDPOINT_EPCFG_EPTYPE0_Pos = 0x0
	// Bit mask of EPTYPE0 field.
	USB_DEVICE_ENDPOINT_EPCFG_EPTYPE0_Msk = 0x7
	// Position of EPTYPE1 field.
	USB_DEVICE_ENDPOINT_EPCFG_EPTYPE1_Pos = 0x4
	// Bit mask of EPTYPE1 field.
	USB_DEVICE_ENDPOINT_EPCFG_EPTYPE1_Msk = 0x70
	// Position of NYETDIS field.
	USB_DEVICE_ENDPOINT_EPCFG_NYETDIS_Pos = 0x7
	// Bit mask of NYETDIS field.
	USB_DEVICE_ENDPOINT_EPCFG_NYETDIS_Msk = 0x80
	// Bit NYETDIS.
	USB_DEVICE_ENDPOINT_EPCFG_NYETDIS = 0x80

	// DEVICE_ENDPOINT.EPSTATUSCLR: DEVICE_ENDPOINT End Point Pipe Status Clear
	// Position of DTGLOUT field.
	USB_DEVICE_ENDPOINT_EPSTATUSCLR_DTGLOUT_Pos = 0x0
	// Bit mask of DTGLOUT field.
	USB_DEVICE_ENDPOINT_EPSTATUSCLR_DTGLOUT_Msk = 0x1
	// Bit DTGLOUT.
	USB_DEVICE_ENDPOINT_EPSTATUSCLR_DTGLOUT = 0x1
	// Position of DTGLIN field.
	USB_DEVICE_ENDPOINT_EPSTATUSCLR_DTGLIN_Pos = 0x1
	// Bit mask of DTGLIN field.
	USB_DEVICE_ENDPOINT_EPSTATUSCLR_DTGLIN_Msk = 0x2
	// Bit DTGLIN.
	USB_DEVICE_ENDPOINT_EPSTATUSCLR_DTGLIN = 0x2
	// Position of CURBK field.
	USB_DEVICE_ENDPOINT_EPSTATUSCLR_CURBK_Pos = 0x2
	// Bit mask of CURBK field.
	USB_DEVICE_ENDPOINT_EPSTATUSCLR_CURBK_Msk = 0x4
	// Bit CURBK.
	USB_DEVICE_ENDPOINT_EPSTATUSCLR_CURBK = 0x4
	// Position of STALLRQ0 field.
	USB_DEVICE_ENDPOINT_EPSTATUSCLR_STALLRQ0_Pos = 0x4
	// Bit mask of STALLRQ0 field.
	USB_DEVICE_ENDPOINT_EPSTATUSCLR_STALLRQ0_Msk = 0x10
	// Bit STALLRQ0.
	USB_DEVICE_ENDPOINT_EPSTATUSCLR_STALLRQ0 = 0x10
	// Position of STALLRQ1 field.
	USB_DEVICE_ENDPOINT_EPSTATUSCLR_STALLRQ1_Pos = 0x5
	// Bit mask of STALLRQ1 field.
	USB_DEVICE_ENDPOINT_EPSTATUSCLR_STALLRQ1_Msk = 0x20
	// Bit STALLRQ1.
	USB_DEVICE_ENDPOINT_EPSTATUSCLR_STALLRQ1 = 0x20
	// Position of BK0RDY field.
	USB_DEVICE_ENDPOINT_EPSTATUSCLR_BK0RDY_Pos = 0x6
	// Bit mask of BK0RDY field.
	USB_DEVICE_ENDPOINT_EPSTATUSCLR_BK0RDY_Msk = 0x40
	// Bit BK0RDY.
	USB_DEVICE_ENDPOINT_EPSTATUSCLR_BK0RDY = 0x40
	// Position of BK1RDY field.
	USB_DEVICE_ENDPOINT_EPSTATUSCLR_BK1RDY_Pos = 0x7
	// Bit mask of BK1RDY field.
	USB_DEVICE_ENDPOINT_EPSTATUSCLR_BK1RDY_Msk = 0x80
	// Bit BK1RDY.
	USB_DEVICE_ENDPOINT_EPSTATUSCLR_BK1RDY = 0x80

	// DEVICE_ENDPOINT.EPSTATUSSET: DEVICE_ENDPOINT End Point Pipe Status Set
	// Position of DTGLOUT field.
	USB_DEVICE_ENDPOINT_EPSTATUSSET_DTGLOUT_Pos = 0x0
	// Bit mask of DTGLOUT field.
	USB_DEVICE_ENDPOINT_EPSTATUSSET_DTGLOUT_Msk = 0x1
	// Bit DTGLOUT.
	USB_DEVICE_ENDPOINT_EPSTATUSSET_DTGLOUT = 0x1
	// Position of DTGLIN field.
	USB_DEVICE_ENDPOINT_EPSTATUSSET_DTGLIN_Pos = 0x1
	// Bit mask of DTGLIN field.
	USB_DEVICE_ENDPOINT_EPSTATUSSET_DTGLIN_Msk = 0x2
	// Bit DTGLIN.
	USB_DEVICE_ENDPOINT_EPSTATUSSET_DTGLIN = 0x2
	// Position of CURBK field.
	USB_DEVICE_ENDPOINT_EPSTATUSSET_CURBK_Pos = 0x2
	// Bit mask of CURBK field.
	USB_DEVICE_ENDPOINT_EPSTATUSSET_CURBK_Msk = 0x4
	// Bit CURBK.
	USB_DEVICE_ENDPOINT_EPSTATUSSET_CURBK = 0x4
	// Position of STALLRQ0 field.
	USB_DEVICE_ENDPOINT_EPSTATUSSET_STALLRQ0_Pos = 0x4
	// Bit mask of STALLRQ0 field.
	USB_DEVICE_ENDPOINT_EPSTATUSSET_STALLRQ0_Msk = 0x10
	// Bit STALLRQ0.
	USB_DEVICE_ENDPOINT_EPSTATUSSET_STALLRQ0 = 0x10
	// Position of STALLRQ1 field.
	USB_DEVICE_ENDPOINT_EPSTATUSSET_STALLRQ1_Pos = 0x5
	// Bit mask of STALLRQ1 field.
	USB_DEVICE_ENDPOINT_EPSTATUSSET_STALLRQ1_Msk = 0x20
	// Bit STALLRQ1.
	USB_DEVICE_ENDPOINT_EPSTATUSSET_STALLRQ1 = 0x20
	// Position of BK0RDY field.
	USB_DEVICE_ENDPOINT_EPSTATUSSET_BK0RDY_Pos = 0x6
	// Bit mask of BK0RDY field.
	USB_DEVICE_ENDPOINT_EPSTATUSSET_BK0RDY_Msk = 0x40
	// Bit BK0RDY.
	USB_DEVICE_ENDPOINT_EPSTATUSSET_BK0RDY = 0x40
	// Position of BK1RDY field.
	USB_DEVICE_ENDPOINT_EPSTATUSSET_BK1RDY_Pos = 0x7
	// Bit mask of BK1RDY field.
	USB_DEVICE_ENDPOINT_EPSTATUSSET_BK1RDY_Msk = 0x80
	// Bit BK1RDY.
	USB_DEVICE_ENDPOINT_EPSTATUSSET_BK1RDY = 0x80

	// DEVICE_ENDPOINT.EPSTATUS: DEVICE_ENDPOINT End Point Pipe Status
	// Position of DTGLOUT field.
	USB_DEVICE_ENDPOINT_EPSTATUS_DTGLOUT_Pos = 0x0
	// Bit mask of DTGLOUT field.
	USB_DEVICE_ENDPOINT_EPSTATUS_DTGLOUT_Msk = 0x1
	// Bit DTGLOUT.
	USB_DEVICE_ENDPOINT_EPSTATUS_DTGLOUT = 0x1
	// Position of DTGLIN field.
	USB_DEVICE_ENDPOINT_EPSTATUS_DTGLIN_Pos = 0x1
	// Bit mask of DTGLIN field.
	USB_DEVICE_ENDPOINT_EPSTATUS_DTGLIN_Msk = 0x2
	// Bit DTGLIN.
	USB_DEVICE_ENDPOINT_EPSTATUS_DTGLIN = 0x2
	// Position of CURBK field.
	USB_DEVICE_ENDPOINT_EPSTATUS_CURBK_Pos = 0x2
	// Bit mask of CURBK field.
	USB_DEVICE_ENDPOINT_EPSTATUS_CURBK_Msk = 0x4
	// Bit CURBK.
	USB_DEVICE_ENDPOINT_EPSTATUS_CURBK = 0x4
	// Position of STALLRQ0 field.
	USB_DEVICE_ENDPOINT_EPSTATUS_STALLRQ0_Pos = 0x4
	// Bit mask of STALLRQ0 field.
	USB_DEVICE_ENDPOINT_EPSTATUS_STALLRQ0_Msk = 0x10
	// Bit STALLRQ0.
	USB_DEVICE_ENDPOINT_EPSTATUS_STALLRQ0 = 0x10
	// Position of STALLRQ1 field.
	USB_DEVICE_ENDPOINT_EPSTATUS_STALLRQ1_Pos = 0x5
	// Bit mask of STALLRQ1 field.
	USB_DEVICE_ENDPOINT_EPSTATUS_STALLRQ1_Msk = 0x20
	// Bit STALLRQ1.
	USB_DEVICE_ENDPOINT_EPSTATUS_STALLRQ1 = 0x20
	// Position of BK0RDY field.
	USB_DEVICE_ENDPOINT_EPSTATUS_BK0RDY_Pos = 0x6
	// Bit mask of BK0RDY field.
	USB_DEVICE_ENDPOINT_EPSTATUS_BK0RDY_Msk = 0x40
	// Bit BK0RDY.
	USB_DEVICE_ENDPOINT_EPSTATUS_BK0RDY = 0x40
	// Position of BK1RDY field.
	USB_DEVICE_ENDPOINT_EPSTATUS_BK1RDY_Pos = 0x7
	// Bit mask of BK1RDY field.
	USB_DEVICE_ENDPOINT_EPSTATUS_BK1RDY_Msk = 0x80
	// Bit BK1RDY.
	USB_DEVICE_ENDPOINT_EPSTATUS_BK1RDY = 0x80

	// DEVICE_ENDPOINT.EPINTFLAG: DEVICE_ENDPOINT End Point Interrupt Flag
	// Position of TRCPT0 field.
	USB_DEVICE_ENDPOINT_EPINTFLAG_TRCPT0_Pos = 0x0
	// Bit mask of TRCPT0 field.
	USB_DEVICE_ENDPOINT_EPINTFLAG_TRCPT0_Msk = 0x1
	// Bit TRCPT0.
	USB_DEVICE_ENDPOINT_EPINTFLAG_TRCPT0 = 0x1
	// Position of TRCPT1 field.
	USB_DEVICE_ENDPOINT_EPINTFLAG_TRCPT1_Pos = 0x1
	// Bit mask of TRCPT1 field.
	USB_DEVICE_ENDPOINT_EPINTFLAG_TRCPT1_Msk = 0x2
	// Bit TRCPT1.
	USB_DEVICE_ENDPOINT_EPINTFLAG_TRCPT1 = 0x2
	// Position of TRFAIL0 field.
	USB_DEVICE_ENDPOINT_EPINTFLAG_TRFAIL0_Pos = 0x2
	// Bit mask of TRFAIL0 field.
	USB_DEVICE_ENDPOINT_EPINTFLAG_TRFAIL0_Msk = 0x4
	// Bit TRFAIL0.
	USB_DEVICE_ENDPOINT_EPINTFLAG_TRFAIL0 = 0x4
	// Position of TRFAIL1 field.
	USB_DEVICE_ENDPOINT_EPINTFLAG_TRFAIL1_Pos = 0x3
	// Bit mask of TRFAIL1 field.
	USB_DEVICE_ENDPOINT_EPINTFLAG_TRFAIL1_Msk = 0x8
	// Bit TRFAIL1.
	USB_DEVICE_ENDPOINT_EPINTFLAG_TRFAIL1 = 0x8
	// Position of RXSTP field.
	USB_DEVICE_ENDPOINT_EPINTFLAG_RXSTP_Pos = 0x4
	// Bit mask of RXSTP field.
	USB_DEVICE_ENDPOINT_EPINTFLAG_RXSTP_Msk = 0x10
	// Bit RXSTP.
	USB_DEVICE_ENDPOINT_EPINTFLAG_RXSTP = 0x10
	// Position of STALL0 field.
	USB_DEVICE_ENDPOINT_EPINTFLAG_STALL0_Pos = 0x5
	// Bit mask of STALL0 field.
	USB_DEVICE_ENDPOINT_EPINTFLAG_STALL0_Msk = 0x20
	// Bit STALL0.
	USB_DEVICE_ENDPOINT_EPINTFLAG_STALL0 = 0x20
	// Position of STALL1 field.
	USB_DEVICE_ENDPOINT_EPINTFLAG_STALL1_Pos = 0x6
	// Bit mask of STALL1 field.
	USB_DEVICE_ENDPOINT_EPINTFLAG_STALL1_Msk = 0x40
	// Bit STALL1.
	USB_DEVICE_ENDPOINT_EPINTFLAG_STALL1 = 0x40

	// DEVICE_ENDPOINT.EPINTENCLR: DEVICE_ENDPOINT End Point Interrupt Clear Flag
	// Position of TRCPT0 field.
	USB_DEVICE_ENDPOINT_EPINTENCLR_TRCPT0_Pos = 0x0
	// Bit mask of TRCPT0 field.
	USB_DEVICE_ENDPOINT_EPINTENCLR_TRCPT0_Msk = 0x1
	// Bit TRCPT0.
	USB_DEVICE_ENDPOINT_EPINTENCLR_TRCPT0 = 0x1
	// Position of TRCPT1 field.
	USB_DEVICE_ENDPOINT_EPINTENCLR_TRCPT1_Pos = 0x1
	// Bit mask of TRCPT1 field.
	USB_DEVICE_ENDPOINT_EPINTENCLR_TRCPT1_Msk = 0x2
	// Bit TRCPT1.
	USB_DEVICE_ENDPOINT_EPINTENCLR_TRCPT1 = 0x2
	// Position of TRFAIL0 field.
	USB_DEVICE_ENDPOINT_EPINTENCLR_TRFAIL0_Pos = 0x2
	// Bit mask of TRFAIL0 field.
	USB_DEVICE_ENDPOINT_EPINTENCLR_TRFAIL0_Msk = 0x4
	// Bit TRFAIL0.
	USB_DEVICE_ENDPOINT_EPINTENCLR_TRFAIL0 = 0x4
	// Position of TRFAIL1 field.
	USB_DEVICE_ENDPOINT_EPINTENCLR_TRFAIL1_Pos = 0x3
	// Bit mask of TRFAIL1 field.
	USB_DEVICE_ENDPOINT_EPINTENCLR_TRFAIL1_Msk = 0x8
	// Bit TRFAIL1.
	USB_DEVICE_ENDPOINT_EPINTENCLR_TRFAIL1 = 0x8
	// Position of RXSTP field.
	USB_DEVICE_ENDPOINT_EPINTENCLR_RXSTP_Pos = 0x4
	// Bit mask of RXSTP field.
	USB_DEVICE_ENDPOINT_EPINTENCLR_RXSTP_Msk = 0x10
	// Bit RXSTP.
	USB_DEVICE_ENDPOINT_EPINTENCLR_RXSTP = 0x10
	// Position of STALL0 field.
	USB_DEVICE_ENDPOINT_EPINTENCLR_STALL0_Pos = 0x5
	// Bit mask of STALL0 field.
	USB_DEVICE_ENDPOINT_EPINTENCLR_STALL0_Msk = 0x20
	// Bit STALL0.
	USB_DEVICE_ENDPOINT_EPINTENCLR_STALL0 = 0x20
	// Position of STALL1 field.
	USB_DEVICE_ENDPOINT_EPINTENCLR_STALL1_Pos = 0x6
	// Bit mask of STALL1 field.
	USB_DEVICE_ENDPOINT_EPINTENCLR_STALL1_Msk = 0x40
	// Bit STALL1.
	USB_DEVICE_ENDPOINT_EPINTENCLR_STALL1 = 0x40

	// DEVICE_ENDPOINT.EPINTENSET: DEVICE_ENDPOINT End Point Interrupt Set Flag
	// Position of TRCPT0 field.
	USB_DEVICE_ENDPOINT_EPINTENSET_TRCPT0_Pos = 0x0
	// Bit mask of TRCPT0 field.
	USB_DEVICE_ENDPOINT_EPINTENSET_TRCPT0_Msk = 0x1
	// Bit TRCPT0.
	USB_DEVICE_ENDPOINT_EPINTENSET_TRCPT0 = 0x1
	// Position of TRCPT1 field.
	USB_DEVICE_ENDPOINT_EPINTENSET_TRCPT1_Pos = 0x1
	// Bit mask of TRCPT1 field.
	USB_DEVICE_ENDPOINT_EPINTENSET_TRCPT1_Msk = 0x2
	// Bit TRCPT1.
	USB_DEVICE_ENDPOINT_EPINTENSET_TRCPT1 = 0x2
	// Position of TRFAIL0 field.
	USB_DEVICE_ENDPOINT_EPINTENSET_TRFAIL0_Pos = 0x2
	// Bit mask of TRFAIL0 field.
	USB_DEVICE_ENDPOINT_EPINTENSET_TRFAIL0_Msk = 0x4
	// Bit TRFAIL0.
	USB_DEVICE_ENDPOINT_EPINTENSET_TRFAIL0 = 0x4
	// Position of TRFAIL1 field.
	USB_DEVICE_ENDPOINT_EPINTENSET_TRFAIL1_Pos = 0x3
	// Bit mask of TRFAIL1 field.
	USB_DEVICE_ENDPOINT_EPINTENSET_TRFAIL1_Msk = 0x8
	// Bit TRFAIL1.
	USB_DEVICE_ENDPOINT_EPINTENSET_TRFAIL1 = 0x8
	// Position of RXSTP field.
	USB_DEVICE_ENDPOINT_EPINTENSET_RXSTP_Pos = 0x4
	// Bit mask of RXSTP field.
	USB_DEVICE_ENDPOINT_EPINTENSET_RXSTP_Msk = 0x10
	// Bit RXSTP.
	USB_DEVICE_ENDPOINT_EPINTENSET_RXSTP = 0x10
	// Position of STALL0 field.
	USB_DEVICE_ENDPOINT_EPINTENSET_STALL0_Pos = 0x5
	// Bit mask of STALL0 field.
	USB_DEVICE_ENDPOINT_EPINTENSET_STALL0_Msk = 0x20
	// Bit STALL0.
	USB_DEVICE_ENDPOINT_EPINTENSET_STALL0 = 0x20
	// Position of STALL1 field.
	USB_DEVICE_ENDPOINT_EPINTENSET_STALL1_Pos = 0x6
	// Bit mask of STALL1 field.
	USB_DEVICE_ENDPOINT_EPINTENSET_STALL1_Msk = 0x40
	// Bit STALL1.
	USB_DEVICE_ENDPOINT_EPINTENSET_STALL1 = 0x40
)

// Constants for USB_HOST: Universal Serial Bus - HOST
const (
	// CTRLA: Control A
	// Position of SWRST field.
	USB_HOST_CTRLA_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	USB_HOST_CTRLA_SWRST_Msk = 0x1
	// Bit SWRST.
	USB_HOST_CTRLA_SWRST = 0x1
	// Position of ENABLE field.
	USB_HOST_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	USB_HOST_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	USB_HOST_CTRLA_ENABLE = 0x2
	// Position of RUNSTDBY field.
	USB_HOST_CTRLA_RUNSTDBY_Pos = 0x2
	// Bit mask of RUNSTDBY field.
	USB_HOST_CTRLA_RUNSTDBY_Msk = 0x4
	// Bit RUNSTDBY.
	USB_HOST_CTRLA_RUNSTDBY = 0x4
	// Position of MODE field.
	USB_HOST_CTRLA_MODE_Pos = 0x7
	// Bit mask of MODE field.
	USB_HOST_CTRLA_MODE_Msk = 0x80
	// Bit MODE.
	USB_HOST_CTRLA_MODE = 0x80
	// Device Mode
	USB_HOST_CTRLA_MODE_DEVICE = 0x0
	// Host Mode
	USB_HOST_CTRLA_MODE_HOST = 0x1

	// SYNCBUSY: Synchronization Busy
	// Position of SWRST field.
	USB_HOST_SYNCBUSY_SWRST_Pos = 0x0
	// Bit mask of SWRST field.
	USB_HOST_SYNCBUSY_SWRST_Msk = 0x1
	// Bit SWRST.
	USB_HOST_SYNCBUSY_SWRST = 0x1
	// Position of ENABLE field.
	USB_HOST_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	USB_HOST_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	USB_HOST_SYNCBUSY_ENABLE = 0x2

	// QOSCTRL: USB Quality Of Service
	// Position of CQOS field.
	USB_HOST_QOSCTRL_CQOS_Pos = 0x0
	// Bit mask of CQOS field.
	USB_HOST_QOSCTRL_CQOS_Msk = 0x3
	// Position of DQOS field.
	USB_HOST_QOSCTRL_DQOS_Pos = 0x2
	// Bit mask of DQOS field.
	USB_HOST_QOSCTRL_DQOS_Msk = 0xc

	// CTRLB: HOST Control B
	// Position of RESUME field.
	USB_HOST_CTRLB_RESUME_Pos = 0x1
	// Bit mask of RESUME field.
	USB_HOST_CTRLB_RESUME_Msk = 0x2
	// Bit RESUME.
	USB_HOST_CTRLB_RESUME = 0x2
	// Position of SPDCONF field.
	USB_HOST_CTRLB_SPDCONF_Pos = 0x2
	// Bit mask of SPDCONF field.
	USB_HOST_CTRLB_SPDCONF_Msk = 0xc
	// Normal mode: the host starts in full-speed mode and performs a high-speed reset to switch to the high speed mode if the downstream peripheral is high-speed capable.
	USB_HOST_CTRLB_SPDCONF_NORMAL = 0x0
	// Full-speed: the host remains in full-speed mode whatever is the peripheral speed capability. Relevant in UTMI mode only.
	USB_HOST_CTRLB_SPDCONF_FS = 0x3
	// Position of AUTORESUME field.
	USB_HOST_CTRLB_AUTORESUME_Pos = 0x4
	// Bit mask of AUTORESUME field.
	USB_HOST_CTRLB_AUTORESUME_Msk = 0x10
	// Bit AUTORESUME.
	USB_HOST_CTRLB_AUTORESUME = 0x10
	// Position of TSTJ field.
	USB_HOST_CTRLB_TSTJ_Pos = 0x5
	// Bit mask of TSTJ field.
	USB_HOST_CTRLB_TSTJ_Msk = 0x20
	// Bit TSTJ.
	USB_HOST_CTRLB_TSTJ = 0x20
	// Position of TSTK field.
	USB_HOST_CTRLB_TSTK_Pos = 0x6
	// Bit mask of TSTK field.
	USB_HOST_CTRLB_TSTK_Msk = 0x40
	// Bit TSTK.
	USB_HOST_CTRLB_TSTK = 0x40
	// Position of SOFE field.
	USB_HOST_CTRLB_SOFE_Pos = 0x8
	// Bit mask of SOFE field.
	USB_HOST_CTRLB_SOFE_Msk = 0x100
	// Bit SOFE.
	USB_HOST_CTRLB_SOFE = 0x100
	// Position of BUSRESET field.
	USB_HOST_CTRLB_BUSRESET_Pos = 0x9
	// Bit mask of BUSRESET field.
	USB_HOST_CTRLB_BUSRESET_Msk = 0x200
	// Bit BUSRESET.
	USB_HOST_CTRLB_BUSRESET = 0x200
	// Position of VBUSOK field.
	USB_HOST_CTRLB_VBUSOK_Pos = 0xa
	// Bit mask of VBUSOK field.
	USB_HOST_CTRLB_VBUSOK_Msk = 0x400
	// Bit VBUSOK.
	USB_HOST_CTRLB_VBUSOK = 0x400
	// Position of L1RESUME field.
	USB_HOST_CTRLB_L1RESUME_Pos = 0xb
	// Bit mask of L1RESUME field.
	USB_HOST_CTRLB_L1RESUME_Msk = 0x800
	// Bit L1RESUME.
	USB_HOST_CTRLB_L1RESUME = 0x800

	// HSOFC: HOST Host Start Of Frame Control
	// Position of FLENC field.
	USB_HOST_HSOFC_FLENC_Pos = 0x0
	// Bit mask of FLENC field.
	USB_HOST_HSOFC_FLENC_Msk = 0xf
	// Position of FLENCE field.
	USB_HOST_HSOFC_FLENCE_Pos = 0x7
	// Bit mask of FLENCE field.
	USB_HOST_HSOFC_FLENCE_Msk = 0x80
	// Bit FLENCE.
	USB_HOST_HSOFC_FLENCE = 0x80

	// STATUS: HOST Status
	// Position of SPEED field.
	USB_HOST_STATUS_SPEED_Pos = 0x2
	// Bit mask of SPEED field.
	USB_HOST_STATUS_SPEED_Msk = 0xc
	// Position of LINESTATE field.
	USB_HOST_STATUS_LINESTATE_Pos = 0x6
	// Bit mask of LINESTATE field.
	USB_HOST_STATUS_LINESTATE_Msk = 0xc0

	// FSMSTATUS: Finite State Machine Status
	// Position of FSMSTATE field.
	USB_HOST_FSMSTATUS_FSMSTATE_Pos = 0x0
	// Bit mask of FSMSTATE field.
	USB_HOST_FSMSTATUS_FSMSTATE_Msk = 0x7f
	// OFF (L3). It corresponds to the powered-off, disconnected, and disabled state
	USB_HOST_FSMSTATUS_FSMSTATE_OFF = 0x1
	// ON (L0). It corresponds to the Idle and Active states
	USB_HOST_FSMSTATUS_FSMSTATE_ON = 0x2
	// SUSPEND (L2)
	USB_HOST_FSMSTATUS_FSMSTATE_SUSPEND = 0x4
	// SLEEP (L1)
	USB_HOST_FSMSTATUS_FSMSTATE_SLEEP = 0x8
	// DNRESUME. Down Stream Resume.
	USB_HOST_FSMSTATUS_FSMSTATE_DNRESUME = 0x10
	// UPRESUME. Up Stream Resume.
	USB_HOST_FSMSTATUS_FSMSTATE_UPRESUME = 0x20
	// RESET. USB lines Reset.
	USB_HOST_FSMSTATUS_FSMSTATE_RESET = 0x40

	// FNUM: HOST Host Frame Number
	// Position of MFNUM field.
	USB_HOST_FNUM_MFNUM_Pos = 0x0
	// Bit mask of MFNUM field.
	USB_HOST_FNUM_MFNUM_Msk = 0x7
	// Position of FNUM field.
	USB_HOST_FNUM_FNUM_Pos = 0x3
	// Bit mask of FNUM field.
	USB_HOST_FNUM_FNUM_Msk = 0x3ff8

	// FLENHIGH: HOST Host Frame Length
	// Position of FLENHIGH field.
	USB_HOST_FLENHIGH_FLENHIGH_Pos = 0x0
	// Bit mask of FLENHIGH field.
	USB_HOST_FLENHIGH_FLENHIGH_Msk = 0xff

	// INTENCLR: HOST Host Interrupt Enable Clear
	// Position of HSOF field.
	USB_HOST_INTENCLR_HSOF_Pos = 0x2
	// Bit mask of HSOF field.
	USB_HOST_INTENCLR_HSOF_Msk = 0x4
	// Bit HSOF.
	USB_HOST_INTENCLR_HSOF = 0x4
	// Position of RST field.
	USB_HOST_INTENCLR_RST_Pos = 0x3
	// Bit mask of RST field.
	USB_HOST_INTENCLR_RST_Msk = 0x8
	// Bit RST.
	USB_HOST_INTENCLR_RST = 0x8
	// Position of WAKEUP field.
	USB_HOST_INTENCLR_WAKEUP_Pos = 0x4
	// Bit mask of WAKEUP field.
	USB_HOST_INTENCLR_WAKEUP_Msk = 0x10
	// Bit WAKEUP.
	USB_HOST_INTENCLR_WAKEUP = 0x10
	// Position of DNRSM field.
	USB_HOST_INTENCLR_DNRSM_Pos = 0x5
	// Bit mask of DNRSM field.
	USB_HOST_INTENCLR_DNRSM_Msk = 0x20
	// Bit DNRSM.
	USB_HOST_INTENCLR_DNRSM = 0x20
	// Position of UPRSM field.
	USB_HOST_INTENCLR_UPRSM_Pos = 0x6
	// Bit mask of UPRSM field.
	USB_HOST_INTENCLR_UPRSM_Msk = 0x40
	// Bit UPRSM.
	USB_HOST_INTENCLR_UPRSM = 0x40
	// Position of RAMACER field.
	USB_HOST_INTENCLR_RAMACER_Pos = 0x7
	// Bit mask of RAMACER field.
	USB_HOST_INTENCLR_RAMACER_Msk = 0x80
	// Bit RAMACER.
	USB_HOST_INTENCLR_RAMACER = 0x80
	// Position of DCONN field.
	USB_HOST_INTENCLR_DCONN_Pos = 0x8
	// Bit mask of DCONN field.
	USB_HOST_INTENCLR_DCONN_Msk = 0x100
	// Bit DCONN.
	USB_HOST_INTENCLR_DCONN = 0x100
	// Position of DDISC field.
	USB_HOST_INTENCLR_DDISC_Pos = 0x9
	// Bit mask of DDISC field.
	USB_HOST_INTENCLR_DDISC_Msk = 0x200
	// Bit DDISC.
	USB_HOST_INTENCLR_DDISC = 0x200

	// INTENSET: HOST Host Interrupt Enable Set
	// Position of HSOF field.
	USB_HOST_INTENSET_HSOF_Pos = 0x2
	// Bit mask of HSOF field.
	USB_HOST_INTENSET_HSOF_Msk = 0x4
	// Bit HSOF.
	USB_HOST_INTENSET_HSOF = 0x4
	// Position of RST field.
	USB_HOST_INTENSET_RST_Pos = 0x3
	// Bit mask of RST field.
	USB_HOST_INTENSET_RST_Msk = 0x8
	// Bit RST.
	USB_HOST_INTENSET_RST = 0x8
	// Position of WAKEUP field.
	USB_HOST_INTENSET_WAKEUP_Pos = 0x4
	// Bit mask of WAKEUP field.
	USB_HOST_INTENSET_WAKEUP_Msk = 0x10
	// Bit WAKEUP.
	USB_HOST_INTENSET_WAKEUP = 0x10
	// Position of DNRSM field.
	USB_HOST_INTENSET_DNRSM_Pos = 0x5
	// Bit mask of DNRSM field.
	USB_HOST_INTENSET_DNRSM_Msk = 0x20
	// Bit DNRSM.
	USB_HOST_INTENSET_DNRSM = 0x20
	// Position of UPRSM field.
	USB_HOST_INTENSET_UPRSM_Pos = 0x6
	// Bit mask of UPRSM field.
	USB_HOST_INTENSET_UPRSM_Msk = 0x40
	// Bit UPRSM.
	USB_HOST_INTENSET_UPRSM = 0x40
	// Position of RAMACER field.
	USB_HOST_INTENSET_RAMACER_Pos = 0x7
	// Bit mask of RAMACER field.
	USB_HOST_INTENSET_RAMACER_Msk = 0x80
	// Bit RAMACER.
	USB_HOST_INTENSET_RAMACER = 0x80
	// Position of DCONN field.
	USB_HOST_INTENSET_DCONN_Pos = 0x8
	// Bit mask of DCONN field.
	USB_HOST_INTENSET_DCONN_Msk = 0x100
	// Bit DCONN.
	USB_HOST_INTENSET_DCONN = 0x100
	// Position of DDISC field.
	USB_HOST_INTENSET_DDISC_Pos = 0x9
	// Bit mask of DDISC field.
	USB_HOST_INTENSET_DDISC_Msk = 0x200
	// Bit DDISC.
	USB_HOST_INTENSET_DDISC = 0x200

	// INTFLAG: HOST Host Interrupt Flag
	// Position of HSOF field.
	USB_HOST_INTFLAG_HSOF_Pos = 0x2
	// Bit mask of HSOF field.
	USB_HOST_INTFLAG_HSOF_Msk = 0x4
	// Bit HSOF.
	USB_HOST_INTFLAG_HSOF = 0x4
	// Position of RST field.
	USB_HOST_INTFLAG_RST_Pos = 0x3
	// Bit mask of RST field.
	USB_HOST_INTFLAG_RST_Msk = 0x8
	// Bit RST.
	USB_HOST_INTFLAG_RST = 0x8
	// Position of WAKEUP field.
	USB_HOST_INTFLAG_WAKEUP_Pos = 0x4
	// Bit mask of WAKEUP field.
	USB_HOST_INTFLAG_WAKEUP_Msk = 0x10
	// Bit WAKEUP.
	USB_HOST_INTFLAG_WAKEUP = 0x10
	// Position of DNRSM field.
	USB_HOST_INTFLAG_DNRSM_Pos = 0x5
	// Bit mask of DNRSM field.
	USB_HOST_INTFLAG_DNRSM_Msk = 0x20
	// Bit DNRSM.
	USB_HOST_INTFLAG_DNRSM = 0x20
	// Position of UPRSM field.
	USB_HOST_INTFLAG_UPRSM_Pos = 0x6
	// Bit mask of UPRSM field.
	USB_HOST_INTFLAG_UPRSM_Msk = 0x40
	// Bit UPRSM.
	USB_HOST_INTFLAG_UPRSM = 0x40
	// Position of RAMACER field.
	USB_HOST_INTFLAG_RAMACER_Pos = 0x7
	// Bit mask of RAMACER field.
	USB_HOST_INTFLAG_RAMACER_Msk = 0x80
	// Bit RAMACER.
	USB_HOST_INTFLAG_RAMACER = 0x80
	// Position of DCONN field.
	USB_HOST_INTFLAG_DCONN_Pos = 0x8
	// Bit mask of DCONN field.
	USB_HOST_INTFLAG_DCONN_Msk = 0x100
	// Bit DCONN.
	USB_HOST_INTFLAG_DCONN = 0x100
	// Position of DDISC field.
	USB_HOST_INTFLAG_DDISC_Pos = 0x9
	// Bit mask of DDISC field.
	USB_HOST_INTFLAG_DDISC_Msk = 0x200
	// Bit DDISC.
	USB_HOST_INTFLAG_DDISC = 0x200

	// PINTSMRY: HOST Pipe Interrupt Summary
	// Position of EPINT0 field.
	USB_HOST_PINTSMRY_EPINT0_Pos = 0x0
	// Bit mask of EPINT0 field.
	USB_HOST_PINTSMRY_EPINT0_Msk = 0x1
	// Bit EPINT0.
	USB_HOST_PINTSMRY_EPINT0 = 0x1
	// Position of EPINT1 field.
	USB_HOST_PINTSMRY_EPINT1_Pos = 0x1
	// Bit mask of EPINT1 field.
	USB_HOST_PINTSMRY_EPINT1_Msk = 0x2
	// Bit EPINT1.
	USB_HOST_PINTSMRY_EPINT1 = 0x2
	// Position of EPINT2 field.
	USB_HOST_PINTSMRY_EPINT2_Pos = 0x2
	// Bit mask of EPINT2 field.
	USB_HOST_PINTSMRY_EPINT2_Msk = 0x4
	// Bit EPINT2.
	USB_HOST_PINTSMRY_EPINT2 = 0x4
	// Position of EPINT3 field.
	USB_HOST_PINTSMRY_EPINT3_Pos = 0x3
	// Bit mask of EPINT3 field.
	USB_HOST_PINTSMRY_EPINT3_Msk = 0x8
	// Bit EPINT3.
	USB_HOST_PINTSMRY_EPINT3 = 0x8
	// Position of EPINT4 field.
	USB_HOST_PINTSMRY_EPINT4_Pos = 0x4
	// Bit mask of EPINT4 field.
	USB_HOST_PINTSMRY_EPINT4_Msk = 0x10
	// Bit EPINT4.
	USB_HOST_PINTSMRY_EPINT4 = 0x10
	// Position of EPINT5 field.
	USB_HOST_PINTSMRY_EPINT5_Pos = 0x5
	// Bit mask of EPINT5 field.
	USB_HOST_PINTSMRY_EPINT5_Msk = 0x20
	// Bit EPINT5.
	USB_HOST_PINTSMRY_EPINT5 = 0x20
	// Position of EPINT6 field.
	USB_HOST_PINTSMRY_EPINT6_Pos = 0x6
	// Bit mask of EPINT6 field.
	USB_HOST_PINTSMRY_EPINT6_Msk = 0x40
	// Bit EPINT6.
	USB_HOST_PINTSMRY_EPINT6 = 0x40
	// Position of EPINT7 field.
	USB_HOST_PINTSMRY_EPINT7_Pos = 0x7
	// Bit mask of EPINT7 field.
	USB_HOST_PINTSMRY_EPINT7_Msk = 0x80
	// Bit EPINT7.
	USB_HOST_PINTSMRY_EPINT7 = 0x80

	// DESCADD: Descriptor Address
	// Position of DESCADD field.
	USB_HOST_DESCADD_DESCADD_Pos = 0x0
	// Bit mask of DESCADD field.
	USB_HOST_DESCADD_DESCADD_Msk = 0xffffffff

	// PADCAL: USB PAD Calibration
	// Position of TRANSP field.
	USB_HOST_PADCAL_TRANSP_Pos = 0x0
	// Bit mask of TRANSP field.
	USB_HOST_PADCAL_TRANSP_Msk = 0x1f
	// Position of TRANSN field.
	USB_HOST_PADCAL_TRANSN_Pos = 0x6
	// Bit mask of TRANSN field.
	USB_HOST_PADCAL_TRANSN_Msk = 0x7c0
	// Position of TRIM field.
	USB_HOST_PADCAL_TRIM_Pos = 0xc
	// Bit mask of TRIM field.
	USB_HOST_PADCAL_TRIM_Msk = 0x7000

	// HOST_PIPE.PCFG: HOST_PIPE End Point Configuration
	// Position of PTOKEN field.
	USB_HOST_PIPE_PCFG_PTOKEN_Pos = 0x0
	// Bit mask of PTOKEN field.
	USB_HOST_PIPE_PCFG_PTOKEN_Msk = 0x3
	// Position of BK field.
	USB_HOST_PIPE_PCFG_BK_Pos = 0x2
	// Bit mask of BK field.
	USB_HOST_PIPE_PCFG_BK_Msk = 0x4
	// Bit BK.
	USB_HOST_PIPE_PCFG_BK = 0x4
	// Position of PTYPE field.
	USB_HOST_PIPE_PCFG_PTYPE_Pos = 0x3
	// Bit mask of PTYPE field.
	USB_HOST_PIPE_PCFG_PTYPE_Msk = 0x38

	// HOST_PIPE.BINTERVAL: HOST_PIPE Bus Access Period of Pipe
	// Position of BITINTERVAL field.
	USB_HOST_PIPE_BINTERVAL_BITINTERVAL_Pos = 0x0
	// Bit mask of BITINTERVAL field.
	USB_HOST_PIPE_BINTERVAL_BITINTERVAL_Msk = 0xff

	// HOST_PIPE.PSTATUSCLR: HOST_PIPE End Point Pipe Status Clear
	// Position of DTGL field.
	USB_HOST_PIPE_PSTATUSCLR_DTGL_Pos = 0x0
	// Bit mask of DTGL field.
	USB_HOST_PIPE_PSTATUSCLR_DTGL_Msk = 0x1
	// Bit DTGL.
	USB_HOST_PIPE_PSTATUSCLR_DTGL = 0x1
	// Position of CURBK field.
	USB_HOST_PIPE_PSTATUSCLR_CURBK_Pos = 0x2
	// Bit mask of CURBK field.
	USB_HOST_PIPE_PSTATUSCLR_CURBK_Msk = 0x4
	// Bit CURBK.
	USB_HOST_PIPE_PSTATUSCLR_CURBK = 0x4
	// Position of PFREEZE field.
	USB_HOST_PIPE_PSTATUSCLR_PFREEZE_Pos = 0x4
	// Bit mask of PFREEZE field.
	USB_HOST_PIPE_PSTATUSCLR_PFREEZE_Msk = 0x10
	// Bit PFREEZE.
	USB_HOST_PIPE_PSTATUSCLR_PFREEZE = 0x10
	// Position of BK0RDY field.
	USB_HOST_PIPE_PSTATUSCLR_BK0RDY_Pos = 0x6
	// Bit mask of BK0RDY field.
	USB_HOST_PIPE_PSTATUSCLR_BK0RDY_Msk = 0x40
	// Bit BK0RDY.
	USB_HOST_PIPE_PSTATUSCLR_BK0RDY = 0x40
	// Position of BK1RDY field.
	USB_HOST_PIPE_PSTATUSCLR_BK1RDY_Pos = 0x7
	// Bit mask of BK1RDY field.
	USB_HOST_PIPE_PSTATUSCLR_BK1RDY_Msk = 0x80
	// Bit BK1RDY.
	USB_HOST_PIPE_PSTATUSCLR_BK1RDY = 0x80

	// HOST_PIPE.PSTATUSSET: HOST_PIPE End Point Pipe Status Set
	// Position of DTGL field.
	USB_HOST_PIPE_PSTATUSSET_DTGL_Pos = 0x0
	// Bit mask of DTGL field.
	USB_HOST_PIPE_PSTATUSSET_DTGL_Msk = 0x1
	// Bit DTGL.
	USB_HOST_PIPE_PSTATUSSET_DTGL = 0x1
	// Position of CURBK field.
	USB_HOST_PIPE_PSTATUSSET_CURBK_Pos = 0x2
	// Bit mask of CURBK field.
	USB_HOST_PIPE_PSTATUSSET_CURBK_Msk = 0x4
	// Bit CURBK.
	USB_HOST_PIPE_PSTATUSSET_CURBK = 0x4
	// Position of PFREEZE field.
	USB_HOST_PIPE_PSTATUSSET_PFREEZE_Pos = 0x4
	// Bit mask of PFREEZE field.
	USB_HOST_PIPE_PSTATUSSET_PFREEZE_Msk = 0x10
	// Bit PFREEZE.
	USB_HOST_PIPE_PSTATUSSET_PFREEZE = 0x10
	// Position of BK0RDY field.
	USB_HOST_PIPE_PSTATUSSET_BK0RDY_Pos = 0x6
	// Bit mask of BK0RDY field.
	USB_HOST_PIPE_PSTATUSSET_BK0RDY_Msk = 0x40
	// Bit BK0RDY.
	USB_HOST_PIPE_PSTATUSSET_BK0RDY = 0x40
	// Position of BK1RDY field.
	USB_HOST_PIPE_PSTATUSSET_BK1RDY_Pos = 0x7
	// Bit mask of BK1RDY field.
	USB_HOST_PIPE_PSTATUSSET_BK1RDY_Msk = 0x80
	// Bit BK1RDY.
	USB_HOST_PIPE_PSTATUSSET_BK1RDY = 0x80

	// HOST_PIPE.PSTATUS: HOST_PIPE End Point Pipe Status
	// Position of DTGL field.
	USB_HOST_PIPE_PSTATUS_DTGL_Pos = 0x0
	// Bit mask of DTGL field.
	USB_HOST_PIPE_PSTATUS_DTGL_Msk = 0x1
	// Bit DTGL.
	USB_HOST_PIPE_PSTATUS_DTGL = 0x1
	// Position of CURBK field.
	USB_HOST_PIPE_PSTATUS_CURBK_Pos = 0x2
	// Bit mask of CURBK field.
	USB_HOST_PIPE_PSTATUS_CURBK_Msk = 0x4
	// Bit CURBK.
	USB_HOST_PIPE_PSTATUS_CURBK = 0x4
	// Position of PFREEZE field.
	USB_HOST_PIPE_PSTATUS_PFREEZE_Pos = 0x4
	// Bit mask of PFREEZE field.
	USB_HOST_PIPE_PSTATUS_PFREEZE_Msk = 0x10
	// Bit PFREEZE.
	USB_HOST_PIPE_PSTATUS_PFREEZE = 0x10
	// Position of BK0RDY field.
	USB_HOST_PIPE_PSTATUS_BK0RDY_Pos = 0x6
	// Bit mask of BK0RDY field.
	USB_HOST_PIPE_PSTATUS_BK0RDY_Msk = 0x40
	// Bit BK0RDY.
	USB_HOST_PIPE_PSTATUS_BK0RDY = 0x40
	// Position of BK1RDY field.
	USB_HOST_PIPE_PSTATUS_BK1RDY_Pos = 0x7
	// Bit mask of BK1RDY field.
	USB_HOST_PIPE_PSTATUS_BK1RDY_Msk = 0x80
	// Bit BK1RDY.
	USB_HOST_PIPE_PSTATUS_BK1RDY = 0x80

	// HOST_PIPE.PINTFLAG: HOST_PIPE Pipe Interrupt Flag
	// Position of TRCPT0 field.
	USB_HOST_PIPE_PINTFLAG_TRCPT0_Pos = 0x0
	// Bit mask of TRCPT0 field.
	USB_HOST_PIPE_PINTFLAG_TRCPT0_Msk = 0x1
	// Bit TRCPT0.
	USB_HOST_PIPE_PINTFLAG_TRCPT0 = 0x1
	// Position of TRCPT1 field.
	USB_HOST_PIPE_PINTFLAG_TRCPT1_Pos = 0x1
	// Bit mask of TRCPT1 field.
	USB_HOST_PIPE_PINTFLAG_TRCPT1_Msk = 0x2
	// Bit TRCPT1.
	USB_HOST_PIPE_PINTFLAG_TRCPT1 = 0x2
	// Position of TRFAIL field.
	USB_HOST_PIPE_PINTFLAG_TRFAIL_Pos = 0x2
	// Bit mask of TRFAIL field.
	USB_HOST_PIPE_PINTFLAG_TRFAIL_Msk = 0x4
	// Bit TRFAIL.
	USB_HOST_PIPE_PINTFLAG_TRFAIL = 0x4
	// Position of PERR field.
	USB_HOST_PIPE_PINTFLAG_PERR_Pos = 0x3
	// Bit mask of PERR field.
	USB_HOST_PIPE_PINTFLAG_PERR_Msk = 0x8
	// Bit PERR.
	USB_HOST_PIPE_PINTFLAG_PERR = 0x8
	// Position of TXSTP field.
	USB_HOST_PIPE_PINTFLAG_TXSTP_Pos = 0x4
	// Bit mask of TXSTP field.
	USB_HOST_PIPE_PINTFLAG_TXSTP_Msk = 0x10
	// Bit TXSTP.
	USB_HOST_PIPE_PINTFLAG_TXSTP = 0x10
	// Position of STALL field.
	USB_HOST_PIPE_PINTFLAG_STALL_Pos = 0x5
	// Bit mask of STALL field.
	USB_HOST_PIPE_PINTFLAG_STALL_Msk = 0x20
	// Bit STALL.
	USB_HOST_PIPE_PINTFLAG_STALL = 0x20

	// HOST_PIPE.PINTENCLR: HOST_PIPE Pipe Interrupt Flag Clear
	// Position of TRCPT0 field.
	USB_HOST_PIPE_PINTENCLR_TRCPT0_Pos = 0x0
	// Bit mask of TRCPT0 field.
	USB_HOST_PIPE_PINTENCLR_TRCPT0_Msk = 0x1
	// Bit TRCPT0.
	USB_HOST_PIPE_PINTENCLR_TRCPT0 = 0x1
	// Position of TRCPT1 field.
	USB_HOST_PIPE_PINTENCLR_TRCPT1_Pos = 0x1
	// Bit mask of TRCPT1 field.
	USB_HOST_PIPE_PINTENCLR_TRCPT1_Msk = 0x2
	// Bit TRCPT1.
	USB_HOST_PIPE_PINTENCLR_TRCPT1 = 0x2
	// Position of TRFAIL field.
	USB_HOST_PIPE_PINTENCLR_TRFAIL_Pos = 0x2
	// Bit mask of TRFAIL field.
	USB_HOST_PIPE_PINTENCLR_TRFAIL_Msk = 0x4
	// Bit TRFAIL.
	USB_HOST_PIPE_PINTENCLR_TRFAIL = 0x4
	// Position of PERR field.
	USB_HOST_PIPE_PINTENCLR_PERR_Pos = 0x3
	// Bit mask of PERR field.
	USB_HOST_PIPE_PINTENCLR_PERR_Msk = 0x8
	// Bit PERR.
	USB_HOST_PIPE_PINTENCLR_PERR = 0x8
	// Position of TXSTP field.
	USB_HOST_PIPE_PINTENCLR_TXSTP_Pos = 0x4
	// Bit mask of TXSTP field.
	USB_HOST_PIPE_PINTENCLR_TXSTP_Msk = 0x10
	// Bit TXSTP.
	USB_HOST_PIPE_PINTENCLR_TXSTP = 0x10
	// Position of STALL field.
	USB_HOST_PIPE_PINTENCLR_STALL_Pos = 0x5
	// Bit mask of STALL field.
	USB_HOST_PIPE_PINTENCLR_STALL_Msk = 0x20
	// Bit STALL.
	USB_HOST_PIPE_PINTENCLR_STALL = 0x20

	// HOST_PIPE.PINTENSET: HOST_PIPE Pipe Interrupt Flag Set
	// Position of TRCPT0 field.
	USB_HOST_PIPE_PINTENSET_TRCPT0_Pos = 0x0
	// Bit mask of TRCPT0 field.
	USB_HOST_PIPE_PINTENSET_TRCPT0_Msk = 0x1
	// Bit TRCPT0.
	USB_HOST_PIPE_PINTENSET_TRCPT0 = 0x1
	// Position of TRCPT1 field.
	USB_HOST_PIPE_PINTENSET_TRCPT1_Pos = 0x1
	// Bit mask of TRCPT1 field.
	USB_HOST_PIPE_PINTENSET_TRCPT1_Msk = 0x2
	// Bit TRCPT1.
	USB_HOST_PIPE_PINTENSET_TRCPT1 = 0x2
	// Position of TRFAIL field.
	USB_HOST_PIPE_PINTENSET_TRFAIL_Pos = 0x2
	// Bit mask of TRFAIL field.
	USB_HOST_PIPE_PINTENSET_TRFAIL_Msk = 0x4
	// Bit TRFAIL.
	USB_HOST_PIPE_PINTENSET_TRFAIL = 0x4
	// Position of PERR field.
	USB_HOST_PIPE_PINTENSET_PERR_Pos = 0x3
	// Bit mask of PERR field.
	USB_HOST_PIPE_PINTENSET_PERR_Msk = 0x8
	// Bit PERR.
	USB_HOST_PIPE_PINTENSET_PERR = 0x8
	// Position of TXSTP field.
	USB_HOST_PIPE_PINTENSET_TXSTP_Pos = 0x4
	// Bit mask of TXSTP field.
	USB_HOST_PIPE_PINTENSET_TXSTP_Msk = 0x10
	// Bit TXSTP.
	USB_HOST_PIPE_PINTENSET_TXSTP = 0x10
	// Position of STALL field.
	USB_HOST_PIPE_PINTENSET_STALL_Pos = 0x5
	// Bit mask of STALL field.
	USB_HOST_PIPE_PINTENSET_STALL_Msk = 0x20
	// Bit STALL.
	USB_HOST_PIPE_PINTENSET_STALL = 0x20
)

// Constants for WDT: Watchdog Timer
const (
	// CTRLA: Control
	// Position of ENABLE field.
	WDT_CTRLA_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	WDT_CTRLA_ENABLE_Msk = 0x2
	// Bit ENABLE.
	WDT_CTRLA_ENABLE = 0x2
	// Position of WEN field.
	WDT_CTRLA_WEN_Pos = 0x2
	// Bit mask of WEN field.
	WDT_CTRLA_WEN_Msk = 0x4
	// Bit WEN.
	WDT_CTRLA_WEN = 0x4
	// Position of ALWAYSON field.
	WDT_CTRLA_ALWAYSON_Pos = 0x7
	// Bit mask of ALWAYSON field.
	WDT_CTRLA_ALWAYSON_Msk = 0x80
	// Bit ALWAYSON.
	WDT_CTRLA_ALWAYSON = 0x80

	// CONFIG: Configuration
	// Position of PER field.
	WDT_CONFIG_PER_Pos = 0x0
	// Bit mask of PER field.
	WDT_CONFIG_PER_Msk = 0xf
	// 8 clock cycles
	WDT_CONFIG_PER_CYC8 = 0x0
	// 16 clock cycles
	WDT_CONFIG_PER_CYC16 = 0x1
	// 32 clock cycles
	WDT_CONFIG_PER_CYC32 = 0x2
	// 64 clock cycles
	WDT_CONFIG_PER_CYC64 = 0x3
	// 128 clock cycles
	WDT_CONFIG_PER_CYC128 = 0x4
	// 256 clock cycles
	WDT_CONFIG_PER_CYC256 = 0x5
	// 512 clock cycles
	WDT_CONFIG_PER_CYC512 = 0x6
	// 1024 clock cycles
	WDT_CONFIG_PER_CYC1024 = 0x7
	// 2048 clock cycles
	WDT_CONFIG_PER_CYC2048 = 0x8
	// 4096 clock cycles
	WDT_CONFIG_PER_CYC4096 = 0x9
	// 8192 clock cycles
	WDT_CONFIG_PER_CYC8192 = 0xa
	// 16384 clock cycles
	WDT_CONFIG_PER_CYC16384 = 0xb
	// Position of WINDOW field.
	WDT_CONFIG_WINDOW_Pos = 0x4
	// Bit mask of WINDOW field.
	WDT_CONFIG_WINDOW_Msk = 0xf0
	// 8 clock cycles
	WDT_CONFIG_WINDOW_CYC8 = 0x0
	// 16 clock cycles
	WDT_CONFIG_WINDOW_CYC16 = 0x1
	// 32 clock cycles
	WDT_CONFIG_WINDOW_CYC32 = 0x2
	// 64 clock cycles
	WDT_CONFIG_WINDOW_CYC64 = 0x3
	// 128 clock cycles
	WDT_CONFIG_WINDOW_CYC128 = 0x4
	// 256 clock cycles
	WDT_CONFIG_WINDOW_CYC256 = 0x5
	// 512 clock cycles
	WDT_CONFIG_WINDOW_CYC512 = 0x6
	// 1024 clock cycles
	WDT_CONFIG_WINDOW_CYC1024 = 0x7
	// 2048 clock cycles
	WDT_CONFIG_WINDOW_CYC2048 = 0x8
	// 4096 clock cycles
	WDT_CONFIG_WINDOW_CYC4096 = 0x9
	// 8192 clock cycles
	WDT_CONFIG_WINDOW_CYC8192 = 0xa
	// 16384 clock cycles
	WDT_CONFIG_WINDOW_CYC16384 = 0xb

	// EWCTRL: Early Warning Interrupt Control
	// Position of EWOFFSET field.
	WDT_EWCTRL_EWOFFSET_Pos = 0x0
	// Bit mask of EWOFFSET field.
	WDT_EWCTRL_EWOFFSET_Msk = 0xf
	// 8 clock cycles
	WDT_EWCTRL_EWOFFSET_CYC8 = 0x0
	// 16 clock cycles
	WDT_EWCTRL_EWOFFSET_CYC16 = 0x1
	// 32 clock cycles
	WDT_EWCTRL_EWOFFSET_CYC32 = 0x2
	// 64 clock cycles
	WDT_EWCTRL_EWOFFSET_CYC64 = 0x3
	// 128 clock cycles
	WDT_EWCTRL_EWOFFSET_CYC128 = 0x4
	// 256 clock cycles
	WDT_EWCTRL_EWOFFSET_CYC256 = 0x5
	// 512 clock cycles
	WDT_EWCTRL_EWOFFSET_CYC512 = 0x6
	// 1024 clock cycles
	WDT_EWCTRL_EWOFFSET_CYC1024 = 0x7
	// 2048 clock cycles
	WDT_EWCTRL_EWOFFSET_CYC2048 = 0x8
	// 4096 clock cycles
	WDT_EWCTRL_EWOFFSET_CYC4096 = 0x9
	// 8192 clock cycles
	WDT_EWCTRL_EWOFFSET_CYC8192 = 0xa
	// 16384 clock cycles
	WDT_EWCTRL_EWOFFSET_CYC16384 = 0xb

	// INTENCLR: Interrupt Enable Clear
	// Position of EW field.
	WDT_INTENCLR_EW_Pos = 0x0
	// Bit mask of EW field.
	WDT_INTENCLR_EW_Msk = 0x1
	// Bit EW.
	WDT_INTENCLR_EW = 0x1

	// INTENSET: Interrupt Enable Set
	// Position of EW field.
	WDT_INTENSET_EW_Pos = 0x0
	// Bit mask of EW field.
	WDT_INTENSET_EW_Msk = 0x1
	// Bit EW.
	WDT_INTENSET_EW = 0x1

	// INTFLAG: Interrupt Flag Status and Clear
	// Position of EW field.
	WDT_INTFLAG_EW_Pos = 0x0
	// Bit mask of EW field.
	WDT_INTFLAG_EW_Msk = 0x1
	// Bit EW.
	WDT_INTFLAG_EW = 0x1

	// SYNCBUSY: Synchronization Busy
	// Position of ENABLE field.
	WDT_SYNCBUSY_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	WDT_SYNCBUSY_ENABLE_Msk = 0x2
	// Bit ENABLE.
	WDT_SYNCBUSY_ENABLE = 0x2
	// Position of WEN field.
	WDT_SYNCBUSY_WEN_Pos = 0x2
	// Bit mask of WEN field.
	WDT_SYNCBUSY_WEN_Msk = 0x4
	// Bit WEN.
	WDT_SYNCBUSY_WEN = 0x4
	// Position of ALWAYSON field.
	WDT_SYNCBUSY_ALWAYSON_Pos = 0x3
	// Bit mask of ALWAYSON field.
	WDT_SYNCBUSY_ALWAYSON_Msk = 0x8
	// Bit ALWAYSON.
	WDT_SYNCBUSY_ALWAYSON = 0x8
	// Position of CLEAR field.
	WDT_SYNCBUSY_CLEAR_Pos = 0x4
	// Bit mask of CLEAR field.
	WDT_SYNCBUSY_CLEAR_Msk = 0x10
	// Bit CLEAR.
	WDT_SYNCBUSY_CLEAR = 0x10

	// CLEAR: Clear
	// Position of CLEAR field.
	WDT_CLEAR_CLEAR_Pos = 0x0
	// Bit mask of CLEAR field.
	WDT_CLEAR_CLEAR_Msk = 0xff
	// Clear Key
	WDT_CLEAR_CLEAR_KEY = 0xa5
)

// Constants for CoreDebug: Core Debug Register
const (
	// DHCSR: Debug Halting Control and Status Register
	// Position of C_DEBUGEN field.
	CoreDebug_DHCSR_C_DEBUGEN_Pos = 0x0
	// Bit mask of C_DEBUGEN field.
	CoreDebug_DHCSR_C_DEBUGEN_Msk = 0x1
	// Bit C_DEBUGEN.
	CoreDebug_DHCSR_C_DEBUGEN = 0x1
	// Position of C_HALT field.
	CoreDebug_DHCSR_C_HALT_Pos = 0x1
	// Bit mask of C_HALT field.
	CoreDebug_DHCSR_C_HALT_Msk = 0x2
	// Bit C_HALT.
	CoreDebug_DHCSR_C_HALT = 0x2
	// Position of C_STEP field.
	CoreDebug_DHCSR_C_STEP_Pos = 0x2
	// Bit mask of C_STEP field.
	CoreDebug_DHCSR_C_STEP_Msk = 0x4
	// Bit C_STEP.
	CoreDebug_DHCSR_C_STEP = 0x4
	// Position of C_MASKINTS field.
	CoreDebug_DHCSR_C_MASKINTS_Pos = 0x3
	// Bit mask of C_MASKINTS field.
	CoreDebug_DHCSR_C_MASKINTS_Msk = 0x8
	// Bit C_MASKINTS.
	CoreDebug_DHCSR_C_MASKINTS = 0x8
	// Position of C_SNAPSTALL field.
	CoreDebug_DHCSR_C_SNAPSTALL_Pos = 0x5
	// Bit mask of C_SNAPSTALL field.
	CoreDebug_DHCSR_C_SNAPSTALL_Msk = 0x20
	// Bit C_SNAPSTALL.
	CoreDebug_DHCSR_C_SNAPSTALL = 0x20
	// Position of S_REGRDY field.
	CoreDebug_DHCSR_S_REGRDY_Pos = 0x10
	// Bit mask of S_REGRDY field.
	CoreDebug_DHCSR_S_REGRDY_Msk = 0x10000
	// Bit S_REGRDY.
	CoreDebug_DHCSR_S_REGRDY = 0x10000
	// Position of S_HALT field.
	CoreDebug_DHCSR_S_HALT_Pos = 0x11
	// Bit mask of S_HALT field.
	CoreDebug_DHCSR_S_HALT_Msk = 0x20000
	// Bit S_HALT.
	CoreDebug_DHCSR_S_HALT = 0x20000
	// Position of S_SLEEP field.
	CoreDebug_DHCSR_S_SLEEP_Pos = 0x12
	// Bit mask of S_SLEEP field.
	CoreDebug_DHCSR_S_SLEEP_Msk = 0x40000
	// Bit S_SLEEP.
	CoreDebug_DHCSR_S_SLEEP = 0x40000
	// Position of S_LOCKUP field.
	CoreDebug_DHCSR_S_LOCKUP_Pos = 0x13
	// Bit mask of S_LOCKUP field.
	CoreDebug_DHCSR_S_LOCKUP_Msk = 0x80000
	// Bit S_LOCKUP.
	CoreDebug_DHCSR_S_LOCKUP = 0x80000
	// Position of S_RETIRE_ST field.
	CoreDebug_DHCSR_S_RETIRE_ST_Pos = 0x18
	// Bit mask of S_RETIRE_ST field.
	CoreDebug_DHCSR_S_RETIRE_ST_Msk = 0x1000000
	// Bit S_RETIRE_ST.
	CoreDebug_DHCSR_S_RETIRE_ST = 0x1000000
	// Position of S_RESET_ST field.
	CoreDebug_DHCSR_S_RESET_ST_Pos = 0x19
	// Bit mask of S_RESET_ST field.
	CoreDebug_DHCSR_S_RESET_ST_Msk = 0x2000000
	// Bit S_RESET_ST.
	CoreDebug_DHCSR_S_RESET_ST = 0x2000000
	// Position of DBGKEY field.
	CoreDebug_DHCSR_DBGKEY_Pos = 0x10
	// Bit mask of DBGKEY field.
	CoreDebug_DHCSR_DBGKEY_Msk = 0xffff0000

	// DCRSR: Debug Core Register Selector Register
	// Position of REGSEL field.
	CoreDebug_DCRSR_REGSEL_Pos = 0x0
	// Bit mask of REGSEL field.
	CoreDebug_DCRSR_REGSEL_Msk = 0x1f
	// Position of REGWnR field.
	CoreDebug_DCRSR_REGWnR_Pos = 0x10
	// Bit mask of REGWnR field.
	CoreDebug_DCRSR_REGWnR_Msk = 0x10000
	// Bit REGWnR.
	CoreDebug_DCRSR_REGWnR = 0x10000

	// DEMCR: Debug Exception and Monitor Control Register
	// Position of VC_CORERESET field.
	CoreDebug_DEMCR_VC_CORERESET_Pos = 0x0
	// Bit mask of VC_CORERESET field.
	CoreDebug_DEMCR_VC_CORERESET_Msk = 0x1
	// Bit VC_CORERESET.
	CoreDebug_DEMCR_VC_CORERESET = 0x1
	// Position of VC_MMERR field.
	CoreDebug_DEMCR_VC_MMERR_Pos = 0x4
	// Bit mask of VC_MMERR field.
	CoreDebug_DEMCR_VC_MMERR_Msk = 0x10
	// Bit VC_MMERR.
	CoreDebug_DEMCR_VC_MMERR = 0x10
	// Position of VC_NOCPERR field.
	CoreDebug_DEMCR_VC_NOCPERR_Pos = 0x5
	// Bit mask of VC_NOCPERR field.
	CoreDebug_DEMCR_VC_NOCPERR_Msk = 0x20
	// Bit VC_NOCPERR.
	CoreDebug_DEMCR_VC_NOCPERR = 0x20
	// Position of VC_CHKERR field.
	CoreDebug_DEMCR_VC_CHKERR_Pos = 0x6
	// Bit mask of VC_CHKERR field.
	CoreDebug_DEMCR_VC_CHKERR_Msk = 0x40
	// Bit VC_CHKERR.
	CoreDebug_DEMCR_VC_CHKERR = 0x40
	// Position of VC_STATERR field.
	CoreDebug_DEMCR_VC_STATERR_Pos = 0x7
	// Bit mask of VC_STATERR field.
	CoreDebug_DEMCR_VC_STATERR_Msk = 0x80
	// Bit VC_STATERR.
	CoreDebug_DEMCR_VC_STATERR = 0x80
	// Position of VC_BUSERR field.
	CoreDebug_DEMCR_VC_BUSERR_Pos = 0x8
	// Bit mask of VC_BUSERR field.
	CoreDebug_DEMCR_VC_BUSERR_Msk = 0x100
	// Bit VC_BUSERR.
	CoreDebug_DEMCR_VC_BUSERR = 0x100
	// Position of VC_INTERR field.
	CoreDebug_DEMCR_VC_INTERR_Pos = 0x9
	// Bit mask of VC_INTERR field.
	CoreDebug_DEMCR_VC_INTERR_Msk = 0x200
	// Bit VC_INTERR.
	CoreDebug_DEMCR_VC_INTERR = 0x200
	// Position of VC_HARDERR field.
	CoreDebug_DEMCR_VC_HARDERR_Pos = 0xa
	// Bit mask of VC_HARDERR field.
	CoreDebug_DEMCR_VC_HARDERR_Msk = 0x400
	// Bit VC_HARDERR.
	CoreDebug_DEMCR_VC_HARDERR = 0x400
	// Position of MON_EN field.
	CoreDebug_DEMCR_MON_EN_Pos = 0x10
	// Bit mask of MON_EN field.
	CoreDebug_DEMCR_MON_EN_Msk = 0x10000
	// Bit MON_EN.
	CoreDebug_DEMCR_MON_EN = 0x10000
	// Position of MON_PEND field.
	CoreDebug_DEMCR_MON_PEND_Pos = 0x11
	// Bit mask of MON_PEND field.
	CoreDebug_DEMCR_MON_PEND_Msk = 0x20000
	// Bit MON_PEND.
	CoreDebug_DEMCR_MON_PEND = 0x20000
	// Position of MON_STEP field.
	CoreDebug_DEMCR_MON_STEP_Pos = 0x12
	// Bit mask of MON_STEP field.
	CoreDebug_DEMCR_MON_STEP_Msk = 0x40000
	// Bit MON_STEP.
	CoreDebug_DEMCR_MON_STEP = 0x40000
	// Position of MON_REQ field.
	CoreDebug_DEMCR_MON_REQ_Pos = 0x13
	// Bit mask of MON_REQ field.
	CoreDebug_DEMCR_MON_REQ_Msk = 0x80000
	// Bit MON_REQ.
	CoreDebug_DEMCR_MON_REQ = 0x80000
	// Position of TRCENA field.
	CoreDebug_DEMCR_TRCENA_Pos = 0x18
	// Bit mask of TRCENA field.
	CoreDebug_DEMCR_TRCENA_Msk = 0x1000000
	// Bit TRCENA.
	CoreDebug_DEMCR_TRCENA = 0x1000000
)

// Constants for DWT: Data Watchpoint and Trace Register
const (
	// CTRL: Control Register
	// Position of CYCCNTENA field.
	DWT_CTRL_CYCCNTENA_Pos = 0x0
	// Bit mask of CYCCNTENA field.
	DWT_CTRL_CYCCNTENA_Msk = 0x1
	// Bit CYCCNTENA.
	DWT_CTRL_CYCCNTENA = 0x1
	// Position of POSTPRESET field.
	DWT_CTRL_POSTPRESET_Pos = 0x1
	// Bit mask of POSTPRESET field.
	DWT_CTRL_POSTPRESET_Msk = 0x1e
	// Position of POSTINIT field.
	DWT_CTRL_POSTINIT_Pos = 0x5
	// Bit mask of POSTINIT field.
	DWT_CTRL_POSTINIT_Msk = 0x1e0
	// Position of CYCTAP field.
	DWT_CTRL_CYCTAP_Pos = 0x9
	// Bit mask of CYCTAP field.
	DWT_CTRL_CYCTAP_Msk = 0x200
	// Bit CYCTAP.
	DWT_CTRL_CYCTAP = 0x200
	// Position of SYNCTAP field.
	DWT_CTRL_SYNCTAP_Pos = 0xa
	// Bit mask of SYNCTAP field.
	DWT_CTRL_SYNCTAP_Msk = 0xc00
	// Position of PCSAMPLENA field.
	DWT_CTRL_PCSAMPLENA_Pos = 0xc
	// Bit mask of PCSAMPLENA field.
	DWT_CTRL_PCSAMPLENA_Msk = 0x1000
	// Bit PCSAMPLENA.
	DWT_CTRL_PCSAMPLENA = 0x1000
	// Position of EXCTRCENA field.
	DWT_CTRL_EXCTRCENA_Pos = 0x10
	// Bit mask of EXCTRCENA field.
	DWT_CTRL_EXCTRCENA_Msk = 0x10000
	// Bit EXCTRCENA.
	DWT_CTRL_EXCTRCENA = 0x10000
	// Position of CPIEVTENA field.
	DWT_CTRL_CPIEVTENA_Pos = 0x11
	// Bit mask of CPIEVTENA field.
	DWT_CTRL_CPIEVTENA_Msk = 0x20000
	// Bit CPIEVTENA.
	DWT_CTRL_CPIEVTENA = 0x20000
	// Position of EXCEVTENA field.
	DWT_CTRL_EXCEVTENA_Pos = 0x12
	// Bit mask of EXCEVTENA field.
	DWT_CTRL_EXCEVTENA_Msk = 0x40000
	// Bit EXCEVTENA.
	DWT_CTRL_EXCEVTENA = 0x40000
	// Position of SLEEPEVTENA field.
	DWT_CTRL_SLEEPEVTENA_Pos = 0x13
	// Bit mask of SLEEPEVTENA field.
	DWT_CTRL_SLEEPEVTENA_Msk = 0x80000
	// Bit SLEEPEVTENA.
	DWT_CTRL_SLEEPEVTENA = 0x80000
	// Position of LSUEVTENA field.
	DWT_CTRL_LSUEVTENA_Pos = 0x14
	// Bit mask of LSUEVTENA field.
	DWT_CTRL_LSUEVTENA_Msk = 0x100000
	// Bit LSUEVTENA.
	DWT_CTRL_LSUEVTENA = 0x100000
	// Position of FOLDEVTENA field.
	DWT_CTRL_FOLDEVTENA_Pos = 0x15
	// Bit mask of FOLDEVTENA field.
	DWT_CTRL_FOLDEVTENA_Msk = 0x200000
	// Bit FOLDEVTENA.
	DWT_CTRL_FOLDEVTENA = 0x200000
	// Position of CYCEVTENA field.
	DWT_CTRL_CYCEVTENA_Pos = 0x16
	// Bit mask of CYCEVTENA field.
	DWT_CTRL_CYCEVTENA_Msk = 0x400000
	// Bit CYCEVTENA.
	DWT_CTRL_CYCEVTENA = 0x400000
	// Position of NOPRFCNT field.
	DWT_CTRL_NOPRFCNT_Pos = 0x18
	// Bit mask of NOPRFCNT field.
	DWT_CTRL_NOPRFCNT_Msk = 0x1000000
	// Bit NOPRFCNT.
	DWT_CTRL_NOPRFCNT = 0x1000000
	// Position of NOCYCCNT field.
	DWT_CTRL_NOCYCCNT_Pos = 0x19
	// Bit mask of NOCYCCNT field.
	DWT_CTRL_NOCYCCNT_Msk = 0x2000000
	// Bit NOCYCCNT.
	DWT_CTRL_NOCYCCNT = 0x2000000
	// Position of NOEXTTRIG field.
	DWT_CTRL_NOEXTTRIG_Pos = 0x1a
	// Bit mask of NOEXTTRIG field.
	DWT_CTRL_NOEXTTRIG_Msk = 0x4000000
	// Bit NOEXTTRIG.
	DWT_CTRL_NOEXTTRIG = 0x4000000
	// Position of NOTRCPKT field.
	DWT_CTRL_NOTRCPKT_Pos = 0x1b
	// Bit mask of NOTRCPKT field.
	DWT_CTRL_NOTRCPKT_Msk = 0x8000000
	// Bit NOTRCPKT.
	DWT_CTRL_NOTRCPKT = 0x8000000
	// Position of NUMCOMP field.
	DWT_CTRL_NUMCOMP_Pos = 0x1c
	// Bit mask of NUMCOMP field.
	DWT_CTRL_NUMCOMP_Msk = 0xf0000000

	// CPICNT: CPI Count Register
	// Position of CPICNT field.
	DWT_CPICNT_CPICNT_Pos = 0x0
	// Bit mask of CPICNT field.
	DWT_CPICNT_CPICNT_Msk = 0xff

	// EXCCNT: Exception Overhead Count Register
	// Position of EXCCNT field.
	DWT_EXCCNT_EXCCNT_Pos = 0x0
	// Bit mask of EXCCNT field.
	DWT_EXCCNT_EXCCNT_Msk = 0xff

	// SLEEPCNT: Sleep Count Register
	// Position of SLEEPCNT field.
	DWT_SLEEPCNT_SLEEPCNT_Pos = 0x0
	// Bit mask of SLEEPCNT field.
	DWT_SLEEPCNT_SLEEPCNT_Msk = 0xff

	// LSUCNT: LSU Count Register
	// Position of LSUCNT field.
	DWT_LSUCNT_LSUCNT_Pos = 0x0
	// Bit mask of LSUCNT field.
	DWT_LSUCNT_LSUCNT_Msk = 0xff

	// FOLDCNT: Folded-instruction Count Register
	// Position of FOLDCNT field.
	DWT_FOLDCNT_FOLDCNT_Pos = 0x0
	// Bit mask of FOLDCNT field.
	DWT_FOLDCNT_FOLDCNT_Msk = 0xff

	// MASK0: Mask Register 0
	// Position of MASK field.
	DWT_MASK0_MASK_Pos = 0x0
	// Bit mask of MASK field.
	DWT_MASK0_MASK_Msk = 0x1f

	// FUNCTION0: Function Register 0
	// Position of FUNCTION field.
	DWT_FUNCTION0_FUNCTION_Pos = 0x0
	// Bit mask of FUNCTION field.
	DWT_FUNCTION0_FUNCTION_Msk = 0xf
	// Position of EMITRANGE field.
	DWT_FUNCTION0_EMITRANGE_Pos = 0x5
	// Bit mask of EMITRANGE field.
	DWT_FUNCTION0_EMITRANGE_Msk = 0x20
	// Bit EMITRANGE.
	DWT_FUNCTION0_EMITRANGE = 0x20
	// Position of CYCMATCH field.
	DWT_FUNCTION0_CYCMATCH_Pos = 0x7
	// Bit mask of CYCMATCH field.
	DWT_FUNCTION0_CYCMATCH_Msk = 0x80
	// Bit CYCMATCH.
	DWT_FUNCTION0_CYCMATCH = 0x80
	// Position of DATAVMATCH field.
	DWT_FUNCTION0_DATAVMATCH_Pos = 0x8
	// Bit mask of DATAVMATCH field.
	DWT_FUNCTION0_DATAVMATCH_Msk = 0x100
	// Bit DATAVMATCH.
	DWT_FUNCTION0_DATAVMATCH = 0x100
	// Position of LNK1ENA field.
	DWT_FUNCTION0_LNK1ENA_Pos = 0x9
	// Bit mask of LNK1ENA field.
	DWT_FUNCTION0_LNK1ENA_Msk = 0x200
	// Bit LNK1ENA.
	DWT_FUNCTION0_LNK1ENA = 0x200
	// Position of DATAVSIZE field.
	DWT_FUNCTION0_DATAVSIZE_Pos = 0xa
	// Bit mask of DATAVSIZE field.
	DWT_FUNCTION0_DATAVSIZE_Msk = 0xc00
	// Position of DATAVADDR0 field.
	DWT_FUNCTION0_DATAVADDR0_Pos = 0xc
	// Bit mask of DATAVADDR0 field.
	DWT_FUNCTION0_DATAVADDR0_Msk = 0xf000
	// Position of DATAVADDR1 field.
	DWT_FUNCTION0_DATAVADDR1_Pos = 0x10
	// Bit mask of DATAVADDR1 field.
	DWT_FUNCTION0_DATAVADDR1_Msk = 0xf0000
	// Position of MATCHED field.
	DWT_FUNCTION0_MATCHED_Pos = 0x18
	// Bit mask of MATCHED field.
	DWT_FUNCTION0_MATCHED_Msk = 0x1000000
	// Bit MATCHED.
	DWT_FUNCTION0_MATCHED = 0x1000000

	// MASK1: Mask Register 1
	// Position of MASK field.
	DWT_MASK1_MASK_Pos = 0x0
	// Bit mask of MASK field.
	DWT_MASK1_MASK_Msk = 0x1f

	// FUNCTION1: Function Register 1
	// Position of FUNCTION field.
	DWT_FUNCTION1_FUNCTION_Pos = 0x0
	// Bit mask of FUNCTION field.
	DWT_FUNCTION1_FUNCTION_Msk = 0xf
	// Position of EMITRANGE field.
	DWT_FUNCTION1_EMITRANGE_Pos = 0x5
	// Bit mask of EMITRANGE field.
	DWT_FUNCTION1_EMITRANGE_Msk = 0x20
	// Bit EMITRANGE.
	DWT_FUNCTION1_EMITRANGE = 0x20
	// Position of CYCMATCH field.
	DWT_FUNCTION1_CYCMATCH_Pos = 0x7
	// Bit mask of CYCMATCH field.
	DWT_FUNCTION1_CYCMATCH_Msk = 0x80
	// Bit CYCMATCH.
	DWT_FUNCTION1_CYCMATCH = 0x80
	// Position of DATAVMATCH field.
	DWT_FUNCTION1_DATAVMATCH_Pos = 0x8
	// Bit mask of DATAVMATCH field.
	DWT_FUNCTION1_DATAVMATCH_Msk = 0x100
	// Bit DATAVMATCH.
	DWT_FUNCTION1_DATAVMATCH = 0x100
	// Position of LNK1ENA field.
	DWT_FUNCTION1_LNK1ENA_Pos = 0x9
	// Bit mask of LNK1ENA field.
	DWT_FUNCTION1_LNK1ENA_Msk = 0x200
	// Bit LNK1ENA.
	DWT_FUNCTION1_LNK1ENA = 0x200
	// Position of DATAVSIZE field.
	DWT_FUNCTION1_DATAVSIZE_Pos = 0xa
	// Bit mask of DATAVSIZE field.
	DWT_FUNCTION1_DATAVSIZE_Msk = 0xc00
	// Position of DATAVADDR0 field.
	DWT_FUNCTION1_DATAVADDR0_Pos = 0xc
	// Bit mask of DATAVADDR0 field.
	DWT_FUNCTION1_DATAVADDR0_Msk = 0xf000
	// Position of DATAVADDR1 field.
	DWT_FUNCTION1_DATAVADDR1_Pos = 0x10
	// Bit mask of DATAVADDR1 field.
	DWT_FUNCTION1_DATAVADDR1_Msk = 0xf0000
	// Position of MATCHED field.
	DWT_FUNCTION1_MATCHED_Pos = 0x18
	// Bit mask of MATCHED field.
	DWT_FUNCTION1_MATCHED_Msk = 0x1000000
	// Bit MATCHED.
	DWT_FUNCTION1_MATCHED = 0x1000000

	// MASK2: Mask Register 2
	// Position of MASK field.
	DWT_MASK2_MASK_Pos = 0x0
	// Bit mask of MASK field.
	DWT_MASK2_MASK_Msk = 0x1f

	// FUNCTION2: Function Register 2
	// Position of FUNCTION field.
	DWT_FUNCTION2_FUNCTION_Pos = 0x0
	// Bit mask of FUNCTION field.
	DWT_FUNCTION2_FUNCTION_Msk = 0xf
	// Position of EMITRANGE field.
	DWT_FUNCTION2_EMITRANGE_Pos = 0x5
	// Bit mask of EMITRANGE field.
	DWT_FUNCTION2_EMITRANGE_Msk = 0x20
	// Bit EMITRANGE.
	DWT_FUNCTION2_EMITRANGE = 0x20
	// Position of CYCMATCH field.
	DWT_FUNCTION2_CYCMATCH_Pos = 0x7
	// Bit mask of CYCMATCH field.
	DWT_FUNCTION2_CYCMATCH_Msk = 0x80
	// Bit CYCMATCH.
	DWT_FUNCTION2_CYCMATCH = 0x80
	// Position of DATAVMATCH field.
	DWT_FUNCTION2_DATAVMATCH_Pos = 0x8
	// Bit mask of DATAVMATCH field.
	DWT_FUNCTION2_DATAVMATCH_Msk = 0x100
	// Bit DATAVMATCH.
	DWT_FUNCTION2_DATAVMATCH = 0x100
	// Position of LNK1ENA field.
	DWT_FUNCTION2_LNK1ENA_Pos = 0x9
	// Bit mask of LNK1ENA field.
	DWT_FUNCTION2_LNK1ENA_Msk = 0x200
	// Bit LNK1ENA.
	DWT_FUNCTION2_LNK1ENA = 0x200
	// Position of DATAVSIZE field.
	DWT_FUNCTION2_DATAVSIZE_Pos = 0xa
	// Bit mask of DATAVSIZE field.
	DWT_FUNCTION2_DATAVSIZE_Msk = 0xc00
	// Position of DATAVADDR0 field.
	DWT_FUNCTION2_DATAVADDR0_Pos = 0xc
	// Bit mask of DATAVADDR0 field.
	DWT_FUNCTION2_DATAVADDR0_Msk = 0xf000
	// Position of DATAVADDR1 field.
	DWT_FUNCTION2_DATAVADDR1_Pos = 0x10
	// Bit mask of DATAVADDR1 field.
	DWT_FUNCTION2_DATAVADDR1_Msk = 0xf0000
	// Position of MATCHED field.
	DWT_FUNCTION2_MATCHED_Pos = 0x18
	// Bit mask of MATCHED field.
	DWT_FUNCTION2_MATCHED_Msk = 0x1000000
	// Bit MATCHED.
	DWT_FUNCTION2_MATCHED = 0x1000000

	// MASK3: Mask Register 3
	// Position of MASK field.
	DWT_MASK3_MASK_Pos = 0x0
	// Bit mask of MASK field.
	DWT_MASK3_MASK_Msk = 0x1f

	// FUNCTION3: Function Register 3
	// Position of FUNCTION field.
	DWT_FUNCTION3_FUNCTION_Pos = 0x0
	// Bit mask of FUNCTION field.
	DWT_FUNCTION3_FUNCTION_Msk = 0xf
	// Position of EMITRANGE field.
	DWT_FUNCTION3_EMITRANGE_Pos = 0x5
	// Bit mask of EMITRANGE field.
	DWT_FUNCTION3_EMITRANGE_Msk = 0x20
	// Bit EMITRANGE.
	DWT_FUNCTION3_EMITRANGE = 0x20
	// Position of CYCMATCH field.
	DWT_FUNCTION3_CYCMATCH_Pos = 0x7
	// Bit mask of CYCMATCH field.
	DWT_FUNCTION3_CYCMATCH_Msk = 0x80
	// Bit CYCMATCH.
	DWT_FUNCTION3_CYCMATCH = 0x80
	// Position of DATAVMATCH field.
	DWT_FUNCTION3_DATAVMATCH_Pos = 0x8
	// Bit mask of DATAVMATCH field.
	DWT_FUNCTION3_DATAVMATCH_Msk = 0x100
	// Bit DATAVMATCH.
	DWT_FUNCTION3_DATAVMATCH = 0x100
	// Position of LNK1ENA field.
	DWT_FUNCTION3_LNK1ENA_Pos = 0x9
	// Bit mask of LNK1ENA field.
	DWT_FUNCTION3_LNK1ENA_Msk = 0x200
	// Bit LNK1ENA.
	DWT_FUNCTION3_LNK1ENA = 0x200
	// Position of DATAVSIZE field.
	DWT_FUNCTION3_DATAVSIZE_Pos = 0xa
	// Bit mask of DATAVSIZE field.
	DWT_FUNCTION3_DATAVSIZE_Msk = 0xc00
	// Position of DATAVADDR0 field.
	DWT_FUNCTION3_DATAVADDR0_Pos = 0xc
	// Bit mask of DATAVADDR0 field.
	DWT_FUNCTION3_DATAVADDR0_Msk = 0xf000
	// Position of DATAVADDR1 field.
	DWT_FUNCTION3_DATAVADDR1_Pos = 0x10
	// Bit mask of DATAVADDR1 field.
	DWT_FUNCTION3_DATAVADDR1_Msk = 0xf0000
	// Position of MATCHED field.
	DWT_FUNCTION3_MATCHED_Pos = 0x18
	// Bit mask of MATCHED field.
	DWT_FUNCTION3_MATCHED_Msk = 0x1000000
	// Bit MATCHED.
	DWT_FUNCTION3_MATCHED = 0x1000000
)

// Constants for ETM: Embedded Trace Macrocell
const (
	// CR: ETM Main Control Register
	// Position of ETMPD field.
	ETM_CR_ETMPD_Pos = 0x0
	// Bit mask of ETMPD field.
	ETM_CR_ETMPD_Msk = 0x1
	// Bit ETMPD.
	ETM_CR_ETMPD = 0x1
	// Position of PORTSIZE field.
	ETM_CR_PORTSIZE_Pos = 0x4
	// Bit mask of PORTSIZE field.
	ETM_CR_PORTSIZE_Msk = 0x70
	// Position of STALL field.
	ETM_CR_STALL_Pos = 0x7
	// Bit mask of STALL field.
	ETM_CR_STALL_Msk = 0x80
	// Bit STALL.
	ETM_CR_STALL = 0x80
	// Position of BROUT field.
	ETM_CR_BROUT_Pos = 0x8
	// Bit mask of BROUT field.
	ETM_CR_BROUT_Msk = 0x100
	// Bit BROUT.
	ETM_CR_BROUT = 0x100
	// Position of DBGRQ field.
	ETM_CR_DBGRQ_Pos = 0x9
	// Bit mask of DBGRQ field.
	ETM_CR_DBGRQ_Msk = 0x200
	// Bit DBGRQ.
	ETM_CR_DBGRQ = 0x200
	// Position of PROG field.
	ETM_CR_PROG_Pos = 0xa
	// Bit mask of PROG field.
	ETM_CR_PROG_Msk = 0x400
	// Bit PROG.
	ETM_CR_PROG = 0x400
	// Position of PORTSEL field.
	ETM_CR_PORTSEL_Pos = 0xb
	// Bit mask of PORTSEL field.
	ETM_CR_PORTSEL_Msk = 0x800
	// Bit PORTSEL.
	ETM_CR_PORTSEL = 0x800
	// Position of PORTMODE2 field.
	ETM_CR_PORTMODE2_Pos = 0xd
	// Bit mask of PORTMODE2 field.
	ETM_CR_PORTMODE2_Msk = 0x2000
	// Bit PORTMODE2.
	ETM_CR_PORTMODE2 = 0x2000
	// Position of PORTMODE field.
	ETM_CR_PORTMODE_Pos = 0x10
	// Bit mask of PORTMODE field.
	ETM_CR_PORTMODE_Msk = 0x30000
	// Position of PORTSIZE3 field.
	ETM_CR_PORTSIZE3_Pos = 0x15
	// Bit mask of PORTSIZE3 field.
	ETM_CR_PORTSIZE3_Msk = 0x200000
	// Bit PORTSIZE3.
	ETM_CR_PORTSIZE3 = 0x200000
	// Position of TSEN field.
	ETM_CR_TSEN_Pos = 0x1c
	// Bit mask of TSEN field.
	ETM_CR_TSEN_Msk = 0x10000000
	// Bit TSEN.
	ETM_CR_TSEN = 0x10000000

	// ITCTRL: ETM Integration Mode Control Register
	// Position of INTEGRATION field.
	ETM_ITCTRL_INTEGRATION_Pos = 0x0
	// Bit mask of INTEGRATION field.
	ETM_ITCTRL_INTEGRATION_Msk = 0x1
	// Bit INTEGRATION.
	ETM_ITCTRL_INTEGRATION = 0x1

	// LSR: ETM Lock Status Register
	// Position of Present field.
	ETM_LSR_Present_Pos = 0x0
	// Bit mask of Present field.
	ETM_LSR_Present_Msk = 0x1
	// Bit Present.
	ETM_LSR_Present = 0x1
	// Position of Access field.
	ETM_LSR_Access_Pos = 0x1
	// Bit mask of Access field.
	ETM_LSR_Access_Msk = 0x2
	// Bit Access.
	ETM_LSR_Access = 0x2
	// Position of ByteAcc field.
	ETM_LSR_ByteAcc_Pos = 0x2
	// Bit mask of ByteAcc field.
	ETM_LSR_ByteAcc_Msk = 0x4
	// Bit ByteAcc.
	ETM_LSR_ByteAcc = 0x4
)

// Constants for FPU: Floating Point Unit
const (
	// FPCCR: Floating-Point Context Control Register
	// Position of LSPACT field.
	FPU_FPCCR_LSPACT_Pos = 0x0
	// Bit mask of LSPACT field.
	FPU_FPCCR_LSPACT_Msk = 0x1
	// Bit LSPACT.
	FPU_FPCCR_LSPACT = 0x1
	// Position of USER field.
	FPU_FPCCR_USER_Pos = 0x1
	// Bit mask of USER field.
	FPU_FPCCR_USER_Msk = 0x2
	// Bit USER.
	FPU_FPCCR_USER = 0x2
	// Position of THREAD field.
	FPU_FPCCR_THREAD_Pos = 0x3
	// Bit mask of THREAD field.
	FPU_FPCCR_THREAD_Msk = 0x8
	// Bit THREAD.
	FPU_FPCCR_THREAD = 0x8
	// Position of HFRDY field.
	FPU_FPCCR_HFRDY_Pos = 0x4
	// Bit mask of HFRDY field.
	FPU_FPCCR_HFRDY_Msk = 0x10
	// Bit HFRDY.
	FPU_FPCCR_HFRDY = 0x10
	// Position of MMRDY field.
	FPU_FPCCR_MMRDY_Pos = 0x5
	// Bit mask of MMRDY field.
	FPU_FPCCR_MMRDY_Msk = 0x20
	// Bit MMRDY.
	FPU_FPCCR_MMRDY = 0x20
	// Position of BFRDY field.
	FPU_FPCCR_BFRDY_Pos = 0x6
	// Bit mask of BFRDY field.
	FPU_FPCCR_BFRDY_Msk = 0x40
	// Bit BFRDY.
	FPU_FPCCR_BFRDY = 0x40
	// Position of MONRDY field.
	FPU_FPCCR_MONRDY_Pos = 0x8
	// Bit mask of MONRDY field.
	FPU_FPCCR_MONRDY_Msk = 0x100
	// Bit MONRDY.
	FPU_FPCCR_MONRDY = 0x100
	// Position of LSPEN field.
	FPU_FPCCR_LSPEN_Pos = 0x1e
	// Bit mask of LSPEN field.
	FPU_FPCCR_LSPEN_Msk = 0x40000000
	// Bit LSPEN.
	FPU_FPCCR_LSPEN = 0x40000000
	// Position of ASPEN field.
	FPU_FPCCR_ASPEN_Pos = 0x1f
	// Bit mask of ASPEN field.
	FPU_FPCCR_ASPEN_Msk = 0x80000000
	// Bit ASPEN.
	FPU_FPCCR_ASPEN = 0x80000000

	// FPCAR: Floating-Point Context Address Register
	// Position of ADDRESS field.
	FPU_FPCAR_ADDRESS_Pos = 0x3
	// Bit mask of ADDRESS field.
	FPU_FPCAR_ADDRESS_Msk = 0xfffffff8

	// FPDSCR: Floating-Point Default Status Control Register
	// Position of RMODE field.
	FPU_FPDSCR_RMODE_Pos = 0x16
	// Bit mask of RMODE field.
	FPU_FPDSCR_RMODE_Msk = 0xc00000
	// Round to Nearest
	FPU_FPDSCR_RMODE_RN = 0x0
	// Round towards Positive Infinity
	FPU_FPDSCR_RMODE_RP = 0x1
	// Round towards Negative Infinity
	FPU_FPDSCR_RMODE_RM = 0x2
	// Round towards Zero
	FPU_FPDSCR_RMODE_RZ = 0x3
	// Position of FZ field.
	FPU_FPDSCR_FZ_Pos = 0x18
	// Bit mask of FZ field.
	FPU_FPDSCR_FZ_Msk = 0x1000000
	// Bit FZ.
	FPU_FPDSCR_FZ = 0x1000000
	// Position of DN field.
	FPU_FPDSCR_DN_Pos = 0x19
	// Bit mask of DN field.
	FPU_FPDSCR_DN_Msk = 0x2000000
	// Bit DN.
	FPU_FPDSCR_DN = 0x2000000
	// Position of AHP field.
	FPU_FPDSCR_AHP_Pos = 0x1a
	// Bit mask of AHP field.
	FPU_FPDSCR_AHP_Msk = 0x4000000
	// Bit AHP.
	FPU_FPDSCR_AHP = 0x4000000

	// MVFR0: Media and FP Feature Register 0
	// Position of A_SIMD_registers field.
	FPU_MVFR0_A_SIMD_registers_Pos = 0x0
	// Bit mask of A_SIMD_registers field.
	FPU_MVFR0_A_SIMD_registers_Msk = 0xf
	// Position of Single_precision field.
	FPU_MVFR0_Single_precision_Pos = 0x4
	// Bit mask of Single_precision field.
	FPU_MVFR0_Single_precision_Msk = 0xf0
	// Position of Double_precision field.
	FPU_MVFR0_Double_precision_Pos = 0x8
	// Bit mask of Double_precision field.
	FPU_MVFR0_Double_precision_Msk = 0xf00
	// Position of FP_excep_trapping field.
	FPU_MVFR0_FP_excep_trapping_Pos = 0xc
	// Bit mask of FP_excep_trapping field.
	FPU_MVFR0_FP_excep_trapping_Msk = 0xf000
	// Position of Divide field.
	FPU_MVFR0_Divide_Pos = 0x10
	// Bit mask of Divide field.
	FPU_MVFR0_Divide_Msk = 0xf0000
	// Position of Square_root field.
	FPU_MVFR0_Square_root_Pos = 0x14
	// Bit mask of Square_root field.
	FPU_MVFR0_Square_root_Msk = 0xf00000
	// Position of Short_vectors field.
	FPU_MVFR0_Short_vectors_Pos = 0x18
	// Bit mask of Short_vectors field.
	FPU_MVFR0_Short_vectors_Msk = 0xf000000
	// Position of FP_rounding_modes field.
	FPU_MVFR0_FP_rounding_modes_Pos = 0x1c
	// Bit mask of FP_rounding_modes field.
	FPU_MVFR0_FP_rounding_modes_Msk = 0xf0000000

	// MVFR1: Media and FP Feature Register 1
	// Position of FtZ_mode field.
	FPU_MVFR1_FtZ_mode_Pos = 0x0
	// Bit mask of FtZ_mode field.
	FPU_MVFR1_FtZ_mode_Msk = 0xf
	// Position of D_NaN_mode field.
	FPU_MVFR1_D_NaN_mode_Pos = 0x4
	// Bit mask of D_NaN_mode field.
	FPU_MVFR1_D_NaN_mode_Msk = 0xf0
	// Position of FP_HPFP field.
	FPU_MVFR1_FP_HPFP_Pos = 0x18
	// Bit mask of FP_HPFP field.
	FPU_MVFR1_FP_HPFP_Msk = 0xf000000
	// Position of FP_fused_MAC field.
	FPU_MVFR1_FP_fused_MAC_Pos = 0x1c
	// Bit mask of FP_fused_MAC field.
	FPU_MVFR1_FP_fused_MAC_Msk = 0xf0000000
)

// Constants for ITM: Instrumentation Trace Macrocell
const (
	// PORT_WORD_MODE: ITM Stimulus Port Registers
	// Position of PORT field.
	ITM_PORT_WORD_MODE_PORT_Pos = 0x0
	// Bit mask of PORT field.
	ITM_PORT_WORD_MODE_PORT_Msk = 0xffffffff

	// PORT_BYTE_MODE: ITM Stimulus Port Registers
	// Position of PORT field.
	ITM_PORT_BYTE_MODE_PORT_Pos = 0x0
	// Bit mask of PORT field.
	ITM_PORT_BYTE_MODE_PORT_Msk = 0xff

	// PORT_HWORD_MODE: ITM Stimulus Port Registers
	// Position of PORT field.
	ITM_PORT_HWORD_MODE_PORT_Pos = 0x0
	// Bit mask of PORT field.
	ITM_PORT_HWORD_MODE_PORT_Msk = 0xffff

	// TPR: ITM Trace Privilege Register
	// Position of PRIVMASK field.
	ITM_TPR_PRIVMASK_Pos = 0x0
	// Bit mask of PRIVMASK field.
	ITM_TPR_PRIVMASK_Msk = 0xf

	// TCR: ITM Trace Control Register
	// Position of ITMENA field.
	ITM_TCR_ITMENA_Pos = 0x0
	// Bit mask of ITMENA field.
	ITM_TCR_ITMENA_Msk = 0x1
	// Bit ITMENA.
	ITM_TCR_ITMENA = 0x1
	// Position of TSENA field.
	ITM_TCR_TSENA_Pos = 0x1
	// Bit mask of TSENA field.
	ITM_TCR_TSENA_Msk = 0x2
	// Bit TSENA.
	ITM_TCR_TSENA = 0x2
	// Position of SYNCENA field.
	ITM_TCR_SYNCENA_Pos = 0x2
	// Bit mask of SYNCENA field.
	ITM_TCR_SYNCENA_Msk = 0x4
	// Bit SYNCENA.
	ITM_TCR_SYNCENA = 0x4
	// Position of DWTENA field.
	ITM_TCR_DWTENA_Pos = 0x3
	// Bit mask of DWTENA field.
	ITM_TCR_DWTENA_Msk = 0x8
	// Bit DWTENA.
	ITM_TCR_DWTENA = 0x8
	// Position of SWOENA field.
	ITM_TCR_SWOENA_Pos = 0x4
	// Bit mask of SWOENA field.
	ITM_TCR_SWOENA_Msk = 0x10
	// Bit SWOENA.
	ITM_TCR_SWOENA = 0x10
	// Position of STALLENA field.
	ITM_TCR_STALLENA_Pos = 0x5
	// Bit mask of STALLENA field.
	ITM_TCR_STALLENA_Msk = 0x20
	// Bit STALLENA.
	ITM_TCR_STALLENA = 0x20
	// Position of TSPrescale field.
	ITM_TCR_TSPrescale_Pos = 0x8
	// Bit mask of TSPrescale field.
	ITM_TCR_TSPrescale_Msk = 0x300
	// Position of GTSFREQ field.
	ITM_TCR_GTSFREQ_Pos = 0xa
	// Bit mask of GTSFREQ field.
	ITM_TCR_GTSFREQ_Msk = 0xc00
	// Position of TraceBusID field.
	ITM_TCR_TraceBusID_Pos = 0x10
	// Bit mask of TraceBusID field.
	ITM_TCR_TraceBusID_Msk = 0x7f0000
	// Position of BUSY field.
	ITM_TCR_BUSY_Pos = 0x17
	// Bit mask of BUSY field.
	ITM_TCR_BUSY_Msk = 0x800000
	// Bit BUSY.
	ITM_TCR_BUSY = 0x800000

	// IWR: ITM Integration Write Register
	// Position of ATVALIDM field.
	ITM_IWR_ATVALIDM_Pos = 0x0
	// Bit mask of ATVALIDM field.
	ITM_IWR_ATVALIDM_Msk = 0x1
	// Bit ATVALIDM.
	ITM_IWR_ATVALIDM = 0x1

	// IRR: ITM Integration Read Register
	// Position of ATREADYM field.
	ITM_IRR_ATREADYM_Pos = 0x0
	// Bit mask of ATREADYM field.
	ITM_IRR_ATREADYM_Msk = 0x1
	// Bit ATREADYM.
	ITM_IRR_ATREADYM = 0x1
)

// Constants for MPU: Memory Protection Unit
const (
	// TYPE: MPU Type Register
	// Position of SEPARATE field.
	MPU_TYPE_SEPARATE_Pos = 0x0
	// Bit mask of SEPARATE field.
	MPU_TYPE_SEPARATE_Msk = 0x1
	// Bit SEPARATE.
	MPU_TYPE_SEPARATE = 0x1
	// Position of DREGION field.
	MPU_TYPE_DREGION_Pos = 0x8
	// Bit mask of DREGION field.
	MPU_TYPE_DREGION_Msk = 0xff00
	// Position of IREGION field.
	MPU_TYPE_IREGION_Pos = 0x10
	// Bit mask of IREGION field.
	MPU_TYPE_IREGION_Msk = 0xff0000

	// CTRL: MPU Control Register
	// Position of ENABLE field.
	MPU_CTRL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MPU_CTRL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MPU_CTRL_ENABLE = 0x1
	// Position of HFNMIENA field.
	MPU_CTRL_HFNMIENA_Pos = 0x1
	// Bit mask of HFNMIENA field.
	MPU_CTRL_HFNMIENA_Msk = 0x2
	// Bit HFNMIENA.
	MPU_CTRL_HFNMIENA = 0x2
	// Position of PRIVDEFENA field.
	MPU_CTRL_PRIVDEFENA_Pos = 0x2
	// Bit mask of PRIVDEFENA field.
	MPU_CTRL_PRIVDEFENA_Msk = 0x4
	// Bit PRIVDEFENA.
	MPU_CTRL_PRIVDEFENA = 0x4

	// RNR: MPU Region Number Register
	// Position of REGION field.
	MPU_RNR_REGION_Pos = 0x0
	// Bit mask of REGION field.
	MPU_RNR_REGION_Msk = 0xff

	// RBAR: MPU Region Base Address Register
	// Position of REGION field.
	MPU_RBAR_REGION_Pos = 0x0
	// Bit mask of REGION field.
	MPU_RBAR_REGION_Msk = 0xf
	// Position of VALID field.
	MPU_RBAR_VALID_Pos = 0x4
	// Bit mask of VALID field.
	MPU_RBAR_VALID_Msk = 0x10
	// Bit VALID.
	MPU_RBAR_VALID = 0x10
	// Position of ADDR field.
	MPU_RBAR_ADDR_Pos = 0x5
	// Bit mask of ADDR field.
	MPU_RBAR_ADDR_Msk = 0xffffffe0

	// RASR: MPU Region Attribute and Size Register
	// Position of ENABLE field.
	MPU_RASR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MPU_RASR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MPU_RASR_ENABLE = 0x1
	// Position of SIZE field.
	MPU_RASR_SIZE_Pos = 0x1
	// Bit mask of SIZE field.
	MPU_RASR_SIZE_Msk = 0x2
	// Bit SIZE.
	MPU_RASR_SIZE = 0x2
	// Position of SRD field.
	MPU_RASR_SRD_Pos = 0x8
	// Bit mask of SRD field.
	MPU_RASR_SRD_Msk = 0xff00
	// Position of B field.
	MPU_RASR_B_Pos = 0x10
	// Bit mask of B field.
	MPU_RASR_B_Msk = 0x10000
	// Bit B.
	MPU_RASR_B = 0x10000
	// Position of C field.
	MPU_RASR_C_Pos = 0x11
	// Bit mask of C field.
	MPU_RASR_C_Msk = 0x20000
	// Bit C.
	MPU_RASR_C = 0x20000
	// Position of S field.
	MPU_RASR_S_Pos = 0x12
	// Bit mask of S field.
	MPU_RASR_S_Msk = 0x40000
	// Bit S.
	MPU_RASR_S = 0x40000
	// Position of TEX field.
	MPU_RASR_TEX_Pos = 0x13
	// Bit mask of TEX field.
	MPU_RASR_TEX_Msk = 0x380000
	// Position of AP field.
	MPU_RASR_AP_Pos = 0x18
	// Bit mask of AP field.
	MPU_RASR_AP_Msk = 0x7000000
	// Position of XN field.
	MPU_RASR_XN_Pos = 0x1c
	// Bit mask of XN field.
	MPU_RASR_XN_Msk = 0x10000000
	// Bit XN.
	MPU_RASR_XN = 0x10000000

	// RBAR_A1: MPU Alias 1 Region Base Address Register
	// Position of REGION field.
	MPU_RBAR_A1_REGION_Pos = 0x0
	// Bit mask of REGION field.
	MPU_RBAR_A1_REGION_Msk = 0xf
	// Position of VALID field.
	MPU_RBAR_A1_VALID_Pos = 0x4
	// Bit mask of VALID field.
	MPU_RBAR_A1_VALID_Msk = 0x10
	// Bit VALID.
	MPU_RBAR_A1_VALID = 0x10
	// Position of ADDR field.
	MPU_RBAR_A1_ADDR_Pos = 0x5
	// Bit mask of ADDR field.
	MPU_RBAR_A1_ADDR_Msk = 0xffffffe0

	// RASR_A1: MPU Alias 1 Region Attribute and Size Register
	// Position of ENABLE field.
	MPU_RASR_A1_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MPU_RASR_A1_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MPU_RASR_A1_ENABLE = 0x1
	// Position of SIZE field.
	MPU_RASR_A1_SIZE_Pos = 0x1
	// Bit mask of SIZE field.
	MPU_RASR_A1_SIZE_Msk = 0x2
	// Bit SIZE.
	MPU_RASR_A1_SIZE = 0x2
	// Position of SRD field.
	MPU_RASR_A1_SRD_Pos = 0x8
	// Bit mask of SRD field.
	MPU_RASR_A1_SRD_Msk = 0xff00
	// Position of B field.
	MPU_RASR_A1_B_Pos = 0x10
	// Bit mask of B field.
	MPU_RASR_A1_B_Msk = 0x10000
	// Bit B.
	MPU_RASR_A1_B = 0x10000
	// Position of C field.
	MPU_RASR_A1_C_Pos = 0x11
	// Bit mask of C field.
	MPU_RASR_A1_C_Msk = 0x20000
	// Bit C.
	MPU_RASR_A1_C = 0x20000
	// Position of S field.
	MPU_RASR_A1_S_Pos = 0x12
	// Bit mask of S field.
	MPU_RASR_A1_S_Msk = 0x40000
	// Bit S.
	MPU_RASR_A1_S = 0x40000
	// Position of TEX field.
	MPU_RASR_A1_TEX_Pos = 0x13
	// Bit mask of TEX field.
	MPU_RASR_A1_TEX_Msk = 0x380000
	// Position of AP field.
	MPU_RASR_A1_AP_Pos = 0x18
	// Bit mask of AP field.
	MPU_RASR_A1_AP_Msk = 0x7000000
	// Position of XN field.
	MPU_RASR_A1_XN_Pos = 0x1c
	// Bit mask of XN field.
	MPU_RASR_A1_XN_Msk = 0x10000000
	// Bit XN.
	MPU_RASR_A1_XN = 0x10000000

	// RBAR_A2: MPU Alias 2 Region Base Address Register
	// Position of REGION field.
	MPU_RBAR_A2_REGION_Pos = 0x0
	// Bit mask of REGION field.
	MPU_RBAR_A2_REGION_Msk = 0xf
	// Position of VALID field.
	MPU_RBAR_A2_VALID_Pos = 0x4
	// Bit mask of VALID field.
	MPU_RBAR_A2_VALID_Msk = 0x10
	// Bit VALID.
	MPU_RBAR_A2_VALID = 0x10
	// Position of ADDR field.
	MPU_RBAR_A2_ADDR_Pos = 0x5
	// Bit mask of ADDR field.
	MPU_RBAR_A2_ADDR_Msk = 0xffffffe0

	// RASR_A2: MPU Alias 2 Region Attribute and Size Register
	// Position of ENABLE field.
	MPU_RASR_A2_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MPU_RASR_A2_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MPU_RASR_A2_ENABLE = 0x1
	// Position of SIZE field.
	MPU_RASR_A2_SIZE_Pos = 0x1
	// Bit mask of SIZE field.
	MPU_RASR_A2_SIZE_Msk = 0x2
	// Bit SIZE.
	MPU_RASR_A2_SIZE = 0x2
	// Position of SRD field.
	MPU_RASR_A2_SRD_Pos = 0x8
	// Bit mask of SRD field.
	MPU_RASR_A2_SRD_Msk = 0xff00
	// Position of B field.
	MPU_RASR_A2_B_Pos = 0x10
	// Bit mask of B field.
	MPU_RASR_A2_B_Msk = 0x10000
	// Bit B.
	MPU_RASR_A2_B = 0x10000
	// Position of C field.
	MPU_RASR_A2_C_Pos = 0x11
	// Bit mask of C field.
	MPU_RASR_A2_C_Msk = 0x20000
	// Bit C.
	MPU_RASR_A2_C = 0x20000
	// Position of S field.
	MPU_RASR_A2_S_Pos = 0x12
	// Bit mask of S field.
	MPU_RASR_A2_S_Msk = 0x40000
	// Bit S.
	MPU_RASR_A2_S = 0x40000
	// Position of TEX field.
	MPU_RASR_A2_TEX_Pos = 0x13
	// Bit mask of TEX field.
	MPU_RASR_A2_TEX_Msk = 0x380000
	// Position of AP field.
	MPU_RASR_A2_AP_Pos = 0x18
	// Bit mask of AP field.
	MPU_RASR_A2_AP_Msk = 0x7000000
	// Position of XN field.
	MPU_RASR_A2_XN_Pos = 0x1c
	// Bit mask of XN field.
	MPU_RASR_A2_XN_Msk = 0x10000000
	// Bit XN.
	MPU_RASR_A2_XN = 0x10000000

	// RBAR_A3: MPU Alias 3 Region Base Address Register
	// Position of REGION field.
	MPU_RBAR_A3_REGION_Pos = 0x0
	// Bit mask of REGION field.
	MPU_RBAR_A3_REGION_Msk = 0xf
	// Position of VALID field.
	MPU_RBAR_A3_VALID_Pos = 0x4
	// Bit mask of VALID field.
	MPU_RBAR_A3_VALID_Msk = 0x10
	// Bit VALID.
	MPU_RBAR_A3_VALID = 0x10
	// Position of ADDR field.
	MPU_RBAR_A3_ADDR_Pos = 0x5
	// Bit mask of ADDR field.
	MPU_RBAR_A3_ADDR_Msk = 0xffffffe0

	// RASR_A3: MPU Alias 3 Region Attribute and Size Register
	// Position of ENABLE field.
	MPU_RASR_A3_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MPU_RASR_A3_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MPU_RASR_A3_ENABLE = 0x1
	// Position of SIZE field.
	MPU_RASR_A3_SIZE_Pos = 0x1
	// Bit mask of SIZE field.
	MPU_RASR_A3_SIZE_Msk = 0x2
	// Bit SIZE.
	MPU_RASR_A3_SIZE = 0x2
	// Position of SRD field.
	MPU_RASR_A3_SRD_Pos = 0x8
	// Bit mask of SRD field.
	MPU_RASR_A3_SRD_Msk = 0xff00
	// Position of B field.
	MPU_RASR_A3_B_Pos = 0x10
	// Bit mask of B field.
	MPU_RASR_A3_B_Msk = 0x10000
	// Bit B.
	MPU_RASR_A3_B = 0x10000
	// Position of C field.
	MPU_RASR_A3_C_Pos = 0x11
	// Bit mask of C field.
	MPU_RASR_A3_C_Msk = 0x20000
	// Bit C.
	MPU_RASR_A3_C = 0x20000
	// Position of S field.
	MPU_RASR_A3_S_Pos = 0x12
	// Bit mask of S field.
	MPU_RASR_A3_S_Msk = 0x40000
	// Bit S.
	MPU_RASR_A3_S = 0x40000
	// Position of TEX field.
	MPU_RASR_A3_TEX_Pos = 0x13
	// Bit mask of TEX field.
	MPU_RASR_A3_TEX_Msk = 0x380000
	// Position of AP field.
	MPU_RASR_A3_AP_Pos = 0x18
	// Bit mask of AP field.
	MPU_RASR_A3_AP_Msk = 0x7000000
	// Position of XN field.
	MPU_RASR_A3_XN_Pos = 0x1c
	// Bit mask of XN field.
	MPU_RASR_A3_XN_Msk = 0x10000000
	// Bit XN.
	MPU_RASR_A3_XN = 0x10000000
)

// Constants for NVIC: Nested Vectored Interrupt Controller
const (
	// ISER: Interrupt Set Enable Register
	// Position of SETENA field.
	NVIC_ISER_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_ISER_SETENA_Msk = 0xffffffff

	// ICER: Interrupt Clear Enable Register
	// Position of CLRENA field.
	NVIC_ICER_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_ICER_CLRENA_Msk = 0xffffffff

	// ISPR: Interrupt Set Pending Register
	// Position of SETPEND field.
	NVIC_ISPR_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_ISPR_SETPEND_Msk = 0xffffffff

	// ICPR: Interrupt Clear Pending Register
	// Position of CLRPEND field.
	NVIC_ICPR_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_ICPR_CLRPEND_Msk = 0xffffffff

	// IABR: Interrupt Active Bit Register
	// Position of ACTIVE field.
	NVIC_IABR_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_IABR_ACTIVE_Msk = 0xffffffff

	// IP: Interrupt Priority Register n
	// Position of PRI0 field.
	NVIC_IP_PRI0_Pos = 0x0
	// Bit mask of PRI0 field.
	NVIC_IP_PRI0_Msk = 0x7

	// STIR: Software Trigger Interrupt Register
	// Position of INTID field.
	NVIC_STIR_INTID_Pos = 0x0
	// Bit mask of INTID field.
	NVIC_STIR_INTID_Msk = 0x1ff
)

// Constants for SysTick: System timer
const (
	// CSR: SysTick Control and Status Register
	// Position of ENABLE field.
	SysTick_CSR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	SysTick_CSR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	SysTick_CSR_ENABLE = 0x1
	// Counter disabled
	SysTick_CSR_ENABLE_VALUE_0 = 0x0
	// Counter enabled
	SysTick_CSR_ENABLE_VALUE_1 = 0x1
	// Position of TICKINT field.
	SysTick_CSR_TICKINT_Pos = 0x1
	// Bit mask of TICKINT field.
	SysTick_CSR_TICKINT_Msk = 0x2
	// Bit TICKINT.
	SysTick_CSR_TICKINT = 0x2
	// Counting down to 0 does not assert the SysTick exception request
	SysTick_CSR_TICKINT_VALUE_0 = 0x0
	// Counting down to 0 asserts the SysTick exception request
	SysTick_CSR_TICKINT_VALUE_1 = 0x1
	// Position of CLKSOURCE field.
	SysTick_CSR_CLKSOURCE_Pos = 0x2
	// Bit mask of CLKSOURCE field.
	SysTick_CSR_CLKSOURCE_Msk = 0x4
	// Bit CLKSOURCE.
	SysTick_CSR_CLKSOURCE = 0x4
	// External clock
	SysTick_CSR_CLKSOURCE_VALUE_0 = 0x0
	// Processor clock
	SysTick_CSR_CLKSOURCE_VALUE_1 = 0x1
	// Position of COUNTFLAG field.
	SysTick_CSR_COUNTFLAG_Pos = 0x10
	// Bit mask of COUNTFLAG field.
	SysTick_CSR_COUNTFLAG_Msk = 0x10000
	// Bit COUNTFLAG.
	SysTick_CSR_COUNTFLAG = 0x10000

	// RVR: SysTick Reload Value Register
	// Position of RELOAD field.
	SysTick_RVR_RELOAD_Pos = 0x0
	// Bit mask of RELOAD field.
	SysTick_RVR_RELOAD_Msk = 0xffffff

	// CVR: SysTick Current Value Register
	// Position of CURRENT field.
	SysTick_CVR_CURRENT_Pos = 0x0
	// Bit mask of CURRENT field.
	SysTick_CVR_CURRENT_Msk = 0xffffff

	// CALIB: SysTick Calibration Value Register
	// Position of TENMS field.
	SysTick_CALIB_TENMS_Pos = 0x0
	// Bit mask of TENMS field.
	SysTick_CALIB_TENMS_Msk = 0xffffff
	// Position of SKEW field.
	SysTick_CALIB_SKEW_Pos = 0x1e
	// Bit mask of SKEW field.
	SysTick_CALIB_SKEW_Msk = 0x40000000
	// Bit SKEW.
	SysTick_CALIB_SKEW = 0x40000000
	// 10ms calibration value is exact
	SysTick_CALIB_SKEW_VALUE_0 = 0x0
	// 10ms calibration value is inexact, because of the clock frequency
	SysTick_CALIB_SKEW_VALUE_1 = 0x1
	// Position of NOREF field.
	SysTick_CALIB_NOREF_Pos = 0x1f
	// Bit mask of NOREF field.
	SysTick_CALIB_NOREF_Msk = 0x80000000
	// Bit NOREF.
	SysTick_CALIB_NOREF = 0x80000000
	// The reference clock is provided
	SysTick_CALIB_NOREF_VALUE_0 = 0x0
	// The reference clock is not provided
	SysTick_CALIB_NOREF_VALUE_1 = 0x1
)

// Constants for SystemControl: System Control Registers
const (
	// ICTR: Interrupt Controller Type Register
	// Position of INTLINESNUM field.
	SystemControl_ICTR_INTLINESNUM_Pos = 0x0
	// Bit mask of INTLINESNUM field.
	SystemControl_ICTR_INTLINESNUM_Msk = 0xf

	// ACTLR: Auxiliary Control Register
	// Position of DISMCYCINT field.
	SystemControl_ACTLR_DISMCYCINT_Pos = 0x0
	// Bit mask of DISMCYCINT field.
	SystemControl_ACTLR_DISMCYCINT_Msk = 0x1
	// Bit DISMCYCINT.
	SystemControl_ACTLR_DISMCYCINT = 0x1
	// Position of DISDEFWBUF field.
	SystemControl_ACTLR_DISDEFWBUF_Pos = 0x1
	// Bit mask of DISDEFWBUF field.
	SystemControl_ACTLR_DISDEFWBUF_Msk = 0x2
	// Bit DISDEFWBUF.
	SystemControl_ACTLR_DISDEFWBUF = 0x2
	// Position of DISFOLD field.
	SystemControl_ACTLR_DISFOLD_Pos = 0x2
	// Bit mask of DISFOLD field.
	SystemControl_ACTLR_DISFOLD_Msk = 0x4
	// Bit DISFOLD.
	SystemControl_ACTLR_DISFOLD = 0x4
	// Position of DISFPCA field.
	SystemControl_ACTLR_DISFPCA_Pos = 0x8
	// Bit mask of DISFPCA field.
	SystemControl_ACTLR_DISFPCA_Msk = 0x100
	// Bit DISFPCA.
	SystemControl_ACTLR_DISFPCA = 0x100
	// Position of DISOOFP field.
	SystemControl_ACTLR_DISOOFP_Pos = 0x9
	// Bit mask of DISOOFP field.
	SystemControl_ACTLR_DISOOFP_Msk = 0x200
	// Bit DISOOFP.
	SystemControl_ACTLR_DISOOFP = 0x200

	// CPUID: CPUID Base Register
	// Position of REVISION field.
	SystemControl_CPUID_REVISION_Pos = 0x0
	// Bit mask of REVISION field.
	SystemControl_CPUID_REVISION_Msk = 0xf
	// Position of PARTNO field.
	SystemControl_CPUID_PARTNO_Pos = 0x4
	// Bit mask of PARTNO field.
	SystemControl_CPUID_PARTNO_Msk = 0xfff0
	// Position of CONSTANT field.
	SystemControl_CPUID_CONSTANT_Pos = 0x10
	// Bit mask of CONSTANT field.
	SystemControl_CPUID_CONSTANT_Msk = 0xf0000
	// Position of VARIANT field.
	SystemControl_CPUID_VARIANT_Pos = 0x14
	// Bit mask of VARIANT field.
	SystemControl_CPUID_VARIANT_Msk = 0xf00000
	// Position of IMPLEMENTER field.
	SystemControl_CPUID_IMPLEMENTER_Pos = 0x18
	// Bit mask of IMPLEMENTER field.
	SystemControl_CPUID_IMPLEMENTER_Msk = 0xff000000

	// ICSR: Interrupt Control and State Register
	// Position of VECTACTIVE field.
	SystemControl_ICSR_VECTACTIVE_Pos = 0x0
	// Bit mask of VECTACTIVE field.
	SystemControl_ICSR_VECTACTIVE_Msk = 0x1ff
	// Position of RETTOBASE field.
	SystemControl_ICSR_RETTOBASE_Pos = 0xb
	// Bit mask of RETTOBASE field.
	SystemControl_ICSR_RETTOBASE_Msk = 0x800
	// Bit RETTOBASE.
	SystemControl_ICSR_RETTOBASE = 0x800
	// Position of VECTPENDING field.
	SystemControl_ICSR_VECTPENDING_Pos = 0xc
	// Bit mask of VECTPENDING field.
	SystemControl_ICSR_VECTPENDING_Msk = 0x3f000
	// Position of ISRPENDING field.
	SystemControl_ICSR_ISRPENDING_Pos = 0x16
	// Bit mask of ISRPENDING field.
	SystemControl_ICSR_ISRPENDING_Msk = 0x400000
	// Bit ISRPENDING.
	SystemControl_ICSR_ISRPENDING = 0x400000
	// Position of ISRPREEMPT field.
	SystemControl_ICSR_ISRPREEMPT_Pos = 0x17
	// Bit mask of ISRPREEMPT field.
	SystemControl_ICSR_ISRPREEMPT_Msk = 0x800000
	// Bit ISRPREEMPT.
	SystemControl_ICSR_ISRPREEMPT = 0x800000
	// Position of PENDSTCLR field.
	SystemControl_ICSR_PENDSTCLR_Pos = 0x19
	// Bit mask of PENDSTCLR field.
	SystemControl_ICSR_PENDSTCLR_Msk = 0x2000000
	// Bit PENDSTCLR.
	SystemControl_ICSR_PENDSTCLR = 0x2000000
	// No effect
	SystemControl_ICSR_PENDSTCLR_VALUE_0 = 0x0
	// Removes the pending state from the SysTick exception
	SystemControl_ICSR_PENDSTCLR_VALUE_1 = 0x1
	// Position of PENDSTSET field.
	SystemControl_ICSR_PENDSTSET_Pos = 0x1a
	// Bit mask of PENDSTSET field.
	SystemControl_ICSR_PENDSTSET_Msk = 0x4000000
	// Bit PENDSTSET.
	SystemControl_ICSR_PENDSTSET = 0x4000000
	// Write: no effect; read: SysTick exception is not pending
	SystemControl_ICSR_PENDSTSET_VALUE_0 = 0x0
	// Write: changes SysTick exception state to pending; read: SysTick exception is pending
	SystemControl_ICSR_PENDSTSET_VALUE_1 = 0x1
	// Position of PENDSVCLR field.
	SystemControl_ICSR_PENDSVCLR_Pos = 0x1b
	// Bit mask of PENDSVCLR field.
	SystemControl_ICSR_PENDSVCLR_Msk = 0x8000000
	// Bit PENDSVCLR.
	SystemControl_ICSR_PENDSVCLR = 0x8000000
	// No effect
	SystemControl_ICSR_PENDSVCLR_VALUE_0 = 0x0
	// Removes the pending state from the PendSV exception
	SystemControl_ICSR_PENDSVCLR_VALUE_1 = 0x1
	// Position of PENDSVSET field.
	SystemControl_ICSR_PENDSVSET_Pos = 0x1c
	// Bit mask of PENDSVSET field.
	SystemControl_ICSR_PENDSVSET_Msk = 0x10000000
	// Bit PENDSVSET.
	SystemControl_ICSR_PENDSVSET = 0x10000000
	// Write: no effect; read: PendSV exception is not pending
	SystemControl_ICSR_PENDSVSET_VALUE_0 = 0x0
	// Write: changes PendSV exception state to pending; read: PendSV exception is pending
	SystemControl_ICSR_PENDSVSET_VALUE_1 = 0x1
	// Position of NMIPENDSET field.
	SystemControl_ICSR_NMIPENDSET_Pos = 0x1f
	// Bit mask of NMIPENDSET field.
	SystemControl_ICSR_NMIPENDSET_Msk = 0x80000000
	// Bit NMIPENDSET.
	SystemControl_ICSR_NMIPENDSET = 0x80000000
	// Write: no effect; read: NMI exception is not pending
	SystemControl_ICSR_NMIPENDSET_VALUE_0 = 0x0
	// Write: changes NMI exception state to pending; read: NMI exception is pending
	SystemControl_ICSR_NMIPENDSET_VALUE_1 = 0x1

	// VTOR: Vector Table Offset Register
	// Position of TBLOFF field.
	SystemControl_VTOR_TBLOFF_Pos = 0x7
	// Bit mask of TBLOFF field.
	SystemControl_VTOR_TBLOFF_Msk = 0xffffff80

	// AIRCR: Application Interrupt and Reset Control Register
	// Position of VECTRESET field.
	SystemControl_AIRCR_VECTRESET_Pos = 0x0
	// Bit mask of VECTRESET field.
	SystemControl_AIRCR_VECTRESET_Msk = 0x1
	// Bit VECTRESET.
	SystemControl_AIRCR_VECTRESET = 0x1
	// Position of VECTCLRACTIVE field.
	SystemControl_AIRCR_VECTCLRACTIVE_Pos = 0x1
	// Bit mask of VECTCLRACTIVE field.
	SystemControl_AIRCR_VECTCLRACTIVE_Msk = 0x2
	// Bit VECTCLRACTIVE.
	SystemControl_AIRCR_VECTCLRACTIVE = 0x2
	// Position of SYSRESETREQ field.
	SystemControl_AIRCR_SYSRESETREQ_Pos = 0x2
	// Bit mask of SYSRESETREQ field.
	SystemControl_AIRCR_SYSRESETREQ_Msk = 0x4
	// Bit SYSRESETREQ.
	SystemControl_AIRCR_SYSRESETREQ = 0x4
	// No system reset request
	SystemControl_AIRCR_SYSRESETREQ_VALUE_0 = 0x0
	// Asserts a signal to the outer system that requests a reset
	SystemControl_AIRCR_SYSRESETREQ_VALUE_1 = 0x1
	// Position of PRIGROUP field.
	SystemControl_AIRCR_PRIGROUP_Pos = 0x8
	// Bit mask of PRIGROUP field.
	SystemControl_AIRCR_PRIGROUP_Msk = 0x700
	// Position of ENDIANNESS field.
	SystemControl_AIRCR_ENDIANNESS_Pos = 0xf
	// Bit mask of ENDIANNESS field.
	SystemControl_AIRCR_ENDIANNESS_Msk = 0x8000
	// Bit ENDIANNESS.
	SystemControl_AIRCR_ENDIANNESS = 0x8000
	// Little-endian
	SystemControl_AIRCR_ENDIANNESS_VALUE_0 = 0x0
	// Big-endian
	SystemControl_AIRCR_ENDIANNESS_VALUE_1 = 0x1
	// Position of VECTKEY field.
	SystemControl_AIRCR_VECTKEY_Pos = 0x10
	// Bit mask of VECTKEY field.
	SystemControl_AIRCR_VECTKEY_Msk = 0xffff0000

	// SCR: System Control Register
	// Position of SLEEPONEXIT field.
	SystemControl_SCR_SLEEPONEXIT_Pos = 0x1
	// Bit mask of SLEEPONEXIT field.
	SystemControl_SCR_SLEEPONEXIT_Msk = 0x2
	// Bit SLEEPONEXIT.
	SystemControl_SCR_SLEEPONEXIT = 0x2
	// Do not sleep when returning to Thread mode
	SystemControl_SCR_SLEEPONEXIT_VALUE_0 = 0x0
	// Enter sleep, or deep sleep, on return from an ISR
	SystemControl_SCR_SLEEPONEXIT_VALUE_1 = 0x1
	// Position of SLEEPDEEP field.
	SystemControl_SCR_SLEEPDEEP_Pos = 0x2
	// Bit mask of SLEEPDEEP field.
	SystemControl_SCR_SLEEPDEEP_Msk = 0x4
	// Bit SLEEPDEEP.
	SystemControl_SCR_SLEEPDEEP = 0x4
	// Sleep
	SystemControl_SCR_SLEEPDEEP_VALUE_0 = 0x0
	// Deep sleep
	SystemControl_SCR_SLEEPDEEP_VALUE_1 = 0x1
	// Position of SEVONPEND field.
	SystemControl_SCR_SEVONPEND_Pos = 0x4
	// Bit mask of SEVONPEND field.
	SystemControl_SCR_SEVONPEND_Msk = 0x10
	// Bit SEVONPEND.
	SystemControl_SCR_SEVONPEND = 0x10
	// Only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded
	SystemControl_SCR_SEVONPEND_VALUE_0 = 0x0
	// Enabled events and all interrupts, including disabled interrupts, can wakeup the processor
	SystemControl_SCR_SEVONPEND_VALUE_1 = 0x1

	// CCR: Configuration and Control Register
	// Position of NONBASETHRDENA field.
	SystemControl_CCR_NONBASETHRDENA_Pos = 0x0
	// Bit mask of NONBASETHRDENA field.
	SystemControl_CCR_NONBASETHRDENA_Msk = 0x1
	// Bit NONBASETHRDENA.
	SystemControl_CCR_NONBASETHRDENA = 0x1
	// Position of USERSETMPEND field.
	SystemControl_CCR_USERSETMPEND_Pos = 0x1
	// Bit mask of USERSETMPEND field.
	SystemControl_CCR_USERSETMPEND_Msk = 0x2
	// Bit USERSETMPEND.
	SystemControl_CCR_USERSETMPEND = 0x2
	// Position of UNALIGN_TRP field.
	SystemControl_CCR_UNALIGN_TRP_Pos = 0x3
	// Bit mask of UNALIGN_TRP field.
	SystemControl_CCR_UNALIGN_TRP_Msk = 0x8
	// Bit UNALIGN_TRP.
	SystemControl_CCR_UNALIGN_TRP = 0x8
	// Do not trap unaligned halfword and word accesses
	SystemControl_CCR_UNALIGN_TRP_VALUE_0 = 0x0
	// Trap unaligned halfword and word accesses
	SystemControl_CCR_UNALIGN_TRP_VALUE_1 = 0x1
	// Position of DIV_0_TRP field.
	SystemControl_CCR_DIV_0_TRP_Pos = 0x4
	// Bit mask of DIV_0_TRP field.
	SystemControl_CCR_DIV_0_TRP_Msk = 0x10
	// Bit DIV_0_TRP.
	SystemControl_CCR_DIV_0_TRP = 0x10
	// Position of BFHFNMIGN field.
	SystemControl_CCR_BFHFNMIGN_Pos = 0x8
	// Bit mask of BFHFNMIGN field.
	SystemControl_CCR_BFHFNMIGN_Msk = 0x100
	// Bit BFHFNMIGN.
	SystemControl_CCR_BFHFNMIGN = 0x100
	// Position of STKALIGN field.
	SystemControl_CCR_STKALIGN_Pos = 0x9
	// Bit mask of STKALIGN field.
	SystemControl_CCR_STKALIGN_Msk = 0x200
	// Bit STKALIGN.
	SystemControl_CCR_STKALIGN = 0x200
	// 4-byte aligned
	SystemControl_CCR_STKALIGN_VALUE_0 = 0x0
	// 8-byte aligned
	SystemControl_CCR_STKALIGN_VALUE_1 = 0x1

	// SHPR1: System Handler Priority Register 1
	// Position of PRI_4 field.
	SystemControl_SHPR1_PRI_4_Pos = 0x0
	// Bit mask of PRI_4 field.
	SystemControl_SHPR1_PRI_4_Msk = 0xff
	// Position of PRI_5 field.
	SystemControl_SHPR1_PRI_5_Pos = 0x8
	// Bit mask of PRI_5 field.
	SystemControl_SHPR1_PRI_5_Msk = 0xff00
	// Position of PRI_6 field.
	SystemControl_SHPR1_PRI_6_Pos = 0x10
	// Bit mask of PRI_6 field.
	SystemControl_SHPR1_PRI_6_Msk = 0xff0000

	// SHPR2: System Handler Priority Register 2
	// Position of PRI_11 field.
	SystemControl_SHPR2_PRI_11_Pos = 0x18
	// Bit mask of PRI_11 field.
	SystemControl_SHPR2_PRI_11_Msk = 0xff000000

	// SHPR3: System Handler Priority Register 3
	// Position of PRI_14 field.
	SystemControl_SHPR3_PRI_14_Pos = 0x10
	// Bit mask of PRI_14 field.
	SystemControl_SHPR3_PRI_14_Msk = 0xff0000
	// Position of PRI_15 field.
	SystemControl_SHPR3_PRI_15_Pos = 0x18
	// Bit mask of PRI_15 field.
	SystemControl_SHPR3_PRI_15_Msk = 0xff000000

	// SHCSR: System Handler Control and State Register
	// Position of MEMFAULTACT field.
	SystemControl_SHCSR_MEMFAULTACT_Pos = 0x0
	// Bit mask of MEMFAULTACT field.
	SystemControl_SHCSR_MEMFAULTACT_Msk = 0x1
	// Bit MEMFAULTACT.
	SystemControl_SHCSR_MEMFAULTACT = 0x1
	// Position of BUSFAULTACT field.
	SystemControl_SHCSR_BUSFAULTACT_Pos = 0x1
	// Bit mask of BUSFAULTACT field.
	SystemControl_SHCSR_BUSFAULTACT_Msk = 0x2
	// Bit BUSFAULTACT.
	SystemControl_SHCSR_BUSFAULTACT = 0x2
	// Position of USGFAULTACT field.
	SystemControl_SHCSR_USGFAULTACT_Pos = 0x3
	// Bit mask of USGFAULTACT field.
	SystemControl_SHCSR_USGFAULTACT_Msk = 0x8
	// Bit USGFAULTACT.
	SystemControl_SHCSR_USGFAULTACT = 0x8
	// Position of SVCALLACT field.
	SystemControl_SHCSR_SVCALLACT_Pos = 0x7
	// Bit mask of SVCALLACT field.
	SystemControl_SHCSR_SVCALLACT_Msk = 0x80
	// Bit SVCALLACT.
	SystemControl_SHCSR_SVCALLACT = 0x80
	// Position of MONITORACT field.
	SystemControl_SHCSR_MONITORACT_Pos = 0x8
	// Bit mask of MONITORACT field.
	SystemControl_SHCSR_MONITORACT_Msk = 0x100
	// Bit MONITORACT.
	SystemControl_SHCSR_MONITORACT = 0x100
	// Position of PENDSVACT field.
	SystemControl_SHCSR_PENDSVACT_Pos = 0xa
	// Bit mask of PENDSVACT field.
	SystemControl_SHCSR_PENDSVACT_Msk = 0x400
	// Bit PENDSVACT.
	SystemControl_SHCSR_PENDSVACT = 0x400
	// Position of SYSTICKACT field.
	SystemControl_SHCSR_SYSTICKACT_Pos = 0xb
	// Bit mask of SYSTICKACT field.
	SystemControl_SHCSR_SYSTICKACT_Msk = 0x800
	// Bit SYSTICKACT.
	SystemControl_SHCSR_SYSTICKACT = 0x800
	// Position of USGFAULTPENDED field.
	SystemControl_SHCSR_USGFAULTPENDED_Pos = 0xc
	// Bit mask of USGFAULTPENDED field.
	SystemControl_SHCSR_USGFAULTPENDED_Msk = 0x1000
	// Bit USGFAULTPENDED.
	SystemControl_SHCSR_USGFAULTPENDED = 0x1000
	// Position of MEMFAULTPENDED field.
	SystemControl_SHCSR_MEMFAULTPENDED_Pos = 0xd
	// Bit mask of MEMFAULTPENDED field.
	SystemControl_SHCSR_MEMFAULTPENDED_Msk = 0x2000
	// Bit MEMFAULTPENDED.
	SystemControl_SHCSR_MEMFAULTPENDED = 0x2000
	// Position of BUSFAULTPENDED field.
	SystemControl_SHCSR_BUSFAULTPENDED_Pos = 0xe
	// Bit mask of BUSFAULTPENDED field.
	SystemControl_SHCSR_BUSFAULTPENDED_Msk = 0x4000
	// Bit BUSFAULTPENDED.
	SystemControl_SHCSR_BUSFAULTPENDED = 0x4000
	// Position of SVCALLPENDED field.
	SystemControl_SHCSR_SVCALLPENDED_Pos = 0xf
	// Bit mask of SVCALLPENDED field.
	SystemControl_SHCSR_SVCALLPENDED_Msk = 0x8000
	// Bit SVCALLPENDED.
	SystemControl_SHCSR_SVCALLPENDED = 0x8000
	// Position of MEMFAULTENA field.
	SystemControl_SHCSR_MEMFAULTENA_Pos = 0x10
	// Bit mask of MEMFAULTENA field.
	SystemControl_SHCSR_MEMFAULTENA_Msk = 0x10000
	// Bit MEMFAULTENA.
	SystemControl_SHCSR_MEMFAULTENA = 0x10000
	// Position of BUSFAULTENA field.
	SystemControl_SHCSR_BUSFAULTENA_Pos = 0x11
	// Bit mask of BUSFAULTENA field.
	SystemControl_SHCSR_BUSFAULTENA_Msk = 0x20000
	// Bit BUSFAULTENA.
	SystemControl_SHCSR_BUSFAULTENA = 0x20000
	// Position of USGFAULTENA field.
	SystemControl_SHCSR_USGFAULTENA_Pos = 0x12
	// Bit mask of USGFAULTENA field.
	SystemControl_SHCSR_USGFAULTENA_Msk = 0x40000
	// Bit USGFAULTENA.
	SystemControl_SHCSR_USGFAULTENA = 0x40000

	// CFSR: Configurable Fault Status Register
	// Position of IACCVIOL field.
	SystemControl_CFSR_IACCVIOL_Pos = 0x0
	// Bit mask of IACCVIOL field.
	SystemControl_CFSR_IACCVIOL_Msk = 0x1
	// Bit IACCVIOL.
	SystemControl_CFSR_IACCVIOL = 0x1
	// Position of DACCVIOL field.
	SystemControl_CFSR_DACCVIOL_Pos = 0x1
	// Bit mask of DACCVIOL field.
	SystemControl_CFSR_DACCVIOL_Msk = 0x2
	// Bit DACCVIOL.
	SystemControl_CFSR_DACCVIOL = 0x2
	// Position of MUNSTKERR field.
	SystemControl_CFSR_MUNSTKERR_Pos = 0x3
	// Bit mask of MUNSTKERR field.
	SystemControl_CFSR_MUNSTKERR_Msk = 0x8
	// Bit MUNSTKERR.
	SystemControl_CFSR_MUNSTKERR = 0x8
	// Position of MSTKERR field.
	SystemControl_CFSR_MSTKERR_Pos = 0x4
	// Bit mask of MSTKERR field.
	SystemControl_CFSR_MSTKERR_Msk = 0x10
	// Bit MSTKERR.
	SystemControl_CFSR_MSTKERR = 0x10
	// Position of MLSPERR field.
	SystemControl_CFSR_MLSPERR_Pos = 0x5
	// Bit mask of MLSPERR field.
	SystemControl_CFSR_MLSPERR_Msk = 0x20
	// Bit MLSPERR.
	SystemControl_CFSR_MLSPERR = 0x20
	// Position of MMARVALID field.
	SystemControl_CFSR_MMARVALID_Pos = 0x7
	// Bit mask of MMARVALID field.
	SystemControl_CFSR_MMARVALID_Msk = 0x80
	// Bit MMARVALID.
	SystemControl_CFSR_MMARVALID = 0x80
	// Position of IBUSERR field.
	SystemControl_CFSR_IBUSERR_Pos = 0x8
	// Bit mask of IBUSERR field.
	SystemControl_CFSR_IBUSERR_Msk = 0x100
	// Bit IBUSERR.
	SystemControl_CFSR_IBUSERR = 0x100
	// Position of PRECISERR field.
	SystemControl_CFSR_PRECISERR_Pos = 0x9
	// Bit mask of PRECISERR field.
	SystemControl_CFSR_PRECISERR_Msk = 0x200
	// Bit PRECISERR.
	SystemControl_CFSR_PRECISERR = 0x200
	// Position of IMPRECISERR field.
	SystemControl_CFSR_IMPRECISERR_Pos = 0xa
	// Bit mask of IMPRECISERR field.
	SystemControl_CFSR_IMPRECISERR_Msk = 0x400
	// Bit IMPRECISERR.
	SystemControl_CFSR_IMPRECISERR = 0x400
	// Position of UNSTKERR field.
	SystemControl_CFSR_UNSTKERR_Pos = 0xb
	// Bit mask of UNSTKERR field.
	SystemControl_CFSR_UNSTKERR_Msk = 0x800
	// Bit UNSTKERR.
	SystemControl_CFSR_UNSTKERR = 0x800
	// Position of STKERR field.
	SystemControl_CFSR_STKERR_Pos = 0xc
	// Bit mask of STKERR field.
	SystemControl_CFSR_STKERR_Msk = 0x1000
	// Bit STKERR.
	SystemControl_CFSR_STKERR = 0x1000
	// Position of LSPERR field.
	SystemControl_CFSR_LSPERR_Pos = 0xd
	// Bit mask of LSPERR field.
	SystemControl_CFSR_LSPERR_Msk = 0x2000
	// Bit LSPERR.
	SystemControl_CFSR_LSPERR = 0x2000
	// Position of BFARVALID field.
	SystemControl_CFSR_BFARVALID_Pos = 0xf
	// Bit mask of BFARVALID field.
	SystemControl_CFSR_BFARVALID_Msk = 0x8000
	// Bit BFARVALID.
	SystemControl_CFSR_BFARVALID = 0x8000
	// Position of UNDEFINSTR field.
	SystemControl_CFSR_UNDEFINSTR_Pos = 0x10
	// Bit mask of UNDEFINSTR field.
	SystemControl_CFSR_UNDEFINSTR_Msk = 0x10000
	// Bit UNDEFINSTR.
	SystemControl_CFSR_UNDEFINSTR = 0x10000
	// Position of INVSTATE field.
	SystemControl_CFSR_INVSTATE_Pos = 0x11
	// Bit mask of INVSTATE field.
	SystemControl_CFSR_INVSTATE_Msk = 0x20000
	// Bit INVSTATE.
	SystemControl_CFSR_INVSTATE = 0x20000
	// Position of INVPC field.
	SystemControl_CFSR_INVPC_Pos = 0x12
	// Bit mask of INVPC field.
	SystemControl_CFSR_INVPC_Msk = 0x40000
	// Bit INVPC.
	SystemControl_CFSR_INVPC = 0x40000
	// Position of NOCP field.
	SystemControl_CFSR_NOCP_Pos = 0x13
	// Bit mask of NOCP field.
	SystemControl_CFSR_NOCP_Msk = 0x80000
	// Bit NOCP.
	SystemControl_CFSR_NOCP = 0x80000
	// Position of UNALIGNED field.
	SystemControl_CFSR_UNALIGNED_Pos = 0x18
	// Bit mask of UNALIGNED field.
	SystemControl_CFSR_UNALIGNED_Msk = 0x1000000
	// Bit UNALIGNED.
	SystemControl_CFSR_UNALIGNED = 0x1000000
	// Position of DIVBYZERO field.
	SystemControl_CFSR_DIVBYZERO_Pos = 0x19
	// Bit mask of DIVBYZERO field.
	SystemControl_CFSR_DIVBYZERO_Msk = 0x2000000
	// Bit DIVBYZERO.
	SystemControl_CFSR_DIVBYZERO = 0x2000000

	// HFSR: HardFault Status Register
	// Position of VECTTBL field.
	SystemControl_HFSR_VECTTBL_Pos = 0x1
	// Bit mask of VECTTBL field.
	SystemControl_HFSR_VECTTBL_Msk = 0x2
	// Bit VECTTBL.
	SystemControl_HFSR_VECTTBL = 0x2
	// Position of FORCED field.
	SystemControl_HFSR_FORCED_Pos = 0x1e
	// Bit mask of FORCED field.
	SystemControl_HFSR_FORCED_Msk = 0x40000000
	// Bit FORCED.
	SystemControl_HFSR_FORCED = 0x40000000
	// Position of DEBUGEVT field.
	SystemControl_HFSR_DEBUGEVT_Pos = 0x1f
	// Bit mask of DEBUGEVT field.
	SystemControl_HFSR_DEBUGEVT_Msk = 0x80000000
	// Bit DEBUGEVT.
	SystemControl_HFSR_DEBUGEVT = 0x80000000

	// DFSR: Debug Fault Status Register
	// Position of HALTED field.
	SystemControl_DFSR_HALTED_Pos = 0x0
	// Bit mask of HALTED field.
	SystemControl_DFSR_HALTED_Msk = 0x1
	// Bit HALTED.
	SystemControl_DFSR_HALTED = 0x1
	// Position of BKPT field.
	SystemControl_DFSR_BKPT_Pos = 0x1
	// Bit mask of BKPT field.
	SystemControl_DFSR_BKPT_Msk = 0x2
	// Bit BKPT.
	SystemControl_DFSR_BKPT = 0x2
	// Position of DWTTRAP field.
	SystemControl_DFSR_DWTTRAP_Pos = 0x2
	// Bit mask of DWTTRAP field.
	SystemControl_DFSR_DWTTRAP_Msk = 0x4
	// Bit DWTTRAP.
	SystemControl_DFSR_DWTTRAP = 0x4
	// Position of VCATCH field.
	SystemControl_DFSR_VCATCH_Pos = 0x3
	// Bit mask of VCATCH field.
	SystemControl_DFSR_VCATCH_Msk = 0x8
	// Bit VCATCH.
	SystemControl_DFSR_VCATCH = 0x8
	// Position of EXTERNAL field.
	SystemControl_DFSR_EXTERNAL_Pos = 0x4
	// Bit mask of EXTERNAL field.
	SystemControl_DFSR_EXTERNAL_Msk = 0x10
	// Bit EXTERNAL.
	SystemControl_DFSR_EXTERNAL = 0x10

	// MMFAR: MemManage Fault Address Register
	// Position of ADDRESS field.
	SystemControl_MMFAR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	SystemControl_MMFAR_ADDRESS_Msk = 0xffffffff

	// BFAR: BusFault Address Register
	// Position of ADDRESS field.
	SystemControl_BFAR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	SystemControl_BFAR_ADDRESS_Msk = 0xffffffff

	// AFSR: Auxiliary Fault Status Register
	// Position of IMPDEF field.
	SystemControl_AFSR_IMPDEF_Pos = 0x0
	// Bit mask of IMPDEF field.
	SystemControl_AFSR_IMPDEF_Msk = 0xffffffff

	// CPACR: Coprocessor Access Control Register
	// Position of CP10 field.
	SystemControl_CPACR_CP10_Pos = 0x14
	// Bit mask of CP10 field.
	SystemControl_CPACR_CP10_Msk = 0x300000
	// Access denied
	SystemControl_CPACR_CP10_DENIED = 0x0
	// Privileged access only
	SystemControl_CPACR_CP10_PRIV = 0x1
	// Full access
	SystemControl_CPACR_CP10_FULL = 0x3
	// Position of CP11 field.
	SystemControl_CPACR_CP11_Pos = 0x16
	// Bit mask of CP11 field.
	SystemControl_CPACR_CP11_Msk = 0xc00000
	// Access denied
	SystemControl_CPACR_CP11_DENIED = 0x0
	// Privileged access only
	SystemControl_CPACR_CP11_PRIV = 0x1
	// Full access
	SystemControl_CPACR_CP11_FULL = 0x3
)

// Constants for TPI: Trace Port Interface Register
const (
	// ACPR: Asynchronous Clock Prescaler Register
	// Position of PRESCALER field.
	TPI_ACPR_PRESCALER_Pos = 0x0
	// Bit mask of PRESCALER field.
	TPI_ACPR_PRESCALER_Msk = 0x1fff

	// SPPR: Selected Pin Protocol Register
	// Position of TXMODE field.
	TPI_SPPR_TXMODE_Pos = 0x0
	// Bit mask of TXMODE field.
	TPI_SPPR_TXMODE_Msk = 0x3

	// FFSR: Formatter and Flush Status Register
	// Position of FlInProg field.
	TPI_FFSR_FlInProg_Pos = 0x0
	// Bit mask of FlInProg field.
	TPI_FFSR_FlInProg_Msk = 0x1
	// Bit FlInProg.
	TPI_FFSR_FlInProg = 0x1
	// Position of FtStopped field.
	TPI_FFSR_FtStopped_Pos = 0x1
	// Bit mask of FtStopped field.
	TPI_FFSR_FtStopped_Msk = 0x2
	// Bit FtStopped.
	TPI_FFSR_FtStopped = 0x2
	// Position of TCPresent field.
	TPI_FFSR_TCPresent_Pos = 0x2
	// Bit mask of TCPresent field.
	TPI_FFSR_TCPresent_Msk = 0x4
	// Bit TCPresent.
	TPI_FFSR_TCPresent = 0x4
	// Position of FtNonStop field.
	TPI_FFSR_FtNonStop_Pos = 0x3
	// Bit mask of FtNonStop field.
	TPI_FFSR_FtNonStop_Msk = 0x8
	// Bit FtNonStop.
	TPI_FFSR_FtNonStop = 0x8

	// FFCR: Formatter and Flush Control Register
	// Position of EnFCont field.
	TPI_FFCR_EnFCont_Pos = 0x1
	// Bit mask of EnFCont field.
	TPI_FFCR_EnFCont_Msk = 0x2
	// Bit EnFCont.
	TPI_FFCR_EnFCont = 0x2
	// Position of TrigIn field.
	TPI_FFCR_TrigIn_Pos = 0x8
	// Bit mask of TrigIn field.
	TPI_FFCR_TrigIn_Msk = 0x100
	// Bit TrigIn.
	TPI_FFCR_TrigIn = 0x100

	// TRIGGER: TRIGGER
	// Position of TRIGGER field.
	TPI_TRIGGER_TRIGGER_Pos = 0x0
	// Bit mask of TRIGGER field.
	TPI_TRIGGER_TRIGGER_Msk = 0x1
	// Bit TRIGGER.
	TPI_TRIGGER_TRIGGER = 0x1

	// FIFO0: Integration ETM Data
	// Position of ETM0 field.
	TPI_FIFO0_ETM0_Pos = 0x0
	// Bit mask of ETM0 field.
	TPI_FIFO0_ETM0_Msk = 0xff
	// Position of ETM1 field.
	TPI_FIFO0_ETM1_Pos = 0x8
	// Bit mask of ETM1 field.
	TPI_FIFO0_ETM1_Msk = 0xff00
	// Position of ETM2 field.
	TPI_FIFO0_ETM2_Pos = 0x10
	// Bit mask of ETM2 field.
	TPI_FIFO0_ETM2_Msk = 0xff0000
	// Position of ETM_bytecount field.
	TPI_FIFO0_ETM_bytecount_Pos = 0x18
	// Bit mask of ETM_bytecount field.
	TPI_FIFO0_ETM_bytecount_Msk = 0x3000000
	// Position of ETM_ATVALID field.
	TPI_FIFO0_ETM_ATVALID_Pos = 0x1a
	// Bit mask of ETM_ATVALID field.
	TPI_FIFO0_ETM_ATVALID_Msk = 0x4000000
	// Bit ETM_ATVALID.
	TPI_FIFO0_ETM_ATVALID = 0x4000000
	// Position of ITM_bytecount field.
	TPI_FIFO0_ITM_bytecount_Pos = 0x1b
	// Bit mask of ITM_bytecount field.
	TPI_FIFO0_ITM_bytecount_Msk = 0x18000000
	// Position of ITM_ATVALID field.
	TPI_FIFO0_ITM_ATVALID_Pos = 0x1d
	// Bit mask of ITM_ATVALID field.
	TPI_FIFO0_ITM_ATVALID_Msk = 0x20000000
	// Bit ITM_ATVALID.
	TPI_FIFO0_ITM_ATVALID = 0x20000000

	// ITATBCTR2: ITATBCTR2
	// Position of ATREADY field.
	TPI_ITATBCTR2_ATREADY_Pos = 0x0
	// Bit mask of ATREADY field.
	TPI_ITATBCTR2_ATREADY_Msk = 0x1
	// Bit ATREADY.
	TPI_ITATBCTR2_ATREADY = 0x1

	// ITATBCTR0: ITATBCTR0
	// Position of ATREADY field.
	TPI_ITATBCTR0_ATREADY_Pos = 0x0
	// Bit mask of ATREADY field.
	TPI_ITATBCTR0_ATREADY_Msk = 0x1
	// Bit ATREADY.
	TPI_ITATBCTR0_ATREADY = 0x1

	// FIFO1: Integration ITM Data
	// Position of ITM0 field.
	TPI_FIFO1_ITM0_Pos = 0x0
	// Bit mask of ITM0 field.
	TPI_FIFO1_ITM0_Msk = 0xff
	// Position of ITM1 field.
	TPI_FIFO1_ITM1_Pos = 0x8
	// Bit mask of ITM1 field.
	TPI_FIFO1_ITM1_Msk = 0xff00
	// Position of ITM2 field.
	TPI_FIFO1_ITM2_Pos = 0x10
	// Bit mask of ITM2 field.
	TPI_FIFO1_ITM2_Msk = 0xff0000
	// Position of ETM_bytecount field.
	TPI_FIFO1_ETM_bytecount_Pos = 0x18
	// Bit mask of ETM_bytecount field.
	TPI_FIFO1_ETM_bytecount_Msk = 0x3000000
	// Position of ETM_ATVALID field.
	TPI_FIFO1_ETM_ATVALID_Pos = 0x1a
	// Bit mask of ETM_ATVALID field.
	TPI_FIFO1_ETM_ATVALID_Msk = 0x4000000
	// Bit ETM_ATVALID.
	TPI_FIFO1_ETM_ATVALID = 0x4000000
	// Position of ITM_bytecount field.
	TPI_FIFO1_ITM_bytecount_Pos = 0x1b
	// Bit mask of ITM_bytecount field.
	TPI_FIFO1_ITM_bytecount_Msk = 0x18000000
	// Position of ITM_ATVALID field.
	TPI_FIFO1_ITM_ATVALID_Pos = 0x1d
	// Bit mask of ITM_ATVALID field.
	TPI_FIFO1_ITM_ATVALID_Msk = 0x20000000
	// Bit ITM_ATVALID.
	TPI_FIFO1_ITM_ATVALID = 0x20000000

	// ITCTRL: Integration Mode Control
	// Position of Mode field.
	TPI_ITCTRL_Mode_Pos = 0x0
	// Bit mask of Mode field.
	TPI_ITCTRL_Mode_Msk = 0x1
	// Bit Mode.
	TPI_ITCTRL_Mode = 0x1

	// DEVID: TPIU_DEVID
	// Position of NrTraceInput field.
	TPI_DEVID_NrTraceInput_Pos = 0x0
	// Bit mask of NrTraceInput field.
	TPI_DEVID_NrTraceInput_Msk = 0x1
	// Bit NrTraceInput.
	TPI_DEVID_NrTraceInput = 0x1
	// Position of AsynClkIn field.
	TPI_DEVID_AsynClkIn_Pos = 0x5
	// Bit mask of AsynClkIn field.
	TPI_DEVID_AsynClkIn_Msk = 0x20
	// Bit AsynClkIn.
	TPI_DEVID_AsynClkIn = 0x20
	// Position of MinBufSz field.
	TPI_DEVID_MinBufSz_Pos = 0x6
	// Bit mask of MinBufSz field.
	TPI_DEVID_MinBufSz_Msk = 0x1c0
	// Position of PTINVALID field.
	TPI_DEVID_PTINVALID_Pos = 0x9
	// Bit mask of PTINVALID field.
	TPI_DEVID_PTINVALID_Msk = 0x200
	// Bit PTINVALID.
	TPI_DEVID_PTINVALID = 0x200
	// Position of MANCVALID field.
	TPI_DEVID_MANCVALID_Pos = 0xa
	// Bit mask of MANCVALID field.
	TPI_DEVID_MANCVALID_Msk = 0x400
	// Bit MANCVALID.
	TPI_DEVID_MANCVALID = 0x400
	// Position of NRZVALID field.
	TPI_DEVID_NRZVALID_Pos = 0xb
	// Bit mask of NRZVALID field.
	TPI_DEVID_NRZVALID_Msk = 0x800
	// Bit NRZVALID.
	TPI_DEVID_NRZVALID = 0x800

	// DEVTYPE: TPIU_DEVTYPE
	// Position of SubType field.
	TPI_DEVTYPE_SubType_Pos = 0x0
	// Bit mask of SubType field.
	TPI_DEVTYPE_SubType_Msk = 0xf
	// Position of MajorType field.
	TPI_DEVTYPE_MajorType_Pos = 0x4
	// Bit mask of MajorType field.
	TPI_DEVTYPE_MajorType_Msk = 0xf0
)
