// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from rp2040.svd, see https://github.com/posborne/cmsis-svd/tree/master/data/RaspberryPi

//go:build rp && rp2040
// +build rp,rp2040

//
//
//     Copyright (c) 2020 Raspberry Pi (Trading) Ltd.
//
//     SPDX-License-Identifier: BSD-3-Clause
package rp

import (
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "RP2040"
	CPU          = "CM0PLUS"
	FPUPresent   = false
	NVICPrioBits = 2
)

// Interrupt numbers.
const (
	// Controls time and alarms
	// time is a 64 bit value indicating the time in usec since power-on
	// timeh is the top 32 bits of time & timel is the bottom 32 bits
	// to change time write to timelw before timehw
	// to read time read from timelr before timehr
	// An alarm is set by setting alarm_enable and writing to the corresponding alarm register
	// When an alarm is pending, the corresponding alarm_running signal will be high
	// An alarm can be cancelled before it has finished by clearing the alarm_enable
	// When an alarm fires, the corresponding alarm_irq is set and alarm_running is cleared
	// To clear the interrupt write a 1 to the corresponding alarm_irq
	IRQ_TIMER_IRQ_0 = 0

	// Controls time and alarms
	// time is a 64 bit value indicating the time in usec since power-on
	// timeh is the top 32 bits of time & timel is the bottom 32 bits
	// to change time write to timelw before timehw
	// to read time read from timelr before timehr
	// An alarm is set by setting alarm_enable and writing to the corresponding alarm register
	// When an alarm is pending, the corresponding alarm_running signal will be high
	// An alarm can be cancelled before it has finished by clearing the alarm_enable
	// When an alarm fires, the corresponding alarm_irq is set and alarm_running is cleared
	// To clear the interrupt write a 1 to the corresponding alarm_irq
	IRQ_TIMER_IRQ_1 = 1

	// Controls time and alarms
	// time is a 64 bit value indicating the time in usec since power-on
	// timeh is the top 32 bits of time & timel is the bottom 32 bits
	// to change time write to timelw before timehw
	// to read time read from timelr before timehr
	// An alarm is set by setting alarm_enable and writing to the corresponding alarm register
	// When an alarm is pending, the corresponding alarm_running signal will be high
	// An alarm can be cancelled before it has finished by clearing the alarm_enable
	// When an alarm fires, the corresponding alarm_irq is set and alarm_running is cleared
	// To clear the interrupt write a 1 to the corresponding alarm_irq
	IRQ_TIMER_IRQ_2 = 2

	// Controls time and alarms
	// time is a 64 bit value indicating the time in usec since power-on
	// timeh is the top 32 bits of time & timel is the bottom 32 bits
	// to change time write to timelw before timehw
	// to read time read from timelr before timehr
	// An alarm is set by setting alarm_enable and writing to the corresponding alarm register
	// When an alarm is pending, the corresponding alarm_running signal will be high
	// An alarm can be cancelled before it has finished by clearing the alarm_enable
	// When an alarm fires, the corresponding alarm_irq is set and alarm_running is cleared
	// To clear the interrupt write a 1 to the corresponding alarm_irq
	IRQ_TIMER_IRQ_3 = 3

	// Simple PWM
	IRQ_PWM_IRQ_WRAP = 4

	// USB FS/LS controller device registers
	IRQ_USBCTRL_IRQ = 5

	// QSPI flash execute-in-place block
	IRQ_XIP_IRQ = 6

	// Programmable IO block
	IRQ_PIO0_IRQ_0 = 7

	// Programmable IO block
	IRQ_PIO0_IRQ_1 = 8

	IRQ_PIO1_IRQ_0 = 9

	IRQ_PIO1_IRQ_1 = 10

	// DMA with separate read and write masters
	IRQ_DMA_IRQ_0 = 11

	// DMA with separate read and write masters
	IRQ_DMA_IRQ_1 = 12

	IRQ_IO_IRQ_BANK0 = 13

	IRQ_IO_IRQ_QSPI = 14

	// Single-cycle IO block
	// Provides core-local and inter-core hardware for the two processors, with single-cycle access.
	IRQ_SIO_IRQ_PROC0 = 15

	// Single-cycle IO block
	// Provides core-local and inter-core hardware for the two processors, with single-cycle access.
	IRQ_SIO_IRQ_PROC1 = 16

	IRQ_CLOCKS_IRQ = 17

	IRQ_SPI0_IRQ = 18

	IRQ_SPI1_IRQ = 19

	IRQ_UART0_IRQ = 20

	IRQ_UART1_IRQ = 21

	// Control and data interface to SAR ADC
	IRQ_ADC_IRQ_FIFO = 22

	// DW_apb_i2c address block
	IRQ_I2C0_IRQ = 23

	IRQ_I2C1_IRQ = 24

	// Register block to control RTC
	IRQ_RTC_IRQ = 25

	// Highest interrupt number on this device.
	IRQ_max = 25
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int)

//export TIMER_IRQ_0_IRQHandler
func interruptTIMER_IRQ_0() {
	callHandlers(IRQ_TIMER_IRQ_0)
}

//export TIMER_IRQ_1_IRQHandler
func interruptTIMER_IRQ_1() {
	callHandlers(IRQ_TIMER_IRQ_1)
}

//export TIMER_IRQ_2_IRQHandler
func interruptTIMER_IRQ_2() {
	callHandlers(IRQ_TIMER_IRQ_2)
}

//export TIMER_IRQ_3_IRQHandler
func interruptTIMER_IRQ_3() {
	callHandlers(IRQ_TIMER_IRQ_3)
}

//export PWM_IRQ_WRAP_IRQHandler
func interruptPWM_IRQ_WRAP() {
	callHandlers(IRQ_PWM_IRQ_WRAP)
}

//export USBCTRL_IRQ_IRQHandler
func interruptUSBCTRL_IRQ() {
	callHandlers(IRQ_USBCTRL_IRQ)
}

//export XIP_IRQ_IRQHandler
func interruptXIP_IRQ() {
	callHandlers(IRQ_XIP_IRQ)
}

//export PIO0_IRQ_0_IRQHandler
func interruptPIO0_IRQ_0() {
	callHandlers(IRQ_PIO0_IRQ_0)
}

//export PIO0_IRQ_1_IRQHandler
func interruptPIO0_IRQ_1() {
	callHandlers(IRQ_PIO0_IRQ_1)
}

//export PIO1_IRQ_0_IRQHandler
func interruptPIO1_IRQ_0() {
	callHandlers(IRQ_PIO1_IRQ_0)
}

//export PIO1_IRQ_1_IRQHandler
func interruptPIO1_IRQ_1() {
	callHandlers(IRQ_PIO1_IRQ_1)
}

//export DMA_IRQ_0_IRQHandler
func interruptDMA_IRQ_0() {
	callHandlers(IRQ_DMA_IRQ_0)
}

//export DMA_IRQ_1_IRQHandler
func interruptDMA_IRQ_1() {
	callHandlers(IRQ_DMA_IRQ_1)
}

//export IO_IRQ_BANK0_IRQHandler
func interruptIO_IRQ_BANK0() {
	callHandlers(IRQ_IO_IRQ_BANK0)
}

//export IO_IRQ_QSPI_IRQHandler
func interruptIO_IRQ_QSPI() {
	callHandlers(IRQ_IO_IRQ_QSPI)
}

//export SIO_IRQ_PROC0_IRQHandler
func interruptSIO_IRQ_PROC0() {
	callHandlers(IRQ_SIO_IRQ_PROC0)
}

//export SIO_IRQ_PROC1_IRQHandler
func interruptSIO_IRQ_PROC1() {
	callHandlers(IRQ_SIO_IRQ_PROC1)
}

//export CLOCKS_IRQ_IRQHandler
func interruptCLOCKS_IRQ() {
	callHandlers(IRQ_CLOCKS_IRQ)
}

//export SPI0_IRQ_IRQHandler
func interruptSPI0_IRQ() {
	callHandlers(IRQ_SPI0_IRQ)
}

//export SPI1_IRQ_IRQHandler
func interruptSPI1_IRQ() {
	callHandlers(IRQ_SPI1_IRQ)
}

//export UART0_IRQ_IRQHandler
func interruptUART0_IRQ() {
	callHandlers(IRQ_UART0_IRQ)
}

//export UART1_IRQ_IRQHandler
func interruptUART1_IRQ() {
	callHandlers(IRQ_UART1_IRQ)
}

//export ADC_IRQ_FIFO_IRQHandler
func interruptADC_IRQ_FIFO() {
	callHandlers(IRQ_ADC_IRQ_FIFO)
}

//export I2C0_IRQ_IRQHandler
func interruptI2C0_IRQ() {
	callHandlers(IRQ_I2C0_IRQ)
}

//export I2C1_IRQ_IRQHandler
func interruptI2C1_IRQ() {
	callHandlers(IRQ_I2C1_IRQ)
}

//export RTC_IRQ_IRQHandler
func interruptRTC_IRQ() {
	callHandlers(IRQ_RTC_IRQ)
}

// Peripherals.
var (
	// QSPI flash execute-in-place block
	XIP_CTRL = (*XIP_CTRL_Type)(unsafe.Pointer(uintptr(0x14000000)))

	// DW_apb_ssi has the following features:
	// * APB interface – Allows for easy integration into a DesignWare Synthesizable Components for AMBA 2 implementation.
	// * APB3 and APB4 protocol support.
	// * Scalable APB data bus width – Supports APB data bus widths of 8, 16, and 32 bits.
	// * Serial-master or serial-slave operation – Enables serial communication with serial-master or serial-slave peripheral devices.
	// * Programmable Dual/Quad/Octal SPI support in Master Mode.
	// * Dual Data Rate (DDR) and Read Data Strobe (RDS) Support - Enables the DW_apb_ssi master to perform operations with the device in DDR and RDS modes when working in Dual/Quad/Octal mode of operation.
	// * Data Mask Support - Enables the DW_apb_ssi to selectively update the bytes in the device. This feature is applicable only in enhanced SPI modes.
	// * eXecute-In-Place (XIP) support - Enables the DW_apb_ssi master to behave as a memory mapped I/O and fetches the data from the device based on the APB read request. This feature is applicable only in enhanced SPI modes.
	// * DMA Controller Interface – Enables the DW_apb_ssi to interface to a DMA controller over the bus using a handshaking interface for transfer requests.
	// * Independent masking of interrupts – Master collision, transmit FIFO overflow, transmit FIFO empty, receive FIFO full, receive FIFO underflow, and receive FIFO overflow interrupts can all be masked independently.
	// * Multi-master contention detection – Informs the processor of multiple serial-master accesses on the serial bus.
	// * Bypass of meta-stability flip-flops for synchronous clocks – When the APB clock (pclk) and the DW_apb_ssi serial clock (ssi_clk) are synchronous, meta-stable flip-flops are not used when transferring control signals across these clock domains.
	// * Programmable delay on the sample time of the received serial data bit (rxd); enables programmable control of routing delays resulting in higher serial data-bit rates.
	// * Programmable features:
	// - Serial interface operation – Choice of Motorola SPI, Texas Instruments Synchronous Serial Protocol or National Semiconductor Microwire.
	// - Clock bit-rate – Dynamic control of the serial bit rate of the data transfer; used in only serial-master mode of operation.
	// - Data Item size (4 to 32 bits) – Item size of each data transfer under the control of the programmer.
	// * Configured features:
	// - FIFO depth – 16 words deep. The FIFO width is fixed at 32 bits.
	// - 1 slave select output.
	// - Hardware slave-select – Dedicated hardware slave-select line.
	// - Combined interrupt line - one combined interrupt line from the DW_apb_ssi to the interrupt controller.
	// - Interrupt polarity – active high interrupt lines.
	// - Serial clock polarity – low serial-clock polarity directly after reset.
	// - Serial clock phase – capture on first edge of serial-clock directly after reset.
	XIP_SSI = (*XIP_SSI_Type)(unsafe.Pointer(uintptr(0x18000000)))

	SYSINFO = (*SYSINFO_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// Register block for various chip control signals
	SYSCFG = (*SYSCFG_Type)(unsafe.Pointer(uintptr(0x40004000)))

	CLOCKS = (*CLOCKS_Type)(unsafe.Pointer(uintptr(0x40008000)))

	RESETS = (*RESETS_Type)(unsafe.Pointer(uintptr(0x4000c000)))

	PSM = (*PSM_Type)(unsafe.Pointer(uintptr(0x40010000)))

	IO_BANK0 = (*IO_BANK0_Type)(unsafe.Pointer(uintptr(0x40014000)))

	IO_QSPI = (*IO_QSPI_Type)(unsafe.Pointer(uintptr(0x40018000)))

	PADS_BANK0 = (*PADS_BANK0_Type)(unsafe.Pointer(uintptr(0x4001c000)))

	PADS_QSPI = (*PADS_QSPI_Type)(unsafe.Pointer(uintptr(0x40020000)))

	// Controls the crystal oscillator
	XOSC = (*XOSC_Type)(unsafe.Pointer(uintptr(0x40024000)))

	PLL_SYS = (*PLL_SYS_Type)(unsafe.Pointer(uintptr(0x40028000)))

	PLL_USB = (*PLL_SYS_Type)(unsafe.Pointer(uintptr(0x4002c000)))

	// Register block for busfabric control signals and performance counters
	BUSCTRL = (*BUSCTRL_Type)(unsafe.Pointer(uintptr(0x40030000)))

	UART0 = (*UART0_Type)(unsafe.Pointer(uintptr(0x40034000)))

	UART1 = (*UART0_Type)(unsafe.Pointer(uintptr(0x40038000)))

	SPI0 = (*SPI0_Type)(unsafe.Pointer(uintptr(0x4003c000)))

	SPI1 = (*SPI0_Type)(unsafe.Pointer(uintptr(0x40040000)))

	// DW_apb_i2c address block
	I2C0 = (*I2C0_Type)(unsafe.Pointer(uintptr(0x40044000)))

	// DW_apb_i2c address block
	I2C1 = (*I2C0_Type)(unsafe.Pointer(uintptr(0x40048000)))

	// Control and data interface to SAR ADC
	ADC = (*ADC_Type)(unsafe.Pointer(uintptr(0x4004c000)))

	// Simple PWM
	PWM = (*PWM_Type)(unsafe.Pointer(uintptr(0x40050000)))

	// Controls time and alarms
	// time is a 64 bit value indicating the time in usec since power-on
	// timeh is the top 32 bits of time & timel is the bottom 32 bits
	// to change time write to timelw before timehw
	// to read time read from timelr before timehr
	// An alarm is set by setting alarm_enable and writing to the corresponding alarm register
	// When an alarm is pending, the corresponding alarm_running signal will be high
	// An alarm can be cancelled before it has finished by clearing the alarm_enable
	// When an alarm fires, the corresponding alarm_irq is set and alarm_running is cleared
	// To clear the interrupt write a 1 to the corresponding alarm_irq
	TIMER = (*TIMER_Type)(unsafe.Pointer(uintptr(0x40054000)))

	WATCHDOG = (*WATCHDOG_Type)(unsafe.Pointer(uintptr(0x40058000)))

	// Register block to control RTC
	RTC = (*RTC_Type)(unsafe.Pointer(uintptr(0x4005c000)))

	ROSC = (*ROSC_Type)(unsafe.Pointer(uintptr(0x40060000)))

	// control and status for on-chip voltage regulator and chip level reset subsystem
	VREG_AND_CHIP_RESET = (*VREG_AND_CHIP_RESET_Type)(unsafe.Pointer(uintptr(0x40064000)))

	// Testbench manager. Allows the programmer to know what platform their software is running on.
	TBMAN = (*TBMAN_Type)(unsafe.Pointer(uintptr(0x4006c000)))

	// DMA with separate read and write masters
	DMA = (*DMA_Type)(unsafe.Pointer(uintptr(0x50000000)))

	// USB FS/LS controller device registers
	USBCTRL_REGS = (*USBCTRL_REGS_Type)(unsafe.Pointer(uintptr(0x50110000)))

	// Programmable IO block
	PIO0 = (*PIO0_Type)(unsafe.Pointer(uintptr(0x50200000)))

	// Programmable IO block
	PIO1 = (*PIO0_Type)(unsafe.Pointer(uintptr(0x50300000)))

	// Single-cycle IO block
	// Provides core-local and inter-core hardware for the two processors, with single-cycle access.
	SIO = (*SIO_Type)(unsafe.Pointer(uintptr(0xd0000000)))

	PPB = (*PPB_Type)(unsafe.Pointer(uintptr(0xe0000000)))
)

// QSPI flash execute-in-place block
type XIP_CTRL_Type struct {
	CTRL        volatile.Register32 // 0x0
	FLUSH       volatile.Register32 // 0x4
	STAT        volatile.Register32 // 0x8
	CTR_HIT     volatile.Register32 // 0xC
	CTR_ACC     volatile.Register32 // 0x10
	STREAM_ADDR volatile.Register32 // 0x14
	STREAM_CTR  volatile.Register32 // 0x18
	STREAM_FIFO volatile.Register32 // 0x1C
}

// XIP_CTRL.CTRL: Cache control
func (o *XIP_CTRL_Type) SetCTRL_POWER_DOWN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *XIP_CTRL_Type) GetCTRL_POWER_DOWN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8) >> 3
}
func (o *XIP_CTRL_Type) SetCTRL_ERR_BADWRITE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *XIP_CTRL_Type) GetCTRL_ERR_BADWRITE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *XIP_CTRL_Type) SetCTRL_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *XIP_CTRL_Type) GetCTRL_EN() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}

// XIP_CTRL.FLUSH: Cache Flush control
func (o *XIP_CTRL_Type) SetFLUSH(value uint32) {
	volatile.StoreUint32(&o.FLUSH.Reg, volatile.LoadUint32(&o.FLUSH.Reg)&^(0x1)|value)
}
func (o *XIP_CTRL_Type) GetFLUSH() uint32 {
	return volatile.LoadUint32(&o.FLUSH.Reg) & 0x1
}

// XIP_CTRL.STAT: Cache Status
func (o *XIP_CTRL_Type) SetSTAT_FIFO_FULL(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x4)|value<<2)
}
func (o *XIP_CTRL_Type) GetSTAT_FIFO_FULL() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x4) >> 2
}
func (o *XIP_CTRL_Type) SetSTAT_FIFO_EMPTY(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x2)|value<<1)
}
func (o *XIP_CTRL_Type) GetSTAT_FIFO_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x2) >> 1
}
func (o *XIP_CTRL_Type) SetSTAT_FLUSH_READY(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x1)|value)
}
func (o *XIP_CTRL_Type) GetSTAT_FLUSH_READY() uint32 {
	return volatile.LoadUint32(&o.STAT.Reg) & 0x1
}

// XIP_CTRL.STREAM_ADDR: FIFO stream address
func (o *XIP_CTRL_Type) SetSTREAM_ADDR(value uint32) {
	volatile.StoreUint32(&o.STREAM_ADDR.Reg, volatile.LoadUint32(&o.STREAM_ADDR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *XIP_CTRL_Type) GetSTREAM_ADDR() uint32 {
	return (volatile.LoadUint32(&o.STREAM_ADDR.Reg) & 0xfffffffc) >> 2
}

// XIP_CTRL.STREAM_CTR: FIFO stream control
func (o *XIP_CTRL_Type) SetSTREAM_CTR(value uint32) {
	volatile.StoreUint32(&o.STREAM_CTR.Reg, volatile.LoadUint32(&o.STREAM_CTR.Reg)&^(0x3fffff)|value)
}
func (o *XIP_CTRL_Type) GetSTREAM_CTR() uint32 {
	return volatile.LoadUint32(&o.STREAM_CTR.Reg) & 0x3fffff
}

// DW_apb_ssi has the following features:
// * APB interface – Allows for easy integration into a DesignWare Synthesizable Components for AMBA 2 implementation.
// * APB3 and APB4 protocol support.
// * Scalable APB data bus width – Supports APB data bus widths of 8, 16, and 32 bits.
// * Serial-master or serial-slave operation – Enables serial communication with serial-master or serial-slave peripheral devices.
// * Programmable Dual/Quad/Octal SPI support in Master Mode.
// * Dual Data Rate (DDR) and Read Data Strobe (RDS) Support - Enables the DW_apb_ssi master to perform operations with the device in DDR and RDS modes when working in Dual/Quad/Octal mode of operation.
// * Data Mask Support - Enables the DW_apb_ssi to selectively update the bytes in the device. This feature is applicable only in enhanced SPI modes.
// * eXecute-In-Place (XIP) support - Enables the DW_apb_ssi master to behave as a memory mapped I/O and fetches the data from the device based on the APB read request. This feature is applicable only in enhanced SPI modes.
// * DMA Controller Interface – Enables the DW_apb_ssi to interface to a DMA controller over the bus using a handshaking interface for transfer requests.
// * Independent masking of interrupts – Master collision, transmit FIFO overflow, transmit FIFO empty, receive FIFO full, receive FIFO underflow, and receive FIFO overflow interrupts can all be masked independently.
// * Multi-master contention detection – Informs the processor of multiple serial-master accesses on the serial bus.
// * Bypass of meta-stability flip-flops for synchronous clocks – When the APB clock (pclk) and the DW_apb_ssi serial clock (ssi_clk) are synchronous, meta-stable flip-flops are not used when transferring control signals across these clock domains.
// * Programmable delay on the sample time of the received serial data bit (rxd); enables programmable control of routing delays resulting in higher serial data-bit rates.
// * Programmable features:
// - Serial interface operation – Choice of Motorola SPI, Texas Instruments Synchronous Serial Protocol or National Semiconductor Microwire.
// - Clock bit-rate – Dynamic control of the serial bit rate of the data transfer; used in only serial-master mode of operation.
// - Data Item size (4 to 32 bits) – Item size of each data transfer under the control of the programmer.
// * Configured features:
// - FIFO depth – 16 words deep. The FIFO width is fixed at 32 bits.
// - 1 slave select output.
// - Hardware slave-select – Dedicated hardware slave-select line.
// - Combined interrupt line - one combined interrupt line from the DW_apb_ssi to the interrupt controller.
// - Interrupt polarity – active high interrupt lines.
// - Serial clock polarity – low serial-clock polarity directly after reset.
// - Serial clock phase – capture on first edge of serial-clock directly after reset.
type XIP_SSI_Type struct {
	CTRLR0         volatile.Register32 // 0x0
	CTRLR1         volatile.Register32 // 0x4
	SSIENR         volatile.Register32 // 0x8
	MWCR           volatile.Register32 // 0xC
	SER            volatile.Register32 // 0x10
	BAUDR          volatile.Register32 // 0x14
	TXFTLR         volatile.Register32 // 0x18
	RXFTLR         volatile.Register32 // 0x1C
	TXFLR          volatile.Register32 // 0x20
	RXFLR          volatile.Register32 // 0x24
	SR             volatile.Register32 // 0x28
	IMR            volatile.Register32 // 0x2C
	ISR            volatile.Register32 // 0x30
	RISR           volatile.Register32 // 0x34
	TXOICR         volatile.Register32 // 0x38
	RXOICR         volatile.Register32 // 0x3C
	RXUICR         volatile.Register32 // 0x40
	MSTICR         volatile.Register32 // 0x44
	ICR            volatile.Register32 // 0x48
	DMACR          volatile.Register32 // 0x4C
	DMATDLR        volatile.Register32 // 0x50
	DMARDLR        volatile.Register32 // 0x54
	IDR            volatile.Register32 // 0x58
	SSI_VERSION_ID volatile.Register32 // 0x5C
	DR0            volatile.Register32 // 0x60
	_              [140]byte
	RX_SAMPLE_DLY  volatile.Register32 // 0xF0
	SPI_CTRLR0     volatile.Register32 // 0xF4
	TXD_DRIVE_EDGE volatile.Register32 // 0xF8
}

// XIP_SSI.CTRLR0: Control register 0
func (o *XIP_SSI_Type) SetCTRLR0_SSTE(value uint32) {
	volatile.StoreUint32(&o.CTRLR0.Reg, volatile.LoadUint32(&o.CTRLR0.Reg)&^(0x1000000)|value<<24)
}
func (o *XIP_SSI_Type) GetCTRLR0_SSTE() uint32 {
	return (volatile.LoadUint32(&o.CTRLR0.Reg) & 0x1000000) >> 24
}
func (o *XIP_SSI_Type) SetCTRLR0_SPI_FRF(value uint32) {
	volatile.StoreUint32(&o.CTRLR0.Reg, volatile.LoadUint32(&o.CTRLR0.Reg)&^(0x600000)|value<<21)
}
func (o *XIP_SSI_Type) GetCTRLR0_SPI_FRF() uint32 {
	return (volatile.LoadUint32(&o.CTRLR0.Reg) & 0x600000) >> 21
}
func (o *XIP_SSI_Type) SetCTRLR0_DFS_32(value uint32) {
	volatile.StoreUint32(&o.CTRLR0.Reg, volatile.LoadUint32(&o.CTRLR0.Reg)&^(0x1f0000)|value<<16)
}
func (o *XIP_SSI_Type) GetCTRLR0_DFS_32() uint32 {
	return (volatile.LoadUint32(&o.CTRLR0.Reg) & 0x1f0000) >> 16
}
func (o *XIP_SSI_Type) SetCTRLR0_CFS(value uint32) {
	volatile.StoreUint32(&o.CTRLR0.Reg, volatile.LoadUint32(&o.CTRLR0.Reg)&^(0xf000)|value<<12)
}
func (o *XIP_SSI_Type) GetCTRLR0_CFS() uint32 {
	return (volatile.LoadUint32(&o.CTRLR0.Reg) & 0xf000) >> 12
}
func (o *XIP_SSI_Type) SetCTRLR0_SRL(value uint32) {
	volatile.StoreUint32(&o.CTRLR0.Reg, volatile.LoadUint32(&o.CTRLR0.Reg)&^(0x800)|value<<11)
}
func (o *XIP_SSI_Type) GetCTRLR0_SRL() uint32 {
	return (volatile.LoadUint32(&o.CTRLR0.Reg) & 0x800) >> 11
}
func (o *XIP_SSI_Type) SetCTRLR0_SLV_OE(value uint32) {
	volatile.StoreUint32(&o.CTRLR0.Reg, volatile.LoadUint32(&o.CTRLR0.Reg)&^(0x400)|value<<10)
}
func (o *XIP_SSI_Type) GetCTRLR0_SLV_OE() uint32 {
	return (volatile.LoadUint32(&o.CTRLR0.Reg) & 0x400) >> 10
}
func (o *XIP_SSI_Type) SetCTRLR0_TMOD(value uint32) {
	volatile.StoreUint32(&o.CTRLR0.Reg, volatile.LoadUint32(&o.CTRLR0.Reg)&^(0x300)|value<<8)
}
func (o *XIP_SSI_Type) GetCTRLR0_TMOD() uint32 {
	return (volatile.LoadUint32(&o.CTRLR0.Reg) & 0x300) >> 8
}
func (o *XIP_SSI_Type) SetCTRLR0_SCPOL(value uint32) {
	volatile.StoreUint32(&o.CTRLR0.Reg, volatile.LoadUint32(&o.CTRLR0.Reg)&^(0x80)|value<<7)
}
func (o *XIP_SSI_Type) GetCTRLR0_SCPOL() uint32 {
	return (volatile.LoadUint32(&o.CTRLR0.Reg) & 0x80) >> 7
}
func (o *XIP_SSI_Type) SetCTRLR0_SCPH(value uint32) {
	volatile.StoreUint32(&o.CTRLR0.Reg, volatile.LoadUint32(&o.CTRLR0.Reg)&^(0x40)|value<<6)
}
func (o *XIP_SSI_Type) GetCTRLR0_SCPH() uint32 {
	return (volatile.LoadUint32(&o.CTRLR0.Reg) & 0x40) >> 6
}
func (o *XIP_SSI_Type) SetCTRLR0_FRF(value uint32) {
	volatile.StoreUint32(&o.CTRLR0.Reg, volatile.LoadUint32(&o.CTRLR0.Reg)&^(0x30)|value<<4)
}
func (o *XIP_SSI_Type) GetCTRLR0_FRF() uint32 {
	return (volatile.LoadUint32(&o.CTRLR0.Reg) & 0x30) >> 4
}
func (o *XIP_SSI_Type) SetCTRLR0_DFS(value uint32) {
	volatile.StoreUint32(&o.CTRLR0.Reg, volatile.LoadUint32(&o.CTRLR0.Reg)&^(0xf)|value)
}
func (o *XIP_SSI_Type) GetCTRLR0_DFS() uint32 {
	return volatile.LoadUint32(&o.CTRLR0.Reg) & 0xf
}

// XIP_SSI.CTRLR1: Master Control register 1
func (o *XIP_SSI_Type) SetCTRLR1_NDF(value uint32) {
	volatile.StoreUint32(&o.CTRLR1.Reg, volatile.LoadUint32(&o.CTRLR1.Reg)&^(0xffff)|value)
}
func (o *XIP_SSI_Type) GetCTRLR1_NDF() uint32 {
	return volatile.LoadUint32(&o.CTRLR1.Reg) & 0xffff
}

// XIP_SSI.SSIENR: SSI Enable
func (o *XIP_SSI_Type) SetSSIENR_SSI_EN(value uint32) {
	volatile.StoreUint32(&o.SSIENR.Reg, volatile.LoadUint32(&o.SSIENR.Reg)&^(0x1)|value)
}
func (o *XIP_SSI_Type) GetSSIENR_SSI_EN() uint32 {
	return volatile.LoadUint32(&o.SSIENR.Reg) & 0x1
}

// XIP_SSI.MWCR: Microwire Control
func (o *XIP_SSI_Type) SetMWCR_MHS(value uint32) {
	volatile.StoreUint32(&o.MWCR.Reg, volatile.LoadUint32(&o.MWCR.Reg)&^(0x4)|value<<2)
}
func (o *XIP_SSI_Type) GetMWCR_MHS() uint32 {
	return (volatile.LoadUint32(&o.MWCR.Reg) & 0x4) >> 2
}
func (o *XIP_SSI_Type) SetMWCR_MDD(value uint32) {
	volatile.StoreUint32(&o.MWCR.Reg, volatile.LoadUint32(&o.MWCR.Reg)&^(0x2)|value<<1)
}
func (o *XIP_SSI_Type) GetMWCR_MDD() uint32 {
	return (volatile.LoadUint32(&o.MWCR.Reg) & 0x2) >> 1
}
func (o *XIP_SSI_Type) SetMWCR_MWMOD(value uint32) {
	volatile.StoreUint32(&o.MWCR.Reg, volatile.LoadUint32(&o.MWCR.Reg)&^(0x1)|value)
}
func (o *XIP_SSI_Type) GetMWCR_MWMOD() uint32 {
	return volatile.LoadUint32(&o.MWCR.Reg) & 0x1
}

// XIP_SSI.SER: Slave enable
func (o *XIP_SSI_Type) SetSER(value uint32) {
	volatile.StoreUint32(&o.SER.Reg, volatile.LoadUint32(&o.SER.Reg)&^(0x1)|value)
}
func (o *XIP_SSI_Type) GetSER() uint32 {
	return volatile.LoadUint32(&o.SER.Reg) & 0x1
}

// XIP_SSI.BAUDR: Baud rate
func (o *XIP_SSI_Type) SetBAUDR_SCKDV(value uint32) {
	volatile.StoreUint32(&o.BAUDR.Reg, volatile.LoadUint32(&o.BAUDR.Reg)&^(0xffff)|value)
}
func (o *XIP_SSI_Type) GetBAUDR_SCKDV() uint32 {
	return volatile.LoadUint32(&o.BAUDR.Reg) & 0xffff
}

// XIP_SSI.TXFTLR: TX FIFO threshold level
func (o *XIP_SSI_Type) SetTXFTLR_TFT(value uint32) {
	volatile.StoreUint32(&o.TXFTLR.Reg, volatile.LoadUint32(&o.TXFTLR.Reg)&^(0xff)|value)
}
func (o *XIP_SSI_Type) GetTXFTLR_TFT() uint32 {
	return volatile.LoadUint32(&o.TXFTLR.Reg) & 0xff
}

// XIP_SSI.RXFTLR: RX FIFO threshold level
func (o *XIP_SSI_Type) SetRXFTLR_RFT(value uint32) {
	volatile.StoreUint32(&o.RXFTLR.Reg, volatile.LoadUint32(&o.RXFTLR.Reg)&^(0xff)|value)
}
func (o *XIP_SSI_Type) GetRXFTLR_RFT() uint32 {
	return volatile.LoadUint32(&o.RXFTLR.Reg) & 0xff
}

// XIP_SSI.TXFLR: TX FIFO level
func (o *XIP_SSI_Type) SetTXFLR_TFTFL(value uint32) {
	volatile.StoreUint32(&o.TXFLR.Reg, volatile.LoadUint32(&o.TXFLR.Reg)&^(0xff)|value)
}
func (o *XIP_SSI_Type) GetTXFLR_TFTFL() uint32 {
	return volatile.LoadUint32(&o.TXFLR.Reg) & 0xff
}

// XIP_SSI.RXFLR: RX FIFO level
func (o *XIP_SSI_Type) SetRXFLR_RXTFL(value uint32) {
	volatile.StoreUint32(&o.RXFLR.Reg, volatile.LoadUint32(&o.RXFLR.Reg)&^(0xff)|value)
}
func (o *XIP_SSI_Type) GetRXFLR_RXTFL() uint32 {
	return volatile.LoadUint32(&o.RXFLR.Reg) & 0xff
}

// XIP_SSI.SR: Status register
func (o *XIP_SSI_Type) SetSR_DCOL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *XIP_SSI_Type) GetSR_DCOL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *XIP_SSI_Type) SetSR_TXE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *XIP_SSI_Type) GetSR_TXE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *XIP_SSI_Type) SetSR_RFF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *XIP_SSI_Type) GetSR_RFF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *XIP_SSI_Type) SetSR_RFNE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *XIP_SSI_Type) GetSR_RFNE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *XIP_SSI_Type) SetSR_TFE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *XIP_SSI_Type) GetSR_TFE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *XIP_SSI_Type) SetSR_TFNF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *XIP_SSI_Type) GetSR_TFNF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *XIP_SSI_Type) SetSR_BUSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *XIP_SSI_Type) GetSR_BUSY() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// XIP_SSI.IMR: Interrupt mask
func (o *XIP_SSI_Type) SetIMR_MSTIM(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *XIP_SSI_Type) GetIMR_MSTIM() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *XIP_SSI_Type) SetIMR_RXFIM(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *XIP_SSI_Type) GetIMR_RXFIM() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *XIP_SSI_Type) SetIMR_RXOIM(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *XIP_SSI_Type) GetIMR_RXOIM() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *XIP_SSI_Type) SetIMR_RXUIM(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *XIP_SSI_Type) GetIMR_RXUIM() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *XIP_SSI_Type) SetIMR_TXOIM(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *XIP_SSI_Type) GetIMR_TXOIM() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *XIP_SSI_Type) SetIMR_TXEIM(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *XIP_SSI_Type) GetIMR_TXEIM() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}

// XIP_SSI.ISR: Interrupt status
func (o *XIP_SSI_Type) SetISR_MSTIS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *XIP_SSI_Type) GetISR_MSTIS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *XIP_SSI_Type) SetISR_RXFIS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *XIP_SSI_Type) GetISR_RXFIS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *XIP_SSI_Type) SetISR_RXOIS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *XIP_SSI_Type) GetISR_RXOIS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *XIP_SSI_Type) SetISR_RXUIS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *XIP_SSI_Type) GetISR_RXUIS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *XIP_SSI_Type) SetISR_TXOIS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *XIP_SSI_Type) GetISR_TXOIS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *XIP_SSI_Type) SetISR_TXEIS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *XIP_SSI_Type) GetISR_TXEIS() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// XIP_SSI.RISR: Raw interrupt status
func (o *XIP_SSI_Type) SetRISR_MSTIR(value uint32) {
	volatile.StoreUint32(&o.RISR.Reg, volatile.LoadUint32(&o.RISR.Reg)&^(0x20)|value<<5)
}
func (o *XIP_SSI_Type) GetRISR_MSTIR() uint32 {
	return (volatile.LoadUint32(&o.RISR.Reg) & 0x20) >> 5
}
func (o *XIP_SSI_Type) SetRISR_RXFIR(value uint32) {
	volatile.StoreUint32(&o.RISR.Reg, volatile.LoadUint32(&o.RISR.Reg)&^(0x10)|value<<4)
}
func (o *XIP_SSI_Type) GetRISR_RXFIR() uint32 {
	return (volatile.LoadUint32(&o.RISR.Reg) & 0x10) >> 4
}
func (o *XIP_SSI_Type) SetRISR_RXOIR(value uint32) {
	volatile.StoreUint32(&o.RISR.Reg, volatile.LoadUint32(&o.RISR.Reg)&^(0x8)|value<<3)
}
func (o *XIP_SSI_Type) GetRISR_RXOIR() uint32 {
	return (volatile.LoadUint32(&o.RISR.Reg) & 0x8) >> 3
}
func (o *XIP_SSI_Type) SetRISR_RXUIR(value uint32) {
	volatile.StoreUint32(&o.RISR.Reg, volatile.LoadUint32(&o.RISR.Reg)&^(0x4)|value<<2)
}
func (o *XIP_SSI_Type) GetRISR_RXUIR() uint32 {
	return (volatile.LoadUint32(&o.RISR.Reg) & 0x4) >> 2
}
func (o *XIP_SSI_Type) SetRISR_TXOIR(value uint32) {
	volatile.StoreUint32(&o.RISR.Reg, volatile.LoadUint32(&o.RISR.Reg)&^(0x2)|value<<1)
}
func (o *XIP_SSI_Type) GetRISR_TXOIR() uint32 {
	return (volatile.LoadUint32(&o.RISR.Reg) & 0x2) >> 1
}
func (o *XIP_SSI_Type) SetRISR_TXEIR(value uint32) {
	volatile.StoreUint32(&o.RISR.Reg, volatile.LoadUint32(&o.RISR.Reg)&^(0x1)|value)
}
func (o *XIP_SSI_Type) GetRISR_TXEIR() uint32 {
	return volatile.LoadUint32(&o.RISR.Reg) & 0x1
}

// XIP_SSI.TXOICR: TX FIFO overflow interrupt clear
func (o *XIP_SSI_Type) SetTXOICR(value uint32) {
	volatile.StoreUint32(&o.TXOICR.Reg, volatile.LoadUint32(&o.TXOICR.Reg)&^(0x1)|value)
}
func (o *XIP_SSI_Type) GetTXOICR() uint32 {
	return volatile.LoadUint32(&o.TXOICR.Reg) & 0x1
}

// XIP_SSI.RXOICR: RX FIFO overflow interrupt clear
func (o *XIP_SSI_Type) SetRXOICR(value uint32) {
	volatile.StoreUint32(&o.RXOICR.Reg, volatile.LoadUint32(&o.RXOICR.Reg)&^(0x1)|value)
}
func (o *XIP_SSI_Type) GetRXOICR() uint32 {
	return volatile.LoadUint32(&o.RXOICR.Reg) & 0x1
}

// XIP_SSI.RXUICR: RX FIFO underflow interrupt clear
func (o *XIP_SSI_Type) SetRXUICR(value uint32) {
	volatile.StoreUint32(&o.RXUICR.Reg, volatile.LoadUint32(&o.RXUICR.Reg)&^(0x1)|value)
}
func (o *XIP_SSI_Type) GetRXUICR() uint32 {
	return volatile.LoadUint32(&o.RXUICR.Reg) & 0x1
}

// XIP_SSI.MSTICR: Multi-master interrupt clear
func (o *XIP_SSI_Type) SetMSTICR(value uint32) {
	volatile.StoreUint32(&o.MSTICR.Reg, volatile.LoadUint32(&o.MSTICR.Reg)&^(0x1)|value)
}
func (o *XIP_SSI_Type) GetMSTICR() uint32 {
	return volatile.LoadUint32(&o.MSTICR.Reg) & 0x1
}

// XIP_SSI.ICR: Interrupt clear
func (o *XIP_SSI_Type) SetICR(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *XIP_SSI_Type) GetICR() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}

// XIP_SSI.DMACR: DMA control
func (o *XIP_SSI_Type) SetDMACR_TDMAE(value uint32) {
	volatile.StoreUint32(&o.DMACR.Reg, volatile.LoadUint32(&o.DMACR.Reg)&^(0x2)|value<<1)
}
func (o *XIP_SSI_Type) GetDMACR_TDMAE() uint32 {
	return (volatile.LoadUint32(&o.DMACR.Reg) & 0x2) >> 1
}
func (o *XIP_SSI_Type) SetDMACR_RDMAE(value uint32) {
	volatile.StoreUint32(&o.DMACR.Reg, volatile.LoadUint32(&o.DMACR.Reg)&^(0x1)|value)
}
func (o *XIP_SSI_Type) GetDMACR_RDMAE() uint32 {
	return volatile.LoadUint32(&o.DMACR.Reg) & 0x1
}

// XIP_SSI.DMATDLR: DMA TX data level
func (o *XIP_SSI_Type) SetDMATDLR_DMATDL(value uint32) {
	volatile.StoreUint32(&o.DMATDLR.Reg, volatile.LoadUint32(&o.DMATDLR.Reg)&^(0xff)|value)
}
func (o *XIP_SSI_Type) GetDMATDLR_DMATDL() uint32 {
	return volatile.LoadUint32(&o.DMATDLR.Reg) & 0xff
}

// XIP_SSI.DMARDLR: DMA RX data level
func (o *XIP_SSI_Type) SetDMARDLR_DMARDL(value uint32) {
	volatile.StoreUint32(&o.DMARDLR.Reg, volatile.LoadUint32(&o.DMARDLR.Reg)&^(0xff)|value)
}
func (o *XIP_SSI_Type) GetDMARDLR_DMARDL() uint32 {
	return volatile.LoadUint32(&o.DMARDLR.Reg) & 0xff
}

// XIP_SSI.IDR: Identification register
func (o *XIP_SSI_Type) SetIDR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, value)
}
func (o *XIP_SSI_Type) GetIDR() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg)
}

// XIP_SSI.SSI_VERSION_ID: Version ID
func (o *XIP_SSI_Type) SetSSI_VERSION_ID(value uint32) {
	volatile.StoreUint32(&o.SSI_VERSION_ID.Reg, value)
}
func (o *XIP_SSI_Type) GetSSI_VERSION_ID() uint32 {
	return volatile.LoadUint32(&o.SSI_VERSION_ID.Reg)
}

// XIP_SSI.DR0: Data Register 0 (of 36)
func (o *XIP_SSI_Type) SetDR0(value uint32) {
	volatile.StoreUint32(&o.DR0.Reg, value)
}
func (o *XIP_SSI_Type) GetDR0() uint32 {
	return volatile.LoadUint32(&o.DR0.Reg)
}

// XIP_SSI.RX_SAMPLE_DLY: RX sample delay
func (o *XIP_SSI_Type) SetRX_SAMPLE_DLY_RSD(value uint32) {
	volatile.StoreUint32(&o.RX_SAMPLE_DLY.Reg, volatile.LoadUint32(&o.RX_SAMPLE_DLY.Reg)&^(0xff)|value)
}
func (o *XIP_SSI_Type) GetRX_SAMPLE_DLY_RSD() uint32 {
	return volatile.LoadUint32(&o.RX_SAMPLE_DLY.Reg) & 0xff
}

// XIP_SSI.SPI_CTRLR0: SPI control
func (o *XIP_SSI_Type) SetSPI_CTRLR0_XIP_CMD(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRLR0.Reg, volatile.LoadUint32(&o.SPI_CTRLR0.Reg)&^(0xff000000)|value<<24)
}
func (o *XIP_SSI_Type) GetSPI_CTRLR0_XIP_CMD() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRLR0.Reg) & 0xff000000) >> 24
}
func (o *XIP_SSI_Type) SetSPI_CTRLR0_SPI_RXDS_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRLR0.Reg, volatile.LoadUint32(&o.SPI_CTRLR0.Reg)&^(0x40000)|value<<18)
}
func (o *XIP_SSI_Type) GetSPI_CTRLR0_SPI_RXDS_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRLR0.Reg) & 0x40000) >> 18
}
func (o *XIP_SSI_Type) SetSPI_CTRLR0_INST_DDR_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRLR0.Reg, volatile.LoadUint32(&o.SPI_CTRLR0.Reg)&^(0x20000)|value<<17)
}
func (o *XIP_SSI_Type) GetSPI_CTRLR0_INST_DDR_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRLR0.Reg) & 0x20000) >> 17
}
func (o *XIP_SSI_Type) SetSPI_CTRLR0_SPI_DDR_EN(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRLR0.Reg, volatile.LoadUint32(&o.SPI_CTRLR0.Reg)&^(0x10000)|value<<16)
}
func (o *XIP_SSI_Type) GetSPI_CTRLR0_SPI_DDR_EN() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRLR0.Reg) & 0x10000) >> 16
}
func (o *XIP_SSI_Type) SetSPI_CTRLR0_WAIT_CYCLES(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRLR0.Reg, volatile.LoadUint32(&o.SPI_CTRLR0.Reg)&^(0xf800)|value<<11)
}
func (o *XIP_SSI_Type) GetSPI_CTRLR0_WAIT_CYCLES() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRLR0.Reg) & 0xf800) >> 11
}
func (o *XIP_SSI_Type) SetSPI_CTRLR0_INST_L(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRLR0.Reg, volatile.LoadUint32(&o.SPI_CTRLR0.Reg)&^(0x300)|value<<8)
}
func (o *XIP_SSI_Type) GetSPI_CTRLR0_INST_L() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRLR0.Reg) & 0x300) >> 8
}
func (o *XIP_SSI_Type) SetSPI_CTRLR0_ADDR_L(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRLR0.Reg, volatile.LoadUint32(&o.SPI_CTRLR0.Reg)&^(0x3c)|value<<2)
}
func (o *XIP_SSI_Type) GetSPI_CTRLR0_ADDR_L() uint32 {
	return (volatile.LoadUint32(&o.SPI_CTRLR0.Reg) & 0x3c) >> 2
}
func (o *XIP_SSI_Type) SetSPI_CTRLR0_TRANS_TYPE(value uint32) {
	volatile.StoreUint32(&o.SPI_CTRLR0.Reg, volatile.LoadUint32(&o.SPI_CTRLR0.Reg)&^(0x3)|value)
}
func (o *XIP_SSI_Type) GetSPI_CTRLR0_TRANS_TYPE() uint32 {
	return volatile.LoadUint32(&o.SPI_CTRLR0.Reg) & 0x3
}

// XIP_SSI.TXD_DRIVE_EDGE: TX drive edge
func (o *XIP_SSI_Type) SetTXD_DRIVE_EDGE_TDE(value uint32) {
	volatile.StoreUint32(&o.TXD_DRIVE_EDGE.Reg, volatile.LoadUint32(&o.TXD_DRIVE_EDGE.Reg)&^(0xff)|value)
}
func (o *XIP_SSI_Type) GetTXD_DRIVE_EDGE_TDE() uint32 {
	return volatile.LoadUint32(&o.TXD_DRIVE_EDGE.Reg) & 0xff
}

type SYSINFO_Type struct {
	CHIP_ID       volatile.Register32 // 0x0
	PLATFORM      volatile.Register32 // 0x4
	_             [56]byte
	GITREF_RP2040 volatile.Register32 // 0x40
}

// SYSINFO.CHIP_ID: JEDEC JEP-106 compliant chip identifier.
func (o *SYSINFO_Type) SetCHIP_ID_REVISION(value uint32) {
	volatile.StoreUint32(&o.CHIP_ID.Reg, volatile.LoadUint32(&o.CHIP_ID.Reg)&^(0xf0000000)|value<<28)
}
func (o *SYSINFO_Type) GetCHIP_ID_REVISION() uint32 {
	return (volatile.LoadUint32(&o.CHIP_ID.Reg) & 0xf0000000) >> 28
}
func (o *SYSINFO_Type) SetCHIP_ID_PART(value uint32) {
	volatile.StoreUint32(&o.CHIP_ID.Reg, volatile.LoadUint32(&o.CHIP_ID.Reg)&^(0xffff000)|value<<12)
}
func (o *SYSINFO_Type) GetCHIP_ID_PART() uint32 {
	return (volatile.LoadUint32(&o.CHIP_ID.Reg) & 0xffff000) >> 12
}
func (o *SYSINFO_Type) SetCHIP_ID_MANUFACTURER(value uint32) {
	volatile.StoreUint32(&o.CHIP_ID.Reg, volatile.LoadUint32(&o.CHIP_ID.Reg)&^(0xfff)|value)
}
func (o *SYSINFO_Type) GetCHIP_ID_MANUFACTURER() uint32 {
	return volatile.LoadUint32(&o.CHIP_ID.Reg) & 0xfff
}

// SYSINFO.PLATFORM: Platform register. Allows software to know what environment it is running in.
func (o *SYSINFO_Type) SetPLATFORM_ASIC(value uint32) {
	volatile.StoreUint32(&o.PLATFORM.Reg, volatile.LoadUint32(&o.PLATFORM.Reg)&^(0x2)|value<<1)
}
func (o *SYSINFO_Type) GetPLATFORM_ASIC() uint32 {
	return (volatile.LoadUint32(&o.PLATFORM.Reg) & 0x2) >> 1
}
func (o *SYSINFO_Type) SetPLATFORM_FPGA(value uint32) {
	volatile.StoreUint32(&o.PLATFORM.Reg, volatile.LoadUint32(&o.PLATFORM.Reg)&^(0x1)|value)
}
func (o *SYSINFO_Type) GetPLATFORM_FPGA() uint32 {
	return volatile.LoadUint32(&o.PLATFORM.Reg) & 0x1
}

// Register block for various chip control signals
type SYSCFG_Type struct {
	PROC0_NMI_MASK         volatile.Register32 // 0x0
	PROC1_NMI_MASK         volatile.Register32 // 0x4
	PROC_CONFIG            volatile.Register32 // 0x8
	PROC_IN_SYNC_BYPASS    volatile.Register32 // 0xC
	PROC_IN_SYNC_BYPASS_HI volatile.Register32 // 0x10
	DBGFORCE               volatile.Register32 // 0x14
	MEMPOWERDOWN           volatile.Register32 // 0x18
}

// SYSCFG.PROC_CONFIG: Configuration for processors
func (o *SYSCFG_Type) SetPROC_CONFIG_PROC1_DAP_INSTID(value uint32) {
	volatile.StoreUint32(&o.PROC_CONFIG.Reg, volatile.LoadUint32(&o.PROC_CONFIG.Reg)&^(0xf0000000)|value<<28)
}
func (o *SYSCFG_Type) GetPROC_CONFIG_PROC1_DAP_INSTID() uint32 {
	return (volatile.LoadUint32(&o.PROC_CONFIG.Reg) & 0xf0000000) >> 28
}
func (o *SYSCFG_Type) SetPROC_CONFIG_PROC0_DAP_INSTID(value uint32) {
	volatile.StoreUint32(&o.PROC_CONFIG.Reg, volatile.LoadUint32(&o.PROC_CONFIG.Reg)&^(0xf000000)|value<<24)
}
func (o *SYSCFG_Type) GetPROC_CONFIG_PROC0_DAP_INSTID() uint32 {
	return (volatile.LoadUint32(&o.PROC_CONFIG.Reg) & 0xf000000) >> 24
}
func (o *SYSCFG_Type) SetPROC_CONFIG_PROC1_HALTED(value uint32) {
	volatile.StoreUint32(&o.PROC_CONFIG.Reg, volatile.LoadUint32(&o.PROC_CONFIG.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetPROC_CONFIG_PROC1_HALTED() uint32 {
	return (volatile.LoadUint32(&o.PROC_CONFIG.Reg) & 0x2) >> 1
}
func (o *SYSCFG_Type) SetPROC_CONFIG_PROC0_HALTED(value uint32) {
	volatile.StoreUint32(&o.PROC_CONFIG.Reg, volatile.LoadUint32(&o.PROC_CONFIG.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetPROC_CONFIG_PROC0_HALTED() uint32 {
	return volatile.LoadUint32(&o.PROC_CONFIG.Reg) & 0x1
}

// SYSCFG.PROC_IN_SYNC_BYPASS
// For each bit, if 1, bypass the input synchronizer between that GPIO
// and the GPIO input register in the SIO. The input synchronizers should
// generally be unbypassed, to avoid injecting metastabilities into processors.
// If you're feeling brave, you can bypass to save two cycles of input
// latency. This register applies to GPIO 0...29.
func (o *SYSCFG_Type) SetPROC_IN_SYNC_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PROC_IN_SYNC_BYPASS.Reg, volatile.LoadUint32(&o.PROC_IN_SYNC_BYPASS.Reg)&^(0x3fffffff)|value)
}
func (o *SYSCFG_Type) GetPROC_IN_SYNC_BYPASS() uint32 {
	return volatile.LoadUint32(&o.PROC_IN_SYNC_BYPASS.Reg) & 0x3fffffff
}

// SYSCFG.PROC_IN_SYNC_BYPASS_HI
// For each bit, if 1, bypass the input synchronizer between that GPIO
// and the GPIO input register in the SIO. The input synchronizers should
// generally be unbypassed, to avoid injecting metastabilities into processors.
// If you're feeling brave, you can bypass to save two cycles of input
// latency. This register applies to GPIO 30...35 (the QSPI IOs).
func (o *SYSCFG_Type) SetPROC_IN_SYNC_BYPASS_HI(value uint32) {
	volatile.StoreUint32(&o.PROC_IN_SYNC_BYPASS_HI.Reg, volatile.LoadUint32(&o.PROC_IN_SYNC_BYPASS_HI.Reg)&^(0x3f)|value)
}
func (o *SYSCFG_Type) GetPROC_IN_SYNC_BYPASS_HI() uint32 {
	return volatile.LoadUint32(&o.PROC_IN_SYNC_BYPASS_HI.Reg) & 0x3f
}

// SYSCFG.DBGFORCE: Directly control the SWD debug port of either processor
func (o *SYSCFG_Type) SetDBGFORCE_PROC1_ATTACH(value uint32) {
	volatile.StoreUint32(&o.DBGFORCE.Reg, volatile.LoadUint32(&o.DBGFORCE.Reg)&^(0x80)|value<<7)
}
func (o *SYSCFG_Type) GetDBGFORCE_PROC1_ATTACH() uint32 {
	return (volatile.LoadUint32(&o.DBGFORCE.Reg) & 0x80) >> 7
}
func (o *SYSCFG_Type) SetDBGFORCE_PROC1_SWCLK(value uint32) {
	volatile.StoreUint32(&o.DBGFORCE.Reg, volatile.LoadUint32(&o.DBGFORCE.Reg)&^(0x40)|value<<6)
}
func (o *SYSCFG_Type) GetDBGFORCE_PROC1_SWCLK() uint32 {
	return (volatile.LoadUint32(&o.DBGFORCE.Reg) & 0x40) >> 6
}
func (o *SYSCFG_Type) SetDBGFORCE_PROC1_SWDI(value uint32) {
	volatile.StoreUint32(&o.DBGFORCE.Reg, volatile.LoadUint32(&o.DBGFORCE.Reg)&^(0x20)|value<<5)
}
func (o *SYSCFG_Type) GetDBGFORCE_PROC1_SWDI() uint32 {
	return (volatile.LoadUint32(&o.DBGFORCE.Reg) & 0x20) >> 5
}
func (o *SYSCFG_Type) SetDBGFORCE_PROC1_SWDO(value uint32) {
	volatile.StoreUint32(&o.DBGFORCE.Reg, volatile.LoadUint32(&o.DBGFORCE.Reg)&^(0x10)|value<<4)
}
func (o *SYSCFG_Type) GetDBGFORCE_PROC1_SWDO() uint32 {
	return (volatile.LoadUint32(&o.DBGFORCE.Reg) & 0x10) >> 4
}
func (o *SYSCFG_Type) SetDBGFORCE_PROC0_ATTACH(value uint32) {
	volatile.StoreUint32(&o.DBGFORCE.Reg, volatile.LoadUint32(&o.DBGFORCE.Reg)&^(0x8)|value<<3)
}
func (o *SYSCFG_Type) GetDBGFORCE_PROC0_ATTACH() uint32 {
	return (volatile.LoadUint32(&o.DBGFORCE.Reg) & 0x8) >> 3
}
func (o *SYSCFG_Type) SetDBGFORCE_PROC0_SWCLK(value uint32) {
	volatile.StoreUint32(&o.DBGFORCE.Reg, volatile.LoadUint32(&o.DBGFORCE.Reg)&^(0x4)|value<<2)
}
func (o *SYSCFG_Type) GetDBGFORCE_PROC0_SWCLK() uint32 {
	return (volatile.LoadUint32(&o.DBGFORCE.Reg) & 0x4) >> 2
}
func (o *SYSCFG_Type) SetDBGFORCE_PROC0_SWDI(value uint32) {
	volatile.StoreUint32(&o.DBGFORCE.Reg, volatile.LoadUint32(&o.DBGFORCE.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetDBGFORCE_PROC0_SWDI() uint32 {
	return (volatile.LoadUint32(&o.DBGFORCE.Reg) & 0x2) >> 1
}
func (o *SYSCFG_Type) SetDBGFORCE_PROC0_SWDO(value uint32) {
	volatile.StoreUint32(&o.DBGFORCE.Reg, volatile.LoadUint32(&o.DBGFORCE.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetDBGFORCE_PROC0_SWDO() uint32 {
	return volatile.LoadUint32(&o.DBGFORCE.Reg) & 0x1
}

// SYSCFG.MEMPOWERDOWN
// Control power downs to memories. Set high to power down memories.
// Use with extreme caution
func (o *SYSCFG_Type) SetMEMPOWERDOWN_ROM(value uint32) {
	volatile.StoreUint32(&o.MEMPOWERDOWN.Reg, volatile.LoadUint32(&o.MEMPOWERDOWN.Reg)&^(0x80)|value<<7)
}
func (o *SYSCFG_Type) GetMEMPOWERDOWN_ROM() uint32 {
	return (volatile.LoadUint32(&o.MEMPOWERDOWN.Reg) & 0x80) >> 7
}
func (o *SYSCFG_Type) SetMEMPOWERDOWN_USB(value uint32) {
	volatile.StoreUint32(&o.MEMPOWERDOWN.Reg, volatile.LoadUint32(&o.MEMPOWERDOWN.Reg)&^(0x40)|value<<6)
}
func (o *SYSCFG_Type) GetMEMPOWERDOWN_USB() uint32 {
	return (volatile.LoadUint32(&o.MEMPOWERDOWN.Reg) & 0x40) >> 6
}
func (o *SYSCFG_Type) SetMEMPOWERDOWN_SRAM5(value uint32) {
	volatile.StoreUint32(&o.MEMPOWERDOWN.Reg, volatile.LoadUint32(&o.MEMPOWERDOWN.Reg)&^(0x20)|value<<5)
}
func (o *SYSCFG_Type) GetMEMPOWERDOWN_SRAM5() uint32 {
	return (volatile.LoadUint32(&o.MEMPOWERDOWN.Reg) & 0x20) >> 5
}
func (o *SYSCFG_Type) SetMEMPOWERDOWN_SRAM4(value uint32) {
	volatile.StoreUint32(&o.MEMPOWERDOWN.Reg, volatile.LoadUint32(&o.MEMPOWERDOWN.Reg)&^(0x10)|value<<4)
}
func (o *SYSCFG_Type) GetMEMPOWERDOWN_SRAM4() uint32 {
	return (volatile.LoadUint32(&o.MEMPOWERDOWN.Reg) & 0x10) >> 4
}
func (o *SYSCFG_Type) SetMEMPOWERDOWN_SRAM3(value uint32) {
	volatile.StoreUint32(&o.MEMPOWERDOWN.Reg, volatile.LoadUint32(&o.MEMPOWERDOWN.Reg)&^(0x8)|value<<3)
}
func (o *SYSCFG_Type) GetMEMPOWERDOWN_SRAM3() uint32 {
	return (volatile.LoadUint32(&o.MEMPOWERDOWN.Reg) & 0x8) >> 3
}
func (o *SYSCFG_Type) SetMEMPOWERDOWN_SRAM2(value uint32) {
	volatile.StoreUint32(&o.MEMPOWERDOWN.Reg, volatile.LoadUint32(&o.MEMPOWERDOWN.Reg)&^(0x4)|value<<2)
}
func (o *SYSCFG_Type) GetMEMPOWERDOWN_SRAM2() uint32 {
	return (volatile.LoadUint32(&o.MEMPOWERDOWN.Reg) & 0x4) >> 2
}
func (o *SYSCFG_Type) SetMEMPOWERDOWN_SRAM1(value uint32) {
	volatile.StoreUint32(&o.MEMPOWERDOWN.Reg, volatile.LoadUint32(&o.MEMPOWERDOWN.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetMEMPOWERDOWN_SRAM1() uint32 {
	return (volatile.LoadUint32(&o.MEMPOWERDOWN.Reg) & 0x2) >> 1
}
func (o *SYSCFG_Type) SetMEMPOWERDOWN_SRAM0(value uint32) {
	volatile.StoreUint32(&o.MEMPOWERDOWN.Reg, volatile.LoadUint32(&o.MEMPOWERDOWN.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetMEMPOWERDOWN_SRAM0() uint32 {
	return volatile.LoadUint32(&o.MEMPOWERDOWN.Reg) & 0x1
}

type CLOCKS_Type struct {
	CLK_GPOUT0_CTRL      volatile.Register32 // 0x0
	CLK_GPOUT0_DIV       volatile.Register32 // 0x4
	CLK_GPOUT0_SELECTED  volatile.Register32 // 0x8
	CLK_GPOUT1_CTRL      volatile.Register32 // 0xC
	CLK_GPOUT1_DIV       volatile.Register32 // 0x10
	CLK_GPOUT1_SELECTED  volatile.Register32 // 0x14
	CLK_GPOUT2_CTRL      volatile.Register32 // 0x18
	CLK_GPOUT2_DIV       volatile.Register32 // 0x1C
	CLK_GPOUT2_SELECTED  volatile.Register32 // 0x20
	CLK_GPOUT3_CTRL      volatile.Register32 // 0x24
	CLK_GPOUT3_DIV       volatile.Register32 // 0x28
	CLK_GPOUT3_SELECTED  volatile.Register32 // 0x2C
	CLK_REF_CTRL         volatile.Register32 // 0x30
	CLK_REF_DIV          volatile.Register32 // 0x34
	CLK_REF_SELECTED     volatile.Register32 // 0x38
	CLK_SYS_CTRL         volatile.Register32 // 0x3C
	CLK_SYS_DIV          volatile.Register32 // 0x40
	CLK_SYS_SELECTED     volatile.Register32 // 0x44
	CLK_PERI_CTRL        volatile.Register32 // 0x48
	_                    [4]byte
	CLK_PERI_SELECTED    volatile.Register32 // 0x50
	CLK_USB_CTRL         volatile.Register32 // 0x54
	CLK_USB_DIV          volatile.Register32 // 0x58
	CLK_USB_SELECTED     volatile.Register32 // 0x5C
	CLK_ADC_CTRL         volatile.Register32 // 0x60
	CLK_ADC_DIV          volatile.Register32 // 0x64
	CLK_ADC_SELECTED     volatile.Register32 // 0x68
	CLK_RTC_CTRL         volatile.Register32 // 0x6C
	CLK_RTC_DIV          volatile.Register32 // 0x70
	CLK_RTC_SELECTED     volatile.Register32 // 0x74
	CLK_SYS_RESUS_CTRL   volatile.Register32 // 0x78
	CLK_SYS_RESUS_STATUS volatile.Register32 // 0x7C
	FC0_REF_KHZ          volatile.Register32 // 0x80
	FC0_MIN_KHZ          volatile.Register32 // 0x84
	FC0_MAX_KHZ          volatile.Register32 // 0x88
	FC0_DELAY            volatile.Register32 // 0x8C
	FC0_INTERVAL         volatile.Register32 // 0x90
	FC0_SRC              volatile.Register32 // 0x94
	FC0_STATUS           volatile.Register32 // 0x98
	FC0_RESULT           volatile.Register32 // 0x9C
	WAKE_EN0             volatile.Register32 // 0xA0
	WAKE_EN1             volatile.Register32 // 0xA4
	SLEEP_EN0            volatile.Register32 // 0xA8
	SLEEP_EN1            volatile.Register32 // 0xAC
	ENABLED0             volatile.Register32 // 0xB0
	ENABLED1             volatile.Register32 // 0xB4
	INTR                 volatile.Register32 // 0xB8
	INTE                 volatile.Register32 // 0xBC
	INTF                 volatile.Register32 // 0xC0
	INTS                 volatile.Register32 // 0xC4
}

// CLOCKS.CLK_GPOUT0_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
func (o *CLOCKS_Type) SetCLK_GPOUT0_CTRL_NUDGE(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT0_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT0_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *CLOCKS_Type) GetCLK_GPOUT0_CTRL_NUDGE() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT0_CTRL.Reg) & 0x100000) >> 20
}
func (o *CLOCKS_Type) SetCLK_GPOUT0_CTRL_PHASE(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT0_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT0_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *CLOCKS_Type) GetCLK_GPOUT0_CTRL_PHASE() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT0_CTRL.Reg) & 0x30000) >> 16
}
func (o *CLOCKS_Type) SetCLK_GPOUT0_CTRL_DC50(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT0_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT0_CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *CLOCKS_Type) GetCLK_GPOUT0_CTRL_DC50() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT0_CTRL.Reg) & 0x1000) >> 12
}
func (o *CLOCKS_Type) SetCLK_GPOUT0_CTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT0_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT0_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *CLOCKS_Type) GetCLK_GPOUT0_CTRL_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT0_CTRL.Reg) & 0x800) >> 11
}
func (o *CLOCKS_Type) SetCLK_GPOUT0_CTRL_KILL(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT0_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT0_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *CLOCKS_Type) GetCLK_GPOUT0_CTRL_KILL() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT0_CTRL.Reg) & 0x400) >> 10
}
func (o *CLOCKS_Type) SetCLK_GPOUT0_CTRL_AUXSRC(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT0_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT0_CTRL.Reg)&^(0x1e0)|value<<5)
}
func (o *CLOCKS_Type) GetCLK_GPOUT0_CTRL_AUXSRC() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT0_CTRL.Reg) & 0x1e0) >> 5
}

// CLOCKS.CLK_GPOUT0_DIV: Clock divisor, can be changed on-the-fly
func (o *CLOCKS_Type) SetCLK_GPOUT0_DIV_INT(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT0_DIV.Reg, volatile.LoadUint32(&o.CLK_GPOUT0_DIV.Reg)&^(0xffffff00)|value<<8)
}
func (o *CLOCKS_Type) GetCLK_GPOUT0_DIV_INT() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT0_DIV.Reg) & 0xffffff00) >> 8
}
func (o *CLOCKS_Type) SetCLK_GPOUT0_DIV_FRAC(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT0_DIV.Reg, volatile.LoadUint32(&o.CLK_GPOUT0_DIV.Reg)&^(0xff)|value)
}
func (o *CLOCKS_Type) GetCLK_GPOUT0_DIV_FRAC() uint32 {
	return volatile.LoadUint32(&o.CLK_GPOUT0_DIV.Reg) & 0xff
}

// CLOCKS.CLK_GPOUT1_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
func (o *CLOCKS_Type) SetCLK_GPOUT1_CTRL_NUDGE(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT1_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT1_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *CLOCKS_Type) GetCLK_GPOUT1_CTRL_NUDGE() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT1_CTRL.Reg) & 0x100000) >> 20
}
func (o *CLOCKS_Type) SetCLK_GPOUT1_CTRL_PHASE(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT1_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT1_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *CLOCKS_Type) GetCLK_GPOUT1_CTRL_PHASE() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT1_CTRL.Reg) & 0x30000) >> 16
}
func (o *CLOCKS_Type) SetCLK_GPOUT1_CTRL_DC50(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT1_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT1_CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *CLOCKS_Type) GetCLK_GPOUT1_CTRL_DC50() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT1_CTRL.Reg) & 0x1000) >> 12
}
func (o *CLOCKS_Type) SetCLK_GPOUT1_CTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT1_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT1_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *CLOCKS_Type) GetCLK_GPOUT1_CTRL_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT1_CTRL.Reg) & 0x800) >> 11
}
func (o *CLOCKS_Type) SetCLK_GPOUT1_CTRL_KILL(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT1_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT1_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *CLOCKS_Type) GetCLK_GPOUT1_CTRL_KILL() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT1_CTRL.Reg) & 0x400) >> 10
}
func (o *CLOCKS_Type) SetCLK_GPOUT1_CTRL_AUXSRC(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT1_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT1_CTRL.Reg)&^(0x1e0)|value<<5)
}
func (o *CLOCKS_Type) GetCLK_GPOUT1_CTRL_AUXSRC() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT1_CTRL.Reg) & 0x1e0) >> 5
}

// CLOCKS.CLK_GPOUT1_DIV: Clock divisor, can be changed on-the-fly
func (o *CLOCKS_Type) SetCLK_GPOUT1_DIV_INT(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT1_DIV.Reg, volatile.LoadUint32(&o.CLK_GPOUT1_DIV.Reg)&^(0xffffff00)|value<<8)
}
func (o *CLOCKS_Type) GetCLK_GPOUT1_DIV_INT() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT1_DIV.Reg) & 0xffffff00) >> 8
}
func (o *CLOCKS_Type) SetCLK_GPOUT1_DIV_FRAC(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT1_DIV.Reg, volatile.LoadUint32(&o.CLK_GPOUT1_DIV.Reg)&^(0xff)|value)
}
func (o *CLOCKS_Type) GetCLK_GPOUT1_DIV_FRAC() uint32 {
	return volatile.LoadUint32(&o.CLK_GPOUT1_DIV.Reg) & 0xff
}

// CLOCKS.CLK_GPOUT2_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
func (o *CLOCKS_Type) SetCLK_GPOUT2_CTRL_NUDGE(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT2_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT2_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *CLOCKS_Type) GetCLK_GPOUT2_CTRL_NUDGE() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT2_CTRL.Reg) & 0x100000) >> 20
}
func (o *CLOCKS_Type) SetCLK_GPOUT2_CTRL_PHASE(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT2_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT2_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *CLOCKS_Type) GetCLK_GPOUT2_CTRL_PHASE() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT2_CTRL.Reg) & 0x30000) >> 16
}
func (o *CLOCKS_Type) SetCLK_GPOUT2_CTRL_DC50(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT2_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT2_CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *CLOCKS_Type) GetCLK_GPOUT2_CTRL_DC50() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT2_CTRL.Reg) & 0x1000) >> 12
}
func (o *CLOCKS_Type) SetCLK_GPOUT2_CTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT2_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT2_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *CLOCKS_Type) GetCLK_GPOUT2_CTRL_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT2_CTRL.Reg) & 0x800) >> 11
}
func (o *CLOCKS_Type) SetCLK_GPOUT2_CTRL_KILL(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT2_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT2_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *CLOCKS_Type) GetCLK_GPOUT2_CTRL_KILL() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT2_CTRL.Reg) & 0x400) >> 10
}
func (o *CLOCKS_Type) SetCLK_GPOUT2_CTRL_AUXSRC(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT2_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT2_CTRL.Reg)&^(0x1e0)|value<<5)
}
func (o *CLOCKS_Type) GetCLK_GPOUT2_CTRL_AUXSRC() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT2_CTRL.Reg) & 0x1e0) >> 5
}

// CLOCKS.CLK_GPOUT2_DIV: Clock divisor, can be changed on-the-fly
func (o *CLOCKS_Type) SetCLK_GPOUT2_DIV_INT(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT2_DIV.Reg, volatile.LoadUint32(&o.CLK_GPOUT2_DIV.Reg)&^(0xffffff00)|value<<8)
}
func (o *CLOCKS_Type) GetCLK_GPOUT2_DIV_INT() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT2_DIV.Reg) & 0xffffff00) >> 8
}
func (o *CLOCKS_Type) SetCLK_GPOUT2_DIV_FRAC(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT2_DIV.Reg, volatile.LoadUint32(&o.CLK_GPOUT2_DIV.Reg)&^(0xff)|value)
}
func (o *CLOCKS_Type) GetCLK_GPOUT2_DIV_FRAC() uint32 {
	return volatile.LoadUint32(&o.CLK_GPOUT2_DIV.Reg) & 0xff
}

// CLOCKS.CLK_GPOUT3_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
func (o *CLOCKS_Type) SetCLK_GPOUT3_CTRL_NUDGE(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT3_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT3_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *CLOCKS_Type) GetCLK_GPOUT3_CTRL_NUDGE() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT3_CTRL.Reg) & 0x100000) >> 20
}
func (o *CLOCKS_Type) SetCLK_GPOUT3_CTRL_PHASE(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT3_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT3_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *CLOCKS_Type) GetCLK_GPOUT3_CTRL_PHASE() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT3_CTRL.Reg) & 0x30000) >> 16
}
func (o *CLOCKS_Type) SetCLK_GPOUT3_CTRL_DC50(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT3_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT3_CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *CLOCKS_Type) GetCLK_GPOUT3_CTRL_DC50() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT3_CTRL.Reg) & 0x1000) >> 12
}
func (o *CLOCKS_Type) SetCLK_GPOUT3_CTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT3_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT3_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *CLOCKS_Type) GetCLK_GPOUT3_CTRL_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT3_CTRL.Reg) & 0x800) >> 11
}
func (o *CLOCKS_Type) SetCLK_GPOUT3_CTRL_KILL(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT3_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT3_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *CLOCKS_Type) GetCLK_GPOUT3_CTRL_KILL() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT3_CTRL.Reg) & 0x400) >> 10
}
func (o *CLOCKS_Type) SetCLK_GPOUT3_CTRL_AUXSRC(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT3_CTRL.Reg, volatile.LoadUint32(&o.CLK_GPOUT3_CTRL.Reg)&^(0x1e0)|value<<5)
}
func (o *CLOCKS_Type) GetCLK_GPOUT3_CTRL_AUXSRC() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT3_CTRL.Reg) & 0x1e0) >> 5
}

// CLOCKS.CLK_GPOUT3_DIV: Clock divisor, can be changed on-the-fly
func (o *CLOCKS_Type) SetCLK_GPOUT3_DIV_INT(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT3_DIV.Reg, volatile.LoadUint32(&o.CLK_GPOUT3_DIV.Reg)&^(0xffffff00)|value<<8)
}
func (o *CLOCKS_Type) GetCLK_GPOUT3_DIV_INT() uint32 {
	return (volatile.LoadUint32(&o.CLK_GPOUT3_DIV.Reg) & 0xffffff00) >> 8
}
func (o *CLOCKS_Type) SetCLK_GPOUT3_DIV_FRAC(value uint32) {
	volatile.StoreUint32(&o.CLK_GPOUT3_DIV.Reg, volatile.LoadUint32(&o.CLK_GPOUT3_DIV.Reg)&^(0xff)|value)
}
func (o *CLOCKS_Type) GetCLK_GPOUT3_DIV_FRAC() uint32 {
	return volatile.LoadUint32(&o.CLK_GPOUT3_DIV.Reg) & 0xff
}

// CLOCKS.CLK_REF_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
func (o *CLOCKS_Type) SetCLK_REF_CTRL_AUXSRC(value uint32) {
	volatile.StoreUint32(&o.CLK_REF_CTRL.Reg, volatile.LoadUint32(&o.CLK_REF_CTRL.Reg)&^(0x60)|value<<5)
}
func (o *CLOCKS_Type) GetCLK_REF_CTRL_AUXSRC() uint32 {
	return (volatile.LoadUint32(&o.CLK_REF_CTRL.Reg) & 0x60) >> 5
}
func (o *CLOCKS_Type) SetCLK_REF_CTRL_SRC(value uint32) {
	volatile.StoreUint32(&o.CLK_REF_CTRL.Reg, volatile.LoadUint32(&o.CLK_REF_CTRL.Reg)&^(0x3)|value)
}
func (o *CLOCKS_Type) GetCLK_REF_CTRL_SRC() uint32 {
	return volatile.LoadUint32(&o.CLK_REF_CTRL.Reg) & 0x3
}

// CLOCKS.CLK_REF_DIV: Clock divisor, can be changed on-the-fly
func (o *CLOCKS_Type) SetCLK_REF_DIV_INT(value uint32) {
	volatile.StoreUint32(&o.CLK_REF_DIV.Reg, volatile.LoadUint32(&o.CLK_REF_DIV.Reg)&^(0x300)|value<<8)
}
func (o *CLOCKS_Type) GetCLK_REF_DIV_INT() uint32 {
	return (volatile.LoadUint32(&o.CLK_REF_DIV.Reg) & 0x300) >> 8
}

// CLOCKS.CLK_SYS_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
func (o *CLOCKS_Type) SetCLK_SYS_CTRL_AUXSRC(value uint32) {
	volatile.StoreUint32(&o.CLK_SYS_CTRL.Reg, volatile.LoadUint32(&o.CLK_SYS_CTRL.Reg)&^(0xe0)|value<<5)
}
func (o *CLOCKS_Type) GetCLK_SYS_CTRL_AUXSRC() uint32 {
	return (volatile.LoadUint32(&o.CLK_SYS_CTRL.Reg) & 0xe0) >> 5
}
func (o *CLOCKS_Type) SetCLK_SYS_CTRL_SRC(value uint32) {
	volatile.StoreUint32(&o.CLK_SYS_CTRL.Reg, volatile.LoadUint32(&o.CLK_SYS_CTRL.Reg)&^(0x1)|value)
}
func (o *CLOCKS_Type) GetCLK_SYS_CTRL_SRC() uint32 {
	return volatile.LoadUint32(&o.CLK_SYS_CTRL.Reg) & 0x1
}

// CLOCKS.CLK_SYS_DIV: Clock divisor, can be changed on-the-fly
func (o *CLOCKS_Type) SetCLK_SYS_DIV_INT(value uint32) {
	volatile.StoreUint32(&o.CLK_SYS_DIV.Reg, volatile.LoadUint32(&o.CLK_SYS_DIV.Reg)&^(0xffffff00)|value<<8)
}
func (o *CLOCKS_Type) GetCLK_SYS_DIV_INT() uint32 {
	return (volatile.LoadUint32(&o.CLK_SYS_DIV.Reg) & 0xffffff00) >> 8
}
func (o *CLOCKS_Type) SetCLK_SYS_DIV_FRAC(value uint32) {
	volatile.StoreUint32(&o.CLK_SYS_DIV.Reg, volatile.LoadUint32(&o.CLK_SYS_DIV.Reg)&^(0xff)|value)
}
func (o *CLOCKS_Type) GetCLK_SYS_DIV_FRAC() uint32 {
	return volatile.LoadUint32(&o.CLK_SYS_DIV.Reg) & 0xff
}

// CLOCKS.CLK_PERI_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
func (o *CLOCKS_Type) SetCLK_PERI_CTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CLK_PERI_CTRL.Reg, volatile.LoadUint32(&o.CLK_PERI_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *CLOCKS_Type) GetCLK_PERI_CTRL_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CLK_PERI_CTRL.Reg) & 0x800) >> 11
}
func (o *CLOCKS_Type) SetCLK_PERI_CTRL_KILL(value uint32) {
	volatile.StoreUint32(&o.CLK_PERI_CTRL.Reg, volatile.LoadUint32(&o.CLK_PERI_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *CLOCKS_Type) GetCLK_PERI_CTRL_KILL() uint32 {
	return (volatile.LoadUint32(&o.CLK_PERI_CTRL.Reg) & 0x400) >> 10
}
func (o *CLOCKS_Type) SetCLK_PERI_CTRL_AUXSRC(value uint32) {
	volatile.StoreUint32(&o.CLK_PERI_CTRL.Reg, volatile.LoadUint32(&o.CLK_PERI_CTRL.Reg)&^(0xe0)|value<<5)
}
func (o *CLOCKS_Type) GetCLK_PERI_CTRL_AUXSRC() uint32 {
	return (volatile.LoadUint32(&o.CLK_PERI_CTRL.Reg) & 0xe0) >> 5
}

// CLOCKS.CLK_USB_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
func (o *CLOCKS_Type) SetCLK_USB_CTRL_NUDGE(value uint32) {
	volatile.StoreUint32(&o.CLK_USB_CTRL.Reg, volatile.LoadUint32(&o.CLK_USB_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *CLOCKS_Type) GetCLK_USB_CTRL_NUDGE() uint32 {
	return (volatile.LoadUint32(&o.CLK_USB_CTRL.Reg) & 0x100000) >> 20
}
func (o *CLOCKS_Type) SetCLK_USB_CTRL_PHASE(value uint32) {
	volatile.StoreUint32(&o.CLK_USB_CTRL.Reg, volatile.LoadUint32(&o.CLK_USB_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *CLOCKS_Type) GetCLK_USB_CTRL_PHASE() uint32 {
	return (volatile.LoadUint32(&o.CLK_USB_CTRL.Reg) & 0x30000) >> 16
}
func (o *CLOCKS_Type) SetCLK_USB_CTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CLK_USB_CTRL.Reg, volatile.LoadUint32(&o.CLK_USB_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *CLOCKS_Type) GetCLK_USB_CTRL_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CLK_USB_CTRL.Reg) & 0x800) >> 11
}
func (o *CLOCKS_Type) SetCLK_USB_CTRL_KILL(value uint32) {
	volatile.StoreUint32(&o.CLK_USB_CTRL.Reg, volatile.LoadUint32(&o.CLK_USB_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *CLOCKS_Type) GetCLK_USB_CTRL_KILL() uint32 {
	return (volatile.LoadUint32(&o.CLK_USB_CTRL.Reg) & 0x400) >> 10
}
func (o *CLOCKS_Type) SetCLK_USB_CTRL_AUXSRC(value uint32) {
	volatile.StoreUint32(&o.CLK_USB_CTRL.Reg, volatile.LoadUint32(&o.CLK_USB_CTRL.Reg)&^(0xe0)|value<<5)
}
func (o *CLOCKS_Type) GetCLK_USB_CTRL_AUXSRC() uint32 {
	return (volatile.LoadUint32(&o.CLK_USB_CTRL.Reg) & 0xe0) >> 5
}

// CLOCKS.CLK_USB_DIV: Clock divisor, can be changed on-the-fly
func (o *CLOCKS_Type) SetCLK_USB_DIV_INT(value uint32) {
	volatile.StoreUint32(&o.CLK_USB_DIV.Reg, volatile.LoadUint32(&o.CLK_USB_DIV.Reg)&^(0x300)|value<<8)
}
func (o *CLOCKS_Type) GetCLK_USB_DIV_INT() uint32 {
	return (volatile.LoadUint32(&o.CLK_USB_DIV.Reg) & 0x300) >> 8
}

// CLOCKS.CLK_ADC_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
func (o *CLOCKS_Type) SetCLK_ADC_CTRL_NUDGE(value uint32) {
	volatile.StoreUint32(&o.CLK_ADC_CTRL.Reg, volatile.LoadUint32(&o.CLK_ADC_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *CLOCKS_Type) GetCLK_ADC_CTRL_NUDGE() uint32 {
	return (volatile.LoadUint32(&o.CLK_ADC_CTRL.Reg) & 0x100000) >> 20
}
func (o *CLOCKS_Type) SetCLK_ADC_CTRL_PHASE(value uint32) {
	volatile.StoreUint32(&o.CLK_ADC_CTRL.Reg, volatile.LoadUint32(&o.CLK_ADC_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *CLOCKS_Type) GetCLK_ADC_CTRL_PHASE() uint32 {
	return (volatile.LoadUint32(&o.CLK_ADC_CTRL.Reg) & 0x30000) >> 16
}
func (o *CLOCKS_Type) SetCLK_ADC_CTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CLK_ADC_CTRL.Reg, volatile.LoadUint32(&o.CLK_ADC_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *CLOCKS_Type) GetCLK_ADC_CTRL_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CLK_ADC_CTRL.Reg) & 0x800) >> 11
}
func (o *CLOCKS_Type) SetCLK_ADC_CTRL_KILL(value uint32) {
	volatile.StoreUint32(&o.CLK_ADC_CTRL.Reg, volatile.LoadUint32(&o.CLK_ADC_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *CLOCKS_Type) GetCLK_ADC_CTRL_KILL() uint32 {
	return (volatile.LoadUint32(&o.CLK_ADC_CTRL.Reg) & 0x400) >> 10
}
func (o *CLOCKS_Type) SetCLK_ADC_CTRL_AUXSRC(value uint32) {
	volatile.StoreUint32(&o.CLK_ADC_CTRL.Reg, volatile.LoadUint32(&o.CLK_ADC_CTRL.Reg)&^(0xe0)|value<<5)
}
func (o *CLOCKS_Type) GetCLK_ADC_CTRL_AUXSRC() uint32 {
	return (volatile.LoadUint32(&o.CLK_ADC_CTRL.Reg) & 0xe0) >> 5
}

// CLOCKS.CLK_ADC_DIV: Clock divisor, can be changed on-the-fly
func (o *CLOCKS_Type) SetCLK_ADC_DIV_INT(value uint32) {
	volatile.StoreUint32(&o.CLK_ADC_DIV.Reg, volatile.LoadUint32(&o.CLK_ADC_DIV.Reg)&^(0x300)|value<<8)
}
func (o *CLOCKS_Type) GetCLK_ADC_DIV_INT() uint32 {
	return (volatile.LoadUint32(&o.CLK_ADC_DIV.Reg) & 0x300) >> 8
}

// CLOCKS.CLK_RTC_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
func (o *CLOCKS_Type) SetCLK_RTC_CTRL_NUDGE(value uint32) {
	volatile.StoreUint32(&o.CLK_RTC_CTRL.Reg, volatile.LoadUint32(&o.CLK_RTC_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *CLOCKS_Type) GetCLK_RTC_CTRL_NUDGE() uint32 {
	return (volatile.LoadUint32(&o.CLK_RTC_CTRL.Reg) & 0x100000) >> 20
}
func (o *CLOCKS_Type) SetCLK_RTC_CTRL_PHASE(value uint32) {
	volatile.StoreUint32(&o.CLK_RTC_CTRL.Reg, volatile.LoadUint32(&o.CLK_RTC_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *CLOCKS_Type) GetCLK_RTC_CTRL_PHASE() uint32 {
	return (volatile.LoadUint32(&o.CLK_RTC_CTRL.Reg) & 0x30000) >> 16
}
func (o *CLOCKS_Type) SetCLK_RTC_CTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CLK_RTC_CTRL.Reg, volatile.LoadUint32(&o.CLK_RTC_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *CLOCKS_Type) GetCLK_RTC_CTRL_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CLK_RTC_CTRL.Reg) & 0x800) >> 11
}
func (o *CLOCKS_Type) SetCLK_RTC_CTRL_KILL(value uint32) {
	volatile.StoreUint32(&o.CLK_RTC_CTRL.Reg, volatile.LoadUint32(&o.CLK_RTC_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *CLOCKS_Type) GetCLK_RTC_CTRL_KILL() uint32 {
	return (volatile.LoadUint32(&o.CLK_RTC_CTRL.Reg) & 0x400) >> 10
}
func (o *CLOCKS_Type) SetCLK_RTC_CTRL_AUXSRC(value uint32) {
	volatile.StoreUint32(&o.CLK_RTC_CTRL.Reg, volatile.LoadUint32(&o.CLK_RTC_CTRL.Reg)&^(0xe0)|value<<5)
}
func (o *CLOCKS_Type) GetCLK_RTC_CTRL_AUXSRC() uint32 {
	return (volatile.LoadUint32(&o.CLK_RTC_CTRL.Reg) & 0xe0) >> 5
}

// CLOCKS.CLK_RTC_DIV: Clock divisor, can be changed on-the-fly
func (o *CLOCKS_Type) SetCLK_RTC_DIV_INT(value uint32) {
	volatile.StoreUint32(&o.CLK_RTC_DIV.Reg, volatile.LoadUint32(&o.CLK_RTC_DIV.Reg)&^(0xffffff00)|value<<8)
}
func (o *CLOCKS_Type) GetCLK_RTC_DIV_INT() uint32 {
	return (volatile.LoadUint32(&o.CLK_RTC_DIV.Reg) & 0xffffff00) >> 8
}
func (o *CLOCKS_Type) SetCLK_RTC_DIV_FRAC(value uint32) {
	volatile.StoreUint32(&o.CLK_RTC_DIV.Reg, volatile.LoadUint32(&o.CLK_RTC_DIV.Reg)&^(0xff)|value)
}
func (o *CLOCKS_Type) GetCLK_RTC_DIV_FRAC() uint32 {
	return volatile.LoadUint32(&o.CLK_RTC_DIV.Reg) & 0xff
}

// CLOCKS.CLK_SYS_RESUS_CTRL
func (o *CLOCKS_Type) SetCLK_SYS_RESUS_CTRL_CLEAR(value uint32) {
	volatile.StoreUint32(&o.CLK_SYS_RESUS_CTRL.Reg, volatile.LoadUint32(&o.CLK_SYS_RESUS_CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *CLOCKS_Type) GetCLK_SYS_RESUS_CTRL_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.CLK_SYS_RESUS_CTRL.Reg) & 0x10000) >> 16
}
func (o *CLOCKS_Type) SetCLK_SYS_RESUS_CTRL_FRCE(value uint32) {
	volatile.StoreUint32(&o.CLK_SYS_RESUS_CTRL.Reg, volatile.LoadUint32(&o.CLK_SYS_RESUS_CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *CLOCKS_Type) GetCLK_SYS_RESUS_CTRL_FRCE() uint32 {
	return (volatile.LoadUint32(&o.CLK_SYS_RESUS_CTRL.Reg) & 0x1000) >> 12
}
func (o *CLOCKS_Type) SetCLK_SYS_RESUS_CTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CLK_SYS_RESUS_CTRL.Reg, volatile.LoadUint32(&o.CLK_SYS_RESUS_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *CLOCKS_Type) GetCLK_SYS_RESUS_CTRL_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CLK_SYS_RESUS_CTRL.Reg) & 0x100) >> 8
}
func (o *CLOCKS_Type) SetCLK_SYS_RESUS_CTRL_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.CLK_SYS_RESUS_CTRL.Reg, volatile.LoadUint32(&o.CLK_SYS_RESUS_CTRL.Reg)&^(0xff)|value)
}
func (o *CLOCKS_Type) GetCLK_SYS_RESUS_CTRL_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.CLK_SYS_RESUS_CTRL.Reg) & 0xff
}

// CLOCKS.CLK_SYS_RESUS_STATUS
func (o *CLOCKS_Type) SetCLK_SYS_RESUS_STATUS_RESUSSED(value uint32) {
	volatile.StoreUint32(&o.CLK_SYS_RESUS_STATUS.Reg, volatile.LoadUint32(&o.CLK_SYS_RESUS_STATUS.Reg)&^(0x1)|value)
}
func (o *CLOCKS_Type) GetCLK_SYS_RESUS_STATUS_RESUSSED() uint32 {
	return volatile.LoadUint32(&o.CLK_SYS_RESUS_STATUS.Reg) & 0x1
}

// CLOCKS.FC0_REF_KHZ: Reference clock frequency in kHz
func (o *CLOCKS_Type) SetFC0_REF_KHZ(value uint32) {
	volatile.StoreUint32(&o.FC0_REF_KHZ.Reg, volatile.LoadUint32(&o.FC0_REF_KHZ.Reg)&^(0xfffff)|value)
}
func (o *CLOCKS_Type) GetFC0_REF_KHZ() uint32 {
	return volatile.LoadUint32(&o.FC0_REF_KHZ.Reg) & 0xfffff
}

// CLOCKS.FC0_MIN_KHZ: Minimum pass frequency in kHz. This is optional. Set to 0 if you are not using the pass/fail flags
func (o *CLOCKS_Type) SetFC0_MIN_KHZ(value uint32) {
	volatile.StoreUint32(&o.FC0_MIN_KHZ.Reg, volatile.LoadUint32(&o.FC0_MIN_KHZ.Reg)&^(0x1ffffff)|value)
}
func (o *CLOCKS_Type) GetFC0_MIN_KHZ() uint32 {
	return volatile.LoadUint32(&o.FC0_MIN_KHZ.Reg) & 0x1ffffff
}

// CLOCKS.FC0_MAX_KHZ: Maximum pass frequency in kHz. This is optional. Set to 0x1ffffff if you are not using the pass/fail flags
func (o *CLOCKS_Type) SetFC0_MAX_KHZ(value uint32) {
	volatile.StoreUint32(&o.FC0_MAX_KHZ.Reg, volatile.LoadUint32(&o.FC0_MAX_KHZ.Reg)&^(0x1ffffff)|value)
}
func (o *CLOCKS_Type) GetFC0_MAX_KHZ() uint32 {
	return volatile.LoadUint32(&o.FC0_MAX_KHZ.Reg) & 0x1ffffff
}

// CLOCKS.FC0_DELAY
// Delays the start of frequency counting to allow the mux to settle
// Delay is measured in multiples of the reference clock period
func (o *CLOCKS_Type) SetFC0_DELAY(value uint32) {
	volatile.StoreUint32(&o.FC0_DELAY.Reg, volatile.LoadUint32(&o.FC0_DELAY.Reg)&^(0x7)|value)
}
func (o *CLOCKS_Type) GetFC0_DELAY() uint32 {
	return volatile.LoadUint32(&o.FC0_DELAY.Reg) & 0x7
}

// CLOCKS.FC0_INTERVAL
// The test interval is 0.98us * 2**interval, but let's call it 1us * 2**interval
// The default gives a test interval of 250us
func (o *CLOCKS_Type) SetFC0_INTERVAL(value uint32) {
	volatile.StoreUint32(&o.FC0_INTERVAL.Reg, volatile.LoadUint32(&o.FC0_INTERVAL.Reg)&^(0xf)|value)
}
func (o *CLOCKS_Type) GetFC0_INTERVAL() uint32 {
	return volatile.LoadUint32(&o.FC0_INTERVAL.Reg) & 0xf
}

// CLOCKS.FC0_SRC
// Clock sent to frequency counter, set to 0 when not required
// Writing to this register initiates the frequency count
func (o *CLOCKS_Type) SetFC0_SRC(value uint32) {
	volatile.StoreUint32(&o.FC0_SRC.Reg, volatile.LoadUint32(&o.FC0_SRC.Reg)&^(0xff)|value)
}
func (o *CLOCKS_Type) GetFC0_SRC() uint32 {
	return volatile.LoadUint32(&o.FC0_SRC.Reg) & 0xff
}

// CLOCKS.FC0_STATUS: Frequency counter status
func (o *CLOCKS_Type) SetFC0_STATUS_DIED(value uint32) {
	volatile.StoreUint32(&o.FC0_STATUS.Reg, volatile.LoadUint32(&o.FC0_STATUS.Reg)&^(0x10000000)|value<<28)
}
func (o *CLOCKS_Type) GetFC0_STATUS_DIED() uint32 {
	return (volatile.LoadUint32(&o.FC0_STATUS.Reg) & 0x10000000) >> 28
}
func (o *CLOCKS_Type) SetFC0_STATUS_FAST(value uint32) {
	volatile.StoreUint32(&o.FC0_STATUS.Reg, volatile.LoadUint32(&o.FC0_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *CLOCKS_Type) GetFC0_STATUS_FAST() uint32 {
	return (volatile.LoadUint32(&o.FC0_STATUS.Reg) & 0x1000000) >> 24
}
func (o *CLOCKS_Type) SetFC0_STATUS_SLOW(value uint32) {
	volatile.StoreUint32(&o.FC0_STATUS.Reg, volatile.LoadUint32(&o.FC0_STATUS.Reg)&^(0x100000)|value<<20)
}
func (o *CLOCKS_Type) GetFC0_STATUS_SLOW() uint32 {
	return (volatile.LoadUint32(&o.FC0_STATUS.Reg) & 0x100000) >> 20
}
func (o *CLOCKS_Type) SetFC0_STATUS_FAIL(value uint32) {
	volatile.StoreUint32(&o.FC0_STATUS.Reg, volatile.LoadUint32(&o.FC0_STATUS.Reg)&^(0x10000)|value<<16)
}
func (o *CLOCKS_Type) GetFC0_STATUS_FAIL() uint32 {
	return (volatile.LoadUint32(&o.FC0_STATUS.Reg) & 0x10000) >> 16
}
func (o *CLOCKS_Type) SetFC0_STATUS_WAITING(value uint32) {
	volatile.StoreUint32(&o.FC0_STATUS.Reg, volatile.LoadUint32(&o.FC0_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *CLOCKS_Type) GetFC0_STATUS_WAITING() uint32 {
	return (volatile.LoadUint32(&o.FC0_STATUS.Reg) & 0x1000) >> 12
}
func (o *CLOCKS_Type) SetFC0_STATUS_RUNNING(value uint32) {
	volatile.StoreUint32(&o.FC0_STATUS.Reg, volatile.LoadUint32(&o.FC0_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *CLOCKS_Type) GetFC0_STATUS_RUNNING() uint32 {
	return (volatile.LoadUint32(&o.FC0_STATUS.Reg) & 0x100) >> 8
}
func (o *CLOCKS_Type) SetFC0_STATUS_DONE(value uint32) {
	volatile.StoreUint32(&o.FC0_STATUS.Reg, volatile.LoadUint32(&o.FC0_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *CLOCKS_Type) GetFC0_STATUS_DONE() uint32 {
	return (volatile.LoadUint32(&o.FC0_STATUS.Reg) & 0x10) >> 4
}
func (o *CLOCKS_Type) SetFC0_STATUS_PASS(value uint32) {
	volatile.StoreUint32(&o.FC0_STATUS.Reg, volatile.LoadUint32(&o.FC0_STATUS.Reg)&^(0x1)|value)
}
func (o *CLOCKS_Type) GetFC0_STATUS_PASS() uint32 {
	return volatile.LoadUint32(&o.FC0_STATUS.Reg) & 0x1
}

// CLOCKS.FC0_RESULT: Result of frequency measurement, only valid when status_done=1
func (o *CLOCKS_Type) SetFC0_RESULT_KHZ(value uint32) {
	volatile.StoreUint32(&o.FC0_RESULT.Reg, volatile.LoadUint32(&o.FC0_RESULT.Reg)&^(0x3fffffe0)|value<<5)
}
func (o *CLOCKS_Type) GetFC0_RESULT_KHZ() uint32 {
	return (volatile.LoadUint32(&o.FC0_RESULT.Reg) & 0x3fffffe0) >> 5
}
func (o *CLOCKS_Type) SetFC0_RESULT_FRAC(value uint32) {
	volatile.StoreUint32(&o.FC0_RESULT.Reg, volatile.LoadUint32(&o.FC0_RESULT.Reg)&^(0x1f)|value)
}
func (o *CLOCKS_Type) GetFC0_RESULT_FRAC() uint32 {
	return volatile.LoadUint32(&o.FC0_RESULT.Reg) & 0x1f
}

// CLOCKS.WAKE_EN0: enable clock in wake mode
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_SRAM3(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x80000000)|value<<31)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_SRAM3() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x80000000) >> 31
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_SRAM2(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x40000000)|value<<30)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_SRAM2() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x40000000) >> 30
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_SRAM1(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x20000000)|value<<29)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_SRAM1() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x20000000) >> 29
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_SRAM0(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x10000000)|value<<28)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_SRAM0() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x10000000) >> 28
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_SPI1(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x8000000)|value<<27)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_SPI1() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x8000000) >> 27
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_PERI_SPI1(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x4000000)|value<<26)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_PERI_SPI1() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x4000000) >> 26
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_SPI0(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x2000000)|value<<25)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_SPI0() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x2000000) >> 25
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_PERI_SPI0(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x1000000)|value<<24)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_PERI_SPI0() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x1000000) >> 24
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_SIO(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x800000)|value<<23)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_SIO() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x800000) >> 23
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_RTC(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x400000)|value<<22)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_RTC() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x400000) >> 22
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_RTC_RTC(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x200000)|value<<21)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_RTC_RTC() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x200000) >> 21
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_ROSC(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x100000)|value<<20)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_ROSC() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x100000) >> 20
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_ROM(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x80000)|value<<19)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_ROM() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x80000) >> 19
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_RESETS(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x40000)|value<<18)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_RESETS() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x40000) >> 18
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_PWM(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x20000)|value<<17)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_PWM() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x20000) >> 17
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_PSM(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x10000)|value<<16)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_PSM() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x10000) >> 16
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_PLL_USB(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x8000)|value<<15)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_PLL_USB() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x8000) >> 15
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_PLL_SYS(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x4000)|value<<14)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_PLL_SYS() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x4000) >> 14
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_PIO1(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x2000)|value<<13)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_PIO1() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x2000) >> 13
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_PIO0(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x1000)|value<<12)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_PIO0() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x1000) >> 12
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_PADS(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x800)|value<<11)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_PADS() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x800) >> 11
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_VREG_AND_CHIP_RESET(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x400)|value<<10)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_VREG_AND_CHIP_RESET() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x400) >> 10
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_JTAG(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x200)|value<<9)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_JTAG() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x200) >> 9
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_IO(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x100)|value<<8)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_IO() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x100) >> 8
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_I2C1(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x80)|value<<7)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_I2C1() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x80) >> 7
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_I2C0(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x40)|value<<6)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_I2C0() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x40) >> 6
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_DMA(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x20)|value<<5)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_DMA() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x20) >> 5
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_BUSFABRIC(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x10)|value<<4)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_BUSFABRIC() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x10) >> 4
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_BUSCTRL(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x8)|value<<3)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_BUSCTRL() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x8) >> 3
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_ADC(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x4)|value<<2)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_ADC() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x4) >> 2
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_ADC_ADC(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x2)|value<<1)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_ADC_ADC() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x2) >> 1
}
func (o *CLOCKS_Type) SetWAKE_EN0_CLK_SYS_CLOCKS(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN0.Reg, volatile.LoadUint32(&o.WAKE_EN0.Reg)&^(0x1)|value)
}
func (o *CLOCKS_Type) GetWAKE_EN0_CLK_SYS_CLOCKS() uint32 {
	return volatile.LoadUint32(&o.WAKE_EN0.Reg) & 0x1
}

// CLOCKS.WAKE_EN1: enable clock in wake mode
func (o *CLOCKS_Type) SetWAKE_EN1_CLK_SYS_XOSC(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN1.Reg, volatile.LoadUint32(&o.WAKE_EN1.Reg)&^(0x4000)|value<<14)
}
func (o *CLOCKS_Type) GetWAKE_EN1_CLK_SYS_XOSC() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN1.Reg) & 0x4000) >> 14
}
func (o *CLOCKS_Type) SetWAKE_EN1_CLK_SYS_XIP(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN1.Reg, volatile.LoadUint32(&o.WAKE_EN1.Reg)&^(0x2000)|value<<13)
}
func (o *CLOCKS_Type) GetWAKE_EN1_CLK_SYS_XIP() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN1.Reg) & 0x2000) >> 13
}
func (o *CLOCKS_Type) SetWAKE_EN1_CLK_SYS_WATCHDOG(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN1.Reg, volatile.LoadUint32(&o.WAKE_EN1.Reg)&^(0x1000)|value<<12)
}
func (o *CLOCKS_Type) GetWAKE_EN1_CLK_SYS_WATCHDOG() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN1.Reg) & 0x1000) >> 12
}
func (o *CLOCKS_Type) SetWAKE_EN1_CLK_USB_USBCTRL(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN1.Reg, volatile.LoadUint32(&o.WAKE_EN1.Reg)&^(0x800)|value<<11)
}
func (o *CLOCKS_Type) GetWAKE_EN1_CLK_USB_USBCTRL() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN1.Reg) & 0x800) >> 11
}
func (o *CLOCKS_Type) SetWAKE_EN1_CLK_SYS_USBCTRL(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN1.Reg, volatile.LoadUint32(&o.WAKE_EN1.Reg)&^(0x400)|value<<10)
}
func (o *CLOCKS_Type) GetWAKE_EN1_CLK_SYS_USBCTRL() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN1.Reg) & 0x400) >> 10
}
func (o *CLOCKS_Type) SetWAKE_EN1_CLK_SYS_UART1(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN1.Reg, volatile.LoadUint32(&o.WAKE_EN1.Reg)&^(0x200)|value<<9)
}
func (o *CLOCKS_Type) GetWAKE_EN1_CLK_SYS_UART1() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN1.Reg) & 0x200) >> 9
}
func (o *CLOCKS_Type) SetWAKE_EN1_CLK_PERI_UART1(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN1.Reg, volatile.LoadUint32(&o.WAKE_EN1.Reg)&^(0x100)|value<<8)
}
func (o *CLOCKS_Type) GetWAKE_EN1_CLK_PERI_UART1() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN1.Reg) & 0x100) >> 8
}
func (o *CLOCKS_Type) SetWAKE_EN1_CLK_SYS_UART0(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN1.Reg, volatile.LoadUint32(&o.WAKE_EN1.Reg)&^(0x80)|value<<7)
}
func (o *CLOCKS_Type) GetWAKE_EN1_CLK_SYS_UART0() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN1.Reg) & 0x80) >> 7
}
func (o *CLOCKS_Type) SetWAKE_EN1_CLK_PERI_UART0(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN1.Reg, volatile.LoadUint32(&o.WAKE_EN1.Reg)&^(0x40)|value<<6)
}
func (o *CLOCKS_Type) GetWAKE_EN1_CLK_PERI_UART0() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN1.Reg) & 0x40) >> 6
}
func (o *CLOCKS_Type) SetWAKE_EN1_CLK_SYS_TIMER(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN1.Reg, volatile.LoadUint32(&o.WAKE_EN1.Reg)&^(0x20)|value<<5)
}
func (o *CLOCKS_Type) GetWAKE_EN1_CLK_SYS_TIMER() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN1.Reg) & 0x20) >> 5
}
func (o *CLOCKS_Type) SetWAKE_EN1_CLK_SYS_TBMAN(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN1.Reg, volatile.LoadUint32(&o.WAKE_EN1.Reg)&^(0x10)|value<<4)
}
func (o *CLOCKS_Type) GetWAKE_EN1_CLK_SYS_TBMAN() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN1.Reg) & 0x10) >> 4
}
func (o *CLOCKS_Type) SetWAKE_EN1_CLK_SYS_SYSINFO(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN1.Reg, volatile.LoadUint32(&o.WAKE_EN1.Reg)&^(0x8)|value<<3)
}
func (o *CLOCKS_Type) GetWAKE_EN1_CLK_SYS_SYSINFO() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN1.Reg) & 0x8) >> 3
}
func (o *CLOCKS_Type) SetWAKE_EN1_CLK_SYS_SYSCFG(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN1.Reg, volatile.LoadUint32(&o.WAKE_EN1.Reg)&^(0x4)|value<<2)
}
func (o *CLOCKS_Type) GetWAKE_EN1_CLK_SYS_SYSCFG() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN1.Reg) & 0x4) >> 2
}
func (o *CLOCKS_Type) SetWAKE_EN1_CLK_SYS_SRAM5(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN1.Reg, volatile.LoadUint32(&o.WAKE_EN1.Reg)&^(0x2)|value<<1)
}
func (o *CLOCKS_Type) GetWAKE_EN1_CLK_SYS_SRAM5() uint32 {
	return (volatile.LoadUint32(&o.WAKE_EN1.Reg) & 0x2) >> 1
}
func (o *CLOCKS_Type) SetWAKE_EN1_CLK_SYS_SRAM4(value uint32) {
	volatile.StoreUint32(&o.WAKE_EN1.Reg, volatile.LoadUint32(&o.WAKE_EN1.Reg)&^(0x1)|value)
}
func (o *CLOCKS_Type) GetWAKE_EN1_CLK_SYS_SRAM4() uint32 {
	return volatile.LoadUint32(&o.WAKE_EN1.Reg) & 0x1
}

// CLOCKS.SLEEP_EN0: enable clock in sleep mode
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_SRAM3(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x80000000)|value<<31)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_SRAM3() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x80000000) >> 31
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_SRAM2(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x40000000)|value<<30)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_SRAM2() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x40000000) >> 30
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_SRAM1(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x20000000)|value<<29)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_SRAM1() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x20000000) >> 29
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_SRAM0(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x10000000)|value<<28)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_SRAM0() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x10000000) >> 28
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_SPI1(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x8000000)|value<<27)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_SPI1() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x8000000) >> 27
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_PERI_SPI1(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x4000000)|value<<26)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_PERI_SPI1() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x4000000) >> 26
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_SPI0(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x2000000)|value<<25)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_SPI0() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x2000000) >> 25
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_PERI_SPI0(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x1000000)|value<<24)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_PERI_SPI0() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x1000000) >> 24
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_SIO(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x800000)|value<<23)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_SIO() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x800000) >> 23
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_RTC(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x400000)|value<<22)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_RTC() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x400000) >> 22
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_RTC_RTC(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x200000)|value<<21)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_RTC_RTC() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x200000) >> 21
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_ROSC(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x100000)|value<<20)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_ROSC() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x100000) >> 20
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_ROM(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x80000)|value<<19)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_ROM() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x80000) >> 19
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_RESETS(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x40000)|value<<18)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_RESETS() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x40000) >> 18
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_PWM(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x20000)|value<<17)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_PWM() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x20000) >> 17
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_PSM(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x10000)|value<<16)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_PSM() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x10000) >> 16
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_PLL_USB(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x8000)|value<<15)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_PLL_USB() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x8000) >> 15
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_PLL_SYS(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x4000)|value<<14)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_PLL_SYS() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x4000) >> 14
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_PIO1(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x2000)|value<<13)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_PIO1() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x2000) >> 13
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_PIO0(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x1000)|value<<12)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_PIO0() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x1000) >> 12
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_PADS(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x800)|value<<11)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_PADS() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x800) >> 11
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_VREG_AND_CHIP_RESET(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x400)|value<<10)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_VREG_AND_CHIP_RESET() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x400) >> 10
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_JTAG(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x200)|value<<9)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_JTAG() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x200) >> 9
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_IO(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x100)|value<<8)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_IO() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x100) >> 8
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_I2C1(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x80)|value<<7)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_I2C1() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x80) >> 7
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_I2C0(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x40)|value<<6)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_I2C0() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x40) >> 6
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_DMA(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x20)|value<<5)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_DMA() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x20) >> 5
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_BUSFABRIC(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x10)|value<<4)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_BUSFABRIC() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x10) >> 4
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_BUSCTRL(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x8)|value<<3)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_BUSCTRL() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x8) >> 3
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_ADC(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x4)|value<<2)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_ADC() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x4) >> 2
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_ADC_ADC(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x2)|value<<1)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_ADC_ADC() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x2) >> 1
}
func (o *CLOCKS_Type) SetSLEEP_EN0_CLK_SYS_CLOCKS(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN0.Reg, volatile.LoadUint32(&o.SLEEP_EN0.Reg)&^(0x1)|value)
}
func (o *CLOCKS_Type) GetSLEEP_EN0_CLK_SYS_CLOCKS() uint32 {
	return volatile.LoadUint32(&o.SLEEP_EN0.Reg) & 0x1
}

// CLOCKS.SLEEP_EN1: enable clock in sleep mode
func (o *CLOCKS_Type) SetSLEEP_EN1_CLK_SYS_XOSC(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN1.Reg, volatile.LoadUint32(&o.SLEEP_EN1.Reg)&^(0x4000)|value<<14)
}
func (o *CLOCKS_Type) GetSLEEP_EN1_CLK_SYS_XOSC() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN1.Reg) & 0x4000) >> 14
}
func (o *CLOCKS_Type) SetSLEEP_EN1_CLK_SYS_XIP(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN1.Reg, volatile.LoadUint32(&o.SLEEP_EN1.Reg)&^(0x2000)|value<<13)
}
func (o *CLOCKS_Type) GetSLEEP_EN1_CLK_SYS_XIP() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN1.Reg) & 0x2000) >> 13
}
func (o *CLOCKS_Type) SetSLEEP_EN1_CLK_SYS_WATCHDOG(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN1.Reg, volatile.LoadUint32(&o.SLEEP_EN1.Reg)&^(0x1000)|value<<12)
}
func (o *CLOCKS_Type) GetSLEEP_EN1_CLK_SYS_WATCHDOG() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN1.Reg) & 0x1000) >> 12
}
func (o *CLOCKS_Type) SetSLEEP_EN1_CLK_USB_USBCTRL(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN1.Reg, volatile.LoadUint32(&o.SLEEP_EN1.Reg)&^(0x800)|value<<11)
}
func (o *CLOCKS_Type) GetSLEEP_EN1_CLK_USB_USBCTRL() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN1.Reg) & 0x800) >> 11
}
func (o *CLOCKS_Type) SetSLEEP_EN1_CLK_SYS_USBCTRL(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN1.Reg, volatile.LoadUint32(&o.SLEEP_EN1.Reg)&^(0x400)|value<<10)
}
func (o *CLOCKS_Type) GetSLEEP_EN1_CLK_SYS_USBCTRL() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN1.Reg) & 0x400) >> 10
}
func (o *CLOCKS_Type) SetSLEEP_EN1_CLK_SYS_UART1(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN1.Reg, volatile.LoadUint32(&o.SLEEP_EN1.Reg)&^(0x200)|value<<9)
}
func (o *CLOCKS_Type) GetSLEEP_EN1_CLK_SYS_UART1() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN1.Reg) & 0x200) >> 9
}
func (o *CLOCKS_Type) SetSLEEP_EN1_CLK_PERI_UART1(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN1.Reg, volatile.LoadUint32(&o.SLEEP_EN1.Reg)&^(0x100)|value<<8)
}
func (o *CLOCKS_Type) GetSLEEP_EN1_CLK_PERI_UART1() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN1.Reg) & 0x100) >> 8
}
func (o *CLOCKS_Type) SetSLEEP_EN1_CLK_SYS_UART0(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN1.Reg, volatile.LoadUint32(&o.SLEEP_EN1.Reg)&^(0x80)|value<<7)
}
func (o *CLOCKS_Type) GetSLEEP_EN1_CLK_SYS_UART0() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN1.Reg) & 0x80) >> 7
}
func (o *CLOCKS_Type) SetSLEEP_EN1_CLK_PERI_UART0(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN1.Reg, volatile.LoadUint32(&o.SLEEP_EN1.Reg)&^(0x40)|value<<6)
}
func (o *CLOCKS_Type) GetSLEEP_EN1_CLK_PERI_UART0() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN1.Reg) & 0x40) >> 6
}
func (o *CLOCKS_Type) SetSLEEP_EN1_CLK_SYS_TIMER(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN1.Reg, volatile.LoadUint32(&o.SLEEP_EN1.Reg)&^(0x20)|value<<5)
}
func (o *CLOCKS_Type) GetSLEEP_EN1_CLK_SYS_TIMER() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN1.Reg) & 0x20) >> 5
}
func (o *CLOCKS_Type) SetSLEEP_EN1_CLK_SYS_TBMAN(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN1.Reg, volatile.LoadUint32(&o.SLEEP_EN1.Reg)&^(0x10)|value<<4)
}
func (o *CLOCKS_Type) GetSLEEP_EN1_CLK_SYS_TBMAN() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN1.Reg) & 0x10) >> 4
}
func (o *CLOCKS_Type) SetSLEEP_EN1_CLK_SYS_SYSINFO(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN1.Reg, volatile.LoadUint32(&o.SLEEP_EN1.Reg)&^(0x8)|value<<3)
}
func (o *CLOCKS_Type) GetSLEEP_EN1_CLK_SYS_SYSINFO() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN1.Reg) & 0x8) >> 3
}
func (o *CLOCKS_Type) SetSLEEP_EN1_CLK_SYS_SYSCFG(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN1.Reg, volatile.LoadUint32(&o.SLEEP_EN1.Reg)&^(0x4)|value<<2)
}
func (o *CLOCKS_Type) GetSLEEP_EN1_CLK_SYS_SYSCFG() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN1.Reg) & 0x4) >> 2
}
func (o *CLOCKS_Type) SetSLEEP_EN1_CLK_SYS_SRAM5(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN1.Reg, volatile.LoadUint32(&o.SLEEP_EN1.Reg)&^(0x2)|value<<1)
}
func (o *CLOCKS_Type) GetSLEEP_EN1_CLK_SYS_SRAM5() uint32 {
	return (volatile.LoadUint32(&o.SLEEP_EN1.Reg) & 0x2) >> 1
}
func (o *CLOCKS_Type) SetSLEEP_EN1_CLK_SYS_SRAM4(value uint32) {
	volatile.StoreUint32(&o.SLEEP_EN1.Reg, volatile.LoadUint32(&o.SLEEP_EN1.Reg)&^(0x1)|value)
}
func (o *CLOCKS_Type) GetSLEEP_EN1_CLK_SYS_SRAM4() uint32 {
	return volatile.LoadUint32(&o.SLEEP_EN1.Reg) & 0x1
}

// CLOCKS.ENABLED0: indicates the state of the clock enable
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_SRAM3(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x80000000)|value<<31)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_SRAM3() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x80000000) >> 31
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_SRAM2(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x40000000)|value<<30)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_SRAM2() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x40000000) >> 30
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_SRAM1(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x20000000)|value<<29)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_SRAM1() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x20000000) >> 29
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_SRAM0(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x10000000)|value<<28)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_SRAM0() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x10000000) >> 28
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_SPI1(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x8000000)|value<<27)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_SPI1() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x8000000) >> 27
}
func (o *CLOCKS_Type) SetENABLED0_CLK_PERI_SPI1(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x4000000)|value<<26)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_PERI_SPI1() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x4000000) >> 26
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_SPI0(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x2000000)|value<<25)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_SPI0() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x2000000) >> 25
}
func (o *CLOCKS_Type) SetENABLED0_CLK_PERI_SPI0(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x1000000)|value<<24)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_PERI_SPI0() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x1000000) >> 24
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_SIO(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x800000)|value<<23)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_SIO() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x800000) >> 23
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_RTC(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x400000)|value<<22)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_RTC() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x400000) >> 22
}
func (o *CLOCKS_Type) SetENABLED0_CLK_RTC_RTC(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x200000)|value<<21)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_RTC_RTC() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x200000) >> 21
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_ROSC(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x100000)|value<<20)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_ROSC() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x100000) >> 20
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_ROM(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x80000)|value<<19)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_ROM() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x80000) >> 19
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_RESETS(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x40000)|value<<18)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_RESETS() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x40000) >> 18
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_PWM(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x20000)|value<<17)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_PWM() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x20000) >> 17
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_PSM(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x10000)|value<<16)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_PSM() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x10000) >> 16
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_PLL_USB(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x8000)|value<<15)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_PLL_USB() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x8000) >> 15
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_PLL_SYS(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x4000)|value<<14)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_PLL_SYS() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x4000) >> 14
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_PIO1(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x2000)|value<<13)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_PIO1() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x2000) >> 13
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_PIO0(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x1000)|value<<12)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_PIO0() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x1000) >> 12
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_PADS(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x800)|value<<11)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_PADS() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x800) >> 11
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_VREG_AND_CHIP_RESET(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x400)|value<<10)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_VREG_AND_CHIP_RESET() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x400) >> 10
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_JTAG(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x200)|value<<9)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_JTAG() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x200) >> 9
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_IO(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x100)|value<<8)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_IO() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x100) >> 8
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_I2C1(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x80)|value<<7)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_I2C1() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x80) >> 7
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_I2C0(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x40)|value<<6)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_I2C0() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x40) >> 6
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_DMA(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x20)|value<<5)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_DMA() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x20) >> 5
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_BUSFABRIC(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x10)|value<<4)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_BUSFABRIC() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x10) >> 4
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_BUSCTRL(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x8)|value<<3)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_BUSCTRL() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x8) >> 3
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_ADC(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x4)|value<<2)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_ADC() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x4) >> 2
}
func (o *CLOCKS_Type) SetENABLED0_CLK_ADC_ADC(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x2)|value<<1)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_ADC_ADC() uint32 {
	return (volatile.LoadUint32(&o.ENABLED0.Reg) & 0x2) >> 1
}
func (o *CLOCKS_Type) SetENABLED0_CLK_SYS_CLOCKS(value uint32) {
	volatile.StoreUint32(&o.ENABLED0.Reg, volatile.LoadUint32(&o.ENABLED0.Reg)&^(0x1)|value)
}
func (o *CLOCKS_Type) GetENABLED0_CLK_SYS_CLOCKS() uint32 {
	return volatile.LoadUint32(&o.ENABLED0.Reg) & 0x1
}

// CLOCKS.ENABLED1: indicates the state of the clock enable
func (o *CLOCKS_Type) SetENABLED1_CLK_SYS_XOSC(value uint32) {
	volatile.StoreUint32(&o.ENABLED1.Reg, volatile.LoadUint32(&o.ENABLED1.Reg)&^(0x4000)|value<<14)
}
func (o *CLOCKS_Type) GetENABLED1_CLK_SYS_XOSC() uint32 {
	return (volatile.LoadUint32(&o.ENABLED1.Reg) & 0x4000) >> 14
}
func (o *CLOCKS_Type) SetENABLED1_CLK_SYS_XIP(value uint32) {
	volatile.StoreUint32(&o.ENABLED1.Reg, volatile.LoadUint32(&o.ENABLED1.Reg)&^(0x2000)|value<<13)
}
func (o *CLOCKS_Type) GetENABLED1_CLK_SYS_XIP() uint32 {
	return (volatile.LoadUint32(&o.ENABLED1.Reg) & 0x2000) >> 13
}
func (o *CLOCKS_Type) SetENABLED1_CLK_SYS_WATCHDOG(value uint32) {
	volatile.StoreUint32(&o.ENABLED1.Reg, volatile.LoadUint32(&o.ENABLED1.Reg)&^(0x1000)|value<<12)
}
func (o *CLOCKS_Type) GetENABLED1_CLK_SYS_WATCHDOG() uint32 {
	return (volatile.LoadUint32(&o.ENABLED1.Reg) & 0x1000) >> 12
}
func (o *CLOCKS_Type) SetENABLED1_CLK_USB_USBCTRL(value uint32) {
	volatile.StoreUint32(&o.ENABLED1.Reg, volatile.LoadUint32(&o.ENABLED1.Reg)&^(0x800)|value<<11)
}
func (o *CLOCKS_Type) GetENABLED1_CLK_USB_USBCTRL() uint32 {
	return (volatile.LoadUint32(&o.ENABLED1.Reg) & 0x800) >> 11
}
func (o *CLOCKS_Type) SetENABLED1_CLK_SYS_USBCTRL(value uint32) {
	volatile.StoreUint32(&o.ENABLED1.Reg, volatile.LoadUint32(&o.ENABLED1.Reg)&^(0x400)|value<<10)
}
func (o *CLOCKS_Type) GetENABLED1_CLK_SYS_USBCTRL() uint32 {
	return (volatile.LoadUint32(&o.ENABLED1.Reg) & 0x400) >> 10
}
func (o *CLOCKS_Type) SetENABLED1_CLK_SYS_UART1(value uint32) {
	volatile.StoreUint32(&o.ENABLED1.Reg, volatile.LoadUint32(&o.ENABLED1.Reg)&^(0x200)|value<<9)
}
func (o *CLOCKS_Type) GetENABLED1_CLK_SYS_UART1() uint32 {
	return (volatile.LoadUint32(&o.ENABLED1.Reg) & 0x200) >> 9
}
func (o *CLOCKS_Type) SetENABLED1_CLK_PERI_UART1(value uint32) {
	volatile.StoreUint32(&o.ENABLED1.Reg, volatile.LoadUint32(&o.ENABLED1.Reg)&^(0x100)|value<<8)
}
func (o *CLOCKS_Type) GetENABLED1_CLK_PERI_UART1() uint32 {
	return (volatile.LoadUint32(&o.ENABLED1.Reg) & 0x100) >> 8
}
func (o *CLOCKS_Type) SetENABLED1_CLK_SYS_UART0(value uint32) {
	volatile.StoreUint32(&o.ENABLED1.Reg, volatile.LoadUint32(&o.ENABLED1.Reg)&^(0x80)|value<<7)
}
func (o *CLOCKS_Type) GetENABLED1_CLK_SYS_UART0() uint32 {
	return (volatile.LoadUint32(&o.ENABLED1.Reg) & 0x80) >> 7
}
func (o *CLOCKS_Type) SetENABLED1_CLK_PERI_UART0(value uint32) {
	volatile.StoreUint32(&o.ENABLED1.Reg, volatile.LoadUint32(&o.ENABLED1.Reg)&^(0x40)|value<<6)
}
func (o *CLOCKS_Type) GetENABLED1_CLK_PERI_UART0() uint32 {
	return (volatile.LoadUint32(&o.ENABLED1.Reg) & 0x40) >> 6
}
func (o *CLOCKS_Type) SetENABLED1_CLK_SYS_TIMER(value uint32) {
	volatile.StoreUint32(&o.ENABLED1.Reg, volatile.LoadUint32(&o.ENABLED1.Reg)&^(0x20)|value<<5)
}
func (o *CLOCKS_Type) GetENABLED1_CLK_SYS_TIMER() uint32 {
	return (volatile.LoadUint32(&o.ENABLED1.Reg) & 0x20) >> 5
}
func (o *CLOCKS_Type) SetENABLED1_CLK_SYS_TBMAN(value uint32) {
	volatile.StoreUint32(&o.ENABLED1.Reg, volatile.LoadUint32(&o.ENABLED1.Reg)&^(0x10)|value<<4)
}
func (o *CLOCKS_Type) GetENABLED1_CLK_SYS_TBMAN() uint32 {
	return (volatile.LoadUint32(&o.ENABLED1.Reg) & 0x10) >> 4
}
func (o *CLOCKS_Type) SetENABLED1_CLK_SYS_SYSINFO(value uint32) {
	volatile.StoreUint32(&o.ENABLED1.Reg, volatile.LoadUint32(&o.ENABLED1.Reg)&^(0x8)|value<<3)
}
func (o *CLOCKS_Type) GetENABLED1_CLK_SYS_SYSINFO() uint32 {
	return (volatile.LoadUint32(&o.ENABLED1.Reg) & 0x8) >> 3
}
func (o *CLOCKS_Type) SetENABLED1_CLK_SYS_SYSCFG(value uint32) {
	volatile.StoreUint32(&o.ENABLED1.Reg, volatile.LoadUint32(&o.ENABLED1.Reg)&^(0x4)|value<<2)
}
func (o *CLOCKS_Type) GetENABLED1_CLK_SYS_SYSCFG() uint32 {
	return (volatile.LoadUint32(&o.ENABLED1.Reg) & 0x4) >> 2
}
func (o *CLOCKS_Type) SetENABLED1_CLK_SYS_SRAM5(value uint32) {
	volatile.StoreUint32(&o.ENABLED1.Reg, volatile.LoadUint32(&o.ENABLED1.Reg)&^(0x2)|value<<1)
}
func (o *CLOCKS_Type) GetENABLED1_CLK_SYS_SRAM5() uint32 {
	return (volatile.LoadUint32(&o.ENABLED1.Reg) & 0x2) >> 1
}
func (o *CLOCKS_Type) SetENABLED1_CLK_SYS_SRAM4(value uint32) {
	volatile.StoreUint32(&o.ENABLED1.Reg, volatile.LoadUint32(&o.ENABLED1.Reg)&^(0x1)|value)
}
func (o *CLOCKS_Type) GetENABLED1_CLK_SYS_SRAM4() uint32 {
	return volatile.LoadUint32(&o.ENABLED1.Reg) & 0x1
}

// CLOCKS.INTR: Raw Interrupts
func (o *CLOCKS_Type) SetINTR_CLK_SYS_RESUS(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x1)|value)
}
func (o *CLOCKS_Type) GetINTR_CLK_SYS_RESUS() uint32 {
	return volatile.LoadUint32(&o.INTR.Reg) & 0x1
}

// CLOCKS.INTE: Interrupt Enable
func (o *CLOCKS_Type) SetINTE_CLK_SYS_RESUS(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x1)|value)
}
func (o *CLOCKS_Type) GetINTE_CLK_SYS_RESUS() uint32 {
	return volatile.LoadUint32(&o.INTE.Reg) & 0x1
}

// CLOCKS.INTF: Interrupt Force
func (o *CLOCKS_Type) SetINTF_CLK_SYS_RESUS(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x1)|value)
}
func (o *CLOCKS_Type) GetINTF_CLK_SYS_RESUS() uint32 {
	return volatile.LoadUint32(&o.INTF.Reg) & 0x1
}

// CLOCKS.INTS: Interrupt status after masking & forcing
func (o *CLOCKS_Type) SetINTS_CLK_SYS_RESUS(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x1)|value)
}
func (o *CLOCKS_Type) GetINTS_CLK_SYS_RESUS() uint32 {
	return volatile.LoadUint32(&o.INTS.Reg) & 0x1
}

type RESETS_Type struct {
	RESET      volatile.Register32 // 0x0
	WDSEL      volatile.Register32 // 0x4
	RESET_DONE volatile.Register32 // 0x8
}

// RESETS.RESET: Reset control. If a bit is set it means the peripheral is in reset. 0 means the peripheral's reset is deasserted.
func (o *RESETS_Type) SetRESET_USBCTRL(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x1000000)|value<<24)
}
func (o *RESETS_Type) GetRESET_USBCTRL() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x1000000) >> 24
}
func (o *RESETS_Type) SetRESET_UART1(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x800000)|value<<23)
}
func (o *RESETS_Type) GetRESET_UART1() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x800000) >> 23
}
func (o *RESETS_Type) SetRESET_UART0(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x400000)|value<<22)
}
func (o *RESETS_Type) GetRESET_UART0() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x400000) >> 22
}
func (o *RESETS_Type) SetRESET_TIMER(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x200000)|value<<21)
}
func (o *RESETS_Type) GetRESET_TIMER() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x200000) >> 21
}
func (o *RESETS_Type) SetRESET_TBMAN(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x100000)|value<<20)
}
func (o *RESETS_Type) GetRESET_TBMAN() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x100000) >> 20
}
func (o *RESETS_Type) SetRESET_SYSINFO(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x80000)|value<<19)
}
func (o *RESETS_Type) GetRESET_SYSINFO() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x80000) >> 19
}
func (o *RESETS_Type) SetRESET_SYSCFG(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x40000)|value<<18)
}
func (o *RESETS_Type) GetRESET_SYSCFG() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x40000) >> 18
}
func (o *RESETS_Type) SetRESET_SPI1(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x20000)|value<<17)
}
func (o *RESETS_Type) GetRESET_SPI1() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x20000) >> 17
}
func (o *RESETS_Type) SetRESET_SPI0(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x10000)|value<<16)
}
func (o *RESETS_Type) GetRESET_SPI0() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x10000) >> 16
}
func (o *RESETS_Type) SetRESET_RTC(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x8000)|value<<15)
}
func (o *RESETS_Type) GetRESET_RTC() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x8000) >> 15
}
func (o *RESETS_Type) SetRESET_PWM(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x4000)|value<<14)
}
func (o *RESETS_Type) GetRESET_PWM() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x4000) >> 14
}
func (o *RESETS_Type) SetRESET_PLL_USB(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x2000)|value<<13)
}
func (o *RESETS_Type) GetRESET_PLL_USB() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x2000) >> 13
}
func (o *RESETS_Type) SetRESET_PLL_SYS(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x1000)|value<<12)
}
func (o *RESETS_Type) GetRESET_PLL_SYS() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x1000) >> 12
}
func (o *RESETS_Type) SetRESET_PIO1(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x800)|value<<11)
}
func (o *RESETS_Type) GetRESET_PIO1() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x800) >> 11
}
func (o *RESETS_Type) SetRESET_PIO0(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x400)|value<<10)
}
func (o *RESETS_Type) GetRESET_PIO0() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x400) >> 10
}
func (o *RESETS_Type) SetRESET_PADS_QSPI(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x200)|value<<9)
}
func (o *RESETS_Type) GetRESET_PADS_QSPI() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x200) >> 9
}
func (o *RESETS_Type) SetRESET_PADS_BANK0(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x100)|value<<8)
}
func (o *RESETS_Type) GetRESET_PADS_BANK0() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x100) >> 8
}
func (o *RESETS_Type) SetRESET_JTAG(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x80)|value<<7)
}
func (o *RESETS_Type) GetRESET_JTAG() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x80) >> 7
}
func (o *RESETS_Type) SetRESET_IO_QSPI(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x40)|value<<6)
}
func (o *RESETS_Type) GetRESET_IO_QSPI() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x40) >> 6
}
func (o *RESETS_Type) SetRESET_IO_BANK0(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x20)|value<<5)
}
func (o *RESETS_Type) GetRESET_IO_BANK0() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x20) >> 5
}
func (o *RESETS_Type) SetRESET_I2C1(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x10)|value<<4)
}
func (o *RESETS_Type) GetRESET_I2C1() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x10) >> 4
}
func (o *RESETS_Type) SetRESET_I2C0(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x8)|value<<3)
}
func (o *RESETS_Type) GetRESET_I2C0() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x8) >> 3
}
func (o *RESETS_Type) SetRESET_DMA(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x4)|value<<2)
}
func (o *RESETS_Type) GetRESET_DMA() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x4) >> 2
}
func (o *RESETS_Type) SetRESET_BUSCTRL(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x2)|value<<1)
}
func (o *RESETS_Type) GetRESET_BUSCTRL() uint32 {
	return (volatile.LoadUint32(&o.RESET.Reg) & 0x2) >> 1
}
func (o *RESETS_Type) SetRESET_ADC(value uint32) {
	volatile.StoreUint32(&o.RESET.Reg, volatile.LoadUint32(&o.RESET.Reg)&^(0x1)|value)
}
func (o *RESETS_Type) GetRESET_ADC() uint32 {
	return volatile.LoadUint32(&o.RESET.Reg) & 0x1
}

// RESETS.WDSEL: Watchdog select. If a bit is set then the watchdog will reset this peripheral when the watchdog fires.
func (o *RESETS_Type) SetWDSEL_USBCTRL(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x1000000)|value<<24)
}
func (o *RESETS_Type) GetWDSEL_USBCTRL() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x1000000) >> 24
}
func (o *RESETS_Type) SetWDSEL_UART1(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x800000)|value<<23)
}
func (o *RESETS_Type) GetWDSEL_UART1() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x800000) >> 23
}
func (o *RESETS_Type) SetWDSEL_UART0(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x400000)|value<<22)
}
func (o *RESETS_Type) GetWDSEL_UART0() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x400000) >> 22
}
func (o *RESETS_Type) SetWDSEL_TIMER(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x200000)|value<<21)
}
func (o *RESETS_Type) GetWDSEL_TIMER() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x200000) >> 21
}
func (o *RESETS_Type) SetWDSEL_TBMAN(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x100000)|value<<20)
}
func (o *RESETS_Type) GetWDSEL_TBMAN() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x100000) >> 20
}
func (o *RESETS_Type) SetWDSEL_SYSINFO(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x80000)|value<<19)
}
func (o *RESETS_Type) GetWDSEL_SYSINFO() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x80000) >> 19
}
func (o *RESETS_Type) SetWDSEL_SYSCFG(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x40000)|value<<18)
}
func (o *RESETS_Type) GetWDSEL_SYSCFG() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x40000) >> 18
}
func (o *RESETS_Type) SetWDSEL_SPI1(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x20000)|value<<17)
}
func (o *RESETS_Type) GetWDSEL_SPI1() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x20000) >> 17
}
func (o *RESETS_Type) SetWDSEL_SPI0(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x10000)|value<<16)
}
func (o *RESETS_Type) GetWDSEL_SPI0() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x10000) >> 16
}
func (o *RESETS_Type) SetWDSEL_RTC(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x8000)|value<<15)
}
func (o *RESETS_Type) GetWDSEL_RTC() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x8000) >> 15
}
func (o *RESETS_Type) SetWDSEL_PWM(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x4000)|value<<14)
}
func (o *RESETS_Type) GetWDSEL_PWM() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x4000) >> 14
}
func (o *RESETS_Type) SetWDSEL_PLL_USB(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x2000)|value<<13)
}
func (o *RESETS_Type) GetWDSEL_PLL_USB() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x2000) >> 13
}
func (o *RESETS_Type) SetWDSEL_PLL_SYS(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x1000)|value<<12)
}
func (o *RESETS_Type) GetWDSEL_PLL_SYS() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x1000) >> 12
}
func (o *RESETS_Type) SetWDSEL_PIO1(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x800)|value<<11)
}
func (o *RESETS_Type) GetWDSEL_PIO1() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x800) >> 11
}
func (o *RESETS_Type) SetWDSEL_PIO0(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x400)|value<<10)
}
func (o *RESETS_Type) GetWDSEL_PIO0() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x400) >> 10
}
func (o *RESETS_Type) SetWDSEL_PADS_QSPI(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x200)|value<<9)
}
func (o *RESETS_Type) GetWDSEL_PADS_QSPI() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x200) >> 9
}
func (o *RESETS_Type) SetWDSEL_PADS_BANK0(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x100)|value<<8)
}
func (o *RESETS_Type) GetWDSEL_PADS_BANK0() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x100) >> 8
}
func (o *RESETS_Type) SetWDSEL_JTAG(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x80)|value<<7)
}
func (o *RESETS_Type) GetWDSEL_JTAG() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x80) >> 7
}
func (o *RESETS_Type) SetWDSEL_IO_QSPI(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x40)|value<<6)
}
func (o *RESETS_Type) GetWDSEL_IO_QSPI() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x40) >> 6
}
func (o *RESETS_Type) SetWDSEL_IO_BANK0(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x20)|value<<5)
}
func (o *RESETS_Type) GetWDSEL_IO_BANK0() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x20) >> 5
}
func (o *RESETS_Type) SetWDSEL_I2C1(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x10)|value<<4)
}
func (o *RESETS_Type) GetWDSEL_I2C1() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x10) >> 4
}
func (o *RESETS_Type) SetWDSEL_I2C0(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x8)|value<<3)
}
func (o *RESETS_Type) GetWDSEL_I2C0() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x8) >> 3
}
func (o *RESETS_Type) SetWDSEL_DMA(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x4)|value<<2)
}
func (o *RESETS_Type) GetWDSEL_DMA() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x4) >> 2
}
func (o *RESETS_Type) SetWDSEL_BUSCTRL(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x2)|value<<1)
}
func (o *RESETS_Type) GetWDSEL_BUSCTRL() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x2) >> 1
}
func (o *RESETS_Type) SetWDSEL_ADC(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x1)|value)
}
func (o *RESETS_Type) GetWDSEL_ADC() uint32 {
	return volatile.LoadUint32(&o.WDSEL.Reg) & 0x1
}

// RESETS.RESET_DONE: Reset done. If a bit is set then a reset done signal has been returned by the peripheral. This indicates that the peripheral's registers are ready to be accessed.
func (o *RESETS_Type) SetRESET_DONE_USBCTRL(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x1000000)|value<<24)
}
func (o *RESETS_Type) GetRESET_DONE_USBCTRL() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x1000000) >> 24
}
func (o *RESETS_Type) SetRESET_DONE_UART1(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x800000)|value<<23)
}
func (o *RESETS_Type) GetRESET_DONE_UART1() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x800000) >> 23
}
func (o *RESETS_Type) SetRESET_DONE_UART0(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x400000)|value<<22)
}
func (o *RESETS_Type) GetRESET_DONE_UART0() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x400000) >> 22
}
func (o *RESETS_Type) SetRESET_DONE_TIMER(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x200000)|value<<21)
}
func (o *RESETS_Type) GetRESET_DONE_TIMER() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x200000) >> 21
}
func (o *RESETS_Type) SetRESET_DONE_TBMAN(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x100000)|value<<20)
}
func (o *RESETS_Type) GetRESET_DONE_TBMAN() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x100000) >> 20
}
func (o *RESETS_Type) SetRESET_DONE_SYSINFO(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x80000)|value<<19)
}
func (o *RESETS_Type) GetRESET_DONE_SYSINFO() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x80000) >> 19
}
func (o *RESETS_Type) SetRESET_DONE_SYSCFG(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x40000)|value<<18)
}
func (o *RESETS_Type) GetRESET_DONE_SYSCFG() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x40000) >> 18
}
func (o *RESETS_Type) SetRESET_DONE_SPI1(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x20000)|value<<17)
}
func (o *RESETS_Type) GetRESET_DONE_SPI1() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x20000) >> 17
}
func (o *RESETS_Type) SetRESET_DONE_SPI0(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x10000)|value<<16)
}
func (o *RESETS_Type) GetRESET_DONE_SPI0() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x10000) >> 16
}
func (o *RESETS_Type) SetRESET_DONE_RTC(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x8000)|value<<15)
}
func (o *RESETS_Type) GetRESET_DONE_RTC() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x8000) >> 15
}
func (o *RESETS_Type) SetRESET_DONE_PWM(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x4000)|value<<14)
}
func (o *RESETS_Type) GetRESET_DONE_PWM() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x4000) >> 14
}
func (o *RESETS_Type) SetRESET_DONE_PLL_USB(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x2000)|value<<13)
}
func (o *RESETS_Type) GetRESET_DONE_PLL_USB() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x2000) >> 13
}
func (o *RESETS_Type) SetRESET_DONE_PLL_SYS(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x1000)|value<<12)
}
func (o *RESETS_Type) GetRESET_DONE_PLL_SYS() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x1000) >> 12
}
func (o *RESETS_Type) SetRESET_DONE_PIO1(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x800)|value<<11)
}
func (o *RESETS_Type) GetRESET_DONE_PIO1() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x800) >> 11
}
func (o *RESETS_Type) SetRESET_DONE_PIO0(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x400)|value<<10)
}
func (o *RESETS_Type) GetRESET_DONE_PIO0() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x400) >> 10
}
func (o *RESETS_Type) SetRESET_DONE_PADS_QSPI(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x200)|value<<9)
}
func (o *RESETS_Type) GetRESET_DONE_PADS_QSPI() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x200) >> 9
}
func (o *RESETS_Type) SetRESET_DONE_PADS_BANK0(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x100)|value<<8)
}
func (o *RESETS_Type) GetRESET_DONE_PADS_BANK0() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x100) >> 8
}
func (o *RESETS_Type) SetRESET_DONE_JTAG(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x80)|value<<7)
}
func (o *RESETS_Type) GetRESET_DONE_JTAG() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x80) >> 7
}
func (o *RESETS_Type) SetRESET_DONE_IO_QSPI(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x40)|value<<6)
}
func (o *RESETS_Type) GetRESET_DONE_IO_QSPI() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x40) >> 6
}
func (o *RESETS_Type) SetRESET_DONE_IO_BANK0(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x20)|value<<5)
}
func (o *RESETS_Type) GetRESET_DONE_IO_BANK0() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x20) >> 5
}
func (o *RESETS_Type) SetRESET_DONE_I2C1(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x10)|value<<4)
}
func (o *RESETS_Type) GetRESET_DONE_I2C1() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x10) >> 4
}
func (o *RESETS_Type) SetRESET_DONE_I2C0(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x8)|value<<3)
}
func (o *RESETS_Type) GetRESET_DONE_I2C0() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x8) >> 3
}
func (o *RESETS_Type) SetRESET_DONE_DMA(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x4)|value<<2)
}
func (o *RESETS_Type) GetRESET_DONE_DMA() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x4) >> 2
}
func (o *RESETS_Type) SetRESET_DONE_BUSCTRL(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x2)|value<<1)
}
func (o *RESETS_Type) GetRESET_DONE_BUSCTRL() uint32 {
	return (volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x2) >> 1
}
func (o *RESETS_Type) SetRESET_DONE_ADC(value uint32) {
	volatile.StoreUint32(&o.RESET_DONE.Reg, volatile.LoadUint32(&o.RESET_DONE.Reg)&^(0x1)|value)
}
func (o *RESETS_Type) GetRESET_DONE_ADC() uint32 {
	return volatile.LoadUint32(&o.RESET_DONE.Reg) & 0x1
}

type PSM_Type struct {
	FRCE_ON  volatile.Register32 // 0x0
	FRCE_OFF volatile.Register32 // 0x4
	WDSEL    volatile.Register32 // 0x8
	DONE     volatile.Register32 // 0xC
}

// PSM.FRCE_ON: Force block out of reset (i.e. power it on)
func (o *PSM_Type) SetFRCE_ON_PROC1(value uint32) {
	volatile.StoreUint32(&o.FRCE_ON.Reg, volatile.LoadUint32(&o.FRCE_ON.Reg)&^(0x10000)|value<<16)
}
func (o *PSM_Type) GetFRCE_ON_PROC1() uint32 {
	return (volatile.LoadUint32(&o.FRCE_ON.Reg) & 0x10000) >> 16
}
func (o *PSM_Type) SetFRCE_ON_PROC0(value uint32) {
	volatile.StoreUint32(&o.FRCE_ON.Reg, volatile.LoadUint32(&o.FRCE_ON.Reg)&^(0x8000)|value<<15)
}
func (o *PSM_Type) GetFRCE_ON_PROC0() uint32 {
	return (volatile.LoadUint32(&o.FRCE_ON.Reg) & 0x8000) >> 15
}
func (o *PSM_Type) SetFRCE_ON_SIO(value uint32) {
	volatile.StoreUint32(&o.FRCE_ON.Reg, volatile.LoadUint32(&o.FRCE_ON.Reg)&^(0x4000)|value<<14)
}
func (o *PSM_Type) GetFRCE_ON_SIO() uint32 {
	return (volatile.LoadUint32(&o.FRCE_ON.Reg) & 0x4000) >> 14
}
func (o *PSM_Type) SetFRCE_ON_VREG_AND_CHIP_RESET(value uint32) {
	volatile.StoreUint32(&o.FRCE_ON.Reg, volatile.LoadUint32(&o.FRCE_ON.Reg)&^(0x2000)|value<<13)
}
func (o *PSM_Type) GetFRCE_ON_VREG_AND_CHIP_RESET() uint32 {
	return (volatile.LoadUint32(&o.FRCE_ON.Reg) & 0x2000) >> 13
}
func (o *PSM_Type) SetFRCE_ON_XIP(value uint32) {
	volatile.StoreUint32(&o.FRCE_ON.Reg, volatile.LoadUint32(&o.FRCE_ON.Reg)&^(0x1000)|value<<12)
}
func (o *PSM_Type) GetFRCE_ON_XIP() uint32 {
	return (volatile.LoadUint32(&o.FRCE_ON.Reg) & 0x1000) >> 12
}
func (o *PSM_Type) SetFRCE_ON_SRAM5(value uint32) {
	volatile.StoreUint32(&o.FRCE_ON.Reg, volatile.LoadUint32(&o.FRCE_ON.Reg)&^(0x800)|value<<11)
}
func (o *PSM_Type) GetFRCE_ON_SRAM5() uint32 {
	return (volatile.LoadUint32(&o.FRCE_ON.Reg) & 0x800) >> 11
}
func (o *PSM_Type) SetFRCE_ON_SRAM4(value uint32) {
	volatile.StoreUint32(&o.FRCE_ON.Reg, volatile.LoadUint32(&o.FRCE_ON.Reg)&^(0x400)|value<<10)
}
func (o *PSM_Type) GetFRCE_ON_SRAM4() uint32 {
	return (volatile.LoadUint32(&o.FRCE_ON.Reg) & 0x400) >> 10
}
func (o *PSM_Type) SetFRCE_ON_SRAM3(value uint32) {
	volatile.StoreUint32(&o.FRCE_ON.Reg, volatile.LoadUint32(&o.FRCE_ON.Reg)&^(0x200)|value<<9)
}
func (o *PSM_Type) GetFRCE_ON_SRAM3() uint32 {
	return (volatile.LoadUint32(&o.FRCE_ON.Reg) & 0x200) >> 9
}
func (o *PSM_Type) SetFRCE_ON_SRAM2(value uint32) {
	volatile.StoreUint32(&o.FRCE_ON.Reg, volatile.LoadUint32(&o.FRCE_ON.Reg)&^(0x100)|value<<8)
}
func (o *PSM_Type) GetFRCE_ON_SRAM2() uint32 {
	return (volatile.LoadUint32(&o.FRCE_ON.Reg) & 0x100) >> 8
}
func (o *PSM_Type) SetFRCE_ON_SRAM1(value uint32) {
	volatile.StoreUint32(&o.FRCE_ON.Reg, volatile.LoadUint32(&o.FRCE_ON.Reg)&^(0x80)|value<<7)
}
func (o *PSM_Type) GetFRCE_ON_SRAM1() uint32 {
	return (volatile.LoadUint32(&o.FRCE_ON.Reg) & 0x80) >> 7
}
func (o *PSM_Type) SetFRCE_ON_SRAM0(value uint32) {
	volatile.StoreUint32(&o.FRCE_ON.Reg, volatile.LoadUint32(&o.FRCE_ON.Reg)&^(0x40)|value<<6)
}
func (o *PSM_Type) GetFRCE_ON_SRAM0() uint32 {
	return (volatile.LoadUint32(&o.FRCE_ON.Reg) & 0x40) >> 6
}
func (o *PSM_Type) SetFRCE_ON_ROM(value uint32) {
	volatile.StoreUint32(&o.FRCE_ON.Reg, volatile.LoadUint32(&o.FRCE_ON.Reg)&^(0x20)|value<<5)
}
func (o *PSM_Type) GetFRCE_ON_ROM() uint32 {
	return (volatile.LoadUint32(&o.FRCE_ON.Reg) & 0x20) >> 5
}
func (o *PSM_Type) SetFRCE_ON_BUSFABRIC(value uint32) {
	volatile.StoreUint32(&o.FRCE_ON.Reg, volatile.LoadUint32(&o.FRCE_ON.Reg)&^(0x10)|value<<4)
}
func (o *PSM_Type) GetFRCE_ON_BUSFABRIC() uint32 {
	return (volatile.LoadUint32(&o.FRCE_ON.Reg) & 0x10) >> 4
}
func (o *PSM_Type) SetFRCE_ON_RESETS(value uint32) {
	volatile.StoreUint32(&o.FRCE_ON.Reg, volatile.LoadUint32(&o.FRCE_ON.Reg)&^(0x8)|value<<3)
}
func (o *PSM_Type) GetFRCE_ON_RESETS() uint32 {
	return (volatile.LoadUint32(&o.FRCE_ON.Reg) & 0x8) >> 3
}
func (o *PSM_Type) SetFRCE_ON_CLOCKS(value uint32) {
	volatile.StoreUint32(&o.FRCE_ON.Reg, volatile.LoadUint32(&o.FRCE_ON.Reg)&^(0x4)|value<<2)
}
func (o *PSM_Type) GetFRCE_ON_CLOCKS() uint32 {
	return (volatile.LoadUint32(&o.FRCE_ON.Reg) & 0x4) >> 2
}
func (o *PSM_Type) SetFRCE_ON_XOSC(value uint32) {
	volatile.StoreUint32(&o.FRCE_ON.Reg, volatile.LoadUint32(&o.FRCE_ON.Reg)&^(0x2)|value<<1)
}
func (o *PSM_Type) GetFRCE_ON_XOSC() uint32 {
	return (volatile.LoadUint32(&o.FRCE_ON.Reg) & 0x2) >> 1
}
func (o *PSM_Type) SetFRCE_ON_ROSC(value uint32) {
	volatile.StoreUint32(&o.FRCE_ON.Reg, volatile.LoadUint32(&o.FRCE_ON.Reg)&^(0x1)|value)
}
func (o *PSM_Type) GetFRCE_ON_ROSC() uint32 {
	return volatile.LoadUint32(&o.FRCE_ON.Reg) & 0x1
}

// PSM.FRCE_OFF: Force into reset (i.e. power it off)
func (o *PSM_Type) SetFRCE_OFF_PROC1(value uint32) {
	volatile.StoreUint32(&o.FRCE_OFF.Reg, volatile.LoadUint32(&o.FRCE_OFF.Reg)&^(0x10000)|value<<16)
}
func (o *PSM_Type) GetFRCE_OFF_PROC1() uint32 {
	return (volatile.LoadUint32(&o.FRCE_OFF.Reg) & 0x10000) >> 16
}
func (o *PSM_Type) SetFRCE_OFF_PROC0(value uint32) {
	volatile.StoreUint32(&o.FRCE_OFF.Reg, volatile.LoadUint32(&o.FRCE_OFF.Reg)&^(0x8000)|value<<15)
}
func (o *PSM_Type) GetFRCE_OFF_PROC0() uint32 {
	return (volatile.LoadUint32(&o.FRCE_OFF.Reg) & 0x8000) >> 15
}
func (o *PSM_Type) SetFRCE_OFF_SIO(value uint32) {
	volatile.StoreUint32(&o.FRCE_OFF.Reg, volatile.LoadUint32(&o.FRCE_OFF.Reg)&^(0x4000)|value<<14)
}
func (o *PSM_Type) GetFRCE_OFF_SIO() uint32 {
	return (volatile.LoadUint32(&o.FRCE_OFF.Reg) & 0x4000) >> 14
}
func (o *PSM_Type) SetFRCE_OFF_VREG_AND_CHIP_RESET(value uint32) {
	volatile.StoreUint32(&o.FRCE_OFF.Reg, volatile.LoadUint32(&o.FRCE_OFF.Reg)&^(0x2000)|value<<13)
}
func (o *PSM_Type) GetFRCE_OFF_VREG_AND_CHIP_RESET() uint32 {
	return (volatile.LoadUint32(&o.FRCE_OFF.Reg) & 0x2000) >> 13
}
func (o *PSM_Type) SetFRCE_OFF_XIP(value uint32) {
	volatile.StoreUint32(&o.FRCE_OFF.Reg, volatile.LoadUint32(&o.FRCE_OFF.Reg)&^(0x1000)|value<<12)
}
func (o *PSM_Type) GetFRCE_OFF_XIP() uint32 {
	return (volatile.LoadUint32(&o.FRCE_OFF.Reg) & 0x1000) >> 12
}
func (o *PSM_Type) SetFRCE_OFF_SRAM5(value uint32) {
	volatile.StoreUint32(&o.FRCE_OFF.Reg, volatile.LoadUint32(&o.FRCE_OFF.Reg)&^(0x800)|value<<11)
}
func (o *PSM_Type) GetFRCE_OFF_SRAM5() uint32 {
	return (volatile.LoadUint32(&o.FRCE_OFF.Reg) & 0x800) >> 11
}
func (o *PSM_Type) SetFRCE_OFF_SRAM4(value uint32) {
	volatile.StoreUint32(&o.FRCE_OFF.Reg, volatile.LoadUint32(&o.FRCE_OFF.Reg)&^(0x400)|value<<10)
}
func (o *PSM_Type) GetFRCE_OFF_SRAM4() uint32 {
	return (volatile.LoadUint32(&o.FRCE_OFF.Reg) & 0x400) >> 10
}
func (o *PSM_Type) SetFRCE_OFF_SRAM3(value uint32) {
	volatile.StoreUint32(&o.FRCE_OFF.Reg, volatile.LoadUint32(&o.FRCE_OFF.Reg)&^(0x200)|value<<9)
}
func (o *PSM_Type) GetFRCE_OFF_SRAM3() uint32 {
	return (volatile.LoadUint32(&o.FRCE_OFF.Reg) & 0x200) >> 9
}
func (o *PSM_Type) SetFRCE_OFF_SRAM2(value uint32) {
	volatile.StoreUint32(&o.FRCE_OFF.Reg, volatile.LoadUint32(&o.FRCE_OFF.Reg)&^(0x100)|value<<8)
}
func (o *PSM_Type) GetFRCE_OFF_SRAM2() uint32 {
	return (volatile.LoadUint32(&o.FRCE_OFF.Reg) & 0x100) >> 8
}
func (o *PSM_Type) SetFRCE_OFF_SRAM1(value uint32) {
	volatile.StoreUint32(&o.FRCE_OFF.Reg, volatile.LoadUint32(&o.FRCE_OFF.Reg)&^(0x80)|value<<7)
}
func (o *PSM_Type) GetFRCE_OFF_SRAM1() uint32 {
	return (volatile.LoadUint32(&o.FRCE_OFF.Reg) & 0x80) >> 7
}
func (o *PSM_Type) SetFRCE_OFF_SRAM0(value uint32) {
	volatile.StoreUint32(&o.FRCE_OFF.Reg, volatile.LoadUint32(&o.FRCE_OFF.Reg)&^(0x40)|value<<6)
}
func (o *PSM_Type) GetFRCE_OFF_SRAM0() uint32 {
	return (volatile.LoadUint32(&o.FRCE_OFF.Reg) & 0x40) >> 6
}
func (o *PSM_Type) SetFRCE_OFF_ROM(value uint32) {
	volatile.StoreUint32(&o.FRCE_OFF.Reg, volatile.LoadUint32(&o.FRCE_OFF.Reg)&^(0x20)|value<<5)
}
func (o *PSM_Type) GetFRCE_OFF_ROM() uint32 {
	return (volatile.LoadUint32(&o.FRCE_OFF.Reg) & 0x20) >> 5
}
func (o *PSM_Type) SetFRCE_OFF_BUSFABRIC(value uint32) {
	volatile.StoreUint32(&o.FRCE_OFF.Reg, volatile.LoadUint32(&o.FRCE_OFF.Reg)&^(0x10)|value<<4)
}
func (o *PSM_Type) GetFRCE_OFF_BUSFABRIC() uint32 {
	return (volatile.LoadUint32(&o.FRCE_OFF.Reg) & 0x10) >> 4
}
func (o *PSM_Type) SetFRCE_OFF_RESETS(value uint32) {
	volatile.StoreUint32(&o.FRCE_OFF.Reg, volatile.LoadUint32(&o.FRCE_OFF.Reg)&^(0x8)|value<<3)
}
func (o *PSM_Type) GetFRCE_OFF_RESETS() uint32 {
	return (volatile.LoadUint32(&o.FRCE_OFF.Reg) & 0x8) >> 3
}
func (o *PSM_Type) SetFRCE_OFF_CLOCKS(value uint32) {
	volatile.StoreUint32(&o.FRCE_OFF.Reg, volatile.LoadUint32(&o.FRCE_OFF.Reg)&^(0x4)|value<<2)
}
func (o *PSM_Type) GetFRCE_OFF_CLOCKS() uint32 {
	return (volatile.LoadUint32(&o.FRCE_OFF.Reg) & 0x4) >> 2
}
func (o *PSM_Type) SetFRCE_OFF_XOSC(value uint32) {
	volatile.StoreUint32(&o.FRCE_OFF.Reg, volatile.LoadUint32(&o.FRCE_OFF.Reg)&^(0x2)|value<<1)
}
func (o *PSM_Type) GetFRCE_OFF_XOSC() uint32 {
	return (volatile.LoadUint32(&o.FRCE_OFF.Reg) & 0x2) >> 1
}
func (o *PSM_Type) SetFRCE_OFF_ROSC(value uint32) {
	volatile.StoreUint32(&o.FRCE_OFF.Reg, volatile.LoadUint32(&o.FRCE_OFF.Reg)&^(0x1)|value)
}
func (o *PSM_Type) GetFRCE_OFF_ROSC() uint32 {
	return volatile.LoadUint32(&o.FRCE_OFF.Reg) & 0x1
}

// PSM.WDSEL: Set to 1 if this peripheral should be reset when the watchdog fires.
func (o *PSM_Type) SetWDSEL_PROC1(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x10000)|value<<16)
}
func (o *PSM_Type) GetWDSEL_PROC1() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x10000) >> 16
}
func (o *PSM_Type) SetWDSEL_PROC0(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x8000)|value<<15)
}
func (o *PSM_Type) GetWDSEL_PROC0() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x8000) >> 15
}
func (o *PSM_Type) SetWDSEL_SIO(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x4000)|value<<14)
}
func (o *PSM_Type) GetWDSEL_SIO() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x4000) >> 14
}
func (o *PSM_Type) SetWDSEL_VREG_AND_CHIP_RESET(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x2000)|value<<13)
}
func (o *PSM_Type) GetWDSEL_VREG_AND_CHIP_RESET() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x2000) >> 13
}
func (o *PSM_Type) SetWDSEL_XIP(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x1000)|value<<12)
}
func (o *PSM_Type) GetWDSEL_XIP() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x1000) >> 12
}
func (o *PSM_Type) SetWDSEL_SRAM5(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x800)|value<<11)
}
func (o *PSM_Type) GetWDSEL_SRAM5() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x800) >> 11
}
func (o *PSM_Type) SetWDSEL_SRAM4(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x400)|value<<10)
}
func (o *PSM_Type) GetWDSEL_SRAM4() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x400) >> 10
}
func (o *PSM_Type) SetWDSEL_SRAM3(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x200)|value<<9)
}
func (o *PSM_Type) GetWDSEL_SRAM3() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x200) >> 9
}
func (o *PSM_Type) SetWDSEL_SRAM2(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x100)|value<<8)
}
func (o *PSM_Type) GetWDSEL_SRAM2() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x100) >> 8
}
func (o *PSM_Type) SetWDSEL_SRAM1(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x80)|value<<7)
}
func (o *PSM_Type) GetWDSEL_SRAM1() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x80) >> 7
}
func (o *PSM_Type) SetWDSEL_SRAM0(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x40)|value<<6)
}
func (o *PSM_Type) GetWDSEL_SRAM0() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x40) >> 6
}
func (o *PSM_Type) SetWDSEL_ROM(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x20)|value<<5)
}
func (o *PSM_Type) GetWDSEL_ROM() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x20) >> 5
}
func (o *PSM_Type) SetWDSEL_BUSFABRIC(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x10)|value<<4)
}
func (o *PSM_Type) GetWDSEL_BUSFABRIC() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x10) >> 4
}
func (o *PSM_Type) SetWDSEL_RESETS(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x8)|value<<3)
}
func (o *PSM_Type) GetWDSEL_RESETS() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x8) >> 3
}
func (o *PSM_Type) SetWDSEL_CLOCKS(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x4)|value<<2)
}
func (o *PSM_Type) GetWDSEL_CLOCKS() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x4) >> 2
}
func (o *PSM_Type) SetWDSEL_XOSC(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x2)|value<<1)
}
func (o *PSM_Type) GetWDSEL_XOSC() uint32 {
	return (volatile.LoadUint32(&o.WDSEL.Reg) & 0x2) >> 1
}
func (o *PSM_Type) SetWDSEL_ROSC(value uint32) {
	volatile.StoreUint32(&o.WDSEL.Reg, volatile.LoadUint32(&o.WDSEL.Reg)&^(0x1)|value)
}
func (o *PSM_Type) GetWDSEL_ROSC() uint32 {
	return volatile.LoadUint32(&o.WDSEL.Reg) & 0x1
}

// PSM.DONE: Indicates the peripheral's registers are ready to access.
func (o *PSM_Type) SetDONE_PROC1(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x10000)|value<<16)
}
func (o *PSM_Type) GetDONE_PROC1() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x10000) >> 16
}
func (o *PSM_Type) SetDONE_PROC0(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x8000)|value<<15)
}
func (o *PSM_Type) GetDONE_PROC0() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x8000) >> 15
}
func (o *PSM_Type) SetDONE_SIO(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x4000)|value<<14)
}
func (o *PSM_Type) GetDONE_SIO() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x4000) >> 14
}
func (o *PSM_Type) SetDONE_VREG_AND_CHIP_RESET(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x2000)|value<<13)
}
func (o *PSM_Type) GetDONE_VREG_AND_CHIP_RESET() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x2000) >> 13
}
func (o *PSM_Type) SetDONE_XIP(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x1000)|value<<12)
}
func (o *PSM_Type) GetDONE_XIP() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x1000) >> 12
}
func (o *PSM_Type) SetDONE_SRAM5(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x800)|value<<11)
}
func (o *PSM_Type) GetDONE_SRAM5() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x800) >> 11
}
func (o *PSM_Type) SetDONE_SRAM4(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x400)|value<<10)
}
func (o *PSM_Type) GetDONE_SRAM4() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x400) >> 10
}
func (o *PSM_Type) SetDONE_SRAM3(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x200)|value<<9)
}
func (o *PSM_Type) GetDONE_SRAM3() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x200) >> 9
}
func (o *PSM_Type) SetDONE_SRAM2(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x100)|value<<8)
}
func (o *PSM_Type) GetDONE_SRAM2() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x100) >> 8
}
func (o *PSM_Type) SetDONE_SRAM1(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x80)|value<<7)
}
func (o *PSM_Type) GetDONE_SRAM1() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x80) >> 7
}
func (o *PSM_Type) SetDONE_SRAM0(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x40)|value<<6)
}
func (o *PSM_Type) GetDONE_SRAM0() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x40) >> 6
}
func (o *PSM_Type) SetDONE_ROM(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x20)|value<<5)
}
func (o *PSM_Type) GetDONE_ROM() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x20) >> 5
}
func (o *PSM_Type) SetDONE_BUSFABRIC(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x10)|value<<4)
}
func (o *PSM_Type) GetDONE_BUSFABRIC() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x10) >> 4
}
func (o *PSM_Type) SetDONE_RESETS(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x8)|value<<3)
}
func (o *PSM_Type) GetDONE_RESETS() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x8) >> 3
}
func (o *PSM_Type) SetDONE_CLOCKS(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x4)|value<<2)
}
func (o *PSM_Type) GetDONE_CLOCKS() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x4) >> 2
}
func (o *PSM_Type) SetDONE_XOSC(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x2)|value<<1)
}
func (o *PSM_Type) GetDONE_XOSC() uint32 {
	return (volatile.LoadUint32(&o.DONE.Reg) & 0x2) >> 1
}
func (o *PSM_Type) SetDONE_ROSC(value uint32) {
	volatile.StoreUint32(&o.DONE.Reg, volatile.LoadUint32(&o.DONE.Reg)&^(0x1)|value)
}
func (o *PSM_Type) GetDONE_ROSC() uint32 {
	return volatile.LoadUint32(&o.DONE.Reg) & 0x1
}

type IO_BANK0_Type struct {
	GPIO0_STATUS       volatile.Register32 // 0x0
	GPIO0_CTRL         volatile.Register32 // 0x4
	GPIO1_STATUS       volatile.Register32 // 0x8
	GPIO1_CTRL         volatile.Register32 // 0xC
	GPIO2_STATUS       volatile.Register32 // 0x10
	GPIO2_CTRL         volatile.Register32 // 0x14
	GPIO3_STATUS       volatile.Register32 // 0x18
	GPIO3_CTRL         volatile.Register32 // 0x1C
	GPIO4_STATUS       volatile.Register32 // 0x20
	GPIO4_CTRL         volatile.Register32 // 0x24
	GPIO5_STATUS       volatile.Register32 // 0x28
	GPIO5_CTRL         volatile.Register32 // 0x2C
	GPIO6_STATUS       volatile.Register32 // 0x30
	GPIO6_CTRL         volatile.Register32 // 0x34
	GPIO7_STATUS       volatile.Register32 // 0x38
	GPIO7_CTRL         volatile.Register32 // 0x3C
	GPIO8_STATUS       volatile.Register32 // 0x40
	GPIO8_CTRL         volatile.Register32 // 0x44
	GPIO9_STATUS       volatile.Register32 // 0x48
	GPIO9_CTRL         volatile.Register32 // 0x4C
	GPIO10_STATUS      volatile.Register32 // 0x50
	GPIO10_CTRL        volatile.Register32 // 0x54
	GPIO11_STATUS      volatile.Register32 // 0x58
	GPIO11_CTRL        volatile.Register32 // 0x5C
	GPIO12_STATUS      volatile.Register32 // 0x60
	GPIO12_CTRL        volatile.Register32 // 0x64
	GPIO13_STATUS      volatile.Register32 // 0x68
	GPIO13_CTRL        volatile.Register32 // 0x6C
	GPIO14_STATUS      volatile.Register32 // 0x70
	GPIO14_CTRL        volatile.Register32 // 0x74
	GPIO15_STATUS      volatile.Register32 // 0x78
	GPIO15_CTRL        volatile.Register32 // 0x7C
	GPIO16_STATUS      volatile.Register32 // 0x80
	GPIO16_CTRL        volatile.Register32 // 0x84
	GPIO17_STATUS      volatile.Register32 // 0x88
	GPIO17_CTRL        volatile.Register32 // 0x8C
	GPIO18_STATUS      volatile.Register32 // 0x90
	GPIO18_CTRL        volatile.Register32 // 0x94
	GPIO19_STATUS      volatile.Register32 // 0x98
	GPIO19_CTRL        volatile.Register32 // 0x9C
	GPIO20_STATUS      volatile.Register32 // 0xA0
	GPIO20_CTRL        volatile.Register32 // 0xA4
	GPIO21_STATUS      volatile.Register32 // 0xA8
	GPIO21_CTRL        volatile.Register32 // 0xAC
	GPIO22_STATUS      volatile.Register32 // 0xB0
	GPIO22_CTRL        volatile.Register32 // 0xB4
	GPIO23_STATUS      volatile.Register32 // 0xB8
	GPIO23_CTRL        volatile.Register32 // 0xBC
	GPIO24_STATUS      volatile.Register32 // 0xC0
	GPIO24_CTRL        volatile.Register32 // 0xC4
	GPIO25_STATUS      volatile.Register32 // 0xC8
	GPIO25_CTRL        volatile.Register32 // 0xCC
	GPIO26_STATUS      volatile.Register32 // 0xD0
	GPIO26_CTRL        volatile.Register32 // 0xD4
	GPIO27_STATUS      volatile.Register32 // 0xD8
	GPIO27_CTRL        volatile.Register32 // 0xDC
	GPIO28_STATUS      volatile.Register32 // 0xE0
	GPIO28_CTRL        volatile.Register32 // 0xE4
	GPIO29_STATUS      volatile.Register32 // 0xE8
	GPIO29_CTRL        volatile.Register32 // 0xEC
	INTR0              volatile.Register32 // 0xF0
	INTR1              volatile.Register32 // 0xF4
	INTR2              volatile.Register32 // 0xF8
	INTR3              volatile.Register32 // 0xFC
	PROC0_INTE0        volatile.Register32 // 0x100
	PROC0_INTE1        volatile.Register32 // 0x104
	PROC0_INTE2        volatile.Register32 // 0x108
	PROC0_INTE3        volatile.Register32 // 0x10C
	PROC0_INTF0        volatile.Register32 // 0x110
	PROC0_INTF1        volatile.Register32 // 0x114
	PROC0_INTF2        volatile.Register32 // 0x118
	PROC0_INTF3        volatile.Register32 // 0x11C
	PROC0_INTS0        volatile.Register32 // 0x120
	PROC0_INTS1        volatile.Register32 // 0x124
	PROC0_INTS2        volatile.Register32 // 0x128
	PROC0_INTS3        volatile.Register32 // 0x12C
	PROC1_INTE0        volatile.Register32 // 0x130
	PROC1_INTE1        volatile.Register32 // 0x134
	PROC1_INTE2        volatile.Register32 // 0x138
	PROC1_INTE3        volatile.Register32 // 0x13C
	PROC1_INTF0        volatile.Register32 // 0x140
	PROC1_INTF1        volatile.Register32 // 0x144
	PROC1_INTF2        volatile.Register32 // 0x148
	PROC1_INTF3        volatile.Register32 // 0x14C
	PROC1_INTS0        volatile.Register32 // 0x150
	PROC1_INTS1        volatile.Register32 // 0x154
	PROC1_INTS2        volatile.Register32 // 0x158
	PROC1_INTS3        volatile.Register32 // 0x15C
	DORMANT_WAKE_INTE0 volatile.Register32 // 0x160
	DORMANT_WAKE_INTE1 volatile.Register32 // 0x164
	DORMANT_WAKE_INTE2 volatile.Register32 // 0x168
	DORMANT_WAKE_INTE3 volatile.Register32 // 0x16C
	DORMANT_WAKE_INTF0 volatile.Register32 // 0x170
	DORMANT_WAKE_INTF1 volatile.Register32 // 0x174
	DORMANT_WAKE_INTF2 volatile.Register32 // 0x178
	DORMANT_WAKE_INTF3 volatile.Register32 // 0x17C
	DORMANT_WAKE_INTS0 volatile.Register32 // 0x180
	DORMANT_WAKE_INTS1 volatile.Register32 // 0x184
	DORMANT_WAKE_INTS2 volatile.Register32 // 0x188
	DORMANT_WAKE_INTS3 volatile.Register32 // 0x18C
}

// IO_BANK0.GPIO0_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO0_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO0_STATUS.Reg, volatile.LoadUint32(&o.GPIO0_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO0_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO0_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO0_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO0_STATUS.Reg, volatile.LoadUint32(&o.GPIO0_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO0_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO0_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO0_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO0_STATUS.Reg, volatile.LoadUint32(&o.GPIO0_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO0_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO0_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO0_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO0_STATUS.Reg, volatile.LoadUint32(&o.GPIO0_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO0_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO0_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO0_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO0_STATUS.Reg, volatile.LoadUint32(&o.GPIO0_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO0_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO0_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO0_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO0_STATUS.Reg, volatile.LoadUint32(&o.GPIO0_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO0_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO0_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO0_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO0_STATUS.Reg, volatile.LoadUint32(&o.GPIO0_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO0_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO0_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO0_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO0_STATUS.Reg, volatile.LoadUint32(&o.GPIO0_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO0_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO0_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO0_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO0_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO0_CTRL.Reg, volatile.LoadUint32(&o.GPIO0_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO0_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO0_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO0_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO0_CTRL.Reg, volatile.LoadUint32(&o.GPIO0_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO0_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO0_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO0_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO0_CTRL.Reg, volatile.LoadUint32(&o.GPIO0_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO0_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO0_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO0_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO0_CTRL.Reg, volatile.LoadUint32(&o.GPIO0_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO0_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO0_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO0_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO0_CTRL.Reg, volatile.LoadUint32(&o.GPIO0_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO0_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO0_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO1_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO1_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO1_STATUS.Reg, volatile.LoadUint32(&o.GPIO1_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO1_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO1_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO1_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO1_STATUS.Reg, volatile.LoadUint32(&o.GPIO1_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO1_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO1_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO1_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO1_STATUS.Reg, volatile.LoadUint32(&o.GPIO1_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO1_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO1_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO1_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO1_STATUS.Reg, volatile.LoadUint32(&o.GPIO1_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO1_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO1_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO1_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO1_STATUS.Reg, volatile.LoadUint32(&o.GPIO1_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO1_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO1_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO1_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO1_STATUS.Reg, volatile.LoadUint32(&o.GPIO1_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO1_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO1_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO1_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO1_STATUS.Reg, volatile.LoadUint32(&o.GPIO1_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO1_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO1_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO1_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO1_STATUS.Reg, volatile.LoadUint32(&o.GPIO1_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO1_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO1_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO1_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO1_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO1_CTRL.Reg, volatile.LoadUint32(&o.GPIO1_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO1_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO1_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO1_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO1_CTRL.Reg, volatile.LoadUint32(&o.GPIO1_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO1_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO1_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO1_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO1_CTRL.Reg, volatile.LoadUint32(&o.GPIO1_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO1_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO1_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO1_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO1_CTRL.Reg, volatile.LoadUint32(&o.GPIO1_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO1_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO1_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO1_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO1_CTRL.Reg, volatile.LoadUint32(&o.GPIO1_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO1_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO1_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO2_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO2_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO2_STATUS.Reg, volatile.LoadUint32(&o.GPIO2_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO2_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO2_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO2_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO2_STATUS.Reg, volatile.LoadUint32(&o.GPIO2_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO2_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO2_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO2_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO2_STATUS.Reg, volatile.LoadUint32(&o.GPIO2_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO2_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO2_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO2_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO2_STATUS.Reg, volatile.LoadUint32(&o.GPIO2_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO2_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO2_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO2_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO2_STATUS.Reg, volatile.LoadUint32(&o.GPIO2_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO2_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO2_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO2_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO2_STATUS.Reg, volatile.LoadUint32(&o.GPIO2_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO2_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO2_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO2_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO2_STATUS.Reg, volatile.LoadUint32(&o.GPIO2_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO2_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO2_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO2_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO2_STATUS.Reg, volatile.LoadUint32(&o.GPIO2_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO2_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO2_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO2_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO2_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO2_CTRL.Reg, volatile.LoadUint32(&o.GPIO2_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO2_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO2_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO2_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO2_CTRL.Reg, volatile.LoadUint32(&o.GPIO2_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO2_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO2_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO2_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO2_CTRL.Reg, volatile.LoadUint32(&o.GPIO2_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO2_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO2_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO2_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO2_CTRL.Reg, volatile.LoadUint32(&o.GPIO2_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO2_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO2_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO2_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO2_CTRL.Reg, volatile.LoadUint32(&o.GPIO2_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO2_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO2_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO3_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO3_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO3_STATUS.Reg, volatile.LoadUint32(&o.GPIO3_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO3_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO3_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO3_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO3_STATUS.Reg, volatile.LoadUint32(&o.GPIO3_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO3_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO3_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO3_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO3_STATUS.Reg, volatile.LoadUint32(&o.GPIO3_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO3_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO3_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO3_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO3_STATUS.Reg, volatile.LoadUint32(&o.GPIO3_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO3_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO3_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO3_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO3_STATUS.Reg, volatile.LoadUint32(&o.GPIO3_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO3_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO3_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO3_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO3_STATUS.Reg, volatile.LoadUint32(&o.GPIO3_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO3_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO3_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO3_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO3_STATUS.Reg, volatile.LoadUint32(&o.GPIO3_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO3_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO3_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO3_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO3_STATUS.Reg, volatile.LoadUint32(&o.GPIO3_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO3_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO3_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO3_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO3_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO3_CTRL.Reg, volatile.LoadUint32(&o.GPIO3_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO3_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO3_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO3_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO3_CTRL.Reg, volatile.LoadUint32(&o.GPIO3_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO3_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO3_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO3_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO3_CTRL.Reg, volatile.LoadUint32(&o.GPIO3_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO3_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO3_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO3_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO3_CTRL.Reg, volatile.LoadUint32(&o.GPIO3_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO3_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO3_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO3_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO3_CTRL.Reg, volatile.LoadUint32(&o.GPIO3_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO3_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO3_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO4_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO4_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO4_STATUS.Reg, volatile.LoadUint32(&o.GPIO4_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO4_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO4_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO4_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO4_STATUS.Reg, volatile.LoadUint32(&o.GPIO4_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO4_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO4_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO4_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO4_STATUS.Reg, volatile.LoadUint32(&o.GPIO4_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO4_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO4_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO4_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO4_STATUS.Reg, volatile.LoadUint32(&o.GPIO4_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO4_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO4_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO4_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO4_STATUS.Reg, volatile.LoadUint32(&o.GPIO4_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO4_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO4_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO4_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO4_STATUS.Reg, volatile.LoadUint32(&o.GPIO4_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO4_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO4_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO4_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO4_STATUS.Reg, volatile.LoadUint32(&o.GPIO4_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO4_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO4_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO4_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO4_STATUS.Reg, volatile.LoadUint32(&o.GPIO4_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO4_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO4_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO4_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO4_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO4_CTRL.Reg, volatile.LoadUint32(&o.GPIO4_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO4_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO4_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO4_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO4_CTRL.Reg, volatile.LoadUint32(&o.GPIO4_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO4_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO4_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO4_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO4_CTRL.Reg, volatile.LoadUint32(&o.GPIO4_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO4_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO4_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO4_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO4_CTRL.Reg, volatile.LoadUint32(&o.GPIO4_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO4_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO4_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO4_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO4_CTRL.Reg, volatile.LoadUint32(&o.GPIO4_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO4_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO4_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO5_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO5_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO5_STATUS.Reg, volatile.LoadUint32(&o.GPIO5_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO5_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO5_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO5_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO5_STATUS.Reg, volatile.LoadUint32(&o.GPIO5_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO5_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO5_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO5_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO5_STATUS.Reg, volatile.LoadUint32(&o.GPIO5_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO5_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO5_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO5_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO5_STATUS.Reg, volatile.LoadUint32(&o.GPIO5_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO5_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO5_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO5_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO5_STATUS.Reg, volatile.LoadUint32(&o.GPIO5_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO5_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO5_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO5_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO5_STATUS.Reg, volatile.LoadUint32(&o.GPIO5_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO5_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO5_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO5_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO5_STATUS.Reg, volatile.LoadUint32(&o.GPIO5_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO5_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO5_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO5_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO5_STATUS.Reg, volatile.LoadUint32(&o.GPIO5_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO5_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO5_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO5_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO5_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO5_CTRL.Reg, volatile.LoadUint32(&o.GPIO5_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO5_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO5_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO5_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO5_CTRL.Reg, volatile.LoadUint32(&o.GPIO5_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO5_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO5_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO5_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO5_CTRL.Reg, volatile.LoadUint32(&o.GPIO5_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO5_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO5_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO5_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO5_CTRL.Reg, volatile.LoadUint32(&o.GPIO5_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO5_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO5_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO5_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO5_CTRL.Reg, volatile.LoadUint32(&o.GPIO5_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO5_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO5_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO6_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO6_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO6_STATUS.Reg, volatile.LoadUint32(&o.GPIO6_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO6_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO6_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO6_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO6_STATUS.Reg, volatile.LoadUint32(&o.GPIO6_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO6_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO6_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO6_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO6_STATUS.Reg, volatile.LoadUint32(&o.GPIO6_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO6_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO6_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO6_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO6_STATUS.Reg, volatile.LoadUint32(&o.GPIO6_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO6_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO6_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO6_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO6_STATUS.Reg, volatile.LoadUint32(&o.GPIO6_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO6_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO6_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO6_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO6_STATUS.Reg, volatile.LoadUint32(&o.GPIO6_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO6_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO6_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO6_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO6_STATUS.Reg, volatile.LoadUint32(&o.GPIO6_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO6_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO6_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO6_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO6_STATUS.Reg, volatile.LoadUint32(&o.GPIO6_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO6_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO6_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO6_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO6_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO6_CTRL.Reg, volatile.LoadUint32(&o.GPIO6_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO6_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO6_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO6_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO6_CTRL.Reg, volatile.LoadUint32(&o.GPIO6_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO6_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO6_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO6_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO6_CTRL.Reg, volatile.LoadUint32(&o.GPIO6_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO6_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO6_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO6_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO6_CTRL.Reg, volatile.LoadUint32(&o.GPIO6_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO6_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO6_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO6_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO6_CTRL.Reg, volatile.LoadUint32(&o.GPIO6_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO6_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO6_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO7_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO7_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO7_STATUS.Reg, volatile.LoadUint32(&o.GPIO7_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO7_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO7_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO7_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO7_STATUS.Reg, volatile.LoadUint32(&o.GPIO7_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO7_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO7_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO7_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO7_STATUS.Reg, volatile.LoadUint32(&o.GPIO7_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO7_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO7_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO7_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO7_STATUS.Reg, volatile.LoadUint32(&o.GPIO7_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO7_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO7_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO7_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO7_STATUS.Reg, volatile.LoadUint32(&o.GPIO7_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO7_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO7_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO7_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO7_STATUS.Reg, volatile.LoadUint32(&o.GPIO7_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO7_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO7_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO7_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO7_STATUS.Reg, volatile.LoadUint32(&o.GPIO7_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO7_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO7_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO7_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO7_STATUS.Reg, volatile.LoadUint32(&o.GPIO7_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO7_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO7_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO7_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO7_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO7_CTRL.Reg, volatile.LoadUint32(&o.GPIO7_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO7_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO7_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO7_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO7_CTRL.Reg, volatile.LoadUint32(&o.GPIO7_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO7_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO7_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO7_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO7_CTRL.Reg, volatile.LoadUint32(&o.GPIO7_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO7_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO7_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO7_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO7_CTRL.Reg, volatile.LoadUint32(&o.GPIO7_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO7_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO7_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO7_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO7_CTRL.Reg, volatile.LoadUint32(&o.GPIO7_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO7_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO7_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO8_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO8_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO8_STATUS.Reg, volatile.LoadUint32(&o.GPIO8_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO8_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO8_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO8_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO8_STATUS.Reg, volatile.LoadUint32(&o.GPIO8_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO8_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO8_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO8_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO8_STATUS.Reg, volatile.LoadUint32(&o.GPIO8_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO8_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO8_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO8_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO8_STATUS.Reg, volatile.LoadUint32(&o.GPIO8_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO8_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO8_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO8_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO8_STATUS.Reg, volatile.LoadUint32(&o.GPIO8_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO8_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO8_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO8_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO8_STATUS.Reg, volatile.LoadUint32(&o.GPIO8_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO8_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO8_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO8_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO8_STATUS.Reg, volatile.LoadUint32(&o.GPIO8_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO8_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO8_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO8_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO8_STATUS.Reg, volatile.LoadUint32(&o.GPIO8_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO8_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO8_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO8_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO8_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO8_CTRL.Reg, volatile.LoadUint32(&o.GPIO8_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO8_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO8_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO8_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO8_CTRL.Reg, volatile.LoadUint32(&o.GPIO8_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO8_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO8_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO8_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO8_CTRL.Reg, volatile.LoadUint32(&o.GPIO8_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO8_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO8_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO8_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO8_CTRL.Reg, volatile.LoadUint32(&o.GPIO8_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO8_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO8_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO8_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO8_CTRL.Reg, volatile.LoadUint32(&o.GPIO8_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO8_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO8_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO9_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO9_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO9_STATUS.Reg, volatile.LoadUint32(&o.GPIO9_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO9_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO9_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO9_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO9_STATUS.Reg, volatile.LoadUint32(&o.GPIO9_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO9_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO9_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO9_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO9_STATUS.Reg, volatile.LoadUint32(&o.GPIO9_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO9_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO9_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO9_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO9_STATUS.Reg, volatile.LoadUint32(&o.GPIO9_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO9_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO9_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO9_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO9_STATUS.Reg, volatile.LoadUint32(&o.GPIO9_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO9_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO9_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO9_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO9_STATUS.Reg, volatile.LoadUint32(&o.GPIO9_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO9_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO9_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO9_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO9_STATUS.Reg, volatile.LoadUint32(&o.GPIO9_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO9_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO9_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO9_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO9_STATUS.Reg, volatile.LoadUint32(&o.GPIO9_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO9_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO9_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO9_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO9_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO9_CTRL.Reg, volatile.LoadUint32(&o.GPIO9_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO9_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO9_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO9_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO9_CTRL.Reg, volatile.LoadUint32(&o.GPIO9_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO9_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO9_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO9_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO9_CTRL.Reg, volatile.LoadUint32(&o.GPIO9_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO9_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO9_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO9_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO9_CTRL.Reg, volatile.LoadUint32(&o.GPIO9_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO9_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO9_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO9_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO9_CTRL.Reg, volatile.LoadUint32(&o.GPIO9_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO9_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO9_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO10_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO10_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO10_STATUS.Reg, volatile.LoadUint32(&o.GPIO10_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO10_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO10_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO10_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO10_STATUS.Reg, volatile.LoadUint32(&o.GPIO10_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO10_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO10_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO10_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO10_STATUS.Reg, volatile.LoadUint32(&o.GPIO10_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO10_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO10_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO10_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO10_STATUS.Reg, volatile.LoadUint32(&o.GPIO10_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO10_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO10_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO10_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO10_STATUS.Reg, volatile.LoadUint32(&o.GPIO10_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO10_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO10_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO10_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO10_STATUS.Reg, volatile.LoadUint32(&o.GPIO10_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO10_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO10_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO10_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO10_STATUS.Reg, volatile.LoadUint32(&o.GPIO10_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO10_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO10_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO10_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO10_STATUS.Reg, volatile.LoadUint32(&o.GPIO10_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO10_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO10_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO10_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO10_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO10_CTRL.Reg, volatile.LoadUint32(&o.GPIO10_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO10_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO10_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO10_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO10_CTRL.Reg, volatile.LoadUint32(&o.GPIO10_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO10_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO10_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO10_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO10_CTRL.Reg, volatile.LoadUint32(&o.GPIO10_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO10_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO10_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO10_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO10_CTRL.Reg, volatile.LoadUint32(&o.GPIO10_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO10_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO10_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO10_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO10_CTRL.Reg, volatile.LoadUint32(&o.GPIO10_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO10_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO10_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO11_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO11_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO11_STATUS.Reg, volatile.LoadUint32(&o.GPIO11_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO11_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO11_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO11_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO11_STATUS.Reg, volatile.LoadUint32(&o.GPIO11_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO11_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO11_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO11_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO11_STATUS.Reg, volatile.LoadUint32(&o.GPIO11_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO11_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO11_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO11_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO11_STATUS.Reg, volatile.LoadUint32(&o.GPIO11_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO11_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO11_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO11_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO11_STATUS.Reg, volatile.LoadUint32(&o.GPIO11_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO11_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO11_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO11_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO11_STATUS.Reg, volatile.LoadUint32(&o.GPIO11_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO11_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO11_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO11_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO11_STATUS.Reg, volatile.LoadUint32(&o.GPIO11_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO11_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO11_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO11_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO11_STATUS.Reg, volatile.LoadUint32(&o.GPIO11_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO11_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO11_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO11_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO11_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO11_CTRL.Reg, volatile.LoadUint32(&o.GPIO11_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO11_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO11_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO11_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO11_CTRL.Reg, volatile.LoadUint32(&o.GPIO11_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO11_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO11_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO11_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO11_CTRL.Reg, volatile.LoadUint32(&o.GPIO11_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO11_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO11_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO11_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO11_CTRL.Reg, volatile.LoadUint32(&o.GPIO11_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO11_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO11_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO11_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO11_CTRL.Reg, volatile.LoadUint32(&o.GPIO11_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO11_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO11_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO12_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO12_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO12_STATUS.Reg, volatile.LoadUint32(&o.GPIO12_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO12_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO12_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO12_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO12_STATUS.Reg, volatile.LoadUint32(&o.GPIO12_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO12_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO12_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO12_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO12_STATUS.Reg, volatile.LoadUint32(&o.GPIO12_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO12_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO12_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO12_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO12_STATUS.Reg, volatile.LoadUint32(&o.GPIO12_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO12_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO12_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO12_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO12_STATUS.Reg, volatile.LoadUint32(&o.GPIO12_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO12_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO12_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO12_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO12_STATUS.Reg, volatile.LoadUint32(&o.GPIO12_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO12_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO12_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO12_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO12_STATUS.Reg, volatile.LoadUint32(&o.GPIO12_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO12_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO12_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO12_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO12_STATUS.Reg, volatile.LoadUint32(&o.GPIO12_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO12_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO12_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO12_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO12_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO12_CTRL.Reg, volatile.LoadUint32(&o.GPIO12_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO12_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO12_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO12_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO12_CTRL.Reg, volatile.LoadUint32(&o.GPIO12_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO12_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO12_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO12_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO12_CTRL.Reg, volatile.LoadUint32(&o.GPIO12_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO12_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO12_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO12_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO12_CTRL.Reg, volatile.LoadUint32(&o.GPIO12_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO12_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO12_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO12_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO12_CTRL.Reg, volatile.LoadUint32(&o.GPIO12_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO12_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO12_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO13_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO13_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO13_STATUS.Reg, volatile.LoadUint32(&o.GPIO13_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO13_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO13_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO13_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO13_STATUS.Reg, volatile.LoadUint32(&o.GPIO13_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO13_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO13_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO13_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO13_STATUS.Reg, volatile.LoadUint32(&o.GPIO13_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO13_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO13_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO13_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO13_STATUS.Reg, volatile.LoadUint32(&o.GPIO13_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO13_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO13_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO13_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO13_STATUS.Reg, volatile.LoadUint32(&o.GPIO13_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO13_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO13_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO13_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO13_STATUS.Reg, volatile.LoadUint32(&o.GPIO13_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO13_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO13_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO13_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO13_STATUS.Reg, volatile.LoadUint32(&o.GPIO13_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO13_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO13_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO13_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO13_STATUS.Reg, volatile.LoadUint32(&o.GPIO13_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO13_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO13_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO13_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO13_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO13_CTRL.Reg, volatile.LoadUint32(&o.GPIO13_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO13_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO13_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO13_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO13_CTRL.Reg, volatile.LoadUint32(&o.GPIO13_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO13_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO13_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO13_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO13_CTRL.Reg, volatile.LoadUint32(&o.GPIO13_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO13_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO13_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO13_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO13_CTRL.Reg, volatile.LoadUint32(&o.GPIO13_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO13_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO13_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO13_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO13_CTRL.Reg, volatile.LoadUint32(&o.GPIO13_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO13_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO13_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO14_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO14_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO14_STATUS.Reg, volatile.LoadUint32(&o.GPIO14_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO14_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO14_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO14_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO14_STATUS.Reg, volatile.LoadUint32(&o.GPIO14_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO14_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO14_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO14_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO14_STATUS.Reg, volatile.LoadUint32(&o.GPIO14_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO14_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO14_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO14_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO14_STATUS.Reg, volatile.LoadUint32(&o.GPIO14_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO14_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO14_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO14_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO14_STATUS.Reg, volatile.LoadUint32(&o.GPIO14_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO14_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO14_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO14_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO14_STATUS.Reg, volatile.LoadUint32(&o.GPIO14_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO14_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO14_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO14_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO14_STATUS.Reg, volatile.LoadUint32(&o.GPIO14_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO14_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO14_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO14_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO14_STATUS.Reg, volatile.LoadUint32(&o.GPIO14_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO14_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO14_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO14_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO14_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO14_CTRL.Reg, volatile.LoadUint32(&o.GPIO14_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO14_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO14_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO14_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO14_CTRL.Reg, volatile.LoadUint32(&o.GPIO14_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO14_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO14_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO14_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO14_CTRL.Reg, volatile.LoadUint32(&o.GPIO14_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO14_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO14_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO14_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO14_CTRL.Reg, volatile.LoadUint32(&o.GPIO14_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO14_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO14_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO14_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO14_CTRL.Reg, volatile.LoadUint32(&o.GPIO14_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO14_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO14_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO15_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO15_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO15_STATUS.Reg, volatile.LoadUint32(&o.GPIO15_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO15_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO15_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO15_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO15_STATUS.Reg, volatile.LoadUint32(&o.GPIO15_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO15_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO15_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO15_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO15_STATUS.Reg, volatile.LoadUint32(&o.GPIO15_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO15_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO15_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO15_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO15_STATUS.Reg, volatile.LoadUint32(&o.GPIO15_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO15_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO15_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO15_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO15_STATUS.Reg, volatile.LoadUint32(&o.GPIO15_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO15_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO15_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO15_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO15_STATUS.Reg, volatile.LoadUint32(&o.GPIO15_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO15_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO15_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO15_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO15_STATUS.Reg, volatile.LoadUint32(&o.GPIO15_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO15_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO15_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO15_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO15_STATUS.Reg, volatile.LoadUint32(&o.GPIO15_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO15_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO15_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO15_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO15_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO15_CTRL.Reg, volatile.LoadUint32(&o.GPIO15_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO15_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO15_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO15_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO15_CTRL.Reg, volatile.LoadUint32(&o.GPIO15_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO15_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO15_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO15_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO15_CTRL.Reg, volatile.LoadUint32(&o.GPIO15_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO15_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO15_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO15_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO15_CTRL.Reg, volatile.LoadUint32(&o.GPIO15_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO15_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO15_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO15_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO15_CTRL.Reg, volatile.LoadUint32(&o.GPIO15_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO15_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO15_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO16_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO16_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO16_STATUS.Reg, volatile.LoadUint32(&o.GPIO16_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO16_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO16_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO16_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO16_STATUS.Reg, volatile.LoadUint32(&o.GPIO16_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO16_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO16_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO16_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO16_STATUS.Reg, volatile.LoadUint32(&o.GPIO16_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO16_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO16_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO16_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO16_STATUS.Reg, volatile.LoadUint32(&o.GPIO16_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO16_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO16_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO16_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO16_STATUS.Reg, volatile.LoadUint32(&o.GPIO16_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO16_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO16_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO16_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO16_STATUS.Reg, volatile.LoadUint32(&o.GPIO16_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO16_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO16_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO16_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO16_STATUS.Reg, volatile.LoadUint32(&o.GPIO16_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO16_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO16_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO16_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO16_STATUS.Reg, volatile.LoadUint32(&o.GPIO16_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO16_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO16_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO16_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO16_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO16_CTRL.Reg, volatile.LoadUint32(&o.GPIO16_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO16_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO16_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO16_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO16_CTRL.Reg, volatile.LoadUint32(&o.GPIO16_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO16_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO16_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO16_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO16_CTRL.Reg, volatile.LoadUint32(&o.GPIO16_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO16_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO16_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO16_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO16_CTRL.Reg, volatile.LoadUint32(&o.GPIO16_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO16_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO16_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO16_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO16_CTRL.Reg, volatile.LoadUint32(&o.GPIO16_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO16_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO16_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO17_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO17_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO17_STATUS.Reg, volatile.LoadUint32(&o.GPIO17_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO17_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO17_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO17_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO17_STATUS.Reg, volatile.LoadUint32(&o.GPIO17_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO17_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO17_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO17_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO17_STATUS.Reg, volatile.LoadUint32(&o.GPIO17_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO17_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO17_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO17_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO17_STATUS.Reg, volatile.LoadUint32(&o.GPIO17_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO17_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO17_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO17_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO17_STATUS.Reg, volatile.LoadUint32(&o.GPIO17_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO17_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO17_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO17_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO17_STATUS.Reg, volatile.LoadUint32(&o.GPIO17_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO17_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO17_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO17_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO17_STATUS.Reg, volatile.LoadUint32(&o.GPIO17_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO17_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO17_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO17_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO17_STATUS.Reg, volatile.LoadUint32(&o.GPIO17_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO17_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO17_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO17_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO17_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO17_CTRL.Reg, volatile.LoadUint32(&o.GPIO17_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO17_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO17_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO17_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO17_CTRL.Reg, volatile.LoadUint32(&o.GPIO17_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO17_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO17_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO17_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO17_CTRL.Reg, volatile.LoadUint32(&o.GPIO17_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO17_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO17_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO17_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO17_CTRL.Reg, volatile.LoadUint32(&o.GPIO17_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO17_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO17_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO17_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO17_CTRL.Reg, volatile.LoadUint32(&o.GPIO17_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO17_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO17_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO18_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO18_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO18_STATUS.Reg, volatile.LoadUint32(&o.GPIO18_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO18_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO18_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO18_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO18_STATUS.Reg, volatile.LoadUint32(&o.GPIO18_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO18_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO18_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO18_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO18_STATUS.Reg, volatile.LoadUint32(&o.GPIO18_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO18_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO18_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO18_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO18_STATUS.Reg, volatile.LoadUint32(&o.GPIO18_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO18_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO18_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO18_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO18_STATUS.Reg, volatile.LoadUint32(&o.GPIO18_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO18_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO18_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO18_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO18_STATUS.Reg, volatile.LoadUint32(&o.GPIO18_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO18_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO18_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO18_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO18_STATUS.Reg, volatile.LoadUint32(&o.GPIO18_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO18_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO18_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO18_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO18_STATUS.Reg, volatile.LoadUint32(&o.GPIO18_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO18_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO18_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO18_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO18_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO18_CTRL.Reg, volatile.LoadUint32(&o.GPIO18_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO18_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO18_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO18_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO18_CTRL.Reg, volatile.LoadUint32(&o.GPIO18_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO18_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO18_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO18_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO18_CTRL.Reg, volatile.LoadUint32(&o.GPIO18_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO18_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO18_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO18_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO18_CTRL.Reg, volatile.LoadUint32(&o.GPIO18_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO18_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO18_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO18_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO18_CTRL.Reg, volatile.LoadUint32(&o.GPIO18_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO18_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO18_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO19_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO19_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO19_STATUS.Reg, volatile.LoadUint32(&o.GPIO19_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO19_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO19_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO19_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO19_STATUS.Reg, volatile.LoadUint32(&o.GPIO19_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO19_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO19_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO19_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO19_STATUS.Reg, volatile.LoadUint32(&o.GPIO19_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO19_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO19_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO19_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO19_STATUS.Reg, volatile.LoadUint32(&o.GPIO19_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO19_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO19_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO19_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO19_STATUS.Reg, volatile.LoadUint32(&o.GPIO19_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO19_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO19_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO19_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO19_STATUS.Reg, volatile.LoadUint32(&o.GPIO19_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO19_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO19_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO19_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO19_STATUS.Reg, volatile.LoadUint32(&o.GPIO19_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO19_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO19_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO19_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO19_STATUS.Reg, volatile.LoadUint32(&o.GPIO19_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO19_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO19_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO19_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO19_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO19_CTRL.Reg, volatile.LoadUint32(&o.GPIO19_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO19_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO19_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO19_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO19_CTRL.Reg, volatile.LoadUint32(&o.GPIO19_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO19_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO19_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO19_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO19_CTRL.Reg, volatile.LoadUint32(&o.GPIO19_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO19_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO19_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO19_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO19_CTRL.Reg, volatile.LoadUint32(&o.GPIO19_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO19_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO19_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO19_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO19_CTRL.Reg, volatile.LoadUint32(&o.GPIO19_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO19_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO19_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO20_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO20_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO20_STATUS.Reg, volatile.LoadUint32(&o.GPIO20_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO20_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO20_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO20_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO20_STATUS.Reg, volatile.LoadUint32(&o.GPIO20_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO20_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO20_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO20_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO20_STATUS.Reg, volatile.LoadUint32(&o.GPIO20_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO20_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO20_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO20_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO20_STATUS.Reg, volatile.LoadUint32(&o.GPIO20_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO20_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO20_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO20_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO20_STATUS.Reg, volatile.LoadUint32(&o.GPIO20_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO20_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO20_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO20_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO20_STATUS.Reg, volatile.LoadUint32(&o.GPIO20_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO20_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO20_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO20_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO20_STATUS.Reg, volatile.LoadUint32(&o.GPIO20_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO20_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO20_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO20_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO20_STATUS.Reg, volatile.LoadUint32(&o.GPIO20_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO20_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO20_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO20_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO20_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO20_CTRL.Reg, volatile.LoadUint32(&o.GPIO20_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO20_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO20_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO20_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO20_CTRL.Reg, volatile.LoadUint32(&o.GPIO20_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO20_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO20_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO20_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO20_CTRL.Reg, volatile.LoadUint32(&o.GPIO20_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO20_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO20_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO20_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO20_CTRL.Reg, volatile.LoadUint32(&o.GPIO20_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO20_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO20_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO20_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO20_CTRL.Reg, volatile.LoadUint32(&o.GPIO20_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO20_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO20_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO21_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO21_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO21_STATUS.Reg, volatile.LoadUint32(&o.GPIO21_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO21_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO21_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO21_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO21_STATUS.Reg, volatile.LoadUint32(&o.GPIO21_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO21_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO21_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO21_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO21_STATUS.Reg, volatile.LoadUint32(&o.GPIO21_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO21_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO21_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO21_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO21_STATUS.Reg, volatile.LoadUint32(&o.GPIO21_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO21_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO21_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO21_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO21_STATUS.Reg, volatile.LoadUint32(&o.GPIO21_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO21_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO21_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO21_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO21_STATUS.Reg, volatile.LoadUint32(&o.GPIO21_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO21_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO21_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO21_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO21_STATUS.Reg, volatile.LoadUint32(&o.GPIO21_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO21_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO21_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO21_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO21_STATUS.Reg, volatile.LoadUint32(&o.GPIO21_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO21_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO21_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO21_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO21_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO21_CTRL.Reg, volatile.LoadUint32(&o.GPIO21_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO21_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO21_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO21_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO21_CTRL.Reg, volatile.LoadUint32(&o.GPIO21_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO21_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO21_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO21_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO21_CTRL.Reg, volatile.LoadUint32(&o.GPIO21_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO21_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO21_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO21_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO21_CTRL.Reg, volatile.LoadUint32(&o.GPIO21_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO21_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO21_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO21_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO21_CTRL.Reg, volatile.LoadUint32(&o.GPIO21_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO21_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO21_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO22_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO22_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO22_STATUS.Reg, volatile.LoadUint32(&o.GPIO22_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO22_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO22_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO22_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO22_STATUS.Reg, volatile.LoadUint32(&o.GPIO22_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO22_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO22_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO22_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO22_STATUS.Reg, volatile.LoadUint32(&o.GPIO22_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO22_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO22_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO22_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO22_STATUS.Reg, volatile.LoadUint32(&o.GPIO22_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO22_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO22_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO22_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO22_STATUS.Reg, volatile.LoadUint32(&o.GPIO22_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO22_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO22_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO22_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO22_STATUS.Reg, volatile.LoadUint32(&o.GPIO22_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO22_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO22_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO22_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO22_STATUS.Reg, volatile.LoadUint32(&o.GPIO22_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO22_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO22_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO22_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO22_STATUS.Reg, volatile.LoadUint32(&o.GPIO22_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO22_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO22_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO22_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO22_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO22_CTRL.Reg, volatile.LoadUint32(&o.GPIO22_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO22_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO22_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO22_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO22_CTRL.Reg, volatile.LoadUint32(&o.GPIO22_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO22_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO22_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO22_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO22_CTRL.Reg, volatile.LoadUint32(&o.GPIO22_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO22_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO22_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO22_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO22_CTRL.Reg, volatile.LoadUint32(&o.GPIO22_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO22_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO22_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO22_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO22_CTRL.Reg, volatile.LoadUint32(&o.GPIO22_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO22_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO22_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO23_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO23_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO23_STATUS.Reg, volatile.LoadUint32(&o.GPIO23_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO23_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO23_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO23_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO23_STATUS.Reg, volatile.LoadUint32(&o.GPIO23_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO23_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO23_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO23_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO23_STATUS.Reg, volatile.LoadUint32(&o.GPIO23_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO23_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO23_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO23_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO23_STATUS.Reg, volatile.LoadUint32(&o.GPIO23_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO23_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO23_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO23_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO23_STATUS.Reg, volatile.LoadUint32(&o.GPIO23_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO23_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO23_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO23_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO23_STATUS.Reg, volatile.LoadUint32(&o.GPIO23_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO23_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO23_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO23_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO23_STATUS.Reg, volatile.LoadUint32(&o.GPIO23_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO23_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO23_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO23_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO23_STATUS.Reg, volatile.LoadUint32(&o.GPIO23_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO23_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO23_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO23_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO23_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO23_CTRL.Reg, volatile.LoadUint32(&o.GPIO23_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO23_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO23_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO23_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO23_CTRL.Reg, volatile.LoadUint32(&o.GPIO23_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO23_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO23_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO23_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO23_CTRL.Reg, volatile.LoadUint32(&o.GPIO23_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO23_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO23_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO23_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO23_CTRL.Reg, volatile.LoadUint32(&o.GPIO23_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO23_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO23_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO23_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO23_CTRL.Reg, volatile.LoadUint32(&o.GPIO23_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO23_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO23_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO24_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO24_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO24_STATUS.Reg, volatile.LoadUint32(&o.GPIO24_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO24_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO24_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO24_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO24_STATUS.Reg, volatile.LoadUint32(&o.GPIO24_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO24_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO24_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO24_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO24_STATUS.Reg, volatile.LoadUint32(&o.GPIO24_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO24_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO24_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO24_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO24_STATUS.Reg, volatile.LoadUint32(&o.GPIO24_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO24_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO24_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO24_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO24_STATUS.Reg, volatile.LoadUint32(&o.GPIO24_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO24_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO24_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO24_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO24_STATUS.Reg, volatile.LoadUint32(&o.GPIO24_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO24_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO24_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO24_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO24_STATUS.Reg, volatile.LoadUint32(&o.GPIO24_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO24_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO24_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO24_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO24_STATUS.Reg, volatile.LoadUint32(&o.GPIO24_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO24_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO24_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO24_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO24_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO24_CTRL.Reg, volatile.LoadUint32(&o.GPIO24_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO24_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO24_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO24_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO24_CTRL.Reg, volatile.LoadUint32(&o.GPIO24_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO24_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO24_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO24_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO24_CTRL.Reg, volatile.LoadUint32(&o.GPIO24_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO24_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO24_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO24_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO24_CTRL.Reg, volatile.LoadUint32(&o.GPIO24_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO24_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO24_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO24_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO24_CTRL.Reg, volatile.LoadUint32(&o.GPIO24_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO24_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO24_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO25_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO25_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO25_STATUS.Reg, volatile.LoadUint32(&o.GPIO25_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO25_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO25_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO25_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO25_STATUS.Reg, volatile.LoadUint32(&o.GPIO25_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO25_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO25_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO25_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO25_STATUS.Reg, volatile.LoadUint32(&o.GPIO25_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO25_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO25_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO25_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO25_STATUS.Reg, volatile.LoadUint32(&o.GPIO25_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO25_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO25_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO25_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO25_STATUS.Reg, volatile.LoadUint32(&o.GPIO25_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO25_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO25_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO25_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO25_STATUS.Reg, volatile.LoadUint32(&o.GPIO25_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO25_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO25_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO25_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO25_STATUS.Reg, volatile.LoadUint32(&o.GPIO25_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO25_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO25_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO25_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO25_STATUS.Reg, volatile.LoadUint32(&o.GPIO25_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO25_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO25_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO25_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO25_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO25_CTRL.Reg, volatile.LoadUint32(&o.GPIO25_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO25_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO25_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO25_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO25_CTRL.Reg, volatile.LoadUint32(&o.GPIO25_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO25_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO25_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO25_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO25_CTRL.Reg, volatile.LoadUint32(&o.GPIO25_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO25_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO25_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO25_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO25_CTRL.Reg, volatile.LoadUint32(&o.GPIO25_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO25_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO25_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO25_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO25_CTRL.Reg, volatile.LoadUint32(&o.GPIO25_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO25_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO25_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO26_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO26_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO26_STATUS.Reg, volatile.LoadUint32(&o.GPIO26_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO26_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO26_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO26_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO26_STATUS.Reg, volatile.LoadUint32(&o.GPIO26_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO26_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO26_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO26_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO26_STATUS.Reg, volatile.LoadUint32(&o.GPIO26_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO26_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO26_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO26_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO26_STATUS.Reg, volatile.LoadUint32(&o.GPIO26_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO26_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO26_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO26_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO26_STATUS.Reg, volatile.LoadUint32(&o.GPIO26_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO26_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO26_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO26_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO26_STATUS.Reg, volatile.LoadUint32(&o.GPIO26_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO26_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO26_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO26_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO26_STATUS.Reg, volatile.LoadUint32(&o.GPIO26_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO26_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO26_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO26_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO26_STATUS.Reg, volatile.LoadUint32(&o.GPIO26_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO26_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO26_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO26_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO26_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO26_CTRL.Reg, volatile.LoadUint32(&o.GPIO26_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO26_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO26_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO26_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO26_CTRL.Reg, volatile.LoadUint32(&o.GPIO26_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO26_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO26_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO26_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO26_CTRL.Reg, volatile.LoadUint32(&o.GPIO26_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO26_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO26_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO26_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO26_CTRL.Reg, volatile.LoadUint32(&o.GPIO26_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO26_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO26_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO26_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO26_CTRL.Reg, volatile.LoadUint32(&o.GPIO26_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO26_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO26_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO27_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO27_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO27_STATUS.Reg, volatile.LoadUint32(&o.GPIO27_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO27_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO27_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO27_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO27_STATUS.Reg, volatile.LoadUint32(&o.GPIO27_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO27_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO27_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO27_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO27_STATUS.Reg, volatile.LoadUint32(&o.GPIO27_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO27_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO27_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO27_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO27_STATUS.Reg, volatile.LoadUint32(&o.GPIO27_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO27_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO27_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO27_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO27_STATUS.Reg, volatile.LoadUint32(&o.GPIO27_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO27_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO27_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO27_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO27_STATUS.Reg, volatile.LoadUint32(&o.GPIO27_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO27_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO27_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO27_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO27_STATUS.Reg, volatile.LoadUint32(&o.GPIO27_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO27_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO27_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO27_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO27_STATUS.Reg, volatile.LoadUint32(&o.GPIO27_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO27_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO27_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO27_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO27_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO27_CTRL.Reg, volatile.LoadUint32(&o.GPIO27_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO27_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO27_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO27_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO27_CTRL.Reg, volatile.LoadUint32(&o.GPIO27_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO27_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO27_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO27_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO27_CTRL.Reg, volatile.LoadUint32(&o.GPIO27_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO27_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO27_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO27_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO27_CTRL.Reg, volatile.LoadUint32(&o.GPIO27_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO27_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO27_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO27_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO27_CTRL.Reg, volatile.LoadUint32(&o.GPIO27_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO27_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO27_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO28_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO28_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO28_STATUS.Reg, volatile.LoadUint32(&o.GPIO28_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO28_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO28_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO28_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO28_STATUS.Reg, volatile.LoadUint32(&o.GPIO28_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO28_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO28_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO28_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO28_STATUS.Reg, volatile.LoadUint32(&o.GPIO28_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO28_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO28_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO28_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO28_STATUS.Reg, volatile.LoadUint32(&o.GPIO28_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO28_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO28_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO28_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO28_STATUS.Reg, volatile.LoadUint32(&o.GPIO28_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO28_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO28_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO28_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO28_STATUS.Reg, volatile.LoadUint32(&o.GPIO28_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO28_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO28_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO28_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO28_STATUS.Reg, volatile.LoadUint32(&o.GPIO28_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO28_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO28_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO28_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO28_STATUS.Reg, volatile.LoadUint32(&o.GPIO28_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO28_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO28_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO28_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO28_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO28_CTRL.Reg, volatile.LoadUint32(&o.GPIO28_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO28_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO28_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO28_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO28_CTRL.Reg, volatile.LoadUint32(&o.GPIO28_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO28_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO28_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO28_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO28_CTRL.Reg, volatile.LoadUint32(&o.GPIO28_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO28_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO28_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO28_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO28_CTRL.Reg, volatile.LoadUint32(&o.GPIO28_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO28_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO28_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO28_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO28_CTRL.Reg, volatile.LoadUint32(&o.GPIO28_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO28_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO28_CTRL.Reg) & 0x1f
}

// IO_BANK0.GPIO29_STATUS: GPIO status
func (o *IO_BANK0_Type) SetGPIO29_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO29_STATUS.Reg, volatile.LoadUint32(&o.GPIO29_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetGPIO29_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO29_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetGPIO29_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO29_STATUS.Reg, volatile.LoadUint32(&o.GPIO29_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetGPIO29_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO29_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetGPIO29_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO29_STATUS.Reg, volatile.LoadUint32(&o.GPIO29_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetGPIO29_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO29_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetGPIO29_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO29_STATUS.Reg, volatile.LoadUint32(&o.GPIO29_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetGPIO29_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO29_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetGPIO29_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO29_STATUS.Reg, volatile.LoadUint32(&o.GPIO29_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetGPIO29_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO29_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetGPIO29_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO29_STATUS.Reg, volatile.LoadUint32(&o.GPIO29_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO29_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO29_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO29_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO29_STATUS.Reg, volatile.LoadUint32(&o.GPIO29_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetGPIO29_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO29_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetGPIO29_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO29_STATUS.Reg, volatile.LoadUint32(&o.GPIO29_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO29_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO29_STATUS.Reg) & 0x100) >> 8
}

// IO_BANK0.GPIO29_CTRL: GPIO control including function select and overrides.
func (o *IO_BANK0_Type) SetGPIO29_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO29_CTRL.Reg, volatile.LoadUint32(&o.GPIO29_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_BANK0_Type) GetGPIO29_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO29_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_BANK0_Type) SetGPIO29_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO29_CTRL.Reg, volatile.LoadUint32(&o.GPIO29_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_BANK0_Type) GetGPIO29_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO29_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_BANK0_Type) SetGPIO29_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO29_CTRL.Reg, volatile.LoadUint32(&o.GPIO29_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_BANK0_Type) GetGPIO29_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO29_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_BANK0_Type) SetGPIO29_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO29_CTRL.Reg, volatile.LoadUint32(&o.GPIO29_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_BANK0_Type) GetGPIO29_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO29_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_BANK0_Type) SetGPIO29_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO29_CTRL.Reg, volatile.LoadUint32(&o.GPIO29_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_BANK0_Type) GetGPIO29_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO29_CTRL.Reg) & 0x1f
}

// IO_BANK0.INTR0: Raw Interrupts
func (o *IO_BANK0_Type) SetINTR0_GPIO7_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO7_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetINTR0_GPIO7_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO7_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetINTR0_GPIO7_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO7_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetINTR0_GPIO7_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO7_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetINTR0_GPIO6_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO6_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetINTR0_GPIO6_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO6_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetINTR0_GPIO6_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO6_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetINTR0_GPIO6_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO6_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetINTR0_GPIO5_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO5_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetINTR0_GPIO5_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO5_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetINTR0_GPIO5_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO5_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetINTR0_GPIO5_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO5_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetINTR0_GPIO4_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO4_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetINTR0_GPIO4_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO4_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetINTR0_GPIO4_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO4_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetINTR0_GPIO4_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO4_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetINTR0_GPIO3_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO3_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetINTR0_GPIO3_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO3_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetINTR0_GPIO3_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO3_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetINTR0_GPIO3_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO3_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetINTR0_GPIO2_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO2_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetINTR0_GPIO2_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO2_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetINTR0_GPIO2_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO2_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetINTR0_GPIO2_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO2_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetINTR0_GPIO1_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO1_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetINTR0_GPIO1_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO1_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetINTR0_GPIO1_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO1_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetINTR0_GPIO1_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO1_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetINTR0_GPIO0_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO0_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetINTR0_GPIO0_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO0_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetINTR0_GPIO0_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO0_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR0.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetINTR0_GPIO0_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR0.Reg, volatile.LoadUint32(&o.INTR0.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetINTR0_GPIO0_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.INTR0.Reg) & 0x1
}

// IO_BANK0.INTR1: Raw Interrupts
func (o *IO_BANK0_Type) SetINTR1_GPIO15_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO15_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetINTR1_GPIO15_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO15_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetINTR1_GPIO15_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO15_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetINTR1_GPIO15_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO15_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetINTR1_GPIO14_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO14_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetINTR1_GPIO14_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO14_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetINTR1_GPIO14_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO14_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetINTR1_GPIO14_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO14_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetINTR1_GPIO13_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO13_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetINTR1_GPIO13_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO13_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetINTR1_GPIO13_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO13_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetINTR1_GPIO13_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO13_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetINTR1_GPIO12_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO12_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetINTR1_GPIO12_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO12_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetINTR1_GPIO12_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO12_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetINTR1_GPIO12_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO12_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetINTR1_GPIO11_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO11_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetINTR1_GPIO11_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO11_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetINTR1_GPIO11_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO11_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetINTR1_GPIO11_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO11_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetINTR1_GPIO10_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO10_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetINTR1_GPIO10_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO10_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetINTR1_GPIO10_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO10_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetINTR1_GPIO10_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO10_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetINTR1_GPIO9_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO9_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetINTR1_GPIO9_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO9_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetINTR1_GPIO9_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO9_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetINTR1_GPIO9_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO9_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetINTR1_GPIO8_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO8_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetINTR1_GPIO8_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO8_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetINTR1_GPIO8_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO8_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR1.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetINTR1_GPIO8_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR1.Reg, volatile.LoadUint32(&o.INTR1.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetINTR1_GPIO8_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.INTR1.Reg) & 0x1
}

// IO_BANK0.INTR2: Raw Interrupts
func (o *IO_BANK0_Type) SetINTR2_GPIO23_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO23_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetINTR2_GPIO23_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO23_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetINTR2_GPIO23_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO23_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetINTR2_GPIO23_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO23_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetINTR2_GPIO22_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO22_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetINTR2_GPIO22_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO22_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetINTR2_GPIO22_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO22_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetINTR2_GPIO22_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO22_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetINTR2_GPIO21_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO21_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetINTR2_GPIO21_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO21_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetINTR2_GPIO21_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO21_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetINTR2_GPIO21_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO21_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetINTR2_GPIO20_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO20_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetINTR2_GPIO20_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO20_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetINTR2_GPIO20_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO20_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetINTR2_GPIO20_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO20_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetINTR2_GPIO19_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO19_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetINTR2_GPIO19_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO19_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetINTR2_GPIO19_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO19_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetINTR2_GPIO19_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO19_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetINTR2_GPIO18_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO18_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetINTR2_GPIO18_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO18_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetINTR2_GPIO18_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO18_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetINTR2_GPIO18_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO18_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetINTR2_GPIO17_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO17_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetINTR2_GPIO17_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO17_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetINTR2_GPIO17_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO17_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetINTR2_GPIO17_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO17_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetINTR2_GPIO16_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO16_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetINTR2_GPIO16_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO16_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetINTR2_GPIO16_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO16_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR2.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetINTR2_GPIO16_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR2.Reg, volatile.LoadUint32(&o.INTR2.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetINTR2_GPIO16_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.INTR2.Reg) & 0x1
}

// IO_BANK0.INTR3: Raw Interrupts
func (o *IO_BANK0_Type) SetINTR3_GPIO29_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO29_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetINTR3_GPIO29_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO29_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetINTR3_GPIO29_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO29_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetINTR3_GPIO29_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO29_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetINTR3_GPIO28_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO28_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetINTR3_GPIO28_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO28_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetINTR3_GPIO28_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO28_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetINTR3_GPIO28_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO28_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetINTR3_GPIO27_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO27_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetINTR3_GPIO27_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO27_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetINTR3_GPIO27_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO27_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetINTR3_GPIO27_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO27_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetINTR3_GPIO26_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO26_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetINTR3_GPIO26_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO26_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetINTR3_GPIO26_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO26_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetINTR3_GPIO26_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO26_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetINTR3_GPIO25_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO25_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetINTR3_GPIO25_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO25_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetINTR3_GPIO25_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO25_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetINTR3_GPIO25_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO25_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetINTR3_GPIO24_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO24_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetINTR3_GPIO24_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO24_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetINTR3_GPIO24_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO24_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR3.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetINTR3_GPIO24_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR3.Reg, volatile.LoadUint32(&o.INTR3.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetINTR3_GPIO24_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.INTR3.Reg) & 0x1
}

// IO_BANK0.PROC0_INTE0: Interrupt Enable for proc0
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO7_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO7_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO7_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO7_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO7_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO7_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO7_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO7_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO6_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO6_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO6_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO6_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO6_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO6_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO6_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO6_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO5_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO5_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO5_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO5_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO5_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO5_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO5_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO5_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO4_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO4_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO4_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO4_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO4_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO4_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO4_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO4_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO3_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO3_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO3_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO3_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO3_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO3_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO3_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO3_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO2_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO2_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO2_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO2_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO2_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO2_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO2_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO2_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO1_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO1_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO1_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO1_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO1_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO1_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO1_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO1_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO0_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO0_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO0_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO0_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO0_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO0_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC0_INTE0_GPIO0_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE0.Reg, volatile.LoadUint32(&o.PROC0_INTE0.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC0_INTE0_GPIO0_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC0_INTE0.Reg) & 0x1
}

// IO_BANK0.PROC0_INTE1: Interrupt Enable for proc0
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO15_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO15_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO15_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO15_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO15_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO15_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO15_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO15_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO14_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO14_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO14_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO14_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO14_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO14_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO14_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO14_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO13_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO13_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO13_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO13_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO13_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO13_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO13_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO13_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO12_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO12_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO12_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO12_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO12_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO12_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO12_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO12_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO11_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO11_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO11_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO11_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO11_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO11_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO11_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO11_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO10_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO10_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO10_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO10_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO10_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO10_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO10_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO10_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO9_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO9_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO9_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO9_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO9_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO9_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO9_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO9_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO8_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO8_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO8_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO8_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO8_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO8_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC0_INTE1_GPIO8_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE1.Reg, volatile.LoadUint32(&o.PROC0_INTE1.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC0_INTE1_GPIO8_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC0_INTE1.Reg) & 0x1
}

// IO_BANK0.PROC0_INTE2: Interrupt Enable for proc0
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO23_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO23_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO23_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO23_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO23_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO23_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO23_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO23_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO22_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO22_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO22_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO22_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO22_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO22_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO22_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO22_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO21_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO21_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO21_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO21_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO21_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO21_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO21_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO21_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO20_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO20_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO20_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO20_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO20_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO20_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO20_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO20_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO19_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO19_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO19_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO19_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO19_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO19_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO19_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO19_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO18_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO18_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO18_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO18_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO18_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO18_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO18_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO18_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO17_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO17_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO17_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO17_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO17_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO17_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO17_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO17_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO16_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO16_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO16_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO16_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO16_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO16_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC0_INTE2_GPIO16_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE2.Reg, volatile.LoadUint32(&o.PROC0_INTE2.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC0_INTE2_GPIO16_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC0_INTE2.Reg) & 0x1
}

// IO_BANK0.PROC0_INTE3: Interrupt Enable for proc0
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO29_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO29_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO29_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO29_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO29_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO29_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO29_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO29_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO28_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO28_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO28_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO28_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO28_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO28_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO28_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO28_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO27_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO27_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO27_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO27_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO27_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO27_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO27_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO27_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO26_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO26_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO26_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO26_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO26_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO26_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO26_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO26_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO25_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO25_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO25_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO25_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO25_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO25_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO25_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO25_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO24_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO24_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO24_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO24_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO24_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO24_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC0_INTE3_GPIO24_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE3.Reg, volatile.LoadUint32(&o.PROC0_INTE3.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC0_INTE3_GPIO24_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC0_INTE3.Reg) & 0x1
}

// IO_BANK0.PROC0_INTF0: Interrupt Force for proc0
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO7_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO7_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO7_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO7_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO7_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO7_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO7_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO7_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO6_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO6_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO6_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO6_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO6_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO6_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO6_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO6_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO5_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO5_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO5_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO5_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO5_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO5_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO5_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO5_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO4_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO4_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO4_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO4_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO4_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO4_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO4_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO4_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO3_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO3_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO3_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO3_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO3_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO3_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO3_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO3_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO2_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO2_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO2_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO2_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO2_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO2_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO2_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO2_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO1_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO1_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO1_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO1_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO1_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO1_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO1_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO1_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO0_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO0_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO0_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO0_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO0_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO0_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC0_INTF0_GPIO0_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF0.Reg, volatile.LoadUint32(&o.PROC0_INTF0.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC0_INTF0_GPIO0_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC0_INTF0.Reg) & 0x1
}

// IO_BANK0.PROC0_INTF1: Interrupt Force for proc0
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO15_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO15_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO15_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO15_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO15_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO15_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO15_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO15_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO14_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO14_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO14_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO14_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO14_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO14_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO14_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO14_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO13_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO13_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO13_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO13_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO13_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO13_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO13_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO13_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO12_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO12_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO12_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO12_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO12_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO12_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO12_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO12_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO11_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO11_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO11_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO11_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO11_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO11_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO11_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO11_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO10_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO10_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO10_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO10_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO10_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO10_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO10_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO10_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO9_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO9_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO9_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO9_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO9_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO9_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO9_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO9_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO8_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO8_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO8_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO8_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO8_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO8_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC0_INTF1_GPIO8_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF1.Reg, volatile.LoadUint32(&o.PROC0_INTF1.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC0_INTF1_GPIO8_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC0_INTF1.Reg) & 0x1
}

// IO_BANK0.PROC0_INTF2: Interrupt Force for proc0
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO23_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO23_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO23_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO23_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO23_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO23_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO23_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO23_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO22_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO22_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO22_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO22_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO22_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO22_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO22_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO22_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO21_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO21_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO21_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO21_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO21_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO21_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO21_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO21_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO20_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO20_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO20_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO20_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO20_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO20_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO20_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO20_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO19_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO19_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO19_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO19_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO19_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO19_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO19_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO19_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO18_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO18_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO18_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO18_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO18_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO18_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO18_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO18_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO17_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO17_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO17_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO17_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO17_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO17_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO17_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO17_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO16_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO16_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO16_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO16_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO16_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO16_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC0_INTF2_GPIO16_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF2.Reg, volatile.LoadUint32(&o.PROC0_INTF2.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC0_INTF2_GPIO16_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC0_INTF2.Reg) & 0x1
}

// IO_BANK0.PROC0_INTF3: Interrupt Force for proc0
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO29_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO29_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO29_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO29_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO29_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO29_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO29_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO29_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO28_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO28_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO28_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO28_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO28_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO28_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO28_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO28_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO27_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO27_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO27_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO27_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO27_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO27_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO27_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO27_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO26_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO26_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO26_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO26_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO26_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO26_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO26_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO26_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO25_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO25_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO25_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO25_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO25_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO25_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO25_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO25_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO24_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO24_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO24_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO24_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO24_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO24_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC0_INTF3_GPIO24_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF3.Reg, volatile.LoadUint32(&o.PROC0_INTF3.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC0_INTF3_GPIO24_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC0_INTF3.Reg) & 0x1
}

// IO_BANK0.PROC0_INTS0: Interrupt status after masking & forcing for proc0
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO7_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO7_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO7_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO7_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO7_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO7_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO7_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO7_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO6_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO6_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO6_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO6_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO6_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO6_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO6_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO6_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO5_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO5_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO5_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO5_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO5_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO5_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO5_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO5_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO4_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO4_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO4_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO4_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO4_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO4_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO4_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO4_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO3_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO3_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO3_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO3_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO3_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO3_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO3_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO3_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO2_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO2_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO2_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO2_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO2_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO2_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO2_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO2_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO1_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO1_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO1_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO1_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO1_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO1_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO1_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO1_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO0_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO0_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO0_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO0_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO0_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO0_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC0_INTS0_GPIO0_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS0.Reg, volatile.LoadUint32(&o.PROC0_INTS0.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC0_INTS0_GPIO0_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC0_INTS0.Reg) & 0x1
}

// IO_BANK0.PROC0_INTS1: Interrupt status after masking & forcing for proc0
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO15_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO15_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO15_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO15_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO15_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO15_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO15_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO15_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO14_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO14_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO14_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO14_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO14_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO14_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO14_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO14_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO13_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO13_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO13_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO13_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO13_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO13_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO13_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO13_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO12_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO12_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO12_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO12_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO12_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO12_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO12_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO12_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO11_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO11_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO11_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO11_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO11_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO11_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO11_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO11_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO10_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO10_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO10_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO10_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO10_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO10_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO10_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO10_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO9_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO9_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO9_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO9_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO9_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO9_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO9_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO9_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO8_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO8_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO8_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO8_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO8_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO8_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC0_INTS1_GPIO8_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS1.Reg, volatile.LoadUint32(&o.PROC0_INTS1.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC0_INTS1_GPIO8_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC0_INTS1.Reg) & 0x1
}

// IO_BANK0.PROC0_INTS2: Interrupt status after masking & forcing for proc0
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO23_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO23_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO23_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO23_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO23_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO23_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO23_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO23_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO22_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO22_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO22_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO22_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO22_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO22_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO22_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO22_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO21_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO21_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO21_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO21_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO21_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO21_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO21_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO21_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO20_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO20_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO20_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO20_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO20_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO20_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO20_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO20_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO19_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO19_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO19_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO19_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO19_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO19_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO19_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO19_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO18_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO18_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO18_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO18_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO18_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO18_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO18_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO18_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO17_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO17_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO17_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO17_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO17_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO17_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO17_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO17_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO16_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO16_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO16_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO16_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO16_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO16_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC0_INTS2_GPIO16_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS2.Reg, volatile.LoadUint32(&o.PROC0_INTS2.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC0_INTS2_GPIO16_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC0_INTS2.Reg) & 0x1
}

// IO_BANK0.PROC0_INTS3: Interrupt status after masking & forcing for proc0
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO29_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO29_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO29_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO29_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO29_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO29_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO29_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO29_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO28_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO28_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO28_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO28_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO28_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO28_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO28_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO28_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO27_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO27_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO27_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO27_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO27_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO27_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO27_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO27_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO26_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO26_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO26_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO26_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO26_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO26_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO26_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO26_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO25_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO25_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO25_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO25_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO25_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO25_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO25_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO25_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO24_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO24_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO24_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO24_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO24_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO24_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC0_INTS3_GPIO24_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS3.Reg, volatile.LoadUint32(&o.PROC0_INTS3.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC0_INTS3_GPIO24_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC0_INTS3.Reg) & 0x1
}

// IO_BANK0.PROC1_INTE0: Interrupt Enable for proc1
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO7_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO7_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO7_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO7_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO7_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO7_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO7_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO7_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO6_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO6_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO6_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO6_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO6_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO6_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO6_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO6_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO5_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO5_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO5_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO5_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO5_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO5_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO5_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO5_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO4_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO4_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO4_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO4_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO4_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO4_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO4_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO4_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO3_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO3_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO3_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO3_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO3_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO3_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO3_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO3_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO2_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO2_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO2_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO2_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO2_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO2_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO2_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO2_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO1_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO1_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO1_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO1_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO1_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO1_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO1_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO1_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO0_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO0_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO0_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO0_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO0_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO0_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC1_INTE0_GPIO0_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE0.Reg, volatile.LoadUint32(&o.PROC1_INTE0.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC1_INTE0_GPIO0_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC1_INTE0.Reg) & 0x1
}

// IO_BANK0.PROC1_INTE1: Interrupt Enable for proc1
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO15_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO15_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO15_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO15_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO15_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO15_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO15_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO15_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO14_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO14_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO14_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO14_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO14_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO14_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO14_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO14_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO13_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO13_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO13_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO13_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO13_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO13_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO13_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO13_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO12_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO12_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO12_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO12_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO12_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO12_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO12_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO12_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO11_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO11_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO11_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO11_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO11_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO11_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO11_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO11_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO10_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO10_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO10_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO10_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO10_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO10_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO10_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO10_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO9_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO9_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO9_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO9_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO9_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO9_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO9_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO9_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO8_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO8_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO8_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO8_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO8_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO8_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC1_INTE1_GPIO8_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE1.Reg, volatile.LoadUint32(&o.PROC1_INTE1.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC1_INTE1_GPIO8_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC1_INTE1.Reg) & 0x1
}

// IO_BANK0.PROC1_INTE2: Interrupt Enable for proc1
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO23_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO23_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO23_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO23_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO23_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO23_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO23_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO23_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO22_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO22_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO22_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO22_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO22_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO22_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO22_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO22_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO21_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO21_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO21_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO21_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO21_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO21_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO21_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO21_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO20_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO20_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO20_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO20_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO20_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO20_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO20_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO20_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO19_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO19_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO19_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO19_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO19_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO19_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO19_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO19_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO18_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO18_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO18_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO18_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO18_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO18_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO18_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO18_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO17_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO17_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO17_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO17_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO17_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO17_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO17_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO17_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO16_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO16_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO16_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO16_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO16_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO16_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC1_INTE2_GPIO16_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE2.Reg, volatile.LoadUint32(&o.PROC1_INTE2.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC1_INTE2_GPIO16_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC1_INTE2.Reg) & 0x1
}

// IO_BANK0.PROC1_INTE3: Interrupt Enable for proc1
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO29_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO29_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO29_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO29_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO29_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO29_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO29_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO29_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO28_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO28_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO28_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO28_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO28_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO28_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO28_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO28_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO27_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO27_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO27_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO27_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO27_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO27_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO27_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO27_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO26_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO26_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO26_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO26_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO26_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO26_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO26_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO26_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO25_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO25_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO25_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO25_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO25_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO25_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO25_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO25_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO24_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO24_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO24_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO24_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO24_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO24_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC1_INTE3_GPIO24_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE3.Reg, volatile.LoadUint32(&o.PROC1_INTE3.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC1_INTE3_GPIO24_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC1_INTE3.Reg) & 0x1
}

// IO_BANK0.PROC1_INTF0: Interrupt Force for proc1
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO7_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO7_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO7_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO7_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO7_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO7_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO7_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO7_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO6_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO6_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO6_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO6_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO6_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO6_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO6_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO6_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO5_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO5_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO5_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO5_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO5_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO5_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO5_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO5_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO4_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO4_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO4_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO4_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO4_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO4_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO4_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO4_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO3_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO3_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO3_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO3_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO3_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO3_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO3_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO3_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO2_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO2_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO2_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO2_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO2_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO2_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO2_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO2_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO1_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO1_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO1_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO1_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO1_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO1_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO1_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO1_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO0_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO0_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO0_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO0_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO0_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO0_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC1_INTF0_GPIO0_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF0.Reg, volatile.LoadUint32(&o.PROC1_INTF0.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC1_INTF0_GPIO0_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC1_INTF0.Reg) & 0x1
}

// IO_BANK0.PROC1_INTF1: Interrupt Force for proc1
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO15_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO15_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO15_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO15_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO15_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO15_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO15_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO15_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO14_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO14_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO14_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO14_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO14_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO14_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO14_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO14_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO13_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO13_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO13_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO13_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO13_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO13_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO13_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO13_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO12_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO12_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO12_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO12_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO12_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO12_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO12_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO12_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO11_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO11_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO11_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO11_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO11_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO11_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO11_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO11_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO10_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO10_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO10_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO10_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO10_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO10_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO10_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO10_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO9_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO9_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO9_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO9_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO9_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO9_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO9_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO9_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO8_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO8_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO8_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO8_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO8_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO8_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC1_INTF1_GPIO8_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF1.Reg, volatile.LoadUint32(&o.PROC1_INTF1.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC1_INTF1_GPIO8_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC1_INTF1.Reg) & 0x1
}

// IO_BANK0.PROC1_INTF2: Interrupt Force for proc1
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO23_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO23_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO23_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO23_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO23_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO23_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO23_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO23_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO22_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO22_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO22_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO22_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO22_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO22_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO22_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO22_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO21_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO21_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO21_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO21_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO21_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO21_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO21_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO21_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO20_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO20_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO20_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO20_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO20_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO20_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO20_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO20_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO19_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO19_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO19_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO19_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO19_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO19_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO19_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO19_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO18_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO18_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO18_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO18_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO18_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO18_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO18_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO18_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO17_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO17_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO17_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO17_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO17_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO17_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO17_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO17_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO16_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO16_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO16_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO16_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO16_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO16_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC1_INTF2_GPIO16_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF2.Reg, volatile.LoadUint32(&o.PROC1_INTF2.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC1_INTF2_GPIO16_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC1_INTF2.Reg) & 0x1
}

// IO_BANK0.PROC1_INTF3: Interrupt Force for proc1
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO29_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO29_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO29_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO29_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO29_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO29_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO29_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO29_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO28_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO28_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO28_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO28_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO28_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO28_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO28_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO28_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO27_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO27_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO27_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO27_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO27_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO27_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO27_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO27_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO26_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO26_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO26_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO26_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO26_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO26_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO26_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO26_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO25_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO25_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO25_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO25_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO25_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO25_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO25_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO25_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO24_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO24_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO24_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO24_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO24_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO24_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC1_INTF3_GPIO24_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF3.Reg, volatile.LoadUint32(&o.PROC1_INTF3.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC1_INTF3_GPIO24_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC1_INTF3.Reg) & 0x1
}

// IO_BANK0.PROC1_INTS0: Interrupt status after masking & forcing for proc1
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO7_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO7_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO7_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO7_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO7_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO7_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO7_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO7_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO6_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO6_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO6_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO6_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO6_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO6_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO6_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO6_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO5_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO5_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO5_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO5_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO5_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO5_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO5_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO5_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO4_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO4_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO4_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO4_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO4_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO4_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO4_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO4_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO3_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO3_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO3_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO3_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO3_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO3_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO3_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO3_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO2_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO2_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO2_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO2_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO2_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO2_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO2_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO2_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO1_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO1_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO1_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO1_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO1_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO1_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO1_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO1_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO0_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO0_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO0_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO0_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO0_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO0_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC1_INTS0_GPIO0_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS0.Reg, volatile.LoadUint32(&o.PROC1_INTS0.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC1_INTS0_GPIO0_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC1_INTS0.Reg) & 0x1
}

// IO_BANK0.PROC1_INTS1: Interrupt status after masking & forcing for proc1
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO15_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO15_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO15_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO15_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO15_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO15_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO15_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO15_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO14_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO14_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO14_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO14_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO14_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO14_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO14_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO14_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO13_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO13_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO13_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO13_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO13_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO13_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO13_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO13_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO12_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO12_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO12_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO12_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO12_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO12_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO12_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO12_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO11_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO11_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO11_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO11_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO11_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO11_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO11_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO11_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO10_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO10_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO10_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO10_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO10_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO10_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO10_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO10_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO9_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO9_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO9_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO9_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO9_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO9_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO9_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO9_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO8_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO8_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO8_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO8_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO8_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO8_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC1_INTS1_GPIO8_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS1.Reg, volatile.LoadUint32(&o.PROC1_INTS1.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC1_INTS1_GPIO8_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC1_INTS1.Reg) & 0x1
}

// IO_BANK0.PROC1_INTS2: Interrupt status after masking & forcing for proc1
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO23_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO23_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO23_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO23_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO23_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO23_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO23_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO23_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO22_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO22_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO22_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO22_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO22_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO22_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO22_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO22_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO21_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO21_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO21_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO21_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO21_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO21_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO21_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO21_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO20_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO20_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO20_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO20_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO20_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO20_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO20_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO20_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO19_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO19_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO19_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO19_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO19_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO19_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO19_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO19_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO18_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO18_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO18_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO18_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO18_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO18_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO18_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO18_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO17_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO17_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO17_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO17_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO17_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO17_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO17_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO17_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO16_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO16_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO16_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO16_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO16_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO16_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC1_INTS2_GPIO16_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS2.Reg, volatile.LoadUint32(&o.PROC1_INTS2.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC1_INTS2_GPIO16_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC1_INTS2.Reg) & 0x1
}

// IO_BANK0.PROC1_INTS3: Interrupt status after masking & forcing for proc1
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO29_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO29_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO29_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO29_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO29_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO29_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO29_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO29_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO28_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO28_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO28_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO28_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO28_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO28_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO28_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO28_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO27_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO27_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO27_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO27_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO27_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO27_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO27_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO27_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO26_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO26_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO26_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO26_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO26_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO26_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO26_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO26_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO25_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO25_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO25_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO25_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO25_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO25_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO25_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO25_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO24_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO24_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO24_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO24_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO24_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO24_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetPROC1_INTS3_GPIO24_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS3.Reg, volatile.LoadUint32(&o.PROC1_INTS3.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetPROC1_INTS3_GPIO24_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC1_INTS3.Reg) & 0x1
}

// IO_BANK0.DORMANT_WAKE_INTE0: Interrupt Enable for dormant_wake
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO7_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO7_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO7_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO7_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO7_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO7_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO7_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO7_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO6_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO6_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO6_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO6_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO6_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO6_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO6_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO6_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO5_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO5_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO5_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO5_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO5_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO5_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO5_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO5_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO4_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO4_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO4_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO4_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO4_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO4_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO4_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO4_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO3_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO3_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO3_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO3_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO3_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO3_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO3_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO3_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO2_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO2_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO2_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO2_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO2_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO2_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO2_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO2_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO1_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO1_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO1_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO1_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO1_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO1_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO1_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO1_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO0_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO0_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO0_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO0_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO0_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO0_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE0_GPIO0_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE0_GPIO0_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.DORMANT_WAKE_INTE0.Reg) & 0x1
}

// IO_BANK0.DORMANT_WAKE_INTE1: Interrupt Enable for dormant_wake
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO15_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO15_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO15_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO15_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO15_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO15_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO15_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO15_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO14_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO14_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO14_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO14_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO14_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO14_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO14_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO14_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO13_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO13_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO13_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO13_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO13_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO13_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO13_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO13_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO12_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO12_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO12_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO12_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO12_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO12_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO12_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO12_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO11_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO11_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO11_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO11_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO11_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO11_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO11_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO11_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO10_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO10_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO10_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO10_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO10_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO10_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO10_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO10_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO9_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO9_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO9_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO9_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO9_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO9_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO9_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO9_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO8_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO8_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO8_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO8_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO8_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO8_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE1_GPIO8_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE1_GPIO8_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.DORMANT_WAKE_INTE1.Reg) & 0x1
}

// IO_BANK0.DORMANT_WAKE_INTE2: Interrupt Enable for dormant_wake
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO23_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO23_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO23_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO23_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO23_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO23_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO23_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO23_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO22_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO22_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO22_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO22_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO22_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO22_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO22_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO22_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO21_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO21_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO21_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO21_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO21_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO21_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO21_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO21_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO20_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO20_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO20_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO20_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO20_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO20_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO20_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO20_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO19_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO19_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO19_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO19_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO19_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO19_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO19_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO19_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO18_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO18_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO18_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO18_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO18_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO18_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO18_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO18_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO17_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO17_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO17_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO17_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO17_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO17_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO17_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO17_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO16_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO16_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO16_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO16_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO16_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO16_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE2_GPIO16_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE2_GPIO16_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.DORMANT_WAKE_INTE2.Reg) & 0x1
}

// IO_BANK0.DORMANT_WAKE_INTE3: Interrupt Enable for dormant_wake
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO29_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO29_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO29_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO29_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO29_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO29_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO29_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO29_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO28_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO28_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO28_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO28_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO28_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO28_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO28_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO28_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO27_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO27_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO27_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO27_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO27_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO27_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO27_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO27_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO26_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO26_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO26_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO26_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO26_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO26_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO26_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO26_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO25_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO25_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO25_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO25_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO25_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO25_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO25_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO25_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO24_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO24_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO24_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO24_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO24_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO24_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTE3_GPIO24_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTE3_GPIO24_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.DORMANT_WAKE_INTE3.Reg) & 0x1
}

// IO_BANK0.DORMANT_WAKE_INTF0: Interrupt Force for dormant_wake
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO7_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO7_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO7_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO7_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO7_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO7_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO7_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO7_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO6_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO6_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO6_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO6_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO6_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO6_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO6_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO6_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO5_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO5_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO5_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO5_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO5_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO5_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO5_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO5_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO4_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO4_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO4_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO4_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO4_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO4_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO4_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO4_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO3_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO3_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO3_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO3_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO3_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO3_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO3_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO3_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO2_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO2_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO2_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO2_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO2_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO2_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO2_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO2_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO1_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO1_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO1_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO1_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO1_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO1_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO1_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO1_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO0_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO0_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO0_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO0_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO0_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO0_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF0_GPIO0_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF0_GPIO0_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.DORMANT_WAKE_INTF0.Reg) & 0x1
}

// IO_BANK0.DORMANT_WAKE_INTF1: Interrupt Force for dormant_wake
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO15_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO15_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO15_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO15_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO15_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO15_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO15_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO15_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO14_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO14_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO14_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO14_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO14_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO14_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO14_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO14_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO13_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO13_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO13_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO13_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO13_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO13_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO13_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO13_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO12_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO12_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO12_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO12_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO12_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO12_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO12_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO12_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO11_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO11_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO11_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO11_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO11_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO11_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO11_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO11_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO10_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO10_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO10_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO10_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO10_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO10_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO10_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO10_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO9_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO9_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO9_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO9_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO9_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO9_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO9_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO9_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO8_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO8_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO8_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO8_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO8_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO8_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF1_GPIO8_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF1_GPIO8_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.DORMANT_WAKE_INTF1.Reg) & 0x1
}

// IO_BANK0.DORMANT_WAKE_INTF2: Interrupt Force for dormant_wake
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO23_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO23_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO23_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO23_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO23_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO23_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO23_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO23_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO22_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO22_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO22_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO22_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO22_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO22_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO22_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO22_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO21_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO21_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO21_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO21_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO21_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO21_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO21_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO21_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO20_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO20_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO20_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO20_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO20_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO20_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO20_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO20_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO19_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO19_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO19_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO19_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO19_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO19_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO19_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO19_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO18_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO18_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO18_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO18_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO18_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO18_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO18_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO18_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO17_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO17_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO17_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO17_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO17_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO17_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO17_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO17_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO16_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO16_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO16_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO16_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO16_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO16_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF2_GPIO16_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF2_GPIO16_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.DORMANT_WAKE_INTF2.Reg) & 0x1
}

// IO_BANK0.DORMANT_WAKE_INTF3: Interrupt Force for dormant_wake
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO29_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO29_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO29_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO29_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO29_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO29_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO29_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO29_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO28_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO28_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO28_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO28_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO28_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO28_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO28_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO28_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO27_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO27_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO27_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO27_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO27_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO27_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO27_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO27_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO26_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO26_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO26_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO26_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO26_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO26_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO26_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO26_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO25_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO25_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO25_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO25_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO25_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO25_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO25_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO25_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO24_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO24_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO24_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO24_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO24_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO24_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTF3_GPIO24_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTF3_GPIO24_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.DORMANT_WAKE_INTF3.Reg) & 0x1
}

// IO_BANK0.DORMANT_WAKE_INTS0: Interrupt status after masking & forcing for dormant_wake
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO7_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO7_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO7_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO7_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO7_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO7_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO7_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO7_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO6_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO6_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO6_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO6_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO6_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO6_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO6_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO6_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO5_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO5_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO5_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO5_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO5_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO5_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO5_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO5_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO4_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO4_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO4_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO4_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO4_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO4_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO4_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO4_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO3_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO3_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO3_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO3_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO3_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO3_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO3_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO3_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO2_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO2_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO2_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO2_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO2_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO2_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO2_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO2_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO1_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO1_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO1_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO1_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO1_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO1_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO1_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO1_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO0_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO0_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO0_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO0_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO0_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO0_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS0_GPIO0_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS0.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS0_GPIO0_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.DORMANT_WAKE_INTS0.Reg) & 0x1
}

// IO_BANK0.DORMANT_WAKE_INTS1: Interrupt status after masking & forcing for dormant_wake
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO15_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO15_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO15_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO15_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO15_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO15_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO15_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO15_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO14_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO14_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO14_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO14_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO14_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO14_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO14_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO14_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO13_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO13_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO13_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO13_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO13_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO13_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO13_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO13_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO12_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO12_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO12_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO12_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO12_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO12_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO12_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO12_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO11_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO11_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO11_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO11_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO11_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO11_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO11_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO11_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO10_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO10_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO10_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO10_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO10_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO10_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO10_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO10_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO9_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO9_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO9_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO9_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO9_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO9_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO9_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO9_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO8_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO8_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO8_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO8_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO8_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO8_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS1_GPIO8_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS1.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS1_GPIO8_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.DORMANT_WAKE_INTS1.Reg) & 0x1
}

// IO_BANK0.DORMANT_WAKE_INTS2: Interrupt status after masking & forcing for dormant_wake
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO23_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x80000000)|value<<31)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO23_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x80000000) >> 31
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO23_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x40000000)|value<<30)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO23_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x40000000) >> 30
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO23_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x20000000)|value<<29)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO23_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x20000000) >> 29
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO23_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x10000000)|value<<28)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO23_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x10000000) >> 28
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO22_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x8000000)|value<<27)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO22_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x8000000) >> 27
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO22_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO22_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x4000000) >> 26
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO22_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x2000000)|value<<25)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO22_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x2000000) >> 25
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO22_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO22_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x1000000) >> 24
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO21_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO21_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO21_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO21_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO21_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO21_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO21_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO21_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO20_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO20_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO20_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO20_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO20_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO20_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO20_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO20_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO19_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO19_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO19_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO19_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO19_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO19_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO19_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO19_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO18_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO18_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO18_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO18_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO18_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO18_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO18_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO18_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO17_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO17_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO17_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO17_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO17_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO17_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO17_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO17_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO16_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO16_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO16_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO16_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO16_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO16_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS2_GPIO16_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS2.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS2_GPIO16_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.DORMANT_WAKE_INTS2.Reg) & 0x1
}

// IO_BANK0.DORMANT_WAKE_INTS3: Interrupt status after masking & forcing for dormant_wake
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO29_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x800000)|value<<23)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO29_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x800000) >> 23
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO29_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x400000)|value<<22)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO29_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x400000) >> 22
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO29_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x200000)|value<<21)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO29_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x200000) >> 21
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO29_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x100000)|value<<20)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO29_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x100000) >> 20
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO28_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x80000)|value<<19)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO28_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x80000) >> 19
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO28_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x40000)|value<<18)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO28_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x40000) >> 18
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO28_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x20000)|value<<17)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO28_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x20000) >> 17
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO28_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x10000)|value<<16)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO28_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x10000) >> 16
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO27_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x8000)|value<<15)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO27_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x8000) >> 15
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO27_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x4000)|value<<14)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO27_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x4000) >> 14
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO27_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x2000)|value<<13)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO27_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x2000) >> 13
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO27_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x1000)|value<<12)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO27_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x1000) >> 12
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO26_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x800)|value<<11)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO26_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x800) >> 11
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO26_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x400)|value<<10)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO26_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x400) >> 10
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO26_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x200)|value<<9)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO26_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x200) >> 9
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO26_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x100)|value<<8)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO26_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x100) >> 8
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO25_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x80)|value<<7)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO25_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x80) >> 7
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO25_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x40)|value<<6)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO25_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x40) >> 6
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO25_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x20)|value<<5)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO25_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x20) >> 5
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO25_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x10)|value<<4)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO25_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x10) >> 4
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO24_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x8)|value<<3)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO24_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x8) >> 3
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO24_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x4)|value<<2)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO24_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x4) >> 2
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO24_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x2)|value<<1)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO24_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x2) >> 1
}
func (o *IO_BANK0_Type) SetDORMANT_WAKE_INTS3_GPIO24_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS3.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg)&^(0x1)|value)
}
func (o *IO_BANK0_Type) GetDORMANT_WAKE_INTS3_GPIO24_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.DORMANT_WAKE_INTS3.Reg) & 0x1
}

type IO_QSPI_Type struct {
	GPIO_QSPI_SCLK_STATUS volatile.Register32 // 0x0
	GPIO_QSPI_SCLK_CTRL   volatile.Register32 // 0x4
	GPIO_QSPI_SS_STATUS   volatile.Register32 // 0x8
	GPIO_QSPI_SS_CTRL     volatile.Register32 // 0xC
	GPIO_QSPI_SD0_STATUS  volatile.Register32 // 0x10
	GPIO_QSPI_SD0_CTRL    volatile.Register32 // 0x14
	GPIO_QSPI_SD1_STATUS  volatile.Register32 // 0x18
	GPIO_QSPI_SD1_CTRL    volatile.Register32 // 0x1C
	GPIO_QSPI_SD2_STATUS  volatile.Register32 // 0x20
	GPIO_QSPI_SD2_CTRL    volatile.Register32 // 0x24
	GPIO_QSPI_SD3_STATUS  volatile.Register32 // 0x28
	GPIO_QSPI_SD3_CTRL    volatile.Register32 // 0x2C
	INTR                  volatile.Register32 // 0x30
	PROC0_INTE            volatile.Register32 // 0x34
	PROC0_INTF            volatile.Register32 // 0x38
	PROC0_INTS            volatile.Register32 // 0x3C
	PROC1_INTE            volatile.Register32 // 0x40
	PROC1_INTF            volatile.Register32 // 0x44
	PROC1_INTS            volatile.Register32 // 0x48
	DORMANT_WAKE_INTE     volatile.Register32 // 0x4C
	DORMANT_WAKE_INTF     volatile.Register32 // 0x50
	DORMANT_WAKE_INTS     volatile.Register32 // 0x54
}

// IO_QSPI.GPIO_QSPI_SCLK_STATUS: GPIO status
func (o *IO_QSPI_Type) SetGPIO_QSPI_SCLK_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SCLK_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SCLK_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SCLK_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SCLK_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SCLK_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SCLK_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SCLK_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SCLK_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SCLK_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SCLK_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SCLK_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SCLK_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SCLK_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SCLK_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SCLK_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SCLK_STATUS.Reg) & 0x100) >> 8
}

// IO_QSPI.GPIO_QSPI_SCLK_CTRL: GPIO control including function select and overrides.
func (o *IO_QSPI_Type) SetGPIO_QSPI_SCLK_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SCLK_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SCLK_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SCLK_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SCLK_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SCLK_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SCLK_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SCLK_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SCLK_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SCLK_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SCLK_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SCLK_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SCLK_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SCLK_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SCLK_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SCLK_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SCLK_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SCLK_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SCLK_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SCLK_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SCLK_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SCLK_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SCLK_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SCLK_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO_QSPI_SCLK_CTRL.Reg) & 0x1f
}

// IO_QSPI.GPIO_QSPI_SS_STATUS: GPIO status
func (o *IO_QSPI_Type) SetGPIO_QSPI_SS_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SS_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SS_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SS_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SS_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SS_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SS_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SS_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SS_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SS_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SS_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SS_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SS_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SS_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SS_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SS_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SS_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SS_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SS_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SS_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SS_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SS_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SS_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SS_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SS_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SS_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SS_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SS_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SS_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SS_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SS_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SS_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SS_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SS_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SS_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SS_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SS_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SS_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SS_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SS_STATUS.Reg) & 0x100) >> 8
}

// IO_QSPI.GPIO_QSPI_SS_CTRL: GPIO control including function select and overrides.
func (o *IO_QSPI_Type) SetGPIO_QSPI_SS_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SS_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SS_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SS_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SS_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SS_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SS_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SS_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SS_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SS_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SS_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SS_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SS_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SS_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SS_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SS_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SS_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SS_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SS_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SS_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SS_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SS_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SS_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SS_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO_QSPI_SS_CTRL.Reg) & 0x1f
}

// IO_QSPI.GPIO_QSPI_SD0_STATUS: GPIO status
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD0_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD0_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD0_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD0_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD0_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD0_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD0_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD0_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD0_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD0_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD0_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD0_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD0_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD0_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD0_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD0_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD0_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD0_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD0_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD0_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD0_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD0_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD0_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD0_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD0_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD0_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD0_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD0_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD0_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD0_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD0_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD0_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD0_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD0_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD0_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD0_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD0_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD0_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD0_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD0_STATUS.Reg) & 0x100) >> 8
}

// IO_QSPI.GPIO_QSPI_SD0_CTRL: GPIO control including function select and overrides.
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD0_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD0_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD0_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD0_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD0_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD0_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD0_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD0_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD0_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD0_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD0_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD0_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD0_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD0_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD0_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD0_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD0_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD0_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD0_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD0_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD0_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD0_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD0_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD0_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO_QSPI_SD0_CTRL.Reg) & 0x1f
}

// IO_QSPI.GPIO_QSPI_SD1_STATUS: GPIO status
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD1_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD1_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD1_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD1_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD1_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD1_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD1_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD1_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD1_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD1_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD1_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD1_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD1_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD1_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD1_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD1_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD1_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD1_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD1_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD1_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD1_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD1_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD1_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD1_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD1_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD1_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD1_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD1_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD1_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD1_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD1_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD1_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD1_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD1_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD1_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD1_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD1_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD1_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD1_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD1_STATUS.Reg) & 0x100) >> 8
}

// IO_QSPI.GPIO_QSPI_SD1_CTRL: GPIO control including function select and overrides.
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD1_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD1_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD1_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD1_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD1_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD1_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD1_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD1_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD1_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD1_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD1_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD1_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD1_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD1_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD1_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD1_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD1_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD1_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD1_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD1_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD1_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD1_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD1_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD1_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO_QSPI_SD1_CTRL.Reg) & 0x1f
}

// IO_QSPI.GPIO_QSPI_SD2_STATUS: GPIO status
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD2_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD2_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD2_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD2_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD2_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD2_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD2_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD2_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD2_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD2_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD2_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD2_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD2_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD2_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD2_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD2_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD2_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD2_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD2_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD2_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD2_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD2_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD2_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD2_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD2_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD2_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD2_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD2_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD2_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD2_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD2_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD2_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD2_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD2_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD2_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD2_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD2_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD2_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD2_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD2_STATUS.Reg) & 0x100) >> 8
}

// IO_QSPI.GPIO_QSPI_SD2_CTRL: GPIO control including function select and overrides.
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD2_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD2_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD2_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD2_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD2_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD2_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD2_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD2_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD2_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD2_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD2_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD2_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD2_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD2_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD2_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD2_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD2_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD2_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD2_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD2_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD2_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD2_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD2_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD2_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO_QSPI_SD2_CTRL.Reg) & 0x1f
}

// IO_QSPI.GPIO_QSPI_SD3_STATUS: GPIO status
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD3_STATUS_IRQTOPROC(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD3_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD3_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD3_STATUS_IRQTOPROC() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD3_STATUS.Reg) & 0x4000000) >> 26
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD3_STATUS_IRQFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD3_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD3_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD3_STATUS_IRQFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD3_STATUS.Reg) & 0x1000000) >> 24
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD3_STATUS_INTOPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD3_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD3_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD3_STATUS_INTOPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD3_STATUS.Reg) & 0x80000) >> 19
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD3_STATUS_INFROMPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD3_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD3_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD3_STATUS_INFROMPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD3_STATUS.Reg) & 0x20000) >> 17
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD3_STATUS_OETOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD3_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD3_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD3_STATUS_OETOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD3_STATUS.Reg) & 0x2000) >> 13
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD3_STATUS_OEFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD3_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD3_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD3_STATUS_OEFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD3_STATUS.Reg) & 0x1000) >> 12
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD3_STATUS_OUTTOPAD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD3_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD3_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD3_STATUS_OUTTOPAD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD3_STATUS.Reg) & 0x200) >> 9
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD3_STATUS_OUTFROMPERI(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD3_STATUS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD3_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD3_STATUS_OUTFROMPERI() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD3_STATUS.Reg) & 0x100) >> 8
}

// IO_QSPI.GPIO_QSPI_SD3_CTRL: GPIO control including function select and overrides.
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD3_CTRL_IRQOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD3_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD3_CTRL.Reg)&^(0x30000000)|value<<28)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD3_CTRL_IRQOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD3_CTRL.Reg) & 0x30000000) >> 28
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD3_CTRL_INOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD3_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD3_CTRL.Reg)&^(0x30000)|value<<16)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD3_CTRL_INOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD3_CTRL.Reg) & 0x30000) >> 16
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD3_CTRL_OEOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD3_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD3_CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD3_CTRL_OEOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD3_CTRL.Reg) & 0x3000) >> 12
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD3_CTRL_OUTOVER(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD3_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD3_CTRL.Reg)&^(0x300)|value<<8)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD3_CTRL_OUTOVER() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD3_CTRL.Reg) & 0x300) >> 8
}
func (o *IO_QSPI_Type) SetGPIO_QSPI_SD3_CTRL_FUNCSEL(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD3_CTRL.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD3_CTRL.Reg)&^(0x1f)|value)
}
func (o *IO_QSPI_Type) GetGPIO_QSPI_SD3_CTRL_FUNCSEL() uint32 {
	return volatile.LoadUint32(&o.GPIO_QSPI_SD3_CTRL.Reg) & 0x1f
}

// IO_QSPI.INTR: Raw Interrupts
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SD3_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x800000)|value<<23)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SD3_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x800000) >> 23
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SD3_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x400000)|value<<22)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SD3_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x400000) >> 22
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SD3_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x200000)|value<<21)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SD3_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x200000) >> 21
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SD3_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x100000)|value<<20)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SD3_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x100000) >> 20
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SD2_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x80000)|value<<19)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SD2_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x80000) >> 19
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SD2_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x40000)|value<<18)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SD2_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x40000) >> 18
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SD2_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x20000)|value<<17)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SD2_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x20000) >> 17
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SD2_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x10000)|value<<16)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SD2_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x10000) >> 16
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SD1_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x8000)|value<<15)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SD1_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x8000) >> 15
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SD1_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x4000)|value<<14)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SD1_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x4000) >> 14
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SD1_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x2000)|value<<13)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SD1_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x2000) >> 13
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SD1_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x1000)|value<<12)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SD1_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x1000) >> 12
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SD0_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x800)|value<<11)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SD0_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x800) >> 11
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SD0_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x400)|value<<10)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SD0_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x400) >> 10
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SD0_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x200)|value<<9)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SD0_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x200) >> 9
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SD0_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x100)|value<<8)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SD0_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x100) >> 8
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SS_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x80)|value<<7)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SS_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x80) >> 7
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SS_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x40)|value<<6)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SS_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x40) >> 6
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SS_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x20)|value<<5)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SS_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x20) >> 5
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SS_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x10)|value<<4)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SS_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x10) >> 4
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SCLK_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x8)|value<<3)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SCLK_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x8) >> 3
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SCLK_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x4)|value<<2)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SCLK_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x4) >> 2
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SCLK_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x2)|value<<1)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SCLK_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x2) >> 1
}
func (o *IO_QSPI_Type) SetINTR_GPIO_QSPI_SCLK_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x1)|value)
}
func (o *IO_QSPI_Type) GetINTR_GPIO_QSPI_SCLK_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.INTR.Reg) & 0x1
}

// IO_QSPI.PROC0_INTE: Interrupt Enable for proc0
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SD3_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x800000)|value<<23)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SD3_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x800000) >> 23
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SD3_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x400000)|value<<22)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SD3_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x400000) >> 22
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SD3_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x200000)|value<<21)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SD3_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x200000) >> 21
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SD3_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x100000)|value<<20)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SD3_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x100000) >> 20
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SD2_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x80000)|value<<19)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SD2_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x80000) >> 19
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SD2_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x40000)|value<<18)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SD2_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x40000) >> 18
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SD2_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x20000)|value<<17)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SD2_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x20000) >> 17
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SD2_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x10000)|value<<16)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SD2_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x10000) >> 16
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SD1_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x8000)|value<<15)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SD1_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x8000) >> 15
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SD1_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x4000)|value<<14)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SD1_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x4000) >> 14
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SD1_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x2000)|value<<13)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SD1_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x2000) >> 13
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SD1_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x1000)|value<<12)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SD1_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x1000) >> 12
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SD0_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x800)|value<<11)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SD0_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x800) >> 11
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SD0_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x400)|value<<10)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SD0_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x400) >> 10
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SD0_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x200)|value<<9)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SD0_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x200) >> 9
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SD0_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x100)|value<<8)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SD0_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x100) >> 8
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SS_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x80)|value<<7)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SS_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x80) >> 7
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SS_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x40)|value<<6)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SS_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x40) >> 6
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SS_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x20)|value<<5)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SS_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x20) >> 5
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SS_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x10)|value<<4)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SS_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x10) >> 4
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SCLK_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x8)|value<<3)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SCLK_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x8) >> 3
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SCLK_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x4)|value<<2)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SCLK_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x4) >> 2
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x2)|value<<1)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x2) >> 1
}
func (o *IO_QSPI_Type) SetPROC0_INTE_GPIO_QSPI_SCLK_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTE.Reg, volatile.LoadUint32(&o.PROC0_INTE.Reg)&^(0x1)|value)
}
func (o *IO_QSPI_Type) GetPROC0_INTE_GPIO_QSPI_SCLK_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC0_INTE.Reg) & 0x1
}

// IO_QSPI.PROC0_INTF: Interrupt Force for proc0
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SD3_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x800000)|value<<23)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SD3_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x800000) >> 23
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SD3_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x400000)|value<<22)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SD3_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x400000) >> 22
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SD3_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x200000)|value<<21)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SD3_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x200000) >> 21
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SD3_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x100000)|value<<20)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SD3_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x100000) >> 20
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SD2_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x80000)|value<<19)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SD2_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x80000) >> 19
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SD2_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x40000)|value<<18)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SD2_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x40000) >> 18
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SD2_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x20000)|value<<17)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SD2_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x20000) >> 17
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SD2_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x10000)|value<<16)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SD2_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x10000) >> 16
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SD1_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x8000)|value<<15)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SD1_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x8000) >> 15
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SD1_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x4000)|value<<14)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SD1_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x4000) >> 14
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SD1_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x2000)|value<<13)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SD1_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x2000) >> 13
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SD1_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x1000)|value<<12)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SD1_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x1000) >> 12
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SD0_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x800)|value<<11)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SD0_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x800) >> 11
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SD0_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x400)|value<<10)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SD0_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x400) >> 10
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SD0_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x200)|value<<9)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SD0_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x200) >> 9
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SD0_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x100)|value<<8)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SD0_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x100) >> 8
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SS_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x80)|value<<7)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SS_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x80) >> 7
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SS_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x40)|value<<6)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SS_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x40) >> 6
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SS_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x20)|value<<5)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SS_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x20) >> 5
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SS_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x10)|value<<4)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SS_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x10) >> 4
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SCLK_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x8)|value<<3)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SCLK_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x8) >> 3
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SCLK_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x4)|value<<2)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SCLK_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x4) >> 2
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x2)|value<<1)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x2) >> 1
}
func (o *IO_QSPI_Type) SetPROC0_INTF_GPIO_QSPI_SCLK_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTF.Reg, volatile.LoadUint32(&o.PROC0_INTF.Reg)&^(0x1)|value)
}
func (o *IO_QSPI_Type) GetPROC0_INTF_GPIO_QSPI_SCLK_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC0_INTF.Reg) & 0x1
}

// IO_QSPI.PROC0_INTS: Interrupt status after masking & forcing for proc0
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SD3_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x800000)|value<<23)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SD3_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x800000) >> 23
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SD3_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x400000)|value<<22)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SD3_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x400000) >> 22
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SD3_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x200000)|value<<21)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SD3_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x200000) >> 21
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SD3_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x100000)|value<<20)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SD3_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x100000) >> 20
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SD2_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SD2_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x80000) >> 19
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SD2_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x40000)|value<<18)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SD2_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x40000) >> 18
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SD2_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SD2_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x20000) >> 17
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SD2_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x10000)|value<<16)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SD2_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x10000) >> 16
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SD1_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x8000)|value<<15)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SD1_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x8000) >> 15
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SD1_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x4000)|value<<14)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SD1_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x4000) >> 14
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SD1_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SD1_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x2000) >> 13
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SD1_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SD1_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x1000) >> 12
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SD0_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x800)|value<<11)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SD0_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x800) >> 11
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SD0_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x400)|value<<10)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SD0_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x400) >> 10
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SD0_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x200)|value<<9)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SD0_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x200) >> 9
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SD0_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x100)|value<<8)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SD0_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x100) >> 8
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SS_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x80)|value<<7)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SS_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x80) >> 7
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SS_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x40)|value<<6)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SS_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x40) >> 6
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SS_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x20)|value<<5)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SS_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x20) >> 5
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SS_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x10)|value<<4)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SS_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x10) >> 4
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SCLK_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x8)|value<<3)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SCLK_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x8) >> 3
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SCLK_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x4)|value<<2)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SCLK_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x4) >> 2
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x2)|value<<1)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x2) >> 1
}
func (o *IO_QSPI_Type) SetPROC0_INTS_GPIO_QSPI_SCLK_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC0_INTS.Reg, volatile.LoadUint32(&o.PROC0_INTS.Reg)&^(0x1)|value)
}
func (o *IO_QSPI_Type) GetPROC0_INTS_GPIO_QSPI_SCLK_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC0_INTS.Reg) & 0x1
}

// IO_QSPI.PROC1_INTE: Interrupt Enable for proc1
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SD3_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x800000)|value<<23)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SD3_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x800000) >> 23
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SD3_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x400000)|value<<22)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SD3_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x400000) >> 22
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SD3_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x200000)|value<<21)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SD3_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x200000) >> 21
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SD3_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x100000)|value<<20)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SD3_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x100000) >> 20
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SD2_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x80000)|value<<19)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SD2_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x80000) >> 19
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SD2_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x40000)|value<<18)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SD2_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x40000) >> 18
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SD2_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x20000)|value<<17)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SD2_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x20000) >> 17
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SD2_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x10000)|value<<16)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SD2_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x10000) >> 16
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SD1_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x8000)|value<<15)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SD1_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x8000) >> 15
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SD1_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x4000)|value<<14)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SD1_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x4000) >> 14
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SD1_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x2000)|value<<13)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SD1_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x2000) >> 13
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SD1_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x1000)|value<<12)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SD1_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x1000) >> 12
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SD0_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x800)|value<<11)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SD0_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x800) >> 11
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SD0_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x400)|value<<10)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SD0_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x400) >> 10
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SD0_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x200)|value<<9)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SD0_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x200) >> 9
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SD0_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x100)|value<<8)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SD0_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x100) >> 8
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SS_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x80)|value<<7)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SS_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x80) >> 7
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SS_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x40)|value<<6)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SS_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x40) >> 6
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SS_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x20)|value<<5)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SS_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x20) >> 5
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SS_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x10)|value<<4)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SS_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x10) >> 4
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SCLK_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x8)|value<<3)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SCLK_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x8) >> 3
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SCLK_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x4)|value<<2)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SCLK_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x4) >> 2
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x2)|value<<1)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x2) >> 1
}
func (o *IO_QSPI_Type) SetPROC1_INTE_GPIO_QSPI_SCLK_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTE.Reg, volatile.LoadUint32(&o.PROC1_INTE.Reg)&^(0x1)|value)
}
func (o *IO_QSPI_Type) GetPROC1_INTE_GPIO_QSPI_SCLK_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC1_INTE.Reg) & 0x1
}

// IO_QSPI.PROC1_INTF: Interrupt Force for proc1
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SD3_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x800000)|value<<23)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SD3_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x800000) >> 23
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SD3_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x400000)|value<<22)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SD3_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x400000) >> 22
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SD3_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x200000)|value<<21)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SD3_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x200000) >> 21
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SD3_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x100000)|value<<20)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SD3_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x100000) >> 20
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SD2_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x80000)|value<<19)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SD2_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x80000) >> 19
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SD2_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x40000)|value<<18)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SD2_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x40000) >> 18
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SD2_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x20000)|value<<17)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SD2_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x20000) >> 17
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SD2_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x10000)|value<<16)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SD2_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x10000) >> 16
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SD1_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x8000)|value<<15)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SD1_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x8000) >> 15
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SD1_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x4000)|value<<14)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SD1_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x4000) >> 14
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SD1_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x2000)|value<<13)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SD1_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x2000) >> 13
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SD1_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x1000)|value<<12)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SD1_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x1000) >> 12
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SD0_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x800)|value<<11)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SD0_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x800) >> 11
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SD0_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x400)|value<<10)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SD0_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x400) >> 10
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SD0_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x200)|value<<9)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SD0_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x200) >> 9
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SD0_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x100)|value<<8)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SD0_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x100) >> 8
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SS_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x80)|value<<7)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SS_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x80) >> 7
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SS_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x40)|value<<6)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SS_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x40) >> 6
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SS_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x20)|value<<5)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SS_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x20) >> 5
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SS_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x10)|value<<4)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SS_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x10) >> 4
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SCLK_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x8)|value<<3)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SCLK_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x8) >> 3
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SCLK_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x4)|value<<2)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SCLK_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x4) >> 2
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x2)|value<<1)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x2) >> 1
}
func (o *IO_QSPI_Type) SetPROC1_INTF_GPIO_QSPI_SCLK_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTF.Reg, volatile.LoadUint32(&o.PROC1_INTF.Reg)&^(0x1)|value)
}
func (o *IO_QSPI_Type) GetPROC1_INTF_GPIO_QSPI_SCLK_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC1_INTF.Reg) & 0x1
}

// IO_QSPI.PROC1_INTS: Interrupt status after masking & forcing for proc1
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SD3_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x800000)|value<<23)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SD3_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x800000) >> 23
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SD3_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x400000)|value<<22)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SD3_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x400000) >> 22
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SD3_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x200000)|value<<21)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SD3_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x200000) >> 21
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SD3_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x100000)|value<<20)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SD3_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x100000) >> 20
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SD2_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SD2_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x80000) >> 19
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SD2_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x40000)|value<<18)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SD2_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x40000) >> 18
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SD2_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SD2_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x20000) >> 17
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SD2_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x10000)|value<<16)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SD2_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x10000) >> 16
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SD1_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x8000)|value<<15)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SD1_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x8000) >> 15
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SD1_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x4000)|value<<14)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SD1_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x4000) >> 14
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SD1_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SD1_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x2000) >> 13
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SD1_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SD1_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x1000) >> 12
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SD0_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x800)|value<<11)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SD0_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x800) >> 11
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SD0_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x400)|value<<10)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SD0_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x400) >> 10
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SD0_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x200)|value<<9)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SD0_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x200) >> 9
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SD0_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x100)|value<<8)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SD0_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x100) >> 8
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SS_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x80)|value<<7)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SS_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x80) >> 7
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SS_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x40)|value<<6)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SS_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x40) >> 6
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SS_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x20)|value<<5)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SS_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x20) >> 5
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SS_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x10)|value<<4)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SS_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x10) >> 4
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SCLK_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x8)|value<<3)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SCLK_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x8) >> 3
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SCLK_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x4)|value<<2)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SCLK_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x4) >> 2
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x2)|value<<1)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x2) >> 1
}
func (o *IO_QSPI_Type) SetPROC1_INTS_GPIO_QSPI_SCLK_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.PROC1_INTS.Reg, volatile.LoadUint32(&o.PROC1_INTS.Reg)&^(0x1)|value)
}
func (o *IO_QSPI_Type) GetPROC1_INTS_GPIO_QSPI_SCLK_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.PROC1_INTS.Reg) & 0x1
}

// IO_QSPI.DORMANT_WAKE_INTE: Interrupt Enable for dormant_wake
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SD3_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x800000)|value<<23)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SD3_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x800000) >> 23
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SD3_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x400000)|value<<22)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SD3_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x400000) >> 22
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SD3_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x200000)|value<<21)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SD3_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x200000) >> 21
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SD3_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x100000)|value<<20)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SD3_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x100000) >> 20
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SD2_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x80000)|value<<19)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SD2_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x80000) >> 19
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SD2_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x40000)|value<<18)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SD2_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x40000) >> 18
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SD2_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x20000)|value<<17)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SD2_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x20000) >> 17
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SD2_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x10000)|value<<16)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SD2_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x10000) >> 16
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SD1_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x8000)|value<<15)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SD1_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x8000) >> 15
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SD1_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x4000)|value<<14)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SD1_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x4000) >> 14
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SD1_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x2000)|value<<13)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SD1_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x2000) >> 13
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SD1_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x1000)|value<<12)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SD1_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x1000) >> 12
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SD0_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x800)|value<<11)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SD0_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x800) >> 11
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SD0_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x400)|value<<10)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SD0_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x400) >> 10
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SD0_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x200)|value<<9)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SD0_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x200) >> 9
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SD0_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x100)|value<<8)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SD0_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x100) >> 8
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SS_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x80)|value<<7)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SS_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x80) >> 7
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SS_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x40)|value<<6)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SS_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x40) >> 6
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SS_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x20)|value<<5)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SS_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x20) >> 5
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SS_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x10)|value<<4)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SS_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x10) >> 4
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SCLK_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x8)|value<<3)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SCLK_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x8) >> 3
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SCLK_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x4)|value<<2)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SCLK_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x4) >> 2
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x2)|value<<1)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x2) >> 1
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTE_GPIO_QSPI_SCLK_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTE.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg)&^(0x1)|value)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTE_GPIO_QSPI_SCLK_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.DORMANT_WAKE_INTE.Reg) & 0x1
}

// IO_QSPI.DORMANT_WAKE_INTF: Interrupt Force for dormant_wake
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SD3_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x800000)|value<<23)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SD3_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x800000) >> 23
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SD3_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x400000)|value<<22)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SD3_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x400000) >> 22
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SD3_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x200000)|value<<21)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SD3_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x200000) >> 21
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SD3_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x100000)|value<<20)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SD3_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x100000) >> 20
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SD2_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x80000)|value<<19)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SD2_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x80000) >> 19
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SD2_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x40000)|value<<18)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SD2_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x40000) >> 18
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SD2_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x20000)|value<<17)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SD2_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x20000) >> 17
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SD2_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x10000)|value<<16)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SD2_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x10000) >> 16
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SD1_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x8000)|value<<15)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SD1_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x8000) >> 15
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SD1_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x4000)|value<<14)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SD1_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x4000) >> 14
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SD1_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x2000)|value<<13)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SD1_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x2000) >> 13
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SD1_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x1000)|value<<12)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SD1_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x1000) >> 12
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SD0_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x800)|value<<11)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SD0_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x800) >> 11
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SD0_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x400)|value<<10)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SD0_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x400) >> 10
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SD0_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x200)|value<<9)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SD0_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x200) >> 9
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SD0_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x100)|value<<8)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SD0_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x100) >> 8
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SS_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x80)|value<<7)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SS_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x80) >> 7
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SS_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x40)|value<<6)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SS_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x40) >> 6
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SS_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x20)|value<<5)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SS_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x20) >> 5
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SS_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x10)|value<<4)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SS_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x10) >> 4
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SCLK_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x8)|value<<3)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SCLK_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x8) >> 3
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SCLK_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x4)|value<<2)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SCLK_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x4) >> 2
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x2)|value<<1)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x2) >> 1
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTF_GPIO_QSPI_SCLK_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTF.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg)&^(0x1)|value)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTF_GPIO_QSPI_SCLK_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.DORMANT_WAKE_INTF.Reg) & 0x1
}

// IO_QSPI.DORMANT_WAKE_INTS: Interrupt status after masking & forcing for dormant_wake
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SD3_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x800000)|value<<23)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SD3_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x800000) >> 23
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SD3_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x400000)|value<<22)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SD3_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x400000) >> 22
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SD3_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x200000)|value<<21)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SD3_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x200000) >> 21
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SD3_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x100000)|value<<20)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SD3_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x100000) >> 20
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SD2_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x80000)|value<<19)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SD2_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x80000) >> 19
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SD2_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x40000)|value<<18)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SD2_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x40000) >> 18
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SD2_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x20000)|value<<17)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SD2_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x20000) >> 17
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SD2_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x10000)|value<<16)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SD2_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x10000) >> 16
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SD1_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x8000)|value<<15)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SD1_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x8000) >> 15
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SD1_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x4000)|value<<14)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SD1_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x4000) >> 14
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SD1_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x2000)|value<<13)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SD1_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x2000) >> 13
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SD1_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x1000)|value<<12)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SD1_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x1000) >> 12
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SD0_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x800)|value<<11)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SD0_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x800) >> 11
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SD0_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x400)|value<<10)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SD0_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x400) >> 10
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SD0_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x200)|value<<9)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SD0_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x200) >> 9
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SD0_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x100)|value<<8)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SD0_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x100) >> 8
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SS_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x80)|value<<7)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SS_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x80) >> 7
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SS_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x40)|value<<6)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SS_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x40) >> 6
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SS_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x20)|value<<5)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SS_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x20) >> 5
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SS_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x10)|value<<4)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SS_LEVEL_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x10) >> 4
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SCLK_EDGE_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x8)|value<<3)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SCLK_EDGE_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x8) >> 3
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SCLK_EDGE_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x4)|value<<2)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SCLK_EDGE_LOW() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x4) >> 2
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x2)|value<<1)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH() uint32 {
	return (volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x2) >> 1
}
func (o *IO_QSPI_Type) SetDORMANT_WAKE_INTS_GPIO_QSPI_SCLK_LEVEL_LOW(value uint32) {
	volatile.StoreUint32(&o.DORMANT_WAKE_INTS.Reg, volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg)&^(0x1)|value)
}
func (o *IO_QSPI_Type) GetDORMANT_WAKE_INTS_GPIO_QSPI_SCLK_LEVEL_LOW() uint32 {
	return volatile.LoadUint32(&o.DORMANT_WAKE_INTS.Reg) & 0x1
}

type PADS_BANK0_Type struct {
	VOLTAGE_SELECT volatile.Register32 // 0x0
	GPIO0          volatile.Register32 // 0x4
	GPIO1          volatile.Register32 // 0x8
	GPIO2          volatile.Register32 // 0xC
	GPIO3          volatile.Register32 // 0x10
	GPIO4          volatile.Register32 // 0x14
	GPIO5          volatile.Register32 // 0x18
	GPIO6          volatile.Register32 // 0x1C
	GPIO7          volatile.Register32 // 0x20
	GPIO8          volatile.Register32 // 0x24
	GPIO9          volatile.Register32 // 0x28
	GPIO10         volatile.Register32 // 0x2C
	GPIO11         volatile.Register32 // 0x30
	GPIO12         volatile.Register32 // 0x34
	GPIO13         volatile.Register32 // 0x38
	GPIO14         volatile.Register32 // 0x3C
	GPIO15         volatile.Register32 // 0x40
	GPIO16         volatile.Register32 // 0x44
	GPIO17         volatile.Register32 // 0x48
	GPIO18         volatile.Register32 // 0x4C
	GPIO19         volatile.Register32 // 0x50
	GPIO20         volatile.Register32 // 0x54
	GPIO21         volatile.Register32 // 0x58
	GPIO22         volatile.Register32 // 0x5C
	GPIO23         volatile.Register32 // 0x60
	GPIO24         volatile.Register32 // 0x64
	GPIO25         volatile.Register32 // 0x68
	GPIO26         volatile.Register32 // 0x6C
	GPIO27         volatile.Register32 // 0x70
	GPIO28         volatile.Register32 // 0x74
	GPIO29         volatile.Register32 // 0x78
	SWCLK          volatile.Register32 // 0x7C
	SWD            volatile.Register32 // 0x80
}

// PADS_BANK0.VOLTAGE_SELECT: Voltage select. Per bank control
func (o *PADS_BANK0_Type) SetVOLTAGE_SELECT(value uint32) {
	volatile.StoreUint32(&o.VOLTAGE_SELECT.Reg, volatile.LoadUint32(&o.VOLTAGE_SELECT.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetVOLTAGE_SELECT() uint32 {
	return volatile.LoadUint32(&o.VOLTAGE_SELECT.Reg) & 0x1
}

// PADS_BANK0.GPIO0: Pad control register
func (o *PADS_BANK0_Type) SetGPIO0_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO0_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO0_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO0_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO0_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO0_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO0_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO0_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO0_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO0_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO0_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO0_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO0.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO0_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO0.Reg, volatile.LoadUint32(&o.GPIO0.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO0_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO0.Reg) & 0x1
}

// PADS_BANK0.GPIO1: Pad control register
func (o *PADS_BANK0_Type) SetGPIO1_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO1_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO1_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO1_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO1_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO1_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO1_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO1_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO1_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO1_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO1_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO1_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO1.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO1_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO1.Reg, volatile.LoadUint32(&o.GPIO1.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO1_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO1.Reg) & 0x1
}

// PADS_BANK0.GPIO2: Pad control register
func (o *PADS_BANK0_Type) SetGPIO2_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO2_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO2_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO2_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO2_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO2_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO2_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO2_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO2_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO2_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO2_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO2_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO2.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO2_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO2.Reg, volatile.LoadUint32(&o.GPIO2.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO2_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO2.Reg) & 0x1
}

// PADS_BANK0.GPIO3: Pad control register
func (o *PADS_BANK0_Type) SetGPIO3_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO3_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO3_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO3_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO3_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO3_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO3_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO3_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO3_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO3_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO3_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO3_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO3.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO3_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO3.Reg, volatile.LoadUint32(&o.GPIO3.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO3_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO3.Reg) & 0x1
}

// PADS_BANK0.GPIO4: Pad control register
func (o *PADS_BANK0_Type) SetGPIO4_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO4_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO4_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO4_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO4_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO4_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO4_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO4_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO4_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO4_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO4_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO4_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO4.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO4_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO4.Reg, volatile.LoadUint32(&o.GPIO4.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO4_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO4.Reg) & 0x1
}

// PADS_BANK0.GPIO5: Pad control register
func (o *PADS_BANK0_Type) SetGPIO5_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO5_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO5_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO5_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO5_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO5_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO5_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO5_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO5_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO5_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO5_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO5_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO5.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO5_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO5.Reg, volatile.LoadUint32(&o.GPIO5.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO5_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO5.Reg) & 0x1
}

// PADS_BANK0.GPIO6: Pad control register
func (o *PADS_BANK0_Type) SetGPIO6_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO6_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO6_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO6_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO6_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO6_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO6_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO6_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO6_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO6_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO6_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO6_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO6.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO6_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO6.Reg, volatile.LoadUint32(&o.GPIO6.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO6_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO6.Reg) & 0x1
}

// PADS_BANK0.GPIO7: Pad control register
func (o *PADS_BANK0_Type) SetGPIO7_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO7_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO7_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO7_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO7_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO7_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO7_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO7_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO7_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO7_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO7_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO7_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO7.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO7_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO7.Reg, volatile.LoadUint32(&o.GPIO7.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO7_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO7.Reg) & 0x1
}

// PADS_BANK0.GPIO8: Pad control register
func (o *PADS_BANK0_Type) SetGPIO8_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO8_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO8_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO8_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO8_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO8_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO8_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO8_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO8_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO8_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO8_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO8_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO8.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO8_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO8.Reg, volatile.LoadUint32(&o.GPIO8.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO8_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO8.Reg) & 0x1
}

// PADS_BANK0.GPIO9: Pad control register
func (o *PADS_BANK0_Type) SetGPIO9_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO9_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO9_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO9_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO9_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO9_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO9_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO9_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO9_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO9_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO9_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO9_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO9.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO9_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO9.Reg, volatile.LoadUint32(&o.GPIO9.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO9_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO9.Reg) & 0x1
}

// PADS_BANK0.GPIO10: Pad control register
func (o *PADS_BANK0_Type) SetGPIO10_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO10_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO10_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO10_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO10_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO10_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO10_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO10_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO10_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO10_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO10_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO10_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO10.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO10_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO10.Reg, volatile.LoadUint32(&o.GPIO10.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO10_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO10.Reg) & 0x1
}

// PADS_BANK0.GPIO11: Pad control register
func (o *PADS_BANK0_Type) SetGPIO11_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO11_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO11_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO11_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO11_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO11_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO11_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO11_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO11_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO11_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO11_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO11_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO11.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO11_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO11.Reg, volatile.LoadUint32(&o.GPIO11.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO11_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO11.Reg) & 0x1
}

// PADS_BANK0.GPIO12: Pad control register
func (o *PADS_BANK0_Type) SetGPIO12_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO12_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO12_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO12_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO12_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO12_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO12_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO12_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO12_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO12_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO12_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO12_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO12.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO12_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO12.Reg, volatile.LoadUint32(&o.GPIO12.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO12_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO12.Reg) & 0x1
}

// PADS_BANK0.GPIO13: Pad control register
func (o *PADS_BANK0_Type) SetGPIO13_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO13_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO13_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO13_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO13_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO13_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO13_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO13_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO13_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO13_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO13_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO13_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO13.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO13_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO13.Reg, volatile.LoadUint32(&o.GPIO13.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO13_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO13.Reg) & 0x1
}

// PADS_BANK0.GPIO14: Pad control register
func (o *PADS_BANK0_Type) SetGPIO14_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO14_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO14_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO14_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO14_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO14_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO14_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO14_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO14_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO14_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO14_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO14_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO14.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO14_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO14.Reg, volatile.LoadUint32(&o.GPIO14.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO14_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO14.Reg) & 0x1
}

// PADS_BANK0.GPIO15: Pad control register
func (o *PADS_BANK0_Type) SetGPIO15_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO15_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO15_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO15_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO15_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO15_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO15_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO15_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO15_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO15_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO15_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO15_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO15.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO15_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO15.Reg, volatile.LoadUint32(&o.GPIO15.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO15_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO15.Reg) & 0x1
}

// PADS_BANK0.GPIO16: Pad control register
func (o *PADS_BANK0_Type) SetGPIO16_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO16_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO16_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO16_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO16_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO16_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO16_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO16_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO16_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO16_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO16_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO16_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO16.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO16_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO16.Reg, volatile.LoadUint32(&o.GPIO16.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO16_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO16.Reg) & 0x1
}

// PADS_BANK0.GPIO17: Pad control register
func (o *PADS_BANK0_Type) SetGPIO17_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO17_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO17_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO17_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO17_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO17_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO17_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO17_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO17_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO17_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO17_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO17_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO17.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO17_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO17.Reg, volatile.LoadUint32(&o.GPIO17.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO17_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO17.Reg) & 0x1
}

// PADS_BANK0.GPIO18: Pad control register
func (o *PADS_BANK0_Type) SetGPIO18_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO18_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO18_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO18_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO18_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO18_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO18_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO18_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO18_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO18_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO18_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO18_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO18.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO18_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO18.Reg, volatile.LoadUint32(&o.GPIO18.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO18_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO18.Reg) & 0x1
}

// PADS_BANK0.GPIO19: Pad control register
func (o *PADS_BANK0_Type) SetGPIO19_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO19_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO19_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO19_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO19_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO19_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO19_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO19_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO19_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO19_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO19_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO19_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO19.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO19_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO19.Reg, volatile.LoadUint32(&o.GPIO19.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO19_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO19.Reg) & 0x1
}

// PADS_BANK0.GPIO20: Pad control register
func (o *PADS_BANK0_Type) SetGPIO20_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO20_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO20_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO20_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO20_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO20_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO20_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO20_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO20_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO20_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO20_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO20_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO20.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO20_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO20.Reg, volatile.LoadUint32(&o.GPIO20.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO20_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO20.Reg) & 0x1
}

// PADS_BANK0.GPIO21: Pad control register
func (o *PADS_BANK0_Type) SetGPIO21_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO21_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO21_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO21_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO21_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO21_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO21_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO21_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO21_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO21_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO21_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO21_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO21.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO21_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO21.Reg, volatile.LoadUint32(&o.GPIO21.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO21_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO21.Reg) & 0x1
}

// PADS_BANK0.GPIO22: Pad control register
func (o *PADS_BANK0_Type) SetGPIO22_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO22.Reg, volatile.LoadUint32(&o.GPIO22.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO22_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO22.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO22_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO22.Reg, volatile.LoadUint32(&o.GPIO22.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO22_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO22.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO22_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO22.Reg, volatile.LoadUint32(&o.GPIO22.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO22_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO22.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO22_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO22.Reg, volatile.LoadUint32(&o.GPIO22.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO22_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO22.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO22_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO22.Reg, volatile.LoadUint32(&o.GPIO22.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO22_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO22.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO22_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO22.Reg, volatile.LoadUint32(&o.GPIO22.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO22_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO22.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO22_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO22.Reg, volatile.LoadUint32(&o.GPIO22.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO22_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO22.Reg) & 0x1
}

// PADS_BANK0.GPIO23: Pad control register
func (o *PADS_BANK0_Type) SetGPIO23_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO23.Reg, volatile.LoadUint32(&o.GPIO23.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO23_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO23.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO23_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO23.Reg, volatile.LoadUint32(&o.GPIO23.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO23_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO23.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO23_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO23.Reg, volatile.LoadUint32(&o.GPIO23.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO23_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO23.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO23_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO23.Reg, volatile.LoadUint32(&o.GPIO23.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO23_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO23.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO23_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO23.Reg, volatile.LoadUint32(&o.GPIO23.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO23_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO23.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO23_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO23.Reg, volatile.LoadUint32(&o.GPIO23.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO23_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO23.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO23_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO23.Reg, volatile.LoadUint32(&o.GPIO23.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO23_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO23.Reg) & 0x1
}

// PADS_BANK0.GPIO24: Pad control register
func (o *PADS_BANK0_Type) SetGPIO24_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO24.Reg, volatile.LoadUint32(&o.GPIO24.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO24_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO24.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO24_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO24.Reg, volatile.LoadUint32(&o.GPIO24.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO24_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO24.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO24_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO24.Reg, volatile.LoadUint32(&o.GPIO24.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO24_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO24.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO24_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO24.Reg, volatile.LoadUint32(&o.GPIO24.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO24_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO24.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO24_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO24.Reg, volatile.LoadUint32(&o.GPIO24.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO24_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO24.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO24_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO24.Reg, volatile.LoadUint32(&o.GPIO24.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO24_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO24.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO24_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO24.Reg, volatile.LoadUint32(&o.GPIO24.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO24_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO24.Reg) & 0x1
}

// PADS_BANK0.GPIO25: Pad control register
func (o *PADS_BANK0_Type) SetGPIO25_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO25.Reg, volatile.LoadUint32(&o.GPIO25.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO25_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO25.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO25_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO25.Reg, volatile.LoadUint32(&o.GPIO25.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO25_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO25.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO25_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO25.Reg, volatile.LoadUint32(&o.GPIO25.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO25_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO25.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO25_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO25.Reg, volatile.LoadUint32(&o.GPIO25.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO25_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO25.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO25_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO25.Reg, volatile.LoadUint32(&o.GPIO25.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO25_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO25.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO25_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO25.Reg, volatile.LoadUint32(&o.GPIO25.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO25_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO25.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO25_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO25.Reg, volatile.LoadUint32(&o.GPIO25.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO25_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO25.Reg) & 0x1
}

// PADS_BANK0.GPIO26: Pad control register
func (o *PADS_BANK0_Type) SetGPIO26_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO26_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO26_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO26_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO26_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO26_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO26_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO26_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO26_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO26_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO26_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO26_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO26.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO26_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO26.Reg, volatile.LoadUint32(&o.GPIO26.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO26_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO26.Reg) & 0x1
}

// PADS_BANK0.GPIO27: Pad control register
func (o *PADS_BANK0_Type) SetGPIO27_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO27_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO27_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO27_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO27_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO27_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO27_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO27_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO27_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO27_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO27_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO27_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO27.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO27_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO27.Reg, volatile.LoadUint32(&o.GPIO27.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO27_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO27.Reg) & 0x1
}

// PADS_BANK0.GPIO28: Pad control register
func (o *PADS_BANK0_Type) SetGPIO28_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO28.Reg, volatile.LoadUint32(&o.GPIO28.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO28_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO28.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO28_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO28.Reg, volatile.LoadUint32(&o.GPIO28.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO28_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO28.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO28_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO28.Reg, volatile.LoadUint32(&o.GPIO28.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO28_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO28.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO28_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO28.Reg, volatile.LoadUint32(&o.GPIO28.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO28_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO28.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO28_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO28.Reg, volatile.LoadUint32(&o.GPIO28.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO28_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO28.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO28_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO28.Reg, volatile.LoadUint32(&o.GPIO28.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO28_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO28.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO28_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO28.Reg, volatile.LoadUint32(&o.GPIO28.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO28_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO28.Reg) & 0x1
}

// PADS_BANK0.GPIO29: Pad control register
func (o *PADS_BANK0_Type) SetGPIO29_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO29.Reg, volatile.LoadUint32(&o.GPIO29.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetGPIO29_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO29.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetGPIO29_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO29.Reg, volatile.LoadUint32(&o.GPIO29.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetGPIO29_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO29.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetGPIO29_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO29.Reg, volatile.LoadUint32(&o.GPIO29.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetGPIO29_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO29.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetGPIO29_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO29.Reg, volatile.LoadUint32(&o.GPIO29.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetGPIO29_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO29.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetGPIO29_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO29.Reg, volatile.LoadUint32(&o.GPIO29.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetGPIO29_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO29.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetGPIO29_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO29.Reg, volatile.LoadUint32(&o.GPIO29.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetGPIO29_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO29.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetGPIO29_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO29.Reg, volatile.LoadUint32(&o.GPIO29.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetGPIO29_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO29.Reg) & 0x1
}

// PADS_BANK0.SWCLK: Pad control register
func (o *PADS_BANK0_Type) SetSWCLK_OD(value uint32) {
	volatile.StoreUint32(&o.SWCLK.Reg, volatile.LoadUint32(&o.SWCLK.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetSWCLK_OD() uint32 {
	return (volatile.LoadUint32(&o.SWCLK.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetSWCLK_IE(value uint32) {
	volatile.StoreUint32(&o.SWCLK.Reg, volatile.LoadUint32(&o.SWCLK.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetSWCLK_IE() uint32 {
	return (volatile.LoadUint32(&o.SWCLK.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetSWCLK_DRIVE(value uint32) {
	volatile.StoreUint32(&o.SWCLK.Reg, volatile.LoadUint32(&o.SWCLK.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetSWCLK_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.SWCLK.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetSWCLK_PUE(value uint32) {
	volatile.StoreUint32(&o.SWCLK.Reg, volatile.LoadUint32(&o.SWCLK.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetSWCLK_PUE() uint32 {
	return (volatile.LoadUint32(&o.SWCLK.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetSWCLK_PDE(value uint32) {
	volatile.StoreUint32(&o.SWCLK.Reg, volatile.LoadUint32(&o.SWCLK.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetSWCLK_PDE() uint32 {
	return (volatile.LoadUint32(&o.SWCLK.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetSWCLK_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.SWCLK.Reg, volatile.LoadUint32(&o.SWCLK.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetSWCLK_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.SWCLK.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetSWCLK_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.SWCLK.Reg, volatile.LoadUint32(&o.SWCLK.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetSWCLK_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.SWCLK.Reg) & 0x1
}

// PADS_BANK0.SWD: Pad control register
func (o *PADS_BANK0_Type) SetSWD_OD(value uint32) {
	volatile.StoreUint32(&o.SWD.Reg, volatile.LoadUint32(&o.SWD.Reg)&^(0x80)|value<<7)
}
func (o *PADS_BANK0_Type) GetSWD_OD() uint32 {
	return (volatile.LoadUint32(&o.SWD.Reg) & 0x80) >> 7
}
func (o *PADS_BANK0_Type) SetSWD_IE(value uint32) {
	volatile.StoreUint32(&o.SWD.Reg, volatile.LoadUint32(&o.SWD.Reg)&^(0x40)|value<<6)
}
func (o *PADS_BANK0_Type) GetSWD_IE() uint32 {
	return (volatile.LoadUint32(&o.SWD.Reg) & 0x40) >> 6
}
func (o *PADS_BANK0_Type) SetSWD_DRIVE(value uint32) {
	volatile.StoreUint32(&o.SWD.Reg, volatile.LoadUint32(&o.SWD.Reg)&^(0x30)|value<<4)
}
func (o *PADS_BANK0_Type) GetSWD_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.SWD.Reg) & 0x30) >> 4
}
func (o *PADS_BANK0_Type) SetSWD_PUE(value uint32) {
	volatile.StoreUint32(&o.SWD.Reg, volatile.LoadUint32(&o.SWD.Reg)&^(0x8)|value<<3)
}
func (o *PADS_BANK0_Type) GetSWD_PUE() uint32 {
	return (volatile.LoadUint32(&o.SWD.Reg) & 0x8) >> 3
}
func (o *PADS_BANK0_Type) SetSWD_PDE(value uint32) {
	volatile.StoreUint32(&o.SWD.Reg, volatile.LoadUint32(&o.SWD.Reg)&^(0x4)|value<<2)
}
func (o *PADS_BANK0_Type) GetSWD_PDE() uint32 {
	return (volatile.LoadUint32(&o.SWD.Reg) & 0x4) >> 2
}
func (o *PADS_BANK0_Type) SetSWD_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.SWD.Reg, volatile.LoadUint32(&o.SWD.Reg)&^(0x2)|value<<1)
}
func (o *PADS_BANK0_Type) GetSWD_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.SWD.Reg) & 0x2) >> 1
}
func (o *PADS_BANK0_Type) SetSWD_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.SWD.Reg, volatile.LoadUint32(&o.SWD.Reg)&^(0x1)|value)
}
func (o *PADS_BANK0_Type) GetSWD_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.SWD.Reg) & 0x1
}

type PADS_QSPI_Type struct {
	VOLTAGE_SELECT volatile.Register32 // 0x0
	GPIO_QSPI_SCLK volatile.Register32 // 0x4
	GPIO_QSPI_SD0  volatile.Register32 // 0x8
	GPIO_QSPI_SD1  volatile.Register32 // 0xC
	GPIO_QSPI_SD2  volatile.Register32 // 0x10
	GPIO_QSPI_SD3  volatile.Register32 // 0x14
	GPIO_QSPI_SS   volatile.Register32 // 0x18
}

// PADS_QSPI.VOLTAGE_SELECT: Voltage select. Per bank control
func (o *PADS_QSPI_Type) SetVOLTAGE_SELECT(value uint32) {
	volatile.StoreUint32(&o.VOLTAGE_SELECT.Reg, volatile.LoadUint32(&o.VOLTAGE_SELECT.Reg)&^(0x1)|value)
}
func (o *PADS_QSPI_Type) GetVOLTAGE_SELECT() uint32 {
	return volatile.LoadUint32(&o.VOLTAGE_SELECT.Reg) & 0x1
}

// PADS_QSPI.GPIO_QSPI_SCLK: Pad control register
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SCLK_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SCLK.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SCLK.Reg)&^(0x80)|value<<7)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SCLK_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SCLK.Reg) & 0x80) >> 7
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SCLK_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SCLK.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SCLK.Reg)&^(0x40)|value<<6)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SCLK_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SCLK.Reg) & 0x40) >> 6
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SCLK_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SCLK.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SCLK.Reg)&^(0x30)|value<<4)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SCLK_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SCLK.Reg) & 0x30) >> 4
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SCLK_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SCLK.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SCLK.Reg)&^(0x8)|value<<3)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SCLK_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SCLK.Reg) & 0x8) >> 3
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SCLK_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SCLK.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SCLK.Reg)&^(0x4)|value<<2)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SCLK_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SCLK.Reg) & 0x4) >> 2
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SCLK_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SCLK.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SCLK.Reg)&^(0x2)|value<<1)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SCLK_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SCLK.Reg) & 0x2) >> 1
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SCLK_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SCLK.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SCLK.Reg)&^(0x1)|value)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SCLK_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO_QSPI_SCLK.Reg) & 0x1
}

// PADS_QSPI.GPIO_QSPI_SD0: Pad control register
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD0_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD0.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD0.Reg)&^(0x80)|value<<7)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD0_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD0.Reg) & 0x80) >> 7
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD0_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD0.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD0.Reg)&^(0x40)|value<<6)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD0_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD0.Reg) & 0x40) >> 6
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD0_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD0.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD0.Reg)&^(0x30)|value<<4)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD0_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD0.Reg) & 0x30) >> 4
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD0_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD0.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD0.Reg)&^(0x8)|value<<3)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD0_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD0.Reg) & 0x8) >> 3
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD0_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD0.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD0.Reg)&^(0x4)|value<<2)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD0_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD0.Reg) & 0x4) >> 2
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD0_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD0.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD0.Reg)&^(0x2)|value<<1)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD0_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD0.Reg) & 0x2) >> 1
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD0_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD0.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD0.Reg)&^(0x1)|value)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD0_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO_QSPI_SD0.Reg) & 0x1
}

// PADS_QSPI.GPIO_QSPI_SD1: Pad control register
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD1_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD1.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD1.Reg)&^(0x80)|value<<7)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD1_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD1.Reg) & 0x80) >> 7
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD1_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD1.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD1.Reg)&^(0x40)|value<<6)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD1_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD1.Reg) & 0x40) >> 6
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD1_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD1.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD1.Reg)&^(0x30)|value<<4)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD1_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD1.Reg) & 0x30) >> 4
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD1_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD1.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD1.Reg)&^(0x8)|value<<3)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD1_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD1.Reg) & 0x8) >> 3
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD1_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD1.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD1.Reg)&^(0x4)|value<<2)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD1_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD1.Reg) & 0x4) >> 2
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD1_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD1.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD1.Reg)&^(0x2)|value<<1)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD1_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD1.Reg) & 0x2) >> 1
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD1_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD1.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD1.Reg)&^(0x1)|value)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD1_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO_QSPI_SD1.Reg) & 0x1
}

// PADS_QSPI.GPIO_QSPI_SD2: Pad control register
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD2_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD2.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD2.Reg)&^(0x80)|value<<7)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD2_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD2.Reg) & 0x80) >> 7
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD2_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD2.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD2.Reg)&^(0x40)|value<<6)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD2_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD2.Reg) & 0x40) >> 6
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD2_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD2.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD2.Reg)&^(0x30)|value<<4)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD2_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD2.Reg) & 0x30) >> 4
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD2_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD2.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD2.Reg)&^(0x8)|value<<3)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD2_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD2.Reg) & 0x8) >> 3
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD2_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD2.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD2.Reg)&^(0x4)|value<<2)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD2_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD2.Reg) & 0x4) >> 2
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD2_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD2.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD2.Reg)&^(0x2)|value<<1)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD2_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD2.Reg) & 0x2) >> 1
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD2_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD2.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD2.Reg)&^(0x1)|value)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD2_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO_QSPI_SD2.Reg) & 0x1
}

// PADS_QSPI.GPIO_QSPI_SD3: Pad control register
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD3_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD3.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD3.Reg)&^(0x80)|value<<7)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD3_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD3.Reg) & 0x80) >> 7
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD3_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD3.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD3.Reg)&^(0x40)|value<<6)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD3_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD3.Reg) & 0x40) >> 6
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD3_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD3.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD3.Reg)&^(0x30)|value<<4)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD3_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD3.Reg) & 0x30) >> 4
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD3_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD3.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD3.Reg)&^(0x8)|value<<3)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD3_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD3.Reg) & 0x8) >> 3
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD3_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD3.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD3.Reg)&^(0x4)|value<<2)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD3_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD3.Reg) & 0x4) >> 2
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD3_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD3.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD3.Reg)&^(0x2)|value<<1)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD3_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SD3.Reg) & 0x2) >> 1
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SD3_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SD3.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SD3.Reg)&^(0x1)|value)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SD3_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO_QSPI_SD3.Reg) & 0x1
}

// PADS_QSPI.GPIO_QSPI_SS: Pad control register
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SS_OD(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SS.Reg)&^(0x80)|value<<7)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SS_OD() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SS.Reg) & 0x80) >> 7
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SS_IE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SS.Reg)&^(0x40)|value<<6)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SS_IE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SS.Reg) & 0x40) >> 6
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SS_DRIVE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SS.Reg)&^(0x30)|value<<4)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SS_DRIVE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SS.Reg) & 0x30) >> 4
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SS_PUE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SS.Reg)&^(0x8)|value<<3)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SS_PUE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SS.Reg) & 0x8) >> 3
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SS_PDE(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SS.Reg)&^(0x4)|value<<2)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SS_PDE() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SS.Reg) & 0x4) >> 2
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SS_SCHMITT(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SS.Reg)&^(0x2)|value<<1)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SS_SCHMITT() uint32 {
	return (volatile.LoadUint32(&o.GPIO_QSPI_SS.Reg) & 0x2) >> 1
}
func (o *PADS_QSPI_Type) SetGPIO_QSPI_SS_SLEWFAST(value uint32) {
	volatile.StoreUint32(&o.GPIO_QSPI_SS.Reg, volatile.LoadUint32(&o.GPIO_QSPI_SS.Reg)&^(0x1)|value)
}
func (o *PADS_QSPI_Type) GetGPIO_QSPI_SS_SLEWFAST() uint32 {
	return volatile.LoadUint32(&o.GPIO_QSPI_SS.Reg) & 0x1
}

// Controls the crystal oscillator
type XOSC_Type struct {
	CTRL    volatile.Register32 // 0x0
	STATUS  volatile.Register32 // 0x4
	DORMANT volatile.Register32 // 0x8
	STARTUP volatile.Register32 // 0xC
	_       [12]byte
	COUNT   volatile.Register32 // 0x1C
}

// XOSC.CTRL: Crystal Oscillator Control
func (o *XOSC_Type) SetCTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xfff000)|value<<12)
}
func (o *XOSC_Type) GetCTRL_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xfff000) >> 12
}
func (o *XOSC_Type) SetCTRL_FREQ_RANGE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xfff)|value)
}
func (o *XOSC_Type) GetCTRL_FREQ_RANGE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0xfff
}

// XOSC.STATUS: Crystal Oscillator Status
func (o *XOSC_Type) SetSTATUS_STABLE(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80000000)|value<<31)
}
func (o *XOSC_Type) GetSTATUS_STABLE() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80000000) >> 31
}
func (o *XOSC_Type) SetSTATUS_BADWRITE(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *XOSC_Type) GetSTATUS_BADWRITE() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x1000000) >> 24
}
func (o *XOSC_Type) SetSTATUS_ENABLED(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *XOSC_Type) GetSTATUS_ENABLED() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x1000) >> 12
}
func (o *XOSC_Type) SetSTATUS_FREQ_RANGE(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x3)|value)
}
func (o *XOSC_Type) GetSTATUS_FREQ_RANGE() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x3
}

// XOSC.STARTUP: Controls the startup delay
func (o *XOSC_Type) SetSTARTUP_X4(value uint32) {
	volatile.StoreUint32(&o.STARTUP.Reg, volatile.LoadUint32(&o.STARTUP.Reg)&^(0x100000)|value<<20)
}
func (o *XOSC_Type) GetSTARTUP_X4() uint32 {
	return (volatile.LoadUint32(&o.STARTUP.Reg) & 0x100000) >> 20
}
func (o *XOSC_Type) SetSTARTUP_DELAY(value uint32) {
	volatile.StoreUint32(&o.STARTUP.Reg, volatile.LoadUint32(&o.STARTUP.Reg)&^(0x3fff)|value)
}
func (o *XOSC_Type) GetSTARTUP_DELAY() uint32 {
	return volatile.LoadUint32(&o.STARTUP.Reg) & 0x3fff
}

// XOSC.COUNT
// A down counter running at the xosc frequency which counts to zero and stops.
// To start the counter write a non-zero value.
// Can be used for short software pauses when setting up time sensitive hardware.
func (o *XOSC_Type) SetCOUNT(value uint32) {
	volatile.StoreUint32(&o.COUNT.Reg, volatile.LoadUint32(&o.COUNT.Reg)&^(0xff)|value)
}
func (o *XOSC_Type) GetCOUNT() uint32 {
	return volatile.LoadUint32(&o.COUNT.Reg) & 0xff
}

type PLL_SYS_Type struct {
	CS        volatile.Register32 // 0x0
	PWR       volatile.Register32 // 0x4
	FBDIV_INT volatile.Register32 // 0x8
	PRIM      volatile.Register32 // 0xC
}

// PLL_SYS.CS
// Control and Status
// GENERAL CONSTRAINTS:
// Reference clock frequency min=5MHz, max=800MHz
// Feedback divider min=16, max=320
// VCO frequency min=400MHz, max=1600MHz
func (o *PLL_SYS_Type) SetCS_LOCK(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x80000000)|value<<31)
}
func (o *PLL_SYS_Type) GetCS_LOCK() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x80000000) >> 31
}
func (o *PLL_SYS_Type) SetCS_BYPASS(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x100)|value<<8)
}
func (o *PLL_SYS_Type) GetCS_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x100) >> 8
}
func (o *PLL_SYS_Type) SetCS_REFDIV(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x3f)|value)
}
func (o *PLL_SYS_Type) GetCS_REFDIV() uint32 {
	return volatile.LoadUint32(&o.CS.Reg) & 0x3f
}

// PLL_SYS.PWR: Controls the PLL power modes.
func (o *PLL_SYS_Type) SetPWR_VCOPD(value uint32) {
	volatile.StoreUint32(&o.PWR.Reg, volatile.LoadUint32(&o.PWR.Reg)&^(0x20)|value<<5)
}
func (o *PLL_SYS_Type) GetPWR_VCOPD() uint32 {
	return (volatile.LoadUint32(&o.PWR.Reg) & 0x20) >> 5
}
func (o *PLL_SYS_Type) SetPWR_POSTDIVPD(value uint32) {
	volatile.StoreUint32(&o.PWR.Reg, volatile.LoadUint32(&o.PWR.Reg)&^(0x8)|value<<3)
}
func (o *PLL_SYS_Type) GetPWR_POSTDIVPD() uint32 {
	return (volatile.LoadUint32(&o.PWR.Reg) & 0x8) >> 3
}
func (o *PLL_SYS_Type) SetPWR_DSMPD(value uint32) {
	volatile.StoreUint32(&o.PWR.Reg, volatile.LoadUint32(&o.PWR.Reg)&^(0x4)|value<<2)
}
func (o *PLL_SYS_Type) GetPWR_DSMPD() uint32 {
	return (volatile.LoadUint32(&o.PWR.Reg) & 0x4) >> 2
}
func (o *PLL_SYS_Type) SetPWR_PD(value uint32) {
	volatile.StoreUint32(&o.PWR.Reg, volatile.LoadUint32(&o.PWR.Reg)&^(0x1)|value)
}
func (o *PLL_SYS_Type) GetPWR_PD() uint32 {
	return volatile.LoadUint32(&o.PWR.Reg) & 0x1
}

// PLL_SYS.FBDIV_INT
// Feedback divisor
// (note: this PLL does not support fractional division)
func (o *PLL_SYS_Type) SetFBDIV_INT(value uint32) {
	volatile.StoreUint32(&o.FBDIV_INT.Reg, volatile.LoadUint32(&o.FBDIV_INT.Reg)&^(0xfff)|value)
}
func (o *PLL_SYS_Type) GetFBDIV_INT() uint32 {
	return volatile.LoadUint32(&o.FBDIV_INT.Reg) & 0xfff
}

// PLL_SYS.PRIM
// Controls the PLL post dividers for the primary output
// (note: this PLL does not have a secondary output)
// the primary output is driven from VCO divided by postdiv1*postdiv2
func (o *PLL_SYS_Type) SetPRIM_POSTDIV1(value uint32) {
	volatile.StoreUint32(&o.PRIM.Reg, volatile.LoadUint32(&o.PRIM.Reg)&^(0x70000)|value<<16)
}
func (o *PLL_SYS_Type) GetPRIM_POSTDIV1() uint32 {
	return (volatile.LoadUint32(&o.PRIM.Reg) & 0x70000) >> 16
}
func (o *PLL_SYS_Type) SetPRIM_POSTDIV2(value uint32) {
	volatile.StoreUint32(&o.PRIM.Reg, volatile.LoadUint32(&o.PRIM.Reg)&^(0x7000)|value<<12)
}
func (o *PLL_SYS_Type) GetPRIM_POSTDIV2() uint32 {
	return (volatile.LoadUint32(&o.PRIM.Reg) & 0x7000) >> 12
}

// Register block for busfabric control signals and performance counters
type BUSCTRL_Type struct {
	BUS_PRIORITY     volatile.Register32 // 0x0
	BUS_PRIORITY_ACK volatile.Register32 // 0x4
	PERFCTR0         volatile.Register32 // 0x8
	PERFSEL0         volatile.Register32 // 0xC
	PERFCTR1         volatile.Register32 // 0x10
	PERFSEL1         volatile.Register32 // 0x14
	PERFCTR2         volatile.Register32 // 0x18
	PERFSEL2         volatile.Register32 // 0x1C
	PERFCTR3         volatile.Register32 // 0x20
	PERFSEL3         volatile.Register32 // 0x24
}

// BUSCTRL.BUS_PRIORITY: Set the priority of each master for bus arbitration.
func (o *BUSCTRL_Type) SetBUS_PRIORITY_DMA_W(value uint32) {
	volatile.StoreUint32(&o.BUS_PRIORITY.Reg, volatile.LoadUint32(&o.BUS_PRIORITY.Reg)&^(0x1000)|value<<12)
}
func (o *BUSCTRL_Type) GetBUS_PRIORITY_DMA_W() uint32 {
	return (volatile.LoadUint32(&o.BUS_PRIORITY.Reg) & 0x1000) >> 12
}
func (o *BUSCTRL_Type) SetBUS_PRIORITY_DMA_R(value uint32) {
	volatile.StoreUint32(&o.BUS_PRIORITY.Reg, volatile.LoadUint32(&o.BUS_PRIORITY.Reg)&^(0x100)|value<<8)
}
func (o *BUSCTRL_Type) GetBUS_PRIORITY_DMA_R() uint32 {
	return (volatile.LoadUint32(&o.BUS_PRIORITY.Reg) & 0x100) >> 8
}
func (o *BUSCTRL_Type) SetBUS_PRIORITY_PROC1(value uint32) {
	volatile.StoreUint32(&o.BUS_PRIORITY.Reg, volatile.LoadUint32(&o.BUS_PRIORITY.Reg)&^(0x10)|value<<4)
}
func (o *BUSCTRL_Type) GetBUS_PRIORITY_PROC1() uint32 {
	return (volatile.LoadUint32(&o.BUS_PRIORITY.Reg) & 0x10) >> 4
}
func (o *BUSCTRL_Type) SetBUS_PRIORITY_PROC0(value uint32) {
	volatile.StoreUint32(&o.BUS_PRIORITY.Reg, volatile.LoadUint32(&o.BUS_PRIORITY.Reg)&^(0x1)|value)
}
func (o *BUSCTRL_Type) GetBUS_PRIORITY_PROC0() uint32 {
	return volatile.LoadUint32(&o.BUS_PRIORITY.Reg) & 0x1
}

// BUSCTRL.BUS_PRIORITY_ACK: Bus priority acknowledge
func (o *BUSCTRL_Type) SetBUS_PRIORITY_ACK(value uint32) {
	volatile.StoreUint32(&o.BUS_PRIORITY_ACK.Reg, volatile.LoadUint32(&o.BUS_PRIORITY_ACK.Reg)&^(0x1)|value)
}
func (o *BUSCTRL_Type) GetBUS_PRIORITY_ACK() uint32 {
	return volatile.LoadUint32(&o.BUS_PRIORITY_ACK.Reg) & 0x1
}

// BUSCTRL.PERFCTR0: Bus fabric performance counter 0
func (o *BUSCTRL_Type) SetPERFCTR0(value uint32) {
	volatile.StoreUint32(&o.PERFCTR0.Reg, volatile.LoadUint32(&o.PERFCTR0.Reg)&^(0xffffff)|value)
}
func (o *BUSCTRL_Type) GetPERFCTR0() uint32 {
	return volatile.LoadUint32(&o.PERFCTR0.Reg) & 0xffffff
}

// BUSCTRL.PERFSEL0: Bus fabric performance event select for PERFCTR0
func (o *BUSCTRL_Type) SetPERFSEL0(value uint32) {
	volatile.StoreUint32(&o.PERFSEL0.Reg, volatile.LoadUint32(&o.PERFSEL0.Reg)&^(0x1f)|value)
}
func (o *BUSCTRL_Type) GetPERFSEL0() uint32 {
	return volatile.LoadUint32(&o.PERFSEL0.Reg) & 0x1f
}

// BUSCTRL.PERFCTR1: Bus fabric performance counter 1
func (o *BUSCTRL_Type) SetPERFCTR1(value uint32) {
	volatile.StoreUint32(&o.PERFCTR1.Reg, volatile.LoadUint32(&o.PERFCTR1.Reg)&^(0xffffff)|value)
}
func (o *BUSCTRL_Type) GetPERFCTR1() uint32 {
	return volatile.LoadUint32(&o.PERFCTR1.Reg) & 0xffffff
}

// BUSCTRL.PERFSEL1: Bus fabric performance event select for PERFCTR1
func (o *BUSCTRL_Type) SetPERFSEL1(value uint32) {
	volatile.StoreUint32(&o.PERFSEL1.Reg, volatile.LoadUint32(&o.PERFSEL1.Reg)&^(0x1f)|value)
}
func (o *BUSCTRL_Type) GetPERFSEL1() uint32 {
	return volatile.LoadUint32(&o.PERFSEL1.Reg) & 0x1f
}

// BUSCTRL.PERFCTR2: Bus fabric performance counter 2
func (o *BUSCTRL_Type) SetPERFCTR2(value uint32) {
	volatile.StoreUint32(&o.PERFCTR2.Reg, volatile.LoadUint32(&o.PERFCTR2.Reg)&^(0xffffff)|value)
}
func (o *BUSCTRL_Type) GetPERFCTR2() uint32 {
	return volatile.LoadUint32(&o.PERFCTR2.Reg) & 0xffffff
}

// BUSCTRL.PERFSEL2: Bus fabric performance event select for PERFCTR2
func (o *BUSCTRL_Type) SetPERFSEL2(value uint32) {
	volatile.StoreUint32(&o.PERFSEL2.Reg, volatile.LoadUint32(&o.PERFSEL2.Reg)&^(0x1f)|value)
}
func (o *BUSCTRL_Type) GetPERFSEL2() uint32 {
	return volatile.LoadUint32(&o.PERFSEL2.Reg) & 0x1f
}

// BUSCTRL.PERFCTR3: Bus fabric performance counter 3
func (o *BUSCTRL_Type) SetPERFCTR3(value uint32) {
	volatile.StoreUint32(&o.PERFCTR3.Reg, volatile.LoadUint32(&o.PERFCTR3.Reg)&^(0xffffff)|value)
}
func (o *BUSCTRL_Type) GetPERFCTR3() uint32 {
	return volatile.LoadUint32(&o.PERFCTR3.Reg) & 0xffffff
}

// BUSCTRL.PERFSEL3: Bus fabric performance event select for PERFCTR3
func (o *BUSCTRL_Type) SetPERFSEL3(value uint32) {
	volatile.StoreUint32(&o.PERFSEL3.Reg, volatile.LoadUint32(&o.PERFSEL3.Reg)&^(0x1f)|value)
}
func (o *BUSCTRL_Type) GetPERFSEL3() uint32 {
	return volatile.LoadUint32(&o.PERFSEL3.Reg) & 0x1f
}

type UART0_Type struct {
	UARTDR        volatile.Register32 // 0x0
	UARTRSR       volatile.Register32 // 0x4
	_             [16]byte
	UARTFR        volatile.Register32 // 0x18
	_             [4]byte
	UARTILPR      volatile.Register32 // 0x20
	UARTIBRD      volatile.Register32 // 0x24
	UARTFBRD      volatile.Register32 // 0x28
	UARTLCR_H     volatile.Register32 // 0x2C
	UARTCR        volatile.Register32 // 0x30
	UARTIFLS      volatile.Register32 // 0x34
	UARTIMSC      volatile.Register32 // 0x38
	UARTRIS       volatile.Register32 // 0x3C
	UARTMIS       volatile.Register32 // 0x40
	UARTICR       volatile.Register32 // 0x44
	UARTDMACR     volatile.Register32 // 0x48
	_             [3988]byte
	UARTPERIPHID0 volatile.Register32 // 0xFE0
	UARTPERIPHID1 volatile.Register32 // 0xFE4
	UARTPERIPHID2 volatile.Register32 // 0xFE8
	UARTPERIPHID3 volatile.Register32 // 0xFEC
	UARTPCELLID0  volatile.Register32 // 0xFF0
	UARTPCELLID1  volatile.Register32 // 0xFF4
	UARTPCELLID2  volatile.Register32 // 0xFF8
	UARTPCELLID3  volatile.Register32 // 0xFFC
}

// UART0.UARTDR: Data Register, UARTDR
func (o *UART0_Type) SetUARTDR_OE(value uint32) {
	volatile.StoreUint32(&o.UARTDR.Reg, volatile.LoadUint32(&o.UARTDR.Reg)&^(0x800)|value<<11)
}
func (o *UART0_Type) GetUARTDR_OE() uint32 {
	return (volatile.LoadUint32(&o.UARTDR.Reg) & 0x800) >> 11
}
func (o *UART0_Type) SetUARTDR_BE(value uint32) {
	volatile.StoreUint32(&o.UARTDR.Reg, volatile.LoadUint32(&o.UARTDR.Reg)&^(0x400)|value<<10)
}
func (o *UART0_Type) GetUARTDR_BE() uint32 {
	return (volatile.LoadUint32(&o.UARTDR.Reg) & 0x400) >> 10
}
func (o *UART0_Type) SetUARTDR_PE(value uint32) {
	volatile.StoreUint32(&o.UARTDR.Reg, volatile.LoadUint32(&o.UARTDR.Reg)&^(0x200)|value<<9)
}
func (o *UART0_Type) GetUARTDR_PE() uint32 {
	return (volatile.LoadUint32(&o.UARTDR.Reg) & 0x200) >> 9
}
func (o *UART0_Type) SetUARTDR_FE(value uint32) {
	volatile.StoreUint32(&o.UARTDR.Reg, volatile.LoadUint32(&o.UARTDR.Reg)&^(0x100)|value<<8)
}
func (o *UART0_Type) GetUARTDR_FE() uint32 {
	return (volatile.LoadUint32(&o.UARTDR.Reg) & 0x100) >> 8
}
func (o *UART0_Type) SetUARTDR_DATA(value uint32) {
	volatile.StoreUint32(&o.UARTDR.Reg, volatile.LoadUint32(&o.UARTDR.Reg)&^(0xff)|value)
}
func (o *UART0_Type) GetUARTDR_DATA() uint32 {
	return volatile.LoadUint32(&o.UARTDR.Reg) & 0xff
}

// UART0.UARTRSR: Receive Status Register/Error Clear Register, UARTRSR/UARTECR
func (o *UART0_Type) SetUARTRSR_OE(value uint32) {
	volatile.StoreUint32(&o.UARTRSR.Reg, volatile.LoadUint32(&o.UARTRSR.Reg)&^(0x8)|value<<3)
}
func (o *UART0_Type) GetUARTRSR_OE() uint32 {
	return (volatile.LoadUint32(&o.UARTRSR.Reg) & 0x8) >> 3
}
func (o *UART0_Type) SetUARTRSR_BE(value uint32) {
	volatile.StoreUint32(&o.UARTRSR.Reg, volatile.LoadUint32(&o.UARTRSR.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetUARTRSR_BE() uint32 {
	return (volatile.LoadUint32(&o.UARTRSR.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetUARTRSR_PE(value uint32) {
	volatile.StoreUint32(&o.UARTRSR.Reg, volatile.LoadUint32(&o.UARTRSR.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetUARTRSR_PE() uint32 {
	return (volatile.LoadUint32(&o.UARTRSR.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetUARTRSR_FE(value uint32) {
	volatile.StoreUint32(&o.UARTRSR.Reg, volatile.LoadUint32(&o.UARTRSR.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetUARTRSR_FE() uint32 {
	return volatile.LoadUint32(&o.UARTRSR.Reg) & 0x1
}

// UART0.UARTFR: Flag Register, UARTFR
func (o *UART0_Type) SetUARTFR_RI(value uint32) {
	volatile.StoreUint32(&o.UARTFR.Reg, volatile.LoadUint32(&o.UARTFR.Reg)&^(0x100)|value<<8)
}
func (o *UART0_Type) GetUARTFR_RI() uint32 {
	return (volatile.LoadUint32(&o.UARTFR.Reg) & 0x100) >> 8
}
func (o *UART0_Type) SetUARTFR_TXFE(value uint32) {
	volatile.StoreUint32(&o.UARTFR.Reg, volatile.LoadUint32(&o.UARTFR.Reg)&^(0x80)|value<<7)
}
func (o *UART0_Type) GetUARTFR_TXFE() uint32 {
	return (volatile.LoadUint32(&o.UARTFR.Reg) & 0x80) >> 7
}
func (o *UART0_Type) SetUARTFR_RXFF(value uint32) {
	volatile.StoreUint32(&o.UARTFR.Reg, volatile.LoadUint32(&o.UARTFR.Reg)&^(0x40)|value<<6)
}
func (o *UART0_Type) GetUARTFR_RXFF() uint32 {
	return (volatile.LoadUint32(&o.UARTFR.Reg) & 0x40) >> 6
}
func (o *UART0_Type) SetUARTFR_TXFF(value uint32) {
	volatile.StoreUint32(&o.UARTFR.Reg, volatile.LoadUint32(&o.UARTFR.Reg)&^(0x20)|value<<5)
}
func (o *UART0_Type) GetUARTFR_TXFF() uint32 {
	return (volatile.LoadUint32(&o.UARTFR.Reg) & 0x20) >> 5
}
func (o *UART0_Type) SetUARTFR_RXFE(value uint32) {
	volatile.StoreUint32(&o.UARTFR.Reg, volatile.LoadUint32(&o.UARTFR.Reg)&^(0x10)|value<<4)
}
func (o *UART0_Type) GetUARTFR_RXFE() uint32 {
	return (volatile.LoadUint32(&o.UARTFR.Reg) & 0x10) >> 4
}
func (o *UART0_Type) SetUARTFR_BUSY(value uint32) {
	volatile.StoreUint32(&o.UARTFR.Reg, volatile.LoadUint32(&o.UARTFR.Reg)&^(0x8)|value<<3)
}
func (o *UART0_Type) GetUARTFR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.UARTFR.Reg) & 0x8) >> 3
}
func (o *UART0_Type) SetUARTFR_DCD(value uint32) {
	volatile.StoreUint32(&o.UARTFR.Reg, volatile.LoadUint32(&o.UARTFR.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetUARTFR_DCD() uint32 {
	return (volatile.LoadUint32(&o.UARTFR.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetUARTFR_DSR(value uint32) {
	volatile.StoreUint32(&o.UARTFR.Reg, volatile.LoadUint32(&o.UARTFR.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetUARTFR_DSR() uint32 {
	return (volatile.LoadUint32(&o.UARTFR.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetUARTFR_CTS(value uint32) {
	volatile.StoreUint32(&o.UARTFR.Reg, volatile.LoadUint32(&o.UARTFR.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetUARTFR_CTS() uint32 {
	return volatile.LoadUint32(&o.UARTFR.Reg) & 0x1
}

// UART0.UARTILPR: IrDA Low-Power Counter Register, UARTILPR
func (o *UART0_Type) SetUARTILPR_ILPDVSR(value uint32) {
	volatile.StoreUint32(&o.UARTILPR.Reg, volatile.LoadUint32(&o.UARTILPR.Reg)&^(0xff)|value)
}
func (o *UART0_Type) GetUARTILPR_ILPDVSR() uint32 {
	return volatile.LoadUint32(&o.UARTILPR.Reg) & 0xff
}

// UART0.UARTIBRD: Integer Baud Rate Register, UARTIBRD
func (o *UART0_Type) SetUARTIBRD_BAUD_DIVINT(value uint32) {
	volatile.StoreUint32(&o.UARTIBRD.Reg, volatile.LoadUint32(&o.UARTIBRD.Reg)&^(0xffff)|value)
}
func (o *UART0_Type) GetUARTIBRD_BAUD_DIVINT() uint32 {
	return volatile.LoadUint32(&o.UARTIBRD.Reg) & 0xffff
}

// UART0.UARTFBRD: Fractional Baud Rate Register, UARTFBRD
func (o *UART0_Type) SetUARTFBRD_BAUD_DIVFRAC(value uint32) {
	volatile.StoreUint32(&o.UARTFBRD.Reg, volatile.LoadUint32(&o.UARTFBRD.Reg)&^(0x3f)|value)
}
func (o *UART0_Type) GetUARTFBRD_BAUD_DIVFRAC() uint32 {
	return volatile.LoadUint32(&o.UARTFBRD.Reg) & 0x3f
}

// UART0.UARTLCR_H: Line Control Register, UARTLCR_H
func (o *UART0_Type) SetUARTLCR_H_SPS(value uint32) {
	volatile.StoreUint32(&o.UARTLCR_H.Reg, volatile.LoadUint32(&o.UARTLCR_H.Reg)&^(0x80)|value<<7)
}
func (o *UART0_Type) GetUARTLCR_H_SPS() uint32 {
	return (volatile.LoadUint32(&o.UARTLCR_H.Reg) & 0x80) >> 7
}
func (o *UART0_Type) SetUARTLCR_H_WLEN(value uint32) {
	volatile.StoreUint32(&o.UARTLCR_H.Reg, volatile.LoadUint32(&o.UARTLCR_H.Reg)&^(0x60)|value<<5)
}
func (o *UART0_Type) GetUARTLCR_H_WLEN() uint32 {
	return (volatile.LoadUint32(&o.UARTLCR_H.Reg) & 0x60) >> 5
}
func (o *UART0_Type) SetUARTLCR_H_FEN(value uint32) {
	volatile.StoreUint32(&o.UARTLCR_H.Reg, volatile.LoadUint32(&o.UARTLCR_H.Reg)&^(0x10)|value<<4)
}
func (o *UART0_Type) GetUARTLCR_H_FEN() uint32 {
	return (volatile.LoadUint32(&o.UARTLCR_H.Reg) & 0x10) >> 4
}
func (o *UART0_Type) SetUARTLCR_H_STP2(value uint32) {
	volatile.StoreUint32(&o.UARTLCR_H.Reg, volatile.LoadUint32(&o.UARTLCR_H.Reg)&^(0x8)|value<<3)
}
func (o *UART0_Type) GetUARTLCR_H_STP2() uint32 {
	return (volatile.LoadUint32(&o.UARTLCR_H.Reg) & 0x8) >> 3
}
func (o *UART0_Type) SetUARTLCR_H_EPS(value uint32) {
	volatile.StoreUint32(&o.UARTLCR_H.Reg, volatile.LoadUint32(&o.UARTLCR_H.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetUARTLCR_H_EPS() uint32 {
	return (volatile.LoadUint32(&o.UARTLCR_H.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetUARTLCR_H_PEN(value uint32) {
	volatile.StoreUint32(&o.UARTLCR_H.Reg, volatile.LoadUint32(&o.UARTLCR_H.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetUARTLCR_H_PEN() uint32 {
	return (volatile.LoadUint32(&o.UARTLCR_H.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetUARTLCR_H_BRK(value uint32) {
	volatile.StoreUint32(&o.UARTLCR_H.Reg, volatile.LoadUint32(&o.UARTLCR_H.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetUARTLCR_H_BRK() uint32 {
	return volatile.LoadUint32(&o.UARTLCR_H.Reg) & 0x1
}

// UART0.UARTCR: Control Register, UARTCR
func (o *UART0_Type) SetUARTCR_CTSEN(value uint32) {
	volatile.StoreUint32(&o.UARTCR.Reg, volatile.LoadUint32(&o.UARTCR.Reg)&^(0x8000)|value<<15)
}
func (o *UART0_Type) GetUARTCR_CTSEN() uint32 {
	return (volatile.LoadUint32(&o.UARTCR.Reg) & 0x8000) >> 15
}
func (o *UART0_Type) SetUARTCR_RTSEN(value uint32) {
	volatile.StoreUint32(&o.UARTCR.Reg, volatile.LoadUint32(&o.UARTCR.Reg)&^(0x4000)|value<<14)
}
func (o *UART0_Type) GetUARTCR_RTSEN() uint32 {
	return (volatile.LoadUint32(&o.UARTCR.Reg) & 0x4000) >> 14
}
func (o *UART0_Type) SetUARTCR_OUT2(value uint32) {
	volatile.StoreUint32(&o.UARTCR.Reg, volatile.LoadUint32(&o.UARTCR.Reg)&^(0x2000)|value<<13)
}
func (o *UART0_Type) GetUARTCR_OUT2() uint32 {
	return (volatile.LoadUint32(&o.UARTCR.Reg) & 0x2000) >> 13
}
func (o *UART0_Type) SetUARTCR_OUT1(value uint32) {
	volatile.StoreUint32(&o.UARTCR.Reg, volatile.LoadUint32(&o.UARTCR.Reg)&^(0x1000)|value<<12)
}
func (o *UART0_Type) GetUARTCR_OUT1() uint32 {
	return (volatile.LoadUint32(&o.UARTCR.Reg) & 0x1000) >> 12
}
func (o *UART0_Type) SetUARTCR_RTS(value uint32) {
	volatile.StoreUint32(&o.UARTCR.Reg, volatile.LoadUint32(&o.UARTCR.Reg)&^(0x800)|value<<11)
}
func (o *UART0_Type) GetUARTCR_RTS() uint32 {
	return (volatile.LoadUint32(&o.UARTCR.Reg) & 0x800) >> 11
}
func (o *UART0_Type) SetUARTCR_DTR(value uint32) {
	volatile.StoreUint32(&o.UARTCR.Reg, volatile.LoadUint32(&o.UARTCR.Reg)&^(0x400)|value<<10)
}
func (o *UART0_Type) GetUARTCR_DTR() uint32 {
	return (volatile.LoadUint32(&o.UARTCR.Reg) & 0x400) >> 10
}
func (o *UART0_Type) SetUARTCR_RXE(value uint32) {
	volatile.StoreUint32(&o.UARTCR.Reg, volatile.LoadUint32(&o.UARTCR.Reg)&^(0x200)|value<<9)
}
func (o *UART0_Type) GetUARTCR_RXE() uint32 {
	return (volatile.LoadUint32(&o.UARTCR.Reg) & 0x200) >> 9
}
func (o *UART0_Type) SetUARTCR_TXE(value uint32) {
	volatile.StoreUint32(&o.UARTCR.Reg, volatile.LoadUint32(&o.UARTCR.Reg)&^(0x100)|value<<8)
}
func (o *UART0_Type) GetUARTCR_TXE() uint32 {
	return (volatile.LoadUint32(&o.UARTCR.Reg) & 0x100) >> 8
}
func (o *UART0_Type) SetUARTCR_LBE(value uint32) {
	volatile.StoreUint32(&o.UARTCR.Reg, volatile.LoadUint32(&o.UARTCR.Reg)&^(0x80)|value<<7)
}
func (o *UART0_Type) GetUARTCR_LBE() uint32 {
	return (volatile.LoadUint32(&o.UARTCR.Reg) & 0x80) >> 7
}
func (o *UART0_Type) SetUARTCR_SIRLP(value uint32) {
	volatile.StoreUint32(&o.UARTCR.Reg, volatile.LoadUint32(&o.UARTCR.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetUARTCR_SIRLP() uint32 {
	return (volatile.LoadUint32(&o.UARTCR.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetUARTCR_SIREN(value uint32) {
	volatile.StoreUint32(&o.UARTCR.Reg, volatile.LoadUint32(&o.UARTCR.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetUARTCR_SIREN() uint32 {
	return (volatile.LoadUint32(&o.UARTCR.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetUARTCR_UARTEN(value uint32) {
	volatile.StoreUint32(&o.UARTCR.Reg, volatile.LoadUint32(&o.UARTCR.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetUARTCR_UARTEN() uint32 {
	return volatile.LoadUint32(&o.UARTCR.Reg) & 0x1
}

// UART0.UARTIFLS: Interrupt FIFO Level Select Register, UARTIFLS
func (o *UART0_Type) SetUARTIFLS_RXIFLSEL(value uint32) {
	volatile.StoreUint32(&o.UARTIFLS.Reg, volatile.LoadUint32(&o.UARTIFLS.Reg)&^(0x38)|value<<3)
}
func (o *UART0_Type) GetUARTIFLS_RXIFLSEL() uint32 {
	return (volatile.LoadUint32(&o.UARTIFLS.Reg) & 0x38) >> 3
}
func (o *UART0_Type) SetUARTIFLS_TXIFLSEL(value uint32) {
	volatile.StoreUint32(&o.UARTIFLS.Reg, volatile.LoadUint32(&o.UARTIFLS.Reg)&^(0x7)|value)
}
func (o *UART0_Type) GetUARTIFLS_TXIFLSEL() uint32 {
	return volatile.LoadUint32(&o.UARTIFLS.Reg) & 0x7
}

// UART0.UARTIMSC: Interrupt Mask Set/Clear Register, UARTIMSC
func (o *UART0_Type) SetUARTIMSC_OEIM(value uint32) {
	volatile.StoreUint32(&o.UARTIMSC.Reg, volatile.LoadUint32(&o.UARTIMSC.Reg)&^(0x400)|value<<10)
}
func (o *UART0_Type) GetUARTIMSC_OEIM() uint32 {
	return (volatile.LoadUint32(&o.UARTIMSC.Reg) & 0x400) >> 10
}
func (o *UART0_Type) SetUARTIMSC_BEIM(value uint32) {
	volatile.StoreUint32(&o.UARTIMSC.Reg, volatile.LoadUint32(&o.UARTIMSC.Reg)&^(0x200)|value<<9)
}
func (o *UART0_Type) GetUARTIMSC_BEIM() uint32 {
	return (volatile.LoadUint32(&o.UARTIMSC.Reg) & 0x200) >> 9
}
func (o *UART0_Type) SetUARTIMSC_PEIM(value uint32) {
	volatile.StoreUint32(&o.UARTIMSC.Reg, volatile.LoadUint32(&o.UARTIMSC.Reg)&^(0x100)|value<<8)
}
func (o *UART0_Type) GetUARTIMSC_PEIM() uint32 {
	return (volatile.LoadUint32(&o.UARTIMSC.Reg) & 0x100) >> 8
}
func (o *UART0_Type) SetUARTIMSC_FEIM(value uint32) {
	volatile.StoreUint32(&o.UARTIMSC.Reg, volatile.LoadUint32(&o.UARTIMSC.Reg)&^(0x80)|value<<7)
}
func (o *UART0_Type) GetUARTIMSC_FEIM() uint32 {
	return (volatile.LoadUint32(&o.UARTIMSC.Reg) & 0x80) >> 7
}
func (o *UART0_Type) SetUARTIMSC_RTIM(value uint32) {
	volatile.StoreUint32(&o.UARTIMSC.Reg, volatile.LoadUint32(&o.UARTIMSC.Reg)&^(0x40)|value<<6)
}
func (o *UART0_Type) GetUARTIMSC_RTIM() uint32 {
	return (volatile.LoadUint32(&o.UARTIMSC.Reg) & 0x40) >> 6
}
func (o *UART0_Type) SetUARTIMSC_TXIM(value uint32) {
	volatile.StoreUint32(&o.UARTIMSC.Reg, volatile.LoadUint32(&o.UARTIMSC.Reg)&^(0x20)|value<<5)
}
func (o *UART0_Type) GetUARTIMSC_TXIM() uint32 {
	return (volatile.LoadUint32(&o.UARTIMSC.Reg) & 0x20) >> 5
}
func (o *UART0_Type) SetUARTIMSC_RXIM(value uint32) {
	volatile.StoreUint32(&o.UARTIMSC.Reg, volatile.LoadUint32(&o.UARTIMSC.Reg)&^(0x10)|value<<4)
}
func (o *UART0_Type) GetUARTIMSC_RXIM() uint32 {
	return (volatile.LoadUint32(&o.UARTIMSC.Reg) & 0x10) >> 4
}
func (o *UART0_Type) SetUARTIMSC_DSRMIM(value uint32) {
	volatile.StoreUint32(&o.UARTIMSC.Reg, volatile.LoadUint32(&o.UARTIMSC.Reg)&^(0x8)|value<<3)
}
func (o *UART0_Type) GetUARTIMSC_DSRMIM() uint32 {
	return (volatile.LoadUint32(&o.UARTIMSC.Reg) & 0x8) >> 3
}
func (o *UART0_Type) SetUARTIMSC_DCDMIM(value uint32) {
	volatile.StoreUint32(&o.UARTIMSC.Reg, volatile.LoadUint32(&o.UARTIMSC.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetUARTIMSC_DCDMIM() uint32 {
	return (volatile.LoadUint32(&o.UARTIMSC.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetUARTIMSC_CTSMIM(value uint32) {
	volatile.StoreUint32(&o.UARTIMSC.Reg, volatile.LoadUint32(&o.UARTIMSC.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetUARTIMSC_CTSMIM() uint32 {
	return (volatile.LoadUint32(&o.UARTIMSC.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetUARTIMSC_RIMIM(value uint32) {
	volatile.StoreUint32(&o.UARTIMSC.Reg, volatile.LoadUint32(&o.UARTIMSC.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetUARTIMSC_RIMIM() uint32 {
	return volatile.LoadUint32(&o.UARTIMSC.Reg) & 0x1
}

// UART0.UARTRIS: Raw Interrupt Status Register, UARTRIS
func (o *UART0_Type) SetUARTRIS_OERIS(value uint32) {
	volatile.StoreUint32(&o.UARTRIS.Reg, volatile.LoadUint32(&o.UARTRIS.Reg)&^(0x400)|value<<10)
}
func (o *UART0_Type) GetUARTRIS_OERIS() uint32 {
	return (volatile.LoadUint32(&o.UARTRIS.Reg) & 0x400) >> 10
}
func (o *UART0_Type) SetUARTRIS_BERIS(value uint32) {
	volatile.StoreUint32(&o.UARTRIS.Reg, volatile.LoadUint32(&o.UARTRIS.Reg)&^(0x200)|value<<9)
}
func (o *UART0_Type) GetUARTRIS_BERIS() uint32 {
	return (volatile.LoadUint32(&o.UARTRIS.Reg) & 0x200) >> 9
}
func (o *UART0_Type) SetUARTRIS_PERIS(value uint32) {
	volatile.StoreUint32(&o.UARTRIS.Reg, volatile.LoadUint32(&o.UARTRIS.Reg)&^(0x100)|value<<8)
}
func (o *UART0_Type) GetUARTRIS_PERIS() uint32 {
	return (volatile.LoadUint32(&o.UARTRIS.Reg) & 0x100) >> 8
}
func (o *UART0_Type) SetUARTRIS_FERIS(value uint32) {
	volatile.StoreUint32(&o.UARTRIS.Reg, volatile.LoadUint32(&o.UARTRIS.Reg)&^(0x80)|value<<7)
}
func (o *UART0_Type) GetUARTRIS_FERIS() uint32 {
	return (volatile.LoadUint32(&o.UARTRIS.Reg) & 0x80) >> 7
}
func (o *UART0_Type) SetUARTRIS_RTRIS(value uint32) {
	volatile.StoreUint32(&o.UARTRIS.Reg, volatile.LoadUint32(&o.UARTRIS.Reg)&^(0x40)|value<<6)
}
func (o *UART0_Type) GetUARTRIS_RTRIS() uint32 {
	return (volatile.LoadUint32(&o.UARTRIS.Reg) & 0x40) >> 6
}
func (o *UART0_Type) SetUARTRIS_TXRIS(value uint32) {
	volatile.StoreUint32(&o.UARTRIS.Reg, volatile.LoadUint32(&o.UARTRIS.Reg)&^(0x20)|value<<5)
}
func (o *UART0_Type) GetUARTRIS_TXRIS() uint32 {
	return (volatile.LoadUint32(&o.UARTRIS.Reg) & 0x20) >> 5
}
func (o *UART0_Type) SetUARTRIS_RXRIS(value uint32) {
	volatile.StoreUint32(&o.UARTRIS.Reg, volatile.LoadUint32(&o.UARTRIS.Reg)&^(0x10)|value<<4)
}
func (o *UART0_Type) GetUARTRIS_RXRIS() uint32 {
	return (volatile.LoadUint32(&o.UARTRIS.Reg) & 0x10) >> 4
}
func (o *UART0_Type) SetUARTRIS_DSRRMIS(value uint32) {
	volatile.StoreUint32(&o.UARTRIS.Reg, volatile.LoadUint32(&o.UARTRIS.Reg)&^(0x8)|value<<3)
}
func (o *UART0_Type) GetUARTRIS_DSRRMIS() uint32 {
	return (volatile.LoadUint32(&o.UARTRIS.Reg) & 0x8) >> 3
}
func (o *UART0_Type) SetUARTRIS_DCDRMIS(value uint32) {
	volatile.StoreUint32(&o.UARTRIS.Reg, volatile.LoadUint32(&o.UARTRIS.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetUARTRIS_DCDRMIS() uint32 {
	return (volatile.LoadUint32(&o.UARTRIS.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetUARTRIS_CTSRMIS(value uint32) {
	volatile.StoreUint32(&o.UARTRIS.Reg, volatile.LoadUint32(&o.UARTRIS.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetUARTRIS_CTSRMIS() uint32 {
	return (volatile.LoadUint32(&o.UARTRIS.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetUARTRIS_RIRMIS(value uint32) {
	volatile.StoreUint32(&o.UARTRIS.Reg, volatile.LoadUint32(&o.UARTRIS.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetUARTRIS_RIRMIS() uint32 {
	return volatile.LoadUint32(&o.UARTRIS.Reg) & 0x1
}

// UART0.UARTMIS: Masked Interrupt Status Register, UARTMIS
func (o *UART0_Type) SetUARTMIS_OEMIS(value uint32) {
	volatile.StoreUint32(&o.UARTMIS.Reg, volatile.LoadUint32(&o.UARTMIS.Reg)&^(0x400)|value<<10)
}
func (o *UART0_Type) GetUARTMIS_OEMIS() uint32 {
	return (volatile.LoadUint32(&o.UARTMIS.Reg) & 0x400) >> 10
}
func (o *UART0_Type) SetUARTMIS_BEMIS(value uint32) {
	volatile.StoreUint32(&o.UARTMIS.Reg, volatile.LoadUint32(&o.UARTMIS.Reg)&^(0x200)|value<<9)
}
func (o *UART0_Type) GetUARTMIS_BEMIS() uint32 {
	return (volatile.LoadUint32(&o.UARTMIS.Reg) & 0x200) >> 9
}
func (o *UART0_Type) SetUARTMIS_PEMIS(value uint32) {
	volatile.StoreUint32(&o.UARTMIS.Reg, volatile.LoadUint32(&o.UARTMIS.Reg)&^(0x100)|value<<8)
}
func (o *UART0_Type) GetUARTMIS_PEMIS() uint32 {
	return (volatile.LoadUint32(&o.UARTMIS.Reg) & 0x100) >> 8
}
func (o *UART0_Type) SetUARTMIS_FEMIS(value uint32) {
	volatile.StoreUint32(&o.UARTMIS.Reg, volatile.LoadUint32(&o.UARTMIS.Reg)&^(0x80)|value<<7)
}
func (o *UART0_Type) GetUARTMIS_FEMIS() uint32 {
	return (volatile.LoadUint32(&o.UARTMIS.Reg) & 0x80) >> 7
}
func (o *UART0_Type) SetUARTMIS_RTMIS(value uint32) {
	volatile.StoreUint32(&o.UARTMIS.Reg, volatile.LoadUint32(&o.UARTMIS.Reg)&^(0x40)|value<<6)
}
func (o *UART0_Type) GetUARTMIS_RTMIS() uint32 {
	return (volatile.LoadUint32(&o.UARTMIS.Reg) & 0x40) >> 6
}
func (o *UART0_Type) SetUARTMIS_TXMIS(value uint32) {
	volatile.StoreUint32(&o.UARTMIS.Reg, volatile.LoadUint32(&o.UARTMIS.Reg)&^(0x20)|value<<5)
}
func (o *UART0_Type) GetUARTMIS_TXMIS() uint32 {
	return (volatile.LoadUint32(&o.UARTMIS.Reg) & 0x20) >> 5
}
func (o *UART0_Type) SetUARTMIS_RXMIS(value uint32) {
	volatile.StoreUint32(&o.UARTMIS.Reg, volatile.LoadUint32(&o.UARTMIS.Reg)&^(0x10)|value<<4)
}
func (o *UART0_Type) GetUARTMIS_RXMIS() uint32 {
	return (volatile.LoadUint32(&o.UARTMIS.Reg) & 0x10) >> 4
}
func (o *UART0_Type) SetUARTMIS_DSRMMIS(value uint32) {
	volatile.StoreUint32(&o.UARTMIS.Reg, volatile.LoadUint32(&o.UARTMIS.Reg)&^(0x8)|value<<3)
}
func (o *UART0_Type) GetUARTMIS_DSRMMIS() uint32 {
	return (volatile.LoadUint32(&o.UARTMIS.Reg) & 0x8) >> 3
}
func (o *UART0_Type) SetUARTMIS_DCDMMIS(value uint32) {
	volatile.StoreUint32(&o.UARTMIS.Reg, volatile.LoadUint32(&o.UARTMIS.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetUARTMIS_DCDMMIS() uint32 {
	return (volatile.LoadUint32(&o.UARTMIS.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetUARTMIS_CTSMMIS(value uint32) {
	volatile.StoreUint32(&o.UARTMIS.Reg, volatile.LoadUint32(&o.UARTMIS.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetUARTMIS_CTSMMIS() uint32 {
	return (volatile.LoadUint32(&o.UARTMIS.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetUARTMIS_RIMMIS(value uint32) {
	volatile.StoreUint32(&o.UARTMIS.Reg, volatile.LoadUint32(&o.UARTMIS.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetUARTMIS_RIMMIS() uint32 {
	return volatile.LoadUint32(&o.UARTMIS.Reg) & 0x1
}

// UART0.UARTICR: Interrupt Clear Register, UARTICR
func (o *UART0_Type) SetUARTICR_OEIC(value uint32) {
	volatile.StoreUint32(&o.UARTICR.Reg, volatile.LoadUint32(&o.UARTICR.Reg)&^(0x400)|value<<10)
}
func (o *UART0_Type) GetUARTICR_OEIC() uint32 {
	return (volatile.LoadUint32(&o.UARTICR.Reg) & 0x400) >> 10
}
func (o *UART0_Type) SetUARTICR_BEIC(value uint32) {
	volatile.StoreUint32(&o.UARTICR.Reg, volatile.LoadUint32(&o.UARTICR.Reg)&^(0x200)|value<<9)
}
func (o *UART0_Type) GetUARTICR_BEIC() uint32 {
	return (volatile.LoadUint32(&o.UARTICR.Reg) & 0x200) >> 9
}
func (o *UART0_Type) SetUARTICR_PEIC(value uint32) {
	volatile.StoreUint32(&o.UARTICR.Reg, volatile.LoadUint32(&o.UARTICR.Reg)&^(0x100)|value<<8)
}
func (o *UART0_Type) GetUARTICR_PEIC() uint32 {
	return (volatile.LoadUint32(&o.UARTICR.Reg) & 0x100) >> 8
}
func (o *UART0_Type) SetUARTICR_FEIC(value uint32) {
	volatile.StoreUint32(&o.UARTICR.Reg, volatile.LoadUint32(&o.UARTICR.Reg)&^(0x80)|value<<7)
}
func (o *UART0_Type) GetUARTICR_FEIC() uint32 {
	return (volatile.LoadUint32(&o.UARTICR.Reg) & 0x80) >> 7
}
func (o *UART0_Type) SetUARTICR_RTIC(value uint32) {
	volatile.StoreUint32(&o.UARTICR.Reg, volatile.LoadUint32(&o.UARTICR.Reg)&^(0x40)|value<<6)
}
func (o *UART0_Type) GetUARTICR_RTIC() uint32 {
	return (volatile.LoadUint32(&o.UARTICR.Reg) & 0x40) >> 6
}
func (o *UART0_Type) SetUARTICR_TXIC(value uint32) {
	volatile.StoreUint32(&o.UARTICR.Reg, volatile.LoadUint32(&o.UARTICR.Reg)&^(0x20)|value<<5)
}
func (o *UART0_Type) GetUARTICR_TXIC() uint32 {
	return (volatile.LoadUint32(&o.UARTICR.Reg) & 0x20) >> 5
}
func (o *UART0_Type) SetUARTICR_RXIC(value uint32) {
	volatile.StoreUint32(&o.UARTICR.Reg, volatile.LoadUint32(&o.UARTICR.Reg)&^(0x10)|value<<4)
}
func (o *UART0_Type) GetUARTICR_RXIC() uint32 {
	return (volatile.LoadUint32(&o.UARTICR.Reg) & 0x10) >> 4
}
func (o *UART0_Type) SetUARTICR_DSRMIC(value uint32) {
	volatile.StoreUint32(&o.UARTICR.Reg, volatile.LoadUint32(&o.UARTICR.Reg)&^(0x8)|value<<3)
}
func (o *UART0_Type) GetUARTICR_DSRMIC() uint32 {
	return (volatile.LoadUint32(&o.UARTICR.Reg) & 0x8) >> 3
}
func (o *UART0_Type) SetUARTICR_DCDMIC(value uint32) {
	volatile.StoreUint32(&o.UARTICR.Reg, volatile.LoadUint32(&o.UARTICR.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetUARTICR_DCDMIC() uint32 {
	return (volatile.LoadUint32(&o.UARTICR.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetUARTICR_CTSMIC(value uint32) {
	volatile.StoreUint32(&o.UARTICR.Reg, volatile.LoadUint32(&o.UARTICR.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetUARTICR_CTSMIC() uint32 {
	return (volatile.LoadUint32(&o.UARTICR.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetUARTICR_RIMIC(value uint32) {
	volatile.StoreUint32(&o.UARTICR.Reg, volatile.LoadUint32(&o.UARTICR.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetUARTICR_RIMIC() uint32 {
	return volatile.LoadUint32(&o.UARTICR.Reg) & 0x1
}

// UART0.UARTDMACR: DMA Control Register, UARTDMACR
func (o *UART0_Type) SetUARTDMACR_DMAONERR(value uint32) {
	volatile.StoreUint32(&o.UARTDMACR.Reg, volatile.LoadUint32(&o.UARTDMACR.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetUARTDMACR_DMAONERR() uint32 {
	return (volatile.LoadUint32(&o.UARTDMACR.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetUARTDMACR_TXDMAE(value uint32) {
	volatile.StoreUint32(&o.UARTDMACR.Reg, volatile.LoadUint32(&o.UARTDMACR.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetUARTDMACR_TXDMAE() uint32 {
	return (volatile.LoadUint32(&o.UARTDMACR.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetUARTDMACR_RXDMAE(value uint32) {
	volatile.StoreUint32(&o.UARTDMACR.Reg, volatile.LoadUint32(&o.UARTDMACR.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetUARTDMACR_RXDMAE() uint32 {
	return volatile.LoadUint32(&o.UARTDMACR.Reg) & 0x1
}

// UART0.UARTPERIPHID0: UARTPeriphID0 Register
func (o *UART0_Type) SetUARTPERIPHID0_PARTNUMBER0(value uint32) {
	volatile.StoreUint32(&o.UARTPERIPHID0.Reg, volatile.LoadUint32(&o.UARTPERIPHID0.Reg)&^(0xff)|value)
}
func (o *UART0_Type) GetUARTPERIPHID0_PARTNUMBER0() uint32 {
	return volatile.LoadUint32(&o.UARTPERIPHID0.Reg) & 0xff
}

// UART0.UARTPERIPHID1: UARTPeriphID1 Register
func (o *UART0_Type) SetUARTPERIPHID1_DESIGNER0(value uint32) {
	volatile.StoreUint32(&o.UARTPERIPHID1.Reg, volatile.LoadUint32(&o.UARTPERIPHID1.Reg)&^(0xf0)|value<<4)
}
func (o *UART0_Type) GetUARTPERIPHID1_DESIGNER0() uint32 {
	return (volatile.LoadUint32(&o.UARTPERIPHID1.Reg) & 0xf0) >> 4
}
func (o *UART0_Type) SetUARTPERIPHID1_PARTNUMBER1(value uint32) {
	volatile.StoreUint32(&o.UARTPERIPHID1.Reg, volatile.LoadUint32(&o.UARTPERIPHID1.Reg)&^(0xf)|value)
}
func (o *UART0_Type) GetUARTPERIPHID1_PARTNUMBER1() uint32 {
	return volatile.LoadUint32(&o.UARTPERIPHID1.Reg) & 0xf
}

// UART0.UARTPERIPHID2: UARTPeriphID2 Register
func (o *UART0_Type) SetUARTPERIPHID2_REVISION(value uint32) {
	volatile.StoreUint32(&o.UARTPERIPHID2.Reg, volatile.LoadUint32(&o.UARTPERIPHID2.Reg)&^(0xf0)|value<<4)
}
func (o *UART0_Type) GetUARTPERIPHID2_REVISION() uint32 {
	return (volatile.LoadUint32(&o.UARTPERIPHID2.Reg) & 0xf0) >> 4
}
func (o *UART0_Type) SetUARTPERIPHID2_DESIGNER1(value uint32) {
	volatile.StoreUint32(&o.UARTPERIPHID2.Reg, volatile.LoadUint32(&o.UARTPERIPHID2.Reg)&^(0xf)|value)
}
func (o *UART0_Type) GetUARTPERIPHID2_DESIGNER1() uint32 {
	return volatile.LoadUint32(&o.UARTPERIPHID2.Reg) & 0xf
}

// UART0.UARTPERIPHID3: UARTPeriphID3 Register
func (o *UART0_Type) SetUARTPERIPHID3_CONFIGURATION(value uint32) {
	volatile.StoreUint32(&o.UARTPERIPHID3.Reg, volatile.LoadUint32(&o.UARTPERIPHID3.Reg)&^(0xff)|value)
}
func (o *UART0_Type) GetUARTPERIPHID3_CONFIGURATION() uint32 {
	return volatile.LoadUint32(&o.UARTPERIPHID3.Reg) & 0xff
}

// UART0.UARTPCELLID0: UARTPCellID0 Register
func (o *UART0_Type) SetUARTPCELLID0(value uint32) {
	volatile.StoreUint32(&o.UARTPCELLID0.Reg, volatile.LoadUint32(&o.UARTPCELLID0.Reg)&^(0xff)|value)
}
func (o *UART0_Type) GetUARTPCELLID0() uint32 {
	return volatile.LoadUint32(&o.UARTPCELLID0.Reg) & 0xff
}

// UART0.UARTPCELLID1: UARTPCellID1 Register
func (o *UART0_Type) SetUARTPCELLID1(value uint32) {
	volatile.StoreUint32(&o.UARTPCELLID1.Reg, volatile.LoadUint32(&o.UARTPCELLID1.Reg)&^(0xff)|value)
}
func (o *UART0_Type) GetUARTPCELLID1() uint32 {
	return volatile.LoadUint32(&o.UARTPCELLID1.Reg) & 0xff
}

// UART0.UARTPCELLID2: UARTPCellID2 Register
func (o *UART0_Type) SetUARTPCELLID2(value uint32) {
	volatile.StoreUint32(&o.UARTPCELLID2.Reg, volatile.LoadUint32(&o.UARTPCELLID2.Reg)&^(0xff)|value)
}
func (o *UART0_Type) GetUARTPCELLID2() uint32 {
	return volatile.LoadUint32(&o.UARTPCELLID2.Reg) & 0xff
}

// UART0.UARTPCELLID3: UARTPCellID3 Register
func (o *UART0_Type) SetUARTPCELLID3(value uint32) {
	volatile.StoreUint32(&o.UARTPCELLID3.Reg, volatile.LoadUint32(&o.UARTPCELLID3.Reg)&^(0xff)|value)
}
func (o *UART0_Type) GetUARTPCELLID3() uint32 {
	return volatile.LoadUint32(&o.UARTPCELLID3.Reg) & 0xff
}

type SPI0_Type struct {
	SSPCR0       volatile.Register32 // 0x0
	SSPCR1       volatile.Register32 // 0x4
	SSPDR        volatile.Register32 // 0x8
	SSPSR        volatile.Register32 // 0xC
	SSPCPSR      volatile.Register32 // 0x10
	SSPIMSC      volatile.Register32 // 0x14
	SSPRIS       volatile.Register32 // 0x18
	SSPMIS       volatile.Register32 // 0x1C
	SSPICR       volatile.Register32 // 0x20
	SSPDMACR     volatile.Register32 // 0x24
	_            [4024]byte
	SSPPERIPHID0 volatile.Register32 // 0xFE0
	SSPPERIPHID1 volatile.Register32 // 0xFE4
	SSPPERIPHID2 volatile.Register32 // 0xFE8
	SSPPERIPHID3 volatile.Register32 // 0xFEC
	SSPPCELLID0  volatile.Register32 // 0xFF0
	SSPPCELLID1  volatile.Register32 // 0xFF4
	SSPPCELLID2  volatile.Register32 // 0xFF8
	SSPPCELLID3  volatile.Register32 // 0xFFC
}

// SPI0.SSPCR0: Control register 0, SSPCR0 on page 3-4
func (o *SPI0_Type) SetSSPCR0_SCR(value uint32) {
	volatile.StoreUint32(&o.SSPCR0.Reg, volatile.LoadUint32(&o.SSPCR0.Reg)&^(0xff00)|value<<8)
}
func (o *SPI0_Type) GetSSPCR0_SCR() uint32 {
	return (volatile.LoadUint32(&o.SSPCR0.Reg) & 0xff00) >> 8
}
func (o *SPI0_Type) SetSSPCR0_SPH(value uint32) {
	volatile.StoreUint32(&o.SSPCR0.Reg, volatile.LoadUint32(&o.SSPCR0.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSSPCR0_SPH() uint32 {
	return (volatile.LoadUint32(&o.SSPCR0.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSSPCR0_SPO(value uint32) {
	volatile.StoreUint32(&o.SSPCR0.Reg, volatile.LoadUint32(&o.SSPCR0.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSSPCR0_SPO() uint32 {
	return (volatile.LoadUint32(&o.SSPCR0.Reg) & 0x40) >> 6
}
func (o *SPI0_Type) SetSSPCR0_FRF(value uint32) {
	volatile.StoreUint32(&o.SSPCR0.Reg, volatile.LoadUint32(&o.SSPCR0.Reg)&^(0x30)|value<<4)
}
func (o *SPI0_Type) GetSSPCR0_FRF() uint32 {
	return (volatile.LoadUint32(&o.SSPCR0.Reg) & 0x30) >> 4
}
func (o *SPI0_Type) SetSSPCR0_DSS(value uint32) {
	volatile.StoreUint32(&o.SSPCR0.Reg, volatile.LoadUint32(&o.SSPCR0.Reg)&^(0xf)|value)
}
func (o *SPI0_Type) GetSSPCR0_DSS() uint32 {
	return volatile.LoadUint32(&o.SSPCR0.Reg) & 0xf
}

// SPI0.SSPCR1: Control register 1, SSPCR1 on page 3-5
func (o *SPI0_Type) SetSSPCR1_SOD(value uint32) {
	volatile.StoreUint32(&o.SSPCR1.Reg, volatile.LoadUint32(&o.SSPCR1.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSSPCR1_SOD() uint32 {
	return (volatile.LoadUint32(&o.SSPCR1.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSSPCR1_MS(value uint32) {
	volatile.StoreUint32(&o.SSPCR1.Reg, volatile.LoadUint32(&o.SSPCR1.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSSPCR1_MS() uint32 {
	return (volatile.LoadUint32(&o.SSPCR1.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSSPCR1_SSE(value uint32) {
	volatile.StoreUint32(&o.SSPCR1.Reg, volatile.LoadUint32(&o.SSPCR1.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSSPCR1_SSE() uint32 {
	return (volatile.LoadUint32(&o.SSPCR1.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSSPCR1_LBM(value uint32) {
	volatile.StoreUint32(&o.SSPCR1.Reg, volatile.LoadUint32(&o.SSPCR1.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSSPCR1_LBM() uint32 {
	return volatile.LoadUint32(&o.SSPCR1.Reg) & 0x1
}

// SPI0.SSPDR: Data register, SSPDR on page 3-6
func (o *SPI0_Type) SetSSPDR_DATA(value uint32) {
	volatile.StoreUint32(&o.SSPDR.Reg, volatile.LoadUint32(&o.SSPDR.Reg)&^(0xffff)|value)
}
func (o *SPI0_Type) GetSSPDR_DATA() uint32 {
	return volatile.LoadUint32(&o.SSPDR.Reg) & 0xffff
}

// SPI0.SSPSR: Status register, SSPSR on page 3-7
func (o *SPI0_Type) SetSSPSR_BSY(value uint32) {
	volatile.StoreUint32(&o.SSPSR.Reg, volatile.LoadUint32(&o.SSPSR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSSPSR_BSY() uint32 {
	return (volatile.LoadUint32(&o.SSPSR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSSPSR_RFF(value uint32) {
	volatile.StoreUint32(&o.SSPSR.Reg, volatile.LoadUint32(&o.SSPSR.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSSPSR_RFF() uint32 {
	return (volatile.LoadUint32(&o.SSPSR.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSSPSR_RNE(value uint32) {
	volatile.StoreUint32(&o.SSPSR.Reg, volatile.LoadUint32(&o.SSPSR.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSSPSR_RNE() uint32 {
	return (volatile.LoadUint32(&o.SSPSR.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSSPSR_TNF(value uint32) {
	volatile.StoreUint32(&o.SSPSR.Reg, volatile.LoadUint32(&o.SSPSR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSSPSR_TNF() uint32 {
	return (volatile.LoadUint32(&o.SSPSR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSSPSR_TFE(value uint32) {
	volatile.StoreUint32(&o.SSPSR.Reg, volatile.LoadUint32(&o.SSPSR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSSPSR_TFE() uint32 {
	return volatile.LoadUint32(&o.SSPSR.Reg) & 0x1
}

// SPI0.SSPCPSR: Clock prescale register, SSPCPSR on page 3-8
func (o *SPI0_Type) SetSSPCPSR_CPSDVSR(value uint32) {
	volatile.StoreUint32(&o.SSPCPSR.Reg, volatile.LoadUint32(&o.SSPCPSR.Reg)&^(0xff)|value)
}
func (o *SPI0_Type) GetSSPCPSR_CPSDVSR() uint32 {
	return volatile.LoadUint32(&o.SSPCPSR.Reg) & 0xff
}

// SPI0.SSPIMSC: Interrupt mask set or clear register, SSPIMSC on page 3-9
func (o *SPI0_Type) SetSSPIMSC_TXIM(value uint32) {
	volatile.StoreUint32(&o.SSPIMSC.Reg, volatile.LoadUint32(&o.SSPIMSC.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSSPIMSC_TXIM() uint32 {
	return (volatile.LoadUint32(&o.SSPIMSC.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSSPIMSC_RXIM(value uint32) {
	volatile.StoreUint32(&o.SSPIMSC.Reg, volatile.LoadUint32(&o.SSPIMSC.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSSPIMSC_RXIM() uint32 {
	return (volatile.LoadUint32(&o.SSPIMSC.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSSPIMSC_RTIM(value uint32) {
	volatile.StoreUint32(&o.SSPIMSC.Reg, volatile.LoadUint32(&o.SSPIMSC.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSSPIMSC_RTIM() uint32 {
	return (volatile.LoadUint32(&o.SSPIMSC.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSSPIMSC_RORIM(value uint32) {
	volatile.StoreUint32(&o.SSPIMSC.Reg, volatile.LoadUint32(&o.SSPIMSC.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSSPIMSC_RORIM() uint32 {
	return volatile.LoadUint32(&o.SSPIMSC.Reg) & 0x1
}

// SPI0.SSPRIS: Raw interrupt status register, SSPRIS on page 3-10
func (o *SPI0_Type) SetSSPRIS_TXRIS(value uint32) {
	volatile.StoreUint32(&o.SSPRIS.Reg, volatile.LoadUint32(&o.SSPRIS.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSSPRIS_TXRIS() uint32 {
	return (volatile.LoadUint32(&o.SSPRIS.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSSPRIS_RXRIS(value uint32) {
	volatile.StoreUint32(&o.SSPRIS.Reg, volatile.LoadUint32(&o.SSPRIS.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSSPRIS_RXRIS() uint32 {
	return (volatile.LoadUint32(&o.SSPRIS.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSSPRIS_RTRIS(value uint32) {
	volatile.StoreUint32(&o.SSPRIS.Reg, volatile.LoadUint32(&o.SSPRIS.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSSPRIS_RTRIS() uint32 {
	return (volatile.LoadUint32(&o.SSPRIS.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSSPRIS_RORRIS(value uint32) {
	volatile.StoreUint32(&o.SSPRIS.Reg, volatile.LoadUint32(&o.SSPRIS.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSSPRIS_RORRIS() uint32 {
	return volatile.LoadUint32(&o.SSPRIS.Reg) & 0x1
}

// SPI0.SSPMIS: Masked interrupt status register, SSPMIS on page 3-11
func (o *SPI0_Type) SetSSPMIS_TXMIS(value uint32) {
	volatile.StoreUint32(&o.SSPMIS.Reg, volatile.LoadUint32(&o.SSPMIS.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSSPMIS_TXMIS() uint32 {
	return (volatile.LoadUint32(&o.SSPMIS.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSSPMIS_RXMIS(value uint32) {
	volatile.StoreUint32(&o.SSPMIS.Reg, volatile.LoadUint32(&o.SSPMIS.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSSPMIS_RXMIS() uint32 {
	return (volatile.LoadUint32(&o.SSPMIS.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSSPMIS_RTMIS(value uint32) {
	volatile.StoreUint32(&o.SSPMIS.Reg, volatile.LoadUint32(&o.SSPMIS.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSSPMIS_RTMIS() uint32 {
	return (volatile.LoadUint32(&o.SSPMIS.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSSPMIS_RORMIS(value uint32) {
	volatile.StoreUint32(&o.SSPMIS.Reg, volatile.LoadUint32(&o.SSPMIS.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSSPMIS_RORMIS() uint32 {
	return volatile.LoadUint32(&o.SSPMIS.Reg) & 0x1
}

// SPI0.SSPICR: Interrupt clear register, SSPICR on page 3-11
func (o *SPI0_Type) SetSSPICR_RTIC(value uint32) {
	volatile.StoreUint32(&o.SSPICR.Reg, volatile.LoadUint32(&o.SSPICR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSSPICR_RTIC() uint32 {
	return (volatile.LoadUint32(&o.SSPICR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSSPICR_RORIC(value uint32) {
	volatile.StoreUint32(&o.SSPICR.Reg, volatile.LoadUint32(&o.SSPICR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSSPICR_RORIC() uint32 {
	return volatile.LoadUint32(&o.SSPICR.Reg) & 0x1
}

// SPI0.SSPDMACR: DMA control register, SSPDMACR on page 3-12
func (o *SPI0_Type) SetSSPDMACR_TXDMAE(value uint32) {
	volatile.StoreUint32(&o.SSPDMACR.Reg, volatile.LoadUint32(&o.SSPDMACR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSSPDMACR_TXDMAE() uint32 {
	return (volatile.LoadUint32(&o.SSPDMACR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSSPDMACR_RXDMAE(value uint32) {
	volatile.StoreUint32(&o.SSPDMACR.Reg, volatile.LoadUint32(&o.SSPDMACR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSSPDMACR_RXDMAE() uint32 {
	return volatile.LoadUint32(&o.SSPDMACR.Reg) & 0x1
}

// SPI0.SSPPERIPHID0: Peripheral identification registers, SSPPeriphID0-3 on page 3-13
func (o *SPI0_Type) SetSSPPERIPHID0_PARTNUMBER0(value uint32) {
	volatile.StoreUint32(&o.SSPPERIPHID0.Reg, volatile.LoadUint32(&o.SSPPERIPHID0.Reg)&^(0xff)|value)
}
func (o *SPI0_Type) GetSSPPERIPHID0_PARTNUMBER0() uint32 {
	return volatile.LoadUint32(&o.SSPPERIPHID0.Reg) & 0xff
}

// SPI0.SSPPERIPHID1: Peripheral identification registers, SSPPeriphID0-3 on page 3-13
func (o *SPI0_Type) SetSSPPERIPHID1_DESIGNER0(value uint32) {
	volatile.StoreUint32(&o.SSPPERIPHID1.Reg, volatile.LoadUint32(&o.SSPPERIPHID1.Reg)&^(0xf0)|value<<4)
}
func (o *SPI0_Type) GetSSPPERIPHID1_DESIGNER0() uint32 {
	return (volatile.LoadUint32(&o.SSPPERIPHID1.Reg) & 0xf0) >> 4
}
func (o *SPI0_Type) SetSSPPERIPHID1_PARTNUMBER1(value uint32) {
	volatile.StoreUint32(&o.SSPPERIPHID1.Reg, volatile.LoadUint32(&o.SSPPERIPHID1.Reg)&^(0xf)|value)
}
func (o *SPI0_Type) GetSSPPERIPHID1_PARTNUMBER1() uint32 {
	return volatile.LoadUint32(&o.SSPPERIPHID1.Reg) & 0xf
}

// SPI0.SSPPERIPHID2: Peripheral identification registers, SSPPeriphID0-3 on page 3-13
func (o *SPI0_Type) SetSSPPERIPHID2_REVISION(value uint32) {
	volatile.StoreUint32(&o.SSPPERIPHID2.Reg, volatile.LoadUint32(&o.SSPPERIPHID2.Reg)&^(0xf0)|value<<4)
}
func (o *SPI0_Type) GetSSPPERIPHID2_REVISION() uint32 {
	return (volatile.LoadUint32(&o.SSPPERIPHID2.Reg) & 0xf0) >> 4
}
func (o *SPI0_Type) SetSSPPERIPHID2_DESIGNER1(value uint32) {
	volatile.StoreUint32(&o.SSPPERIPHID2.Reg, volatile.LoadUint32(&o.SSPPERIPHID2.Reg)&^(0xf)|value)
}
func (o *SPI0_Type) GetSSPPERIPHID2_DESIGNER1() uint32 {
	return volatile.LoadUint32(&o.SSPPERIPHID2.Reg) & 0xf
}

// SPI0.SSPPERIPHID3: Peripheral identification registers, SSPPeriphID0-3 on page 3-13
func (o *SPI0_Type) SetSSPPERIPHID3_CONFIGURATION(value uint32) {
	volatile.StoreUint32(&o.SSPPERIPHID3.Reg, volatile.LoadUint32(&o.SSPPERIPHID3.Reg)&^(0xff)|value)
}
func (o *SPI0_Type) GetSSPPERIPHID3_CONFIGURATION() uint32 {
	return volatile.LoadUint32(&o.SSPPERIPHID3.Reg) & 0xff
}

// SPI0.SSPPCELLID0: PrimeCell identification registers, SSPPCellID0-3 on page 3-16
func (o *SPI0_Type) SetSSPPCELLID0(value uint32) {
	volatile.StoreUint32(&o.SSPPCELLID0.Reg, volatile.LoadUint32(&o.SSPPCELLID0.Reg)&^(0xff)|value)
}
func (o *SPI0_Type) GetSSPPCELLID0() uint32 {
	return volatile.LoadUint32(&o.SSPPCELLID0.Reg) & 0xff
}

// SPI0.SSPPCELLID1: PrimeCell identification registers, SSPPCellID0-3 on page 3-16
func (o *SPI0_Type) SetSSPPCELLID1(value uint32) {
	volatile.StoreUint32(&o.SSPPCELLID1.Reg, volatile.LoadUint32(&o.SSPPCELLID1.Reg)&^(0xff)|value)
}
func (o *SPI0_Type) GetSSPPCELLID1() uint32 {
	return volatile.LoadUint32(&o.SSPPCELLID1.Reg) & 0xff
}

// SPI0.SSPPCELLID2: PrimeCell identification registers, SSPPCellID0-3 on page 3-16
func (o *SPI0_Type) SetSSPPCELLID2(value uint32) {
	volatile.StoreUint32(&o.SSPPCELLID2.Reg, volatile.LoadUint32(&o.SSPPCELLID2.Reg)&^(0xff)|value)
}
func (o *SPI0_Type) GetSSPPCELLID2() uint32 {
	return volatile.LoadUint32(&o.SSPPCELLID2.Reg) & 0xff
}

// SPI0.SSPPCELLID3: PrimeCell identification registers, SSPPCellID0-3 on page 3-16
func (o *SPI0_Type) SetSSPPCELLID3(value uint32) {
	volatile.StoreUint32(&o.SSPPCELLID3.Reg, volatile.LoadUint32(&o.SSPPCELLID3.Reg)&^(0xff)|value)
}
func (o *SPI0_Type) GetSSPPCELLID3() uint32 {
	return volatile.LoadUint32(&o.SSPPCELLID3.Reg) & 0xff
}

// DW_apb_i2c address block
type I2C0_Type struct {
	IC_CON                volatile.Register32 // 0x0
	IC_TAR                volatile.Register32 // 0x4
	IC_SAR                volatile.Register32 // 0x8
	_                     [4]byte
	IC_DATA_CMD           volatile.Register32 // 0x10
	IC_SS_SCL_HCNT        volatile.Register32 // 0x14
	IC_SS_SCL_LCNT        volatile.Register32 // 0x18
	IC_FS_SCL_HCNT        volatile.Register32 // 0x1C
	IC_FS_SCL_LCNT        volatile.Register32 // 0x20
	_                     [8]byte
	IC_INTR_STAT          volatile.Register32 // 0x2C
	IC_INTR_MASK          volatile.Register32 // 0x30
	IC_RAW_INTR_STAT      volatile.Register32 // 0x34
	IC_RX_TL              volatile.Register32 // 0x38
	IC_TX_TL              volatile.Register32 // 0x3C
	IC_CLR_INTR           volatile.Register32 // 0x40
	IC_CLR_RX_UNDER       volatile.Register32 // 0x44
	IC_CLR_RX_OVER        volatile.Register32 // 0x48
	IC_CLR_TX_OVER        volatile.Register32 // 0x4C
	IC_CLR_RD_REQ         volatile.Register32 // 0x50
	IC_CLR_TX_ABRT        volatile.Register32 // 0x54
	IC_CLR_RX_DONE        volatile.Register32 // 0x58
	IC_CLR_ACTIVITY       volatile.Register32 // 0x5C
	IC_CLR_STOP_DET       volatile.Register32 // 0x60
	IC_CLR_START_DET      volatile.Register32 // 0x64
	IC_CLR_GEN_CALL       volatile.Register32 // 0x68
	IC_ENABLE             volatile.Register32 // 0x6C
	IC_STATUS             volatile.Register32 // 0x70
	IC_TXFLR              volatile.Register32 // 0x74
	IC_RXFLR              volatile.Register32 // 0x78
	IC_SDA_HOLD           volatile.Register32 // 0x7C
	IC_TX_ABRT_SOURCE     volatile.Register32 // 0x80
	IC_SLV_DATA_NACK_ONLY volatile.Register32 // 0x84
	IC_DMA_CR             volatile.Register32 // 0x88
	IC_DMA_TDLR           volatile.Register32 // 0x8C
	IC_DMA_RDLR           volatile.Register32 // 0x90
	IC_SDA_SETUP          volatile.Register32 // 0x94
	IC_ACK_GENERAL_CALL   volatile.Register32 // 0x98
	IC_ENABLE_STATUS      volatile.Register32 // 0x9C
	IC_FS_SPKLEN          volatile.Register32 // 0xA0
	_                     [4]byte
	IC_CLR_RESTART_DET    volatile.Register32 // 0xA8
	_                     [72]byte
	IC_COMP_PARAM_1       volatile.Register32 // 0xF4
	IC_COMP_VERSION       volatile.Register32 // 0xF8
	IC_COMP_TYPE          volatile.Register32 // 0xFC
}

// I2C0.IC_CON
// I2C Control Register. This register can be written only when the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n
// Read/Write Access: - bit 10 is read only. - bit 11 is read only - bit 16 is read only - bit 17 is read only - bits 18 and 19 are read only.
func (o *I2C0_Type) SetIC_CON_STOP_DET_IF_MASTER_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.IC_CON.Reg, volatile.LoadUint32(&o.IC_CON.Reg)&^(0x400)|value<<10)
}
func (o *I2C0_Type) GetIC_CON_STOP_DET_IF_MASTER_ACTIVE() uint32 {
	return (volatile.LoadUint32(&o.IC_CON.Reg) & 0x400) >> 10
}
func (o *I2C0_Type) SetIC_CON_RX_FIFO_FULL_HLD_CTRL(value uint32) {
	volatile.StoreUint32(&o.IC_CON.Reg, volatile.LoadUint32(&o.IC_CON.Reg)&^(0x200)|value<<9)
}
func (o *I2C0_Type) GetIC_CON_RX_FIFO_FULL_HLD_CTRL() uint32 {
	return (volatile.LoadUint32(&o.IC_CON.Reg) & 0x200) >> 9
}
func (o *I2C0_Type) SetIC_CON_TX_EMPTY_CTRL(value uint32) {
	volatile.StoreUint32(&o.IC_CON.Reg, volatile.LoadUint32(&o.IC_CON.Reg)&^(0x100)|value<<8)
}
func (o *I2C0_Type) GetIC_CON_TX_EMPTY_CTRL() uint32 {
	return (volatile.LoadUint32(&o.IC_CON.Reg) & 0x100) >> 8
}
func (o *I2C0_Type) SetIC_CON_STOP_DET_IFADDRESSED(value uint32) {
	volatile.StoreUint32(&o.IC_CON.Reg, volatile.LoadUint32(&o.IC_CON.Reg)&^(0x80)|value<<7)
}
func (o *I2C0_Type) GetIC_CON_STOP_DET_IFADDRESSED() uint32 {
	return (volatile.LoadUint32(&o.IC_CON.Reg) & 0x80) >> 7
}
func (o *I2C0_Type) SetIC_CON_IC_SLAVE_DISABLE(value uint32) {
	volatile.StoreUint32(&o.IC_CON.Reg, volatile.LoadUint32(&o.IC_CON.Reg)&^(0x40)|value<<6)
}
func (o *I2C0_Type) GetIC_CON_IC_SLAVE_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.IC_CON.Reg) & 0x40) >> 6
}
func (o *I2C0_Type) SetIC_CON_IC_RESTART_EN(value uint32) {
	volatile.StoreUint32(&o.IC_CON.Reg, volatile.LoadUint32(&o.IC_CON.Reg)&^(0x20)|value<<5)
}
func (o *I2C0_Type) GetIC_CON_IC_RESTART_EN() uint32 {
	return (volatile.LoadUint32(&o.IC_CON.Reg) & 0x20) >> 5
}
func (o *I2C0_Type) SetIC_CON_IC_10BITADDR_MASTER(value uint32) {
	volatile.StoreUint32(&o.IC_CON.Reg, volatile.LoadUint32(&o.IC_CON.Reg)&^(0x10)|value<<4)
}
func (o *I2C0_Type) GetIC_CON_IC_10BITADDR_MASTER() uint32 {
	return (volatile.LoadUint32(&o.IC_CON.Reg) & 0x10) >> 4
}
func (o *I2C0_Type) SetIC_CON_IC_10BITADDR_SLAVE(value uint32) {
	volatile.StoreUint32(&o.IC_CON.Reg, volatile.LoadUint32(&o.IC_CON.Reg)&^(0x8)|value<<3)
}
func (o *I2C0_Type) GetIC_CON_IC_10BITADDR_SLAVE() uint32 {
	return (volatile.LoadUint32(&o.IC_CON.Reg) & 0x8) >> 3
}
func (o *I2C0_Type) SetIC_CON_SPEED(value uint32) {
	volatile.StoreUint32(&o.IC_CON.Reg, volatile.LoadUint32(&o.IC_CON.Reg)&^(0x6)|value<<1)
}
func (o *I2C0_Type) GetIC_CON_SPEED() uint32 {
	return (volatile.LoadUint32(&o.IC_CON.Reg) & 0x6) >> 1
}
func (o *I2C0_Type) SetIC_CON_MASTER_MODE(value uint32) {
	volatile.StoreUint32(&o.IC_CON.Reg, volatile.LoadUint32(&o.IC_CON.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_CON_MASTER_MODE() uint32 {
	return volatile.LoadUint32(&o.IC_CON.Reg) & 0x1
}

// I2C0.IC_TAR
// I2C Target Address Register\n
// This register is 12 bits wide, and bits 31:12 are reserved. This register can be written to only when IC_ENABLE[0] is set to 0.\n
// Note: If the software or application is aware that the DW_apb_i2c is not using the TAR address for the pending commands in the Tx FIFO, then it is possible to update the TAR address even while the Tx FIFO has entries (IC_STATUS[2]= 0). - It is not necessary to perform any write to this register if DW_apb_i2c is enabled as an I2C slave only.
func (o *I2C0_Type) SetIC_TAR_SPECIAL(value uint32) {
	volatile.StoreUint32(&o.IC_TAR.Reg, volatile.LoadUint32(&o.IC_TAR.Reg)&^(0x800)|value<<11)
}
func (o *I2C0_Type) GetIC_TAR_SPECIAL() uint32 {
	return (volatile.LoadUint32(&o.IC_TAR.Reg) & 0x800) >> 11
}
func (o *I2C0_Type) SetIC_TAR_GC_OR_START(value uint32) {
	volatile.StoreUint32(&o.IC_TAR.Reg, volatile.LoadUint32(&o.IC_TAR.Reg)&^(0x400)|value<<10)
}
func (o *I2C0_Type) GetIC_TAR_GC_OR_START() uint32 {
	return (volatile.LoadUint32(&o.IC_TAR.Reg) & 0x400) >> 10
}
func (o *I2C0_Type) SetIC_TAR(value uint32) {
	volatile.StoreUint32(&o.IC_TAR.Reg, volatile.LoadUint32(&o.IC_TAR.Reg)&^(0x3ff)|value)
}
func (o *I2C0_Type) GetIC_TAR() uint32 {
	return volatile.LoadUint32(&o.IC_TAR.Reg) & 0x3ff
}

// I2C0.IC_SAR: I2C Slave Address Register
func (o *I2C0_Type) SetIC_SAR(value uint32) {
	volatile.StoreUint32(&o.IC_SAR.Reg, volatile.LoadUint32(&o.IC_SAR.Reg)&^(0x3ff)|value)
}
func (o *I2C0_Type) GetIC_SAR() uint32 {
	return volatile.LoadUint32(&o.IC_SAR.Reg) & 0x3ff
}

// I2C0.IC_DATA_CMD
// I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX FIFO.\n
// The size of the register changes as follows:\n
// Write: - 11 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read: - 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1 - 8 bits when IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order for the DW_apb_i2c to continue acknowledging reads, a read command should be written for every byte that is to be received; otherwise the DW_apb_i2c will stop acknowledging.
func (o *I2C0_Type) SetIC_DATA_CMD_FIRST_DATA_BYTE(value uint32) {
	volatile.StoreUint32(&o.IC_DATA_CMD.Reg, volatile.LoadUint32(&o.IC_DATA_CMD.Reg)&^(0x800)|value<<11)
}
func (o *I2C0_Type) GetIC_DATA_CMD_FIRST_DATA_BYTE() uint32 {
	return (volatile.LoadUint32(&o.IC_DATA_CMD.Reg) & 0x800) >> 11
}
func (o *I2C0_Type) SetIC_DATA_CMD_RESTART(value uint32) {
	volatile.StoreUint32(&o.IC_DATA_CMD.Reg, volatile.LoadUint32(&o.IC_DATA_CMD.Reg)&^(0x400)|value<<10)
}
func (o *I2C0_Type) GetIC_DATA_CMD_RESTART() uint32 {
	return (volatile.LoadUint32(&o.IC_DATA_CMD.Reg) & 0x400) >> 10
}
func (o *I2C0_Type) SetIC_DATA_CMD_STOP(value uint32) {
	volatile.StoreUint32(&o.IC_DATA_CMD.Reg, volatile.LoadUint32(&o.IC_DATA_CMD.Reg)&^(0x200)|value<<9)
}
func (o *I2C0_Type) GetIC_DATA_CMD_STOP() uint32 {
	return (volatile.LoadUint32(&o.IC_DATA_CMD.Reg) & 0x200) >> 9
}
func (o *I2C0_Type) SetIC_DATA_CMD_CMD(value uint32) {
	volatile.StoreUint32(&o.IC_DATA_CMD.Reg, volatile.LoadUint32(&o.IC_DATA_CMD.Reg)&^(0x100)|value<<8)
}
func (o *I2C0_Type) GetIC_DATA_CMD_CMD() uint32 {
	return (volatile.LoadUint32(&o.IC_DATA_CMD.Reg) & 0x100) >> 8
}
func (o *I2C0_Type) SetIC_DATA_CMD_DAT(value uint32) {
	volatile.StoreUint32(&o.IC_DATA_CMD.Reg, volatile.LoadUint32(&o.IC_DATA_CMD.Reg)&^(0xff)|value)
}
func (o *I2C0_Type) GetIC_DATA_CMD_DAT() uint32 {
	return volatile.LoadUint32(&o.IC_DATA_CMD.Reg) & 0xff
}

// I2C0.IC_SS_SCL_HCNT: Standard Speed I2C Clock SCL High Count Register
func (o *I2C0_Type) SetIC_SS_SCL_HCNT(value uint32) {
	volatile.StoreUint32(&o.IC_SS_SCL_HCNT.Reg, volatile.LoadUint32(&o.IC_SS_SCL_HCNT.Reg)&^(0xffff)|value)
}
func (o *I2C0_Type) GetIC_SS_SCL_HCNT() uint32 {
	return volatile.LoadUint32(&o.IC_SS_SCL_HCNT.Reg) & 0xffff
}

// I2C0.IC_SS_SCL_LCNT: Standard Speed I2C Clock SCL Low Count Register
func (o *I2C0_Type) SetIC_SS_SCL_LCNT(value uint32) {
	volatile.StoreUint32(&o.IC_SS_SCL_LCNT.Reg, volatile.LoadUint32(&o.IC_SS_SCL_LCNT.Reg)&^(0xffff)|value)
}
func (o *I2C0_Type) GetIC_SS_SCL_LCNT() uint32 {
	return volatile.LoadUint32(&o.IC_SS_SCL_LCNT.Reg) & 0xffff
}

// I2C0.IC_FS_SCL_HCNT: Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register
func (o *I2C0_Type) SetIC_FS_SCL_HCNT(value uint32) {
	volatile.StoreUint32(&o.IC_FS_SCL_HCNT.Reg, volatile.LoadUint32(&o.IC_FS_SCL_HCNT.Reg)&^(0xffff)|value)
}
func (o *I2C0_Type) GetIC_FS_SCL_HCNT() uint32 {
	return volatile.LoadUint32(&o.IC_FS_SCL_HCNT.Reg) & 0xffff
}

// I2C0.IC_FS_SCL_LCNT: Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register
func (o *I2C0_Type) SetIC_FS_SCL_LCNT(value uint32) {
	volatile.StoreUint32(&o.IC_FS_SCL_LCNT.Reg, volatile.LoadUint32(&o.IC_FS_SCL_LCNT.Reg)&^(0xffff)|value)
}
func (o *I2C0_Type) GetIC_FS_SCL_LCNT() uint32 {
	return volatile.LoadUint32(&o.IC_FS_SCL_LCNT.Reg) & 0xffff
}

// I2C0.IC_INTR_STAT
// I2C Interrupt Status Register\n
// Each bit in this register has a corresponding mask bit in the IC_INTR_MASK register. These bits are cleared by reading the matching interrupt clear register. The unmasked raw versions of these bits are available in the IC_RAW_INTR_STAT register.
func (o *I2C0_Type) SetIC_INTR_STAT_R_MASTER_ON_HOLD(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_INTR_STAT.Reg)&^(0x2000)|value<<13)
}
func (o *I2C0_Type) GetIC_INTR_STAT_R_MASTER_ON_HOLD() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_STAT.Reg) & 0x2000) >> 13
}
func (o *I2C0_Type) SetIC_INTR_STAT_R_RESTART_DET(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_INTR_STAT.Reg)&^(0x1000)|value<<12)
}
func (o *I2C0_Type) GetIC_INTR_STAT_R_RESTART_DET() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_STAT.Reg) & 0x1000) >> 12
}
func (o *I2C0_Type) SetIC_INTR_STAT_R_GEN_CALL(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_INTR_STAT.Reg)&^(0x800)|value<<11)
}
func (o *I2C0_Type) GetIC_INTR_STAT_R_GEN_CALL() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_STAT.Reg) & 0x800) >> 11
}
func (o *I2C0_Type) SetIC_INTR_STAT_R_START_DET(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_INTR_STAT.Reg)&^(0x400)|value<<10)
}
func (o *I2C0_Type) GetIC_INTR_STAT_R_START_DET() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_STAT.Reg) & 0x400) >> 10
}
func (o *I2C0_Type) SetIC_INTR_STAT_R_STOP_DET(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_INTR_STAT.Reg)&^(0x200)|value<<9)
}
func (o *I2C0_Type) GetIC_INTR_STAT_R_STOP_DET() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_STAT.Reg) & 0x200) >> 9
}
func (o *I2C0_Type) SetIC_INTR_STAT_R_ACTIVITY(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_INTR_STAT.Reg)&^(0x100)|value<<8)
}
func (o *I2C0_Type) GetIC_INTR_STAT_R_ACTIVITY() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_STAT.Reg) & 0x100) >> 8
}
func (o *I2C0_Type) SetIC_INTR_STAT_R_RX_DONE(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_INTR_STAT.Reg)&^(0x80)|value<<7)
}
func (o *I2C0_Type) GetIC_INTR_STAT_R_RX_DONE() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_STAT.Reg) & 0x80) >> 7
}
func (o *I2C0_Type) SetIC_INTR_STAT_R_TX_ABRT(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_INTR_STAT.Reg)&^(0x40)|value<<6)
}
func (o *I2C0_Type) GetIC_INTR_STAT_R_TX_ABRT() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_STAT.Reg) & 0x40) >> 6
}
func (o *I2C0_Type) SetIC_INTR_STAT_R_RD_REQ(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_INTR_STAT.Reg)&^(0x20)|value<<5)
}
func (o *I2C0_Type) GetIC_INTR_STAT_R_RD_REQ() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_STAT.Reg) & 0x20) >> 5
}
func (o *I2C0_Type) SetIC_INTR_STAT_R_TX_EMPTY(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_INTR_STAT.Reg)&^(0x10)|value<<4)
}
func (o *I2C0_Type) GetIC_INTR_STAT_R_TX_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_STAT.Reg) & 0x10) >> 4
}
func (o *I2C0_Type) SetIC_INTR_STAT_R_TX_OVER(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_INTR_STAT.Reg)&^(0x8)|value<<3)
}
func (o *I2C0_Type) GetIC_INTR_STAT_R_TX_OVER() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_STAT.Reg) & 0x8) >> 3
}
func (o *I2C0_Type) SetIC_INTR_STAT_R_RX_FULL(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_INTR_STAT.Reg)&^(0x4)|value<<2)
}
func (o *I2C0_Type) GetIC_INTR_STAT_R_RX_FULL() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_STAT.Reg) & 0x4) >> 2
}
func (o *I2C0_Type) SetIC_INTR_STAT_R_RX_OVER(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_INTR_STAT.Reg)&^(0x2)|value<<1)
}
func (o *I2C0_Type) GetIC_INTR_STAT_R_RX_OVER() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_STAT.Reg) & 0x2) >> 1
}
func (o *I2C0_Type) SetIC_INTR_STAT_R_RX_UNDER(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_INTR_STAT.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_INTR_STAT_R_RX_UNDER() uint32 {
	return volatile.LoadUint32(&o.IC_INTR_STAT.Reg) & 0x1
}

// I2C0.IC_INTR_MASK
// I2C Interrupt Mask Register.\n
// These bits mask their corresponding interrupt status bits. This register is active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the interrupt.
func (o *I2C0_Type) SetIC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_MASK.Reg, volatile.LoadUint32(&o.IC_INTR_MASK.Reg)&^(0x2000)|value<<13)
}
func (o *I2C0_Type) GetIC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_MASK.Reg) & 0x2000) >> 13
}
func (o *I2C0_Type) SetIC_INTR_MASK_M_RESTART_DET(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_MASK.Reg, volatile.LoadUint32(&o.IC_INTR_MASK.Reg)&^(0x1000)|value<<12)
}
func (o *I2C0_Type) GetIC_INTR_MASK_M_RESTART_DET() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_MASK.Reg) & 0x1000) >> 12
}
func (o *I2C0_Type) SetIC_INTR_MASK_M_GEN_CALL(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_MASK.Reg, volatile.LoadUint32(&o.IC_INTR_MASK.Reg)&^(0x800)|value<<11)
}
func (o *I2C0_Type) GetIC_INTR_MASK_M_GEN_CALL() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_MASK.Reg) & 0x800) >> 11
}
func (o *I2C0_Type) SetIC_INTR_MASK_M_START_DET(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_MASK.Reg, volatile.LoadUint32(&o.IC_INTR_MASK.Reg)&^(0x400)|value<<10)
}
func (o *I2C0_Type) GetIC_INTR_MASK_M_START_DET() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_MASK.Reg) & 0x400) >> 10
}
func (o *I2C0_Type) SetIC_INTR_MASK_M_STOP_DET(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_MASK.Reg, volatile.LoadUint32(&o.IC_INTR_MASK.Reg)&^(0x200)|value<<9)
}
func (o *I2C0_Type) GetIC_INTR_MASK_M_STOP_DET() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_MASK.Reg) & 0x200) >> 9
}
func (o *I2C0_Type) SetIC_INTR_MASK_M_ACTIVITY(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_MASK.Reg, volatile.LoadUint32(&o.IC_INTR_MASK.Reg)&^(0x100)|value<<8)
}
func (o *I2C0_Type) GetIC_INTR_MASK_M_ACTIVITY() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_MASK.Reg) & 0x100) >> 8
}
func (o *I2C0_Type) SetIC_INTR_MASK_M_RX_DONE(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_MASK.Reg, volatile.LoadUint32(&o.IC_INTR_MASK.Reg)&^(0x80)|value<<7)
}
func (o *I2C0_Type) GetIC_INTR_MASK_M_RX_DONE() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_MASK.Reg) & 0x80) >> 7
}
func (o *I2C0_Type) SetIC_INTR_MASK_M_TX_ABRT(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_MASK.Reg, volatile.LoadUint32(&o.IC_INTR_MASK.Reg)&^(0x40)|value<<6)
}
func (o *I2C0_Type) GetIC_INTR_MASK_M_TX_ABRT() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_MASK.Reg) & 0x40) >> 6
}
func (o *I2C0_Type) SetIC_INTR_MASK_M_RD_REQ(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_MASK.Reg, volatile.LoadUint32(&o.IC_INTR_MASK.Reg)&^(0x20)|value<<5)
}
func (o *I2C0_Type) GetIC_INTR_MASK_M_RD_REQ() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_MASK.Reg) & 0x20) >> 5
}
func (o *I2C0_Type) SetIC_INTR_MASK_M_TX_EMPTY(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_MASK.Reg, volatile.LoadUint32(&o.IC_INTR_MASK.Reg)&^(0x10)|value<<4)
}
func (o *I2C0_Type) GetIC_INTR_MASK_M_TX_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_MASK.Reg) & 0x10) >> 4
}
func (o *I2C0_Type) SetIC_INTR_MASK_M_TX_OVER(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_MASK.Reg, volatile.LoadUint32(&o.IC_INTR_MASK.Reg)&^(0x8)|value<<3)
}
func (o *I2C0_Type) GetIC_INTR_MASK_M_TX_OVER() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_MASK.Reg) & 0x8) >> 3
}
func (o *I2C0_Type) SetIC_INTR_MASK_M_RX_FULL(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_MASK.Reg, volatile.LoadUint32(&o.IC_INTR_MASK.Reg)&^(0x4)|value<<2)
}
func (o *I2C0_Type) GetIC_INTR_MASK_M_RX_FULL() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_MASK.Reg) & 0x4) >> 2
}
func (o *I2C0_Type) SetIC_INTR_MASK_M_RX_OVER(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_MASK.Reg, volatile.LoadUint32(&o.IC_INTR_MASK.Reg)&^(0x2)|value<<1)
}
func (o *I2C0_Type) GetIC_INTR_MASK_M_RX_OVER() uint32 {
	return (volatile.LoadUint32(&o.IC_INTR_MASK.Reg) & 0x2) >> 1
}
func (o *I2C0_Type) SetIC_INTR_MASK_M_RX_UNDER(value uint32) {
	volatile.StoreUint32(&o.IC_INTR_MASK.Reg, volatile.LoadUint32(&o.IC_INTR_MASK.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_INTR_MASK_M_RX_UNDER() uint32 {
	return volatile.LoadUint32(&o.IC_INTR_MASK.Reg) & 0x1
}

// I2C0.IC_RAW_INTR_STAT
// I2C Raw Interrupt Status Register\n
// Unlike the IC_INTR_STAT register, these bits are not masked so they always show the true status of the DW_apb_i2c.
func (o *I2C0_Type) SetIC_RAW_INTR_STAT_MASTER_ON_HOLD(value uint32) {
	volatile.StoreUint32(&o.IC_RAW_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg)&^(0x2000)|value<<13)
}
func (o *I2C0_Type) GetIC_RAW_INTR_STAT_MASTER_ON_HOLD() uint32 {
	return (volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg) & 0x2000) >> 13
}
func (o *I2C0_Type) SetIC_RAW_INTR_STAT_RESTART_DET(value uint32) {
	volatile.StoreUint32(&o.IC_RAW_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg)&^(0x1000)|value<<12)
}
func (o *I2C0_Type) GetIC_RAW_INTR_STAT_RESTART_DET() uint32 {
	return (volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg) & 0x1000) >> 12
}
func (o *I2C0_Type) SetIC_RAW_INTR_STAT_GEN_CALL(value uint32) {
	volatile.StoreUint32(&o.IC_RAW_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg)&^(0x800)|value<<11)
}
func (o *I2C0_Type) GetIC_RAW_INTR_STAT_GEN_CALL() uint32 {
	return (volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg) & 0x800) >> 11
}
func (o *I2C0_Type) SetIC_RAW_INTR_STAT_START_DET(value uint32) {
	volatile.StoreUint32(&o.IC_RAW_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg)&^(0x400)|value<<10)
}
func (o *I2C0_Type) GetIC_RAW_INTR_STAT_START_DET() uint32 {
	return (volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg) & 0x400) >> 10
}
func (o *I2C0_Type) SetIC_RAW_INTR_STAT_STOP_DET(value uint32) {
	volatile.StoreUint32(&o.IC_RAW_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg)&^(0x200)|value<<9)
}
func (o *I2C0_Type) GetIC_RAW_INTR_STAT_STOP_DET() uint32 {
	return (volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg) & 0x200) >> 9
}
func (o *I2C0_Type) SetIC_RAW_INTR_STAT_ACTIVITY(value uint32) {
	volatile.StoreUint32(&o.IC_RAW_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg)&^(0x100)|value<<8)
}
func (o *I2C0_Type) GetIC_RAW_INTR_STAT_ACTIVITY() uint32 {
	return (volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg) & 0x100) >> 8
}
func (o *I2C0_Type) SetIC_RAW_INTR_STAT_RX_DONE(value uint32) {
	volatile.StoreUint32(&o.IC_RAW_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg)&^(0x80)|value<<7)
}
func (o *I2C0_Type) GetIC_RAW_INTR_STAT_RX_DONE() uint32 {
	return (volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg) & 0x80) >> 7
}
func (o *I2C0_Type) SetIC_RAW_INTR_STAT_TX_ABRT(value uint32) {
	volatile.StoreUint32(&o.IC_RAW_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg)&^(0x40)|value<<6)
}
func (o *I2C0_Type) GetIC_RAW_INTR_STAT_TX_ABRT() uint32 {
	return (volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg) & 0x40) >> 6
}
func (o *I2C0_Type) SetIC_RAW_INTR_STAT_RD_REQ(value uint32) {
	volatile.StoreUint32(&o.IC_RAW_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg)&^(0x20)|value<<5)
}
func (o *I2C0_Type) GetIC_RAW_INTR_STAT_RD_REQ() uint32 {
	return (volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg) & 0x20) >> 5
}
func (o *I2C0_Type) SetIC_RAW_INTR_STAT_TX_EMPTY(value uint32) {
	volatile.StoreUint32(&o.IC_RAW_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg)&^(0x10)|value<<4)
}
func (o *I2C0_Type) GetIC_RAW_INTR_STAT_TX_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg) & 0x10) >> 4
}
func (o *I2C0_Type) SetIC_RAW_INTR_STAT_TX_OVER(value uint32) {
	volatile.StoreUint32(&o.IC_RAW_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg)&^(0x8)|value<<3)
}
func (o *I2C0_Type) GetIC_RAW_INTR_STAT_TX_OVER() uint32 {
	return (volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg) & 0x8) >> 3
}
func (o *I2C0_Type) SetIC_RAW_INTR_STAT_RX_FULL(value uint32) {
	volatile.StoreUint32(&o.IC_RAW_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg)&^(0x4)|value<<2)
}
func (o *I2C0_Type) GetIC_RAW_INTR_STAT_RX_FULL() uint32 {
	return (volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg) & 0x4) >> 2
}
func (o *I2C0_Type) SetIC_RAW_INTR_STAT_RX_OVER(value uint32) {
	volatile.StoreUint32(&o.IC_RAW_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg)&^(0x2)|value<<1)
}
func (o *I2C0_Type) GetIC_RAW_INTR_STAT_RX_OVER() uint32 {
	return (volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg) & 0x2) >> 1
}
func (o *I2C0_Type) SetIC_RAW_INTR_STAT_RX_UNDER(value uint32) {
	volatile.StoreUint32(&o.IC_RAW_INTR_STAT.Reg, volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_RAW_INTR_STAT_RX_UNDER() uint32 {
	return volatile.LoadUint32(&o.IC_RAW_INTR_STAT.Reg) & 0x1
}

// I2C0.IC_RX_TL: I2C Receive FIFO Threshold Register
func (o *I2C0_Type) SetIC_RX_TL_RX_TL(value uint32) {
	volatile.StoreUint32(&o.IC_RX_TL.Reg, volatile.LoadUint32(&o.IC_RX_TL.Reg)&^(0xff)|value)
}
func (o *I2C0_Type) GetIC_RX_TL_RX_TL() uint32 {
	return volatile.LoadUint32(&o.IC_RX_TL.Reg) & 0xff
}

// I2C0.IC_TX_TL: I2C Transmit FIFO Threshold Register
func (o *I2C0_Type) SetIC_TX_TL_TX_TL(value uint32) {
	volatile.StoreUint32(&o.IC_TX_TL.Reg, volatile.LoadUint32(&o.IC_TX_TL.Reg)&^(0xff)|value)
}
func (o *I2C0_Type) GetIC_TX_TL_TX_TL() uint32 {
	return volatile.LoadUint32(&o.IC_TX_TL.Reg) & 0xff
}

// I2C0.IC_CLR_INTR: Clear Combined and Individual Interrupt Register
func (o *I2C0_Type) SetIC_CLR_INTR_CLR_INTR(value uint32) {
	volatile.StoreUint32(&o.IC_CLR_INTR.Reg, volatile.LoadUint32(&o.IC_CLR_INTR.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_CLR_INTR_CLR_INTR() uint32 {
	return volatile.LoadUint32(&o.IC_CLR_INTR.Reg) & 0x1
}

// I2C0.IC_CLR_RX_UNDER: Clear RX_UNDER Interrupt Register
func (o *I2C0_Type) SetIC_CLR_RX_UNDER_CLR_RX_UNDER(value uint32) {
	volatile.StoreUint32(&o.IC_CLR_RX_UNDER.Reg, volatile.LoadUint32(&o.IC_CLR_RX_UNDER.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_CLR_RX_UNDER_CLR_RX_UNDER() uint32 {
	return volatile.LoadUint32(&o.IC_CLR_RX_UNDER.Reg) & 0x1
}

// I2C0.IC_CLR_RX_OVER: Clear RX_OVER Interrupt Register
func (o *I2C0_Type) SetIC_CLR_RX_OVER_CLR_RX_OVER(value uint32) {
	volatile.StoreUint32(&o.IC_CLR_RX_OVER.Reg, volatile.LoadUint32(&o.IC_CLR_RX_OVER.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_CLR_RX_OVER_CLR_RX_OVER() uint32 {
	return volatile.LoadUint32(&o.IC_CLR_RX_OVER.Reg) & 0x1
}

// I2C0.IC_CLR_TX_OVER: Clear TX_OVER Interrupt Register
func (o *I2C0_Type) SetIC_CLR_TX_OVER_CLR_TX_OVER(value uint32) {
	volatile.StoreUint32(&o.IC_CLR_TX_OVER.Reg, volatile.LoadUint32(&o.IC_CLR_TX_OVER.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_CLR_TX_OVER_CLR_TX_OVER() uint32 {
	return volatile.LoadUint32(&o.IC_CLR_TX_OVER.Reg) & 0x1
}

// I2C0.IC_CLR_RD_REQ: Clear RD_REQ Interrupt Register
func (o *I2C0_Type) SetIC_CLR_RD_REQ_CLR_RD_REQ(value uint32) {
	volatile.StoreUint32(&o.IC_CLR_RD_REQ.Reg, volatile.LoadUint32(&o.IC_CLR_RD_REQ.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_CLR_RD_REQ_CLR_RD_REQ() uint32 {
	return volatile.LoadUint32(&o.IC_CLR_RD_REQ.Reg) & 0x1
}

// I2C0.IC_CLR_TX_ABRT: Clear TX_ABRT Interrupt Register
func (o *I2C0_Type) SetIC_CLR_TX_ABRT_CLR_TX_ABRT(value uint32) {
	volatile.StoreUint32(&o.IC_CLR_TX_ABRT.Reg, volatile.LoadUint32(&o.IC_CLR_TX_ABRT.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_CLR_TX_ABRT_CLR_TX_ABRT() uint32 {
	return volatile.LoadUint32(&o.IC_CLR_TX_ABRT.Reg) & 0x1
}

// I2C0.IC_CLR_RX_DONE: Clear RX_DONE Interrupt Register
func (o *I2C0_Type) SetIC_CLR_RX_DONE_CLR_RX_DONE(value uint32) {
	volatile.StoreUint32(&o.IC_CLR_RX_DONE.Reg, volatile.LoadUint32(&o.IC_CLR_RX_DONE.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_CLR_RX_DONE_CLR_RX_DONE() uint32 {
	return volatile.LoadUint32(&o.IC_CLR_RX_DONE.Reg) & 0x1
}

// I2C0.IC_CLR_ACTIVITY: Clear ACTIVITY Interrupt Register
func (o *I2C0_Type) SetIC_CLR_ACTIVITY_CLR_ACTIVITY(value uint32) {
	volatile.StoreUint32(&o.IC_CLR_ACTIVITY.Reg, volatile.LoadUint32(&o.IC_CLR_ACTIVITY.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_CLR_ACTIVITY_CLR_ACTIVITY() uint32 {
	return volatile.LoadUint32(&o.IC_CLR_ACTIVITY.Reg) & 0x1
}

// I2C0.IC_CLR_STOP_DET: Clear STOP_DET Interrupt Register
func (o *I2C0_Type) SetIC_CLR_STOP_DET_CLR_STOP_DET(value uint32) {
	volatile.StoreUint32(&o.IC_CLR_STOP_DET.Reg, volatile.LoadUint32(&o.IC_CLR_STOP_DET.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_CLR_STOP_DET_CLR_STOP_DET() uint32 {
	return volatile.LoadUint32(&o.IC_CLR_STOP_DET.Reg) & 0x1
}

// I2C0.IC_CLR_START_DET: Clear START_DET Interrupt Register
func (o *I2C0_Type) SetIC_CLR_START_DET_CLR_START_DET(value uint32) {
	volatile.StoreUint32(&o.IC_CLR_START_DET.Reg, volatile.LoadUint32(&o.IC_CLR_START_DET.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_CLR_START_DET_CLR_START_DET() uint32 {
	return volatile.LoadUint32(&o.IC_CLR_START_DET.Reg) & 0x1
}

// I2C0.IC_CLR_GEN_CALL: Clear GEN_CALL Interrupt Register
func (o *I2C0_Type) SetIC_CLR_GEN_CALL_CLR_GEN_CALL(value uint32) {
	volatile.StoreUint32(&o.IC_CLR_GEN_CALL.Reg, volatile.LoadUint32(&o.IC_CLR_GEN_CALL.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_CLR_GEN_CALL_CLR_GEN_CALL() uint32 {
	return volatile.LoadUint32(&o.IC_CLR_GEN_CALL.Reg) & 0x1
}

// I2C0.IC_ENABLE: I2C Enable Register
func (o *I2C0_Type) SetIC_ENABLE_TX_CMD_BLOCK(value uint32) {
	volatile.StoreUint32(&o.IC_ENABLE.Reg, volatile.LoadUint32(&o.IC_ENABLE.Reg)&^(0x4)|value<<2)
}
func (o *I2C0_Type) GetIC_ENABLE_TX_CMD_BLOCK() uint32 {
	return (volatile.LoadUint32(&o.IC_ENABLE.Reg) & 0x4) >> 2
}
func (o *I2C0_Type) SetIC_ENABLE_ABORT(value uint32) {
	volatile.StoreUint32(&o.IC_ENABLE.Reg, volatile.LoadUint32(&o.IC_ENABLE.Reg)&^(0x2)|value<<1)
}
func (o *I2C0_Type) GetIC_ENABLE_ABORT() uint32 {
	return (volatile.LoadUint32(&o.IC_ENABLE.Reg) & 0x2) >> 1
}
func (o *I2C0_Type) SetIC_ENABLE_ENABLE(value uint32) {
	volatile.StoreUint32(&o.IC_ENABLE.Reg, volatile.LoadUint32(&o.IC_ENABLE.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_ENABLE_ENABLE() uint32 {
	return volatile.LoadUint32(&o.IC_ENABLE.Reg) & 0x1
}

// I2C0.IC_STATUS
// I2C Status Register\n
// This is a read-only register used to indicate the current transfer status and FIFO status. The status register may be read at any time. None of the bits in this register request an interrupt.\n
// When the I2C is disabled by writing 0 in bit 0 of the IC_ENABLE register: - Bits 1 and 2 are set to 1 - Bits 3 and 10 are set to 0 When the master or slave state machines goes to idle and ic_en=0: - Bits 5 and 6 are set to 0
func (o *I2C0_Type) SetIC_STATUS_SLV_ACTIVITY(value uint32) {
	volatile.StoreUint32(&o.IC_STATUS.Reg, volatile.LoadUint32(&o.IC_STATUS.Reg)&^(0x40)|value<<6)
}
func (o *I2C0_Type) GetIC_STATUS_SLV_ACTIVITY() uint32 {
	return (volatile.LoadUint32(&o.IC_STATUS.Reg) & 0x40) >> 6
}
func (o *I2C0_Type) SetIC_STATUS_MST_ACTIVITY(value uint32) {
	volatile.StoreUint32(&o.IC_STATUS.Reg, volatile.LoadUint32(&o.IC_STATUS.Reg)&^(0x20)|value<<5)
}
func (o *I2C0_Type) GetIC_STATUS_MST_ACTIVITY() uint32 {
	return (volatile.LoadUint32(&o.IC_STATUS.Reg) & 0x20) >> 5
}
func (o *I2C0_Type) SetIC_STATUS_RFF(value uint32) {
	volatile.StoreUint32(&o.IC_STATUS.Reg, volatile.LoadUint32(&o.IC_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *I2C0_Type) GetIC_STATUS_RFF() uint32 {
	return (volatile.LoadUint32(&o.IC_STATUS.Reg) & 0x10) >> 4
}
func (o *I2C0_Type) SetIC_STATUS_RFNE(value uint32) {
	volatile.StoreUint32(&o.IC_STATUS.Reg, volatile.LoadUint32(&o.IC_STATUS.Reg)&^(0x8)|value<<3)
}
func (o *I2C0_Type) GetIC_STATUS_RFNE() uint32 {
	return (volatile.LoadUint32(&o.IC_STATUS.Reg) & 0x8) >> 3
}
func (o *I2C0_Type) SetIC_STATUS_TFE(value uint32) {
	volatile.StoreUint32(&o.IC_STATUS.Reg, volatile.LoadUint32(&o.IC_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *I2C0_Type) GetIC_STATUS_TFE() uint32 {
	return (volatile.LoadUint32(&o.IC_STATUS.Reg) & 0x4) >> 2
}
func (o *I2C0_Type) SetIC_STATUS_TFNF(value uint32) {
	volatile.StoreUint32(&o.IC_STATUS.Reg, volatile.LoadUint32(&o.IC_STATUS.Reg)&^(0x2)|value<<1)
}
func (o *I2C0_Type) GetIC_STATUS_TFNF() uint32 {
	return (volatile.LoadUint32(&o.IC_STATUS.Reg) & 0x2) >> 1
}
func (o *I2C0_Type) SetIC_STATUS_ACTIVITY(value uint32) {
	volatile.StoreUint32(&o.IC_STATUS.Reg, volatile.LoadUint32(&o.IC_STATUS.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_STATUS_ACTIVITY() uint32 {
	return volatile.LoadUint32(&o.IC_STATUS.Reg) & 0x1
}

// I2C0.IC_TXFLR: I2C Transmit FIFO Level Register This register contains the number of valid data entries in the transmit FIFO buffer. It is cleared whenever: - The I2C is disabled - There is a transmit abort - that is, TX_ABRT bit is set in the IC_RAW_INTR_STAT register - The slave bulk transmit mode is aborted The register increments whenever data is placed into the transmit FIFO and decrements when data is taken from the transmit FIFO.
func (o *I2C0_Type) SetIC_TXFLR_TXFLR(value uint32) {
	volatile.StoreUint32(&o.IC_TXFLR.Reg, volatile.LoadUint32(&o.IC_TXFLR.Reg)&^(0x1f)|value)
}
func (o *I2C0_Type) GetIC_TXFLR_TXFLR() uint32 {
	return volatile.LoadUint32(&o.IC_TXFLR.Reg) & 0x1f
}

// I2C0.IC_RXFLR: I2C Receive FIFO Level Register This register contains the number of valid data entries in the receive FIFO buffer. It is cleared whenever: - The I2C is disabled - Whenever there is a transmit abort caused by any of the events tracked in IC_TX_ABRT_SOURCE The register increments whenever data is placed into the receive FIFO and decrements when data is taken from the receive FIFO.
func (o *I2C0_Type) SetIC_RXFLR_RXFLR(value uint32) {
	volatile.StoreUint32(&o.IC_RXFLR.Reg, volatile.LoadUint32(&o.IC_RXFLR.Reg)&^(0x1f)|value)
}
func (o *I2C0_Type) GetIC_RXFLR_RXFLR() uint32 {
	return volatile.LoadUint32(&o.IC_RXFLR.Reg) & 0x1f
}

// I2C0.IC_SDA_HOLD
// I2C SDA Hold Time Length Register\n
// The bits [15:0] of this register are used to control the hold time of SDA during transmit in both slave and master mode (after SCL goes from HIGH to LOW).\n
// The bits [23:16] of this register are used to extend the SDA transition (if any) whenever SCL is HIGH in the receiver in either master or slave mode.\n
// Writes to this register succeed only when IC_ENABLE[0]=0.\n
// The values in this register are in units of ic_clk period. The value programmed in IC_SDA_TX_HOLD must be greater than the minimum hold time in each mode one cycle in master mode, seven cycles in slave mode for the value to be implemented.\n
// The programmed SDA hold time during transmit (IC_SDA_TX_HOLD) cannot exceed at any time the duration of the low part of scl. Therefore the programmed value cannot be larger than N_SCL_LOW-2, where N_SCL_LOW is the duration of the low part of the scl period measured in ic_clk cycles.
func (o *I2C0_Type) SetIC_SDA_HOLD_IC_SDA_RX_HOLD(value uint32) {
	volatile.StoreUint32(&o.IC_SDA_HOLD.Reg, volatile.LoadUint32(&o.IC_SDA_HOLD.Reg)&^(0xff0000)|value<<16)
}
func (o *I2C0_Type) GetIC_SDA_HOLD_IC_SDA_RX_HOLD() uint32 {
	return (volatile.LoadUint32(&o.IC_SDA_HOLD.Reg) & 0xff0000) >> 16
}
func (o *I2C0_Type) SetIC_SDA_HOLD_IC_SDA_TX_HOLD(value uint32) {
	volatile.StoreUint32(&o.IC_SDA_HOLD.Reg, volatile.LoadUint32(&o.IC_SDA_HOLD.Reg)&^(0xffff)|value)
}
func (o *I2C0_Type) GetIC_SDA_HOLD_IC_SDA_TX_HOLD() uint32 {
	return volatile.LoadUint32(&o.IC_SDA_HOLD.Reg) & 0xffff
}

// I2C0.IC_TX_ABRT_SOURCE
// I2C Transmit Abort Source Register\n
// This register has 32 bits that indicate the source of the TX_ABRT bit. Except for Bit 9, this register is cleared whenever the IC_CLR_TX_ABRT register or the IC_CLR_INTR register is read. To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; RESTART must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]).\n
// Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, Bit 9 clears for one cycle and is then re-asserted.
func (o *I2C0_Type) SetIC_TX_ABRT_SOURCE_TX_FLUSH_CNT(value uint32) {
	volatile.StoreUint32(&o.IC_TX_ABRT_SOURCE.Reg, volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg)&^(0xff800000)|value<<23)
}
func (o *I2C0_Type) GetIC_TX_ABRT_SOURCE_TX_FLUSH_CNT() uint32 {
	return (volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg) & 0xff800000) >> 23
}
func (o *I2C0_Type) SetIC_TX_ABRT_SOURCE_ABRT_USER_ABRT(value uint32) {
	volatile.StoreUint32(&o.IC_TX_ABRT_SOURCE.Reg, volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg)&^(0x10000)|value<<16)
}
func (o *I2C0_Type) GetIC_TX_ABRT_SOURCE_ABRT_USER_ABRT() uint32 {
	return (volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg) & 0x10000) >> 16
}
func (o *I2C0_Type) SetIC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX(value uint32) {
	volatile.StoreUint32(&o.IC_TX_ABRT_SOURCE.Reg, volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg)&^(0x8000)|value<<15)
}
func (o *I2C0_Type) GetIC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX() uint32 {
	return (volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg) & 0x8000) >> 15
}
func (o *I2C0_Type) SetIC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST(value uint32) {
	volatile.StoreUint32(&o.IC_TX_ABRT_SOURCE.Reg, volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg)&^(0x4000)|value<<14)
}
func (o *I2C0_Type) GetIC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST() uint32 {
	return (volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg) & 0x4000) >> 14
}
func (o *I2C0_Type) SetIC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO(value uint32) {
	volatile.StoreUint32(&o.IC_TX_ABRT_SOURCE.Reg, volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg)&^(0x2000)|value<<13)
}
func (o *I2C0_Type) GetIC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO() uint32 {
	return (volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg) & 0x2000) >> 13
}
func (o *I2C0_Type) SetIC_TX_ABRT_SOURCE_ARB_LOST(value uint32) {
	volatile.StoreUint32(&o.IC_TX_ABRT_SOURCE.Reg, volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg)&^(0x1000)|value<<12)
}
func (o *I2C0_Type) GetIC_TX_ABRT_SOURCE_ARB_LOST() uint32 {
	return (volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg) & 0x1000) >> 12
}
func (o *I2C0_Type) SetIC_TX_ABRT_SOURCE_ABRT_MASTER_DIS(value uint32) {
	volatile.StoreUint32(&o.IC_TX_ABRT_SOURCE.Reg, volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg)&^(0x800)|value<<11)
}
func (o *I2C0_Type) GetIC_TX_ABRT_SOURCE_ABRT_MASTER_DIS() uint32 {
	return (volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg) & 0x800) >> 11
}
func (o *I2C0_Type) SetIC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT(value uint32) {
	volatile.StoreUint32(&o.IC_TX_ABRT_SOURCE.Reg, volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg)&^(0x400)|value<<10)
}
func (o *I2C0_Type) GetIC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT() uint32 {
	return (volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg) & 0x400) >> 10
}
func (o *I2C0_Type) SetIC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT(value uint32) {
	volatile.StoreUint32(&o.IC_TX_ABRT_SOURCE.Reg, volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg)&^(0x200)|value<<9)
}
func (o *I2C0_Type) GetIC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT() uint32 {
	return (volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg) & 0x200) >> 9
}
func (o *I2C0_Type) SetIC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT(value uint32) {
	volatile.StoreUint32(&o.IC_TX_ABRT_SOURCE.Reg, volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg)&^(0x100)|value<<8)
}
func (o *I2C0_Type) GetIC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT() uint32 {
	return (volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg) & 0x100) >> 8
}
func (o *I2C0_Type) SetIC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET(value uint32) {
	volatile.StoreUint32(&o.IC_TX_ABRT_SOURCE.Reg, volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg)&^(0x80)|value<<7)
}
func (o *I2C0_Type) GetIC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET() uint32 {
	return (volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg) & 0x80) >> 7
}
func (o *I2C0_Type) SetIC_TX_ABRT_SOURCE_ABRT_HS_ACKDET(value uint32) {
	volatile.StoreUint32(&o.IC_TX_ABRT_SOURCE.Reg, volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg)&^(0x40)|value<<6)
}
func (o *I2C0_Type) GetIC_TX_ABRT_SOURCE_ABRT_HS_ACKDET() uint32 {
	return (volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg) & 0x40) >> 6
}
func (o *I2C0_Type) SetIC_TX_ABRT_SOURCE_ABRT_GCALL_READ(value uint32) {
	volatile.StoreUint32(&o.IC_TX_ABRT_SOURCE.Reg, volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg)&^(0x20)|value<<5)
}
func (o *I2C0_Type) GetIC_TX_ABRT_SOURCE_ABRT_GCALL_READ() uint32 {
	return (volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg) & 0x20) >> 5
}
func (o *I2C0_Type) SetIC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK(value uint32) {
	volatile.StoreUint32(&o.IC_TX_ABRT_SOURCE.Reg, volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg)&^(0x10)|value<<4)
}
func (o *I2C0_Type) GetIC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK() uint32 {
	return (volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg) & 0x10) >> 4
}
func (o *I2C0_Type) SetIC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK(value uint32) {
	volatile.StoreUint32(&o.IC_TX_ABRT_SOURCE.Reg, volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg)&^(0x8)|value<<3)
}
func (o *I2C0_Type) GetIC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK() uint32 {
	return (volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg) & 0x8) >> 3
}
func (o *I2C0_Type) SetIC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK(value uint32) {
	volatile.StoreUint32(&o.IC_TX_ABRT_SOURCE.Reg, volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg)&^(0x4)|value<<2)
}
func (o *I2C0_Type) GetIC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK() uint32 {
	return (volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg) & 0x4) >> 2
}
func (o *I2C0_Type) SetIC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK(value uint32) {
	volatile.StoreUint32(&o.IC_TX_ABRT_SOURCE.Reg, volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg)&^(0x2)|value<<1)
}
func (o *I2C0_Type) GetIC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK() uint32 {
	return (volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg) & 0x2) >> 1
}
func (o *I2C0_Type) SetIC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK(value uint32) {
	volatile.StoreUint32(&o.IC_TX_ABRT_SOURCE.Reg, volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK() uint32 {
	return volatile.LoadUint32(&o.IC_TX_ABRT_SOURCE.Reg) & 0x1
}

// I2C0.IC_SLV_DATA_NACK_ONLY
// Generate Slave Data NACK Register\n
// The register is used to generate a NACK for the data part of a transfer when DW_apb_i2c is acting as a slave-receiver. This register only exists when the IC_SLV_DATA_NACK_ONLY parameter is set to 1. When this parameter disabled, this register does not exist and writing to the register's address has no effect.\n
// A write can occur on this register if both of the following conditions are met: - DW_apb_i2c is disabled (IC_ENABLE[0] = 0) - Slave part is inactive (IC_STATUS[6] = 0) Note: The IC_STATUS[6] is a register read-back location for the internal slv_activity signal; the user should poll this before writing the ic_slv_data_nack_only bit.
func (o *I2C0_Type) SetIC_SLV_DATA_NACK_ONLY_NACK(value uint32) {
	volatile.StoreUint32(&o.IC_SLV_DATA_NACK_ONLY.Reg, volatile.LoadUint32(&o.IC_SLV_DATA_NACK_ONLY.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_SLV_DATA_NACK_ONLY_NACK() uint32 {
	return volatile.LoadUint32(&o.IC_SLV_DATA_NACK_ONLY.Reg) & 0x1
}

// I2C0.IC_DMA_CR
// DMA Control Register\n
// The register is used to enable the DMA Controller interface operation. There is a separate bit for transmit and receive. This can be programmed regardless of the state of IC_ENABLE.
func (o *I2C0_Type) SetIC_DMA_CR_TDMAE(value uint32) {
	volatile.StoreUint32(&o.IC_DMA_CR.Reg, volatile.LoadUint32(&o.IC_DMA_CR.Reg)&^(0x2)|value<<1)
}
func (o *I2C0_Type) GetIC_DMA_CR_TDMAE() uint32 {
	return (volatile.LoadUint32(&o.IC_DMA_CR.Reg) & 0x2) >> 1
}
func (o *I2C0_Type) SetIC_DMA_CR_RDMAE(value uint32) {
	volatile.StoreUint32(&o.IC_DMA_CR.Reg, volatile.LoadUint32(&o.IC_DMA_CR.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_DMA_CR_RDMAE() uint32 {
	return volatile.LoadUint32(&o.IC_DMA_CR.Reg) & 0x1
}

// I2C0.IC_DMA_TDLR: DMA Transmit Data Level Register
func (o *I2C0_Type) SetIC_DMA_TDLR_DMATDL(value uint32) {
	volatile.StoreUint32(&o.IC_DMA_TDLR.Reg, volatile.LoadUint32(&o.IC_DMA_TDLR.Reg)&^(0xf)|value)
}
func (o *I2C0_Type) GetIC_DMA_TDLR_DMATDL() uint32 {
	return volatile.LoadUint32(&o.IC_DMA_TDLR.Reg) & 0xf
}

// I2C0.IC_DMA_RDLR: I2C Receive Data Level Register
func (o *I2C0_Type) SetIC_DMA_RDLR_DMARDL(value uint32) {
	volatile.StoreUint32(&o.IC_DMA_RDLR.Reg, volatile.LoadUint32(&o.IC_DMA_RDLR.Reg)&^(0xf)|value)
}
func (o *I2C0_Type) GetIC_DMA_RDLR_DMARDL() uint32 {
	return volatile.LoadUint32(&o.IC_DMA_RDLR.Reg) & 0xf
}

// I2C0.IC_SDA_SETUP
// I2C SDA Setup Register\n
// This register controls the amount of time delay (in terms of number of ic_clk clock periods) introduced in the rising edge of SCL - relative to SDA changing - when DW_apb_i2c services a read request in a slave-transmitter operation. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2.\n
// Writes to this register succeed only when IC_ENABLE[0] = 0.\n
// Note: The length of setup time is calculated using [(IC_SDA_SETUP - 1) * (ic_clk_period)], so if the user requires 10 ic_clk periods of setup time, they should program a value of 11. The IC_SDA_SETUP register is only used by the DW_apb_i2c when operating as a slave transmitter.
func (o *I2C0_Type) SetIC_SDA_SETUP_SDA_SETUP(value uint32) {
	volatile.StoreUint32(&o.IC_SDA_SETUP.Reg, volatile.LoadUint32(&o.IC_SDA_SETUP.Reg)&^(0xff)|value)
}
func (o *I2C0_Type) GetIC_SDA_SETUP_SDA_SETUP() uint32 {
	return volatile.LoadUint32(&o.IC_SDA_SETUP.Reg) & 0xff
}

// I2C0.IC_ACK_GENERAL_CALL
// I2C ACK General Call Register\n
// The register controls whether DW_apb_i2c responds with a ACK or NACK when it receives an I2C General Call address.\n
// This register is applicable only when the DW_apb_i2c is in slave mode.
func (o *I2C0_Type) SetIC_ACK_GENERAL_CALL_ACK_GEN_CALL(value uint32) {
	volatile.StoreUint32(&o.IC_ACK_GENERAL_CALL.Reg, volatile.LoadUint32(&o.IC_ACK_GENERAL_CALL.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_ACK_GENERAL_CALL_ACK_GEN_CALL() uint32 {
	return volatile.LoadUint32(&o.IC_ACK_GENERAL_CALL.Reg) & 0x1
}

// I2C0.IC_ENABLE_STATUS
// I2C Enable Status Register\n
// The register is used to report the DW_apb_i2c hardware status when the IC_ENABLE[0] register is set from 1 to 0; that is, when DW_apb_i2c is disabled.\n
// If IC_ENABLE[0] has been set to 1, bits 2:1 are forced to 0, and bit 0 is forced to 1.\n
// If IC_ENABLE[0] has been set to 0, bits 2:1 is only be valid as soon as bit 0 is read as '0'.\n
// Note: When IC_ENABLE[0] has been set to 0, a delay occurs for bit 0 to be read as 0 because disabling the DW_apb_i2c depends on I2C bus activities.
func (o *I2C0_Type) SetIC_ENABLE_STATUS_SLV_RX_DATA_LOST(value uint32) {
	volatile.StoreUint32(&o.IC_ENABLE_STATUS.Reg, volatile.LoadUint32(&o.IC_ENABLE_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *I2C0_Type) GetIC_ENABLE_STATUS_SLV_RX_DATA_LOST() uint32 {
	return (volatile.LoadUint32(&o.IC_ENABLE_STATUS.Reg) & 0x4) >> 2
}
func (o *I2C0_Type) SetIC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY(value uint32) {
	volatile.StoreUint32(&o.IC_ENABLE_STATUS.Reg, volatile.LoadUint32(&o.IC_ENABLE_STATUS.Reg)&^(0x2)|value<<1)
}
func (o *I2C0_Type) GetIC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY() uint32 {
	return (volatile.LoadUint32(&o.IC_ENABLE_STATUS.Reg) & 0x2) >> 1
}
func (o *I2C0_Type) SetIC_ENABLE_STATUS_IC_EN(value uint32) {
	volatile.StoreUint32(&o.IC_ENABLE_STATUS.Reg, volatile.LoadUint32(&o.IC_ENABLE_STATUS.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_ENABLE_STATUS_IC_EN() uint32 {
	return volatile.LoadUint32(&o.IC_ENABLE_STATUS.Reg) & 0x1
}

// I2C0.IC_FS_SPKLEN
// I2C SS, FS or FM+ spike suppression limit\n
// This register is used to store the duration, measured in ic_clk cycles, of the longest spike that is filtered out by the spike suppression logic when the component is operating in SS, FS or FM+ modes. The relevant I2C requirement is tSP (table 4) as detailed in the I2C Bus Specification. This register must be programmed with a minimum value of 1.
func (o *I2C0_Type) SetIC_FS_SPKLEN(value uint32) {
	volatile.StoreUint32(&o.IC_FS_SPKLEN.Reg, volatile.LoadUint32(&o.IC_FS_SPKLEN.Reg)&^(0xff)|value)
}
func (o *I2C0_Type) GetIC_FS_SPKLEN() uint32 {
	return volatile.LoadUint32(&o.IC_FS_SPKLEN.Reg) & 0xff
}

// I2C0.IC_CLR_RESTART_DET: Clear RESTART_DET Interrupt Register
func (o *I2C0_Type) SetIC_CLR_RESTART_DET_CLR_RESTART_DET(value uint32) {
	volatile.StoreUint32(&o.IC_CLR_RESTART_DET.Reg, volatile.LoadUint32(&o.IC_CLR_RESTART_DET.Reg)&^(0x1)|value)
}
func (o *I2C0_Type) GetIC_CLR_RESTART_DET_CLR_RESTART_DET() uint32 {
	return volatile.LoadUint32(&o.IC_CLR_RESTART_DET.Reg) & 0x1
}

// I2C0.IC_COMP_PARAM_1
// Component Parameter Register 1\n
// Note This register is not implemented and therefore reads as 0. If it was implemented it would be a constant read-only register that contains encoded information about the component's parameter settings. Fields shown below are the settings for those parameters
func (o *I2C0_Type) SetIC_COMP_PARAM_1_TX_BUFFER_DEPTH(value uint32) {
	volatile.StoreUint32(&o.IC_COMP_PARAM_1.Reg, volatile.LoadUint32(&o.IC_COMP_PARAM_1.Reg)&^(0xff0000)|value<<16)
}
func (o *I2C0_Type) GetIC_COMP_PARAM_1_TX_BUFFER_DEPTH() uint32 {
	return (volatile.LoadUint32(&o.IC_COMP_PARAM_1.Reg) & 0xff0000) >> 16
}
func (o *I2C0_Type) SetIC_COMP_PARAM_1_RX_BUFFER_DEPTH(value uint32) {
	volatile.StoreUint32(&o.IC_COMP_PARAM_1.Reg, volatile.LoadUint32(&o.IC_COMP_PARAM_1.Reg)&^(0xff00)|value<<8)
}
func (o *I2C0_Type) GetIC_COMP_PARAM_1_RX_BUFFER_DEPTH() uint32 {
	return (volatile.LoadUint32(&o.IC_COMP_PARAM_1.Reg) & 0xff00) >> 8
}
func (o *I2C0_Type) SetIC_COMP_PARAM_1_ADD_ENCODED_PARAMS(value uint32) {
	volatile.StoreUint32(&o.IC_COMP_PARAM_1.Reg, volatile.LoadUint32(&o.IC_COMP_PARAM_1.Reg)&^(0x80)|value<<7)
}
func (o *I2C0_Type) GetIC_COMP_PARAM_1_ADD_ENCODED_PARAMS() uint32 {
	return (volatile.LoadUint32(&o.IC_COMP_PARAM_1.Reg) & 0x80) >> 7
}
func (o *I2C0_Type) SetIC_COMP_PARAM_1_HAS_DMA(value uint32) {
	volatile.StoreUint32(&o.IC_COMP_PARAM_1.Reg, volatile.LoadUint32(&o.IC_COMP_PARAM_1.Reg)&^(0x40)|value<<6)
}
func (o *I2C0_Type) GetIC_COMP_PARAM_1_HAS_DMA() uint32 {
	return (volatile.LoadUint32(&o.IC_COMP_PARAM_1.Reg) & 0x40) >> 6
}
func (o *I2C0_Type) SetIC_COMP_PARAM_1_INTR_IO(value uint32) {
	volatile.StoreUint32(&o.IC_COMP_PARAM_1.Reg, volatile.LoadUint32(&o.IC_COMP_PARAM_1.Reg)&^(0x20)|value<<5)
}
func (o *I2C0_Type) GetIC_COMP_PARAM_1_INTR_IO() uint32 {
	return (volatile.LoadUint32(&o.IC_COMP_PARAM_1.Reg) & 0x20) >> 5
}
func (o *I2C0_Type) SetIC_COMP_PARAM_1_HC_COUNT_VALUES(value uint32) {
	volatile.StoreUint32(&o.IC_COMP_PARAM_1.Reg, volatile.LoadUint32(&o.IC_COMP_PARAM_1.Reg)&^(0x10)|value<<4)
}
func (o *I2C0_Type) GetIC_COMP_PARAM_1_HC_COUNT_VALUES() uint32 {
	return (volatile.LoadUint32(&o.IC_COMP_PARAM_1.Reg) & 0x10) >> 4
}
func (o *I2C0_Type) SetIC_COMP_PARAM_1_MAX_SPEED_MODE(value uint32) {
	volatile.StoreUint32(&o.IC_COMP_PARAM_1.Reg, volatile.LoadUint32(&o.IC_COMP_PARAM_1.Reg)&^(0xc)|value<<2)
}
func (o *I2C0_Type) GetIC_COMP_PARAM_1_MAX_SPEED_MODE() uint32 {
	return (volatile.LoadUint32(&o.IC_COMP_PARAM_1.Reg) & 0xc) >> 2
}
func (o *I2C0_Type) SetIC_COMP_PARAM_1_APB_DATA_WIDTH(value uint32) {
	volatile.StoreUint32(&o.IC_COMP_PARAM_1.Reg, volatile.LoadUint32(&o.IC_COMP_PARAM_1.Reg)&^(0x3)|value)
}
func (o *I2C0_Type) GetIC_COMP_PARAM_1_APB_DATA_WIDTH() uint32 {
	return volatile.LoadUint32(&o.IC_COMP_PARAM_1.Reg) & 0x3
}

// I2C0.IC_COMP_VERSION: I2C Component Version Register
func (o *I2C0_Type) SetIC_COMP_VERSION(value uint32) {
	volatile.StoreUint32(&o.IC_COMP_VERSION.Reg, value)
}
func (o *I2C0_Type) GetIC_COMP_VERSION() uint32 {
	return volatile.LoadUint32(&o.IC_COMP_VERSION.Reg)
}

// I2C0.IC_COMP_TYPE: I2C Component Type Register
func (o *I2C0_Type) SetIC_COMP_TYPE(value uint32) {
	volatile.StoreUint32(&o.IC_COMP_TYPE.Reg, value)
}
func (o *I2C0_Type) GetIC_COMP_TYPE() uint32 {
	return volatile.LoadUint32(&o.IC_COMP_TYPE.Reg)
}

// Control and data interface to SAR ADC
type ADC_Type struct {
	CS     volatile.Register32 // 0x0
	RESULT volatile.Register32 // 0x4
	FCS    volatile.Register32 // 0x8
	FIFO   volatile.Register32 // 0xC
	DIV    volatile.Register32 // 0x10
	INTR   volatile.Register32 // 0x14
	INTE   volatile.Register32 // 0x18
	INTF   volatile.Register32 // 0x1C
	INTS   volatile.Register32 // 0x20
}

// ADC.CS: ADC Control and Status
func (o *ADC_Type) SetCS_RROBIN(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x1f0000)|value<<16)
}
func (o *ADC_Type) GetCS_RROBIN() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x1f0000) >> 16
}
func (o *ADC_Type) SetCS_AINSEL(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x7000)|value<<12)
}
func (o *ADC_Type) GetCS_AINSEL() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x7000) >> 12
}
func (o *ADC_Type) SetCS_ERR_STICKY(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetCS_ERR_STICKY() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetCS_ERR(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetCS_ERR() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetCS_READY(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetCS_READY() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetCS_START_MANY(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetCS_START_MANY() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetCS_START_ONCE(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetCS_START_ONCE() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetCS_TS_EN(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCS_TS_EN() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCS_EN(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCS_EN() uint32 {
	return volatile.LoadUint32(&o.CS.Reg) & 0x1
}

// ADC.RESULT: Result of most recent ADC conversion
func (o *ADC_Type) SetRESULT(value uint32) {
	volatile.StoreUint32(&o.RESULT.Reg, volatile.LoadUint32(&o.RESULT.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetRESULT() uint32 {
	return volatile.LoadUint32(&o.RESULT.Reg) & 0xfff
}

// ADC.FCS: FIFO control and status
func (o *ADC_Type) SetFCS_THRESH(value uint32) {
	volatile.StoreUint32(&o.FCS.Reg, volatile.LoadUint32(&o.FCS.Reg)&^(0xf000000)|value<<24)
}
func (o *ADC_Type) GetFCS_THRESH() uint32 {
	return (volatile.LoadUint32(&o.FCS.Reg) & 0xf000000) >> 24
}
func (o *ADC_Type) SetFCS_LEVEL(value uint32) {
	volatile.StoreUint32(&o.FCS.Reg, volatile.LoadUint32(&o.FCS.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_Type) GetFCS_LEVEL() uint32 {
	return (volatile.LoadUint32(&o.FCS.Reg) & 0xf0000) >> 16
}
func (o *ADC_Type) SetFCS_OVER(value uint32) {
	volatile.StoreUint32(&o.FCS.Reg, volatile.LoadUint32(&o.FCS.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetFCS_OVER() uint32 {
	return (volatile.LoadUint32(&o.FCS.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetFCS_UNDER(value uint32) {
	volatile.StoreUint32(&o.FCS.Reg, volatile.LoadUint32(&o.FCS.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetFCS_UNDER() uint32 {
	return (volatile.LoadUint32(&o.FCS.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetFCS_FULL(value uint32) {
	volatile.StoreUint32(&o.FCS.Reg, volatile.LoadUint32(&o.FCS.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetFCS_FULL() uint32 {
	return (volatile.LoadUint32(&o.FCS.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetFCS_EMPTY(value uint32) {
	volatile.StoreUint32(&o.FCS.Reg, volatile.LoadUint32(&o.FCS.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetFCS_EMPTY() uint32 {
	return (volatile.LoadUint32(&o.FCS.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetFCS_DREQ_EN(value uint32) {
	volatile.StoreUint32(&o.FCS.Reg, volatile.LoadUint32(&o.FCS.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetFCS_DREQ_EN() uint32 {
	return (volatile.LoadUint32(&o.FCS.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetFCS_ERR(value uint32) {
	volatile.StoreUint32(&o.FCS.Reg, volatile.LoadUint32(&o.FCS.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetFCS_ERR() uint32 {
	return (volatile.LoadUint32(&o.FCS.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetFCS_SHIFT(value uint32) {
	volatile.StoreUint32(&o.FCS.Reg, volatile.LoadUint32(&o.FCS.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetFCS_SHIFT() uint32 {
	return (volatile.LoadUint32(&o.FCS.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetFCS_EN(value uint32) {
	volatile.StoreUint32(&o.FCS.Reg, volatile.LoadUint32(&o.FCS.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetFCS_EN() uint32 {
	return volatile.LoadUint32(&o.FCS.Reg) & 0x1
}

// ADC.FIFO: Conversion result FIFO
func (o *ADC_Type) SetFIFO_ERR(value uint32) {
	volatile.StoreUint32(&o.FIFO.Reg, volatile.LoadUint32(&o.FIFO.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_Type) GetFIFO_ERR() uint32 {
	return (volatile.LoadUint32(&o.FIFO.Reg) & 0x8000) >> 15
}
func (o *ADC_Type) SetFIFO_VAL(value uint32) {
	volatile.StoreUint32(&o.FIFO.Reg, volatile.LoadUint32(&o.FIFO.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetFIFO_VAL() uint32 {
	return volatile.LoadUint32(&o.FIFO.Reg) & 0xfff
}

// ADC.DIV
// Clock divider. If non-zero, CS_START_MANY will start conversions
// at regular intervals rather than back-to-back.
// The divider is reset when either of these fields are written.
// Total period is 1 + INT + FRAC / 256
func (o *ADC_Type) SetDIV_INT(value uint32) {
	volatile.StoreUint32(&o.DIV.Reg, volatile.LoadUint32(&o.DIV.Reg)&^(0xffff00)|value<<8)
}
func (o *ADC_Type) GetDIV_INT() uint32 {
	return (volatile.LoadUint32(&o.DIV.Reg) & 0xffff00) >> 8
}
func (o *ADC_Type) SetDIV_FRAC(value uint32) {
	volatile.StoreUint32(&o.DIV.Reg, volatile.LoadUint32(&o.DIV.Reg)&^(0xff)|value)
}
func (o *ADC_Type) GetDIV_FRAC() uint32 {
	return volatile.LoadUint32(&o.DIV.Reg) & 0xff
}

// ADC.INTR: Raw Interrupts
func (o *ADC_Type) SetINTR_FIFO(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetINTR_FIFO() uint32 {
	return volatile.LoadUint32(&o.INTR.Reg) & 0x1
}

// ADC.INTE: Interrupt Enable
func (o *ADC_Type) SetINTE_FIFO(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetINTE_FIFO() uint32 {
	return volatile.LoadUint32(&o.INTE.Reg) & 0x1
}

// ADC.INTF: Interrupt Force
func (o *ADC_Type) SetINTF_FIFO(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetINTF_FIFO() uint32 {
	return volatile.LoadUint32(&o.INTF.Reg) & 0x1
}

// ADC.INTS: Interrupt status after masking & forcing
func (o *ADC_Type) SetINTS_FIFO(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetINTS_FIFO() uint32 {
	return volatile.LoadUint32(&o.INTS.Reg) & 0x1
}

// Simple PWM
type PWM_Type struct {
	CH0_CSR volatile.Register32 // 0x0
	CH0_DIV volatile.Register32 // 0x4
	CH0_CTR volatile.Register32 // 0x8
	CH0_CC  volatile.Register32 // 0xC
	CH0_TOP volatile.Register32 // 0x10
	CH1_CSR volatile.Register32 // 0x14
	CH1_DIV volatile.Register32 // 0x18
	CH1_CTR volatile.Register32 // 0x1C
	CH1_CC  volatile.Register32 // 0x20
	CH1_TOP volatile.Register32 // 0x24
	CH2_CSR volatile.Register32 // 0x28
	CH2_DIV volatile.Register32 // 0x2C
	CH2_CTR volatile.Register32 // 0x30
	CH2_CC  volatile.Register32 // 0x34
	CH2_TOP volatile.Register32 // 0x38
	CH3_CSR volatile.Register32 // 0x3C
	CH3_DIV volatile.Register32 // 0x40
	CH3_CTR volatile.Register32 // 0x44
	CH3_CC  volatile.Register32 // 0x48
	CH3_TOP volatile.Register32 // 0x4C
	CH4_CSR volatile.Register32 // 0x50
	CH4_DIV volatile.Register32 // 0x54
	CH4_CTR volatile.Register32 // 0x58
	CH4_CC  volatile.Register32 // 0x5C
	CH4_TOP volatile.Register32 // 0x60
	CH5_CSR volatile.Register32 // 0x64
	CH5_DIV volatile.Register32 // 0x68
	CH5_CTR volatile.Register32 // 0x6C
	CH5_CC  volatile.Register32 // 0x70
	CH5_TOP volatile.Register32 // 0x74
	CH6_CSR volatile.Register32 // 0x78
	CH6_DIV volatile.Register32 // 0x7C
	CH6_CTR volatile.Register32 // 0x80
	CH6_CC  volatile.Register32 // 0x84
	CH6_TOP volatile.Register32 // 0x88
	CH7_CSR volatile.Register32 // 0x8C
	CH7_DIV volatile.Register32 // 0x90
	CH7_CTR volatile.Register32 // 0x94
	CH7_CC  volatile.Register32 // 0x98
	CH7_TOP volatile.Register32 // 0x9C
	EN      volatile.Register32 // 0xA0
	INTR    volatile.Register32 // 0xA4
	INTE    volatile.Register32 // 0xA8
	INTF    volatile.Register32 // 0xAC
	INTS    volatile.Register32 // 0xB0
}

// PWM.CH0_CSR: Control and status register
func (o *PWM_Type) SetCH0_CSR_PH_ADV(value uint32) {
	volatile.StoreUint32(&o.CH0_CSR.Reg, volatile.LoadUint32(&o.CH0_CSR.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetCH0_CSR_PH_ADV() uint32 {
	return (volatile.LoadUint32(&o.CH0_CSR.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetCH0_CSR_PH_RET(value uint32) {
	volatile.StoreUint32(&o.CH0_CSR.Reg, volatile.LoadUint32(&o.CH0_CSR.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetCH0_CSR_PH_RET() uint32 {
	return (volatile.LoadUint32(&o.CH0_CSR.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetCH0_CSR_DIVMODE(value uint32) {
	volatile.StoreUint32(&o.CH0_CSR.Reg, volatile.LoadUint32(&o.CH0_CSR.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetCH0_CSR_DIVMODE() uint32 {
	return (volatile.LoadUint32(&o.CH0_CSR.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetCH0_CSR_B_INV(value uint32) {
	volatile.StoreUint32(&o.CH0_CSR.Reg, volatile.LoadUint32(&o.CH0_CSR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetCH0_CSR_B_INV() uint32 {
	return (volatile.LoadUint32(&o.CH0_CSR.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetCH0_CSR_A_INV(value uint32) {
	volatile.StoreUint32(&o.CH0_CSR.Reg, volatile.LoadUint32(&o.CH0_CSR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetCH0_CSR_A_INV() uint32 {
	return (volatile.LoadUint32(&o.CH0_CSR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetCH0_CSR_PH_CORRECT(value uint32) {
	volatile.StoreUint32(&o.CH0_CSR.Reg, volatile.LoadUint32(&o.CH0_CSR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetCH0_CSR_PH_CORRECT() uint32 {
	return (volatile.LoadUint32(&o.CH0_CSR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetCH0_CSR_EN(value uint32) {
	volatile.StoreUint32(&o.CH0_CSR.Reg, volatile.LoadUint32(&o.CH0_CSR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCH0_CSR_EN() uint32 {
	return volatile.LoadUint32(&o.CH0_CSR.Reg) & 0x1
}

// PWM.CH0_DIV
// INT and FRAC form a fixed-point fractional number.
// Counting rate is system clock frequency divided by this number.
// Fractional division uses simple 1st-order sigma-delta.
func (o *PWM_Type) SetCH0_DIV_INT(value uint32) {
	volatile.StoreUint32(&o.CH0_DIV.Reg, volatile.LoadUint32(&o.CH0_DIV.Reg)&^(0xff0)|value<<4)
}
func (o *PWM_Type) GetCH0_DIV_INT() uint32 {
	return (volatile.LoadUint32(&o.CH0_DIV.Reg) & 0xff0) >> 4
}
func (o *PWM_Type) SetCH0_DIV_FRAC(value uint32) {
	volatile.StoreUint32(&o.CH0_DIV.Reg, volatile.LoadUint32(&o.CH0_DIV.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetCH0_DIV_FRAC() uint32 {
	return volatile.LoadUint32(&o.CH0_DIV.Reg) & 0xf
}

// PWM.CH0_CTR: Direct access to the PWM counter
func (o *PWM_Type) SetCH0_CTR(value uint32) {
	volatile.StoreUint32(&o.CH0_CTR.Reg, volatile.LoadUint32(&o.CH0_CTR.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH0_CTR() uint32 {
	return volatile.LoadUint32(&o.CH0_CTR.Reg) & 0xffff
}

// PWM.CH0_CC: Counter compare values
func (o *PWM_Type) SetCH0_CC_B(value uint32) {
	volatile.StoreUint32(&o.CH0_CC.Reg, volatile.LoadUint32(&o.CH0_CC.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetCH0_CC_B() uint32 {
	return (volatile.LoadUint32(&o.CH0_CC.Reg) & 0xffff0000) >> 16
}
func (o *PWM_Type) SetCH0_CC_A(value uint32) {
	volatile.StoreUint32(&o.CH0_CC.Reg, volatile.LoadUint32(&o.CH0_CC.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH0_CC_A() uint32 {
	return volatile.LoadUint32(&o.CH0_CC.Reg) & 0xffff
}

// PWM.CH0_TOP: Counter wrap value
func (o *PWM_Type) SetCH0_TOP(value uint32) {
	volatile.StoreUint32(&o.CH0_TOP.Reg, volatile.LoadUint32(&o.CH0_TOP.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH0_TOP() uint32 {
	return volatile.LoadUint32(&o.CH0_TOP.Reg) & 0xffff
}

// PWM.CH1_CSR: Control and status register
func (o *PWM_Type) SetCH1_CSR_PH_ADV(value uint32) {
	volatile.StoreUint32(&o.CH1_CSR.Reg, volatile.LoadUint32(&o.CH1_CSR.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetCH1_CSR_PH_ADV() uint32 {
	return (volatile.LoadUint32(&o.CH1_CSR.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetCH1_CSR_PH_RET(value uint32) {
	volatile.StoreUint32(&o.CH1_CSR.Reg, volatile.LoadUint32(&o.CH1_CSR.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetCH1_CSR_PH_RET() uint32 {
	return (volatile.LoadUint32(&o.CH1_CSR.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetCH1_CSR_DIVMODE(value uint32) {
	volatile.StoreUint32(&o.CH1_CSR.Reg, volatile.LoadUint32(&o.CH1_CSR.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetCH1_CSR_DIVMODE() uint32 {
	return (volatile.LoadUint32(&o.CH1_CSR.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetCH1_CSR_B_INV(value uint32) {
	volatile.StoreUint32(&o.CH1_CSR.Reg, volatile.LoadUint32(&o.CH1_CSR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetCH1_CSR_B_INV() uint32 {
	return (volatile.LoadUint32(&o.CH1_CSR.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetCH1_CSR_A_INV(value uint32) {
	volatile.StoreUint32(&o.CH1_CSR.Reg, volatile.LoadUint32(&o.CH1_CSR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetCH1_CSR_A_INV() uint32 {
	return (volatile.LoadUint32(&o.CH1_CSR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetCH1_CSR_PH_CORRECT(value uint32) {
	volatile.StoreUint32(&o.CH1_CSR.Reg, volatile.LoadUint32(&o.CH1_CSR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetCH1_CSR_PH_CORRECT() uint32 {
	return (volatile.LoadUint32(&o.CH1_CSR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetCH1_CSR_EN(value uint32) {
	volatile.StoreUint32(&o.CH1_CSR.Reg, volatile.LoadUint32(&o.CH1_CSR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCH1_CSR_EN() uint32 {
	return volatile.LoadUint32(&o.CH1_CSR.Reg) & 0x1
}

// PWM.CH1_DIV
// INT and FRAC form a fixed-point fractional number.
// Counting rate is system clock frequency divided by this number.
// Fractional division uses simple 1st-order sigma-delta.
func (o *PWM_Type) SetCH1_DIV_INT(value uint32) {
	volatile.StoreUint32(&o.CH1_DIV.Reg, volatile.LoadUint32(&o.CH1_DIV.Reg)&^(0xff0)|value<<4)
}
func (o *PWM_Type) GetCH1_DIV_INT() uint32 {
	return (volatile.LoadUint32(&o.CH1_DIV.Reg) & 0xff0) >> 4
}
func (o *PWM_Type) SetCH1_DIV_FRAC(value uint32) {
	volatile.StoreUint32(&o.CH1_DIV.Reg, volatile.LoadUint32(&o.CH1_DIV.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetCH1_DIV_FRAC() uint32 {
	return volatile.LoadUint32(&o.CH1_DIV.Reg) & 0xf
}

// PWM.CH1_CTR: Direct access to the PWM counter
func (o *PWM_Type) SetCH1_CTR(value uint32) {
	volatile.StoreUint32(&o.CH1_CTR.Reg, volatile.LoadUint32(&o.CH1_CTR.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH1_CTR() uint32 {
	return volatile.LoadUint32(&o.CH1_CTR.Reg) & 0xffff
}

// PWM.CH1_CC: Counter compare values
func (o *PWM_Type) SetCH1_CC_B(value uint32) {
	volatile.StoreUint32(&o.CH1_CC.Reg, volatile.LoadUint32(&o.CH1_CC.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetCH1_CC_B() uint32 {
	return (volatile.LoadUint32(&o.CH1_CC.Reg) & 0xffff0000) >> 16
}
func (o *PWM_Type) SetCH1_CC_A(value uint32) {
	volatile.StoreUint32(&o.CH1_CC.Reg, volatile.LoadUint32(&o.CH1_CC.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH1_CC_A() uint32 {
	return volatile.LoadUint32(&o.CH1_CC.Reg) & 0xffff
}

// PWM.CH1_TOP: Counter wrap value
func (o *PWM_Type) SetCH1_TOP(value uint32) {
	volatile.StoreUint32(&o.CH1_TOP.Reg, volatile.LoadUint32(&o.CH1_TOP.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH1_TOP() uint32 {
	return volatile.LoadUint32(&o.CH1_TOP.Reg) & 0xffff
}

// PWM.CH2_CSR: Control and status register
func (o *PWM_Type) SetCH2_CSR_PH_ADV(value uint32) {
	volatile.StoreUint32(&o.CH2_CSR.Reg, volatile.LoadUint32(&o.CH2_CSR.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetCH2_CSR_PH_ADV() uint32 {
	return (volatile.LoadUint32(&o.CH2_CSR.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetCH2_CSR_PH_RET(value uint32) {
	volatile.StoreUint32(&o.CH2_CSR.Reg, volatile.LoadUint32(&o.CH2_CSR.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetCH2_CSR_PH_RET() uint32 {
	return (volatile.LoadUint32(&o.CH2_CSR.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetCH2_CSR_DIVMODE(value uint32) {
	volatile.StoreUint32(&o.CH2_CSR.Reg, volatile.LoadUint32(&o.CH2_CSR.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetCH2_CSR_DIVMODE() uint32 {
	return (volatile.LoadUint32(&o.CH2_CSR.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetCH2_CSR_B_INV(value uint32) {
	volatile.StoreUint32(&o.CH2_CSR.Reg, volatile.LoadUint32(&o.CH2_CSR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetCH2_CSR_B_INV() uint32 {
	return (volatile.LoadUint32(&o.CH2_CSR.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetCH2_CSR_A_INV(value uint32) {
	volatile.StoreUint32(&o.CH2_CSR.Reg, volatile.LoadUint32(&o.CH2_CSR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetCH2_CSR_A_INV() uint32 {
	return (volatile.LoadUint32(&o.CH2_CSR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetCH2_CSR_PH_CORRECT(value uint32) {
	volatile.StoreUint32(&o.CH2_CSR.Reg, volatile.LoadUint32(&o.CH2_CSR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetCH2_CSR_PH_CORRECT() uint32 {
	return (volatile.LoadUint32(&o.CH2_CSR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetCH2_CSR_EN(value uint32) {
	volatile.StoreUint32(&o.CH2_CSR.Reg, volatile.LoadUint32(&o.CH2_CSR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCH2_CSR_EN() uint32 {
	return volatile.LoadUint32(&o.CH2_CSR.Reg) & 0x1
}

// PWM.CH2_DIV
// INT and FRAC form a fixed-point fractional number.
// Counting rate is system clock frequency divided by this number.
// Fractional division uses simple 1st-order sigma-delta.
func (o *PWM_Type) SetCH2_DIV_INT(value uint32) {
	volatile.StoreUint32(&o.CH2_DIV.Reg, volatile.LoadUint32(&o.CH2_DIV.Reg)&^(0xff0)|value<<4)
}
func (o *PWM_Type) GetCH2_DIV_INT() uint32 {
	return (volatile.LoadUint32(&o.CH2_DIV.Reg) & 0xff0) >> 4
}
func (o *PWM_Type) SetCH2_DIV_FRAC(value uint32) {
	volatile.StoreUint32(&o.CH2_DIV.Reg, volatile.LoadUint32(&o.CH2_DIV.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetCH2_DIV_FRAC() uint32 {
	return volatile.LoadUint32(&o.CH2_DIV.Reg) & 0xf
}

// PWM.CH2_CTR: Direct access to the PWM counter
func (o *PWM_Type) SetCH2_CTR(value uint32) {
	volatile.StoreUint32(&o.CH2_CTR.Reg, volatile.LoadUint32(&o.CH2_CTR.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH2_CTR() uint32 {
	return volatile.LoadUint32(&o.CH2_CTR.Reg) & 0xffff
}

// PWM.CH2_CC: Counter compare values
func (o *PWM_Type) SetCH2_CC_B(value uint32) {
	volatile.StoreUint32(&o.CH2_CC.Reg, volatile.LoadUint32(&o.CH2_CC.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetCH2_CC_B() uint32 {
	return (volatile.LoadUint32(&o.CH2_CC.Reg) & 0xffff0000) >> 16
}
func (o *PWM_Type) SetCH2_CC_A(value uint32) {
	volatile.StoreUint32(&o.CH2_CC.Reg, volatile.LoadUint32(&o.CH2_CC.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH2_CC_A() uint32 {
	return volatile.LoadUint32(&o.CH2_CC.Reg) & 0xffff
}

// PWM.CH2_TOP: Counter wrap value
func (o *PWM_Type) SetCH2_TOP(value uint32) {
	volatile.StoreUint32(&o.CH2_TOP.Reg, volatile.LoadUint32(&o.CH2_TOP.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH2_TOP() uint32 {
	return volatile.LoadUint32(&o.CH2_TOP.Reg) & 0xffff
}

// PWM.CH3_CSR: Control and status register
func (o *PWM_Type) SetCH3_CSR_PH_ADV(value uint32) {
	volatile.StoreUint32(&o.CH3_CSR.Reg, volatile.LoadUint32(&o.CH3_CSR.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetCH3_CSR_PH_ADV() uint32 {
	return (volatile.LoadUint32(&o.CH3_CSR.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetCH3_CSR_PH_RET(value uint32) {
	volatile.StoreUint32(&o.CH3_CSR.Reg, volatile.LoadUint32(&o.CH3_CSR.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetCH3_CSR_PH_RET() uint32 {
	return (volatile.LoadUint32(&o.CH3_CSR.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetCH3_CSR_DIVMODE(value uint32) {
	volatile.StoreUint32(&o.CH3_CSR.Reg, volatile.LoadUint32(&o.CH3_CSR.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetCH3_CSR_DIVMODE() uint32 {
	return (volatile.LoadUint32(&o.CH3_CSR.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetCH3_CSR_B_INV(value uint32) {
	volatile.StoreUint32(&o.CH3_CSR.Reg, volatile.LoadUint32(&o.CH3_CSR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetCH3_CSR_B_INV() uint32 {
	return (volatile.LoadUint32(&o.CH3_CSR.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetCH3_CSR_A_INV(value uint32) {
	volatile.StoreUint32(&o.CH3_CSR.Reg, volatile.LoadUint32(&o.CH3_CSR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetCH3_CSR_A_INV() uint32 {
	return (volatile.LoadUint32(&o.CH3_CSR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetCH3_CSR_PH_CORRECT(value uint32) {
	volatile.StoreUint32(&o.CH3_CSR.Reg, volatile.LoadUint32(&o.CH3_CSR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetCH3_CSR_PH_CORRECT() uint32 {
	return (volatile.LoadUint32(&o.CH3_CSR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetCH3_CSR_EN(value uint32) {
	volatile.StoreUint32(&o.CH3_CSR.Reg, volatile.LoadUint32(&o.CH3_CSR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCH3_CSR_EN() uint32 {
	return volatile.LoadUint32(&o.CH3_CSR.Reg) & 0x1
}

// PWM.CH3_DIV
// INT and FRAC form a fixed-point fractional number.
// Counting rate is system clock frequency divided by this number.
// Fractional division uses simple 1st-order sigma-delta.
func (o *PWM_Type) SetCH3_DIV_INT(value uint32) {
	volatile.StoreUint32(&o.CH3_DIV.Reg, volatile.LoadUint32(&o.CH3_DIV.Reg)&^(0xff0)|value<<4)
}
func (o *PWM_Type) GetCH3_DIV_INT() uint32 {
	return (volatile.LoadUint32(&o.CH3_DIV.Reg) & 0xff0) >> 4
}
func (o *PWM_Type) SetCH3_DIV_FRAC(value uint32) {
	volatile.StoreUint32(&o.CH3_DIV.Reg, volatile.LoadUint32(&o.CH3_DIV.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetCH3_DIV_FRAC() uint32 {
	return volatile.LoadUint32(&o.CH3_DIV.Reg) & 0xf
}

// PWM.CH3_CTR: Direct access to the PWM counter
func (o *PWM_Type) SetCH3_CTR(value uint32) {
	volatile.StoreUint32(&o.CH3_CTR.Reg, volatile.LoadUint32(&o.CH3_CTR.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH3_CTR() uint32 {
	return volatile.LoadUint32(&o.CH3_CTR.Reg) & 0xffff
}

// PWM.CH3_CC: Counter compare values
func (o *PWM_Type) SetCH3_CC_B(value uint32) {
	volatile.StoreUint32(&o.CH3_CC.Reg, volatile.LoadUint32(&o.CH3_CC.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetCH3_CC_B() uint32 {
	return (volatile.LoadUint32(&o.CH3_CC.Reg) & 0xffff0000) >> 16
}
func (o *PWM_Type) SetCH3_CC_A(value uint32) {
	volatile.StoreUint32(&o.CH3_CC.Reg, volatile.LoadUint32(&o.CH3_CC.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH3_CC_A() uint32 {
	return volatile.LoadUint32(&o.CH3_CC.Reg) & 0xffff
}

// PWM.CH3_TOP: Counter wrap value
func (o *PWM_Type) SetCH3_TOP(value uint32) {
	volatile.StoreUint32(&o.CH3_TOP.Reg, volatile.LoadUint32(&o.CH3_TOP.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH3_TOP() uint32 {
	return volatile.LoadUint32(&o.CH3_TOP.Reg) & 0xffff
}

// PWM.CH4_CSR: Control and status register
func (o *PWM_Type) SetCH4_CSR_PH_ADV(value uint32) {
	volatile.StoreUint32(&o.CH4_CSR.Reg, volatile.LoadUint32(&o.CH4_CSR.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetCH4_CSR_PH_ADV() uint32 {
	return (volatile.LoadUint32(&o.CH4_CSR.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetCH4_CSR_PH_RET(value uint32) {
	volatile.StoreUint32(&o.CH4_CSR.Reg, volatile.LoadUint32(&o.CH4_CSR.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetCH4_CSR_PH_RET() uint32 {
	return (volatile.LoadUint32(&o.CH4_CSR.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetCH4_CSR_DIVMODE(value uint32) {
	volatile.StoreUint32(&o.CH4_CSR.Reg, volatile.LoadUint32(&o.CH4_CSR.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetCH4_CSR_DIVMODE() uint32 {
	return (volatile.LoadUint32(&o.CH4_CSR.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetCH4_CSR_B_INV(value uint32) {
	volatile.StoreUint32(&o.CH4_CSR.Reg, volatile.LoadUint32(&o.CH4_CSR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetCH4_CSR_B_INV() uint32 {
	return (volatile.LoadUint32(&o.CH4_CSR.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetCH4_CSR_A_INV(value uint32) {
	volatile.StoreUint32(&o.CH4_CSR.Reg, volatile.LoadUint32(&o.CH4_CSR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetCH4_CSR_A_INV() uint32 {
	return (volatile.LoadUint32(&o.CH4_CSR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetCH4_CSR_PH_CORRECT(value uint32) {
	volatile.StoreUint32(&o.CH4_CSR.Reg, volatile.LoadUint32(&o.CH4_CSR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetCH4_CSR_PH_CORRECT() uint32 {
	return (volatile.LoadUint32(&o.CH4_CSR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetCH4_CSR_EN(value uint32) {
	volatile.StoreUint32(&o.CH4_CSR.Reg, volatile.LoadUint32(&o.CH4_CSR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCH4_CSR_EN() uint32 {
	return volatile.LoadUint32(&o.CH4_CSR.Reg) & 0x1
}

// PWM.CH4_DIV
// INT and FRAC form a fixed-point fractional number.
// Counting rate is system clock frequency divided by this number.
// Fractional division uses simple 1st-order sigma-delta.
func (o *PWM_Type) SetCH4_DIV_INT(value uint32) {
	volatile.StoreUint32(&o.CH4_DIV.Reg, volatile.LoadUint32(&o.CH4_DIV.Reg)&^(0xff0)|value<<4)
}
func (o *PWM_Type) GetCH4_DIV_INT() uint32 {
	return (volatile.LoadUint32(&o.CH4_DIV.Reg) & 0xff0) >> 4
}
func (o *PWM_Type) SetCH4_DIV_FRAC(value uint32) {
	volatile.StoreUint32(&o.CH4_DIV.Reg, volatile.LoadUint32(&o.CH4_DIV.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetCH4_DIV_FRAC() uint32 {
	return volatile.LoadUint32(&o.CH4_DIV.Reg) & 0xf
}

// PWM.CH4_CTR: Direct access to the PWM counter
func (o *PWM_Type) SetCH4_CTR(value uint32) {
	volatile.StoreUint32(&o.CH4_CTR.Reg, volatile.LoadUint32(&o.CH4_CTR.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH4_CTR() uint32 {
	return volatile.LoadUint32(&o.CH4_CTR.Reg) & 0xffff
}

// PWM.CH4_CC: Counter compare values
func (o *PWM_Type) SetCH4_CC_B(value uint32) {
	volatile.StoreUint32(&o.CH4_CC.Reg, volatile.LoadUint32(&o.CH4_CC.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetCH4_CC_B() uint32 {
	return (volatile.LoadUint32(&o.CH4_CC.Reg) & 0xffff0000) >> 16
}
func (o *PWM_Type) SetCH4_CC_A(value uint32) {
	volatile.StoreUint32(&o.CH4_CC.Reg, volatile.LoadUint32(&o.CH4_CC.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH4_CC_A() uint32 {
	return volatile.LoadUint32(&o.CH4_CC.Reg) & 0xffff
}

// PWM.CH4_TOP: Counter wrap value
func (o *PWM_Type) SetCH4_TOP(value uint32) {
	volatile.StoreUint32(&o.CH4_TOP.Reg, volatile.LoadUint32(&o.CH4_TOP.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH4_TOP() uint32 {
	return volatile.LoadUint32(&o.CH4_TOP.Reg) & 0xffff
}

// PWM.CH5_CSR: Control and status register
func (o *PWM_Type) SetCH5_CSR_PH_ADV(value uint32) {
	volatile.StoreUint32(&o.CH5_CSR.Reg, volatile.LoadUint32(&o.CH5_CSR.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetCH5_CSR_PH_ADV() uint32 {
	return (volatile.LoadUint32(&o.CH5_CSR.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetCH5_CSR_PH_RET(value uint32) {
	volatile.StoreUint32(&o.CH5_CSR.Reg, volatile.LoadUint32(&o.CH5_CSR.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetCH5_CSR_PH_RET() uint32 {
	return (volatile.LoadUint32(&o.CH5_CSR.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetCH5_CSR_DIVMODE(value uint32) {
	volatile.StoreUint32(&o.CH5_CSR.Reg, volatile.LoadUint32(&o.CH5_CSR.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetCH5_CSR_DIVMODE() uint32 {
	return (volatile.LoadUint32(&o.CH5_CSR.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetCH5_CSR_B_INV(value uint32) {
	volatile.StoreUint32(&o.CH5_CSR.Reg, volatile.LoadUint32(&o.CH5_CSR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetCH5_CSR_B_INV() uint32 {
	return (volatile.LoadUint32(&o.CH5_CSR.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetCH5_CSR_A_INV(value uint32) {
	volatile.StoreUint32(&o.CH5_CSR.Reg, volatile.LoadUint32(&o.CH5_CSR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetCH5_CSR_A_INV() uint32 {
	return (volatile.LoadUint32(&o.CH5_CSR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetCH5_CSR_PH_CORRECT(value uint32) {
	volatile.StoreUint32(&o.CH5_CSR.Reg, volatile.LoadUint32(&o.CH5_CSR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetCH5_CSR_PH_CORRECT() uint32 {
	return (volatile.LoadUint32(&o.CH5_CSR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetCH5_CSR_EN(value uint32) {
	volatile.StoreUint32(&o.CH5_CSR.Reg, volatile.LoadUint32(&o.CH5_CSR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCH5_CSR_EN() uint32 {
	return volatile.LoadUint32(&o.CH5_CSR.Reg) & 0x1
}

// PWM.CH5_DIV
// INT and FRAC form a fixed-point fractional number.
// Counting rate is system clock frequency divided by this number.
// Fractional division uses simple 1st-order sigma-delta.
func (o *PWM_Type) SetCH5_DIV_INT(value uint32) {
	volatile.StoreUint32(&o.CH5_DIV.Reg, volatile.LoadUint32(&o.CH5_DIV.Reg)&^(0xff0)|value<<4)
}
func (o *PWM_Type) GetCH5_DIV_INT() uint32 {
	return (volatile.LoadUint32(&o.CH5_DIV.Reg) & 0xff0) >> 4
}
func (o *PWM_Type) SetCH5_DIV_FRAC(value uint32) {
	volatile.StoreUint32(&o.CH5_DIV.Reg, volatile.LoadUint32(&o.CH5_DIV.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetCH5_DIV_FRAC() uint32 {
	return volatile.LoadUint32(&o.CH5_DIV.Reg) & 0xf
}

// PWM.CH5_CTR: Direct access to the PWM counter
func (o *PWM_Type) SetCH5_CTR(value uint32) {
	volatile.StoreUint32(&o.CH5_CTR.Reg, volatile.LoadUint32(&o.CH5_CTR.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH5_CTR() uint32 {
	return volatile.LoadUint32(&o.CH5_CTR.Reg) & 0xffff
}

// PWM.CH5_CC: Counter compare values
func (o *PWM_Type) SetCH5_CC_B(value uint32) {
	volatile.StoreUint32(&o.CH5_CC.Reg, volatile.LoadUint32(&o.CH5_CC.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetCH5_CC_B() uint32 {
	return (volatile.LoadUint32(&o.CH5_CC.Reg) & 0xffff0000) >> 16
}
func (o *PWM_Type) SetCH5_CC_A(value uint32) {
	volatile.StoreUint32(&o.CH5_CC.Reg, volatile.LoadUint32(&o.CH5_CC.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH5_CC_A() uint32 {
	return volatile.LoadUint32(&o.CH5_CC.Reg) & 0xffff
}

// PWM.CH5_TOP: Counter wrap value
func (o *PWM_Type) SetCH5_TOP(value uint32) {
	volatile.StoreUint32(&o.CH5_TOP.Reg, volatile.LoadUint32(&o.CH5_TOP.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH5_TOP() uint32 {
	return volatile.LoadUint32(&o.CH5_TOP.Reg) & 0xffff
}

// PWM.CH6_CSR: Control and status register
func (o *PWM_Type) SetCH6_CSR_PH_ADV(value uint32) {
	volatile.StoreUint32(&o.CH6_CSR.Reg, volatile.LoadUint32(&o.CH6_CSR.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetCH6_CSR_PH_ADV() uint32 {
	return (volatile.LoadUint32(&o.CH6_CSR.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetCH6_CSR_PH_RET(value uint32) {
	volatile.StoreUint32(&o.CH6_CSR.Reg, volatile.LoadUint32(&o.CH6_CSR.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetCH6_CSR_PH_RET() uint32 {
	return (volatile.LoadUint32(&o.CH6_CSR.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetCH6_CSR_DIVMODE(value uint32) {
	volatile.StoreUint32(&o.CH6_CSR.Reg, volatile.LoadUint32(&o.CH6_CSR.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetCH6_CSR_DIVMODE() uint32 {
	return (volatile.LoadUint32(&o.CH6_CSR.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetCH6_CSR_B_INV(value uint32) {
	volatile.StoreUint32(&o.CH6_CSR.Reg, volatile.LoadUint32(&o.CH6_CSR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetCH6_CSR_B_INV() uint32 {
	return (volatile.LoadUint32(&o.CH6_CSR.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetCH6_CSR_A_INV(value uint32) {
	volatile.StoreUint32(&o.CH6_CSR.Reg, volatile.LoadUint32(&o.CH6_CSR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetCH6_CSR_A_INV() uint32 {
	return (volatile.LoadUint32(&o.CH6_CSR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetCH6_CSR_PH_CORRECT(value uint32) {
	volatile.StoreUint32(&o.CH6_CSR.Reg, volatile.LoadUint32(&o.CH6_CSR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetCH6_CSR_PH_CORRECT() uint32 {
	return (volatile.LoadUint32(&o.CH6_CSR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetCH6_CSR_EN(value uint32) {
	volatile.StoreUint32(&o.CH6_CSR.Reg, volatile.LoadUint32(&o.CH6_CSR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCH6_CSR_EN() uint32 {
	return volatile.LoadUint32(&o.CH6_CSR.Reg) & 0x1
}

// PWM.CH6_DIV
// INT and FRAC form a fixed-point fractional number.
// Counting rate is system clock frequency divided by this number.
// Fractional division uses simple 1st-order sigma-delta.
func (o *PWM_Type) SetCH6_DIV_INT(value uint32) {
	volatile.StoreUint32(&o.CH6_DIV.Reg, volatile.LoadUint32(&o.CH6_DIV.Reg)&^(0xff0)|value<<4)
}
func (o *PWM_Type) GetCH6_DIV_INT() uint32 {
	return (volatile.LoadUint32(&o.CH6_DIV.Reg) & 0xff0) >> 4
}
func (o *PWM_Type) SetCH6_DIV_FRAC(value uint32) {
	volatile.StoreUint32(&o.CH6_DIV.Reg, volatile.LoadUint32(&o.CH6_DIV.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetCH6_DIV_FRAC() uint32 {
	return volatile.LoadUint32(&o.CH6_DIV.Reg) & 0xf
}

// PWM.CH6_CTR: Direct access to the PWM counter
func (o *PWM_Type) SetCH6_CTR(value uint32) {
	volatile.StoreUint32(&o.CH6_CTR.Reg, volatile.LoadUint32(&o.CH6_CTR.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH6_CTR() uint32 {
	return volatile.LoadUint32(&o.CH6_CTR.Reg) & 0xffff
}

// PWM.CH6_CC: Counter compare values
func (o *PWM_Type) SetCH6_CC_B(value uint32) {
	volatile.StoreUint32(&o.CH6_CC.Reg, volatile.LoadUint32(&o.CH6_CC.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetCH6_CC_B() uint32 {
	return (volatile.LoadUint32(&o.CH6_CC.Reg) & 0xffff0000) >> 16
}
func (o *PWM_Type) SetCH6_CC_A(value uint32) {
	volatile.StoreUint32(&o.CH6_CC.Reg, volatile.LoadUint32(&o.CH6_CC.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH6_CC_A() uint32 {
	return volatile.LoadUint32(&o.CH6_CC.Reg) & 0xffff
}

// PWM.CH6_TOP: Counter wrap value
func (o *PWM_Type) SetCH6_TOP(value uint32) {
	volatile.StoreUint32(&o.CH6_TOP.Reg, volatile.LoadUint32(&o.CH6_TOP.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH6_TOP() uint32 {
	return volatile.LoadUint32(&o.CH6_TOP.Reg) & 0xffff
}

// PWM.CH7_CSR: Control and status register
func (o *PWM_Type) SetCH7_CSR_PH_ADV(value uint32) {
	volatile.StoreUint32(&o.CH7_CSR.Reg, volatile.LoadUint32(&o.CH7_CSR.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetCH7_CSR_PH_ADV() uint32 {
	return (volatile.LoadUint32(&o.CH7_CSR.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetCH7_CSR_PH_RET(value uint32) {
	volatile.StoreUint32(&o.CH7_CSR.Reg, volatile.LoadUint32(&o.CH7_CSR.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetCH7_CSR_PH_RET() uint32 {
	return (volatile.LoadUint32(&o.CH7_CSR.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetCH7_CSR_DIVMODE(value uint32) {
	volatile.StoreUint32(&o.CH7_CSR.Reg, volatile.LoadUint32(&o.CH7_CSR.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetCH7_CSR_DIVMODE() uint32 {
	return (volatile.LoadUint32(&o.CH7_CSR.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetCH7_CSR_B_INV(value uint32) {
	volatile.StoreUint32(&o.CH7_CSR.Reg, volatile.LoadUint32(&o.CH7_CSR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetCH7_CSR_B_INV() uint32 {
	return (volatile.LoadUint32(&o.CH7_CSR.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetCH7_CSR_A_INV(value uint32) {
	volatile.StoreUint32(&o.CH7_CSR.Reg, volatile.LoadUint32(&o.CH7_CSR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetCH7_CSR_A_INV() uint32 {
	return (volatile.LoadUint32(&o.CH7_CSR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetCH7_CSR_PH_CORRECT(value uint32) {
	volatile.StoreUint32(&o.CH7_CSR.Reg, volatile.LoadUint32(&o.CH7_CSR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetCH7_CSR_PH_CORRECT() uint32 {
	return (volatile.LoadUint32(&o.CH7_CSR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetCH7_CSR_EN(value uint32) {
	volatile.StoreUint32(&o.CH7_CSR.Reg, volatile.LoadUint32(&o.CH7_CSR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCH7_CSR_EN() uint32 {
	return volatile.LoadUint32(&o.CH7_CSR.Reg) & 0x1
}

// PWM.CH7_DIV
// INT and FRAC form a fixed-point fractional number.
// Counting rate is system clock frequency divided by this number.
// Fractional division uses simple 1st-order sigma-delta.
func (o *PWM_Type) SetCH7_DIV_INT(value uint32) {
	volatile.StoreUint32(&o.CH7_DIV.Reg, volatile.LoadUint32(&o.CH7_DIV.Reg)&^(0xff0)|value<<4)
}
func (o *PWM_Type) GetCH7_DIV_INT() uint32 {
	return (volatile.LoadUint32(&o.CH7_DIV.Reg) & 0xff0) >> 4
}
func (o *PWM_Type) SetCH7_DIV_FRAC(value uint32) {
	volatile.StoreUint32(&o.CH7_DIV.Reg, volatile.LoadUint32(&o.CH7_DIV.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetCH7_DIV_FRAC() uint32 {
	return volatile.LoadUint32(&o.CH7_DIV.Reg) & 0xf
}

// PWM.CH7_CTR: Direct access to the PWM counter
func (o *PWM_Type) SetCH7_CTR(value uint32) {
	volatile.StoreUint32(&o.CH7_CTR.Reg, volatile.LoadUint32(&o.CH7_CTR.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH7_CTR() uint32 {
	return volatile.LoadUint32(&o.CH7_CTR.Reg) & 0xffff
}

// PWM.CH7_CC: Counter compare values
func (o *PWM_Type) SetCH7_CC_B(value uint32) {
	volatile.StoreUint32(&o.CH7_CC.Reg, volatile.LoadUint32(&o.CH7_CC.Reg)&^(0xffff0000)|value<<16)
}
func (o *PWM_Type) GetCH7_CC_B() uint32 {
	return (volatile.LoadUint32(&o.CH7_CC.Reg) & 0xffff0000) >> 16
}
func (o *PWM_Type) SetCH7_CC_A(value uint32) {
	volatile.StoreUint32(&o.CH7_CC.Reg, volatile.LoadUint32(&o.CH7_CC.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH7_CC_A() uint32 {
	return volatile.LoadUint32(&o.CH7_CC.Reg) & 0xffff
}

// PWM.CH7_TOP: Counter wrap value
func (o *PWM_Type) SetCH7_TOP(value uint32) {
	volatile.StoreUint32(&o.CH7_TOP.Reg, volatile.LoadUint32(&o.CH7_TOP.Reg)&^(0xffff)|value)
}
func (o *PWM_Type) GetCH7_TOP() uint32 {
	return volatile.LoadUint32(&o.CH7_TOP.Reg) & 0xffff
}

// PWM.EN
// This register aliases the CSR_EN bits for all channels.
// Writing to this register allows multiple channels to be enabled
// or disabled simultaneously, so they can run in perfect sync.
// For each channel, there is only one physical EN register bit,
// which can be accessed through here or CHx_CSR.
func (o *PWM_Type) SetEN_CH7(value uint32) {
	volatile.StoreUint32(&o.EN.Reg, volatile.LoadUint32(&o.EN.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetEN_CH7() uint32 {
	return (volatile.LoadUint32(&o.EN.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetEN_CH6(value uint32) {
	volatile.StoreUint32(&o.EN.Reg, volatile.LoadUint32(&o.EN.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetEN_CH6() uint32 {
	return (volatile.LoadUint32(&o.EN.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetEN_CH5(value uint32) {
	volatile.StoreUint32(&o.EN.Reg, volatile.LoadUint32(&o.EN.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetEN_CH5() uint32 {
	return (volatile.LoadUint32(&o.EN.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetEN_CH4(value uint32) {
	volatile.StoreUint32(&o.EN.Reg, volatile.LoadUint32(&o.EN.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetEN_CH4() uint32 {
	return (volatile.LoadUint32(&o.EN.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetEN_CH3(value uint32) {
	volatile.StoreUint32(&o.EN.Reg, volatile.LoadUint32(&o.EN.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetEN_CH3() uint32 {
	return (volatile.LoadUint32(&o.EN.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetEN_CH2(value uint32) {
	volatile.StoreUint32(&o.EN.Reg, volatile.LoadUint32(&o.EN.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetEN_CH2() uint32 {
	return (volatile.LoadUint32(&o.EN.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetEN_CH1(value uint32) {
	volatile.StoreUint32(&o.EN.Reg, volatile.LoadUint32(&o.EN.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetEN_CH1() uint32 {
	return (volatile.LoadUint32(&o.EN.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetEN_CH0(value uint32) {
	volatile.StoreUint32(&o.EN.Reg, volatile.LoadUint32(&o.EN.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetEN_CH0() uint32 {
	return volatile.LoadUint32(&o.EN.Reg) & 0x1
}

// PWM.INTR: Raw Interrupts
func (o *PWM_Type) SetINTR_CH7(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetINTR_CH7() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetINTR_CH6(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetINTR_CH6() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetINTR_CH5(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetINTR_CH5() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetINTR_CH4(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetINTR_CH4() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetINTR_CH3(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetINTR_CH3() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetINTR_CH2(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetINTR_CH2() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetINTR_CH1(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetINTR_CH1() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetINTR_CH0(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetINTR_CH0() uint32 {
	return volatile.LoadUint32(&o.INTR.Reg) & 0x1
}

// PWM.INTE: Interrupt Enable
func (o *PWM_Type) SetINTE_CH7(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetINTE_CH7() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetINTE_CH6(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetINTE_CH6() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetINTE_CH5(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetINTE_CH5() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetINTE_CH4(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetINTE_CH4() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetINTE_CH3(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetINTE_CH3() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetINTE_CH2(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetINTE_CH2() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetINTE_CH1(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetINTE_CH1() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetINTE_CH0(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetINTE_CH0() uint32 {
	return volatile.LoadUint32(&o.INTE.Reg) & 0x1
}

// PWM.INTF: Interrupt Force
func (o *PWM_Type) SetINTF_CH7(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetINTF_CH7() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetINTF_CH6(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetINTF_CH6() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetINTF_CH5(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetINTF_CH5() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetINTF_CH4(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetINTF_CH4() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetINTF_CH3(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetINTF_CH3() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetINTF_CH2(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetINTF_CH2() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetINTF_CH1(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetINTF_CH1() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetINTF_CH0(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetINTF_CH0() uint32 {
	return volatile.LoadUint32(&o.INTF.Reg) & 0x1
}

// PWM.INTS: Interrupt status after masking & forcing
func (o *PWM_Type) SetINTS_CH7(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetINTS_CH7() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetINTS_CH6(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetINTS_CH6() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetINTS_CH5(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetINTS_CH5() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetINTS_CH4(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetINTS_CH4() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetINTS_CH3(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetINTS_CH3() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetINTS_CH2(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetINTS_CH2() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetINTS_CH1(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetINTS_CH1() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetINTS_CH0(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetINTS_CH0() uint32 {
	return volatile.LoadUint32(&o.INTS.Reg) & 0x1
}

// Controls time and alarms
// time is a 64 bit value indicating the time in usec since power-on
// timeh is the top 32 bits of time & timel is the bottom 32 bits
// to change time write to timelw before timehw
// to read time read from timelr before timehr
// An alarm is set by setting alarm_enable and writing to the corresponding alarm register
// When an alarm is pending, the corresponding alarm_running signal will be high
// An alarm can be cancelled before it has finished by clearing the alarm_enable
// When an alarm fires, the corresponding alarm_irq is set and alarm_running is cleared
// To clear the interrupt write a 1 to the corresponding alarm_irq
type TIMER_Type struct {
	TIMEHW   volatile.Register32 // 0x0
	TIMELW   volatile.Register32 // 0x4
	TIMEHR   volatile.Register32 // 0x8
	TIMELR   volatile.Register32 // 0xC
	ALARM0   volatile.Register32 // 0x10
	ALARM1   volatile.Register32 // 0x14
	ALARM2   volatile.Register32 // 0x18
	ALARM3   volatile.Register32 // 0x1C
	ARMED    volatile.Register32 // 0x20
	TIMERAWH volatile.Register32 // 0x24
	TIMERAWL volatile.Register32 // 0x28
	DBGPAUSE volatile.Register32 // 0x2C
	PAUSE    volatile.Register32 // 0x30
	INTR     volatile.Register32 // 0x34
	INTE     volatile.Register32 // 0x38
	INTF     volatile.Register32 // 0x3C
	INTS     volatile.Register32 // 0x40
}

// TIMER.ARMED
// Indicates the armed/disarmed status of each alarm.
// A write to the corresponding ALARMx register arms the alarm.
// Alarms automatically disarm upon firing, but writing ones here
// will disarm immediately without waiting to fire.
func (o *TIMER_Type) SetARMED(value uint32) {
	volatile.StoreUint32(&o.ARMED.Reg, volatile.LoadUint32(&o.ARMED.Reg)&^(0xf)|value)
}
func (o *TIMER_Type) GetARMED() uint32 {
	return volatile.LoadUint32(&o.ARMED.Reg) & 0xf
}

// TIMER.DBGPAUSE: Set bits high to enable pause when the corresponding debug ports are active
func (o *TIMER_Type) SetDBGPAUSE_DBG1(value uint32) {
	volatile.StoreUint32(&o.DBGPAUSE.Reg, volatile.LoadUint32(&o.DBGPAUSE.Reg)&^(0x4)|value<<2)
}
func (o *TIMER_Type) GetDBGPAUSE_DBG1() uint32 {
	return (volatile.LoadUint32(&o.DBGPAUSE.Reg) & 0x4) >> 2
}
func (o *TIMER_Type) SetDBGPAUSE_DBG0(value uint32) {
	volatile.StoreUint32(&o.DBGPAUSE.Reg, volatile.LoadUint32(&o.DBGPAUSE.Reg)&^(0x2)|value<<1)
}
func (o *TIMER_Type) GetDBGPAUSE_DBG0() uint32 {
	return (volatile.LoadUint32(&o.DBGPAUSE.Reg) & 0x2) >> 1
}

// TIMER.PAUSE: Set high to pause the timer
func (o *TIMER_Type) SetPAUSE(value uint32) {
	volatile.StoreUint32(&o.PAUSE.Reg, volatile.LoadUint32(&o.PAUSE.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetPAUSE() uint32 {
	return volatile.LoadUint32(&o.PAUSE.Reg) & 0x1
}

// TIMER.INTR: Raw Interrupts
func (o *TIMER_Type) SetINTR_ALARM_3(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x8)|value<<3)
}
func (o *TIMER_Type) GetINTR_ALARM_3() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x8) >> 3
}
func (o *TIMER_Type) SetINTR_ALARM_2(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x4)|value<<2)
}
func (o *TIMER_Type) GetINTR_ALARM_2() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x4) >> 2
}
func (o *TIMER_Type) SetINTR_ALARM_1(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x2)|value<<1)
}
func (o *TIMER_Type) GetINTR_ALARM_1() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x2) >> 1
}
func (o *TIMER_Type) SetINTR_ALARM_0(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetINTR_ALARM_0() uint32 {
	return volatile.LoadUint32(&o.INTR.Reg) & 0x1
}

// TIMER.INTE: Interrupt Enable
func (o *TIMER_Type) SetINTE_ALARM_3(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x8)|value<<3)
}
func (o *TIMER_Type) GetINTE_ALARM_3() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x8) >> 3
}
func (o *TIMER_Type) SetINTE_ALARM_2(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x4)|value<<2)
}
func (o *TIMER_Type) GetINTE_ALARM_2() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x4) >> 2
}
func (o *TIMER_Type) SetINTE_ALARM_1(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x2)|value<<1)
}
func (o *TIMER_Type) GetINTE_ALARM_1() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x2) >> 1
}
func (o *TIMER_Type) SetINTE_ALARM_0(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetINTE_ALARM_0() uint32 {
	return volatile.LoadUint32(&o.INTE.Reg) & 0x1
}

// TIMER.INTF: Interrupt Force
func (o *TIMER_Type) SetINTF_ALARM_3(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x8)|value<<3)
}
func (o *TIMER_Type) GetINTF_ALARM_3() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x8) >> 3
}
func (o *TIMER_Type) SetINTF_ALARM_2(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x4)|value<<2)
}
func (o *TIMER_Type) GetINTF_ALARM_2() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x4) >> 2
}
func (o *TIMER_Type) SetINTF_ALARM_1(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x2)|value<<1)
}
func (o *TIMER_Type) GetINTF_ALARM_1() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x2) >> 1
}
func (o *TIMER_Type) SetINTF_ALARM_0(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetINTF_ALARM_0() uint32 {
	return volatile.LoadUint32(&o.INTF.Reg) & 0x1
}

// TIMER.INTS: Interrupt status after masking & forcing
func (o *TIMER_Type) SetINTS_ALARM_3(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x8)|value<<3)
}
func (o *TIMER_Type) GetINTS_ALARM_3() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x8) >> 3
}
func (o *TIMER_Type) SetINTS_ALARM_2(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x4)|value<<2)
}
func (o *TIMER_Type) GetINTS_ALARM_2() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x4) >> 2
}
func (o *TIMER_Type) SetINTS_ALARM_1(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x2)|value<<1)
}
func (o *TIMER_Type) GetINTS_ALARM_1() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x2) >> 1
}
func (o *TIMER_Type) SetINTS_ALARM_0(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x1)|value)
}
func (o *TIMER_Type) GetINTS_ALARM_0() uint32 {
	return volatile.LoadUint32(&o.INTS.Reg) & 0x1
}

type WATCHDOG_Type struct {
	CTRL     volatile.Register32 // 0x0
	LOAD     volatile.Register32 // 0x4
	REASON   volatile.Register32 // 0x8
	SCRATCH0 volatile.Register32 // 0xC
	SCRATCH1 volatile.Register32 // 0x10
	SCRATCH2 volatile.Register32 // 0x14
	SCRATCH3 volatile.Register32 // 0x18
	SCRATCH4 volatile.Register32 // 0x1C
	SCRATCH5 volatile.Register32 // 0x20
	SCRATCH6 volatile.Register32 // 0x24
	SCRATCH7 volatile.Register32 // 0x28
	TICK     volatile.Register32 // 0x2C
}

// WATCHDOG.CTRL
// Watchdog control
// The rst_wdsel register determines which subsystems are reset when the watchdog is triggered.
// The watchdog can be triggered in software.
func (o *WATCHDOG_Type) SetCTRL_TRIGGER(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *WATCHDOG_Type) GetCTRL_TRIGGER() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80000000) >> 31
}
func (o *WATCHDOG_Type) SetCTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *WATCHDOG_Type) GetCTRL_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40000000) >> 30
}
func (o *WATCHDOG_Type) SetCTRL_PAUSE_DBG1(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *WATCHDOG_Type) GetCTRL_PAUSE_DBG1() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4000000) >> 26
}
func (o *WATCHDOG_Type) SetCTRL_PAUSE_DBG0(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *WATCHDOG_Type) GetCTRL_PAUSE_DBG0() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2000000) >> 25
}
func (o *WATCHDOG_Type) SetCTRL_PAUSE_JTAG(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *WATCHDOG_Type) GetCTRL_PAUSE_JTAG() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1000000) >> 24
}
func (o *WATCHDOG_Type) SetCTRL_TIME(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xffffff)|value)
}
func (o *WATCHDOG_Type) GetCTRL_TIME() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0xffffff
}

// WATCHDOG.LOAD: Load the watchdog timer. The maximum setting is 0xffffff which corresponds to 0xffffff / 2 ticks before triggering a watchdog reset (see errata RP2040-E1).
func (o *WATCHDOG_Type) SetLOAD(value uint32) {
	volatile.StoreUint32(&o.LOAD.Reg, volatile.LoadUint32(&o.LOAD.Reg)&^(0xffffff)|value)
}
func (o *WATCHDOG_Type) GetLOAD() uint32 {
	return volatile.LoadUint32(&o.LOAD.Reg) & 0xffffff
}

// WATCHDOG.REASON: Logs the reason for the last reset. Both bits are zero for the case of a hardware reset.
func (o *WATCHDOG_Type) SetREASON_FORCE(value uint32) {
	volatile.StoreUint32(&o.REASON.Reg, volatile.LoadUint32(&o.REASON.Reg)&^(0x2)|value<<1)
}
func (o *WATCHDOG_Type) GetREASON_FORCE() uint32 {
	return (volatile.LoadUint32(&o.REASON.Reg) & 0x2) >> 1
}
func (o *WATCHDOG_Type) SetREASON_TIMER(value uint32) {
	volatile.StoreUint32(&o.REASON.Reg, volatile.LoadUint32(&o.REASON.Reg)&^(0x1)|value)
}
func (o *WATCHDOG_Type) GetREASON_TIMER() uint32 {
	return volatile.LoadUint32(&o.REASON.Reg) & 0x1
}

// WATCHDOG.TICK: Controls the tick generator
func (o *WATCHDOG_Type) SetTICK_COUNT(value uint32) {
	volatile.StoreUint32(&o.TICK.Reg, volatile.LoadUint32(&o.TICK.Reg)&^(0xff800)|value<<11)
}
func (o *WATCHDOG_Type) GetTICK_COUNT() uint32 {
	return (volatile.LoadUint32(&o.TICK.Reg) & 0xff800) >> 11
}
func (o *WATCHDOG_Type) SetTICK_RUNNING(value uint32) {
	volatile.StoreUint32(&o.TICK.Reg, volatile.LoadUint32(&o.TICK.Reg)&^(0x400)|value<<10)
}
func (o *WATCHDOG_Type) GetTICK_RUNNING() uint32 {
	return (volatile.LoadUint32(&o.TICK.Reg) & 0x400) >> 10
}
func (o *WATCHDOG_Type) SetTICK_ENABLE(value uint32) {
	volatile.StoreUint32(&o.TICK.Reg, volatile.LoadUint32(&o.TICK.Reg)&^(0x200)|value<<9)
}
func (o *WATCHDOG_Type) GetTICK_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.TICK.Reg) & 0x200) >> 9
}
func (o *WATCHDOG_Type) SetTICK_CYCLES(value uint32) {
	volatile.StoreUint32(&o.TICK.Reg, volatile.LoadUint32(&o.TICK.Reg)&^(0x1ff)|value)
}
func (o *WATCHDOG_Type) GetTICK_CYCLES() uint32 {
	return volatile.LoadUint32(&o.TICK.Reg) & 0x1ff
}

// Register block to control RTC
type RTC_Type struct {
	CLKDIV_M1   volatile.Register32 // 0x0
	SETUP_0     volatile.Register32 // 0x4
	SETUP_1     volatile.Register32 // 0x8
	CTRL        volatile.Register32 // 0xC
	IRQ_SETUP_0 volatile.Register32 // 0x10
	IRQ_SETUP_1 volatile.Register32 // 0x14
	RTC_1       volatile.Register32 // 0x18
	RTC_0       volatile.Register32 // 0x1C
	INTR        volatile.Register32 // 0x20
	INTE        volatile.Register32 // 0x24
	INTF        volatile.Register32 // 0x28
	INTS        volatile.Register32 // 0x2C
}

// RTC.CLKDIV_M1: Divider minus 1 for the 1 second counter. Safe to change the value when RTC is not enabled.
func (o *RTC_Type) SetCLKDIV_M1(value uint32) {
	volatile.StoreUint32(&o.CLKDIV_M1.Reg, volatile.LoadUint32(&o.CLKDIV_M1.Reg)&^(0xffff)|value)
}
func (o *RTC_Type) GetCLKDIV_M1() uint32 {
	return volatile.LoadUint32(&o.CLKDIV_M1.Reg) & 0xffff
}

// RTC.SETUP_0: RTC setup register 0
func (o *RTC_Type) SetSETUP_0_YEAR(value uint32) {
	volatile.StoreUint32(&o.SETUP_0.Reg, volatile.LoadUint32(&o.SETUP_0.Reg)&^(0xfff000)|value<<12)
}
func (o *RTC_Type) GetSETUP_0_YEAR() uint32 {
	return (volatile.LoadUint32(&o.SETUP_0.Reg) & 0xfff000) >> 12
}
func (o *RTC_Type) SetSETUP_0_MONTH(value uint32) {
	volatile.StoreUint32(&o.SETUP_0.Reg, volatile.LoadUint32(&o.SETUP_0.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetSETUP_0_MONTH() uint32 {
	return (volatile.LoadUint32(&o.SETUP_0.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetSETUP_0_DAY(value uint32) {
	volatile.StoreUint32(&o.SETUP_0.Reg, volatile.LoadUint32(&o.SETUP_0.Reg)&^(0x1f)|value)
}
func (o *RTC_Type) GetSETUP_0_DAY() uint32 {
	return volatile.LoadUint32(&o.SETUP_0.Reg) & 0x1f
}

// RTC.SETUP_1: RTC setup register 1
func (o *RTC_Type) SetSETUP_1_DOTW(value uint32) {
	volatile.StoreUint32(&o.SETUP_1.Reg, volatile.LoadUint32(&o.SETUP_1.Reg)&^(0x7000000)|value<<24)
}
func (o *RTC_Type) GetSETUP_1_DOTW() uint32 {
	return (volatile.LoadUint32(&o.SETUP_1.Reg) & 0x7000000) >> 24
}
func (o *RTC_Type) SetSETUP_1_HOUR(value uint32) {
	volatile.StoreUint32(&o.SETUP_1.Reg, volatile.LoadUint32(&o.SETUP_1.Reg)&^(0x1f0000)|value<<16)
}
func (o *RTC_Type) GetSETUP_1_HOUR() uint32 {
	return (volatile.LoadUint32(&o.SETUP_1.Reg) & 0x1f0000) >> 16
}
func (o *RTC_Type) SetSETUP_1_MIN(value uint32) {
	volatile.StoreUint32(&o.SETUP_1.Reg, volatile.LoadUint32(&o.SETUP_1.Reg)&^(0x3f00)|value<<8)
}
func (o *RTC_Type) GetSETUP_1_MIN() uint32 {
	return (volatile.LoadUint32(&o.SETUP_1.Reg) & 0x3f00) >> 8
}
func (o *RTC_Type) SetSETUP_1_SEC(value uint32) {
	volatile.StoreUint32(&o.SETUP_1.Reg, volatile.LoadUint32(&o.SETUP_1.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetSETUP_1_SEC() uint32 {
	return volatile.LoadUint32(&o.SETUP_1.Reg) & 0x3f
}

// RTC.CTRL: RTC Control and status
func (o *RTC_Type) SetCTRL_FORCE_NOTLEAPYEAR(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100)|value<<8)
}
func (o *RTC_Type) GetCTRL_FORCE_NOTLEAPYEAR() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100) >> 8
}
func (o *RTC_Type) SetCTRL_LOAD(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetCTRL_LOAD() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetCTRL_RTC_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetCTRL_RTC_ACTIVE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetCTRL_RTC_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetCTRL_RTC_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}

// RTC.IRQ_SETUP_0: Interrupt setup register 0
func (o *RTC_Type) SetIRQ_SETUP_0_MATCH_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.IRQ_SETUP_0.Reg, volatile.LoadUint32(&o.IRQ_SETUP_0.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_Type) GetIRQ_SETUP_0_MATCH_ACTIVE() uint32 {
	return (volatile.LoadUint32(&o.IRQ_SETUP_0.Reg) & 0x20000000) >> 29
}
func (o *RTC_Type) SetIRQ_SETUP_0_MATCH_ENA(value uint32) {
	volatile.StoreUint32(&o.IRQ_SETUP_0.Reg, volatile.LoadUint32(&o.IRQ_SETUP_0.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_Type) GetIRQ_SETUP_0_MATCH_ENA() uint32 {
	return (volatile.LoadUint32(&o.IRQ_SETUP_0.Reg) & 0x10000000) >> 28
}
func (o *RTC_Type) SetIRQ_SETUP_0_YEAR_ENA(value uint32) {
	volatile.StoreUint32(&o.IRQ_SETUP_0.Reg, volatile.LoadUint32(&o.IRQ_SETUP_0.Reg)&^(0x4000000)|value<<26)
}
func (o *RTC_Type) GetIRQ_SETUP_0_YEAR_ENA() uint32 {
	return (volatile.LoadUint32(&o.IRQ_SETUP_0.Reg) & 0x4000000) >> 26
}
func (o *RTC_Type) SetIRQ_SETUP_0_MONTH_ENA(value uint32) {
	volatile.StoreUint32(&o.IRQ_SETUP_0.Reg, volatile.LoadUint32(&o.IRQ_SETUP_0.Reg)&^(0x2000000)|value<<25)
}
func (o *RTC_Type) GetIRQ_SETUP_0_MONTH_ENA() uint32 {
	return (volatile.LoadUint32(&o.IRQ_SETUP_0.Reg) & 0x2000000) >> 25
}
func (o *RTC_Type) SetIRQ_SETUP_0_DAY_ENA(value uint32) {
	volatile.StoreUint32(&o.IRQ_SETUP_0.Reg, volatile.LoadUint32(&o.IRQ_SETUP_0.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_Type) GetIRQ_SETUP_0_DAY_ENA() uint32 {
	return (volatile.LoadUint32(&o.IRQ_SETUP_0.Reg) & 0x1000000) >> 24
}
func (o *RTC_Type) SetIRQ_SETUP_0_YEAR(value uint32) {
	volatile.StoreUint32(&o.IRQ_SETUP_0.Reg, volatile.LoadUint32(&o.IRQ_SETUP_0.Reg)&^(0xfff000)|value<<12)
}
func (o *RTC_Type) GetIRQ_SETUP_0_YEAR() uint32 {
	return (volatile.LoadUint32(&o.IRQ_SETUP_0.Reg) & 0xfff000) >> 12
}
func (o *RTC_Type) SetIRQ_SETUP_0_MONTH(value uint32) {
	volatile.StoreUint32(&o.IRQ_SETUP_0.Reg, volatile.LoadUint32(&o.IRQ_SETUP_0.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetIRQ_SETUP_0_MONTH() uint32 {
	return (volatile.LoadUint32(&o.IRQ_SETUP_0.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetIRQ_SETUP_0_DAY(value uint32) {
	volatile.StoreUint32(&o.IRQ_SETUP_0.Reg, volatile.LoadUint32(&o.IRQ_SETUP_0.Reg)&^(0x1f)|value)
}
func (o *RTC_Type) GetIRQ_SETUP_0_DAY() uint32 {
	return volatile.LoadUint32(&o.IRQ_SETUP_0.Reg) & 0x1f
}

// RTC.IRQ_SETUP_1: Interrupt setup register 1
func (o *RTC_Type) SetIRQ_SETUP_1_DOTW_ENA(value uint32) {
	volatile.StoreUint32(&o.IRQ_SETUP_1.Reg, volatile.LoadUint32(&o.IRQ_SETUP_1.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetIRQ_SETUP_1_DOTW_ENA() uint32 {
	return (volatile.LoadUint32(&o.IRQ_SETUP_1.Reg) & 0x80000000) >> 31
}
func (o *RTC_Type) SetIRQ_SETUP_1_HOUR_ENA(value uint32) {
	volatile.StoreUint32(&o.IRQ_SETUP_1.Reg, volatile.LoadUint32(&o.IRQ_SETUP_1.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_Type) GetIRQ_SETUP_1_HOUR_ENA() uint32 {
	return (volatile.LoadUint32(&o.IRQ_SETUP_1.Reg) & 0x40000000) >> 30
}
func (o *RTC_Type) SetIRQ_SETUP_1_MIN_ENA(value uint32) {
	volatile.StoreUint32(&o.IRQ_SETUP_1.Reg, volatile.LoadUint32(&o.IRQ_SETUP_1.Reg)&^(0x20000000)|value<<29)
}
func (o *RTC_Type) GetIRQ_SETUP_1_MIN_ENA() uint32 {
	return (volatile.LoadUint32(&o.IRQ_SETUP_1.Reg) & 0x20000000) >> 29
}
func (o *RTC_Type) SetIRQ_SETUP_1_SEC_ENA(value uint32) {
	volatile.StoreUint32(&o.IRQ_SETUP_1.Reg, volatile.LoadUint32(&o.IRQ_SETUP_1.Reg)&^(0x10000000)|value<<28)
}
func (o *RTC_Type) GetIRQ_SETUP_1_SEC_ENA() uint32 {
	return (volatile.LoadUint32(&o.IRQ_SETUP_1.Reg) & 0x10000000) >> 28
}
func (o *RTC_Type) SetIRQ_SETUP_1_DOTW(value uint32) {
	volatile.StoreUint32(&o.IRQ_SETUP_1.Reg, volatile.LoadUint32(&o.IRQ_SETUP_1.Reg)&^(0x7000000)|value<<24)
}
func (o *RTC_Type) GetIRQ_SETUP_1_DOTW() uint32 {
	return (volatile.LoadUint32(&o.IRQ_SETUP_1.Reg) & 0x7000000) >> 24
}
func (o *RTC_Type) SetIRQ_SETUP_1_HOUR(value uint32) {
	volatile.StoreUint32(&o.IRQ_SETUP_1.Reg, volatile.LoadUint32(&o.IRQ_SETUP_1.Reg)&^(0x1f0000)|value<<16)
}
func (o *RTC_Type) GetIRQ_SETUP_1_HOUR() uint32 {
	return (volatile.LoadUint32(&o.IRQ_SETUP_1.Reg) & 0x1f0000) >> 16
}
func (o *RTC_Type) SetIRQ_SETUP_1_MIN(value uint32) {
	volatile.StoreUint32(&o.IRQ_SETUP_1.Reg, volatile.LoadUint32(&o.IRQ_SETUP_1.Reg)&^(0x3f00)|value<<8)
}
func (o *RTC_Type) GetIRQ_SETUP_1_MIN() uint32 {
	return (volatile.LoadUint32(&o.IRQ_SETUP_1.Reg) & 0x3f00) >> 8
}
func (o *RTC_Type) SetIRQ_SETUP_1_SEC(value uint32) {
	volatile.StoreUint32(&o.IRQ_SETUP_1.Reg, volatile.LoadUint32(&o.IRQ_SETUP_1.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetIRQ_SETUP_1_SEC() uint32 {
	return volatile.LoadUint32(&o.IRQ_SETUP_1.Reg) & 0x3f
}

// RTC.RTC_1: RTC register 1.
func (o *RTC_Type) SetRTC_1_YEAR(value uint32) {
	volatile.StoreUint32(&o.RTC_1.Reg, volatile.LoadUint32(&o.RTC_1.Reg)&^(0xfff000)|value<<12)
}
func (o *RTC_Type) GetRTC_1_YEAR() uint32 {
	return (volatile.LoadUint32(&o.RTC_1.Reg) & 0xfff000) >> 12
}
func (o *RTC_Type) SetRTC_1_MONTH(value uint32) {
	volatile.StoreUint32(&o.RTC_1.Reg, volatile.LoadUint32(&o.RTC_1.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetRTC_1_MONTH() uint32 {
	return (volatile.LoadUint32(&o.RTC_1.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetRTC_1_DAY(value uint32) {
	volatile.StoreUint32(&o.RTC_1.Reg, volatile.LoadUint32(&o.RTC_1.Reg)&^(0x1f)|value)
}
func (o *RTC_Type) GetRTC_1_DAY() uint32 {
	return volatile.LoadUint32(&o.RTC_1.Reg) & 0x1f
}

// RTC.RTC_0
// RTC register 0
// Read this before RTC 1!
func (o *RTC_Type) SetRTC_0_DOTW(value uint32) {
	volatile.StoreUint32(&o.RTC_0.Reg, volatile.LoadUint32(&o.RTC_0.Reg)&^(0x7000000)|value<<24)
}
func (o *RTC_Type) GetRTC_0_DOTW() uint32 {
	return (volatile.LoadUint32(&o.RTC_0.Reg) & 0x7000000) >> 24
}
func (o *RTC_Type) SetRTC_0_HOUR(value uint32) {
	volatile.StoreUint32(&o.RTC_0.Reg, volatile.LoadUint32(&o.RTC_0.Reg)&^(0x1f0000)|value<<16)
}
func (o *RTC_Type) GetRTC_0_HOUR() uint32 {
	return (volatile.LoadUint32(&o.RTC_0.Reg) & 0x1f0000) >> 16
}
func (o *RTC_Type) SetRTC_0_MIN(value uint32) {
	volatile.StoreUint32(&o.RTC_0.Reg, volatile.LoadUint32(&o.RTC_0.Reg)&^(0x3f00)|value<<8)
}
func (o *RTC_Type) GetRTC_0_MIN() uint32 {
	return (volatile.LoadUint32(&o.RTC_0.Reg) & 0x3f00) >> 8
}
func (o *RTC_Type) SetRTC_0_SEC(value uint32) {
	volatile.StoreUint32(&o.RTC_0.Reg, volatile.LoadUint32(&o.RTC_0.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetRTC_0_SEC() uint32 {
	return volatile.LoadUint32(&o.RTC_0.Reg) & 0x3f
}

// RTC.INTR: Raw Interrupts
func (o *RTC_Type) SetINTR_RTC(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetINTR_RTC() uint32 {
	return volatile.LoadUint32(&o.INTR.Reg) & 0x1
}

// RTC.INTE: Interrupt Enable
func (o *RTC_Type) SetINTE_RTC(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetINTE_RTC() uint32 {
	return volatile.LoadUint32(&o.INTE.Reg) & 0x1
}

// RTC.INTF: Interrupt Force
func (o *RTC_Type) SetINTF_RTC(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetINTF_RTC() uint32 {
	return volatile.LoadUint32(&o.INTF.Reg) & 0x1
}

// RTC.INTS: Interrupt status after masking & forcing
func (o *RTC_Type) SetINTS_RTC(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetINTS_RTC() uint32 {
	return volatile.LoadUint32(&o.INTS.Reg) & 0x1
}

type ROSC_Type struct {
	CTRL      volatile.Register32 // 0x0
	FREQA     volatile.Register32 // 0x4
	FREQB     volatile.Register32 // 0x8
	DORMANT   volatile.Register32 // 0xC
	DIV       volatile.Register32 // 0x10
	PHASE     volatile.Register32 // 0x14
	STATUS    volatile.Register32 // 0x18
	RANDOMBIT volatile.Register32 // 0x1C
	COUNT     volatile.Register32 // 0x20
}

// ROSC.CTRL: Ring Oscillator control
func (o *ROSC_Type) SetCTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xfff000)|value<<12)
}
func (o *ROSC_Type) GetCTRL_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xfff000) >> 12
}
func (o *ROSC_Type) SetCTRL_FREQ_RANGE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xfff)|value)
}
func (o *ROSC_Type) GetCTRL_FREQ_RANGE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0xfff
}

// ROSC.FREQA
// The FREQA & FREQB registers control the frequency by controlling the drive strength of each stage
// The drive strength has 4 levels determined by the number of bits set
// Increasing the number of bits set increases the drive strength and increases the oscillation frequency
// 0 bits set is the default drive strength
// 1 bit set doubles the drive strength
// 2 bits set triples drive strength
// 3 bits set quadruples drive strength
func (o *ROSC_Type) SetFREQA_PASSWD(value uint32) {
	volatile.StoreUint32(&o.FREQA.Reg, volatile.LoadUint32(&o.FREQA.Reg)&^(0xffff0000)|value<<16)
}
func (o *ROSC_Type) GetFREQA_PASSWD() uint32 {
	return (volatile.LoadUint32(&o.FREQA.Reg) & 0xffff0000) >> 16
}
func (o *ROSC_Type) SetFREQA_DS3(value uint32) {
	volatile.StoreUint32(&o.FREQA.Reg, volatile.LoadUint32(&o.FREQA.Reg)&^(0x7000)|value<<12)
}
func (o *ROSC_Type) GetFREQA_DS3() uint32 {
	return (volatile.LoadUint32(&o.FREQA.Reg) & 0x7000) >> 12
}
func (o *ROSC_Type) SetFREQA_DS2(value uint32) {
	volatile.StoreUint32(&o.FREQA.Reg, volatile.LoadUint32(&o.FREQA.Reg)&^(0x700)|value<<8)
}
func (o *ROSC_Type) GetFREQA_DS2() uint32 {
	return (volatile.LoadUint32(&o.FREQA.Reg) & 0x700) >> 8
}
func (o *ROSC_Type) SetFREQA_DS1(value uint32) {
	volatile.StoreUint32(&o.FREQA.Reg, volatile.LoadUint32(&o.FREQA.Reg)&^(0x70)|value<<4)
}
func (o *ROSC_Type) GetFREQA_DS1() uint32 {
	return (volatile.LoadUint32(&o.FREQA.Reg) & 0x70) >> 4
}
func (o *ROSC_Type) SetFREQA_DS0(value uint32) {
	volatile.StoreUint32(&o.FREQA.Reg, volatile.LoadUint32(&o.FREQA.Reg)&^(0x7)|value)
}
func (o *ROSC_Type) GetFREQA_DS0() uint32 {
	return volatile.LoadUint32(&o.FREQA.Reg) & 0x7
}

// ROSC.FREQB: For a detailed description see freqa register
func (o *ROSC_Type) SetFREQB_PASSWD(value uint32) {
	volatile.StoreUint32(&o.FREQB.Reg, volatile.LoadUint32(&o.FREQB.Reg)&^(0xffff0000)|value<<16)
}
func (o *ROSC_Type) GetFREQB_PASSWD() uint32 {
	return (volatile.LoadUint32(&o.FREQB.Reg) & 0xffff0000) >> 16
}
func (o *ROSC_Type) SetFREQB_DS7(value uint32) {
	volatile.StoreUint32(&o.FREQB.Reg, volatile.LoadUint32(&o.FREQB.Reg)&^(0x7000)|value<<12)
}
func (o *ROSC_Type) GetFREQB_DS7() uint32 {
	return (volatile.LoadUint32(&o.FREQB.Reg) & 0x7000) >> 12
}
func (o *ROSC_Type) SetFREQB_DS6(value uint32) {
	volatile.StoreUint32(&o.FREQB.Reg, volatile.LoadUint32(&o.FREQB.Reg)&^(0x700)|value<<8)
}
func (o *ROSC_Type) GetFREQB_DS6() uint32 {
	return (volatile.LoadUint32(&o.FREQB.Reg) & 0x700) >> 8
}
func (o *ROSC_Type) SetFREQB_DS5(value uint32) {
	volatile.StoreUint32(&o.FREQB.Reg, volatile.LoadUint32(&o.FREQB.Reg)&^(0x70)|value<<4)
}
func (o *ROSC_Type) GetFREQB_DS5() uint32 {
	return (volatile.LoadUint32(&o.FREQB.Reg) & 0x70) >> 4
}
func (o *ROSC_Type) SetFREQB_DS4(value uint32) {
	volatile.StoreUint32(&o.FREQB.Reg, volatile.LoadUint32(&o.FREQB.Reg)&^(0x7)|value)
}
func (o *ROSC_Type) GetFREQB_DS4() uint32 {
	return volatile.LoadUint32(&o.FREQB.Reg) & 0x7
}

// ROSC.DIV: Controls the output divider
func (o *ROSC_Type) SetDIV(value uint32) {
	volatile.StoreUint32(&o.DIV.Reg, volatile.LoadUint32(&o.DIV.Reg)&^(0xfff)|value)
}
func (o *ROSC_Type) GetDIV() uint32 {
	return volatile.LoadUint32(&o.DIV.Reg) & 0xfff
}

// ROSC.PHASE: Controls the phase shifted output
func (o *ROSC_Type) SetPHASE_PASSWD(value uint32) {
	volatile.StoreUint32(&o.PHASE.Reg, volatile.LoadUint32(&o.PHASE.Reg)&^(0xff0)|value<<4)
}
func (o *ROSC_Type) GetPHASE_PASSWD() uint32 {
	return (volatile.LoadUint32(&o.PHASE.Reg) & 0xff0) >> 4
}
func (o *ROSC_Type) SetPHASE_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PHASE.Reg, volatile.LoadUint32(&o.PHASE.Reg)&^(0x8)|value<<3)
}
func (o *ROSC_Type) GetPHASE_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PHASE.Reg) & 0x8) >> 3
}
func (o *ROSC_Type) SetPHASE_FLIP(value uint32) {
	volatile.StoreUint32(&o.PHASE.Reg, volatile.LoadUint32(&o.PHASE.Reg)&^(0x4)|value<<2)
}
func (o *ROSC_Type) GetPHASE_FLIP() uint32 {
	return (volatile.LoadUint32(&o.PHASE.Reg) & 0x4) >> 2
}
func (o *ROSC_Type) SetPHASE_SHIFT(value uint32) {
	volatile.StoreUint32(&o.PHASE.Reg, volatile.LoadUint32(&o.PHASE.Reg)&^(0x3)|value)
}
func (o *ROSC_Type) GetPHASE_SHIFT() uint32 {
	return volatile.LoadUint32(&o.PHASE.Reg) & 0x3
}

// ROSC.STATUS: Ring Oscillator Status
func (o *ROSC_Type) SetSTATUS_STABLE(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80000000)|value<<31)
}
func (o *ROSC_Type) GetSTATUS_STABLE() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80000000) >> 31
}
func (o *ROSC_Type) SetSTATUS_BADWRITE(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *ROSC_Type) GetSTATUS_BADWRITE() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x1000000) >> 24
}
func (o *ROSC_Type) SetSTATUS_DIV_RUNNING(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x10000)|value<<16)
}
func (o *ROSC_Type) GetSTATUS_DIV_RUNNING() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x10000) >> 16
}
func (o *ROSC_Type) SetSTATUS_ENABLED(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *ROSC_Type) GetSTATUS_ENABLED() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x1000) >> 12
}

// ROSC.RANDOMBIT: This just reads the state of the oscillator output so randomness is compromised if the ring oscillator is stopped or run at a harmonic of the bus frequency
func (o *ROSC_Type) SetRANDOMBIT(value uint32) {
	volatile.StoreUint32(&o.RANDOMBIT.Reg, volatile.LoadUint32(&o.RANDOMBIT.Reg)&^(0x1)|value)
}
func (o *ROSC_Type) GetRANDOMBIT() uint32 {
	return volatile.LoadUint32(&o.RANDOMBIT.Reg) & 0x1
}

// ROSC.COUNT
// A down counter running at the ROSC frequency which counts to zero and stops.
// To start the counter write a non-zero value.
// Can be used for short software pauses when setting up time sensitive hardware.
func (o *ROSC_Type) SetCOUNT(value uint32) {
	volatile.StoreUint32(&o.COUNT.Reg, volatile.LoadUint32(&o.COUNT.Reg)&^(0xff)|value)
}
func (o *ROSC_Type) GetCOUNT() uint32 {
	return volatile.LoadUint32(&o.COUNT.Reg) & 0xff
}

// control and status for on-chip voltage regulator and chip level reset subsystem
type VREG_AND_CHIP_RESET_Type struct {
	VREG       volatile.Register32 // 0x0
	BOD        volatile.Register32 // 0x4
	CHIP_RESET volatile.Register32 // 0x8
}

// VREG_AND_CHIP_RESET.VREG: Voltage regulator control and status
func (o *VREG_AND_CHIP_RESET_Type) SetVREG_ROK(value uint32) {
	volatile.StoreUint32(&o.VREG.Reg, volatile.LoadUint32(&o.VREG.Reg)&^(0x1000)|value<<12)
}
func (o *VREG_AND_CHIP_RESET_Type) GetVREG_ROK() uint32 {
	return (volatile.LoadUint32(&o.VREG.Reg) & 0x1000) >> 12
}
func (o *VREG_AND_CHIP_RESET_Type) SetVREG_VSEL(value uint32) {
	volatile.StoreUint32(&o.VREG.Reg, volatile.LoadUint32(&o.VREG.Reg)&^(0xf0)|value<<4)
}
func (o *VREG_AND_CHIP_RESET_Type) GetVREG_VSEL() uint32 {
	return (volatile.LoadUint32(&o.VREG.Reg) & 0xf0) >> 4
}
func (o *VREG_AND_CHIP_RESET_Type) SetVREG_HIZ(value uint32) {
	volatile.StoreUint32(&o.VREG.Reg, volatile.LoadUint32(&o.VREG.Reg)&^(0x2)|value<<1)
}
func (o *VREG_AND_CHIP_RESET_Type) GetVREG_HIZ() uint32 {
	return (volatile.LoadUint32(&o.VREG.Reg) & 0x2) >> 1
}
func (o *VREG_AND_CHIP_RESET_Type) SetVREG_EN(value uint32) {
	volatile.StoreUint32(&o.VREG.Reg, volatile.LoadUint32(&o.VREG.Reg)&^(0x1)|value)
}
func (o *VREG_AND_CHIP_RESET_Type) GetVREG_EN() uint32 {
	return volatile.LoadUint32(&o.VREG.Reg) & 0x1
}

// VREG_AND_CHIP_RESET.BOD: brown-out detection control
func (o *VREG_AND_CHIP_RESET_Type) SetBOD_VSEL(value uint32) {
	volatile.StoreUint32(&o.BOD.Reg, volatile.LoadUint32(&o.BOD.Reg)&^(0xf0)|value<<4)
}
func (o *VREG_AND_CHIP_RESET_Type) GetBOD_VSEL() uint32 {
	return (volatile.LoadUint32(&o.BOD.Reg) & 0xf0) >> 4
}
func (o *VREG_AND_CHIP_RESET_Type) SetBOD_EN(value uint32) {
	volatile.StoreUint32(&o.BOD.Reg, volatile.LoadUint32(&o.BOD.Reg)&^(0x1)|value)
}
func (o *VREG_AND_CHIP_RESET_Type) GetBOD_EN() uint32 {
	return volatile.LoadUint32(&o.BOD.Reg) & 0x1
}

// VREG_AND_CHIP_RESET.CHIP_RESET: Chip reset control and status
func (o *VREG_AND_CHIP_RESET_Type) SetCHIP_RESET_PSM_RESTART_FLAG(value uint32) {
	volatile.StoreUint32(&o.CHIP_RESET.Reg, volatile.LoadUint32(&o.CHIP_RESET.Reg)&^(0x1000000)|value<<24)
}
func (o *VREG_AND_CHIP_RESET_Type) GetCHIP_RESET_PSM_RESTART_FLAG() uint32 {
	return (volatile.LoadUint32(&o.CHIP_RESET.Reg) & 0x1000000) >> 24
}
func (o *VREG_AND_CHIP_RESET_Type) SetCHIP_RESET_HAD_PSM_RESTART(value uint32) {
	volatile.StoreUint32(&o.CHIP_RESET.Reg, volatile.LoadUint32(&o.CHIP_RESET.Reg)&^(0x100000)|value<<20)
}
func (o *VREG_AND_CHIP_RESET_Type) GetCHIP_RESET_HAD_PSM_RESTART() uint32 {
	return (volatile.LoadUint32(&o.CHIP_RESET.Reg) & 0x100000) >> 20
}
func (o *VREG_AND_CHIP_RESET_Type) SetCHIP_RESET_HAD_RUN(value uint32) {
	volatile.StoreUint32(&o.CHIP_RESET.Reg, volatile.LoadUint32(&o.CHIP_RESET.Reg)&^(0x10000)|value<<16)
}
func (o *VREG_AND_CHIP_RESET_Type) GetCHIP_RESET_HAD_RUN() uint32 {
	return (volatile.LoadUint32(&o.CHIP_RESET.Reg) & 0x10000) >> 16
}
func (o *VREG_AND_CHIP_RESET_Type) SetCHIP_RESET_HAD_POR(value uint32) {
	volatile.StoreUint32(&o.CHIP_RESET.Reg, volatile.LoadUint32(&o.CHIP_RESET.Reg)&^(0x100)|value<<8)
}
func (o *VREG_AND_CHIP_RESET_Type) GetCHIP_RESET_HAD_POR() uint32 {
	return (volatile.LoadUint32(&o.CHIP_RESET.Reg) & 0x100) >> 8
}

// Testbench manager. Allows the programmer to know what platform their software is running on.
type TBMAN_Type struct {
	PLATFORM volatile.Register32 // 0x0
}

// TBMAN.PLATFORM: Indicates the type of platform in use
func (o *TBMAN_Type) SetPLATFORM_FPGA(value uint32) {
	volatile.StoreUint32(&o.PLATFORM.Reg, volatile.LoadUint32(&o.PLATFORM.Reg)&^(0x2)|value<<1)
}
func (o *TBMAN_Type) GetPLATFORM_FPGA() uint32 {
	return (volatile.LoadUint32(&o.PLATFORM.Reg) & 0x2) >> 1
}
func (o *TBMAN_Type) SetPLATFORM_ASIC(value uint32) {
	volatile.StoreUint32(&o.PLATFORM.Reg, volatile.LoadUint32(&o.PLATFORM.Reg)&^(0x1)|value)
}
func (o *TBMAN_Type) GetPLATFORM_ASIC() uint32 {
	return volatile.LoadUint32(&o.PLATFORM.Reg) & 0x1
}

// DMA with separate read and write masters
type DMA_Type struct {
	CH0_READ_ADDR             volatile.Register32 // 0x0
	CH0_WRITE_ADDR            volatile.Register32 // 0x4
	CH0_TRANS_COUNT           volatile.Register32 // 0x8
	CH0_CTRL_TRIG             volatile.Register32 // 0xC
	CH0_AL1_CTRL              volatile.Register32 // 0x10
	CH0_AL1_READ_ADDR         volatile.Register32 // 0x14
	CH0_AL1_WRITE_ADDR        volatile.Register32 // 0x18
	CH0_AL1_TRANS_COUNT_TRIG  volatile.Register32 // 0x1C
	CH0_AL2_CTRL              volatile.Register32 // 0x20
	CH0_AL2_TRANS_COUNT       volatile.Register32 // 0x24
	CH0_AL2_READ_ADDR         volatile.Register32 // 0x28
	CH0_AL2_WRITE_ADDR_TRIG   volatile.Register32 // 0x2C
	CH0_AL3_CTRL              volatile.Register32 // 0x30
	CH0_AL3_WRITE_ADDR        volatile.Register32 // 0x34
	CH0_AL3_TRANS_COUNT       volatile.Register32 // 0x38
	CH0_AL3_READ_ADDR_TRIG    volatile.Register32 // 0x3C
	CH1_READ_ADDR             volatile.Register32 // 0x40
	CH1_WRITE_ADDR            volatile.Register32 // 0x44
	CH1_TRANS_COUNT           volatile.Register32 // 0x48
	CH1_CTRL_TRIG             volatile.Register32 // 0x4C
	CH1_AL1_CTRL              volatile.Register32 // 0x50
	CH1_AL1_READ_ADDR         volatile.Register32 // 0x54
	CH1_AL1_WRITE_ADDR        volatile.Register32 // 0x58
	CH1_AL1_TRANS_COUNT_TRIG  volatile.Register32 // 0x5C
	CH1_AL2_CTRL              volatile.Register32 // 0x60
	CH1_AL2_TRANS_COUNT       volatile.Register32 // 0x64
	CH1_AL2_READ_ADDR         volatile.Register32 // 0x68
	CH1_AL2_WRITE_ADDR_TRIG   volatile.Register32 // 0x6C
	CH1_AL3_CTRL              volatile.Register32 // 0x70
	CH1_AL3_WRITE_ADDR        volatile.Register32 // 0x74
	CH1_AL3_TRANS_COUNT       volatile.Register32 // 0x78
	CH1_AL3_READ_ADDR_TRIG    volatile.Register32 // 0x7C
	CH2_READ_ADDR             volatile.Register32 // 0x80
	CH2_WRITE_ADDR            volatile.Register32 // 0x84
	CH2_TRANS_COUNT           volatile.Register32 // 0x88
	CH2_CTRL_TRIG             volatile.Register32 // 0x8C
	CH2_AL1_CTRL              volatile.Register32 // 0x90
	CH2_AL1_READ_ADDR         volatile.Register32 // 0x94
	CH2_AL1_WRITE_ADDR        volatile.Register32 // 0x98
	CH2_AL1_TRANS_COUNT_TRIG  volatile.Register32 // 0x9C
	CH2_AL2_CTRL              volatile.Register32 // 0xA0
	CH2_AL2_TRANS_COUNT       volatile.Register32 // 0xA4
	CH2_AL2_READ_ADDR         volatile.Register32 // 0xA8
	CH2_AL2_WRITE_ADDR_TRIG   volatile.Register32 // 0xAC
	CH2_AL3_CTRL              volatile.Register32 // 0xB0
	CH2_AL3_WRITE_ADDR        volatile.Register32 // 0xB4
	CH2_AL3_TRANS_COUNT       volatile.Register32 // 0xB8
	CH2_AL3_READ_ADDR_TRIG    volatile.Register32 // 0xBC
	CH3_READ_ADDR             volatile.Register32 // 0xC0
	CH3_WRITE_ADDR            volatile.Register32 // 0xC4
	CH3_TRANS_COUNT           volatile.Register32 // 0xC8
	CH3_CTRL_TRIG             volatile.Register32 // 0xCC
	CH3_AL1_CTRL              volatile.Register32 // 0xD0
	CH3_AL1_READ_ADDR         volatile.Register32 // 0xD4
	CH3_AL1_WRITE_ADDR        volatile.Register32 // 0xD8
	CH3_AL1_TRANS_COUNT_TRIG  volatile.Register32 // 0xDC
	CH3_AL2_CTRL              volatile.Register32 // 0xE0
	CH3_AL2_TRANS_COUNT       volatile.Register32 // 0xE4
	CH3_AL2_READ_ADDR         volatile.Register32 // 0xE8
	CH3_AL2_WRITE_ADDR_TRIG   volatile.Register32 // 0xEC
	CH3_AL3_CTRL              volatile.Register32 // 0xF0
	CH3_AL3_WRITE_ADDR        volatile.Register32 // 0xF4
	CH3_AL3_TRANS_COUNT       volatile.Register32 // 0xF8
	CH3_AL3_READ_ADDR_TRIG    volatile.Register32 // 0xFC
	CH4_READ_ADDR             volatile.Register32 // 0x100
	CH4_WRITE_ADDR            volatile.Register32 // 0x104
	CH4_TRANS_COUNT           volatile.Register32 // 0x108
	CH4_CTRL_TRIG             volatile.Register32 // 0x10C
	CH4_AL1_CTRL              volatile.Register32 // 0x110
	CH4_AL1_READ_ADDR         volatile.Register32 // 0x114
	CH4_AL1_WRITE_ADDR        volatile.Register32 // 0x118
	CH4_AL1_TRANS_COUNT_TRIG  volatile.Register32 // 0x11C
	CH4_AL2_CTRL              volatile.Register32 // 0x120
	CH4_AL2_TRANS_COUNT       volatile.Register32 // 0x124
	CH4_AL2_READ_ADDR         volatile.Register32 // 0x128
	CH4_AL2_WRITE_ADDR_TRIG   volatile.Register32 // 0x12C
	CH4_AL3_CTRL              volatile.Register32 // 0x130
	CH4_AL3_WRITE_ADDR        volatile.Register32 // 0x134
	CH4_AL3_TRANS_COUNT       volatile.Register32 // 0x138
	CH4_AL3_READ_ADDR_TRIG    volatile.Register32 // 0x13C
	CH5_READ_ADDR             volatile.Register32 // 0x140
	CH5_WRITE_ADDR            volatile.Register32 // 0x144
	CH5_TRANS_COUNT           volatile.Register32 // 0x148
	CH5_CTRL_TRIG             volatile.Register32 // 0x14C
	CH5_AL1_CTRL              volatile.Register32 // 0x150
	CH5_AL1_READ_ADDR         volatile.Register32 // 0x154
	CH5_AL1_WRITE_ADDR        volatile.Register32 // 0x158
	CH5_AL1_TRANS_COUNT_TRIG  volatile.Register32 // 0x15C
	CH5_AL2_CTRL              volatile.Register32 // 0x160
	CH5_AL2_TRANS_COUNT       volatile.Register32 // 0x164
	CH5_AL2_READ_ADDR         volatile.Register32 // 0x168
	CH5_AL2_WRITE_ADDR_TRIG   volatile.Register32 // 0x16C
	CH5_AL3_CTRL              volatile.Register32 // 0x170
	CH5_AL3_WRITE_ADDR        volatile.Register32 // 0x174
	CH5_AL3_TRANS_COUNT       volatile.Register32 // 0x178
	CH5_AL3_READ_ADDR_TRIG    volatile.Register32 // 0x17C
	CH6_READ_ADDR             volatile.Register32 // 0x180
	CH6_WRITE_ADDR            volatile.Register32 // 0x184
	CH6_TRANS_COUNT           volatile.Register32 // 0x188
	CH6_CTRL_TRIG             volatile.Register32 // 0x18C
	CH6_AL1_CTRL              volatile.Register32 // 0x190
	CH6_AL1_READ_ADDR         volatile.Register32 // 0x194
	CH6_AL1_WRITE_ADDR        volatile.Register32 // 0x198
	CH6_AL1_TRANS_COUNT_TRIG  volatile.Register32 // 0x19C
	CH6_AL2_CTRL              volatile.Register32 // 0x1A0
	CH6_AL2_TRANS_COUNT       volatile.Register32 // 0x1A4
	CH6_AL2_READ_ADDR         volatile.Register32 // 0x1A8
	CH6_AL2_WRITE_ADDR_TRIG   volatile.Register32 // 0x1AC
	CH6_AL3_CTRL              volatile.Register32 // 0x1B0
	CH6_AL3_WRITE_ADDR        volatile.Register32 // 0x1B4
	CH6_AL3_TRANS_COUNT       volatile.Register32 // 0x1B8
	CH6_AL3_READ_ADDR_TRIG    volatile.Register32 // 0x1BC
	CH7_READ_ADDR             volatile.Register32 // 0x1C0
	CH7_WRITE_ADDR            volatile.Register32 // 0x1C4
	CH7_TRANS_COUNT           volatile.Register32 // 0x1C8
	CH7_CTRL_TRIG             volatile.Register32 // 0x1CC
	CH7_AL1_CTRL              volatile.Register32 // 0x1D0
	CH7_AL1_READ_ADDR         volatile.Register32 // 0x1D4
	CH7_AL1_WRITE_ADDR        volatile.Register32 // 0x1D8
	CH7_AL1_TRANS_COUNT_TRIG  volatile.Register32 // 0x1DC
	CH7_AL2_CTRL              volatile.Register32 // 0x1E0
	CH7_AL2_TRANS_COUNT       volatile.Register32 // 0x1E4
	CH7_AL2_READ_ADDR         volatile.Register32 // 0x1E8
	CH7_AL2_WRITE_ADDR_TRIG   volatile.Register32 // 0x1EC
	CH7_AL3_CTRL              volatile.Register32 // 0x1F0
	CH7_AL3_WRITE_ADDR        volatile.Register32 // 0x1F4
	CH7_AL3_TRANS_COUNT       volatile.Register32 // 0x1F8
	CH7_AL3_READ_ADDR_TRIG    volatile.Register32 // 0x1FC
	CH8_READ_ADDR             volatile.Register32 // 0x200
	CH8_WRITE_ADDR            volatile.Register32 // 0x204
	CH8_TRANS_COUNT           volatile.Register32 // 0x208
	CH8_CTRL_TRIG             volatile.Register32 // 0x20C
	CH8_AL1_CTRL              volatile.Register32 // 0x210
	CH8_AL1_READ_ADDR         volatile.Register32 // 0x214
	CH8_AL1_WRITE_ADDR        volatile.Register32 // 0x218
	CH8_AL1_TRANS_COUNT_TRIG  volatile.Register32 // 0x21C
	CH8_AL2_CTRL              volatile.Register32 // 0x220
	CH8_AL2_TRANS_COUNT       volatile.Register32 // 0x224
	CH8_AL2_READ_ADDR         volatile.Register32 // 0x228
	CH8_AL2_WRITE_ADDR_TRIG   volatile.Register32 // 0x22C
	CH8_AL3_CTRL              volatile.Register32 // 0x230
	CH8_AL3_WRITE_ADDR        volatile.Register32 // 0x234
	CH8_AL3_TRANS_COUNT       volatile.Register32 // 0x238
	CH8_AL3_READ_ADDR_TRIG    volatile.Register32 // 0x23C
	CH9_READ_ADDR             volatile.Register32 // 0x240
	CH9_WRITE_ADDR            volatile.Register32 // 0x244
	CH9_TRANS_COUNT           volatile.Register32 // 0x248
	CH9_CTRL_TRIG             volatile.Register32 // 0x24C
	CH9_AL1_CTRL              volatile.Register32 // 0x250
	CH9_AL1_READ_ADDR         volatile.Register32 // 0x254
	CH9_AL1_WRITE_ADDR        volatile.Register32 // 0x258
	CH9_AL1_TRANS_COUNT_TRIG  volatile.Register32 // 0x25C
	CH9_AL2_CTRL              volatile.Register32 // 0x260
	CH9_AL2_TRANS_COUNT       volatile.Register32 // 0x264
	CH9_AL2_READ_ADDR         volatile.Register32 // 0x268
	CH9_AL2_WRITE_ADDR_TRIG   volatile.Register32 // 0x26C
	CH9_AL3_CTRL              volatile.Register32 // 0x270
	CH9_AL3_WRITE_ADDR        volatile.Register32 // 0x274
	CH9_AL3_TRANS_COUNT       volatile.Register32 // 0x278
	CH9_AL3_READ_ADDR_TRIG    volatile.Register32 // 0x27C
	CH10_READ_ADDR            volatile.Register32 // 0x280
	CH10_WRITE_ADDR           volatile.Register32 // 0x284
	CH10_TRANS_COUNT          volatile.Register32 // 0x288
	CH10_CTRL_TRIG            volatile.Register32 // 0x28C
	CH10_AL1_CTRL             volatile.Register32 // 0x290
	CH10_AL1_READ_ADDR        volatile.Register32 // 0x294
	CH10_AL1_WRITE_ADDR       volatile.Register32 // 0x298
	CH10_AL1_TRANS_COUNT_TRIG volatile.Register32 // 0x29C
	CH10_AL2_CTRL             volatile.Register32 // 0x2A0
	CH10_AL2_TRANS_COUNT      volatile.Register32 // 0x2A4
	CH10_AL2_READ_ADDR        volatile.Register32 // 0x2A8
	CH10_AL2_WRITE_ADDR_TRIG  volatile.Register32 // 0x2AC
	CH10_AL3_CTRL             volatile.Register32 // 0x2B0
	CH10_AL3_WRITE_ADDR       volatile.Register32 // 0x2B4
	CH10_AL3_TRANS_COUNT      volatile.Register32 // 0x2B8
	CH10_AL3_READ_ADDR_TRIG   volatile.Register32 // 0x2BC
	CH11_READ_ADDR            volatile.Register32 // 0x2C0
	CH11_WRITE_ADDR           volatile.Register32 // 0x2C4
	CH11_TRANS_COUNT          volatile.Register32 // 0x2C8
	CH11_CTRL_TRIG            volatile.Register32 // 0x2CC
	CH11_AL1_CTRL             volatile.Register32 // 0x2D0
	CH11_AL1_READ_ADDR        volatile.Register32 // 0x2D4
	CH11_AL1_WRITE_ADDR       volatile.Register32 // 0x2D8
	CH11_AL1_TRANS_COUNT_TRIG volatile.Register32 // 0x2DC
	CH11_AL2_CTRL             volatile.Register32 // 0x2E0
	CH11_AL2_TRANS_COUNT      volatile.Register32 // 0x2E4
	CH11_AL2_READ_ADDR        volatile.Register32 // 0x2E8
	CH11_AL2_WRITE_ADDR_TRIG  volatile.Register32 // 0x2EC
	CH11_AL3_CTRL             volatile.Register32 // 0x2F0
	CH11_AL3_WRITE_ADDR       volatile.Register32 // 0x2F4
	CH11_AL3_TRANS_COUNT      volatile.Register32 // 0x2F8
	CH11_AL3_READ_ADDR_TRIG   volatile.Register32 // 0x2FC
	_                         [256]byte
	INTR                      volatile.Register32 // 0x400
	INTE0                     volatile.Register32 // 0x404
	INTF0                     volatile.Register32 // 0x408
	INTS0                     volatile.Register32 // 0x40C
	_                         [4]byte
	INTE1                     volatile.Register32 // 0x414
	INTF1                     volatile.Register32 // 0x418
	INTS1                     volatile.Register32 // 0x41C
	TIMER0                    volatile.Register32 // 0x420
	TIMER1                    volatile.Register32 // 0x424
	_                         [8]byte
	MULTI_CHAN_TRIGGER        volatile.Register32 // 0x430
	SNIFF_CTRL                volatile.Register32 // 0x434
	SNIFF_DATA                volatile.Register32 // 0x438
	_                         [4]byte
	FIFO_LEVELS               volatile.Register32 // 0x440
	CHAN_ABORT                volatile.Register32 // 0x444
	N_CHANNELS                volatile.Register32 // 0x448
	_                         [948]byte
	CH0_DBG_CTDREQ            volatile.Register32 // 0x800
	CH0_DBG_TCR               volatile.Register32 // 0x804
	_                         [56]byte
	CH1_DBG_CTDREQ            volatile.Register32 // 0x840
	CH1_DBG_TCR               volatile.Register32 // 0x844
	_                         [56]byte
	CH2_DBG_CTDREQ            volatile.Register32 // 0x880
	CH2_DBG_TCR               volatile.Register32 // 0x884
	_                         [56]byte
	CH3_DBG_CTDREQ            volatile.Register32 // 0x8C0
	CH3_DBG_TCR               volatile.Register32 // 0x8C4
	_                         [56]byte
	CH4_DBG_CTDREQ            volatile.Register32 // 0x900
	CH4_DBG_TCR               volatile.Register32 // 0x904
	_                         [56]byte
	CH5_DBG_CTDREQ            volatile.Register32 // 0x940
	CH5_DBG_TCR               volatile.Register32 // 0x944
	_                         [56]byte
	CH6_DBG_CTDREQ            volatile.Register32 // 0x980
	CH6_DBG_TCR               volatile.Register32 // 0x984
	_                         [56]byte
	CH7_DBG_CTDREQ            volatile.Register32 // 0x9C0
	CH7_DBG_TCR               volatile.Register32 // 0x9C4
	_                         [56]byte
	CH8_DBG_CTDREQ            volatile.Register32 // 0xA00
	CH8_DBG_TCR               volatile.Register32 // 0xA04
	_                         [56]byte
	CH9_DBG_CTDREQ            volatile.Register32 // 0xA40
	CH9_DBG_TCR               volatile.Register32 // 0xA44
	_                         [56]byte
	CH10_DBG_CTDREQ           volatile.Register32 // 0xA80
	CH10_DBG_TCR              volatile.Register32 // 0xA84
	_                         [56]byte
	CH11_DBG_CTDREQ           volatile.Register32 // 0xAC0
	CH11_DBG_TCR              volatile.Register32 // 0xAC4
}

// DMA.CH0_CTRL_TRIG: DMA Channel 0 Control and Status
func (o *DMA_Type) SetCH0_CTRL_TRIG_AHB_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH0_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg)&^(0x80000000)|value<<31)
}
func (o *DMA_Type) GetCH0_CTRL_TRIG_AHB_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg) & 0x80000000) >> 31
}
func (o *DMA_Type) SetCH0_CTRL_TRIG_READ_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH0_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg)&^(0x40000000)|value<<30)
}
func (o *DMA_Type) GetCH0_CTRL_TRIG_READ_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg) & 0x40000000) >> 30
}
func (o *DMA_Type) SetCH0_CTRL_TRIG_WRITE_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH0_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg)&^(0x20000000)|value<<29)
}
func (o *DMA_Type) GetCH0_CTRL_TRIG_WRITE_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg) & 0x20000000) >> 29
}
func (o *DMA_Type) SetCH0_CTRL_TRIG_BUSY(value uint32) {
	volatile.StoreUint32(&o.CH0_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetCH0_CTRL_TRIG_BUSY() uint32 {
	return (volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetCH0_CTRL_TRIG_SNIFF_EN(value uint32) {
	volatile.StoreUint32(&o.CH0_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetCH0_CTRL_TRIG_SNIFF_EN() uint32 {
	return (volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetCH0_CTRL_TRIG_BSWAP(value uint32) {
	volatile.StoreUint32(&o.CH0_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetCH0_CTRL_TRIG_BSWAP() uint32 {
	return (volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetCH0_CTRL_TRIG_IRQ_QUIET(value uint32) {
	volatile.StoreUint32(&o.CH0_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetCH0_CTRL_TRIG_IRQ_QUIET() uint32 {
	return (volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetCH0_CTRL_TRIG_TREQ_SEL(value uint32) {
	volatile.StoreUint32(&o.CH0_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg)&^(0x1f8000)|value<<15)
}
func (o *DMA_Type) GetCH0_CTRL_TRIG_TREQ_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg) & 0x1f8000) >> 15
}
func (o *DMA_Type) SetCH0_CTRL_TRIG_CHAIN_TO(value uint32) {
	volatile.StoreUint32(&o.CH0_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg)&^(0x7800)|value<<11)
}
func (o *DMA_Type) GetCH0_CTRL_TRIG_CHAIN_TO() uint32 {
	return (volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg) & 0x7800) >> 11
}
func (o *DMA_Type) SetCH0_CTRL_TRIG_RING_SEL(value uint32) {
	volatile.StoreUint32(&o.CH0_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetCH0_CTRL_TRIG_RING_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetCH0_CTRL_TRIG_RING_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH0_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg)&^(0x3c0)|value<<6)
}
func (o *DMA_Type) GetCH0_CTRL_TRIG_RING_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg) & 0x3c0) >> 6
}
func (o *DMA_Type) SetCH0_CTRL_TRIG_INCR_WRITE(value uint32) {
	volatile.StoreUint32(&o.CH0_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCH0_CTRL_TRIG_INCR_WRITE() uint32 {
	return (volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCH0_CTRL_TRIG_INCR_READ(value uint32) {
	volatile.StoreUint32(&o.CH0_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCH0_CTRL_TRIG_INCR_READ() uint32 {
	return (volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCH0_CTRL_TRIG_DATA_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH0_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg)&^(0xc)|value<<2)
}
func (o *DMA_Type) GetCH0_CTRL_TRIG_DATA_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg) & 0xc) >> 2
}
func (o *DMA_Type) SetCH0_CTRL_TRIG_HIGH_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.CH0_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCH0_CTRL_TRIG_HIGH_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCH0_CTRL_TRIG_EN(value uint32) {
	volatile.StoreUint32(&o.CH0_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCH0_CTRL_TRIG_EN() uint32 {
	return volatile.LoadUint32(&o.CH0_CTRL_TRIG.Reg) & 0x1
}

// DMA.CH1_CTRL_TRIG: DMA Channel 1 Control and Status
func (o *DMA_Type) SetCH1_CTRL_TRIG_AHB_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH1_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg)&^(0x80000000)|value<<31)
}
func (o *DMA_Type) GetCH1_CTRL_TRIG_AHB_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg) & 0x80000000) >> 31
}
func (o *DMA_Type) SetCH1_CTRL_TRIG_READ_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH1_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg)&^(0x40000000)|value<<30)
}
func (o *DMA_Type) GetCH1_CTRL_TRIG_READ_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg) & 0x40000000) >> 30
}
func (o *DMA_Type) SetCH1_CTRL_TRIG_WRITE_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH1_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg)&^(0x20000000)|value<<29)
}
func (o *DMA_Type) GetCH1_CTRL_TRIG_WRITE_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg) & 0x20000000) >> 29
}
func (o *DMA_Type) SetCH1_CTRL_TRIG_BUSY(value uint32) {
	volatile.StoreUint32(&o.CH1_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetCH1_CTRL_TRIG_BUSY() uint32 {
	return (volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetCH1_CTRL_TRIG_SNIFF_EN(value uint32) {
	volatile.StoreUint32(&o.CH1_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetCH1_CTRL_TRIG_SNIFF_EN() uint32 {
	return (volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetCH1_CTRL_TRIG_BSWAP(value uint32) {
	volatile.StoreUint32(&o.CH1_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetCH1_CTRL_TRIG_BSWAP() uint32 {
	return (volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetCH1_CTRL_TRIG_IRQ_QUIET(value uint32) {
	volatile.StoreUint32(&o.CH1_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetCH1_CTRL_TRIG_IRQ_QUIET() uint32 {
	return (volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetCH1_CTRL_TRIG_TREQ_SEL(value uint32) {
	volatile.StoreUint32(&o.CH1_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg)&^(0x1f8000)|value<<15)
}
func (o *DMA_Type) GetCH1_CTRL_TRIG_TREQ_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg) & 0x1f8000) >> 15
}
func (o *DMA_Type) SetCH1_CTRL_TRIG_CHAIN_TO(value uint32) {
	volatile.StoreUint32(&o.CH1_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg)&^(0x7800)|value<<11)
}
func (o *DMA_Type) GetCH1_CTRL_TRIG_CHAIN_TO() uint32 {
	return (volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg) & 0x7800) >> 11
}
func (o *DMA_Type) SetCH1_CTRL_TRIG_RING_SEL(value uint32) {
	volatile.StoreUint32(&o.CH1_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetCH1_CTRL_TRIG_RING_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetCH1_CTRL_TRIG_RING_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH1_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg)&^(0x3c0)|value<<6)
}
func (o *DMA_Type) GetCH1_CTRL_TRIG_RING_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg) & 0x3c0) >> 6
}
func (o *DMA_Type) SetCH1_CTRL_TRIG_INCR_WRITE(value uint32) {
	volatile.StoreUint32(&o.CH1_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCH1_CTRL_TRIG_INCR_WRITE() uint32 {
	return (volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCH1_CTRL_TRIG_INCR_READ(value uint32) {
	volatile.StoreUint32(&o.CH1_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCH1_CTRL_TRIG_INCR_READ() uint32 {
	return (volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCH1_CTRL_TRIG_DATA_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH1_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg)&^(0xc)|value<<2)
}
func (o *DMA_Type) GetCH1_CTRL_TRIG_DATA_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg) & 0xc) >> 2
}
func (o *DMA_Type) SetCH1_CTRL_TRIG_HIGH_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.CH1_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCH1_CTRL_TRIG_HIGH_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCH1_CTRL_TRIG_EN(value uint32) {
	volatile.StoreUint32(&o.CH1_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCH1_CTRL_TRIG_EN() uint32 {
	return volatile.LoadUint32(&o.CH1_CTRL_TRIG.Reg) & 0x1
}

// DMA.CH2_CTRL_TRIG: DMA Channel 2 Control and Status
func (o *DMA_Type) SetCH2_CTRL_TRIG_AHB_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH2_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg)&^(0x80000000)|value<<31)
}
func (o *DMA_Type) GetCH2_CTRL_TRIG_AHB_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg) & 0x80000000) >> 31
}
func (o *DMA_Type) SetCH2_CTRL_TRIG_READ_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH2_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg)&^(0x40000000)|value<<30)
}
func (o *DMA_Type) GetCH2_CTRL_TRIG_READ_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg) & 0x40000000) >> 30
}
func (o *DMA_Type) SetCH2_CTRL_TRIG_WRITE_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH2_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg)&^(0x20000000)|value<<29)
}
func (o *DMA_Type) GetCH2_CTRL_TRIG_WRITE_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg) & 0x20000000) >> 29
}
func (o *DMA_Type) SetCH2_CTRL_TRIG_BUSY(value uint32) {
	volatile.StoreUint32(&o.CH2_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetCH2_CTRL_TRIG_BUSY() uint32 {
	return (volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetCH2_CTRL_TRIG_SNIFF_EN(value uint32) {
	volatile.StoreUint32(&o.CH2_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetCH2_CTRL_TRIG_SNIFF_EN() uint32 {
	return (volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetCH2_CTRL_TRIG_BSWAP(value uint32) {
	volatile.StoreUint32(&o.CH2_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetCH2_CTRL_TRIG_BSWAP() uint32 {
	return (volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetCH2_CTRL_TRIG_IRQ_QUIET(value uint32) {
	volatile.StoreUint32(&o.CH2_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetCH2_CTRL_TRIG_IRQ_QUIET() uint32 {
	return (volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetCH2_CTRL_TRIG_TREQ_SEL(value uint32) {
	volatile.StoreUint32(&o.CH2_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg)&^(0x1f8000)|value<<15)
}
func (o *DMA_Type) GetCH2_CTRL_TRIG_TREQ_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg) & 0x1f8000) >> 15
}
func (o *DMA_Type) SetCH2_CTRL_TRIG_CHAIN_TO(value uint32) {
	volatile.StoreUint32(&o.CH2_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg)&^(0x7800)|value<<11)
}
func (o *DMA_Type) GetCH2_CTRL_TRIG_CHAIN_TO() uint32 {
	return (volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg) & 0x7800) >> 11
}
func (o *DMA_Type) SetCH2_CTRL_TRIG_RING_SEL(value uint32) {
	volatile.StoreUint32(&o.CH2_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetCH2_CTRL_TRIG_RING_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetCH2_CTRL_TRIG_RING_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH2_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg)&^(0x3c0)|value<<6)
}
func (o *DMA_Type) GetCH2_CTRL_TRIG_RING_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg) & 0x3c0) >> 6
}
func (o *DMA_Type) SetCH2_CTRL_TRIG_INCR_WRITE(value uint32) {
	volatile.StoreUint32(&o.CH2_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCH2_CTRL_TRIG_INCR_WRITE() uint32 {
	return (volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCH2_CTRL_TRIG_INCR_READ(value uint32) {
	volatile.StoreUint32(&o.CH2_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCH2_CTRL_TRIG_INCR_READ() uint32 {
	return (volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCH2_CTRL_TRIG_DATA_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH2_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg)&^(0xc)|value<<2)
}
func (o *DMA_Type) GetCH2_CTRL_TRIG_DATA_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg) & 0xc) >> 2
}
func (o *DMA_Type) SetCH2_CTRL_TRIG_HIGH_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.CH2_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCH2_CTRL_TRIG_HIGH_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCH2_CTRL_TRIG_EN(value uint32) {
	volatile.StoreUint32(&o.CH2_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCH2_CTRL_TRIG_EN() uint32 {
	return volatile.LoadUint32(&o.CH2_CTRL_TRIG.Reg) & 0x1
}

// DMA.CH3_CTRL_TRIG: DMA Channel 3 Control and Status
func (o *DMA_Type) SetCH3_CTRL_TRIG_AHB_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH3_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg)&^(0x80000000)|value<<31)
}
func (o *DMA_Type) GetCH3_CTRL_TRIG_AHB_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg) & 0x80000000) >> 31
}
func (o *DMA_Type) SetCH3_CTRL_TRIG_READ_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH3_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg)&^(0x40000000)|value<<30)
}
func (o *DMA_Type) GetCH3_CTRL_TRIG_READ_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg) & 0x40000000) >> 30
}
func (o *DMA_Type) SetCH3_CTRL_TRIG_WRITE_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH3_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg)&^(0x20000000)|value<<29)
}
func (o *DMA_Type) GetCH3_CTRL_TRIG_WRITE_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg) & 0x20000000) >> 29
}
func (o *DMA_Type) SetCH3_CTRL_TRIG_BUSY(value uint32) {
	volatile.StoreUint32(&o.CH3_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetCH3_CTRL_TRIG_BUSY() uint32 {
	return (volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetCH3_CTRL_TRIG_SNIFF_EN(value uint32) {
	volatile.StoreUint32(&o.CH3_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetCH3_CTRL_TRIG_SNIFF_EN() uint32 {
	return (volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetCH3_CTRL_TRIG_BSWAP(value uint32) {
	volatile.StoreUint32(&o.CH3_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetCH3_CTRL_TRIG_BSWAP() uint32 {
	return (volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetCH3_CTRL_TRIG_IRQ_QUIET(value uint32) {
	volatile.StoreUint32(&o.CH3_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetCH3_CTRL_TRIG_IRQ_QUIET() uint32 {
	return (volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetCH3_CTRL_TRIG_TREQ_SEL(value uint32) {
	volatile.StoreUint32(&o.CH3_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg)&^(0x1f8000)|value<<15)
}
func (o *DMA_Type) GetCH3_CTRL_TRIG_TREQ_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg) & 0x1f8000) >> 15
}
func (o *DMA_Type) SetCH3_CTRL_TRIG_CHAIN_TO(value uint32) {
	volatile.StoreUint32(&o.CH3_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg)&^(0x7800)|value<<11)
}
func (o *DMA_Type) GetCH3_CTRL_TRIG_CHAIN_TO() uint32 {
	return (volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg) & 0x7800) >> 11
}
func (o *DMA_Type) SetCH3_CTRL_TRIG_RING_SEL(value uint32) {
	volatile.StoreUint32(&o.CH3_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetCH3_CTRL_TRIG_RING_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetCH3_CTRL_TRIG_RING_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH3_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg)&^(0x3c0)|value<<6)
}
func (o *DMA_Type) GetCH3_CTRL_TRIG_RING_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg) & 0x3c0) >> 6
}
func (o *DMA_Type) SetCH3_CTRL_TRIG_INCR_WRITE(value uint32) {
	volatile.StoreUint32(&o.CH3_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCH3_CTRL_TRIG_INCR_WRITE() uint32 {
	return (volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCH3_CTRL_TRIG_INCR_READ(value uint32) {
	volatile.StoreUint32(&o.CH3_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCH3_CTRL_TRIG_INCR_READ() uint32 {
	return (volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCH3_CTRL_TRIG_DATA_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH3_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg)&^(0xc)|value<<2)
}
func (o *DMA_Type) GetCH3_CTRL_TRIG_DATA_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg) & 0xc) >> 2
}
func (o *DMA_Type) SetCH3_CTRL_TRIG_HIGH_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.CH3_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCH3_CTRL_TRIG_HIGH_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCH3_CTRL_TRIG_EN(value uint32) {
	volatile.StoreUint32(&o.CH3_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCH3_CTRL_TRIG_EN() uint32 {
	return volatile.LoadUint32(&o.CH3_CTRL_TRIG.Reg) & 0x1
}

// DMA.CH4_CTRL_TRIG: DMA Channel 4 Control and Status
func (o *DMA_Type) SetCH4_CTRL_TRIG_AHB_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH4_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg)&^(0x80000000)|value<<31)
}
func (o *DMA_Type) GetCH4_CTRL_TRIG_AHB_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg) & 0x80000000) >> 31
}
func (o *DMA_Type) SetCH4_CTRL_TRIG_READ_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH4_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg)&^(0x40000000)|value<<30)
}
func (o *DMA_Type) GetCH4_CTRL_TRIG_READ_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg) & 0x40000000) >> 30
}
func (o *DMA_Type) SetCH4_CTRL_TRIG_WRITE_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH4_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg)&^(0x20000000)|value<<29)
}
func (o *DMA_Type) GetCH4_CTRL_TRIG_WRITE_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg) & 0x20000000) >> 29
}
func (o *DMA_Type) SetCH4_CTRL_TRIG_BUSY(value uint32) {
	volatile.StoreUint32(&o.CH4_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetCH4_CTRL_TRIG_BUSY() uint32 {
	return (volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetCH4_CTRL_TRIG_SNIFF_EN(value uint32) {
	volatile.StoreUint32(&o.CH4_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetCH4_CTRL_TRIG_SNIFF_EN() uint32 {
	return (volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetCH4_CTRL_TRIG_BSWAP(value uint32) {
	volatile.StoreUint32(&o.CH4_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetCH4_CTRL_TRIG_BSWAP() uint32 {
	return (volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetCH4_CTRL_TRIG_IRQ_QUIET(value uint32) {
	volatile.StoreUint32(&o.CH4_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetCH4_CTRL_TRIG_IRQ_QUIET() uint32 {
	return (volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetCH4_CTRL_TRIG_TREQ_SEL(value uint32) {
	volatile.StoreUint32(&o.CH4_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg)&^(0x1f8000)|value<<15)
}
func (o *DMA_Type) GetCH4_CTRL_TRIG_TREQ_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg) & 0x1f8000) >> 15
}
func (o *DMA_Type) SetCH4_CTRL_TRIG_CHAIN_TO(value uint32) {
	volatile.StoreUint32(&o.CH4_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg)&^(0x7800)|value<<11)
}
func (o *DMA_Type) GetCH4_CTRL_TRIG_CHAIN_TO() uint32 {
	return (volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg) & 0x7800) >> 11
}
func (o *DMA_Type) SetCH4_CTRL_TRIG_RING_SEL(value uint32) {
	volatile.StoreUint32(&o.CH4_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetCH4_CTRL_TRIG_RING_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetCH4_CTRL_TRIG_RING_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH4_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg)&^(0x3c0)|value<<6)
}
func (o *DMA_Type) GetCH4_CTRL_TRIG_RING_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg) & 0x3c0) >> 6
}
func (o *DMA_Type) SetCH4_CTRL_TRIG_INCR_WRITE(value uint32) {
	volatile.StoreUint32(&o.CH4_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCH4_CTRL_TRIG_INCR_WRITE() uint32 {
	return (volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCH4_CTRL_TRIG_INCR_READ(value uint32) {
	volatile.StoreUint32(&o.CH4_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCH4_CTRL_TRIG_INCR_READ() uint32 {
	return (volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCH4_CTRL_TRIG_DATA_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH4_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg)&^(0xc)|value<<2)
}
func (o *DMA_Type) GetCH4_CTRL_TRIG_DATA_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg) & 0xc) >> 2
}
func (o *DMA_Type) SetCH4_CTRL_TRIG_HIGH_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.CH4_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCH4_CTRL_TRIG_HIGH_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCH4_CTRL_TRIG_EN(value uint32) {
	volatile.StoreUint32(&o.CH4_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCH4_CTRL_TRIG_EN() uint32 {
	return volatile.LoadUint32(&o.CH4_CTRL_TRIG.Reg) & 0x1
}

// DMA.CH5_CTRL_TRIG: DMA Channel 5 Control and Status
func (o *DMA_Type) SetCH5_CTRL_TRIG_AHB_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH5_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg)&^(0x80000000)|value<<31)
}
func (o *DMA_Type) GetCH5_CTRL_TRIG_AHB_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg) & 0x80000000) >> 31
}
func (o *DMA_Type) SetCH5_CTRL_TRIG_READ_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH5_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg)&^(0x40000000)|value<<30)
}
func (o *DMA_Type) GetCH5_CTRL_TRIG_READ_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg) & 0x40000000) >> 30
}
func (o *DMA_Type) SetCH5_CTRL_TRIG_WRITE_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH5_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg)&^(0x20000000)|value<<29)
}
func (o *DMA_Type) GetCH5_CTRL_TRIG_WRITE_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg) & 0x20000000) >> 29
}
func (o *DMA_Type) SetCH5_CTRL_TRIG_BUSY(value uint32) {
	volatile.StoreUint32(&o.CH5_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetCH5_CTRL_TRIG_BUSY() uint32 {
	return (volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetCH5_CTRL_TRIG_SNIFF_EN(value uint32) {
	volatile.StoreUint32(&o.CH5_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetCH5_CTRL_TRIG_SNIFF_EN() uint32 {
	return (volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetCH5_CTRL_TRIG_BSWAP(value uint32) {
	volatile.StoreUint32(&o.CH5_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetCH5_CTRL_TRIG_BSWAP() uint32 {
	return (volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetCH5_CTRL_TRIG_IRQ_QUIET(value uint32) {
	volatile.StoreUint32(&o.CH5_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetCH5_CTRL_TRIG_IRQ_QUIET() uint32 {
	return (volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetCH5_CTRL_TRIG_TREQ_SEL(value uint32) {
	volatile.StoreUint32(&o.CH5_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg)&^(0x1f8000)|value<<15)
}
func (o *DMA_Type) GetCH5_CTRL_TRIG_TREQ_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg) & 0x1f8000) >> 15
}
func (o *DMA_Type) SetCH5_CTRL_TRIG_CHAIN_TO(value uint32) {
	volatile.StoreUint32(&o.CH5_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg)&^(0x7800)|value<<11)
}
func (o *DMA_Type) GetCH5_CTRL_TRIG_CHAIN_TO() uint32 {
	return (volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg) & 0x7800) >> 11
}
func (o *DMA_Type) SetCH5_CTRL_TRIG_RING_SEL(value uint32) {
	volatile.StoreUint32(&o.CH5_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetCH5_CTRL_TRIG_RING_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetCH5_CTRL_TRIG_RING_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH5_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg)&^(0x3c0)|value<<6)
}
func (o *DMA_Type) GetCH5_CTRL_TRIG_RING_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg) & 0x3c0) >> 6
}
func (o *DMA_Type) SetCH5_CTRL_TRIG_INCR_WRITE(value uint32) {
	volatile.StoreUint32(&o.CH5_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCH5_CTRL_TRIG_INCR_WRITE() uint32 {
	return (volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCH5_CTRL_TRIG_INCR_READ(value uint32) {
	volatile.StoreUint32(&o.CH5_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCH5_CTRL_TRIG_INCR_READ() uint32 {
	return (volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCH5_CTRL_TRIG_DATA_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH5_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg)&^(0xc)|value<<2)
}
func (o *DMA_Type) GetCH5_CTRL_TRIG_DATA_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg) & 0xc) >> 2
}
func (o *DMA_Type) SetCH5_CTRL_TRIG_HIGH_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.CH5_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCH5_CTRL_TRIG_HIGH_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCH5_CTRL_TRIG_EN(value uint32) {
	volatile.StoreUint32(&o.CH5_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCH5_CTRL_TRIG_EN() uint32 {
	return volatile.LoadUint32(&o.CH5_CTRL_TRIG.Reg) & 0x1
}

// DMA.CH6_CTRL_TRIG: DMA Channel 6 Control and Status
func (o *DMA_Type) SetCH6_CTRL_TRIG_AHB_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH6_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg)&^(0x80000000)|value<<31)
}
func (o *DMA_Type) GetCH6_CTRL_TRIG_AHB_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg) & 0x80000000) >> 31
}
func (o *DMA_Type) SetCH6_CTRL_TRIG_READ_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH6_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg)&^(0x40000000)|value<<30)
}
func (o *DMA_Type) GetCH6_CTRL_TRIG_READ_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg) & 0x40000000) >> 30
}
func (o *DMA_Type) SetCH6_CTRL_TRIG_WRITE_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH6_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg)&^(0x20000000)|value<<29)
}
func (o *DMA_Type) GetCH6_CTRL_TRIG_WRITE_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg) & 0x20000000) >> 29
}
func (o *DMA_Type) SetCH6_CTRL_TRIG_BUSY(value uint32) {
	volatile.StoreUint32(&o.CH6_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetCH6_CTRL_TRIG_BUSY() uint32 {
	return (volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetCH6_CTRL_TRIG_SNIFF_EN(value uint32) {
	volatile.StoreUint32(&o.CH6_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetCH6_CTRL_TRIG_SNIFF_EN() uint32 {
	return (volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetCH6_CTRL_TRIG_BSWAP(value uint32) {
	volatile.StoreUint32(&o.CH6_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetCH6_CTRL_TRIG_BSWAP() uint32 {
	return (volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetCH6_CTRL_TRIG_IRQ_QUIET(value uint32) {
	volatile.StoreUint32(&o.CH6_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetCH6_CTRL_TRIG_IRQ_QUIET() uint32 {
	return (volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetCH6_CTRL_TRIG_TREQ_SEL(value uint32) {
	volatile.StoreUint32(&o.CH6_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg)&^(0x1f8000)|value<<15)
}
func (o *DMA_Type) GetCH6_CTRL_TRIG_TREQ_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg) & 0x1f8000) >> 15
}
func (o *DMA_Type) SetCH6_CTRL_TRIG_CHAIN_TO(value uint32) {
	volatile.StoreUint32(&o.CH6_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg)&^(0x7800)|value<<11)
}
func (o *DMA_Type) GetCH6_CTRL_TRIG_CHAIN_TO() uint32 {
	return (volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg) & 0x7800) >> 11
}
func (o *DMA_Type) SetCH6_CTRL_TRIG_RING_SEL(value uint32) {
	volatile.StoreUint32(&o.CH6_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetCH6_CTRL_TRIG_RING_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetCH6_CTRL_TRIG_RING_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH6_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg)&^(0x3c0)|value<<6)
}
func (o *DMA_Type) GetCH6_CTRL_TRIG_RING_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg) & 0x3c0) >> 6
}
func (o *DMA_Type) SetCH6_CTRL_TRIG_INCR_WRITE(value uint32) {
	volatile.StoreUint32(&o.CH6_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCH6_CTRL_TRIG_INCR_WRITE() uint32 {
	return (volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCH6_CTRL_TRIG_INCR_READ(value uint32) {
	volatile.StoreUint32(&o.CH6_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCH6_CTRL_TRIG_INCR_READ() uint32 {
	return (volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCH6_CTRL_TRIG_DATA_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH6_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg)&^(0xc)|value<<2)
}
func (o *DMA_Type) GetCH6_CTRL_TRIG_DATA_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg) & 0xc) >> 2
}
func (o *DMA_Type) SetCH6_CTRL_TRIG_HIGH_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.CH6_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCH6_CTRL_TRIG_HIGH_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCH6_CTRL_TRIG_EN(value uint32) {
	volatile.StoreUint32(&o.CH6_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCH6_CTRL_TRIG_EN() uint32 {
	return volatile.LoadUint32(&o.CH6_CTRL_TRIG.Reg) & 0x1
}

// DMA.CH7_CTRL_TRIG: DMA Channel 7 Control and Status
func (o *DMA_Type) SetCH7_CTRL_TRIG_AHB_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH7_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg)&^(0x80000000)|value<<31)
}
func (o *DMA_Type) GetCH7_CTRL_TRIG_AHB_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg) & 0x80000000) >> 31
}
func (o *DMA_Type) SetCH7_CTRL_TRIG_READ_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH7_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg)&^(0x40000000)|value<<30)
}
func (o *DMA_Type) GetCH7_CTRL_TRIG_READ_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg) & 0x40000000) >> 30
}
func (o *DMA_Type) SetCH7_CTRL_TRIG_WRITE_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH7_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg)&^(0x20000000)|value<<29)
}
func (o *DMA_Type) GetCH7_CTRL_TRIG_WRITE_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg) & 0x20000000) >> 29
}
func (o *DMA_Type) SetCH7_CTRL_TRIG_BUSY(value uint32) {
	volatile.StoreUint32(&o.CH7_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetCH7_CTRL_TRIG_BUSY() uint32 {
	return (volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetCH7_CTRL_TRIG_SNIFF_EN(value uint32) {
	volatile.StoreUint32(&o.CH7_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetCH7_CTRL_TRIG_SNIFF_EN() uint32 {
	return (volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetCH7_CTRL_TRIG_BSWAP(value uint32) {
	volatile.StoreUint32(&o.CH7_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetCH7_CTRL_TRIG_BSWAP() uint32 {
	return (volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetCH7_CTRL_TRIG_IRQ_QUIET(value uint32) {
	volatile.StoreUint32(&o.CH7_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetCH7_CTRL_TRIG_IRQ_QUIET() uint32 {
	return (volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetCH7_CTRL_TRIG_TREQ_SEL(value uint32) {
	volatile.StoreUint32(&o.CH7_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg)&^(0x1f8000)|value<<15)
}
func (o *DMA_Type) GetCH7_CTRL_TRIG_TREQ_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg) & 0x1f8000) >> 15
}
func (o *DMA_Type) SetCH7_CTRL_TRIG_CHAIN_TO(value uint32) {
	volatile.StoreUint32(&o.CH7_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg)&^(0x7800)|value<<11)
}
func (o *DMA_Type) GetCH7_CTRL_TRIG_CHAIN_TO() uint32 {
	return (volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg) & 0x7800) >> 11
}
func (o *DMA_Type) SetCH7_CTRL_TRIG_RING_SEL(value uint32) {
	volatile.StoreUint32(&o.CH7_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetCH7_CTRL_TRIG_RING_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetCH7_CTRL_TRIG_RING_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH7_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg)&^(0x3c0)|value<<6)
}
func (o *DMA_Type) GetCH7_CTRL_TRIG_RING_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg) & 0x3c0) >> 6
}
func (o *DMA_Type) SetCH7_CTRL_TRIG_INCR_WRITE(value uint32) {
	volatile.StoreUint32(&o.CH7_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCH7_CTRL_TRIG_INCR_WRITE() uint32 {
	return (volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCH7_CTRL_TRIG_INCR_READ(value uint32) {
	volatile.StoreUint32(&o.CH7_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCH7_CTRL_TRIG_INCR_READ() uint32 {
	return (volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCH7_CTRL_TRIG_DATA_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH7_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg)&^(0xc)|value<<2)
}
func (o *DMA_Type) GetCH7_CTRL_TRIG_DATA_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg) & 0xc) >> 2
}
func (o *DMA_Type) SetCH7_CTRL_TRIG_HIGH_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.CH7_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCH7_CTRL_TRIG_HIGH_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCH7_CTRL_TRIG_EN(value uint32) {
	volatile.StoreUint32(&o.CH7_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCH7_CTRL_TRIG_EN() uint32 {
	return volatile.LoadUint32(&o.CH7_CTRL_TRIG.Reg) & 0x1
}

// DMA.CH8_CTRL_TRIG: DMA Channel 8 Control and Status
func (o *DMA_Type) SetCH8_CTRL_TRIG_AHB_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH8_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg)&^(0x80000000)|value<<31)
}
func (o *DMA_Type) GetCH8_CTRL_TRIG_AHB_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg) & 0x80000000) >> 31
}
func (o *DMA_Type) SetCH8_CTRL_TRIG_READ_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH8_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg)&^(0x40000000)|value<<30)
}
func (o *DMA_Type) GetCH8_CTRL_TRIG_READ_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg) & 0x40000000) >> 30
}
func (o *DMA_Type) SetCH8_CTRL_TRIG_WRITE_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH8_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg)&^(0x20000000)|value<<29)
}
func (o *DMA_Type) GetCH8_CTRL_TRIG_WRITE_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg) & 0x20000000) >> 29
}
func (o *DMA_Type) SetCH8_CTRL_TRIG_BUSY(value uint32) {
	volatile.StoreUint32(&o.CH8_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetCH8_CTRL_TRIG_BUSY() uint32 {
	return (volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetCH8_CTRL_TRIG_SNIFF_EN(value uint32) {
	volatile.StoreUint32(&o.CH8_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetCH8_CTRL_TRIG_SNIFF_EN() uint32 {
	return (volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetCH8_CTRL_TRIG_BSWAP(value uint32) {
	volatile.StoreUint32(&o.CH8_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetCH8_CTRL_TRIG_BSWAP() uint32 {
	return (volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetCH8_CTRL_TRIG_IRQ_QUIET(value uint32) {
	volatile.StoreUint32(&o.CH8_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetCH8_CTRL_TRIG_IRQ_QUIET() uint32 {
	return (volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetCH8_CTRL_TRIG_TREQ_SEL(value uint32) {
	volatile.StoreUint32(&o.CH8_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg)&^(0x1f8000)|value<<15)
}
func (o *DMA_Type) GetCH8_CTRL_TRIG_TREQ_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg) & 0x1f8000) >> 15
}
func (o *DMA_Type) SetCH8_CTRL_TRIG_CHAIN_TO(value uint32) {
	volatile.StoreUint32(&o.CH8_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg)&^(0x7800)|value<<11)
}
func (o *DMA_Type) GetCH8_CTRL_TRIG_CHAIN_TO() uint32 {
	return (volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg) & 0x7800) >> 11
}
func (o *DMA_Type) SetCH8_CTRL_TRIG_RING_SEL(value uint32) {
	volatile.StoreUint32(&o.CH8_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetCH8_CTRL_TRIG_RING_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetCH8_CTRL_TRIG_RING_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH8_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg)&^(0x3c0)|value<<6)
}
func (o *DMA_Type) GetCH8_CTRL_TRIG_RING_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg) & 0x3c0) >> 6
}
func (o *DMA_Type) SetCH8_CTRL_TRIG_INCR_WRITE(value uint32) {
	volatile.StoreUint32(&o.CH8_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCH8_CTRL_TRIG_INCR_WRITE() uint32 {
	return (volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCH8_CTRL_TRIG_INCR_READ(value uint32) {
	volatile.StoreUint32(&o.CH8_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCH8_CTRL_TRIG_INCR_READ() uint32 {
	return (volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCH8_CTRL_TRIG_DATA_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH8_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg)&^(0xc)|value<<2)
}
func (o *DMA_Type) GetCH8_CTRL_TRIG_DATA_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg) & 0xc) >> 2
}
func (o *DMA_Type) SetCH8_CTRL_TRIG_HIGH_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.CH8_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCH8_CTRL_TRIG_HIGH_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCH8_CTRL_TRIG_EN(value uint32) {
	volatile.StoreUint32(&o.CH8_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCH8_CTRL_TRIG_EN() uint32 {
	return volatile.LoadUint32(&o.CH8_CTRL_TRIG.Reg) & 0x1
}

// DMA.CH9_CTRL_TRIG: DMA Channel 9 Control and Status
func (o *DMA_Type) SetCH9_CTRL_TRIG_AHB_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH9_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg)&^(0x80000000)|value<<31)
}
func (o *DMA_Type) GetCH9_CTRL_TRIG_AHB_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg) & 0x80000000) >> 31
}
func (o *DMA_Type) SetCH9_CTRL_TRIG_READ_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH9_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg)&^(0x40000000)|value<<30)
}
func (o *DMA_Type) GetCH9_CTRL_TRIG_READ_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg) & 0x40000000) >> 30
}
func (o *DMA_Type) SetCH9_CTRL_TRIG_WRITE_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH9_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg)&^(0x20000000)|value<<29)
}
func (o *DMA_Type) GetCH9_CTRL_TRIG_WRITE_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg) & 0x20000000) >> 29
}
func (o *DMA_Type) SetCH9_CTRL_TRIG_BUSY(value uint32) {
	volatile.StoreUint32(&o.CH9_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetCH9_CTRL_TRIG_BUSY() uint32 {
	return (volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetCH9_CTRL_TRIG_SNIFF_EN(value uint32) {
	volatile.StoreUint32(&o.CH9_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetCH9_CTRL_TRIG_SNIFF_EN() uint32 {
	return (volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetCH9_CTRL_TRIG_BSWAP(value uint32) {
	volatile.StoreUint32(&o.CH9_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetCH9_CTRL_TRIG_BSWAP() uint32 {
	return (volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetCH9_CTRL_TRIG_IRQ_QUIET(value uint32) {
	volatile.StoreUint32(&o.CH9_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetCH9_CTRL_TRIG_IRQ_QUIET() uint32 {
	return (volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetCH9_CTRL_TRIG_TREQ_SEL(value uint32) {
	volatile.StoreUint32(&o.CH9_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg)&^(0x1f8000)|value<<15)
}
func (o *DMA_Type) GetCH9_CTRL_TRIG_TREQ_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg) & 0x1f8000) >> 15
}
func (o *DMA_Type) SetCH9_CTRL_TRIG_CHAIN_TO(value uint32) {
	volatile.StoreUint32(&o.CH9_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg)&^(0x7800)|value<<11)
}
func (o *DMA_Type) GetCH9_CTRL_TRIG_CHAIN_TO() uint32 {
	return (volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg) & 0x7800) >> 11
}
func (o *DMA_Type) SetCH9_CTRL_TRIG_RING_SEL(value uint32) {
	volatile.StoreUint32(&o.CH9_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetCH9_CTRL_TRIG_RING_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetCH9_CTRL_TRIG_RING_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH9_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg)&^(0x3c0)|value<<6)
}
func (o *DMA_Type) GetCH9_CTRL_TRIG_RING_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg) & 0x3c0) >> 6
}
func (o *DMA_Type) SetCH9_CTRL_TRIG_INCR_WRITE(value uint32) {
	volatile.StoreUint32(&o.CH9_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCH9_CTRL_TRIG_INCR_WRITE() uint32 {
	return (volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCH9_CTRL_TRIG_INCR_READ(value uint32) {
	volatile.StoreUint32(&o.CH9_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCH9_CTRL_TRIG_INCR_READ() uint32 {
	return (volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCH9_CTRL_TRIG_DATA_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH9_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg)&^(0xc)|value<<2)
}
func (o *DMA_Type) GetCH9_CTRL_TRIG_DATA_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg) & 0xc) >> 2
}
func (o *DMA_Type) SetCH9_CTRL_TRIG_HIGH_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.CH9_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCH9_CTRL_TRIG_HIGH_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCH9_CTRL_TRIG_EN(value uint32) {
	volatile.StoreUint32(&o.CH9_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCH9_CTRL_TRIG_EN() uint32 {
	return volatile.LoadUint32(&o.CH9_CTRL_TRIG.Reg) & 0x1
}

// DMA.CH10_CTRL_TRIG: DMA Channel 10 Control and Status
func (o *DMA_Type) SetCH10_CTRL_TRIG_AHB_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH10_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg)&^(0x80000000)|value<<31)
}
func (o *DMA_Type) GetCH10_CTRL_TRIG_AHB_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg) & 0x80000000) >> 31
}
func (o *DMA_Type) SetCH10_CTRL_TRIG_READ_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH10_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg)&^(0x40000000)|value<<30)
}
func (o *DMA_Type) GetCH10_CTRL_TRIG_READ_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg) & 0x40000000) >> 30
}
func (o *DMA_Type) SetCH10_CTRL_TRIG_WRITE_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH10_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg)&^(0x20000000)|value<<29)
}
func (o *DMA_Type) GetCH10_CTRL_TRIG_WRITE_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg) & 0x20000000) >> 29
}
func (o *DMA_Type) SetCH10_CTRL_TRIG_BUSY(value uint32) {
	volatile.StoreUint32(&o.CH10_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetCH10_CTRL_TRIG_BUSY() uint32 {
	return (volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetCH10_CTRL_TRIG_SNIFF_EN(value uint32) {
	volatile.StoreUint32(&o.CH10_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetCH10_CTRL_TRIG_SNIFF_EN() uint32 {
	return (volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetCH10_CTRL_TRIG_BSWAP(value uint32) {
	volatile.StoreUint32(&o.CH10_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetCH10_CTRL_TRIG_BSWAP() uint32 {
	return (volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetCH10_CTRL_TRIG_IRQ_QUIET(value uint32) {
	volatile.StoreUint32(&o.CH10_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetCH10_CTRL_TRIG_IRQ_QUIET() uint32 {
	return (volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetCH10_CTRL_TRIG_TREQ_SEL(value uint32) {
	volatile.StoreUint32(&o.CH10_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg)&^(0x1f8000)|value<<15)
}
func (o *DMA_Type) GetCH10_CTRL_TRIG_TREQ_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg) & 0x1f8000) >> 15
}
func (o *DMA_Type) SetCH10_CTRL_TRIG_CHAIN_TO(value uint32) {
	volatile.StoreUint32(&o.CH10_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg)&^(0x7800)|value<<11)
}
func (o *DMA_Type) GetCH10_CTRL_TRIG_CHAIN_TO() uint32 {
	return (volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg) & 0x7800) >> 11
}
func (o *DMA_Type) SetCH10_CTRL_TRIG_RING_SEL(value uint32) {
	volatile.StoreUint32(&o.CH10_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetCH10_CTRL_TRIG_RING_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetCH10_CTRL_TRIG_RING_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH10_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg)&^(0x3c0)|value<<6)
}
func (o *DMA_Type) GetCH10_CTRL_TRIG_RING_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg) & 0x3c0) >> 6
}
func (o *DMA_Type) SetCH10_CTRL_TRIG_INCR_WRITE(value uint32) {
	volatile.StoreUint32(&o.CH10_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCH10_CTRL_TRIG_INCR_WRITE() uint32 {
	return (volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCH10_CTRL_TRIG_INCR_READ(value uint32) {
	volatile.StoreUint32(&o.CH10_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCH10_CTRL_TRIG_INCR_READ() uint32 {
	return (volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCH10_CTRL_TRIG_DATA_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH10_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg)&^(0xc)|value<<2)
}
func (o *DMA_Type) GetCH10_CTRL_TRIG_DATA_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg) & 0xc) >> 2
}
func (o *DMA_Type) SetCH10_CTRL_TRIG_HIGH_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.CH10_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCH10_CTRL_TRIG_HIGH_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCH10_CTRL_TRIG_EN(value uint32) {
	volatile.StoreUint32(&o.CH10_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCH10_CTRL_TRIG_EN() uint32 {
	return volatile.LoadUint32(&o.CH10_CTRL_TRIG.Reg) & 0x1
}

// DMA.CH11_CTRL_TRIG: DMA Channel 11 Control and Status
func (o *DMA_Type) SetCH11_CTRL_TRIG_AHB_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH11_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg)&^(0x80000000)|value<<31)
}
func (o *DMA_Type) GetCH11_CTRL_TRIG_AHB_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg) & 0x80000000) >> 31
}
func (o *DMA_Type) SetCH11_CTRL_TRIG_READ_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH11_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg)&^(0x40000000)|value<<30)
}
func (o *DMA_Type) GetCH11_CTRL_TRIG_READ_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg) & 0x40000000) >> 30
}
func (o *DMA_Type) SetCH11_CTRL_TRIG_WRITE_ERROR(value uint32) {
	volatile.StoreUint32(&o.CH11_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg)&^(0x20000000)|value<<29)
}
func (o *DMA_Type) GetCH11_CTRL_TRIG_WRITE_ERROR() uint32 {
	return (volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg) & 0x20000000) >> 29
}
func (o *DMA_Type) SetCH11_CTRL_TRIG_BUSY(value uint32) {
	volatile.StoreUint32(&o.CH11_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetCH11_CTRL_TRIG_BUSY() uint32 {
	return (volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetCH11_CTRL_TRIG_SNIFF_EN(value uint32) {
	volatile.StoreUint32(&o.CH11_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg)&^(0x800000)|value<<23)
}
func (o *DMA_Type) GetCH11_CTRL_TRIG_SNIFF_EN() uint32 {
	return (volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg) & 0x800000) >> 23
}
func (o *DMA_Type) SetCH11_CTRL_TRIG_BSWAP(value uint32) {
	volatile.StoreUint32(&o.CH11_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetCH11_CTRL_TRIG_BSWAP() uint32 {
	return (volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetCH11_CTRL_TRIG_IRQ_QUIET(value uint32) {
	volatile.StoreUint32(&o.CH11_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetCH11_CTRL_TRIG_IRQ_QUIET() uint32 {
	return (volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetCH11_CTRL_TRIG_TREQ_SEL(value uint32) {
	volatile.StoreUint32(&o.CH11_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg)&^(0x1f8000)|value<<15)
}
func (o *DMA_Type) GetCH11_CTRL_TRIG_TREQ_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg) & 0x1f8000) >> 15
}
func (o *DMA_Type) SetCH11_CTRL_TRIG_CHAIN_TO(value uint32) {
	volatile.StoreUint32(&o.CH11_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg)&^(0x7800)|value<<11)
}
func (o *DMA_Type) GetCH11_CTRL_TRIG_CHAIN_TO() uint32 {
	return (volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg) & 0x7800) >> 11
}
func (o *DMA_Type) SetCH11_CTRL_TRIG_RING_SEL(value uint32) {
	volatile.StoreUint32(&o.CH11_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetCH11_CTRL_TRIG_RING_SEL() uint32 {
	return (volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetCH11_CTRL_TRIG_RING_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH11_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg)&^(0x3c0)|value<<6)
}
func (o *DMA_Type) GetCH11_CTRL_TRIG_RING_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg) & 0x3c0) >> 6
}
func (o *DMA_Type) SetCH11_CTRL_TRIG_INCR_WRITE(value uint32) {
	volatile.StoreUint32(&o.CH11_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCH11_CTRL_TRIG_INCR_WRITE() uint32 {
	return (volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCH11_CTRL_TRIG_INCR_READ(value uint32) {
	volatile.StoreUint32(&o.CH11_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCH11_CTRL_TRIG_INCR_READ() uint32 {
	return (volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCH11_CTRL_TRIG_DATA_SIZE(value uint32) {
	volatile.StoreUint32(&o.CH11_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg)&^(0xc)|value<<2)
}
func (o *DMA_Type) GetCH11_CTRL_TRIG_DATA_SIZE() uint32 {
	return (volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg) & 0xc) >> 2
}
func (o *DMA_Type) SetCH11_CTRL_TRIG_HIGH_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.CH11_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCH11_CTRL_TRIG_HIGH_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCH11_CTRL_TRIG_EN(value uint32) {
	volatile.StoreUint32(&o.CH11_CTRL_TRIG.Reg, volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetCH11_CTRL_TRIG_EN() uint32 {
	return volatile.LoadUint32(&o.CH11_CTRL_TRIG.Reg) & 0x1
}

// DMA.INTR: Interrupt Status (raw)
func (o *DMA_Type) SetINTR(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0xffff)|value)
}
func (o *DMA_Type) GetINTR() uint32 {
	return volatile.LoadUint32(&o.INTR.Reg) & 0xffff
}

// DMA.INTE0: Interrupt Enables for IRQ 0
func (o *DMA_Type) SetINTE0(value uint32) {
	volatile.StoreUint32(&o.INTE0.Reg, volatile.LoadUint32(&o.INTE0.Reg)&^(0xffff)|value)
}
func (o *DMA_Type) GetINTE0() uint32 {
	return volatile.LoadUint32(&o.INTE0.Reg) & 0xffff
}

// DMA.INTF0: Force Interrupts
func (o *DMA_Type) SetINTF0(value uint32) {
	volatile.StoreUint32(&o.INTF0.Reg, volatile.LoadUint32(&o.INTF0.Reg)&^(0xffff)|value)
}
func (o *DMA_Type) GetINTF0() uint32 {
	return volatile.LoadUint32(&o.INTF0.Reg) & 0xffff
}

// DMA.INTS0: Interrupt Status for IRQ 0
func (o *DMA_Type) SetINTS0(value uint32) {
	volatile.StoreUint32(&o.INTS0.Reg, volatile.LoadUint32(&o.INTS0.Reg)&^(0xffff)|value)
}
func (o *DMA_Type) GetINTS0() uint32 {
	return volatile.LoadUint32(&o.INTS0.Reg) & 0xffff
}

// DMA.INTE1: Interrupt Enables for IRQ 1
func (o *DMA_Type) SetINTE1(value uint32) {
	volatile.StoreUint32(&o.INTE1.Reg, volatile.LoadUint32(&o.INTE1.Reg)&^(0xffff)|value)
}
func (o *DMA_Type) GetINTE1() uint32 {
	return volatile.LoadUint32(&o.INTE1.Reg) & 0xffff
}

// DMA.INTF1: Force Interrupts for IRQ 1
func (o *DMA_Type) SetINTF1(value uint32) {
	volatile.StoreUint32(&o.INTF1.Reg, volatile.LoadUint32(&o.INTF1.Reg)&^(0xffff)|value)
}
func (o *DMA_Type) GetINTF1() uint32 {
	return volatile.LoadUint32(&o.INTF1.Reg) & 0xffff
}

// DMA.INTS1: Interrupt Status (masked) for IRQ 1
func (o *DMA_Type) SetINTS1(value uint32) {
	volatile.StoreUint32(&o.INTS1.Reg, volatile.LoadUint32(&o.INTS1.Reg)&^(0xffff)|value)
}
func (o *DMA_Type) GetINTS1() uint32 {
	return volatile.LoadUint32(&o.INTS1.Reg) & 0xffff
}

// DMA.TIMER0
// Pacing (X/Y) Fractional Timer
// The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
func (o *DMA_Type) SetTIMER0_X(value uint32) {
	volatile.StoreUint32(&o.TIMER0.Reg, volatile.LoadUint32(&o.TIMER0.Reg)&^(0xffff0000)|value<<16)
}
func (o *DMA_Type) GetTIMER0_X() uint32 {
	return (volatile.LoadUint32(&o.TIMER0.Reg) & 0xffff0000) >> 16
}
func (o *DMA_Type) SetTIMER0_Y(value uint32) {
	volatile.StoreUint32(&o.TIMER0.Reg, volatile.LoadUint32(&o.TIMER0.Reg)&^(0xffff)|value)
}
func (o *DMA_Type) GetTIMER0_Y() uint32 {
	return volatile.LoadUint32(&o.TIMER0.Reg) & 0xffff
}

// DMA.TIMER1
// Pacing (X/Y) Fractional Timer
// The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
func (o *DMA_Type) SetTIMER1_X(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0xffff0000)|value<<16)
}
func (o *DMA_Type) GetTIMER1_X() uint32 {
	return (volatile.LoadUint32(&o.TIMER1.Reg) & 0xffff0000) >> 16
}
func (o *DMA_Type) SetTIMER1_Y(value uint32) {
	volatile.StoreUint32(&o.TIMER1.Reg, volatile.LoadUint32(&o.TIMER1.Reg)&^(0xffff)|value)
}
func (o *DMA_Type) GetTIMER1_Y() uint32 {
	return volatile.LoadUint32(&o.TIMER1.Reg) & 0xffff
}

// DMA.MULTI_CHAN_TRIGGER: Trigger one or more channels simultaneously
func (o *DMA_Type) SetMULTI_CHAN_TRIGGER(value uint32) {
	volatile.StoreUint32(&o.MULTI_CHAN_TRIGGER.Reg, volatile.LoadUint32(&o.MULTI_CHAN_TRIGGER.Reg)&^(0xffff)|value)
}
func (o *DMA_Type) GetMULTI_CHAN_TRIGGER() uint32 {
	return volatile.LoadUint32(&o.MULTI_CHAN_TRIGGER.Reg) & 0xffff
}

// DMA.SNIFF_CTRL: Sniffer Control
func (o *DMA_Type) SetSNIFF_CTRL_OUT_INV(value uint32) {
	volatile.StoreUint32(&o.SNIFF_CTRL.Reg, volatile.LoadUint32(&o.SNIFF_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetSNIFF_CTRL_OUT_INV() uint32 {
	return (volatile.LoadUint32(&o.SNIFF_CTRL.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetSNIFF_CTRL_OUT_REV(value uint32) {
	volatile.StoreUint32(&o.SNIFF_CTRL.Reg, volatile.LoadUint32(&o.SNIFF_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetSNIFF_CTRL_OUT_REV() uint32 {
	return (volatile.LoadUint32(&o.SNIFF_CTRL.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetSNIFF_CTRL_BSWAP(value uint32) {
	volatile.StoreUint32(&o.SNIFF_CTRL.Reg, volatile.LoadUint32(&o.SNIFF_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetSNIFF_CTRL_BSWAP() uint32 {
	return (volatile.LoadUint32(&o.SNIFF_CTRL.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetSNIFF_CTRL_CALC(value uint32) {
	volatile.StoreUint32(&o.SNIFF_CTRL.Reg, volatile.LoadUint32(&o.SNIFF_CTRL.Reg)&^(0x1e0)|value<<5)
}
func (o *DMA_Type) GetSNIFF_CTRL_CALC() uint32 {
	return (volatile.LoadUint32(&o.SNIFF_CTRL.Reg) & 0x1e0) >> 5
}
func (o *DMA_Type) SetSNIFF_CTRL_DMACH(value uint32) {
	volatile.StoreUint32(&o.SNIFF_CTRL.Reg, volatile.LoadUint32(&o.SNIFF_CTRL.Reg)&^(0x1e)|value<<1)
}
func (o *DMA_Type) GetSNIFF_CTRL_DMACH() uint32 {
	return (volatile.LoadUint32(&o.SNIFF_CTRL.Reg) & 0x1e) >> 1
}
func (o *DMA_Type) SetSNIFF_CTRL_EN(value uint32) {
	volatile.StoreUint32(&o.SNIFF_CTRL.Reg, volatile.LoadUint32(&o.SNIFF_CTRL.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetSNIFF_CTRL_EN() uint32 {
	return volatile.LoadUint32(&o.SNIFF_CTRL.Reg) & 0x1
}

// DMA.FIFO_LEVELS: Debug RAF, WAF, TDF levels
func (o *DMA_Type) SetFIFO_LEVELS_RAF_LVL(value uint32) {
	volatile.StoreUint32(&o.FIFO_LEVELS.Reg, volatile.LoadUint32(&o.FIFO_LEVELS.Reg)&^(0xff0000)|value<<16)
}
func (o *DMA_Type) GetFIFO_LEVELS_RAF_LVL() uint32 {
	return (volatile.LoadUint32(&o.FIFO_LEVELS.Reg) & 0xff0000) >> 16
}
func (o *DMA_Type) SetFIFO_LEVELS_WAF_LVL(value uint32) {
	volatile.StoreUint32(&o.FIFO_LEVELS.Reg, volatile.LoadUint32(&o.FIFO_LEVELS.Reg)&^(0xff00)|value<<8)
}
func (o *DMA_Type) GetFIFO_LEVELS_WAF_LVL() uint32 {
	return (volatile.LoadUint32(&o.FIFO_LEVELS.Reg) & 0xff00) >> 8
}
func (o *DMA_Type) SetFIFO_LEVELS_TDF_LVL(value uint32) {
	volatile.StoreUint32(&o.FIFO_LEVELS.Reg, volatile.LoadUint32(&o.FIFO_LEVELS.Reg)&^(0xff)|value)
}
func (o *DMA_Type) GetFIFO_LEVELS_TDF_LVL() uint32 {
	return volatile.LoadUint32(&o.FIFO_LEVELS.Reg) & 0xff
}

// DMA.CHAN_ABORT: Abort an in-progress transfer sequence on one or more channels
func (o *DMA_Type) SetCHAN_ABORT(value uint32) {
	volatile.StoreUint32(&o.CHAN_ABORT.Reg, volatile.LoadUint32(&o.CHAN_ABORT.Reg)&^(0xffff)|value)
}
func (o *DMA_Type) GetCHAN_ABORT() uint32 {
	return volatile.LoadUint32(&o.CHAN_ABORT.Reg) & 0xffff
}

// DMA.N_CHANNELS: The number of channels this DMA instance is equipped with. This DMA supports up to 16 hardware channels, but can be configured with as few as one, to minimise silicon area.
func (o *DMA_Type) SetN_CHANNELS(value uint32) {
	volatile.StoreUint32(&o.N_CHANNELS.Reg, volatile.LoadUint32(&o.N_CHANNELS.Reg)&^(0x1f)|value)
}
func (o *DMA_Type) GetN_CHANNELS() uint32 {
	return volatile.LoadUint32(&o.N_CHANNELS.Reg) & 0x1f
}

// DMA.CH0_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
func (o *DMA_Type) SetCH0_DBG_CTDREQ(value uint32) {
	volatile.StoreUint32(&o.CH0_DBG_CTDREQ.Reg, volatile.LoadUint32(&o.CH0_DBG_CTDREQ.Reg)&^(0x3f)|value)
}
func (o *DMA_Type) GetCH0_DBG_CTDREQ() uint32 {
	return volatile.LoadUint32(&o.CH0_DBG_CTDREQ.Reg) & 0x3f
}

// DMA.CH1_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
func (o *DMA_Type) SetCH1_DBG_CTDREQ(value uint32) {
	volatile.StoreUint32(&o.CH1_DBG_CTDREQ.Reg, volatile.LoadUint32(&o.CH1_DBG_CTDREQ.Reg)&^(0x3f)|value)
}
func (o *DMA_Type) GetCH1_DBG_CTDREQ() uint32 {
	return volatile.LoadUint32(&o.CH1_DBG_CTDREQ.Reg) & 0x3f
}

// DMA.CH2_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
func (o *DMA_Type) SetCH2_DBG_CTDREQ(value uint32) {
	volatile.StoreUint32(&o.CH2_DBG_CTDREQ.Reg, volatile.LoadUint32(&o.CH2_DBG_CTDREQ.Reg)&^(0x3f)|value)
}
func (o *DMA_Type) GetCH2_DBG_CTDREQ() uint32 {
	return volatile.LoadUint32(&o.CH2_DBG_CTDREQ.Reg) & 0x3f
}

// DMA.CH3_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
func (o *DMA_Type) SetCH3_DBG_CTDREQ(value uint32) {
	volatile.StoreUint32(&o.CH3_DBG_CTDREQ.Reg, volatile.LoadUint32(&o.CH3_DBG_CTDREQ.Reg)&^(0x3f)|value)
}
func (o *DMA_Type) GetCH3_DBG_CTDREQ() uint32 {
	return volatile.LoadUint32(&o.CH3_DBG_CTDREQ.Reg) & 0x3f
}

// DMA.CH4_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
func (o *DMA_Type) SetCH4_DBG_CTDREQ(value uint32) {
	volatile.StoreUint32(&o.CH4_DBG_CTDREQ.Reg, volatile.LoadUint32(&o.CH4_DBG_CTDREQ.Reg)&^(0x3f)|value)
}
func (o *DMA_Type) GetCH4_DBG_CTDREQ() uint32 {
	return volatile.LoadUint32(&o.CH4_DBG_CTDREQ.Reg) & 0x3f
}

// DMA.CH5_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
func (o *DMA_Type) SetCH5_DBG_CTDREQ(value uint32) {
	volatile.StoreUint32(&o.CH5_DBG_CTDREQ.Reg, volatile.LoadUint32(&o.CH5_DBG_CTDREQ.Reg)&^(0x3f)|value)
}
func (o *DMA_Type) GetCH5_DBG_CTDREQ() uint32 {
	return volatile.LoadUint32(&o.CH5_DBG_CTDREQ.Reg) & 0x3f
}

// DMA.CH6_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
func (o *DMA_Type) SetCH6_DBG_CTDREQ(value uint32) {
	volatile.StoreUint32(&o.CH6_DBG_CTDREQ.Reg, volatile.LoadUint32(&o.CH6_DBG_CTDREQ.Reg)&^(0x3f)|value)
}
func (o *DMA_Type) GetCH6_DBG_CTDREQ() uint32 {
	return volatile.LoadUint32(&o.CH6_DBG_CTDREQ.Reg) & 0x3f
}

// DMA.CH7_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
func (o *DMA_Type) SetCH7_DBG_CTDREQ(value uint32) {
	volatile.StoreUint32(&o.CH7_DBG_CTDREQ.Reg, volatile.LoadUint32(&o.CH7_DBG_CTDREQ.Reg)&^(0x3f)|value)
}
func (o *DMA_Type) GetCH7_DBG_CTDREQ() uint32 {
	return volatile.LoadUint32(&o.CH7_DBG_CTDREQ.Reg) & 0x3f
}

// DMA.CH8_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
func (o *DMA_Type) SetCH8_DBG_CTDREQ(value uint32) {
	volatile.StoreUint32(&o.CH8_DBG_CTDREQ.Reg, volatile.LoadUint32(&o.CH8_DBG_CTDREQ.Reg)&^(0x3f)|value)
}
func (o *DMA_Type) GetCH8_DBG_CTDREQ() uint32 {
	return volatile.LoadUint32(&o.CH8_DBG_CTDREQ.Reg) & 0x3f
}

// DMA.CH9_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
func (o *DMA_Type) SetCH9_DBG_CTDREQ(value uint32) {
	volatile.StoreUint32(&o.CH9_DBG_CTDREQ.Reg, volatile.LoadUint32(&o.CH9_DBG_CTDREQ.Reg)&^(0x3f)|value)
}
func (o *DMA_Type) GetCH9_DBG_CTDREQ() uint32 {
	return volatile.LoadUint32(&o.CH9_DBG_CTDREQ.Reg) & 0x3f
}

// DMA.CH10_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
func (o *DMA_Type) SetCH10_DBG_CTDREQ(value uint32) {
	volatile.StoreUint32(&o.CH10_DBG_CTDREQ.Reg, volatile.LoadUint32(&o.CH10_DBG_CTDREQ.Reg)&^(0x3f)|value)
}
func (o *DMA_Type) GetCH10_DBG_CTDREQ() uint32 {
	return volatile.LoadUint32(&o.CH10_DBG_CTDREQ.Reg) & 0x3f
}

// DMA.CH11_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
func (o *DMA_Type) SetCH11_DBG_CTDREQ(value uint32) {
	volatile.StoreUint32(&o.CH11_DBG_CTDREQ.Reg, volatile.LoadUint32(&o.CH11_DBG_CTDREQ.Reg)&^(0x3f)|value)
}
func (o *DMA_Type) GetCH11_DBG_CTDREQ() uint32 {
	return volatile.LoadUint32(&o.CH11_DBG_CTDREQ.Reg) & 0x3f
}

// USB FS/LS controller device registers
type USBCTRL_REGS_Type struct {
	ADDR_ENDP              volatile.Register32 // 0x0
	ADDR_ENDP1             volatile.Register32 // 0x4
	ADDR_ENDP2             volatile.Register32 // 0x8
	ADDR_ENDP3             volatile.Register32 // 0xC
	ADDR_ENDP4             volatile.Register32 // 0x10
	ADDR_ENDP5             volatile.Register32 // 0x14
	ADDR_ENDP6             volatile.Register32 // 0x18
	ADDR_ENDP7             volatile.Register32 // 0x1C
	ADDR_ENDP8             volatile.Register32 // 0x20
	ADDR_ENDP9             volatile.Register32 // 0x24
	ADDR_ENDP10            volatile.Register32 // 0x28
	ADDR_ENDP11            volatile.Register32 // 0x2C
	ADDR_ENDP12            volatile.Register32 // 0x30
	ADDR_ENDP13            volatile.Register32 // 0x34
	ADDR_ENDP14            volatile.Register32 // 0x38
	ADDR_ENDP15            volatile.Register32 // 0x3C
	MAIN_CTRL              volatile.Register32 // 0x40
	SOF_WR                 volatile.Register32 // 0x44
	SOF_RD                 volatile.Register32 // 0x48
	SIE_CTRL               volatile.Register32 // 0x4C
	SIE_STATUS             volatile.Register32 // 0x50
	INT_EP_CTRL            volatile.Register32 // 0x54
	BUFF_STATUS            volatile.Register32 // 0x58
	BUFF_CPU_SHOULD_HANDLE volatile.Register32 // 0x5C
	EP_ABORT               volatile.Register32 // 0x60
	EP_ABORT_DONE          volatile.Register32 // 0x64
	EP_STALL_ARM           volatile.Register32 // 0x68
	NAK_POLL               volatile.Register32 // 0x6C
	EP_STATUS_STALL_NAK    volatile.Register32 // 0x70
	USB_MUXING             volatile.Register32 // 0x74
	USB_PWR                volatile.Register32 // 0x78
	USBPHY_DIRECT          volatile.Register32 // 0x7C
	USBPHY_DIRECT_OVERRIDE volatile.Register32 // 0x80
	USBPHY_TRIM            volatile.Register32 // 0x84
	_                      [4]byte
	INTR                   volatile.Register32 // 0x8C
	INTE                   volatile.Register32 // 0x90
	INTF                   volatile.Register32 // 0x94
	INTS                   volatile.Register32 // 0x98
}

// USBCTRL_REGS.ADDR_ENDP: Device address and endpoint control
func (o *USBCTRL_REGS_Type) SetADDR_ENDP_ENDPOINT(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP.Reg, volatile.LoadUint32(&o.ADDR_ENDP.Reg)&^(0xf0000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP_ENDPOINT() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP.Reg) & 0xf0000) >> 16
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP.Reg, volatile.LoadUint32(&o.ADDR_ENDP.Reg)&^(0x7f)|value)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.ADDR_ENDP.Reg) & 0x7f
}

// USBCTRL_REGS.ADDR_ENDP1: Interrupt endpoint 1. Only valid for HOST mode.
func (o *USBCTRL_REGS_Type) SetADDR_ENDP1_INTEP_PREAMBLE(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP1.Reg, volatile.LoadUint32(&o.ADDR_ENDP1.Reg)&^(0x4000000)|value<<26)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP1_INTEP_PREAMBLE() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP1.Reg) & 0x4000000) >> 26
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP1_INTEP_DIR(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP1.Reg, volatile.LoadUint32(&o.ADDR_ENDP1.Reg)&^(0x2000000)|value<<25)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP1_INTEP_DIR() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP1.Reg) & 0x2000000) >> 25
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP1_ENDPOINT(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP1.Reg, volatile.LoadUint32(&o.ADDR_ENDP1.Reg)&^(0xf0000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP1_ENDPOINT() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP1.Reg) & 0xf0000) >> 16
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP1_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP1.Reg, volatile.LoadUint32(&o.ADDR_ENDP1.Reg)&^(0x7f)|value)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP1_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.ADDR_ENDP1.Reg) & 0x7f
}

// USBCTRL_REGS.ADDR_ENDP2: Interrupt endpoint 2. Only valid for HOST mode.
func (o *USBCTRL_REGS_Type) SetADDR_ENDP2_INTEP_PREAMBLE(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP2.Reg, volatile.LoadUint32(&o.ADDR_ENDP2.Reg)&^(0x4000000)|value<<26)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP2_INTEP_PREAMBLE() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP2.Reg) & 0x4000000) >> 26
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP2_INTEP_DIR(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP2.Reg, volatile.LoadUint32(&o.ADDR_ENDP2.Reg)&^(0x2000000)|value<<25)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP2_INTEP_DIR() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP2.Reg) & 0x2000000) >> 25
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP2_ENDPOINT(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP2.Reg, volatile.LoadUint32(&o.ADDR_ENDP2.Reg)&^(0xf0000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP2_ENDPOINT() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP2.Reg) & 0xf0000) >> 16
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP2_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP2.Reg, volatile.LoadUint32(&o.ADDR_ENDP2.Reg)&^(0x7f)|value)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP2_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.ADDR_ENDP2.Reg) & 0x7f
}

// USBCTRL_REGS.ADDR_ENDP3: Interrupt endpoint 3. Only valid for HOST mode.
func (o *USBCTRL_REGS_Type) SetADDR_ENDP3_INTEP_PREAMBLE(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP3.Reg, volatile.LoadUint32(&o.ADDR_ENDP3.Reg)&^(0x4000000)|value<<26)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP3_INTEP_PREAMBLE() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP3.Reg) & 0x4000000) >> 26
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP3_INTEP_DIR(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP3.Reg, volatile.LoadUint32(&o.ADDR_ENDP3.Reg)&^(0x2000000)|value<<25)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP3_INTEP_DIR() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP3.Reg) & 0x2000000) >> 25
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP3_ENDPOINT(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP3.Reg, volatile.LoadUint32(&o.ADDR_ENDP3.Reg)&^(0xf0000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP3_ENDPOINT() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP3.Reg) & 0xf0000) >> 16
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP3_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP3.Reg, volatile.LoadUint32(&o.ADDR_ENDP3.Reg)&^(0x7f)|value)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP3_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.ADDR_ENDP3.Reg) & 0x7f
}

// USBCTRL_REGS.ADDR_ENDP4: Interrupt endpoint 4. Only valid for HOST mode.
func (o *USBCTRL_REGS_Type) SetADDR_ENDP4_INTEP_PREAMBLE(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP4.Reg, volatile.LoadUint32(&o.ADDR_ENDP4.Reg)&^(0x4000000)|value<<26)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP4_INTEP_PREAMBLE() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP4.Reg) & 0x4000000) >> 26
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP4_INTEP_DIR(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP4.Reg, volatile.LoadUint32(&o.ADDR_ENDP4.Reg)&^(0x2000000)|value<<25)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP4_INTEP_DIR() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP4.Reg) & 0x2000000) >> 25
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP4_ENDPOINT(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP4.Reg, volatile.LoadUint32(&o.ADDR_ENDP4.Reg)&^(0xf0000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP4_ENDPOINT() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP4.Reg) & 0xf0000) >> 16
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP4_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP4.Reg, volatile.LoadUint32(&o.ADDR_ENDP4.Reg)&^(0x7f)|value)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP4_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.ADDR_ENDP4.Reg) & 0x7f
}

// USBCTRL_REGS.ADDR_ENDP5: Interrupt endpoint 5. Only valid for HOST mode.
func (o *USBCTRL_REGS_Type) SetADDR_ENDP5_INTEP_PREAMBLE(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP5.Reg, volatile.LoadUint32(&o.ADDR_ENDP5.Reg)&^(0x4000000)|value<<26)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP5_INTEP_PREAMBLE() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP5.Reg) & 0x4000000) >> 26
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP5_INTEP_DIR(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP5.Reg, volatile.LoadUint32(&o.ADDR_ENDP5.Reg)&^(0x2000000)|value<<25)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP5_INTEP_DIR() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP5.Reg) & 0x2000000) >> 25
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP5_ENDPOINT(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP5.Reg, volatile.LoadUint32(&o.ADDR_ENDP5.Reg)&^(0xf0000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP5_ENDPOINT() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP5.Reg) & 0xf0000) >> 16
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP5_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP5.Reg, volatile.LoadUint32(&o.ADDR_ENDP5.Reg)&^(0x7f)|value)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP5_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.ADDR_ENDP5.Reg) & 0x7f
}

// USBCTRL_REGS.ADDR_ENDP6: Interrupt endpoint 6. Only valid for HOST mode.
func (o *USBCTRL_REGS_Type) SetADDR_ENDP6_INTEP_PREAMBLE(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP6.Reg, volatile.LoadUint32(&o.ADDR_ENDP6.Reg)&^(0x4000000)|value<<26)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP6_INTEP_PREAMBLE() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP6.Reg) & 0x4000000) >> 26
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP6_INTEP_DIR(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP6.Reg, volatile.LoadUint32(&o.ADDR_ENDP6.Reg)&^(0x2000000)|value<<25)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP6_INTEP_DIR() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP6.Reg) & 0x2000000) >> 25
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP6_ENDPOINT(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP6.Reg, volatile.LoadUint32(&o.ADDR_ENDP6.Reg)&^(0xf0000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP6_ENDPOINT() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP6.Reg) & 0xf0000) >> 16
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP6_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP6.Reg, volatile.LoadUint32(&o.ADDR_ENDP6.Reg)&^(0x7f)|value)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP6_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.ADDR_ENDP6.Reg) & 0x7f
}

// USBCTRL_REGS.ADDR_ENDP7: Interrupt endpoint 7. Only valid for HOST mode.
func (o *USBCTRL_REGS_Type) SetADDR_ENDP7_INTEP_PREAMBLE(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP7.Reg, volatile.LoadUint32(&o.ADDR_ENDP7.Reg)&^(0x4000000)|value<<26)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP7_INTEP_PREAMBLE() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP7.Reg) & 0x4000000) >> 26
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP7_INTEP_DIR(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP7.Reg, volatile.LoadUint32(&o.ADDR_ENDP7.Reg)&^(0x2000000)|value<<25)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP7_INTEP_DIR() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP7.Reg) & 0x2000000) >> 25
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP7_ENDPOINT(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP7.Reg, volatile.LoadUint32(&o.ADDR_ENDP7.Reg)&^(0xf0000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP7_ENDPOINT() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP7.Reg) & 0xf0000) >> 16
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP7_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP7.Reg, volatile.LoadUint32(&o.ADDR_ENDP7.Reg)&^(0x7f)|value)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP7_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.ADDR_ENDP7.Reg) & 0x7f
}

// USBCTRL_REGS.ADDR_ENDP8: Interrupt endpoint 8. Only valid for HOST mode.
func (o *USBCTRL_REGS_Type) SetADDR_ENDP8_INTEP_PREAMBLE(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP8.Reg, volatile.LoadUint32(&o.ADDR_ENDP8.Reg)&^(0x4000000)|value<<26)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP8_INTEP_PREAMBLE() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP8.Reg) & 0x4000000) >> 26
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP8_INTEP_DIR(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP8.Reg, volatile.LoadUint32(&o.ADDR_ENDP8.Reg)&^(0x2000000)|value<<25)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP8_INTEP_DIR() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP8.Reg) & 0x2000000) >> 25
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP8_ENDPOINT(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP8.Reg, volatile.LoadUint32(&o.ADDR_ENDP8.Reg)&^(0xf0000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP8_ENDPOINT() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP8.Reg) & 0xf0000) >> 16
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP8_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP8.Reg, volatile.LoadUint32(&o.ADDR_ENDP8.Reg)&^(0x7f)|value)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP8_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.ADDR_ENDP8.Reg) & 0x7f
}

// USBCTRL_REGS.ADDR_ENDP9: Interrupt endpoint 9. Only valid for HOST mode.
func (o *USBCTRL_REGS_Type) SetADDR_ENDP9_INTEP_PREAMBLE(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP9.Reg, volatile.LoadUint32(&o.ADDR_ENDP9.Reg)&^(0x4000000)|value<<26)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP9_INTEP_PREAMBLE() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP9.Reg) & 0x4000000) >> 26
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP9_INTEP_DIR(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP9.Reg, volatile.LoadUint32(&o.ADDR_ENDP9.Reg)&^(0x2000000)|value<<25)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP9_INTEP_DIR() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP9.Reg) & 0x2000000) >> 25
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP9_ENDPOINT(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP9.Reg, volatile.LoadUint32(&o.ADDR_ENDP9.Reg)&^(0xf0000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP9_ENDPOINT() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP9.Reg) & 0xf0000) >> 16
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP9_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP9.Reg, volatile.LoadUint32(&o.ADDR_ENDP9.Reg)&^(0x7f)|value)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP9_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.ADDR_ENDP9.Reg) & 0x7f
}

// USBCTRL_REGS.ADDR_ENDP10: Interrupt endpoint 10. Only valid for HOST mode.
func (o *USBCTRL_REGS_Type) SetADDR_ENDP10_INTEP_PREAMBLE(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP10.Reg, volatile.LoadUint32(&o.ADDR_ENDP10.Reg)&^(0x4000000)|value<<26)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP10_INTEP_PREAMBLE() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP10.Reg) & 0x4000000) >> 26
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP10_INTEP_DIR(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP10.Reg, volatile.LoadUint32(&o.ADDR_ENDP10.Reg)&^(0x2000000)|value<<25)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP10_INTEP_DIR() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP10.Reg) & 0x2000000) >> 25
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP10_ENDPOINT(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP10.Reg, volatile.LoadUint32(&o.ADDR_ENDP10.Reg)&^(0xf0000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP10_ENDPOINT() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP10.Reg) & 0xf0000) >> 16
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP10_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP10.Reg, volatile.LoadUint32(&o.ADDR_ENDP10.Reg)&^(0x7f)|value)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP10_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.ADDR_ENDP10.Reg) & 0x7f
}

// USBCTRL_REGS.ADDR_ENDP11: Interrupt endpoint 11. Only valid for HOST mode.
func (o *USBCTRL_REGS_Type) SetADDR_ENDP11_INTEP_PREAMBLE(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP11.Reg, volatile.LoadUint32(&o.ADDR_ENDP11.Reg)&^(0x4000000)|value<<26)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP11_INTEP_PREAMBLE() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP11.Reg) & 0x4000000) >> 26
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP11_INTEP_DIR(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP11.Reg, volatile.LoadUint32(&o.ADDR_ENDP11.Reg)&^(0x2000000)|value<<25)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP11_INTEP_DIR() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP11.Reg) & 0x2000000) >> 25
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP11_ENDPOINT(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP11.Reg, volatile.LoadUint32(&o.ADDR_ENDP11.Reg)&^(0xf0000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP11_ENDPOINT() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP11.Reg) & 0xf0000) >> 16
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP11_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP11.Reg, volatile.LoadUint32(&o.ADDR_ENDP11.Reg)&^(0x7f)|value)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP11_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.ADDR_ENDP11.Reg) & 0x7f
}

// USBCTRL_REGS.ADDR_ENDP12: Interrupt endpoint 12. Only valid for HOST mode.
func (o *USBCTRL_REGS_Type) SetADDR_ENDP12_INTEP_PREAMBLE(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP12.Reg, volatile.LoadUint32(&o.ADDR_ENDP12.Reg)&^(0x4000000)|value<<26)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP12_INTEP_PREAMBLE() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP12.Reg) & 0x4000000) >> 26
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP12_INTEP_DIR(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP12.Reg, volatile.LoadUint32(&o.ADDR_ENDP12.Reg)&^(0x2000000)|value<<25)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP12_INTEP_DIR() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP12.Reg) & 0x2000000) >> 25
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP12_ENDPOINT(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP12.Reg, volatile.LoadUint32(&o.ADDR_ENDP12.Reg)&^(0xf0000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP12_ENDPOINT() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP12.Reg) & 0xf0000) >> 16
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP12_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP12.Reg, volatile.LoadUint32(&o.ADDR_ENDP12.Reg)&^(0x7f)|value)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP12_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.ADDR_ENDP12.Reg) & 0x7f
}

// USBCTRL_REGS.ADDR_ENDP13: Interrupt endpoint 13. Only valid for HOST mode.
func (o *USBCTRL_REGS_Type) SetADDR_ENDP13_INTEP_PREAMBLE(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP13.Reg, volatile.LoadUint32(&o.ADDR_ENDP13.Reg)&^(0x4000000)|value<<26)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP13_INTEP_PREAMBLE() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP13.Reg) & 0x4000000) >> 26
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP13_INTEP_DIR(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP13.Reg, volatile.LoadUint32(&o.ADDR_ENDP13.Reg)&^(0x2000000)|value<<25)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP13_INTEP_DIR() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP13.Reg) & 0x2000000) >> 25
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP13_ENDPOINT(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP13.Reg, volatile.LoadUint32(&o.ADDR_ENDP13.Reg)&^(0xf0000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP13_ENDPOINT() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP13.Reg) & 0xf0000) >> 16
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP13_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP13.Reg, volatile.LoadUint32(&o.ADDR_ENDP13.Reg)&^(0x7f)|value)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP13_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.ADDR_ENDP13.Reg) & 0x7f
}

// USBCTRL_REGS.ADDR_ENDP14: Interrupt endpoint 14. Only valid for HOST mode.
func (o *USBCTRL_REGS_Type) SetADDR_ENDP14_INTEP_PREAMBLE(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP14.Reg, volatile.LoadUint32(&o.ADDR_ENDP14.Reg)&^(0x4000000)|value<<26)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP14_INTEP_PREAMBLE() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP14.Reg) & 0x4000000) >> 26
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP14_INTEP_DIR(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP14.Reg, volatile.LoadUint32(&o.ADDR_ENDP14.Reg)&^(0x2000000)|value<<25)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP14_INTEP_DIR() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP14.Reg) & 0x2000000) >> 25
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP14_ENDPOINT(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP14.Reg, volatile.LoadUint32(&o.ADDR_ENDP14.Reg)&^(0xf0000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP14_ENDPOINT() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP14.Reg) & 0xf0000) >> 16
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP14_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP14.Reg, volatile.LoadUint32(&o.ADDR_ENDP14.Reg)&^(0x7f)|value)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP14_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.ADDR_ENDP14.Reg) & 0x7f
}

// USBCTRL_REGS.ADDR_ENDP15: Interrupt endpoint 15. Only valid for HOST mode.
func (o *USBCTRL_REGS_Type) SetADDR_ENDP15_INTEP_PREAMBLE(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP15.Reg, volatile.LoadUint32(&o.ADDR_ENDP15.Reg)&^(0x4000000)|value<<26)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP15_INTEP_PREAMBLE() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP15.Reg) & 0x4000000) >> 26
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP15_INTEP_DIR(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP15.Reg, volatile.LoadUint32(&o.ADDR_ENDP15.Reg)&^(0x2000000)|value<<25)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP15_INTEP_DIR() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP15.Reg) & 0x2000000) >> 25
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP15_ENDPOINT(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP15.Reg, volatile.LoadUint32(&o.ADDR_ENDP15.Reg)&^(0xf0000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP15_ENDPOINT() uint32 {
	return (volatile.LoadUint32(&o.ADDR_ENDP15.Reg) & 0xf0000) >> 16
}
func (o *USBCTRL_REGS_Type) SetADDR_ENDP15_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.ADDR_ENDP15.Reg, volatile.LoadUint32(&o.ADDR_ENDP15.Reg)&^(0x7f)|value)
}
func (o *USBCTRL_REGS_Type) GetADDR_ENDP15_ADDRESS() uint32 {
	return volatile.LoadUint32(&o.ADDR_ENDP15.Reg) & 0x7f
}

// USBCTRL_REGS.MAIN_CTRL: Main control register
func (o *USBCTRL_REGS_Type) SetMAIN_CTRL_SIM_TIMING(value uint32) {
	volatile.StoreUint32(&o.MAIN_CTRL.Reg, volatile.LoadUint32(&o.MAIN_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *USBCTRL_REGS_Type) GetMAIN_CTRL_SIM_TIMING() uint32 {
	return (volatile.LoadUint32(&o.MAIN_CTRL.Reg) & 0x80000000) >> 31
}
func (o *USBCTRL_REGS_Type) SetMAIN_CTRL_HOST_NDEVICE(value uint32) {
	volatile.StoreUint32(&o.MAIN_CTRL.Reg, volatile.LoadUint32(&o.MAIN_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *USBCTRL_REGS_Type) GetMAIN_CTRL_HOST_NDEVICE() uint32 {
	return (volatile.LoadUint32(&o.MAIN_CTRL.Reg) & 0x2) >> 1
}
func (o *USBCTRL_REGS_Type) SetMAIN_CTRL_CONTROLLER_EN(value uint32) {
	volatile.StoreUint32(&o.MAIN_CTRL.Reg, volatile.LoadUint32(&o.MAIN_CTRL.Reg)&^(0x1)|value)
}
func (o *USBCTRL_REGS_Type) GetMAIN_CTRL_CONTROLLER_EN() uint32 {
	return volatile.LoadUint32(&o.MAIN_CTRL.Reg) & 0x1
}

// USBCTRL_REGS.SOF_WR: Set the SOF (Start of Frame) frame number in the host controller. The SOF packet is sent every 1ms and the host will increment the frame number by 1 each time.
func (o *USBCTRL_REGS_Type) SetSOF_WR_COUNT(value uint32) {
	volatile.StoreUint32(&o.SOF_WR.Reg, volatile.LoadUint32(&o.SOF_WR.Reg)&^(0x7ff)|value)
}
func (o *USBCTRL_REGS_Type) GetSOF_WR_COUNT() uint32 {
	return volatile.LoadUint32(&o.SOF_WR.Reg) & 0x7ff
}

// USBCTRL_REGS.SOF_RD: Read the last SOF (Start of Frame) frame number seen. In device mode the last SOF received from the host. In host mode the last SOF sent by the host.
func (o *USBCTRL_REGS_Type) SetSOF_RD_COUNT(value uint32) {
	volatile.StoreUint32(&o.SOF_RD.Reg, volatile.LoadUint32(&o.SOF_RD.Reg)&^(0x7ff)|value)
}
func (o *USBCTRL_REGS_Type) GetSOF_RD_COUNT() uint32 {
	return volatile.LoadUint32(&o.SOF_RD.Reg) & 0x7ff
}

// USBCTRL_REGS.SIE_CTRL: SIE control register
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_EP0_INT_STALL(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_EP0_INT_STALL() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x80000000) >> 31
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_EP0_DOUBLE_BUF(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_EP0_DOUBLE_BUF() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x40000000) >> 30
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_EP0_INT_1BUF(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_EP0_INT_1BUF() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x20000000) >> 29
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_EP0_INT_2BUF(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_EP0_INT_2BUF() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x10000000) >> 28
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_EP0_INT_NAK(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x8000000)|value<<27)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_EP0_INT_NAK() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x8000000) >> 27
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_DIRECT_EN(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_DIRECT_EN() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x4000000) >> 26
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_DIRECT_DP(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_DIRECT_DP() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x2000000) >> 25
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_DIRECT_DM(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_DIRECT_DM() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x1000000) >> 24
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_TRANSCEIVER_PD(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_TRANSCEIVER_PD() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x40000) >> 18
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_RPU_OPT(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x20000)|value<<17)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_RPU_OPT() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x20000) >> 17
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_PULLUP_EN(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_PULLUP_EN() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x10000) >> 16
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_PULLDOWN_EN(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x8000)|value<<15)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_PULLDOWN_EN() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x8000) >> 15
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_RESET_BUS(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x2000)|value<<13)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_RESET_BUS() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x2000) >> 13
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_RESUME(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_RESUME() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x1000) >> 12
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_VBUS_EN(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_VBUS_EN() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x800) >> 11
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_KEEP_ALIVE_EN(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_KEEP_ALIVE_EN() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x400) >> 10
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_SOF_EN(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_SOF_EN() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x200) >> 9
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_SOF_SYNC(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_SOF_SYNC() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x100) >> 8
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_PREAMBLE_EN(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x40)|value<<6)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_PREAMBLE_EN() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x40) >> 6
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_STOP_TRANS(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_STOP_TRANS() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x10) >> 4
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_RECEIVE_DATA(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_RECEIVE_DATA() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x8) >> 3
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_SEND_DATA(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_SEND_DATA() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x4) >> 2
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_SEND_SETUP(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_SEND_SETUP() uint32 {
	return (volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x2) >> 1
}
func (o *USBCTRL_REGS_Type) SetSIE_CTRL_START_TRANS(value uint32) {
	volatile.StoreUint32(&o.SIE_CTRL.Reg, volatile.LoadUint32(&o.SIE_CTRL.Reg)&^(0x1)|value)
}
func (o *USBCTRL_REGS_Type) GetSIE_CTRL_START_TRANS() uint32 {
	return volatile.LoadUint32(&o.SIE_CTRL.Reg) & 0x1
}

// USBCTRL_REGS.SIE_STATUS: SIE status register
func (o *USBCTRL_REGS_Type) SetSIE_STATUS_DATA_SEQ_ERROR(value uint32) {
	volatile.StoreUint32(&o.SIE_STATUS.Reg, volatile.LoadUint32(&o.SIE_STATUS.Reg)&^(0x80000000)|value<<31)
}
func (o *USBCTRL_REGS_Type) GetSIE_STATUS_DATA_SEQ_ERROR() uint32 {
	return (volatile.LoadUint32(&o.SIE_STATUS.Reg) & 0x80000000) >> 31
}
func (o *USBCTRL_REGS_Type) SetSIE_STATUS_ACK_REC(value uint32) {
	volatile.StoreUint32(&o.SIE_STATUS.Reg, volatile.LoadUint32(&o.SIE_STATUS.Reg)&^(0x40000000)|value<<30)
}
func (o *USBCTRL_REGS_Type) GetSIE_STATUS_ACK_REC() uint32 {
	return (volatile.LoadUint32(&o.SIE_STATUS.Reg) & 0x40000000) >> 30
}
func (o *USBCTRL_REGS_Type) SetSIE_STATUS_STALL_REC(value uint32) {
	volatile.StoreUint32(&o.SIE_STATUS.Reg, volatile.LoadUint32(&o.SIE_STATUS.Reg)&^(0x20000000)|value<<29)
}
func (o *USBCTRL_REGS_Type) GetSIE_STATUS_STALL_REC() uint32 {
	return (volatile.LoadUint32(&o.SIE_STATUS.Reg) & 0x20000000) >> 29
}
func (o *USBCTRL_REGS_Type) SetSIE_STATUS_NAK_REC(value uint32) {
	volatile.StoreUint32(&o.SIE_STATUS.Reg, volatile.LoadUint32(&o.SIE_STATUS.Reg)&^(0x10000000)|value<<28)
}
func (o *USBCTRL_REGS_Type) GetSIE_STATUS_NAK_REC() uint32 {
	return (volatile.LoadUint32(&o.SIE_STATUS.Reg) & 0x10000000) >> 28
}
func (o *USBCTRL_REGS_Type) SetSIE_STATUS_RX_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.SIE_STATUS.Reg, volatile.LoadUint32(&o.SIE_STATUS.Reg)&^(0x8000000)|value<<27)
}
func (o *USBCTRL_REGS_Type) GetSIE_STATUS_RX_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.SIE_STATUS.Reg) & 0x8000000) >> 27
}
func (o *USBCTRL_REGS_Type) SetSIE_STATUS_RX_OVERFLOW(value uint32) {
	volatile.StoreUint32(&o.SIE_STATUS.Reg, volatile.LoadUint32(&o.SIE_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *USBCTRL_REGS_Type) GetSIE_STATUS_RX_OVERFLOW() uint32 {
	return (volatile.LoadUint32(&o.SIE_STATUS.Reg) & 0x4000000) >> 26
}
func (o *USBCTRL_REGS_Type) SetSIE_STATUS_BIT_STUFF_ERROR(value uint32) {
	volatile.StoreUint32(&o.SIE_STATUS.Reg, volatile.LoadUint32(&o.SIE_STATUS.Reg)&^(0x2000000)|value<<25)
}
func (o *USBCTRL_REGS_Type) GetSIE_STATUS_BIT_STUFF_ERROR() uint32 {
	return (volatile.LoadUint32(&o.SIE_STATUS.Reg) & 0x2000000) >> 25
}
func (o *USBCTRL_REGS_Type) SetSIE_STATUS_CRC_ERROR(value uint32) {
	volatile.StoreUint32(&o.SIE_STATUS.Reg, volatile.LoadUint32(&o.SIE_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *USBCTRL_REGS_Type) GetSIE_STATUS_CRC_ERROR() uint32 {
	return (volatile.LoadUint32(&o.SIE_STATUS.Reg) & 0x1000000) >> 24
}
func (o *USBCTRL_REGS_Type) SetSIE_STATUS_BUS_RESET(value uint32) {
	volatile.StoreUint32(&o.SIE_STATUS.Reg, volatile.LoadUint32(&o.SIE_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *USBCTRL_REGS_Type) GetSIE_STATUS_BUS_RESET() uint32 {
	return (volatile.LoadUint32(&o.SIE_STATUS.Reg) & 0x80000) >> 19
}
func (o *USBCTRL_REGS_Type) SetSIE_STATUS_TRANS_COMPLETE(value uint32) {
	volatile.StoreUint32(&o.SIE_STATUS.Reg, volatile.LoadUint32(&o.SIE_STATUS.Reg)&^(0x40000)|value<<18)
}
func (o *USBCTRL_REGS_Type) GetSIE_STATUS_TRANS_COMPLETE() uint32 {
	return (volatile.LoadUint32(&o.SIE_STATUS.Reg) & 0x40000) >> 18
}
func (o *USBCTRL_REGS_Type) SetSIE_STATUS_SETUP_REC(value uint32) {
	volatile.StoreUint32(&o.SIE_STATUS.Reg, volatile.LoadUint32(&o.SIE_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *USBCTRL_REGS_Type) GetSIE_STATUS_SETUP_REC() uint32 {
	return (volatile.LoadUint32(&o.SIE_STATUS.Reg) & 0x20000) >> 17
}
func (o *USBCTRL_REGS_Type) SetSIE_STATUS_CONNECTED(value uint32) {
	volatile.StoreUint32(&o.SIE_STATUS.Reg, volatile.LoadUint32(&o.SIE_STATUS.Reg)&^(0x10000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetSIE_STATUS_CONNECTED() uint32 {
	return (volatile.LoadUint32(&o.SIE_STATUS.Reg) & 0x10000) >> 16
}
func (o *USBCTRL_REGS_Type) SetSIE_STATUS_RESUME(value uint32) {
	volatile.StoreUint32(&o.SIE_STATUS.Reg, volatile.LoadUint32(&o.SIE_STATUS.Reg)&^(0x800)|value<<11)
}
func (o *USBCTRL_REGS_Type) GetSIE_STATUS_RESUME() uint32 {
	return (volatile.LoadUint32(&o.SIE_STATUS.Reg) & 0x800) >> 11
}
func (o *USBCTRL_REGS_Type) SetSIE_STATUS_VBUS_OVER_CURR(value uint32) {
	volatile.StoreUint32(&o.SIE_STATUS.Reg, volatile.LoadUint32(&o.SIE_STATUS.Reg)&^(0x400)|value<<10)
}
func (o *USBCTRL_REGS_Type) GetSIE_STATUS_VBUS_OVER_CURR() uint32 {
	return (volatile.LoadUint32(&o.SIE_STATUS.Reg) & 0x400) >> 10
}
func (o *USBCTRL_REGS_Type) SetSIE_STATUS_SPEED(value uint32) {
	volatile.StoreUint32(&o.SIE_STATUS.Reg, volatile.LoadUint32(&o.SIE_STATUS.Reg)&^(0x300)|value<<8)
}
func (o *USBCTRL_REGS_Type) GetSIE_STATUS_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SIE_STATUS.Reg) & 0x300) >> 8
}
func (o *USBCTRL_REGS_Type) SetSIE_STATUS_SUSPENDED(value uint32) {
	volatile.StoreUint32(&o.SIE_STATUS.Reg, volatile.LoadUint32(&o.SIE_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *USBCTRL_REGS_Type) GetSIE_STATUS_SUSPENDED() uint32 {
	return (volatile.LoadUint32(&o.SIE_STATUS.Reg) & 0x10) >> 4
}
func (o *USBCTRL_REGS_Type) SetSIE_STATUS_LINE_STATE(value uint32) {
	volatile.StoreUint32(&o.SIE_STATUS.Reg, volatile.LoadUint32(&o.SIE_STATUS.Reg)&^(0xc)|value<<2)
}
func (o *USBCTRL_REGS_Type) GetSIE_STATUS_LINE_STATE() uint32 {
	return (volatile.LoadUint32(&o.SIE_STATUS.Reg) & 0xc) >> 2
}
func (o *USBCTRL_REGS_Type) SetSIE_STATUS_VBUS_DETECTED(value uint32) {
	volatile.StoreUint32(&o.SIE_STATUS.Reg, volatile.LoadUint32(&o.SIE_STATUS.Reg)&^(0x1)|value)
}
func (o *USBCTRL_REGS_Type) GetSIE_STATUS_VBUS_DETECTED() uint32 {
	return volatile.LoadUint32(&o.SIE_STATUS.Reg) & 0x1
}

// USBCTRL_REGS.INT_EP_CTRL: interrupt endpoint control register
func (o *USBCTRL_REGS_Type) SetINT_EP_CTRL_INT_EP_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.INT_EP_CTRL.Reg, volatile.LoadUint32(&o.INT_EP_CTRL.Reg)&^(0xfffe)|value<<1)
}
func (o *USBCTRL_REGS_Type) GetINT_EP_CTRL_INT_EP_ACTIVE() uint32 {
	return (volatile.LoadUint32(&o.INT_EP_CTRL.Reg) & 0xfffe) >> 1
}

// USBCTRL_REGS.BUFF_STATUS: Buffer status register. A bit set here indicates that a buffer has completed on the endpoint (if the buffer interrupt is enabled). It is possible for 2 buffers to be completed, so clearing the buffer status bit may instantly re set it on the next clock cycle.
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP15_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x80000000)|value<<31)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP15_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x80000000) >> 31
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP15_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x40000000)|value<<30)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP15_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x40000000) >> 30
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP14_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x20000000)|value<<29)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP14_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x20000000) >> 29
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP14_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x10000000)|value<<28)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP14_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x10000000) >> 28
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP13_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x8000000)|value<<27)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP13_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x8000000) >> 27
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP13_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x4000000)|value<<26)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP13_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x4000000) >> 26
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP12_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x2000000)|value<<25)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP12_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x2000000) >> 25
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP12_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x1000000)|value<<24)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP12_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x1000000) >> 24
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP11_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x800000)|value<<23)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP11_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x800000) >> 23
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP11_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x400000)|value<<22)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP11_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x400000) >> 22
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP10_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x200000)|value<<21)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP10_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x200000) >> 21
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP10_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x100000)|value<<20)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP10_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x100000) >> 20
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP9_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP9_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x80000) >> 19
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP9_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x40000)|value<<18)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP9_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x40000) >> 18
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP8_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP8_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x20000) >> 17
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP8_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x10000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP8_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x10000) >> 16
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP7_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x8000)|value<<15)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP7_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x8000) >> 15
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP7_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x4000)|value<<14)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP7_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x4000) >> 14
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP6_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP6_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x2000) >> 13
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP6_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP6_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x1000) >> 12
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP5_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x800)|value<<11)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP5_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x800) >> 11
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP5_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x400)|value<<10)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP5_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x400) >> 10
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP4_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x200)|value<<9)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP4_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x200) >> 9
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP4_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x100)|value<<8)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP4_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x100) >> 8
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP3_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x80)|value<<7)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP3_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x80) >> 7
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP3_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x40)|value<<6)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP3_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x40) >> 6
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP2_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x20)|value<<5)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP2_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x20) >> 5
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP2_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP2_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x10) >> 4
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP1_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x8)|value<<3)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP1_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x8) >> 3
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP1_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP1_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x4) >> 2
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP0_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x2)|value<<1)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP0_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x2) >> 1
}
func (o *USBCTRL_REGS_Type) SetBUFF_STATUS_EP0_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_STATUS.Reg, volatile.LoadUint32(&o.BUFF_STATUS.Reg)&^(0x1)|value)
}
func (o *USBCTRL_REGS_Type) GetBUFF_STATUS_EP0_IN() uint32 {
	return volatile.LoadUint32(&o.BUFF_STATUS.Reg) & 0x1
}

// USBCTRL_REGS.BUFF_CPU_SHOULD_HANDLE: Which of the double buffers should be handled. Only valid if using an interrupt per buffer (i.e. not per 2 buffers). Not valid for host interrupt endpoint polling because they are only single buffered.
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP15_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x80000000)|value<<31)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP15_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x80000000) >> 31
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP15_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x40000000)|value<<30)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP15_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x40000000) >> 30
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP14_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x20000000)|value<<29)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP14_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x20000000) >> 29
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP14_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x10000000)|value<<28)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP14_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x10000000) >> 28
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP13_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x8000000)|value<<27)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP13_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x8000000) >> 27
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP13_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x4000000)|value<<26)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP13_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x4000000) >> 26
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP12_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x2000000)|value<<25)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP12_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x2000000) >> 25
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP12_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x1000000)|value<<24)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP12_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x1000000) >> 24
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP11_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x800000)|value<<23)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP11_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x800000) >> 23
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP11_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x400000)|value<<22)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP11_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x400000) >> 22
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP10_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x200000)|value<<21)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP10_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x200000) >> 21
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP10_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x100000)|value<<20)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP10_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x100000) >> 20
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP9_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x80000)|value<<19)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP9_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x80000) >> 19
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP9_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x40000)|value<<18)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP9_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x40000) >> 18
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP8_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x20000)|value<<17)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP8_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x20000) >> 17
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP8_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x10000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP8_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x10000) >> 16
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP7_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x8000)|value<<15)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP7_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x8000) >> 15
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP7_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x4000)|value<<14)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP7_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x4000) >> 14
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP6_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x2000)|value<<13)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP6_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x2000) >> 13
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP6_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x1000)|value<<12)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP6_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x1000) >> 12
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP5_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x800)|value<<11)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP5_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x800) >> 11
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP5_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x400)|value<<10)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP5_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x400) >> 10
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP4_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x200)|value<<9)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP4_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x200) >> 9
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP4_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x100)|value<<8)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP4_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x100) >> 8
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP3_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x80)|value<<7)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP3_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x80) >> 7
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP3_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x40)|value<<6)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP3_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x40) >> 6
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP2_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x20)|value<<5)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP2_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x20) >> 5
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP2_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x10)|value<<4)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP2_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x10) >> 4
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP1_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x8)|value<<3)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP1_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x8) >> 3
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP1_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x4)|value<<2)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP1_IN() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x4) >> 2
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP0_OUT(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x2)|value<<1)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP0_OUT() uint32 {
	return (volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x2) >> 1
}
func (o *USBCTRL_REGS_Type) SetBUFF_CPU_SHOULD_HANDLE_EP0_IN(value uint32) {
	volatile.StoreUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg, volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg)&^(0x1)|value)
}
func (o *USBCTRL_REGS_Type) GetBUFF_CPU_SHOULD_HANDLE_EP0_IN() uint32 {
	return volatile.LoadUint32(&o.BUFF_CPU_SHOULD_HANDLE.Reg) & 0x1
}

// USBCTRL_REGS.EP_ABORT: Device only: Can be set to ignore the buffer control register for this endpoint in case you would like to revoke a buffer. A NAK will be sent for every access to the endpoint until this bit is cleared. A corresponding bit in `EP_ABORT_DONE` is set when it is safe to modify the buffer control register.
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP15_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x80000000)|value<<31)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP15_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x80000000) >> 31
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP15_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x40000000)|value<<30)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP15_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x40000000) >> 30
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP14_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x20000000)|value<<29)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP14_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x20000000) >> 29
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP14_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x10000000)|value<<28)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP14_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x10000000) >> 28
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP13_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x8000000)|value<<27)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP13_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x8000000) >> 27
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP13_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x4000000)|value<<26)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP13_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x4000000) >> 26
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP12_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x2000000)|value<<25)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP12_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x2000000) >> 25
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP12_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x1000000)|value<<24)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP12_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x1000000) >> 24
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP11_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x800000)|value<<23)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP11_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x800000) >> 23
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP11_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x400000)|value<<22)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP11_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x400000) >> 22
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP10_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x200000)|value<<21)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP10_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x200000) >> 21
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP10_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x100000)|value<<20)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP10_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x100000) >> 20
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP9_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x80000)|value<<19)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP9_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x80000) >> 19
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP9_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x40000)|value<<18)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP9_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x40000) >> 18
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP8_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x20000)|value<<17)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP8_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x20000) >> 17
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP8_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x10000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP8_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x10000) >> 16
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP7_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x8000)|value<<15)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP7_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x8000) >> 15
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP7_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x4000)|value<<14)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP7_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x4000) >> 14
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP6_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x2000)|value<<13)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP6_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x2000) >> 13
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP6_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x1000)|value<<12)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP6_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x1000) >> 12
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP5_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x800)|value<<11)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP5_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x800) >> 11
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP5_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x400)|value<<10)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP5_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x400) >> 10
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP4_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x200)|value<<9)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP4_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x200) >> 9
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP4_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x100)|value<<8)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP4_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x100) >> 8
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP3_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x80)|value<<7)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP3_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x80) >> 7
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP3_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x40)|value<<6)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP3_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x40) >> 6
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP2_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x20)|value<<5)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP2_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x20) >> 5
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP2_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x10)|value<<4)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP2_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x10) >> 4
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP1_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x8)|value<<3)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP1_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x8) >> 3
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP1_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x4)|value<<2)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP1_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x4) >> 2
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP0_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x2)|value<<1)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP0_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x2) >> 1
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_EP0_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT.Reg, volatile.LoadUint32(&o.EP_ABORT.Reg)&^(0x1)|value)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_EP0_IN() uint32 {
	return volatile.LoadUint32(&o.EP_ABORT.Reg) & 0x1
}

// USBCTRL_REGS.EP_ABORT_DONE: Device only: Used in conjunction with `EP_ABORT`. Set once an endpoint is idle so the programmer knows it is safe to modify the buffer control register.
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP15_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x80000000)|value<<31)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP15_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x80000000) >> 31
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP15_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x40000000)|value<<30)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP15_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x40000000) >> 30
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP14_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x20000000)|value<<29)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP14_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x20000000) >> 29
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP14_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x10000000)|value<<28)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP14_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x10000000) >> 28
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP13_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x8000000)|value<<27)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP13_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x8000000) >> 27
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP13_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x4000000)|value<<26)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP13_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x4000000) >> 26
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP12_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x2000000)|value<<25)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP12_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x2000000) >> 25
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP12_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x1000000)|value<<24)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP12_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x1000000) >> 24
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP11_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x800000)|value<<23)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP11_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x800000) >> 23
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP11_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x400000)|value<<22)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP11_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x400000) >> 22
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP10_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x200000)|value<<21)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP10_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x200000) >> 21
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP10_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x100000)|value<<20)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP10_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x100000) >> 20
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP9_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x80000)|value<<19)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP9_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x80000) >> 19
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP9_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x40000)|value<<18)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP9_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x40000) >> 18
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP8_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x20000)|value<<17)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP8_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x20000) >> 17
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP8_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x10000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP8_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x10000) >> 16
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP7_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x8000)|value<<15)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP7_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x8000) >> 15
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP7_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x4000)|value<<14)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP7_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x4000) >> 14
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP6_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x2000)|value<<13)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP6_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x2000) >> 13
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP6_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x1000)|value<<12)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP6_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x1000) >> 12
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP5_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x800)|value<<11)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP5_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x800) >> 11
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP5_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x400)|value<<10)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP5_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x400) >> 10
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP4_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x200)|value<<9)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP4_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x200) >> 9
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP4_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x100)|value<<8)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP4_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x100) >> 8
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP3_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x80)|value<<7)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP3_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x80) >> 7
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP3_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x40)|value<<6)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP3_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x40) >> 6
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP2_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x20)|value<<5)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP2_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x20) >> 5
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP2_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x10)|value<<4)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP2_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x10) >> 4
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP1_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x8)|value<<3)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP1_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x8) >> 3
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP1_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x4)|value<<2)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP1_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x4) >> 2
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP0_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x2)|value<<1)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP0_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x2) >> 1
}
func (o *USBCTRL_REGS_Type) SetEP_ABORT_DONE_EP0_IN(value uint32) {
	volatile.StoreUint32(&o.EP_ABORT_DONE.Reg, volatile.LoadUint32(&o.EP_ABORT_DONE.Reg)&^(0x1)|value)
}
func (o *USBCTRL_REGS_Type) GetEP_ABORT_DONE_EP0_IN() uint32 {
	return volatile.LoadUint32(&o.EP_ABORT_DONE.Reg) & 0x1
}

// USBCTRL_REGS.EP_STALL_ARM: Device: this bit must be set in conjunction with the `STALL` bit in the buffer control register to send a STALL on EP0. The device controller clears these bits when a SETUP packet is received because the USB spec requires that a STALL condition is cleared when a SETUP packet is received.
func (o *USBCTRL_REGS_Type) SetEP_STALL_ARM_EP0_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_STALL_ARM.Reg, volatile.LoadUint32(&o.EP_STALL_ARM.Reg)&^(0x2)|value<<1)
}
func (o *USBCTRL_REGS_Type) GetEP_STALL_ARM_EP0_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_STALL_ARM.Reg) & 0x2) >> 1
}
func (o *USBCTRL_REGS_Type) SetEP_STALL_ARM_EP0_IN(value uint32) {
	volatile.StoreUint32(&o.EP_STALL_ARM.Reg, volatile.LoadUint32(&o.EP_STALL_ARM.Reg)&^(0x1)|value)
}
func (o *USBCTRL_REGS_Type) GetEP_STALL_ARM_EP0_IN() uint32 {
	return volatile.LoadUint32(&o.EP_STALL_ARM.Reg) & 0x1
}

// USBCTRL_REGS.NAK_POLL: Used by the host controller. Sets the wait time in microseconds before trying again if the device replies with a NAK.
func (o *USBCTRL_REGS_Type) SetNAK_POLL_DELAY_FS(value uint32) {
	volatile.StoreUint32(&o.NAK_POLL.Reg, volatile.LoadUint32(&o.NAK_POLL.Reg)&^(0x3ff0000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetNAK_POLL_DELAY_FS() uint32 {
	return (volatile.LoadUint32(&o.NAK_POLL.Reg) & 0x3ff0000) >> 16
}
func (o *USBCTRL_REGS_Type) SetNAK_POLL_DELAY_LS(value uint32) {
	volatile.StoreUint32(&o.NAK_POLL.Reg, volatile.LoadUint32(&o.NAK_POLL.Reg)&^(0x3ff)|value)
}
func (o *USBCTRL_REGS_Type) GetNAK_POLL_DELAY_LS() uint32 {
	return volatile.LoadUint32(&o.NAK_POLL.Reg) & 0x3ff
}

// USBCTRL_REGS.EP_STATUS_STALL_NAK: Device: bits are set when the `IRQ_ON_NAK` or `IRQ_ON_STALL` bits are set. For EP0 this comes from `SIE_CTRL`. For all other endpoints it comes from the endpoint control register.
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP15_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x80000000)|value<<31)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP15_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x80000000) >> 31
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP15_IN(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x40000000)|value<<30)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP15_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x40000000) >> 30
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP14_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x20000000)|value<<29)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP14_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x20000000) >> 29
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP14_IN(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x10000000)|value<<28)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP14_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x10000000) >> 28
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP13_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x8000000)|value<<27)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP13_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x8000000) >> 27
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP13_IN(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x4000000)|value<<26)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP13_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x4000000) >> 26
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP12_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x2000000)|value<<25)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP12_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x2000000) >> 25
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP12_IN(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x1000000)|value<<24)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP12_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x1000000) >> 24
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP11_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x800000)|value<<23)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP11_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x800000) >> 23
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP11_IN(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x400000)|value<<22)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP11_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x400000) >> 22
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP10_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x200000)|value<<21)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP10_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x200000) >> 21
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP10_IN(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x100000)|value<<20)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP10_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x100000) >> 20
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP9_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x80000)|value<<19)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP9_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x80000) >> 19
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP9_IN(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x40000)|value<<18)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP9_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x40000) >> 18
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP8_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x20000)|value<<17)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP8_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x20000) >> 17
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP8_IN(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x10000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP8_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x10000) >> 16
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP7_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x8000)|value<<15)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP7_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x8000) >> 15
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP7_IN(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x4000)|value<<14)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP7_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x4000) >> 14
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP6_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x2000)|value<<13)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP6_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x2000) >> 13
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP6_IN(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x1000)|value<<12)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP6_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x1000) >> 12
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP5_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x800)|value<<11)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP5_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x800) >> 11
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP5_IN(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x400)|value<<10)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP5_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x400) >> 10
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP4_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x200)|value<<9)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP4_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x200) >> 9
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP4_IN(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x100)|value<<8)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP4_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x100) >> 8
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP3_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x80)|value<<7)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP3_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x80) >> 7
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP3_IN(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x40)|value<<6)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP3_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x40) >> 6
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP2_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x20)|value<<5)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP2_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x20) >> 5
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP2_IN(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x10)|value<<4)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP2_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x10) >> 4
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP1_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x8)|value<<3)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP1_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x8) >> 3
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP1_IN(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x4)|value<<2)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP1_IN() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x4) >> 2
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP0_OUT(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x2)|value<<1)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP0_OUT() uint32 {
	return (volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x2) >> 1
}
func (o *USBCTRL_REGS_Type) SetEP_STATUS_STALL_NAK_EP0_IN(value uint32) {
	volatile.StoreUint32(&o.EP_STATUS_STALL_NAK.Reg, volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg)&^(0x1)|value)
}
func (o *USBCTRL_REGS_Type) GetEP_STATUS_STALL_NAK_EP0_IN() uint32 {
	return volatile.LoadUint32(&o.EP_STATUS_STALL_NAK.Reg) & 0x1
}

// USBCTRL_REGS.USB_MUXING: Where to connect the USB controller. Should be to_phy by default.
func (o *USBCTRL_REGS_Type) SetUSB_MUXING_SOFTCON(value uint32) {
	volatile.StoreUint32(&o.USB_MUXING.Reg, volatile.LoadUint32(&o.USB_MUXING.Reg)&^(0x8)|value<<3)
}
func (o *USBCTRL_REGS_Type) GetUSB_MUXING_SOFTCON() uint32 {
	return (volatile.LoadUint32(&o.USB_MUXING.Reg) & 0x8) >> 3
}
func (o *USBCTRL_REGS_Type) SetUSB_MUXING_TO_DIGITAL_PAD(value uint32) {
	volatile.StoreUint32(&o.USB_MUXING.Reg, volatile.LoadUint32(&o.USB_MUXING.Reg)&^(0x4)|value<<2)
}
func (o *USBCTRL_REGS_Type) GetUSB_MUXING_TO_DIGITAL_PAD() uint32 {
	return (volatile.LoadUint32(&o.USB_MUXING.Reg) & 0x4) >> 2
}
func (o *USBCTRL_REGS_Type) SetUSB_MUXING_TO_EXTPHY(value uint32) {
	volatile.StoreUint32(&o.USB_MUXING.Reg, volatile.LoadUint32(&o.USB_MUXING.Reg)&^(0x2)|value<<1)
}
func (o *USBCTRL_REGS_Type) GetUSB_MUXING_TO_EXTPHY() uint32 {
	return (volatile.LoadUint32(&o.USB_MUXING.Reg) & 0x2) >> 1
}
func (o *USBCTRL_REGS_Type) SetUSB_MUXING_TO_PHY(value uint32) {
	volatile.StoreUint32(&o.USB_MUXING.Reg, volatile.LoadUint32(&o.USB_MUXING.Reg)&^(0x1)|value)
}
func (o *USBCTRL_REGS_Type) GetUSB_MUXING_TO_PHY() uint32 {
	return volatile.LoadUint32(&o.USB_MUXING.Reg) & 0x1
}

// USBCTRL_REGS.USB_PWR: Overrides for the power signals in the event that the VBUS signals are not hooked up to GPIO. Set the value of the override and then the override enable to switch over to the override value.
func (o *USBCTRL_REGS_Type) SetUSB_PWR_OVERCURR_DETECT_EN(value uint32) {
	volatile.StoreUint32(&o.USB_PWR.Reg, volatile.LoadUint32(&o.USB_PWR.Reg)&^(0x20)|value<<5)
}
func (o *USBCTRL_REGS_Type) GetUSB_PWR_OVERCURR_DETECT_EN() uint32 {
	return (volatile.LoadUint32(&o.USB_PWR.Reg) & 0x20) >> 5
}
func (o *USBCTRL_REGS_Type) SetUSB_PWR_OVERCURR_DETECT(value uint32) {
	volatile.StoreUint32(&o.USB_PWR.Reg, volatile.LoadUint32(&o.USB_PWR.Reg)&^(0x10)|value<<4)
}
func (o *USBCTRL_REGS_Type) GetUSB_PWR_OVERCURR_DETECT() uint32 {
	return (volatile.LoadUint32(&o.USB_PWR.Reg) & 0x10) >> 4
}
func (o *USBCTRL_REGS_Type) SetUSB_PWR_VBUS_DETECT_OVERRIDE_EN(value uint32) {
	volatile.StoreUint32(&o.USB_PWR.Reg, volatile.LoadUint32(&o.USB_PWR.Reg)&^(0x8)|value<<3)
}
func (o *USBCTRL_REGS_Type) GetUSB_PWR_VBUS_DETECT_OVERRIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.USB_PWR.Reg) & 0x8) >> 3
}
func (o *USBCTRL_REGS_Type) SetUSB_PWR_VBUS_DETECT(value uint32) {
	volatile.StoreUint32(&o.USB_PWR.Reg, volatile.LoadUint32(&o.USB_PWR.Reg)&^(0x4)|value<<2)
}
func (o *USBCTRL_REGS_Type) GetUSB_PWR_VBUS_DETECT() uint32 {
	return (volatile.LoadUint32(&o.USB_PWR.Reg) & 0x4) >> 2
}
func (o *USBCTRL_REGS_Type) SetUSB_PWR_VBUS_EN_OVERRIDE_EN(value uint32) {
	volatile.StoreUint32(&o.USB_PWR.Reg, volatile.LoadUint32(&o.USB_PWR.Reg)&^(0x2)|value<<1)
}
func (o *USBCTRL_REGS_Type) GetUSB_PWR_VBUS_EN_OVERRIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.USB_PWR.Reg) & 0x2) >> 1
}
func (o *USBCTRL_REGS_Type) SetUSB_PWR_VBUS_EN(value uint32) {
	volatile.StoreUint32(&o.USB_PWR.Reg, volatile.LoadUint32(&o.USB_PWR.Reg)&^(0x1)|value)
}
func (o *USBCTRL_REGS_Type) GetUSB_PWR_VBUS_EN() uint32 {
	return volatile.LoadUint32(&o.USB_PWR.Reg) & 0x1
}

// USBCTRL_REGS.USBPHY_DIRECT: This register allows for direct control of the USB phy. Use in conjunction with usbphy_direct_override register to enable each override bit.
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_DM_OVV(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT.Reg)&^(0x400000)|value<<22)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_DM_OVV() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT.Reg) & 0x400000) >> 22
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_DP_OVV(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT.Reg)&^(0x200000)|value<<21)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_DP_OVV() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT.Reg) & 0x200000) >> 21
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_DM_OVCN(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT.Reg)&^(0x100000)|value<<20)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_DM_OVCN() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT.Reg) & 0x100000) >> 20
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_DP_OVCN(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT.Reg)&^(0x80000)|value<<19)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_DP_OVCN() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT.Reg) & 0x80000) >> 19
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_RX_DM(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT.Reg)&^(0x40000)|value<<18)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_RX_DM() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT.Reg) & 0x40000) >> 18
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_RX_DP(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT.Reg)&^(0x20000)|value<<17)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_RX_DP() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT.Reg) & 0x20000) >> 17
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_RX_DD(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT.Reg)&^(0x10000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_RX_DD() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT.Reg) & 0x10000) >> 16
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_TX_DIFFMODE(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT.Reg)&^(0x8000)|value<<15)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_TX_DIFFMODE() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT.Reg) & 0x8000) >> 15
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_TX_FSSLEW(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT.Reg)&^(0x4000)|value<<14)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_TX_FSSLEW() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT.Reg) & 0x4000) >> 14
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_TX_PD(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT.Reg)&^(0x2000)|value<<13)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_TX_PD() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT.Reg) & 0x2000) >> 13
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_RX_PD(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT.Reg)&^(0x1000)|value<<12)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_RX_PD() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT.Reg) & 0x1000) >> 12
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_TX_DM(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT.Reg)&^(0x800)|value<<11)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_TX_DM() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT.Reg) & 0x800) >> 11
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_TX_DP(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT.Reg)&^(0x400)|value<<10)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_TX_DP() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT.Reg) & 0x400) >> 10
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_TX_DM_OE(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT.Reg)&^(0x200)|value<<9)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_TX_DM_OE() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT.Reg) & 0x200) >> 9
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_TX_DP_OE(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT.Reg)&^(0x100)|value<<8)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_TX_DP_OE() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT.Reg) & 0x100) >> 8
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_DM_PULLDN_EN(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT.Reg)&^(0x40)|value<<6)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_DM_PULLDN_EN() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT.Reg) & 0x40) >> 6
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_DM_PULLUP_EN(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT.Reg)&^(0x20)|value<<5)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_DM_PULLUP_EN() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT.Reg) & 0x20) >> 5
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_DM_PULLUP_HISEL(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT.Reg)&^(0x10)|value<<4)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_DM_PULLUP_HISEL() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT.Reg) & 0x10) >> 4
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_DP_PULLDN_EN(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT.Reg)&^(0x4)|value<<2)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_DP_PULLDN_EN() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT.Reg) & 0x4) >> 2
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_DP_PULLUP_EN(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT.Reg)&^(0x2)|value<<1)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_DP_PULLUP_EN() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT.Reg) & 0x2) >> 1
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_DP_PULLUP_HISEL(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT.Reg)&^(0x1)|value)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_DP_PULLUP_HISEL() uint32 {
	return volatile.LoadUint32(&o.USBPHY_DIRECT.Reg) & 0x1
}

// USBCTRL_REGS.USBPHY_DIRECT_OVERRIDE: Override enable for each control in usbphy_direct
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_OVERRIDE_TX_DIFFMODE_OVERRIDE_EN(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg)&^(0x8000)|value<<15)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_OVERRIDE_TX_DIFFMODE_OVERRIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg) & 0x8000) >> 15
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_OVERRIDE_DM_PULLUP_OVERRIDE_EN(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg)&^(0x1000)|value<<12)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_OVERRIDE_DM_PULLUP_OVERRIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg) & 0x1000) >> 12
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_OVERRIDE_TX_FSSLEW_OVERRIDE_EN(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg)&^(0x800)|value<<11)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_OVERRIDE_TX_FSSLEW_OVERRIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg) & 0x800) >> 11
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_OVERRIDE_TX_PD_OVERRIDE_EN(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg)&^(0x400)|value<<10)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_OVERRIDE_TX_PD_OVERRIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg) & 0x400) >> 10
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_OVERRIDE_RX_PD_OVERRIDE_EN(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg)&^(0x200)|value<<9)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_OVERRIDE_RX_PD_OVERRIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg) & 0x200) >> 9
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_OVERRIDE_TX_DM_OVERRIDE_EN(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg)&^(0x100)|value<<8)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_OVERRIDE_TX_DM_OVERRIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg) & 0x100) >> 8
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_OVERRIDE_TX_DP_OVERRIDE_EN(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg)&^(0x80)|value<<7)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_OVERRIDE_TX_DP_OVERRIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg) & 0x80) >> 7
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_OVERRIDE_TX_DM_OE_OVERRIDE_EN(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg)&^(0x40)|value<<6)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_OVERRIDE_TX_DM_OE_OVERRIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg) & 0x40) >> 6
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_OVERRIDE_TX_DP_OE_OVERRIDE_EN(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg)&^(0x20)|value<<5)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_OVERRIDE_TX_DP_OE_OVERRIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg) & 0x20) >> 5
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_OVERRIDE_DM_PULLDN_EN_OVERRIDE_EN(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg)&^(0x10)|value<<4)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_OVERRIDE_DM_PULLDN_EN_OVERRIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg) & 0x10) >> 4
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_OVERRIDE_DP_PULLDN_EN_OVERRIDE_EN(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg)&^(0x8)|value<<3)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_OVERRIDE_DP_PULLDN_EN_OVERRIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg) & 0x8) >> 3
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_OVERRIDE_DP_PULLUP_EN_OVERRIDE_EN(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg)&^(0x4)|value<<2)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_OVERRIDE_DP_PULLUP_EN_OVERRIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg) & 0x4) >> 2
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_OVERRIDE_DM_PULLUP_HISEL_OVERRIDE_EN(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg)&^(0x2)|value<<1)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_OVERRIDE_DM_PULLUP_HISEL_OVERRIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg) & 0x2) >> 1
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_DIRECT_OVERRIDE_DP_PULLUP_HISEL_OVERRIDE_EN(value uint32) {
	volatile.StoreUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg, volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg)&^(0x1)|value)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_DIRECT_OVERRIDE_DP_PULLUP_HISEL_OVERRIDE_EN() uint32 {
	return volatile.LoadUint32(&o.USBPHY_DIRECT_OVERRIDE.Reg) & 0x1
}

// USBCTRL_REGS.USBPHY_TRIM: Used to adjust trim values of USB phy pull down resistors.
func (o *USBCTRL_REGS_Type) SetUSBPHY_TRIM_DM_PULLDN_TRIM(value uint32) {
	volatile.StoreUint32(&o.USBPHY_TRIM.Reg, volatile.LoadUint32(&o.USBPHY_TRIM.Reg)&^(0x1f00)|value<<8)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_TRIM_DM_PULLDN_TRIM() uint32 {
	return (volatile.LoadUint32(&o.USBPHY_TRIM.Reg) & 0x1f00) >> 8
}
func (o *USBCTRL_REGS_Type) SetUSBPHY_TRIM_DP_PULLDN_TRIM(value uint32) {
	volatile.StoreUint32(&o.USBPHY_TRIM.Reg, volatile.LoadUint32(&o.USBPHY_TRIM.Reg)&^(0x1f)|value)
}
func (o *USBCTRL_REGS_Type) GetUSBPHY_TRIM_DP_PULLDN_TRIM() uint32 {
	return volatile.LoadUint32(&o.USBPHY_TRIM.Reg) & 0x1f
}

// USBCTRL_REGS.INTR: Raw Interrupts
func (o *USBCTRL_REGS_Type) SetINTR_EP_STALL_NAK(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x80000)|value<<19)
}
func (o *USBCTRL_REGS_Type) GetINTR_EP_STALL_NAK() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x80000) >> 19
}
func (o *USBCTRL_REGS_Type) SetINTR_ABORT_DONE(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x40000)|value<<18)
}
func (o *USBCTRL_REGS_Type) GetINTR_ABORT_DONE() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x40000) >> 18
}
func (o *USBCTRL_REGS_Type) SetINTR_DEV_SOF(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x20000)|value<<17)
}
func (o *USBCTRL_REGS_Type) GetINTR_DEV_SOF() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x20000) >> 17
}
func (o *USBCTRL_REGS_Type) SetINTR_SETUP_REQ(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x10000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetINTR_SETUP_REQ() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x10000) >> 16
}
func (o *USBCTRL_REGS_Type) SetINTR_DEV_RESUME_FROM_HOST(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBCTRL_REGS_Type) GetINTR_DEV_RESUME_FROM_HOST() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x8000) >> 15
}
func (o *USBCTRL_REGS_Type) SetINTR_DEV_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBCTRL_REGS_Type) GetINTR_DEV_SUSPEND() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x4000) >> 14
}
func (o *USBCTRL_REGS_Type) SetINTR_DEV_CONN_DIS(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBCTRL_REGS_Type) GetINTR_DEV_CONN_DIS() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x2000) >> 13
}
func (o *USBCTRL_REGS_Type) SetINTR_BUS_RESET(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x1000)|value<<12)
}
func (o *USBCTRL_REGS_Type) GetINTR_BUS_RESET() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x1000) >> 12
}
func (o *USBCTRL_REGS_Type) SetINTR_VBUS_DETECT(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x800)|value<<11)
}
func (o *USBCTRL_REGS_Type) GetINTR_VBUS_DETECT() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x800) >> 11
}
func (o *USBCTRL_REGS_Type) SetINTR_STALL(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x400)|value<<10)
}
func (o *USBCTRL_REGS_Type) GetINTR_STALL() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x400) >> 10
}
func (o *USBCTRL_REGS_Type) SetINTR_ERROR_CRC(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x200)|value<<9)
}
func (o *USBCTRL_REGS_Type) GetINTR_ERROR_CRC() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x200) >> 9
}
func (o *USBCTRL_REGS_Type) SetINTR_ERROR_BIT_STUFF(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x100)|value<<8)
}
func (o *USBCTRL_REGS_Type) GetINTR_ERROR_BIT_STUFF() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x100) >> 8
}
func (o *USBCTRL_REGS_Type) SetINTR_ERROR_RX_OVERFLOW(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x80)|value<<7)
}
func (o *USBCTRL_REGS_Type) GetINTR_ERROR_RX_OVERFLOW() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x80) >> 7
}
func (o *USBCTRL_REGS_Type) SetINTR_ERROR_RX_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x40)|value<<6)
}
func (o *USBCTRL_REGS_Type) GetINTR_ERROR_RX_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x40) >> 6
}
func (o *USBCTRL_REGS_Type) SetINTR_ERROR_DATA_SEQ(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x20)|value<<5)
}
func (o *USBCTRL_REGS_Type) GetINTR_ERROR_DATA_SEQ() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x20) >> 5
}
func (o *USBCTRL_REGS_Type) SetINTR_BUFF_STATUS(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x10)|value<<4)
}
func (o *USBCTRL_REGS_Type) GetINTR_BUFF_STATUS() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x10) >> 4
}
func (o *USBCTRL_REGS_Type) SetINTR_TRANS_COMPLETE(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x8)|value<<3)
}
func (o *USBCTRL_REGS_Type) GetINTR_TRANS_COMPLETE() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x8) >> 3
}
func (o *USBCTRL_REGS_Type) SetINTR_HOST_SOF(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x4)|value<<2)
}
func (o *USBCTRL_REGS_Type) GetINTR_HOST_SOF() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x4) >> 2
}
func (o *USBCTRL_REGS_Type) SetINTR_HOST_RESUME(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x2)|value<<1)
}
func (o *USBCTRL_REGS_Type) GetINTR_HOST_RESUME() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x2) >> 1
}
func (o *USBCTRL_REGS_Type) SetINTR_HOST_CONN_DIS(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x1)|value)
}
func (o *USBCTRL_REGS_Type) GetINTR_HOST_CONN_DIS() uint32 {
	return volatile.LoadUint32(&o.INTR.Reg) & 0x1
}

// USBCTRL_REGS.INTE: Interrupt Enable
func (o *USBCTRL_REGS_Type) SetINTE_EP_STALL_NAK(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x80000)|value<<19)
}
func (o *USBCTRL_REGS_Type) GetINTE_EP_STALL_NAK() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x80000) >> 19
}
func (o *USBCTRL_REGS_Type) SetINTE_ABORT_DONE(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x40000)|value<<18)
}
func (o *USBCTRL_REGS_Type) GetINTE_ABORT_DONE() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x40000) >> 18
}
func (o *USBCTRL_REGS_Type) SetINTE_DEV_SOF(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x20000)|value<<17)
}
func (o *USBCTRL_REGS_Type) GetINTE_DEV_SOF() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x20000) >> 17
}
func (o *USBCTRL_REGS_Type) SetINTE_SETUP_REQ(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x10000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetINTE_SETUP_REQ() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x10000) >> 16
}
func (o *USBCTRL_REGS_Type) SetINTE_DEV_RESUME_FROM_HOST(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x8000)|value<<15)
}
func (o *USBCTRL_REGS_Type) GetINTE_DEV_RESUME_FROM_HOST() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x8000) >> 15
}
func (o *USBCTRL_REGS_Type) SetINTE_DEV_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x4000)|value<<14)
}
func (o *USBCTRL_REGS_Type) GetINTE_DEV_SUSPEND() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x4000) >> 14
}
func (o *USBCTRL_REGS_Type) SetINTE_DEV_CONN_DIS(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x2000)|value<<13)
}
func (o *USBCTRL_REGS_Type) GetINTE_DEV_CONN_DIS() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x2000) >> 13
}
func (o *USBCTRL_REGS_Type) SetINTE_BUS_RESET(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x1000)|value<<12)
}
func (o *USBCTRL_REGS_Type) GetINTE_BUS_RESET() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x1000) >> 12
}
func (o *USBCTRL_REGS_Type) SetINTE_VBUS_DETECT(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x800)|value<<11)
}
func (o *USBCTRL_REGS_Type) GetINTE_VBUS_DETECT() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x800) >> 11
}
func (o *USBCTRL_REGS_Type) SetINTE_STALL(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x400)|value<<10)
}
func (o *USBCTRL_REGS_Type) GetINTE_STALL() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x400) >> 10
}
func (o *USBCTRL_REGS_Type) SetINTE_ERROR_CRC(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x200)|value<<9)
}
func (o *USBCTRL_REGS_Type) GetINTE_ERROR_CRC() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x200) >> 9
}
func (o *USBCTRL_REGS_Type) SetINTE_ERROR_BIT_STUFF(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x100)|value<<8)
}
func (o *USBCTRL_REGS_Type) GetINTE_ERROR_BIT_STUFF() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x100) >> 8
}
func (o *USBCTRL_REGS_Type) SetINTE_ERROR_RX_OVERFLOW(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x80)|value<<7)
}
func (o *USBCTRL_REGS_Type) GetINTE_ERROR_RX_OVERFLOW() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x80) >> 7
}
func (o *USBCTRL_REGS_Type) SetINTE_ERROR_RX_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x40)|value<<6)
}
func (o *USBCTRL_REGS_Type) GetINTE_ERROR_RX_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x40) >> 6
}
func (o *USBCTRL_REGS_Type) SetINTE_ERROR_DATA_SEQ(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x20)|value<<5)
}
func (o *USBCTRL_REGS_Type) GetINTE_ERROR_DATA_SEQ() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x20) >> 5
}
func (o *USBCTRL_REGS_Type) SetINTE_BUFF_STATUS(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x10)|value<<4)
}
func (o *USBCTRL_REGS_Type) GetINTE_BUFF_STATUS() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x10) >> 4
}
func (o *USBCTRL_REGS_Type) SetINTE_TRANS_COMPLETE(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x8)|value<<3)
}
func (o *USBCTRL_REGS_Type) GetINTE_TRANS_COMPLETE() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x8) >> 3
}
func (o *USBCTRL_REGS_Type) SetINTE_HOST_SOF(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x4)|value<<2)
}
func (o *USBCTRL_REGS_Type) GetINTE_HOST_SOF() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x4) >> 2
}
func (o *USBCTRL_REGS_Type) SetINTE_HOST_RESUME(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x2)|value<<1)
}
func (o *USBCTRL_REGS_Type) GetINTE_HOST_RESUME() uint32 {
	return (volatile.LoadUint32(&o.INTE.Reg) & 0x2) >> 1
}
func (o *USBCTRL_REGS_Type) SetINTE_HOST_CONN_DIS(value uint32) {
	volatile.StoreUint32(&o.INTE.Reg, volatile.LoadUint32(&o.INTE.Reg)&^(0x1)|value)
}
func (o *USBCTRL_REGS_Type) GetINTE_HOST_CONN_DIS() uint32 {
	return volatile.LoadUint32(&o.INTE.Reg) & 0x1
}

// USBCTRL_REGS.INTF: Interrupt Force
func (o *USBCTRL_REGS_Type) SetINTF_EP_STALL_NAK(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x80000)|value<<19)
}
func (o *USBCTRL_REGS_Type) GetINTF_EP_STALL_NAK() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x80000) >> 19
}
func (o *USBCTRL_REGS_Type) SetINTF_ABORT_DONE(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x40000)|value<<18)
}
func (o *USBCTRL_REGS_Type) GetINTF_ABORT_DONE() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x40000) >> 18
}
func (o *USBCTRL_REGS_Type) SetINTF_DEV_SOF(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x20000)|value<<17)
}
func (o *USBCTRL_REGS_Type) GetINTF_DEV_SOF() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x20000) >> 17
}
func (o *USBCTRL_REGS_Type) SetINTF_SETUP_REQ(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x10000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetINTF_SETUP_REQ() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x10000) >> 16
}
func (o *USBCTRL_REGS_Type) SetINTF_DEV_RESUME_FROM_HOST(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x8000)|value<<15)
}
func (o *USBCTRL_REGS_Type) GetINTF_DEV_RESUME_FROM_HOST() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x8000) >> 15
}
func (o *USBCTRL_REGS_Type) SetINTF_DEV_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x4000)|value<<14)
}
func (o *USBCTRL_REGS_Type) GetINTF_DEV_SUSPEND() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x4000) >> 14
}
func (o *USBCTRL_REGS_Type) SetINTF_DEV_CONN_DIS(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x2000)|value<<13)
}
func (o *USBCTRL_REGS_Type) GetINTF_DEV_CONN_DIS() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x2000) >> 13
}
func (o *USBCTRL_REGS_Type) SetINTF_BUS_RESET(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x1000)|value<<12)
}
func (o *USBCTRL_REGS_Type) GetINTF_BUS_RESET() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x1000) >> 12
}
func (o *USBCTRL_REGS_Type) SetINTF_VBUS_DETECT(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x800)|value<<11)
}
func (o *USBCTRL_REGS_Type) GetINTF_VBUS_DETECT() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x800) >> 11
}
func (o *USBCTRL_REGS_Type) SetINTF_STALL(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x400)|value<<10)
}
func (o *USBCTRL_REGS_Type) GetINTF_STALL() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x400) >> 10
}
func (o *USBCTRL_REGS_Type) SetINTF_ERROR_CRC(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x200)|value<<9)
}
func (o *USBCTRL_REGS_Type) GetINTF_ERROR_CRC() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x200) >> 9
}
func (o *USBCTRL_REGS_Type) SetINTF_ERROR_BIT_STUFF(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x100)|value<<8)
}
func (o *USBCTRL_REGS_Type) GetINTF_ERROR_BIT_STUFF() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x100) >> 8
}
func (o *USBCTRL_REGS_Type) SetINTF_ERROR_RX_OVERFLOW(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x80)|value<<7)
}
func (o *USBCTRL_REGS_Type) GetINTF_ERROR_RX_OVERFLOW() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x80) >> 7
}
func (o *USBCTRL_REGS_Type) SetINTF_ERROR_RX_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x40)|value<<6)
}
func (o *USBCTRL_REGS_Type) GetINTF_ERROR_RX_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x40) >> 6
}
func (o *USBCTRL_REGS_Type) SetINTF_ERROR_DATA_SEQ(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x20)|value<<5)
}
func (o *USBCTRL_REGS_Type) GetINTF_ERROR_DATA_SEQ() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x20) >> 5
}
func (o *USBCTRL_REGS_Type) SetINTF_BUFF_STATUS(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x10)|value<<4)
}
func (o *USBCTRL_REGS_Type) GetINTF_BUFF_STATUS() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x10) >> 4
}
func (o *USBCTRL_REGS_Type) SetINTF_TRANS_COMPLETE(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x8)|value<<3)
}
func (o *USBCTRL_REGS_Type) GetINTF_TRANS_COMPLETE() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x8) >> 3
}
func (o *USBCTRL_REGS_Type) SetINTF_HOST_SOF(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x4)|value<<2)
}
func (o *USBCTRL_REGS_Type) GetINTF_HOST_SOF() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x4) >> 2
}
func (o *USBCTRL_REGS_Type) SetINTF_HOST_RESUME(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x2)|value<<1)
}
func (o *USBCTRL_REGS_Type) GetINTF_HOST_RESUME() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x2) >> 1
}
func (o *USBCTRL_REGS_Type) SetINTF_HOST_CONN_DIS(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x1)|value)
}
func (o *USBCTRL_REGS_Type) GetINTF_HOST_CONN_DIS() uint32 {
	return volatile.LoadUint32(&o.INTF.Reg) & 0x1
}

// USBCTRL_REGS.INTS: Interrupt status after masking & forcing
func (o *USBCTRL_REGS_Type) SetINTS_EP_STALL_NAK(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x80000)|value<<19)
}
func (o *USBCTRL_REGS_Type) GetINTS_EP_STALL_NAK() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x80000) >> 19
}
func (o *USBCTRL_REGS_Type) SetINTS_ABORT_DONE(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x40000)|value<<18)
}
func (o *USBCTRL_REGS_Type) GetINTS_ABORT_DONE() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x40000) >> 18
}
func (o *USBCTRL_REGS_Type) SetINTS_DEV_SOF(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x20000)|value<<17)
}
func (o *USBCTRL_REGS_Type) GetINTS_DEV_SOF() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x20000) >> 17
}
func (o *USBCTRL_REGS_Type) SetINTS_SETUP_REQ(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x10000)|value<<16)
}
func (o *USBCTRL_REGS_Type) GetINTS_SETUP_REQ() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x10000) >> 16
}
func (o *USBCTRL_REGS_Type) SetINTS_DEV_RESUME_FROM_HOST(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x8000)|value<<15)
}
func (o *USBCTRL_REGS_Type) GetINTS_DEV_RESUME_FROM_HOST() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x8000) >> 15
}
func (o *USBCTRL_REGS_Type) SetINTS_DEV_SUSPEND(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x4000)|value<<14)
}
func (o *USBCTRL_REGS_Type) GetINTS_DEV_SUSPEND() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x4000) >> 14
}
func (o *USBCTRL_REGS_Type) SetINTS_DEV_CONN_DIS(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x2000)|value<<13)
}
func (o *USBCTRL_REGS_Type) GetINTS_DEV_CONN_DIS() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x2000) >> 13
}
func (o *USBCTRL_REGS_Type) SetINTS_BUS_RESET(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x1000)|value<<12)
}
func (o *USBCTRL_REGS_Type) GetINTS_BUS_RESET() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x1000) >> 12
}
func (o *USBCTRL_REGS_Type) SetINTS_VBUS_DETECT(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x800)|value<<11)
}
func (o *USBCTRL_REGS_Type) GetINTS_VBUS_DETECT() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x800) >> 11
}
func (o *USBCTRL_REGS_Type) SetINTS_STALL(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x400)|value<<10)
}
func (o *USBCTRL_REGS_Type) GetINTS_STALL() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x400) >> 10
}
func (o *USBCTRL_REGS_Type) SetINTS_ERROR_CRC(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x200)|value<<9)
}
func (o *USBCTRL_REGS_Type) GetINTS_ERROR_CRC() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x200) >> 9
}
func (o *USBCTRL_REGS_Type) SetINTS_ERROR_BIT_STUFF(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x100)|value<<8)
}
func (o *USBCTRL_REGS_Type) GetINTS_ERROR_BIT_STUFF() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x100) >> 8
}
func (o *USBCTRL_REGS_Type) SetINTS_ERROR_RX_OVERFLOW(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x80)|value<<7)
}
func (o *USBCTRL_REGS_Type) GetINTS_ERROR_RX_OVERFLOW() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x80) >> 7
}
func (o *USBCTRL_REGS_Type) SetINTS_ERROR_RX_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x40)|value<<6)
}
func (o *USBCTRL_REGS_Type) GetINTS_ERROR_RX_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x40) >> 6
}
func (o *USBCTRL_REGS_Type) SetINTS_ERROR_DATA_SEQ(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x20)|value<<5)
}
func (o *USBCTRL_REGS_Type) GetINTS_ERROR_DATA_SEQ() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x20) >> 5
}
func (o *USBCTRL_REGS_Type) SetINTS_BUFF_STATUS(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x10)|value<<4)
}
func (o *USBCTRL_REGS_Type) GetINTS_BUFF_STATUS() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x10) >> 4
}
func (o *USBCTRL_REGS_Type) SetINTS_TRANS_COMPLETE(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x8)|value<<3)
}
func (o *USBCTRL_REGS_Type) GetINTS_TRANS_COMPLETE() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x8) >> 3
}
func (o *USBCTRL_REGS_Type) SetINTS_HOST_SOF(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x4)|value<<2)
}
func (o *USBCTRL_REGS_Type) GetINTS_HOST_SOF() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x4) >> 2
}
func (o *USBCTRL_REGS_Type) SetINTS_HOST_RESUME(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x2)|value<<1)
}
func (o *USBCTRL_REGS_Type) GetINTS_HOST_RESUME() uint32 {
	return (volatile.LoadUint32(&o.INTS.Reg) & 0x2) >> 1
}
func (o *USBCTRL_REGS_Type) SetINTS_HOST_CONN_DIS(value uint32) {
	volatile.StoreUint32(&o.INTS.Reg, volatile.LoadUint32(&o.INTS.Reg)&^(0x1)|value)
}
func (o *USBCTRL_REGS_Type) GetINTS_HOST_CONN_DIS() uint32 {
	return volatile.LoadUint32(&o.INTS.Reg) & 0x1
}

// Programmable IO block
type PIO0_Type struct {
	CTRL              volatile.Register32 // 0x0
	FSTAT             volatile.Register32 // 0x4
	FDEBUG            volatile.Register32 // 0x8
	FLEVEL            volatile.Register32 // 0xC
	TXF0              volatile.Register32 // 0x10
	TXF1              volatile.Register32 // 0x14
	TXF2              volatile.Register32 // 0x18
	TXF3              volatile.Register32 // 0x1C
	RXF0              volatile.Register32 // 0x20
	RXF1              volatile.Register32 // 0x24
	RXF2              volatile.Register32 // 0x28
	RXF3              volatile.Register32 // 0x2C
	IRQ               volatile.Register32 // 0x30
	IRQ_FORCE         volatile.Register32 // 0x34
	INPUT_SYNC_BYPASS volatile.Register32 // 0x38
	DBG_PADOUT        volatile.Register32 // 0x3C
	DBG_PADOE         volatile.Register32 // 0x40
	DBG_CFGINFO       volatile.Register32 // 0x44
	INSTR_MEM0        volatile.Register32 // 0x48
	INSTR_MEM1        volatile.Register32 // 0x4C
	INSTR_MEM2        volatile.Register32 // 0x50
	INSTR_MEM3        volatile.Register32 // 0x54
	INSTR_MEM4        volatile.Register32 // 0x58
	INSTR_MEM5        volatile.Register32 // 0x5C
	INSTR_MEM6        volatile.Register32 // 0x60
	INSTR_MEM7        volatile.Register32 // 0x64
	INSTR_MEM8        volatile.Register32 // 0x68
	INSTR_MEM9        volatile.Register32 // 0x6C
	INSTR_MEM10       volatile.Register32 // 0x70
	INSTR_MEM11       volatile.Register32 // 0x74
	INSTR_MEM12       volatile.Register32 // 0x78
	INSTR_MEM13       volatile.Register32 // 0x7C
	INSTR_MEM14       volatile.Register32 // 0x80
	INSTR_MEM15       volatile.Register32 // 0x84
	INSTR_MEM16       volatile.Register32 // 0x88
	INSTR_MEM17       volatile.Register32 // 0x8C
	INSTR_MEM18       volatile.Register32 // 0x90
	INSTR_MEM19       volatile.Register32 // 0x94
	INSTR_MEM20       volatile.Register32 // 0x98
	INSTR_MEM21       volatile.Register32 // 0x9C
	INSTR_MEM22       volatile.Register32 // 0xA0
	INSTR_MEM23       volatile.Register32 // 0xA4
	INSTR_MEM24       volatile.Register32 // 0xA8
	INSTR_MEM25       volatile.Register32 // 0xAC
	INSTR_MEM26       volatile.Register32 // 0xB0
	INSTR_MEM27       volatile.Register32 // 0xB4
	INSTR_MEM28       volatile.Register32 // 0xB8
	INSTR_MEM29       volatile.Register32 // 0xBC
	INSTR_MEM30       volatile.Register32 // 0xC0
	INSTR_MEM31       volatile.Register32 // 0xC4
	SM0_CLKDIV        volatile.Register32 // 0xC8
	SM0_EXECCTRL      volatile.Register32 // 0xCC
	SM0_SHIFTCTRL     volatile.Register32 // 0xD0
	SM0_ADDR          volatile.Register32 // 0xD4
	SM0_INSTR         volatile.Register32 // 0xD8
	SM0_PINCTRL       volatile.Register32 // 0xDC
	SM1_CLKDIV        volatile.Register32 // 0xE0
	SM1_EXECCTRL      volatile.Register32 // 0xE4
	SM1_SHIFTCTRL     volatile.Register32 // 0xE8
	SM1_ADDR          volatile.Register32 // 0xEC
	SM1_INSTR         volatile.Register32 // 0xF0
	SM1_PINCTRL       volatile.Register32 // 0xF4
	SM2_CLKDIV        volatile.Register32 // 0xF8
	SM2_EXECCTRL      volatile.Register32 // 0xFC
	SM2_SHIFTCTRL     volatile.Register32 // 0x100
	SM2_ADDR          volatile.Register32 // 0x104
	SM2_INSTR         volatile.Register32 // 0x108
	SM2_PINCTRL       volatile.Register32 // 0x10C
	SM3_CLKDIV        volatile.Register32 // 0x110
	SM3_EXECCTRL      volatile.Register32 // 0x114
	SM3_SHIFTCTRL     volatile.Register32 // 0x118
	SM3_ADDR          volatile.Register32 // 0x11C
	SM3_INSTR         volatile.Register32 // 0x120
	SM3_PINCTRL       volatile.Register32 // 0x124
	INTR              volatile.Register32 // 0x128
	IRQ0_INTE         volatile.Register32 // 0x12C
	IRQ0_INTF         volatile.Register32 // 0x130
	IRQ0_INTS         volatile.Register32 // 0x134
	IRQ1_INTE         volatile.Register32 // 0x138
	IRQ1_INTF         volatile.Register32 // 0x13C
	IRQ1_INTS         volatile.Register32 // 0x140
}

// PIO0.CTRL: PIO control register
func (o *PIO0_Type) SetCTRL_CLKDIV_RESTART(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xf00)|value<<8)
}
func (o *PIO0_Type) GetCTRL_CLKDIV_RESTART() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xf00) >> 8
}
func (o *PIO0_Type) SetCTRL_SM_RESTART(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xf0)|value<<4)
}
func (o *PIO0_Type) GetCTRL_SM_RESTART() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xf0) >> 4
}
func (o *PIO0_Type) SetCTRL_SM_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xf)|value)
}
func (o *PIO0_Type) GetCTRL_SM_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0xf
}

// PIO0.FSTAT: FIFO status register
func (o *PIO0_Type) SetFSTAT_TXEMPTY(value uint32) {
	volatile.StoreUint32(&o.FSTAT.Reg, volatile.LoadUint32(&o.FSTAT.Reg)&^(0xf000000)|value<<24)
}
func (o *PIO0_Type) GetFSTAT_TXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.FSTAT.Reg) & 0xf000000) >> 24
}
func (o *PIO0_Type) SetFSTAT_TXFULL(value uint32) {
	volatile.StoreUint32(&o.FSTAT.Reg, volatile.LoadUint32(&o.FSTAT.Reg)&^(0xf0000)|value<<16)
}
func (o *PIO0_Type) GetFSTAT_TXFULL() uint32 {
	return (volatile.LoadUint32(&o.FSTAT.Reg) & 0xf0000) >> 16
}
func (o *PIO0_Type) SetFSTAT_RXEMPTY(value uint32) {
	volatile.StoreUint32(&o.FSTAT.Reg, volatile.LoadUint32(&o.FSTAT.Reg)&^(0xf00)|value<<8)
}
func (o *PIO0_Type) GetFSTAT_RXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.FSTAT.Reg) & 0xf00) >> 8
}
func (o *PIO0_Type) SetFSTAT_RXFULL(value uint32) {
	volatile.StoreUint32(&o.FSTAT.Reg, volatile.LoadUint32(&o.FSTAT.Reg)&^(0xf)|value)
}
func (o *PIO0_Type) GetFSTAT_RXFULL() uint32 {
	return volatile.LoadUint32(&o.FSTAT.Reg) & 0xf
}

// PIO0.FDEBUG: FIFO debug register
func (o *PIO0_Type) SetFDEBUG_TXSTALL(value uint32) {
	volatile.StoreUint32(&o.FDEBUG.Reg, volatile.LoadUint32(&o.FDEBUG.Reg)&^(0xf000000)|value<<24)
}
func (o *PIO0_Type) GetFDEBUG_TXSTALL() uint32 {
	return (volatile.LoadUint32(&o.FDEBUG.Reg) & 0xf000000) >> 24
}
func (o *PIO0_Type) SetFDEBUG_TXOVER(value uint32) {
	volatile.StoreUint32(&o.FDEBUG.Reg, volatile.LoadUint32(&o.FDEBUG.Reg)&^(0xf0000)|value<<16)
}
func (o *PIO0_Type) GetFDEBUG_TXOVER() uint32 {
	return (volatile.LoadUint32(&o.FDEBUG.Reg) & 0xf0000) >> 16
}
func (o *PIO0_Type) SetFDEBUG_RXUNDER(value uint32) {
	volatile.StoreUint32(&o.FDEBUG.Reg, volatile.LoadUint32(&o.FDEBUG.Reg)&^(0xf00)|value<<8)
}
func (o *PIO0_Type) GetFDEBUG_RXUNDER() uint32 {
	return (volatile.LoadUint32(&o.FDEBUG.Reg) & 0xf00) >> 8
}
func (o *PIO0_Type) SetFDEBUG_RXSTALL(value uint32) {
	volatile.StoreUint32(&o.FDEBUG.Reg, volatile.LoadUint32(&o.FDEBUG.Reg)&^(0xf)|value)
}
func (o *PIO0_Type) GetFDEBUG_RXSTALL() uint32 {
	return volatile.LoadUint32(&o.FDEBUG.Reg) & 0xf
}

// PIO0.FLEVEL: FIFO levels
func (o *PIO0_Type) SetFLEVEL_RX3(value uint32) {
	volatile.StoreUint32(&o.FLEVEL.Reg, volatile.LoadUint32(&o.FLEVEL.Reg)&^(0xf0000000)|value<<28)
}
func (o *PIO0_Type) GetFLEVEL_RX3() uint32 {
	return (volatile.LoadUint32(&o.FLEVEL.Reg) & 0xf0000000) >> 28
}
func (o *PIO0_Type) SetFLEVEL_TX3(value uint32) {
	volatile.StoreUint32(&o.FLEVEL.Reg, volatile.LoadUint32(&o.FLEVEL.Reg)&^(0xf000000)|value<<24)
}
func (o *PIO0_Type) GetFLEVEL_TX3() uint32 {
	return (volatile.LoadUint32(&o.FLEVEL.Reg) & 0xf000000) >> 24
}
func (o *PIO0_Type) SetFLEVEL_RX2(value uint32) {
	volatile.StoreUint32(&o.FLEVEL.Reg, volatile.LoadUint32(&o.FLEVEL.Reg)&^(0xf00000)|value<<20)
}
func (o *PIO0_Type) GetFLEVEL_RX2() uint32 {
	return (volatile.LoadUint32(&o.FLEVEL.Reg) & 0xf00000) >> 20
}
func (o *PIO0_Type) SetFLEVEL_TX2(value uint32) {
	volatile.StoreUint32(&o.FLEVEL.Reg, volatile.LoadUint32(&o.FLEVEL.Reg)&^(0xf0000)|value<<16)
}
func (o *PIO0_Type) GetFLEVEL_TX2() uint32 {
	return (volatile.LoadUint32(&o.FLEVEL.Reg) & 0xf0000) >> 16
}
func (o *PIO0_Type) SetFLEVEL_RX1(value uint32) {
	volatile.StoreUint32(&o.FLEVEL.Reg, volatile.LoadUint32(&o.FLEVEL.Reg)&^(0xf000)|value<<12)
}
func (o *PIO0_Type) GetFLEVEL_RX1() uint32 {
	return (volatile.LoadUint32(&o.FLEVEL.Reg) & 0xf000) >> 12
}
func (o *PIO0_Type) SetFLEVEL_TX1(value uint32) {
	volatile.StoreUint32(&o.FLEVEL.Reg, volatile.LoadUint32(&o.FLEVEL.Reg)&^(0xf00)|value<<8)
}
func (o *PIO0_Type) GetFLEVEL_TX1() uint32 {
	return (volatile.LoadUint32(&o.FLEVEL.Reg) & 0xf00) >> 8
}
func (o *PIO0_Type) SetFLEVEL_RX0(value uint32) {
	volatile.StoreUint32(&o.FLEVEL.Reg, volatile.LoadUint32(&o.FLEVEL.Reg)&^(0xf0)|value<<4)
}
func (o *PIO0_Type) GetFLEVEL_RX0() uint32 {
	return (volatile.LoadUint32(&o.FLEVEL.Reg) & 0xf0) >> 4
}
func (o *PIO0_Type) SetFLEVEL_TX0(value uint32) {
	volatile.StoreUint32(&o.FLEVEL.Reg, volatile.LoadUint32(&o.FLEVEL.Reg)&^(0xf)|value)
}
func (o *PIO0_Type) GetFLEVEL_TX0() uint32 {
	return volatile.LoadUint32(&o.FLEVEL.Reg) & 0xf
}

// PIO0.IRQ: Interrupt request register. Write 1 to clear
func (o *PIO0_Type) SetIRQ(value uint32) {
	volatile.StoreUint32(&o.IRQ.Reg, volatile.LoadUint32(&o.IRQ.Reg)&^(0xff)|value)
}
func (o *PIO0_Type) GetIRQ() uint32 {
	return volatile.LoadUint32(&o.IRQ.Reg) & 0xff
}

// PIO0.IRQ_FORCE
// Writing a 1 to each of these bits will forcibly assert the corresponding IRQ.
// Note this is different to the INTF register: writing here affects PIO internal
// state. INTF just asserts the processor-facing IRQ signal for testing ISRs,
// and is not visible to the state machines.
func (o *PIO0_Type) SetIRQ_FORCE(value uint32) {
	volatile.StoreUint32(&o.IRQ_FORCE.Reg, volatile.LoadUint32(&o.IRQ_FORCE.Reg)&^(0xff)|value)
}
func (o *PIO0_Type) GetIRQ_FORCE() uint32 {
	return volatile.LoadUint32(&o.IRQ_FORCE.Reg) & 0xff
}

// PIO0.DBG_CFGINFO
// The PIO hardware has some free parameters that may vary between chip products.
// These should be provided in the chip datasheet, but are also exposed here.
func (o *PIO0_Type) SetDBG_CFGINFO_IMEM_SIZE(value uint32) {
	volatile.StoreUint32(&o.DBG_CFGINFO.Reg, volatile.LoadUint32(&o.DBG_CFGINFO.Reg)&^(0x3f0000)|value<<16)
}
func (o *PIO0_Type) GetDBG_CFGINFO_IMEM_SIZE() uint32 {
	return (volatile.LoadUint32(&o.DBG_CFGINFO.Reg) & 0x3f0000) >> 16
}
func (o *PIO0_Type) SetDBG_CFGINFO_SM_COUNT(value uint32) {
	volatile.StoreUint32(&o.DBG_CFGINFO.Reg, volatile.LoadUint32(&o.DBG_CFGINFO.Reg)&^(0xf00)|value<<8)
}
func (o *PIO0_Type) GetDBG_CFGINFO_SM_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DBG_CFGINFO.Reg) & 0xf00) >> 8
}
func (o *PIO0_Type) SetDBG_CFGINFO_FIFO_DEPTH(value uint32) {
	volatile.StoreUint32(&o.DBG_CFGINFO.Reg, volatile.LoadUint32(&o.DBG_CFGINFO.Reg)&^(0x3f)|value)
}
func (o *PIO0_Type) GetDBG_CFGINFO_FIFO_DEPTH() uint32 {
	return volatile.LoadUint32(&o.DBG_CFGINFO.Reg) & 0x3f
}

// PIO0.INSTR_MEM0: Write-only access to instruction memory location 0
func (o *PIO0_Type) SetINSTR_MEM0(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM0.Reg, volatile.LoadUint32(&o.INSTR_MEM0.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM0() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM0.Reg) & 0xffff
}

// PIO0.INSTR_MEM1: Write-only access to instruction memory location 1
func (o *PIO0_Type) SetINSTR_MEM1(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM1.Reg, volatile.LoadUint32(&o.INSTR_MEM1.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM1() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM1.Reg) & 0xffff
}

// PIO0.INSTR_MEM2: Write-only access to instruction memory location 2
func (o *PIO0_Type) SetINSTR_MEM2(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM2.Reg, volatile.LoadUint32(&o.INSTR_MEM2.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM2() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM2.Reg) & 0xffff
}

// PIO0.INSTR_MEM3: Write-only access to instruction memory location 3
func (o *PIO0_Type) SetINSTR_MEM3(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM3.Reg, volatile.LoadUint32(&o.INSTR_MEM3.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM3() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM3.Reg) & 0xffff
}

// PIO0.INSTR_MEM4: Write-only access to instruction memory location 4
func (o *PIO0_Type) SetINSTR_MEM4(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM4.Reg, volatile.LoadUint32(&o.INSTR_MEM4.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM4() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM4.Reg) & 0xffff
}

// PIO0.INSTR_MEM5: Write-only access to instruction memory location 5
func (o *PIO0_Type) SetINSTR_MEM5(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM5.Reg, volatile.LoadUint32(&o.INSTR_MEM5.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM5() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM5.Reg) & 0xffff
}

// PIO0.INSTR_MEM6: Write-only access to instruction memory location 6
func (o *PIO0_Type) SetINSTR_MEM6(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM6.Reg, volatile.LoadUint32(&o.INSTR_MEM6.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM6() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM6.Reg) & 0xffff
}

// PIO0.INSTR_MEM7: Write-only access to instruction memory location 7
func (o *PIO0_Type) SetINSTR_MEM7(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM7.Reg, volatile.LoadUint32(&o.INSTR_MEM7.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM7() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM7.Reg) & 0xffff
}

// PIO0.INSTR_MEM8: Write-only access to instruction memory location 8
func (o *PIO0_Type) SetINSTR_MEM8(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM8.Reg, volatile.LoadUint32(&o.INSTR_MEM8.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM8() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM8.Reg) & 0xffff
}

// PIO0.INSTR_MEM9: Write-only access to instruction memory location 9
func (o *PIO0_Type) SetINSTR_MEM9(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM9.Reg, volatile.LoadUint32(&o.INSTR_MEM9.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM9() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM9.Reg) & 0xffff
}

// PIO0.INSTR_MEM10: Write-only access to instruction memory location 10
func (o *PIO0_Type) SetINSTR_MEM10(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM10.Reg, volatile.LoadUint32(&o.INSTR_MEM10.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM10() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM10.Reg) & 0xffff
}

// PIO0.INSTR_MEM11: Write-only access to instruction memory location 11
func (o *PIO0_Type) SetINSTR_MEM11(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM11.Reg, volatile.LoadUint32(&o.INSTR_MEM11.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM11() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM11.Reg) & 0xffff
}

// PIO0.INSTR_MEM12: Write-only access to instruction memory location 12
func (o *PIO0_Type) SetINSTR_MEM12(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM12.Reg, volatile.LoadUint32(&o.INSTR_MEM12.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM12() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM12.Reg) & 0xffff
}

// PIO0.INSTR_MEM13: Write-only access to instruction memory location 13
func (o *PIO0_Type) SetINSTR_MEM13(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM13.Reg, volatile.LoadUint32(&o.INSTR_MEM13.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM13() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM13.Reg) & 0xffff
}

// PIO0.INSTR_MEM14: Write-only access to instruction memory location 14
func (o *PIO0_Type) SetINSTR_MEM14(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM14.Reg, volatile.LoadUint32(&o.INSTR_MEM14.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM14() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM14.Reg) & 0xffff
}

// PIO0.INSTR_MEM15: Write-only access to instruction memory location 15
func (o *PIO0_Type) SetINSTR_MEM15(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM15.Reg, volatile.LoadUint32(&o.INSTR_MEM15.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM15() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM15.Reg) & 0xffff
}

// PIO0.INSTR_MEM16: Write-only access to instruction memory location 16
func (o *PIO0_Type) SetINSTR_MEM16(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM16.Reg, volatile.LoadUint32(&o.INSTR_MEM16.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM16() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM16.Reg) & 0xffff
}

// PIO0.INSTR_MEM17: Write-only access to instruction memory location 17
func (o *PIO0_Type) SetINSTR_MEM17(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM17.Reg, volatile.LoadUint32(&o.INSTR_MEM17.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM17() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM17.Reg) & 0xffff
}

// PIO0.INSTR_MEM18: Write-only access to instruction memory location 18
func (o *PIO0_Type) SetINSTR_MEM18(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM18.Reg, volatile.LoadUint32(&o.INSTR_MEM18.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM18() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM18.Reg) & 0xffff
}

// PIO0.INSTR_MEM19: Write-only access to instruction memory location 19
func (o *PIO0_Type) SetINSTR_MEM19(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM19.Reg, volatile.LoadUint32(&o.INSTR_MEM19.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM19() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM19.Reg) & 0xffff
}

// PIO0.INSTR_MEM20: Write-only access to instruction memory location 20
func (o *PIO0_Type) SetINSTR_MEM20(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM20.Reg, volatile.LoadUint32(&o.INSTR_MEM20.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM20() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM20.Reg) & 0xffff
}

// PIO0.INSTR_MEM21: Write-only access to instruction memory location 21
func (o *PIO0_Type) SetINSTR_MEM21(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM21.Reg, volatile.LoadUint32(&o.INSTR_MEM21.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM21() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM21.Reg) & 0xffff
}

// PIO0.INSTR_MEM22: Write-only access to instruction memory location 22
func (o *PIO0_Type) SetINSTR_MEM22(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM22.Reg, volatile.LoadUint32(&o.INSTR_MEM22.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM22() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM22.Reg) & 0xffff
}

// PIO0.INSTR_MEM23: Write-only access to instruction memory location 23
func (o *PIO0_Type) SetINSTR_MEM23(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM23.Reg, volatile.LoadUint32(&o.INSTR_MEM23.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM23() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM23.Reg) & 0xffff
}

// PIO0.INSTR_MEM24: Write-only access to instruction memory location 24
func (o *PIO0_Type) SetINSTR_MEM24(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM24.Reg, volatile.LoadUint32(&o.INSTR_MEM24.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM24() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM24.Reg) & 0xffff
}

// PIO0.INSTR_MEM25: Write-only access to instruction memory location 25
func (o *PIO0_Type) SetINSTR_MEM25(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM25.Reg, volatile.LoadUint32(&o.INSTR_MEM25.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM25() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM25.Reg) & 0xffff
}

// PIO0.INSTR_MEM26: Write-only access to instruction memory location 26
func (o *PIO0_Type) SetINSTR_MEM26(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM26.Reg, volatile.LoadUint32(&o.INSTR_MEM26.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM26() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM26.Reg) & 0xffff
}

// PIO0.INSTR_MEM27: Write-only access to instruction memory location 27
func (o *PIO0_Type) SetINSTR_MEM27(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM27.Reg, volatile.LoadUint32(&o.INSTR_MEM27.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM27() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM27.Reg) & 0xffff
}

// PIO0.INSTR_MEM28: Write-only access to instruction memory location 28
func (o *PIO0_Type) SetINSTR_MEM28(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM28.Reg, volatile.LoadUint32(&o.INSTR_MEM28.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM28() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM28.Reg) & 0xffff
}

// PIO0.INSTR_MEM29: Write-only access to instruction memory location 29
func (o *PIO0_Type) SetINSTR_MEM29(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM29.Reg, volatile.LoadUint32(&o.INSTR_MEM29.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM29() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM29.Reg) & 0xffff
}

// PIO0.INSTR_MEM30: Write-only access to instruction memory location 30
func (o *PIO0_Type) SetINSTR_MEM30(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM30.Reg, volatile.LoadUint32(&o.INSTR_MEM30.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM30() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM30.Reg) & 0xffff
}

// PIO0.INSTR_MEM31: Write-only access to instruction memory location 31
func (o *PIO0_Type) SetINSTR_MEM31(value uint32) {
	volatile.StoreUint32(&o.INSTR_MEM31.Reg, volatile.LoadUint32(&o.INSTR_MEM31.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetINSTR_MEM31() uint32 {
	return volatile.LoadUint32(&o.INSTR_MEM31.Reg) & 0xffff
}

// PIO0.SM0_CLKDIV
// Clock divider register for state machine 0
// Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
func (o *PIO0_Type) SetSM0_CLKDIV_INT(value uint32) {
	volatile.StoreUint32(&o.SM0_CLKDIV.Reg, volatile.LoadUint32(&o.SM0_CLKDIV.Reg)&^(0xffff0000)|value<<16)
}
func (o *PIO0_Type) GetSM0_CLKDIV_INT() uint32 {
	return (volatile.LoadUint32(&o.SM0_CLKDIV.Reg) & 0xffff0000) >> 16
}
func (o *PIO0_Type) SetSM0_CLKDIV_FRAC(value uint32) {
	volatile.StoreUint32(&o.SM0_CLKDIV.Reg, volatile.LoadUint32(&o.SM0_CLKDIV.Reg)&^(0xff00)|value<<8)
}
func (o *PIO0_Type) GetSM0_CLKDIV_FRAC() uint32 {
	return (volatile.LoadUint32(&o.SM0_CLKDIV.Reg) & 0xff00) >> 8
}

// PIO0.SM0_EXECCTRL: Execution/behavioural settings for state machine 0
func (o *PIO0_Type) SetSM0_EXECCTRL_EXEC_STALLED(value uint32) {
	volatile.StoreUint32(&o.SM0_EXECCTRL.Reg, volatile.LoadUint32(&o.SM0_EXECCTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO0_Type) GetSM0_EXECCTRL_EXEC_STALLED() uint32 {
	return (volatile.LoadUint32(&o.SM0_EXECCTRL.Reg) & 0x80000000) >> 31
}
func (o *PIO0_Type) SetSM0_EXECCTRL_SIDE_EN(value uint32) {
	volatile.StoreUint32(&o.SM0_EXECCTRL.Reg, volatile.LoadUint32(&o.SM0_EXECCTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO0_Type) GetSM0_EXECCTRL_SIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.SM0_EXECCTRL.Reg) & 0x40000000) >> 30
}
func (o *PIO0_Type) SetSM0_EXECCTRL_SIDE_PINDIR(value uint32) {
	volatile.StoreUint32(&o.SM0_EXECCTRL.Reg, volatile.LoadUint32(&o.SM0_EXECCTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO0_Type) GetSM0_EXECCTRL_SIDE_PINDIR() uint32 {
	return (volatile.LoadUint32(&o.SM0_EXECCTRL.Reg) & 0x20000000) >> 29
}
func (o *PIO0_Type) SetSM0_EXECCTRL_JMP_PIN(value uint32) {
	volatile.StoreUint32(&o.SM0_EXECCTRL.Reg, volatile.LoadUint32(&o.SM0_EXECCTRL.Reg)&^(0x1f000000)|value<<24)
}
func (o *PIO0_Type) GetSM0_EXECCTRL_JMP_PIN() uint32 {
	return (volatile.LoadUint32(&o.SM0_EXECCTRL.Reg) & 0x1f000000) >> 24
}
func (o *PIO0_Type) SetSM0_EXECCTRL_OUT_EN_SEL(value uint32) {
	volatile.StoreUint32(&o.SM0_EXECCTRL.Reg, volatile.LoadUint32(&o.SM0_EXECCTRL.Reg)&^(0xf80000)|value<<19)
}
func (o *PIO0_Type) GetSM0_EXECCTRL_OUT_EN_SEL() uint32 {
	return (volatile.LoadUint32(&o.SM0_EXECCTRL.Reg) & 0xf80000) >> 19
}
func (o *PIO0_Type) SetSM0_EXECCTRL_INLINE_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.SM0_EXECCTRL.Reg, volatile.LoadUint32(&o.SM0_EXECCTRL.Reg)&^(0x40000)|value<<18)
}
func (o *PIO0_Type) GetSM0_EXECCTRL_INLINE_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.SM0_EXECCTRL.Reg) & 0x40000) >> 18
}
func (o *PIO0_Type) SetSM0_EXECCTRL_OUT_STICKY(value uint32) {
	volatile.StoreUint32(&o.SM0_EXECCTRL.Reg, volatile.LoadUint32(&o.SM0_EXECCTRL.Reg)&^(0x20000)|value<<17)
}
func (o *PIO0_Type) GetSM0_EXECCTRL_OUT_STICKY() uint32 {
	return (volatile.LoadUint32(&o.SM0_EXECCTRL.Reg) & 0x20000) >> 17
}
func (o *PIO0_Type) SetSM0_EXECCTRL_WRAP_TOP(value uint32) {
	volatile.StoreUint32(&o.SM0_EXECCTRL.Reg, volatile.LoadUint32(&o.SM0_EXECCTRL.Reg)&^(0x1f000)|value<<12)
}
func (o *PIO0_Type) GetSM0_EXECCTRL_WRAP_TOP() uint32 {
	return (volatile.LoadUint32(&o.SM0_EXECCTRL.Reg) & 0x1f000) >> 12
}
func (o *PIO0_Type) SetSM0_EXECCTRL_WRAP_BOTTOM(value uint32) {
	volatile.StoreUint32(&o.SM0_EXECCTRL.Reg, volatile.LoadUint32(&o.SM0_EXECCTRL.Reg)&^(0xf80)|value<<7)
}
func (o *PIO0_Type) GetSM0_EXECCTRL_WRAP_BOTTOM() uint32 {
	return (volatile.LoadUint32(&o.SM0_EXECCTRL.Reg) & 0xf80) >> 7
}
func (o *PIO0_Type) SetSM0_EXECCTRL_STATUS_SEL(value uint32) {
	volatile.StoreUint32(&o.SM0_EXECCTRL.Reg, volatile.LoadUint32(&o.SM0_EXECCTRL.Reg)&^(0x10)|value<<4)
}
func (o *PIO0_Type) GetSM0_EXECCTRL_STATUS_SEL() uint32 {
	return (volatile.LoadUint32(&o.SM0_EXECCTRL.Reg) & 0x10) >> 4
}
func (o *PIO0_Type) SetSM0_EXECCTRL_STATUS_N(value uint32) {
	volatile.StoreUint32(&o.SM0_EXECCTRL.Reg, volatile.LoadUint32(&o.SM0_EXECCTRL.Reg)&^(0xf)|value)
}
func (o *PIO0_Type) GetSM0_EXECCTRL_STATUS_N() uint32 {
	return volatile.LoadUint32(&o.SM0_EXECCTRL.Reg) & 0xf
}

// PIO0.SM0_SHIFTCTRL: Control behaviour of the input/output shift registers for state machine 0
func (o *PIO0_Type) SetSM0_SHIFTCTRL_FJOIN_RX(value uint32) {
	volatile.StoreUint32(&o.SM0_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM0_SHIFTCTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO0_Type) GetSM0_SHIFTCTRL_FJOIN_RX() uint32 {
	return (volatile.LoadUint32(&o.SM0_SHIFTCTRL.Reg) & 0x80000000) >> 31
}
func (o *PIO0_Type) SetSM0_SHIFTCTRL_FJOIN_TX(value uint32) {
	volatile.StoreUint32(&o.SM0_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM0_SHIFTCTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO0_Type) GetSM0_SHIFTCTRL_FJOIN_TX() uint32 {
	return (volatile.LoadUint32(&o.SM0_SHIFTCTRL.Reg) & 0x40000000) >> 30
}
func (o *PIO0_Type) SetSM0_SHIFTCTRL_PULL_THRESH(value uint32) {
	volatile.StoreUint32(&o.SM0_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM0_SHIFTCTRL.Reg)&^(0x3e000000)|value<<25)
}
func (o *PIO0_Type) GetSM0_SHIFTCTRL_PULL_THRESH() uint32 {
	return (volatile.LoadUint32(&o.SM0_SHIFTCTRL.Reg) & 0x3e000000) >> 25
}
func (o *PIO0_Type) SetSM0_SHIFTCTRL_PUSH_THRESH(value uint32) {
	volatile.StoreUint32(&o.SM0_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM0_SHIFTCTRL.Reg)&^(0x1f00000)|value<<20)
}
func (o *PIO0_Type) GetSM0_SHIFTCTRL_PUSH_THRESH() uint32 {
	return (volatile.LoadUint32(&o.SM0_SHIFTCTRL.Reg) & 0x1f00000) >> 20
}
func (o *PIO0_Type) SetSM0_SHIFTCTRL_OUT_SHIFTDIR(value uint32) {
	volatile.StoreUint32(&o.SM0_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM0_SHIFTCTRL.Reg)&^(0x80000)|value<<19)
}
func (o *PIO0_Type) GetSM0_SHIFTCTRL_OUT_SHIFTDIR() uint32 {
	return (volatile.LoadUint32(&o.SM0_SHIFTCTRL.Reg) & 0x80000) >> 19
}
func (o *PIO0_Type) SetSM0_SHIFTCTRL_IN_SHIFTDIR(value uint32) {
	volatile.StoreUint32(&o.SM0_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM0_SHIFTCTRL.Reg)&^(0x40000)|value<<18)
}
func (o *PIO0_Type) GetSM0_SHIFTCTRL_IN_SHIFTDIR() uint32 {
	return (volatile.LoadUint32(&o.SM0_SHIFTCTRL.Reg) & 0x40000) >> 18
}
func (o *PIO0_Type) SetSM0_SHIFTCTRL_AUTOPULL(value uint32) {
	volatile.StoreUint32(&o.SM0_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM0_SHIFTCTRL.Reg)&^(0x20000)|value<<17)
}
func (o *PIO0_Type) GetSM0_SHIFTCTRL_AUTOPULL() uint32 {
	return (volatile.LoadUint32(&o.SM0_SHIFTCTRL.Reg) & 0x20000) >> 17
}
func (o *PIO0_Type) SetSM0_SHIFTCTRL_AUTOPUSH(value uint32) {
	volatile.StoreUint32(&o.SM0_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM0_SHIFTCTRL.Reg)&^(0x10000)|value<<16)
}
func (o *PIO0_Type) GetSM0_SHIFTCTRL_AUTOPUSH() uint32 {
	return (volatile.LoadUint32(&o.SM0_SHIFTCTRL.Reg) & 0x10000) >> 16
}

// PIO0.SM0_ADDR: Current instruction address of state machine 0
func (o *PIO0_Type) SetSM0_ADDR(value uint32) {
	volatile.StoreUint32(&o.SM0_ADDR.Reg, volatile.LoadUint32(&o.SM0_ADDR.Reg)&^(0x1f)|value)
}
func (o *PIO0_Type) GetSM0_ADDR() uint32 {
	return volatile.LoadUint32(&o.SM0_ADDR.Reg) & 0x1f
}

// PIO0.SM0_INSTR
// Instruction currently being executed by state machine 0
// Write to execute an instruction immediately (including jumps) and then resume execution.
func (o *PIO0_Type) SetSM0_INSTR(value uint32) {
	volatile.StoreUint32(&o.SM0_INSTR.Reg, volatile.LoadUint32(&o.SM0_INSTR.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetSM0_INSTR() uint32 {
	return volatile.LoadUint32(&o.SM0_INSTR.Reg) & 0xffff
}

// PIO0.SM0_PINCTRL: State machine pin control
func (o *PIO0_Type) SetSM0_PINCTRL_SIDESET_COUNT(value uint32) {
	volatile.StoreUint32(&o.SM0_PINCTRL.Reg, volatile.LoadUint32(&o.SM0_PINCTRL.Reg)&^(0xe0000000)|value<<29)
}
func (o *PIO0_Type) GetSM0_PINCTRL_SIDESET_COUNT() uint32 {
	return (volatile.LoadUint32(&o.SM0_PINCTRL.Reg) & 0xe0000000) >> 29
}
func (o *PIO0_Type) SetSM0_PINCTRL_SET_COUNT(value uint32) {
	volatile.StoreUint32(&o.SM0_PINCTRL.Reg, volatile.LoadUint32(&o.SM0_PINCTRL.Reg)&^(0x1c000000)|value<<26)
}
func (o *PIO0_Type) GetSM0_PINCTRL_SET_COUNT() uint32 {
	return (volatile.LoadUint32(&o.SM0_PINCTRL.Reg) & 0x1c000000) >> 26
}
func (o *PIO0_Type) SetSM0_PINCTRL_OUT_COUNT(value uint32) {
	volatile.StoreUint32(&o.SM0_PINCTRL.Reg, volatile.LoadUint32(&o.SM0_PINCTRL.Reg)&^(0x3f00000)|value<<20)
}
func (o *PIO0_Type) GetSM0_PINCTRL_OUT_COUNT() uint32 {
	return (volatile.LoadUint32(&o.SM0_PINCTRL.Reg) & 0x3f00000) >> 20
}
func (o *PIO0_Type) SetSM0_PINCTRL_IN_BASE(value uint32) {
	volatile.StoreUint32(&o.SM0_PINCTRL.Reg, volatile.LoadUint32(&o.SM0_PINCTRL.Reg)&^(0xf8000)|value<<15)
}
func (o *PIO0_Type) GetSM0_PINCTRL_IN_BASE() uint32 {
	return (volatile.LoadUint32(&o.SM0_PINCTRL.Reg) & 0xf8000) >> 15
}
func (o *PIO0_Type) SetSM0_PINCTRL_SIDESET_BASE(value uint32) {
	volatile.StoreUint32(&o.SM0_PINCTRL.Reg, volatile.LoadUint32(&o.SM0_PINCTRL.Reg)&^(0x7c00)|value<<10)
}
func (o *PIO0_Type) GetSM0_PINCTRL_SIDESET_BASE() uint32 {
	return (volatile.LoadUint32(&o.SM0_PINCTRL.Reg) & 0x7c00) >> 10
}
func (o *PIO0_Type) SetSM0_PINCTRL_SET_BASE(value uint32) {
	volatile.StoreUint32(&o.SM0_PINCTRL.Reg, volatile.LoadUint32(&o.SM0_PINCTRL.Reg)&^(0x3e0)|value<<5)
}
func (o *PIO0_Type) GetSM0_PINCTRL_SET_BASE() uint32 {
	return (volatile.LoadUint32(&o.SM0_PINCTRL.Reg) & 0x3e0) >> 5
}
func (o *PIO0_Type) SetSM0_PINCTRL_OUT_BASE(value uint32) {
	volatile.StoreUint32(&o.SM0_PINCTRL.Reg, volatile.LoadUint32(&o.SM0_PINCTRL.Reg)&^(0x1f)|value)
}
func (o *PIO0_Type) GetSM0_PINCTRL_OUT_BASE() uint32 {
	return volatile.LoadUint32(&o.SM0_PINCTRL.Reg) & 0x1f
}

// PIO0.SM1_CLKDIV
// Clock divider register for state machine 1
// Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
func (o *PIO0_Type) SetSM1_CLKDIV_INT(value uint32) {
	volatile.StoreUint32(&o.SM1_CLKDIV.Reg, volatile.LoadUint32(&o.SM1_CLKDIV.Reg)&^(0xffff0000)|value<<16)
}
func (o *PIO0_Type) GetSM1_CLKDIV_INT() uint32 {
	return (volatile.LoadUint32(&o.SM1_CLKDIV.Reg) & 0xffff0000) >> 16
}
func (o *PIO0_Type) SetSM1_CLKDIV_FRAC(value uint32) {
	volatile.StoreUint32(&o.SM1_CLKDIV.Reg, volatile.LoadUint32(&o.SM1_CLKDIV.Reg)&^(0xff00)|value<<8)
}
func (o *PIO0_Type) GetSM1_CLKDIV_FRAC() uint32 {
	return (volatile.LoadUint32(&o.SM1_CLKDIV.Reg) & 0xff00) >> 8
}

// PIO0.SM1_EXECCTRL: Execution/behavioural settings for state machine 1
func (o *PIO0_Type) SetSM1_EXECCTRL_EXEC_STALLED(value uint32) {
	volatile.StoreUint32(&o.SM1_EXECCTRL.Reg, volatile.LoadUint32(&o.SM1_EXECCTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO0_Type) GetSM1_EXECCTRL_EXEC_STALLED() uint32 {
	return (volatile.LoadUint32(&o.SM1_EXECCTRL.Reg) & 0x80000000) >> 31
}
func (o *PIO0_Type) SetSM1_EXECCTRL_SIDE_EN(value uint32) {
	volatile.StoreUint32(&o.SM1_EXECCTRL.Reg, volatile.LoadUint32(&o.SM1_EXECCTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO0_Type) GetSM1_EXECCTRL_SIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.SM1_EXECCTRL.Reg) & 0x40000000) >> 30
}
func (o *PIO0_Type) SetSM1_EXECCTRL_SIDE_PINDIR(value uint32) {
	volatile.StoreUint32(&o.SM1_EXECCTRL.Reg, volatile.LoadUint32(&o.SM1_EXECCTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO0_Type) GetSM1_EXECCTRL_SIDE_PINDIR() uint32 {
	return (volatile.LoadUint32(&o.SM1_EXECCTRL.Reg) & 0x20000000) >> 29
}
func (o *PIO0_Type) SetSM1_EXECCTRL_JMP_PIN(value uint32) {
	volatile.StoreUint32(&o.SM1_EXECCTRL.Reg, volatile.LoadUint32(&o.SM1_EXECCTRL.Reg)&^(0x1f000000)|value<<24)
}
func (o *PIO0_Type) GetSM1_EXECCTRL_JMP_PIN() uint32 {
	return (volatile.LoadUint32(&o.SM1_EXECCTRL.Reg) & 0x1f000000) >> 24
}
func (o *PIO0_Type) SetSM1_EXECCTRL_OUT_EN_SEL(value uint32) {
	volatile.StoreUint32(&o.SM1_EXECCTRL.Reg, volatile.LoadUint32(&o.SM1_EXECCTRL.Reg)&^(0xf80000)|value<<19)
}
func (o *PIO0_Type) GetSM1_EXECCTRL_OUT_EN_SEL() uint32 {
	return (volatile.LoadUint32(&o.SM1_EXECCTRL.Reg) & 0xf80000) >> 19
}
func (o *PIO0_Type) SetSM1_EXECCTRL_INLINE_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.SM1_EXECCTRL.Reg, volatile.LoadUint32(&o.SM1_EXECCTRL.Reg)&^(0x40000)|value<<18)
}
func (o *PIO0_Type) GetSM1_EXECCTRL_INLINE_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.SM1_EXECCTRL.Reg) & 0x40000) >> 18
}
func (o *PIO0_Type) SetSM1_EXECCTRL_OUT_STICKY(value uint32) {
	volatile.StoreUint32(&o.SM1_EXECCTRL.Reg, volatile.LoadUint32(&o.SM1_EXECCTRL.Reg)&^(0x20000)|value<<17)
}
func (o *PIO0_Type) GetSM1_EXECCTRL_OUT_STICKY() uint32 {
	return (volatile.LoadUint32(&o.SM1_EXECCTRL.Reg) & 0x20000) >> 17
}
func (o *PIO0_Type) SetSM1_EXECCTRL_WRAP_TOP(value uint32) {
	volatile.StoreUint32(&o.SM1_EXECCTRL.Reg, volatile.LoadUint32(&o.SM1_EXECCTRL.Reg)&^(0x1f000)|value<<12)
}
func (o *PIO0_Type) GetSM1_EXECCTRL_WRAP_TOP() uint32 {
	return (volatile.LoadUint32(&o.SM1_EXECCTRL.Reg) & 0x1f000) >> 12
}
func (o *PIO0_Type) SetSM1_EXECCTRL_WRAP_BOTTOM(value uint32) {
	volatile.StoreUint32(&o.SM1_EXECCTRL.Reg, volatile.LoadUint32(&o.SM1_EXECCTRL.Reg)&^(0xf80)|value<<7)
}
func (o *PIO0_Type) GetSM1_EXECCTRL_WRAP_BOTTOM() uint32 {
	return (volatile.LoadUint32(&o.SM1_EXECCTRL.Reg) & 0xf80) >> 7
}
func (o *PIO0_Type) SetSM1_EXECCTRL_STATUS_SEL(value uint32) {
	volatile.StoreUint32(&o.SM1_EXECCTRL.Reg, volatile.LoadUint32(&o.SM1_EXECCTRL.Reg)&^(0x10)|value<<4)
}
func (o *PIO0_Type) GetSM1_EXECCTRL_STATUS_SEL() uint32 {
	return (volatile.LoadUint32(&o.SM1_EXECCTRL.Reg) & 0x10) >> 4
}
func (o *PIO0_Type) SetSM1_EXECCTRL_STATUS_N(value uint32) {
	volatile.StoreUint32(&o.SM1_EXECCTRL.Reg, volatile.LoadUint32(&o.SM1_EXECCTRL.Reg)&^(0xf)|value)
}
func (o *PIO0_Type) GetSM1_EXECCTRL_STATUS_N() uint32 {
	return volatile.LoadUint32(&o.SM1_EXECCTRL.Reg) & 0xf
}

// PIO0.SM1_SHIFTCTRL: Control behaviour of the input/output shift registers for state machine 1
func (o *PIO0_Type) SetSM1_SHIFTCTRL_FJOIN_RX(value uint32) {
	volatile.StoreUint32(&o.SM1_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM1_SHIFTCTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO0_Type) GetSM1_SHIFTCTRL_FJOIN_RX() uint32 {
	return (volatile.LoadUint32(&o.SM1_SHIFTCTRL.Reg) & 0x80000000) >> 31
}
func (o *PIO0_Type) SetSM1_SHIFTCTRL_FJOIN_TX(value uint32) {
	volatile.StoreUint32(&o.SM1_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM1_SHIFTCTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO0_Type) GetSM1_SHIFTCTRL_FJOIN_TX() uint32 {
	return (volatile.LoadUint32(&o.SM1_SHIFTCTRL.Reg) & 0x40000000) >> 30
}
func (o *PIO0_Type) SetSM1_SHIFTCTRL_PULL_THRESH(value uint32) {
	volatile.StoreUint32(&o.SM1_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM1_SHIFTCTRL.Reg)&^(0x3e000000)|value<<25)
}
func (o *PIO0_Type) GetSM1_SHIFTCTRL_PULL_THRESH() uint32 {
	return (volatile.LoadUint32(&o.SM1_SHIFTCTRL.Reg) & 0x3e000000) >> 25
}
func (o *PIO0_Type) SetSM1_SHIFTCTRL_PUSH_THRESH(value uint32) {
	volatile.StoreUint32(&o.SM1_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM1_SHIFTCTRL.Reg)&^(0x1f00000)|value<<20)
}
func (o *PIO0_Type) GetSM1_SHIFTCTRL_PUSH_THRESH() uint32 {
	return (volatile.LoadUint32(&o.SM1_SHIFTCTRL.Reg) & 0x1f00000) >> 20
}
func (o *PIO0_Type) SetSM1_SHIFTCTRL_OUT_SHIFTDIR(value uint32) {
	volatile.StoreUint32(&o.SM1_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM1_SHIFTCTRL.Reg)&^(0x80000)|value<<19)
}
func (o *PIO0_Type) GetSM1_SHIFTCTRL_OUT_SHIFTDIR() uint32 {
	return (volatile.LoadUint32(&o.SM1_SHIFTCTRL.Reg) & 0x80000) >> 19
}
func (o *PIO0_Type) SetSM1_SHIFTCTRL_IN_SHIFTDIR(value uint32) {
	volatile.StoreUint32(&o.SM1_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM1_SHIFTCTRL.Reg)&^(0x40000)|value<<18)
}
func (o *PIO0_Type) GetSM1_SHIFTCTRL_IN_SHIFTDIR() uint32 {
	return (volatile.LoadUint32(&o.SM1_SHIFTCTRL.Reg) & 0x40000) >> 18
}
func (o *PIO0_Type) SetSM1_SHIFTCTRL_AUTOPULL(value uint32) {
	volatile.StoreUint32(&o.SM1_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM1_SHIFTCTRL.Reg)&^(0x20000)|value<<17)
}
func (o *PIO0_Type) GetSM1_SHIFTCTRL_AUTOPULL() uint32 {
	return (volatile.LoadUint32(&o.SM1_SHIFTCTRL.Reg) & 0x20000) >> 17
}
func (o *PIO0_Type) SetSM1_SHIFTCTRL_AUTOPUSH(value uint32) {
	volatile.StoreUint32(&o.SM1_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM1_SHIFTCTRL.Reg)&^(0x10000)|value<<16)
}
func (o *PIO0_Type) GetSM1_SHIFTCTRL_AUTOPUSH() uint32 {
	return (volatile.LoadUint32(&o.SM1_SHIFTCTRL.Reg) & 0x10000) >> 16
}

// PIO0.SM1_ADDR: Current instruction address of state machine 1
func (o *PIO0_Type) SetSM1_ADDR(value uint32) {
	volatile.StoreUint32(&o.SM1_ADDR.Reg, volatile.LoadUint32(&o.SM1_ADDR.Reg)&^(0x1f)|value)
}
func (o *PIO0_Type) GetSM1_ADDR() uint32 {
	return volatile.LoadUint32(&o.SM1_ADDR.Reg) & 0x1f
}

// PIO0.SM1_INSTR
// Instruction currently being executed by state machine 1
// Write to execute an instruction immediately (including jumps) and then resume execution.
func (o *PIO0_Type) SetSM1_INSTR(value uint32) {
	volatile.StoreUint32(&o.SM1_INSTR.Reg, volatile.LoadUint32(&o.SM1_INSTR.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetSM1_INSTR() uint32 {
	return volatile.LoadUint32(&o.SM1_INSTR.Reg) & 0xffff
}

// PIO0.SM1_PINCTRL: State machine pin control
func (o *PIO0_Type) SetSM1_PINCTRL_SIDESET_COUNT(value uint32) {
	volatile.StoreUint32(&o.SM1_PINCTRL.Reg, volatile.LoadUint32(&o.SM1_PINCTRL.Reg)&^(0xe0000000)|value<<29)
}
func (o *PIO0_Type) GetSM1_PINCTRL_SIDESET_COUNT() uint32 {
	return (volatile.LoadUint32(&o.SM1_PINCTRL.Reg) & 0xe0000000) >> 29
}
func (o *PIO0_Type) SetSM1_PINCTRL_SET_COUNT(value uint32) {
	volatile.StoreUint32(&o.SM1_PINCTRL.Reg, volatile.LoadUint32(&o.SM1_PINCTRL.Reg)&^(0x1c000000)|value<<26)
}
func (o *PIO0_Type) GetSM1_PINCTRL_SET_COUNT() uint32 {
	return (volatile.LoadUint32(&o.SM1_PINCTRL.Reg) & 0x1c000000) >> 26
}
func (o *PIO0_Type) SetSM1_PINCTRL_OUT_COUNT(value uint32) {
	volatile.StoreUint32(&o.SM1_PINCTRL.Reg, volatile.LoadUint32(&o.SM1_PINCTRL.Reg)&^(0x3f00000)|value<<20)
}
func (o *PIO0_Type) GetSM1_PINCTRL_OUT_COUNT() uint32 {
	return (volatile.LoadUint32(&o.SM1_PINCTRL.Reg) & 0x3f00000) >> 20
}
func (o *PIO0_Type) SetSM1_PINCTRL_IN_BASE(value uint32) {
	volatile.StoreUint32(&o.SM1_PINCTRL.Reg, volatile.LoadUint32(&o.SM1_PINCTRL.Reg)&^(0xf8000)|value<<15)
}
func (o *PIO0_Type) GetSM1_PINCTRL_IN_BASE() uint32 {
	return (volatile.LoadUint32(&o.SM1_PINCTRL.Reg) & 0xf8000) >> 15
}
func (o *PIO0_Type) SetSM1_PINCTRL_SIDESET_BASE(value uint32) {
	volatile.StoreUint32(&o.SM1_PINCTRL.Reg, volatile.LoadUint32(&o.SM1_PINCTRL.Reg)&^(0x7c00)|value<<10)
}
func (o *PIO0_Type) GetSM1_PINCTRL_SIDESET_BASE() uint32 {
	return (volatile.LoadUint32(&o.SM1_PINCTRL.Reg) & 0x7c00) >> 10
}
func (o *PIO0_Type) SetSM1_PINCTRL_SET_BASE(value uint32) {
	volatile.StoreUint32(&o.SM1_PINCTRL.Reg, volatile.LoadUint32(&o.SM1_PINCTRL.Reg)&^(0x3e0)|value<<5)
}
func (o *PIO0_Type) GetSM1_PINCTRL_SET_BASE() uint32 {
	return (volatile.LoadUint32(&o.SM1_PINCTRL.Reg) & 0x3e0) >> 5
}
func (o *PIO0_Type) SetSM1_PINCTRL_OUT_BASE(value uint32) {
	volatile.StoreUint32(&o.SM1_PINCTRL.Reg, volatile.LoadUint32(&o.SM1_PINCTRL.Reg)&^(0x1f)|value)
}
func (o *PIO0_Type) GetSM1_PINCTRL_OUT_BASE() uint32 {
	return volatile.LoadUint32(&o.SM1_PINCTRL.Reg) & 0x1f
}

// PIO0.SM2_CLKDIV
// Clock divider register for state machine 2
// Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
func (o *PIO0_Type) SetSM2_CLKDIV_INT(value uint32) {
	volatile.StoreUint32(&o.SM2_CLKDIV.Reg, volatile.LoadUint32(&o.SM2_CLKDIV.Reg)&^(0xffff0000)|value<<16)
}
func (o *PIO0_Type) GetSM2_CLKDIV_INT() uint32 {
	return (volatile.LoadUint32(&o.SM2_CLKDIV.Reg) & 0xffff0000) >> 16
}
func (o *PIO0_Type) SetSM2_CLKDIV_FRAC(value uint32) {
	volatile.StoreUint32(&o.SM2_CLKDIV.Reg, volatile.LoadUint32(&o.SM2_CLKDIV.Reg)&^(0xff00)|value<<8)
}
func (o *PIO0_Type) GetSM2_CLKDIV_FRAC() uint32 {
	return (volatile.LoadUint32(&o.SM2_CLKDIV.Reg) & 0xff00) >> 8
}

// PIO0.SM2_EXECCTRL: Execution/behavioural settings for state machine 2
func (o *PIO0_Type) SetSM2_EXECCTRL_EXEC_STALLED(value uint32) {
	volatile.StoreUint32(&o.SM2_EXECCTRL.Reg, volatile.LoadUint32(&o.SM2_EXECCTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO0_Type) GetSM2_EXECCTRL_EXEC_STALLED() uint32 {
	return (volatile.LoadUint32(&o.SM2_EXECCTRL.Reg) & 0x80000000) >> 31
}
func (o *PIO0_Type) SetSM2_EXECCTRL_SIDE_EN(value uint32) {
	volatile.StoreUint32(&o.SM2_EXECCTRL.Reg, volatile.LoadUint32(&o.SM2_EXECCTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO0_Type) GetSM2_EXECCTRL_SIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.SM2_EXECCTRL.Reg) & 0x40000000) >> 30
}
func (o *PIO0_Type) SetSM2_EXECCTRL_SIDE_PINDIR(value uint32) {
	volatile.StoreUint32(&o.SM2_EXECCTRL.Reg, volatile.LoadUint32(&o.SM2_EXECCTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO0_Type) GetSM2_EXECCTRL_SIDE_PINDIR() uint32 {
	return (volatile.LoadUint32(&o.SM2_EXECCTRL.Reg) & 0x20000000) >> 29
}
func (o *PIO0_Type) SetSM2_EXECCTRL_JMP_PIN(value uint32) {
	volatile.StoreUint32(&o.SM2_EXECCTRL.Reg, volatile.LoadUint32(&o.SM2_EXECCTRL.Reg)&^(0x1f000000)|value<<24)
}
func (o *PIO0_Type) GetSM2_EXECCTRL_JMP_PIN() uint32 {
	return (volatile.LoadUint32(&o.SM2_EXECCTRL.Reg) & 0x1f000000) >> 24
}
func (o *PIO0_Type) SetSM2_EXECCTRL_OUT_EN_SEL(value uint32) {
	volatile.StoreUint32(&o.SM2_EXECCTRL.Reg, volatile.LoadUint32(&o.SM2_EXECCTRL.Reg)&^(0xf80000)|value<<19)
}
func (o *PIO0_Type) GetSM2_EXECCTRL_OUT_EN_SEL() uint32 {
	return (volatile.LoadUint32(&o.SM2_EXECCTRL.Reg) & 0xf80000) >> 19
}
func (o *PIO0_Type) SetSM2_EXECCTRL_INLINE_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.SM2_EXECCTRL.Reg, volatile.LoadUint32(&o.SM2_EXECCTRL.Reg)&^(0x40000)|value<<18)
}
func (o *PIO0_Type) GetSM2_EXECCTRL_INLINE_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.SM2_EXECCTRL.Reg) & 0x40000) >> 18
}
func (o *PIO0_Type) SetSM2_EXECCTRL_OUT_STICKY(value uint32) {
	volatile.StoreUint32(&o.SM2_EXECCTRL.Reg, volatile.LoadUint32(&o.SM2_EXECCTRL.Reg)&^(0x20000)|value<<17)
}
func (o *PIO0_Type) GetSM2_EXECCTRL_OUT_STICKY() uint32 {
	return (volatile.LoadUint32(&o.SM2_EXECCTRL.Reg) & 0x20000) >> 17
}
func (o *PIO0_Type) SetSM2_EXECCTRL_WRAP_TOP(value uint32) {
	volatile.StoreUint32(&o.SM2_EXECCTRL.Reg, volatile.LoadUint32(&o.SM2_EXECCTRL.Reg)&^(0x1f000)|value<<12)
}
func (o *PIO0_Type) GetSM2_EXECCTRL_WRAP_TOP() uint32 {
	return (volatile.LoadUint32(&o.SM2_EXECCTRL.Reg) & 0x1f000) >> 12
}
func (o *PIO0_Type) SetSM2_EXECCTRL_WRAP_BOTTOM(value uint32) {
	volatile.StoreUint32(&o.SM2_EXECCTRL.Reg, volatile.LoadUint32(&o.SM2_EXECCTRL.Reg)&^(0xf80)|value<<7)
}
func (o *PIO0_Type) GetSM2_EXECCTRL_WRAP_BOTTOM() uint32 {
	return (volatile.LoadUint32(&o.SM2_EXECCTRL.Reg) & 0xf80) >> 7
}
func (o *PIO0_Type) SetSM2_EXECCTRL_STATUS_SEL(value uint32) {
	volatile.StoreUint32(&o.SM2_EXECCTRL.Reg, volatile.LoadUint32(&o.SM2_EXECCTRL.Reg)&^(0x10)|value<<4)
}
func (o *PIO0_Type) GetSM2_EXECCTRL_STATUS_SEL() uint32 {
	return (volatile.LoadUint32(&o.SM2_EXECCTRL.Reg) & 0x10) >> 4
}
func (o *PIO0_Type) SetSM2_EXECCTRL_STATUS_N(value uint32) {
	volatile.StoreUint32(&o.SM2_EXECCTRL.Reg, volatile.LoadUint32(&o.SM2_EXECCTRL.Reg)&^(0xf)|value)
}
func (o *PIO0_Type) GetSM2_EXECCTRL_STATUS_N() uint32 {
	return volatile.LoadUint32(&o.SM2_EXECCTRL.Reg) & 0xf
}

// PIO0.SM2_SHIFTCTRL: Control behaviour of the input/output shift registers for state machine 2
func (o *PIO0_Type) SetSM2_SHIFTCTRL_FJOIN_RX(value uint32) {
	volatile.StoreUint32(&o.SM2_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM2_SHIFTCTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO0_Type) GetSM2_SHIFTCTRL_FJOIN_RX() uint32 {
	return (volatile.LoadUint32(&o.SM2_SHIFTCTRL.Reg) & 0x80000000) >> 31
}
func (o *PIO0_Type) SetSM2_SHIFTCTRL_FJOIN_TX(value uint32) {
	volatile.StoreUint32(&o.SM2_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM2_SHIFTCTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO0_Type) GetSM2_SHIFTCTRL_FJOIN_TX() uint32 {
	return (volatile.LoadUint32(&o.SM2_SHIFTCTRL.Reg) & 0x40000000) >> 30
}
func (o *PIO0_Type) SetSM2_SHIFTCTRL_PULL_THRESH(value uint32) {
	volatile.StoreUint32(&o.SM2_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM2_SHIFTCTRL.Reg)&^(0x3e000000)|value<<25)
}
func (o *PIO0_Type) GetSM2_SHIFTCTRL_PULL_THRESH() uint32 {
	return (volatile.LoadUint32(&o.SM2_SHIFTCTRL.Reg) & 0x3e000000) >> 25
}
func (o *PIO0_Type) SetSM2_SHIFTCTRL_PUSH_THRESH(value uint32) {
	volatile.StoreUint32(&o.SM2_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM2_SHIFTCTRL.Reg)&^(0x1f00000)|value<<20)
}
func (o *PIO0_Type) GetSM2_SHIFTCTRL_PUSH_THRESH() uint32 {
	return (volatile.LoadUint32(&o.SM2_SHIFTCTRL.Reg) & 0x1f00000) >> 20
}
func (o *PIO0_Type) SetSM2_SHIFTCTRL_OUT_SHIFTDIR(value uint32) {
	volatile.StoreUint32(&o.SM2_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM2_SHIFTCTRL.Reg)&^(0x80000)|value<<19)
}
func (o *PIO0_Type) GetSM2_SHIFTCTRL_OUT_SHIFTDIR() uint32 {
	return (volatile.LoadUint32(&o.SM2_SHIFTCTRL.Reg) & 0x80000) >> 19
}
func (o *PIO0_Type) SetSM2_SHIFTCTRL_IN_SHIFTDIR(value uint32) {
	volatile.StoreUint32(&o.SM2_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM2_SHIFTCTRL.Reg)&^(0x40000)|value<<18)
}
func (o *PIO0_Type) GetSM2_SHIFTCTRL_IN_SHIFTDIR() uint32 {
	return (volatile.LoadUint32(&o.SM2_SHIFTCTRL.Reg) & 0x40000) >> 18
}
func (o *PIO0_Type) SetSM2_SHIFTCTRL_AUTOPULL(value uint32) {
	volatile.StoreUint32(&o.SM2_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM2_SHIFTCTRL.Reg)&^(0x20000)|value<<17)
}
func (o *PIO0_Type) GetSM2_SHIFTCTRL_AUTOPULL() uint32 {
	return (volatile.LoadUint32(&o.SM2_SHIFTCTRL.Reg) & 0x20000) >> 17
}
func (o *PIO0_Type) SetSM2_SHIFTCTRL_AUTOPUSH(value uint32) {
	volatile.StoreUint32(&o.SM2_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM2_SHIFTCTRL.Reg)&^(0x10000)|value<<16)
}
func (o *PIO0_Type) GetSM2_SHIFTCTRL_AUTOPUSH() uint32 {
	return (volatile.LoadUint32(&o.SM2_SHIFTCTRL.Reg) & 0x10000) >> 16
}

// PIO0.SM2_ADDR: Current instruction address of state machine 2
func (o *PIO0_Type) SetSM2_ADDR(value uint32) {
	volatile.StoreUint32(&o.SM2_ADDR.Reg, volatile.LoadUint32(&o.SM2_ADDR.Reg)&^(0x1f)|value)
}
func (o *PIO0_Type) GetSM2_ADDR() uint32 {
	return volatile.LoadUint32(&o.SM2_ADDR.Reg) & 0x1f
}

// PIO0.SM2_INSTR
// Instruction currently being executed by state machine 2
// Write to execute an instruction immediately (including jumps) and then resume execution.
func (o *PIO0_Type) SetSM2_INSTR(value uint32) {
	volatile.StoreUint32(&o.SM2_INSTR.Reg, volatile.LoadUint32(&o.SM2_INSTR.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetSM2_INSTR() uint32 {
	return volatile.LoadUint32(&o.SM2_INSTR.Reg) & 0xffff
}

// PIO0.SM2_PINCTRL: State machine pin control
func (o *PIO0_Type) SetSM2_PINCTRL_SIDESET_COUNT(value uint32) {
	volatile.StoreUint32(&o.SM2_PINCTRL.Reg, volatile.LoadUint32(&o.SM2_PINCTRL.Reg)&^(0xe0000000)|value<<29)
}
func (o *PIO0_Type) GetSM2_PINCTRL_SIDESET_COUNT() uint32 {
	return (volatile.LoadUint32(&o.SM2_PINCTRL.Reg) & 0xe0000000) >> 29
}
func (o *PIO0_Type) SetSM2_PINCTRL_SET_COUNT(value uint32) {
	volatile.StoreUint32(&o.SM2_PINCTRL.Reg, volatile.LoadUint32(&o.SM2_PINCTRL.Reg)&^(0x1c000000)|value<<26)
}
func (o *PIO0_Type) GetSM2_PINCTRL_SET_COUNT() uint32 {
	return (volatile.LoadUint32(&o.SM2_PINCTRL.Reg) & 0x1c000000) >> 26
}
func (o *PIO0_Type) SetSM2_PINCTRL_OUT_COUNT(value uint32) {
	volatile.StoreUint32(&o.SM2_PINCTRL.Reg, volatile.LoadUint32(&o.SM2_PINCTRL.Reg)&^(0x3f00000)|value<<20)
}
func (o *PIO0_Type) GetSM2_PINCTRL_OUT_COUNT() uint32 {
	return (volatile.LoadUint32(&o.SM2_PINCTRL.Reg) & 0x3f00000) >> 20
}
func (o *PIO0_Type) SetSM2_PINCTRL_IN_BASE(value uint32) {
	volatile.StoreUint32(&o.SM2_PINCTRL.Reg, volatile.LoadUint32(&o.SM2_PINCTRL.Reg)&^(0xf8000)|value<<15)
}
func (o *PIO0_Type) GetSM2_PINCTRL_IN_BASE() uint32 {
	return (volatile.LoadUint32(&o.SM2_PINCTRL.Reg) & 0xf8000) >> 15
}
func (o *PIO0_Type) SetSM2_PINCTRL_SIDESET_BASE(value uint32) {
	volatile.StoreUint32(&o.SM2_PINCTRL.Reg, volatile.LoadUint32(&o.SM2_PINCTRL.Reg)&^(0x7c00)|value<<10)
}
func (o *PIO0_Type) GetSM2_PINCTRL_SIDESET_BASE() uint32 {
	return (volatile.LoadUint32(&o.SM2_PINCTRL.Reg) & 0x7c00) >> 10
}
func (o *PIO0_Type) SetSM2_PINCTRL_SET_BASE(value uint32) {
	volatile.StoreUint32(&o.SM2_PINCTRL.Reg, volatile.LoadUint32(&o.SM2_PINCTRL.Reg)&^(0x3e0)|value<<5)
}
func (o *PIO0_Type) GetSM2_PINCTRL_SET_BASE() uint32 {
	return (volatile.LoadUint32(&o.SM2_PINCTRL.Reg) & 0x3e0) >> 5
}
func (o *PIO0_Type) SetSM2_PINCTRL_OUT_BASE(value uint32) {
	volatile.StoreUint32(&o.SM2_PINCTRL.Reg, volatile.LoadUint32(&o.SM2_PINCTRL.Reg)&^(0x1f)|value)
}
func (o *PIO0_Type) GetSM2_PINCTRL_OUT_BASE() uint32 {
	return volatile.LoadUint32(&o.SM2_PINCTRL.Reg) & 0x1f
}

// PIO0.SM3_CLKDIV
// Clock divider register for state machine 3
// Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
func (o *PIO0_Type) SetSM3_CLKDIV_INT(value uint32) {
	volatile.StoreUint32(&o.SM3_CLKDIV.Reg, volatile.LoadUint32(&o.SM3_CLKDIV.Reg)&^(0xffff0000)|value<<16)
}
func (o *PIO0_Type) GetSM3_CLKDIV_INT() uint32 {
	return (volatile.LoadUint32(&o.SM3_CLKDIV.Reg) & 0xffff0000) >> 16
}
func (o *PIO0_Type) SetSM3_CLKDIV_FRAC(value uint32) {
	volatile.StoreUint32(&o.SM3_CLKDIV.Reg, volatile.LoadUint32(&o.SM3_CLKDIV.Reg)&^(0xff00)|value<<8)
}
func (o *PIO0_Type) GetSM3_CLKDIV_FRAC() uint32 {
	return (volatile.LoadUint32(&o.SM3_CLKDIV.Reg) & 0xff00) >> 8
}

// PIO0.SM3_EXECCTRL: Execution/behavioural settings for state machine 3
func (o *PIO0_Type) SetSM3_EXECCTRL_EXEC_STALLED(value uint32) {
	volatile.StoreUint32(&o.SM3_EXECCTRL.Reg, volatile.LoadUint32(&o.SM3_EXECCTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO0_Type) GetSM3_EXECCTRL_EXEC_STALLED() uint32 {
	return (volatile.LoadUint32(&o.SM3_EXECCTRL.Reg) & 0x80000000) >> 31
}
func (o *PIO0_Type) SetSM3_EXECCTRL_SIDE_EN(value uint32) {
	volatile.StoreUint32(&o.SM3_EXECCTRL.Reg, volatile.LoadUint32(&o.SM3_EXECCTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO0_Type) GetSM3_EXECCTRL_SIDE_EN() uint32 {
	return (volatile.LoadUint32(&o.SM3_EXECCTRL.Reg) & 0x40000000) >> 30
}
func (o *PIO0_Type) SetSM3_EXECCTRL_SIDE_PINDIR(value uint32) {
	volatile.StoreUint32(&o.SM3_EXECCTRL.Reg, volatile.LoadUint32(&o.SM3_EXECCTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *PIO0_Type) GetSM3_EXECCTRL_SIDE_PINDIR() uint32 {
	return (volatile.LoadUint32(&o.SM3_EXECCTRL.Reg) & 0x20000000) >> 29
}
func (o *PIO0_Type) SetSM3_EXECCTRL_JMP_PIN(value uint32) {
	volatile.StoreUint32(&o.SM3_EXECCTRL.Reg, volatile.LoadUint32(&o.SM3_EXECCTRL.Reg)&^(0x1f000000)|value<<24)
}
func (o *PIO0_Type) GetSM3_EXECCTRL_JMP_PIN() uint32 {
	return (volatile.LoadUint32(&o.SM3_EXECCTRL.Reg) & 0x1f000000) >> 24
}
func (o *PIO0_Type) SetSM3_EXECCTRL_OUT_EN_SEL(value uint32) {
	volatile.StoreUint32(&o.SM3_EXECCTRL.Reg, volatile.LoadUint32(&o.SM3_EXECCTRL.Reg)&^(0xf80000)|value<<19)
}
func (o *PIO0_Type) GetSM3_EXECCTRL_OUT_EN_SEL() uint32 {
	return (volatile.LoadUint32(&o.SM3_EXECCTRL.Reg) & 0xf80000) >> 19
}
func (o *PIO0_Type) SetSM3_EXECCTRL_INLINE_OUT_EN(value uint32) {
	volatile.StoreUint32(&o.SM3_EXECCTRL.Reg, volatile.LoadUint32(&o.SM3_EXECCTRL.Reg)&^(0x40000)|value<<18)
}
func (o *PIO0_Type) GetSM3_EXECCTRL_INLINE_OUT_EN() uint32 {
	return (volatile.LoadUint32(&o.SM3_EXECCTRL.Reg) & 0x40000) >> 18
}
func (o *PIO0_Type) SetSM3_EXECCTRL_OUT_STICKY(value uint32) {
	volatile.StoreUint32(&o.SM3_EXECCTRL.Reg, volatile.LoadUint32(&o.SM3_EXECCTRL.Reg)&^(0x20000)|value<<17)
}
func (o *PIO0_Type) GetSM3_EXECCTRL_OUT_STICKY() uint32 {
	return (volatile.LoadUint32(&o.SM3_EXECCTRL.Reg) & 0x20000) >> 17
}
func (o *PIO0_Type) SetSM3_EXECCTRL_WRAP_TOP(value uint32) {
	volatile.StoreUint32(&o.SM3_EXECCTRL.Reg, volatile.LoadUint32(&o.SM3_EXECCTRL.Reg)&^(0x1f000)|value<<12)
}
func (o *PIO0_Type) GetSM3_EXECCTRL_WRAP_TOP() uint32 {
	return (volatile.LoadUint32(&o.SM3_EXECCTRL.Reg) & 0x1f000) >> 12
}
func (o *PIO0_Type) SetSM3_EXECCTRL_WRAP_BOTTOM(value uint32) {
	volatile.StoreUint32(&o.SM3_EXECCTRL.Reg, volatile.LoadUint32(&o.SM3_EXECCTRL.Reg)&^(0xf80)|value<<7)
}
func (o *PIO0_Type) GetSM3_EXECCTRL_WRAP_BOTTOM() uint32 {
	return (volatile.LoadUint32(&o.SM3_EXECCTRL.Reg) & 0xf80) >> 7
}
func (o *PIO0_Type) SetSM3_EXECCTRL_STATUS_SEL(value uint32) {
	volatile.StoreUint32(&o.SM3_EXECCTRL.Reg, volatile.LoadUint32(&o.SM3_EXECCTRL.Reg)&^(0x10)|value<<4)
}
func (o *PIO0_Type) GetSM3_EXECCTRL_STATUS_SEL() uint32 {
	return (volatile.LoadUint32(&o.SM3_EXECCTRL.Reg) & 0x10) >> 4
}
func (o *PIO0_Type) SetSM3_EXECCTRL_STATUS_N(value uint32) {
	volatile.StoreUint32(&o.SM3_EXECCTRL.Reg, volatile.LoadUint32(&o.SM3_EXECCTRL.Reg)&^(0xf)|value)
}
func (o *PIO0_Type) GetSM3_EXECCTRL_STATUS_N() uint32 {
	return volatile.LoadUint32(&o.SM3_EXECCTRL.Reg) & 0xf
}

// PIO0.SM3_SHIFTCTRL: Control behaviour of the input/output shift registers for state machine 3
func (o *PIO0_Type) SetSM3_SHIFTCTRL_FJOIN_RX(value uint32) {
	volatile.StoreUint32(&o.SM3_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM3_SHIFTCTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *PIO0_Type) GetSM3_SHIFTCTRL_FJOIN_RX() uint32 {
	return (volatile.LoadUint32(&o.SM3_SHIFTCTRL.Reg) & 0x80000000) >> 31
}
func (o *PIO0_Type) SetSM3_SHIFTCTRL_FJOIN_TX(value uint32) {
	volatile.StoreUint32(&o.SM3_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM3_SHIFTCTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *PIO0_Type) GetSM3_SHIFTCTRL_FJOIN_TX() uint32 {
	return (volatile.LoadUint32(&o.SM3_SHIFTCTRL.Reg) & 0x40000000) >> 30
}
func (o *PIO0_Type) SetSM3_SHIFTCTRL_PULL_THRESH(value uint32) {
	volatile.StoreUint32(&o.SM3_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM3_SHIFTCTRL.Reg)&^(0x3e000000)|value<<25)
}
func (o *PIO0_Type) GetSM3_SHIFTCTRL_PULL_THRESH() uint32 {
	return (volatile.LoadUint32(&o.SM3_SHIFTCTRL.Reg) & 0x3e000000) >> 25
}
func (o *PIO0_Type) SetSM3_SHIFTCTRL_PUSH_THRESH(value uint32) {
	volatile.StoreUint32(&o.SM3_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM3_SHIFTCTRL.Reg)&^(0x1f00000)|value<<20)
}
func (o *PIO0_Type) GetSM3_SHIFTCTRL_PUSH_THRESH() uint32 {
	return (volatile.LoadUint32(&o.SM3_SHIFTCTRL.Reg) & 0x1f00000) >> 20
}
func (o *PIO0_Type) SetSM3_SHIFTCTRL_OUT_SHIFTDIR(value uint32) {
	volatile.StoreUint32(&o.SM3_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM3_SHIFTCTRL.Reg)&^(0x80000)|value<<19)
}
func (o *PIO0_Type) GetSM3_SHIFTCTRL_OUT_SHIFTDIR() uint32 {
	return (volatile.LoadUint32(&o.SM3_SHIFTCTRL.Reg) & 0x80000) >> 19
}
func (o *PIO0_Type) SetSM3_SHIFTCTRL_IN_SHIFTDIR(value uint32) {
	volatile.StoreUint32(&o.SM3_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM3_SHIFTCTRL.Reg)&^(0x40000)|value<<18)
}
func (o *PIO0_Type) GetSM3_SHIFTCTRL_IN_SHIFTDIR() uint32 {
	return (volatile.LoadUint32(&o.SM3_SHIFTCTRL.Reg) & 0x40000) >> 18
}
func (o *PIO0_Type) SetSM3_SHIFTCTRL_AUTOPULL(value uint32) {
	volatile.StoreUint32(&o.SM3_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM3_SHIFTCTRL.Reg)&^(0x20000)|value<<17)
}
func (o *PIO0_Type) GetSM3_SHIFTCTRL_AUTOPULL() uint32 {
	return (volatile.LoadUint32(&o.SM3_SHIFTCTRL.Reg) & 0x20000) >> 17
}
func (o *PIO0_Type) SetSM3_SHIFTCTRL_AUTOPUSH(value uint32) {
	volatile.StoreUint32(&o.SM3_SHIFTCTRL.Reg, volatile.LoadUint32(&o.SM3_SHIFTCTRL.Reg)&^(0x10000)|value<<16)
}
func (o *PIO0_Type) GetSM3_SHIFTCTRL_AUTOPUSH() uint32 {
	return (volatile.LoadUint32(&o.SM3_SHIFTCTRL.Reg) & 0x10000) >> 16
}

// PIO0.SM3_ADDR: Current instruction address of state machine 3
func (o *PIO0_Type) SetSM3_ADDR(value uint32) {
	volatile.StoreUint32(&o.SM3_ADDR.Reg, volatile.LoadUint32(&o.SM3_ADDR.Reg)&^(0x1f)|value)
}
func (o *PIO0_Type) GetSM3_ADDR() uint32 {
	return volatile.LoadUint32(&o.SM3_ADDR.Reg) & 0x1f
}

// PIO0.SM3_INSTR
// Instruction currently being executed by state machine 3
// Write to execute an instruction immediately (including jumps) and then resume execution.
func (o *PIO0_Type) SetSM3_INSTR(value uint32) {
	volatile.StoreUint32(&o.SM3_INSTR.Reg, volatile.LoadUint32(&o.SM3_INSTR.Reg)&^(0xffff)|value)
}
func (o *PIO0_Type) GetSM3_INSTR() uint32 {
	return volatile.LoadUint32(&o.SM3_INSTR.Reg) & 0xffff
}

// PIO0.SM3_PINCTRL: State machine pin control
func (o *PIO0_Type) SetSM3_PINCTRL_SIDESET_COUNT(value uint32) {
	volatile.StoreUint32(&o.SM3_PINCTRL.Reg, volatile.LoadUint32(&o.SM3_PINCTRL.Reg)&^(0xe0000000)|value<<29)
}
func (o *PIO0_Type) GetSM3_PINCTRL_SIDESET_COUNT() uint32 {
	return (volatile.LoadUint32(&o.SM3_PINCTRL.Reg) & 0xe0000000) >> 29
}
func (o *PIO0_Type) SetSM3_PINCTRL_SET_COUNT(value uint32) {
	volatile.StoreUint32(&o.SM3_PINCTRL.Reg, volatile.LoadUint32(&o.SM3_PINCTRL.Reg)&^(0x1c000000)|value<<26)
}
func (o *PIO0_Type) GetSM3_PINCTRL_SET_COUNT() uint32 {
	return (volatile.LoadUint32(&o.SM3_PINCTRL.Reg) & 0x1c000000) >> 26
}
func (o *PIO0_Type) SetSM3_PINCTRL_OUT_COUNT(value uint32) {
	volatile.StoreUint32(&o.SM3_PINCTRL.Reg, volatile.LoadUint32(&o.SM3_PINCTRL.Reg)&^(0x3f00000)|value<<20)
}
func (o *PIO0_Type) GetSM3_PINCTRL_OUT_COUNT() uint32 {
	return (volatile.LoadUint32(&o.SM3_PINCTRL.Reg) & 0x3f00000) >> 20
}
func (o *PIO0_Type) SetSM3_PINCTRL_IN_BASE(value uint32) {
	volatile.StoreUint32(&o.SM3_PINCTRL.Reg, volatile.LoadUint32(&o.SM3_PINCTRL.Reg)&^(0xf8000)|value<<15)
}
func (o *PIO0_Type) GetSM3_PINCTRL_IN_BASE() uint32 {
	return (volatile.LoadUint32(&o.SM3_PINCTRL.Reg) & 0xf8000) >> 15
}
func (o *PIO0_Type) SetSM3_PINCTRL_SIDESET_BASE(value uint32) {
	volatile.StoreUint32(&o.SM3_PINCTRL.Reg, volatile.LoadUint32(&o.SM3_PINCTRL.Reg)&^(0x7c00)|value<<10)
}
func (o *PIO0_Type) GetSM3_PINCTRL_SIDESET_BASE() uint32 {
	return (volatile.LoadUint32(&o.SM3_PINCTRL.Reg) & 0x7c00) >> 10
}
func (o *PIO0_Type) SetSM3_PINCTRL_SET_BASE(value uint32) {
	volatile.StoreUint32(&o.SM3_PINCTRL.Reg, volatile.LoadUint32(&o.SM3_PINCTRL.Reg)&^(0x3e0)|value<<5)
}
func (o *PIO0_Type) GetSM3_PINCTRL_SET_BASE() uint32 {
	return (volatile.LoadUint32(&o.SM3_PINCTRL.Reg) & 0x3e0) >> 5
}
func (o *PIO0_Type) SetSM3_PINCTRL_OUT_BASE(value uint32) {
	volatile.StoreUint32(&o.SM3_PINCTRL.Reg, volatile.LoadUint32(&o.SM3_PINCTRL.Reg)&^(0x1f)|value)
}
func (o *PIO0_Type) GetSM3_PINCTRL_OUT_BASE() uint32 {
	return volatile.LoadUint32(&o.SM3_PINCTRL.Reg) & 0x1f
}

// PIO0.INTR: Raw Interrupts
func (o *PIO0_Type) SetINTR_SM3(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x800)|value<<11)
}
func (o *PIO0_Type) GetINTR_SM3() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x800) >> 11
}
func (o *PIO0_Type) SetINTR_SM2(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x400)|value<<10)
}
func (o *PIO0_Type) GetINTR_SM2() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x400) >> 10
}
func (o *PIO0_Type) SetINTR_SM1(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x200)|value<<9)
}
func (o *PIO0_Type) GetINTR_SM1() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x200) >> 9
}
func (o *PIO0_Type) SetINTR_SM0(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x100)|value<<8)
}
func (o *PIO0_Type) GetINTR_SM0() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x100) >> 8
}
func (o *PIO0_Type) SetINTR_SM3_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x80)|value<<7)
}
func (o *PIO0_Type) GetINTR_SM3_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x80) >> 7
}
func (o *PIO0_Type) SetINTR_SM2_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x40)|value<<6)
}
func (o *PIO0_Type) GetINTR_SM2_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x40) >> 6
}
func (o *PIO0_Type) SetINTR_SM1_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x20)|value<<5)
}
func (o *PIO0_Type) GetINTR_SM1_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x20) >> 5
}
func (o *PIO0_Type) SetINTR_SM0_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x10)|value<<4)
}
func (o *PIO0_Type) GetINTR_SM0_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x10) >> 4
}
func (o *PIO0_Type) SetINTR_SM3_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x8)|value<<3)
}
func (o *PIO0_Type) GetINTR_SM3_RXNEMPTY() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x8) >> 3
}
func (o *PIO0_Type) SetINTR_SM2_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x4)|value<<2)
}
func (o *PIO0_Type) GetINTR_SM2_RXNEMPTY() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x4) >> 2
}
func (o *PIO0_Type) SetINTR_SM1_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x2)|value<<1)
}
func (o *PIO0_Type) GetINTR_SM1_RXNEMPTY() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x2) >> 1
}
func (o *PIO0_Type) SetINTR_SM0_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x1)|value)
}
func (o *PIO0_Type) GetINTR_SM0_RXNEMPTY() uint32 {
	return volatile.LoadUint32(&o.INTR.Reg) & 0x1
}

// PIO0.IRQ0_INTE: Interrupt Enable for irq0
func (o *PIO0_Type) SetIRQ0_INTE_SM3(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTE.Reg, volatile.LoadUint32(&o.IRQ0_INTE.Reg)&^(0x800)|value<<11)
}
func (o *PIO0_Type) GetIRQ0_INTE_SM3() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTE.Reg) & 0x800) >> 11
}
func (o *PIO0_Type) SetIRQ0_INTE_SM2(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTE.Reg, volatile.LoadUint32(&o.IRQ0_INTE.Reg)&^(0x400)|value<<10)
}
func (o *PIO0_Type) GetIRQ0_INTE_SM2() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTE.Reg) & 0x400) >> 10
}
func (o *PIO0_Type) SetIRQ0_INTE_SM1(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTE.Reg, volatile.LoadUint32(&o.IRQ0_INTE.Reg)&^(0x200)|value<<9)
}
func (o *PIO0_Type) GetIRQ0_INTE_SM1() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTE.Reg) & 0x200) >> 9
}
func (o *PIO0_Type) SetIRQ0_INTE_SM0(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTE.Reg, volatile.LoadUint32(&o.IRQ0_INTE.Reg)&^(0x100)|value<<8)
}
func (o *PIO0_Type) GetIRQ0_INTE_SM0() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTE.Reg) & 0x100) >> 8
}
func (o *PIO0_Type) SetIRQ0_INTE_SM3_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTE.Reg, volatile.LoadUint32(&o.IRQ0_INTE.Reg)&^(0x80)|value<<7)
}
func (o *PIO0_Type) GetIRQ0_INTE_SM3_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTE.Reg) & 0x80) >> 7
}
func (o *PIO0_Type) SetIRQ0_INTE_SM2_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTE.Reg, volatile.LoadUint32(&o.IRQ0_INTE.Reg)&^(0x40)|value<<6)
}
func (o *PIO0_Type) GetIRQ0_INTE_SM2_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTE.Reg) & 0x40) >> 6
}
func (o *PIO0_Type) SetIRQ0_INTE_SM1_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTE.Reg, volatile.LoadUint32(&o.IRQ0_INTE.Reg)&^(0x20)|value<<5)
}
func (o *PIO0_Type) GetIRQ0_INTE_SM1_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTE.Reg) & 0x20) >> 5
}
func (o *PIO0_Type) SetIRQ0_INTE_SM0_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTE.Reg, volatile.LoadUint32(&o.IRQ0_INTE.Reg)&^(0x10)|value<<4)
}
func (o *PIO0_Type) GetIRQ0_INTE_SM0_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTE.Reg) & 0x10) >> 4
}
func (o *PIO0_Type) SetIRQ0_INTE_SM3_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTE.Reg, volatile.LoadUint32(&o.IRQ0_INTE.Reg)&^(0x8)|value<<3)
}
func (o *PIO0_Type) GetIRQ0_INTE_SM3_RXNEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTE.Reg) & 0x8) >> 3
}
func (o *PIO0_Type) SetIRQ0_INTE_SM2_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTE.Reg, volatile.LoadUint32(&o.IRQ0_INTE.Reg)&^(0x4)|value<<2)
}
func (o *PIO0_Type) GetIRQ0_INTE_SM2_RXNEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTE.Reg) & 0x4) >> 2
}
func (o *PIO0_Type) SetIRQ0_INTE_SM1_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTE.Reg, volatile.LoadUint32(&o.IRQ0_INTE.Reg)&^(0x2)|value<<1)
}
func (o *PIO0_Type) GetIRQ0_INTE_SM1_RXNEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTE.Reg) & 0x2) >> 1
}
func (o *PIO0_Type) SetIRQ0_INTE_SM0_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTE.Reg, volatile.LoadUint32(&o.IRQ0_INTE.Reg)&^(0x1)|value)
}
func (o *PIO0_Type) GetIRQ0_INTE_SM0_RXNEMPTY() uint32 {
	return volatile.LoadUint32(&o.IRQ0_INTE.Reg) & 0x1
}

// PIO0.IRQ0_INTF: Interrupt Force for irq0
func (o *PIO0_Type) SetIRQ0_INTF_SM3(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTF.Reg, volatile.LoadUint32(&o.IRQ0_INTF.Reg)&^(0x800)|value<<11)
}
func (o *PIO0_Type) GetIRQ0_INTF_SM3() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTF.Reg) & 0x800) >> 11
}
func (o *PIO0_Type) SetIRQ0_INTF_SM2(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTF.Reg, volatile.LoadUint32(&o.IRQ0_INTF.Reg)&^(0x400)|value<<10)
}
func (o *PIO0_Type) GetIRQ0_INTF_SM2() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTF.Reg) & 0x400) >> 10
}
func (o *PIO0_Type) SetIRQ0_INTF_SM1(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTF.Reg, volatile.LoadUint32(&o.IRQ0_INTF.Reg)&^(0x200)|value<<9)
}
func (o *PIO0_Type) GetIRQ0_INTF_SM1() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTF.Reg) & 0x200) >> 9
}
func (o *PIO0_Type) SetIRQ0_INTF_SM0(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTF.Reg, volatile.LoadUint32(&o.IRQ0_INTF.Reg)&^(0x100)|value<<8)
}
func (o *PIO0_Type) GetIRQ0_INTF_SM0() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTF.Reg) & 0x100) >> 8
}
func (o *PIO0_Type) SetIRQ0_INTF_SM3_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTF.Reg, volatile.LoadUint32(&o.IRQ0_INTF.Reg)&^(0x80)|value<<7)
}
func (o *PIO0_Type) GetIRQ0_INTF_SM3_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTF.Reg) & 0x80) >> 7
}
func (o *PIO0_Type) SetIRQ0_INTF_SM2_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTF.Reg, volatile.LoadUint32(&o.IRQ0_INTF.Reg)&^(0x40)|value<<6)
}
func (o *PIO0_Type) GetIRQ0_INTF_SM2_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTF.Reg) & 0x40) >> 6
}
func (o *PIO0_Type) SetIRQ0_INTF_SM1_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTF.Reg, volatile.LoadUint32(&o.IRQ0_INTF.Reg)&^(0x20)|value<<5)
}
func (o *PIO0_Type) GetIRQ0_INTF_SM1_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTF.Reg) & 0x20) >> 5
}
func (o *PIO0_Type) SetIRQ0_INTF_SM0_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTF.Reg, volatile.LoadUint32(&o.IRQ0_INTF.Reg)&^(0x10)|value<<4)
}
func (o *PIO0_Type) GetIRQ0_INTF_SM0_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTF.Reg) & 0x10) >> 4
}
func (o *PIO0_Type) SetIRQ0_INTF_SM3_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTF.Reg, volatile.LoadUint32(&o.IRQ0_INTF.Reg)&^(0x8)|value<<3)
}
func (o *PIO0_Type) GetIRQ0_INTF_SM3_RXNEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTF.Reg) & 0x8) >> 3
}
func (o *PIO0_Type) SetIRQ0_INTF_SM2_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTF.Reg, volatile.LoadUint32(&o.IRQ0_INTF.Reg)&^(0x4)|value<<2)
}
func (o *PIO0_Type) GetIRQ0_INTF_SM2_RXNEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTF.Reg) & 0x4) >> 2
}
func (o *PIO0_Type) SetIRQ0_INTF_SM1_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTF.Reg, volatile.LoadUint32(&o.IRQ0_INTF.Reg)&^(0x2)|value<<1)
}
func (o *PIO0_Type) GetIRQ0_INTF_SM1_RXNEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTF.Reg) & 0x2) >> 1
}
func (o *PIO0_Type) SetIRQ0_INTF_SM0_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTF.Reg, volatile.LoadUint32(&o.IRQ0_INTF.Reg)&^(0x1)|value)
}
func (o *PIO0_Type) GetIRQ0_INTF_SM0_RXNEMPTY() uint32 {
	return volatile.LoadUint32(&o.IRQ0_INTF.Reg) & 0x1
}

// PIO0.IRQ0_INTS: Interrupt status after masking & forcing for irq0
func (o *PIO0_Type) SetIRQ0_INTS_SM3(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTS.Reg, volatile.LoadUint32(&o.IRQ0_INTS.Reg)&^(0x800)|value<<11)
}
func (o *PIO0_Type) GetIRQ0_INTS_SM3() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTS.Reg) & 0x800) >> 11
}
func (o *PIO0_Type) SetIRQ0_INTS_SM2(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTS.Reg, volatile.LoadUint32(&o.IRQ0_INTS.Reg)&^(0x400)|value<<10)
}
func (o *PIO0_Type) GetIRQ0_INTS_SM2() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTS.Reg) & 0x400) >> 10
}
func (o *PIO0_Type) SetIRQ0_INTS_SM1(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTS.Reg, volatile.LoadUint32(&o.IRQ0_INTS.Reg)&^(0x200)|value<<9)
}
func (o *PIO0_Type) GetIRQ0_INTS_SM1() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTS.Reg) & 0x200) >> 9
}
func (o *PIO0_Type) SetIRQ0_INTS_SM0(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTS.Reg, volatile.LoadUint32(&o.IRQ0_INTS.Reg)&^(0x100)|value<<8)
}
func (o *PIO0_Type) GetIRQ0_INTS_SM0() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTS.Reg) & 0x100) >> 8
}
func (o *PIO0_Type) SetIRQ0_INTS_SM3_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTS.Reg, volatile.LoadUint32(&o.IRQ0_INTS.Reg)&^(0x80)|value<<7)
}
func (o *PIO0_Type) GetIRQ0_INTS_SM3_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTS.Reg) & 0x80) >> 7
}
func (o *PIO0_Type) SetIRQ0_INTS_SM2_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTS.Reg, volatile.LoadUint32(&o.IRQ0_INTS.Reg)&^(0x40)|value<<6)
}
func (o *PIO0_Type) GetIRQ0_INTS_SM2_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTS.Reg) & 0x40) >> 6
}
func (o *PIO0_Type) SetIRQ0_INTS_SM1_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTS.Reg, volatile.LoadUint32(&o.IRQ0_INTS.Reg)&^(0x20)|value<<5)
}
func (o *PIO0_Type) GetIRQ0_INTS_SM1_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTS.Reg) & 0x20) >> 5
}
func (o *PIO0_Type) SetIRQ0_INTS_SM0_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTS.Reg, volatile.LoadUint32(&o.IRQ0_INTS.Reg)&^(0x10)|value<<4)
}
func (o *PIO0_Type) GetIRQ0_INTS_SM0_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTS.Reg) & 0x10) >> 4
}
func (o *PIO0_Type) SetIRQ0_INTS_SM3_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTS.Reg, volatile.LoadUint32(&o.IRQ0_INTS.Reg)&^(0x8)|value<<3)
}
func (o *PIO0_Type) GetIRQ0_INTS_SM3_RXNEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTS.Reg) & 0x8) >> 3
}
func (o *PIO0_Type) SetIRQ0_INTS_SM2_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTS.Reg, volatile.LoadUint32(&o.IRQ0_INTS.Reg)&^(0x4)|value<<2)
}
func (o *PIO0_Type) GetIRQ0_INTS_SM2_RXNEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTS.Reg) & 0x4) >> 2
}
func (o *PIO0_Type) SetIRQ0_INTS_SM1_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTS.Reg, volatile.LoadUint32(&o.IRQ0_INTS.Reg)&^(0x2)|value<<1)
}
func (o *PIO0_Type) GetIRQ0_INTS_SM1_RXNEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IRQ0_INTS.Reg) & 0x2) >> 1
}
func (o *PIO0_Type) SetIRQ0_INTS_SM0_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ0_INTS.Reg, volatile.LoadUint32(&o.IRQ0_INTS.Reg)&^(0x1)|value)
}
func (o *PIO0_Type) GetIRQ0_INTS_SM0_RXNEMPTY() uint32 {
	return volatile.LoadUint32(&o.IRQ0_INTS.Reg) & 0x1
}

// PIO0.IRQ1_INTE: Interrupt Enable for irq1
func (o *PIO0_Type) SetIRQ1_INTE_SM3(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTE.Reg, volatile.LoadUint32(&o.IRQ1_INTE.Reg)&^(0x800)|value<<11)
}
func (o *PIO0_Type) GetIRQ1_INTE_SM3() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTE.Reg) & 0x800) >> 11
}
func (o *PIO0_Type) SetIRQ1_INTE_SM2(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTE.Reg, volatile.LoadUint32(&o.IRQ1_INTE.Reg)&^(0x400)|value<<10)
}
func (o *PIO0_Type) GetIRQ1_INTE_SM2() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTE.Reg) & 0x400) >> 10
}
func (o *PIO0_Type) SetIRQ1_INTE_SM1(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTE.Reg, volatile.LoadUint32(&o.IRQ1_INTE.Reg)&^(0x200)|value<<9)
}
func (o *PIO0_Type) GetIRQ1_INTE_SM1() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTE.Reg) & 0x200) >> 9
}
func (o *PIO0_Type) SetIRQ1_INTE_SM0(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTE.Reg, volatile.LoadUint32(&o.IRQ1_INTE.Reg)&^(0x100)|value<<8)
}
func (o *PIO0_Type) GetIRQ1_INTE_SM0() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTE.Reg) & 0x100) >> 8
}
func (o *PIO0_Type) SetIRQ1_INTE_SM3_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTE.Reg, volatile.LoadUint32(&o.IRQ1_INTE.Reg)&^(0x80)|value<<7)
}
func (o *PIO0_Type) GetIRQ1_INTE_SM3_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTE.Reg) & 0x80) >> 7
}
func (o *PIO0_Type) SetIRQ1_INTE_SM2_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTE.Reg, volatile.LoadUint32(&o.IRQ1_INTE.Reg)&^(0x40)|value<<6)
}
func (o *PIO0_Type) GetIRQ1_INTE_SM2_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTE.Reg) & 0x40) >> 6
}
func (o *PIO0_Type) SetIRQ1_INTE_SM1_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTE.Reg, volatile.LoadUint32(&o.IRQ1_INTE.Reg)&^(0x20)|value<<5)
}
func (o *PIO0_Type) GetIRQ1_INTE_SM1_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTE.Reg) & 0x20) >> 5
}
func (o *PIO0_Type) SetIRQ1_INTE_SM0_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTE.Reg, volatile.LoadUint32(&o.IRQ1_INTE.Reg)&^(0x10)|value<<4)
}
func (o *PIO0_Type) GetIRQ1_INTE_SM0_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTE.Reg) & 0x10) >> 4
}
func (o *PIO0_Type) SetIRQ1_INTE_SM3_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTE.Reg, volatile.LoadUint32(&o.IRQ1_INTE.Reg)&^(0x8)|value<<3)
}
func (o *PIO0_Type) GetIRQ1_INTE_SM3_RXNEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTE.Reg) & 0x8) >> 3
}
func (o *PIO0_Type) SetIRQ1_INTE_SM2_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTE.Reg, volatile.LoadUint32(&o.IRQ1_INTE.Reg)&^(0x4)|value<<2)
}
func (o *PIO0_Type) GetIRQ1_INTE_SM2_RXNEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTE.Reg) & 0x4) >> 2
}
func (o *PIO0_Type) SetIRQ1_INTE_SM1_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTE.Reg, volatile.LoadUint32(&o.IRQ1_INTE.Reg)&^(0x2)|value<<1)
}
func (o *PIO0_Type) GetIRQ1_INTE_SM1_RXNEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTE.Reg) & 0x2) >> 1
}
func (o *PIO0_Type) SetIRQ1_INTE_SM0_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTE.Reg, volatile.LoadUint32(&o.IRQ1_INTE.Reg)&^(0x1)|value)
}
func (o *PIO0_Type) GetIRQ1_INTE_SM0_RXNEMPTY() uint32 {
	return volatile.LoadUint32(&o.IRQ1_INTE.Reg) & 0x1
}

// PIO0.IRQ1_INTF: Interrupt Force for irq1
func (o *PIO0_Type) SetIRQ1_INTF_SM3(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTF.Reg, volatile.LoadUint32(&o.IRQ1_INTF.Reg)&^(0x800)|value<<11)
}
func (o *PIO0_Type) GetIRQ1_INTF_SM3() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTF.Reg) & 0x800) >> 11
}
func (o *PIO0_Type) SetIRQ1_INTF_SM2(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTF.Reg, volatile.LoadUint32(&o.IRQ1_INTF.Reg)&^(0x400)|value<<10)
}
func (o *PIO0_Type) GetIRQ1_INTF_SM2() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTF.Reg) & 0x400) >> 10
}
func (o *PIO0_Type) SetIRQ1_INTF_SM1(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTF.Reg, volatile.LoadUint32(&o.IRQ1_INTF.Reg)&^(0x200)|value<<9)
}
func (o *PIO0_Type) GetIRQ1_INTF_SM1() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTF.Reg) & 0x200) >> 9
}
func (o *PIO0_Type) SetIRQ1_INTF_SM0(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTF.Reg, volatile.LoadUint32(&o.IRQ1_INTF.Reg)&^(0x100)|value<<8)
}
func (o *PIO0_Type) GetIRQ1_INTF_SM0() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTF.Reg) & 0x100) >> 8
}
func (o *PIO0_Type) SetIRQ1_INTF_SM3_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTF.Reg, volatile.LoadUint32(&o.IRQ1_INTF.Reg)&^(0x80)|value<<7)
}
func (o *PIO0_Type) GetIRQ1_INTF_SM3_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTF.Reg) & 0x80) >> 7
}
func (o *PIO0_Type) SetIRQ1_INTF_SM2_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTF.Reg, volatile.LoadUint32(&o.IRQ1_INTF.Reg)&^(0x40)|value<<6)
}
func (o *PIO0_Type) GetIRQ1_INTF_SM2_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTF.Reg) & 0x40) >> 6
}
func (o *PIO0_Type) SetIRQ1_INTF_SM1_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTF.Reg, volatile.LoadUint32(&o.IRQ1_INTF.Reg)&^(0x20)|value<<5)
}
func (o *PIO0_Type) GetIRQ1_INTF_SM1_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTF.Reg) & 0x20) >> 5
}
func (o *PIO0_Type) SetIRQ1_INTF_SM0_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTF.Reg, volatile.LoadUint32(&o.IRQ1_INTF.Reg)&^(0x10)|value<<4)
}
func (o *PIO0_Type) GetIRQ1_INTF_SM0_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTF.Reg) & 0x10) >> 4
}
func (o *PIO0_Type) SetIRQ1_INTF_SM3_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTF.Reg, volatile.LoadUint32(&o.IRQ1_INTF.Reg)&^(0x8)|value<<3)
}
func (o *PIO0_Type) GetIRQ1_INTF_SM3_RXNEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTF.Reg) & 0x8) >> 3
}
func (o *PIO0_Type) SetIRQ1_INTF_SM2_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTF.Reg, volatile.LoadUint32(&o.IRQ1_INTF.Reg)&^(0x4)|value<<2)
}
func (o *PIO0_Type) GetIRQ1_INTF_SM2_RXNEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTF.Reg) & 0x4) >> 2
}
func (o *PIO0_Type) SetIRQ1_INTF_SM1_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTF.Reg, volatile.LoadUint32(&o.IRQ1_INTF.Reg)&^(0x2)|value<<1)
}
func (o *PIO0_Type) GetIRQ1_INTF_SM1_RXNEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTF.Reg) & 0x2) >> 1
}
func (o *PIO0_Type) SetIRQ1_INTF_SM0_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTF.Reg, volatile.LoadUint32(&o.IRQ1_INTF.Reg)&^(0x1)|value)
}
func (o *PIO0_Type) GetIRQ1_INTF_SM0_RXNEMPTY() uint32 {
	return volatile.LoadUint32(&o.IRQ1_INTF.Reg) & 0x1
}

// PIO0.IRQ1_INTS: Interrupt status after masking & forcing for irq1
func (o *PIO0_Type) SetIRQ1_INTS_SM3(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTS.Reg, volatile.LoadUint32(&o.IRQ1_INTS.Reg)&^(0x800)|value<<11)
}
func (o *PIO0_Type) GetIRQ1_INTS_SM3() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTS.Reg) & 0x800) >> 11
}
func (o *PIO0_Type) SetIRQ1_INTS_SM2(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTS.Reg, volatile.LoadUint32(&o.IRQ1_INTS.Reg)&^(0x400)|value<<10)
}
func (o *PIO0_Type) GetIRQ1_INTS_SM2() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTS.Reg) & 0x400) >> 10
}
func (o *PIO0_Type) SetIRQ1_INTS_SM1(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTS.Reg, volatile.LoadUint32(&o.IRQ1_INTS.Reg)&^(0x200)|value<<9)
}
func (o *PIO0_Type) GetIRQ1_INTS_SM1() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTS.Reg) & 0x200) >> 9
}
func (o *PIO0_Type) SetIRQ1_INTS_SM0(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTS.Reg, volatile.LoadUint32(&o.IRQ1_INTS.Reg)&^(0x100)|value<<8)
}
func (o *PIO0_Type) GetIRQ1_INTS_SM0() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTS.Reg) & 0x100) >> 8
}
func (o *PIO0_Type) SetIRQ1_INTS_SM3_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTS.Reg, volatile.LoadUint32(&o.IRQ1_INTS.Reg)&^(0x80)|value<<7)
}
func (o *PIO0_Type) GetIRQ1_INTS_SM3_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTS.Reg) & 0x80) >> 7
}
func (o *PIO0_Type) SetIRQ1_INTS_SM2_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTS.Reg, volatile.LoadUint32(&o.IRQ1_INTS.Reg)&^(0x40)|value<<6)
}
func (o *PIO0_Type) GetIRQ1_INTS_SM2_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTS.Reg) & 0x40) >> 6
}
func (o *PIO0_Type) SetIRQ1_INTS_SM1_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTS.Reg, volatile.LoadUint32(&o.IRQ1_INTS.Reg)&^(0x20)|value<<5)
}
func (o *PIO0_Type) GetIRQ1_INTS_SM1_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTS.Reg) & 0x20) >> 5
}
func (o *PIO0_Type) SetIRQ1_INTS_SM0_TXNFULL(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTS.Reg, volatile.LoadUint32(&o.IRQ1_INTS.Reg)&^(0x10)|value<<4)
}
func (o *PIO0_Type) GetIRQ1_INTS_SM0_TXNFULL() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTS.Reg) & 0x10) >> 4
}
func (o *PIO0_Type) SetIRQ1_INTS_SM3_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTS.Reg, volatile.LoadUint32(&o.IRQ1_INTS.Reg)&^(0x8)|value<<3)
}
func (o *PIO0_Type) GetIRQ1_INTS_SM3_RXNEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTS.Reg) & 0x8) >> 3
}
func (o *PIO0_Type) SetIRQ1_INTS_SM2_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTS.Reg, volatile.LoadUint32(&o.IRQ1_INTS.Reg)&^(0x4)|value<<2)
}
func (o *PIO0_Type) GetIRQ1_INTS_SM2_RXNEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTS.Reg) & 0x4) >> 2
}
func (o *PIO0_Type) SetIRQ1_INTS_SM1_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTS.Reg, volatile.LoadUint32(&o.IRQ1_INTS.Reg)&^(0x2)|value<<1)
}
func (o *PIO0_Type) GetIRQ1_INTS_SM1_RXNEMPTY() uint32 {
	return (volatile.LoadUint32(&o.IRQ1_INTS.Reg) & 0x2) >> 1
}
func (o *PIO0_Type) SetIRQ1_INTS_SM0_RXNEMPTY(value uint32) {
	volatile.StoreUint32(&o.IRQ1_INTS.Reg, volatile.LoadUint32(&o.IRQ1_INTS.Reg)&^(0x1)|value)
}
func (o *PIO0_Type) GetIRQ1_INTS_SM0_RXNEMPTY() uint32 {
	return volatile.LoadUint32(&o.IRQ1_INTS.Reg) & 0x1
}

// Single-cycle IO block
// Provides core-local and inter-core hardware for the two processors, with single-cycle access.
type SIO_Type struct {
	CPUID              volatile.Register32 // 0x0
	GPIO_IN            volatile.Register32 // 0x4
	GPIO_HI_IN         volatile.Register32 // 0x8
	_                  [4]byte
	GPIO_OUT           volatile.Register32 // 0x10
	GPIO_OUT_SET       volatile.Register32 // 0x14
	GPIO_OUT_CLR       volatile.Register32 // 0x18
	GPIO_OUT_XOR       volatile.Register32 // 0x1C
	GPIO_OE            volatile.Register32 // 0x20
	GPIO_OE_SET        volatile.Register32 // 0x24
	GPIO_OE_CLR        volatile.Register32 // 0x28
	GPIO_OE_XOR        volatile.Register32 // 0x2C
	GPIO_HI_OUT        volatile.Register32 // 0x30
	GPIO_HI_OUT_SET    volatile.Register32 // 0x34
	GPIO_HI_OUT_CLR    volatile.Register32 // 0x38
	GPIO_HI_OUT_XOR    volatile.Register32 // 0x3C
	GPIO_HI_OE         volatile.Register32 // 0x40
	GPIO_HI_OE_SET     volatile.Register32 // 0x44
	GPIO_HI_OE_CLR     volatile.Register32 // 0x48
	GPIO_HI_OE_XOR     volatile.Register32 // 0x4C
	FIFO_ST            volatile.Register32 // 0x50
	FIFO_WR            volatile.Register32 // 0x54
	FIFO_RD            volatile.Register32 // 0x58
	SPINLOCK_ST        volatile.Register32 // 0x5C
	DIV_UDIVIDEND      volatile.Register32 // 0x60
	DIV_UDIVISOR       volatile.Register32 // 0x64
	DIV_SDIVIDEND      volatile.Register32 // 0x68
	DIV_SDIVISOR       volatile.Register32 // 0x6C
	DIV_QUOTIENT       volatile.Register32 // 0x70
	DIV_REMAINDER      volatile.Register32 // 0x74
	DIV_CSR            volatile.Register32 // 0x78
	_                  [4]byte
	INTERP0_ACCUM0     volatile.Register32 // 0x80
	INTERP0_ACCUM1     volatile.Register32 // 0x84
	INTERP0_BASE0      volatile.Register32 // 0x88
	INTERP0_BASE1      volatile.Register32 // 0x8C
	INTERP0_BASE2      volatile.Register32 // 0x90
	INTERP0_POP_LANE0  volatile.Register32 // 0x94
	INTERP0_POP_LANE1  volatile.Register32 // 0x98
	INTERP0_POP_FULL   volatile.Register32 // 0x9C
	INTERP0_PEEK_LANE0 volatile.Register32 // 0xA0
	INTERP0_PEEK_LANE1 volatile.Register32 // 0xA4
	INTERP0_PEEK_FULL  volatile.Register32 // 0xA8
	INTERP0_CTRL_LANE0 volatile.Register32 // 0xAC
	INTERP0_CTRL_LANE1 volatile.Register32 // 0xB0
	INTERP0_ACCUM0_ADD volatile.Register32 // 0xB4
	INTERP0_ACCUM1_ADD volatile.Register32 // 0xB8
	INTERP0_BASE_1AND0 volatile.Register32 // 0xBC
	INTERP1_ACCUM0     volatile.Register32 // 0xC0
	INTERP1_ACCUM1     volatile.Register32 // 0xC4
	INTERP1_BASE0      volatile.Register32 // 0xC8
	INTERP1_BASE1      volatile.Register32 // 0xCC
	INTERP1_BASE2      volatile.Register32 // 0xD0
	INTERP1_POP_LANE0  volatile.Register32 // 0xD4
	INTERP1_POP_LANE1  volatile.Register32 // 0xD8
	INTERP1_POP_FULL   volatile.Register32 // 0xDC
	INTERP1_PEEK_LANE0 volatile.Register32 // 0xE0
	INTERP1_PEEK_LANE1 volatile.Register32 // 0xE4
	INTERP1_PEEK_FULL  volatile.Register32 // 0xE8
	INTERP1_CTRL_LANE0 volatile.Register32 // 0xEC
	INTERP1_CTRL_LANE1 volatile.Register32 // 0xF0
	INTERP1_ACCUM0_ADD volatile.Register32 // 0xF4
	INTERP1_ACCUM1_ADD volatile.Register32 // 0xF8
	INTERP1_BASE_1AND0 volatile.Register32 // 0xFC
	SPINLOCK0          volatile.Register32 // 0x100
	SPINLOCK1          volatile.Register32 // 0x104
	SPINLOCK2          volatile.Register32 // 0x108
	SPINLOCK3          volatile.Register32 // 0x10C
	SPINLOCK4          volatile.Register32 // 0x110
	SPINLOCK5          volatile.Register32 // 0x114
	SPINLOCK6          volatile.Register32 // 0x118
	SPINLOCK7          volatile.Register32 // 0x11C
	SPINLOCK8          volatile.Register32 // 0x120
	SPINLOCK9          volatile.Register32 // 0x124
	SPINLOCK10         volatile.Register32 // 0x128
	SPINLOCK11         volatile.Register32 // 0x12C
	SPINLOCK12         volatile.Register32 // 0x130
	SPINLOCK13         volatile.Register32 // 0x134
	SPINLOCK14         volatile.Register32 // 0x138
	SPINLOCK15         volatile.Register32 // 0x13C
	SPINLOCK16         volatile.Register32 // 0x140
	SPINLOCK17         volatile.Register32 // 0x144
	SPINLOCK18         volatile.Register32 // 0x148
	SPINLOCK19         volatile.Register32 // 0x14C
	SPINLOCK20         volatile.Register32 // 0x150
	SPINLOCK21         volatile.Register32 // 0x154
	SPINLOCK22         volatile.Register32 // 0x158
	SPINLOCK23         volatile.Register32 // 0x15C
	SPINLOCK24         volatile.Register32 // 0x160
	SPINLOCK25         volatile.Register32 // 0x164
	SPINLOCK26         volatile.Register32 // 0x168
	SPINLOCK27         volatile.Register32 // 0x16C
	SPINLOCK28         volatile.Register32 // 0x170
	SPINLOCK29         volatile.Register32 // 0x174
	SPINLOCK30         volatile.Register32 // 0x178
	SPINLOCK31         volatile.Register32 // 0x17C
}

// SIO.GPIO_IN: Input value for GPIO pins
func (o *SIO_Type) SetGPIO_IN(value uint32) {
	volatile.StoreUint32(&o.GPIO_IN.Reg, volatile.LoadUint32(&o.GPIO_IN.Reg)&^(0x3fffffff)|value)
}
func (o *SIO_Type) GetGPIO_IN() uint32 {
	return volatile.LoadUint32(&o.GPIO_IN.Reg) & 0x3fffffff
}

// SIO.GPIO_HI_IN: Input value for QSPI pins
func (o *SIO_Type) SetGPIO_HI_IN(value uint32) {
	volatile.StoreUint32(&o.GPIO_HI_IN.Reg, volatile.LoadUint32(&o.GPIO_HI_IN.Reg)&^(0x3f)|value)
}
func (o *SIO_Type) GetGPIO_HI_IN() uint32 {
	return volatile.LoadUint32(&o.GPIO_HI_IN.Reg) & 0x3f
}

// SIO.GPIO_OUT: GPIO output value
func (o *SIO_Type) SetGPIO_OUT(value uint32) {
	volatile.StoreUint32(&o.GPIO_OUT.Reg, volatile.LoadUint32(&o.GPIO_OUT.Reg)&^(0x3fffffff)|value)
}
func (o *SIO_Type) GetGPIO_OUT() uint32 {
	return volatile.LoadUint32(&o.GPIO_OUT.Reg) & 0x3fffffff
}

// SIO.GPIO_OUT_SET: GPIO output value set
func (o *SIO_Type) SetGPIO_OUT_SET(value uint32) {
	volatile.StoreUint32(&o.GPIO_OUT_SET.Reg, volatile.LoadUint32(&o.GPIO_OUT_SET.Reg)&^(0x3fffffff)|value)
}
func (o *SIO_Type) GetGPIO_OUT_SET() uint32 {
	return volatile.LoadUint32(&o.GPIO_OUT_SET.Reg) & 0x3fffffff
}

// SIO.GPIO_OUT_CLR: GPIO output value clear
func (o *SIO_Type) SetGPIO_OUT_CLR(value uint32) {
	volatile.StoreUint32(&o.GPIO_OUT_CLR.Reg, volatile.LoadUint32(&o.GPIO_OUT_CLR.Reg)&^(0x3fffffff)|value)
}
func (o *SIO_Type) GetGPIO_OUT_CLR() uint32 {
	return volatile.LoadUint32(&o.GPIO_OUT_CLR.Reg) & 0x3fffffff
}

// SIO.GPIO_OUT_XOR: GPIO output value XOR
func (o *SIO_Type) SetGPIO_OUT_XOR(value uint32) {
	volatile.StoreUint32(&o.GPIO_OUT_XOR.Reg, volatile.LoadUint32(&o.GPIO_OUT_XOR.Reg)&^(0x3fffffff)|value)
}
func (o *SIO_Type) GetGPIO_OUT_XOR() uint32 {
	return volatile.LoadUint32(&o.GPIO_OUT_XOR.Reg) & 0x3fffffff
}

// SIO.GPIO_OE: GPIO output enable
func (o *SIO_Type) SetGPIO_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO_OE.Reg, volatile.LoadUint32(&o.GPIO_OE.Reg)&^(0x3fffffff)|value)
}
func (o *SIO_Type) GetGPIO_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO_OE.Reg) & 0x3fffffff
}

// SIO.GPIO_OE_SET: GPIO output enable set
func (o *SIO_Type) SetGPIO_OE_SET(value uint32) {
	volatile.StoreUint32(&o.GPIO_OE_SET.Reg, volatile.LoadUint32(&o.GPIO_OE_SET.Reg)&^(0x3fffffff)|value)
}
func (o *SIO_Type) GetGPIO_OE_SET() uint32 {
	return volatile.LoadUint32(&o.GPIO_OE_SET.Reg) & 0x3fffffff
}

// SIO.GPIO_OE_CLR: GPIO output enable clear
func (o *SIO_Type) SetGPIO_OE_CLR(value uint32) {
	volatile.StoreUint32(&o.GPIO_OE_CLR.Reg, volatile.LoadUint32(&o.GPIO_OE_CLR.Reg)&^(0x3fffffff)|value)
}
func (o *SIO_Type) GetGPIO_OE_CLR() uint32 {
	return volatile.LoadUint32(&o.GPIO_OE_CLR.Reg) & 0x3fffffff
}

// SIO.GPIO_OE_XOR: GPIO output enable XOR
func (o *SIO_Type) SetGPIO_OE_XOR(value uint32) {
	volatile.StoreUint32(&o.GPIO_OE_XOR.Reg, volatile.LoadUint32(&o.GPIO_OE_XOR.Reg)&^(0x3fffffff)|value)
}
func (o *SIO_Type) GetGPIO_OE_XOR() uint32 {
	return volatile.LoadUint32(&o.GPIO_OE_XOR.Reg) & 0x3fffffff
}

// SIO.GPIO_HI_OUT: QSPI output value
func (o *SIO_Type) SetGPIO_HI_OUT(value uint32) {
	volatile.StoreUint32(&o.GPIO_HI_OUT.Reg, volatile.LoadUint32(&o.GPIO_HI_OUT.Reg)&^(0x3f)|value)
}
func (o *SIO_Type) GetGPIO_HI_OUT() uint32 {
	return volatile.LoadUint32(&o.GPIO_HI_OUT.Reg) & 0x3f
}

// SIO.GPIO_HI_OUT_SET: QSPI output value set
func (o *SIO_Type) SetGPIO_HI_OUT_SET(value uint32) {
	volatile.StoreUint32(&o.GPIO_HI_OUT_SET.Reg, volatile.LoadUint32(&o.GPIO_HI_OUT_SET.Reg)&^(0x3f)|value)
}
func (o *SIO_Type) GetGPIO_HI_OUT_SET() uint32 {
	return volatile.LoadUint32(&o.GPIO_HI_OUT_SET.Reg) & 0x3f
}

// SIO.GPIO_HI_OUT_CLR: QSPI output value clear
func (o *SIO_Type) SetGPIO_HI_OUT_CLR(value uint32) {
	volatile.StoreUint32(&o.GPIO_HI_OUT_CLR.Reg, volatile.LoadUint32(&o.GPIO_HI_OUT_CLR.Reg)&^(0x3f)|value)
}
func (o *SIO_Type) GetGPIO_HI_OUT_CLR() uint32 {
	return volatile.LoadUint32(&o.GPIO_HI_OUT_CLR.Reg) & 0x3f
}

// SIO.GPIO_HI_OUT_XOR: QSPI output value XOR
func (o *SIO_Type) SetGPIO_HI_OUT_XOR(value uint32) {
	volatile.StoreUint32(&o.GPIO_HI_OUT_XOR.Reg, volatile.LoadUint32(&o.GPIO_HI_OUT_XOR.Reg)&^(0x3f)|value)
}
func (o *SIO_Type) GetGPIO_HI_OUT_XOR() uint32 {
	return volatile.LoadUint32(&o.GPIO_HI_OUT_XOR.Reg) & 0x3f
}

// SIO.GPIO_HI_OE: QSPI output enable
func (o *SIO_Type) SetGPIO_HI_OE(value uint32) {
	volatile.StoreUint32(&o.GPIO_HI_OE.Reg, volatile.LoadUint32(&o.GPIO_HI_OE.Reg)&^(0x3f)|value)
}
func (o *SIO_Type) GetGPIO_HI_OE() uint32 {
	return volatile.LoadUint32(&o.GPIO_HI_OE.Reg) & 0x3f
}

// SIO.GPIO_HI_OE_SET: QSPI output enable set
func (o *SIO_Type) SetGPIO_HI_OE_SET(value uint32) {
	volatile.StoreUint32(&o.GPIO_HI_OE_SET.Reg, volatile.LoadUint32(&o.GPIO_HI_OE_SET.Reg)&^(0x3f)|value)
}
func (o *SIO_Type) GetGPIO_HI_OE_SET() uint32 {
	return volatile.LoadUint32(&o.GPIO_HI_OE_SET.Reg) & 0x3f
}

// SIO.GPIO_HI_OE_CLR: QSPI output enable clear
func (o *SIO_Type) SetGPIO_HI_OE_CLR(value uint32) {
	volatile.StoreUint32(&o.GPIO_HI_OE_CLR.Reg, volatile.LoadUint32(&o.GPIO_HI_OE_CLR.Reg)&^(0x3f)|value)
}
func (o *SIO_Type) GetGPIO_HI_OE_CLR() uint32 {
	return volatile.LoadUint32(&o.GPIO_HI_OE_CLR.Reg) & 0x3f
}

// SIO.GPIO_HI_OE_XOR: QSPI output enable XOR
func (o *SIO_Type) SetGPIO_HI_OE_XOR(value uint32) {
	volatile.StoreUint32(&o.GPIO_HI_OE_XOR.Reg, volatile.LoadUint32(&o.GPIO_HI_OE_XOR.Reg)&^(0x3f)|value)
}
func (o *SIO_Type) GetGPIO_HI_OE_XOR() uint32 {
	return volatile.LoadUint32(&o.GPIO_HI_OE_XOR.Reg) & 0x3f
}

// SIO.FIFO_ST
// Status register for inter-core FIFOs (mailboxes).
// There is one FIFO in the core 0 -> core 1 direction, and one core 1 -> core 0. Both are 32 bits wide and 8 words deep.
// Core 0 can see the read side of the 1->0 FIFO (RX), and the write side of 0->1 FIFO (TX).
// Core 1 can see the read side of the 0->1 FIFO (RX), and the write side of 1->0 FIFO (TX).
// The SIO IRQ for each core is the logical OR of the VLD, WOF and ROE fields of its FIFO_ST register.
func (o *SIO_Type) SetFIFO_ST_ROE(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0x8)|value<<3)
}
func (o *SIO_Type) GetFIFO_ST_ROE() uint32 {
	return (volatile.LoadUint32(&o.FIFO_ST.Reg) & 0x8) >> 3
}
func (o *SIO_Type) SetFIFO_ST_WOF(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0x4)|value<<2)
}
func (o *SIO_Type) GetFIFO_ST_WOF() uint32 {
	return (volatile.LoadUint32(&o.FIFO_ST.Reg) & 0x4) >> 2
}
func (o *SIO_Type) SetFIFO_ST_RDY(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0x2)|value<<1)
}
func (o *SIO_Type) GetFIFO_ST_RDY() uint32 {
	return (volatile.LoadUint32(&o.FIFO_ST.Reg) & 0x2) >> 1
}
func (o *SIO_Type) SetFIFO_ST_VLD(value uint32) {
	volatile.StoreUint32(&o.FIFO_ST.Reg, volatile.LoadUint32(&o.FIFO_ST.Reg)&^(0x1)|value)
}
func (o *SIO_Type) GetFIFO_ST_VLD() uint32 {
	return volatile.LoadUint32(&o.FIFO_ST.Reg) & 0x1
}

// SIO.DIV_CSR: Control and status register for divider.
func (o *SIO_Type) SetDIV_CSR_DIRTY(value uint32) {
	volatile.StoreUint32(&o.DIV_CSR.Reg, volatile.LoadUint32(&o.DIV_CSR.Reg)&^(0x2)|value<<1)
}
func (o *SIO_Type) GetDIV_CSR_DIRTY() uint32 {
	return (volatile.LoadUint32(&o.DIV_CSR.Reg) & 0x2) >> 1
}
func (o *SIO_Type) SetDIV_CSR_READY(value uint32) {
	volatile.StoreUint32(&o.DIV_CSR.Reg, volatile.LoadUint32(&o.DIV_CSR.Reg)&^(0x1)|value)
}
func (o *SIO_Type) GetDIV_CSR_READY() uint32 {
	return volatile.LoadUint32(&o.DIV_CSR.Reg) & 0x1
}

// SIO.INTERP0_CTRL_LANE0: Control register for lane 0
func (o *SIO_Type) SetINTERP0_CTRL_LANE0_OVERF(value uint32) {
	volatile.StoreUint32(&o.INTERP0_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg)&^(0x2000000)|value<<25)
}
func (o *SIO_Type) GetINTERP0_CTRL_LANE0_OVERF() uint32 {
	return (volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg) & 0x2000000) >> 25
}
func (o *SIO_Type) SetINTERP0_CTRL_LANE0_OVERF1(value uint32) {
	volatile.StoreUint32(&o.INTERP0_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg)&^(0x1000000)|value<<24)
}
func (o *SIO_Type) GetINTERP0_CTRL_LANE0_OVERF1() uint32 {
	return (volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg) & 0x1000000) >> 24
}
func (o *SIO_Type) SetINTERP0_CTRL_LANE0_OVERF0(value uint32) {
	volatile.StoreUint32(&o.INTERP0_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg)&^(0x800000)|value<<23)
}
func (o *SIO_Type) GetINTERP0_CTRL_LANE0_OVERF0() uint32 {
	return (volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg) & 0x800000) >> 23
}
func (o *SIO_Type) SetINTERP0_CTRL_LANE0_BLEND(value uint32) {
	volatile.StoreUint32(&o.INTERP0_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg)&^(0x200000)|value<<21)
}
func (o *SIO_Type) GetINTERP0_CTRL_LANE0_BLEND() uint32 {
	return (volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg) & 0x200000) >> 21
}
func (o *SIO_Type) SetINTERP0_CTRL_LANE0_FORCE_MSB(value uint32) {
	volatile.StoreUint32(&o.INTERP0_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg)&^(0x180000)|value<<19)
}
func (o *SIO_Type) GetINTERP0_CTRL_LANE0_FORCE_MSB() uint32 {
	return (volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg) & 0x180000) >> 19
}
func (o *SIO_Type) SetINTERP0_CTRL_LANE0_ADD_RAW(value uint32) {
	volatile.StoreUint32(&o.INTERP0_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg)&^(0x40000)|value<<18)
}
func (o *SIO_Type) GetINTERP0_CTRL_LANE0_ADD_RAW() uint32 {
	return (volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg) & 0x40000) >> 18
}
func (o *SIO_Type) SetINTERP0_CTRL_LANE0_CROSS_RESULT(value uint32) {
	volatile.StoreUint32(&o.INTERP0_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg)&^(0x20000)|value<<17)
}
func (o *SIO_Type) GetINTERP0_CTRL_LANE0_CROSS_RESULT() uint32 {
	return (volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg) & 0x20000) >> 17
}
func (o *SIO_Type) SetINTERP0_CTRL_LANE0_CROSS_INPUT(value uint32) {
	volatile.StoreUint32(&o.INTERP0_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg)&^(0x10000)|value<<16)
}
func (o *SIO_Type) GetINTERP0_CTRL_LANE0_CROSS_INPUT() uint32 {
	return (volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg) & 0x10000) >> 16
}
func (o *SIO_Type) SetINTERP0_CTRL_LANE0_SIGNED(value uint32) {
	volatile.StoreUint32(&o.INTERP0_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg)&^(0x8000)|value<<15)
}
func (o *SIO_Type) GetINTERP0_CTRL_LANE0_SIGNED() uint32 {
	return (volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg) & 0x8000) >> 15
}
func (o *SIO_Type) SetINTERP0_CTRL_LANE0_MASK_MSB(value uint32) {
	volatile.StoreUint32(&o.INTERP0_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg)&^(0x7c00)|value<<10)
}
func (o *SIO_Type) GetINTERP0_CTRL_LANE0_MASK_MSB() uint32 {
	return (volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg) & 0x7c00) >> 10
}
func (o *SIO_Type) SetINTERP0_CTRL_LANE0_MASK_LSB(value uint32) {
	volatile.StoreUint32(&o.INTERP0_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg)&^(0x3e0)|value<<5)
}
func (o *SIO_Type) GetINTERP0_CTRL_LANE0_MASK_LSB() uint32 {
	return (volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg) & 0x3e0) >> 5
}
func (o *SIO_Type) SetINTERP0_CTRL_LANE0_SHIFT(value uint32) {
	volatile.StoreUint32(&o.INTERP0_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg)&^(0x1f)|value)
}
func (o *SIO_Type) GetINTERP0_CTRL_LANE0_SHIFT() uint32 {
	return volatile.LoadUint32(&o.INTERP0_CTRL_LANE0.Reg) & 0x1f
}

// SIO.INTERP0_CTRL_LANE1: Control register for lane 1
func (o *SIO_Type) SetINTERP0_CTRL_LANE1_FORCE_MSB(value uint32) {
	volatile.StoreUint32(&o.INTERP0_CTRL_LANE1.Reg, volatile.LoadUint32(&o.INTERP0_CTRL_LANE1.Reg)&^(0x180000)|value<<19)
}
func (o *SIO_Type) GetINTERP0_CTRL_LANE1_FORCE_MSB() uint32 {
	return (volatile.LoadUint32(&o.INTERP0_CTRL_LANE1.Reg) & 0x180000) >> 19
}
func (o *SIO_Type) SetINTERP0_CTRL_LANE1_ADD_RAW(value uint32) {
	volatile.StoreUint32(&o.INTERP0_CTRL_LANE1.Reg, volatile.LoadUint32(&o.INTERP0_CTRL_LANE1.Reg)&^(0x40000)|value<<18)
}
func (o *SIO_Type) GetINTERP0_CTRL_LANE1_ADD_RAW() uint32 {
	return (volatile.LoadUint32(&o.INTERP0_CTRL_LANE1.Reg) & 0x40000) >> 18
}
func (o *SIO_Type) SetINTERP0_CTRL_LANE1_CROSS_RESULT(value uint32) {
	volatile.StoreUint32(&o.INTERP0_CTRL_LANE1.Reg, volatile.LoadUint32(&o.INTERP0_CTRL_LANE1.Reg)&^(0x20000)|value<<17)
}
func (o *SIO_Type) GetINTERP0_CTRL_LANE1_CROSS_RESULT() uint32 {
	return (volatile.LoadUint32(&o.INTERP0_CTRL_LANE1.Reg) & 0x20000) >> 17
}
func (o *SIO_Type) SetINTERP0_CTRL_LANE1_CROSS_INPUT(value uint32) {
	volatile.StoreUint32(&o.INTERP0_CTRL_LANE1.Reg, volatile.LoadUint32(&o.INTERP0_CTRL_LANE1.Reg)&^(0x10000)|value<<16)
}
func (o *SIO_Type) GetINTERP0_CTRL_LANE1_CROSS_INPUT() uint32 {
	return (volatile.LoadUint32(&o.INTERP0_CTRL_LANE1.Reg) & 0x10000) >> 16
}
func (o *SIO_Type) SetINTERP0_CTRL_LANE1_SIGNED(value uint32) {
	volatile.StoreUint32(&o.INTERP0_CTRL_LANE1.Reg, volatile.LoadUint32(&o.INTERP0_CTRL_LANE1.Reg)&^(0x8000)|value<<15)
}
func (o *SIO_Type) GetINTERP0_CTRL_LANE1_SIGNED() uint32 {
	return (volatile.LoadUint32(&o.INTERP0_CTRL_LANE1.Reg) & 0x8000) >> 15
}
func (o *SIO_Type) SetINTERP0_CTRL_LANE1_MASK_MSB(value uint32) {
	volatile.StoreUint32(&o.INTERP0_CTRL_LANE1.Reg, volatile.LoadUint32(&o.INTERP0_CTRL_LANE1.Reg)&^(0x7c00)|value<<10)
}
func (o *SIO_Type) GetINTERP0_CTRL_LANE1_MASK_MSB() uint32 {
	return (volatile.LoadUint32(&o.INTERP0_CTRL_LANE1.Reg) & 0x7c00) >> 10
}
func (o *SIO_Type) SetINTERP0_CTRL_LANE1_MASK_LSB(value uint32) {
	volatile.StoreUint32(&o.INTERP0_CTRL_LANE1.Reg, volatile.LoadUint32(&o.INTERP0_CTRL_LANE1.Reg)&^(0x3e0)|value<<5)
}
func (o *SIO_Type) GetINTERP0_CTRL_LANE1_MASK_LSB() uint32 {
	return (volatile.LoadUint32(&o.INTERP0_CTRL_LANE1.Reg) & 0x3e0) >> 5
}
func (o *SIO_Type) SetINTERP0_CTRL_LANE1_SHIFT(value uint32) {
	volatile.StoreUint32(&o.INTERP0_CTRL_LANE1.Reg, volatile.LoadUint32(&o.INTERP0_CTRL_LANE1.Reg)&^(0x1f)|value)
}
func (o *SIO_Type) GetINTERP0_CTRL_LANE1_SHIFT() uint32 {
	return volatile.LoadUint32(&o.INTERP0_CTRL_LANE1.Reg) & 0x1f
}

// SIO.INTERP0_ACCUM0_ADD
// Values written here are atomically added to ACCUM0
// Reading yields lane 0's raw shift and mask value (BASE0 not added).
func (o *SIO_Type) SetINTERP0_ACCUM0_ADD(value uint32) {
	volatile.StoreUint32(&o.INTERP0_ACCUM0_ADD.Reg, volatile.LoadUint32(&o.INTERP0_ACCUM0_ADD.Reg)&^(0xffffff)|value)
}
func (o *SIO_Type) GetINTERP0_ACCUM0_ADD() uint32 {
	return volatile.LoadUint32(&o.INTERP0_ACCUM0_ADD.Reg) & 0xffffff
}

// SIO.INTERP0_ACCUM1_ADD
// Values written here are atomically added to ACCUM1
// Reading yields lane 1's raw shift and mask value (BASE1 not added).
func (o *SIO_Type) SetINTERP0_ACCUM1_ADD(value uint32) {
	volatile.StoreUint32(&o.INTERP0_ACCUM1_ADD.Reg, volatile.LoadUint32(&o.INTERP0_ACCUM1_ADD.Reg)&^(0xffffff)|value)
}
func (o *SIO_Type) GetINTERP0_ACCUM1_ADD() uint32 {
	return volatile.LoadUint32(&o.INTERP0_ACCUM1_ADD.Reg) & 0xffffff
}

// SIO.INTERP1_CTRL_LANE0: Control register for lane 0
func (o *SIO_Type) SetINTERP1_CTRL_LANE0_OVERF(value uint32) {
	volatile.StoreUint32(&o.INTERP1_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg)&^(0x2000000)|value<<25)
}
func (o *SIO_Type) GetINTERP1_CTRL_LANE0_OVERF() uint32 {
	return (volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg) & 0x2000000) >> 25
}
func (o *SIO_Type) SetINTERP1_CTRL_LANE0_OVERF1(value uint32) {
	volatile.StoreUint32(&o.INTERP1_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg)&^(0x1000000)|value<<24)
}
func (o *SIO_Type) GetINTERP1_CTRL_LANE0_OVERF1() uint32 {
	return (volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg) & 0x1000000) >> 24
}
func (o *SIO_Type) SetINTERP1_CTRL_LANE0_OVERF0(value uint32) {
	volatile.StoreUint32(&o.INTERP1_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg)&^(0x800000)|value<<23)
}
func (o *SIO_Type) GetINTERP1_CTRL_LANE0_OVERF0() uint32 {
	return (volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg) & 0x800000) >> 23
}
func (o *SIO_Type) SetINTERP1_CTRL_LANE0_CLAMP(value uint32) {
	volatile.StoreUint32(&o.INTERP1_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg)&^(0x400000)|value<<22)
}
func (o *SIO_Type) GetINTERP1_CTRL_LANE0_CLAMP() uint32 {
	return (volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg) & 0x400000) >> 22
}
func (o *SIO_Type) SetINTERP1_CTRL_LANE0_FORCE_MSB(value uint32) {
	volatile.StoreUint32(&o.INTERP1_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg)&^(0x180000)|value<<19)
}
func (o *SIO_Type) GetINTERP1_CTRL_LANE0_FORCE_MSB() uint32 {
	return (volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg) & 0x180000) >> 19
}
func (o *SIO_Type) SetINTERP1_CTRL_LANE0_ADD_RAW(value uint32) {
	volatile.StoreUint32(&o.INTERP1_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg)&^(0x40000)|value<<18)
}
func (o *SIO_Type) GetINTERP1_CTRL_LANE0_ADD_RAW() uint32 {
	return (volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg) & 0x40000) >> 18
}
func (o *SIO_Type) SetINTERP1_CTRL_LANE0_CROSS_RESULT(value uint32) {
	volatile.StoreUint32(&o.INTERP1_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg)&^(0x20000)|value<<17)
}
func (o *SIO_Type) GetINTERP1_CTRL_LANE0_CROSS_RESULT() uint32 {
	return (volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg) & 0x20000) >> 17
}
func (o *SIO_Type) SetINTERP1_CTRL_LANE0_CROSS_INPUT(value uint32) {
	volatile.StoreUint32(&o.INTERP1_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg)&^(0x10000)|value<<16)
}
func (o *SIO_Type) GetINTERP1_CTRL_LANE0_CROSS_INPUT() uint32 {
	return (volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg) & 0x10000) >> 16
}
func (o *SIO_Type) SetINTERP1_CTRL_LANE0_SIGNED(value uint32) {
	volatile.StoreUint32(&o.INTERP1_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg)&^(0x8000)|value<<15)
}
func (o *SIO_Type) GetINTERP1_CTRL_LANE0_SIGNED() uint32 {
	return (volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg) & 0x8000) >> 15
}
func (o *SIO_Type) SetINTERP1_CTRL_LANE0_MASK_MSB(value uint32) {
	volatile.StoreUint32(&o.INTERP1_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg)&^(0x7c00)|value<<10)
}
func (o *SIO_Type) GetINTERP1_CTRL_LANE0_MASK_MSB() uint32 {
	return (volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg) & 0x7c00) >> 10
}
func (o *SIO_Type) SetINTERP1_CTRL_LANE0_MASK_LSB(value uint32) {
	volatile.StoreUint32(&o.INTERP1_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg)&^(0x3e0)|value<<5)
}
func (o *SIO_Type) GetINTERP1_CTRL_LANE0_MASK_LSB() uint32 {
	return (volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg) & 0x3e0) >> 5
}
func (o *SIO_Type) SetINTERP1_CTRL_LANE0_SHIFT(value uint32) {
	volatile.StoreUint32(&o.INTERP1_CTRL_LANE0.Reg, volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg)&^(0x1f)|value)
}
func (o *SIO_Type) GetINTERP1_CTRL_LANE0_SHIFT() uint32 {
	return volatile.LoadUint32(&o.INTERP1_CTRL_LANE0.Reg) & 0x1f
}

// SIO.INTERP1_CTRL_LANE1: Control register for lane 1
func (o *SIO_Type) SetINTERP1_CTRL_LANE1_FORCE_MSB(value uint32) {
	volatile.StoreUint32(&o.INTERP1_CTRL_LANE1.Reg, volatile.LoadUint32(&o.INTERP1_CTRL_LANE1.Reg)&^(0x180000)|value<<19)
}
func (o *SIO_Type) GetINTERP1_CTRL_LANE1_FORCE_MSB() uint32 {
	return (volatile.LoadUint32(&o.INTERP1_CTRL_LANE1.Reg) & 0x180000) >> 19
}
func (o *SIO_Type) SetINTERP1_CTRL_LANE1_ADD_RAW(value uint32) {
	volatile.StoreUint32(&o.INTERP1_CTRL_LANE1.Reg, volatile.LoadUint32(&o.INTERP1_CTRL_LANE1.Reg)&^(0x40000)|value<<18)
}
func (o *SIO_Type) GetINTERP1_CTRL_LANE1_ADD_RAW() uint32 {
	return (volatile.LoadUint32(&o.INTERP1_CTRL_LANE1.Reg) & 0x40000) >> 18
}
func (o *SIO_Type) SetINTERP1_CTRL_LANE1_CROSS_RESULT(value uint32) {
	volatile.StoreUint32(&o.INTERP1_CTRL_LANE1.Reg, volatile.LoadUint32(&o.INTERP1_CTRL_LANE1.Reg)&^(0x20000)|value<<17)
}
func (o *SIO_Type) GetINTERP1_CTRL_LANE1_CROSS_RESULT() uint32 {
	return (volatile.LoadUint32(&o.INTERP1_CTRL_LANE1.Reg) & 0x20000) >> 17
}
func (o *SIO_Type) SetINTERP1_CTRL_LANE1_CROSS_INPUT(value uint32) {
	volatile.StoreUint32(&o.INTERP1_CTRL_LANE1.Reg, volatile.LoadUint32(&o.INTERP1_CTRL_LANE1.Reg)&^(0x10000)|value<<16)
}
func (o *SIO_Type) GetINTERP1_CTRL_LANE1_CROSS_INPUT() uint32 {
	return (volatile.LoadUint32(&o.INTERP1_CTRL_LANE1.Reg) & 0x10000) >> 16
}
func (o *SIO_Type) SetINTERP1_CTRL_LANE1_SIGNED(value uint32) {
	volatile.StoreUint32(&o.INTERP1_CTRL_LANE1.Reg, volatile.LoadUint32(&o.INTERP1_CTRL_LANE1.Reg)&^(0x8000)|value<<15)
}
func (o *SIO_Type) GetINTERP1_CTRL_LANE1_SIGNED() uint32 {
	return (volatile.LoadUint32(&o.INTERP1_CTRL_LANE1.Reg) & 0x8000) >> 15
}
func (o *SIO_Type) SetINTERP1_CTRL_LANE1_MASK_MSB(value uint32) {
	volatile.StoreUint32(&o.INTERP1_CTRL_LANE1.Reg, volatile.LoadUint32(&o.INTERP1_CTRL_LANE1.Reg)&^(0x7c00)|value<<10)
}
func (o *SIO_Type) GetINTERP1_CTRL_LANE1_MASK_MSB() uint32 {
	return (volatile.LoadUint32(&o.INTERP1_CTRL_LANE1.Reg) & 0x7c00) >> 10
}
func (o *SIO_Type) SetINTERP1_CTRL_LANE1_MASK_LSB(value uint32) {
	volatile.StoreUint32(&o.INTERP1_CTRL_LANE1.Reg, volatile.LoadUint32(&o.INTERP1_CTRL_LANE1.Reg)&^(0x3e0)|value<<5)
}
func (o *SIO_Type) GetINTERP1_CTRL_LANE1_MASK_LSB() uint32 {
	return (volatile.LoadUint32(&o.INTERP1_CTRL_LANE1.Reg) & 0x3e0) >> 5
}
func (o *SIO_Type) SetINTERP1_CTRL_LANE1_SHIFT(value uint32) {
	volatile.StoreUint32(&o.INTERP1_CTRL_LANE1.Reg, volatile.LoadUint32(&o.INTERP1_CTRL_LANE1.Reg)&^(0x1f)|value)
}
func (o *SIO_Type) GetINTERP1_CTRL_LANE1_SHIFT() uint32 {
	return volatile.LoadUint32(&o.INTERP1_CTRL_LANE1.Reg) & 0x1f
}

// SIO.INTERP1_ACCUM0_ADD
// Values written here are atomically added to ACCUM0
// Reading yields lane 0's raw shift and mask value (BASE0 not added).
func (o *SIO_Type) SetINTERP1_ACCUM0_ADD(value uint32) {
	volatile.StoreUint32(&o.INTERP1_ACCUM0_ADD.Reg, volatile.LoadUint32(&o.INTERP1_ACCUM0_ADD.Reg)&^(0xffffff)|value)
}
func (o *SIO_Type) GetINTERP1_ACCUM0_ADD() uint32 {
	return volatile.LoadUint32(&o.INTERP1_ACCUM0_ADD.Reg) & 0xffffff
}

// SIO.INTERP1_ACCUM1_ADD
// Values written here are atomically added to ACCUM1
// Reading yields lane 1's raw shift and mask value (BASE1 not added).
func (o *SIO_Type) SetINTERP1_ACCUM1_ADD(value uint32) {
	volatile.StoreUint32(&o.INTERP1_ACCUM1_ADD.Reg, volatile.LoadUint32(&o.INTERP1_ACCUM1_ADD.Reg)&^(0xffffff)|value)
}
func (o *SIO_Type) GetINTERP1_ACCUM1_ADD() uint32 {
	return volatile.LoadUint32(&o.INTERP1_ACCUM1_ADD.Reg) & 0xffffff
}

type PPB_Type struct {
	_          [57360]byte
	SYST_CSR   volatile.Register32 // 0xE010
	SYST_RVR   volatile.Register32 // 0xE014
	SYST_CVR   volatile.Register32 // 0xE018
	SYST_CALIB volatile.Register32 // 0xE01C
	_          [224]byte
	NVIC_ISER  volatile.Register32 // 0xE100
	_          [124]byte
	NVIC_ICER  volatile.Register32 // 0xE180
	_          [124]byte
	NVIC_ISPR  volatile.Register32 // 0xE200
	_          [124]byte
	NVIC_ICPR  volatile.Register32 // 0xE280
	_          [380]byte
	NVIC_IPR0  volatile.Register32 // 0xE400
	NVIC_IPR1  volatile.Register32 // 0xE404
	NVIC_IPR2  volatile.Register32 // 0xE408
	NVIC_IPR3  volatile.Register32 // 0xE40C
	NVIC_IPR4  volatile.Register32 // 0xE410
	NVIC_IPR5  volatile.Register32 // 0xE414
	NVIC_IPR6  volatile.Register32 // 0xE418
	NVIC_IPR7  volatile.Register32 // 0xE41C
	_          [2272]byte
	CPUID      volatile.Register32 // 0xED00
	ICSR       volatile.Register32 // 0xED04
	VTOR       volatile.Register32 // 0xED08
	AIRCR      volatile.Register32 // 0xED0C
	SCR        volatile.Register32 // 0xED10
	CCR        volatile.Register32 // 0xED14
	_          [4]byte
	SHPR2      volatile.Register32 // 0xED1C
	SHPR3      volatile.Register32 // 0xED20
	SHCSR      volatile.Register32 // 0xED24
	_          [104]byte
	MPU_TYPE   volatile.Register32 // 0xED90
	MPU_CTRL   volatile.Register32 // 0xED94
	MPU_RNR    volatile.Register32 // 0xED98
	MPU_RBAR   volatile.Register32 // 0xED9C
	MPU_RASR   volatile.Register32 // 0xEDA0
}

// PPB.SYST_CSR: Use the SysTick Control and Status Register to enable the SysTick features.
func (o *PPB_Type) SetSYST_CSR_COUNTFLAG(value uint32) {
	volatile.StoreUint32(&o.SYST_CSR.Reg, volatile.LoadUint32(&o.SYST_CSR.Reg)&^(0x10000)|value<<16)
}
func (o *PPB_Type) GetSYST_CSR_COUNTFLAG() uint32 {
	return (volatile.LoadUint32(&o.SYST_CSR.Reg) & 0x10000) >> 16
}
func (o *PPB_Type) SetSYST_CSR_CLKSOURCE(value uint32) {
	volatile.StoreUint32(&o.SYST_CSR.Reg, volatile.LoadUint32(&o.SYST_CSR.Reg)&^(0x4)|value<<2)
}
func (o *PPB_Type) GetSYST_CSR_CLKSOURCE() uint32 {
	return (volatile.LoadUint32(&o.SYST_CSR.Reg) & 0x4) >> 2
}
func (o *PPB_Type) SetSYST_CSR_TICKINT(value uint32) {
	volatile.StoreUint32(&o.SYST_CSR.Reg, volatile.LoadUint32(&o.SYST_CSR.Reg)&^(0x2)|value<<1)
}
func (o *PPB_Type) GetSYST_CSR_TICKINT() uint32 {
	return (volatile.LoadUint32(&o.SYST_CSR.Reg) & 0x2) >> 1
}
func (o *PPB_Type) SetSYST_CSR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.SYST_CSR.Reg, volatile.LoadUint32(&o.SYST_CSR.Reg)&^(0x1)|value)
}
func (o *PPB_Type) GetSYST_CSR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.SYST_CSR.Reg) & 0x1
}

// PPB.SYST_RVR
// Use the SysTick Reload Value Register to specify the start value to load into the current value register when the counter reaches 0. It can be any value between 0 and 0x00FFFFFF. A start value of 0 is possible, but has no effect because the SysTick interrupt and COUNTFLAG are activated when counting from 1 to 0. The reset value of this register is UNKNOWN.
// To generate a multi-shot timer with a period of N processor clock cycles, use a RELOAD value of N-1. For example, if the SysTick interrupt is required every 100 clock pulses, set RELOAD to 99.
func (o *PPB_Type) SetSYST_RVR_RELOAD(value uint32) {
	volatile.StoreUint32(&o.SYST_RVR.Reg, volatile.LoadUint32(&o.SYST_RVR.Reg)&^(0xffffff)|value)
}
func (o *PPB_Type) GetSYST_RVR_RELOAD() uint32 {
	return volatile.LoadUint32(&o.SYST_RVR.Reg) & 0xffffff
}

// PPB.SYST_CVR: Use the SysTick Current Value Register to find the current value in the register. The reset value of this register is UNKNOWN.
func (o *PPB_Type) SetSYST_CVR_CURRENT(value uint32) {
	volatile.StoreUint32(&o.SYST_CVR.Reg, volatile.LoadUint32(&o.SYST_CVR.Reg)&^(0xffffff)|value)
}
func (o *PPB_Type) GetSYST_CVR_CURRENT() uint32 {
	return volatile.LoadUint32(&o.SYST_CVR.Reg) & 0xffffff
}

// PPB.SYST_CALIB: Use the SysTick Calibration Value Register to enable software to scale to any required speed using divide and multiply.
func (o *PPB_Type) SetSYST_CALIB_NOREF(value uint32) {
	volatile.StoreUint32(&o.SYST_CALIB.Reg, volatile.LoadUint32(&o.SYST_CALIB.Reg)&^(0x80000000)|value<<31)
}
func (o *PPB_Type) GetSYST_CALIB_NOREF() uint32 {
	return (volatile.LoadUint32(&o.SYST_CALIB.Reg) & 0x80000000) >> 31
}
func (o *PPB_Type) SetSYST_CALIB_SKEW(value uint32) {
	volatile.StoreUint32(&o.SYST_CALIB.Reg, volatile.LoadUint32(&o.SYST_CALIB.Reg)&^(0x40000000)|value<<30)
}
func (o *PPB_Type) GetSYST_CALIB_SKEW() uint32 {
	return (volatile.LoadUint32(&o.SYST_CALIB.Reg) & 0x40000000) >> 30
}
func (o *PPB_Type) SetSYST_CALIB_TENMS(value uint32) {
	volatile.StoreUint32(&o.SYST_CALIB.Reg, volatile.LoadUint32(&o.SYST_CALIB.Reg)&^(0xffffff)|value)
}
func (o *PPB_Type) GetSYST_CALIB_TENMS() uint32 {
	return volatile.LoadUint32(&o.SYST_CALIB.Reg) & 0xffffff
}

// PPB.NVIC_ISER
// Use the Interrupt Set-Enable Register to enable interrupts and determine which interrupts are currently enabled.
// If a pending interrupt is enabled, the NVIC activates the interrupt based on its priority. If an interrupt is not enabled, asserting its interrupt signal changes the interrupt state to pending, but the NVIC never activates the interrupt, regardless of its priority.
func (o *PPB_Type) SetNVIC_ISER(value uint32) {
	volatile.StoreUint32(&o.NVIC_ISER.Reg, value)
}
func (o *PPB_Type) GetNVIC_ISER() uint32 {
	return volatile.LoadUint32(&o.NVIC_ISER.Reg)
}

// PPB.NVIC_ICER: Use the Interrupt Clear-Enable Registers to disable interrupts and determine which interrupts are currently enabled.
func (o *PPB_Type) SetNVIC_ICER(value uint32) {
	volatile.StoreUint32(&o.NVIC_ICER.Reg, value)
}
func (o *PPB_Type) GetNVIC_ICER() uint32 {
	return volatile.LoadUint32(&o.NVIC_ICER.Reg)
}

// PPB.NVIC_ISPR: The NVIC_ISPR forces interrupts into the pending state, and shows which interrupts are pending.
func (o *PPB_Type) SetNVIC_ISPR(value uint32) {
	volatile.StoreUint32(&o.NVIC_ISPR.Reg, value)
}
func (o *PPB_Type) GetNVIC_ISPR() uint32 {
	return volatile.LoadUint32(&o.NVIC_ISPR.Reg)
}

// PPB.NVIC_ICPR: Use the Interrupt Clear-Pending Register to clear pending interrupts and determine which interrupts are currently pending.
func (o *PPB_Type) SetNVIC_ICPR(value uint32) {
	volatile.StoreUint32(&o.NVIC_ICPR.Reg, value)
}
func (o *PPB_Type) GetNVIC_ICPR() uint32 {
	return volatile.LoadUint32(&o.NVIC_ICPR.Reg)
}

// PPB.NVIC_IPR0
// Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
// Note: Writing 1 to an NVIC_ICPR bit does not affect the active state of the corresponding interrupt.
// These registers are only word-accessible
func (o *PPB_Type) SetNVIC_IPR0_IP_3(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR0.Reg, volatile.LoadUint32(&o.NVIC_IPR0.Reg)&^(0xc0000000)|value<<30)
}
func (o *PPB_Type) GetNVIC_IPR0_IP_3() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR0.Reg) & 0xc0000000) >> 30
}
func (o *PPB_Type) SetNVIC_IPR0_IP_2(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR0.Reg, volatile.LoadUint32(&o.NVIC_IPR0.Reg)&^(0xc00000)|value<<22)
}
func (o *PPB_Type) GetNVIC_IPR0_IP_2() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR0.Reg) & 0xc00000) >> 22
}
func (o *PPB_Type) SetNVIC_IPR0_IP_1(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR0.Reg, volatile.LoadUint32(&o.NVIC_IPR0.Reg)&^(0xc000)|value<<14)
}
func (o *PPB_Type) GetNVIC_IPR0_IP_1() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR0.Reg) & 0xc000) >> 14
}
func (o *PPB_Type) SetNVIC_IPR0_IP_0(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR0.Reg, volatile.LoadUint32(&o.NVIC_IPR0.Reg)&^(0xc0)|value<<6)
}
func (o *PPB_Type) GetNVIC_IPR0_IP_0() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR0.Reg) & 0xc0) >> 6
}

// PPB.NVIC_IPR1: Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
func (o *PPB_Type) SetNVIC_IPR1_IP_7(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR1.Reg, volatile.LoadUint32(&o.NVIC_IPR1.Reg)&^(0xc0000000)|value<<30)
}
func (o *PPB_Type) GetNVIC_IPR1_IP_7() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR1.Reg) & 0xc0000000) >> 30
}
func (o *PPB_Type) SetNVIC_IPR1_IP_6(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR1.Reg, volatile.LoadUint32(&o.NVIC_IPR1.Reg)&^(0xc00000)|value<<22)
}
func (o *PPB_Type) GetNVIC_IPR1_IP_6() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR1.Reg) & 0xc00000) >> 22
}
func (o *PPB_Type) SetNVIC_IPR1_IP_5(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR1.Reg, volatile.LoadUint32(&o.NVIC_IPR1.Reg)&^(0xc000)|value<<14)
}
func (o *PPB_Type) GetNVIC_IPR1_IP_5() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR1.Reg) & 0xc000) >> 14
}
func (o *PPB_Type) SetNVIC_IPR1_IP_4(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR1.Reg, volatile.LoadUint32(&o.NVIC_IPR1.Reg)&^(0xc0)|value<<6)
}
func (o *PPB_Type) GetNVIC_IPR1_IP_4() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR1.Reg) & 0xc0) >> 6
}

// PPB.NVIC_IPR2: Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
func (o *PPB_Type) SetNVIC_IPR2_IP_11(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR2.Reg, volatile.LoadUint32(&o.NVIC_IPR2.Reg)&^(0xc0000000)|value<<30)
}
func (o *PPB_Type) GetNVIC_IPR2_IP_11() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR2.Reg) & 0xc0000000) >> 30
}
func (o *PPB_Type) SetNVIC_IPR2_IP_10(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR2.Reg, volatile.LoadUint32(&o.NVIC_IPR2.Reg)&^(0xc00000)|value<<22)
}
func (o *PPB_Type) GetNVIC_IPR2_IP_10() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR2.Reg) & 0xc00000) >> 22
}
func (o *PPB_Type) SetNVIC_IPR2_IP_9(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR2.Reg, volatile.LoadUint32(&o.NVIC_IPR2.Reg)&^(0xc000)|value<<14)
}
func (o *PPB_Type) GetNVIC_IPR2_IP_9() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR2.Reg) & 0xc000) >> 14
}
func (o *PPB_Type) SetNVIC_IPR2_IP_8(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR2.Reg, volatile.LoadUint32(&o.NVIC_IPR2.Reg)&^(0xc0)|value<<6)
}
func (o *PPB_Type) GetNVIC_IPR2_IP_8() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR2.Reg) & 0xc0) >> 6
}

// PPB.NVIC_IPR3: Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
func (o *PPB_Type) SetNVIC_IPR3_IP_15(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR3.Reg, volatile.LoadUint32(&o.NVIC_IPR3.Reg)&^(0xc0000000)|value<<30)
}
func (o *PPB_Type) GetNVIC_IPR3_IP_15() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR3.Reg) & 0xc0000000) >> 30
}
func (o *PPB_Type) SetNVIC_IPR3_IP_14(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR3.Reg, volatile.LoadUint32(&o.NVIC_IPR3.Reg)&^(0xc00000)|value<<22)
}
func (o *PPB_Type) GetNVIC_IPR3_IP_14() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR3.Reg) & 0xc00000) >> 22
}
func (o *PPB_Type) SetNVIC_IPR3_IP_13(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR3.Reg, volatile.LoadUint32(&o.NVIC_IPR3.Reg)&^(0xc000)|value<<14)
}
func (o *PPB_Type) GetNVIC_IPR3_IP_13() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR3.Reg) & 0xc000) >> 14
}
func (o *PPB_Type) SetNVIC_IPR3_IP_12(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR3.Reg, volatile.LoadUint32(&o.NVIC_IPR3.Reg)&^(0xc0)|value<<6)
}
func (o *PPB_Type) GetNVIC_IPR3_IP_12() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR3.Reg) & 0xc0) >> 6
}

// PPB.NVIC_IPR4: Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
func (o *PPB_Type) SetNVIC_IPR4_IP_19(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR4.Reg, volatile.LoadUint32(&o.NVIC_IPR4.Reg)&^(0xc0000000)|value<<30)
}
func (o *PPB_Type) GetNVIC_IPR4_IP_19() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR4.Reg) & 0xc0000000) >> 30
}
func (o *PPB_Type) SetNVIC_IPR4_IP_18(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR4.Reg, volatile.LoadUint32(&o.NVIC_IPR4.Reg)&^(0xc00000)|value<<22)
}
func (o *PPB_Type) GetNVIC_IPR4_IP_18() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR4.Reg) & 0xc00000) >> 22
}
func (o *PPB_Type) SetNVIC_IPR4_IP_17(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR4.Reg, volatile.LoadUint32(&o.NVIC_IPR4.Reg)&^(0xc000)|value<<14)
}
func (o *PPB_Type) GetNVIC_IPR4_IP_17() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR4.Reg) & 0xc000) >> 14
}
func (o *PPB_Type) SetNVIC_IPR4_IP_16(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR4.Reg, volatile.LoadUint32(&o.NVIC_IPR4.Reg)&^(0xc0)|value<<6)
}
func (o *PPB_Type) GetNVIC_IPR4_IP_16() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR4.Reg) & 0xc0) >> 6
}

// PPB.NVIC_IPR5: Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
func (o *PPB_Type) SetNVIC_IPR5_IP_23(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR5.Reg, volatile.LoadUint32(&o.NVIC_IPR5.Reg)&^(0xc0000000)|value<<30)
}
func (o *PPB_Type) GetNVIC_IPR5_IP_23() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR5.Reg) & 0xc0000000) >> 30
}
func (o *PPB_Type) SetNVIC_IPR5_IP_22(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR5.Reg, volatile.LoadUint32(&o.NVIC_IPR5.Reg)&^(0xc00000)|value<<22)
}
func (o *PPB_Type) GetNVIC_IPR5_IP_22() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR5.Reg) & 0xc00000) >> 22
}
func (o *PPB_Type) SetNVIC_IPR5_IP_21(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR5.Reg, volatile.LoadUint32(&o.NVIC_IPR5.Reg)&^(0xc000)|value<<14)
}
func (o *PPB_Type) GetNVIC_IPR5_IP_21() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR5.Reg) & 0xc000) >> 14
}
func (o *PPB_Type) SetNVIC_IPR5_IP_20(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR5.Reg, volatile.LoadUint32(&o.NVIC_IPR5.Reg)&^(0xc0)|value<<6)
}
func (o *PPB_Type) GetNVIC_IPR5_IP_20() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR5.Reg) & 0xc0) >> 6
}

// PPB.NVIC_IPR6: Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
func (o *PPB_Type) SetNVIC_IPR6_IP_27(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR6.Reg, volatile.LoadUint32(&o.NVIC_IPR6.Reg)&^(0xc0000000)|value<<30)
}
func (o *PPB_Type) GetNVIC_IPR6_IP_27() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR6.Reg) & 0xc0000000) >> 30
}
func (o *PPB_Type) SetNVIC_IPR6_IP_26(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR6.Reg, volatile.LoadUint32(&o.NVIC_IPR6.Reg)&^(0xc00000)|value<<22)
}
func (o *PPB_Type) GetNVIC_IPR6_IP_26() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR6.Reg) & 0xc00000) >> 22
}
func (o *PPB_Type) SetNVIC_IPR6_IP_25(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR6.Reg, volatile.LoadUint32(&o.NVIC_IPR6.Reg)&^(0xc000)|value<<14)
}
func (o *PPB_Type) GetNVIC_IPR6_IP_25() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR6.Reg) & 0xc000) >> 14
}
func (o *PPB_Type) SetNVIC_IPR6_IP_24(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR6.Reg, volatile.LoadUint32(&o.NVIC_IPR6.Reg)&^(0xc0)|value<<6)
}
func (o *PPB_Type) GetNVIC_IPR6_IP_24() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR6.Reg) & 0xc0) >> 6
}

// PPB.NVIC_IPR7: Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
func (o *PPB_Type) SetNVIC_IPR7_IP_31(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR7.Reg, volatile.LoadUint32(&o.NVIC_IPR7.Reg)&^(0xc0000000)|value<<30)
}
func (o *PPB_Type) GetNVIC_IPR7_IP_31() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR7.Reg) & 0xc0000000) >> 30
}
func (o *PPB_Type) SetNVIC_IPR7_IP_30(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR7.Reg, volatile.LoadUint32(&o.NVIC_IPR7.Reg)&^(0xc00000)|value<<22)
}
func (o *PPB_Type) GetNVIC_IPR7_IP_30() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR7.Reg) & 0xc00000) >> 22
}
func (o *PPB_Type) SetNVIC_IPR7_IP_29(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR7.Reg, volatile.LoadUint32(&o.NVIC_IPR7.Reg)&^(0xc000)|value<<14)
}
func (o *PPB_Type) GetNVIC_IPR7_IP_29() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR7.Reg) & 0xc000) >> 14
}
func (o *PPB_Type) SetNVIC_IPR7_IP_28(value uint32) {
	volatile.StoreUint32(&o.NVIC_IPR7.Reg, volatile.LoadUint32(&o.NVIC_IPR7.Reg)&^(0xc0)|value<<6)
}
func (o *PPB_Type) GetNVIC_IPR7_IP_28() uint32 {
	return (volatile.LoadUint32(&o.NVIC_IPR7.Reg) & 0xc0) >> 6
}

// PPB.CPUID: Read the CPU ID Base Register to determine: the ID number of the processor core, the version number of the processor core, the implementation details of the processor core.
func (o *PPB_Type) SetCPUID_IMPLEMENTER(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xff000000)|value<<24)
}
func (o *PPB_Type) GetCPUID_IMPLEMENTER() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xff000000) >> 24
}
func (o *PPB_Type) SetCPUID_VARIANT(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf00000)|value<<20)
}
func (o *PPB_Type) GetCPUID_VARIANT() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xf00000) >> 20
}
func (o *PPB_Type) SetCPUID_ARCHITECTURE(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf0000)|value<<16)
}
func (o *PPB_Type) GetCPUID_ARCHITECTURE() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xf0000) >> 16
}
func (o *PPB_Type) SetCPUID_PARTNO(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xfff0)|value<<4)
}
func (o *PPB_Type) GetCPUID_PARTNO() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xfff0) >> 4
}
func (o *PPB_Type) SetCPUID_REVISION(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf)|value)
}
func (o *PPB_Type) GetCPUID_REVISION() uint32 {
	return volatile.LoadUint32(&o.CPUID.Reg) & 0xf
}

// PPB.ICSR: Use the Interrupt Control State Register to set a pending Non-Maskable Interrupt (NMI), set or clear a pending PendSV, set or clear a pending SysTick, check for pending exceptions, check the vector number of the highest priority pended exception, check the vector number of the active exception.
func (o *PPB_Type) SetICSR_NMIPENDSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x80000000)|value<<31)
}
func (o *PPB_Type) GetICSR_NMIPENDSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x80000000) >> 31
}
func (o *PPB_Type) SetICSR_PENDSVSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x10000000)|value<<28)
}
func (o *PPB_Type) GetICSR_PENDSVSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x10000000) >> 28
}
func (o *PPB_Type) SetICSR_PENDSVCLR(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x8000000)|value<<27)
}
func (o *PPB_Type) GetICSR_PENDSVCLR() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x8000000) >> 27
}
func (o *PPB_Type) SetICSR_PENDSTSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x4000000)|value<<26)
}
func (o *PPB_Type) GetICSR_PENDSTSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x4000000) >> 26
}
func (o *PPB_Type) SetICSR_PENDSTCLR(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x2000000)|value<<25)
}
func (o *PPB_Type) GetICSR_PENDSTCLR() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x2000000) >> 25
}
func (o *PPB_Type) SetICSR_ISRPREEMPT(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x800000)|value<<23)
}
func (o *PPB_Type) GetICSR_ISRPREEMPT() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x800000) >> 23
}
func (o *PPB_Type) SetICSR_ISRPENDING(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x400000)|value<<22)
}
func (o *PPB_Type) GetICSR_ISRPENDING() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x400000) >> 22
}
func (o *PPB_Type) SetICSR_VECTPENDING(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x1ff000)|value<<12)
}
func (o *PPB_Type) GetICSR_VECTPENDING() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x1ff000) >> 12
}
func (o *PPB_Type) SetICSR_VECTACTIVE(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x1ff)|value)
}
func (o *PPB_Type) GetICSR_VECTACTIVE() uint32 {
	return volatile.LoadUint32(&o.ICSR.Reg) & 0x1ff
}

// PPB.VTOR: The VTOR holds the vector table offset address.
func (o *PPB_Type) SetVTOR_TBLOFF(value uint32) {
	volatile.StoreUint32(&o.VTOR.Reg, volatile.LoadUint32(&o.VTOR.Reg)&^(0xffffff00)|value<<8)
}
func (o *PPB_Type) GetVTOR_TBLOFF() uint32 {
	return (volatile.LoadUint32(&o.VTOR.Reg) & 0xffffff00) >> 8
}

// PPB.AIRCR: Use the Application Interrupt and Reset Control Register to: determine data endianness, clear all active state information from debug halt mode, request a system reset.
func (o *PPB_Type) SetAIRCR_VECTKEY(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0xffff0000)|value<<16)
}
func (o *PPB_Type) GetAIRCR_VECTKEY() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0xffff0000) >> 16
}
func (o *PPB_Type) SetAIRCR_ENDIANESS(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x8000)|value<<15)
}
func (o *PPB_Type) GetAIRCR_ENDIANESS() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x8000) >> 15
}
func (o *PPB_Type) SetAIRCR_SYSRESETREQ(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x4)|value<<2)
}
func (o *PPB_Type) GetAIRCR_SYSRESETREQ() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x4) >> 2
}
func (o *PPB_Type) SetAIRCR_VECTCLRACTIVE(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x2)|value<<1)
}
func (o *PPB_Type) GetAIRCR_VECTCLRACTIVE() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x2) >> 1
}

// PPB.SCR: System Control Register. Use the System Control Register for power-management functions: signal to the system when the processor can enter a low power state, control how the processor enters and exits low power states.
func (o *PPB_Type) SetSCR_SEVONPEND(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *PPB_Type) GetSCR_SEVONPEND() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x10) >> 4
}
func (o *PPB_Type) SetSCR_SLEEPDEEP(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *PPB_Type) GetSCR_SLEEPDEEP() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x4) >> 2
}
func (o *PPB_Type) SetSCR_SLEEPONEXIT(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x2)|value<<1)
}
func (o *PPB_Type) GetSCR_SLEEPONEXIT() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x2) >> 1
}

// PPB.CCR: The Configuration and Control Register permanently enables stack alignment and causes unaligned accesses to result in a Hard Fault.
func (o *PPB_Type) SetCCR_STKALIGN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x200)|value<<9)
}
func (o *PPB_Type) GetCCR_STKALIGN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x200) >> 9
}
func (o *PPB_Type) SetCCR_UNALIGN_TRP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x8)|value<<3)
}
func (o *PPB_Type) GetCCR_UNALIGN_TRP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x8) >> 3
}

// PPB.SHPR2: System handlers are a special class of exception handler that can have their priority set to any of the priority levels. Use the System Handler Priority Register 2 to set the priority of SVCall.
func (o *PPB_Type) SetSHPR2_PRI_11(value uint32) {
	volatile.StoreUint32(&o.SHPR2.Reg, volatile.LoadUint32(&o.SHPR2.Reg)&^(0xc0000000)|value<<30)
}
func (o *PPB_Type) GetSHPR2_PRI_11() uint32 {
	return (volatile.LoadUint32(&o.SHPR2.Reg) & 0xc0000000) >> 30
}

// PPB.SHPR3: System handlers are a special class of exception handler that can have their priority set to any of the priority levels. Use the System Handler Priority Register 3 to set the priority of PendSV and SysTick.
func (o *PPB_Type) SetSHPR3_PRI_15(value uint32) {
	volatile.StoreUint32(&o.SHPR3.Reg, volatile.LoadUint32(&o.SHPR3.Reg)&^(0xc0000000)|value<<30)
}
func (o *PPB_Type) GetSHPR3_PRI_15() uint32 {
	return (volatile.LoadUint32(&o.SHPR3.Reg) & 0xc0000000) >> 30
}
func (o *PPB_Type) SetSHPR3_PRI_14(value uint32) {
	volatile.StoreUint32(&o.SHPR3.Reg, volatile.LoadUint32(&o.SHPR3.Reg)&^(0xc00000)|value<<22)
}
func (o *PPB_Type) GetSHPR3_PRI_14() uint32 {
	return (volatile.LoadUint32(&o.SHPR3.Reg) & 0xc00000) >> 22
}

// PPB.SHCSR: Use the System Handler Control and State Register to determine or clear the pending status of SVCall.
func (o *PPB_Type) SetSHCSR_SVCALLPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x8000)|value<<15)
}
func (o *PPB_Type) GetSHCSR_SVCALLPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x8000) >> 15
}

// PPB.MPU_TYPE: Read the MPU Type Register to determine if the processor implements an MPU, and how many regions the MPU supports.
func (o *PPB_Type) SetMPU_TYPE_IREGION(value uint32) {
	volatile.StoreUint32(&o.MPU_TYPE.Reg, volatile.LoadUint32(&o.MPU_TYPE.Reg)&^(0xff0000)|value<<16)
}
func (o *PPB_Type) GetMPU_TYPE_IREGION() uint32 {
	return (volatile.LoadUint32(&o.MPU_TYPE.Reg) & 0xff0000) >> 16
}
func (o *PPB_Type) SetMPU_TYPE_DREGION(value uint32) {
	volatile.StoreUint32(&o.MPU_TYPE.Reg, volatile.LoadUint32(&o.MPU_TYPE.Reg)&^(0xff00)|value<<8)
}
func (o *PPB_Type) GetMPU_TYPE_DREGION() uint32 {
	return (volatile.LoadUint32(&o.MPU_TYPE.Reg) & 0xff00) >> 8
}
func (o *PPB_Type) SetMPU_TYPE_SEPARATE(value uint32) {
	volatile.StoreUint32(&o.MPU_TYPE.Reg, volatile.LoadUint32(&o.MPU_TYPE.Reg)&^(0x1)|value)
}
func (o *PPB_Type) GetMPU_TYPE_SEPARATE() uint32 {
	return volatile.LoadUint32(&o.MPU_TYPE.Reg) & 0x1
}

// PPB.MPU_CTRL: Use the MPU Control Register to enable and disable the MPU, and to control whether the default memory map is enabled as a background region for privileged accesses, and whether the MPU is enabled for HardFaults and NMIs.
func (o *PPB_Type) SetMPU_CTRL_PRIVDEFENA(value uint32) {
	volatile.StoreUint32(&o.MPU_CTRL.Reg, volatile.LoadUint32(&o.MPU_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *PPB_Type) GetMPU_CTRL_PRIVDEFENA() uint32 {
	return (volatile.LoadUint32(&o.MPU_CTRL.Reg) & 0x4) >> 2
}
func (o *PPB_Type) SetMPU_CTRL_HFNMIENA(value uint32) {
	volatile.StoreUint32(&o.MPU_CTRL.Reg, volatile.LoadUint32(&o.MPU_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *PPB_Type) GetMPU_CTRL_HFNMIENA() uint32 {
	return (volatile.LoadUint32(&o.MPU_CTRL.Reg) & 0x2) >> 1
}
func (o *PPB_Type) SetMPU_CTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.MPU_CTRL.Reg, volatile.LoadUint32(&o.MPU_CTRL.Reg)&^(0x1)|value)
}
func (o *PPB_Type) GetMPU_CTRL_ENABLE() uint32 {
	return volatile.LoadUint32(&o.MPU_CTRL.Reg) & 0x1
}

// PPB.MPU_RNR: Use the MPU Region Number Register to select the region currently accessed by MPU_RBAR and MPU_RASR.
func (o *PPB_Type) SetMPU_RNR_REGION(value uint32) {
	volatile.StoreUint32(&o.MPU_RNR.Reg, volatile.LoadUint32(&o.MPU_RNR.Reg)&^(0xf)|value)
}
func (o *PPB_Type) GetMPU_RNR_REGION() uint32 {
	return volatile.LoadUint32(&o.MPU_RNR.Reg) & 0xf
}

// PPB.MPU_RBAR: Read the MPU Region Base Address Register to determine the base address of the region identified by MPU_RNR. Write to update the base address of said region or that of a specified region, with whose number MPU_RNR will also be updated.
func (o *PPB_Type) SetMPU_RBAR_ADDR(value uint32) {
	volatile.StoreUint32(&o.MPU_RBAR.Reg, volatile.LoadUint32(&o.MPU_RBAR.Reg)&^(0xffffff00)|value<<8)
}
func (o *PPB_Type) GetMPU_RBAR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.MPU_RBAR.Reg) & 0xffffff00) >> 8
}
func (o *PPB_Type) SetMPU_RBAR_VALID(value uint32) {
	volatile.StoreUint32(&o.MPU_RBAR.Reg, volatile.LoadUint32(&o.MPU_RBAR.Reg)&^(0x10)|value<<4)
}
func (o *PPB_Type) GetMPU_RBAR_VALID() uint32 {
	return (volatile.LoadUint32(&o.MPU_RBAR.Reg) & 0x10) >> 4
}
func (o *PPB_Type) SetMPU_RBAR_REGION(value uint32) {
	volatile.StoreUint32(&o.MPU_RBAR.Reg, volatile.LoadUint32(&o.MPU_RBAR.Reg)&^(0xf)|value)
}
func (o *PPB_Type) GetMPU_RBAR_REGION() uint32 {
	return volatile.LoadUint32(&o.MPU_RBAR.Reg) & 0xf
}

// PPB.MPU_RASR: Use the MPU Region Attribute and Size Register to define the size, access behaviour and memory type of the region identified by MPU_RNR, and enable that region.
func (o *PPB_Type) SetMPU_RASR_ATTRS(value uint32) {
	volatile.StoreUint32(&o.MPU_RASR.Reg, volatile.LoadUint32(&o.MPU_RASR.Reg)&^(0xffff0000)|value<<16)
}
func (o *PPB_Type) GetMPU_RASR_ATTRS() uint32 {
	return (volatile.LoadUint32(&o.MPU_RASR.Reg) & 0xffff0000) >> 16
}
func (o *PPB_Type) SetMPU_RASR_SRD(value uint32) {
	volatile.StoreUint32(&o.MPU_RASR.Reg, volatile.LoadUint32(&o.MPU_RASR.Reg)&^(0xff00)|value<<8)
}
func (o *PPB_Type) GetMPU_RASR_SRD() uint32 {
	return (volatile.LoadUint32(&o.MPU_RASR.Reg) & 0xff00) >> 8
}
func (o *PPB_Type) SetMPU_RASR_SIZE(value uint32) {
	volatile.StoreUint32(&o.MPU_RASR.Reg, volatile.LoadUint32(&o.MPU_RASR.Reg)&^(0x3e)|value<<1)
}
func (o *PPB_Type) GetMPU_RASR_SIZE() uint32 {
	return (volatile.LoadUint32(&o.MPU_RASR.Reg) & 0x3e) >> 1
}
func (o *PPB_Type) SetMPU_RASR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.MPU_RASR.Reg, volatile.LoadUint32(&o.MPU_RASR.Reg)&^(0x1)|value)
}
func (o *PPB_Type) GetMPU_RASR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.MPU_RASR.Reg) & 0x1
}

// Constants for XIP_CTRL: QSPI flash execute-in-place block
const (
	// CTRL: Cache control
	// Position of POWER_DOWN field.
	XIP_CTRL_CTRL_POWER_DOWN_Pos = 0x3
	// Bit mask of POWER_DOWN field.
	XIP_CTRL_CTRL_POWER_DOWN_Msk = 0x8
	// Bit POWER_DOWN.
	XIP_CTRL_CTRL_POWER_DOWN = 0x8
	// Position of ERR_BADWRITE field.
	XIP_CTRL_CTRL_ERR_BADWRITE_Pos = 0x1
	// Bit mask of ERR_BADWRITE field.
	XIP_CTRL_CTRL_ERR_BADWRITE_Msk = 0x2
	// Bit ERR_BADWRITE.
	XIP_CTRL_CTRL_ERR_BADWRITE = 0x2
	// Position of EN field.
	XIP_CTRL_CTRL_EN_Pos = 0x0
	// Bit mask of EN field.
	XIP_CTRL_CTRL_EN_Msk = 0x1
	// Bit EN.
	XIP_CTRL_CTRL_EN = 0x1

	// FLUSH: Cache Flush control
	// Position of FLUSH field.
	XIP_CTRL_FLUSH_FLUSH_Pos = 0x0
	// Bit mask of FLUSH field.
	XIP_CTRL_FLUSH_FLUSH_Msk = 0x1
	// Bit FLUSH.
	XIP_CTRL_FLUSH_FLUSH = 0x1

	// STAT: Cache Status
	// Position of FIFO_FULL field.
	XIP_CTRL_STAT_FIFO_FULL_Pos = 0x2
	// Bit mask of FIFO_FULL field.
	XIP_CTRL_STAT_FIFO_FULL_Msk = 0x4
	// Bit FIFO_FULL.
	XIP_CTRL_STAT_FIFO_FULL = 0x4
	// Position of FIFO_EMPTY field.
	XIP_CTRL_STAT_FIFO_EMPTY_Pos = 0x1
	// Bit mask of FIFO_EMPTY field.
	XIP_CTRL_STAT_FIFO_EMPTY_Msk = 0x2
	// Bit FIFO_EMPTY.
	XIP_CTRL_STAT_FIFO_EMPTY = 0x2
	// Position of FLUSH_READY field.
	XIP_CTRL_STAT_FLUSH_READY_Pos = 0x0
	// Bit mask of FLUSH_READY field.
	XIP_CTRL_STAT_FLUSH_READY_Msk = 0x1
	// Bit FLUSH_READY.
	XIP_CTRL_STAT_FLUSH_READY = 0x1

	// STREAM_ADDR: FIFO stream address
	// Position of STREAM_ADDR field.
	XIP_CTRL_STREAM_ADDR_STREAM_ADDR_Pos = 0x2
	// Bit mask of STREAM_ADDR field.
	XIP_CTRL_STREAM_ADDR_STREAM_ADDR_Msk = 0xfffffffc

	// STREAM_CTR: FIFO stream control
	// Position of STREAM_CTR field.
	XIP_CTRL_STREAM_CTR_STREAM_CTR_Pos = 0x0
	// Bit mask of STREAM_CTR field.
	XIP_CTRL_STREAM_CTR_STREAM_CTR_Msk = 0x3fffff
)

// Constants for XIP_SSI
// DW_apb_ssi has the following features:
// * APB interface – Allows for easy integration into a DesignWare Synthesizable Components for AMBA 2 implementation.
// * APB3 and APB4 protocol support.
// * Scalable APB data bus width – Supports APB data bus widths of 8, 16, and 32 bits.
// * Serial-master or serial-slave operation – Enables serial communication with serial-master or serial-slave peripheral devices.
// * Programmable Dual/Quad/Octal SPI support in Master Mode.
// * Dual Data Rate (DDR) and Read Data Strobe (RDS) Support - Enables the DW_apb_ssi master to perform operations with the device in DDR and RDS modes when working in Dual/Quad/Octal mode of operation.
// * Data Mask Support - Enables the DW_apb_ssi to selectively update the bytes in the device. This feature is applicable only in enhanced SPI modes.
// * eXecute-In-Place (XIP) support - Enables the DW_apb_ssi master to behave as a memory mapped I/O and fetches the data from the device based on the APB read request. This feature is applicable only in enhanced SPI modes.
// * DMA Controller Interface – Enables the DW_apb_ssi to interface to a DMA controller over the bus using a handshaking interface for transfer requests.
// * Independent masking of interrupts – Master collision, transmit FIFO overflow, transmit FIFO empty, receive FIFO full, receive FIFO underflow, and receive FIFO overflow interrupts can all be masked independently.
// * Multi-master contention detection – Informs the processor of multiple serial-master accesses on the serial bus.
// * Bypass of meta-stability flip-flops for synchronous clocks – When the APB clock (pclk) and the DW_apb_ssi serial clock (ssi_clk) are synchronous, meta-stable flip-flops are not used when transferring control signals across these clock domains.
// * Programmable delay on the sample time of the received serial data bit (rxd); enables programmable control of routing delays resulting in higher serial data-bit rates.
// * Programmable features:
// - Serial interface operation – Choice of Motorola SPI, Texas Instruments Synchronous Serial Protocol or National Semiconductor Microwire.
// - Clock bit-rate – Dynamic control of the serial bit rate of the data transfer; used in only serial-master mode of operation.
// - Data Item size (4 to 32 bits) – Item size of each data transfer under the control of the programmer.
// * Configured features:
// - FIFO depth – 16 words deep. The FIFO width is fixed at 32 bits.
// - 1 slave select output.
// - Hardware slave-select – Dedicated hardware slave-select line.
// - Combined interrupt line - one combined interrupt line from the DW_apb_ssi to the interrupt controller.
// - Interrupt polarity – active high interrupt lines.
// - Serial clock polarity – low serial-clock polarity directly after reset.
// - Serial clock phase – capture on first edge of serial-clock directly after reset.
const (
	// CTRLR0: Control register 0
	// Position of SSTE field.
	XIP_SSI_CTRLR0_SSTE_Pos = 0x18
	// Bit mask of SSTE field.
	XIP_SSI_CTRLR0_SSTE_Msk = 0x1000000
	// Bit SSTE.
	XIP_SSI_CTRLR0_SSTE = 0x1000000
	// Position of SPI_FRF field.
	XIP_SSI_CTRLR0_SPI_FRF_Pos = 0x15
	// Bit mask of SPI_FRF field.
	XIP_SSI_CTRLR0_SPI_FRF_Msk = 0x600000
	// Standard 1-bit SPI frame format; 1 bit per SCK, full-duplex
	XIP_SSI_CTRLR0_SPI_FRF_STD = 0x0
	// Dual-SPI frame format; two bits per SCK, half-duplex
	XIP_SSI_CTRLR0_SPI_FRF_DUAL = 0x1
	// Quad-SPI frame format; four bits per SCK, half-duplex
	XIP_SSI_CTRLR0_SPI_FRF_QUAD = 0x2
	// Position of DFS_32 field.
	XIP_SSI_CTRLR0_DFS_32_Pos = 0x10
	// Bit mask of DFS_32 field.
	XIP_SSI_CTRLR0_DFS_32_Msk = 0x1f0000
	// Position of CFS field.
	XIP_SSI_CTRLR0_CFS_Pos = 0xc
	// Bit mask of CFS field.
	XIP_SSI_CTRLR0_CFS_Msk = 0xf000
	// Position of SRL field.
	XIP_SSI_CTRLR0_SRL_Pos = 0xb
	// Bit mask of SRL field.
	XIP_SSI_CTRLR0_SRL_Msk = 0x800
	// Bit SRL.
	XIP_SSI_CTRLR0_SRL = 0x800
	// Position of SLV_OE field.
	XIP_SSI_CTRLR0_SLV_OE_Pos = 0xa
	// Bit mask of SLV_OE field.
	XIP_SSI_CTRLR0_SLV_OE_Msk = 0x400
	// Bit SLV_OE.
	XIP_SSI_CTRLR0_SLV_OE = 0x400
	// Position of TMOD field.
	XIP_SSI_CTRLR0_TMOD_Pos = 0x8
	// Bit mask of TMOD field.
	XIP_SSI_CTRLR0_TMOD_Msk = 0x300
	// Both transmit and receive
	XIP_SSI_CTRLR0_TMOD_TX_AND_RX = 0x0
	// Transmit only (not for FRF == 0, standard SPI mode)
	XIP_SSI_CTRLR0_TMOD_TX_ONLY = 0x1
	// Receive only (not for FRF == 0, standard SPI mode)
	XIP_SSI_CTRLR0_TMOD_RX_ONLY = 0x2
	// EEPROM read mode (TX then RX; RX starts after control data TX'd)
	XIP_SSI_CTRLR0_TMOD_EEPROM_READ = 0x3
	// Position of SCPOL field.
	XIP_SSI_CTRLR0_SCPOL_Pos = 0x7
	// Bit mask of SCPOL field.
	XIP_SSI_CTRLR0_SCPOL_Msk = 0x80
	// Bit SCPOL.
	XIP_SSI_CTRLR0_SCPOL = 0x80
	// Position of SCPH field.
	XIP_SSI_CTRLR0_SCPH_Pos = 0x6
	// Bit mask of SCPH field.
	XIP_SSI_CTRLR0_SCPH_Msk = 0x40
	// Bit SCPH.
	XIP_SSI_CTRLR0_SCPH = 0x40
	// Position of FRF field.
	XIP_SSI_CTRLR0_FRF_Pos = 0x4
	// Bit mask of FRF field.
	XIP_SSI_CTRLR0_FRF_Msk = 0x30
	// Position of DFS field.
	XIP_SSI_CTRLR0_DFS_Pos = 0x0
	// Bit mask of DFS field.
	XIP_SSI_CTRLR0_DFS_Msk = 0xf

	// CTRLR1: Master Control register 1
	// Position of NDF field.
	XIP_SSI_CTRLR1_NDF_Pos = 0x0
	// Bit mask of NDF field.
	XIP_SSI_CTRLR1_NDF_Msk = 0xffff

	// SSIENR: SSI Enable
	// Position of SSI_EN field.
	XIP_SSI_SSIENR_SSI_EN_Pos = 0x0
	// Bit mask of SSI_EN field.
	XIP_SSI_SSIENR_SSI_EN_Msk = 0x1
	// Bit SSI_EN.
	XIP_SSI_SSIENR_SSI_EN = 0x1

	// MWCR: Microwire Control
	// Position of MHS field.
	XIP_SSI_MWCR_MHS_Pos = 0x2
	// Bit mask of MHS field.
	XIP_SSI_MWCR_MHS_Msk = 0x4
	// Bit MHS.
	XIP_SSI_MWCR_MHS = 0x4
	// Position of MDD field.
	XIP_SSI_MWCR_MDD_Pos = 0x1
	// Bit mask of MDD field.
	XIP_SSI_MWCR_MDD_Msk = 0x2
	// Bit MDD.
	XIP_SSI_MWCR_MDD = 0x2
	// Position of MWMOD field.
	XIP_SSI_MWCR_MWMOD_Pos = 0x0
	// Bit mask of MWMOD field.
	XIP_SSI_MWCR_MWMOD_Msk = 0x1
	// Bit MWMOD.
	XIP_SSI_MWCR_MWMOD = 0x1

	// SER: Slave enable
	// Position of SER field.
	XIP_SSI_SER_SER_Pos = 0x0
	// Bit mask of SER field.
	XIP_SSI_SER_SER_Msk = 0x1
	// Bit SER.
	XIP_SSI_SER_SER = 0x1

	// BAUDR: Baud rate
	// Position of SCKDV field.
	XIP_SSI_BAUDR_SCKDV_Pos = 0x0
	// Bit mask of SCKDV field.
	XIP_SSI_BAUDR_SCKDV_Msk = 0xffff

	// TXFTLR: TX FIFO threshold level
	// Position of TFT field.
	XIP_SSI_TXFTLR_TFT_Pos = 0x0
	// Bit mask of TFT field.
	XIP_SSI_TXFTLR_TFT_Msk = 0xff

	// RXFTLR: RX FIFO threshold level
	// Position of RFT field.
	XIP_SSI_RXFTLR_RFT_Pos = 0x0
	// Bit mask of RFT field.
	XIP_SSI_RXFTLR_RFT_Msk = 0xff

	// TXFLR: TX FIFO level
	// Position of TFTFL field.
	XIP_SSI_TXFLR_TFTFL_Pos = 0x0
	// Bit mask of TFTFL field.
	XIP_SSI_TXFLR_TFTFL_Msk = 0xff

	// RXFLR: RX FIFO level
	// Position of RXTFL field.
	XIP_SSI_RXFLR_RXTFL_Pos = 0x0
	// Bit mask of RXTFL field.
	XIP_SSI_RXFLR_RXTFL_Msk = 0xff

	// SR: Status register
	// Position of DCOL field.
	XIP_SSI_SR_DCOL_Pos = 0x6
	// Bit mask of DCOL field.
	XIP_SSI_SR_DCOL_Msk = 0x40
	// Bit DCOL.
	XIP_SSI_SR_DCOL = 0x40
	// Position of TXE field.
	XIP_SSI_SR_TXE_Pos = 0x5
	// Bit mask of TXE field.
	XIP_SSI_SR_TXE_Msk = 0x20
	// Bit TXE.
	XIP_SSI_SR_TXE = 0x20
	// Position of RFF field.
	XIP_SSI_SR_RFF_Pos = 0x4
	// Bit mask of RFF field.
	XIP_SSI_SR_RFF_Msk = 0x10
	// Bit RFF.
	XIP_SSI_SR_RFF = 0x10
	// Position of RFNE field.
	XIP_SSI_SR_RFNE_Pos = 0x3
	// Bit mask of RFNE field.
	XIP_SSI_SR_RFNE_Msk = 0x8
	// Bit RFNE.
	XIP_SSI_SR_RFNE = 0x8
	// Position of TFE field.
	XIP_SSI_SR_TFE_Pos = 0x2
	// Bit mask of TFE field.
	XIP_SSI_SR_TFE_Msk = 0x4
	// Bit TFE.
	XIP_SSI_SR_TFE = 0x4
	// Position of TFNF field.
	XIP_SSI_SR_TFNF_Pos = 0x1
	// Bit mask of TFNF field.
	XIP_SSI_SR_TFNF_Msk = 0x2
	// Bit TFNF.
	XIP_SSI_SR_TFNF = 0x2
	// Position of BUSY field.
	XIP_SSI_SR_BUSY_Pos = 0x0
	// Bit mask of BUSY field.
	XIP_SSI_SR_BUSY_Msk = 0x1
	// Bit BUSY.
	XIP_SSI_SR_BUSY = 0x1

	// IMR: Interrupt mask
	// Position of MSTIM field.
	XIP_SSI_IMR_MSTIM_Pos = 0x5
	// Bit mask of MSTIM field.
	XIP_SSI_IMR_MSTIM_Msk = 0x20
	// Bit MSTIM.
	XIP_SSI_IMR_MSTIM = 0x20
	// Position of RXFIM field.
	XIP_SSI_IMR_RXFIM_Pos = 0x4
	// Bit mask of RXFIM field.
	XIP_SSI_IMR_RXFIM_Msk = 0x10
	// Bit RXFIM.
	XIP_SSI_IMR_RXFIM = 0x10
	// Position of RXOIM field.
	XIP_SSI_IMR_RXOIM_Pos = 0x3
	// Bit mask of RXOIM field.
	XIP_SSI_IMR_RXOIM_Msk = 0x8
	// Bit RXOIM.
	XIP_SSI_IMR_RXOIM = 0x8
	// Position of RXUIM field.
	XIP_SSI_IMR_RXUIM_Pos = 0x2
	// Bit mask of RXUIM field.
	XIP_SSI_IMR_RXUIM_Msk = 0x4
	// Bit RXUIM.
	XIP_SSI_IMR_RXUIM = 0x4
	// Position of TXOIM field.
	XIP_SSI_IMR_TXOIM_Pos = 0x1
	// Bit mask of TXOIM field.
	XIP_SSI_IMR_TXOIM_Msk = 0x2
	// Bit TXOIM.
	XIP_SSI_IMR_TXOIM = 0x2
	// Position of TXEIM field.
	XIP_SSI_IMR_TXEIM_Pos = 0x0
	// Bit mask of TXEIM field.
	XIP_SSI_IMR_TXEIM_Msk = 0x1
	// Bit TXEIM.
	XIP_SSI_IMR_TXEIM = 0x1

	// ISR: Interrupt status
	// Position of MSTIS field.
	XIP_SSI_ISR_MSTIS_Pos = 0x5
	// Bit mask of MSTIS field.
	XIP_SSI_ISR_MSTIS_Msk = 0x20
	// Bit MSTIS.
	XIP_SSI_ISR_MSTIS = 0x20
	// Position of RXFIS field.
	XIP_SSI_ISR_RXFIS_Pos = 0x4
	// Bit mask of RXFIS field.
	XIP_SSI_ISR_RXFIS_Msk = 0x10
	// Bit RXFIS.
	XIP_SSI_ISR_RXFIS = 0x10
	// Position of RXOIS field.
	XIP_SSI_ISR_RXOIS_Pos = 0x3
	// Bit mask of RXOIS field.
	XIP_SSI_ISR_RXOIS_Msk = 0x8
	// Bit RXOIS.
	XIP_SSI_ISR_RXOIS = 0x8
	// Position of RXUIS field.
	XIP_SSI_ISR_RXUIS_Pos = 0x2
	// Bit mask of RXUIS field.
	XIP_SSI_ISR_RXUIS_Msk = 0x4
	// Bit RXUIS.
	XIP_SSI_ISR_RXUIS = 0x4
	// Position of TXOIS field.
	XIP_SSI_ISR_TXOIS_Pos = 0x1
	// Bit mask of TXOIS field.
	XIP_SSI_ISR_TXOIS_Msk = 0x2
	// Bit TXOIS.
	XIP_SSI_ISR_TXOIS = 0x2
	// Position of TXEIS field.
	XIP_SSI_ISR_TXEIS_Pos = 0x0
	// Bit mask of TXEIS field.
	XIP_SSI_ISR_TXEIS_Msk = 0x1
	// Bit TXEIS.
	XIP_SSI_ISR_TXEIS = 0x1

	// RISR: Raw interrupt status
	// Position of MSTIR field.
	XIP_SSI_RISR_MSTIR_Pos = 0x5
	// Bit mask of MSTIR field.
	XIP_SSI_RISR_MSTIR_Msk = 0x20
	// Bit MSTIR.
	XIP_SSI_RISR_MSTIR = 0x20
	// Position of RXFIR field.
	XIP_SSI_RISR_RXFIR_Pos = 0x4
	// Bit mask of RXFIR field.
	XIP_SSI_RISR_RXFIR_Msk = 0x10
	// Bit RXFIR.
	XIP_SSI_RISR_RXFIR = 0x10
	// Position of RXOIR field.
	XIP_SSI_RISR_RXOIR_Pos = 0x3
	// Bit mask of RXOIR field.
	XIP_SSI_RISR_RXOIR_Msk = 0x8
	// Bit RXOIR.
	XIP_SSI_RISR_RXOIR = 0x8
	// Position of RXUIR field.
	XIP_SSI_RISR_RXUIR_Pos = 0x2
	// Bit mask of RXUIR field.
	XIP_SSI_RISR_RXUIR_Msk = 0x4
	// Bit RXUIR.
	XIP_SSI_RISR_RXUIR = 0x4
	// Position of TXOIR field.
	XIP_SSI_RISR_TXOIR_Pos = 0x1
	// Bit mask of TXOIR field.
	XIP_SSI_RISR_TXOIR_Msk = 0x2
	// Bit TXOIR.
	XIP_SSI_RISR_TXOIR = 0x2
	// Position of TXEIR field.
	XIP_SSI_RISR_TXEIR_Pos = 0x0
	// Bit mask of TXEIR field.
	XIP_SSI_RISR_TXEIR_Msk = 0x1
	// Bit TXEIR.
	XIP_SSI_RISR_TXEIR = 0x1

	// TXOICR: TX FIFO overflow interrupt clear
	// Position of TXOICR field.
	XIP_SSI_TXOICR_TXOICR_Pos = 0x0
	// Bit mask of TXOICR field.
	XIP_SSI_TXOICR_TXOICR_Msk = 0x1
	// Bit TXOICR.
	XIP_SSI_TXOICR_TXOICR = 0x1

	// RXOICR: RX FIFO overflow interrupt clear
	// Position of RXOICR field.
	XIP_SSI_RXOICR_RXOICR_Pos = 0x0
	// Bit mask of RXOICR field.
	XIP_SSI_RXOICR_RXOICR_Msk = 0x1
	// Bit RXOICR.
	XIP_SSI_RXOICR_RXOICR = 0x1

	// RXUICR: RX FIFO underflow interrupt clear
	// Position of RXUICR field.
	XIP_SSI_RXUICR_RXUICR_Pos = 0x0
	// Bit mask of RXUICR field.
	XIP_SSI_RXUICR_RXUICR_Msk = 0x1
	// Bit RXUICR.
	XIP_SSI_RXUICR_RXUICR = 0x1

	// MSTICR: Multi-master interrupt clear
	// Position of MSTICR field.
	XIP_SSI_MSTICR_MSTICR_Pos = 0x0
	// Bit mask of MSTICR field.
	XIP_SSI_MSTICR_MSTICR_Msk = 0x1
	// Bit MSTICR.
	XIP_SSI_MSTICR_MSTICR = 0x1

	// ICR: Interrupt clear
	// Position of ICR field.
	XIP_SSI_ICR_ICR_Pos = 0x0
	// Bit mask of ICR field.
	XIP_SSI_ICR_ICR_Msk = 0x1
	// Bit ICR.
	XIP_SSI_ICR_ICR = 0x1

	// DMACR: DMA control
	// Position of TDMAE field.
	XIP_SSI_DMACR_TDMAE_Pos = 0x1
	// Bit mask of TDMAE field.
	XIP_SSI_DMACR_TDMAE_Msk = 0x2
	// Bit TDMAE.
	XIP_SSI_DMACR_TDMAE = 0x2
	// Position of RDMAE field.
	XIP_SSI_DMACR_RDMAE_Pos = 0x0
	// Bit mask of RDMAE field.
	XIP_SSI_DMACR_RDMAE_Msk = 0x1
	// Bit RDMAE.
	XIP_SSI_DMACR_RDMAE = 0x1

	// DMATDLR: DMA TX data level
	// Position of DMATDL field.
	XIP_SSI_DMATDLR_DMATDL_Pos = 0x0
	// Bit mask of DMATDL field.
	XIP_SSI_DMATDLR_DMATDL_Msk = 0xff

	// DMARDLR: DMA RX data level
	// Position of DMARDL field.
	XIP_SSI_DMARDLR_DMARDL_Pos = 0x0
	// Bit mask of DMARDL field.
	XIP_SSI_DMARDLR_DMARDL_Msk = 0xff

	// IDR: Identification register
	// Position of IDCODE field.
	XIP_SSI_IDR_IDCODE_Pos = 0x0
	// Bit mask of IDCODE field.
	XIP_SSI_IDR_IDCODE_Msk = 0xffffffff

	// SSI_VERSION_ID: Version ID
	// Position of SSI_COMP_VERSION field.
	XIP_SSI_SSI_VERSION_ID_SSI_COMP_VERSION_Pos = 0x0
	// Bit mask of SSI_COMP_VERSION field.
	XIP_SSI_SSI_VERSION_ID_SSI_COMP_VERSION_Msk = 0xffffffff

	// DR0: Data Register 0 (of 36)
	// Position of DR field.
	XIP_SSI_DR0_DR_Pos = 0x0
	// Bit mask of DR field.
	XIP_SSI_DR0_DR_Msk = 0xffffffff

	// RX_SAMPLE_DLY: RX sample delay
	// Position of RSD field.
	XIP_SSI_RX_SAMPLE_DLY_RSD_Pos = 0x0
	// Bit mask of RSD field.
	XIP_SSI_RX_SAMPLE_DLY_RSD_Msk = 0xff

	// SPI_CTRLR0: SPI control
	// Position of XIP_CMD field.
	XIP_SSI_SPI_CTRLR0_XIP_CMD_Pos = 0x18
	// Bit mask of XIP_CMD field.
	XIP_SSI_SPI_CTRLR0_XIP_CMD_Msk = 0xff000000
	// Position of SPI_RXDS_EN field.
	XIP_SSI_SPI_CTRLR0_SPI_RXDS_EN_Pos = 0x12
	// Bit mask of SPI_RXDS_EN field.
	XIP_SSI_SPI_CTRLR0_SPI_RXDS_EN_Msk = 0x40000
	// Bit SPI_RXDS_EN.
	XIP_SSI_SPI_CTRLR0_SPI_RXDS_EN = 0x40000
	// Position of INST_DDR_EN field.
	XIP_SSI_SPI_CTRLR0_INST_DDR_EN_Pos = 0x11
	// Bit mask of INST_DDR_EN field.
	XIP_SSI_SPI_CTRLR0_INST_DDR_EN_Msk = 0x20000
	// Bit INST_DDR_EN.
	XIP_SSI_SPI_CTRLR0_INST_DDR_EN = 0x20000
	// Position of SPI_DDR_EN field.
	XIP_SSI_SPI_CTRLR0_SPI_DDR_EN_Pos = 0x10
	// Bit mask of SPI_DDR_EN field.
	XIP_SSI_SPI_CTRLR0_SPI_DDR_EN_Msk = 0x10000
	// Bit SPI_DDR_EN.
	XIP_SSI_SPI_CTRLR0_SPI_DDR_EN = 0x10000
	// Position of WAIT_CYCLES field.
	XIP_SSI_SPI_CTRLR0_WAIT_CYCLES_Pos = 0xb
	// Bit mask of WAIT_CYCLES field.
	XIP_SSI_SPI_CTRLR0_WAIT_CYCLES_Msk = 0xf800
	// Position of INST_L field.
	XIP_SSI_SPI_CTRLR0_INST_L_Pos = 0x8
	// Bit mask of INST_L field.
	XIP_SSI_SPI_CTRLR0_INST_L_Msk = 0x300
	// No instruction
	XIP_SSI_SPI_CTRLR0_INST_L_NONE = 0x0
	// 4-bit instruction
	XIP_SSI_SPI_CTRLR0_INST_L_4B = 0x1
	// 8-bit instruction
	XIP_SSI_SPI_CTRLR0_INST_L_8B = 0x2
	// 16-bit instruction
	XIP_SSI_SPI_CTRLR0_INST_L_16B = 0x3
	// Position of ADDR_L field.
	XIP_SSI_SPI_CTRLR0_ADDR_L_Pos = 0x2
	// Bit mask of ADDR_L field.
	XIP_SSI_SPI_CTRLR0_ADDR_L_Msk = 0x3c
	// Position of TRANS_TYPE field.
	XIP_SSI_SPI_CTRLR0_TRANS_TYPE_Pos = 0x0
	// Bit mask of TRANS_TYPE field.
	XIP_SSI_SPI_CTRLR0_TRANS_TYPE_Msk = 0x3
	// Command and address both in standard SPI frame format
	XIP_SSI_SPI_CTRLR0_TRANS_TYPE_1C1A = 0x0
	// Command in standard SPI format, address in format specified by FRF
	XIP_SSI_SPI_CTRLR0_TRANS_TYPE_1C2A = 0x1
	// Command and address both in format specified by FRF (e.g. Dual-SPI)
	XIP_SSI_SPI_CTRLR0_TRANS_TYPE_2C2A = 0x2

	// TXD_DRIVE_EDGE: TX drive edge
	// Position of TDE field.
	XIP_SSI_TXD_DRIVE_EDGE_TDE_Pos = 0x0
	// Bit mask of TDE field.
	XIP_SSI_TXD_DRIVE_EDGE_TDE_Msk = 0xff
)

// Constants for SYSINFO
const (
	// CHIP_ID: JEDEC JEP-106 compliant chip identifier.
	// Position of REVISION field.
	SYSINFO_CHIP_ID_REVISION_Pos = 0x1c
	// Bit mask of REVISION field.
	SYSINFO_CHIP_ID_REVISION_Msk = 0xf0000000
	// Position of PART field.
	SYSINFO_CHIP_ID_PART_Pos = 0xc
	// Bit mask of PART field.
	SYSINFO_CHIP_ID_PART_Msk = 0xffff000
	// Position of MANUFACTURER field.
	SYSINFO_CHIP_ID_MANUFACTURER_Pos = 0x0
	// Bit mask of MANUFACTURER field.
	SYSINFO_CHIP_ID_MANUFACTURER_Msk = 0xfff

	// PLATFORM: Platform register. Allows software to know what environment it is running in.
	// Position of ASIC field.
	SYSINFO_PLATFORM_ASIC_Pos = 0x1
	// Bit mask of ASIC field.
	SYSINFO_PLATFORM_ASIC_Msk = 0x2
	// Bit ASIC.
	SYSINFO_PLATFORM_ASIC = 0x2
	// Position of FPGA field.
	SYSINFO_PLATFORM_FPGA_Pos = 0x0
	// Bit mask of FPGA field.
	SYSINFO_PLATFORM_FPGA_Msk = 0x1
	// Bit FPGA.
	SYSINFO_PLATFORM_FPGA = 0x1
)

// Constants for SYSCFG: Register block for various chip control signals
const (
	// PROC_CONFIG: Configuration for processors
	// Position of PROC1_DAP_INSTID field.
	SYSCFG_PROC_CONFIG_PROC1_DAP_INSTID_Pos = 0x1c
	// Bit mask of PROC1_DAP_INSTID field.
	SYSCFG_PROC_CONFIG_PROC1_DAP_INSTID_Msk = 0xf0000000
	// Position of PROC0_DAP_INSTID field.
	SYSCFG_PROC_CONFIG_PROC0_DAP_INSTID_Pos = 0x18
	// Bit mask of PROC0_DAP_INSTID field.
	SYSCFG_PROC_CONFIG_PROC0_DAP_INSTID_Msk = 0xf000000
	// Position of PROC1_HALTED field.
	SYSCFG_PROC_CONFIG_PROC1_HALTED_Pos = 0x1
	// Bit mask of PROC1_HALTED field.
	SYSCFG_PROC_CONFIG_PROC1_HALTED_Msk = 0x2
	// Bit PROC1_HALTED.
	SYSCFG_PROC_CONFIG_PROC1_HALTED = 0x2
	// Position of PROC0_HALTED field.
	SYSCFG_PROC_CONFIG_PROC0_HALTED_Pos = 0x0
	// Bit mask of PROC0_HALTED field.
	SYSCFG_PROC_CONFIG_PROC0_HALTED_Msk = 0x1
	// Bit PROC0_HALTED.
	SYSCFG_PROC_CONFIG_PROC0_HALTED = 0x1

	// PROC_IN_SYNC_BYPASS
	// For each bit, if 1, bypass the input synchronizer between that GPIO
	// and the GPIO input register in the SIO. The input synchronizers should
	// generally be unbypassed, to avoid injecting metastabilities into processors.
	// If you're feeling brave, you can bypass to save two cycles of input
	// latency. This register applies to GPIO 0...29.
	// Position of PROC_IN_SYNC_BYPASS field.
	SYSCFG_PROC_IN_SYNC_BYPASS_PROC_IN_SYNC_BYPASS_Pos = 0x0
	// Bit mask of PROC_IN_SYNC_BYPASS field.
	SYSCFG_PROC_IN_SYNC_BYPASS_PROC_IN_SYNC_BYPASS_Msk = 0x3fffffff

	// PROC_IN_SYNC_BYPASS_HI
	// For each bit, if 1, bypass the input synchronizer between that GPIO
	// and the GPIO input register in the SIO. The input synchronizers should
	// generally be unbypassed, to avoid injecting metastabilities into processors.
	// If you're feeling brave, you can bypass to save two cycles of input
	// latency. This register applies to GPIO 30...35 (the QSPI IOs).
	// Position of PROC_IN_SYNC_BYPASS_HI field.
	SYSCFG_PROC_IN_SYNC_BYPASS_HI_PROC_IN_SYNC_BYPASS_HI_Pos = 0x0
	// Bit mask of PROC_IN_SYNC_BYPASS_HI field.
	SYSCFG_PROC_IN_SYNC_BYPASS_HI_PROC_IN_SYNC_BYPASS_HI_Msk = 0x3f

	// DBGFORCE: Directly control the SWD debug port of either processor
	// Position of PROC1_ATTACH field.
	SYSCFG_DBGFORCE_PROC1_ATTACH_Pos = 0x7
	// Bit mask of PROC1_ATTACH field.
	SYSCFG_DBGFORCE_PROC1_ATTACH_Msk = 0x80
	// Bit PROC1_ATTACH.
	SYSCFG_DBGFORCE_PROC1_ATTACH = 0x80
	// Position of PROC1_SWCLK field.
	SYSCFG_DBGFORCE_PROC1_SWCLK_Pos = 0x6
	// Bit mask of PROC1_SWCLK field.
	SYSCFG_DBGFORCE_PROC1_SWCLK_Msk = 0x40
	// Bit PROC1_SWCLK.
	SYSCFG_DBGFORCE_PROC1_SWCLK = 0x40
	// Position of PROC1_SWDI field.
	SYSCFG_DBGFORCE_PROC1_SWDI_Pos = 0x5
	// Bit mask of PROC1_SWDI field.
	SYSCFG_DBGFORCE_PROC1_SWDI_Msk = 0x20
	// Bit PROC1_SWDI.
	SYSCFG_DBGFORCE_PROC1_SWDI = 0x20
	// Position of PROC1_SWDO field.
	SYSCFG_DBGFORCE_PROC1_SWDO_Pos = 0x4
	// Bit mask of PROC1_SWDO field.
	SYSCFG_DBGFORCE_PROC1_SWDO_Msk = 0x10
	// Bit PROC1_SWDO.
	SYSCFG_DBGFORCE_PROC1_SWDO = 0x10
	// Position of PROC0_ATTACH field.
	SYSCFG_DBGFORCE_PROC0_ATTACH_Pos = 0x3
	// Bit mask of PROC0_ATTACH field.
	SYSCFG_DBGFORCE_PROC0_ATTACH_Msk = 0x8
	// Bit PROC0_ATTACH.
	SYSCFG_DBGFORCE_PROC0_ATTACH = 0x8
	// Position of PROC0_SWCLK field.
	SYSCFG_DBGFORCE_PROC0_SWCLK_Pos = 0x2
	// Bit mask of PROC0_SWCLK field.
	SYSCFG_DBGFORCE_PROC0_SWCLK_Msk = 0x4
	// Bit PROC0_SWCLK.
	SYSCFG_DBGFORCE_PROC0_SWCLK = 0x4
	// Position of PROC0_SWDI field.
	SYSCFG_DBGFORCE_PROC0_SWDI_Pos = 0x1
	// Bit mask of PROC0_SWDI field.
	SYSCFG_DBGFORCE_PROC0_SWDI_Msk = 0x2
	// Bit PROC0_SWDI.
	SYSCFG_DBGFORCE_PROC0_SWDI = 0x2
	// Position of PROC0_SWDO field.
	SYSCFG_DBGFORCE_PROC0_SWDO_Pos = 0x0
	// Bit mask of PROC0_SWDO field.
	SYSCFG_DBGFORCE_PROC0_SWDO_Msk = 0x1
	// Bit PROC0_SWDO.
	SYSCFG_DBGFORCE_PROC0_SWDO = 0x1

	// MEMPOWERDOWN
	// Control power downs to memories. Set high to power down memories.
	// Use with extreme caution
	// Position of ROM field.
	SYSCFG_MEMPOWERDOWN_ROM_Pos = 0x7
	// Bit mask of ROM field.
	SYSCFG_MEMPOWERDOWN_ROM_Msk = 0x80
	// Bit ROM.
	SYSCFG_MEMPOWERDOWN_ROM = 0x80
	// Position of USB field.
	SYSCFG_MEMPOWERDOWN_USB_Pos = 0x6
	// Bit mask of USB field.
	SYSCFG_MEMPOWERDOWN_USB_Msk = 0x40
	// Bit USB.
	SYSCFG_MEMPOWERDOWN_USB = 0x40
	// Position of SRAM5 field.
	SYSCFG_MEMPOWERDOWN_SRAM5_Pos = 0x5
	// Bit mask of SRAM5 field.
	SYSCFG_MEMPOWERDOWN_SRAM5_Msk = 0x20
	// Bit SRAM5.
	SYSCFG_MEMPOWERDOWN_SRAM5 = 0x20
	// Position of SRAM4 field.
	SYSCFG_MEMPOWERDOWN_SRAM4_Pos = 0x4
	// Bit mask of SRAM4 field.
	SYSCFG_MEMPOWERDOWN_SRAM4_Msk = 0x10
	// Bit SRAM4.
	SYSCFG_MEMPOWERDOWN_SRAM4 = 0x10
	// Position of SRAM3 field.
	SYSCFG_MEMPOWERDOWN_SRAM3_Pos = 0x3
	// Bit mask of SRAM3 field.
	SYSCFG_MEMPOWERDOWN_SRAM3_Msk = 0x8
	// Bit SRAM3.
	SYSCFG_MEMPOWERDOWN_SRAM3 = 0x8
	// Position of SRAM2 field.
	SYSCFG_MEMPOWERDOWN_SRAM2_Pos = 0x2
	// Bit mask of SRAM2 field.
	SYSCFG_MEMPOWERDOWN_SRAM2_Msk = 0x4
	// Bit SRAM2.
	SYSCFG_MEMPOWERDOWN_SRAM2 = 0x4
	// Position of SRAM1 field.
	SYSCFG_MEMPOWERDOWN_SRAM1_Pos = 0x1
	// Bit mask of SRAM1 field.
	SYSCFG_MEMPOWERDOWN_SRAM1_Msk = 0x2
	// Bit SRAM1.
	SYSCFG_MEMPOWERDOWN_SRAM1 = 0x2
	// Position of SRAM0 field.
	SYSCFG_MEMPOWERDOWN_SRAM0_Pos = 0x0
	// Bit mask of SRAM0 field.
	SYSCFG_MEMPOWERDOWN_SRAM0_Msk = 0x1
	// Bit SRAM0.
	SYSCFG_MEMPOWERDOWN_SRAM0 = 0x1
)

// Constants for CLOCKS
const (
	// CLK_GPOUT0_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
	// Position of NUDGE field.
	CLOCKS_CLK_GPOUT0_CTRL_NUDGE_Pos = 0x14
	// Bit mask of NUDGE field.
	CLOCKS_CLK_GPOUT0_CTRL_NUDGE_Msk = 0x100000
	// Bit NUDGE.
	CLOCKS_CLK_GPOUT0_CTRL_NUDGE = 0x100000
	// Position of PHASE field.
	CLOCKS_CLK_GPOUT0_CTRL_PHASE_Pos = 0x10
	// Bit mask of PHASE field.
	CLOCKS_CLK_GPOUT0_CTRL_PHASE_Msk = 0x30000
	// Position of DC50 field.
	CLOCKS_CLK_GPOUT0_CTRL_DC50_Pos = 0xc
	// Bit mask of DC50 field.
	CLOCKS_CLK_GPOUT0_CTRL_DC50_Msk = 0x1000
	// Bit DC50.
	CLOCKS_CLK_GPOUT0_CTRL_DC50 = 0x1000
	// Position of ENABLE field.
	CLOCKS_CLK_GPOUT0_CTRL_ENABLE_Pos = 0xb
	// Bit mask of ENABLE field.
	CLOCKS_CLK_GPOUT0_CTRL_ENABLE_Msk = 0x800
	// Bit ENABLE.
	CLOCKS_CLK_GPOUT0_CTRL_ENABLE = 0x800
	// Position of KILL field.
	CLOCKS_CLK_GPOUT0_CTRL_KILL_Pos = 0xa
	// Bit mask of KILL field.
	CLOCKS_CLK_GPOUT0_CTRL_KILL_Msk = 0x400
	// Bit KILL.
	CLOCKS_CLK_GPOUT0_CTRL_KILL = 0x400
	// Position of AUXSRC field.
	CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_Pos = 0x5
	// Bit mask of AUXSRC field.
	CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_Msk            = 0x1e0
	CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_CLKSRC_PLL_SYS = 0x0
	CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_CLKSRC_GPIN0   = 0x1
	CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_CLKSRC_GPIN1   = 0x2
	CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_CLKSRC_PLL_USB = 0x3
	CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_ROSC_CLKSRC    = 0x4
	CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_XOSC_CLKSRC    = 0x5
	CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_CLK_SYS        = 0x6
	CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_CLK_USB        = 0x7
	CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_CLK_ADC        = 0x8
	CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_CLK_RTC        = 0x9
	CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_CLK_REF        = 0xa

	// CLK_GPOUT0_DIV: Clock divisor, can be changed on-the-fly
	// Position of INT field.
	CLOCKS_CLK_GPOUT0_DIV_INT_Pos = 0x8
	// Bit mask of INT field.
	CLOCKS_CLK_GPOUT0_DIV_INT_Msk = 0xffffff00
	// Position of FRAC field.
	CLOCKS_CLK_GPOUT0_DIV_FRAC_Pos = 0x0
	// Bit mask of FRAC field.
	CLOCKS_CLK_GPOUT0_DIV_FRAC_Msk = 0xff

	// CLK_GPOUT1_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
	// Position of NUDGE field.
	CLOCKS_CLK_GPOUT1_CTRL_NUDGE_Pos = 0x14
	// Bit mask of NUDGE field.
	CLOCKS_CLK_GPOUT1_CTRL_NUDGE_Msk = 0x100000
	// Bit NUDGE.
	CLOCKS_CLK_GPOUT1_CTRL_NUDGE = 0x100000
	// Position of PHASE field.
	CLOCKS_CLK_GPOUT1_CTRL_PHASE_Pos = 0x10
	// Bit mask of PHASE field.
	CLOCKS_CLK_GPOUT1_CTRL_PHASE_Msk = 0x30000
	// Position of DC50 field.
	CLOCKS_CLK_GPOUT1_CTRL_DC50_Pos = 0xc
	// Bit mask of DC50 field.
	CLOCKS_CLK_GPOUT1_CTRL_DC50_Msk = 0x1000
	// Bit DC50.
	CLOCKS_CLK_GPOUT1_CTRL_DC50 = 0x1000
	// Position of ENABLE field.
	CLOCKS_CLK_GPOUT1_CTRL_ENABLE_Pos = 0xb
	// Bit mask of ENABLE field.
	CLOCKS_CLK_GPOUT1_CTRL_ENABLE_Msk = 0x800
	// Bit ENABLE.
	CLOCKS_CLK_GPOUT1_CTRL_ENABLE = 0x800
	// Position of KILL field.
	CLOCKS_CLK_GPOUT1_CTRL_KILL_Pos = 0xa
	// Bit mask of KILL field.
	CLOCKS_CLK_GPOUT1_CTRL_KILL_Msk = 0x400
	// Bit KILL.
	CLOCKS_CLK_GPOUT1_CTRL_KILL = 0x400
	// Position of AUXSRC field.
	CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_Pos = 0x5
	// Bit mask of AUXSRC field.
	CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_Msk            = 0x1e0
	CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_CLKSRC_PLL_SYS = 0x0
	CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_CLKSRC_GPIN0   = 0x1
	CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_CLKSRC_GPIN1   = 0x2
	CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_CLKSRC_PLL_USB = 0x3
	CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_ROSC_CLKSRC    = 0x4
	CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_XOSC_CLKSRC    = 0x5
	CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_CLK_SYS        = 0x6
	CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_CLK_USB        = 0x7
	CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_CLK_ADC        = 0x8
	CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_CLK_RTC        = 0x9
	CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_CLK_REF        = 0xa

	// CLK_GPOUT1_DIV: Clock divisor, can be changed on-the-fly
	// Position of INT field.
	CLOCKS_CLK_GPOUT1_DIV_INT_Pos = 0x8
	// Bit mask of INT field.
	CLOCKS_CLK_GPOUT1_DIV_INT_Msk = 0xffffff00
	// Position of FRAC field.
	CLOCKS_CLK_GPOUT1_DIV_FRAC_Pos = 0x0
	// Bit mask of FRAC field.
	CLOCKS_CLK_GPOUT1_DIV_FRAC_Msk = 0xff

	// CLK_GPOUT2_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
	// Position of NUDGE field.
	CLOCKS_CLK_GPOUT2_CTRL_NUDGE_Pos = 0x14
	// Bit mask of NUDGE field.
	CLOCKS_CLK_GPOUT2_CTRL_NUDGE_Msk = 0x100000
	// Bit NUDGE.
	CLOCKS_CLK_GPOUT2_CTRL_NUDGE = 0x100000
	// Position of PHASE field.
	CLOCKS_CLK_GPOUT2_CTRL_PHASE_Pos = 0x10
	// Bit mask of PHASE field.
	CLOCKS_CLK_GPOUT2_CTRL_PHASE_Msk = 0x30000
	// Position of DC50 field.
	CLOCKS_CLK_GPOUT2_CTRL_DC50_Pos = 0xc
	// Bit mask of DC50 field.
	CLOCKS_CLK_GPOUT2_CTRL_DC50_Msk = 0x1000
	// Bit DC50.
	CLOCKS_CLK_GPOUT2_CTRL_DC50 = 0x1000
	// Position of ENABLE field.
	CLOCKS_CLK_GPOUT2_CTRL_ENABLE_Pos = 0xb
	// Bit mask of ENABLE field.
	CLOCKS_CLK_GPOUT2_CTRL_ENABLE_Msk = 0x800
	// Bit ENABLE.
	CLOCKS_CLK_GPOUT2_CTRL_ENABLE = 0x800
	// Position of KILL field.
	CLOCKS_CLK_GPOUT2_CTRL_KILL_Pos = 0xa
	// Bit mask of KILL field.
	CLOCKS_CLK_GPOUT2_CTRL_KILL_Msk = 0x400
	// Bit KILL.
	CLOCKS_CLK_GPOUT2_CTRL_KILL = 0x400
	// Position of AUXSRC field.
	CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_Pos = 0x5
	// Bit mask of AUXSRC field.
	CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_Msk            = 0x1e0
	CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_CLKSRC_PLL_SYS = 0x0
	CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_CLKSRC_GPIN0   = 0x1
	CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_CLKSRC_GPIN1   = 0x2
	CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_CLKSRC_PLL_USB = 0x3
	CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_ROSC_CLKSRC_PH = 0x4
	CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_XOSC_CLKSRC    = 0x5
	CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_CLK_SYS        = 0x6
	CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_CLK_USB        = 0x7
	CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_CLK_ADC        = 0x8
	CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_CLK_RTC        = 0x9
	CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_CLK_REF        = 0xa

	// CLK_GPOUT2_DIV: Clock divisor, can be changed on-the-fly
	// Position of INT field.
	CLOCKS_CLK_GPOUT2_DIV_INT_Pos = 0x8
	// Bit mask of INT field.
	CLOCKS_CLK_GPOUT2_DIV_INT_Msk = 0xffffff00
	// Position of FRAC field.
	CLOCKS_CLK_GPOUT2_DIV_FRAC_Pos = 0x0
	// Bit mask of FRAC field.
	CLOCKS_CLK_GPOUT2_DIV_FRAC_Msk = 0xff

	// CLK_GPOUT3_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
	// Position of NUDGE field.
	CLOCKS_CLK_GPOUT3_CTRL_NUDGE_Pos = 0x14
	// Bit mask of NUDGE field.
	CLOCKS_CLK_GPOUT3_CTRL_NUDGE_Msk = 0x100000
	// Bit NUDGE.
	CLOCKS_CLK_GPOUT3_CTRL_NUDGE = 0x100000
	// Position of PHASE field.
	CLOCKS_CLK_GPOUT3_CTRL_PHASE_Pos = 0x10
	// Bit mask of PHASE field.
	CLOCKS_CLK_GPOUT3_CTRL_PHASE_Msk = 0x30000
	// Position of DC50 field.
	CLOCKS_CLK_GPOUT3_CTRL_DC50_Pos = 0xc
	// Bit mask of DC50 field.
	CLOCKS_CLK_GPOUT3_CTRL_DC50_Msk = 0x1000
	// Bit DC50.
	CLOCKS_CLK_GPOUT3_CTRL_DC50 = 0x1000
	// Position of ENABLE field.
	CLOCKS_CLK_GPOUT3_CTRL_ENABLE_Pos = 0xb
	// Bit mask of ENABLE field.
	CLOCKS_CLK_GPOUT3_CTRL_ENABLE_Msk = 0x800
	// Bit ENABLE.
	CLOCKS_CLK_GPOUT3_CTRL_ENABLE = 0x800
	// Position of KILL field.
	CLOCKS_CLK_GPOUT3_CTRL_KILL_Pos = 0xa
	// Bit mask of KILL field.
	CLOCKS_CLK_GPOUT3_CTRL_KILL_Msk = 0x400
	// Bit KILL.
	CLOCKS_CLK_GPOUT3_CTRL_KILL = 0x400
	// Position of AUXSRC field.
	CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_Pos = 0x5
	// Bit mask of AUXSRC field.
	CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_Msk            = 0x1e0
	CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_CLKSRC_PLL_SYS = 0x0
	CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_CLKSRC_GPIN0   = 0x1
	CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_CLKSRC_GPIN1   = 0x2
	CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_CLKSRC_PLL_USB = 0x3
	CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_ROSC_CLKSRC_PH = 0x4
	CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_XOSC_CLKSRC    = 0x5
	CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_CLK_SYS        = 0x6
	CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_CLK_USB        = 0x7
	CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_CLK_ADC        = 0x8
	CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_CLK_RTC        = 0x9
	CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_CLK_REF        = 0xa

	// CLK_GPOUT3_DIV: Clock divisor, can be changed on-the-fly
	// Position of INT field.
	CLOCKS_CLK_GPOUT3_DIV_INT_Pos = 0x8
	// Bit mask of INT field.
	CLOCKS_CLK_GPOUT3_DIV_INT_Msk = 0xffffff00
	// Position of FRAC field.
	CLOCKS_CLK_GPOUT3_DIV_FRAC_Pos = 0x0
	// Bit mask of FRAC field.
	CLOCKS_CLK_GPOUT3_DIV_FRAC_Msk = 0xff

	// CLK_REF_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
	// Position of AUXSRC field.
	CLOCKS_CLK_REF_CTRL_AUXSRC_Pos = 0x5
	// Bit mask of AUXSRC field.
	CLOCKS_CLK_REF_CTRL_AUXSRC_Msk            = 0x60
	CLOCKS_CLK_REF_CTRL_AUXSRC_CLKSRC_PLL_USB = 0x0
	CLOCKS_CLK_REF_CTRL_AUXSRC_CLKSRC_GPIN0   = 0x1
	CLOCKS_CLK_REF_CTRL_AUXSRC_CLKSRC_GPIN1   = 0x2
	// Position of SRC field.
	CLOCKS_CLK_REF_CTRL_SRC_Pos = 0x0
	// Bit mask of SRC field.
	CLOCKS_CLK_REF_CTRL_SRC_Msk                = 0x3
	CLOCKS_CLK_REF_CTRL_SRC_ROSC_CLKSRC_PH     = 0x0
	CLOCKS_CLK_REF_CTRL_SRC_CLKSRC_CLK_REF_AUX = 0x1
	CLOCKS_CLK_REF_CTRL_SRC_XOSC_CLKSRC        = 0x2

	// CLK_REF_DIV: Clock divisor, can be changed on-the-fly
	// Position of INT field.
	CLOCKS_CLK_REF_DIV_INT_Pos = 0x8
	// Bit mask of INT field.
	CLOCKS_CLK_REF_DIV_INT_Msk = 0x300

	// CLK_SYS_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
	// Position of AUXSRC field.
	CLOCKS_CLK_SYS_CTRL_AUXSRC_Pos = 0x5
	// Bit mask of AUXSRC field.
	CLOCKS_CLK_SYS_CTRL_AUXSRC_Msk            = 0xe0
	CLOCKS_CLK_SYS_CTRL_AUXSRC_CLKSRC_PLL_SYS = 0x0
	CLOCKS_CLK_SYS_CTRL_AUXSRC_CLKSRC_PLL_USB = 0x1
	CLOCKS_CLK_SYS_CTRL_AUXSRC_ROSC_CLKSRC    = 0x2
	CLOCKS_CLK_SYS_CTRL_AUXSRC_XOSC_CLKSRC    = 0x3
	CLOCKS_CLK_SYS_CTRL_AUXSRC_CLKSRC_GPIN0   = 0x4
	CLOCKS_CLK_SYS_CTRL_AUXSRC_CLKSRC_GPIN1   = 0x5
	// Position of SRC field.
	CLOCKS_CLK_SYS_CTRL_SRC_Pos = 0x0
	// Bit mask of SRC field.
	CLOCKS_CLK_SYS_CTRL_SRC_Msk = 0x1
	// Bit SRC.
	CLOCKS_CLK_SYS_CTRL_SRC                    = 0x1
	CLOCKS_CLK_SYS_CTRL_SRC_CLK_REF            = 0x0
	CLOCKS_CLK_SYS_CTRL_SRC_CLKSRC_CLK_SYS_AUX = 0x1

	// CLK_SYS_DIV: Clock divisor, can be changed on-the-fly
	// Position of INT field.
	CLOCKS_CLK_SYS_DIV_INT_Pos = 0x8
	// Bit mask of INT field.
	CLOCKS_CLK_SYS_DIV_INT_Msk = 0xffffff00
	// Position of FRAC field.
	CLOCKS_CLK_SYS_DIV_FRAC_Pos = 0x0
	// Bit mask of FRAC field.
	CLOCKS_CLK_SYS_DIV_FRAC_Msk = 0xff

	// CLK_PERI_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
	// Position of ENABLE field.
	CLOCKS_CLK_PERI_CTRL_ENABLE_Pos = 0xb
	// Bit mask of ENABLE field.
	CLOCKS_CLK_PERI_CTRL_ENABLE_Msk = 0x800
	// Bit ENABLE.
	CLOCKS_CLK_PERI_CTRL_ENABLE = 0x800
	// Position of KILL field.
	CLOCKS_CLK_PERI_CTRL_KILL_Pos = 0xa
	// Bit mask of KILL field.
	CLOCKS_CLK_PERI_CTRL_KILL_Msk = 0x400
	// Bit KILL.
	CLOCKS_CLK_PERI_CTRL_KILL = 0x400
	// Position of AUXSRC field.
	CLOCKS_CLK_PERI_CTRL_AUXSRC_Pos = 0x5
	// Bit mask of AUXSRC field.
	CLOCKS_CLK_PERI_CTRL_AUXSRC_Msk            = 0xe0
	CLOCKS_CLK_PERI_CTRL_AUXSRC_CLK_SYS        = 0x0
	CLOCKS_CLK_PERI_CTRL_AUXSRC_CLKSRC_PLL_SYS = 0x1
	CLOCKS_CLK_PERI_CTRL_AUXSRC_CLKSRC_PLL_USB = 0x2
	CLOCKS_CLK_PERI_CTRL_AUXSRC_ROSC_CLKSRC_PH = 0x3
	CLOCKS_CLK_PERI_CTRL_AUXSRC_XOSC_CLKSRC    = 0x4
	CLOCKS_CLK_PERI_CTRL_AUXSRC_CLKSRC_GPIN0   = 0x5
	CLOCKS_CLK_PERI_CTRL_AUXSRC_CLKSRC_GPIN1   = 0x6

	// CLK_USB_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
	// Position of NUDGE field.
	CLOCKS_CLK_USB_CTRL_NUDGE_Pos = 0x14
	// Bit mask of NUDGE field.
	CLOCKS_CLK_USB_CTRL_NUDGE_Msk = 0x100000
	// Bit NUDGE.
	CLOCKS_CLK_USB_CTRL_NUDGE = 0x100000
	// Position of PHASE field.
	CLOCKS_CLK_USB_CTRL_PHASE_Pos = 0x10
	// Bit mask of PHASE field.
	CLOCKS_CLK_USB_CTRL_PHASE_Msk = 0x30000
	// Position of ENABLE field.
	CLOCKS_CLK_USB_CTRL_ENABLE_Pos = 0xb
	// Bit mask of ENABLE field.
	CLOCKS_CLK_USB_CTRL_ENABLE_Msk = 0x800
	// Bit ENABLE.
	CLOCKS_CLK_USB_CTRL_ENABLE = 0x800
	// Position of KILL field.
	CLOCKS_CLK_USB_CTRL_KILL_Pos = 0xa
	// Bit mask of KILL field.
	CLOCKS_CLK_USB_CTRL_KILL_Msk = 0x400
	// Bit KILL.
	CLOCKS_CLK_USB_CTRL_KILL = 0x400
	// Position of AUXSRC field.
	CLOCKS_CLK_USB_CTRL_AUXSRC_Pos = 0x5
	// Bit mask of AUXSRC field.
	CLOCKS_CLK_USB_CTRL_AUXSRC_Msk            = 0xe0
	CLOCKS_CLK_USB_CTRL_AUXSRC_CLKSRC_PLL_USB = 0x0
	CLOCKS_CLK_USB_CTRL_AUXSRC_CLKSRC_PLL_SYS = 0x1
	CLOCKS_CLK_USB_CTRL_AUXSRC_ROSC_CLKSRC_PH = 0x2
	CLOCKS_CLK_USB_CTRL_AUXSRC_XOSC_CLKSRC    = 0x3
	CLOCKS_CLK_USB_CTRL_AUXSRC_CLKSRC_GPIN0   = 0x4
	CLOCKS_CLK_USB_CTRL_AUXSRC_CLKSRC_GPIN1   = 0x5

	// CLK_USB_DIV: Clock divisor, can be changed on-the-fly
	// Position of INT field.
	CLOCKS_CLK_USB_DIV_INT_Pos = 0x8
	// Bit mask of INT field.
	CLOCKS_CLK_USB_DIV_INT_Msk = 0x300

	// CLK_ADC_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
	// Position of NUDGE field.
	CLOCKS_CLK_ADC_CTRL_NUDGE_Pos = 0x14
	// Bit mask of NUDGE field.
	CLOCKS_CLK_ADC_CTRL_NUDGE_Msk = 0x100000
	// Bit NUDGE.
	CLOCKS_CLK_ADC_CTRL_NUDGE = 0x100000
	// Position of PHASE field.
	CLOCKS_CLK_ADC_CTRL_PHASE_Pos = 0x10
	// Bit mask of PHASE field.
	CLOCKS_CLK_ADC_CTRL_PHASE_Msk = 0x30000
	// Position of ENABLE field.
	CLOCKS_CLK_ADC_CTRL_ENABLE_Pos = 0xb
	// Bit mask of ENABLE field.
	CLOCKS_CLK_ADC_CTRL_ENABLE_Msk = 0x800
	// Bit ENABLE.
	CLOCKS_CLK_ADC_CTRL_ENABLE = 0x800
	// Position of KILL field.
	CLOCKS_CLK_ADC_CTRL_KILL_Pos = 0xa
	// Bit mask of KILL field.
	CLOCKS_CLK_ADC_CTRL_KILL_Msk = 0x400
	// Bit KILL.
	CLOCKS_CLK_ADC_CTRL_KILL = 0x400
	// Position of AUXSRC field.
	CLOCKS_CLK_ADC_CTRL_AUXSRC_Pos = 0x5
	// Bit mask of AUXSRC field.
	CLOCKS_CLK_ADC_CTRL_AUXSRC_Msk            = 0xe0
	CLOCKS_CLK_ADC_CTRL_AUXSRC_CLKSRC_PLL_USB = 0x0
	CLOCKS_CLK_ADC_CTRL_AUXSRC_CLKSRC_PLL_SYS = 0x1
	CLOCKS_CLK_ADC_CTRL_AUXSRC_ROSC_CLKSRC_PH = 0x2
	CLOCKS_CLK_ADC_CTRL_AUXSRC_XOSC_CLKSRC    = 0x3
	CLOCKS_CLK_ADC_CTRL_AUXSRC_CLKSRC_GPIN0   = 0x4
	CLOCKS_CLK_ADC_CTRL_AUXSRC_CLKSRC_GPIN1   = 0x5

	// CLK_ADC_DIV: Clock divisor, can be changed on-the-fly
	// Position of INT field.
	CLOCKS_CLK_ADC_DIV_INT_Pos = 0x8
	// Bit mask of INT field.
	CLOCKS_CLK_ADC_DIV_INT_Msk = 0x300

	// CLK_RTC_CTRL: Clock control, can be changed on-the-fly (except for auxsrc)
	// Position of NUDGE field.
	CLOCKS_CLK_RTC_CTRL_NUDGE_Pos = 0x14
	// Bit mask of NUDGE field.
	CLOCKS_CLK_RTC_CTRL_NUDGE_Msk = 0x100000
	// Bit NUDGE.
	CLOCKS_CLK_RTC_CTRL_NUDGE = 0x100000
	// Position of PHASE field.
	CLOCKS_CLK_RTC_CTRL_PHASE_Pos = 0x10
	// Bit mask of PHASE field.
	CLOCKS_CLK_RTC_CTRL_PHASE_Msk = 0x30000
	// Position of ENABLE field.
	CLOCKS_CLK_RTC_CTRL_ENABLE_Pos = 0xb
	// Bit mask of ENABLE field.
	CLOCKS_CLK_RTC_CTRL_ENABLE_Msk = 0x800
	// Bit ENABLE.
	CLOCKS_CLK_RTC_CTRL_ENABLE = 0x800
	// Position of KILL field.
	CLOCKS_CLK_RTC_CTRL_KILL_Pos = 0xa
	// Bit mask of KILL field.
	CLOCKS_CLK_RTC_CTRL_KILL_Msk = 0x400
	// Bit KILL.
	CLOCKS_CLK_RTC_CTRL_KILL = 0x400
	// Position of AUXSRC field.
	CLOCKS_CLK_RTC_CTRL_AUXSRC_Pos = 0x5
	// Bit mask of AUXSRC field.
	CLOCKS_CLK_RTC_CTRL_AUXSRC_Msk            = 0xe0
	CLOCKS_CLK_RTC_CTRL_AUXSRC_CLKSRC_PLL_USB = 0x0
	CLOCKS_CLK_RTC_CTRL_AUXSRC_CLKSRC_PLL_SYS = 0x1
	CLOCKS_CLK_RTC_CTRL_AUXSRC_ROSC_CLKSRC_PH = 0x2
	CLOCKS_CLK_RTC_CTRL_AUXSRC_XOSC_CLKSRC    = 0x3
	CLOCKS_CLK_RTC_CTRL_AUXSRC_CLKSRC_GPIN0   = 0x4
	CLOCKS_CLK_RTC_CTRL_AUXSRC_CLKSRC_GPIN1   = 0x5

	// CLK_RTC_DIV: Clock divisor, can be changed on-the-fly
	// Position of INT field.
	CLOCKS_CLK_RTC_DIV_INT_Pos = 0x8
	// Bit mask of INT field.
	CLOCKS_CLK_RTC_DIV_INT_Msk = 0xffffff00
	// Position of FRAC field.
	CLOCKS_CLK_RTC_DIV_FRAC_Pos = 0x0
	// Bit mask of FRAC field.
	CLOCKS_CLK_RTC_DIV_FRAC_Msk = 0xff

	// CLK_SYS_RESUS_CTRL
	// Position of CLEAR field.
	CLOCKS_CLK_SYS_RESUS_CTRL_CLEAR_Pos = 0x10
	// Bit mask of CLEAR field.
	CLOCKS_CLK_SYS_RESUS_CTRL_CLEAR_Msk = 0x10000
	// Bit CLEAR.
	CLOCKS_CLK_SYS_RESUS_CTRL_CLEAR = 0x10000
	// Position of FRCE field.
	CLOCKS_CLK_SYS_RESUS_CTRL_FRCE_Pos = 0xc
	// Bit mask of FRCE field.
	CLOCKS_CLK_SYS_RESUS_CTRL_FRCE_Msk = 0x1000
	// Bit FRCE.
	CLOCKS_CLK_SYS_RESUS_CTRL_FRCE = 0x1000
	// Position of ENABLE field.
	CLOCKS_CLK_SYS_RESUS_CTRL_ENABLE_Pos = 0x8
	// Bit mask of ENABLE field.
	CLOCKS_CLK_SYS_RESUS_CTRL_ENABLE_Msk = 0x100
	// Bit ENABLE.
	CLOCKS_CLK_SYS_RESUS_CTRL_ENABLE = 0x100
	// Position of TIMEOUT field.
	CLOCKS_CLK_SYS_RESUS_CTRL_TIMEOUT_Pos = 0x0
	// Bit mask of TIMEOUT field.
	CLOCKS_CLK_SYS_RESUS_CTRL_TIMEOUT_Msk = 0xff

	// CLK_SYS_RESUS_STATUS
	// Position of RESUSSED field.
	CLOCKS_CLK_SYS_RESUS_STATUS_RESUSSED_Pos = 0x0
	// Bit mask of RESUSSED field.
	CLOCKS_CLK_SYS_RESUS_STATUS_RESUSSED_Msk = 0x1
	// Bit RESUSSED.
	CLOCKS_CLK_SYS_RESUS_STATUS_RESUSSED = 0x1

	// FC0_REF_KHZ: Reference clock frequency in kHz
	// Position of FC0_REF_KHZ field.
	CLOCKS_FC0_REF_KHZ_FC0_REF_KHZ_Pos = 0x0
	// Bit mask of FC0_REF_KHZ field.
	CLOCKS_FC0_REF_KHZ_FC0_REF_KHZ_Msk = 0xfffff

	// FC0_MIN_KHZ: Minimum pass frequency in kHz. This is optional. Set to 0 if you are not using the pass/fail flags
	// Position of FC0_MIN_KHZ field.
	CLOCKS_FC0_MIN_KHZ_FC0_MIN_KHZ_Pos = 0x0
	// Bit mask of FC0_MIN_KHZ field.
	CLOCKS_FC0_MIN_KHZ_FC0_MIN_KHZ_Msk = 0x1ffffff

	// FC0_MAX_KHZ: Maximum pass frequency in kHz. This is optional. Set to 0x1ffffff if you are not using the pass/fail flags
	// Position of FC0_MAX_KHZ field.
	CLOCKS_FC0_MAX_KHZ_FC0_MAX_KHZ_Pos = 0x0
	// Bit mask of FC0_MAX_KHZ field.
	CLOCKS_FC0_MAX_KHZ_FC0_MAX_KHZ_Msk = 0x1ffffff

	// FC0_DELAY
	// Delays the start of frequency counting to allow the mux to settle
	// Delay is measured in multiples of the reference clock period
	// Position of FC0_DELAY field.
	CLOCKS_FC0_DELAY_FC0_DELAY_Pos = 0x0
	// Bit mask of FC0_DELAY field.
	CLOCKS_FC0_DELAY_FC0_DELAY_Msk = 0x7

	// FC0_INTERVAL
	// The test interval is 0.98us * 2**interval, but let's call it 1us * 2**interval
	// The default gives a test interval of 250us
	// Position of FC0_INTERVAL field.
	CLOCKS_FC0_INTERVAL_FC0_INTERVAL_Pos = 0x0
	// Bit mask of FC0_INTERVAL field.
	CLOCKS_FC0_INTERVAL_FC0_INTERVAL_Msk = 0xf

	// FC0_SRC
	// Clock sent to frequency counter, set to 0 when not required
	// Writing to this register initiates the frequency count
	// Position of FC0_SRC field.
	CLOCKS_FC0_SRC_FC0_SRC_Pos = 0x0
	// Bit mask of FC0_SRC field.
	CLOCKS_FC0_SRC_FC0_SRC_Msk                    = 0xff
	CLOCKS_FC0_SRC_FC0_SRC_NULL                   = 0x0
	CLOCKS_FC0_SRC_FC0_SRC_PLL_SYS_CLKSRC_PRIMARY = 0x1
	CLOCKS_FC0_SRC_FC0_SRC_PLL_USB_CLKSRC_PRIMARY = 0x2
	CLOCKS_FC0_SRC_FC0_SRC_ROSC_CLKSRC            = 0x3
	CLOCKS_FC0_SRC_FC0_SRC_ROSC_CLKSRC_PH         = 0x4
	CLOCKS_FC0_SRC_FC0_SRC_XOSC_CLKSRC            = 0x5
	CLOCKS_FC0_SRC_FC0_SRC_CLKSRC_GPIN0           = 0x6
	CLOCKS_FC0_SRC_FC0_SRC_CLKSRC_GPIN1           = 0x7
	CLOCKS_FC0_SRC_FC0_SRC_CLK_REF                = 0x8
	CLOCKS_FC0_SRC_FC0_SRC_CLK_SYS                = 0x9
	CLOCKS_FC0_SRC_FC0_SRC_CLK_PERI               = 0xa
	CLOCKS_FC0_SRC_FC0_SRC_CLK_USB                = 0xb
	CLOCKS_FC0_SRC_FC0_SRC_CLK_ADC                = 0xc
	CLOCKS_FC0_SRC_FC0_SRC_CLK_RTC                = 0xd

	// FC0_STATUS: Frequency counter status
	// Position of DIED field.
	CLOCKS_FC0_STATUS_DIED_Pos = 0x1c
	// Bit mask of DIED field.
	CLOCKS_FC0_STATUS_DIED_Msk = 0x10000000
	// Bit DIED.
	CLOCKS_FC0_STATUS_DIED = 0x10000000
	// Position of FAST field.
	CLOCKS_FC0_STATUS_FAST_Pos = 0x18
	// Bit mask of FAST field.
	CLOCKS_FC0_STATUS_FAST_Msk = 0x1000000
	// Bit FAST.
	CLOCKS_FC0_STATUS_FAST = 0x1000000
	// Position of SLOW field.
	CLOCKS_FC0_STATUS_SLOW_Pos = 0x14
	// Bit mask of SLOW field.
	CLOCKS_FC0_STATUS_SLOW_Msk = 0x100000
	// Bit SLOW.
	CLOCKS_FC0_STATUS_SLOW = 0x100000
	// Position of FAIL field.
	CLOCKS_FC0_STATUS_FAIL_Pos = 0x10
	// Bit mask of FAIL field.
	CLOCKS_FC0_STATUS_FAIL_Msk = 0x10000
	// Bit FAIL.
	CLOCKS_FC0_STATUS_FAIL = 0x10000
	// Position of WAITING field.
	CLOCKS_FC0_STATUS_WAITING_Pos = 0xc
	// Bit mask of WAITING field.
	CLOCKS_FC0_STATUS_WAITING_Msk = 0x1000
	// Bit WAITING.
	CLOCKS_FC0_STATUS_WAITING = 0x1000
	// Position of RUNNING field.
	CLOCKS_FC0_STATUS_RUNNING_Pos = 0x8
	// Bit mask of RUNNING field.
	CLOCKS_FC0_STATUS_RUNNING_Msk = 0x100
	// Bit RUNNING.
	CLOCKS_FC0_STATUS_RUNNING = 0x100
	// Position of DONE field.
	CLOCKS_FC0_STATUS_DONE_Pos = 0x4
	// Bit mask of DONE field.
	CLOCKS_FC0_STATUS_DONE_Msk = 0x10
	// Bit DONE.
	CLOCKS_FC0_STATUS_DONE = 0x10
	// Position of PASS field.
	CLOCKS_FC0_STATUS_PASS_Pos = 0x0
	// Bit mask of PASS field.
	CLOCKS_FC0_STATUS_PASS_Msk = 0x1
	// Bit PASS.
	CLOCKS_FC0_STATUS_PASS = 0x1

	// FC0_RESULT: Result of frequency measurement, only valid when status_done=1
	// Position of KHZ field.
	CLOCKS_FC0_RESULT_KHZ_Pos = 0x5
	// Bit mask of KHZ field.
	CLOCKS_FC0_RESULT_KHZ_Msk = 0x3fffffe0
	// Position of FRAC field.
	CLOCKS_FC0_RESULT_FRAC_Pos = 0x0
	// Bit mask of FRAC field.
	CLOCKS_FC0_RESULT_FRAC_Msk = 0x1f

	// WAKE_EN0: enable clock in wake mode
	// Position of CLK_SYS_SRAM3 field.
	CLOCKS_WAKE_EN0_CLK_SYS_SRAM3_Pos = 0x1f
	// Bit mask of CLK_SYS_SRAM3 field.
	CLOCKS_WAKE_EN0_CLK_SYS_SRAM3_Msk = 0x80000000
	// Bit CLK_SYS_SRAM3.
	CLOCKS_WAKE_EN0_CLK_SYS_SRAM3 = 0x80000000
	// Position of CLK_SYS_SRAM2 field.
	CLOCKS_WAKE_EN0_CLK_SYS_SRAM2_Pos = 0x1e
	// Bit mask of CLK_SYS_SRAM2 field.
	CLOCKS_WAKE_EN0_CLK_SYS_SRAM2_Msk = 0x40000000
	// Bit CLK_SYS_SRAM2.
	CLOCKS_WAKE_EN0_CLK_SYS_SRAM2 = 0x40000000
	// Position of CLK_SYS_SRAM1 field.
	CLOCKS_WAKE_EN0_CLK_SYS_SRAM1_Pos = 0x1d
	// Bit mask of CLK_SYS_SRAM1 field.
	CLOCKS_WAKE_EN0_CLK_SYS_SRAM1_Msk = 0x20000000
	// Bit CLK_SYS_SRAM1.
	CLOCKS_WAKE_EN0_CLK_SYS_SRAM1 = 0x20000000
	// Position of CLK_SYS_SRAM0 field.
	CLOCKS_WAKE_EN0_CLK_SYS_SRAM0_Pos = 0x1c
	// Bit mask of CLK_SYS_SRAM0 field.
	CLOCKS_WAKE_EN0_CLK_SYS_SRAM0_Msk = 0x10000000
	// Bit CLK_SYS_SRAM0.
	CLOCKS_WAKE_EN0_CLK_SYS_SRAM0 = 0x10000000
	// Position of CLK_SYS_SPI1 field.
	CLOCKS_WAKE_EN0_CLK_SYS_SPI1_Pos = 0x1b
	// Bit mask of CLK_SYS_SPI1 field.
	CLOCKS_WAKE_EN0_CLK_SYS_SPI1_Msk = 0x8000000
	// Bit CLK_SYS_SPI1.
	CLOCKS_WAKE_EN0_CLK_SYS_SPI1 = 0x8000000
	// Position of CLK_PERI_SPI1 field.
	CLOCKS_WAKE_EN0_CLK_PERI_SPI1_Pos = 0x1a
	// Bit mask of CLK_PERI_SPI1 field.
	CLOCKS_WAKE_EN0_CLK_PERI_SPI1_Msk = 0x4000000
	// Bit CLK_PERI_SPI1.
	CLOCKS_WAKE_EN0_CLK_PERI_SPI1 = 0x4000000
	// Position of CLK_SYS_SPI0 field.
	CLOCKS_WAKE_EN0_CLK_SYS_SPI0_Pos = 0x19
	// Bit mask of CLK_SYS_SPI0 field.
	CLOCKS_WAKE_EN0_CLK_SYS_SPI0_Msk = 0x2000000
	// Bit CLK_SYS_SPI0.
	CLOCKS_WAKE_EN0_CLK_SYS_SPI0 = 0x2000000
	// Position of CLK_PERI_SPI0 field.
	CLOCKS_WAKE_EN0_CLK_PERI_SPI0_Pos = 0x18
	// Bit mask of CLK_PERI_SPI0 field.
	CLOCKS_WAKE_EN0_CLK_PERI_SPI0_Msk = 0x1000000
	// Bit CLK_PERI_SPI0.
	CLOCKS_WAKE_EN0_CLK_PERI_SPI0 = 0x1000000
	// Position of CLK_SYS_SIO field.
	CLOCKS_WAKE_EN0_CLK_SYS_SIO_Pos = 0x17
	// Bit mask of CLK_SYS_SIO field.
	CLOCKS_WAKE_EN0_CLK_SYS_SIO_Msk = 0x800000
	// Bit CLK_SYS_SIO.
	CLOCKS_WAKE_EN0_CLK_SYS_SIO = 0x800000
	// Position of CLK_SYS_RTC field.
	CLOCKS_WAKE_EN0_CLK_SYS_RTC_Pos = 0x16
	// Bit mask of CLK_SYS_RTC field.
	CLOCKS_WAKE_EN0_CLK_SYS_RTC_Msk = 0x400000
	// Bit CLK_SYS_RTC.
	CLOCKS_WAKE_EN0_CLK_SYS_RTC = 0x400000
	// Position of CLK_RTC_RTC field.
	CLOCKS_WAKE_EN0_CLK_RTC_RTC_Pos = 0x15
	// Bit mask of CLK_RTC_RTC field.
	CLOCKS_WAKE_EN0_CLK_RTC_RTC_Msk = 0x200000
	// Bit CLK_RTC_RTC.
	CLOCKS_WAKE_EN0_CLK_RTC_RTC = 0x200000
	// Position of CLK_SYS_ROSC field.
	CLOCKS_WAKE_EN0_CLK_SYS_ROSC_Pos = 0x14
	// Bit mask of CLK_SYS_ROSC field.
	CLOCKS_WAKE_EN0_CLK_SYS_ROSC_Msk = 0x100000
	// Bit CLK_SYS_ROSC.
	CLOCKS_WAKE_EN0_CLK_SYS_ROSC = 0x100000
	// Position of CLK_SYS_ROM field.
	CLOCKS_WAKE_EN0_CLK_SYS_ROM_Pos = 0x13
	// Bit mask of CLK_SYS_ROM field.
	CLOCKS_WAKE_EN0_CLK_SYS_ROM_Msk = 0x80000
	// Bit CLK_SYS_ROM.
	CLOCKS_WAKE_EN0_CLK_SYS_ROM = 0x80000
	// Position of CLK_SYS_RESETS field.
	CLOCKS_WAKE_EN0_CLK_SYS_RESETS_Pos = 0x12
	// Bit mask of CLK_SYS_RESETS field.
	CLOCKS_WAKE_EN0_CLK_SYS_RESETS_Msk = 0x40000
	// Bit CLK_SYS_RESETS.
	CLOCKS_WAKE_EN0_CLK_SYS_RESETS = 0x40000
	// Position of CLK_SYS_PWM field.
	CLOCKS_WAKE_EN0_CLK_SYS_PWM_Pos = 0x11
	// Bit mask of CLK_SYS_PWM field.
	CLOCKS_WAKE_EN0_CLK_SYS_PWM_Msk = 0x20000
	// Bit CLK_SYS_PWM.
	CLOCKS_WAKE_EN0_CLK_SYS_PWM = 0x20000
	// Position of CLK_SYS_PSM field.
	CLOCKS_WAKE_EN0_CLK_SYS_PSM_Pos = 0x10
	// Bit mask of CLK_SYS_PSM field.
	CLOCKS_WAKE_EN0_CLK_SYS_PSM_Msk = 0x10000
	// Bit CLK_SYS_PSM.
	CLOCKS_WAKE_EN0_CLK_SYS_PSM = 0x10000
	// Position of CLK_SYS_PLL_USB field.
	CLOCKS_WAKE_EN0_CLK_SYS_PLL_USB_Pos = 0xf
	// Bit mask of CLK_SYS_PLL_USB field.
	CLOCKS_WAKE_EN0_CLK_SYS_PLL_USB_Msk = 0x8000
	// Bit CLK_SYS_PLL_USB.
	CLOCKS_WAKE_EN0_CLK_SYS_PLL_USB = 0x8000
	// Position of CLK_SYS_PLL_SYS field.
	CLOCKS_WAKE_EN0_CLK_SYS_PLL_SYS_Pos = 0xe
	// Bit mask of CLK_SYS_PLL_SYS field.
	CLOCKS_WAKE_EN0_CLK_SYS_PLL_SYS_Msk = 0x4000
	// Bit CLK_SYS_PLL_SYS.
	CLOCKS_WAKE_EN0_CLK_SYS_PLL_SYS = 0x4000
	// Position of CLK_SYS_PIO1 field.
	CLOCKS_WAKE_EN0_CLK_SYS_PIO1_Pos = 0xd
	// Bit mask of CLK_SYS_PIO1 field.
	CLOCKS_WAKE_EN0_CLK_SYS_PIO1_Msk = 0x2000
	// Bit CLK_SYS_PIO1.
	CLOCKS_WAKE_EN0_CLK_SYS_PIO1 = 0x2000
	// Position of CLK_SYS_PIO0 field.
	CLOCKS_WAKE_EN0_CLK_SYS_PIO0_Pos = 0xc
	// Bit mask of CLK_SYS_PIO0 field.
	CLOCKS_WAKE_EN0_CLK_SYS_PIO0_Msk = 0x1000
	// Bit CLK_SYS_PIO0.
	CLOCKS_WAKE_EN0_CLK_SYS_PIO0 = 0x1000
	// Position of CLK_SYS_PADS field.
	CLOCKS_WAKE_EN0_CLK_SYS_PADS_Pos = 0xb
	// Bit mask of CLK_SYS_PADS field.
	CLOCKS_WAKE_EN0_CLK_SYS_PADS_Msk = 0x800
	// Bit CLK_SYS_PADS.
	CLOCKS_WAKE_EN0_CLK_SYS_PADS = 0x800
	// Position of CLK_SYS_VREG_AND_CHIP_RESET field.
	CLOCKS_WAKE_EN0_CLK_SYS_VREG_AND_CHIP_RESET_Pos = 0xa
	// Bit mask of CLK_SYS_VREG_AND_CHIP_RESET field.
	CLOCKS_WAKE_EN0_CLK_SYS_VREG_AND_CHIP_RESET_Msk = 0x400
	// Bit CLK_SYS_VREG_AND_CHIP_RESET.
	CLOCKS_WAKE_EN0_CLK_SYS_VREG_AND_CHIP_RESET = 0x400
	// Position of CLK_SYS_JTAG field.
	CLOCKS_WAKE_EN0_CLK_SYS_JTAG_Pos = 0x9
	// Bit mask of CLK_SYS_JTAG field.
	CLOCKS_WAKE_EN0_CLK_SYS_JTAG_Msk = 0x200
	// Bit CLK_SYS_JTAG.
	CLOCKS_WAKE_EN0_CLK_SYS_JTAG = 0x200
	// Position of CLK_SYS_IO field.
	CLOCKS_WAKE_EN0_CLK_SYS_IO_Pos = 0x8
	// Bit mask of CLK_SYS_IO field.
	CLOCKS_WAKE_EN0_CLK_SYS_IO_Msk = 0x100
	// Bit CLK_SYS_IO.
	CLOCKS_WAKE_EN0_CLK_SYS_IO = 0x100
	// Position of CLK_SYS_I2C1 field.
	CLOCKS_WAKE_EN0_CLK_SYS_I2C1_Pos = 0x7
	// Bit mask of CLK_SYS_I2C1 field.
	CLOCKS_WAKE_EN0_CLK_SYS_I2C1_Msk = 0x80
	// Bit CLK_SYS_I2C1.
	CLOCKS_WAKE_EN0_CLK_SYS_I2C1 = 0x80
	// Position of CLK_SYS_I2C0 field.
	CLOCKS_WAKE_EN0_CLK_SYS_I2C0_Pos = 0x6
	// Bit mask of CLK_SYS_I2C0 field.
	CLOCKS_WAKE_EN0_CLK_SYS_I2C0_Msk = 0x40
	// Bit CLK_SYS_I2C0.
	CLOCKS_WAKE_EN0_CLK_SYS_I2C0 = 0x40
	// Position of CLK_SYS_DMA field.
	CLOCKS_WAKE_EN0_CLK_SYS_DMA_Pos = 0x5
	// Bit mask of CLK_SYS_DMA field.
	CLOCKS_WAKE_EN0_CLK_SYS_DMA_Msk = 0x20
	// Bit CLK_SYS_DMA.
	CLOCKS_WAKE_EN0_CLK_SYS_DMA = 0x20
	// Position of CLK_SYS_BUSFABRIC field.
	CLOCKS_WAKE_EN0_CLK_SYS_BUSFABRIC_Pos = 0x4
	// Bit mask of CLK_SYS_BUSFABRIC field.
	CLOCKS_WAKE_EN0_CLK_SYS_BUSFABRIC_Msk = 0x10
	// Bit CLK_SYS_BUSFABRIC.
	CLOCKS_WAKE_EN0_CLK_SYS_BUSFABRIC = 0x10
	// Position of CLK_SYS_BUSCTRL field.
	CLOCKS_WAKE_EN0_CLK_SYS_BUSCTRL_Pos = 0x3
	// Bit mask of CLK_SYS_BUSCTRL field.
	CLOCKS_WAKE_EN0_CLK_SYS_BUSCTRL_Msk = 0x8
	// Bit CLK_SYS_BUSCTRL.
	CLOCKS_WAKE_EN0_CLK_SYS_BUSCTRL = 0x8
	// Position of CLK_SYS_ADC field.
	CLOCKS_WAKE_EN0_CLK_SYS_ADC_Pos = 0x2
	// Bit mask of CLK_SYS_ADC field.
	CLOCKS_WAKE_EN0_CLK_SYS_ADC_Msk = 0x4
	// Bit CLK_SYS_ADC.
	CLOCKS_WAKE_EN0_CLK_SYS_ADC = 0x4
	// Position of CLK_ADC_ADC field.
	CLOCKS_WAKE_EN0_CLK_ADC_ADC_Pos = 0x1
	// Bit mask of CLK_ADC_ADC field.
	CLOCKS_WAKE_EN0_CLK_ADC_ADC_Msk = 0x2
	// Bit CLK_ADC_ADC.
	CLOCKS_WAKE_EN0_CLK_ADC_ADC = 0x2
	// Position of CLK_SYS_CLOCKS field.
	CLOCKS_WAKE_EN0_CLK_SYS_CLOCKS_Pos = 0x0
	// Bit mask of CLK_SYS_CLOCKS field.
	CLOCKS_WAKE_EN0_CLK_SYS_CLOCKS_Msk = 0x1
	// Bit CLK_SYS_CLOCKS.
	CLOCKS_WAKE_EN0_CLK_SYS_CLOCKS = 0x1

	// WAKE_EN1: enable clock in wake mode
	// Position of CLK_SYS_XOSC field.
	CLOCKS_WAKE_EN1_CLK_SYS_XOSC_Pos = 0xe
	// Bit mask of CLK_SYS_XOSC field.
	CLOCKS_WAKE_EN1_CLK_SYS_XOSC_Msk = 0x4000
	// Bit CLK_SYS_XOSC.
	CLOCKS_WAKE_EN1_CLK_SYS_XOSC = 0x4000
	// Position of CLK_SYS_XIP field.
	CLOCKS_WAKE_EN1_CLK_SYS_XIP_Pos = 0xd
	// Bit mask of CLK_SYS_XIP field.
	CLOCKS_WAKE_EN1_CLK_SYS_XIP_Msk = 0x2000
	// Bit CLK_SYS_XIP.
	CLOCKS_WAKE_EN1_CLK_SYS_XIP = 0x2000
	// Position of CLK_SYS_WATCHDOG field.
	CLOCKS_WAKE_EN1_CLK_SYS_WATCHDOG_Pos = 0xc
	// Bit mask of CLK_SYS_WATCHDOG field.
	CLOCKS_WAKE_EN1_CLK_SYS_WATCHDOG_Msk = 0x1000
	// Bit CLK_SYS_WATCHDOG.
	CLOCKS_WAKE_EN1_CLK_SYS_WATCHDOG = 0x1000
	// Position of CLK_USB_USBCTRL field.
	CLOCKS_WAKE_EN1_CLK_USB_USBCTRL_Pos = 0xb
	// Bit mask of CLK_USB_USBCTRL field.
	CLOCKS_WAKE_EN1_CLK_USB_USBCTRL_Msk = 0x800
	// Bit CLK_USB_USBCTRL.
	CLOCKS_WAKE_EN1_CLK_USB_USBCTRL = 0x800
	// Position of CLK_SYS_USBCTRL field.
	CLOCKS_WAKE_EN1_CLK_SYS_USBCTRL_Pos = 0xa
	// Bit mask of CLK_SYS_USBCTRL field.
	CLOCKS_WAKE_EN1_CLK_SYS_USBCTRL_Msk = 0x400
	// Bit CLK_SYS_USBCTRL.
	CLOCKS_WAKE_EN1_CLK_SYS_USBCTRL = 0x400
	// Position of CLK_SYS_UART1 field.
	CLOCKS_WAKE_EN1_CLK_SYS_UART1_Pos = 0x9
	// Bit mask of CLK_SYS_UART1 field.
	CLOCKS_WAKE_EN1_CLK_SYS_UART1_Msk = 0x200
	// Bit CLK_SYS_UART1.
	CLOCKS_WAKE_EN1_CLK_SYS_UART1 = 0x200
	// Position of CLK_PERI_UART1 field.
	CLOCKS_WAKE_EN1_CLK_PERI_UART1_Pos = 0x8
	// Bit mask of CLK_PERI_UART1 field.
	CLOCKS_WAKE_EN1_CLK_PERI_UART1_Msk = 0x100
	// Bit CLK_PERI_UART1.
	CLOCKS_WAKE_EN1_CLK_PERI_UART1 = 0x100
	// Position of CLK_SYS_UART0 field.
	CLOCKS_WAKE_EN1_CLK_SYS_UART0_Pos = 0x7
	// Bit mask of CLK_SYS_UART0 field.
	CLOCKS_WAKE_EN1_CLK_SYS_UART0_Msk = 0x80
	// Bit CLK_SYS_UART0.
	CLOCKS_WAKE_EN1_CLK_SYS_UART0 = 0x80
	// Position of CLK_PERI_UART0 field.
	CLOCKS_WAKE_EN1_CLK_PERI_UART0_Pos = 0x6
	// Bit mask of CLK_PERI_UART0 field.
	CLOCKS_WAKE_EN1_CLK_PERI_UART0_Msk = 0x40
	// Bit CLK_PERI_UART0.
	CLOCKS_WAKE_EN1_CLK_PERI_UART0 = 0x40
	// Position of CLK_SYS_TIMER field.
	CLOCKS_WAKE_EN1_CLK_SYS_TIMER_Pos = 0x5
	// Bit mask of CLK_SYS_TIMER field.
	CLOCKS_WAKE_EN1_CLK_SYS_TIMER_Msk = 0x20
	// Bit CLK_SYS_TIMER.
	CLOCKS_WAKE_EN1_CLK_SYS_TIMER = 0x20
	// Position of CLK_SYS_TBMAN field.
	CLOCKS_WAKE_EN1_CLK_SYS_TBMAN_Pos = 0x4
	// Bit mask of CLK_SYS_TBMAN field.
	CLOCKS_WAKE_EN1_CLK_SYS_TBMAN_Msk = 0x10
	// Bit CLK_SYS_TBMAN.
	CLOCKS_WAKE_EN1_CLK_SYS_TBMAN = 0x10
	// Position of CLK_SYS_SYSINFO field.
	CLOCKS_WAKE_EN1_CLK_SYS_SYSINFO_Pos = 0x3
	// Bit mask of CLK_SYS_SYSINFO field.
	CLOCKS_WAKE_EN1_CLK_SYS_SYSINFO_Msk = 0x8
	// Bit CLK_SYS_SYSINFO.
	CLOCKS_WAKE_EN1_CLK_SYS_SYSINFO = 0x8
	// Position of CLK_SYS_SYSCFG field.
	CLOCKS_WAKE_EN1_CLK_SYS_SYSCFG_Pos = 0x2
	// Bit mask of CLK_SYS_SYSCFG field.
	CLOCKS_WAKE_EN1_CLK_SYS_SYSCFG_Msk = 0x4
	// Bit CLK_SYS_SYSCFG.
	CLOCKS_WAKE_EN1_CLK_SYS_SYSCFG = 0x4
	// Position of CLK_SYS_SRAM5 field.
	CLOCKS_WAKE_EN1_CLK_SYS_SRAM5_Pos = 0x1
	// Bit mask of CLK_SYS_SRAM5 field.
	CLOCKS_WAKE_EN1_CLK_SYS_SRAM5_Msk = 0x2
	// Bit CLK_SYS_SRAM5.
	CLOCKS_WAKE_EN1_CLK_SYS_SRAM5 = 0x2
	// Position of CLK_SYS_SRAM4 field.
	CLOCKS_WAKE_EN1_CLK_SYS_SRAM4_Pos = 0x0
	// Bit mask of CLK_SYS_SRAM4 field.
	CLOCKS_WAKE_EN1_CLK_SYS_SRAM4_Msk = 0x1
	// Bit CLK_SYS_SRAM4.
	CLOCKS_WAKE_EN1_CLK_SYS_SRAM4 = 0x1

	// SLEEP_EN0: enable clock in sleep mode
	// Position of CLK_SYS_SRAM3 field.
	CLOCKS_SLEEP_EN0_CLK_SYS_SRAM3_Pos = 0x1f
	// Bit mask of CLK_SYS_SRAM3 field.
	CLOCKS_SLEEP_EN0_CLK_SYS_SRAM3_Msk = 0x80000000
	// Bit CLK_SYS_SRAM3.
	CLOCKS_SLEEP_EN0_CLK_SYS_SRAM3 = 0x80000000
	// Position of CLK_SYS_SRAM2 field.
	CLOCKS_SLEEP_EN0_CLK_SYS_SRAM2_Pos = 0x1e
	// Bit mask of CLK_SYS_SRAM2 field.
	CLOCKS_SLEEP_EN0_CLK_SYS_SRAM2_Msk = 0x40000000
	// Bit CLK_SYS_SRAM2.
	CLOCKS_SLEEP_EN0_CLK_SYS_SRAM2 = 0x40000000
	// Position of CLK_SYS_SRAM1 field.
	CLOCKS_SLEEP_EN0_CLK_SYS_SRAM1_Pos = 0x1d
	// Bit mask of CLK_SYS_SRAM1 field.
	CLOCKS_SLEEP_EN0_CLK_SYS_SRAM1_Msk = 0x20000000
	// Bit CLK_SYS_SRAM1.
	CLOCKS_SLEEP_EN0_CLK_SYS_SRAM1 = 0x20000000
	// Position of CLK_SYS_SRAM0 field.
	CLOCKS_SLEEP_EN0_CLK_SYS_SRAM0_Pos = 0x1c
	// Bit mask of CLK_SYS_SRAM0 field.
	CLOCKS_SLEEP_EN0_CLK_SYS_SRAM0_Msk = 0x10000000
	// Bit CLK_SYS_SRAM0.
	CLOCKS_SLEEP_EN0_CLK_SYS_SRAM0 = 0x10000000
	// Position of CLK_SYS_SPI1 field.
	CLOCKS_SLEEP_EN0_CLK_SYS_SPI1_Pos = 0x1b
	// Bit mask of CLK_SYS_SPI1 field.
	CLOCKS_SLEEP_EN0_CLK_SYS_SPI1_Msk = 0x8000000
	// Bit CLK_SYS_SPI1.
	CLOCKS_SLEEP_EN0_CLK_SYS_SPI1 = 0x8000000
	// Position of CLK_PERI_SPI1 field.
	CLOCKS_SLEEP_EN0_CLK_PERI_SPI1_Pos = 0x1a
	// Bit mask of CLK_PERI_SPI1 field.
	CLOCKS_SLEEP_EN0_CLK_PERI_SPI1_Msk = 0x4000000
	// Bit CLK_PERI_SPI1.
	CLOCKS_SLEEP_EN0_CLK_PERI_SPI1 = 0x4000000
	// Position of CLK_SYS_SPI0 field.
	CLOCKS_SLEEP_EN0_CLK_SYS_SPI0_Pos = 0x19
	// Bit mask of CLK_SYS_SPI0 field.
	CLOCKS_SLEEP_EN0_CLK_SYS_SPI0_Msk = 0x2000000
	// Bit CLK_SYS_SPI0.
	CLOCKS_SLEEP_EN0_CLK_SYS_SPI0 = 0x2000000
	// Position of CLK_PERI_SPI0 field.
	CLOCKS_SLEEP_EN0_CLK_PERI_SPI0_Pos = 0x18
	// Bit mask of CLK_PERI_SPI0 field.
	CLOCKS_SLEEP_EN0_CLK_PERI_SPI0_Msk = 0x1000000
	// Bit CLK_PERI_SPI0.
	CLOCKS_SLEEP_EN0_CLK_PERI_SPI0 = 0x1000000
	// Position of CLK_SYS_SIO field.
	CLOCKS_SLEEP_EN0_CLK_SYS_SIO_Pos = 0x17
	// Bit mask of CLK_SYS_SIO field.
	CLOCKS_SLEEP_EN0_CLK_SYS_SIO_Msk = 0x800000
	// Bit CLK_SYS_SIO.
	CLOCKS_SLEEP_EN0_CLK_SYS_SIO = 0x800000
	// Position of CLK_SYS_RTC field.
	CLOCKS_SLEEP_EN0_CLK_SYS_RTC_Pos = 0x16
	// Bit mask of CLK_SYS_RTC field.
	CLOCKS_SLEEP_EN0_CLK_SYS_RTC_Msk = 0x400000
	// Bit CLK_SYS_RTC.
	CLOCKS_SLEEP_EN0_CLK_SYS_RTC = 0x400000
	// Position of CLK_RTC_RTC field.
	CLOCKS_SLEEP_EN0_CLK_RTC_RTC_Pos = 0x15
	// Bit mask of CLK_RTC_RTC field.
	CLOCKS_SLEEP_EN0_CLK_RTC_RTC_Msk = 0x200000
	// Bit CLK_RTC_RTC.
	CLOCKS_SLEEP_EN0_CLK_RTC_RTC = 0x200000
	// Position of CLK_SYS_ROSC field.
	CLOCKS_SLEEP_EN0_CLK_SYS_ROSC_Pos = 0x14
	// Bit mask of CLK_SYS_ROSC field.
	CLOCKS_SLEEP_EN0_CLK_SYS_ROSC_Msk = 0x100000
	// Bit CLK_SYS_ROSC.
	CLOCKS_SLEEP_EN0_CLK_SYS_ROSC = 0x100000
	// Position of CLK_SYS_ROM field.
	CLOCKS_SLEEP_EN0_CLK_SYS_ROM_Pos = 0x13
	// Bit mask of CLK_SYS_ROM field.
	CLOCKS_SLEEP_EN0_CLK_SYS_ROM_Msk = 0x80000
	// Bit CLK_SYS_ROM.
	CLOCKS_SLEEP_EN0_CLK_SYS_ROM = 0x80000
	// Position of CLK_SYS_RESETS field.
	CLOCKS_SLEEP_EN0_CLK_SYS_RESETS_Pos = 0x12
	// Bit mask of CLK_SYS_RESETS field.
	CLOCKS_SLEEP_EN0_CLK_SYS_RESETS_Msk = 0x40000
	// Bit CLK_SYS_RESETS.
	CLOCKS_SLEEP_EN0_CLK_SYS_RESETS = 0x40000
	// Position of CLK_SYS_PWM field.
	CLOCKS_SLEEP_EN0_CLK_SYS_PWM_Pos = 0x11
	// Bit mask of CLK_SYS_PWM field.
	CLOCKS_SLEEP_EN0_CLK_SYS_PWM_Msk = 0x20000
	// Bit CLK_SYS_PWM.
	CLOCKS_SLEEP_EN0_CLK_SYS_PWM = 0x20000
	// Position of CLK_SYS_PSM field.
	CLOCKS_SLEEP_EN0_CLK_SYS_PSM_Pos = 0x10
	// Bit mask of CLK_SYS_PSM field.
	CLOCKS_SLEEP_EN0_CLK_SYS_PSM_Msk = 0x10000
	// Bit CLK_SYS_PSM.
	CLOCKS_SLEEP_EN0_CLK_SYS_PSM = 0x10000
	// Position of CLK_SYS_PLL_USB field.
	CLOCKS_SLEEP_EN0_CLK_SYS_PLL_USB_Pos = 0xf
	// Bit mask of CLK_SYS_PLL_USB field.
	CLOCKS_SLEEP_EN0_CLK_SYS_PLL_USB_Msk = 0x8000
	// Bit CLK_SYS_PLL_USB.
	CLOCKS_SLEEP_EN0_CLK_SYS_PLL_USB = 0x8000
	// Position of CLK_SYS_PLL_SYS field.
	CLOCKS_SLEEP_EN0_CLK_SYS_PLL_SYS_Pos = 0xe
	// Bit mask of CLK_SYS_PLL_SYS field.
	CLOCKS_SLEEP_EN0_CLK_SYS_PLL_SYS_Msk = 0x4000
	// Bit CLK_SYS_PLL_SYS.
	CLOCKS_SLEEP_EN0_CLK_SYS_PLL_SYS = 0x4000
	// Position of CLK_SYS_PIO1 field.
	CLOCKS_SLEEP_EN0_CLK_SYS_PIO1_Pos = 0xd
	// Bit mask of CLK_SYS_PIO1 field.
	CLOCKS_SLEEP_EN0_CLK_SYS_PIO1_Msk = 0x2000
	// Bit CLK_SYS_PIO1.
	CLOCKS_SLEEP_EN0_CLK_SYS_PIO1 = 0x2000
	// Position of CLK_SYS_PIO0 field.
	CLOCKS_SLEEP_EN0_CLK_SYS_PIO0_Pos = 0xc
	// Bit mask of CLK_SYS_PIO0 field.
	CLOCKS_SLEEP_EN0_CLK_SYS_PIO0_Msk = 0x1000
	// Bit CLK_SYS_PIO0.
	CLOCKS_SLEEP_EN0_CLK_SYS_PIO0 = 0x1000
	// Position of CLK_SYS_PADS field.
	CLOCKS_SLEEP_EN0_CLK_SYS_PADS_Pos = 0xb
	// Bit mask of CLK_SYS_PADS field.
	CLOCKS_SLEEP_EN0_CLK_SYS_PADS_Msk = 0x800
	// Bit CLK_SYS_PADS.
	CLOCKS_SLEEP_EN0_CLK_SYS_PADS = 0x800
	// Position of CLK_SYS_VREG_AND_CHIP_RESET field.
	CLOCKS_SLEEP_EN0_CLK_SYS_VREG_AND_CHIP_RESET_Pos = 0xa
	// Bit mask of CLK_SYS_VREG_AND_CHIP_RESET field.
	CLOCKS_SLEEP_EN0_CLK_SYS_VREG_AND_CHIP_RESET_Msk = 0x400
	// Bit CLK_SYS_VREG_AND_CHIP_RESET.
	CLOCKS_SLEEP_EN0_CLK_SYS_VREG_AND_CHIP_RESET = 0x400
	// Position of CLK_SYS_JTAG field.
	CLOCKS_SLEEP_EN0_CLK_SYS_JTAG_Pos = 0x9
	// Bit mask of CLK_SYS_JTAG field.
	CLOCKS_SLEEP_EN0_CLK_SYS_JTAG_Msk = 0x200
	// Bit CLK_SYS_JTAG.
	CLOCKS_SLEEP_EN0_CLK_SYS_JTAG = 0x200
	// Position of CLK_SYS_IO field.
	CLOCKS_SLEEP_EN0_CLK_SYS_IO_Pos = 0x8
	// Bit mask of CLK_SYS_IO field.
	CLOCKS_SLEEP_EN0_CLK_SYS_IO_Msk = 0x100
	// Bit CLK_SYS_IO.
	CLOCKS_SLEEP_EN0_CLK_SYS_IO = 0x100
	// Position of CLK_SYS_I2C1 field.
	CLOCKS_SLEEP_EN0_CLK_SYS_I2C1_Pos = 0x7
	// Bit mask of CLK_SYS_I2C1 field.
	CLOCKS_SLEEP_EN0_CLK_SYS_I2C1_Msk = 0x80
	// Bit CLK_SYS_I2C1.
	CLOCKS_SLEEP_EN0_CLK_SYS_I2C1 = 0x80
	// Position of CLK_SYS_I2C0 field.
	CLOCKS_SLEEP_EN0_CLK_SYS_I2C0_Pos = 0x6
	// Bit mask of CLK_SYS_I2C0 field.
	CLOCKS_SLEEP_EN0_CLK_SYS_I2C0_Msk = 0x40
	// Bit CLK_SYS_I2C0.
	CLOCKS_SLEEP_EN0_CLK_SYS_I2C0 = 0x40
	// Position of CLK_SYS_DMA field.
	CLOCKS_SLEEP_EN0_CLK_SYS_DMA_Pos = 0x5
	// Bit mask of CLK_SYS_DMA field.
	CLOCKS_SLEEP_EN0_CLK_SYS_DMA_Msk = 0x20
	// Bit CLK_SYS_DMA.
	CLOCKS_SLEEP_EN0_CLK_SYS_DMA = 0x20
	// Position of CLK_SYS_BUSFABRIC field.
	CLOCKS_SLEEP_EN0_CLK_SYS_BUSFABRIC_Pos = 0x4
	// Bit mask of CLK_SYS_BUSFABRIC field.
	CLOCKS_SLEEP_EN0_CLK_SYS_BUSFABRIC_Msk = 0x10
	// Bit CLK_SYS_BUSFABRIC.
	CLOCKS_SLEEP_EN0_CLK_SYS_BUSFABRIC = 0x10
	// Position of CLK_SYS_BUSCTRL field.
	CLOCKS_SLEEP_EN0_CLK_SYS_BUSCTRL_Pos = 0x3
	// Bit mask of CLK_SYS_BUSCTRL field.
	CLOCKS_SLEEP_EN0_CLK_SYS_BUSCTRL_Msk = 0x8
	// Bit CLK_SYS_BUSCTRL.
	CLOCKS_SLEEP_EN0_CLK_SYS_BUSCTRL = 0x8
	// Position of CLK_SYS_ADC field.
	CLOCKS_SLEEP_EN0_CLK_SYS_ADC_Pos = 0x2
	// Bit mask of CLK_SYS_ADC field.
	CLOCKS_SLEEP_EN0_CLK_SYS_ADC_Msk = 0x4
	// Bit CLK_SYS_ADC.
	CLOCKS_SLEEP_EN0_CLK_SYS_ADC = 0x4
	// Position of CLK_ADC_ADC field.
	CLOCKS_SLEEP_EN0_CLK_ADC_ADC_Pos = 0x1
	// Bit mask of CLK_ADC_ADC field.
	CLOCKS_SLEEP_EN0_CLK_ADC_ADC_Msk = 0x2
	// Bit CLK_ADC_ADC.
	CLOCKS_SLEEP_EN0_CLK_ADC_ADC = 0x2
	// Position of CLK_SYS_CLOCKS field.
	CLOCKS_SLEEP_EN0_CLK_SYS_CLOCKS_Pos = 0x0
	// Bit mask of CLK_SYS_CLOCKS field.
	CLOCKS_SLEEP_EN0_CLK_SYS_CLOCKS_Msk = 0x1
	// Bit CLK_SYS_CLOCKS.
	CLOCKS_SLEEP_EN0_CLK_SYS_CLOCKS = 0x1

	// SLEEP_EN1: enable clock in sleep mode
	// Position of CLK_SYS_XOSC field.
	CLOCKS_SLEEP_EN1_CLK_SYS_XOSC_Pos = 0xe
	// Bit mask of CLK_SYS_XOSC field.
	CLOCKS_SLEEP_EN1_CLK_SYS_XOSC_Msk = 0x4000
	// Bit CLK_SYS_XOSC.
	CLOCKS_SLEEP_EN1_CLK_SYS_XOSC = 0x4000
	// Position of CLK_SYS_XIP field.
	CLOCKS_SLEEP_EN1_CLK_SYS_XIP_Pos = 0xd
	// Bit mask of CLK_SYS_XIP field.
	CLOCKS_SLEEP_EN1_CLK_SYS_XIP_Msk = 0x2000
	// Bit CLK_SYS_XIP.
	CLOCKS_SLEEP_EN1_CLK_SYS_XIP = 0x2000
	// Position of CLK_SYS_WATCHDOG field.
	CLOCKS_SLEEP_EN1_CLK_SYS_WATCHDOG_Pos = 0xc
	// Bit mask of CLK_SYS_WATCHDOG field.
	CLOCKS_SLEEP_EN1_CLK_SYS_WATCHDOG_Msk = 0x1000
	// Bit CLK_SYS_WATCHDOG.
	CLOCKS_SLEEP_EN1_CLK_SYS_WATCHDOG = 0x1000
	// Position of CLK_USB_USBCTRL field.
	CLOCKS_SLEEP_EN1_CLK_USB_USBCTRL_Pos = 0xb
	// Bit mask of CLK_USB_USBCTRL field.
	CLOCKS_SLEEP_EN1_CLK_USB_USBCTRL_Msk = 0x800
	// Bit CLK_USB_USBCTRL.
	CLOCKS_SLEEP_EN1_CLK_USB_USBCTRL = 0x800
	// Position of CLK_SYS_USBCTRL field.
	CLOCKS_SLEEP_EN1_CLK_SYS_USBCTRL_Pos = 0xa
	// Bit mask of CLK_SYS_USBCTRL field.
	CLOCKS_SLEEP_EN1_CLK_SYS_USBCTRL_Msk = 0x400
	// Bit CLK_SYS_USBCTRL.
	CLOCKS_SLEEP_EN1_CLK_SYS_USBCTRL = 0x400
	// Position of CLK_SYS_UART1 field.
	CLOCKS_SLEEP_EN1_CLK_SYS_UART1_Pos = 0x9
	// Bit mask of CLK_SYS_UART1 field.
	CLOCKS_SLEEP_EN1_CLK_SYS_UART1_Msk = 0x200
	// Bit CLK_SYS_UART1.
	CLOCKS_SLEEP_EN1_CLK_SYS_UART1 = 0x200
	// Position of CLK_PERI_UART1 field.
	CLOCKS_SLEEP_EN1_CLK_PERI_UART1_Pos = 0x8
	// Bit mask of CLK_PERI_UART1 field.
	CLOCKS_SLEEP_EN1_CLK_PERI_UART1_Msk = 0x100
	// Bit CLK_PERI_UART1.
	CLOCKS_SLEEP_EN1_CLK_PERI_UART1 = 0x100
	// Position of CLK_SYS_UART0 field.
	CLOCKS_SLEEP_EN1_CLK_SYS_UART0_Pos = 0x7
	// Bit mask of CLK_SYS_UART0 field.
	CLOCKS_SLEEP_EN1_CLK_SYS_UART0_Msk = 0x80
	// Bit CLK_SYS_UART0.
	CLOCKS_SLEEP_EN1_CLK_SYS_UART0 = 0x80
	// Position of CLK_PERI_UART0 field.
	CLOCKS_SLEEP_EN1_CLK_PERI_UART0_Pos = 0x6
	// Bit mask of CLK_PERI_UART0 field.
	CLOCKS_SLEEP_EN1_CLK_PERI_UART0_Msk = 0x40
	// Bit CLK_PERI_UART0.
	CLOCKS_SLEEP_EN1_CLK_PERI_UART0 = 0x40
	// Position of CLK_SYS_TIMER field.
	CLOCKS_SLEEP_EN1_CLK_SYS_TIMER_Pos = 0x5
	// Bit mask of CLK_SYS_TIMER field.
	CLOCKS_SLEEP_EN1_CLK_SYS_TIMER_Msk = 0x20
	// Bit CLK_SYS_TIMER.
	CLOCKS_SLEEP_EN1_CLK_SYS_TIMER = 0x20
	// Position of CLK_SYS_TBMAN field.
	CLOCKS_SLEEP_EN1_CLK_SYS_TBMAN_Pos = 0x4
	// Bit mask of CLK_SYS_TBMAN field.
	CLOCKS_SLEEP_EN1_CLK_SYS_TBMAN_Msk = 0x10
	// Bit CLK_SYS_TBMAN.
	CLOCKS_SLEEP_EN1_CLK_SYS_TBMAN = 0x10
	// Position of CLK_SYS_SYSINFO field.
	CLOCKS_SLEEP_EN1_CLK_SYS_SYSINFO_Pos = 0x3
	// Bit mask of CLK_SYS_SYSINFO field.
	CLOCKS_SLEEP_EN1_CLK_SYS_SYSINFO_Msk = 0x8
	// Bit CLK_SYS_SYSINFO.
	CLOCKS_SLEEP_EN1_CLK_SYS_SYSINFO = 0x8
	// Position of CLK_SYS_SYSCFG field.
	CLOCKS_SLEEP_EN1_CLK_SYS_SYSCFG_Pos = 0x2
	// Bit mask of CLK_SYS_SYSCFG field.
	CLOCKS_SLEEP_EN1_CLK_SYS_SYSCFG_Msk = 0x4
	// Bit CLK_SYS_SYSCFG.
	CLOCKS_SLEEP_EN1_CLK_SYS_SYSCFG = 0x4
	// Position of CLK_SYS_SRAM5 field.
	CLOCKS_SLEEP_EN1_CLK_SYS_SRAM5_Pos = 0x1
	// Bit mask of CLK_SYS_SRAM5 field.
	CLOCKS_SLEEP_EN1_CLK_SYS_SRAM5_Msk = 0x2
	// Bit CLK_SYS_SRAM5.
	CLOCKS_SLEEP_EN1_CLK_SYS_SRAM5 = 0x2
	// Position of CLK_SYS_SRAM4 field.
	CLOCKS_SLEEP_EN1_CLK_SYS_SRAM4_Pos = 0x0
	// Bit mask of CLK_SYS_SRAM4 field.
	CLOCKS_SLEEP_EN1_CLK_SYS_SRAM4_Msk = 0x1
	// Bit CLK_SYS_SRAM4.
	CLOCKS_SLEEP_EN1_CLK_SYS_SRAM4 = 0x1

	// ENABLED0: indicates the state of the clock enable
	// Position of CLK_SYS_SRAM3 field.
	CLOCKS_ENABLED0_CLK_SYS_SRAM3_Pos = 0x1f
	// Bit mask of CLK_SYS_SRAM3 field.
	CLOCKS_ENABLED0_CLK_SYS_SRAM3_Msk = 0x80000000
	// Bit CLK_SYS_SRAM3.
	CLOCKS_ENABLED0_CLK_SYS_SRAM3 = 0x80000000
	// Position of CLK_SYS_SRAM2 field.
	CLOCKS_ENABLED0_CLK_SYS_SRAM2_Pos = 0x1e
	// Bit mask of CLK_SYS_SRAM2 field.
	CLOCKS_ENABLED0_CLK_SYS_SRAM2_Msk = 0x40000000
	// Bit CLK_SYS_SRAM2.
	CLOCKS_ENABLED0_CLK_SYS_SRAM2 = 0x40000000
	// Position of CLK_SYS_SRAM1 field.
	CLOCKS_ENABLED0_CLK_SYS_SRAM1_Pos = 0x1d
	// Bit mask of CLK_SYS_SRAM1 field.
	CLOCKS_ENABLED0_CLK_SYS_SRAM1_Msk = 0x20000000
	// Bit CLK_SYS_SRAM1.
	CLOCKS_ENABLED0_CLK_SYS_SRAM1 = 0x20000000
	// Position of CLK_SYS_SRAM0 field.
	CLOCKS_ENABLED0_CLK_SYS_SRAM0_Pos = 0x1c
	// Bit mask of CLK_SYS_SRAM0 field.
	CLOCKS_ENABLED0_CLK_SYS_SRAM0_Msk = 0x10000000
	// Bit CLK_SYS_SRAM0.
	CLOCKS_ENABLED0_CLK_SYS_SRAM0 = 0x10000000
	// Position of CLK_SYS_SPI1 field.
	CLOCKS_ENABLED0_CLK_SYS_SPI1_Pos = 0x1b
	// Bit mask of CLK_SYS_SPI1 field.
	CLOCKS_ENABLED0_CLK_SYS_SPI1_Msk = 0x8000000
	// Bit CLK_SYS_SPI1.
	CLOCKS_ENABLED0_CLK_SYS_SPI1 = 0x8000000
	// Position of CLK_PERI_SPI1 field.
	CLOCKS_ENABLED0_CLK_PERI_SPI1_Pos = 0x1a
	// Bit mask of CLK_PERI_SPI1 field.
	CLOCKS_ENABLED0_CLK_PERI_SPI1_Msk = 0x4000000
	// Bit CLK_PERI_SPI1.
	CLOCKS_ENABLED0_CLK_PERI_SPI1 = 0x4000000
	// Position of CLK_SYS_SPI0 field.
	CLOCKS_ENABLED0_CLK_SYS_SPI0_Pos = 0x19
	// Bit mask of CLK_SYS_SPI0 field.
	CLOCKS_ENABLED0_CLK_SYS_SPI0_Msk = 0x2000000
	// Bit CLK_SYS_SPI0.
	CLOCKS_ENABLED0_CLK_SYS_SPI0 = 0x2000000
	// Position of CLK_PERI_SPI0 field.
	CLOCKS_ENABLED0_CLK_PERI_SPI0_Pos = 0x18
	// Bit mask of CLK_PERI_SPI0 field.
	CLOCKS_ENABLED0_CLK_PERI_SPI0_Msk = 0x1000000
	// Bit CLK_PERI_SPI0.
	CLOCKS_ENABLED0_CLK_PERI_SPI0 = 0x1000000
	// Position of CLK_SYS_SIO field.
	CLOCKS_ENABLED0_CLK_SYS_SIO_Pos = 0x17
	// Bit mask of CLK_SYS_SIO field.
	CLOCKS_ENABLED0_CLK_SYS_SIO_Msk = 0x800000
	// Bit CLK_SYS_SIO.
	CLOCKS_ENABLED0_CLK_SYS_SIO = 0x800000
	// Position of CLK_SYS_RTC field.
	CLOCKS_ENABLED0_CLK_SYS_RTC_Pos = 0x16
	// Bit mask of CLK_SYS_RTC field.
	CLOCKS_ENABLED0_CLK_SYS_RTC_Msk = 0x400000
	// Bit CLK_SYS_RTC.
	CLOCKS_ENABLED0_CLK_SYS_RTC = 0x400000
	// Position of CLK_RTC_RTC field.
	CLOCKS_ENABLED0_CLK_RTC_RTC_Pos = 0x15
	// Bit mask of CLK_RTC_RTC field.
	CLOCKS_ENABLED0_CLK_RTC_RTC_Msk = 0x200000
	// Bit CLK_RTC_RTC.
	CLOCKS_ENABLED0_CLK_RTC_RTC = 0x200000
	// Position of CLK_SYS_ROSC field.
	CLOCKS_ENABLED0_CLK_SYS_ROSC_Pos = 0x14
	// Bit mask of CLK_SYS_ROSC field.
	CLOCKS_ENABLED0_CLK_SYS_ROSC_Msk = 0x100000
	// Bit CLK_SYS_ROSC.
	CLOCKS_ENABLED0_CLK_SYS_ROSC = 0x100000
	// Position of CLK_SYS_ROM field.
	CLOCKS_ENABLED0_CLK_SYS_ROM_Pos = 0x13
	// Bit mask of CLK_SYS_ROM field.
	CLOCKS_ENABLED0_CLK_SYS_ROM_Msk = 0x80000
	// Bit CLK_SYS_ROM.
	CLOCKS_ENABLED0_CLK_SYS_ROM = 0x80000
	// Position of CLK_SYS_RESETS field.
	CLOCKS_ENABLED0_CLK_SYS_RESETS_Pos = 0x12
	// Bit mask of CLK_SYS_RESETS field.
	CLOCKS_ENABLED0_CLK_SYS_RESETS_Msk = 0x40000
	// Bit CLK_SYS_RESETS.
	CLOCKS_ENABLED0_CLK_SYS_RESETS = 0x40000
	// Position of CLK_SYS_PWM field.
	CLOCKS_ENABLED0_CLK_SYS_PWM_Pos = 0x11
	// Bit mask of CLK_SYS_PWM field.
	CLOCKS_ENABLED0_CLK_SYS_PWM_Msk = 0x20000
	// Bit CLK_SYS_PWM.
	CLOCKS_ENABLED0_CLK_SYS_PWM = 0x20000
	// Position of CLK_SYS_PSM field.
	CLOCKS_ENABLED0_CLK_SYS_PSM_Pos = 0x10
	// Bit mask of CLK_SYS_PSM field.
	CLOCKS_ENABLED0_CLK_SYS_PSM_Msk = 0x10000
	// Bit CLK_SYS_PSM.
	CLOCKS_ENABLED0_CLK_SYS_PSM = 0x10000
	// Position of CLK_SYS_PLL_USB field.
	CLOCKS_ENABLED0_CLK_SYS_PLL_USB_Pos = 0xf
	// Bit mask of CLK_SYS_PLL_USB field.
	CLOCKS_ENABLED0_CLK_SYS_PLL_USB_Msk = 0x8000
	// Bit CLK_SYS_PLL_USB.
	CLOCKS_ENABLED0_CLK_SYS_PLL_USB = 0x8000
	// Position of CLK_SYS_PLL_SYS field.
	CLOCKS_ENABLED0_CLK_SYS_PLL_SYS_Pos = 0xe
	// Bit mask of CLK_SYS_PLL_SYS field.
	CLOCKS_ENABLED0_CLK_SYS_PLL_SYS_Msk = 0x4000
	// Bit CLK_SYS_PLL_SYS.
	CLOCKS_ENABLED0_CLK_SYS_PLL_SYS = 0x4000
	// Position of CLK_SYS_PIO1 field.
	CLOCKS_ENABLED0_CLK_SYS_PIO1_Pos = 0xd
	// Bit mask of CLK_SYS_PIO1 field.
	CLOCKS_ENABLED0_CLK_SYS_PIO1_Msk = 0x2000
	// Bit CLK_SYS_PIO1.
	CLOCKS_ENABLED0_CLK_SYS_PIO1 = 0x2000
	// Position of CLK_SYS_PIO0 field.
	CLOCKS_ENABLED0_CLK_SYS_PIO0_Pos = 0xc
	// Bit mask of CLK_SYS_PIO0 field.
	CLOCKS_ENABLED0_CLK_SYS_PIO0_Msk = 0x1000
	// Bit CLK_SYS_PIO0.
	CLOCKS_ENABLED0_CLK_SYS_PIO0 = 0x1000
	// Position of CLK_SYS_PADS field.
	CLOCKS_ENABLED0_CLK_SYS_PADS_Pos = 0xb
	// Bit mask of CLK_SYS_PADS field.
	CLOCKS_ENABLED0_CLK_SYS_PADS_Msk = 0x800
	// Bit CLK_SYS_PADS.
	CLOCKS_ENABLED0_CLK_SYS_PADS = 0x800
	// Position of CLK_SYS_VREG_AND_CHIP_RESET field.
	CLOCKS_ENABLED0_CLK_SYS_VREG_AND_CHIP_RESET_Pos = 0xa
	// Bit mask of CLK_SYS_VREG_AND_CHIP_RESET field.
	CLOCKS_ENABLED0_CLK_SYS_VREG_AND_CHIP_RESET_Msk = 0x400
	// Bit CLK_SYS_VREG_AND_CHIP_RESET.
	CLOCKS_ENABLED0_CLK_SYS_VREG_AND_CHIP_RESET = 0x400
	// Position of CLK_SYS_JTAG field.
	CLOCKS_ENABLED0_CLK_SYS_JTAG_Pos = 0x9
	// Bit mask of CLK_SYS_JTAG field.
	CLOCKS_ENABLED0_CLK_SYS_JTAG_Msk = 0x200
	// Bit CLK_SYS_JTAG.
	CLOCKS_ENABLED0_CLK_SYS_JTAG = 0x200
	// Position of CLK_SYS_IO field.
	CLOCKS_ENABLED0_CLK_SYS_IO_Pos = 0x8
	// Bit mask of CLK_SYS_IO field.
	CLOCKS_ENABLED0_CLK_SYS_IO_Msk = 0x100
	// Bit CLK_SYS_IO.
	CLOCKS_ENABLED0_CLK_SYS_IO = 0x100
	// Position of CLK_SYS_I2C1 field.
	CLOCKS_ENABLED0_CLK_SYS_I2C1_Pos = 0x7
	// Bit mask of CLK_SYS_I2C1 field.
	CLOCKS_ENABLED0_CLK_SYS_I2C1_Msk = 0x80
	// Bit CLK_SYS_I2C1.
	CLOCKS_ENABLED0_CLK_SYS_I2C1 = 0x80
	// Position of CLK_SYS_I2C0 field.
	CLOCKS_ENABLED0_CLK_SYS_I2C0_Pos = 0x6
	// Bit mask of CLK_SYS_I2C0 field.
	CLOCKS_ENABLED0_CLK_SYS_I2C0_Msk = 0x40
	// Bit CLK_SYS_I2C0.
	CLOCKS_ENABLED0_CLK_SYS_I2C0 = 0x40
	// Position of CLK_SYS_DMA field.
	CLOCKS_ENABLED0_CLK_SYS_DMA_Pos = 0x5
	// Bit mask of CLK_SYS_DMA field.
	CLOCKS_ENABLED0_CLK_SYS_DMA_Msk = 0x20
	// Bit CLK_SYS_DMA.
	CLOCKS_ENABLED0_CLK_SYS_DMA = 0x20
	// Position of CLK_SYS_BUSFABRIC field.
	CLOCKS_ENABLED0_CLK_SYS_BUSFABRIC_Pos = 0x4
	// Bit mask of CLK_SYS_BUSFABRIC field.
	CLOCKS_ENABLED0_CLK_SYS_BUSFABRIC_Msk = 0x10
	// Bit CLK_SYS_BUSFABRIC.
	CLOCKS_ENABLED0_CLK_SYS_BUSFABRIC = 0x10
	// Position of CLK_SYS_BUSCTRL field.
	CLOCKS_ENABLED0_CLK_SYS_BUSCTRL_Pos = 0x3
	// Bit mask of CLK_SYS_BUSCTRL field.
	CLOCKS_ENABLED0_CLK_SYS_BUSCTRL_Msk = 0x8
	// Bit CLK_SYS_BUSCTRL.
	CLOCKS_ENABLED0_CLK_SYS_BUSCTRL = 0x8
	// Position of CLK_SYS_ADC field.
	CLOCKS_ENABLED0_CLK_SYS_ADC_Pos = 0x2
	// Bit mask of CLK_SYS_ADC field.
	CLOCKS_ENABLED0_CLK_SYS_ADC_Msk = 0x4
	// Bit CLK_SYS_ADC.
	CLOCKS_ENABLED0_CLK_SYS_ADC = 0x4
	// Position of CLK_ADC_ADC field.
	CLOCKS_ENABLED0_CLK_ADC_ADC_Pos = 0x1
	// Bit mask of CLK_ADC_ADC field.
	CLOCKS_ENABLED0_CLK_ADC_ADC_Msk = 0x2
	// Bit CLK_ADC_ADC.
	CLOCKS_ENABLED0_CLK_ADC_ADC = 0x2
	// Position of CLK_SYS_CLOCKS field.
	CLOCKS_ENABLED0_CLK_SYS_CLOCKS_Pos = 0x0
	// Bit mask of CLK_SYS_CLOCKS field.
	CLOCKS_ENABLED0_CLK_SYS_CLOCKS_Msk = 0x1
	// Bit CLK_SYS_CLOCKS.
	CLOCKS_ENABLED0_CLK_SYS_CLOCKS = 0x1

	// ENABLED1: indicates the state of the clock enable
	// Position of CLK_SYS_XOSC field.
	CLOCKS_ENABLED1_CLK_SYS_XOSC_Pos = 0xe
	// Bit mask of CLK_SYS_XOSC field.
	CLOCKS_ENABLED1_CLK_SYS_XOSC_Msk = 0x4000
	// Bit CLK_SYS_XOSC.
	CLOCKS_ENABLED1_CLK_SYS_XOSC = 0x4000
	// Position of CLK_SYS_XIP field.
	CLOCKS_ENABLED1_CLK_SYS_XIP_Pos = 0xd
	// Bit mask of CLK_SYS_XIP field.
	CLOCKS_ENABLED1_CLK_SYS_XIP_Msk = 0x2000
	// Bit CLK_SYS_XIP.
	CLOCKS_ENABLED1_CLK_SYS_XIP = 0x2000
	// Position of CLK_SYS_WATCHDOG field.
	CLOCKS_ENABLED1_CLK_SYS_WATCHDOG_Pos = 0xc
	// Bit mask of CLK_SYS_WATCHDOG field.
	CLOCKS_ENABLED1_CLK_SYS_WATCHDOG_Msk = 0x1000
	// Bit CLK_SYS_WATCHDOG.
	CLOCKS_ENABLED1_CLK_SYS_WATCHDOG = 0x1000
	// Position of CLK_USB_USBCTRL field.
	CLOCKS_ENABLED1_CLK_USB_USBCTRL_Pos = 0xb
	// Bit mask of CLK_USB_USBCTRL field.
	CLOCKS_ENABLED1_CLK_USB_USBCTRL_Msk = 0x800
	// Bit CLK_USB_USBCTRL.
	CLOCKS_ENABLED1_CLK_USB_USBCTRL = 0x800
	// Position of CLK_SYS_USBCTRL field.
	CLOCKS_ENABLED1_CLK_SYS_USBCTRL_Pos = 0xa
	// Bit mask of CLK_SYS_USBCTRL field.
	CLOCKS_ENABLED1_CLK_SYS_USBCTRL_Msk = 0x400
	// Bit CLK_SYS_USBCTRL.
	CLOCKS_ENABLED1_CLK_SYS_USBCTRL = 0x400
	// Position of CLK_SYS_UART1 field.
	CLOCKS_ENABLED1_CLK_SYS_UART1_Pos = 0x9
	// Bit mask of CLK_SYS_UART1 field.
	CLOCKS_ENABLED1_CLK_SYS_UART1_Msk = 0x200
	// Bit CLK_SYS_UART1.
	CLOCKS_ENABLED1_CLK_SYS_UART1 = 0x200
	// Position of CLK_PERI_UART1 field.
	CLOCKS_ENABLED1_CLK_PERI_UART1_Pos = 0x8
	// Bit mask of CLK_PERI_UART1 field.
	CLOCKS_ENABLED1_CLK_PERI_UART1_Msk = 0x100
	// Bit CLK_PERI_UART1.
	CLOCKS_ENABLED1_CLK_PERI_UART1 = 0x100
	// Position of CLK_SYS_UART0 field.
	CLOCKS_ENABLED1_CLK_SYS_UART0_Pos = 0x7
	// Bit mask of CLK_SYS_UART0 field.
	CLOCKS_ENABLED1_CLK_SYS_UART0_Msk = 0x80
	// Bit CLK_SYS_UART0.
	CLOCKS_ENABLED1_CLK_SYS_UART0 = 0x80
	// Position of CLK_PERI_UART0 field.
	CLOCKS_ENABLED1_CLK_PERI_UART0_Pos = 0x6
	// Bit mask of CLK_PERI_UART0 field.
	CLOCKS_ENABLED1_CLK_PERI_UART0_Msk = 0x40
	// Bit CLK_PERI_UART0.
	CLOCKS_ENABLED1_CLK_PERI_UART0 = 0x40
	// Position of CLK_SYS_TIMER field.
	CLOCKS_ENABLED1_CLK_SYS_TIMER_Pos = 0x5
	// Bit mask of CLK_SYS_TIMER field.
	CLOCKS_ENABLED1_CLK_SYS_TIMER_Msk = 0x20
	// Bit CLK_SYS_TIMER.
	CLOCKS_ENABLED1_CLK_SYS_TIMER = 0x20
	// Position of CLK_SYS_TBMAN field.
	CLOCKS_ENABLED1_CLK_SYS_TBMAN_Pos = 0x4
	// Bit mask of CLK_SYS_TBMAN field.
	CLOCKS_ENABLED1_CLK_SYS_TBMAN_Msk = 0x10
	// Bit CLK_SYS_TBMAN.
	CLOCKS_ENABLED1_CLK_SYS_TBMAN = 0x10
	// Position of CLK_SYS_SYSINFO field.
	CLOCKS_ENABLED1_CLK_SYS_SYSINFO_Pos = 0x3
	// Bit mask of CLK_SYS_SYSINFO field.
	CLOCKS_ENABLED1_CLK_SYS_SYSINFO_Msk = 0x8
	// Bit CLK_SYS_SYSINFO.
	CLOCKS_ENABLED1_CLK_SYS_SYSINFO = 0x8
	// Position of CLK_SYS_SYSCFG field.
	CLOCKS_ENABLED1_CLK_SYS_SYSCFG_Pos = 0x2
	// Bit mask of CLK_SYS_SYSCFG field.
	CLOCKS_ENABLED1_CLK_SYS_SYSCFG_Msk = 0x4
	// Bit CLK_SYS_SYSCFG.
	CLOCKS_ENABLED1_CLK_SYS_SYSCFG = 0x4
	// Position of CLK_SYS_SRAM5 field.
	CLOCKS_ENABLED1_CLK_SYS_SRAM5_Pos = 0x1
	// Bit mask of CLK_SYS_SRAM5 field.
	CLOCKS_ENABLED1_CLK_SYS_SRAM5_Msk = 0x2
	// Bit CLK_SYS_SRAM5.
	CLOCKS_ENABLED1_CLK_SYS_SRAM5 = 0x2
	// Position of CLK_SYS_SRAM4 field.
	CLOCKS_ENABLED1_CLK_SYS_SRAM4_Pos = 0x0
	// Bit mask of CLK_SYS_SRAM4 field.
	CLOCKS_ENABLED1_CLK_SYS_SRAM4_Msk = 0x1
	// Bit CLK_SYS_SRAM4.
	CLOCKS_ENABLED1_CLK_SYS_SRAM4 = 0x1

	// INTR: Raw Interrupts
	// Position of CLK_SYS_RESUS field.
	CLOCKS_INTR_CLK_SYS_RESUS_Pos = 0x0
	// Bit mask of CLK_SYS_RESUS field.
	CLOCKS_INTR_CLK_SYS_RESUS_Msk = 0x1
	// Bit CLK_SYS_RESUS.
	CLOCKS_INTR_CLK_SYS_RESUS = 0x1

	// INTE: Interrupt Enable
	// Position of CLK_SYS_RESUS field.
	CLOCKS_INTE_CLK_SYS_RESUS_Pos = 0x0
	// Bit mask of CLK_SYS_RESUS field.
	CLOCKS_INTE_CLK_SYS_RESUS_Msk = 0x1
	// Bit CLK_SYS_RESUS.
	CLOCKS_INTE_CLK_SYS_RESUS = 0x1

	// INTF: Interrupt Force
	// Position of CLK_SYS_RESUS field.
	CLOCKS_INTF_CLK_SYS_RESUS_Pos = 0x0
	// Bit mask of CLK_SYS_RESUS field.
	CLOCKS_INTF_CLK_SYS_RESUS_Msk = 0x1
	// Bit CLK_SYS_RESUS.
	CLOCKS_INTF_CLK_SYS_RESUS = 0x1

	// INTS: Interrupt status after masking & forcing
	// Position of CLK_SYS_RESUS field.
	CLOCKS_INTS_CLK_SYS_RESUS_Pos = 0x0
	// Bit mask of CLK_SYS_RESUS field.
	CLOCKS_INTS_CLK_SYS_RESUS_Msk = 0x1
	// Bit CLK_SYS_RESUS.
	CLOCKS_INTS_CLK_SYS_RESUS = 0x1
)

// Constants for RESETS
const (
	// RESET: Reset control. If a bit is set it means the peripheral is in reset. 0 means the peripheral's reset is deasserted.
	// Position of USBCTRL field.
	RESETS_RESET_USBCTRL_Pos = 0x18
	// Bit mask of USBCTRL field.
	RESETS_RESET_USBCTRL_Msk = 0x1000000
	// Bit USBCTRL.
	RESETS_RESET_USBCTRL = 0x1000000
	// Position of UART1 field.
	RESETS_RESET_UART1_Pos = 0x17
	// Bit mask of UART1 field.
	RESETS_RESET_UART1_Msk = 0x800000
	// Bit UART1.
	RESETS_RESET_UART1 = 0x800000
	// Position of UART0 field.
	RESETS_RESET_UART0_Pos = 0x16
	// Bit mask of UART0 field.
	RESETS_RESET_UART0_Msk = 0x400000
	// Bit UART0.
	RESETS_RESET_UART0 = 0x400000
	// Position of TIMER field.
	RESETS_RESET_TIMER_Pos = 0x15
	// Bit mask of TIMER field.
	RESETS_RESET_TIMER_Msk = 0x200000
	// Bit TIMER.
	RESETS_RESET_TIMER = 0x200000
	// Position of TBMAN field.
	RESETS_RESET_TBMAN_Pos = 0x14
	// Bit mask of TBMAN field.
	RESETS_RESET_TBMAN_Msk = 0x100000
	// Bit TBMAN.
	RESETS_RESET_TBMAN = 0x100000
	// Position of SYSINFO field.
	RESETS_RESET_SYSINFO_Pos = 0x13
	// Bit mask of SYSINFO field.
	RESETS_RESET_SYSINFO_Msk = 0x80000
	// Bit SYSINFO.
	RESETS_RESET_SYSINFO = 0x80000
	// Position of SYSCFG field.
	RESETS_RESET_SYSCFG_Pos = 0x12
	// Bit mask of SYSCFG field.
	RESETS_RESET_SYSCFG_Msk = 0x40000
	// Bit SYSCFG.
	RESETS_RESET_SYSCFG = 0x40000
	// Position of SPI1 field.
	RESETS_RESET_SPI1_Pos = 0x11
	// Bit mask of SPI1 field.
	RESETS_RESET_SPI1_Msk = 0x20000
	// Bit SPI1.
	RESETS_RESET_SPI1 = 0x20000
	// Position of SPI0 field.
	RESETS_RESET_SPI0_Pos = 0x10
	// Bit mask of SPI0 field.
	RESETS_RESET_SPI0_Msk = 0x10000
	// Bit SPI0.
	RESETS_RESET_SPI0 = 0x10000
	// Position of RTC field.
	RESETS_RESET_RTC_Pos = 0xf
	// Bit mask of RTC field.
	RESETS_RESET_RTC_Msk = 0x8000
	// Bit RTC.
	RESETS_RESET_RTC = 0x8000
	// Position of PWM field.
	RESETS_RESET_PWM_Pos = 0xe
	// Bit mask of PWM field.
	RESETS_RESET_PWM_Msk = 0x4000
	// Bit PWM.
	RESETS_RESET_PWM = 0x4000
	// Position of PLL_USB field.
	RESETS_RESET_PLL_USB_Pos = 0xd
	// Bit mask of PLL_USB field.
	RESETS_RESET_PLL_USB_Msk = 0x2000
	// Bit PLL_USB.
	RESETS_RESET_PLL_USB = 0x2000
	// Position of PLL_SYS field.
	RESETS_RESET_PLL_SYS_Pos = 0xc
	// Bit mask of PLL_SYS field.
	RESETS_RESET_PLL_SYS_Msk = 0x1000
	// Bit PLL_SYS.
	RESETS_RESET_PLL_SYS = 0x1000
	// Position of PIO1 field.
	RESETS_RESET_PIO1_Pos = 0xb
	// Bit mask of PIO1 field.
	RESETS_RESET_PIO1_Msk = 0x800
	// Bit PIO1.
	RESETS_RESET_PIO1 = 0x800
	// Position of PIO0 field.
	RESETS_RESET_PIO0_Pos = 0xa
	// Bit mask of PIO0 field.
	RESETS_RESET_PIO0_Msk = 0x400
	// Bit PIO0.
	RESETS_RESET_PIO0 = 0x400
	// Position of PADS_QSPI field.
	RESETS_RESET_PADS_QSPI_Pos = 0x9
	// Bit mask of PADS_QSPI field.
	RESETS_RESET_PADS_QSPI_Msk = 0x200
	// Bit PADS_QSPI.
	RESETS_RESET_PADS_QSPI = 0x200
	// Position of PADS_BANK0 field.
	RESETS_RESET_PADS_BANK0_Pos = 0x8
	// Bit mask of PADS_BANK0 field.
	RESETS_RESET_PADS_BANK0_Msk = 0x100
	// Bit PADS_BANK0.
	RESETS_RESET_PADS_BANK0 = 0x100
	// Position of JTAG field.
	RESETS_RESET_JTAG_Pos = 0x7
	// Bit mask of JTAG field.
	RESETS_RESET_JTAG_Msk = 0x80
	// Bit JTAG.
	RESETS_RESET_JTAG = 0x80
	// Position of IO_QSPI field.
	RESETS_RESET_IO_QSPI_Pos = 0x6
	// Bit mask of IO_QSPI field.
	RESETS_RESET_IO_QSPI_Msk = 0x40
	// Bit IO_QSPI.
	RESETS_RESET_IO_QSPI = 0x40
	// Position of IO_BANK0 field.
	RESETS_RESET_IO_BANK0_Pos = 0x5
	// Bit mask of IO_BANK0 field.
	RESETS_RESET_IO_BANK0_Msk = 0x20
	// Bit IO_BANK0.
	RESETS_RESET_IO_BANK0 = 0x20
	// Position of I2C1 field.
	RESETS_RESET_I2C1_Pos = 0x4
	// Bit mask of I2C1 field.
	RESETS_RESET_I2C1_Msk = 0x10
	// Bit I2C1.
	RESETS_RESET_I2C1 = 0x10
	// Position of I2C0 field.
	RESETS_RESET_I2C0_Pos = 0x3
	// Bit mask of I2C0 field.
	RESETS_RESET_I2C0_Msk = 0x8
	// Bit I2C0.
	RESETS_RESET_I2C0 = 0x8
	// Position of DMA field.
	RESETS_RESET_DMA_Pos = 0x2
	// Bit mask of DMA field.
	RESETS_RESET_DMA_Msk = 0x4
	// Bit DMA.
	RESETS_RESET_DMA = 0x4
	// Position of BUSCTRL field.
	RESETS_RESET_BUSCTRL_Pos = 0x1
	// Bit mask of BUSCTRL field.
	RESETS_RESET_BUSCTRL_Msk = 0x2
	// Bit BUSCTRL.
	RESETS_RESET_BUSCTRL = 0x2
	// Position of ADC field.
	RESETS_RESET_ADC_Pos = 0x0
	// Bit mask of ADC field.
	RESETS_RESET_ADC_Msk = 0x1
	// Bit ADC.
	RESETS_RESET_ADC = 0x1

	// WDSEL: Watchdog select. If a bit is set then the watchdog will reset this peripheral when the watchdog fires.
	// Position of USBCTRL field.
	RESETS_WDSEL_USBCTRL_Pos = 0x18
	// Bit mask of USBCTRL field.
	RESETS_WDSEL_USBCTRL_Msk = 0x1000000
	// Bit USBCTRL.
	RESETS_WDSEL_USBCTRL = 0x1000000
	// Position of UART1 field.
	RESETS_WDSEL_UART1_Pos = 0x17
	// Bit mask of UART1 field.
	RESETS_WDSEL_UART1_Msk = 0x800000
	// Bit UART1.
	RESETS_WDSEL_UART1 = 0x800000
	// Position of UART0 field.
	RESETS_WDSEL_UART0_Pos = 0x16
	// Bit mask of UART0 field.
	RESETS_WDSEL_UART0_Msk = 0x400000
	// Bit UART0.
	RESETS_WDSEL_UART0 = 0x400000
	// Position of TIMER field.
	RESETS_WDSEL_TIMER_Pos = 0x15
	// Bit mask of TIMER field.
	RESETS_WDSEL_TIMER_Msk = 0x200000
	// Bit TIMER.
	RESETS_WDSEL_TIMER = 0x200000
	// Position of TBMAN field.
	RESETS_WDSEL_TBMAN_Pos = 0x14
	// Bit mask of TBMAN field.
	RESETS_WDSEL_TBMAN_Msk = 0x100000
	// Bit TBMAN.
	RESETS_WDSEL_TBMAN = 0x100000
	// Position of SYSINFO field.
	RESETS_WDSEL_SYSINFO_Pos = 0x13
	// Bit mask of SYSINFO field.
	RESETS_WDSEL_SYSINFO_Msk = 0x80000
	// Bit SYSINFO.
	RESETS_WDSEL_SYSINFO = 0x80000
	// Position of SYSCFG field.
	RESETS_WDSEL_SYSCFG_Pos = 0x12
	// Bit mask of SYSCFG field.
	RESETS_WDSEL_SYSCFG_Msk = 0x40000
	// Bit SYSCFG.
	RESETS_WDSEL_SYSCFG = 0x40000
	// Position of SPI1 field.
	RESETS_WDSEL_SPI1_Pos = 0x11
	// Bit mask of SPI1 field.
	RESETS_WDSEL_SPI1_Msk = 0x20000
	// Bit SPI1.
	RESETS_WDSEL_SPI1 = 0x20000
	// Position of SPI0 field.
	RESETS_WDSEL_SPI0_Pos = 0x10
	// Bit mask of SPI0 field.
	RESETS_WDSEL_SPI0_Msk = 0x10000
	// Bit SPI0.
	RESETS_WDSEL_SPI0 = 0x10000
	// Position of RTC field.
	RESETS_WDSEL_RTC_Pos = 0xf
	// Bit mask of RTC field.
	RESETS_WDSEL_RTC_Msk = 0x8000
	// Bit RTC.
	RESETS_WDSEL_RTC = 0x8000
	// Position of PWM field.
	RESETS_WDSEL_PWM_Pos = 0xe
	// Bit mask of PWM field.
	RESETS_WDSEL_PWM_Msk = 0x4000
	// Bit PWM.
	RESETS_WDSEL_PWM = 0x4000
	// Position of PLL_USB field.
	RESETS_WDSEL_PLL_USB_Pos = 0xd
	// Bit mask of PLL_USB field.
	RESETS_WDSEL_PLL_USB_Msk = 0x2000
	// Bit PLL_USB.
	RESETS_WDSEL_PLL_USB = 0x2000
	// Position of PLL_SYS field.
	RESETS_WDSEL_PLL_SYS_Pos = 0xc
	// Bit mask of PLL_SYS field.
	RESETS_WDSEL_PLL_SYS_Msk = 0x1000
	// Bit PLL_SYS.
	RESETS_WDSEL_PLL_SYS = 0x1000
	// Position of PIO1 field.
	RESETS_WDSEL_PIO1_Pos = 0xb
	// Bit mask of PIO1 field.
	RESETS_WDSEL_PIO1_Msk = 0x800
	// Bit PIO1.
	RESETS_WDSEL_PIO1 = 0x800
	// Position of PIO0 field.
	RESETS_WDSEL_PIO0_Pos = 0xa
	// Bit mask of PIO0 field.
	RESETS_WDSEL_PIO0_Msk = 0x400
	// Bit PIO0.
	RESETS_WDSEL_PIO0 = 0x400
	// Position of PADS_QSPI field.
	RESETS_WDSEL_PADS_QSPI_Pos = 0x9
	// Bit mask of PADS_QSPI field.
	RESETS_WDSEL_PADS_QSPI_Msk = 0x200
	// Bit PADS_QSPI.
	RESETS_WDSEL_PADS_QSPI = 0x200
	// Position of PADS_BANK0 field.
	RESETS_WDSEL_PADS_BANK0_Pos = 0x8
	// Bit mask of PADS_BANK0 field.
	RESETS_WDSEL_PADS_BANK0_Msk = 0x100
	// Bit PADS_BANK0.
	RESETS_WDSEL_PADS_BANK0 = 0x100
	// Position of JTAG field.
	RESETS_WDSEL_JTAG_Pos = 0x7
	// Bit mask of JTAG field.
	RESETS_WDSEL_JTAG_Msk = 0x80
	// Bit JTAG.
	RESETS_WDSEL_JTAG = 0x80
	// Position of IO_QSPI field.
	RESETS_WDSEL_IO_QSPI_Pos = 0x6
	// Bit mask of IO_QSPI field.
	RESETS_WDSEL_IO_QSPI_Msk = 0x40
	// Bit IO_QSPI.
	RESETS_WDSEL_IO_QSPI = 0x40
	// Position of IO_BANK0 field.
	RESETS_WDSEL_IO_BANK0_Pos = 0x5
	// Bit mask of IO_BANK0 field.
	RESETS_WDSEL_IO_BANK0_Msk = 0x20
	// Bit IO_BANK0.
	RESETS_WDSEL_IO_BANK0 = 0x20
	// Position of I2C1 field.
	RESETS_WDSEL_I2C1_Pos = 0x4
	// Bit mask of I2C1 field.
	RESETS_WDSEL_I2C1_Msk = 0x10
	// Bit I2C1.
	RESETS_WDSEL_I2C1 = 0x10
	// Position of I2C0 field.
	RESETS_WDSEL_I2C0_Pos = 0x3
	// Bit mask of I2C0 field.
	RESETS_WDSEL_I2C0_Msk = 0x8
	// Bit I2C0.
	RESETS_WDSEL_I2C0 = 0x8
	// Position of DMA field.
	RESETS_WDSEL_DMA_Pos = 0x2
	// Bit mask of DMA field.
	RESETS_WDSEL_DMA_Msk = 0x4
	// Bit DMA.
	RESETS_WDSEL_DMA = 0x4
	// Position of BUSCTRL field.
	RESETS_WDSEL_BUSCTRL_Pos = 0x1
	// Bit mask of BUSCTRL field.
	RESETS_WDSEL_BUSCTRL_Msk = 0x2
	// Bit BUSCTRL.
	RESETS_WDSEL_BUSCTRL = 0x2
	// Position of ADC field.
	RESETS_WDSEL_ADC_Pos = 0x0
	// Bit mask of ADC field.
	RESETS_WDSEL_ADC_Msk = 0x1
	// Bit ADC.
	RESETS_WDSEL_ADC = 0x1

	// RESET_DONE: Reset done. If a bit is set then a reset done signal has been returned by the peripheral. This indicates that the peripheral's registers are ready to be accessed.
	// Position of USBCTRL field.
	RESETS_RESET_DONE_USBCTRL_Pos = 0x18
	// Bit mask of USBCTRL field.
	RESETS_RESET_DONE_USBCTRL_Msk = 0x1000000
	// Bit USBCTRL.
	RESETS_RESET_DONE_USBCTRL = 0x1000000
	// Position of UART1 field.
	RESETS_RESET_DONE_UART1_Pos = 0x17
	// Bit mask of UART1 field.
	RESETS_RESET_DONE_UART1_Msk = 0x800000
	// Bit UART1.
	RESETS_RESET_DONE_UART1 = 0x800000
	// Position of UART0 field.
	RESETS_RESET_DONE_UART0_Pos = 0x16
	// Bit mask of UART0 field.
	RESETS_RESET_DONE_UART0_Msk = 0x400000
	// Bit UART0.
	RESETS_RESET_DONE_UART0 = 0x400000
	// Position of TIMER field.
	RESETS_RESET_DONE_TIMER_Pos = 0x15
	// Bit mask of TIMER field.
	RESETS_RESET_DONE_TIMER_Msk = 0x200000
	// Bit TIMER.
	RESETS_RESET_DONE_TIMER = 0x200000
	// Position of TBMAN field.
	RESETS_RESET_DONE_TBMAN_Pos = 0x14
	// Bit mask of TBMAN field.
	RESETS_RESET_DONE_TBMAN_Msk = 0x100000
	// Bit TBMAN.
	RESETS_RESET_DONE_TBMAN = 0x100000
	// Position of SYSINFO field.
	RESETS_RESET_DONE_SYSINFO_Pos = 0x13
	// Bit mask of SYSINFO field.
	RESETS_RESET_DONE_SYSINFO_Msk = 0x80000
	// Bit SYSINFO.
	RESETS_RESET_DONE_SYSINFO = 0x80000
	// Position of SYSCFG field.
	RESETS_RESET_DONE_SYSCFG_Pos = 0x12
	// Bit mask of SYSCFG field.
	RESETS_RESET_DONE_SYSCFG_Msk = 0x40000
	// Bit SYSCFG.
	RESETS_RESET_DONE_SYSCFG = 0x40000
	// Position of SPI1 field.
	RESETS_RESET_DONE_SPI1_Pos = 0x11
	// Bit mask of SPI1 field.
	RESETS_RESET_DONE_SPI1_Msk = 0x20000
	// Bit SPI1.
	RESETS_RESET_DONE_SPI1 = 0x20000
	// Position of SPI0 field.
	RESETS_RESET_DONE_SPI0_Pos = 0x10
	// Bit mask of SPI0 field.
	RESETS_RESET_DONE_SPI0_Msk = 0x10000
	// Bit SPI0.
	RESETS_RESET_DONE_SPI0 = 0x10000
	// Position of RTC field.
	RESETS_RESET_DONE_RTC_Pos = 0xf
	// Bit mask of RTC field.
	RESETS_RESET_DONE_RTC_Msk = 0x8000
	// Bit RTC.
	RESETS_RESET_DONE_RTC = 0x8000
	// Position of PWM field.
	RESETS_RESET_DONE_PWM_Pos = 0xe
	// Bit mask of PWM field.
	RESETS_RESET_DONE_PWM_Msk = 0x4000
	// Bit PWM.
	RESETS_RESET_DONE_PWM = 0x4000
	// Position of PLL_USB field.
	RESETS_RESET_DONE_PLL_USB_Pos = 0xd
	// Bit mask of PLL_USB field.
	RESETS_RESET_DONE_PLL_USB_Msk = 0x2000
	// Bit PLL_USB.
	RESETS_RESET_DONE_PLL_USB = 0x2000
	// Position of PLL_SYS field.
	RESETS_RESET_DONE_PLL_SYS_Pos = 0xc
	// Bit mask of PLL_SYS field.
	RESETS_RESET_DONE_PLL_SYS_Msk = 0x1000
	// Bit PLL_SYS.
	RESETS_RESET_DONE_PLL_SYS = 0x1000
	// Position of PIO1 field.
	RESETS_RESET_DONE_PIO1_Pos = 0xb
	// Bit mask of PIO1 field.
	RESETS_RESET_DONE_PIO1_Msk = 0x800
	// Bit PIO1.
	RESETS_RESET_DONE_PIO1 = 0x800
	// Position of PIO0 field.
	RESETS_RESET_DONE_PIO0_Pos = 0xa
	// Bit mask of PIO0 field.
	RESETS_RESET_DONE_PIO0_Msk = 0x400
	// Bit PIO0.
	RESETS_RESET_DONE_PIO0 = 0x400
	// Position of PADS_QSPI field.
	RESETS_RESET_DONE_PADS_QSPI_Pos = 0x9
	// Bit mask of PADS_QSPI field.
	RESETS_RESET_DONE_PADS_QSPI_Msk = 0x200
	// Bit PADS_QSPI.
	RESETS_RESET_DONE_PADS_QSPI = 0x200
	// Position of PADS_BANK0 field.
	RESETS_RESET_DONE_PADS_BANK0_Pos = 0x8
	// Bit mask of PADS_BANK0 field.
	RESETS_RESET_DONE_PADS_BANK0_Msk = 0x100
	// Bit PADS_BANK0.
	RESETS_RESET_DONE_PADS_BANK0 = 0x100
	// Position of JTAG field.
	RESETS_RESET_DONE_JTAG_Pos = 0x7
	// Bit mask of JTAG field.
	RESETS_RESET_DONE_JTAG_Msk = 0x80
	// Bit JTAG.
	RESETS_RESET_DONE_JTAG = 0x80
	// Position of IO_QSPI field.
	RESETS_RESET_DONE_IO_QSPI_Pos = 0x6
	// Bit mask of IO_QSPI field.
	RESETS_RESET_DONE_IO_QSPI_Msk = 0x40
	// Bit IO_QSPI.
	RESETS_RESET_DONE_IO_QSPI = 0x40
	// Position of IO_BANK0 field.
	RESETS_RESET_DONE_IO_BANK0_Pos = 0x5
	// Bit mask of IO_BANK0 field.
	RESETS_RESET_DONE_IO_BANK0_Msk = 0x20
	// Bit IO_BANK0.
	RESETS_RESET_DONE_IO_BANK0 = 0x20
	// Position of I2C1 field.
	RESETS_RESET_DONE_I2C1_Pos = 0x4
	// Bit mask of I2C1 field.
	RESETS_RESET_DONE_I2C1_Msk = 0x10
	// Bit I2C1.
	RESETS_RESET_DONE_I2C1 = 0x10
	// Position of I2C0 field.
	RESETS_RESET_DONE_I2C0_Pos = 0x3
	// Bit mask of I2C0 field.
	RESETS_RESET_DONE_I2C0_Msk = 0x8
	// Bit I2C0.
	RESETS_RESET_DONE_I2C0 = 0x8
	// Position of DMA field.
	RESETS_RESET_DONE_DMA_Pos = 0x2
	// Bit mask of DMA field.
	RESETS_RESET_DONE_DMA_Msk = 0x4
	// Bit DMA.
	RESETS_RESET_DONE_DMA = 0x4
	// Position of BUSCTRL field.
	RESETS_RESET_DONE_BUSCTRL_Pos = 0x1
	// Bit mask of BUSCTRL field.
	RESETS_RESET_DONE_BUSCTRL_Msk = 0x2
	// Bit BUSCTRL.
	RESETS_RESET_DONE_BUSCTRL = 0x2
	// Position of ADC field.
	RESETS_RESET_DONE_ADC_Pos = 0x0
	// Bit mask of ADC field.
	RESETS_RESET_DONE_ADC_Msk = 0x1
	// Bit ADC.
	RESETS_RESET_DONE_ADC = 0x1
)

// Constants for PSM
const (
	// FRCE_ON: Force block out of reset (i.e. power it on)
	// Position of PROC1 field.
	PSM_FRCE_ON_PROC1_Pos = 0x10
	// Bit mask of PROC1 field.
	PSM_FRCE_ON_PROC1_Msk = 0x10000
	// Bit PROC1.
	PSM_FRCE_ON_PROC1 = 0x10000
	// Position of PROC0 field.
	PSM_FRCE_ON_PROC0_Pos = 0xf
	// Bit mask of PROC0 field.
	PSM_FRCE_ON_PROC0_Msk = 0x8000
	// Bit PROC0.
	PSM_FRCE_ON_PROC0 = 0x8000
	// Position of SIO field.
	PSM_FRCE_ON_SIO_Pos = 0xe
	// Bit mask of SIO field.
	PSM_FRCE_ON_SIO_Msk = 0x4000
	// Bit SIO.
	PSM_FRCE_ON_SIO = 0x4000
	// Position of VREG_AND_CHIP_RESET field.
	PSM_FRCE_ON_VREG_AND_CHIP_RESET_Pos = 0xd
	// Bit mask of VREG_AND_CHIP_RESET field.
	PSM_FRCE_ON_VREG_AND_CHIP_RESET_Msk = 0x2000
	// Bit VREG_AND_CHIP_RESET.
	PSM_FRCE_ON_VREG_AND_CHIP_RESET = 0x2000
	// Position of XIP field.
	PSM_FRCE_ON_XIP_Pos = 0xc
	// Bit mask of XIP field.
	PSM_FRCE_ON_XIP_Msk = 0x1000
	// Bit XIP.
	PSM_FRCE_ON_XIP = 0x1000
	// Position of SRAM5 field.
	PSM_FRCE_ON_SRAM5_Pos = 0xb
	// Bit mask of SRAM5 field.
	PSM_FRCE_ON_SRAM5_Msk = 0x800
	// Bit SRAM5.
	PSM_FRCE_ON_SRAM5 = 0x800
	// Position of SRAM4 field.
	PSM_FRCE_ON_SRAM4_Pos = 0xa
	// Bit mask of SRAM4 field.
	PSM_FRCE_ON_SRAM4_Msk = 0x400
	// Bit SRAM4.
	PSM_FRCE_ON_SRAM4 = 0x400
	// Position of SRAM3 field.
	PSM_FRCE_ON_SRAM3_Pos = 0x9
	// Bit mask of SRAM3 field.
	PSM_FRCE_ON_SRAM3_Msk = 0x200
	// Bit SRAM3.
	PSM_FRCE_ON_SRAM3 = 0x200
	// Position of SRAM2 field.
	PSM_FRCE_ON_SRAM2_Pos = 0x8
	// Bit mask of SRAM2 field.
	PSM_FRCE_ON_SRAM2_Msk = 0x100
	// Bit SRAM2.
	PSM_FRCE_ON_SRAM2 = 0x100
	// Position of SRAM1 field.
	PSM_FRCE_ON_SRAM1_Pos = 0x7
	// Bit mask of SRAM1 field.
	PSM_FRCE_ON_SRAM1_Msk = 0x80
	// Bit SRAM1.
	PSM_FRCE_ON_SRAM1 = 0x80
	// Position of SRAM0 field.
	PSM_FRCE_ON_SRAM0_Pos = 0x6
	// Bit mask of SRAM0 field.
	PSM_FRCE_ON_SRAM0_Msk = 0x40
	// Bit SRAM0.
	PSM_FRCE_ON_SRAM0 = 0x40
	// Position of ROM field.
	PSM_FRCE_ON_ROM_Pos = 0x5
	// Bit mask of ROM field.
	PSM_FRCE_ON_ROM_Msk = 0x20
	// Bit ROM.
	PSM_FRCE_ON_ROM = 0x20
	// Position of BUSFABRIC field.
	PSM_FRCE_ON_BUSFABRIC_Pos = 0x4
	// Bit mask of BUSFABRIC field.
	PSM_FRCE_ON_BUSFABRIC_Msk = 0x10
	// Bit BUSFABRIC.
	PSM_FRCE_ON_BUSFABRIC = 0x10
	// Position of RESETS field.
	PSM_FRCE_ON_RESETS_Pos = 0x3
	// Bit mask of RESETS field.
	PSM_FRCE_ON_RESETS_Msk = 0x8
	// Bit RESETS.
	PSM_FRCE_ON_RESETS = 0x8
	// Position of CLOCKS field.
	PSM_FRCE_ON_CLOCKS_Pos = 0x2
	// Bit mask of CLOCKS field.
	PSM_FRCE_ON_CLOCKS_Msk = 0x4
	// Bit CLOCKS.
	PSM_FRCE_ON_CLOCKS = 0x4
	// Position of XOSC field.
	PSM_FRCE_ON_XOSC_Pos = 0x1
	// Bit mask of XOSC field.
	PSM_FRCE_ON_XOSC_Msk = 0x2
	// Bit XOSC.
	PSM_FRCE_ON_XOSC = 0x2
	// Position of ROSC field.
	PSM_FRCE_ON_ROSC_Pos = 0x0
	// Bit mask of ROSC field.
	PSM_FRCE_ON_ROSC_Msk = 0x1
	// Bit ROSC.
	PSM_FRCE_ON_ROSC = 0x1

	// FRCE_OFF: Force into reset (i.e. power it off)
	// Position of PROC1 field.
	PSM_FRCE_OFF_PROC1_Pos = 0x10
	// Bit mask of PROC1 field.
	PSM_FRCE_OFF_PROC1_Msk = 0x10000
	// Bit PROC1.
	PSM_FRCE_OFF_PROC1 = 0x10000
	// Position of PROC0 field.
	PSM_FRCE_OFF_PROC0_Pos = 0xf
	// Bit mask of PROC0 field.
	PSM_FRCE_OFF_PROC0_Msk = 0x8000
	// Bit PROC0.
	PSM_FRCE_OFF_PROC0 = 0x8000
	// Position of SIO field.
	PSM_FRCE_OFF_SIO_Pos = 0xe
	// Bit mask of SIO field.
	PSM_FRCE_OFF_SIO_Msk = 0x4000
	// Bit SIO.
	PSM_FRCE_OFF_SIO = 0x4000
	// Position of VREG_AND_CHIP_RESET field.
	PSM_FRCE_OFF_VREG_AND_CHIP_RESET_Pos = 0xd
	// Bit mask of VREG_AND_CHIP_RESET field.
	PSM_FRCE_OFF_VREG_AND_CHIP_RESET_Msk = 0x2000
	// Bit VREG_AND_CHIP_RESET.
	PSM_FRCE_OFF_VREG_AND_CHIP_RESET = 0x2000
	// Position of XIP field.
	PSM_FRCE_OFF_XIP_Pos = 0xc
	// Bit mask of XIP field.
	PSM_FRCE_OFF_XIP_Msk = 0x1000
	// Bit XIP.
	PSM_FRCE_OFF_XIP = 0x1000
	// Position of SRAM5 field.
	PSM_FRCE_OFF_SRAM5_Pos = 0xb
	// Bit mask of SRAM5 field.
	PSM_FRCE_OFF_SRAM5_Msk = 0x800
	// Bit SRAM5.
	PSM_FRCE_OFF_SRAM5 = 0x800
	// Position of SRAM4 field.
	PSM_FRCE_OFF_SRAM4_Pos = 0xa
	// Bit mask of SRAM4 field.
	PSM_FRCE_OFF_SRAM4_Msk = 0x400
	// Bit SRAM4.
	PSM_FRCE_OFF_SRAM4 = 0x400
	// Position of SRAM3 field.
	PSM_FRCE_OFF_SRAM3_Pos = 0x9
	// Bit mask of SRAM3 field.
	PSM_FRCE_OFF_SRAM3_Msk = 0x200
	// Bit SRAM3.
	PSM_FRCE_OFF_SRAM3 = 0x200
	// Position of SRAM2 field.
	PSM_FRCE_OFF_SRAM2_Pos = 0x8
	// Bit mask of SRAM2 field.
	PSM_FRCE_OFF_SRAM2_Msk = 0x100
	// Bit SRAM2.
	PSM_FRCE_OFF_SRAM2 = 0x100
	// Position of SRAM1 field.
	PSM_FRCE_OFF_SRAM1_Pos = 0x7
	// Bit mask of SRAM1 field.
	PSM_FRCE_OFF_SRAM1_Msk = 0x80
	// Bit SRAM1.
	PSM_FRCE_OFF_SRAM1 = 0x80
	// Position of SRAM0 field.
	PSM_FRCE_OFF_SRAM0_Pos = 0x6
	// Bit mask of SRAM0 field.
	PSM_FRCE_OFF_SRAM0_Msk = 0x40
	// Bit SRAM0.
	PSM_FRCE_OFF_SRAM0 = 0x40
	// Position of ROM field.
	PSM_FRCE_OFF_ROM_Pos = 0x5
	// Bit mask of ROM field.
	PSM_FRCE_OFF_ROM_Msk = 0x20
	// Bit ROM.
	PSM_FRCE_OFF_ROM = 0x20
	// Position of BUSFABRIC field.
	PSM_FRCE_OFF_BUSFABRIC_Pos = 0x4
	// Bit mask of BUSFABRIC field.
	PSM_FRCE_OFF_BUSFABRIC_Msk = 0x10
	// Bit BUSFABRIC.
	PSM_FRCE_OFF_BUSFABRIC = 0x10
	// Position of RESETS field.
	PSM_FRCE_OFF_RESETS_Pos = 0x3
	// Bit mask of RESETS field.
	PSM_FRCE_OFF_RESETS_Msk = 0x8
	// Bit RESETS.
	PSM_FRCE_OFF_RESETS = 0x8
	// Position of CLOCKS field.
	PSM_FRCE_OFF_CLOCKS_Pos = 0x2
	// Bit mask of CLOCKS field.
	PSM_FRCE_OFF_CLOCKS_Msk = 0x4
	// Bit CLOCKS.
	PSM_FRCE_OFF_CLOCKS = 0x4
	// Position of XOSC field.
	PSM_FRCE_OFF_XOSC_Pos = 0x1
	// Bit mask of XOSC field.
	PSM_FRCE_OFF_XOSC_Msk = 0x2
	// Bit XOSC.
	PSM_FRCE_OFF_XOSC = 0x2
	// Position of ROSC field.
	PSM_FRCE_OFF_ROSC_Pos = 0x0
	// Bit mask of ROSC field.
	PSM_FRCE_OFF_ROSC_Msk = 0x1
	// Bit ROSC.
	PSM_FRCE_OFF_ROSC = 0x1

	// WDSEL: Set to 1 if this peripheral should be reset when the watchdog fires.
	// Position of PROC1 field.
	PSM_WDSEL_PROC1_Pos = 0x10
	// Bit mask of PROC1 field.
	PSM_WDSEL_PROC1_Msk = 0x10000
	// Bit PROC1.
	PSM_WDSEL_PROC1 = 0x10000
	// Position of PROC0 field.
	PSM_WDSEL_PROC0_Pos = 0xf
	// Bit mask of PROC0 field.
	PSM_WDSEL_PROC0_Msk = 0x8000
	// Bit PROC0.
	PSM_WDSEL_PROC0 = 0x8000
	// Position of SIO field.
	PSM_WDSEL_SIO_Pos = 0xe
	// Bit mask of SIO field.
	PSM_WDSEL_SIO_Msk = 0x4000
	// Bit SIO.
	PSM_WDSEL_SIO = 0x4000
	// Position of VREG_AND_CHIP_RESET field.
	PSM_WDSEL_VREG_AND_CHIP_RESET_Pos = 0xd
	// Bit mask of VREG_AND_CHIP_RESET field.
	PSM_WDSEL_VREG_AND_CHIP_RESET_Msk = 0x2000
	// Bit VREG_AND_CHIP_RESET.
	PSM_WDSEL_VREG_AND_CHIP_RESET = 0x2000
	// Position of XIP field.
	PSM_WDSEL_XIP_Pos = 0xc
	// Bit mask of XIP field.
	PSM_WDSEL_XIP_Msk = 0x1000
	// Bit XIP.
	PSM_WDSEL_XIP = 0x1000
	// Position of SRAM5 field.
	PSM_WDSEL_SRAM5_Pos = 0xb
	// Bit mask of SRAM5 field.
	PSM_WDSEL_SRAM5_Msk = 0x800
	// Bit SRAM5.
	PSM_WDSEL_SRAM5 = 0x800
	// Position of SRAM4 field.
	PSM_WDSEL_SRAM4_Pos = 0xa
	// Bit mask of SRAM4 field.
	PSM_WDSEL_SRAM4_Msk = 0x400
	// Bit SRAM4.
	PSM_WDSEL_SRAM4 = 0x400
	// Position of SRAM3 field.
	PSM_WDSEL_SRAM3_Pos = 0x9
	// Bit mask of SRAM3 field.
	PSM_WDSEL_SRAM3_Msk = 0x200
	// Bit SRAM3.
	PSM_WDSEL_SRAM3 = 0x200
	// Position of SRAM2 field.
	PSM_WDSEL_SRAM2_Pos = 0x8
	// Bit mask of SRAM2 field.
	PSM_WDSEL_SRAM2_Msk = 0x100
	// Bit SRAM2.
	PSM_WDSEL_SRAM2 = 0x100
	// Position of SRAM1 field.
	PSM_WDSEL_SRAM1_Pos = 0x7
	// Bit mask of SRAM1 field.
	PSM_WDSEL_SRAM1_Msk = 0x80
	// Bit SRAM1.
	PSM_WDSEL_SRAM1 = 0x80
	// Position of SRAM0 field.
	PSM_WDSEL_SRAM0_Pos = 0x6
	// Bit mask of SRAM0 field.
	PSM_WDSEL_SRAM0_Msk = 0x40
	// Bit SRAM0.
	PSM_WDSEL_SRAM0 = 0x40
	// Position of ROM field.
	PSM_WDSEL_ROM_Pos = 0x5
	// Bit mask of ROM field.
	PSM_WDSEL_ROM_Msk = 0x20
	// Bit ROM.
	PSM_WDSEL_ROM = 0x20
	// Position of BUSFABRIC field.
	PSM_WDSEL_BUSFABRIC_Pos = 0x4
	// Bit mask of BUSFABRIC field.
	PSM_WDSEL_BUSFABRIC_Msk = 0x10
	// Bit BUSFABRIC.
	PSM_WDSEL_BUSFABRIC = 0x10
	// Position of RESETS field.
	PSM_WDSEL_RESETS_Pos = 0x3
	// Bit mask of RESETS field.
	PSM_WDSEL_RESETS_Msk = 0x8
	// Bit RESETS.
	PSM_WDSEL_RESETS = 0x8
	// Position of CLOCKS field.
	PSM_WDSEL_CLOCKS_Pos = 0x2
	// Bit mask of CLOCKS field.
	PSM_WDSEL_CLOCKS_Msk = 0x4
	// Bit CLOCKS.
	PSM_WDSEL_CLOCKS = 0x4
	// Position of XOSC field.
	PSM_WDSEL_XOSC_Pos = 0x1
	// Bit mask of XOSC field.
	PSM_WDSEL_XOSC_Msk = 0x2
	// Bit XOSC.
	PSM_WDSEL_XOSC = 0x2
	// Position of ROSC field.
	PSM_WDSEL_ROSC_Pos = 0x0
	// Bit mask of ROSC field.
	PSM_WDSEL_ROSC_Msk = 0x1
	// Bit ROSC.
	PSM_WDSEL_ROSC = 0x1

	// DONE: Indicates the peripheral's registers are ready to access.
	// Position of PROC1 field.
	PSM_DONE_PROC1_Pos = 0x10
	// Bit mask of PROC1 field.
	PSM_DONE_PROC1_Msk = 0x10000
	// Bit PROC1.
	PSM_DONE_PROC1 = 0x10000
	// Position of PROC0 field.
	PSM_DONE_PROC0_Pos = 0xf
	// Bit mask of PROC0 field.
	PSM_DONE_PROC0_Msk = 0x8000
	// Bit PROC0.
	PSM_DONE_PROC0 = 0x8000
	// Position of SIO field.
	PSM_DONE_SIO_Pos = 0xe
	// Bit mask of SIO field.
	PSM_DONE_SIO_Msk = 0x4000
	// Bit SIO.
	PSM_DONE_SIO = 0x4000
	// Position of VREG_AND_CHIP_RESET field.
	PSM_DONE_VREG_AND_CHIP_RESET_Pos = 0xd
	// Bit mask of VREG_AND_CHIP_RESET field.
	PSM_DONE_VREG_AND_CHIP_RESET_Msk = 0x2000
	// Bit VREG_AND_CHIP_RESET.
	PSM_DONE_VREG_AND_CHIP_RESET = 0x2000
	// Position of XIP field.
	PSM_DONE_XIP_Pos = 0xc
	// Bit mask of XIP field.
	PSM_DONE_XIP_Msk = 0x1000
	// Bit XIP.
	PSM_DONE_XIP = 0x1000
	// Position of SRAM5 field.
	PSM_DONE_SRAM5_Pos = 0xb
	// Bit mask of SRAM5 field.
	PSM_DONE_SRAM5_Msk = 0x800
	// Bit SRAM5.
	PSM_DONE_SRAM5 = 0x800
	// Position of SRAM4 field.
	PSM_DONE_SRAM4_Pos = 0xa
	// Bit mask of SRAM4 field.
	PSM_DONE_SRAM4_Msk = 0x400
	// Bit SRAM4.
	PSM_DONE_SRAM4 = 0x400
	// Position of SRAM3 field.
	PSM_DONE_SRAM3_Pos = 0x9
	// Bit mask of SRAM3 field.
	PSM_DONE_SRAM3_Msk = 0x200
	// Bit SRAM3.
	PSM_DONE_SRAM3 = 0x200
	// Position of SRAM2 field.
	PSM_DONE_SRAM2_Pos = 0x8
	// Bit mask of SRAM2 field.
	PSM_DONE_SRAM2_Msk = 0x100
	// Bit SRAM2.
	PSM_DONE_SRAM2 = 0x100
	// Position of SRAM1 field.
	PSM_DONE_SRAM1_Pos = 0x7
	// Bit mask of SRAM1 field.
	PSM_DONE_SRAM1_Msk = 0x80
	// Bit SRAM1.
	PSM_DONE_SRAM1 = 0x80
	// Position of SRAM0 field.
	PSM_DONE_SRAM0_Pos = 0x6
	// Bit mask of SRAM0 field.
	PSM_DONE_SRAM0_Msk = 0x40
	// Bit SRAM0.
	PSM_DONE_SRAM0 = 0x40
	// Position of ROM field.
	PSM_DONE_ROM_Pos = 0x5
	// Bit mask of ROM field.
	PSM_DONE_ROM_Msk = 0x20
	// Bit ROM.
	PSM_DONE_ROM = 0x20
	// Position of BUSFABRIC field.
	PSM_DONE_BUSFABRIC_Pos = 0x4
	// Bit mask of BUSFABRIC field.
	PSM_DONE_BUSFABRIC_Msk = 0x10
	// Bit BUSFABRIC.
	PSM_DONE_BUSFABRIC = 0x10
	// Position of RESETS field.
	PSM_DONE_RESETS_Pos = 0x3
	// Bit mask of RESETS field.
	PSM_DONE_RESETS_Msk = 0x8
	// Bit RESETS.
	PSM_DONE_RESETS = 0x8
	// Position of CLOCKS field.
	PSM_DONE_CLOCKS_Pos = 0x2
	// Bit mask of CLOCKS field.
	PSM_DONE_CLOCKS_Msk = 0x4
	// Bit CLOCKS.
	PSM_DONE_CLOCKS = 0x4
	// Position of XOSC field.
	PSM_DONE_XOSC_Pos = 0x1
	// Bit mask of XOSC field.
	PSM_DONE_XOSC_Msk = 0x2
	// Bit XOSC.
	PSM_DONE_XOSC = 0x2
	// Position of ROSC field.
	PSM_DONE_ROSC_Pos = 0x0
	// Bit mask of ROSC field.
	PSM_DONE_ROSC_Msk = 0x1
	// Bit ROSC.
	PSM_DONE_ROSC = 0x1
)

// Constants for IO_BANK0
const (
	// GPIO0_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO0_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO0_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO0_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO0_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO0_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO0_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO0_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO0_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO0_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO0_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO0_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO0_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO0_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO0_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO0_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO0_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO0_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO0_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO0_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO0_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO0_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO0_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO0_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO0_STATUS_OUTFROMPERI = 0x100

	// GPIO0_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO0_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO0_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO0_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO0_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO0_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO0_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO0_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO0_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO0_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO0_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO0_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO0_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO0_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO0_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO0_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO0_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO0_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO0_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO0_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO0_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO0_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO0_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO0_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO0_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO0_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO0_CTRL_FUNCSEL_Msk                        = 0x1f
	IO_BANK0_GPIO0_CTRL_FUNCSEL_JTAG_TCK                   = 0x0
	IO_BANK0_GPIO0_CTRL_FUNCSEL_SPI0_RX                    = 0x1
	IO_BANK0_GPIO0_CTRL_FUNCSEL_UART0_TX                   = 0x2
	IO_BANK0_GPIO0_CTRL_FUNCSEL_I2C0_SDA                   = 0x3
	IO_BANK0_GPIO0_CTRL_FUNCSEL_PWM_A_0                    = 0x4
	IO_BANK0_GPIO0_CTRL_FUNCSEL_SIO_0                      = 0x5
	IO_BANK0_GPIO0_CTRL_FUNCSEL_PIO0_0                     = 0x6
	IO_BANK0_GPIO0_CTRL_FUNCSEL_PIO1_0                     = 0x7
	IO_BANK0_GPIO0_CTRL_FUNCSEL_USB_MUXING_OVERCURR_DETECT = 0x9
	IO_BANK0_GPIO0_CTRL_FUNCSEL_NULL                       = 0x1f

	// GPIO1_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO1_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO1_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO1_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO1_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO1_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO1_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO1_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO1_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO1_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO1_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO1_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO1_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO1_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO1_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO1_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO1_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO1_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO1_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO1_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO1_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO1_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO1_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO1_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO1_STATUS_OUTFROMPERI = 0x100

	// GPIO1_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO1_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO1_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO1_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO1_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO1_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO1_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO1_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO1_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO1_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO1_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO1_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO1_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO1_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO1_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO1_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO1_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO1_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO1_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO1_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO1_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO1_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO1_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO1_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO1_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO1_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO1_CTRL_FUNCSEL_Msk                    = 0x1f
	IO_BANK0_GPIO1_CTRL_FUNCSEL_JTAG_TMS               = 0x0
	IO_BANK0_GPIO1_CTRL_FUNCSEL_SPI0_SS_N              = 0x1
	IO_BANK0_GPIO1_CTRL_FUNCSEL_UART0_RX               = 0x2
	IO_BANK0_GPIO1_CTRL_FUNCSEL_I2C0_SCL               = 0x3
	IO_BANK0_GPIO1_CTRL_FUNCSEL_PWM_B_0                = 0x4
	IO_BANK0_GPIO1_CTRL_FUNCSEL_SIO_1                  = 0x5
	IO_BANK0_GPIO1_CTRL_FUNCSEL_PIO0_1                 = 0x6
	IO_BANK0_GPIO1_CTRL_FUNCSEL_PIO1_1                 = 0x7
	IO_BANK0_GPIO1_CTRL_FUNCSEL_USB_MUXING_VBUS_DETECT = 0x9
	IO_BANK0_GPIO1_CTRL_FUNCSEL_NULL                   = 0x1f

	// GPIO2_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO2_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO2_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO2_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO2_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO2_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO2_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO2_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO2_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO2_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO2_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO2_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO2_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO2_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO2_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO2_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO2_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO2_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO2_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO2_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO2_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO2_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO2_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO2_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO2_STATUS_OUTFROMPERI = 0x100

	// GPIO2_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO2_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO2_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO2_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO2_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO2_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO2_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO2_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO2_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO2_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO2_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO2_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO2_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO2_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO2_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO2_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO2_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO2_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO2_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO2_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO2_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO2_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO2_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO2_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO2_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO2_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO2_CTRL_FUNCSEL_Msk                = 0x1f
	IO_BANK0_GPIO2_CTRL_FUNCSEL_JTAG_TDI           = 0x0
	IO_BANK0_GPIO2_CTRL_FUNCSEL_SPI0_SCLK          = 0x1
	IO_BANK0_GPIO2_CTRL_FUNCSEL_UART0_CTS          = 0x2
	IO_BANK0_GPIO2_CTRL_FUNCSEL_I2C1_SDA           = 0x3
	IO_BANK0_GPIO2_CTRL_FUNCSEL_PWM_A_1            = 0x4
	IO_BANK0_GPIO2_CTRL_FUNCSEL_SIO_2              = 0x5
	IO_BANK0_GPIO2_CTRL_FUNCSEL_PIO0_2             = 0x6
	IO_BANK0_GPIO2_CTRL_FUNCSEL_PIO1_2             = 0x7
	IO_BANK0_GPIO2_CTRL_FUNCSEL_USB_MUXING_VBUS_EN = 0x9
	IO_BANK0_GPIO2_CTRL_FUNCSEL_NULL               = 0x1f

	// GPIO3_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO3_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO3_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO3_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO3_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO3_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO3_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO3_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO3_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO3_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO3_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO3_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO3_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO3_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO3_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO3_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO3_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO3_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO3_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO3_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO3_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO3_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO3_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO3_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO3_STATUS_OUTFROMPERI = 0x100

	// GPIO3_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO3_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO3_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO3_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO3_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO3_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO3_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO3_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO3_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO3_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO3_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO3_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO3_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO3_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO3_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO3_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO3_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO3_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO3_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO3_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO3_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO3_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO3_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO3_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO3_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO3_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO3_CTRL_FUNCSEL_Msk                        = 0x1f
	IO_BANK0_GPIO3_CTRL_FUNCSEL_JTAG_TDO                   = 0x0
	IO_BANK0_GPIO3_CTRL_FUNCSEL_SPI0_TX                    = 0x1
	IO_BANK0_GPIO3_CTRL_FUNCSEL_UART0_RTS                  = 0x2
	IO_BANK0_GPIO3_CTRL_FUNCSEL_I2C1_SCL                   = 0x3
	IO_BANK0_GPIO3_CTRL_FUNCSEL_PWM_B_1                    = 0x4
	IO_BANK0_GPIO3_CTRL_FUNCSEL_SIO_3                      = 0x5
	IO_BANK0_GPIO3_CTRL_FUNCSEL_PIO0_3                     = 0x6
	IO_BANK0_GPIO3_CTRL_FUNCSEL_PIO1_3                     = 0x7
	IO_BANK0_GPIO3_CTRL_FUNCSEL_USB_MUXING_OVERCURR_DETECT = 0x9
	IO_BANK0_GPIO3_CTRL_FUNCSEL_NULL                       = 0x1f

	// GPIO4_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO4_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO4_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO4_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO4_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO4_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO4_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO4_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO4_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO4_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO4_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO4_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO4_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO4_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO4_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO4_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO4_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO4_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO4_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO4_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO4_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO4_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO4_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO4_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO4_STATUS_OUTFROMPERI = 0x100

	// GPIO4_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO4_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO4_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO4_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO4_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO4_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO4_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO4_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO4_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO4_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO4_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO4_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO4_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO4_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO4_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO4_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO4_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO4_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO4_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO4_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO4_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO4_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO4_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO4_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO4_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO4_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO4_CTRL_FUNCSEL_Msk                    = 0x1f
	IO_BANK0_GPIO4_CTRL_FUNCSEL_SPI0_RX                = 0x1
	IO_BANK0_GPIO4_CTRL_FUNCSEL_UART1_TX               = 0x2
	IO_BANK0_GPIO4_CTRL_FUNCSEL_I2C0_SDA               = 0x3
	IO_BANK0_GPIO4_CTRL_FUNCSEL_PWM_A_2                = 0x4
	IO_BANK0_GPIO4_CTRL_FUNCSEL_SIO_4                  = 0x5
	IO_BANK0_GPIO4_CTRL_FUNCSEL_PIO0_4                 = 0x6
	IO_BANK0_GPIO4_CTRL_FUNCSEL_PIO1_4                 = 0x7
	IO_BANK0_GPIO4_CTRL_FUNCSEL_USB_MUXING_VBUS_DETECT = 0x9
	IO_BANK0_GPIO4_CTRL_FUNCSEL_NULL                   = 0x1f

	// GPIO5_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO5_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO5_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO5_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO5_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO5_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO5_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO5_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO5_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO5_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO5_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO5_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO5_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO5_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO5_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO5_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO5_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO5_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO5_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO5_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO5_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO5_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO5_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO5_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO5_STATUS_OUTFROMPERI = 0x100

	// GPIO5_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO5_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO5_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO5_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO5_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO5_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO5_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO5_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO5_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO5_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO5_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO5_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO5_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO5_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO5_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO5_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO5_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO5_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO5_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO5_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO5_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO5_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO5_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO5_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO5_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO5_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO5_CTRL_FUNCSEL_Msk                = 0x1f
	IO_BANK0_GPIO5_CTRL_FUNCSEL_SPI0_SS_N          = 0x1
	IO_BANK0_GPIO5_CTRL_FUNCSEL_UART1_RX           = 0x2
	IO_BANK0_GPIO5_CTRL_FUNCSEL_I2C0_SCL           = 0x3
	IO_BANK0_GPIO5_CTRL_FUNCSEL_PWM_B_2            = 0x4
	IO_BANK0_GPIO5_CTRL_FUNCSEL_SIO_5              = 0x5
	IO_BANK0_GPIO5_CTRL_FUNCSEL_PIO0_5             = 0x6
	IO_BANK0_GPIO5_CTRL_FUNCSEL_PIO1_5             = 0x7
	IO_BANK0_GPIO5_CTRL_FUNCSEL_USB_MUXING_VBUS_EN = 0x9
	IO_BANK0_GPIO5_CTRL_FUNCSEL_NULL               = 0x1f

	// GPIO6_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO6_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO6_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO6_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO6_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO6_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO6_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO6_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO6_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO6_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO6_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO6_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO6_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO6_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO6_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO6_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO6_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO6_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO6_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO6_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO6_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO6_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO6_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO6_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO6_STATUS_OUTFROMPERI = 0x100

	// GPIO6_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO6_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO6_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO6_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO6_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO6_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO6_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO6_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO6_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO6_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO6_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO6_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO6_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO6_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO6_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO6_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO6_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO6_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO6_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO6_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO6_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO6_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO6_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO6_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO6_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO6_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO6_CTRL_FUNCSEL_Msk                        = 0x1f
	IO_BANK0_GPIO6_CTRL_FUNCSEL_SPI0_SCLK                  = 0x1
	IO_BANK0_GPIO6_CTRL_FUNCSEL_UART1_CTS                  = 0x2
	IO_BANK0_GPIO6_CTRL_FUNCSEL_I2C1_SDA                   = 0x3
	IO_BANK0_GPIO6_CTRL_FUNCSEL_PWM_A_3                    = 0x4
	IO_BANK0_GPIO6_CTRL_FUNCSEL_SIO_6                      = 0x5
	IO_BANK0_GPIO6_CTRL_FUNCSEL_PIO0_6                     = 0x6
	IO_BANK0_GPIO6_CTRL_FUNCSEL_PIO1_6                     = 0x7
	IO_BANK0_GPIO6_CTRL_FUNCSEL_USB_MUXING_EXTPHY_SOFTCON  = 0x8
	IO_BANK0_GPIO6_CTRL_FUNCSEL_USB_MUXING_OVERCURR_DETECT = 0x9
	IO_BANK0_GPIO6_CTRL_FUNCSEL_NULL                       = 0x1f

	// GPIO7_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO7_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO7_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO7_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO7_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO7_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO7_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO7_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO7_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO7_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO7_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO7_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO7_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO7_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO7_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO7_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO7_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO7_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO7_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO7_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO7_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO7_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO7_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO7_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO7_STATUS_OUTFROMPERI = 0x100

	// GPIO7_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO7_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO7_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO7_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO7_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO7_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO7_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO7_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO7_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO7_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO7_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO7_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO7_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO7_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO7_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO7_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO7_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO7_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO7_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO7_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO7_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO7_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO7_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO7_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO7_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO7_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO7_CTRL_FUNCSEL_Msk                    = 0x1f
	IO_BANK0_GPIO7_CTRL_FUNCSEL_SPI0_TX                = 0x1
	IO_BANK0_GPIO7_CTRL_FUNCSEL_UART1_RTS              = 0x2
	IO_BANK0_GPIO7_CTRL_FUNCSEL_I2C1_SCL               = 0x3
	IO_BANK0_GPIO7_CTRL_FUNCSEL_PWM_B_3                = 0x4
	IO_BANK0_GPIO7_CTRL_FUNCSEL_SIO_7                  = 0x5
	IO_BANK0_GPIO7_CTRL_FUNCSEL_PIO0_7                 = 0x6
	IO_BANK0_GPIO7_CTRL_FUNCSEL_PIO1_7                 = 0x7
	IO_BANK0_GPIO7_CTRL_FUNCSEL_USB_MUXING_EXTPHY_OE_N = 0x8
	IO_BANK0_GPIO7_CTRL_FUNCSEL_USB_MUXING_VBUS_DETECT = 0x9
	IO_BANK0_GPIO7_CTRL_FUNCSEL_NULL                   = 0x1f

	// GPIO8_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO8_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO8_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO8_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO8_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO8_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO8_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO8_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO8_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO8_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO8_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO8_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO8_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO8_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO8_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO8_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO8_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO8_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO8_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO8_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO8_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO8_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO8_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO8_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO8_STATUS_OUTFROMPERI = 0x100

	// GPIO8_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO8_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO8_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO8_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO8_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO8_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO8_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO8_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO8_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO8_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO8_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO8_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO8_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO8_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO8_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO8_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO8_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO8_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO8_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO8_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO8_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO8_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO8_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO8_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO8_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO8_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO8_CTRL_FUNCSEL_Msk                   = 0x1f
	IO_BANK0_GPIO8_CTRL_FUNCSEL_SPI1_RX               = 0x1
	IO_BANK0_GPIO8_CTRL_FUNCSEL_UART1_TX              = 0x2
	IO_BANK0_GPIO8_CTRL_FUNCSEL_I2C0_SDA              = 0x3
	IO_BANK0_GPIO8_CTRL_FUNCSEL_PWM_A_4               = 0x4
	IO_BANK0_GPIO8_CTRL_FUNCSEL_SIO_8                 = 0x5
	IO_BANK0_GPIO8_CTRL_FUNCSEL_PIO0_8                = 0x6
	IO_BANK0_GPIO8_CTRL_FUNCSEL_PIO1_8                = 0x7
	IO_BANK0_GPIO8_CTRL_FUNCSEL_USB_MUXING_EXTPHY_RCV = 0x8
	IO_BANK0_GPIO8_CTRL_FUNCSEL_USB_MUXING_VBUS_EN    = 0x9
	IO_BANK0_GPIO8_CTRL_FUNCSEL_NULL                  = 0x1f

	// GPIO9_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO9_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO9_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO9_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO9_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO9_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO9_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO9_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO9_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO9_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO9_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO9_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO9_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO9_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO9_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO9_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO9_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO9_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO9_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO9_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO9_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO9_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO9_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO9_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO9_STATUS_OUTFROMPERI = 0x100

	// GPIO9_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO9_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO9_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO9_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO9_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO9_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO9_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO9_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO9_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO9_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO9_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO9_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO9_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO9_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO9_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO9_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO9_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO9_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO9_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO9_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO9_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO9_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO9_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO9_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO9_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO9_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO9_CTRL_FUNCSEL_Msk                        = 0x1f
	IO_BANK0_GPIO9_CTRL_FUNCSEL_SPI1_SS_N                  = 0x1
	IO_BANK0_GPIO9_CTRL_FUNCSEL_UART1_RX                   = 0x2
	IO_BANK0_GPIO9_CTRL_FUNCSEL_I2C0_SCL                   = 0x3
	IO_BANK0_GPIO9_CTRL_FUNCSEL_PWM_B_4                    = 0x4
	IO_BANK0_GPIO9_CTRL_FUNCSEL_SIO_9                      = 0x5
	IO_BANK0_GPIO9_CTRL_FUNCSEL_PIO0_9                     = 0x6
	IO_BANK0_GPIO9_CTRL_FUNCSEL_PIO1_9                     = 0x7
	IO_BANK0_GPIO9_CTRL_FUNCSEL_USB_MUXING_EXTPHY_VP       = 0x8
	IO_BANK0_GPIO9_CTRL_FUNCSEL_USB_MUXING_OVERCURR_DETECT = 0x9
	IO_BANK0_GPIO9_CTRL_FUNCSEL_NULL                       = 0x1f

	// GPIO10_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO10_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO10_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO10_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO10_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO10_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO10_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO10_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO10_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO10_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO10_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO10_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO10_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO10_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO10_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO10_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO10_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO10_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO10_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO10_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO10_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO10_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO10_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO10_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO10_STATUS_OUTFROMPERI = 0x100

	// GPIO10_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO10_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO10_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO10_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO10_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO10_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO10_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO10_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO10_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO10_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO10_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO10_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO10_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO10_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO10_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO10_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO10_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO10_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO10_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO10_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO10_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO10_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO10_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO10_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO10_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO10_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO10_CTRL_FUNCSEL_Msk                    = 0x1f
	IO_BANK0_GPIO10_CTRL_FUNCSEL_SPI1_SCLK              = 0x1
	IO_BANK0_GPIO10_CTRL_FUNCSEL_UART1_CTS              = 0x2
	IO_BANK0_GPIO10_CTRL_FUNCSEL_I2C1_SDA               = 0x3
	IO_BANK0_GPIO10_CTRL_FUNCSEL_PWM_A_5                = 0x4
	IO_BANK0_GPIO10_CTRL_FUNCSEL_SIO_10                 = 0x5
	IO_BANK0_GPIO10_CTRL_FUNCSEL_PIO0_10                = 0x6
	IO_BANK0_GPIO10_CTRL_FUNCSEL_PIO1_10                = 0x7
	IO_BANK0_GPIO10_CTRL_FUNCSEL_USB_MUXING_EXTPHY_VM   = 0x8
	IO_BANK0_GPIO10_CTRL_FUNCSEL_USB_MUXING_VBUS_DETECT = 0x9
	IO_BANK0_GPIO10_CTRL_FUNCSEL_NULL                   = 0x1f

	// GPIO11_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO11_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO11_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO11_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO11_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO11_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO11_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO11_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO11_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO11_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO11_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO11_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO11_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO11_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO11_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO11_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO11_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO11_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO11_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO11_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO11_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO11_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO11_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO11_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO11_STATUS_OUTFROMPERI = 0x100

	// GPIO11_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO11_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO11_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO11_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO11_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO11_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO11_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO11_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO11_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO11_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO11_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO11_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO11_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO11_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO11_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO11_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO11_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO11_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO11_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO11_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO11_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO11_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO11_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO11_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO11_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO11_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO11_CTRL_FUNCSEL_Msk                      = 0x1f
	IO_BANK0_GPIO11_CTRL_FUNCSEL_SPI1_TX                  = 0x1
	IO_BANK0_GPIO11_CTRL_FUNCSEL_UART1_RTS                = 0x2
	IO_BANK0_GPIO11_CTRL_FUNCSEL_I2C1_SCL                 = 0x3
	IO_BANK0_GPIO11_CTRL_FUNCSEL_PWM_B_5                  = 0x4
	IO_BANK0_GPIO11_CTRL_FUNCSEL_SIO_11                   = 0x5
	IO_BANK0_GPIO11_CTRL_FUNCSEL_PIO0_11                  = 0x6
	IO_BANK0_GPIO11_CTRL_FUNCSEL_PIO1_11                  = 0x7
	IO_BANK0_GPIO11_CTRL_FUNCSEL_USB_MUXING_EXTPHY_SUSPND = 0x8
	IO_BANK0_GPIO11_CTRL_FUNCSEL_USB_MUXING_VBUS_EN       = 0x9
	IO_BANK0_GPIO11_CTRL_FUNCSEL_NULL                     = 0x1f

	// GPIO12_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO12_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO12_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO12_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO12_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO12_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO12_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO12_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO12_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO12_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO12_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO12_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO12_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO12_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO12_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO12_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO12_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO12_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO12_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO12_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO12_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO12_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO12_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO12_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO12_STATUS_OUTFROMPERI = 0x100

	// GPIO12_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO12_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO12_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO12_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO12_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO12_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO12_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO12_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO12_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO12_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO12_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO12_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO12_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO12_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO12_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO12_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO12_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO12_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO12_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO12_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO12_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO12_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO12_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO12_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO12_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO12_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO12_CTRL_FUNCSEL_Msk                        = 0x1f
	IO_BANK0_GPIO12_CTRL_FUNCSEL_SPI1_RX                    = 0x1
	IO_BANK0_GPIO12_CTRL_FUNCSEL_UART0_TX                   = 0x2
	IO_BANK0_GPIO12_CTRL_FUNCSEL_I2C0_SDA                   = 0x3
	IO_BANK0_GPIO12_CTRL_FUNCSEL_PWM_A_6                    = 0x4
	IO_BANK0_GPIO12_CTRL_FUNCSEL_SIO_12                     = 0x5
	IO_BANK0_GPIO12_CTRL_FUNCSEL_PIO0_12                    = 0x6
	IO_BANK0_GPIO12_CTRL_FUNCSEL_PIO1_12                    = 0x7
	IO_BANK0_GPIO12_CTRL_FUNCSEL_USB_MUXING_EXTPHY_SPEED    = 0x8
	IO_BANK0_GPIO12_CTRL_FUNCSEL_USB_MUXING_OVERCURR_DETECT = 0x9
	IO_BANK0_GPIO12_CTRL_FUNCSEL_NULL                       = 0x1f

	// GPIO13_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO13_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO13_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO13_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO13_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO13_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO13_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO13_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO13_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO13_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO13_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO13_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO13_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO13_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO13_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO13_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO13_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO13_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO13_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO13_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO13_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO13_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO13_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO13_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO13_STATUS_OUTFROMPERI = 0x100

	// GPIO13_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO13_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO13_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO13_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO13_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO13_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO13_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO13_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO13_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO13_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO13_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO13_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO13_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO13_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO13_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO13_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO13_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO13_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO13_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO13_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO13_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO13_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO13_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO13_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO13_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO13_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO13_CTRL_FUNCSEL_Msk                    = 0x1f
	IO_BANK0_GPIO13_CTRL_FUNCSEL_SPI1_SS_N              = 0x1
	IO_BANK0_GPIO13_CTRL_FUNCSEL_UART0_RX               = 0x2
	IO_BANK0_GPIO13_CTRL_FUNCSEL_I2C0_SCL               = 0x3
	IO_BANK0_GPIO13_CTRL_FUNCSEL_PWM_B_6                = 0x4
	IO_BANK0_GPIO13_CTRL_FUNCSEL_SIO_13                 = 0x5
	IO_BANK0_GPIO13_CTRL_FUNCSEL_PIO0_13                = 0x6
	IO_BANK0_GPIO13_CTRL_FUNCSEL_PIO1_13                = 0x7
	IO_BANK0_GPIO13_CTRL_FUNCSEL_USB_MUXING_EXTPHY_VPO  = 0x8
	IO_BANK0_GPIO13_CTRL_FUNCSEL_USB_MUXING_VBUS_DETECT = 0x9
	IO_BANK0_GPIO13_CTRL_FUNCSEL_NULL                   = 0x1f

	// GPIO14_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO14_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO14_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO14_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO14_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO14_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO14_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO14_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO14_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO14_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO14_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO14_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO14_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO14_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO14_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO14_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO14_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO14_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO14_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO14_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO14_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO14_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO14_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO14_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO14_STATUS_OUTFROMPERI = 0x100

	// GPIO14_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO14_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO14_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO14_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO14_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO14_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO14_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO14_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO14_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO14_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO14_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO14_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO14_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO14_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO14_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO14_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO14_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO14_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO14_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO14_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO14_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO14_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO14_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO14_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO14_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO14_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO14_CTRL_FUNCSEL_Msk                   = 0x1f
	IO_BANK0_GPIO14_CTRL_FUNCSEL_SPI1_SCLK             = 0x1
	IO_BANK0_GPIO14_CTRL_FUNCSEL_UART0_CTS             = 0x2
	IO_BANK0_GPIO14_CTRL_FUNCSEL_I2C1_SDA              = 0x3
	IO_BANK0_GPIO14_CTRL_FUNCSEL_PWM_A_7               = 0x4
	IO_BANK0_GPIO14_CTRL_FUNCSEL_SIO_14                = 0x5
	IO_BANK0_GPIO14_CTRL_FUNCSEL_PIO0_14               = 0x6
	IO_BANK0_GPIO14_CTRL_FUNCSEL_PIO1_14               = 0x7
	IO_BANK0_GPIO14_CTRL_FUNCSEL_USB_MUXING_EXTPHY_VMO = 0x8
	IO_BANK0_GPIO14_CTRL_FUNCSEL_USB_MUXING_VBUS_EN    = 0x9
	IO_BANK0_GPIO14_CTRL_FUNCSEL_NULL                  = 0x1f

	// GPIO15_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO15_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO15_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO15_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO15_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO15_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO15_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO15_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO15_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO15_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO15_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO15_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO15_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO15_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO15_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO15_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO15_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO15_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO15_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO15_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO15_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO15_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO15_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO15_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO15_STATUS_OUTFROMPERI = 0x100

	// GPIO15_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO15_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO15_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO15_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO15_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO15_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO15_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO15_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO15_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO15_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO15_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO15_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO15_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO15_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO15_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO15_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO15_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO15_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO15_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO15_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO15_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO15_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO15_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO15_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO15_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO15_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO15_CTRL_FUNCSEL_Msk                        = 0x1f
	IO_BANK0_GPIO15_CTRL_FUNCSEL_SPI1_TX                    = 0x1
	IO_BANK0_GPIO15_CTRL_FUNCSEL_UART0_RTS                  = 0x2
	IO_BANK0_GPIO15_CTRL_FUNCSEL_I2C1_SCL                   = 0x3
	IO_BANK0_GPIO15_CTRL_FUNCSEL_PWM_B_7                    = 0x4
	IO_BANK0_GPIO15_CTRL_FUNCSEL_SIO_15                     = 0x5
	IO_BANK0_GPIO15_CTRL_FUNCSEL_PIO0_15                    = 0x6
	IO_BANK0_GPIO15_CTRL_FUNCSEL_PIO1_15                    = 0x7
	IO_BANK0_GPIO15_CTRL_FUNCSEL_USB_MUXING_DIGITAL_DP      = 0x8
	IO_BANK0_GPIO15_CTRL_FUNCSEL_USB_MUXING_OVERCURR_DETECT = 0x9
	IO_BANK0_GPIO15_CTRL_FUNCSEL_NULL                       = 0x1f

	// GPIO16_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO16_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO16_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO16_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO16_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO16_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO16_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO16_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO16_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO16_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO16_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO16_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO16_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO16_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO16_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO16_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO16_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO16_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO16_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO16_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO16_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO16_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO16_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO16_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO16_STATUS_OUTFROMPERI = 0x100

	// GPIO16_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO16_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO16_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO16_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO16_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO16_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO16_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO16_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO16_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO16_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO16_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO16_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO16_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO16_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO16_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO16_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO16_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO16_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO16_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO16_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO16_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO16_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO16_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO16_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO16_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO16_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO16_CTRL_FUNCSEL_Msk                    = 0x1f
	IO_BANK0_GPIO16_CTRL_FUNCSEL_SPI0_RX                = 0x1
	IO_BANK0_GPIO16_CTRL_FUNCSEL_UART0_TX               = 0x2
	IO_BANK0_GPIO16_CTRL_FUNCSEL_I2C0_SDA               = 0x3
	IO_BANK0_GPIO16_CTRL_FUNCSEL_PWM_A_0                = 0x4
	IO_BANK0_GPIO16_CTRL_FUNCSEL_SIO_16                 = 0x5
	IO_BANK0_GPIO16_CTRL_FUNCSEL_PIO0_16                = 0x6
	IO_BANK0_GPIO16_CTRL_FUNCSEL_PIO1_16                = 0x7
	IO_BANK0_GPIO16_CTRL_FUNCSEL_USB_MUXING_DIGITAL_DM  = 0x8
	IO_BANK0_GPIO16_CTRL_FUNCSEL_USB_MUXING_VBUS_DETECT = 0x9
	IO_BANK0_GPIO16_CTRL_FUNCSEL_NULL                   = 0x1f

	// GPIO17_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO17_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO17_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO17_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO17_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO17_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO17_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO17_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO17_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO17_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO17_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO17_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO17_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO17_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO17_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO17_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO17_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO17_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO17_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO17_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO17_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO17_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO17_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO17_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO17_STATUS_OUTFROMPERI = 0x100

	// GPIO17_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO17_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO17_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO17_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO17_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO17_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO17_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO17_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO17_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO17_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO17_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO17_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO17_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO17_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO17_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO17_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO17_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO17_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO17_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO17_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO17_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO17_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO17_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO17_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO17_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO17_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO17_CTRL_FUNCSEL_Msk                = 0x1f
	IO_BANK0_GPIO17_CTRL_FUNCSEL_SPI0_SS_N          = 0x1
	IO_BANK0_GPIO17_CTRL_FUNCSEL_UART0_RX           = 0x2
	IO_BANK0_GPIO17_CTRL_FUNCSEL_I2C0_SCL           = 0x3
	IO_BANK0_GPIO17_CTRL_FUNCSEL_PWM_B_0            = 0x4
	IO_BANK0_GPIO17_CTRL_FUNCSEL_SIO_17             = 0x5
	IO_BANK0_GPIO17_CTRL_FUNCSEL_PIO0_17            = 0x6
	IO_BANK0_GPIO17_CTRL_FUNCSEL_PIO1_17            = 0x7
	IO_BANK0_GPIO17_CTRL_FUNCSEL_USB_MUXING_VBUS_EN = 0x9
	IO_BANK0_GPIO17_CTRL_FUNCSEL_NULL               = 0x1f

	// GPIO18_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO18_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO18_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO18_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO18_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO18_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO18_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO18_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO18_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO18_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO18_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO18_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO18_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO18_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO18_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO18_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO18_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO18_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO18_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO18_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO18_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO18_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO18_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO18_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO18_STATUS_OUTFROMPERI = 0x100

	// GPIO18_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO18_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO18_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO18_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO18_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO18_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO18_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO18_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO18_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO18_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO18_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO18_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO18_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO18_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO18_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO18_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO18_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO18_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO18_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO18_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO18_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO18_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO18_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO18_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO18_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO18_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO18_CTRL_FUNCSEL_Msk                        = 0x1f
	IO_BANK0_GPIO18_CTRL_FUNCSEL_SPI0_SCLK                  = 0x1
	IO_BANK0_GPIO18_CTRL_FUNCSEL_UART0_CTS                  = 0x2
	IO_BANK0_GPIO18_CTRL_FUNCSEL_I2C1_SDA                   = 0x3
	IO_BANK0_GPIO18_CTRL_FUNCSEL_PWM_A_1                    = 0x4
	IO_BANK0_GPIO18_CTRL_FUNCSEL_SIO_18                     = 0x5
	IO_BANK0_GPIO18_CTRL_FUNCSEL_PIO0_18                    = 0x6
	IO_BANK0_GPIO18_CTRL_FUNCSEL_PIO1_18                    = 0x7
	IO_BANK0_GPIO18_CTRL_FUNCSEL_USB_MUXING_OVERCURR_DETECT = 0x9
	IO_BANK0_GPIO18_CTRL_FUNCSEL_NULL                       = 0x1f

	// GPIO19_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO19_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO19_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO19_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO19_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO19_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO19_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO19_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO19_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO19_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO19_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO19_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO19_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO19_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO19_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO19_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO19_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO19_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO19_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO19_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO19_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO19_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO19_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO19_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO19_STATUS_OUTFROMPERI = 0x100

	// GPIO19_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO19_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO19_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO19_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO19_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO19_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO19_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO19_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO19_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO19_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO19_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO19_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO19_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO19_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO19_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO19_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO19_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO19_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO19_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO19_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO19_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO19_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO19_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO19_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO19_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO19_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO19_CTRL_FUNCSEL_Msk                    = 0x1f
	IO_BANK0_GPIO19_CTRL_FUNCSEL_SPI0_TX                = 0x1
	IO_BANK0_GPIO19_CTRL_FUNCSEL_UART0_RTS              = 0x2
	IO_BANK0_GPIO19_CTRL_FUNCSEL_I2C1_SCL               = 0x3
	IO_BANK0_GPIO19_CTRL_FUNCSEL_PWM_B_1                = 0x4
	IO_BANK0_GPIO19_CTRL_FUNCSEL_SIO_19                 = 0x5
	IO_BANK0_GPIO19_CTRL_FUNCSEL_PIO0_19                = 0x6
	IO_BANK0_GPIO19_CTRL_FUNCSEL_PIO1_19                = 0x7
	IO_BANK0_GPIO19_CTRL_FUNCSEL_USB_MUXING_VBUS_DETECT = 0x9
	IO_BANK0_GPIO19_CTRL_FUNCSEL_NULL                   = 0x1f

	// GPIO20_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO20_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO20_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO20_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO20_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO20_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO20_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO20_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO20_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO20_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO20_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO20_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO20_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO20_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO20_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO20_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO20_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO20_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO20_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO20_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO20_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO20_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO20_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO20_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO20_STATUS_OUTFROMPERI = 0x100

	// GPIO20_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO20_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO20_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO20_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO20_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO20_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO20_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO20_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO20_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO20_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO20_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO20_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO20_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO20_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO20_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO20_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO20_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO20_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO20_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO20_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO20_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO20_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO20_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO20_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO20_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO20_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO20_CTRL_FUNCSEL_Msk                = 0x1f
	IO_BANK0_GPIO20_CTRL_FUNCSEL_SPI0_RX            = 0x1
	IO_BANK0_GPIO20_CTRL_FUNCSEL_UART1_TX           = 0x2
	IO_BANK0_GPIO20_CTRL_FUNCSEL_I2C0_SDA           = 0x3
	IO_BANK0_GPIO20_CTRL_FUNCSEL_PWM_A_2            = 0x4
	IO_BANK0_GPIO20_CTRL_FUNCSEL_SIO_20             = 0x5
	IO_BANK0_GPIO20_CTRL_FUNCSEL_PIO0_20            = 0x6
	IO_BANK0_GPIO20_CTRL_FUNCSEL_PIO1_20            = 0x7
	IO_BANK0_GPIO20_CTRL_FUNCSEL_CLOCKS_GPIN_0      = 0x8
	IO_BANK0_GPIO20_CTRL_FUNCSEL_USB_MUXING_VBUS_EN = 0x9
	IO_BANK0_GPIO20_CTRL_FUNCSEL_NULL               = 0x1f

	// GPIO21_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO21_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO21_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO21_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO21_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO21_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO21_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO21_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO21_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO21_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO21_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO21_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO21_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO21_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO21_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO21_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO21_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO21_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO21_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO21_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO21_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO21_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO21_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO21_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO21_STATUS_OUTFROMPERI = 0x100

	// GPIO21_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO21_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO21_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO21_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO21_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO21_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO21_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO21_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO21_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO21_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO21_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO21_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO21_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO21_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO21_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO21_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO21_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO21_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO21_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO21_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO21_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO21_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO21_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO21_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO21_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO21_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO21_CTRL_FUNCSEL_Msk                        = 0x1f
	IO_BANK0_GPIO21_CTRL_FUNCSEL_SPI0_SS_N                  = 0x1
	IO_BANK0_GPIO21_CTRL_FUNCSEL_UART1_RX                   = 0x2
	IO_BANK0_GPIO21_CTRL_FUNCSEL_I2C0_SCL                   = 0x3
	IO_BANK0_GPIO21_CTRL_FUNCSEL_PWM_B_2                    = 0x4
	IO_BANK0_GPIO21_CTRL_FUNCSEL_SIO_21                     = 0x5
	IO_BANK0_GPIO21_CTRL_FUNCSEL_PIO0_21                    = 0x6
	IO_BANK0_GPIO21_CTRL_FUNCSEL_PIO1_21                    = 0x7
	IO_BANK0_GPIO21_CTRL_FUNCSEL_CLOCKS_GPOUT_0             = 0x8
	IO_BANK0_GPIO21_CTRL_FUNCSEL_USB_MUXING_OVERCURR_DETECT = 0x9
	IO_BANK0_GPIO21_CTRL_FUNCSEL_NULL                       = 0x1f

	// GPIO22_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO22_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO22_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO22_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO22_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO22_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO22_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO22_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO22_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO22_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO22_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO22_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO22_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO22_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO22_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO22_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO22_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO22_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO22_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO22_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO22_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO22_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO22_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO22_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO22_STATUS_OUTFROMPERI = 0x100

	// GPIO22_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO22_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO22_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO22_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO22_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO22_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO22_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO22_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO22_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO22_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO22_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO22_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO22_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO22_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO22_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO22_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO22_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO22_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO22_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO22_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO22_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO22_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO22_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO22_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO22_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO22_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO22_CTRL_FUNCSEL_Msk                    = 0x1f
	IO_BANK0_GPIO22_CTRL_FUNCSEL_SPI0_SCLK              = 0x1
	IO_BANK0_GPIO22_CTRL_FUNCSEL_UART1_CTS              = 0x2
	IO_BANK0_GPIO22_CTRL_FUNCSEL_I2C1_SDA               = 0x3
	IO_BANK0_GPIO22_CTRL_FUNCSEL_PWM_A_3                = 0x4
	IO_BANK0_GPIO22_CTRL_FUNCSEL_SIO_22                 = 0x5
	IO_BANK0_GPIO22_CTRL_FUNCSEL_PIO0_22                = 0x6
	IO_BANK0_GPIO22_CTRL_FUNCSEL_PIO1_22                = 0x7
	IO_BANK0_GPIO22_CTRL_FUNCSEL_CLOCKS_GPIN_1          = 0x8
	IO_BANK0_GPIO22_CTRL_FUNCSEL_USB_MUXING_VBUS_DETECT = 0x9
	IO_BANK0_GPIO22_CTRL_FUNCSEL_NULL                   = 0x1f

	// GPIO23_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO23_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO23_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO23_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO23_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO23_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO23_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO23_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO23_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO23_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO23_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO23_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO23_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO23_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO23_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO23_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO23_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO23_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO23_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO23_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO23_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO23_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO23_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO23_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO23_STATUS_OUTFROMPERI = 0x100

	// GPIO23_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO23_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO23_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO23_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO23_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO23_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO23_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO23_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO23_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO23_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO23_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO23_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO23_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO23_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO23_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO23_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO23_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO23_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO23_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO23_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO23_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO23_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO23_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO23_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO23_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO23_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO23_CTRL_FUNCSEL_Msk                = 0x1f
	IO_BANK0_GPIO23_CTRL_FUNCSEL_SPI0_TX            = 0x1
	IO_BANK0_GPIO23_CTRL_FUNCSEL_UART1_RTS          = 0x2
	IO_BANK0_GPIO23_CTRL_FUNCSEL_I2C1_SCL           = 0x3
	IO_BANK0_GPIO23_CTRL_FUNCSEL_PWM_B_3            = 0x4
	IO_BANK0_GPIO23_CTRL_FUNCSEL_SIO_23             = 0x5
	IO_BANK0_GPIO23_CTRL_FUNCSEL_PIO0_23            = 0x6
	IO_BANK0_GPIO23_CTRL_FUNCSEL_PIO1_23            = 0x7
	IO_BANK0_GPIO23_CTRL_FUNCSEL_CLOCKS_GPOUT_1     = 0x8
	IO_BANK0_GPIO23_CTRL_FUNCSEL_USB_MUXING_VBUS_EN = 0x9
	IO_BANK0_GPIO23_CTRL_FUNCSEL_NULL               = 0x1f

	// GPIO24_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO24_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO24_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO24_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO24_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO24_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO24_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO24_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO24_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO24_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO24_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO24_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO24_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO24_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO24_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO24_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO24_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO24_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO24_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO24_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO24_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO24_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO24_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO24_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO24_STATUS_OUTFROMPERI = 0x100

	// GPIO24_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO24_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO24_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO24_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO24_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO24_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO24_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO24_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO24_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO24_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO24_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO24_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO24_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO24_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO24_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO24_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO24_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO24_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO24_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO24_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO24_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO24_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO24_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO24_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO24_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO24_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO24_CTRL_FUNCSEL_Msk                        = 0x1f
	IO_BANK0_GPIO24_CTRL_FUNCSEL_SPI1_RX                    = 0x1
	IO_BANK0_GPIO24_CTRL_FUNCSEL_UART1_TX                   = 0x2
	IO_BANK0_GPIO24_CTRL_FUNCSEL_I2C0_SDA                   = 0x3
	IO_BANK0_GPIO24_CTRL_FUNCSEL_PWM_A_4                    = 0x4
	IO_BANK0_GPIO24_CTRL_FUNCSEL_SIO_24                     = 0x5
	IO_BANK0_GPIO24_CTRL_FUNCSEL_PIO0_24                    = 0x6
	IO_BANK0_GPIO24_CTRL_FUNCSEL_PIO1_24                    = 0x7
	IO_BANK0_GPIO24_CTRL_FUNCSEL_CLOCKS_GPOUT_2             = 0x8
	IO_BANK0_GPIO24_CTRL_FUNCSEL_USB_MUXING_OVERCURR_DETECT = 0x9
	IO_BANK0_GPIO24_CTRL_FUNCSEL_NULL                       = 0x1f

	// GPIO25_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO25_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO25_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO25_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO25_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO25_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO25_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO25_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO25_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO25_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO25_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO25_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO25_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO25_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO25_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO25_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO25_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO25_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO25_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO25_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO25_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO25_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO25_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO25_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO25_STATUS_OUTFROMPERI = 0x100

	// GPIO25_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO25_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO25_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO25_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO25_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO25_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO25_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO25_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO25_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO25_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO25_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO25_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO25_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO25_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO25_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO25_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO25_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO25_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO25_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO25_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO25_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO25_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO25_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO25_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO25_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO25_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO25_CTRL_FUNCSEL_Msk                    = 0x1f
	IO_BANK0_GPIO25_CTRL_FUNCSEL_SPI1_SS_N              = 0x1
	IO_BANK0_GPIO25_CTRL_FUNCSEL_UART1_RX               = 0x2
	IO_BANK0_GPIO25_CTRL_FUNCSEL_I2C0_SCL               = 0x3
	IO_BANK0_GPIO25_CTRL_FUNCSEL_PWM_B_4                = 0x4
	IO_BANK0_GPIO25_CTRL_FUNCSEL_SIO_25                 = 0x5
	IO_BANK0_GPIO25_CTRL_FUNCSEL_PIO0_25                = 0x6
	IO_BANK0_GPIO25_CTRL_FUNCSEL_PIO1_25                = 0x7
	IO_BANK0_GPIO25_CTRL_FUNCSEL_CLOCKS_GPOUT_3         = 0x8
	IO_BANK0_GPIO25_CTRL_FUNCSEL_USB_MUXING_VBUS_DETECT = 0x9
	IO_BANK0_GPIO25_CTRL_FUNCSEL_NULL                   = 0x1f

	// GPIO26_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO26_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO26_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO26_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO26_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO26_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO26_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO26_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO26_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO26_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO26_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO26_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO26_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO26_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO26_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO26_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO26_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO26_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO26_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO26_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO26_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO26_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO26_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO26_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO26_STATUS_OUTFROMPERI = 0x100

	// GPIO26_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO26_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO26_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO26_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO26_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO26_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO26_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO26_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO26_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO26_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO26_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO26_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO26_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO26_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO26_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO26_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO26_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO26_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO26_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO26_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO26_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO26_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO26_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO26_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO26_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO26_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO26_CTRL_FUNCSEL_Msk                = 0x1f
	IO_BANK0_GPIO26_CTRL_FUNCSEL_SPI1_SCLK          = 0x1
	IO_BANK0_GPIO26_CTRL_FUNCSEL_UART1_CTS          = 0x2
	IO_BANK0_GPIO26_CTRL_FUNCSEL_I2C1_SDA           = 0x3
	IO_BANK0_GPIO26_CTRL_FUNCSEL_PWM_A_5            = 0x4
	IO_BANK0_GPIO26_CTRL_FUNCSEL_SIO_26             = 0x5
	IO_BANK0_GPIO26_CTRL_FUNCSEL_PIO0_26            = 0x6
	IO_BANK0_GPIO26_CTRL_FUNCSEL_PIO1_26            = 0x7
	IO_BANK0_GPIO26_CTRL_FUNCSEL_USB_MUXING_VBUS_EN = 0x9
	IO_BANK0_GPIO26_CTRL_FUNCSEL_NULL               = 0x1f

	// GPIO27_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO27_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO27_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO27_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO27_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO27_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO27_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO27_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO27_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO27_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO27_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO27_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO27_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO27_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO27_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO27_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO27_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO27_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO27_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO27_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO27_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO27_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO27_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO27_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO27_STATUS_OUTFROMPERI = 0x100

	// GPIO27_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO27_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO27_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO27_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO27_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO27_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO27_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO27_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO27_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO27_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO27_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO27_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO27_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO27_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO27_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO27_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO27_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO27_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO27_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO27_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO27_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO27_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO27_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO27_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO27_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO27_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO27_CTRL_FUNCSEL_Msk                        = 0x1f
	IO_BANK0_GPIO27_CTRL_FUNCSEL_SPI1_TX                    = 0x1
	IO_BANK0_GPIO27_CTRL_FUNCSEL_UART1_RTS                  = 0x2
	IO_BANK0_GPIO27_CTRL_FUNCSEL_I2C1_SCL                   = 0x3
	IO_BANK0_GPIO27_CTRL_FUNCSEL_PWM_B_5                    = 0x4
	IO_BANK0_GPIO27_CTRL_FUNCSEL_SIO_27                     = 0x5
	IO_BANK0_GPIO27_CTRL_FUNCSEL_PIO0_27                    = 0x6
	IO_BANK0_GPIO27_CTRL_FUNCSEL_PIO1_27                    = 0x7
	IO_BANK0_GPIO27_CTRL_FUNCSEL_USB_MUXING_OVERCURR_DETECT = 0x9
	IO_BANK0_GPIO27_CTRL_FUNCSEL_NULL                       = 0x1f

	// GPIO28_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO28_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO28_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO28_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO28_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO28_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO28_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO28_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO28_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO28_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO28_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO28_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO28_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO28_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO28_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO28_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO28_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO28_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO28_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO28_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO28_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO28_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO28_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO28_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO28_STATUS_OUTFROMPERI = 0x100

	// GPIO28_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO28_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO28_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO28_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO28_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO28_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO28_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO28_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO28_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO28_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO28_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO28_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO28_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO28_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO28_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO28_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO28_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO28_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO28_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO28_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO28_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO28_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO28_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO28_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO28_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO28_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO28_CTRL_FUNCSEL_Msk                    = 0x1f
	IO_BANK0_GPIO28_CTRL_FUNCSEL_SPI1_RX                = 0x1
	IO_BANK0_GPIO28_CTRL_FUNCSEL_UART0_TX               = 0x2
	IO_BANK0_GPIO28_CTRL_FUNCSEL_I2C0_SDA               = 0x3
	IO_BANK0_GPIO28_CTRL_FUNCSEL_PWM_A_6                = 0x4
	IO_BANK0_GPIO28_CTRL_FUNCSEL_SIO_28                 = 0x5
	IO_BANK0_GPIO28_CTRL_FUNCSEL_PIO0_28                = 0x6
	IO_BANK0_GPIO28_CTRL_FUNCSEL_PIO1_28                = 0x7
	IO_BANK0_GPIO28_CTRL_FUNCSEL_USB_MUXING_VBUS_DETECT = 0x9
	IO_BANK0_GPIO28_CTRL_FUNCSEL_NULL                   = 0x1f

	// GPIO29_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_BANK0_GPIO29_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_BANK0_GPIO29_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_BANK0_GPIO29_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_BANK0_GPIO29_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_BANK0_GPIO29_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_BANK0_GPIO29_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_BANK0_GPIO29_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_BANK0_GPIO29_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_BANK0_GPIO29_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_BANK0_GPIO29_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_BANK0_GPIO29_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_BANK0_GPIO29_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_BANK0_GPIO29_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_BANK0_GPIO29_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_BANK0_GPIO29_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_BANK0_GPIO29_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_BANK0_GPIO29_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_BANK0_GPIO29_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_BANK0_GPIO29_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_BANK0_GPIO29_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_BANK0_GPIO29_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_BANK0_GPIO29_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_BANK0_GPIO29_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_BANK0_GPIO29_STATUS_OUTFROMPERI = 0x100

	// GPIO29_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_BANK0_GPIO29_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_BANK0_GPIO29_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_BANK0_GPIO29_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_BANK0_GPIO29_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_BANK0_GPIO29_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_BANK0_GPIO29_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_BANK0_GPIO29_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_BANK0_GPIO29_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_BANK0_GPIO29_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_BANK0_GPIO29_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_BANK0_GPIO29_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_BANK0_GPIO29_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_BANK0_GPIO29_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_BANK0_GPIO29_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_BANK0_GPIO29_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO29_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_BANK0_GPIO29_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_BANK0_GPIO29_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_BANK0_GPIO29_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_BANK0_GPIO29_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_BANK0_GPIO29_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_BANK0_GPIO29_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_BANK0_GPIO29_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_BANK0_GPIO29_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_BANK0_GPIO29_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_BANK0_GPIO29_CTRL_FUNCSEL_Msk                = 0x1f
	IO_BANK0_GPIO29_CTRL_FUNCSEL_SPI1_SS_N          = 0x1
	IO_BANK0_GPIO29_CTRL_FUNCSEL_UART0_RX           = 0x2
	IO_BANK0_GPIO29_CTRL_FUNCSEL_I2C0_SCL           = 0x3
	IO_BANK0_GPIO29_CTRL_FUNCSEL_PWM_B_6            = 0x4
	IO_BANK0_GPIO29_CTRL_FUNCSEL_SIO_29             = 0x5
	IO_BANK0_GPIO29_CTRL_FUNCSEL_PIO0_29            = 0x6
	IO_BANK0_GPIO29_CTRL_FUNCSEL_PIO1_29            = 0x7
	IO_BANK0_GPIO29_CTRL_FUNCSEL_USB_MUXING_VBUS_EN = 0x9
	IO_BANK0_GPIO29_CTRL_FUNCSEL_NULL               = 0x1f

	// INTR0: Raw Interrupts
	// Position of GPIO7_EDGE_HIGH field.
	IO_BANK0_INTR0_GPIO7_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO7_EDGE_HIGH field.
	IO_BANK0_INTR0_GPIO7_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO7_EDGE_HIGH.
	IO_BANK0_INTR0_GPIO7_EDGE_HIGH = 0x80000000
	// Position of GPIO7_EDGE_LOW field.
	IO_BANK0_INTR0_GPIO7_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO7_EDGE_LOW field.
	IO_BANK0_INTR0_GPIO7_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO7_EDGE_LOW.
	IO_BANK0_INTR0_GPIO7_EDGE_LOW = 0x40000000
	// Position of GPIO7_LEVEL_HIGH field.
	IO_BANK0_INTR0_GPIO7_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO7_LEVEL_HIGH field.
	IO_BANK0_INTR0_GPIO7_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO7_LEVEL_HIGH.
	IO_BANK0_INTR0_GPIO7_LEVEL_HIGH = 0x20000000
	// Position of GPIO7_LEVEL_LOW field.
	IO_BANK0_INTR0_GPIO7_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO7_LEVEL_LOW field.
	IO_BANK0_INTR0_GPIO7_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO7_LEVEL_LOW.
	IO_BANK0_INTR0_GPIO7_LEVEL_LOW = 0x10000000
	// Position of GPIO6_EDGE_HIGH field.
	IO_BANK0_INTR0_GPIO6_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO6_EDGE_HIGH field.
	IO_BANK0_INTR0_GPIO6_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO6_EDGE_HIGH.
	IO_BANK0_INTR0_GPIO6_EDGE_HIGH = 0x8000000
	// Position of GPIO6_EDGE_LOW field.
	IO_BANK0_INTR0_GPIO6_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO6_EDGE_LOW field.
	IO_BANK0_INTR0_GPIO6_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO6_EDGE_LOW.
	IO_BANK0_INTR0_GPIO6_EDGE_LOW = 0x4000000
	// Position of GPIO6_LEVEL_HIGH field.
	IO_BANK0_INTR0_GPIO6_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO6_LEVEL_HIGH field.
	IO_BANK0_INTR0_GPIO6_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO6_LEVEL_HIGH.
	IO_BANK0_INTR0_GPIO6_LEVEL_HIGH = 0x2000000
	// Position of GPIO6_LEVEL_LOW field.
	IO_BANK0_INTR0_GPIO6_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO6_LEVEL_LOW field.
	IO_BANK0_INTR0_GPIO6_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO6_LEVEL_LOW.
	IO_BANK0_INTR0_GPIO6_LEVEL_LOW = 0x1000000
	// Position of GPIO5_EDGE_HIGH field.
	IO_BANK0_INTR0_GPIO5_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO5_EDGE_HIGH field.
	IO_BANK0_INTR0_GPIO5_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO5_EDGE_HIGH.
	IO_BANK0_INTR0_GPIO5_EDGE_HIGH = 0x800000
	// Position of GPIO5_EDGE_LOW field.
	IO_BANK0_INTR0_GPIO5_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO5_EDGE_LOW field.
	IO_BANK0_INTR0_GPIO5_EDGE_LOW_Msk = 0x400000
	// Bit GPIO5_EDGE_LOW.
	IO_BANK0_INTR0_GPIO5_EDGE_LOW = 0x400000
	// Position of GPIO5_LEVEL_HIGH field.
	IO_BANK0_INTR0_GPIO5_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO5_LEVEL_HIGH field.
	IO_BANK0_INTR0_GPIO5_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO5_LEVEL_HIGH.
	IO_BANK0_INTR0_GPIO5_LEVEL_HIGH = 0x200000
	// Position of GPIO5_LEVEL_LOW field.
	IO_BANK0_INTR0_GPIO5_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO5_LEVEL_LOW field.
	IO_BANK0_INTR0_GPIO5_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO5_LEVEL_LOW.
	IO_BANK0_INTR0_GPIO5_LEVEL_LOW = 0x100000
	// Position of GPIO4_EDGE_HIGH field.
	IO_BANK0_INTR0_GPIO4_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO4_EDGE_HIGH field.
	IO_BANK0_INTR0_GPIO4_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO4_EDGE_HIGH.
	IO_BANK0_INTR0_GPIO4_EDGE_HIGH = 0x80000
	// Position of GPIO4_EDGE_LOW field.
	IO_BANK0_INTR0_GPIO4_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO4_EDGE_LOW field.
	IO_BANK0_INTR0_GPIO4_EDGE_LOW_Msk = 0x40000
	// Bit GPIO4_EDGE_LOW.
	IO_BANK0_INTR0_GPIO4_EDGE_LOW = 0x40000
	// Position of GPIO4_LEVEL_HIGH field.
	IO_BANK0_INTR0_GPIO4_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO4_LEVEL_HIGH field.
	IO_BANK0_INTR0_GPIO4_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO4_LEVEL_HIGH.
	IO_BANK0_INTR0_GPIO4_LEVEL_HIGH = 0x20000
	// Position of GPIO4_LEVEL_LOW field.
	IO_BANK0_INTR0_GPIO4_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO4_LEVEL_LOW field.
	IO_BANK0_INTR0_GPIO4_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO4_LEVEL_LOW.
	IO_BANK0_INTR0_GPIO4_LEVEL_LOW = 0x10000
	// Position of GPIO3_EDGE_HIGH field.
	IO_BANK0_INTR0_GPIO3_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO3_EDGE_HIGH field.
	IO_BANK0_INTR0_GPIO3_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO3_EDGE_HIGH.
	IO_BANK0_INTR0_GPIO3_EDGE_HIGH = 0x8000
	// Position of GPIO3_EDGE_LOW field.
	IO_BANK0_INTR0_GPIO3_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO3_EDGE_LOW field.
	IO_BANK0_INTR0_GPIO3_EDGE_LOW_Msk = 0x4000
	// Bit GPIO3_EDGE_LOW.
	IO_BANK0_INTR0_GPIO3_EDGE_LOW = 0x4000
	// Position of GPIO3_LEVEL_HIGH field.
	IO_BANK0_INTR0_GPIO3_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO3_LEVEL_HIGH field.
	IO_BANK0_INTR0_GPIO3_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO3_LEVEL_HIGH.
	IO_BANK0_INTR0_GPIO3_LEVEL_HIGH = 0x2000
	// Position of GPIO3_LEVEL_LOW field.
	IO_BANK0_INTR0_GPIO3_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO3_LEVEL_LOW field.
	IO_BANK0_INTR0_GPIO3_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO3_LEVEL_LOW.
	IO_BANK0_INTR0_GPIO3_LEVEL_LOW = 0x1000
	// Position of GPIO2_EDGE_HIGH field.
	IO_BANK0_INTR0_GPIO2_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO2_EDGE_HIGH field.
	IO_BANK0_INTR0_GPIO2_EDGE_HIGH_Msk = 0x800
	// Bit GPIO2_EDGE_HIGH.
	IO_BANK0_INTR0_GPIO2_EDGE_HIGH = 0x800
	// Position of GPIO2_EDGE_LOW field.
	IO_BANK0_INTR0_GPIO2_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO2_EDGE_LOW field.
	IO_BANK0_INTR0_GPIO2_EDGE_LOW_Msk = 0x400
	// Bit GPIO2_EDGE_LOW.
	IO_BANK0_INTR0_GPIO2_EDGE_LOW = 0x400
	// Position of GPIO2_LEVEL_HIGH field.
	IO_BANK0_INTR0_GPIO2_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO2_LEVEL_HIGH field.
	IO_BANK0_INTR0_GPIO2_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO2_LEVEL_HIGH.
	IO_BANK0_INTR0_GPIO2_LEVEL_HIGH = 0x200
	// Position of GPIO2_LEVEL_LOW field.
	IO_BANK0_INTR0_GPIO2_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO2_LEVEL_LOW field.
	IO_BANK0_INTR0_GPIO2_LEVEL_LOW_Msk = 0x100
	// Bit GPIO2_LEVEL_LOW.
	IO_BANK0_INTR0_GPIO2_LEVEL_LOW = 0x100
	// Position of GPIO1_EDGE_HIGH field.
	IO_BANK0_INTR0_GPIO1_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO1_EDGE_HIGH field.
	IO_BANK0_INTR0_GPIO1_EDGE_HIGH_Msk = 0x80
	// Bit GPIO1_EDGE_HIGH.
	IO_BANK0_INTR0_GPIO1_EDGE_HIGH = 0x80
	// Position of GPIO1_EDGE_LOW field.
	IO_BANK0_INTR0_GPIO1_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO1_EDGE_LOW field.
	IO_BANK0_INTR0_GPIO1_EDGE_LOW_Msk = 0x40
	// Bit GPIO1_EDGE_LOW.
	IO_BANK0_INTR0_GPIO1_EDGE_LOW = 0x40
	// Position of GPIO1_LEVEL_HIGH field.
	IO_BANK0_INTR0_GPIO1_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO1_LEVEL_HIGH field.
	IO_BANK0_INTR0_GPIO1_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO1_LEVEL_HIGH.
	IO_BANK0_INTR0_GPIO1_LEVEL_HIGH = 0x20
	// Position of GPIO1_LEVEL_LOW field.
	IO_BANK0_INTR0_GPIO1_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO1_LEVEL_LOW field.
	IO_BANK0_INTR0_GPIO1_LEVEL_LOW_Msk = 0x10
	// Bit GPIO1_LEVEL_LOW.
	IO_BANK0_INTR0_GPIO1_LEVEL_LOW = 0x10
	// Position of GPIO0_EDGE_HIGH field.
	IO_BANK0_INTR0_GPIO0_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO0_EDGE_HIGH field.
	IO_BANK0_INTR0_GPIO0_EDGE_HIGH_Msk = 0x8
	// Bit GPIO0_EDGE_HIGH.
	IO_BANK0_INTR0_GPIO0_EDGE_HIGH = 0x8
	// Position of GPIO0_EDGE_LOW field.
	IO_BANK0_INTR0_GPIO0_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO0_EDGE_LOW field.
	IO_BANK0_INTR0_GPIO0_EDGE_LOW_Msk = 0x4
	// Bit GPIO0_EDGE_LOW.
	IO_BANK0_INTR0_GPIO0_EDGE_LOW = 0x4
	// Position of GPIO0_LEVEL_HIGH field.
	IO_BANK0_INTR0_GPIO0_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO0_LEVEL_HIGH field.
	IO_BANK0_INTR0_GPIO0_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO0_LEVEL_HIGH.
	IO_BANK0_INTR0_GPIO0_LEVEL_HIGH = 0x2
	// Position of GPIO0_LEVEL_LOW field.
	IO_BANK0_INTR0_GPIO0_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO0_LEVEL_LOW field.
	IO_BANK0_INTR0_GPIO0_LEVEL_LOW_Msk = 0x1
	// Bit GPIO0_LEVEL_LOW.
	IO_BANK0_INTR0_GPIO0_LEVEL_LOW = 0x1

	// INTR1: Raw Interrupts
	// Position of GPIO15_EDGE_HIGH field.
	IO_BANK0_INTR1_GPIO15_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO15_EDGE_HIGH field.
	IO_BANK0_INTR1_GPIO15_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO15_EDGE_HIGH.
	IO_BANK0_INTR1_GPIO15_EDGE_HIGH = 0x80000000
	// Position of GPIO15_EDGE_LOW field.
	IO_BANK0_INTR1_GPIO15_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO15_EDGE_LOW field.
	IO_BANK0_INTR1_GPIO15_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO15_EDGE_LOW.
	IO_BANK0_INTR1_GPIO15_EDGE_LOW = 0x40000000
	// Position of GPIO15_LEVEL_HIGH field.
	IO_BANK0_INTR1_GPIO15_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO15_LEVEL_HIGH field.
	IO_BANK0_INTR1_GPIO15_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO15_LEVEL_HIGH.
	IO_BANK0_INTR1_GPIO15_LEVEL_HIGH = 0x20000000
	// Position of GPIO15_LEVEL_LOW field.
	IO_BANK0_INTR1_GPIO15_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO15_LEVEL_LOW field.
	IO_BANK0_INTR1_GPIO15_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO15_LEVEL_LOW.
	IO_BANK0_INTR1_GPIO15_LEVEL_LOW = 0x10000000
	// Position of GPIO14_EDGE_HIGH field.
	IO_BANK0_INTR1_GPIO14_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO14_EDGE_HIGH field.
	IO_BANK0_INTR1_GPIO14_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO14_EDGE_HIGH.
	IO_BANK0_INTR1_GPIO14_EDGE_HIGH = 0x8000000
	// Position of GPIO14_EDGE_LOW field.
	IO_BANK0_INTR1_GPIO14_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO14_EDGE_LOW field.
	IO_BANK0_INTR1_GPIO14_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO14_EDGE_LOW.
	IO_BANK0_INTR1_GPIO14_EDGE_LOW = 0x4000000
	// Position of GPIO14_LEVEL_HIGH field.
	IO_BANK0_INTR1_GPIO14_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO14_LEVEL_HIGH field.
	IO_BANK0_INTR1_GPIO14_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO14_LEVEL_HIGH.
	IO_BANK0_INTR1_GPIO14_LEVEL_HIGH = 0x2000000
	// Position of GPIO14_LEVEL_LOW field.
	IO_BANK0_INTR1_GPIO14_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO14_LEVEL_LOW field.
	IO_BANK0_INTR1_GPIO14_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO14_LEVEL_LOW.
	IO_BANK0_INTR1_GPIO14_LEVEL_LOW = 0x1000000
	// Position of GPIO13_EDGE_HIGH field.
	IO_BANK0_INTR1_GPIO13_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO13_EDGE_HIGH field.
	IO_BANK0_INTR1_GPIO13_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO13_EDGE_HIGH.
	IO_BANK0_INTR1_GPIO13_EDGE_HIGH = 0x800000
	// Position of GPIO13_EDGE_LOW field.
	IO_BANK0_INTR1_GPIO13_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO13_EDGE_LOW field.
	IO_BANK0_INTR1_GPIO13_EDGE_LOW_Msk = 0x400000
	// Bit GPIO13_EDGE_LOW.
	IO_BANK0_INTR1_GPIO13_EDGE_LOW = 0x400000
	// Position of GPIO13_LEVEL_HIGH field.
	IO_BANK0_INTR1_GPIO13_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO13_LEVEL_HIGH field.
	IO_BANK0_INTR1_GPIO13_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO13_LEVEL_HIGH.
	IO_BANK0_INTR1_GPIO13_LEVEL_HIGH = 0x200000
	// Position of GPIO13_LEVEL_LOW field.
	IO_BANK0_INTR1_GPIO13_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO13_LEVEL_LOW field.
	IO_BANK0_INTR1_GPIO13_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO13_LEVEL_LOW.
	IO_BANK0_INTR1_GPIO13_LEVEL_LOW = 0x100000
	// Position of GPIO12_EDGE_HIGH field.
	IO_BANK0_INTR1_GPIO12_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO12_EDGE_HIGH field.
	IO_BANK0_INTR1_GPIO12_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO12_EDGE_HIGH.
	IO_BANK0_INTR1_GPIO12_EDGE_HIGH = 0x80000
	// Position of GPIO12_EDGE_LOW field.
	IO_BANK0_INTR1_GPIO12_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO12_EDGE_LOW field.
	IO_BANK0_INTR1_GPIO12_EDGE_LOW_Msk = 0x40000
	// Bit GPIO12_EDGE_LOW.
	IO_BANK0_INTR1_GPIO12_EDGE_LOW = 0x40000
	// Position of GPIO12_LEVEL_HIGH field.
	IO_BANK0_INTR1_GPIO12_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO12_LEVEL_HIGH field.
	IO_BANK0_INTR1_GPIO12_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO12_LEVEL_HIGH.
	IO_BANK0_INTR1_GPIO12_LEVEL_HIGH = 0x20000
	// Position of GPIO12_LEVEL_LOW field.
	IO_BANK0_INTR1_GPIO12_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO12_LEVEL_LOW field.
	IO_BANK0_INTR1_GPIO12_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO12_LEVEL_LOW.
	IO_BANK0_INTR1_GPIO12_LEVEL_LOW = 0x10000
	// Position of GPIO11_EDGE_HIGH field.
	IO_BANK0_INTR1_GPIO11_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO11_EDGE_HIGH field.
	IO_BANK0_INTR1_GPIO11_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO11_EDGE_HIGH.
	IO_BANK0_INTR1_GPIO11_EDGE_HIGH = 0x8000
	// Position of GPIO11_EDGE_LOW field.
	IO_BANK0_INTR1_GPIO11_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO11_EDGE_LOW field.
	IO_BANK0_INTR1_GPIO11_EDGE_LOW_Msk = 0x4000
	// Bit GPIO11_EDGE_LOW.
	IO_BANK0_INTR1_GPIO11_EDGE_LOW = 0x4000
	// Position of GPIO11_LEVEL_HIGH field.
	IO_BANK0_INTR1_GPIO11_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO11_LEVEL_HIGH field.
	IO_BANK0_INTR1_GPIO11_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO11_LEVEL_HIGH.
	IO_BANK0_INTR1_GPIO11_LEVEL_HIGH = 0x2000
	// Position of GPIO11_LEVEL_LOW field.
	IO_BANK0_INTR1_GPIO11_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO11_LEVEL_LOW field.
	IO_BANK0_INTR1_GPIO11_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO11_LEVEL_LOW.
	IO_BANK0_INTR1_GPIO11_LEVEL_LOW = 0x1000
	// Position of GPIO10_EDGE_HIGH field.
	IO_BANK0_INTR1_GPIO10_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO10_EDGE_HIGH field.
	IO_BANK0_INTR1_GPIO10_EDGE_HIGH_Msk = 0x800
	// Bit GPIO10_EDGE_HIGH.
	IO_BANK0_INTR1_GPIO10_EDGE_HIGH = 0x800
	// Position of GPIO10_EDGE_LOW field.
	IO_BANK0_INTR1_GPIO10_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO10_EDGE_LOW field.
	IO_BANK0_INTR1_GPIO10_EDGE_LOW_Msk = 0x400
	// Bit GPIO10_EDGE_LOW.
	IO_BANK0_INTR1_GPIO10_EDGE_LOW = 0x400
	// Position of GPIO10_LEVEL_HIGH field.
	IO_BANK0_INTR1_GPIO10_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO10_LEVEL_HIGH field.
	IO_BANK0_INTR1_GPIO10_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO10_LEVEL_HIGH.
	IO_BANK0_INTR1_GPIO10_LEVEL_HIGH = 0x200
	// Position of GPIO10_LEVEL_LOW field.
	IO_BANK0_INTR1_GPIO10_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO10_LEVEL_LOW field.
	IO_BANK0_INTR1_GPIO10_LEVEL_LOW_Msk = 0x100
	// Bit GPIO10_LEVEL_LOW.
	IO_BANK0_INTR1_GPIO10_LEVEL_LOW = 0x100
	// Position of GPIO9_EDGE_HIGH field.
	IO_BANK0_INTR1_GPIO9_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO9_EDGE_HIGH field.
	IO_BANK0_INTR1_GPIO9_EDGE_HIGH_Msk = 0x80
	// Bit GPIO9_EDGE_HIGH.
	IO_BANK0_INTR1_GPIO9_EDGE_HIGH = 0x80
	// Position of GPIO9_EDGE_LOW field.
	IO_BANK0_INTR1_GPIO9_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO9_EDGE_LOW field.
	IO_BANK0_INTR1_GPIO9_EDGE_LOW_Msk = 0x40
	// Bit GPIO9_EDGE_LOW.
	IO_BANK0_INTR1_GPIO9_EDGE_LOW = 0x40
	// Position of GPIO9_LEVEL_HIGH field.
	IO_BANK0_INTR1_GPIO9_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO9_LEVEL_HIGH field.
	IO_BANK0_INTR1_GPIO9_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO9_LEVEL_HIGH.
	IO_BANK0_INTR1_GPIO9_LEVEL_HIGH = 0x20
	// Position of GPIO9_LEVEL_LOW field.
	IO_BANK0_INTR1_GPIO9_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO9_LEVEL_LOW field.
	IO_BANK0_INTR1_GPIO9_LEVEL_LOW_Msk = 0x10
	// Bit GPIO9_LEVEL_LOW.
	IO_BANK0_INTR1_GPIO9_LEVEL_LOW = 0x10
	// Position of GPIO8_EDGE_HIGH field.
	IO_BANK0_INTR1_GPIO8_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO8_EDGE_HIGH field.
	IO_BANK0_INTR1_GPIO8_EDGE_HIGH_Msk = 0x8
	// Bit GPIO8_EDGE_HIGH.
	IO_BANK0_INTR1_GPIO8_EDGE_HIGH = 0x8
	// Position of GPIO8_EDGE_LOW field.
	IO_BANK0_INTR1_GPIO8_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO8_EDGE_LOW field.
	IO_BANK0_INTR1_GPIO8_EDGE_LOW_Msk = 0x4
	// Bit GPIO8_EDGE_LOW.
	IO_BANK0_INTR1_GPIO8_EDGE_LOW = 0x4
	// Position of GPIO8_LEVEL_HIGH field.
	IO_BANK0_INTR1_GPIO8_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO8_LEVEL_HIGH field.
	IO_BANK0_INTR1_GPIO8_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO8_LEVEL_HIGH.
	IO_BANK0_INTR1_GPIO8_LEVEL_HIGH = 0x2
	// Position of GPIO8_LEVEL_LOW field.
	IO_BANK0_INTR1_GPIO8_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO8_LEVEL_LOW field.
	IO_BANK0_INTR1_GPIO8_LEVEL_LOW_Msk = 0x1
	// Bit GPIO8_LEVEL_LOW.
	IO_BANK0_INTR1_GPIO8_LEVEL_LOW = 0x1

	// INTR2: Raw Interrupts
	// Position of GPIO23_EDGE_HIGH field.
	IO_BANK0_INTR2_GPIO23_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO23_EDGE_HIGH field.
	IO_BANK0_INTR2_GPIO23_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO23_EDGE_HIGH.
	IO_BANK0_INTR2_GPIO23_EDGE_HIGH = 0x80000000
	// Position of GPIO23_EDGE_LOW field.
	IO_BANK0_INTR2_GPIO23_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO23_EDGE_LOW field.
	IO_BANK0_INTR2_GPIO23_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO23_EDGE_LOW.
	IO_BANK0_INTR2_GPIO23_EDGE_LOW = 0x40000000
	// Position of GPIO23_LEVEL_HIGH field.
	IO_BANK0_INTR2_GPIO23_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO23_LEVEL_HIGH field.
	IO_BANK0_INTR2_GPIO23_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO23_LEVEL_HIGH.
	IO_BANK0_INTR2_GPIO23_LEVEL_HIGH = 0x20000000
	// Position of GPIO23_LEVEL_LOW field.
	IO_BANK0_INTR2_GPIO23_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO23_LEVEL_LOW field.
	IO_BANK0_INTR2_GPIO23_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO23_LEVEL_LOW.
	IO_BANK0_INTR2_GPIO23_LEVEL_LOW = 0x10000000
	// Position of GPIO22_EDGE_HIGH field.
	IO_BANK0_INTR2_GPIO22_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO22_EDGE_HIGH field.
	IO_BANK0_INTR2_GPIO22_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO22_EDGE_HIGH.
	IO_BANK0_INTR2_GPIO22_EDGE_HIGH = 0x8000000
	// Position of GPIO22_EDGE_LOW field.
	IO_BANK0_INTR2_GPIO22_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO22_EDGE_LOW field.
	IO_BANK0_INTR2_GPIO22_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO22_EDGE_LOW.
	IO_BANK0_INTR2_GPIO22_EDGE_LOW = 0x4000000
	// Position of GPIO22_LEVEL_HIGH field.
	IO_BANK0_INTR2_GPIO22_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO22_LEVEL_HIGH field.
	IO_BANK0_INTR2_GPIO22_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO22_LEVEL_HIGH.
	IO_BANK0_INTR2_GPIO22_LEVEL_HIGH = 0x2000000
	// Position of GPIO22_LEVEL_LOW field.
	IO_BANK0_INTR2_GPIO22_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO22_LEVEL_LOW field.
	IO_BANK0_INTR2_GPIO22_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO22_LEVEL_LOW.
	IO_BANK0_INTR2_GPIO22_LEVEL_LOW = 0x1000000
	// Position of GPIO21_EDGE_HIGH field.
	IO_BANK0_INTR2_GPIO21_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO21_EDGE_HIGH field.
	IO_BANK0_INTR2_GPIO21_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO21_EDGE_HIGH.
	IO_BANK0_INTR2_GPIO21_EDGE_HIGH = 0x800000
	// Position of GPIO21_EDGE_LOW field.
	IO_BANK0_INTR2_GPIO21_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO21_EDGE_LOW field.
	IO_BANK0_INTR2_GPIO21_EDGE_LOW_Msk = 0x400000
	// Bit GPIO21_EDGE_LOW.
	IO_BANK0_INTR2_GPIO21_EDGE_LOW = 0x400000
	// Position of GPIO21_LEVEL_HIGH field.
	IO_BANK0_INTR2_GPIO21_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO21_LEVEL_HIGH field.
	IO_BANK0_INTR2_GPIO21_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO21_LEVEL_HIGH.
	IO_BANK0_INTR2_GPIO21_LEVEL_HIGH = 0x200000
	// Position of GPIO21_LEVEL_LOW field.
	IO_BANK0_INTR2_GPIO21_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO21_LEVEL_LOW field.
	IO_BANK0_INTR2_GPIO21_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO21_LEVEL_LOW.
	IO_BANK0_INTR2_GPIO21_LEVEL_LOW = 0x100000
	// Position of GPIO20_EDGE_HIGH field.
	IO_BANK0_INTR2_GPIO20_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO20_EDGE_HIGH field.
	IO_BANK0_INTR2_GPIO20_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO20_EDGE_HIGH.
	IO_BANK0_INTR2_GPIO20_EDGE_HIGH = 0x80000
	// Position of GPIO20_EDGE_LOW field.
	IO_BANK0_INTR2_GPIO20_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO20_EDGE_LOW field.
	IO_BANK0_INTR2_GPIO20_EDGE_LOW_Msk = 0x40000
	// Bit GPIO20_EDGE_LOW.
	IO_BANK0_INTR2_GPIO20_EDGE_LOW = 0x40000
	// Position of GPIO20_LEVEL_HIGH field.
	IO_BANK0_INTR2_GPIO20_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO20_LEVEL_HIGH field.
	IO_BANK0_INTR2_GPIO20_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO20_LEVEL_HIGH.
	IO_BANK0_INTR2_GPIO20_LEVEL_HIGH = 0x20000
	// Position of GPIO20_LEVEL_LOW field.
	IO_BANK0_INTR2_GPIO20_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO20_LEVEL_LOW field.
	IO_BANK0_INTR2_GPIO20_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO20_LEVEL_LOW.
	IO_BANK0_INTR2_GPIO20_LEVEL_LOW = 0x10000
	// Position of GPIO19_EDGE_HIGH field.
	IO_BANK0_INTR2_GPIO19_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO19_EDGE_HIGH field.
	IO_BANK0_INTR2_GPIO19_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO19_EDGE_HIGH.
	IO_BANK0_INTR2_GPIO19_EDGE_HIGH = 0x8000
	// Position of GPIO19_EDGE_LOW field.
	IO_BANK0_INTR2_GPIO19_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO19_EDGE_LOW field.
	IO_BANK0_INTR2_GPIO19_EDGE_LOW_Msk = 0x4000
	// Bit GPIO19_EDGE_LOW.
	IO_BANK0_INTR2_GPIO19_EDGE_LOW = 0x4000
	// Position of GPIO19_LEVEL_HIGH field.
	IO_BANK0_INTR2_GPIO19_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO19_LEVEL_HIGH field.
	IO_BANK0_INTR2_GPIO19_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO19_LEVEL_HIGH.
	IO_BANK0_INTR2_GPIO19_LEVEL_HIGH = 0x2000
	// Position of GPIO19_LEVEL_LOW field.
	IO_BANK0_INTR2_GPIO19_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO19_LEVEL_LOW field.
	IO_BANK0_INTR2_GPIO19_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO19_LEVEL_LOW.
	IO_BANK0_INTR2_GPIO19_LEVEL_LOW = 0x1000
	// Position of GPIO18_EDGE_HIGH field.
	IO_BANK0_INTR2_GPIO18_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO18_EDGE_HIGH field.
	IO_BANK0_INTR2_GPIO18_EDGE_HIGH_Msk = 0x800
	// Bit GPIO18_EDGE_HIGH.
	IO_BANK0_INTR2_GPIO18_EDGE_HIGH = 0x800
	// Position of GPIO18_EDGE_LOW field.
	IO_BANK0_INTR2_GPIO18_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO18_EDGE_LOW field.
	IO_BANK0_INTR2_GPIO18_EDGE_LOW_Msk = 0x400
	// Bit GPIO18_EDGE_LOW.
	IO_BANK0_INTR2_GPIO18_EDGE_LOW = 0x400
	// Position of GPIO18_LEVEL_HIGH field.
	IO_BANK0_INTR2_GPIO18_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO18_LEVEL_HIGH field.
	IO_BANK0_INTR2_GPIO18_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO18_LEVEL_HIGH.
	IO_BANK0_INTR2_GPIO18_LEVEL_HIGH = 0x200
	// Position of GPIO18_LEVEL_LOW field.
	IO_BANK0_INTR2_GPIO18_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO18_LEVEL_LOW field.
	IO_BANK0_INTR2_GPIO18_LEVEL_LOW_Msk = 0x100
	// Bit GPIO18_LEVEL_LOW.
	IO_BANK0_INTR2_GPIO18_LEVEL_LOW = 0x100
	// Position of GPIO17_EDGE_HIGH field.
	IO_BANK0_INTR2_GPIO17_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO17_EDGE_HIGH field.
	IO_BANK0_INTR2_GPIO17_EDGE_HIGH_Msk = 0x80
	// Bit GPIO17_EDGE_HIGH.
	IO_BANK0_INTR2_GPIO17_EDGE_HIGH = 0x80
	// Position of GPIO17_EDGE_LOW field.
	IO_BANK0_INTR2_GPIO17_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO17_EDGE_LOW field.
	IO_BANK0_INTR2_GPIO17_EDGE_LOW_Msk = 0x40
	// Bit GPIO17_EDGE_LOW.
	IO_BANK0_INTR2_GPIO17_EDGE_LOW = 0x40
	// Position of GPIO17_LEVEL_HIGH field.
	IO_BANK0_INTR2_GPIO17_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO17_LEVEL_HIGH field.
	IO_BANK0_INTR2_GPIO17_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO17_LEVEL_HIGH.
	IO_BANK0_INTR2_GPIO17_LEVEL_HIGH = 0x20
	// Position of GPIO17_LEVEL_LOW field.
	IO_BANK0_INTR2_GPIO17_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO17_LEVEL_LOW field.
	IO_BANK0_INTR2_GPIO17_LEVEL_LOW_Msk = 0x10
	// Bit GPIO17_LEVEL_LOW.
	IO_BANK0_INTR2_GPIO17_LEVEL_LOW = 0x10
	// Position of GPIO16_EDGE_HIGH field.
	IO_BANK0_INTR2_GPIO16_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO16_EDGE_HIGH field.
	IO_BANK0_INTR2_GPIO16_EDGE_HIGH_Msk = 0x8
	// Bit GPIO16_EDGE_HIGH.
	IO_BANK0_INTR2_GPIO16_EDGE_HIGH = 0x8
	// Position of GPIO16_EDGE_LOW field.
	IO_BANK0_INTR2_GPIO16_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO16_EDGE_LOW field.
	IO_BANK0_INTR2_GPIO16_EDGE_LOW_Msk = 0x4
	// Bit GPIO16_EDGE_LOW.
	IO_BANK0_INTR2_GPIO16_EDGE_LOW = 0x4
	// Position of GPIO16_LEVEL_HIGH field.
	IO_BANK0_INTR2_GPIO16_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO16_LEVEL_HIGH field.
	IO_BANK0_INTR2_GPIO16_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO16_LEVEL_HIGH.
	IO_BANK0_INTR2_GPIO16_LEVEL_HIGH = 0x2
	// Position of GPIO16_LEVEL_LOW field.
	IO_BANK0_INTR2_GPIO16_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO16_LEVEL_LOW field.
	IO_BANK0_INTR2_GPIO16_LEVEL_LOW_Msk = 0x1
	// Bit GPIO16_LEVEL_LOW.
	IO_BANK0_INTR2_GPIO16_LEVEL_LOW = 0x1

	// INTR3: Raw Interrupts
	// Position of GPIO29_EDGE_HIGH field.
	IO_BANK0_INTR3_GPIO29_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO29_EDGE_HIGH field.
	IO_BANK0_INTR3_GPIO29_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO29_EDGE_HIGH.
	IO_BANK0_INTR3_GPIO29_EDGE_HIGH = 0x800000
	// Position of GPIO29_EDGE_LOW field.
	IO_BANK0_INTR3_GPIO29_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO29_EDGE_LOW field.
	IO_BANK0_INTR3_GPIO29_EDGE_LOW_Msk = 0x400000
	// Bit GPIO29_EDGE_LOW.
	IO_BANK0_INTR3_GPIO29_EDGE_LOW = 0x400000
	// Position of GPIO29_LEVEL_HIGH field.
	IO_BANK0_INTR3_GPIO29_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO29_LEVEL_HIGH field.
	IO_BANK0_INTR3_GPIO29_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO29_LEVEL_HIGH.
	IO_BANK0_INTR3_GPIO29_LEVEL_HIGH = 0x200000
	// Position of GPIO29_LEVEL_LOW field.
	IO_BANK0_INTR3_GPIO29_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO29_LEVEL_LOW field.
	IO_BANK0_INTR3_GPIO29_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO29_LEVEL_LOW.
	IO_BANK0_INTR3_GPIO29_LEVEL_LOW = 0x100000
	// Position of GPIO28_EDGE_HIGH field.
	IO_BANK0_INTR3_GPIO28_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO28_EDGE_HIGH field.
	IO_BANK0_INTR3_GPIO28_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO28_EDGE_HIGH.
	IO_BANK0_INTR3_GPIO28_EDGE_HIGH = 0x80000
	// Position of GPIO28_EDGE_LOW field.
	IO_BANK0_INTR3_GPIO28_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO28_EDGE_LOW field.
	IO_BANK0_INTR3_GPIO28_EDGE_LOW_Msk = 0x40000
	// Bit GPIO28_EDGE_LOW.
	IO_BANK0_INTR3_GPIO28_EDGE_LOW = 0x40000
	// Position of GPIO28_LEVEL_HIGH field.
	IO_BANK0_INTR3_GPIO28_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO28_LEVEL_HIGH field.
	IO_BANK0_INTR3_GPIO28_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO28_LEVEL_HIGH.
	IO_BANK0_INTR3_GPIO28_LEVEL_HIGH = 0x20000
	// Position of GPIO28_LEVEL_LOW field.
	IO_BANK0_INTR3_GPIO28_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO28_LEVEL_LOW field.
	IO_BANK0_INTR3_GPIO28_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO28_LEVEL_LOW.
	IO_BANK0_INTR3_GPIO28_LEVEL_LOW = 0x10000
	// Position of GPIO27_EDGE_HIGH field.
	IO_BANK0_INTR3_GPIO27_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO27_EDGE_HIGH field.
	IO_BANK0_INTR3_GPIO27_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO27_EDGE_HIGH.
	IO_BANK0_INTR3_GPIO27_EDGE_HIGH = 0x8000
	// Position of GPIO27_EDGE_LOW field.
	IO_BANK0_INTR3_GPIO27_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO27_EDGE_LOW field.
	IO_BANK0_INTR3_GPIO27_EDGE_LOW_Msk = 0x4000
	// Bit GPIO27_EDGE_LOW.
	IO_BANK0_INTR3_GPIO27_EDGE_LOW = 0x4000
	// Position of GPIO27_LEVEL_HIGH field.
	IO_BANK0_INTR3_GPIO27_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO27_LEVEL_HIGH field.
	IO_BANK0_INTR3_GPIO27_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO27_LEVEL_HIGH.
	IO_BANK0_INTR3_GPIO27_LEVEL_HIGH = 0x2000
	// Position of GPIO27_LEVEL_LOW field.
	IO_BANK0_INTR3_GPIO27_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO27_LEVEL_LOW field.
	IO_BANK0_INTR3_GPIO27_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO27_LEVEL_LOW.
	IO_BANK0_INTR3_GPIO27_LEVEL_LOW = 0x1000
	// Position of GPIO26_EDGE_HIGH field.
	IO_BANK0_INTR3_GPIO26_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO26_EDGE_HIGH field.
	IO_BANK0_INTR3_GPIO26_EDGE_HIGH_Msk = 0x800
	// Bit GPIO26_EDGE_HIGH.
	IO_BANK0_INTR3_GPIO26_EDGE_HIGH = 0x800
	// Position of GPIO26_EDGE_LOW field.
	IO_BANK0_INTR3_GPIO26_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO26_EDGE_LOW field.
	IO_BANK0_INTR3_GPIO26_EDGE_LOW_Msk = 0x400
	// Bit GPIO26_EDGE_LOW.
	IO_BANK0_INTR3_GPIO26_EDGE_LOW = 0x400
	// Position of GPIO26_LEVEL_HIGH field.
	IO_BANK0_INTR3_GPIO26_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO26_LEVEL_HIGH field.
	IO_BANK0_INTR3_GPIO26_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO26_LEVEL_HIGH.
	IO_BANK0_INTR3_GPIO26_LEVEL_HIGH = 0x200
	// Position of GPIO26_LEVEL_LOW field.
	IO_BANK0_INTR3_GPIO26_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO26_LEVEL_LOW field.
	IO_BANK0_INTR3_GPIO26_LEVEL_LOW_Msk = 0x100
	// Bit GPIO26_LEVEL_LOW.
	IO_BANK0_INTR3_GPIO26_LEVEL_LOW = 0x100
	// Position of GPIO25_EDGE_HIGH field.
	IO_BANK0_INTR3_GPIO25_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO25_EDGE_HIGH field.
	IO_BANK0_INTR3_GPIO25_EDGE_HIGH_Msk = 0x80
	// Bit GPIO25_EDGE_HIGH.
	IO_BANK0_INTR3_GPIO25_EDGE_HIGH = 0x80
	// Position of GPIO25_EDGE_LOW field.
	IO_BANK0_INTR3_GPIO25_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO25_EDGE_LOW field.
	IO_BANK0_INTR3_GPIO25_EDGE_LOW_Msk = 0x40
	// Bit GPIO25_EDGE_LOW.
	IO_BANK0_INTR3_GPIO25_EDGE_LOW = 0x40
	// Position of GPIO25_LEVEL_HIGH field.
	IO_BANK0_INTR3_GPIO25_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO25_LEVEL_HIGH field.
	IO_BANK0_INTR3_GPIO25_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO25_LEVEL_HIGH.
	IO_BANK0_INTR3_GPIO25_LEVEL_HIGH = 0x20
	// Position of GPIO25_LEVEL_LOW field.
	IO_BANK0_INTR3_GPIO25_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO25_LEVEL_LOW field.
	IO_BANK0_INTR3_GPIO25_LEVEL_LOW_Msk = 0x10
	// Bit GPIO25_LEVEL_LOW.
	IO_BANK0_INTR3_GPIO25_LEVEL_LOW = 0x10
	// Position of GPIO24_EDGE_HIGH field.
	IO_BANK0_INTR3_GPIO24_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO24_EDGE_HIGH field.
	IO_BANK0_INTR3_GPIO24_EDGE_HIGH_Msk = 0x8
	// Bit GPIO24_EDGE_HIGH.
	IO_BANK0_INTR3_GPIO24_EDGE_HIGH = 0x8
	// Position of GPIO24_EDGE_LOW field.
	IO_BANK0_INTR3_GPIO24_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO24_EDGE_LOW field.
	IO_BANK0_INTR3_GPIO24_EDGE_LOW_Msk = 0x4
	// Bit GPIO24_EDGE_LOW.
	IO_BANK0_INTR3_GPIO24_EDGE_LOW = 0x4
	// Position of GPIO24_LEVEL_HIGH field.
	IO_BANK0_INTR3_GPIO24_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO24_LEVEL_HIGH field.
	IO_BANK0_INTR3_GPIO24_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO24_LEVEL_HIGH.
	IO_BANK0_INTR3_GPIO24_LEVEL_HIGH = 0x2
	// Position of GPIO24_LEVEL_LOW field.
	IO_BANK0_INTR3_GPIO24_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO24_LEVEL_LOW field.
	IO_BANK0_INTR3_GPIO24_LEVEL_LOW_Msk = 0x1
	// Bit GPIO24_LEVEL_LOW.
	IO_BANK0_INTR3_GPIO24_LEVEL_LOW = 0x1

	// PROC0_INTE0: Interrupt Enable for proc0
	// Position of GPIO7_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO7_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO7_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO7_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO7_EDGE_HIGH.
	IO_BANK0_PROC0_INTE0_GPIO7_EDGE_HIGH = 0x80000000
	// Position of GPIO7_EDGE_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO7_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO7_EDGE_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO7_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO7_EDGE_LOW.
	IO_BANK0_PROC0_INTE0_GPIO7_EDGE_LOW = 0x40000000
	// Position of GPIO7_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO7_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO7_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO7_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO7_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE0_GPIO7_LEVEL_HIGH = 0x20000000
	// Position of GPIO7_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO7_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO7_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO7_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO7_LEVEL_LOW.
	IO_BANK0_PROC0_INTE0_GPIO7_LEVEL_LOW = 0x10000000
	// Position of GPIO6_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO6_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO6_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO6_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO6_EDGE_HIGH.
	IO_BANK0_PROC0_INTE0_GPIO6_EDGE_HIGH = 0x8000000
	// Position of GPIO6_EDGE_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO6_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO6_EDGE_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO6_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO6_EDGE_LOW.
	IO_BANK0_PROC0_INTE0_GPIO6_EDGE_LOW = 0x4000000
	// Position of GPIO6_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO6_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO6_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO6_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO6_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE0_GPIO6_LEVEL_HIGH = 0x2000000
	// Position of GPIO6_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO6_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO6_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO6_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO6_LEVEL_LOW.
	IO_BANK0_PROC0_INTE0_GPIO6_LEVEL_LOW = 0x1000000
	// Position of GPIO5_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO5_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO5_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO5_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO5_EDGE_HIGH.
	IO_BANK0_PROC0_INTE0_GPIO5_EDGE_HIGH = 0x800000
	// Position of GPIO5_EDGE_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO5_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO5_EDGE_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO5_EDGE_LOW_Msk = 0x400000
	// Bit GPIO5_EDGE_LOW.
	IO_BANK0_PROC0_INTE0_GPIO5_EDGE_LOW = 0x400000
	// Position of GPIO5_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO5_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO5_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO5_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO5_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE0_GPIO5_LEVEL_HIGH = 0x200000
	// Position of GPIO5_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO5_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO5_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO5_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO5_LEVEL_LOW.
	IO_BANK0_PROC0_INTE0_GPIO5_LEVEL_LOW = 0x100000
	// Position of GPIO4_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO4_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO4_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO4_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO4_EDGE_HIGH.
	IO_BANK0_PROC0_INTE0_GPIO4_EDGE_HIGH = 0x80000
	// Position of GPIO4_EDGE_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO4_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO4_EDGE_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO4_EDGE_LOW_Msk = 0x40000
	// Bit GPIO4_EDGE_LOW.
	IO_BANK0_PROC0_INTE0_GPIO4_EDGE_LOW = 0x40000
	// Position of GPIO4_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO4_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO4_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO4_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO4_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE0_GPIO4_LEVEL_HIGH = 0x20000
	// Position of GPIO4_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO4_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO4_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO4_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO4_LEVEL_LOW.
	IO_BANK0_PROC0_INTE0_GPIO4_LEVEL_LOW = 0x10000
	// Position of GPIO3_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO3_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO3_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO3_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO3_EDGE_HIGH.
	IO_BANK0_PROC0_INTE0_GPIO3_EDGE_HIGH = 0x8000
	// Position of GPIO3_EDGE_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO3_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO3_EDGE_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO3_EDGE_LOW_Msk = 0x4000
	// Bit GPIO3_EDGE_LOW.
	IO_BANK0_PROC0_INTE0_GPIO3_EDGE_LOW = 0x4000
	// Position of GPIO3_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO3_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO3_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO3_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO3_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE0_GPIO3_LEVEL_HIGH = 0x2000
	// Position of GPIO3_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO3_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO3_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO3_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO3_LEVEL_LOW.
	IO_BANK0_PROC0_INTE0_GPIO3_LEVEL_LOW = 0x1000
	// Position of GPIO2_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO2_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO2_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO2_EDGE_HIGH_Msk = 0x800
	// Bit GPIO2_EDGE_HIGH.
	IO_BANK0_PROC0_INTE0_GPIO2_EDGE_HIGH = 0x800
	// Position of GPIO2_EDGE_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO2_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO2_EDGE_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO2_EDGE_LOW_Msk = 0x400
	// Bit GPIO2_EDGE_LOW.
	IO_BANK0_PROC0_INTE0_GPIO2_EDGE_LOW = 0x400
	// Position of GPIO2_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO2_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO2_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO2_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO2_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE0_GPIO2_LEVEL_HIGH = 0x200
	// Position of GPIO2_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO2_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO2_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO2_LEVEL_LOW_Msk = 0x100
	// Bit GPIO2_LEVEL_LOW.
	IO_BANK0_PROC0_INTE0_GPIO2_LEVEL_LOW = 0x100
	// Position of GPIO1_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO1_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO1_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO1_EDGE_HIGH_Msk = 0x80
	// Bit GPIO1_EDGE_HIGH.
	IO_BANK0_PROC0_INTE0_GPIO1_EDGE_HIGH = 0x80
	// Position of GPIO1_EDGE_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO1_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO1_EDGE_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO1_EDGE_LOW_Msk = 0x40
	// Bit GPIO1_EDGE_LOW.
	IO_BANK0_PROC0_INTE0_GPIO1_EDGE_LOW = 0x40
	// Position of GPIO1_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO1_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO1_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO1_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO1_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE0_GPIO1_LEVEL_HIGH = 0x20
	// Position of GPIO1_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO1_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO1_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO1_LEVEL_LOW_Msk = 0x10
	// Bit GPIO1_LEVEL_LOW.
	IO_BANK0_PROC0_INTE0_GPIO1_LEVEL_LOW = 0x10
	// Position of GPIO0_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO0_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO0_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO0_EDGE_HIGH_Msk = 0x8
	// Bit GPIO0_EDGE_HIGH.
	IO_BANK0_PROC0_INTE0_GPIO0_EDGE_HIGH = 0x8
	// Position of GPIO0_EDGE_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO0_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO0_EDGE_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO0_EDGE_LOW_Msk = 0x4
	// Bit GPIO0_EDGE_LOW.
	IO_BANK0_PROC0_INTE0_GPIO0_EDGE_LOW = 0x4
	// Position of GPIO0_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO0_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO0_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE0_GPIO0_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO0_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE0_GPIO0_LEVEL_HIGH = 0x2
	// Position of GPIO0_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO0_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO0_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE0_GPIO0_LEVEL_LOW_Msk = 0x1
	// Bit GPIO0_LEVEL_LOW.
	IO_BANK0_PROC0_INTE0_GPIO0_LEVEL_LOW = 0x1

	// PROC0_INTE1: Interrupt Enable for proc0
	// Position of GPIO15_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO15_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO15_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO15_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO15_EDGE_HIGH.
	IO_BANK0_PROC0_INTE1_GPIO15_EDGE_HIGH = 0x80000000
	// Position of GPIO15_EDGE_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO15_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO15_EDGE_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO15_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO15_EDGE_LOW.
	IO_BANK0_PROC0_INTE1_GPIO15_EDGE_LOW = 0x40000000
	// Position of GPIO15_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO15_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO15_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO15_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO15_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE1_GPIO15_LEVEL_HIGH = 0x20000000
	// Position of GPIO15_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO15_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO15_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO15_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO15_LEVEL_LOW.
	IO_BANK0_PROC0_INTE1_GPIO15_LEVEL_LOW = 0x10000000
	// Position of GPIO14_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO14_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO14_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO14_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO14_EDGE_HIGH.
	IO_BANK0_PROC0_INTE1_GPIO14_EDGE_HIGH = 0x8000000
	// Position of GPIO14_EDGE_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO14_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO14_EDGE_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO14_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO14_EDGE_LOW.
	IO_BANK0_PROC0_INTE1_GPIO14_EDGE_LOW = 0x4000000
	// Position of GPIO14_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO14_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO14_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO14_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO14_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE1_GPIO14_LEVEL_HIGH = 0x2000000
	// Position of GPIO14_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO14_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO14_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO14_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO14_LEVEL_LOW.
	IO_BANK0_PROC0_INTE1_GPIO14_LEVEL_LOW = 0x1000000
	// Position of GPIO13_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO13_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO13_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO13_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO13_EDGE_HIGH.
	IO_BANK0_PROC0_INTE1_GPIO13_EDGE_HIGH = 0x800000
	// Position of GPIO13_EDGE_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO13_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO13_EDGE_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO13_EDGE_LOW_Msk = 0x400000
	// Bit GPIO13_EDGE_LOW.
	IO_BANK0_PROC0_INTE1_GPIO13_EDGE_LOW = 0x400000
	// Position of GPIO13_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO13_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO13_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO13_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO13_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE1_GPIO13_LEVEL_HIGH = 0x200000
	// Position of GPIO13_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO13_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO13_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO13_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO13_LEVEL_LOW.
	IO_BANK0_PROC0_INTE1_GPIO13_LEVEL_LOW = 0x100000
	// Position of GPIO12_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO12_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO12_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO12_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO12_EDGE_HIGH.
	IO_BANK0_PROC0_INTE1_GPIO12_EDGE_HIGH = 0x80000
	// Position of GPIO12_EDGE_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO12_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO12_EDGE_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO12_EDGE_LOW_Msk = 0x40000
	// Bit GPIO12_EDGE_LOW.
	IO_BANK0_PROC0_INTE1_GPIO12_EDGE_LOW = 0x40000
	// Position of GPIO12_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO12_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO12_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO12_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO12_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE1_GPIO12_LEVEL_HIGH = 0x20000
	// Position of GPIO12_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO12_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO12_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO12_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO12_LEVEL_LOW.
	IO_BANK0_PROC0_INTE1_GPIO12_LEVEL_LOW = 0x10000
	// Position of GPIO11_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO11_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO11_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO11_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO11_EDGE_HIGH.
	IO_BANK0_PROC0_INTE1_GPIO11_EDGE_HIGH = 0x8000
	// Position of GPIO11_EDGE_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO11_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO11_EDGE_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO11_EDGE_LOW_Msk = 0x4000
	// Bit GPIO11_EDGE_LOW.
	IO_BANK0_PROC0_INTE1_GPIO11_EDGE_LOW = 0x4000
	// Position of GPIO11_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO11_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO11_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO11_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO11_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE1_GPIO11_LEVEL_HIGH = 0x2000
	// Position of GPIO11_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO11_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO11_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO11_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO11_LEVEL_LOW.
	IO_BANK0_PROC0_INTE1_GPIO11_LEVEL_LOW = 0x1000
	// Position of GPIO10_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO10_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO10_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO10_EDGE_HIGH_Msk = 0x800
	// Bit GPIO10_EDGE_HIGH.
	IO_BANK0_PROC0_INTE1_GPIO10_EDGE_HIGH = 0x800
	// Position of GPIO10_EDGE_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO10_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO10_EDGE_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO10_EDGE_LOW_Msk = 0x400
	// Bit GPIO10_EDGE_LOW.
	IO_BANK0_PROC0_INTE1_GPIO10_EDGE_LOW = 0x400
	// Position of GPIO10_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO10_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO10_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO10_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO10_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE1_GPIO10_LEVEL_HIGH = 0x200
	// Position of GPIO10_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO10_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO10_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO10_LEVEL_LOW_Msk = 0x100
	// Bit GPIO10_LEVEL_LOW.
	IO_BANK0_PROC0_INTE1_GPIO10_LEVEL_LOW = 0x100
	// Position of GPIO9_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO9_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO9_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO9_EDGE_HIGH_Msk = 0x80
	// Bit GPIO9_EDGE_HIGH.
	IO_BANK0_PROC0_INTE1_GPIO9_EDGE_HIGH = 0x80
	// Position of GPIO9_EDGE_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO9_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO9_EDGE_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO9_EDGE_LOW_Msk = 0x40
	// Bit GPIO9_EDGE_LOW.
	IO_BANK0_PROC0_INTE1_GPIO9_EDGE_LOW = 0x40
	// Position of GPIO9_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO9_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO9_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO9_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO9_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE1_GPIO9_LEVEL_HIGH = 0x20
	// Position of GPIO9_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO9_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO9_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO9_LEVEL_LOW_Msk = 0x10
	// Bit GPIO9_LEVEL_LOW.
	IO_BANK0_PROC0_INTE1_GPIO9_LEVEL_LOW = 0x10
	// Position of GPIO8_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO8_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO8_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO8_EDGE_HIGH_Msk = 0x8
	// Bit GPIO8_EDGE_HIGH.
	IO_BANK0_PROC0_INTE1_GPIO8_EDGE_HIGH = 0x8
	// Position of GPIO8_EDGE_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO8_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO8_EDGE_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO8_EDGE_LOW_Msk = 0x4
	// Bit GPIO8_EDGE_LOW.
	IO_BANK0_PROC0_INTE1_GPIO8_EDGE_LOW = 0x4
	// Position of GPIO8_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO8_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO8_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE1_GPIO8_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO8_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE1_GPIO8_LEVEL_HIGH = 0x2
	// Position of GPIO8_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO8_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO8_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE1_GPIO8_LEVEL_LOW_Msk = 0x1
	// Bit GPIO8_LEVEL_LOW.
	IO_BANK0_PROC0_INTE1_GPIO8_LEVEL_LOW = 0x1

	// PROC0_INTE2: Interrupt Enable for proc0
	// Position of GPIO23_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO23_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO23_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO23_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO23_EDGE_HIGH.
	IO_BANK0_PROC0_INTE2_GPIO23_EDGE_HIGH = 0x80000000
	// Position of GPIO23_EDGE_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO23_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO23_EDGE_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO23_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO23_EDGE_LOW.
	IO_BANK0_PROC0_INTE2_GPIO23_EDGE_LOW = 0x40000000
	// Position of GPIO23_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO23_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO23_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO23_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO23_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE2_GPIO23_LEVEL_HIGH = 0x20000000
	// Position of GPIO23_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO23_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO23_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO23_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO23_LEVEL_LOW.
	IO_BANK0_PROC0_INTE2_GPIO23_LEVEL_LOW = 0x10000000
	// Position of GPIO22_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO22_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO22_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO22_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO22_EDGE_HIGH.
	IO_BANK0_PROC0_INTE2_GPIO22_EDGE_HIGH = 0x8000000
	// Position of GPIO22_EDGE_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO22_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO22_EDGE_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO22_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO22_EDGE_LOW.
	IO_BANK0_PROC0_INTE2_GPIO22_EDGE_LOW = 0x4000000
	// Position of GPIO22_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO22_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO22_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO22_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO22_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE2_GPIO22_LEVEL_HIGH = 0x2000000
	// Position of GPIO22_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO22_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO22_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO22_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO22_LEVEL_LOW.
	IO_BANK0_PROC0_INTE2_GPIO22_LEVEL_LOW = 0x1000000
	// Position of GPIO21_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO21_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO21_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO21_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO21_EDGE_HIGH.
	IO_BANK0_PROC0_INTE2_GPIO21_EDGE_HIGH = 0x800000
	// Position of GPIO21_EDGE_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO21_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO21_EDGE_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO21_EDGE_LOW_Msk = 0x400000
	// Bit GPIO21_EDGE_LOW.
	IO_BANK0_PROC0_INTE2_GPIO21_EDGE_LOW = 0x400000
	// Position of GPIO21_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO21_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO21_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO21_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO21_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE2_GPIO21_LEVEL_HIGH = 0x200000
	// Position of GPIO21_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO21_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO21_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO21_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO21_LEVEL_LOW.
	IO_BANK0_PROC0_INTE2_GPIO21_LEVEL_LOW = 0x100000
	// Position of GPIO20_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO20_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO20_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO20_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO20_EDGE_HIGH.
	IO_BANK0_PROC0_INTE2_GPIO20_EDGE_HIGH = 0x80000
	// Position of GPIO20_EDGE_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO20_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO20_EDGE_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO20_EDGE_LOW_Msk = 0x40000
	// Bit GPIO20_EDGE_LOW.
	IO_BANK0_PROC0_INTE2_GPIO20_EDGE_LOW = 0x40000
	// Position of GPIO20_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO20_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO20_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO20_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO20_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE2_GPIO20_LEVEL_HIGH = 0x20000
	// Position of GPIO20_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO20_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO20_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO20_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO20_LEVEL_LOW.
	IO_BANK0_PROC0_INTE2_GPIO20_LEVEL_LOW = 0x10000
	// Position of GPIO19_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO19_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO19_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO19_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO19_EDGE_HIGH.
	IO_BANK0_PROC0_INTE2_GPIO19_EDGE_HIGH = 0x8000
	// Position of GPIO19_EDGE_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO19_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO19_EDGE_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO19_EDGE_LOW_Msk = 0x4000
	// Bit GPIO19_EDGE_LOW.
	IO_BANK0_PROC0_INTE2_GPIO19_EDGE_LOW = 0x4000
	// Position of GPIO19_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO19_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO19_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO19_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO19_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE2_GPIO19_LEVEL_HIGH = 0x2000
	// Position of GPIO19_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO19_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO19_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO19_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO19_LEVEL_LOW.
	IO_BANK0_PROC0_INTE2_GPIO19_LEVEL_LOW = 0x1000
	// Position of GPIO18_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO18_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO18_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO18_EDGE_HIGH_Msk = 0x800
	// Bit GPIO18_EDGE_HIGH.
	IO_BANK0_PROC0_INTE2_GPIO18_EDGE_HIGH = 0x800
	// Position of GPIO18_EDGE_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO18_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO18_EDGE_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO18_EDGE_LOW_Msk = 0x400
	// Bit GPIO18_EDGE_LOW.
	IO_BANK0_PROC0_INTE2_GPIO18_EDGE_LOW = 0x400
	// Position of GPIO18_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO18_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO18_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO18_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO18_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE2_GPIO18_LEVEL_HIGH = 0x200
	// Position of GPIO18_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO18_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO18_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO18_LEVEL_LOW_Msk = 0x100
	// Bit GPIO18_LEVEL_LOW.
	IO_BANK0_PROC0_INTE2_GPIO18_LEVEL_LOW = 0x100
	// Position of GPIO17_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO17_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO17_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO17_EDGE_HIGH_Msk = 0x80
	// Bit GPIO17_EDGE_HIGH.
	IO_BANK0_PROC0_INTE2_GPIO17_EDGE_HIGH = 0x80
	// Position of GPIO17_EDGE_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO17_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO17_EDGE_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO17_EDGE_LOW_Msk = 0x40
	// Bit GPIO17_EDGE_LOW.
	IO_BANK0_PROC0_INTE2_GPIO17_EDGE_LOW = 0x40
	// Position of GPIO17_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO17_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO17_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO17_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO17_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE2_GPIO17_LEVEL_HIGH = 0x20
	// Position of GPIO17_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO17_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO17_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO17_LEVEL_LOW_Msk = 0x10
	// Bit GPIO17_LEVEL_LOW.
	IO_BANK0_PROC0_INTE2_GPIO17_LEVEL_LOW = 0x10
	// Position of GPIO16_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO16_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO16_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO16_EDGE_HIGH_Msk = 0x8
	// Bit GPIO16_EDGE_HIGH.
	IO_BANK0_PROC0_INTE2_GPIO16_EDGE_HIGH = 0x8
	// Position of GPIO16_EDGE_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO16_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO16_EDGE_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO16_EDGE_LOW_Msk = 0x4
	// Bit GPIO16_EDGE_LOW.
	IO_BANK0_PROC0_INTE2_GPIO16_EDGE_LOW = 0x4
	// Position of GPIO16_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO16_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO16_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE2_GPIO16_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO16_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE2_GPIO16_LEVEL_HIGH = 0x2
	// Position of GPIO16_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO16_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO16_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE2_GPIO16_LEVEL_LOW_Msk = 0x1
	// Bit GPIO16_LEVEL_LOW.
	IO_BANK0_PROC0_INTE2_GPIO16_LEVEL_LOW = 0x1

	// PROC0_INTE3: Interrupt Enable for proc0
	// Position of GPIO29_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO29_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO29_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO29_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO29_EDGE_HIGH.
	IO_BANK0_PROC0_INTE3_GPIO29_EDGE_HIGH = 0x800000
	// Position of GPIO29_EDGE_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO29_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO29_EDGE_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO29_EDGE_LOW_Msk = 0x400000
	// Bit GPIO29_EDGE_LOW.
	IO_BANK0_PROC0_INTE3_GPIO29_EDGE_LOW = 0x400000
	// Position of GPIO29_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO29_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO29_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO29_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO29_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE3_GPIO29_LEVEL_HIGH = 0x200000
	// Position of GPIO29_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO29_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO29_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO29_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO29_LEVEL_LOW.
	IO_BANK0_PROC0_INTE3_GPIO29_LEVEL_LOW = 0x100000
	// Position of GPIO28_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO28_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO28_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO28_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO28_EDGE_HIGH.
	IO_BANK0_PROC0_INTE3_GPIO28_EDGE_HIGH = 0x80000
	// Position of GPIO28_EDGE_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO28_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO28_EDGE_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO28_EDGE_LOW_Msk = 0x40000
	// Bit GPIO28_EDGE_LOW.
	IO_BANK0_PROC0_INTE3_GPIO28_EDGE_LOW = 0x40000
	// Position of GPIO28_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO28_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO28_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO28_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO28_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE3_GPIO28_LEVEL_HIGH = 0x20000
	// Position of GPIO28_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO28_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO28_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO28_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO28_LEVEL_LOW.
	IO_BANK0_PROC0_INTE3_GPIO28_LEVEL_LOW = 0x10000
	// Position of GPIO27_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO27_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO27_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO27_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO27_EDGE_HIGH.
	IO_BANK0_PROC0_INTE3_GPIO27_EDGE_HIGH = 0x8000
	// Position of GPIO27_EDGE_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO27_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO27_EDGE_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO27_EDGE_LOW_Msk = 0x4000
	// Bit GPIO27_EDGE_LOW.
	IO_BANK0_PROC0_INTE3_GPIO27_EDGE_LOW = 0x4000
	// Position of GPIO27_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO27_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO27_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO27_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO27_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE3_GPIO27_LEVEL_HIGH = 0x2000
	// Position of GPIO27_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO27_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO27_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO27_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO27_LEVEL_LOW.
	IO_BANK0_PROC0_INTE3_GPIO27_LEVEL_LOW = 0x1000
	// Position of GPIO26_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO26_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO26_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO26_EDGE_HIGH_Msk = 0x800
	// Bit GPIO26_EDGE_HIGH.
	IO_BANK0_PROC0_INTE3_GPIO26_EDGE_HIGH = 0x800
	// Position of GPIO26_EDGE_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO26_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO26_EDGE_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO26_EDGE_LOW_Msk = 0x400
	// Bit GPIO26_EDGE_LOW.
	IO_BANK0_PROC0_INTE3_GPIO26_EDGE_LOW = 0x400
	// Position of GPIO26_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO26_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO26_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO26_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO26_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE3_GPIO26_LEVEL_HIGH = 0x200
	// Position of GPIO26_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO26_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO26_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO26_LEVEL_LOW_Msk = 0x100
	// Bit GPIO26_LEVEL_LOW.
	IO_BANK0_PROC0_INTE3_GPIO26_LEVEL_LOW = 0x100
	// Position of GPIO25_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO25_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO25_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO25_EDGE_HIGH_Msk = 0x80
	// Bit GPIO25_EDGE_HIGH.
	IO_BANK0_PROC0_INTE3_GPIO25_EDGE_HIGH = 0x80
	// Position of GPIO25_EDGE_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO25_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO25_EDGE_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO25_EDGE_LOW_Msk = 0x40
	// Bit GPIO25_EDGE_LOW.
	IO_BANK0_PROC0_INTE3_GPIO25_EDGE_LOW = 0x40
	// Position of GPIO25_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO25_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO25_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO25_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO25_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE3_GPIO25_LEVEL_HIGH = 0x20
	// Position of GPIO25_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO25_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO25_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO25_LEVEL_LOW_Msk = 0x10
	// Bit GPIO25_LEVEL_LOW.
	IO_BANK0_PROC0_INTE3_GPIO25_LEVEL_LOW = 0x10
	// Position of GPIO24_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO24_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO24_EDGE_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO24_EDGE_HIGH_Msk = 0x8
	// Bit GPIO24_EDGE_HIGH.
	IO_BANK0_PROC0_INTE3_GPIO24_EDGE_HIGH = 0x8
	// Position of GPIO24_EDGE_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO24_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO24_EDGE_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO24_EDGE_LOW_Msk = 0x4
	// Bit GPIO24_EDGE_LOW.
	IO_BANK0_PROC0_INTE3_GPIO24_EDGE_LOW = 0x4
	// Position of GPIO24_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO24_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO24_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTE3_GPIO24_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO24_LEVEL_HIGH.
	IO_BANK0_PROC0_INTE3_GPIO24_LEVEL_HIGH = 0x2
	// Position of GPIO24_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO24_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO24_LEVEL_LOW field.
	IO_BANK0_PROC0_INTE3_GPIO24_LEVEL_LOW_Msk = 0x1
	// Bit GPIO24_LEVEL_LOW.
	IO_BANK0_PROC0_INTE3_GPIO24_LEVEL_LOW = 0x1

	// PROC0_INTF0: Interrupt Force for proc0
	// Position of GPIO7_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO7_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO7_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO7_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO7_EDGE_HIGH.
	IO_BANK0_PROC0_INTF0_GPIO7_EDGE_HIGH = 0x80000000
	// Position of GPIO7_EDGE_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO7_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO7_EDGE_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO7_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO7_EDGE_LOW.
	IO_BANK0_PROC0_INTF0_GPIO7_EDGE_LOW = 0x40000000
	// Position of GPIO7_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO7_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO7_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO7_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO7_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF0_GPIO7_LEVEL_HIGH = 0x20000000
	// Position of GPIO7_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO7_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO7_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO7_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO7_LEVEL_LOW.
	IO_BANK0_PROC0_INTF0_GPIO7_LEVEL_LOW = 0x10000000
	// Position of GPIO6_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO6_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO6_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO6_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO6_EDGE_HIGH.
	IO_BANK0_PROC0_INTF0_GPIO6_EDGE_HIGH = 0x8000000
	// Position of GPIO6_EDGE_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO6_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO6_EDGE_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO6_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO6_EDGE_LOW.
	IO_BANK0_PROC0_INTF0_GPIO6_EDGE_LOW = 0x4000000
	// Position of GPIO6_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO6_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO6_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO6_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO6_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF0_GPIO6_LEVEL_HIGH = 0x2000000
	// Position of GPIO6_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO6_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO6_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO6_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO6_LEVEL_LOW.
	IO_BANK0_PROC0_INTF0_GPIO6_LEVEL_LOW = 0x1000000
	// Position of GPIO5_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO5_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO5_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO5_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO5_EDGE_HIGH.
	IO_BANK0_PROC0_INTF0_GPIO5_EDGE_HIGH = 0x800000
	// Position of GPIO5_EDGE_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO5_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO5_EDGE_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO5_EDGE_LOW_Msk = 0x400000
	// Bit GPIO5_EDGE_LOW.
	IO_BANK0_PROC0_INTF0_GPIO5_EDGE_LOW = 0x400000
	// Position of GPIO5_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO5_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO5_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO5_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO5_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF0_GPIO5_LEVEL_HIGH = 0x200000
	// Position of GPIO5_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO5_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO5_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO5_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO5_LEVEL_LOW.
	IO_BANK0_PROC0_INTF0_GPIO5_LEVEL_LOW = 0x100000
	// Position of GPIO4_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO4_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO4_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO4_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO4_EDGE_HIGH.
	IO_BANK0_PROC0_INTF0_GPIO4_EDGE_HIGH = 0x80000
	// Position of GPIO4_EDGE_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO4_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO4_EDGE_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO4_EDGE_LOW_Msk = 0x40000
	// Bit GPIO4_EDGE_LOW.
	IO_BANK0_PROC0_INTF0_GPIO4_EDGE_LOW = 0x40000
	// Position of GPIO4_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO4_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO4_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO4_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO4_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF0_GPIO4_LEVEL_HIGH = 0x20000
	// Position of GPIO4_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO4_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO4_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO4_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO4_LEVEL_LOW.
	IO_BANK0_PROC0_INTF0_GPIO4_LEVEL_LOW = 0x10000
	// Position of GPIO3_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO3_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO3_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO3_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO3_EDGE_HIGH.
	IO_BANK0_PROC0_INTF0_GPIO3_EDGE_HIGH = 0x8000
	// Position of GPIO3_EDGE_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO3_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO3_EDGE_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO3_EDGE_LOW_Msk = 0x4000
	// Bit GPIO3_EDGE_LOW.
	IO_BANK0_PROC0_INTF0_GPIO3_EDGE_LOW = 0x4000
	// Position of GPIO3_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO3_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO3_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO3_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO3_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF0_GPIO3_LEVEL_HIGH = 0x2000
	// Position of GPIO3_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO3_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO3_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO3_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO3_LEVEL_LOW.
	IO_BANK0_PROC0_INTF0_GPIO3_LEVEL_LOW = 0x1000
	// Position of GPIO2_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO2_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO2_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO2_EDGE_HIGH_Msk = 0x800
	// Bit GPIO2_EDGE_HIGH.
	IO_BANK0_PROC0_INTF0_GPIO2_EDGE_HIGH = 0x800
	// Position of GPIO2_EDGE_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO2_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO2_EDGE_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO2_EDGE_LOW_Msk = 0x400
	// Bit GPIO2_EDGE_LOW.
	IO_BANK0_PROC0_INTF0_GPIO2_EDGE_LOW = 0x400
	// Position of GPIO2_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO2_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO2_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO2_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO2_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF0_GPIO2_LEVEL_HIGH = 0x200
	// Position of GPIO2_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO2_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO2_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO2_LEVEL_LOW_Msk = 0x100
	// Bit GPIO2_LEVEL_LOW.
	IO_BANK0_PROC0_INTF0_GPIO2_LEVEL_LOW = 0x100
	// Position of GPIO1_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO1_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO1_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO1_EDGE_HIGH_Msk = 0x80
	// Bit GPIO1_EDGE_HIGH.
	IO_BANK0_PROC0_INTF0_GPIO1_EDGE_HIGH = 0x80
	// Position of GPIO1_EDGE_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO1_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO1_EDGE_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO1_EDGE_LOW_Msk = 0x40
	// Bit GPIO1_EDGE_LOW.
	IO_BANK0_PROC0_INTF0_GPIO1_EDGE_LOW = 0x40
	// Position of GPIO1_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO1_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO1_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO1_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO1_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF0_GPIO1_LEVEL_HIGH = 0x20
	// Position of GPIO1_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO1_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO1_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO1_LEVEL_LOW_Msk = 0x10
	// Bit GPIO1_LEVEL_LOW.
	IO_BANK0_PROC0_INTF0_GPIO1_LEVEL_LOW = 0x10
	// Position of GPIO0_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO0_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO0_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO0_EDGE_HIGH_Msk = 0x8
	// Bit GPIO0_EDGE_HIGH.
	IO_BANK0_PROC0_INTF0_GPIO0_EDGE_HIGH = 0x8
	// Position of GPIO0_EDGE_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO0_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO0_EDGE_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO0_EDGE_LOW_Msk = 0x4
	// Bit GPIO0_EDGE_LOW.
	IO_BANK0_PROC0_INTF0_GPIO0_EDGE_LOW = 0x4
	// Position of GPIO0_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO0_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO0_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF0_GPIO0_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO0_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF0_GPIO0_LEVEL_HIGH = 0x2
	// Position of GPIO0_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO0_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO0_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF0_GPIO0_LEVEL_LOW_Msk = 0x1
	// Bit GPIO0_LEVEL_LOW.
	IO_BANK0_PROC0_INTF0_GPIO0_LEVEL_LOW = 0x1

	// PROC0_INTF1: Interrupt Force for proc0
	// Position of GPIO15_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO15_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO15_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO15_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO15_EDGE_HIGH.
	IO_BANK0_PROC0_INTF1_GPIO15_EDGE_HIGH = 0x80000000
	// Position of GPIO15_EDGE_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO15_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO15_EDGE_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO15_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO15_EDGE_LOW.
	IO_BANK0_PROC0_INTF1_GPIO15_EDGE_LOW = 0x40000000
	// Position of GPIO15_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO15_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO15_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO15_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO15_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF1_GPIO15_LEVEL_HIGH = 0x20000000
	// Position of GPIO15_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO15_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO15_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO15_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO15_LEVEL_LOW.
	IO_BANK0_PROC0_INTF1_GPIO15_LEVEL_LOW = 0x10000000
	// Position of GPIO14_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO14_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO14_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO14_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO14_EDGE_HIGH.
	IO_BANK0_PROC0_INTF1_GPIO14_EDGE_HIGH = 0x8000000
	// Position of GPIO14_EDGE_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO14_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO14_EDGE_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO14_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO14_EDGE_LOW.
	IO_BANK0_PROC0_INTF1_GPIO14_EDGE_LOW = 0x4000000
	// Position of GPIO14_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO14_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO14_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO14_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO14_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF1_GPIO14_LEVEL_HIGH = 0x2000000
	// Position of GPIO14_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO14_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO14_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO14_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO14_LEVEL_LOW.
	IO_BANK0_PROC0_INTF1_GPIO14_LEVEL_LOW = 0x1000000
	// Position of GPIO13_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO13_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO13_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO13_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO13_EDGE_HIGH.
	IO_BANK0_PROC0_INTF1_GPIO13_EDGE_HIGH = 0x800000
	// Position of GPIO13_EDGE_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO13_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO13_EDGE_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO13_EDGE_LOW_Msk = 0x400000
	// Bit GPIO13_EDGE_LOW.
	IO_BANK0_PROC0_INTF1_GPIO13_EDGE_LOW = 0x400000
	// Position of GPIO13_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO13_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO13_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO13_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO13_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF1_GPIO13_LEVEL_HIGH = 0x200000
	// Position of GPIO13_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO13_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO13_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO13_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO13_LEVEL_LOW.
	IO_BANK0_PROC0_INTF1_GPIO13_LEVEL_LOW = 0x100000
	// Position of GPIO12_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO12_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO12_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO12_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO12_EDGE_HIGH.
	IO_BANK0_PROC0_INTF1_GPIO12_EDGE_HIGH = 0x80000
	// Position of GPIO12_EDGE_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO12_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO12_EDGE_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO12_EDGE_LOW_Msk = 0x40000
	// Bit GPIO12_EDGE_LOW.
	IO_BANK0_PROC0_INTF1_GPIO12_EDGE_LOW = 0x40000
	// Position of GPIO12_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO12_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO12_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO12_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO12_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF1_GPIO12_LEVEL_HIGH = 0x20000
	// Position of GPIO12_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO12_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO12_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO12_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO12_LEVEL_LOW.
	IO_BANK0_PROC0_INTF1_GPIO12_LEVEL_LOW = 0x10000
	// Position of GPIO11_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO11_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO11_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO11_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO11_EDGE_HIGH.
	IO_BANK0_PROC0_INTF1_GPIO11_EDGE_HIGH = 0x8000
	// Position of GPIO11_EDGE_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO11_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO11_EDGE_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO11_EDGE_LOW_Msk = 0x4000
	// Bit GPIO11_EDGE_LOW.
	IO_BANK0_PROC0_INTF1_GPIO11_EDGE_LOW = 0x4000
	// Position of GPIO11_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO11_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO11_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO11_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO11_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF1_GPIO11_LEVEL_HIGH = 0x2000
	// Position of GPIO11_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO11_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO11_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO11_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO11_LEVEL_LOW.
	IO_BANK0_PROC0_INTF1_GPIO11_LEVEL_LOW = 0x1000
	// Position of GPIO10_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO10_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO10_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO10_EDGE_HIGH_Msk = 0x800
	// Bit GPIO10_EDGE_HIGH.
	IO_BANK0_PROC0_INTF1_GPIO10_EDGE_HIGH = 0x800
	// Position of GPIO10_EDGE_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO10_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO10_EDGE_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO10_EDGE_LOW_Msk = 0x400
	// Bit GPIO10_EDGE_LOW.
	IO_BANK0_PROC0_INTF1_GPIO10_EDGE_LOW = 0x400
	// Position of GPIO10_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO10_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO10_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO10_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO10_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF1_GPIO10_LEVEL_HIGH = 0x200
	// Position of GPIO10_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO10_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO10_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO10_LEVEL_LOW_Msk = 0x100
	// Bit GPIO10_LEVEL_LOW.
	IO_BANK0_PROC0_INTF1_GPIO10_LEVEL_LOW = 0x100
	// Position of GPIO9_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO9_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO9_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO9_EDGE_HIGH_Msk = 0x80
	// Bit GPIO9_EDGE_HIGH.
	IO_BANK0_PROC0_INTF1_GPIO9_EDGE_HIGH = 0x80
	// Position of GPIO9_EDGE_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO9_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO9_EDGE_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO9_EDGE_LOW_Msk = 0x40
	// Bit GPIO9_EDGE_LOW.
	IO_BANK0_PROC0_INTF1_GPIO9_EDGE_LOW = 0x40
	// Position of GPIO9_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO9_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO9_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO9_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO9_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF1_GPIO9_LEVEL_HIGH = 0x20
	// Position of GPIO9_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO9_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO9_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO9_LEVEL_LOW_Msk = 0x10
	// Bit GPIO9_LEVEL_LOW.
	IO_BANK0_PROC0_INTF1_GPIO9_LEVEL_LOW = 0x10
	// Position of GPIO8_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO8_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO8_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO8_EDGE_HIGH_Msk = 0x8
	// Bit GPIO8_EDGE_HIGH.
	IO_BANK0_PROC0_INTF1_GPIO8_EDGE_HIGH = 0x8
	// Position of GPIO8_EDGE_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO8_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO8_EDGE_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO8_EDGE_LOW_Msk = 0x4
	// Bit GPIO8_EDGE_LOW.
	IO_BANK0_PROC0_INTF1_GPIO8_EDGE_LOW = 0x4
	// Position of GPIO8_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO8_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO8_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF1_GPIO8_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO8_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF1_GPIO8_LEVEL_HIGH = 0x2
	// Position of GPIO8_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO8_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO8_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF1_GPIO8_LEVEL_LOW_Msk = 0x1
	// Bit GPIO8_LEVEL_LOW.
	IO_BANK0_PROC0_INTF1_GPIO8_LEVEL_LOW = 0x1

	// PROC0_INTF2: Interrupt Force for proc0
	// Position of GPIO23_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO23_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO23_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO23_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO23_EDGE_HIGH.
	IO_BANK0_PROC0_INTF2_GPIO23_EDGE_HIGH = 0x80000000
	// Position of GPIO23_EDGE_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO23_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO23_EDGE_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO23_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO23_EDGE_LOW.
	IO_BANK0_PROC0_INTF2_GPIO23_EDGE_LOW = 0x40000000
	// Position of GPIO23_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO23_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO23_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO23_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO23_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF2_GPIO23_LEVEL_HIGH = 0x20000000
	// Position of GPIO23_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO23_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO23_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO23_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO23_LEVEL_LOW.
	IO_BANK0_PROC0_INTF2_GPIO23_LEVEL_LOW = 0x10000000
	// Position of GPIO22_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO22_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO22_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO22_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO22_EDGE_HIGH.
	IO_BANK0_PROC0_INTF2_GPIO22_EDGE_HIGH = 0x8000000
	// Position of GPIO22_EDGE_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO22_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO22_EDGE_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO22_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO22_EDGE_LOW.
	IO_BANK0_PROC0_INTF2_GPIO22_EDGE_LOW = 0x4000000
	// Position of GPIO22_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO22_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO22_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO22_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO22_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF2_GPIO22_LEVEL_HIGH = 0x2000000
	// Position of GPIO22_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO22_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO22_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO22_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO22_LEVEL_LOW.
	IO_BANK0_PROC0_INTF2_GPIO22_LEVEL_LOW = 0x1000000
	// Position of GPIO21_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO21_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO21_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO21_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO21_EDGE_HIGH.
	IO_BANK0_PROC0_INTF2_GPIO21_EDGE_HIGH = 0x800000
	// Position of GPIO21_EDGE_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO21_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO21_EDGE_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO21_EDGE_LOW_Msk = 0x400000
	// Bit GPIO21_EDGE_LOW.
	IO_BANK0_PROC0_INTF2_GPIO21_EDGE_LOW = 0x400000
	// Position of GPIO21_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO21_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO21_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO21_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO21_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF2_GPIO21_LEVEL_HIGH = 0x200000
	// Position of GPIO21_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO21_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO21_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO21_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO21_LEVEL_LOW.
	IO_BANK0_PROC0_INTF2_GPIO21_LEVEL_LOW = 0x100000
	// Position of GPIO20_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO20_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO20_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO20_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO20_EDGE_HIGH.
	IO_BANK0_PROC0_INTF2_GPIO20_EDGE_HIGH = 0x80000
	// Position of GPIO20_EDGE_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO20_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO20_EDGE_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO20_EDGE_LOW_Msk = 0x40000
	// Bit GPIO20_EDGE_LOW.
	IO_BANK0_PROC0_INTF2_GPIO20_EDGE_LOW = 0x40000
	// Position of GPIO20_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO20_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO20_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO20_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO20_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF2_GPIO20_LEVEL_HIGH = 0x20000
	// Position of GPIO20_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO20_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO20_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO20_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO20_LEVEL_LOW.
	IO_BANK0_PROC0_INTF2_GPIO20_LEVEL_LOW = 0x10000
	// Position of GPIO19_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO19_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO19_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO19_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO19_EDGE_HIGH.
	IO_BANK0_PROC0_INTF2_GPIO19_EDGE_HIGH = 0x8000
	// Position of GPIO19_EDGE_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO19_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO19_EDGE_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO19_EDGE_LOW_Msk = 0x4000
	// Bit GPIO19_EDGE_LOW.
	IO_BANK0_PROC0_INTF2_GPIO19_EDGE_LOW = 0x4000
	// Position of GPIO19_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO19_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO19_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO19_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO19_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF2_GPIO19_LEVEL_HIGH = 0x2000
	// Position of GPIO19_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO19_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO19_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO19_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO19_LEVEL_LOW.
	IO_BANK0_PROC0_INTF2_GPIO19_LEVEL_LOW = 0x1000
	// Position of GPIO18_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO18_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO18_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO18_EDGE_HIGH_Msk = 0x800
	// Bit GPIO18_EDGE_HIGH.
	IO_BANK0_PROC0_INTF2_GPIO18_EDGE_HIGH = 0x800
	// Position of GPIO18_EDGE_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO18_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO18_EDGE_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO18_EDGE_LOW_Msk = 0x400
	// Bit GPIO18_EDGE_LOW.
	IO_BANK0_PROC0_INTF2_GPIO18_EDGE_LOW = 0x400
	// Position of GPIO18_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO18_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO18_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO18_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO18_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF2_GPIO18_LEVEL_HIGH = 0x200
	// Position of GPIO18_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO18_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO18_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO18_LEVEL_LOW_Msk = 0x100
	// Bit GPIO18_LEVEL_LOW.
	IO_BANK0_PROC0_INTF2_GPIO18_LEVEL_LOW = 0x100
	// Position of GPIO17_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO17_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO17_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO17_EDGE_HIGH_Msk = 0x80
	// Bit GPIO17_EDGE_HIGH.
	IO_BANK0_PROC0_INTF2_GPIO17_EDGE_HIGH = 0x80
	// Position of GPIO17_EDGE_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO17_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO17_EDGE_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO17_EDGE_LOW_Msk = 0x40
	// Bit GPIO17_EDGE_LOW.
	IO_BANK0_PROC0_INTF2_GPIO17_EDGE_LOW = 0x40
	// Position of GPIO17_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO17_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO17_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO17_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO17_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF2_GPIO17_LEVEL_HIGH = 0x20
	// Position of GPIO17_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO17_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO17_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO17_LEVEL_LOW_Msk = 0x10
	// Bit GPIO17_LEVEL_LOW.
	IO_BANK0_PROC0_INTF2_GPIO17_LEVEL_LOW = 0x10
	// Position of GPIO16_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO16_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO16_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO16_EDGE_HIGH_Msk = 0x8
	// Bit GPIO16_EDGE_HIGH.
	IO_BANK0_PROC0_INTF2_GPIO16_EDGE_HIGH = 0x8
	// Position of GPIO16_EDGE_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO16_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO16_EDGE_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO16_EDGE_LOW_Msk = 0x4
	// Bit GPIO16_EDGE_LOW.
	IO_BANK0_PROC0_INTF2_GPIO16_EDGE_LOW = 0x4
	// Position of GPIO16_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO16_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO16_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF2_GPIO16_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO16_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF2_GPIO16_LEVEL_HIGH = 0x2
	// Position of GPIO16_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO16_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO16_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF2_GPIO16_LEVEL_LOW_Msk = 0x1
	// Bit GPIO16_LEVEL_LOW.
	IO_BANK0_PROC0_INTF2_GPIO16_LEVEL_LOW = 0x1

	// PROC0_INTF3: Interrupt Force for proc0
	// Position of GPIO29_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO29_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO29_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO29_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO29_EDGE_HIGH.
	IO_BANK0_PROC0_INTF3_GPIO29_EDGE_HIGH = 0x800000
	// Position of GPIO29_EDGE_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO29_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO29_EDGE_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO29_EDGE_LOW_Msk = 0x400000
	// Bit GPIO29_EDGE_LOW.
	IO_BANK0_PROC0_INTF3_GPIO29_EDGE_LOW = 0x400000
	// Position of GPIO29_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO29_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO29_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO29_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO29_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF3_GPIO29_LEVEL_HIGH = 0x200000
	// Position of GPIO29_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO29_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO29_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO29_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO29_LEVEL_LOW.
	IO_BANK0_PROC0_INTF3_GPIO29_LEVEL_LOW = 0x100000
	// Position of GPIO28_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO28_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO28_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO28_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO28_EDGE_HIGH.
	IO_BANK0_PROC0_INTF3_GPIO28_EDGE_HIGH = 0x80000
	// Position of GPIO28_EDGE_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO28_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO28_EDGE_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO28_EDGE_LOW_Msk = 0x40000
	// Bit GPIO28_EDGE_LOW.
	IO_BANK0_PROC0_INTF3_GPIO28_EDGE_LOW = 0x40000
	// Position of GPIO28_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO28_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO28_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO28_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO28_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF3_GPIO28_LEVEL_HIGH = 0x20000
	// Position of GPIO28_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO28_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO28_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO28_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO28_LEVEL_LOW.
	IO_BANK0_PROC0_INTF3_GPIO28_LEVEL_LOW = 0x10000
	// Position of GPIO27_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO27_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO27_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO27_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO27_EDGE_HIGH.
	IO_BANK0_PROC0_INTF3_GPIO27_EDGE_HIGH = 0x8000
	// Position of GPIO27_EDGE_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO27_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO27_EDGE_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO27_EDGE_LOW_Msk = 0x4000
	// Bit GPIO27_EDGE_LOW.
	IO_BANK0_PROC0_INTF3_GPIO27_EDGE_LOW = 0x4000
	// Position of GPIO27_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO27_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO27_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO27_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO27_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF3_GPIO27_LEVEL_HIGH = 0x2000
	// Position of GPIO27_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO27_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO27_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO27_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO27_LEVEL_LOW.
	IO_BANK0_PROC0_INTF3_GPIO27_LEVEL_LOW = 0x1000
	// Position of GPIO26_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO26_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO26_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO26_EDGE_HIGH_Msk = 0x800
	// Bit GPIO26_EDGE_HIGH.
	IO_BANK0_PROC0_INTF3_GPIO26_EDGE_HIGH = 0x800
	// Position of GPIO26_EDGE_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO26_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO26_EDGE_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO26_EDGE_LOW_Msk = 0x400
	// Bit GPIO26_EDGE_LOW.
	IO_BANK0_PROC0_INTF3_GPIO26_EDGE_LOW = 0x400
	// Position of GPIO26_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO26_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO26_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO26_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO26_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF3_GPIO26_LEVEL_HIGH = 0x200
	// Position of GPIO26_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO26_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO26_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO26_LEVEL_LOW_Msk = 0x100
	// Bit GPIO26_LEVEL_LOW.
	IO_BANK0_PROC0_INTF3_GPIO26_LEVEL_LOW = 0x100
	// Position of GPIO25_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO25_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO25_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO25_EDGE_HIGH_Msk = 0x80
	// Bit GPIO25_EDGE_HIGH.
	IO_BANK0_PROC0_INTF3_GPIO25_EDGE_HIGH = 0x80
	// Position of GPIO25_EDGE_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO25_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO25_EDGE_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO25_EDGE_LOW_Msk = 0x40
	// Bit GPIO25_EDGE_LOW.
	IO_BANK0_PROC0_INTF3_GPIO25_EDGE_LOW = 0x40
	// Position of GPIO25_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO25_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO25_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO25_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO25_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF3_GPIO25_LEVEL_HIGH = 0x20
	// Position of GPIO25_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO25_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO25_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO25_LEVEL_LOW_Msk = 0x10
	// Bit GPIO25_LEVEL_LOW.
	IO_BANK0_PROC0_INTF3_GPIO25_LEVEL_LOW = 0x10
	// Position of GPIO24_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO24_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO24_EDGE_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO24_EDGE_HIGH_Msk = 0x8
	// Bit GPIO24_EDGE_HIGH.
	IO_BANK0_PROC0_INTF3_GPIO24_EDGE_HIGH = 0x8
	// Position of GPIO24_EDGE_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO24_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO24_EDGE_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO24_EDGE_LOW_Msk = 0x4
	// Bit GPIO24_EDGE_LOW.
	IO_BANK0_PROC0_INTF3_GPIO24_EDGE_LOW = 0x4
	// Position of GPIO24_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO24_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO24_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTF3_GPIO24_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO24_LEVEL_HIGH.
	IO_BANK0_PROC0_INTF3_GPIO24_LEVEL_HIGH = 0x2
	// Position of GPIO24_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO24_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO24_LEVEL_LOW field.
	IO_BANK0_PROC0_INTF3_GPIO24_LEVEL_LOW_Msk = 0x1
	// Bit GPIO24_LEVEL_LOW.
	IO_BANK0_PROC0_INTF3_GPIO24_LEVEL_LOW = 0x1

	// PROC0_INTS0: Interrupt status after masking & forcing for proc0
	// Position of GPIO7_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO7_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO7_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO7_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO7_EDGE_HIGH.
	IO_BANK0_PROC0_INTS0_GPIO7_EDGE_HIGH = 0x80000000
	// Position of GPIO7_EDGE_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO7_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO7_EDGE_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO7_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO7_EDGE_LOW.
	IO_BANK0_PROC0_INTS0_GPIO7_EDGE_LOW = 0x40000000
	// Position of GPIO7_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO7_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO7_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO7_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO7_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS0_GPIO7_LEVEL_HIGH = 0x20000000
	// Position of GPIO7_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO7_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO7_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO7_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO7_LEVEL_LOW.
	IO_BANK0_PROC0_INTS0_GPIO7_LEVEL_LOW = 0x10000000
	// Position of GPIO6_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO6_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO6_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO6_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO6_EDGE_HIGH.
	IO_BANK0_PROC0_INTS0_GPIO6_EDGE_HIGH = 0x8000000
	// Position of GPIO6_EDGE_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO6_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO6_EDGE_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO6_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO6_EDGE_LOW.
	IO_BANK0_PROC0_INTS0_GPIO6_EDGE_LOW = 0x4000000
	// Position of GPIO6_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO6_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO6_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO6_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO6_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS0_GPIO6_LEVEL_HIGH = 0x2000000
	// Position of GPIO6_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO6_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO6_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO6_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO6_LEVEL_LOW.
	IO_BANK0_PROC0_INTS0_GPIO6_LEVEL_LOW = 0x1000000
	// Position of GPIO5_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO5_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO5_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO5_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO5_EDGE_HIGH.
	IO_BANK0_PROC0_INTS0_GPIO5_EDGE_HIGH = 0x800000
	// Position of GPIO5_EDGE_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO5_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO5_EDGE_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO5_EDGE_LOW_Msk = 0x400000
	// Bit GPIO5_EDGE_LOW.
	IO_BANK0_PROC0_INTS0_GPIO5_EDGE_LOW = 0x400000
	// Position of GPIO5_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO5_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO5_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO5_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO5_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS0_GPIO5_LEVEL_HIGH = 0x200000
	// Position of GPIO5_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO5_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO5_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO5_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO5_LEVEL_LOW.
	IO_BANK0_PROC0_INTS0_GPIO5_LEVEL_LOW = 0x100000
	// Position of GPIO4_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO4_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO4_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO4_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO4_EDGE_HIGH.
	IO_BANK0_PROC0_INTS0_GPIO4_EDGE_HIGH = 0x80000
	// Position of GPIO4_EDGE_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO4_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO4_EDGE_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO4_EDGE_LOW_Msk = 0x40000
	// Bit GPIO4_EDGE_LOW.
	IO_BANK0_PROC0_INTS0_GPIO4_EDGE_LOW = 0x40000
	// Position of GPIO4_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO4_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO4_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO4_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO4_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS0_GPIO4_LEVEL_HIGH = 0x20000
	// Position of GPIO4_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO4_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO4_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO4_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO4_LEVEL_LOW.
	IO_BANK0_PROC0_INTS0_GPIO4_LEVEL_LOW = 0x10000
	// Position of GPIO3_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO3_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO3_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO3_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO3_EDGE_HIGH.
	IO_BANK0_PROC0_INTS0_GPIO3_EDGE_HIGH = 0x8000
	// Position of GPIO3_EDGE_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO3_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO3_EDGE_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO3_EDGE_LOW_Msk = 0x4000
	// Bit GPIO3_EDGE_LOW.
	IO_BANK0_PROC0_INTS0_GPIO3_EDGE_LOW = 0x4000
	// Position of GPIO3_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO3_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO3_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO3_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO3_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS0_GPIO3_LEVEL_HIGH = 0x2000
	// Position of GPIO3_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO3_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO3_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO3_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO3_LEVEL_LOW.
	IO_BANK0_PROC0_INTS0_GPIO3_LEVEL_LOW = 0x1000
	// Position of GPIO2_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO2_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO2_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO2_EDGE_HIGH_Msk = 0x800
	// Bit GPIO2_EDGE_HIGH.
	IO_BANK0_PROC0_INTS0_GPIO2_EDGE_HIGH = 0x800
	// Position of GPIO2_EDGE_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO2_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO2_EDGE_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO2_EDGE_LOW_Msk = 0x400
	// Bit GPIO2_EDGE_LOW.
	IO_BANK0_PROC0_INTS0_GPIO2_EDGE_LOW = 0x400
	// Position of GPIO2_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO2_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO2_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO2_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO2_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS0_GPIO2_LEVEL_HIGH = 0x200
	// Position of GPIO2_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO2_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO2_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO2_LEVEL_LOW_Msk = 0x100
	// Bit GPIO2_LEVEL_LOW.
	IO_BANK0_PROC0_INTS0_GPIO2_LEVEL_LOW = 0x100
	// Position of GPIO1_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO1_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO1_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO1_EDGE_HIGH_Msk = 0x80
	// Bit GPIO1_EDGE_HIGH.
	IO_BANK0_PROC0_INTS0_GPIO1_EDGE_HIGH = 0x80
	// Position of GPIO1_EDGE_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO1_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO1_EDGE_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO1_EDGE_LOW_Msk = 0x40
	// Bit GPIO1_EDGE_LOW.
	IO_BANK0_PROC0_INTS0_GPIO1_EDGE_LOW = 0x40
	// Position of GPIO1_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO1_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO1_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO1_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO1_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS0_GPIO1_LEVEL_HIGH = 0x20
	// Position of GPIO1_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO1_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO1_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO1_LEVEL_LOW_Msk = 0x10
	// Bit GPIO1_LEVEL_LOW.
	IO_BANK0_PROC0_INTS0_GPIO1_LEVEL_LOW = 0x10
	// Position of GPIO0_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO0_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO0_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO0_EDGE_HIGH_Msk = 0x8
	// Bit GPIO0_EDGE_HIGH.
	IO_BANK0_PROC0_INTS0_GPIO0_EDGE_HIGH = 0x8
	// Position of GPIO0_EDGE_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO0_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO0_EDGE_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO0_EDGE_LOW_Msk = 0x4
	// Bit GPIO0_EDGE_LOW.
	IO_BANK0_PROC0_INTS0_GPIO0_EDGE_LOW = 0x4
	// Position of GPIO0_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO0_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO0_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS0_GPIO0_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO0_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS0_GPIO0_LEVEL_HIGH = 0x2
	// Position of GPIO0_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO0_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO0_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS0_GPIO0_LEVEL_LOW_Msk = 0x1
	// Bit GPIO0_LEVEL_LOW.
	IO_BANK0_PROC0_INTS0_GPIO0_LEVEL_LOW = 0x1

	// PROC0_INTS1: Interrupt status after masking & forcing for proc0
	// Position of GPIO15_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO15_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO15_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO15_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO15_EDGE_HIGH.
	IO_BANK0_PROC0_INTS1_GPIO15_EDGE_HIGH = 0x80000000
	// Position of GPIO15_EDGE_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO15_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO15_EDGE_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO15_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO15_EDGE_LOW.
	IO_BANK0_PROC0_INTS1_GPIO15_EDGE_LOW = 0x40000000
	// Position of GPIO15_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO15_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO15_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO15_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO15_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS1_GPIO15_LEVEL_HIGH = 0x20000000
	// Position of GPIO15_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO15_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO15_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO15_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO15_LEVEL_LOW.
	IO_BANK0_PROC0_INTS1_GPIO15_LEVEL_LOW = 0x10000000
	// Position of GPIO14_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO14_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO14_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO14_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO14_EDGE_HIGH.
	IO_BANK0_PROC0_INTS1_GPIO14_EDGE_HIGH = 0x8000000
	// Position of GPIO14_EDGE_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO14_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO14_EDGE_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO14_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO14_EDGE_LOW.
	IO_BANK0_PROC0_INTS1_GPIO14_EDGE_LOW = 0x4000000
	// Position of GPIO14_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO14_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO14_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO14_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO14_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS1_GPIO14_LEVEL_HIGH = 0x2000000
	// Position of GPIO14_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO14_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO14_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO14_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO14_LEVEL_LOW.
	IO_BANK0_PROC0_INTS1_GPIO14_LEVEL_LOW = 0x1000000
	// Position of GPIO13_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO13_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO13_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO13_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO13_EDGE_HIGH.
	IO_BANK0_PROC0_INTS1_GPIO13_EDGE_HIGH = 0x800000
	// Position of GPIO13_EDGE_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO13_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO13_EDGE_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO13_EDGE_LOW_Msk = 0x400000
	// Bit GPIO13_EDGE_LOW.
	IO_BANK0_PROC0_INTS1_GPIO13_EDGE_LOW = 0x400000
	// Position of GPIO13_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO13_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO13_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO13_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO13_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS1_GPIO13_LEVEL_HIGH = 0x200000
	// Position of GPIO13_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO13_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO13_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO13_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO13_LEVEL_LOW.
	IO_BANK0_PROC0_INTS1_GPIO13_LEVEL_LOW = 0x100000
	// Position of GPIO12_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO12_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO12_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO12_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO12_EDGE_HIGH.
	IO_BANK0_PROC0_INTS1_GPIO12_EDGE_HIGH = 0x80000
	// Position of GPIO12_EDGE_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO12_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO12_EDGE_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO12_EDGE_LOW_Msk = 0x40000
	// Bit GPIO12_EDGE_LOW.
	IO_BANK0_PROC0_INTS1_GPIO12_EDGE_LOW = 0x40000
	// Position of GPIO12_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO12_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO12_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO12_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO12_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS1_GPIO12_LEVEL_HIGH = 0x20000
	// Position of GPIO12_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO12_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO12_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO12_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO12_LEVEL_LOW.
	IO_BANK0_PROC0_INTS1_GPIO12_LEVEL_LOW = 0x10000
	// Position of GPIO11_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO11_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO11_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO11_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO11_EDGE_HIGH.
	IO_BANK0_PROC0_INTS1_GPIO11_EDGE_HIGH = 0x8000
	// Position of GPIO11_EDGE_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO11_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO11_EDGE_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO11_EDGE_LOW_Msk = 0x4000
	// Bit GPIO11_EDGE_LOW.
	IO_BANK0_PROC0_INTS1_GPIO11_EDGE_LOW = 0x4000
	// Position of GPIO11_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO11_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO11_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO11_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO11_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS1_GPIO11_LEVEL_HIGH = 0x2000
	// Position of GPIO11_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO11_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO11_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO11_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO11_LEVEL_LOW.
	IO_BANK0_PROC0_INTS1_GPIO11_LEVEL_LOW = 0x1000
	// Position of GPIO10_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO10_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO10_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO10_EDGE_HIGH_Msk = 0x800
	// Bit GPIO10_EDGE_HIGH.
	IO_BANK0_PROC0_INTS1_GPIO10_EDGE_HIGH = 0x800
	// Position of GPIO10_EDGE_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO10_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO10_EDGE_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO10_EDGE_LOW_Msk = 0x400
	// Bit GPIO10_EDGE_LOW.
	IO_BANK0_PROC0_INTS1_GPIO10_EDGE_LOW = 0x400
	// Position of GPIO10_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO10_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO10_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO10_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO10_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS1_GPIO10_LEVEL_HIGH = 0x200
	// Position of GPIO10_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO10_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO10_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO10_LEVEL_LOW_Msk = 0x100
	// Bit GPIO10_LEVEL_LOW.
	IO_BANK0_PROC0_INTS1_GPIO10_LEVEL_LOW = 0x100
	// Position of GPIO9_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO9_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO9_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO9_EDGE_HIGH_Msk = 0x80
	// Bit GPIO9_EDGE_HIGH.
	IO_BANK0_PROC0_INTS1_GPIO9_EDGE_HIGH = 0x80
	// Position of GPIO9_EDGE_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO9_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO9_EDGE_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO9_EDGE_LOW_Msk = 0x40
	// Bit GPIO9_EDGE_LOW.
	IO_BANK0_PROC0_INTS1_GPIO9_EDGE_LOW = 0x40
	// Position of GPIO9_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO9_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO9_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO9_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO9_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS1_GPIO9_LEVEL_HIGH = 0x20
	// Position of GPIO9_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO9_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO9_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO9_LEVEL_LOW_Msk = 0x10
	// Bit GPIO9_LEVEL_LOW.
	IO_BANK0_PROC0_INTS1_GPIO9_LEVEL_LOW = 0x10
	// Position of GPIO8_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO8_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO8_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO8_EDGE_HIGH_Msk = 0x8
	// Bit GPIO8_EDGE_HIGH.
	IO_BANK0_PROC0_INTS1_GPIO8_EDGE_HIGH = 0x8
	// Position of GPIO8_EDGE_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO8_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO8_EDGE_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO8_EDGE_LOW_Msk = 0x4
	// Bit GPIO8_EDGE_LOW.
	IO_BANK0_PROC0_INTS1_GPIO8_EDGE_LOW = 0x4
	// Position of GPIO8_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO8_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO8_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS1_GPIO8_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO8_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS1_GPIO8_LEVEL_HIGH = 0x2
	// Position of GPIO8_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO8_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO8_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS1_GPIO8_LEVEL_LOW_Msk = 0x1
	// Bit GPIO8_LEVEL_LOW.
	IO_BANK0_PROC0_INTS1_GPIO8_LEVEL_LOW = 0x1

	// PROC0_INTS2: Interrupt status after masking & forcing for proc0
	// Position of GPIO23_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO23_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO23_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO23_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO23_EDGE_HIGH.
	IO_BANK0_PROC0_INTS2_GPIO23_EDGE_HIGH = 0x80000000
	// Position of GPIO23_EDGE_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO23_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO23_EDGE_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO23_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO23_EDGE_LOW.
	IO_BANK0_PROC0_INTS2_GPIO23_EDGE_LOW = 0x40000000
	// Position of GPIO23_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO23_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO23_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO23_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO23_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS2_GPIO23_LEVEL_HIGH = 0x20000000
	// Position of GPIO23_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO23_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO23_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO23_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO23_LEVEL_LOW.
	IO_BANK0_PROC0_INTS2_GPIO23_LEVEL_LOW = 0x10000000
	// Position of GPIO22_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO22_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO22_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO22_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO22_EDGE_HIGH.
	IO_BANK0_PROC0_INTS2_GPIO22_EDGE_HIGH = 0x8000000
	// Position of GPIO22_EDGE_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO22_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO22_EDGE_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO22_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO22_EDGE_LOW.
	IO_BANK0_PROC0_INTS2_GPIO22_EDGE_LOW = 0x4000000
	// Position of GPIO22_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO22_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO22_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO22_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO22_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS2_GPIO22_LEVEL_HIGH = 0x2000000
	// Position of GPIO22_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO22_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO22_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO22_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO22_LEVEL_LOW.
	IO_BANK0_PROC0_INTS2_GPIO22_LEVEL_LOW = 0x1000000
	// Position of GPIO21_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO21_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO21_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO21_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO21_EDGE_HIGH.
	IO_BANK0_PROC0_INTS2_GPIO21_EDGE_HIGH = 0x800000
	// Position of GPIO21_EDGE_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO21_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO21_EDGE_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO21_EDGE_LOW_Msk = 0x400000
	// Bit GPIO21_EDGE_LOW.
	IO_BANK0_PROC0_INTS2_GPIO21_EDGE_LOW = 0x400000
	// Position of GPIO21_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO21_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO21_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO21_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO21_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS2_GPIO21_LEVEL_HIGH = 0x200000
	// Position of GPIO21_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO21_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO21_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO21_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO21_LEVEL_LOW.
	IO_BANK0_PROC0_INTS2_GPIO21_LEVEL_LOW = 0x100000
	// Position of GPIO20_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO20_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO20_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO20_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO20_EDGE_HIGH.
	IO_BANK0_PROC0_INTS2_GPIO20_EDGE_HIGH = 0x80000
	// Position of GPIO20_EDGE_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO20_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO20_EDGE_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO20_EDGE_LOW_Msk = 0x40000
	// Bit GPIO20_EDGE_LOW.
	IO_BANK0_PROC0_INTS2_GPIO20_EDGE_LOW = 0x40000
	// Position of GPIO20_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO20_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO20_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO20_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO20_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS2_GPIO20_LEVEL_HIGH = 0x20000
	// Position of GPIO20_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO20_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO20_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO20_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO20_LEVEL_LOW.
	IO_BANK0_PROC0_INTS2_GPIO20_LEVEL_LOW = 0x10000
	// Position of GPIO19_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO19_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO19_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO19_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO19_EDGE_HIGH.
	IO_BANK0_PROC0_INTS2_GPIO19_EDGE_HIGH = 0x8000
	// Position of GPIO19_EDGE_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO19_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO19_EDGE_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO19_EDGE_LOW_Msk = 0x4000
	// Bit GPIO19_EDGE_LOW.
	IO_BANK0_PROC0_INTS2_GPIO19_EDGE_LOW = 0x4000
	// Position of GPIO19_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO19_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO19_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO19_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO19_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS2_GPIO19_LEVEL_HIGH = 0x2000
	// Position of GPIO19_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO19_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO19_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO19_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO19_LEVEL_LOW.
	IO_BANK0_PROC0_INTS2_GPIO19_LEVEL_LOW = 0x1000
	// Position of GPIO18_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO18_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO18_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO18_EDGE_HIGH_Msk = 0x800
	// Bit GPIO18_EDGE_HIGH.
	IO_BANK0_PROC0_INTS2_GPIO18_EDGE_HIGH = 0x800
	// Position of GPIO18_EDGE_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO18_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO18_EDGE_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO18_EDGE_LOW_Msk = 0x400
	// Bit GPIO18_EDGE_LOW.
	IO_BANK0_PROC0_INTS2_GPIO18_EDGE_LOW = 0x400
	// Position of GPIO18_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO18_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO18_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO18_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO18_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS2_GPIO18_LEVEL_HIGH = 0x200
	// Position of GPIO18_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO18_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO18_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO18_LEVEL_LOW_Msk = 0x100
	// Bit GPIO18_LEVEL_LOW.
	IO_BANK0_PROC0_INTS2_GPIO18_LEVEL_LOW = 0x100
	// Position of GPIO17_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO17_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO17_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO17_EDGE_HIGH_Msk = 0x80
	// Bit GPIO17_EDGE_HIGH.
	IO_BANK0_PROC0_INTS2_GPIO17_EDGE_HIGH = 0x80
	// Position of GPIO17_EDGE_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO17_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO17_EDGE_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO17_EDGE_LOW_Msk = 0x40
	// Bit GPIO17_EDGE_LOW.
	IO_BANK0_PROC0_INTS2_GPIO17_EDGE_LOW = 0x40
	// Position of GPIO17_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO17_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO17_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO17_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO17_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS2_GPIO17_LEVEL_HIGH = 0x20
	// Position of GPIO17_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO17_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO17_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO17_LEVEL_LOW_Msk = 0x10
	// Bit GPIO17_LEVEL_LOW.
	IO_BANK0_PROC0_INTS2_GPIO17_LEVEL_LOW = 0x10
	// Position of GPIO16_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO16_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO16_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO16_EDGE_HIGH_Msk = 0x8
	// Bit GPIO16_EDGE_HIGH.
	IO_BANK0_PROC0_INTS2_GPIO16_EDGE_HIGH = 0x8
	// Position of GPIO16_EDGE_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO16_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO16_EDGE_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO16_EDGE_LOW_Msk = 0x4
	// Bit GPIO16_EDGE_LOW.
	IO_BANK0_PROC0_INTS2_GPIO16_EDGE_LOW = 0x4
	// Position of GPIO16_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO16_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO16_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS2_GPIO16_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO16_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS2_GPIO16_LEVEL_HIGH = 0x2
	// Position of GPIO16_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO16_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO16_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS2_GPIO16_LEVEL_LOW_Msk = 0x1
	// Bit GPIO16_LEVEL_LOW.
	IO_BANK0_PROC0_INTS2_GPIO16_LEVEL_LOW = 0x1

	// PROC0_INTS3: Interrupt status after masking & forcing for proc0
	// Position of GPIO29_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO29_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO29_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO29_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO29_EDGE_HIGH.
	IO_BANK0_PROC0_INTS3_GPIO29_EDGE_HIGH = 0x800000
	// Position of GPIO29_EDGE_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO29_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO29_EDGE_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO29_EDGE_LOW_Msk = 0x400000
	// Bit GPIO29_EDGE_LOW.
	IO_BANK0_PROC0_INTS3_GPIO29_EDGE_LOW = 0x400000
	// Position of GPIO29_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO29_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO29_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO29_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO29_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS3_GPIO29_LEVEL_HIGH = 0x200000
	// Position of GPIO29_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO29_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO29_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO29_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO29_LEVEL_LOW.
	IO_BANK0_PROC0_INTS3_GPIO29_LEVEL_LOW = 0x100000
	// Position of GPIO28_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO28_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO28_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO28_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO28_EDGE_HIGH.
	IO_BANK0_PROC0_INTS3_GPIO28_EDGE_HIGH = 0x80000
	// Position of GPIO28_EDGE_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO28_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO28_EDGE_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO28_EDGE_LOW_Msk = 0x40000
	// Bit GPIO28_EDGE_LOW.
	IO_BANK0_PROC0_INTS3_GPIO28_EDGE_LOW = 0x40000
	// Position of GPIO28_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO28_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO28_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO28_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO28_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS3_GPIO28_LEVEL_HIGH = 0x20000
	// Position of GPIO28_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO28_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO28_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO28_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO28_LEVEL_LOW.
	IO_BANK0_PROC0_INTS3_GPIO28_LEVEL_LOW = 0x10000
	// Position of GPIO27_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO27_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO27_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO27_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO27_EDGE_HIGH.
	IO_BANK0_PROC0_INTS3_GPIO27_EDGE_HIGH = 0x8000
	// Position of GPIO27_EDGE_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO27_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO27_EDGE_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO27_EDGE_LOW_Msk = 0x4000
	// Bit GPIO27_EDGE_LOW.
	IO_BANK0_PROC0_INTS3_GPIO27_EDGE_LOW = 0x4000
	// Position of GPIO27_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO27_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO27_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO27_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO27_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS3_GPIO27_LEVEL_HIGH = 0x2000
	// Position of GPIO27_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO27_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO27_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO27_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO27_LEVEL_LOW.
	IO_BANK0_PROC0_INTS3_GPIO27_LEVEL_LOW = 0x1000
	// Position of GPIO26_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO26_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO26_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO26_EDGE_HIGH_Msk = 0x800
	// Bit GPIO26_EDGE_HIGH.
	IO_BANK0_PROC0_INTS3_GPIO26_EDGE_HIGH = 0x800
	// Position of GPIO26_EDGE_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO26_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO26_EDGE_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO26_EDGE_LOW_Msk = 0x400
	// Bit GPIO26_EDGE_LOW.
	IO_BANK0_PROC0_INTS3_GPIO26_EDGE_LOW = 0x400
	// Position of GPIO26_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO26_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO26_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO26_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO26_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS3_GPIO26_LEVEL_HIGH = 0x200
	// Position of GPIO26_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO26_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO26_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO26_LEVEL_LOW_Msk = 0x100
	// Bit GPIO26_LEVEL_LOW.
	IO_BANK0_PROC0_INTS3_GPIO26_LEVEL_LOW = 0x100
	// Position of GPIO25_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO25_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO25_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO25_EDGE_HIGH_Msk = 0x80
	// Bit GPIO25_EDGE_HIGH.
	IO_BANK0_PROC0_INTS3_GPIO25_EDGE_HIGH = 0x80
	// Position of GPIO25_EDGE_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO25_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO25_EDGE_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO25_EDGE_LOW_Msk = 0x40
	// Bit GPIO25_EDGE_LOW.
	IO_BANK0_PROC0_INTS3_GPIO25_EDGE_LOW = 0x40
	// Position of GPIO25_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO25_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO25_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO25_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO25_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS3_GPIO25_LEVEL_HIGH = 0x20
	// Position of GPIO25_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO25_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO25_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO25_LEVEL_LOW_Msk = 0x10
	// Bit GPIO25_LEVEL_LOW.
	IO_BANK0_PROC0_INTS3_GPIO25_LEVEL_LOW = 0x10
	// Position of GPIO24_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO24_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO24_EDGE_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO24_EDGE_HIGH_Msk = 0x8
	// Bit GPIO24_EDGE_HIGH.
	IO_BANK0_PROC0_INTS3_GPIO24_EDGE_HIGH = 0x8
	// Position of GPIO24_EDGE_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO24_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO24_EDGE_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO24_EDGE_LOW_Msk = 0x4
	// Bit GPIO24_EDGE_LOW.
	IO_BANK0_PROC0_INTS3_GPIO24_EDGE_LOW = 0x4
	// Position of GPIO24_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO24_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO24_LEVEL_HIGH field.
	IO_BANK0_PROC0_INTS3_GPIO24_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO24_LEVEL_HIGH.
	IO_BANK0_PROC0_INTS3_GPIO24_LEVEL_HIGH = 0x2
	// Position of GPIO24_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO24_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO24_LEVEL_LOW field.
	IO_BANK0_PROC0_INTS3_GPIO24_LEVEL_LOW_Msk = 0x1
	// Bit GPIO24_LEVEL_LOW.
	IO_BANK0_PROC0_INTS3_GPIO24_LEVEL_LOW = 0x1

	// PROC1_INTE0: Interrupt Enable for proc1
	// Position of GPIO7_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO7_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO7_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO7_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO7_EDGE_HIGH.
	IO_BANK0_PROC1_INTE0_GPIO7_EDGE_HIGH = 0x80000000
	// Position of GPIO7_EDGE_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO7_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO7_EDGE_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO7_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO7_EDGE_LOW.
	IO_BANK0_PROC1_INTE0_GPIO7_EDGE_LOW = 0x40000000
	// Position of GPIO7_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO7_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO7_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO7_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO7_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE0_GPIO7_LEVEL_HIGH = 0x20000000
	// Position of GPIO7_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO7_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO7_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO7_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO7_LEVEL_LOW.
	IO_BANK0_PROC1_INTE0_GPIO7_LEVEL_LOW = 0x10000000
	// Position of GPIO6_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO6_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO6_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO6_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO6_EDGE_HIGH.
	IO_BANK0_PROC1_INTE0_GPIO6_EDGE_HIGH = 0x8000000
	// Position of GPIO6_EDGE_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO6_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO6_EDGE_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO6_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO6_EDGE_LOW.
	IO_BANK0_PROC1_INTE0_GPIO6_EDGE_LOW = 0x4000000
	// Position of GPIO6_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO6_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO6_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO6_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO6_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE0_GPIO6_LEVEL_HIGH = 0x2000000
	// Position of GPIO6_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO6_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO6_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO6_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO6_LEVEL_LOW.
	IO_BANK0_PROC1_INTE0_GPIO6_LEVEL_LOW = 0x1000000
	// Position of GPIO5_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO5_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO5_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO5_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO5_EDGE_HIGH.
	IO_BANK0_PROC1_INTE0_GPIO5_EDGE_HIGH = 0x800000
	// Position of GPIO5_EDGE_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO5_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO5_EDGE_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO5_EDGE_LOW_Msk = 0x400000
	// Bit GPIO5_EDGE_LOW.
	IO_BANK0_PROC1_INTE0_GPIO5_EDGE_LOW = 0x400000
	// Position of GPIO5_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO5_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO5_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO5_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO5_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE0_GPIO5_LEVEL_HIGH = 0x200000
	// Position of GPIO5_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO5_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO5_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO5_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO5_LEVEL_LOW.
	IO_BANK0_PROC1_INTE0_GPIO5_LEVEL_LOW = 0x100000
	// Position of GPIO4_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO4_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO4_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO4_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO4_EDGE_HIGH.
	IO_BANK0_PROC1_INTE0_GPIO4_EDGE_HIGH = 0x80000
	// Position of GPIO4_EDGE_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO4_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO4_EDGE_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO4_EDGE_LOW_Msk = 0x40000
	// Bit GPIO4_EDGE_LOW.
	IO_BANK0_PROC1_INTE0_GPIO4_EDGE_LOW = 0x40000
	// Position of GPIO4_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO4_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO4_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO4_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO4_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE0_GPIO4_LEVEL_HIGH = 0x20000
	// Position of GPIO4_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO4_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO4_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO4_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO4_LEVEL_LOW.
	IO_BANK0_PROC1_INTE0_GPIO4_LEVEL_LOW = 0x10000
	// Position of GPIO3_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO3_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO3_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO3_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO3_EDGE_HIGH.
	IO_BANK0_PROC1_INTE0_GPIO3_EDGE_HIGH = 0x8000
	// Position of GPIO3_EDGE_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO3_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO3_EDGE_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO3_EDGE_LOW_Msk = 0x4000
	// Bit GPIO3_EDGE_LOW.
	IO_BANK0_PROC1_INTE0_GPIO3_EDGE_LOW = 0x4000
	// Position of GPIO3_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO3_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO3_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO3_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO3_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE0_GPIO3_LEVEL_HIGH = 0x2000
	// Position of GPIO3_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO3_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO3_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO3_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO3_LEVEL_LOW.
	IO_BANK0_PROC1_INTE0_GPIO3_LEVEL_LOW = 0x1000
	// Position of GPIO2_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO2_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO2_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO2_EDGE_HIGH_Msk = 0x800
	// Bit GPIO2_EDGE_HIGH.
	IO_BANK0_PROC1_INTE0_GPIO2_EDGE_HIGH = 0x800
	// Position of GPIO2_EDGE_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO2_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO2_EDGE_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO2_EDGE_LOW_Msk = 0x400
	// Bit GPIO2_EDGE_LOW.
	IO_BANK0_PROC1_INTE0_GPIO2_EDGE_LOW = 0x400
	// Position of GPIO2_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO2_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO2_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO2_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO2_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE0_GPIO2_LEVEL_HIGH = 0x200
	// Position of GPIO2_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO2_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO2_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO2_LEVEL_LOW_Msk = 0x100
	// Bit GPIO2_LEVEL_LOW.
	IO_BANK0_PROC1_INTE0_GPIO2_LEVEL_LOW = 0x100
	// Position of GPIO1_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO1_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO1_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO1_EDGE_HIGH_Msk = 0x80
	// Bit GPIO1_EDGE_HIGH.
	IO_BANK0_PROC1_INTE0_GPIO1_EDGE_HIGH = 0x80
	// Position of GPIO1_EDGE_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO1_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO1_EDGE_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO1_EDGE_LOW_Msk = 0x40
	// Bit GPIO1_EDGE_LOW.
	IO_BANK0_PROC1_INTE0_GPIO1_EDGE_LOW = 0x40
	// Position of GPIO1_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO1_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO1_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO1_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO1_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE0_GPIO1_LEVEL_HIGH = 0x20
	// Position of GPIO1_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO1_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO1_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO1_LEVEL_LOW_Msk = 0x10
	// Bit GPIO1_LEVEL_LOW.
	IO_BANK0_PROC1_INTE0_GPIO1_LEVEL_LOW = 0x10
	// Position of GPIO0_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO0_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO0_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO0_EDGE_HIGH_Msk = 0x8
	// Bit GPIO0_EDGE_HIGH.
	IO_BANK0_PROC1_INTE0_GPIO0_EDGE_HIGH = 0x8
	// Position of GPIO0_EDGE_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO0_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO0_EDGE_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO0_EDGE_LOW_Msk = 0x4
	// Bit GPIO0_EDGE_LOW.
	IO_BANK0_PROC1_INTE0_GPIO0_EDGE_LOW = 0x4
	// Position of GPIO0_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO0_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO0_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE0_GPIO0_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO0_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE0_GPIO0_LEVEL_HIGH = 0x2
	// Position of GPIO0_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO0_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO0_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE0_GPIO0_LEVEL_LOW_Msk = 0x1
	// Bit GPIO0_LEVEL_LOW.
	IO_BANK0_PROC1_INTE0_GPIO0_LEVEL_LOW = 0x1

	// PROC1_INTE1: Interrupt Enable for proc1
	// Position of GPIO15_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO15_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO15_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO15_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO15_EDGE_HIGH.
	IO_BANK0_PROC1_INTE1_GPIO15_EDGE_HIGH = 0x80000000
	// Position of GPIO15_EDGE_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO15_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO15_EDGE_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO15_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO15_EDGE_LOW.
	IO_BANK0_PROC1_INTE1_GPIO15_EDGE_LOW = 0x40000000
	// Position of GPIO15_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO15_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO15_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO15_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO15_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE1_GPIO15_LEVEL_HIGH = 0x20000000
	// Position of GPIO15_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO15_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO15_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO15_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO15_LEVEL_LOW.
	IO_BANK0_PROC1_INTE1_GPIO15_LEVEL_LOW = 0x10000000
	// Position of GPIO14_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO14_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO14_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO14_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO14_EDGE_HIGH.
	IO_BANK0_PROC1_INTE1_GPIO14_EDGE_HIGH = 0x8000000
	// Position of GPIO14_EDGE_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO14_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO14_EDGE_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO14_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO14_EDGE_LOW.
	IO_BANK0_PROC1_INTE1_GPIO14_EDGE_LOW = 0x4000000
	// Position of GPIO14_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO14_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO14_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO14_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO14_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE1_GPIO14_LEVEL_HIGH = 0x2000000
	// Position of GPIO14_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO14_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO14_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO14_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO14_LEVEL_LOW.
	IO_BANK0_PROC1_INTE1_GPIO14_LEVEL_LOW = 0x1000000
	// Position of GPIO13_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO13_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO13_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO13_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO13_EDGE_HIGH.
	IO_BANK0_PROC1_INTE1_GPIO13_EDGE_HIGH = 0x800000
	// Position of GPIO13_EDGE_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO13_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO13_EDGE_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO13_EDGE_LOW_Msk = 0x400000
	// Bit GPIO13_EDGE_LOW.
	IO_BANK0_PROC1_INTE1_GPIO13_EDGE_LOW = 0x400000
	// Position of GPIO13_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO13_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO13_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO13_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO13_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE1_GPIO13_LEVEL_HIGH = 0x200000
	// Position of GPIO13_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO13_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO13_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO13_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO13_LEVEL_LOW.
	IO_BANK0_PROC1_INTE1_GPIO13_LEVEL_LOW = 0x100000
	// Position of GPIO12_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO12_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO12_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO12_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO12_EDGE_HIGH.
	IO_BANK0_PROC1_INTE1_GPIO12_EDGE_HIGH = 0x80000
	// Position of GPIO12_EDGE_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO12_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO12_EDGE_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO12_EDGE_LOW_Msk = 0x40000
	// Bit GPIO12_EDGE_LOW.
	IO_BANK0_PROC1_INTE1_GPIO12_EDGE_LOW = 0x40000
	// Position of GPIO12_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO12_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO12_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO12_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO12_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE1_GPIO12_LEVEL_HIGH = 0x20000
	// Position of GPIO12_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO12_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO12_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO12_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO12_LEVEL_LOW.
	IO_BANK0_PROC1_INTE1_GPIO12_LEVEL_LOW = 0x10000
	// Position of GPIO11_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO11_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO11_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO11_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO11_EDGE_HIGH.
	IO_BANK0_PROC1_INTE1_GPIO11_EDGE_HIGH = 0x8000
	// Position of GPIO11_EDGE_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO11_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO11_EDGE_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO11_EDGE_LOW_Msk = 0x4000
	// Bit GPIO11_EDGE_LOW.
	IO_BANK0_PROC1_INTE1_GPIO11_EDGE_LOW = 0x4000
	// Position of GPIO11_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO11_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO11_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO11_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO11_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE1_GPIO11_LEVEL_HIGH = 0x2000
	// Position of GPIO11_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO11_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO11_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO11_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO11_LEVEL_LOW.
	IO_BANK0_PROC1_INTE1_GPIO11_LEVEL_LOW = 0x1000
	// Position of GPIO10_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO10_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO10_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO10_EDGE_HIGH_Msk = 0x800
	// Bit GPIO10_EDGE_HIGH.
	IO_BANK0_PROC1_INTE1_GPIO10_EDGE_HIGH = 0x800
	// Position of GPIO10_EDGE_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO10_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO10_EDGE_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO10_EDGE_LOW_Msk = 0x400
	// Bit GPIO10_EDGE_LOW.
	IO_BANK0_PROC1_INTE1_GPIO10_EDGE_LOW = 0x400
	// Position of GPIO10_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO10_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO10_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO10_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO10_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE1_GPIO10_LEVEL_HIGH = 0x200
	// Position of GPIO10_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO10_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO10_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO10_LEVEL_LOW_Msk = 0x100
	// Bit GPIO10_LEVEL_LOW.
	IO_BANK0_PROC1_INTE1_GPIO10_LEVEL_LOW = 0x100
	// Position of GPIO9_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO9_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO9_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO9_EDGE_HIGH_Msk = 0x80
	// Bit GPIO9_EDGE_HIGH.
	IO_BANK0_PROC1_INTE1_GPIO9_EDGE_HIGH = 0x80
	// Position of GPIO9_EDGE_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO9_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO9_EDGE_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO9_EDGE_LOW_Msk = 0x40
	// Bit GPIO9_EDGE_LOW.
	IO_BANK0_PROC1_INTE1_GPIO9_EDGE_LOW = 0x40
	// Position of GPIO9_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO9_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO9_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO9_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO9_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE1_GPIO9_LEVEL_HIGH = 0x20
	// Position of GPIO9_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO9_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO9_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO9_LEVEL_LOW_Msk = 0x10
	// Bit GPIO9_LEVEL_LOW.
	IO_BANK0_PROC1_INTE1_GPIO9_LEVEL_LOW = 0x10
	// Position of GPIO8_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO8_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO8_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO8_EDGE_HIGH_Msk = 0x8
	// Bit GPIO8_EDGE_HIGH.
	IO_BANK0_PROC1_INTE1_GPIO8_EDGE_HIGH = 0x8
	// Position of GPIO8_EDGE_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO8_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO8_EDGE_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO8_EDGE_LOW_Msk = 0x4
	// Bit GPIO8_EDGE_LOW.
	IO_BANK0_PROC1_INTE1_GPIO8_EDGE_LOW = 0x4
	// Position of GPIO8_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO8_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO8_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE1_GPIO8_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO8_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE1_GPIO8_LEVEL_HIGH = 0x2
	// Position of GPIO8_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO8_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO8_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE1_GPIO8_LEVEL_LOW_Msk = 0x1
	// Bit GPIO8_LEVEL_LOW.
	IO_BANK0_PROC1_INTE1_GPIO8_LEVEL_LOW = 0x1

	// PROC1_INTE2: Interrupt Enable for proc1
	// Position of GPIO23_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO23_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO23_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO23_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO23_EDGE_HIGH.
	IO_BANK0_PROC1_INTE2_GPIO23_EDGE_HIGH = 0x80000000
	// Position of GPIO23_EDGE_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO23_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO23_EDGE_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO23_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO23_EDGE_LOW.
	IO_BANK0_PROC1_INTE2_GPIO23_EDGE_LOW = 0x40000000
	// Position of GPIO23_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO23_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO23_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO23_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO23_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE2_GPIO23_LEVEL_HIGH = 0x20000000
	// Position of GPIO23_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO23_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO23_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO23_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO23_LEVEL_LOW.
	IO_BANK0_PROC1_INTE2_GPIO23_LEVEL_LOW = 0x10000000
	// Position of GPIO22_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO22_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO22_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO22_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO22_EDGE_HIGH.
	IO_BANK0_PROC1_INTE2_GPIO22_EDGE_HIGH = 0x8000000
	// Position of GPIO22_EDGE_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO22_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO22_EDGE_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO22_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO22_EDGE_LOW.
	IO_BANK0_PROC1_INTE2_GPIO22_EDGE_LOW = 0x4000000
	// Position of GPIO22_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO22_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO22_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO22_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO22_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE2_GPIO22_LEVEL_HIGH = 0x2000000
	// Position of GPIO22_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO22_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO22_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO22_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO22_LEVEL_LOW.
	IO_BANK0_PROC1_INTE2_GPIO22_LEVEL_LOW = 0x1000000
	// Position of GPIO21_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO21_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO21_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO21_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO21_EDGE_HIGH.
	IO_BANK0_PROC1_INTE2_GPIO21_EDGE_HIGH = 0x800000
	// Position of GPIO21_EDGE_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO21_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO21_EDGE_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO21_EDGE_LOW_Msk = 0x400000
	// Bit GPIO21_EDGE_LOW.
	IO_BANK0_PROC1_INTE2_GPIO21_EDGE_LOW = 0x400000
	// Position of GPIO21_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO21_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO21_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO21_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO21_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE2_GPIO21_LEVEL_HIGH = 0x200000
	// Position of GPIO21_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO21_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO21_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO21_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO21_LEVEL_LOW.
	IO_BANK0_PROC1_INTE2_GPIO21_LEVEL_LOW = 0x100000
	// Position of GPIO20_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO20_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO20_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO20_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO20_EDGE_HIGH.
	IO_BANK0_PROC1_INTE2_GPIO20_EDGE_HIGH = 0x80000
	// Position of GPIO20_EDGE_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO20_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO20_EDGE_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO20_EDGE_LOW_Msk = 0x40000
	// Bit GPIO20_EDGE_LOW.
	IO_BANK0_PROC1_INTE2_GPIO20_EDGE_LOW = 0x40000
	// Position of GPIO20_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO20_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO20_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO20_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO20_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE2_GPIO20_LEVEL_HIGH = 0x20000
	// Position of GPIO20_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO20_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO20_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO20_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO20_LEVEL_LOW.
	IO_BANK0_PROC1_INTE2_GPIO20_LEVEL_LOW = 0x10000
	// Position of GPIO19_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO19_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO19_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO19_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO19_EDGE_HIGH.
	IO_BANK0_PROC1_INTE2_GPIO19_EDGE_HIGH = 0x8000
	// Position of GPIO19_EDGE_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO19_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO19_EDGE_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO19_EDGE_LOW_Msk = 0x4000
	// Bit GPIO19_EDGE_LOW.
	IO_BANK0_PROC1_INTE2_GPIO19_EDGE_LOW = 0x4000
	// Position of GPIO19_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO19_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO19_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO19_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO19_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE2_GPIO19_LEVEL_HIGH = 0x2000
	// Position of GPIO19_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO19_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO19_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO19_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO19_LEVEL_LOW.
	IO_BANK0_PROC1_INTE2_GPIO19_LEVEL_LOW = 0x1000
	// Position of GPIO18_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO18_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO18_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO18_EDGE_HIGH_Msk = 0x800
	// Bit GPIO18_EDGE_HIGH.
	IO_BANK0_PROC1_INTE2_GPIO18_EDGE_HIGH = 0x800
	// Position of GPIO18_EDGE_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO18_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO18_EDGE_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO18_EDGE_LOW_Msk = 0x400
	// Bit GPIO18_EDGE_LOW.
	IO_BANK0_PROC1_INTE2_GPIO18_EDGE_LOW = 0x400
	// Position of GPIO18_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO18_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO18_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO18_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO18_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE2_GPIO18_LEVEL_HIGH = 0x200
	// Position of GPIO18_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO18_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO18_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO18_LEVEL_LOW_Msk = 0x100
	// Bit GPIO18_LEVEL_LOW.
	IO_BANK0_PROC1_INTE2_GPIO18_LEVEL_LOW = 0x100
	// Position of GPIO17_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO17_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO17_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO17_EDGE_HIGH_Msk = 0x80
	// Bit GPIO17_EDGE_HIGH.
	IO_BANK0_PROC1_INTE2_GPIO17_EDGE_HIGH = 0x80
	// Position of GPIO17_EDGE_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO17_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO17_EDGE_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO17_EDGE_LOW_Msk = 0x40
	// Bit GPIO17_EDGE_LOW.
	IO_BANK0_PROC1_INTE2_GPIO17_EDGE_LOW = 0x40
	// Position of GPIO17_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO17_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO17_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO17_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO17_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE2_GPIO17_LEVEL_HIGH = 0x20
	// Position of GPIO17_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO17_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO17_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO17_LEVEL_LOW_Msk = 0x10
	// Bit GPIO17_LEVEL_LOW.
	IO_BANK0_PROC1_INTE2_GPIO17_LEVEL_LOW = 0x10
	// Position of GPIO16_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO16_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO16_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO16_EDGE_HIGH_Msk = 0x8
	// Bit GPIO16_EDGE_HIGH.
	IO_BANK0_PROC1_INTE2_GPIO16_EDGE_HIGH = 0x8
	// Position of GPIO16_EDGE_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO16_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO16_EDGE_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO16_EDGE_LOW_Msk = 0x4
	// Bit GPIO16_EDGE_LOW.
	IO_BANK0_PROC1_INTE2_GPIO16_EDGE_LOW = 0x4
	// Position of GPIO16_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO16_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO16_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE2_GPIO16_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO16_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE2_GPIO16_LEVEL_HIGH = 0x2
	// Position of GPIO16_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO16_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO16_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE2_GPIO16_LEVEL_LOW_Msk = 0x1
	// Bit GPIO16_LEVEL_LOW.
	IO_BANK0_PROC1_INTE2_GPIO16_LEVEL_LOW = 0x1

	// PROC1_INTE3: Interrupt Enable for proc1
	// Position of GPIO29_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO29_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO29_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO29_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO29_EDGE_HIGH.
	IO_BANK0_PROC1_INTE3_GPIO29_EDGE_HIGH = 0x800000
	// Position of GPIO29_EDGE_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO29_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO29_EDGE_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO29_EDGE_LOW_Msk = 0x400000
	// Bit GPIO29_EDGE_LOW.
	IO_BANK0_PROC1_INTE3_GPIO29_EDGE_LOW = 0x400000
	// Position of GPIO29_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO29_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO29_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO29_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO29_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE3_GPIO29_LEVEL_HIGH = 0x200000
	// Position of GPIO29_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO29_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO29_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO29_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO29_LEVEL_LOW.
	IO_BANK0_PROC1_INTE3_GPIO29_LEVEL_LOW = 0x100000
	// Position of GPIO28_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO28_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO28_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO28_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO28_EDGE_HIGH.
	IO_BANK0_PROC1_INTE3_GPIO28_EDGE_HIGH = 0x80000
	// Position of GPIO28_EDGE_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO28_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO28_EDGE_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO28_EDGE_LOW_Msk = 0x40000
	// Bit GPIO28_EDGE_LOW.
	IO_BANK0_PROC1_INTE3_GPIO28_EDGE_LOW = 0x40000
	// Position of GPIO28_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO28_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO28_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO28_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO28_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE3_GPIO28_LEVEL_HIGH = 0x20000
	// Position of GPIO28_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO28_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO28_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO28_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO28_LEVEL_LOW.
	IO_BANK0_PROC1_INTE3_GPIO28_LEVEL_LOW = 0x10000
	// Position of GPIO27_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO27_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO27_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO27_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO27_EDGE_HIGH.
	IO_BANK0_PROC1_INTE3_GPIO27_EDGE_HIGH = 0x8000
	// Position of GPIO27_EDGE_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO27_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO27_EDGE_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO27_EDGE_LOW_Msk = 0x4000
	// Bit GPIO27_EDGE_LOW.
	IO_BANK0_PROC1_INTE3_GPIO27_EDGE_LOW = 0x4000
	// Position of GPIO27_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO27_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO27_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO27_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO27_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE3_GPIO27_LEVEL_HIGH = 0x2000
	// Position of GPIO27_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO27_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO27_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO27_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO27_LEVEL_LOW.
	IO_BANK0_PROC1_INTE3_GPIO27_LEVEL_LOW = 0x1000
	// Position of GPIO26_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO26_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO26_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO26_EDGE_HIGH_Msk = 0x800
	// Bit GPIO26_EDGE_HIGH.
	IO_BANK0_PROC1_INTE3_GPIO26_EDGE_HIGH = 0x800
	// Position of GPIO26_EDGE_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO26_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO26_EDGE_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO26_EDGE_LOW_Msk = 0x400
	// Bit GPIO26_EDGE_LOW.
	IO_BANK0_PROC1_INTE3_GPIO26_EDGE_LOW = 0x400
	// Position of GPIO26_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO26_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO26_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO26_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO26_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE3_GPIO26_LEVEL_HIGH = 0x200
	// Position of GPIO26_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO26_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO26_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO26_LEVEL_LOW_Msk = 0x100
	// Bit GPIO26_LEVEL_LOW.
	IO_BANK0_PROC1_INTE3_GPIO26_LEVEL_LOW = 0x100
	// Position of GPIO25_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO25_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO25_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO25_EDGE_HIGH_Msk = 0x80
	// Bit GPIO25_EDGE_HIGH.
	IO_BANK0_PROC1_INTE3_GPIO25_EDGE_HIGH = 0x80
	// Position of GPIO25_EDGE_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO25_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO25_EDGE_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO25_EDGE_LOW_Msk = 0x40
	// Bit GPIO25_EDGE_LOW.
	IO_BANK0_PROC1_INTE3_GPIO25_EDGE_LOW = 0x40
	// Position of GPIO25_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO25_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO25_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO25_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO25_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE3_GPIO25_LEVEL_HIGH = 0x20
	// Position of GPIO25_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO25_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO25_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO25_LEVEL_LOW_Msk = 0x10
	// Bit GPIO25_LEVEL_LOW.
	IO_BANK0_PROC1_INTE3_GPIO25_LEVEL_LOW = 0x10
	// Position of GPIO24_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO24_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO24_EDGE_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO24_EDGE_HIGH_Msk = 0x8
	// Bit GPIO24_EDGE_HIGH.
	IO_BANK0_PROC1_INTE3_GPIO24_EDGE_HIGH = 0x8
	// Position of GPIO24_EDGE_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO24_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO24_EDGE_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO24_EDGE_LOW_Msk = 0x4
	// Bit GPIO24_EDGE_LOW.
	IO_BANK0_PROC1_INTE3_GPIO24_EDGE_LOW = 0x4
	// Position of GPIO24_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO24_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO24_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTE3_GPIO24_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO24_LEVEL_HIGH.
	IO_BANK0_PROC1_INTE3_GPIO24_LEVEL_HIGH = 0x2
	// Position of GPIO24_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO24_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO24_LEVEL_LOW field.
	IO_BANK0_PROC1_INTE3_GPIO24_LEVEL_LOW_Msk = 0x1
	// Bit GPIO24_LEVEL_LOW.
	IO_BANK0_PROC1_INTE3_GPIO24_LEVEL_LOW = 0x1

	// PROC1_INTF0: Interrupt Force for proc1
	// Position of GPIO7_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO7_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO7_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO7_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO7_EDGE_HIGH.
	IO_BANK0_PROC1_INTF0_GPIO7_EDGE_HIGH = 0x80000000
	// Position of GPIO7_EDGE_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO7_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO7_EDGE_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO7_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO7_EDGE_LOW.
	IO_BANK0_PROC1_INTF0_GPIO7_EDGE_LOW = 0x40000000
	// Position of GPIO7_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO7_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO7_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO7_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO7_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF0_GPIO7_LEVEL_HIGH = 0x20000000
	// Position of GPIO7_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO7_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO7_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO7_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO7_LEVEL_LOW.
	IO_BANK0_PROC1_INTF0_GPIO7_LEVEL_LOW = 0x10000000
	// Position of GPIO6_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO6_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO6_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO6_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO6_EDGE_HIGH.
	IO_BANK0_PROC1_INTF0_GPIO6_EDGE_HIGH = 0x8000000
	// Position of GPIO6_EDGE_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO6_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO6_EDGE_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO6_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO6_EDGE_LOW.
	IO_BANK0_PROC1_INTF0_GPIO6_EDGE_LOW = 0x4000000
	// Position of GPIO6_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO6_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO6_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO6_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO6_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF0_GPIO6_LEVEL_HIGH = 0x2000000
	// Position of GPIO6_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO6_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO6_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO6_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO6_LEVEL_LOW.
	IO_BANK0_PROC1_INTF0_GPIO6_LEVEL_LOW = 0x1000000
	// Position of GPIO5_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO5_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO5_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO5_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO5_EDGE_HIGH.
	IO_BANK0_PROC1_INTF0_GPIO5_EDGE_HIGH = 0x800000
	// Position of GPIO5_EDGE_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO5_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO5_EDGE_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO5_EDGE_LOW_Msk = 0x400000
	// Bit GPIO5_EDGE_LOW.
	IO_BANK0_PROC1_INTF0_GPIO5_EDGE_LOW = 0x400000
	// Position of GPIO5_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO5_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO5_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO5_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO5_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF0_GPIO5_LEVEL_HIGH = 0x200000
	// Position of GPIO5_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO5_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO5_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO5_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO5_LEVEL_LOW.
	IO_BANK0_PROC1_INTF0_GPIO5_LEVEL_LOW = 0x100000
	// Position of GPIO4_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO4_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO4_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO4_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO4_EDGE_HIGH.
	IO_BANK0_PROC1_INTF0_GPIO4_EDGE_HIGH = 0x80000
	// Position of GPIO4_EDGE_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO4_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO4_EDGE_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO4_EDGE_LOW_Msk = 0x40000
	// Bit GPIO4_EDGE_LOW.
	IO_BANK0_PROC1_INTF0_GPIO4_EDGE_LOW = 0x40000
	// Position of GPIO4_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO4_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO4_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO4_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO4_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF0_GPIO4_LEVEL_HIGH = 0x20000
	// Position of GPIO4_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO4_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO4_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO4_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO4_LEVEL_LOW.
	IO_BANK0_PROC1_INTF0_GPIO4_LEVEL_LOW = 0x10000
	// Position of GPIO3_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO3_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO3_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO3_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO3_EDGE_HIGH.
	IO_BANK0_PROC1_INTF0_GPIO3_EDGE_HIGH = 0x8000
	// Position of GPIO3_EDGE_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO3_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO3_EDGE_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO3_EDGE_LOW_Msk = 0x4000
	// Bit GPIO3_EDGE_LOW.
	IO_BANK0_PROC1_INTF0_GPIO3_EDGE_LOW = 0x4000
	// Position of GPIO3_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO3_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO3_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO3_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO3_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF0_GPIO3_LEVEL_HIGH = 0x2000
	// Position of GPIO3_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO3_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO3_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO3_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO3_LEVEL_LOW.
	IO_BANK0_PROC1_INTF0_GPIO3_LEVEL_LOW = 0x1000
	// Position of GPIO2_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO2_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO2_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO2_EDGE_HIGH_Msk = 0x800
	// Bit GPIO2_EDGE_HIGH.
	IO_BANK0_PROC1_INTF0_GPIO2_EDGE_HIGH = 0x800
	// Position of GPIO2_EDGE_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO2_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO2_EDGE_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO2_EDGE_LOW_Msk = 0x400
	// Bit GPIO2_EDGE_LOW.
	IO_BANK0_PROC1_INTF0_GPIO2_EDGE_LOW = 0x400
	// Position of GPIO2_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO2_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO2_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO2_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO2_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF0_GPIO2_LEVEL_HIGH = 0x200
	// Position of GPIO2_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO2_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO2_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO2_LEVEL_LOW_Msk = 0x100
	// Bit GPIO2_LEVEL_LOW.
	IO_BANK0_PROC1_INTF0_GPIO2_LEVEL_LOW = 0x100
	// Position of GPIO1_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO1_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO1_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO1_EDGE_HIGH_Msk = 0x80
	// Bit GPIO1_EDGE_HIGH.
	IO_BANK0_PROC1_INTF0_GPIO1_EDGE_HIGH = 0x80
	// Position of GPIO1_EDGE_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO1_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO1_EDGE_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO1_EDGE_LOW_Msk = 0x40
	// Bit GPIO1_EDGE_LOW.
	IO_BANK0_PROC1_INTF0_GPIO1_EDGE_LOW = 0x40
	// Position of GPIO1_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO1_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO1_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO1_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO1_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF0_GPIO1_LEVEL_HIGH = 0x20
	// Position of GPIO1_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO1_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO1_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO1_LEVEL_LOW_Msk = 0x10
	// Bit GPIO1_LEVEL_LOW.
	IO_BANK0_PROC1_INTF0_GPIO1_LEVEL_LOW = 0x10
	// Position of GPIO0_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO0_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO0_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO0_EDGE_HIGH_Msk = 0x8
	// Bit GPIO0_EDGE_HIGH.
	IO_BANK0_PROC1_INTF0_GPIO0_EDGE_HIGH = 0x8
	// Position of GPIO0_EDGE_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO0_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO0_EDGE_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO0_EDGE_LOW_Msk = 0x4
	// Bit GPIO0_EDGE_LOW.
	IO_BANK0_PROC1_INTF0_GPIO0_EDGE_LOW = 0x4
	// Position of GPIO0_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO0_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO0_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF0_GPIO0_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO0_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF0_GPIO0_LEVEL_HIGH = 0x2
	// Position of GPIO0_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO0_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO0_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF0_GPIO0_LEVEL_LOW_Msk = 0x1
	// Bit GPIO0_LEVEL_LOW.
	IO_BANK0_PROC1_INTF0_GPIO0_LEVEL_LOW = 0x1

	// PROC1_INTF1: Interrupt Force for proc1
	// Position of GPIO15_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO15_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO15_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO15_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO15_EDGE_HIGH.
	IO_BANK0_PROC1_INTF1_GPIO15_EDGE_HIGH = 0x80000000
	// Position of GPIO15_EDGE_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO15_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO15_EDGE_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO15_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO15_EDGE_LOW.
	IO_BANK0_PROC1_INTF1_GPIO15_EDGE_LOW = 0x40000000
	// Position of GPIO15_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO15_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO15_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO15_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO15_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF1_GPIO15_LEVEL_HIGH = 0x20000000
	// Position of GPIO15_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO15_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO15_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO15_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO15_LEVEL_LOW.
	IO_BANK0_PROC1_INTF1_GPIO15_LEVEL_LOW = 0x10000000
	// Position of GPIO14_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO14_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO14_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO14_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO14_EDGE_HIGH.
	IO_BANK0_PROC1_INTF1_GPIO14_EDGE_HIGH = 0x8000000
	// Position of GPIO14_EDGE_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO14_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO14_EDGE_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO14_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO14_EDGE_LOW.
	IO_BANK0_PROC1_INTF1_GPIO14_EDGE_LOW = 0x4000000
	// Position of GPIO14_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO14_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO14_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO14_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO14_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF1_GPIO14_LEVEL_HIGH = 0x2000000
	// Position of GPIO14_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO14_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO14_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO14_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO14_LEVEL_LOW.
	IO_BANK0_PROC1_INTF1_GPIO14_LEVEL_LOW = 0x1000000
	// Position of GPIO13_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO13_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO13_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO13_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO13_EDGE_HIGH.
	IO_BANK0_PROC1_INTF1_GPIO13_EDGE_HIGH = 0x800000
	// Position of GPIO13_EDGE_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO13_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO13_EDGE_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO13_EDGE_LOW_Msk = 0x400000
	// Bit GPIO13_EDGE_LOW.
	IO_BANK0_PROC1_INTF1_GPIO13_EDGE_LOW = 0x400000
	// Position of GPIO13_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO13_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO13_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO13_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO13_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF1_GPIO13_LEVEL_HIGH = 0x200000
	// Position of GPIO13_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO13_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO13_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO13_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO13_LEVEL_LOW.
	IO_BANK0_PROC1_INTF1_GPIO13_LEVEL_LOW = 0x100000
	// Position of GPIO12_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO12_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO12_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO12_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO12_EDGE_HIGH.
	IO_BANK0_PROC1_INTF1_GPIO12_EDGE_HIGH = 0x80000
	// Position of GPIO12_EDGE_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO12_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO12_EDGE_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO12_EDGE_LOW_Msk = 0x40000
	// Bit GPIO12_EDGE_LOW.
	IO_BANK0_PROC1_INTF1_GPIO12_EDGE_LOW = 0x40000
	// Position of GPIO12_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO12_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO12_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO12_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO12_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF1_GPIO12_LEVEL_HIGH = 0x20000
	// Position of GPIO12_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO12_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO12_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO12_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO12_LEVEL_LOW.
	IO_BANK0_PROC1_INTF1_GPIO12_LEVEL_LOW = 0x10000
	// Position of GPIO11_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO11_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO11_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO11_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO11_EDGE_HIGH.
	IO_BANK0_PROC1_INTF1_GPIO11_EDGE_HIGH = 0x8000
	// Position of GPIO11_EDGE_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO11_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO11_EDGE_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO11_EDGE_LOW_Msk = 0x4000
	// Bit GPIO11_EDGE_LOW.
	IO_BANK0_PROC1_INTF1_GPIO11_EDGE_LOW = 0x4000
	// Position of GPIO11_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO11_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO11_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO11_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO11_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF1_GPIO11_LEVEL_HIGH = 0x2000
	// Position of GPIO11_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO11_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO11_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO11_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO11_LEVEL_LOW.
	IO_BANK0_PROC1_INTF1_GPIO11_LEVEL_LOW = 0x1000
	// Position of GPIO10_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO10_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO10_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO10_EDGE_HIGH_Msk = 0x800
	// Bit GPIO10_EDGE_HIGH.
	IO_BANK0_PROC1_INTF1_GPIO10_EDGE_HIGH = 0x800
	// Position of GPIO10_EDGE_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO10_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO10_EDGE_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO10_EDGE_LOW_Msk = 0x400
	// Bit GPIO10_EDGE_LOW.
	IO_BANK0_PROC1_INTF1_GPIO10_EDGE_LOW = 0x400
	// Position of GPIO10_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO10_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO10_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO10_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO10_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF1_GPIO10_LEVEL_HIGH = 0x200
	// Position of GPIO10_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO10_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO10_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO10_LEVEL_LOW_Msk = 0x100
	// Bit GPIO10_LEVEL_LOW.
	IO_BANK0_PROC1_INTF1_GPIO10_LEVEL_LOW = 0x100
	// Position of GPIO9_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO9_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO9_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO9_EDGE_HIGH_Msk = 0x80
	// Bit GPIO9_EDGE_HIGH.
	IO_BANK0_PROC1_INTF1_GPIO9_EDGE_HIGH = 0x80
	// Position of GPIO9_EDGE_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO9_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO9_EDGE_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO9_EDGE_LOW_Msk = 0x40
	// Bit GPIO9_EDGE_LOW.
	IO_BANK0_PROC1_INTF1_GPIO9_EDGE_LOW = 0x40
	// Position of GPIO9_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO9_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO9_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO9_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO9_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF1_GPIO9_LEVEL_HIGH = 0x20
	// Position of GPIO9_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO9_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO9_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO9_LEVEL_LOW_Msk = 0x10
	// Bit GPIO9_LEVEL_LOW.
	IO_BANK0_PROC1_INTF1_GPIO9_LEVEL_LOW = 0x10
	// Position of GPIO8_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO8_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO8_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO8_EDGE_HIGH_Msk = 0x8
	// Bit GPIO8_EDGE_HIGH.
	IO_BANK0_PROC1_INTF1_GPIO8_EDGE_HIGH = 0x8
	// Position of GPIO8_EDGE_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO8_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO8_EDGE_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO8_EDGE_LOW_Msk = 0x4
	// Bit GPIO8_EDGE_LOW.
	IO_BANK0_PROC1_INTF1_GPIO8_EDGE_LOW = 0x4
	// Position of GPIO8_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO8_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO8_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF1_GPIO8_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO8_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF1_GPIO8_LEVEL_HIGH = 0x2
	// Position of GPIO8_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO8_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO8_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF1_GPIO8_LEVEL_LOW_Msk = 0x1
	// Bit GPIO8_LEVEL_LOW.
	IO_BANK0_PROC1_INTF1_GPIO8_LEVEL_LOW = 0x1

	// PROC1_INTF2: Interrupt Force for proc1
	// Position of GPIO23_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO23_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO23_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO23_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO23_EDGE_HIGH.
	IO_BANK0_PROC1_INTF2_GPIO23_EDGE_HIGH = 0x80000000
	// Position of GPIO23_EDGE_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO23_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO23_EDGE_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO23_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO23_EDGE_LOW.
	IO_BANK0_PROC1_INTF2_GPIO23_EDGE_LOW = 0x40000000
	// Position of GPIO23_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO23_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO23_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO23_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO23_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF2_GPIO23_LEVEL_HIGH = 0x20000000
	// Position of GPIO23_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO23_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO23_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO23_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO23_LEVEL_LOW.
	IO_BANK0_PROC1_INTF2_GPIO23_LEVEL_LOW = 0x10000000
	// Position of GPIO22_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO22_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO22_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO22_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO22_EDGE_HIGH.
	IO_BANK0_PROC1_INTF2_GPIO22_EDGE_HIGH = 0x8000000
	// Position of GPIO22_EDGE_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO22_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO22_EDGE_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO22_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO22_EDGE_LOW.
	IO_BANK0_PROC1_INTF2_GPIO22_EDGE_LOW = 0x4000000
	// Position of GPIO22_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO22_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO22_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO22_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO22_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF2_GPIO22_LEVEL_HIGH = 0x2000000
	// Position of GPIO22_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO22_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO22_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO22_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO22_LEVEL_LOW.
	IO_BANK0_PROC1_INTF2_GPIO22_LEVEL_LOW = 0x1000000
	// Position of GPIO21_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO21_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO21_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO21_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO21_EDGE_HIGH.
	IO_BANK0_PROC1_INTF2_GPIO21_EDGE_HIGH = 0x800000
	// Position of GPIO21_EDGE_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO21_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO21_EDGE_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO21_EDGE_LOW_Msk = 0x400000
	// Bit GPIO21_EDGE_LOW.
	IO_BANK0_PROC1_INTF2_GPIO21_EDGE_LOW = 0x400000
	// Position of GPIO21_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO21_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO21_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO21_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO21_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF2_GPIO21_LEVEL_HIGH = 0x200000
	// Position of GPIO21_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO21_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO21_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO21_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO21_LEVEL_LOW.
	IO_BANK0_PROC1_INTF2_GPIO21_LEVEL_LOW = 0x100000
	// Position of GPIO20_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO20_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO20_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO20_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO20_EDGE_HIGH.
	IO_BANK0_PROC1_INTF2_GPIO20_EDGE_HIGH = 0x80000
	// Position of GPIO20_EDGE_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO20_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO20_EDGE_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO20_EDGE_LOW_Msk = 0x40000
	// Bit GPIO20_EDGE_LOW.
	IO_BANK0_PROC1_INTF2_GPIO20_EDGE_LOW = 0x40000
	// Position of GPIO20_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO20_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO20_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO20_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO20_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF2_GPIO20_LEVEL_HIGH = 0x20000
	// Position of GPIO20_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO20_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO20_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO20_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO20_LEVEL_LOW.
	IO_BANK0_PROC1_INTF2_GPIO20_LEVEL_LOW = 0x10000
	// Position of GPIO19_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO19_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO19_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO19_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO19_EDGE_HIGH.
	IO_BANK0_PROC1_INTF2_GPIO19_EDGE_HIGH = 0x8000
	// Position of GPIO19_EDGE_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO19_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO19_EDGE_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO19_EDGE_LOW_Msk = 0x4000
	// Bit GPIO19_EDGE_LOW.
	IO_BANK0_PROC1_INTF2_GPIO19_EDGE_LOW = 0x4000
	// Position of GPIO19_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO19_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO19_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO19_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO19_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF2_GPIO19_LEVEL_HIGH = 0x2000
	// Position of GPIO19_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO19_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO19_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO19_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO19_LEVEL_LOW.
	IO_BANK0_PROC1_INTF2_GPIO19_LEVEL_LOW = 0x1000
	// Position of GPIO18_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO18_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO18_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO18_EDGE_HIGH_Msk = 0x800
	// Bit GPIO18_EDGE_HIGH.
	IO_BANK0_PROC1_INTF2_GPIO18_EDGE_HIGH = 0x800
	// Position of GPIO18_EDGE_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO18_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO18_EDGE_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO18_EDGE_LOW_Msk = 0x400
	// Bit GPIO18_EDGE_LOW.
	IO_BANK0_PROC1_INTF2_GPIO18_EDGE_LOW = 0x400
	// Position of GPIO18_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO18_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO18_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO18_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO18_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF2_GPIO18_LEVEL_HIGH = 0x200
	// Position of GPIO18_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO18_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO18_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO18_LEVEL_LOW_Msk = 0x100
	// Bit GPIO18_LEVEL_LOW.
	IO_BANK0_PROC1_INTF2_GPIO18_LEVEL_LOW = 0x100
	// Position of GPIO17_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO17_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO17_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO17_EDGE_HIGH_Msk = 0x80
	// Bit GPIO17_EDGE_HIGH.
	IO_BANK0_PROC1_INTF2_GPIO17_EDGE_HIGH = 0x80
	// Position of GPIO17_EDGE_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO17_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO17_EDGE_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO17_EDGE_LOW_Msk = 0x40
	// Bit GPIO17_EDGE_LOW.
	IO_BANK0_PROC1_INTF2_GPIO17_EDGE_LOW = 0x40
	// Position of GPIO17_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO17_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO17_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO17_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO17_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF2_GPIO17_LEVEL_HIGH = 0x20
	// Position of GPIO17_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO17_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO17_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO17_LEVEL_LOW_Msk = 0x10
	// Bit GPIO17_LEVEL_LOW.
	IO_BANK0_PROC1_INTF2_GPIO17_LEVEL_LOW = 0x10
	// Position of GPIO16_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO16_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO16_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO16_EDGE_HIGH_Msk = 0x8
	// Bit GPIO16_EDGE_HIGH.
	IO_BANK0_PROC1_INTF2_GPIO16_EDGE_HIGH = 0x8
	// Position of GPIO16_EDGE_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO16_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO16_EDGE_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO16_EDGE_LOW_Msk = 0x4
	// Bit GPIO16_EDGE_LOW.
	IO_BANK0_PROC1_INTF2_GPIO16_EDGE_LOW = 0x4
	// Position of GPIO16_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO16_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO16_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF2_GPIO16_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO16_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF2_GPIO16_LEVEL_HIGH = 0x2
	// Position of GPIO16_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO16_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO16_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF2_GPIO16_LEVEL_LOW_Msk = 0x1
	// Bit GPIO16_LEVEL_LOW.
	IO_BANK0_PROC1_INTF2_GPIO16_LEVEL_LOW = 0x1

	// PROC1_INTF3: Interrupt Force for proc1
	// Position of GPIO29_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO29_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO29_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO29_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO29_EDGE_HIGH.
	IO_BANK0_PROC1_INTF3_GPIO29_EDGE_HIGH = 0x800000
	// Position of GPIO29_EDGE_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO29_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO29_EDGE_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO29_EDGE_LOW_Msk = 0x400000
	// Bit GPIO29_EDGE_LOW.
	IO_BANK0_PROC1_INTF3_GPIO29_EDGE_LOW = 0x400000
	// Position of GPIO29_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO29_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO29_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO29_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO29_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF3_GPIO29_LEVEL_HIGH = 0x200000
	// Position of GPIO29_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO29_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO29_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO29_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO29_LEVEL_LOW.
	IO_BANK0_PROC1_INTF3_GPIO29_LEVEL_LOW = 0x100000
	// Position of GPIO28_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO28_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO28_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO28_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO28_EDGE_HIGH.
	IO_BANK0_PROC1_INTF3_GPIO28_EDGE_HIGH = 0x80000
	// Position of GPIO28_EDGE_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO28_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO28_EDGE_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO28_EDGE_LOW_Msk = 0x40000
	// Bit GPIO28_EDGE_LOW.
	IO_BANK0_PROC1_INTF3_GPIO28_EDGE_LOW = 0x40000
	// Position of GPIO28_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO28_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO28_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO28_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO28_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF3_GPIO28_LEVEL_HIGH = 0x20000
	// Position of GPIO28_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO28_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO28_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO28_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO28_LEVEL_LOW.
	IO_BANK0_PROC1_INTF3_GPIO28_LEVEL_LOW = 0x10000
	// Position of GPIO27_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO27_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO27_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO27_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO27_EDGE_HIGH.
	IO_BANK0_PROC1_INTF3_GPIO27_EDGE_HIGH = 0x8000
	// Position of GPIO27_EDGE_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO27_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO27_EDGE_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO27_EDGE_LOW_Msk = 0x4000
	// Bit GPIO27_EDGE_LOW.
	IO_BANK0_PROC1_INTF3_GPIO27_EDGE_LOW = 0x4000
	// Position of GPIO27_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO27_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO27_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO27_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO27_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF3_GPIO27_LEVEL_HIGH = 0x2000
	// Position of GPIO27_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO27_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO27_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO27_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO27_LEVEL_LOW.
	IO_BANK0_PROC1_INTF3_GPIO27_LEVEL_LOW = 0x1000
	// Position of GPIO26_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO26_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO26_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO26_EDGE_HIGH_Msk = 0x800
	// Bit GPIO26_EDGE_HIGH.
	IO_BANK0_PROC1_INTF3_GPIO26_EDGE_HIGH = 0x800
	// Position of GPIO26_EDGE_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO26_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO26_EDGE_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO26_EDGE_LOW_Msk = 0x400
	// Bit GPIO26_EDGE_LOW.
	IO_BANK0_PROC1_INTF3_GPIO26_EDGE_LOW = 0x400
	// Position of GPIO26_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO26_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO26_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO26_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO26_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF3_GPIO26_LEVEL_HIGH = 0x200
	// Position of GPIO26_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO26_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO26_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO26_LEVEL_LOW_Msk = 0x100
	// Bit GPIO26_LEVEL_LOW.
	IO_BANK0_PROC1_INTF3_GPIO26_LEVEL_LOW = 0x100
	// Position of GPIO25_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO25_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO25_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO25_EDGE_HIGH_Msk = 0x80
	// Bit GPIO25_EDGE_HIGH.
	IO_BANK0_PROC1_INTF3_GPIO25_EDGE_HIGH = 0x80
	// Position of GPIO25_EDGE_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO25_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO25_EDGE_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO25_EDGE_LOW_Msk = 0x40
	// Bit GPIO25_EDGE_LOW.
	IO_BANK0_PROC1_INTF3_GPIO25_EDGE_LOW = 0x40
	// Position of GPIO25_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO25_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO25_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO25_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO25_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF3_GPIO25_LEVEL_HIGH = 0x20
	// Position of GPIO25_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO25_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO25_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO25_LEVEL_LOW_Msk = 0x10
	// Bit GPIO25_LEVEL_LOW.
	IO_BANK0_PROC1_INTF3_GPIO25_LEVEL_LOW = 0x10
	// Position of GPIO24_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO24_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO24_EDGE_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO24_EDGE_HIGH_Msk = 0x8
	// Bit GPIO24_EDGE_HIGH.
	IO_BANK0_PROC1_INTF3_GPIO24_EDGE_HIGH = 0x8
	// Position of GPIO24_EDGE_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO24_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO24_EDGE_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO24_EDGE_LOW_Msk = 0x4
	// Bit GPIO24_EDGE_LOW.
	IO_BANK0_PROC1_INTF3_GPIO24_EDGE_LOW = 0x4
	// Position of GPIO24_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO24_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO24_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTF3_GPIO24_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO24_LEVEL_HIGH.
	IO_BANK0_PROC1_INTF3_GPIO24_LEVEL_HIGH = 0x2
	// Position of GPIO24_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO24_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO24_LEVEL_LOW field.
	IO_BANK0_PROC1_INTF3_GPIO24_LEVEL_LOW_Msk = 0x1
	// Bit GPIO24_LEVEL_LOW.
	IO_BANK0_PROC1_INTF3_GPIO24_LEVEL_LOW = 0x1

	// PROC1_INTS0: Interrupt status after masking & forcing for proc1
	// Position of GPIO7_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO7_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO7_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO7_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO7_EDGE_HIGH.
	IO_BANK0_PROC1_INTS0_GPIO7_EDGE_HIGH = 0x80000000
	// Position of GPIO7_EDGE_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO7_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO7_EDGE_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO7_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO7_EDGE_LOW.
	IO_BANK0_PROC1_INTS0_GPIO7_EDGE_LOW = 0x40000000
	// Position of GPIO7_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO7_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO7_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO7_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO7_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS0_GPIO7_LEVEL_HIGH = 0x20000000
	// Position of GPIO7_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO7_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO7_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO7_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO7_LEVEL_LOW.
	IO_BANK0_PROC1_INTS0_GPIO7_LEVEL_LOW = 0x10000000
	// Position of GPIO6_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO6_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO6_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO6_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO6_EDGE_HIGH.
	IO_BANK0_PROC1_INTS0_GPIO6_EDGE_HIGH = 0x8000000
	// Position of GPIO6_EDGE_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO6_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO6_EDGE_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO6_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO6_EDGE_LOW.
	IO_BANK0_PROC1_INTS0_GPIO6_EDGE_LOW = 0x4000000
	// Position of GPIO6_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO6_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO6_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO6_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO6_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS0_GPIO6_LEVEL_HIGH = 0x2000000
	// Position of GPIO6_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO6_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO6_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO6_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO6_LEVEL_LOW.
	IO_BANK0_PROC1_INTS0_GPIO6_LEVEL_LOW = 0x1000000
	// Position of GPIO5_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO5_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO5_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO5_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO5_EDGE_HIGH.
	IO_BANK0_PROC1_INTS0_GPIO5_EDGE_HIGH = 0x800000
	// Position of GPIO5_EDGE_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO5_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO5_EDGE_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO5_EDGE_LOW_Msk = 0x400000
	// Bit GPIO5_EDGE_LOW.
	IO_BANK0_PROC1_INTS0_GPIO5_EDGE_LOW = 0x400000
	// Position of GPIO5_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO5_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO5_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO5_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO5_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS0_GPIO5_LEVEL_HIGH = 0x200000
	// Position of GPIO5_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO5_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO5_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO5_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO5_LEVEL_LOW.
	IO_BANK0_PROC1_INTS0_GPIO5_LEVEL_LOW = 0x100000
	// Position of GPIO4_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO4_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO4_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO4_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO4_EDGE_HIGH.
	IO_BANK0_PROC1_INTS0_GPIO4_EDGE_HIGH = 0x80000
	// Position of GPIO4_EDGE_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO4_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO4_EDGE_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO4_EDGE_LOW_Msk = 0x40000
	// Bit GPIO4_EDGE_LOW.
	IO_BANK0_PROC1_INTS0_GPIO4_EDGE_LOW = 0x40000
	// Position of GPIO4_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO4_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO4_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO4_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO4_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS0_GPIO4_LEVEL_HIGH = 0x20000
	// Position of GPIO4_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO4_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO4_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO4_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO4_LEVEL_LOW.
	IO_BANK0_PROC1_INTS0_GPIO4_LEVEL_LOW = 0x10000
	// Position of GPIO3_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO3_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO3_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO3_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO3_EDGE_HIGH.
	IO_BANK0_PROC1_INTS0_GPIO3_EDGE_HIGH = 0x8000
	// Position of GPIO3_EDGE_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO3_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO3_EDGE_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO3_EDGE_LOW_Msk = 0x4000
	// Bit GPIO3_EDGE_LOW.
	IO_BANK0_PROC1_INTS0_GPIO3_EDGE_LOW = 0x4000
	// Position of GPIO3_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO3_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO3_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO3_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO3_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS0_GPIO3_LEVEL_HIGH = 0x2000
	// Position of GPIO3_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO3_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO3_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO3_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO3_LEVEL_LOW.
	IO_BANK0_PROC1_INTS0_GPIO3_LEVEL_LOW = 0x1000
	// Position of GPIO2_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO2_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO2_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO2_EDGE_HIGH_Msk = 0x800
	// Bit GPIO2_EDGE_HIGH.
	IO_BANK0_PROC1_INTS0_GPIO2_EDGE_HIGH = 0x800
	// Position of GPIO2_EDGE_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO2_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO2_EDGE_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO2_EDGE_LOW_Msk = 0x400
	// Bit GPIO2_EDGE_LOW.
	IO_BANK0_PROC1_INTS0_GPIO2_EDGE_LOW = 0x400
	// Position of GPIO2_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO2_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO2_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO2_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO2_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS0_GPIO2_LEVEL_HIGH = 0x200
	// Position of GPIO2_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO2_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO2_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO2_LEVEL_LOW_Msk = 0x100
	// Bit GPIO2_LEVEL_LOW.
	IO_BANK0_PROC1_INTS0_GPIO2_LEVEL_LOW = 0x100
	// Position of GPIO1_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO1_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO1_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO1_EDGE_HIGH_Msk = 0x80
	// Bit GPIO1_EDGE_HIGH.
	IO_BANK0_PROC1_INTS0_GPIO1_EDGE_HIGH = 0x80
	// Position of GPIO1_EDGE_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO1_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO1_EDGE_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO1_EDGE_LOW_Msk = 0x40
	// Bit GPIO1_EDGE_LOW.
	IO_BANK0_PROC1_INTS0_GPIO1_EDGE_LOW = 0x40
	// Position of GPIO1_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO1_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO1_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO1_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO1_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS0_GPIO1_LEVEL_HIGH = 0x20
	// Position of GPIO1_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO1_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO1_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO1_LEVEL_LOW_Msk = 0x10
	// Bit GPIO1_LEVEL_LOW.
	IO_BANK0_PROC1_INTS0_GPIO1_LEVEL_LOW = 0x10
	// Position of GPIO0_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO0_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO0_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO0_EDGE_HIGH_Msk = 0x8
	// Bit GPIO0_EDGE_HIGH.
	IO_BANK0_PROC1_INTS0_GPIO0_EDGE_HIGH = 0x8
	// Position of GPIO0_EDGE_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO0_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO0_EDGE_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO0_EDGE_LOW_Msk = 0x4
	// Bit GPIO0_EDGE_LOW.
	IO_BANK0_PROC1_INTS0_GPIO0_EDGE_LOW = 0x4
	// Position of GPIO0_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO0_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO0_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS0_GPIO0_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO0_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS0_GPIO0_LEVEL_HIGH = 0x2
	// Position of GPIO0_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO0_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO0_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS0_GPIO0_LEVEL_LOW_Msk = 0x1
	// Bit GPIO0_LEVEL_LOW.
	IO_BANK0_PROC1_INTS0_GPIO0_LEVEL_LOW = 0x1

	// PROC1_INTS1: Interrupt status after masking & forcing for proc1
	// Position of GPIO15_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO15_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO15_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO15_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO15_EDGE_HIGH.
	IO_BANK0_PROC1_INTS1_GPIO15_EDGE_HIGH = 0x80000000
	// Position of GPIO15_EDGE_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO15_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO15_EDGE_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO15_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO15_EDGE_LOW.
	IO_BANK0_PROC1_INTS1_GPIO15_EDGE_LOW = 0x40000000
	// Position of GPIO15_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO15_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO15_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO15_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO15_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS1_GPIO15_LEVEL_HIGH = 0x20000000
	// Position of GPIO15_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO15_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO15_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO15_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO15_LEVEL_LOW.
	IO_BANK0_PROC1_INTS1_GPIO15_LEVEL_LOW = 0x10000000
	// Position of GPIO14_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO14_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO14_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO14_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO14_EDGE_HIGH.
	IO_BANK0_PROC1_INTS1_GPIO14_EDGE_HIGH = 0x8000000
	// Position of GPIO14_EDGE_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO14_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO14_EDGE_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO14_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO14_EDGE_LOW.
	IO_BANK0_PROC1_INTS1_GPIO14_EDGE_LOW = 0x4000000
	// Position of GPIO14_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO14_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO14_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO14_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO14_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS1_GPIO14_LEVEL_HIGH = 0x2000000
	// Position of GPIO14_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO14_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO14_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO14_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO14_LEVEL_LOW.
	IO_BANK0_PROC1_INTS1_GPIO14_LEVEL_LOW = 0x1000000
	// Position of GPIO13_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO13_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO13_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO13_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO13_EDGE_HIGH.
	IO_BANK0_PROC1_INTS1_GPIO13_EDGE_HIGH = 0x800000
	// Position of GPIO13_EDGE_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO13_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO13_EDGE_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO13_EDGE_LOW_Msk = 0x400000
	// Bit GPIO13_EDGE_LOW.
	IO_BANK0_PROC1_INTS1_GPIO13_EDGE_LOW = 0x400000
	// Position of GPIO13_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO13_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO13_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO13_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO13_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS1_GPIO13_LEVEL_HIGH = 0x200000
	// Position of GPIO13_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO13_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO13_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO13_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO13_LEVEL_LOW.
	IO_BANK0_PROC1_INTS1_GPIO13_LEVEL_LOW = 0x100000
	// Position of GPIO12_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO12_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO12_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO12_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO12_EDGE_HIGH.
	IO_BANK0_PROC1_INTS1_GPIO12_EDGE_HIGH = 0x80000
	// Position of GPIO12_EDGE_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO12_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO12_EDGE_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO12_EDGE_LOW_Msk = 0x40000
	// Bit GPIO12_EDGE_LOW.
	IO_BANK0_PROC1_INTS1_GPIO12_EDGE_LOW = 0x40000
	// Position of GPIO12_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO12_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO12_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO12_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO12_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS1_GPIO12_LEVEL_HIGH = 0x20000
	// Position of GPIO12_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO12_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO12_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO12_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO12_LEVEL_LOW.
	IO_BANK0_PROC1_INTS1_GPIO12_LEVEL_LOW = 0x10000
	// Position of GPIO11_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO11_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO11_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO11_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO11_EDGE_HIGH.
	IO_BANK0_PROC1_INTS1_GPIO11_EDGE_HIGH = 0x8000
	// Position of GPIO11_EDGE_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO11_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO11_EDGE_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO11_EDGE_LOW_Msk = 0x4000
	// Bit GPIO11_EDGE_LOW.
	IO_BANK0_PROC1_INTS1_GPIO11_EDGE_LOW = 0x4000
	// Position of GPIO11_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO11_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO11_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO11_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO11_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS1_GPIO11_LEVEL_HIGH = 0x2000
	// Position of GPIO11_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO11_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO11_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO11_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO11_LEVEL_LOW.
	IO_BANK0_PROC1_INTS1_GPIO11_LEVEL_LOW = 0x1000
	// Position of GPIO10_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO10_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO10_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO10_EDGE_HIGH_Msk = 0x800
	// Bit GPIO10_EDGE_HIGH.
	IO_BANK0_PROC1_INTS1_GPIO10_EDGE_HIGH = 0x800
	// Position of GPIO10_EDGE_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO10_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO10_EDGE_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO10_EDGE_LOW_Msk = 0x400
	// Bit GPIO10_EDGE_LOW.
	IO_BANK0_PROC1_INTS1_GPIO10_EDGE_LOW = 0x400
	// Position of GPIO10_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO10_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO10_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO10_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO10_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS1_GPIO10_LEVEL_HIGH = 0x200
	// Position of GPIO10_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO10_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO10_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO10_LEVEL_LOW_Msk = 0x100
	// Bit GPIO10_LEVEL_LOW.
	IO_BANK0_PROC1_INTS1_GPIO10_LEVEL_LOW = 0x100
	// Position of GPIO9_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO9_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO9_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO9_EDGE_HIGH_Msk = 0x80
	// Bit GPIO9_EDGE_HIGH.
	IO_BANK0_PROC1_INTS1_GPIO9_EDGE_HIGH = 0x80
	// Position of GPIO9_EDGE_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO9_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO9_EDGE_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO9_EDGE_LOW_Msk = 0x40
	// Bit GPIO9_EDGE_LOW.
	IO_BANK0_PROC1_INTS1_GPIO9_EDGE_LOW = 0x40
	// Position of GPIO9_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO9_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO9_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO9_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO9_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS1_GPIO9_LEVEL_HIGH = 0x20
	// Position of GPIO9_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO9_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO9_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO9_LEVEL_LOW_Msk = 0x10
	// Bit GPIO9_LEVEL_LOW.
	IO_BANK0_PROC1_INTS1_GPIO9_LEVEL_LOW = 0x10
	// Position of GPIO8_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO8_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO8_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO8_EDGE_HIGH_Msk = 0x8
	// Bit GPIO8_EDGE_HIGH.
	IO_BANK0_PROC1_INTS1_GPIO8_EDGE_HIGH = 0x8
	// Position of GPIO8_EDGE_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO8_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO8_EDGE_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO8_EDGE_LOW_Msk = 0x4
	// Bit GPIO8_EDGE_LOW.
	IO_BANK0_PROC1_INTS1_GPIO8_EDGE_LOW = 0x4
	// Position of GPIO8_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO8_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO8_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS1_GPIO8_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO8_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS1_GPIO8_LEVEL_HIGH = 0x2
	// Position of GPIO8_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO8_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO8_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS1_GPIO8_LEVEL_LOW_Msk = 0x1
	// Bit GPIO8_LEVEL_LOW.
	IO_BANK0_PROC1_INTS1_GPIO8_LEVEL_LOW = 0x1

	// PROC1_INTS2: Interrupt status after masking & forcing for proc1
	// Position of GPIO23_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO23_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO23_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO23_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO23_EDGE_HIGH.
	IO_BANK0_PROC1_INTS2_GPIO23_EDGE_HIGH = 0x80000000
	// Position of GPIO23_EDGE_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO23_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO23_EDGE_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO23_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO23_EDGE_LOW.
	IO_BANK0_PROC1_INTS2_GPIO23_EDGE_LOW = 0x40000000
	// Position of GPIO23_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO23_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO23_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO23_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO23_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS2_GPIO23_LEVEL_HIGH = 0x20000000
	// Position of GPIO23_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO23_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO23_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO23_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO23_LEVEL_LOW.
	IO_BANK0_PROC1_INTS2_GPIO23_LEVEL_LOW = 0x10000000
	// Position of GPIO22_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO22_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO22_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO22_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO22_EDGE_HIGH.
	IO_BANK0_PROC1_INTS2_GPIO22_EDGE_HIGH = 0x8000000
	// Position of GPIO22_EDGE_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO22_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO22_EDGE_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO22_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO22_EDGE_LOW.
	IO_BANK0_PROC1_INTS2_GPIO22_EDGE_LOW = 0x4000000
	// Position of GPIO22_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO22_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO22_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO22_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO22_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS2_GPIO22_LEVEL_HIGH = 0x2000000
	// Position of GPIO22_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO22_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO22_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO22_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO22_LEVEL_LOW.
	IO_BANK0_PROC1_INTS2_GPIO22_LEVEL_LOW = 0x1000000
	// Position of GPIO21_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO21_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO21_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO21_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO21_EDGE_HIGH.
	IO_BANK0_PROC1_INTS2_GPIO21_EDGE_HIGH = 0x800000
	// Position of GPIO21_EDGE_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO21_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO21_EDGE_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO21_EDGE_LOW_Msk = 0x400000
	// Bit GPIO21_EDGE_LOW.
	IO_BANK0_PROC1_INTS2_GPIO21_EDGE_LOW = 0x400000
	// Position of GPIO21_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO21_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO21_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO21_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO21_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS2_GPIO21_LEVEL_HIGH = 0x200000
	// Position of GPIO21_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO21_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO21_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO21_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO21_LEVEL_LOW.
	IO_BANK0_PROC1_INTS2_GPIO21_LEVEL_LOW = 0x100000
	// Position of GPIO20_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO20_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO20_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO20_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO20_EDGE_HIGH.
	IO_BANK0_PROC1_INTS2_GPIO20_EDGE_HIGH = 0x80000
	// Position of GPIO20_EDGE_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO20_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO20_EDGE_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO20_EDGE_LOW_Msk = 0x40000
	// Bit GPIO20_EDGE_LOW.
	IO_BANK0_PROC1_INTS2_GPIO20_EDGE_LOW = 0x40000
	// Position of GPIO20_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO20_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO20_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO20_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO20_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS2_GPIO20_LEVEL_HIGH = 0x20000
	// Position of GPIO20_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO20_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO20_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO20_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO20_LEVEL_LOW.
	IO_BANK0_PROC1_INTS2_GPIO20_LEVEL_LOW = 0x10000
	// Position of GPIO19_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO19_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO19_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO19_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO19_EDGE_HIGH.
	IO_BANK0_PROC1_INTS2_GPIO19_EDGE_HIGH = 0x8000
	// Position of GPIO19_EDGE_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO19_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO19_EDGE_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO19_EDGE_LOW_Msk = 0x4000
	// Bit GPIO19_EDGE_LOW.
	IO_BANK0_PROC1_INTS2_GPIO19_EDGE_LOW = 0x4000
	// Position of GPIO19_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO19_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO19_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO19_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO19_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS2_GPIO19_LEVEL_HIGH = 0x2000
	// Position of GPIO19_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO19_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO19_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO19_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO19_LEVEL_LOW.
	IO_BANK0_PROC1_INTS2_GPIO19_LEVEL_LOW = 0x1000
	// Position of GPIO18_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO18_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO18_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO18_EDGE_HIGH_Msk = 0x800
	// Bit GPIO18_EDGE_HIGH.
	IO_BANK0_PROC1_INTS2_GPIO18_EDGE_HIGH = 0x800
	// Position of GPIO18_EDGE_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO18_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO18_EDGE_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO18_EDGE_LOW_Msk = 0x400
	// Bit GPIO18_EDGE_LOW.
	IO_BANK0_PROC1_INTS2_GPIO18_EDGE_LOW = 0x400
	// Position of GPIO18_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO18_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO18_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO18_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO18_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS2_GPIO18_LEVEL_HIGH = 0x200
	// Position of GPIO18_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO18_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO18_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO18_LEVEL_LOW_Msk = 0x100
	// Bit GPIO18_LEVEL_LOW.
	IO_BANK0_PROC1_INTS2_GPIO18_LEVEL_LOW = 0x100
	// Position of GPIO17_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO17_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO17_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO17_EDGE_HIGH_Msk = 0x80
	// Bit GPIO17_EDGE_HIGH.
	IO_BANK0_PROC1_INTS2_GPIO17_EDGE_HIGH = 0x80
	// Position of GPIO17_EDGE_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO17_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO17_EDGE_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO17_EDGE_LOW_Msk = 0x40
	// Bit GPIO17_EDGE_LOW.
	IO_BANK0_PROC1_INTS2_GPIO17_EDGE_LOW = 0x40
	// Position of GPIO17_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO17_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO17_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO17_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO17_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS2_GPIO17_LEVEL_HIGH = 0x20
	// Position of GPIO17_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO17_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO17_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO17_LEVEL_LOW_Msk = 0x10
	// Bit GPIO17_LEVEL_LOW.
	IO_BANK0_PROC1_INTS2_GPIO17_LEVEL_LOW = 0x10
	// Position of GPIO16_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO16_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO16_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO16_EDGE_HIGH_Msk = 0x8
	// Bit GPIO16_EDGE_HIGH.
	IO_BANK0_PROC1_INTS2_GPIO16_EDGE_HIGH = 0x8
	// Position of GPIO16_EDGE_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO16_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO16_EDGE_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO16_EDGE_LOW_Msk = 0x4
	// Bit GPIO16_EDGE_LOW.
	IO_BANK0_PROC1_INTS2_GPIO16_EDGE_LOW = 0x4
	// Position of GPIO16_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO16_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO16_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS2_GPIO16_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO16_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS2_GPIO16_LEVEL_HIGH = 0x2
	// Position of GPIO16_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO16_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO16_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS2_GPIO16_LEVEL_LOW_Msk = 0x1
	// Bit GPIO16_LEVEL_LOW.
	IO_BANK0_PROC1_INTS2_GPIO16_LEVEL_LOW = 0x1

	// PROC1_INTS3: Interrupt status after masking & forcing for proc1
	// Position of GPIO29_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO29_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO29_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO29_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO29_EDGE_HIGH.
	IO_BANK0_PROC1_INTS3_GPIO29_EDGE_HIGH = 0x800000
	// Position of GPIO29_EDGE_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO29_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO29_EDGE_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO29_EDGE_LOW_Msk = 0x400000
	// Bit GPIO29_EDGE_LOW.
	IO_BANK0_PROC1_INTS3_GPIO29_EDGE_LOW = 0x400000
	// Position of GPIO29_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO29_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO29_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO29_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO29_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS3_GPIO29_LEVEL_HIGH = 0x200000
	// Position of GPIO29_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO29_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO29_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO29_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO29_LEVEL_LOW.
	IO_BANK0_PROC1_INTS3_GPIO29_LEVEL_LOW = 0x100000
	// Position of GPIO28_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO28_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO28_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO28_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO28_EDGE_HIGH.
	IO_BANK0_PROC1_INTS3_GPIO28_EDGE_HIGH = 0x80000
	// Position of GPIO28_EDGE_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO28_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO28_EDGE_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO28_EDGE_LOW_Msk = 0x40000
	// Bit GPIO28_EDGE_LOW.
	IO_BANK0_PROC1_INTS3_GPIO28_EDGE_LOW = 0x40000
	// Position of GPIO28_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO28_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO28_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO28_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO28_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS3_GPIO28_LEVEL_HIGH = 0x20000
	// Position of GPIO28_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO28_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO28_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO28_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO28_LEVEL_LOW.
	IO_BANK0_PROC1_INTS3_GPIO28_LEVEL_LOW = 0x10000
	// Position of GPIO27_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO27_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO27_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO27_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO27_EDGE_HIGH.
	IO_BANK0_PROC1_INTS3_GPIO27_EDGE_HIGH = 0x8000
	// Position of GPIO27_EDGE_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO27_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO27_EDGE_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO27_EDGE_LOW_Msk = 0x4000
	// Bit GPIO27_EDGE_LOW.
	IO_BANK0_PROC1_INTS3_GPIO27_EDGE_LOW = 0x4000
	// Position of GPIO27_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO27_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO27_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO27_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO27_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS3_GPIO27_LEVEL_HIGH = 0x2000
	// Position of GPIO27_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO27_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO27_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO27_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO27_LEVEL_LOW.
	IO_BANK0_PROC1_INTS3_GPIO27_LEVEL_LOW = 0x1000
	// Position of GPIO26_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO26_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO26_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO26_EDGE_HIGH_Msk = 0x800
	// Bit GPIO26_EDGE_HIGH.
	IO_BANK0_PROC1_INTS3_GPIO26_EDGE_HIGH = 0x800
	// Position of GPIO26_EDGE_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO26_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO26_EDGE_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO26_EDGE_LOW_Msk = 0x400
	// Bit GPIO26_EDGE_LOW.
	IO_BANK0_PROC1_INTS3_GPIO26_EDGE_LOW = 0x400
	// Position of GPIO26_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO26_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO26_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO26_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO26_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS3_GPIO26_LEVEL_HIGH = 0x200
	// Position of GPIO26_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO26_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO26_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO26_LEVEL_LOW_Msk = 0x100
	// Bit GPIO26_LEVEL_LOW.
	IO_BANK0_PROC1_INTS3_GPIO26_LEVEL_LOW = 0x100
	// Position of GPIO25_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO25_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO25_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO25_EDGE_HIGH_Msk = 0x80
	// Bit GPIO25_EDGE_HIGH.
	IO_BANK0_PROC1_INTS3_GPIO25_EDGE_HIGH = 0x80
	// Position of GPIO25_EDGE_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO25_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO25_EDGE_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO25_EDGE_LOW_Msk = 0x40
	// Bit GPIO25_EDGE_LOW.
	IO_BANK0_PROC1_INTS3_GPIO25_EDGE_LOW = 0x40
	// Position of GPIO25_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO25_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO25_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO25_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO25_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS3_GPIO25_LEVEL_HIGH = 0x20
	// Position of GPIO25_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO25_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO25_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO25_LEVEL_LOW_Msk = 0x10
	// Bit GPIO25_LEVEL_LOW.
	IO_BANK0_PROC1_INTS3_GPIO25_LEVEL_LOW = 0x10
	// Position of GPIO24_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO24_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO24_EDGE_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO24_EDGE_HIGH_Msk = 0x8
	// Bit GPIO24_EDGE_HIGH.
	IO_BANK0_PROC1_INTS3_GPIO24_EDGE_HIGH = 0x8
	// Position of GPIO24_EDGE_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO24_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO24_EDGE_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO24_EDGE_LOW_Msk = 0x4
	// Bit GPIO24_EDGE_LOW.
	IO_BANK0_PROC1_INTS3_GPIO24_EDGE_LOW = 0x4
	// Position of GPIO24_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO24_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO24_LEVEL_HIGH field.
	IO_BANK0_PROC1_INTS3_GPIO24_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO24_LEVEL_HIGH.
	IO_BANK0_PROC1_INTS3_GPIO24_LEVEL_HIGH = 0x2
	// Position of GPIO24_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO24_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO24_LEVEL_LOW field.
	IO_BANK0_PROC1_INTS3_GPIO24_LEVEL_LOW_Msk = 0x1
	// Bit GPIO24_LEVEL_LOW.
	IO_BANK0_PROC1_INTS3_GPIO24_LEVEL_LOW = 0x1

	// DORMANT_WAKE_INTE0: Interrupt Enable for dormant_wake
	// Position of GPIO7_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO7_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO7_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_EDGE_HIGH = 0x80000000
	// Position of GPIO7_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO7_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO7_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_EDGE_LOW = 0x40000000
	// Position of GPIO7_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO7_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO7_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_LEVEL_HIGH = 0x20000000
	// Position of GPIO7_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO7_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO7_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_LEVEL_LOW = 0x10000000
	// Position of GPIO6_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO6_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO6_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_EDGE_HIGH = 0x8000000
	// Position of GPIO6_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO6_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO6_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_EDGE_LOW = 0x4000000
	// Position of GPIO6_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO6_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO6_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_LEVEL_HIGH = 0x2000000
	// Position of GPIO6_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO6_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO6_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_LEVEL_LOW = 0x1000000
	// Position of GPIO5_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO5_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO5_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_EDGE_HIGH = 0x800000
	// Position of GPIO5_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO5_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_EDGE_LOW_Msk = 0x400000
	// Bit GPIO5_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_EDGE_LOW = 0x400000
	// Position of GPIO5_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO5_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO5_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_LEVEL_HIGH = 0x200000
	// Position of GPIO5_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO5_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO5_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_LEVEL_LOW = 0x100000
	// Position of GPIO4_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO4_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO4_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_EDGE_HIGH = 0x80000
	// Position of GPIO4_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO4_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_EDGE_LOW_Msk = 0x40000
	// Bit GPIO4_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_EDGE_LOW = 0x40000
	// Position of GPIO4_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO4_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO4_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_LEVEL_HIGH = 0x20000
	// Position of GPIO4_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO4_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO4_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_LEVEL_LOW = 0x10000
	// Position of GPIO3_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO3_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO3_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_EDGE_HIGH = 0x8000
	// Position of GPIO3_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO3_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_EDGE_LOW_Msk = 0x4000
	// Bit GPIO3_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_EDGE_LOW = 0x4000
	// Position of GPIO3_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO3_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO3_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_LEVEL_HIGH = 0x2000
	// Position of GPIO3_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO3_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO3_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_LEVEL_LOW = 0x1000
	// Position of GPIO2_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO2_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_EDGE_HIGH_Msk = 0x800
	// Bit GPIO2_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_EDGE_HIGH = 0x800
	// Position of GPIO2_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO2_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_EDGE_LOW_Msk = 0x400
	// Bit GPIO2_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_EDGE_LOW = 0x400
	// Position of GPIO2_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO2_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO2_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_LEVEL_HIGH = 0x200
	// Position of GPIO2_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO2_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_LEVEL_LOW_Msk = 0x100
	// Bit GPIO2_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_LEVEL_LOW = 0x100
	// Position of GPIO1_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO1_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_EDGE_HIGH_Msk = 0x80
	// Bit GPIO1_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_EDGE_HIGH = 0x80
	// Position of GPIO1_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO1_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_EDGE_LOW_Msk = 0x40
	// Bit GPIO1_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_EDGE_LOW = 0x40
	// Position of GPIO1_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO1_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO1_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_LEVEL_HIGH = 0x20
	// Position of GPIO1_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO1_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_LEVEL_LOW_Msk = 0x10
	// Bit GPIO1_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_LEVEL_LOW = 0x10
	// Position of GPIO0_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO0_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_EDGE_HIGH_Msk = 0x8
	// Bit GPIO0_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_EDGE_HIGH = 0x8
	// Position of GPIO0_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO0_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_EDGE_LOW_Msk = 0x4
	// Bit GPIO0_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_EDGE_LOW = 0x4
	// Position of GPIO0_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO0_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO0_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_LEVEL_HIGH = 0x2
	// Position of GPIO0_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO0_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_LEVEL_LOW_Msk = 0x1
	// Bit GPIO0_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_LEVEL_LOW = 0x1

	// DORMANT_WAKE_INTE1: Interrupt Enable for dormant_wake
	// Position of GPIO15_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO15_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO15_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_EDGE_HIGH = 0x80000000
	// Position of GPIO15_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO15_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO15_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_EDGE_LOW = 0x40000000
	// Position of GPIO15_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO15_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO15_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_LEVEL_HIGH = 0x20000000
	// Position of GPIO15_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO15_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO15_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_LEVEL_LOW = 0x10000000
	// Position of GPIO14_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO14_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO14_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_EDGE_HIGH = 0x8000000
	// Position of GPIO14_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO14_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO14_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_EDGE_LOW = 0x4000000
	// Position of GPIO14_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO14_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO14_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_LEVEL_HIGH = 0x2000000
	// Position of GPIO14_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO14_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO14_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_LEVEL_LOW = 0x1000000
	// Position of GPIO13_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO13_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO13_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_EDGE_HIGH = 0x800000
	// Position of GPIO13_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO13_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_EDGE_LOW_Msk = 0x400000
	// Bit GPIO13_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_EDGE_LOW = 0x400000
	// Position of GPIO13_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO13_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO13_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_LEVEL_HIGH = 0x200000
	// Position of GPIO13_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO13_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO13_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_LEVEL_LOW = 0x100000
	// Position of GPIO12_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO12_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO12_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_EDGE_HIGH = 0x80000
	// Position of GPIO12_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO12_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_EDGE_LOW_Msk = 0x40000
	// Bit GPIO12_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_EDGE_LOW = 0x40000
	// Position of GPIO12_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO12_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO12_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_LEVEL_HIGH = 0x20000
	// Position of GPIO12_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO12_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO12_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_LEVEL_LOW = 0x10000
	// Position of GPIO11_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO11_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO11_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_EDGE_HIGH = 0x8000
	// Position of GPIO11_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO11_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_EDGE_LOW_Msk = 0x4000
	// Bit GPIO11_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_EDGE_LOW = 0x4000
	// Position of GPIO11_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO11_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO11_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_LEVEL_HIGH = 0x2000
	// Position of GPIO11_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO11_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO11_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_LEVEL_LOW = 0x1000
	// Position of GPIO10_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO10_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_EDGE_HIGH_Msk = 0x800
	// Bit GPIO10_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_EDGE_HIGH = 0x800
	// Position of GPIO10_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO10_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_EDGE_LOW_Msk = 0x400
	// Bit GPIO10_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_EDGE_LOW = 0x400
	// Position of GPIO10_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO10_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO10_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_LEVEL_HIGH = 0x200
	// Position of GPIO10_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO10_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_LEVEL_LOW_Msk = 0x100
	// Bit GPIO10_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_LEVEL_LOW = 0x100
	// Position of GPIO9_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO9_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_EDGE_HIGH_Msk = 0x80
	// Bit GPIO9_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_EDGE_HIGH = 0x80
	// Position of GPIO9_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO9_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_EDGE_LOW_Msk = 0x40
	// Bit GPIO9_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_EDGE_LOW = 0x40
	// Position of GPIO9_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO9_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO9_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_LEVEL_HIGH = 0x20
	// Position of GPIO9_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO9_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_LEVEL_LOW_Msk = 0x10
	// Bit GPIO9_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_LEVEL_LOW = 0x10
	// Position of GPIO8_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO8_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_EDGE_HIGH_Msk = 0x8
	// Bit GPIO8_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_EDGE_HIGH = 0x8
	// Position of GPIO8_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO8_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_EDGE_LOW_Msk = 0x4
	// Bit GPIO8_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_EDGE_LOW = 0x4
	// Position of GPIO8_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO8_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO8_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_LEVEL_HIGH = 0x2
	// Position of GPIO8_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO8_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_LEVEL_LOW_Msk = 0x1
	// Bit GPIO8_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_LEVEL_LOW = 0x1

	// DORMANT_WAKE_INTE2: Interrupt Enable for dormant_wake
	// Position of GPIO23_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO23_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO23_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_EDGE_HIGH = 0x80000000
	// Position of GPIO23_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO23_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO23_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_EDGE_LOW = 0x40000000
	// Position of GPIO23_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO23_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO23_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_LEVEL_HIGH = 0x20000000
	// Position of GPIO23_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO23_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO23_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_LEVEL_LOW = 0x10000000
	// Position of GPIO22_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO22_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO22_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_EDGE_HIGH = 0x8000000
	// Position of GPIO22_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO22_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO22_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_EDGE_LOW = 0x4000000
	// Position of GPIO22_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO22_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO22_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_LEVEL_HIGH = 0x2000000
	// Position of GPIO22_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO22_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO22_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_LEVEL_LOW = 0x1000000
	// Position of GPIO21_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO21_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO21_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_EDGE_HIGH = 0x800000
	// Position of GPIO21_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO21_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_EDGE_LOW_Msk = 0x400000
	// Bit GPIO21_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_EDGE_LOW = 0x400000
	// Position of GPIO21_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO21_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO21_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_LEVEL_HIGH = 0x200000
	// Position of GPIO21_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO21_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO21_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_LEVEL_LOW = 0x100000
	// Position of GPIO20_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO20_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO20_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_EDGE_HIGH = 0x80000
	// Position of GPIO20_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO20_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_EDGE_LOW_Msk = 0x40000
	// Bit GPIO20_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_EDGE_LOW = 0x40000
	// Position of GPIO20_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO20_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO20_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_LEVEL_HIGH = 0x20000
	// Position of GPIO20_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO20_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO20_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_LEVEL_LOW = 0x10000
	// Position of GPIO19_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO19_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO19_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_EDGE_HIGH = 0x8000
	// Position of GPIO19_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO19_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_EDGE_LOW_Msk = 0x4000
	// Bit GPIO19_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_EDGE_LOW = 0x4000
	// Position of GPIO19_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO19_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO19_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_LEVEL_HIGH = 0x2000
	// Position of GPIO19_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO19_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO19_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_LEVEL_LOW = 0x1000
	// Position of GPIO18_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO18_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_EDGE_HIGH_Msk = 0x800
	// Bit GPIO18_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_EDGE_HIGH = 0x800
	// Position of GPIO18_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO18_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_EDGE_LOW_Msk = 0x400
	// Bit GPIO18_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_EDGE_LOW = 0x400
	// Position of GPIO18_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO18_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO18_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_LEVEL_HIGH = 0x200
	// Position of GPIO18_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO18_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_LEVEL_LOW_Msk = 0x100
	// Bit GPIO18_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_LEVEL_LOW = 0x100
	// Position of GPIO17_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO17_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_EDGE_HIGH_Msk = 0x80
	// Bit GPIO17_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_EDGE_HIGH = 0x80
	// Position of GPIO17_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO17_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_EDGE_LOW_Msk = 0x40
	// Bit GPIO17_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_EDGE_LOW = 0x40
	// Position of GPIO17_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO17_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO17_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_LEVEL_HIGH = 0x20
	// Position of GPIO17_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO17_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_LEVEL_LOW_Msk = 0x10
	// Bit GPIO17_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_LEVEL_LOW = 0x10
	// Position of GPIO16_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO16_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_EDGE_HIGH_Msk = 0x8
	// Bit GPIO16_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_EDGE_HIGH = 0x8
	// Position of GPIO16_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO16_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_EDGE_LOW_Msk = 0x4
	// Bit GPIO16_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_EDGE_LOW = 0x4
	// Position of GPIO16_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO16_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO16_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_LEVEL_HIGH = 0x2
	// Position of GPIO16_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO16_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_LEVEL_LOW_Msk = 0x1
	// Bit GPIO16_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_LEVEL_LOW = 0x1

	// DORMANT_WAKE_INTE3: Interrupt Enable for dormant_wake
	// Position of GPIO29_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO29_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO29_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_EDGE_HIGH = 0x800000
	// Position of GPIO29_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO29_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_EDGE_LOW_Msk = 0x400000
	// Bit GPIO29_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_EDGE_LOW = 0x400000
	// Position of GPIO29_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO29_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO29_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_LEVEL_HIGH = 0x200000
	// Position of GPIO29_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO29_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO29_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_LEVEL_LOW = 0x100000
	// Position of GPIO28_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO28_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO28_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_EDGE_HIGH = 0x80000
	// Position of GPIO28_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO28_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_EDGE_LOW_Msk = 0x40000
	// Bit GPIO28_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_EDGE_LOW = 0x40000
	// Position of GPIO28_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO28_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO28_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_LEVEL_HIGH = 0x20000
	// Position of GPIO28_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO28_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO28_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_LEVEL_LOW = 0x10000
	// Position of GPIO27_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO27_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO27_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_EDGE_HIGH = 0x8000
	// Position of GPIO27_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO27_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_EDGE_LOW_Msk = 0x4000
	// Bit GPIO27_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_EDGE_LOW = 0x4000
	// Position of GPIO27_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO27_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO27_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_LEVEL_HIGH = 0x2000
	// Position of GPIO27_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO27_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO27_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_LEVEL_LOW = 0x1000
	// Position of GPIO26_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO26_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_EDGE_HIGH_Msk = 0x800
	// Bit GPIO26_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_EDGE_HIGH = 0x800
	// Position of GPIO26_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO26_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_EDGE_LOW_Msk = 0x400
	// Bit GPIO26_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_EDGE_LOW = 0x400
	// Position of GPIO26_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO26_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO26_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_LEVEL_HIGH = 0x200
	// Position of GPIO26_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO26_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_LEVEL_LOW_Msk = 0x100
	// Bit GPIO26_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_LEVEL_LOW = 0x100
	// Position of GPIO25_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO25_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_EDGE_HIGH_Msk = 0x80
	// Bit GPIO25_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_EDGE_HIGH = 0x80
	// Position of GPIO25_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO25_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_EDGE_LOW_Msk = 0x40
	// Bit GPIO25_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_EDGE_LOW = 0x40
	// Position of GPIO25_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO25_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO25_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_LEVEL_HIGH = 0x20
	// Position of GPIO25_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO25_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_LEVEL_LOW_Msk = 0x10
	// Bit GPIO25_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_LEVEL_LOW = 0x10
	// Position of GPIO24_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO24_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_EDGE_HIGH_Msk = 0x8
	// Bit GPIO24_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_EDGE_HIGH = 0x8
	// Position of GPIO24_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO24_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_EDGE_LOW_Msk = 0x4
	// Bit GPIO24_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_EDGE_LOW = 0x4
	// Position of GPIO24_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO24_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO24_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_LEVEL_HIGH = 0x2
	// Position of GPIO24_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO24_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_LEVEL_LOW_Msk = 0x1
	// Bit GPIO24_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_LEVEL_LOW = 0x1

	// DORMANT_WAKE_INTF0: Interrupt Force for dormant_wake
	// Position of GPIO7_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO7_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO7_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_EDGE_HIGH = 0x80000000
	// Position of GPIO7_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO7_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO7_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_EDGE_LOW = 0x40000000
	// Position of GPIO7_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO7_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO7_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_LEVEL_HIGH = 0x20000000
	// Position of GPIO7_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO7_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO7_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_LEVEL_LOW = 0x10000000
	// Position of GPIO6_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO6_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO6_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_EDGE_HIGH = 0x8000000
	// Position of GPIO6_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO6_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO6_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_EDGE_LOW = 0x4000000
	// Position of GPIO6_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO6_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO6_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_LEVEL_HIGH = 0x2000000
	// Position of GPIO6_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO6_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO6_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_LEVEL_LOW = 0x1000000
	// Position of GPIO5_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO5_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO5_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_EDGE_HIGH = 0x800000
	// Position of GPIO5_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO5_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_EDGE_LOW_Msk = 0x400000
	// Bit GPIO5_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_EDGE_LOW = 0x400000
	// Position of GPIO5_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO5_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO5_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_LEVEL_HIGH = 0x200000
	// Position of GPIO5_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO5_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO5_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_LEVEL_LOW = 0x100000
	// Position of GPIO4_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO4_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO4_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_EDGE_HIGH = 0x80000
	// Position of GPIO4_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO4_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_EDGE_LOW_Msk = 0x40000
	// Bit GPIO4_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_EDGE_LOW = 0x40000
	// Position of GPIO4_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO4_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO4_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_LEVEL_HIGH = 0x20000
	// Position of GPIO4_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO4_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO4_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_LEVEL_LOW = 0x10000
	// Position of GPIO3_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO3_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO3_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_EDGE_HIGH = 0x8000
	// Position of GPIO3_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO3_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_EDGE_LOW_Msk = 0x4000
	// Bit GPIO3_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_EDGE_LOW = 0x4000
	// Position of GPIO3_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO3_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO3_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_LEVEL_HIGH = 0x2000
	// Position of GPIO3_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO3_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO3_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_LEVEL_LOW = 0x1000
	// Position of GPIO2_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO2_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_EDGE_HIGH_Msk = 0x800
	// Bit GPIO2_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_EDGE_HIGH = 0x800
	// Position of GPIO2_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO2_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_EDGE_LOW_Msk = 0x400
	// Bit GPIO2_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_EDGE_LOW = 0x400
	// Position of GPIO2_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO2_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO2_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_LEVEL_HIGH = 0x200
	// Position of GPIO2_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO2_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_LEVEL_LOW_Msk = 0x100
	// Bit GPIO2_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_LEVEL_LOW = 0x100
	// Position of GPIO1_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO1_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_EDGE_HIGH_Msk = 0x80
	// Bit GPIO1_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_EDGE_HIGH = 0x80
	// Position of GPIO1_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO1_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_EDGE_LOW_Msk = 0x40
	// Bit GPIO1_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_EDGE_LOW = 0x40
	// Position of GPIO1_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO1_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO1_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_LEVEL_HIGH = 0x20
	// Position of GPIO1_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO1_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_LEVEL_LOW_Msk = 0x10
	// Bit GPIO1_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_LEVEL_LOW = 0x10
	// Position of GPIO0_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO0_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_EDGE_HIGH_Msk = 0x8
	// Bit GPIO0_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_EDGE_HIGH = 0x8
	// Position of GPIO0_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO0_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_EDGE_LOW_Msk = 0x4
	// Bit GPIO0_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_EDGE_LOW = 0x4
	// Position of GPIO0_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO0_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO0_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_LEVEL_HIGH = 0x2
	// Position of GPIO0_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO0_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_LEVEL_LOW_Msk = 0x1
	// Bit GPIO0_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_LEVEL_LOW = 0x1

	// DORMANT_WAKE_INTF1: Interrupt Force for dormant_wake
	// Position of GPIO15_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO15_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO15_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_EDGE_HIGH = 0x80000000
	// Position of GPIO15_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO15_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO15_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_EDGE_LOW = 0x40000000
	// Position of GPIO15_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO15_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO15_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_LEVEL_HIGH = 0x20000000
	// Position of GPIO15_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO15_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO15_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_LEVEL_LOW = 0x10000000
	// Position of GPIO14_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO14_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO14_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_EDGE_HIGH = 0x8000000
	// Position of GPIO14_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO14_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO14_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_EDGE_LOW = 0x4000000
	// Position of GPIO14_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO14_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO14_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_LEVEL_HIGH = 0x2000000
	// Position of GPIO14_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO14_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO14_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_LEVEL_LOW = 0x1000000
	// Position of GPIO13_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO13_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO13_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_EDGE_HIGH = 0x800000
	// Position of GPIO13_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO13_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_EDGE_LOW_Msk = 0x400000
	// Bit GPIO13_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_EDGE_LOW = 0x400000
	// Position of GPIO13_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO13_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO13_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_LEVEL_HIGH = 0x200000
	// Position of GPIO13_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO13_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO13_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_LEVEL_LOW = 0x100000
	// Position of GPIO12_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO12_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO12_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_EDGE_HIGH = 0x80000
	// Position of GPIO12_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO12_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_EDGE_LOW_Msk = 0x40000
	// Bit GPIO12_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_EDGE_LOW = 0x40000
	// Position of GPIO12_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO12_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO12_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_LEVEL_HIGH = 0x20000
	// Position of GPIO12_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO12_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO12_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_LEVEL_LOW = 0x10000
	// Position of GPIO11_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO11_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO11_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_EDGE_HIGH = 0x8000
	// Position of GPIO11_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO11_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_EDGE_LOW_Msk = 0x4000
	// Bit GPIO11_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_EDGE_LOW = 0x4000
	// Position of GPIO11_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO11_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO11_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_LEVEL_HIGH = 0x2000
	// Position of GPIO11_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO11_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO11_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_LEVEL_LOW = 0x1000
	// Position of GPIO10_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO10_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_EDGE_HIGH_Msk = 0x800
	// Bit GPIO10_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_EDGE_HIGH = 0x800
	// Position of GPIO10_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO10_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_EDGE_LOW_Msk = 0x400
	// Bit GPIO10_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_EDGE_LOW = 0x400
	// Position of GPIO10_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO10_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO10_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_LEVEL_HIGH = 0x200
	// Position of GPIO10_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO10_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_LEVEL_LOW_Msk = 0x100
	// Bit GPIO10_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_LEVEL_LOW = 0x100
	// Position of GPIO9_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO9_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_EDGE_HIGH_Msk = 0x80
	// Bit GPIO9_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_EDGE_HIGH = 0x80
	// Position of GPIO9_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO9_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_EDGE_LOW_Msk = 0x40
	// Bit GPIO9_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_EDGE_LOW = 0x40
	// Position of GPIO9_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO9_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO9_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_LEVEL_HIGH = 0x20
	// Position of GPIO9_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO9_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_LEVEL_LOW_Msk = 0x10
	// Bit GPIO9_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_LEVEL_LOW = 0x10
	// Position of GPIO8_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO8_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_EDGE_HIGH_Msk = 0x8
	// Bit GPIO8_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_EDGE_HIGH = 0x8
	// Position of GPIO8_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO8_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_EDGE_LOW_Msk = 0x4
	// Bit GPIO8_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_EDGE_LOW = 0x4
	// Position of GPIO8_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO8_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO8_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_LEVEL_HIGH = 0x2
	// Position of GPIO8_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO8_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_LEVEL_LOW_Msk = 0x1
	// Bit GPIO8_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_LEVEL_LOW = 0x1

	// DORMANT_WAKE_INTF2: Interrupt Force for dormant_wake
	// Position of GPIO23_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO23_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO23_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_EDGE_HIGH = 0x80000000
	// Position of GPIO23_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO23_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO23_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_EDGE_LOW = 0x40000000
	// Position of GPIO23_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO23_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO23_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_LEVEL_HIGH = 0x20000000
	// Position of GPIO23_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO23_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO23_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_LEVEL_LOW = 0x10000000
	// Position of GPIO22_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO22_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO22_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_EDGE_HIGH = 0x8000000
	// Position of GPIO22_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO22_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO22_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_EDGE_LOW = 0x4000000
	// Position of GPIO22_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO22_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO22_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_LEVEL_HIGH = 0x2000000
	// Position of GPIO22_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO22_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO22_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_LEVEL_LOW = 0x1000000
	// Position of GPIO21_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO21_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO21_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_EDGE_HIGH = 0x800000
	// Position of GPIO21_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO21_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_EDGE_LOW_Msk = 0x400000
	// Bit GPIO21_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_EDGE_LOW = 0x400000
	// Position of GPIO21_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO21_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO21_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_LEVEL_HIGH = 0x200000
	// Position of GPIO21_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO21_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO21_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_LEVEL_LOW = 0x100000
	// Position of GPIO20_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO20_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO20_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_EDGE_HIGH = 0x80000
	// Position of GPIO20_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO20_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_EDGE_LOW_Msk = 0x40000
	// Bit GPIO20_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_EDGE_LOW = 0x40000
	// Position of GPIO20_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO20_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO20_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_LEVEL_HIGH = 0x20000
	// Position of GPIO20_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO20_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO20_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_LEVEL_LOW = 0x10000
	// Position of GPIO19_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO19_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO19_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_EDGE_HIGH = 0x8000
	// Position of GPIO19_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO19_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_EDGE_LOW_Msk = 0x4000
	// Bit GPIO19_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_EDGE_LOW = 0x4000
	// Position of GPIO19_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO19_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO19_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_LEVEL_HIGH = 0x2000
	// Position of GPIO19_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO19_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO19_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_LEVEL_LOW = 0x1000
	// Position of GPIO18_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO18_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_EDGE_HIGH_Msk = 0x800
	// Bit GPIO18_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_EDGE_HIGH = 0x800
	// Position of GPIO18_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO18_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_EDGE_LOW_Msk = 0x400
	// Bit GPIO18_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_EDGE_LOW = 0x400
	// Position of GPIO18_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO18_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO18_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_LEVEL_HIGH = 0x200
	// Position of GPIO18_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO18_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_LEVEL_LOW_Msk = 0x100
	// Bit GPIO18_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_LEVEL_LOW = 0x100
	// Position of GPIO17_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO17_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_EDGE_HIGH_Msk = 0x80
	// Bit GPIO17_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_EDGE_HIGH = 0x80
	// Position of GPIO17_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO17_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_EDGE_LOW_Msk = 0x40
	// Bit GPIO17_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_EDGE_LOW = 0x40
	// Position of GPIO17_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO17_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO17_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_LEVEL_HIGH = 0x20
	// Position of GPIO17_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO17_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_LEVEL_LOW_Msk = 0x10
	// Bit GPIO17_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_LEVEL_LOW = 0x10
	// Position of GPIO16_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO16_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_EDGE_HIGH_Msk = 0x8
	// Bit GPIO16_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_EDGE_HIGH = 0x8
	// Position of GPIO16_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO16_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_EDGE_LOW_Msk = 0x4
	// Bit GPIO16_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_EDGE_LOW = 0x4
	// Position of GPIO16_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO16_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO16_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_LEVEL_HIGH = 0x2
	// Position of GPIO16_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO16_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_LEVEL_LOW_Msk = 0x1
	// Bit GPIO16_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_LEVEL_LOW = 0x1

	// DORMANT_WAKE_INTF3: Interrupt Force for dormant_wake
	// Position of GPIO29_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO29_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO29_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_EDGE_HIGH = 0x800000
	// Position of GPIO29_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO29_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_EDGE_LOW_Msk = 0x400000
	// Bit GPIO29_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_EDGE_LOW = 0x400000
	// Position of GPIO29_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO29_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO29_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_LEVEL_HIGH = 0x200000
	// Position of GPIO29_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO29_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO29_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_LEVEL_LOW = 0x100000
	// Position of GPIO28_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO28_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO28_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_EDGE_HIGH = 0x80000
	// Position of GPIO28_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO28_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_EDGE_LOW_Msk = 0x40000
	// Bit GPIO28_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_EDGE_LOW = 0x40000
	// Position of GPIO28_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO28_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO28_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_LEVEL_HIGH = 0x20000
	// Position of GPIO28_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO28_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO28_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_LEVEL_LOW = 0x10000
	// Position of GPIO27_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO27_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO27_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_EDGE_HIGH = 0x8000
	// Position of GPIO27_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO27_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_EDGE_LOW_Msk = 0x4000
	// Bit GPIO27_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_EDGE_LOW = 0x4000
	// Position of GPIO27_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO27_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO27_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_LEVEL_HIGH = 0x2000
	// Position of GPIO27_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO27_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO27_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_LEVEL_LOW = 0x1000
	// Position of GPIO26_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO26_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_EDGE_HIGH_Msk = 0x800
	// Bit GPIO26_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_EDGE_HIGH = 0x800
	// Position of GPIO26_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO26_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_EDGE_LOW_Msk = 0x400
	// Bit GPIO26_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_EDGE_LOW = 0x400
	// Position of GPIO26_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO26_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO26_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_LEVEL_HIGH = 0x200
	// Position of GPIO26_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO26_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_LEVEL_LOW_Msk = 0x100
	// Bit GPIO26_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_LEVEL_LOW = 0x100
	// Position of GPIO25_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO25_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_EDGE_HIGH_Msk = 0x80
	// Bit GPIO25_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_EDGE_HIGH = 0x80
	// Position of GPIO25_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO25_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_EDGE_LOW_Msk = 0x40
	// Bit GPIO25_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_EDGE_LOW = 0x40
	// Position of GPIO25_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO25_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO25_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_LEVEL_HIGH = 0x20
	// Position of GPIO25_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO25_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_LEVEL_LOW_Msk = 0x10
	// Bit GPIO25_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_LEVEL_LOW = 0x10
	// Position of GPIO24_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO24_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_EDGE_HIGH_Msk = 0x8
	// Bit GPIO24_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_EDGE_HIGH = 0x8
	// Position of GPIO24_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO24_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_EDGE_LOW_Msk = 0x4
	// Bit GPIO24_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_EDGE_LOW = 0x4
	// Position of GPIO24_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO24_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO24_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_LEVEL_HIGH = 0x2
	// Position of GPIO24_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO24_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_LEVEL_LOW_Msk = 0x1
	// Bit GPIO24_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_LEVEL_LOW = 0x1

	// DORMANT_WAKE_INTS0: Interrupt status after masking & forcing for dormant_wake
	// Position of GPIO7_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO7_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO7_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_EDGE_HIGH = 0x80000000
	// Position of GPIO7_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO7_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO7_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_EDGE_LOW = 0x40000000
	// Position of GPIO7_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO7_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO7_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_LEVEL_HIGH = 0x20000000
	// Position of GPIO7_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO7_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO7_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_LEVEL_LOW = 0x10000000
	// Position of GPIO6_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO6_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO6_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_EDGE_HIGH = 0x8000000
	// Position of GPIO6_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO6_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO6_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_EDGE_LOW = 0x4000000
	// Position of GPIO6_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO6_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO6_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_LEVEL_HIGH = 0x2000000
	// Position of GPIO6_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO6_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO6_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_LEVEL_LOW = 0x1000000
	// Position of GPIO5_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO5_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO5_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_EDGE_HIGH = 0x800000
	// Position of GPIO5_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO5_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_EDGE_LOW_Msk = 0x400000
	// Bit GPIO5_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_EDGE_LOW = 0x400000
	// Position of GPIO5_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO5_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO5_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_LEVEL_HIGH = 0x200000
	// Position of GPIO5_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO5_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO5_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_LEVEL_LOW = 0x100000
	// Position of GPIO4_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO4_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO4_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_EDGE_HIGH = 0x80000
	// Position of GPIO4_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO4_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_EDGE_LOW_Msk = 0x40000
	// Bit GPIO4_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_EDGE_LOW = 0x40000
	// Position of GPIO4_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO4_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO4_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_LEVEL_HIGH = 0x20000
	// Position of GPIO4_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO4_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO4_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_LEVEL_LOW = 0x10000
	// Position of GPIO3_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO3_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO3_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_EDGE_HIGH = 0x8000
	// Position of GPIO3_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO3_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_EDGE_LOW_Msk = 0x4000
	// Bit GPIO3_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_EDGE_LOW = 0x4000
	// Position of GPIO3_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO3_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO3_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_LEVEL_HIGH = 0x2000
	// Position of GPIO3_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO3_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO3_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_LEVEL_LOW = 0x1000
	// Position of GPIO2_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO2_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_EDGE_HIGH_Msk = 0x800
	// Bit GPIO2_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_EDGE_HIGH = 0x800
	// Position of GPIO2_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO2_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_EDGE_LOW_Msk = 0x400
	// Bit GPIO2_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_EDGE_LOW = 0x400
	// Position of GPIO2_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO2_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO2_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_LEVEL_HIGH = 0x200
	// Position of GPIO2_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO2_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_LEVEL_LOW_Msk = 0x100
	// Bit GPIO2_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_LEVEL_LOW = 0x100
	// Position of GPIO1_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO1_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_EDGE_HIGH_Msk = 0x80
	// Bit GPIO1_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_EDGE_HIGH = 0x80
	// Position of GPIO1_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO1_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_EDGE_LOW_Msk = 0x40
	// Bit GPIO1_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_EDGE_LOW = 0x40
	// Position of GPIO1_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO1_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO1_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_LEVEL_HIGH = 0x20
	// Position of GPIO1_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO1_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_LEVEL_LOW_Msk = 0x10
	// Bit GPIO1_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_LEVEL_LOW = 0x10
	// Position of GPIO0_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO0_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_EDGE_HIGH_Msk = 0x8
	// Bit GPIO0_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_EDGE_HIGH = 0x8
	// Position of GPIO0_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO0_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_EDGE_LOW_Msk = 0x4
	// Bit GPIO0_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_EDGE_LOW = 0x4
	// Position of GPIO0_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO0_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO0_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_LEVEL_HIGH = 0x2
	// Position of GPIO0_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO0_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_LEVEL_LOW_Msk = 0x1
	// Bit GPIO0_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_LEVEL_LOW = 0x1

	// DORMANT_WAKE_INTS1: Interrupt status after masking & forcing for dormant_wake
	// Position of GPIO15_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO15_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO15_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_EDGE_HIGH = 0x80000000
	// Position of GPIO15_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO15_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO15_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_EDGE_LOW = 0x40000000
	// Position of GPIO15_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO15_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO15_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_LEVEL_HIGH = 0x20000000
	// Position of GPIO15_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO15_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO15_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_LEVEL_LOW = 0x10000000
	// Position of GPIO14_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO14_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO14_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_EDGE_HIGH = 0x8000000
	// Position of GPIO14_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO14_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO14_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_EDGE_LOW = 0x4000000
	// Position of GPIO14_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO14_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO14_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_LEVEL_HIGH = 0x2000000
	// Position of GPIO14_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO14_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO14_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_LEVEL_LOW = 0x1000000
	// Position of GPIO13_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO13_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO13_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_EDGE_HIGH = 0x800000
	// Position of GPIO13_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO13_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_EDGE_LOW_Msk = 0x400000
	// Bit GPIO13_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_EDGE_LOW = 0x400000
	// Position of GPIO13_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO13_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO13_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_LEVEL_HIGH = 0x200000
	// Position of GPIO13_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO13_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO13_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_LEVEL_LOW = 0x100000
	// Position of GPIO12_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO12_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO12_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_EDGE_HIGH = 0x80000
	// Position of GPIO12_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO12_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_EDGE_LOW_Msk = 0x40000
	// Bit GPIO12_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_EDGE_LOW = 0x40000
	// Position of GPIO12_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO12_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO12_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_LEVEL_HIGH = 0x20000
	// Position of GPIO12_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO12_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO12_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_LEVEL_LOW = 0x10000
	// Position of GPIO11_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO11_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO11_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_EDGE_HIGH = 0x8000
	// Position of GPIO11_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO11_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_EDGE_LOW_Msk = 0x4000
	// Bit GPIO11_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_EDGE_LOW = 0x4000
	// Position of GPIO11_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO11_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO11_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_LEVEL_HIGH = 0x2000
	// Position of GPIO11_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO11_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO11_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_LEVEL_LOW = 0x1000
	// Position of GPIO10_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO10_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_EDGE_HIGH_Msk = 0x800
	// Bit GPIO10_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_EDGE_HIGH = 0x800
	// Position of GPIO10_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO10_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_EDGE_LOW_Msk = 0x400
	// Bit GPIO10_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_EDGE_LOW = 0x400
	// Position of GPIO10_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO10_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO10_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_LEVEL_HIGH = 0x200
	// Position of GPIO10_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO10_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_LEVEL_LOW_Msk = 0x100
	// Bit GPIO10_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_LEVEL_LOW = 0x100
	// Position of GPIO9_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO9_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_EDGE_HIGH_Msk = 0x80
	// Bit GPIO9_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_EDGE_HIGH = 0x80
	// Position of GPIO9_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO9_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_EDGE_LOW_Msk = 0x40
	// Bit GPIO9_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_EDGE_LOW = 0x40
	// Position of GPIO9_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO9_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO9_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_LEVEL_HIGH = 0x20
	// Position of GPIO9_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO9_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_LEVEL_LOW_Msk = 0x10
	// Bit GPIO9_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_LEVEL_LOW = 0x10
	// Position of GPIO8_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO8_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_EDGE_HIGH_Msk = 0x8
	// Bit GPIO8_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_EDGE_HIGH = 0x8
	// Position of GPIO8_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO8_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_EDGE_LOW_Msk = 0x4
	// Bit GPIO8_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_EDGE_LOW = 0x4
	// Position of GPIO8_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO8_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO8_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_LEVEL_HIGH = 0x2
	// Position of GPIO8_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO8_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_LEVEL_LOW_Msk = 0x1
	// Bit GPIO8_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_LEVEL_LOW = 0x1

	// DORMANT_WAKE_INTS2: Interrupt status after masking & forcing for dormant_wake
	// Position of GPIO23_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_EDGE_HIGH_Pos = 0x1f
	// Bit mask of GPIO23_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_EDGE_HIGH_Msk = 0x80000000
	// Bit GPIO23_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_EDGE_HIGH = 0x80000000
	// Position of GPIO23_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_EDGE_LOW_Pos = 0x1e
	// Bit mask of GPIO23_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_EDGE_LOW_Msk = 0x40000000
	// Bit GPIO23_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_EDGE_LOW = 0x40000000
	// Position of GPIO23_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_LEVEL_HIGH_Pos = 0x1d
	// Bit mask of GPIO23_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_LEVEL_HIGH_Msk = 0x20000000
	// Bit GPIO23_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_LEVEL_HIGH = 0x20000000
	// Position of GPIO23_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_LEVEL_LOW_Pos = 0x1c
	// Bit mask of GPIO23_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_LEVEL_LOW_Msk = 0x10000000
	// Bit GPIO23_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_LEVEL_LOW = 0x10000000
	// Position of GPIO22_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_EDGE_HIGH_Pos = 0x1b
	// Bit mask of GPIO22_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_EDGE_HIGH_Msk = 0x8000000
	// Bit GPIO22_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_EDGE_HIGH = 0x8000000
	// Position of GPIO22_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_EDGE_LOW_Pos = 0x1a
	// Bit mask of GPIO22_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_EDGE_LOW_Msk = 0x4000000
	// Bit GPIO22_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_EDGE_LOW = 0x4000000
	// Position of GPIO22_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_LEVEL_HIGH_Pos = 0x19
	// Bit mask of GPIO22_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_LEVEL_HIGH_Msk = 0x2000000
	// Bit GPIO22_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_LEVEL_HIGH = 0x2000000
	// Position of GPIO22_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_LEVEL_LOW_Pos = 0x18
	// Bit mask of GPIO22_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_LEVEL_LOW_Msk = 0x1000000
	// Bit GPIO22_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_LEVEL_LOW = 0x1000000
	// Position of GPIO21_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO21_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO21_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_EDGE_HIGH = 0x800000
	// Position of GPIO21_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO21_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_EDGE_LOW_Msk = 0x400000
	// Bit GPIO21_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_EDGE_LOW = 0x400000
	// Position of GPIO21_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO21_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO21_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_LEVEL_HIGH = 0x200000
	// Position of GPIO21_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO21_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO21_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_LEVEL_LOW = 0x100000
	// Position of GPIO20_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO20_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO20_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_EDGE_HIGH = 0x80000
	// Position of GPIO20_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO20_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_EDGE_LOW_Msk = 0x40000
	// Bit GPIO20_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_EDGE_LOW = 0x40000
	// Position of GPIO20_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO20_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO20_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_LEVEL_HIGH = 0x20000
	// Position of GPIO20_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO20_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO20_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_LEVEL_LOW = 0x10000
	// Position of GPIO19_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO19_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO19_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_EDGE_HIGH = 0x8000
	// Position of GPIO19_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO19_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_EDGE_LOW_Msk = 0x4000
	// Bit GPIO19_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_EDGE_LOW = 0x4000
	// Position of GPIO19_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO19_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO19_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_LEVEL_HIGH = 0x2000
	// Position of GPIO19_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO19_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO19_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_LEVEL_LOW = 0x1000
	// Position of GPIO18_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO18_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_EDGE_HIGH_Msk = 0x800
	// Bit GPIO18_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_EDGE_HIGH = 0x800
	// Position of GPIO18_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO18_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_EDGE_LOW_Msk = 0x400
	// Bit GPIO18_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_EDGE_LOW = 0x400
	// Position of GPIO18_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO18_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO18_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_LEVEL_HIGH = 0x200
	// Position of GPIO18_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO18_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_LEVEL_LOW_Msk = 0x100
	// Bit GPIO18_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_LEVEL_LOW = 0x100
	// Position of GPIO17_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO17_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_EDGE_HIGH_Msk = 0x80
	// Bit GPIO17_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_EDGE_HIGH = 0x80
	// Position of GPIO17_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO17_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_EDGE_LOW_Msk = 0x40
	// Bit GPIO17_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_EDGE_LOW = 0x40
	// Position of GPIO17_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO17_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO17_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_LEVEL_HIGH = 0x20
	// Position of GPIO17_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO17_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_LEVEL_LOW_Msk = 0x10
	// Bit GPIO17_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_LEVEL_LOW = 0x10
	// Position of GPIO16_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO16_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_EDGE_HIGH_Msk = 0x8
	// Bit GPIO16_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_EDGE_HIGH = 0x8
	// Position of GPIO16_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO16_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_EDGE_LOW_Msk = 0x4
	// Bit GPIO16_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_EDGE_LOW = 0x4
	// Position of GPIO16_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO16_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO16_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_LEVEL_HIGH = 0x2
	// Position of GPIO16_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO16_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_LEVEL_LOW_Msk = 0x1
	// Bit GPIO16_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_LEVEL_LOW = 0x1

	// DORMANT_WAKE_INTS3: Interrupt status after masking & forcing for dormant_wake
	// Position of GPIO29_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO29_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO29_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_EDGE_HIGH = 0x800000
	// Position of GPIO29_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO29_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_EDGE_LOW_Msk = 0x400000
	// Bit GPIO29_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_EDGE_LOW = 0x400000
	// Position of GPIO29_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO29_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO29_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_LEVEL_HIGH = 0x200000
	// Position of GPIO29_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO29_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO29_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_LEVEL_LOW = 0x100000
	// Position of GPIO28_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO28_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO28_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_EDGE_HIGH = 0x80000
	// Position of GPIO28_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO28_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_EDGE_LOW_Msk = 0x40000
	// Bit GPIO28_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_EDGE_LOW = 0x40000
	// Position of GPIO28_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO28_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO28_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_LEVEL_HIGH = 0x20000
	// Position of GPIO28_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO28_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO28_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_LEVEL_LOW = 0x10000
	// Position of GPIO27_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO27_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO27_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_EDGE_HIGH = 0x8000
	// Position of GPIO27_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO27_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_EDGE_LOW_Msk = 0x4000
	// Bit GPIO27_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_EDGE_LOW = 0x4000
	// Position of GPIO27_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO27_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO27_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_LEVEL_HIGH = 0x2000
	// Position of GPIO27_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO27_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO27_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_LEVEL_LOW = 0x1000
	// Position of GPIO26_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO26_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_EDGE_HIGH_Msk = 0x800
	// Bit GPIO26_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_EDGE_HIGH = 0x800
	// Position of GPIO26_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO26_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_EDGE_LOW_Msk = 0x400
	// Bit GPIO26_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_EDGE_LOW = 0x400
	// Position of GPIO26_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO26_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO26_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_LEVEL_HIGH = 0x200
	// Position of GPIO26_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO26_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_LEVEL_LOW_Msk = 0x100
	// Bit GPIO26_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_LEVEL_LOW = 0x100
	// Position of GPIO25_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO25_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_EDGE_HIGH_Msk = 0x80
	// Bit GPIO25_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_EDGE_HIGH = 0x80
	// Position of GPIO25_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO25_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_EDGE_LOW_Msk = 0x40
	// Bit GPIO25_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_EDGE_LOW = 0x40
	// Position of GPIO25_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO25_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO25_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_LEVEL_HIGH = 0x20
	// Position of GPIO25_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO25_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_LEVEL_LOW_Msk = 0x10
	// Bit GPIO25_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_LEVEL_LOW = 0x10
	// Position of GPIO24_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO24_EDGE_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_EDGE_HIGH_Msk = 0x8
	// Bit GPIO24_EDGE_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_EDGE_HIGH = 0x8
	// Position of GPIO24_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO24_EDGE_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_EDGE_LOW_Msk = 0x4
	// Bit GPIO24_EDGE_LOW.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_EDGE_LOW = 0x4
	// Position of GPIO24_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO24_LEVEL_HIGH field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO24_LEVEL_HIGH.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_LEVEL_HIGH = 0x2
	// Position of GPIO24_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO24_LEVEL_LOW field.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_LEVEL_LOW_Msk = 0x1
	// Bit GPIO24_LEVEL_LOW.
	IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_LEVEL_LOW = 0x1
)

// Constants for IO_QSPI
const (
	// GPIO_QSPI_SCLK_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_QSPI_GPIO_QSPI_SCLK_STATUS_OUTFROMPERI = 0x100

	// GPIO_QSPI_SCLK_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL_Msk      = 0x1f
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL_XIP_SCLK = 0x0
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL_SIO_30   = 0x5
	IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL_NULL     = 0x1f

	// GPIO_QSPI_SS_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_QSPI_GPIO_QSPI_SS_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_QSPI_GPIO_QSPI_SS_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_QSPI_GPIO_QSPI_SS_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_QSPI_GPIO_QSPI_SS_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_QSPI_GPIO_QSPI_SS_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_QSPI_GPIO_QSPI_SS_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_QSPI_GPIO_QSPI_SS_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_QSPI_GPIO_QSPI_SS_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_QSPI_GPIO_QSPI_SS_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_QSPI_GPIO_QSPI_SS_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_QSPI_GPIO_QSPI_SS_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_QSPI_GPIO_QSPI_SS_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_QSPI_GPIO_QSPI_SS_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_QSPI_GPIO_QSPI_SS_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_QSPI_GPIO_QSPI_SS_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_QSPI_GPIO_QSPI_SS_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_QSPI_GPIO_QSPI_SS_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_QSPI_GPIO_QSPI_SS_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_QSPI_GPIO_QSPI_SS_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_QSPI_GPIO_QSPI_SS_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_QSPI_GPIO_QSPI_SS_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_QSPI_GPIO_QSPI_SS_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_QSPI_GPIO_QSPI_SS_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_QSPI_GPIO_QSPI_SS_STATUS_OUTFROMPERI = 0x100

	// GPIO_QSPI_SS_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL_Msk      = 0x1f
	IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL_XIP_SS_N = 0x0
	IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL_SIO_31   = 0x5
	IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL_NULL     = 0x1f

	// GPIO_QSPI_SD0_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_QSPI_GPIO_QSPI_SD0_STATUS_OUTFROMPERI = 0x100

	// GPIO_QSPI_SD0_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL_Msk     = 0x1f
	IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL_XIP_SD0 = 0x0
	IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL_SIO_32  = 0x5
	IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL_NULL    = 0x1f

	// GPIO_QSPI_SD1_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_QSPI_GPIO_QSPI_SD1_STATUS_OUTFROMPERI = 0x100

	// GPIO_QSPI_SD1_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL_Msk     = 0x1f
	IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL_XIP_SD1 = 0x0
	IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL_SIO_33  = 0x5
	IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL_NULL    = 0x1f

	// GPIO_QSPI_SD2_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_QSPI_GPIO_QSPI_SD2_STATUS_OUTFROMPERI = 0x100

	// GPIO_QSPI_SD2_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL_Msk     = 0x1f
	IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL_XIP_SD2 = 0x0
	IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL_SIO_34  = 0x5
	IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL_NULL    = 0x1f

	// GPIO_QSPI_SD3_STATUS: GPIO status
	// Position of IRQTOPROC field.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_IRQTOPROC_Pos = 0x1a
	// Bit mask of IRQTOPROC field.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_IRQTOPROC_Msk = 0x4000000
	// Bit IRQTOPROC.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_IRQTOPROC = 0x4000000
	// Position of IRQFROMPAD field.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_IRQFROMPAD_Pos = 0x18
	// Bit mask of IRQFROMPAD field.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_IRQFROMPAD_Msk = 0x1000000
	// Bit IRQFROMPAD.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_IRQFROMPAD = 0x1000000
	// Position of INTOPERI field.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_INTOPERI_Pos = 0x13
	// Bit mask of INTOPERI field.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_INTOPERI_Msk = 0x80000
	// Bit INTOPERI.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_INTOPERI = 0x80000
	// Position of INFROMPAD field.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_INFROMPAD_Pos = 0x11
	// Bit mask of INFROMPAD field.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_INFROMPAD_Msk = 0x20000
	// Bit INFROMPAD.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_INFROMPAD = 0x20000
	// Position of OETOPAD field.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_OETOPAD_Pos = 0xd
	// Bit mask of OETOPAD field.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_OETOPAD_Msk = 0x2000
	// Bit OETOPAD.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_OETOPAD = 0x2000
	// Position of OEFROMPERI field.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_OEFROMPERI_Pos = 0xc
	// Bit mask of OEFROMPERI field.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_OEFROMPERI_Msk = 0x1000
	// Bit OEFROMPERI.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_OEFROMPERI = 0x1000
	// Position of OUTTOPAD field.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_OUTTOPAD_Pos = 0x9
	// Bit mask of OUTTOPAD field.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_OUTTOPAD_Msk = 0x200
	// Bit OUTTOPAD.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_OUTTOPAD = 0x200
	// Position of OUTFROMPERI field.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_OUTFROMPERI_Pos = 0x8
	// Bit mask of OUTFROMPERI field.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_OUTFROMPERI_Msk = 0x100
	// Bit OUTFROMPERI.
	IO_QSPI_GPIO_QSPI_SD3_STATUS_OUTFROMPERI = 0x100

	// GPIO_QSPI_SD3_CTRL: GPIO control including function select and overrides.
	// Position of IRQOVER field.
	IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER_Pos = 0x1c
	// Bit mask of IRQOVER field.
	IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER_Msk = 0x30000000
	// don't invert the interrupt
	IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER_NORMAL = 0x0
	// invert the interrupt
	IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER_INVERT = 0x1
	// drive interrupt low
	IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER_LOW = 0x2
	// drive interrupt high
	IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER_HIGH = 0x3
	// Position of INOVER field.
	IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER_Pos = 0x10
	// Bit mask of INOVER field.
	IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER_Msk = 0x30000
	// don't invert the peri input
	IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER_NORMAL = 0x0
	// invert the peri input
	IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER_INVERT = 0x1
	// drive peri input low
	IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER_LOW = 0x2
	// drive peri input high
	IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER_HIGH = 0x3
	// Position of OEOVER field.
	IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER_Pos = 0xc
	// Bit mask of OEOVER field.
	IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER_Msk = 0x3000
	// drive output enable from peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER_NORMAL = 0x0
	// drive output enable from inverse of peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER_INVERT = 0x1
	// disable output
	IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER_DISABLE = 0x2
	// enable output
	IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER_ENABLE = 0x3
	// Position of OUTOVER field.
	IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER_Pos = 0x8
	// Bit mask of OUTOVER field.
	IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER_Msk = 0x300
	// drive output from peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER_NORMAL = 0x0
	// drive output from inverse of peripheral signal selected by funcsel
	IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER_INVERT = 0x1
	// drive output low
	IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER_LOW = 0x2
	// drive output high
	IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER_HIGH = 0x3
	// Position of FUNCSEL field.
	IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL_Pos = 0x0
	// Bit mask of FUNCSEL field.
	IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL_Msk     = 0x1f
	IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL_XIP_SD3 = 0x0
	IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL_SIO_35  = 0x5
	IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL_NULL    = 0x1f

	// INTR: Raw Interrupts
	// Position of GPIO_QSPI_SD3_EDGE_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SD3_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO_QSPI_SD3_EDGE_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SD3_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO_QSPI_SD3_EDGE_HIGH.
	IO_QSPI_INTR_GPIO_QSPI_SD3_EDGE_HIGH = 0x800000
	// Position of GPIO_QSPI_SD3_EDGE_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SD3_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO_QSPI_SD3_EDGE_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SD3_EDGE_LOW_Msk = 0x400000
	// Bit GPIO_QSPI_SD3_EDGE_LOW.
	IO_QSPI_INTR_GPIO_QSPI_SD3_EDGE_LOW = 0x400000
	// Position of GPIO_QSPI_SD3_LEVEL_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SD3_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO_QSPI_SD3_LEVEL_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SD3_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO_QSPI_SD3_LEVEL_HIGH.
	IO_QSPI_INTR_GPIO_QSPI_SD3_LEVEL_HIGH = 0x200000
	// Position of GPIO_QSPI_SD3_LEVEL_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SD3_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO_QSPI_SD3_LEVEL_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SD3_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO_QSPI_SD3_LEVEL_LOW.
	IO_QSPI_INTR_GPIO_QSPI_SD3_LEVEL_LOW = 0x100000
	// Position of GPIO_QSPI_SD2_EDGE_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SD2_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO_QSPI_SD2_EDGE_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SD2_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO_QSPI_SD2_EDGE_HIGH.
	IO_QSPI_INTR_GPIO_QSPI_SD2_EDGE_HIGH = 0x80000
	// Position of GPIO_QSPI_SD2_EDGE_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SD2_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO_QSPI_SD2_EDGE_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SD2_EDGE_LOW_Msk = 0x40000
	// Bit GPIO_QSPI_SD2_EDGE_LOW.
	IO_QSPI_INTR_GPIO_QSPI_SD2_EDGE_LOW = 0x40000
	// Position of GPIO_QSPI_SD2_LEVEL_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SD2_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO_QSPI_SD2_LEVEL_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SD2_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO_QSPI_SD2_LEVEL_HIGH.
	IO_QSPI_INTR_GPIO_QSPI_SD2_LEVEL_HIGH = 0x20000
	// Position of GPIO_QSPI_SD2_LEVEL_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SD2_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO_QSPI_SD2_LEVEL_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SD2_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO_QSPI_SD2_LEVEL_LOW.
	IO_QSPI_INTR_GPIO_QSPI_SD2_LEVEL_LOW = 0x10000
	// Position of GPIO_QSPI_SD1_EDGE_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SD1_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO_QSPI_SD1_EDGE_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SD1_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO_QSPI_SD1_EDGE_HIGH.
	IO_QSPI_INTR_GPIO_QSPI_SD1_EDGE_HIGH = 0x8000
	// Position of GPIO_QSPI_SD1_EDGE_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SD1_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO_QSPI_SD1_EDGE_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SD1_EDGE_LOW_Msk = 0x4000
	// Bit GPIO_QSPI_SD1_EDGE_LOW.
	IO_QSPI_INTR_GPIO_QSPI_SD1_EDGE_LOW = 0x4000
	// Position of GPIO_QSPI_SD1_LEVEL_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SD1_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO_QSPI_SD1_LEVEL_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SD1_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO_QSPI_SD1_LEVEL_HIGH.
	IO_QSPI_INTR_GPIO_QSPI_SD1_LEVEL_HIGH = 0x2000
	// Position of GPIO_QSPI_SD1_LEVEL_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SD1_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO_QSPI_SD1_LEVEL_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SD1_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO_QSPI_SD1_LEVEL_LOW.
	IO_QSPI_INTR_GPIO_QSPI_SD1_LEVEL_LOW = 0x1000
	// Position of GPIO_QSPI_SD0_EDGE_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SD0_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO_QSPI_SD0_EDGE_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SD0_EDGE_HIGH_Msk = 0x800
	// Bit GPIO_QSPI_SD0_EDGE_HIGH.
	IO_QSPI_INTR_GPIO_QSPI_SD0_EDGE_HIGH = 0x800
	// Position of GPIO_QSPI_SD0_EDGE_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SD0_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO_QSPI_SD0_EDGE_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SD0_EDGE_LOW_Msk = 0x400
	// Bit GPIO_QSPI_SD0_EDGE_LOW.
	IO_QSPI_INTR_GPIO_QSPI_SD0_EDGE_LOW = 0x400
	// Position of GPIO_QSPI_SD0_LEVEL_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SD0_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO_QSPI_SD0_LEVEL_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SD0_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO_QSPI_SD0_LEVEL_HIGH.
	IO_QSPI_INTR_GPIO_QSPI_SD0_LEVEL_HIGH = 0x200
	// Position of GPIO_QSPI_SD0_LEVEL_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SD0_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO_QSPI_SD0_LEVEL_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SD0_LEVEL_LOW_Msk = 0x100
	// Bit GPIO_QSPI_SD0_LEVEL_LOW.
	IO_QSPI_INTR_GPIO_QSPI_SD0_LEVEL_LOW = 0x100
	// Position of GPIO_QSPI_SS_EDGE_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SS_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO_QSPI_SS_EDGE_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SS_EDGE_HIGH_Msk = 0x80
	// Bit GPIO_QSPI_SS_EDGE_HIGH.
	IO_QSPI_INTR_GPIO_QSPI_SS_EDGE_HIGH = 0x80
	// Position of GPIO_QSPI_SS_EDGE_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SS_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO_QSPI_SS_EDGE_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SS_EDGE_LOW_Msk = 0x40
	// Bit GPIO_QSPI_SS_EDGE_LOW.
	IO_QSPI_INTR_GPIO_QSPI_SS_EDGE_LOW = 0x40
	// Position of GPIO_QSPI_SS_LEVEL_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SS_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO_QSPI_SS_LEVEL_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SS_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO_QSPI_SS_LEVEL_HIGH.
	IO_QSPI_INTR_GPIO_QSPI_SS_LEVEL_HIGH = 0x20
	// Position of GPIO_QSPI_SS_LEVEL_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SS_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO_QSPI_SS_LEVEL_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SS_LEVEL_LOW_Msk = 0x10
	// Bit GPIO_QSPI_SS_LEVEL_LOW.
	IO_QSPI_INTR_GPIO_QSPI_SS_LEVEL_LOW = 0x10
	// Position of GPIO_QSPI_SCLK_EDGE_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SCLK_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO_QSPI_SCLK_EDGE_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SCLK_EDGE_HIGH_Msk = 0x8
	// Bit GPIO_QSPI_SCLK_EDGE_HIGH.
	IO_QSPI_INTR_GPIO_QSPI_SCLK_EDGE_HIGH = 0x8
	// Position of GPIO_QSPI_SCLK_EDGE_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SCLK_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO_QSPI_SCLK_EDGE_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SCLK_EDGE_LOW_Msk = 0x4
	// Bit GPIO_QSPI_SCLK_EDGE_LOW.
	IO_QSPI_INTR_GPIO_QSPI_SCLK_EDGE_LOW = 0x4
	// Position of GPIO_QSPI_SCLK_LEVEL_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO_QSPI_SCLK_LEVEL_HIGH field.
	IO_QSPI_INTR_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO_QSPI_SCLK_LEVEL_HIGH.
	IO_QSPI_INTR_GPIO_QSPI_SCLK_LEVEL_HIGH = 0x2
	// Position of GPIO_QSPI_SCLK_LEVEL_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SCLK_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO_QSPI_SCLK_LEVEL_LOW field.
	IO_QSPI_INTR_GPIO_QSPI_SCLK_LEVEL_LOW_Msk = 0x1
	// Bit GPIO_QSPI_SCLK_LEVEL_LOW.
	IO_QSPI_INTR_GPIO_QSPI_SCLK_LEVEL_LOW = 0x1

	// PROC0_INTE: Interrupt Enable for proc0
	// Position of GPIO_QSPI_SD3_EDGE_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO_QSPI_SD3_EDGE_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO_QSPI_SD3_EDGE_HIGH.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_EDGE_HIGH = 0x800000
	// Position of GPIO_QSPI_SD3_EDGE_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO_QSPI_SD3_EDGE_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_EDGE_LOW_Msk = 0x400000
	// Bit GPIO_QSPI_SD3_EDGE_LOW.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_EDGE_LOW = 0x400000
	// Position of GPIO_QSPI_SD3_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO_QSPI_SD3_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO_QSPI_SD3_LEVEL_HIGH.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_LEVEL_HIGH = 0x200000
	// Position of GPIO_QSPI_SD3_LEVEL_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO_QSPI_SD3_LEVEL_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO_QSPI_SD3_LEVEL_LOW.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_LEVEL_LOW = 0x100000
	// Position of GPIO_QSPI_SD2_EDGE_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO_QSPI_SD2_EDGE_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO_QSPI_SD2_EDGE_HIGH.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_EDGE_HIGH = 0x80000
	// Position of GPIO_QSPI_SD2_EDGE_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO_QSPI_SD2_EDGE_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_EDGE_LOW_Msk = 0x40000
	// Bit GPIO_QSPI_SD2_EDGE_LOW.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_EDGE_LOW = 0x40000
	// Position of GPIO_QSPI_SD2_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO_QSPI_SD2_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO_QSPI_SD2_LEVEL_HIGH.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_LEVEL_HIGH = 0x20000
	// Position of GPIO_QSPI_SD2_LEVEL_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO_QSPI_SD2_LEVEL_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO_QSPI_SD2_LEVEL_LOW.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_LEVEL_LOW = 0x10000
	// Position of GPIO_QSPI_SD1_EDGE_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO_QSPI_SD1_EDGE_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO_QSPI_SD1_EDGE_HIGH.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_EDGE_HIGH = 0x8000
	// Position of GPIO_QSPI_SD1_EDGE_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO_QSPI_SD1_EDGE_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_EDGE_LOW_Msk = 0x4000
	// Bit GPIO_QSPI_SD1_EDGE_LOW.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_EDGE_LOW = 0x4000
	// Position of GPIO_QSPI_SD1_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO_QSPI_SD1_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO_QSPI_SD1_LEVEL_HIGH.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_LEVEL_HIGH = 0x2000
	// Position of GPIO_QSPI_SD1_LEVEL_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO_QSPI_SD1_LEVEL_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO_QSPI_SD1_LEVEL_LOW.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_LEVEL_LOW = 0x1000
	// Position of GPIO_QSPI_SD0_EDGE_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO_QSPI_SD0_EDGE_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_EDGE_HIGH_Msk = 0x800
	// Bit GPIO_QSPI_SD0_EDGE_HIGH.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_EDGE_HIGH = 0x800
	// Position of GPIO_QSPI_SD0_EDGE_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO_QSPI_SD0_EDGE_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_EDGE_LOW_Msk = 0x400
	// Bit GPIO_QSPI_SD0_EDGE_LOW.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_EDGE_LOW = 0x400
	// Position of GPIO_QSPI_SD0_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO_QSPI_SD0_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO_QSPI_SD0_LEVEL_HIGH.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_LEVEL_HIGH = 0x200
	// Position of GPIO_QSPI_SD0_LEVEL_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO_QSPI_SD0_LEVEL_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_LEVEL_LOW_Msk = 0x100
	// Bit GPIO_QSPI_SD0_LEVEL_LOW.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_LEVEL_LOW = 0x100
	// Position of GPIO_QSPI_SS_EDGE_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO_QSPI_SS_EDGE_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_EDGE_HIGH_Msk = 0x80
	// Bit GPIO_QSPI_SS_EDGE_HIGH.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_EDGE_HIGH = 0x80
	// Position of GPIO_QSPI_SS_EDGE_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO_QSPI_SS_EDGE_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_EDGE_LOW_Msk = 0x40
	// Bit GPIO_QSPI_SS_EDGE_LOW.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_EDGE_LOW = 0x40
	// Position of GPIO_QSPI_SS_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO_QSPI_SS_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO_QSPI_SS_LEVEL_HIGH.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_LEVEL_HIGH = 0x20
	// Position of GPIO_QSPI_SS_LEVEL_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO_QSPI_SS_LEVEL_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_LEVEL_LOW_Msk = 0x10
	// Bit GPIO_QSPI_SS_LEVEL_LOW.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_LEVEL_LOW = 0x10
	// Position of GPIO_QSPI_SCLK_EDGE_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO_QSPI_SCLK_EDGE_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_EDGE_HIGH_Msk = 0x8
	// Bit GPIO_QSPI_SCLK_EDGE_HIGH.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_EDGE_HIGH = 0x8
	// Position of GPIO_QSPI_SCLK_EDGE_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO_QSPI_SCLK_EDGE_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_EDGE_LOW_Msk = 0x4
	// Bit GPIO_QSPI_SCLK_EDGE_LOW.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_EDGE_LOW = 0x4
	// Position of GPIO_QSPI_SCLK_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO_QSPI_SCLK_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO_QSPI_SCLK_LEVEL_HIGH.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH = 0x2
	// Position of GPIO_QSPI_SCLK_LEVEL_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO_QSPI_SCLK_LEVEL_LOW field.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_LEVEL_LOW_Msk = 0x1
	// Bit GPIO_QSPI_SCLK_LEVEL_LOW.
	IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_LEVEL_LOW = 0x1

	// PROC0_INTF: Interrupt Force for proc0
	// Position of GPIO_QSPI_SD3_EDGE_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO_QSPI_SD3_EDGE_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO_QSPI_SD3_EDGE_HIGH.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_EDGE_HIGH = 0x800000
	// Position of GPIO_QSPI_SD3_EDGE_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO_QSPI_SD3_EDGE_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_EDGE_LOW_Msk = 0x400000
	// Bit GPIO_QSPI_SD3_EDGE_LOW.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_EDGE_LOW = 0x400000
	// Position of GPIO_QSPI_SD3_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO_QSPI_SD3_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO_QSPI_SD3_LEVEL_HIGH.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_LEVEL_HIGH = 0x200000
	// Position of GPIO_QSPI_SD3_LEVEL_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO_QSPI_SD3_LEVEL_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO_QSPI_SD3_LEVEL_LOW.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_LEVEL_LOW = 0x100000
	// Position of GPIO_QSPI_SD2_EDGE_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO_QSPI_SD2_EDGE_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO_QSPI_SD2_EDGE_HIGH.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_EDGE_HIGH = 0x80000
	// Position of GPIO_QSPI_SD2_EDGE_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO_QSPI_SD2_EDGE_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_EDGE_LOW_Msk = 0x40000
	// Bit GPIO_QSPI_SD2_EDGE_LOW.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_EDGE_LOW = 0x40000
	// Position of GPIO_QSPI_SD2_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO_QSPI_SD2_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO_QSPI_SD2_LEVEL_HIGH.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_LEVEL_HIGH = 0x20000
	// Position of GPIO_QSPI_SD2_LEVEL_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO_QSPI_SD2_LEVEL_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO_QSPI_SD2_LEVEL_LOW.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_LEVEL_LOW = 0x10000
	// Position of GPIO_QSPI_SD1_EDGE_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO_QSPI_SD1_EDGE_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO_QSPI_SD1_EDGE_HIGH.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_EDGE_HIGH = 0x8000
	// Position of GPIO_QSPI_SD1_EDGE_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO_QSPI_SD1_EDGE_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_EDGE_LOW_Msk = 0x4000
	// Bit GPIO_QSPI_SD1_EDGE_LOW.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_EDGE_LOW = 0x4000
	// Position of GPIO_QSPI_SD1_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO_QSPI_SD1_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO_QSPI_SD1_LEVEL_HIGH.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_LEVEL_HIGH = 0x2000
	// Position of GPIO_QSPI_SD1_LEVEL_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO_QSPI_SD1_LEVEL_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO_QSPI_SD1_LEVEL_LOW.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_LEVEL_LOW = 0x1000
	// Position of GPIO_QSPI_SD0_EDGE_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO_QSPI_SD0_EDGE_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_EDGE_HIGH_Msk = 0x800
	// Bit GPIO_QSPI_SD0_EDGE_HIGH.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_EDGE_HIGH = 0x800
	// Position of GPIO_QSPI_SD0_EDGE_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO_QSPI_SD0_EDGE_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_EDGE_LOW_Msk = 0x400
	// Bit GPIO_QSPI_SD0_EDGE_LOW.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_EDGE_LOW = 0x400
	// Position of GPIO_QSPI_SD0_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO_QSPI_SD0_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO_QSPI_SD0_LEVEL_HIGH.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_LEVEL_HIGH = 0x200
	// Position of GPIO_QSPI_SD0_LEVEL_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO_QSPI_SD0_LEVEL_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_LEVEL_LOW_Msk = 0x100
	// Bit GPIO_QSPI_SD0_LEVEL_LOW.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_LEVEL_LOW = 0x100
	// Position of GPIO_QSPI_SS_EDGE_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO_QSPI_SS_EDGE_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_EDGE_HIGH_Msk = 0x80
	// Bit GPIO_QSPI_SS_EDGE_HIGH.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_EDGE_HIGH = 0x80
	// Position of GPIO_QSPI_SS_EDGE_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO_QSPI_SS_EDGE_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_EDGE_LOW_Msk = 0x40
	// Bit GPIO_QSPI_SS_EDGE_LOW.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_EDGE_LOW = 0x40
	// Position of GPIO_QSPI_SS_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO_QSPI_SS_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO_QSPI_SS_LEVEL_HIGH.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_LEVEL_HIGH = 0x20
	// Position of GPIO_QSPI_SS_LEVEL_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO_QSPI_SS_LEVEL_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_LEVEL_LOW_Msk = 0x10
	// Bit GPIO_QSPI_SS_LEVEL_LOW.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_LEVEL_LOW = 0x10
	// Position of GPIO_QSPI_SCLK_EDGE_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO_QSPI_SCLK_EDGE_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_EDGE_HIGH_Msk = 0x8
	// Bit GPIO_QSPI_SCLK_EDGE_HIGH.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_EDGE_HIGH = 0x8
	// Position of GPIO_QSPI_SCLK_EDGE_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO_QSPI_SCLK_EDGE_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_EDGE_LOW_Msk = 0x4
	// Bit GPIO_QSPI_SCLK_EDGE_LOW.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_EDGE_LOW = 0x4
	// Position of GPIO_QSPI_SCLK_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO_QSPI_SCLK_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO_QSPI_SCLK_LEVEL_HIGH.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH = 0x2
	// Position of GPIO_QSPI_SCLK_LEVEL_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO_QSPI_SCLK_LEVEL_LOW field.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_LEVEL_LOW_Msk = 0x1
	// Bit GPIO_QSPI_SCLK_LEVEL_LOW.
	IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_LEVEL_LOW = 0x1

	// PROC0_INTS: Interrupt status after masking & forcing for proc0
	// Position of GPIO_QSPI_SD3_EDGE_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO_QSPI_SD3_EDGE_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO_QSPI_SD3_EDGE_HIGH.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_EDGE_HIGH = 0x800000
	// Position of GPIO_QSPI_SD3_EDGE_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO_QSPI_SD3_EDGE_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_EDGE_LOW_Msk = 0x400000
	// Bit GPIO_QSPI_SD3_EDGE_LOW.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_EDGE_LOW = 0x400000
	// Position of GPIO_QSPI_SD3_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO_QSPI_SD3_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO_QSPI_SD3_LEVEL_HIGH.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_LEVEL_HIGH = 0x200000
	// Position of GPIO_QSPI_SD3_LEVEL_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO_QSPI_SD3_LEVEL_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO_QSPI_SD3_LEVEL_LOW.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_LEVEL_LOW = 0x100000
	// Position of GPIO_QSPI_SD2_EDGE_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO_QSPI_SD2_EDGE_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO_QSPI_SD2_EDGE_HIGH.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_EDGE_HIGH = 0x80000
	// Position of GPIO_QSPI_SD2_EDGE_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO_QSPI_SD2_EDGE_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_EDGE_LOW_Msk = 0x40000
	// Bit GPIO_QSPI_SD2_EDGE_LOW.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_EDGE_LOW = 0x40000
	// Position of GPIO_QSPI_SD2_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO_QSPI_SD2_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO_QSPI_SD2_LEVEL_HIGH.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_LEVEL_HIGH = 0x20000
	// Position of GPIO_QSPI_SD2_LEVEL_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO_QSPI_SD2_LEVEL_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO_QSPI_SD2_LEVEL_LOW.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_LEVEL_LOW = 0x10000
	// Position of GPIO_QSPI_SD1_EDGE_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO_QSPI_SD1_EDGE_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO_QSPI_SD1_EDGE_HIGH.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_EDGE_HIGH = 0x8000
	// Position of GPIO_QSPI_SD1_EDGE_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO_QSPI_SD1_EDGE_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_EDGE_LOW_Msk = 0x4000
	// Bit GPIO_QSPI_SD1_EDGE_LOW.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_EDGE_LOW = 0x4000
	// Position of GPIO_QSPI_SD1_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO_QSPI_SD1_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO_QSPI_SD1_LEVEL_HIGH.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_LEVEL_HIGH = 0x2000
	// Position of GPIO_QSPI_SD1_LEVEL_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO_QSPI_SD1_LEVEL_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO_QSPI_SD1_LEVEL_LOW.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_LEVEL_LOW = 0x1000
	// Position of GPIO_QSPI_SD0_EDGE_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO_QSPI_SD0_EDGE_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_EDGE_HIGH_Msk = 0x800
	// Bit GPIO_QSPI_SD0_EDGE_HIGH.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_EDGE_HIGH = 0x800
	// Position of GPIO_QSPI_SD0_EDGE_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO_QSPI_SD0_EDGE_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_EDGE_LOW_Msk = 0x400
	// Bit GPIO_QSPI_SD0_EDGE_LOW.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_EDGE_LOW = 0x400
	// Position of GPIO_QSPI_SD0_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO_QSPI_SD0_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO_QSPI_SD0_LEVEL_HIGH.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_LEVEL_HIGH = 0x200
	// Position of GPIO_QSPI_SD0_LEVEL_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO_QSPI_SD0_LEVEL_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_LEVEL_LOW_Msk = 0x100
	// Bit GPIO_QSPI_SD0_LEVEL_LOW.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_LEVEL_LOW = 0x100
	// Position of GPIO_QSPI_SS_EDGE_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO_QSPI_SS_EDGE_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_EDGE_HIGH_Msk = 0x80
	// Bit GPIO_QSPI_SS_EDGE_HIGH.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_EDGE_HIGH = 0x80
	// Position of GPIO_QSPI_SS_EDGE_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO_QSPI_SS_EDGE_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_EDGE_LOW_Msk = 0x40
	// Bit GPIO_QSPI_SS_EDGE_LOW.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_EDGE_LOW = 0x40
	// Position of GPIO_QSPI_SS_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO_QSPI_SS_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO_QSPI_SS_LEVEL_HIGH.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_LEVEL_HIGH = 0x20
	// Position of GPIO_QSPI_SS_LEVEL_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO_QSPI_SS_LEVEL_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_LEVEL_LOW_Msk = 0x10
	// Bit GPIO_QSPI_SS_LEVEL_LOW.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_LEVEL_LOW = 0x10
	// Position of GPIO_QSPI_SCLK_EDGE_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO_QSPI_SCLK_EDGE_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_EDGE_HIGH_Msk = 0x8
	// Bit GPIO_QSPI_SCLK_EDGE_HIGH.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_EDGE_HIGH = 0x8
	// Position of GPIO_QSPI_SCLK_EDGE_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO_QSPI_SCLK_EDGE_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_EDGE_LOW_Msk = 0x4
	// Bit GPIO_QSPI_SCLK_EDGE_LOW.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_EDGE_LOW = 0x4
	// Position of GPIO_QSPI_SCLK_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO_QSPI_SCLK_LEVEL_HIGH field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO_QSPI_SCLK_LEVEL_HIGH.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH = 0x2
	// Position of GPIO_QSPI_SCLK_LEVEL_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO_QSPI_SCLK_LEVEL_LOW field.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_LEVEL_LOW_Msk = 0x1
	// Bit GPIO_QSPI_SCLK_LEVEL_LOW.
	IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_LEVEL_LOW = 0x1

	// PROC1_INTE: Interrupt Enable for proc1
	// Position of GPIO_QSPI_SD3_EDGE_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO_QSPI_SD3_EDGE_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO_QSPI_SD3_EDGE_HIGH.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_EDGE_HIGH = 0x800000
	// Position of GPIO_QSPI_SD3_EDGE_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO_QSPI_SD3_EDGE_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_EDGE_LOW_Msk = 0x400000
	// Bit GPIO_QSPI_SD3_EDGE_LOW.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_EDGE_LOW = 0x400000
	// Position of GPIO_QSPI_SD3_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO_QSPI_SD3_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO_QSPI_SD3_LEVEL_HIGH.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_LEVEL_HIGH = 0x200000
	// Position of GPIO_QSPI_SD3_LEVEL_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO_QSPI_SD3_LEVEL_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO_QSPI_SD3_LEVEL_LOW.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_LEVEL_LOW = 0x100000
	// Position of GPIO_QSPI_SD2_EDGE_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO_QSPI_SD2_EDGE_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO_QSPI_SD2_EDGE_HIGH.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_EDGE_HIGH = 0x80000
	// Position of GPIO_QSPI_SD2_EDGE_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO_QSPI_SD2_EDGE_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_EDGE_LOW_Msk = 0x40000
	// Bit GPIO_QSPI_SD2_EDGE_LOW.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_EDGE_LOW = 0x40000
	// Position of GPIO_QSPI_SD2_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO_QSPI_SD2_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO_QSPI_SD2_LEVEL_HIGH.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_LEVEL_HIGH = 0x20000
	// Position of GPIO_QSPI_SD2_LEVEL_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO_QSPI_SD2_LEVEL_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO_QSPI_SD2_LEVEL_LOW.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_LEVEL_LOW = 0x10000
	// Position of GPIO_QSPI_SD1_EDGE_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO_QSPI_SD1_EDGE_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO_QSPI_SD1_EDGE_HIGH.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_EDGE_HIGH = 0x8000
	// Position of GPIO_QSPI_SD1_EDGE_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO_QSPI_SD1_EDGE_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_EDGE_LOW_Msk = 0x4000
	// Bit GPIO_QSPI_SD1_EDGE_LOW.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_EDGE_LOW = 0x4000
	// Position of GPIO_QSPI_SD1_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO_QSPI_SD1_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO_QSPI_SD1_LEVEL_HIGH.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_LEVEL_HIGH = 0x2000
	// Position of GPIO_QSPI_SD1_LEVEL_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO_QSPI_SD1_LEVEL_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO_QSPI_SD1_LEVEL_LOW.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_LEVEL_LOW = 0x1000
	// Position of GPIO_QSPI_SD0_EDGE_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO_QSPI_SD0_EDGE_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_EDGE_HIGH_Msk = 0x800
	// Bit GPIO_QSPI_SD0_EDGE_HIGH.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_EDGE_HIGH = 0x800
	// Position of GPIO_QSPI_SD0_EDGE_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO_QSPI_SD0_EDGE_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_EDGE_LOW_Msk = 0x400
	// Bit GPIO_QSPI_SD0_EDGE_LOW.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_EDGE_LOW = 0x400
	// Position of GPIO_QSPI_SD0_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO_QSPI_SD0_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO_QSPI_SD0_LEVEL_HIGH.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_LEVEL_HIGH = 0x200
	// Position of GPIO_QSPI_SD0_LEVEL_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO_QSPI_SD0_LEVEL_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_LEVEL_LOW_Msk = 0x100
	// Bit GPIO_QSPI_SD0_LEVEL_LOW.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_LEVEL_LOW = 0x100
	// Position of GPIO_QSPI_SS_EDGE_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO_QSPI_SS_EDGE_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_EDGE_HIGH_Msk = 0x80
	// Bit GPIO_QSPI_SS_EDGE_HIGH.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_EDGE_HIGH = 0x80
	// Position of GPIO_QSPI_SS_EDGE_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO_QSPI_SS_EDGE_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_EDGE_LOW_Msk = 0x40
	// Bit GPIO_QSPI_SS_EDGE_LOW.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_EDGE_LOW = 0x40
	// Position of GPIO_QSPI_SS_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO_QSPI_SS_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO_QSPI_SS_LEVEL_HIGH.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_LEVEL_HIGH = 0x20
	// Position of GPIO_QSPI_SS_LEVEL_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO_QSPI_SS_LEVEL_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_LEVEL_LOW_Msk = 0x10
	// Bit GPIO_QSPI_SS_LEVEL_LOW.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_LEVEL_LOW = 0x10
	// Position of GPIO_QSPI_SCLK_EDGE_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO_QSPI_SCLK_EDGE_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_EDGE_HIGH_Msk = 0x8
	// Bit GPIO_QSPI_SCLK_EDGE_HIGH.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_EDGE_HIGH = 0x8
	// Position of GPIO_QSPI_SCLK_EDGE_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO_QSPI_SCLK_EDGE_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_EDGE_LOW_Msk = 0x4
	// Bit GPIO_QSPI_SCLK_EDGE_LOW.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_EDGE_LOW = 0x4
	// Position of GPIO_QSPI_SCLK_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO_QSPI_SCLK_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO_QSPI_SCLK_LEVEL_HIGH.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH = 0x2
	// Position of GPIO_QSPI_SCLK_LEVEL_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO_QSPI_SCLK_LEVEL_LOW field.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_LEVEL_LOW_Msk = 0x1
	// Bit GPIO_QSPI_SCLK_LEVEL_LOW.
	IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_LEVEL_LOW = 0x1

	// PROC1_INTF: Interrupt Force for proc1
	// Position of GPIO_QSPI_SD3_EDGE_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO_QSPI_SD3_EDGE_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO_QSPI_SD3_EDGE_HIGH.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_EDGE_HIGH = 0x800000
	// Position of GPIO_QSPI_SD3_EDGE_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO_QSPI_SD3_EDGE_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_EDGE_LOW_Msk = 0x400000
	// Bit GPIO_QSPI_SD3_EDGE_LOW.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_EDGE_LOW = 0x400000
	// Position of GPIO_QSPI_SD3_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO_QSPI_SD3_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO_QSPI_SD3_LEVEL_HIGH.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_LEVEL_HIGH = 0x200000
	// Position of GPIO_QSPI_SD3_LEVEL_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO_QSPI_SD3_LEVEL_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO_QSPI_SD3_LEVEL_LOW.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_LEVEL_LOW = 0x100000
	// Position of GPIO_QSPI_SD2_EDGE_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO_QSPI_SD2_EDGE_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO_QSPI_SD2_EDGE_HIGH.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_EDGE_HIGH = 0x80000
	// Position of GPIO_QSPI_SD2_EDGE_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO_QSPI_SD2_EDGE_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_EDGE_LOW_Msk = 0x40000
	// Bit GPIO_QSPI_SD2_EDGE_LOW.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_EDGE_LOW = 0x40000
	// Position of GPIO_QSPI_SD2_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO_QSPI_SD2_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO_QSPI_SD2_LEVEL_HIGH.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_LEVEL_HIGH = 0x20000
	// Position of GPIO_QSPI_SD2_LEVEL_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO_QSPI_SD2_LEVEL_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO_QSPI_SD2_LEVEL_LOW.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_LEVEL_LOW = 0x10000
	// Position of GPIO_QSPI_SD1_EDGE_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO_QSPI_SD1_EDGE_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO_QSPI_SD1_EDGE_HIGH.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_EDGE_HIGH = 0x8000
	// Position of GPIO_QSPI_SD1_EDGE_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO_QSPI_SD1_EDGE_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_EDGE_LOW_Msk = 0x4000
	// Bit GPIO_QSPI_SD1_EDGE_LOW.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_EDGE_LOW = 0x4000
	// Position of GPIO_QSPI_SD1_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO_QSPI_SD1_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO_QSPI_SD1_LEVEL_HIGH.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_LEVEL_HIGH = 0x2000
	// Position of GPIO_QSPI_SD1_LEVEL_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO_QSPI_SD1_LEVEL_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO_QSPI_SD1_LEVEL_LOW.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_LEVEL_LOW = 0x1000
	// Position of GPIO_QSPI_SD0_EDGE_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO_QSPI_SD0_EDGE_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_EDGE_HIGH_Msk = 0x800
	// Bit GPIO_QSPI_SD0_EDGE_HIGH.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_EDGE_HIGH = 0x800
	// Position of GPIO_QSPI_SD0_EDGE_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO_QSPI_SD0_EDGE_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_EDGE_LOW_Msk = 0x400
	// Bit GPIO_QSPI_SD0_EDGE_LOW.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_EDGE_LOW = 0x400
	// Position of GPIO_QSPI_SD0_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO_QSPI_SD0_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO_QSPI_SD0_LEVEL_HIGH.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_LEVEL_HIGH = 0x200
	// Position of GPIO_QSPI_SD0_LEVEL_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO_QSPI_SD0_LEVEL_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_LEVEL_LOW_Msk = 0x100
	// Bit GPIO_QSPI_SD0_LEVEL_LOW.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_LEVEL_LOW = 0x100
	// Position of GPIO_QSPI_SS_EDGE_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO_QSPI_SS_EDGE_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_EDGE_HIGH_Msk = 0x80
	// Bit GPIO_QSPI_SS_EDGE_HIGH.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_EDGE_HIGH = 0x80
	// Position of GPIO_QSPI_SS_EDGE_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO_QSPI_SS_EDGE_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_EDGE_LOW_Msk = 0x40
	// Bit GPIO_QSPI_SS_EDGE_LOW.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_EDGE_LOW = 0x40
	// Position of GPIO_QSPI_SS_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO_QSPI_SS_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO_QSPI_SS_LEVEL_HIGH.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_LEVEL_HIGH = 0x20
	// Position of GPIO_QSPI_SS_LEVEL_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO_QSPI_SS_LEVEL_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_LEVEL_LOW_Msk = 0x10
	// Bit GPIO_QSPI_SS_LEVEL_LOW.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_LEVEL_LOW = 0x10
	// Position of GPIO_QSPI_SCLK_EDGE_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO_QSPI_SCLK_EDGE_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_EDGE_HIGH_Msk = 0x8
	// Bit GPIO_QSPI_SCLK_EDGE_HIGH.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_EDGE_HIGH = 0x8
	// Position of GPIO_QSPI_SCLK_EDGE_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO_QSPI_SCLK_EDGE_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_EDGE_LOW_Msk = 0x4
	// Bit GPIO_QSPI_SCLK_EDGE_LOW.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_EDGE_LOW = 0x4
	// Position of GPIO_QSPI_SCLK_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO_QSPI_SCLK_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO_QSPI_SCLK_LEVEL_HIGH.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH = 0x2
	// Position of GPIO_QSPI_SCLK_LEVEL_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO_QSPI_SCLK_LEVEL_LOW field.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_LEVEL_LOW_Msk = 0x1
	// Bit GPIO_QSPI_SCLK_LEVEL_LOW.
	IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_LEVEL_LOW = 0x1

	// PROC1_INTS: Interrupt status after masking & forcing for proc1
	// Position of GPIO_QSPI_SD3_EDGE_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO_QSPI_SD3_EDGE_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO_QSPI_SD3_EDGE_HIGH.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_EDGE_HIGH = 0x800000
	// Position of GPIO_QSPI_SD3_EDGE_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO_QSPI_SD3_EDGE_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_EDGE_LOW_Msk = 0x400000
	// Bit GPIO_QSPI_SD3_EDGE_LOW.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_EDGE_LOW = 0x400000
	// Position of GPIO_QSPI_SD3_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO_QSPI_SD3_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO_QSPI_SD3_LEVEL_HIGH.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_LEVEL_HIGH = 0x200000
	// Position of GPIO_QSPI_SD3_LEVEL_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO_QSPI_SD3_LEVEL_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO_QSPI_SD3_LEVEL_LOW.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_LEVEL_LOW = 0x100000
	// Position of GPIO_QSPI_SD2_EDGE_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO_QSPI_SD2_EDGE_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO_QSPI_SD2_EDGE_HIGH.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_EDGE_HIGH = 0x80000
	// Position of GPIO_QSPI_SD2_EDGE_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO_QSPI_SD2_EDGE_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_EDGE_LOW_Msk = 0x40000
	// Bit GPIO_QSPI_SD2_EDGE_LOW.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_EDGE_LOW = 0x40000
	// Position of GPIO_QSPI_SD2_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO_QSPI_SD2_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO_QSPI_SD2_LEVEL_HIGH.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_LEVEL_HIGH = 0x20000
	// Position of GPIO_QSPI_SD2_LEVEL_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO_QSPI_SD2_LEVEL_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO_QSPI_SD2_LEVEL_LOW.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_LEVEL_LOW = 0x10000
	// Position of GPIO_QSPI_SD1_EDGE_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO_QSPI_SD1_EDGE_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO_QSPI_SD1_EDGE_HIGH.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_EDGE_HIGH = 0x8000
	// Position of GPIO_QSPI_SD1_EDGE_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO_QSPI_SD1_EDGE_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_EDGE_LOW_Msk = 0x4000
	// Bit GPIO_QSPI_SD1_EDGE_LOW.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_EDGE_LOW = 0x4000
	// Position of GPIO_QSPI_SD1_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO_QSPI_SD1_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO_QSPI_SD1_LEVEL_HIGH.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_LEVEL_HIGH = 0x2000
	// Position of GPIO_QSPI_SD1_LEVEL_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO_QSPI_SD1_LEVEL_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO_QSPI_SD1_LEVEL_LOW.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_LEVEL_LOW = 0x1000
	// Position of GPIO_QSPI_SD0_EDGE_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO_QSPI_SD0_EDGE_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_EDGE_HIGH_Msk = 0x800
	// Bit GPIO_QSPI_SD0_EDGE_HIGH.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_EDGE_HIGH = 0x800
	// Position of GPIO_QSPI_SD0_EDGE_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO_QSPI_SD0_EDGE_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_EDGE_LOW_Msk = 0x400
	// Bit GPIO_QSPI_SD0_EDGE_LOW.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_EDGE_LOW = 0x400
	// Position of GPIO_QSPI_SD0_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO_QSPI_SD0_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO_QSPI_SD0_LEVEL_HIGH.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_LEVEL_HIGH = 0x200
	// Position of GPIO_QSPI_SD0_LEVEL_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO_QSPI_SD0_LEVEL_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_LEVEL_LOW_Msk = 0x100
	// Bit GPIO_QSPI_SD0_LEVEL_LOW.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_LEVEL_LOW = 0x100
	// Position of GPIO_QSPI_SS_EDGE_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO_QSPI_SS_EDGE_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_EDGE_HIGH_Msk = 0x80
	// Bit GPIO_QSPI_SS_EDGE_HIGH.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_EDGE_HIGH = 0x80
	// Position of GPIO_QSPI_SS_EDGE_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO_QSPI_SS_EDGE_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_EDGE_LOW_Msk = 0x40
	// Bit GPIO_QSPI_SS_EDGE_LOW.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_EDGE_LOW = 0x40
	// Position of GPIO_QSPI_SS_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO_QSPI_SS_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO_QSPI_SS_LEVEL_HIGH.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_LEVEL_HIGH = 0x20
	// Position of GPIO_QSPI_SS_LEVEL_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO_QSPI_SS_LEVEL_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_LEVEL_LOW_Msk = 0x10
	// Bit GPIO_QSPI_SS_LEVEL_LOW.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_LEVEL_LOW = 0x10
	// Position of GPIO_QSPI_SCLK_EDGE_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO_QSPI_SCLK_EDGE_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_EDGE_HIGH_Msk = 0x8
	// Bit GPIO_QSPI_SCLK_EDGE_HIGH.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_EDGE_HIGH = 0x8
	// Position of GPIO_QSPI_SCLK_EDGE_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO_QSPI_SCLK_EDGE_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_EDGE_LOW_Msk = 0x4
	// Bit GPIO_QSPI_SCLK_EDGE_LOW.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_EDGE_LOW = 0x4
	// Position of GPIO_QSPI_SCLK_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO_QSPI_SCLK_LEVEL_HIGH field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO_QSPI_SCLK_LEVEL_HIGH.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH = 0x2
	// Position of GPIO_QSPI_SCLK_LEVEL_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO_QSPI_SCLK_LEVEL_LOW field.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_LEVEL_LOW_Msk = 0x1
	// Bit GPIO_QSPI_SCLK_LEVEL_LOW.
	IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_LEVEL_LOW = 0x1

	// DORMANT_WAKE_INTE: Interrupt Enable for dormant_wake
	// Position of GPIO_QSPI_SD3_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO_QSPI_SD3_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO_QSPI_SD3_EDGE_HIGH.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_EDGE_HIGH = 0x800000
	// Position of GPIO_QSPI_SD3_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO_QSPI_SD3_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_EDGE_LOW_Msk = 0x400000
	// Bit GPIO_QSPI_SD3_EDGE_LOW.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_EDGE_LOW = 0x400000
	// Position of GPIO_QSPI_SD3_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO_QSPI_SD3_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO_QSPI_SD3_LEVEL_HIGH.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_LEVEL_HIGH = 0x200000
	// Position of GPIO_QSPI_SD3_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO_QSPI_SD3_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO_QSPI_SD3_LEVEL_LOW.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_LEVEL_LOW = 0x100000
	// Position of GPIO_QSPI_SD2_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO_QSPI_SD2_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO_QSPI_SD2_EDGE_HIGH.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_EDGE_HIGH = 0x80000
	// Position of GPIO_QSPI_SD2_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO_QSPI_SD2_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_EDGE_LOW_Msk = 0x40000
	// Bit GPIO_QSPI_SD2_EDGE_LOW.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_EDGE_LOW = 0x40000
	// Position of GPIO_QSPI_SD2_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO_QSPI_SD2_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO_QSPI_SD2_LEVEL_HIGH.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_LEVEL_HIGH = 0x20000
	// Position of GPIO_QSPI_SD2_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO_QSPI_SD2_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO_QSPI_SD2_LEVEL_LOW.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_LEVEL_LOW = 0x10000
	// Position of GPIO_QSPI_SD1_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO_QSPI_SD1_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO_QSPI_SD1_EDGE_HIGH.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_EDGE_HIGH = 0x8000
	// Position of GPIO_QSPI_SD1_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO_QSPI_SD1_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_EDGE_LOW_Msk = 0x4000
	// Bit GPIO_QSPI_SD1_EDGE_LOW.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_EDGE_LOW = 0x4000
	// Position of GPIO_QSPI_SD1_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO_QSPI_SD1_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO_QSPI_SD1_LEVEL_HIGH.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_LEVEL_HIGH = 0x2000
	// Position of GPIO_QSPI_SD1_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO_QSPI_SD1_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO_QSPI_SD1_LEVEL_LOW.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_LEVEL_LOW = 0x1000
	// Position of GPIO_QSPI_SD0_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO_QSPI_SD0_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_EDGE_HIGH_Msk = 0x800
	// Bit GPIO_QSPI_SD0_EDGE_HIGH.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_EDGE_HIGH = 0x800
	// Position of GPIO_QSPI_SD0_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO_QSPI_SD0_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_EDGE_LOW_Msk = 0x400
	// Bit GPIO_QSPI_SD0_EDGE_LOW.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_EDGE_LOW = 0x400
	// Position of GPIO_QSPI_SD0_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO_QSPI_SD0_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO_QSPI_SD0_LEVEL_HIGH.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_LEVEL_HIGH = 0x200
	// Position of GPIO_QSPI_SD0_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO_QSPI_SD0_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_LEVEL_LOW_Msk = 0x100
	// Bit GPIO_QSPI_SD0_LEVEL_LOW.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_LEVEL_LOW = 0x100
	// Position of GPIO_QSPI_SS_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO_QSPI_SS_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_EDGE_HIGH_Msk = 0x80
	// Bit GPIO_QSPI_SS_EDGE_HIGH.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_EDGE_HIGH = 0x80
	// Position of GPIO_QSPI_SS_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO_QSPI_SS_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_EDGE_LOW_Msk = 0x40
	// Bit GPIO_QSPI_SS_EDGE_LOW.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_EDGE_LOW = 0x40
	// Position of GPIO_QSPI_SS_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO_QSPI_SS_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO_QSPI_SS_LEVEL_HIGH.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_LEVEL_HIGH = 0x20
	// Position of GPIO_QSPI_SS_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO_QSPI_SS_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_LEVEL_LOW_Msk = 0x10
	// Bit GPIO_QSPI_SS_LEVEL_LOW.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_LEVEL_LOW = 0x10
	// Position of GPIO_QSPI_SCLK_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO_QSPI_SCLK_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_EDGE_HIGH_Msk = 0x8
	// Bit GPIO_QSPI_SCLK_EDGE_HIGH.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_EDGE_HIGH = 0x8
	// Position of GPIO_QSPI_SCLK_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO_QSPI_SCLK_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_EDGE_LOW_Msk = 0x4
	// Bit GPIO_QSPI_SCLK_EDGE_LOW.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_EDGE_LOW = 0x4
	// Position of GPIO_QSPI_SCLK_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO_QSPI_SCLK_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO_QSPI_SCLK_LEVEL_HIGH.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH = 0x2
	// Position of GPIO_QSPI_SCLK_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO_QSPI_SCLK_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_LEVEL_LOW_Msk = 0x1
	// Bit GPIO_QSPI_SCLK_LEVEL_LOW.
	IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_LEVEL_LOW = 0x1

	// DORMANT_WAKE_INTF: Interrupt Force for dormant_wake
	// Position of GPIO_QSPI_SD3_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO_QSPI_SD3_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO_QSPI_SD3_EDGE_HIGH.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_EDGE_HIGH = 0x800000
	// Position of GPIO_QSPI_SD3_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO_QSPI_SD3_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_EDGE_LOW_Msk = 0x400000
	// Bit GPIO_QSPI_SD3_EDGE_LOW.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_EDGE_LOW = 0x400000
	// Position of GPIO_QSPI_SD3_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO_QSPI_SD3_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO_QSPI_SD3_LEVEL_HIGH.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_LEVEL_HIGH = 0x200000
	// Position of GPIO_QSPI_SD3_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO_QSPI_SD3_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO_QSPI_SD3_LEVEL_LOW.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_LEVEL_LOW = 0x100000
	// Position of GPIO_QSPI_SD2_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO_QSPI_SD2_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO_QSPI_SD2_EDGE_HIGH.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_EDGE_HIGH = 0x80000
	// Position of GPIO_QSPI_SD2_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO_QSPI_SD2_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_EDGE_LOW_Msk = 0x40000
	// Bit GPIO_QSPI_SD2_EDGE_LOW.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_EDGE_LOW = 0x40000
	// Position of GPIO_QSPI_SD2_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO_QSPI_SD2_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO_QSPI_SD2_LEVEL_HIGH.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_LEVEL_HIGH = 0x20000
	// Position of GPIO_QSPI_SD2_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO_QSPI_SD2_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO_QSPI_SD2_LEVEL_LOW.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_LEVEL_LOW = 0x10000
	// Position of GPIO_QSPI_SD1_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO_QSPI_SD1_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO_QSPI_SD1_EDGE_HIGH.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_EDGE_HIGH = 0x8000
	// Position of GPIO_QSPI_SD1_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO_QSPI_SD1_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_EDGE_LOW_Msk = 0x4000
	// Bit GPIO_QSPI_SD1_EDGE_LOW.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_EDGE_LOW = 0x4000
	// Position of GPIO_QSPI_SD1_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO_QSPI_SD1_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO_QSPI_SD1_LEVEL_HIGH.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_LEVEL_HIGH = 0x2000
	// Position of GPIO_QSPI_SD1_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO_QSPI_SD1_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO_QSPI_SD1_LEVEL_LOW.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_LEVEL_LOW = 0x1000
	// Position of GPIO_QSPI_SD0_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO_QSPI_SD0_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_EDGE_HIGH_Msk = 0x800
	// Bit GPIO_QSPI_SD0_EDGE_HIGH.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_EDGE_HIGH = 0x800
	// Position of GPIO_QSPI_SD0_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO_QSPI_SD0_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_EDGE_LOW_Msk = 0x400
	// Bit GPIO_QSPI_SD0_EDGE_LOW.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_EDGE_LOW = 0x400
	// Position of GPIO_QSPI_SD0_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO_QSPI_SD0_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO_QSPI_SD0_LEVEL_HIGH.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_LEVEL_HIGH = 0x200
	// Position of GPIO_QSPI_SD0_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO_QSPI_SD0_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_LEVEL_LOW_Msk = 0x100
	// Bit GPIO_QSPI_SD0_LEVEL_LOW.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_LEVEL_LOW = 0x100
	// Position of GPIO_QSPI_SS_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO_QSPI_SS_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_EDGE_HIGH_Msk = 0x80
	// Bit GPIO_QSPI_SS_EDGE_HIGH.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_EDGE_HIGH = 0x80
	// Position of GPIO_QSPI_SS_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO_QSPI_SS_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_EDGE_LOW_Msk = 0x40
	// Bit GPIO_QSPI_SS_EDGE_LOW.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_EDGE_LOW = 0x40
	// Position of GPIO_QSPI_SS_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO_QSPI_SS_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO_QSPI_SS_LEVEL_HIGH.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_LEVEL_HIGH = 0x20
	// Position of GPIO_QSPI_SS_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO_QSPI_SS_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_LEVEL_LOW_Msk = 0x10
	// Bit GPIO_QSPI_SS_LEVEL_LOW.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_LEVEL_LOW = 0x10
	// Position of GPIO_QSPI_SCLK_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO_QSPI_SCLK_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_EDGE_HIGH_Msk = 0x8
	// Bit GPIO_QSPI_SCLK_EDGE_HIGH.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_EDGE_HIGH = 0x8
	// Position of GPIO_QSPI_SCLK_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO_QSPI_SCLK_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_EDGE_LOW_Msk = 0x4
	// Bit GPIO_QSPI_SCLK_EDGE_LOW.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_EDGE_LOW = 0x4
	// Position of GPIO_QSPI_SCLK_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO_QSPI_SCLK_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO_QSPI_SCLK_LEVEL_HIGH.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH = 0x2
	// Position of GPIO_QSPI_SCLK_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO_QSPI_SCLK_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_LEVEL_LOW_Msk = 0x1
	// Bit GPIO_QSPI_SCLK_LEVEL_LOW.
	IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_LEVEL_LOW = 0x1

	// DORMANT_WAKE_INTS: Interrupt status after masking & forcing for dormant_wake
	// Position of GPIO_QSPI_SD3_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_EDGE_HIGH_Pos = 0x17
	// Bit mask of GPIO_QSPI_SD3_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_EDGE_HIGH_Msk = 0x800000
	// Bit GPIO_QSPI_SD3_EDGE_HIGH.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_EDGE_HIGH = 0x800000
	// Position of GPIO_QSPI_SD3_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_EDGE_LOW_Pos = 0x16
	// Bit mask of GPIO_QSPI_SD3_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_EDGE_LOW_Msk = 0x400000
	// Bit GPIO_QSPI_SD3_EDGE_LOW.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_EDGE_LOW = 0x400000
	// Position of GPIO_QSPI_SD3_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_LEVEL_HIGH_Pos = 0x15
	// Bit mask of GPIO_QSPI_SD3_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_LEVEL_HIGH_Msk = 0x200000
	// Bit GPIO_QSPI_SD3_LEVEL_HIGH.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_LEVEL_HIGH = 0x200000
	// Position of GPIO_QSPI_SD3_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_LEVEL_LOW_Pos = 0x14
	// Bit mask of GPIO_QSPI_SD3_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_LEVEL_LOW_Msk = 0x100000
	// Bit GPIO_QSPI_SD3_LEVEL_LOW.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_LEVEL_LOW = 0x100000
	// Position of GPIO_QSPI_SD2_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_EDGE_HIGH_Pos = 0x13
	// Bit mask of GPIO_QSPI_SD2_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_EDGE_HIGH_Msk = 0x80000
	// Bit GPIO_QSPI_SD2_EDGE_HIGH.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_EDGE_HIGH = 0x80000
	// Position of GPIO_QSPI_SD2_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_EDGE_LOW_Pos = 0x12
	// Bit mask of GPIO_QSPI_SD2_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_EDGE_LOW_Msk = 0x40000
	// Bit GPIO_QSPI_SD2_EDGE_LOW.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_EDGE_LOW = 0x40000
	// Position of GPIO_QSPI_SD2_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_LEVEL_HIGH_Pos = 0x11
	// Bit mask of GPIO_QSPI_SD2_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_LEVEL_HIGH_Msk = 0x20000
	// Bit GPIO_QSPI_SD2_LEVEL_HIGH.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_LEVEL_HIGH = 0x20000
	// Position of GPIO_QSPI_SD2_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_LEVEL_LOW_Pos = 0x10
	// Bit mask of GPIO_QSPI_SD2_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_LEVEL_LOW_Msk = 0x10000
	// Bit GPIO_QSPI_SD2_LEVEL_LOW.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_LEVEL_LOW = 0x10000
	// Position of GPIO_QSPI_SD1_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_EDGE_HIGH_Pos = 0xf
	// Bit mask of GPIO_QSPI_SD1_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_EDGE_HIGH_Msk = 0x8000
	// Bit GPIO_QSPI_SD1_EDGE_HIGH.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_EDGE_HIGH = 0x8000
	// Position of GPIO_QSPI_SD1_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_EDGE_LOW_Pos = 0xe
	// Bit mask of GPIO_QSPI_SD1_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_EDGE_LOW_Msk = 0x4000
	// Bit GPIO_QSPI_SD1_EDGE_LOW.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_EDGE_LOW = 0x4000
	// Position of GPIO_QSPI_SD1_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_LEVEL_HIGH_Pos = 0xd
	// Bit mask of GPIO_QSPI_SD1_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_LEVEL_HIGH_Msk = 0x2000
	// Bit GPIO_QSPI_SD1_LEVEL_HIGH.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_LEVEL_HIGH = 0x2000
	// Position of GPIO_QSPI_SD1_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_LEVEL_LOW_Pos = 0xc
	// Bit mask of GPIO_QSPI_SD1_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_LEVEL_LOW_Msk = 0x1000
	// Bit GPIO_QSPI_SD1_LEVEL_LOW.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_LEVEL_LOW = 0x1000
	// Position of GPIO_QSPI_SD0_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_EDGE_HIGH_Pos = 0xb
	// Bit mask of GPIO_QSPI_SD0_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_EDGE_HIGH_Msk = 0x800
	// Bit GPIO_QSPI_SD0_EDGE_HIGH.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_EDGE_HIGH = 0x800
	// Position of GPIO_QSPI_SD0_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_EDGE_LOW_Pos = 0xa
	// Bit mask of GPIO_QSPI_SD0_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_EDGE_LOW_Msk = 0x400
	// Bit GPIO_QSPI_SD0_EDGE_LOW.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_EDGE_LOW = 0x400
	// Position of GPIO_QSPI_SD0_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_LEVEL_HIGH_Pos = 0x9
	// Bit mask of GPIO_QSPI_SD0_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_LEVEL_HIGH_Msk = 0x200
	// Bit GPIO_QSPI_SD0_LEVEL_HIGH.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_LEVEL_HIGH = 0x200
	// Position of GPIO_QSPI_SD0_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_LEVEL_LOW_Pos = 0x8
	// Bit mask of GPIO_QSPI_SD0_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_LEVEL_LOW_Msk = 0x100
	// Bit GPIO_QSPI_SD0_LEVEL_LOW.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_LEVEL_LOW = 0x100
	// Position of GPIO_QSPI_SS_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_EDGE_HIGH_Pos = 0x7
	// Bit mask of GPIO_QSPI_SS_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_EDGE_HIGH_Msk = 0x80
	// Bit GPIO_QSPI_SS_EDGE_HIGH.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_EDGE_HIGH = 0x80
	// Position of GPIO_QSPI_SS_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_EDGE_LOW_Pos = 0x6
	// Bit mask of GPIO_QSPI_SS_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_EDGE_LOW_Msk = 0x40
	// Bit GPIO_QSPI_SS_EDGE_LOW.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_EDGE_LOW = 0x40
	// Position of GPIO_QSPI_SS_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_LEVEL_HIGH_Pos = 0x5
	// Bit mask of GPIO_QSPI_SS_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_LEVEL_HIGH_Msk = 0x20
	// Bit GPIO_QSPI_SS_LEVEL_HIGH.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_LEVEL_HIGH = 0x20
	// Position of GPIO_QSPI_SS_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_LEVEL_LOW_Pos = 0x4
	// Bit mask of GPIO_QSPI_SS_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_LEVEL_LOW_Msk = 0x10
	// Bit GPIO_QSPI_SS_LEVEL_LOW.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_LEVEL_LOW = 0x10
	// Position of GPIO_QSPI_SCLK_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_EDGE_HIGH_Pos = 0x3
	// Bit mask of GPIO_QSPI_SCLK_EDGE_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_EDGE_HIGH_Msk = 0x8
	// Bit GPIO_QSPI_SCLK_EDGE_HIGH.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_EDGE_HIGH = 0x8
	// Position of GPIO_QSPI_SCLK_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_EDGE_LOW_Pos = 0x2
	// Bit mask of GPIO_QSPI_SCLK_EDGE_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_EDGE_LOW_Msk = 0x4
	// Bit GPIO_QSPI_SCLK_EDGE_LOW.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_EDGE_LOW = 0x4
	// Position of GPIO_QSPI_SCLK_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos = 0x1
	// Bit mask of GPIO_QSPI_SCLK_LEVEL_HIGH field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk = 0x2
	// Bit GPIO_QSPI_SCLK_LEVEL_HIGH.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH = 0x2
	// Position of GPIO_QSPI_SCLK_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_LEVEL_LOW_Pos = 0x0
	// Bit mask of GPIO_QSPI_SCLK_LEVEL_LOW field.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_LEVEL_LOW_Msk = 0x1
	// Bit GPIO_QSPI_SCLK_LEVEL_LOW.
	IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_LEVEL_LOW = 0x1
)

// Constants for PADS_BANK0
const (
	// VOLTAGE_SELECT: Voltage select. Per bank control
	// Position of VOLTAGE_SELECT field.
	PADS_BANK0_VOLTAGE_SELECT_VOLTAGE_SELECT_Pos = 0x0
	// Bit mask of VOLTAGE_SELECT field.
	PADS_BANK0_VOLTAGE_SELECT_VOLTAGE_SELECT_Msk = 0x1
	// Bit VOLTAGE_SELECT.
	PADS_BANK0_VOLTAGE_SELECT_VOLTAGE_SELECT = 0x1
	// Set voltage to 3.3V (DVDD >= 2V5)
	PADS_BANK0_VOLTAGE_SELECT_VOLTAGE_SELECT_3v3 = 0x0
	// Set voltage to 1.8V (DVDD <= 1V8)
	PADS_BANK0_VOLTAGE_SELECT_VOLTAGE_SELECT_1v8 = 0x1

	// GPIO0: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO0_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO0_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO0_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO0_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO0_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO0_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO0_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO0_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO0_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO0_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO0_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO0_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO0_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO0_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO0_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO0_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO0_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO0_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO0_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO0_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO0_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO0_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO0_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO0_SLEWFAST = 0x1

	// GPIO1: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO1_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO1_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO1_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO1_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO1_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO1_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO1_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO1_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO1_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO1_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO1_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO1_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO1_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO1_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO1_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO1_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO1_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO1_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO1_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO1_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO1_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO1_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO1_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO1_SLEWFAST = 0x1

	// GPIO2: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO2_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO2_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO2_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO2_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO2_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO2_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO2_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO2_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO2_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO2_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO2_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO2_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO2_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO2_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO2_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO2_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO2_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO2_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO2_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO2_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO2_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO2_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO2_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO2_SLEWFAST = 0x1

	// GPIO3: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO3_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO3_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO3_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO3_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO3_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO3_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO3_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO3_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO3_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO3_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO3_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO3_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO3_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO3_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO3_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO3_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO3_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO3_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO3_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO3_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO3_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO3_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO3_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO3_SLEWFAST = 0x1

	// GPIO4: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO4_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO4_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO4_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO4_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO4_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO4_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO4_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO4_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO4_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO4_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO4_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO4_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO4_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO4_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO4_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO4_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO4_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO4_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO4_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO4_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO4_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO4_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO4_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO4_SLEWFAST = 0x1

	// GPIO5: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO5_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO5_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO5_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO5_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO5_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO5_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO5_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO5_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO5_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO5_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO5_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO5_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO5_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO5_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO5_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO5_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO5_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO5_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO5_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO5_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO5_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO5_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO5_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO5_SLEWFAST = 0x1

	// GPIO6: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO6_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO6_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO6_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO6_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO6_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO6_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO6_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO6_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO6_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO6_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO6_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO6_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO6_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO6_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO6_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO6_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO6_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO6_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO6_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO6_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO6_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO6_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO6_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO6_SLEWFAST = 0x1

	// GPIO7: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO7_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO7_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO7_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO7_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO7_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO7_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO7_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO7_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO7_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO7_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO7_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO7_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO7_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO7_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO7_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO7_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO7_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO7_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO7_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO7_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO7_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO7_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO7_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO7_SLEWFAST = 0x1

	// GPIO8: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO8_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO8_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO8_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO8_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO8_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO8_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO8_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO8_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO8_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO8_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO8_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO8_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO8_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO8_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO8_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO8_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO8_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO8_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO8_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO8_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO8_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO8_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO8_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO8_SLEWFAST = 0x1

	// GPIO9: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO9_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO9_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO9_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO9_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO9_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO9_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO9_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO9_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO9_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO9_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO9_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO9_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO9_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO9_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO9_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO9_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO9_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO9_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO9_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO9_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO9_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO9_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO9_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO9_SLEWFAST = 0x1

	// GPIO10: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO10_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO10_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO10_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO10_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO10_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO10_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO10_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO10_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO10_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO10_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO10_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO10_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO10_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO10_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO10_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO10_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO10_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO10_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO10_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO10_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO10_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO10_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO10_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO10_SLEWFAST = 0x1

	// GPIO11: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO11_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO11_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO11_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO11_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO11_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO11_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO11_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO11_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO11_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO11_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO11_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO11_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO11_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO11_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO11_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO11_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO11_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO11_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO11_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO11_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO11_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO11_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO11_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO11_SLEWFAST = 0x1

	// GPIO12: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO12_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO12_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO12_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO12_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO12_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO12_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO12_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO12_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO12_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO12_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO12_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO12_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO12_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO12_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO12_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO12_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO12_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO12_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO12_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO12_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO12_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO12_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO12_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO12_SLEWFAST = 0x1

	// GPIO13: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO13_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO13_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO13_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO13_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO13_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO13_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO13_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO13_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO13_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO13_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO13_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO13_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO13_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO13_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO13_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO13_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO13_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO13_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO13_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO13_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO13_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO13_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO13_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO13_SLEWFAST = 0x1

	// GPIO14: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO14_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO14_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO14_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO14_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO14_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO14_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO14_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO14_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO14_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO14_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO14_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO14_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO14_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO14_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO14_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO14_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO14_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO14_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO14_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO14_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO14_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO14_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO14_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO14_SLEWFAST = 0x1

	// GPIO15: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO15_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO15_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO15_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO15_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO15_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO15_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO15_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO15_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO15_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO15_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO15_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO15_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO15_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO15_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO15_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO15_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO15_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO15_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO15_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO15_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO15_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO15_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO15_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO15_SLEWFAST = 0x1

	// GPIO16: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO16_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO16_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO16_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO16_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO16_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO16_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO16_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO16_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO16_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO16_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO16_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO16_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO16_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO16_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO16_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO16_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO16_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO16_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO16_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO16_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO16_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO16_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO16_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO16_SLEWFAST = 0x1

	// GPIO17: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO17_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO17_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO17_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO17_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO17_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO17_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO17_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO17_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO17_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO17_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO17_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO17_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO17_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO17_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO17_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO17_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO17_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO17_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO17_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO17_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO17_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO17_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO17_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO17_SLEWFAST = 0x1

	// GPIO18: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO18_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO18_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO18_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO18_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO18_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO18_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO18_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO18_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO18_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO18_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO18_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO18_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO18_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO18_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO18_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO18_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO18_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO18_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO18_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO18_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO18_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO18_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO18_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO18_SLEWFAST = 0x1

	// GPIO19: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO19_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO19_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO19_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO19_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO19_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO19_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO19_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO19_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO19_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO19_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO19_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO19_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO19_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO19_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO19_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO19_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO19_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO19_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO19_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO19_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO19_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO19_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO19_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO19_SLEWFAST = 0x1

	// GPIO20: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO20_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO20_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO20_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO20_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO20_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO20_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO20_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO20_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO20_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO20_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO20_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO20_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO20_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO20_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO20_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO20_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO20_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO20_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO20_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO20_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO20_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO20_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO20_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO20_SLEWFAST = 0x1

	// GPIO21: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO21_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO21_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO21_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO21_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO21_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO21_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO21_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO21_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO21_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO21_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO21_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO21_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO21_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO21_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO21_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO21_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO21_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO21_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO21_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO21_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO21_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO21_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO21_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO21_SLEWFAST = 0x1

	// GPIO22: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO22_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO22_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO22_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO22_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO22_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO22_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO22_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO22_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO22_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO22_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO22_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO22_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO22_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO22_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO22_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO22_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO22_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO22_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO22_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO22_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO22_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO22_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO22_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO22_SLEWFAST = 0x1

	// GPIO23: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO23_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO23_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO23_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO23_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO23_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO23_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO23_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO23_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO23_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO23_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO23_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO23_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO23_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO23_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO23_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO23_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO23_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO23_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO23_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO23_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO23_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO23_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO23_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO23_SLEWFAST = 0x1

	// GPIO24: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO24_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO24_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO24_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO24_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO24_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO24_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO24_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO24_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO24_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO24_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO24_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO24_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO24_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO24_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO24_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO24_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO24_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO24_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO24_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO24_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO24_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO24_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO24_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO24_SLEWFAST = 0x1

	// GPIO25: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO25_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO25_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO25_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO25_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO25_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO25_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO25_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO25_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO25_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO25_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO25_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO25_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO25_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO25_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO25_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO25_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO25_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO25_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO25_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO25_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO25_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO25_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO25_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO25_SLEWFAST = 0x1

	// GPIO26: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO26_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO26_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO26_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO26_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO26_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO26_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO26_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO26_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO26_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO26_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO26_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO26_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO26_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO26_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO26_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO26_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO26_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO26_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO26_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO26_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO26_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO26_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO26_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO26_SLEWFAST = 0x1

	// GPIO27: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO27_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO27_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO27_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO27_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO27_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO27_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO27_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO27_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO27_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO27_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO27_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO27_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO27_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO27_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO27_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO27_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO27_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO27_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO27_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO27_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO27_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO27_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO27_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO27_SLEWFAST = 0x1

	// GPIO28: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO28_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO28_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO28_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO28_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO28_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO28_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO28_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO28_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO28_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO28_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO28_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO28_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO28_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO28_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO28_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO28_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO28_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO28_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO28_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO28_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO28_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO28_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO28_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO28_SLEWFAST = 0x1

	// GPIO29: Pad control register
	// Position of OD field.
	PADS_BANK0_GPIO29_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_GPIO29_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_GPIO29_OD = 0x80
	// Position of IE field.
	PADS_BANK0_GPIO29_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_GPIO29_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_GPIO29_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_GPIO29_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_GPIO29_DRIVE_Msk  = 0x30
	PADS_BANK0_GPIO29_DRIVE_2mA  = 0x0
	PADS_BANK0_GPIO29_DRIVE_4mA  = 0x1
	PADS_BANK0_GPIO29_DRIVE_8mA  = 0x2
	PADS_BANK0_GPIO29_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_GPIO29_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_GPIO29_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_GPIO29_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_GPIO29_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_GPIO29_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_GPIO29_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_GPIO29_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_GPIO29_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_GPIO29_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_GPIO29_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_GPIO29_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_GPIO29_SLEWFAST = 0x1

	// SWCLK: Pad control register
	// Position of OD field.
	PADS_BANK0_SWCLK_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_SWCLK_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_SWCLK_OD = 0x80
	// Position of IE field.
	PADS_BANK0_SWCLK_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_SWCLK_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_SWCLK_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_SWCLK_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_SWCLK_DRIVE_Msk  = 0x30
	PADS_BANK0_SWCLK_DRIVE_2mA  = 0x0
	PADS_BANK0_SWCLK_DRIVE_4mA  = 0x1
	PADS_BANK0_SWCLK_DRIVE_8mA  = 0x2
	PADS_BANK0_SWCLK_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_SWCLK_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_SWCLK_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_SWCLK_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_SWCLK_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_SWCLK_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_SWCLK_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_SWCLK_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_SWCLK_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_SWCLK_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_SWCLK_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_SWCLK_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_SWCLK_SLEWFAST = 0x1

	// SWD: Pad control register
	// Position of OD field.
	PADS_BANK0_SWD_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_BANK0_SWD_OD_Msk = 0x80
	// Bit OD.
	PADS_BANK0_SWD_OD = 0x80
	// Position of IE field.
	PADS_BANK0_SWD_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_BANK0_SWD_IE_Msk = 0x40
	// Bit IE.
	PADS_BANK0_SWD_IE = 0x40
	// Position of DRIVE field.
	PADS_BANK0_SWD_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_BANK0_SWD_DRIVE_Msk  = 0x30
	PADS_BANK0_SWD_DRIVE_2mA  = 0x0
	PADS_BANK0_SWD_DRIVE_4mA  = 0x1
	PADS_BANK0_SWD_DRIVE_8mA  = 0x2
	PADS_BANK0_SWD_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_BANK0_SWD_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_BANK0_SWD_PUE_Msk = 0x8
	// Bit PUE.
	PADS_BANK0_SWD_PUE = 0x8
	// Position of PDE field.
	PADS_BANK0_SWD_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_BANK0_SWD_PDE_Msk = 0x4
	// Bit PDE.
	PADS_BANK0_SWD_PDE = 0x4
	// Position of SCHMITT field.
	PADS_BANK0_SWD_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_BANK0_SWD_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_BANK0_SWD_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_BANK0_SWD_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_BANK0_SWD_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_BANK0_SWD_SLEWFAST = 0x1
)

// Constants for PADS_QSPI
const (
	// VOLTAGE_SELECT: Voltage select. Per bank control
	// Position of VOLTAGE_SELECT field.
	PADS_QSPI_VOLTAGE_SELECT_VOLTAGE_SELECT_Pos = 0x0
	// Bit mask of VOLTAGE_SELECT field.
	PADS_QSPI_VOLTAGE_SELECT_VOLTAGE_SELECT_Msk = 0x1
	// Bit VOLTAGE_SELECT.
	PADS_QSPI_VOLTAGE_SELECT_VOLTAGE_SELECT = 0x1
	// Set voltage to 3.3V (DVDD >= 2V5)
	PADS_QSPI_VOLTAGE_SELECT_VOLTAGE_SELECT_3v3 = 0x0
	// Set voltage to 1.8V (DVDD <= 1V8)
	PADS_QSPI_VOLTAGE_SELECT_VOLTAGE_SELECT_1v8 = 0x1

	// GPIO_QSPI_SCLK: Pad control register
	// Position of OD field.
	PADS_QSPI_GPIO_QSPI_SCLK_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_QSPI_GPIO_QSPI_SCLK_OD_Msk = 0x80
	// Bit OD.
	PADS_QSPI_GPIO_QSPI_SCLK_OD = 0x80
	// Position of IE field.
	PADS_QSPI_GPIO_QSPI_SCLK_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_QSPI_GPIO_QSPI_SCLK_IE_Msk = 0x40
	// Bit IE.
	PADS_QSPI_GPIO_QSPI_SCLK_IE = 0x40
	// Position of DRIVE field.
	PADS_QSPI_GPIO_QSPI_SCLK_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_QSPI_GPIO_QSPI_SCLK_DRIVE_Msk  = 0x30
	PADS_QSPI_GPIO_QSPI_SCLK_DRIVE_2mA  = 0x0
	PADS_QSPI_GPIO_QSPI_SCLK_DRIVE_4mA  = 0x1
	PADS_QSPI_GPIO_QSPI_SCLK_DRIVE_8mA  = 0x2
	PADS_QSPI_GPIO_QSPI_SCLK_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_QSPI_GPIO_QSPI_SCLK_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_QSPI_GPIO_QSPI_SCLK_PUE_Msk = 0x8
	// Bit PUE.
	PADS_QSPI_GPIO_QSPI_SCLK_PUE = 0x8
	// Position of PDE field.
	PADS_QSPI_GPIO_QSPI_SCLK_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_QSPI_GPIO_QSPI_SCLK_PDE_Msk = 0x4
	// Bit PDE.
	PADS_QSPI_GPIO_QSPI_SCLK_PDE = 0x4
	// Position of SCHMITT field.
	PADS_QSPI_GPIO_QSPI_SCLK_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_QSPI_GPIO_QSPI_SCLK_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_QSPI_GPIO_QSPI_SCLK_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_QSPI_GPIO_QSPI_SCLK_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_QSPI_GPIO_QSPI_SCLK_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_QSPI_GPIO_QSPI_SCLK_SLEWFAST = 0x1

	// GPIO_QSPI_SD0: Pad control register
	// Position of OD field.
	PADS_QSPI_GPIO_QSPI_SD0_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_QSPI_GPIO_QSPI_SD0_OD_Msk = 0x80
	// Bit OD.
	PADS_QSPI_GPIO_QSPI_SD0_OD = 0x80
	// Position of IE field.
	PADS_QSPI_GPIO_QSPI_SD0_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_QSPI_GPIO_QSPI_SD0_IE_Msk = 0x40
	// Bit IE.
	PADS_QSPI_GPIO_QSPI_SD0_IE = 0x40
	// Position of DRIVE field.
	PADS_QSPI_GPIO_QSPI_SD0_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_QSPI_GPIO_QSPI_SD0_DRIVE_Msk  = 0x30
	PADS_QSPI_GPIO_QSPI_SD0_DRIVE_2mA  = 0x0
	PADS_QSPI_GPIO_QSPI_SD0_DRIVE_4mA  = 0x1
	PADS_QSPI_GPIO_QSPI_SD0_DRIVE_8mA  = 0x2
	PADS_QSPI_GPIO_QSPI_SD0_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_QSPI_GPIO_QSPI_SD0_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_QSPI_GPIO_QSPI_SD0_PUE_Msk = 0x8
	// Bit PUE.
	PADS_QSPI_GPIO_QSPI_SD0_PUE = 0x8
	// Position of PDE field.
	PADS_QSPI_GPIO_QSPI_SD0_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_QSPI_GPIO_QSPI_SD0_PDE_Msk = 0x4
	// Bit PDE.
	PADS_QSPI_GPIO_QSPI_SD0_PDE = 0x4
	// Position of SCHMITT field.
	PADS_QSPI_GPIO_QSPI_SD0_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_QSPI_GPIO_QSPI_SD0_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_QSPI_GPIO_QSPI_SD0_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_QSPI_GPIO_QSPI_SD0_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_QSPI_GPIO_QSPI_SD0_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_QSPI_GPIO_QSPI_SD0_SLEWFAST = 0x1

	// GPIO_QSPI_SD1: Pad control register
	// Position of OD field.
	PADS_QSPI_GPIO_QSPI_SD1_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_QSPI_GPIO_QSPI_SD1_OD_Msk = 0x80
	// Bit OD.
	PADS_QSPI_GPIO_QSPI_SD1_OD = 0x80
	// Position of IE field.
	PADS_QSPI_GPIO_QSPI_SD1_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_QSPI_GPIO_QSPI_SD1_IE_Msk = 0x40
	// Bit IE.
	PADS_QSPI_GPIO_QSPI_SD1_IE = 0x40
	// Position of DRIVE field.
	PADS_QSPI_GPIO_QSPI_SD1_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_QSPI_GPIO_QSPI_SD1_DRIVE_Msk  = 0x30
	PADS_QSPI_GPIO_QSPI_SD1_DRIVE_2mA  = 0x0
	PADS_QSPI_GPIO_QSPI_SD1_DRIVE_4mA  = 0x1
	PADS_QSPI_GPIO_QSPI_SD1_DRIVE_8mA  = 0x2
	PADS_QSPI_GPIO_QSPI_SD1_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_QSPI_GPIO_QSPI_SD1_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_QSPI_GPIO_QSPI_SD1_PUE_Msk = 0x8
	// Bit PUE.
	PADS_QSPI_GPIO_QSPI_SD1_PUE = 0x8
	// Position of PDE field.
	PADS_QSPI_GPIO_QSPI_SD1_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_QSPI_GPIO_QSPI_SD1_PDE_Msk = 0x4
	// Bit PDE.
	PADS_QSPI_GPIO_QSPI_SD1_PDE = 0x4
	// Position of SCHMITT field.
	PADS_QSPI_GPIO_QSPI_SD1_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_QSPI_GPIO_QSPI_SD1_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_QSPI_GPIO_QSPI_SD1_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_QSPI_GPIO_QSPI_SD1_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_QSPI_GPIO_QSPI_SD1_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_QSPI_GPIO_QSPI_SD1_SLEWFAST = 0x1

	// GPIO_QSPI_SD2: Pad control register
	// Position of OD field.
	PADS_QSPI_GPIO_QSPI_SD2_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_QSPI_GPIO_QSPI_SD2_OD_Msk = 0x80
	// Bit OD.
	PADS_QSPI_GPIO_QSPI_SD2_OD = 0x80
	// Position of IE field.
	PADS_QSPI_GPIO_QSPI_SD2_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_QSPI_GPIO_QSPI_SD2_IE_Msk = 0x40
	// Bit IE.
	PADS_QSPI_GPIO_QSPI_SD2_IE = 0x40
	// Position of DRIVE field.
	PADS_QSPI_GPIO_QSPI_SD2_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_QSPI_GPIO_QSPI_SD2_DRIVE_Msk  = 0x30
	PADS_QSPI_GPIO_QSPI_SD2_DRIVE_2mA  = 0x0
	PADS_QSPI_GPIO_QSPI_SD2_DRIVE_4mA  = 0x1
	PADS_QSPI_GPIO_QSPI_SD2_DRIVE_8mA  = 0x2
	PADS_QSPI_GPIO_QSPI_SD2_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_QSPI_GPIO_QSPI_SD2_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_QSPI_GPIO_QSPI_SD2_PUE_Msk = 0x8
	// Bit PUE.
	PADS_QSPI_GPIO_QSPI_SD2_PUE = 0x8
	// Position of PDE field.
	PADS_QSPI_GPIO_QSPI_SD2_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_QSPI_GPIO_QSPI_SD2_PDE_Msk = 0x4
	// Bit PDE.
	PADS_QSPI_GPIO_QSPI_SD2_PDE = 0x4
	// Position of SCHMITT field.
	PADS_QSPI_GPIO_QSPI_SD2_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_QSPI_GPIO_QSPI_SD2_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_QSPI_GPIO_QSPI_SD2_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_QSPI_GPIO_QSPI_SD2_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_QSPI_GPIO_QSPI_SD2_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_QSPI_GPIO_QSPI_SD2_SLEWFAST = 0x1

	// GPIO_QSPI_SD3: Pad control register
	// Position of OD field.
	PADS_QSPI_GPIO_QSPI_SD3_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_QSPI_GPIO_QSPI_SD3_OD_Msk = 0x80
	// Bit OD.
	PADS_QSPI_GPIO_QSPI_SD3_OD = 0x80
	// Position of IE field.
	PADS_QSPI_GPIO_QSPI_SD3_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_QSPI_GPIO_QSPI_SD3_IE_Msk = 0x40
	// Bit IE.
	PADS_QSPI_GPIO_QSPI_SD3_IE = 0x40
	// Position of DRIVE field.
	PADS_QSPI_GPIO_QSPI_SD3_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_QSPI_GPIO_QSPI_SD3_DRIVE_Msk  = 0x30
	PADS_QSPI_GPIO_QSPI_SD3_DRIVE_2mA  = 0x0
	PADS_QSPI_GPIO_QSPI_SD3_DRIVE_4mA  = 0x1
	PADS_QSPI_GPIO_QSPI_SD3_DRIVE_8mA  = 0x2
	PADS_QSPI_GPIO_QSPI_SD3_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_QSPI_GPIO_QSPI_SD3_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_QSPI_GPIO_QSPI_SD3_PUE_Msk = 0x8
	// Bit PUE.
	PADS_QSPI_GPIO_QSPI_SD3_PUE = 0x8
	// Position of PDE field.
	PADS_QSPI_GPIO_QSPI_SD3_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_QSPI_GPIO_QSPI_SD3_PDE_Msk = 0x4
	// Bit PDE.
	PADS_QSPI_GPIO_QSPI_SD3_PDE = 0x4
	// Position of SCHMITT field.
	PADS_QSPI_GPIO_QSPI_SD3_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_QSPI_GPIO_QSPI_SD3_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_QSPI_GPIO_QSPI_SD3_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_QSPI_GPIO_QSPI_SD3_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_QSPI_GPIO_QSPI_SD3_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_QSPI_GPIO_QSPI_SD3_SLEWFAST = 0x1

	// GPIO_QSPI_SS: Pad control register
	// Position of OD field.
	PADS_QSPI_GPIO_QSPI_SS_OD_Pos = 0x7
	// Bit mask of OD field.
	PADS_QSPI_GPIO_QSPI_SS_OD_Msk = 0x80
	// Bit OD.
	PADS_QSPI_GPIO_QSPI_SS_OD = 0x80
	// Position of IE field.
	PADS_QSPI_GPIO_QSPI_SS_IE_Pos = 0x6
	// Bit mask of IE field.
	PADS_QSPI_GPIO_QSPI_SS_IE_Msk = 0x40
	// Bit IE.
	PADS_QSPI_GPIO_QSPI_SS_IE = 0x40
	// Position of DRIVE field.
	PADS_QSPI_GPIO_QSPI_SS_DRIVE_Pos = 0x4
	// Bit mask of DRIVE field.
	PADS_QSPI_GPIO_QSPI_SS_DRIVE_Msk  = 0x30
	PADS_QSPI_GPIO_QSPI_SS_DRIVE_2mA  = 0x0
	PADS_QSPI_GPIO_QSPI_SS_DRIVE_4mA  = 0x1
	PADS_QSPI_GPIO_QSPI_SS_DRIVE_8mA  = 0x2
	PADS_QSPI_GPIO_QSPI_SS_DRIVE_12mA = 0x3
	// Position of PUE field.
	PADS_QSPI_GPIO_QSPI_SS_PUE_Pos = 0x3
	// Bit mask of PUE field.
	PADS_QSPI_GPIO_QSPI_SS_PUE_Msk = 0x8
	// Bit PUE.
	PADS_QSPI_GPIO_QSPI_SS_PUE = 0x8
	// Position of PDE field.
	PADS_QSPI_GPIO_QSPI_SS_PDE_Pos = 0x2
	// Bit mask of PDE field.
	PADS_QSPI_GPIO_QSPI_SS_PDE_Msk = 0x4
	// Bit PDE.
	PADS_QSPI_GPIO_QSPI_SS_PDE = 0x4
	// Position of SCHMITT field.
	PADS_QSPI_GPIO_QSPI_SS_SCHMITT_Pos = 0x1
	// Bit mask of SCHMITT field.
	PADS_QSPI_GPIO_QSPI_SS_SCHMITT_Msk = 0x2
	// Bit SCHMITT.
	PADS_QSPI_GPIO_QSPI_SS_SCHMITT = 0x2
	// Position of SLEWFAST field.
	PADS_QSPI_GPIO_QSPI_SS_SLEWFAST_Pos = 0x0
	// Bit mask of SLEWFAST field.
	PADS_QSPI_GPIO_QSPI_SS_SLEWFAST_Msk = 0x1
	// Bit SLEWFAST.
	PADS_QSPI_GPIO_QSPI_SS_SLEWFAST = 0x1
)

// Constants for XOSC: Controls the crystal oscillator
const (
	// CTRL: Crystal Oscillator Control
	// Position of ENABLE field.
	XOSC_CTRL_ENABLE_Pos = 0xc
	// Bit mask of ENABLE field.
	XOSC_CTRL_ENABLE_Msk     = 0xfff000
	XOSC_CTRL_ENABLE_DISABLE = 0xd1e
	XOSC_CTRL_ENABLE_ENABLE  = 0xfab
	// Position of FREQ_RANGE field.
	XOSC_CTRL_FREQ_RANGE_Pos = 0x0
	// Bit mask of FREQ_RANGE field.
	XOSC_CTRL_FREQ_RANGE_Msk        = 0xfff
	XOSC_CTRL_FREQ_RANGE_1_15MHZ    = 0xaa0
	XOSC_CTRL_FREQ_RANGE_RESERVED_1 = 0xaa1
	XOSC_CTRL_FREQ_RANGE_RESERVED_2 = 0xaa2
	XOSC_CTRL_FREQ_RANGE_RESERVED_3 = 0xaa3

	// STATUS: Crystal Oscillator Status
	// Position of STABLE field.
	XOSC_STATUS_STABLE_Pos = 0x1f
	// Bit mask of STABLE field.
	XOSC_STATUS_STABLE_Msk = 0x80000000
	// Bit STABLE.
	XOSC_STATUS_STABLE = 0x80000000
	// Position of BADWRITE field.
	XOSC_STATUS_BADWRITE_Pos = 0x18
	// Bit mask of BADWRITE field.
	XOSC_STATUS_BADWRITE_Msk = 0x1000000
	// Bit BADWRITE.
	XOSC_STATUS_BADWRITE = 0x1000000
	// Position of ENABLED field.
	XOSC_STATUS_ENABLED_Pos = 0xc
	// Bit mask of ENABLED field.
	XOSC_STATUS_ENABLED_Msk = 0x1000
	// Bit ENABLED.
	XOSC_STATUS_ENABLED = 0x1000
	// Position of FREQ_RANGE field.
	XOSC_STATUS_FREQ_RANGE_Pos = 0x0
	// Bit mask of FREQ_RANGE field.
	XOSC_STATUS_FREQ_RANGE_Msk        = 0x3
	XOSC_STATUS_FREQ_RANGE_1_15MHZ    = 0x0
	XOSC_STATUS_FREQ_RANGE_RESERVED_1 = 0x1
	XOSC_STATUS_FREQ_RANGE_RESERVED_2 = 0x2
	XOSC_STATUS_FREQ_RANGE_RESERVED_3 = 0x3

	// STARTUP: Controls the startup delay
	// Position of X4 field.
	XOSC_STARTUP_X4_Pos = 0x14
	// Bit mask of X4 field.
	XOSC_STARTUP_X4_Msk = 0x100000
	// Bit X4.
	XOSC_STARTUP_X4 = 0x100000
	// Position of DELAY field.
	XOSC_STARTUP_DELAY_Pos = 0x0
	// Bit mask of DELAY field.
	XOSC_STARTUP_DELAY_Msk = 0x3fff

	// COUNT
	// A down counter running at the xosc frequency which counts to zero and stops.
	// To start the counter write a non-zero value.
	// Can be used for short software pauses when setting up time sensitive hardware.
	// Position of COUNT field.
	XOSC_COUNT_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	XOSC_COUNT_COUNT_Msk = 0xff
)

// Constants for PLL_SYS
const (
	// CS
	// Control and Status
	// GENERAL CONSTRAINTS:
	// Reference clock frequency min=5MHz, max=800MHz
	// Feedback divider min=16, max=320
	// VCO frequency min=400MHz, max=1600MHz
	// Position of LOCK field.
	PLL_SYS_CS_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	PLL_SYS_CS_LOCK_Msk = 0x80000000
	// Bit LOCK.
	PLL_SYS_CS_LOCK = 0x80000000
	// Position of BYPASS field.
	PLL_SYS_CS_BYPASS_Pos = 0x8
	// Bit mask of BYPASS field.
	PLL_SYS_CS_BYPASS_Msk = 0x100
	// Bit BYPASS.
	PLL_SYS_CS_BYPASS = 0x100
	// Position of REFDIV field.
	PLL_SYS_CS_REFDIV_Pos = 0x0
	// Bit mask of REFDIV field.
	PLL_SYS_CS_REFDIV_Msk = 0x3f

	// PWR: Controls the PLL power modes.
	// Position of VCOPD field.
	PLL_SYS_PWR_VCOPD_Pos = 0x5
	// Bit mask of VCOPD field.
	PLL_SYS_PWR_VCOPD_Msk = 0x20
	// Bit VCOPD.
	PLL_SYS_PWR_VCOPD = 0x20
	// Position of POSTDIVPD field.
	PLL_SYS_PWR_POSTDIVPD_Pos = 0x3
	// Bit mask of POSTDIVPD field.
	PLL_SYS_PWR_POSTDIVPD_Msk = 0x8
	// Bit POSTDIVPD.
	PLL_SYS_PWR_POSTDIVPD = 0x8
	// Position of DSMPD field.
	PLL_SYS_PWR_DSMPD_Pos = 0x2
	// Bit mask of DSMPD field.
	PLL_SYS_PWR_DSMPD_Msk = 0x4
	// Bit DSMPD.
	PLL_SYS_PWR_DSMPD = 0x4
	// Position of PD field.
	PLL_SYS_PWR_PD_Pos = 0x0
	// Bit mask of PD field.
	PLL_SYS_PWR_PD_Msk = 0x1
	// Bit PD.
	PLL_SYS_PWR_PD = 0x1

	// FBDIV_INT
	// Feedback divisor
	// (note: this PLL does not support fractional division)
	// Position of FBDIV_INT field.
	PLL_SYS_FBDIV_INT_FBDIV_INT_Pos = 0x0
	// Bit mask of FBDIV_INT field.
	PLL_SYS_FBDIV_INT_FBDIV_INT_Msk = 0xfff

	// PRIM
	// Controls the PLL post dividers for the primary output
	// (note: this PLL does not have a secondary output)
	// the primary output is driven from VCO divided by postdiv1*postdiv2
	// Position of POSTDIV1 field.
	PLL_SYS_PRIM_POSTDIV1_Pos = 0x10
	// Bit mask of POSTDIV1 field.
	PLL_SYS_PRIM_POSTDIV1_Msk = 0x70000
	// Position of POSTDIV2 field.
	PLL_SYS_PRIM_POSTDIV2_Pos = 0xc
	// Bit mask of POSTDIV2 field.
	PLL_SYS_PRIM_POSTDIV2_Msk = 0x7000
)

// Constants for BUSCTRL: Register block for busfabric control signals and performance counters
const (
	// BUS_PRIORITY: Set the priority of each master for bus arbitration.
	// Position of DMA_W field.
	BUSCTRL_BUS_PRIORITY_DMA_W_Pos = 0xc
	// Bit mask of DMA_W field.
	BUSCTRL_BUS_PRIORITY_DMA_W_Msk = 0x1000
	// Bit DMA_W.
	BUSCTRL_BUS_PRIORITY_DMA_W = 0x1000
	// Position of DMA_R field.
	BUSCTRL_BUS_PRIORITY_DMA_R_Pos = 0x8
	// Bit mask of DMA_R field.
	BUSCTRL_BUS_PRIORITY_DMA_R_Msk = 0x100
	// Bit DMA_R.
	BUSCTRL_BUS_PRIORITY_DMA_R = 0x100
	// Position of PROC1 field.
	BUSCTRL_BUS_PRIORITY_PROC1_Pos = 0x4
	// Bit mask of PROC1 field.
	BUSCTRL_BUS_PRIORITY_PROC1_Msk = 0x10
	// Bit PROC1.
	BUSCTRL_BUS_PRIORITY_PROC1 = 0x10
	// Position of PROC0 field.
	BUSCTRL_BUS_PRIORITY_PROC0_Pos = 0x0
	// Bit mask of PROC0 field.
	BUSCTRL_BUS_PRIORITY_PROC0_Msk = 0x1
	// Bit PROC0.
	BUSCTRL_BUS_PRIORITY_PROC0 = 0x1

	// BUS_PRIORITY_ACK: Bus priority acknowledge
	// Position of BUS_PRIORITY_ACK field.
	BUSCTRL_BUS_PRIORITY_ACK_BUS_PRIORITY_ACK_Pos = 0x0
	// Bit mask of BUS_PRIORITY_ACK field.
	BUSCTRL_BUS_PRIORITY_ACK_BUS_PRIORITY_ACK_Msk = 0x1
	// Bit BUS_PRIORITY_ACK.
	BUSCTRL_BUS_PRIORITY_ACK_BUS_PRIORITY_ACK = 0x1

	// PERFCTR0: Bus fabric performance counter 0
	// Position of PERFCTR0 field.
	BUSCTRL_PERFCTR0_PERFCTR0_Pos = 0x0
	// Bit mask of PERFCTR0 field.
	BUSCTRL_PERFCTR0_PERFCTR0_Msk = 0xffffff

	// PERFSEL0: Bus fabric performance event select for PERFCTR0
	// Position of PERFSEL0 field.
	BUSCTRL_PERFSEL0_PERFSEL0_Pos = 0x0
	// Bit mask of PERFSEL0 field.
	BUSCTRL_PERFSEL0_PERFSEL0_Msk = 0x1f

	// PERFCTR1: Bus fabric performance counter 1
	// Position of PERFCTR1 field.
	BUSCTRL_PERFCTR1_PERFCTR1_Pos = 0x0
	// Bit mask of PERFCTR1 field.
	BUSCTRL_PERFCTR1_PERFCTR1_Msk = 0xffffff

	// PERFSEL1: Bus fabric performance event select for PERFCTR1
	// Position of PERFSEL1 field.
	BUSCTRL_PERFSEL1_PERFSEL1_Pos = 0x0
	// Bit mask of PERFSEL1 field.
	BUSCTRL_PERFSEL1_PERFSEL1_Msk = 0x1f

	// PERFCTR2: Bus fabric performance counter 2
	// Position of PERFCTR2 field.
	BUSCTRL_PERFCTR2_PERFCTR2_Pos = 0x0
	// Bit mask of PERFCTR2 field.
	BUSCTRL_PERFCTR2_PERFCTR2_Msk = 0xffffff

	// PERFSEL2: Bus fabric performance event select for PERFCTR2
	// Position of PERFSEL2 field.
	BUSCTRL_PERFSEL2_PERFSEL2_Pos = 0x0
	// Bit mask of PERFSEL2 field.
	BUSCTRL_PERFSEL2_PERFSEL2_Msk = 0x1f

	// PERFCTR3: Bus fabric performance counter 3
	// Position of PERFCTR3 field.
	BUSCTRL_PERFCTR3_PERFCTR3_Pos = 0x0
	// Bit mask of PERFCTR3 field.
	BUSCTRL_PERFCTR3_PERFCTR3_Msk = 0xffffff

	// PERFSEL3: Bus fabric performance event select for PERFCTR3
	// Position of PERFSEL3 field.
	BUSCTRL_PERFSEL3_PERFSEL3_Pos = 0x0
	// Bit mask of PERFSEL3 field.
	BUSCTRL_PERFSEL3_PERFSEL3_Msk = 0x1f
)

// Constants for UART0
const (
	// UARTDR: Data Register, UARTDR
	// Position of OE field.
	UART0_UARTDR_OE_Pos = 0xb
	// Bit mask of OE field.
	UART0_UARTDR_OE_Msk = 0x800
	// Bit OE.
	UART0_UARTDR_OE = 0x800
	// Position of BE field.
	UART0_UARTDR_BE_Pos = 0xa
	// Bit mask of BE field.
	UART0_UARTDR_BE_Msk = 0x400
	// Bit BE.
	UART0_UARTDR_BE = 0x400
	// Position of PE field.
	UART0_UARTDR_PE_Pos = 0x9
	// Bit mask of PE field.
	UART0_UARTDR_PE_Msk = 0x200
	// Bit PE.
	UART0_UARTDR_PE = 0x200
	// Position of FE field.
	UART0_UARTDR_FE_Pos = 0x8
	// Bit mask of FE field.
	UART0_UARTDR_FE_Msk = 0x100
	// Bit FE.
	UART0_UARTDR_FE = 0x100
	// Position of DATA field.
	UART0_UARTDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	UART0_UARTDR_DATA_Msk = 0xff

	// UARTRSR: Receive Status Register/Error Clear Register, UARTRSR/UARTECR
	// Position of OE field.
	UART0_UARTRSR_OE_Pos = 0x3
	// Bit mask of OE field.
	UART0_UARTRSR_OE_Msk = 0x8
	// Bit OE.
	UART0_UARTRSR_OE = 0x8
	// Position of BE field.
	UART0_UARTRSR_BE_Pos = 0x2
	// Bit mask of BE field.
	UART0_UARTRSR_BE_Msk = 0x4
	// Bit BE.
	UART0_UARTRSR_BE = 0x4
	// Position of PE field.
	UART0_UARTRSR_PE_Pos = 0x1
	// Bit mask of PE field.
	UART0_UARTRSR_PE_Msk = 0x2
	// Bit PE.
	UART0_UARTRSR_PE = 0x2
	// Position of FE field.
	UART0_UARTRSR_FE_Pos = 0x0
	// Bit mask of FE field.
	UART0_UARTRSR_FE_Msk = 0x1
	// Bit FE.
	UART0_UARTRSR_FE = 0x1

	// UARTFR: Flag Register, UARTFR
	// Position of RI field.
	UART0_UARTFR_RI_Pos = 0x8
	// Bit mask of RI field.
	UART0_UARTFR_RI_Msk = 0x100
	// Bit RI.
	UART0_UARTFR_RI = 0x100
	// Position of TXFE field.
	UART0_UARTFR_TXFE_Pos = 0x7
	// Bit mask of TXFE field.
	UART0_UARTFR_TXFE_Msk = 0x80
	// Bit TXFE.
	UART0_UARTFR_TXFE = 0x80
	// Position of RXFF field.
	UART0_UARTFR_RXFF_Pos = 0x6
	// Bit mask of RXFF field.
	UART0_UARTFR_RXFF_Msk = 0x40
	// Bit RXFF.
	UART0_UARTFR_RXFF = 0x40
	// Position of TXFF field.
	UART0_UARTFR_TXFF_Pos = 0x5
	// Bit mask of TXFF field.
	UART0_UARTFR_TXFF_Msk = 0x20
	// Bit TXFF.
	UART0_UARTFR_TXFF = 0x20
	// Position of RXFE field.
	UART0_UARTFR_RXFE_Pos = 0x4
	// Bit mask of RXFE field.
	UART0_UARTFR_RXFE_Msk = 0x10
	// Bit RXFE.
	UART0_UARTFR_RXFE = 0x10
	// Position of BUSY field.
	UART0_UARTFR_BUSY_Pos = 0x3
	// Bit mask of BUSY field.
	UART0_UARTFR_BUSY_Msk = 0x8
	// Bit BUSY.
	UART0_UARTFR_BUSY = 0x8
	// Position of DCD field.
	UART0_UARTFR_DCD_Pos = 0x2
	// Bit mask of DCD field.
	UART0_UARTFR_DCD_Msk = 0x4
	// Bit DCD.
	UART0_UARTFR_DCD = 0x4
	// Position of DSR field.
	UART0_UARTFR_DSR_Pos = 0x1
	// Bit mask of DSR field.
	UART0_UARTFR_DSR_Msk = 0x2
	// Bit DSR.
	UART0_UARTFR_DSR = 0x2
	// Position of CTS field.
	UART0_UARTFR_CTS_Pos = 0x0
	// Bit mask of CTS field.
	UART0_UARTFR_CTS_Msk = 0x1
	// Bit CTS.
	UART0_UARTFR_CTS = 0x1

	// UARTILPR: IrDA Low-Power Counter Register, UARTILPR
	// Position of ILPDVSR field.
	UART0_UARTILPR_ILPDVSR_Pos = 0x0
	// Bit mask of ILPDVSR field.
	UART0_UARTILPR_ILPDVSR_Msk = 0xff

	// UARTIBRD: Integer Baud Rate Register, UARTIBRD
	// Position of BAUD_DIVINT field.
	UART0_UARTIBRD_BAUD_DIVINT_Pos = 0x0
	// Bit mask of BAUD_DIVINT field.
	UART0_UARTIBRD_BAUD_DIVINT_Msk = 0xffff

	// UARTFBRD: Fractional Baud Rate Register, UARTFBRD
	// Position of BAUD_DIVFRAC field.
	UART0_UARTFBRD_BAUD_DIVFRAC_Pos = 0x0
	// Bit mask of BAUD_DIVFRAC field.
	UART0_UARTFBRD_BAUD_DIVFRAC_Msk = 0x3f

	// UARTLCR_H: Line Control Register, UARTLCR_H
	// Position of SPS field.
	UART0_UARTLCR_H_SPS_Pos = 0x7
	// Bit mask of SPS field.
	UART0_UARTLCR_H_SPS_Msk = 0x80
	// Bit SPS.
	UART0_UARTLCR_H_SPS = 0x80
	// Position of WLEN field.
	UART0_UARTLCR_H_WLEN_Pos = 0x5
	// Bit mask of WLEN field.
	UART0_UARTLCR_H_WLEN_Msk = 0x60
	// Position of FEN field.
	UART0_UARTLCR_H_FEN_Pos = 0x4
	// Bit mask of FEN field.
	UART0_UARTLCR_H_FEN_Msk = 0x10
	// Bit FEN.
	UART0_UARTLCR_H_FEN = 0x10
	// Position of STP2 field.
	UART0_UARTLCR_H_STP2_Pos = 0x3
	// Bit mask of STP2 field.
	UART0_UARTLCR_H_STP2_Msk = 0x8
	// Bit STP2.
	UART0_UARTLCR_H_STP2 = 0x8
	// Position of EPS field.
	UART0_UARTLCR_H_EPS_Pos = 0x2
	// Bit mask of EPS field.
	UART0_UARTLCR_H_EPS_Msk = 0x4
	// Bit EPS.
	UART0_UARTLCR_H_EPS = 0x4
	// Position of PEN field.
	UART0_UARTLCR_H_PEN_Pos = 0x1
	// Bit mask of PEN field.
	UART0_UARTLCR_H_PEN_Msk = 0x2
	// Bit PEN.
	UART0_UARTLCR_H_PEN = 0x2
	// Position of BRK field.
	UART0_UARTLCR_H_BRK_Pos = 0x0
	// Bit mask of BRK field.
	UART0_UARTLCR_H_BRK_Msk = 0x1
	// Bit BRK.
	UART0_UARTLCR_H_BRK = 0x1

	// UARTCR: Control Register, UARTCR
	// Position of CTSEN field.
	UART0_UARTCR_CTSEN_Pos = 0xf
	// Bit mask of CTSEN field.
	UART0_UARTCR_CTSEN_Msk = 0x8000
	// Bit CTSEN.
	UART0_UARTCR_CTSEN = 0x8000
	// Position of RTSEN field.
	UART0_UARTCR_RTSEN_Pos = 0xe
	// Bit mask of RTSEN field.
	UART0_UARTCR_RTSEN_Msk = 0x4000
	// Bit RTSEN.
	UART0_UARTCR_RTSEN = 0x4000
	// Position of OUT2 field.
	UART0_UARTCR_OUT2_Pos = 0xd
	// Bit mask of OUT2 field.
	UART0_UARTCR_OUT2_Msk = 0x2000
	// Bit OUT2.
	UART0_UARTCR_OUT2 = 0x2000
	// Position of OUT1 field.
	UART0_UARTCR_OUT1_Pos = 0xc
	// Bit mask of OUT1 field.
	UART0_UARTCR_OUT1_Msk = 0x1000
	// Bit OUT1.
	UART0_UARTCR_OUT1 = 0x1000
	// Position of RTS field.
	UART0_UARTCR_RTS_Pos = 0xb
	// Bit mask of RTS field.
	UART0_UARTCR_RTS_Msk = 0x800
	// Bit RTS.
	UART0_UARTCR_RTS = 0x800
	// Position of DTR field.
	UART0_UARTCR_DTR_Pos = 0xa
	// Bit mask of DTR field.
	UART0_UARTCR_DTR_Msk = 0x400
	// Bit DTR.
	UART0_UARTCR_DTR = 0x400
	// Position of RXE field.
	UART0_UARTCR_RXE_Pos = 0x9
	// Bit mask of RXE field.
	UART0_UARTCR_RXE_Msk = 0x200
	// Bit RXE.
	UART0_UARTCR_RXE = 0x200
	// Position of TXE field.
	UART0_UARTCR_TXE_Pos = 0x8
	// Bit mask of TXE field.
	UART0_UARTCR_TXE_Msk = 0x100
	// Bit TXE.
	UART0_UARTCR_TXE = 0x100
	// Position of LBE field.
	UART0_UARTCR_LBE_Pos = 0x7
	// Bit mask of LBE field.
	UART0_UARTCR_LBE_Msk = 0x80
	// Bit LBE.
	UART0_UARTCR_LBE = 0x80
	// Position of SIRLP field.
	UART0_UARTCR_SIRLP_Pos = 0x2
	// Bit mask of SIRLP field.
	UART0_UARTCR_SIRLP_Msk = 0x4
	// Bit SIRLP.
	UART0_UARTCR_SIRLP = 0x4
	// Position of SIREN field.
	UART0_UARTCR_SIREN_Pos = 0x1
	// Bit mask of SIREN field.
	UART0_UARTCR_SIREN_Msk = 0x2
	// Bit SIREN.
	UART0_UARTCR_SIREN = 0x2
	// Position of UARTEN field.
	UART0_UARTCR_UARTEN_Pos = 0x0
	// Bit mask of UARTEN field.
	UART0_UARTCR_UARTEN_Msk = 0x1
	// Bit UARTEN.
	UART0_UARTCR_UARTEN = 0x1

	// UARTIFLS: Interrupt FIFO Level Select Register, UARTIFLS
	// Position of RXIFLSEL field.
	UART0_UARTIFLS_RXIFLSEL_Pos = 0x3
	// Bit mask of RXIFLSEL field.
	UART0_UARTIFLS_RXIFLSEL_Msk = 0x38
	// Position of TXIFLSEL field.
	UART0_UARTIFLS_TXIFLSEL_Pos = 0x0
	// Bit mask of TXIFLSEL field.
	UART0_UARTIFLS_TXIFLSEL_Msk = 0x7

	// UARTIMSC: Interrupt Mask Set/Clear Register, UARTIMSC
	// Position of OEIM field.
	UART0_UARTIMSC_OEIM_Pos = 0xa
	// Bit mask of OEIM field.
	UART0_UARTIMSC_OEIM_Msk = 0x400
	// Bit OEIM.
	UART0_UARTIMSC_OEIM = 0x400
	// Position of BEIM field.
	UART0_UARTIMSC_BEIM_Pos = 0x9
	// Bit mask of BEIM field.
	UART0_UARTIMSC_BEIM_Msk = 0x200
	// Bit BEIM.
	UART0_UARTIMSC_BEIM = 0x200
	// Position of PEIM field.
	UART0_UARTIMSC_PEIM_Pos = 0x8
	// Bit mask of PEIM field.
	UART0_UARTIMSC_PEIM_Msk = 0x100
	// Bit PEIM.
	UART0_UARTIMSC_PEIM = 0x100
	// Position of FEIM field.
	UART0_UARTIMSC_FEIM_Pos = 0x7
	// Bit mask of FEIM field.
	UART0_UARTIMSC_FEIM_Msk = 0x80
	// Bit FEIM.
	UART0_UARTIMSC_FEIM = 0x80
	// Position of RTIM field.
	UART0_UARTIMSC_RTIM_Pos = 0x6
	// Bit mask of RTIM field.
	UART0_UARTIMSC_RTIM_Msk = 0x40
	// Bit RTIM.
	UART0_UARTIMSC_RTIM = 0x40
	// Position of TXIM field.
	UART0_UARTIMSC_TXIM_Pos = 0x5
	// Bit mask of TXIM field.
	UART0_UARTIMSC_TXIM_Msk = 0x20
	// Bit TXIM.
	UART0_UARTIMSC_TXIM = 0x20
	// Position of RXIM field.
	UART0_UARTIMSC_RXIM_Pos = 0x4
	// Bit mask of RXIM field.
	UART0_UARTIMSC_RXIM_Msk = 0x10
	// Bit RXIM.
	UART0_UARTIMSC_RXIM = 0x10
	// Position of DSRMIM field.
	UART0_UARTIMSC_DSRMIM_Pos = 0x3
	// Bit mask of DSRMIM field.
	UART0_UARTIMSC_DSRMIM_Msk = 0x8
	// Bit DSRMIM.
	UART0_UARTIMSC_DSRMIM = 0x8
	// Position of DCDMIM field.
	UART0_UARTIMSC_DCDMIM_Pos = 0x2
	// Bit mask of DCDMIM field.
	UART0_UARTIMSC_DCDMIM_Msk = 0x4
	// Bit DCDMIM.
	UART0_UARTIMSC_DCDMIM = 0x4
	// Position of CTSMIM field.
	UART0_UARTIMSC_CTSMIM_Pos = 0x1
	// Bit mask of CTSMIM field.
	UART0_UARTIMSC_CTSMIM_Msk = 0x2
	// Bit CTSMIM.
	UART0_UARTIMSC_CTSMIM = 0x2
	// Position of RIMIM field.
	UART0_UARTIMSC_RIMIM_Pos = 0x0
	// Bit mask of RIMIM field.
	UART0_UARTIMSC_RIMIM_Msk = 0x1
	// Bit RIMIM.
	UART0_UARTIMSC_RIMIM = 0x1

	// UARTRIS: Raw Interrupt Status Register, UARTRIS
	// Position of OERIS field.
	UART0_UARTRIS_OERIS_Pos = 0xa
	// Bit mask of OERIS field.
	UART0_UARTRIS_OERIS_Msk = 0x400
	// Bit OERIS.
	UART0_UARTRIS_OERIS = 0x400
	// Position of BERIS field.
	UART0_UARTRIS_BERIS_Pos = 0x9
	// Bit mask of BERIS field.
	UART0_UARTRIS_BERIS_Msk = 0x200
	// Bit BERIS.
	UART0_UARTRIS_BERIS = 0x200
	// Position of PERIS field.
	UART0_UARTRIS_PERIS_Pos = 0x8
	// Bit mask of PERIS field.
	UART0_UARTRIS_PERIS_Msk = 0x100
	// Bit PERIS.
	UART0_UARTRIS_PERIS = 0x100
	// Position of FERIS field.
	UART0_UARTRIS_FERIS_Pos = 0x7
	// Bit mask of FERIS field.
	UART0_UARTRIS_FERIS_Msk = 0x80
	// Bit FERIS.
	UART0_UARTRIS_FERIS = 0x80
	// Position of RTRIS field.
	UART0_UARTRIS_RTRIS_Pos = 0x6
	// Bit mask of RTRIS field.
	UART0_UARTRIS_RTRIS_Msk = 0x40
	// Bit RTRIS.
	UART0_UARTRIS_RTRIS = 0x40
	// Position of TXRIS field.
	UART0_UARTRIS_TXRIS_Pos = 0x5
	// Bit mask of TXRIS field.
	UART0_UARTRIS_TXRIS_Msk = 0x20
	// Bit TXRIS.
	UART0_UARTRIS_TXRIS = 0x20
	// Position of RXRIS field.
	UART0_UARTRIS_RXRIS_Pos = 0x4
	// Bit mask of RXRIS field.
	UART0_UARTRIS_RXRIS_Msk = 0x10
	// Bit RXRIS.
	UART0_UARTRIS_RXRIS = 0x10
	// Position of DSRRMIS field.
	UART0_UARTRIS_DSRRMIS_Pos = 0x3
	// Bit mask of DSRRMIS field.
	UART0_UARTRIS_DSRRMIS_Msk = 0x8
	// Bit DSRRMIS.
	UART0_UARTRIS_DSRRMIS = 0x8
	// Position of DCDRMIS field.
	UART0_UARTRIS_DCDRMIS_Pos = 0x2
	// Bit mask of DCDRMIS field.
	UART0_UARTRIS_DCDRMIS_Msk = 0x4
	// Bit DCDRMIS.
	UART0_UARTRIS_DCDRMIS = 0x4
	// Position of CTSRMIS field.
	UART0_UARTRIS_CTSRMIS_Pos = 0x1
	// Bit mask of CTSRMIS field.
	UART0_UARTRIS_CTSRMIS_Msk = 0x2
	// Bit CTSRMIS.
	UART0_UARTRIS_CTSRMIS = 0x2
	// Position of RIRMIS field.
	UART0_UARTRIS_RIRMIS_Pos = 0x0
	// Bit mask of RIRMIS field.
	UART0_UARTRIS_RIRMIS_Msk = 0x1
	// Bit RIRMIS.
	UART0_UARTRIS_RIRMIS = 0x1

	// UARTMIS: Masked Interrupt Status Register, UARTMIS
	// Position of OEMIS field.
	UART0_UARTMIS_OEMIS_Pos = 0xa
	// Bit mask of OEMIS field.
	UART0_UARTMIS_OEMIS_Msk = 0x400
	// Bit OEMIS.
	UART0_UARTMIS_OEMIS = 0x400
	// Position of BEMIS field.
	UART0_UARTMIS_BEMIS_Pos = 0x9
	// Bit mask of BEMIS field.
	UART0_UARTMIS_BEMIS_Msk = 0x200
	// Bit BEMIS.
	UART0_UARTMIS_BEMIS = 0x200
	// Position of PEMIS field.
	UART0_UARTMIS_PEMIS_Pos = 0x8
	// Bit mask of PEMIS field.
	UART0_UARTMIS_PEMIS_Msk = 0x100
	// Bit PEMIS.
	UART0_UARTMIS_PEMIS = 0x100
	// Position of FEMIS field.
	UART0_UARTMIS_FEMIS_Pos = 0x7
	// Bit mask of FEMIS field.
	UART0_UARTMIS_FEMIS_Msk = 0x80
	// Bit FEMIS.
	UART0_UARTMIS_FEMIS = 0x80
	// Position of RTMIS field.
	UART0_UARTMIS_RTMIS_Pos = 0x6
	// Bit mask of RTMIS field.
	UART0_UARTMIS_RTMIS_Msk = 0x40
	// Bit RTMIS.
	UART0_UARTMIS_RTMIS = 0x40
	// Position of TXMIS field.
	UART0_UARTMIS_TXMIS_Pos = 0x5
	// Bit mask of TXMIS field.
	UART0_UARTMIS_TXMIS_Msk = 0x20
	// Bit TXMIS.
	UART0_UARTMIS_TXMIS = 0x20
	// Position of RXMIS field.
	UART0_UARTMIS_RXMIS_Pos = 0x4
	// Bit mask of RXMIS field.
	UART0_UARTMIS_RXMIS_Msk = 0x10
	// Bit RXMIS.
	UART0_UARTMIS_RXMIS = 0x10
	// Position of DSRMMIS field.
	UART0_UARTMIS_DSRMMIS_Pos = 0x3
	// Bit mask of DSRMMIS field.
	UART0_UARTMIS_DSRMMIS_Msk = 0x8
	// Bit DSRMMIS.
	UART0_UARTMIS_DSRMMIS = 0x8
	// Position of DCDMMIS field.
	UART0_UARTMIS_DCDMMIS_Pos = 0x2
	// Bit mask of DCDMMIS field.
	UART0_UARTMIS_DCDMMIS_Msk = 0x4
	// Bit DCDMMIS.
	UART0_UARTMIS_DCDMMIS = 0x4
	// Position of CTSMMIS field.
	UART0_UARTMIS_CTSMMIS_Pos = 0x1
	// Bit mask of CTSMMIS field.
	UART0_UARTMIS_CTSMMIS_Msk = 0x2
	// Bit CTSMMIS.
	UART0_UARTMIS_CTSMMIS = 0x2
	// Position of RIMMIS field.
	UART0_UARTMIS_RIMMIS_Pos = 0x0
	// Bit mask of RIMMIS field.
	UART0_UARTMIS_RIMMIS_Msk = 0x1
	// Bit RIMMIS.
	UART0_UARTMIS_RIMMIS = 0x1

	// UARTICR: Interrupt Clear Register, UARTICR
	// Position of OEIC field.
	UART0_UARTICR_OEIC_Pos = 0xa
	// Bit mask of OEIC field.
	UART0_UARTICR_OEIC_Msk = 0x400
	// Bit OEIC.
	UART0_UARTICR_OEIC = 0x400
	// Position of BEIC field.
	UART0_UARTICR_BEIC_Pos = 0x9
	// Bit mask of BEIC field.
	UART0_UARTICR_BEIC_Msk = 0x200
	// Bit BEIC.
	UART0_UARTICR_BEIC = 0x200
	// Position of PEIC field.
	UART0_UARTICR_PEIC_Pos = 0x8
	// Bit mask of PEIC field.
	UART0_UARTICR_PEIC_Msk = 0x100
	// Bit PEIC.
	UART0_UARTICR_PEIC = 0x100
	// Position of FEIC field.
	UART0_UARTICR_FEIC_Pos = 0x7
	// Bit mask of FEIC field.
	UART0_UARTICR_FEIC_Msk = 0x80
	// Bit FEIC.
	UART0_UARTICR_FEIC = 0x80
	// Position of RTIC field.
	UART0_UARTICR_RTIC_Pos = 0x6
	// Bit mask of RTIC field.
	UART0_UARTICR_RTIC_Msk = 0x40
	// Bit RTIC.
	UART0_UARTICR_RTIC = 0x40
	// Position of TXIC field.
	UART0_UARTICR_TXIC_Pos = 0x5
	// Bit mask of TXIC field.
	UART0_UARTICR_TXIC_Msk = 0x20
	// Bit TXIC.
	UART0_UARTICR_TXIC = 0x20
	// Position of RXIC field.
	UART0_UARTICR_RXIC_Pos = 0x4
	// Bit mask of RXIC field.
	UART0_UARTICR_RXIC_Msk = 0x10
	// Bit RXIC.
	UART0_UARTICR_RXIC = 0x10
	// Position of DSRMIC field.
	UART0_UARTICR_DSRMIC_Pos = 0x3
	// Bit mask of DSRMIC field.
	UART0_UARTICR_DSRMIC_Msk = 0x8
	// Bit DSRMIC.
	UART0_UARTICR_DSRMIC = 0x8
	// Position of DCDMIC field.
	UART0_UARTICR_DCDMIC_Pos = 0x2
	// Bit mask of DCDMIC field.
	UART0_UARTICR_DCDMIC_Msk = 0x4
	// Bit DCDMIC.
	UART0_UARTICR_DCDMIC = 0x4
	// Position of CTSMIC field.
	UART0_UARTICR_CTSMIC_Pos = 0x1
	// Bit mask of CTSMIC field.
	UART0_UARTICR_CTSMIC_Msk = 0x2
	// Bit CTSMIC.
	UART0_UARTICR_CTSMIC = 0x2
	// Position of RIMIC field.
	UART0_UARTICR_RIMIC_Pos = 0x0
	// Bit mask of RIMIC field.
	UART0_UARTICR_RIMIC_Msk = 0x1
	// Bit RIMIC.
	UART0_UARTICR_RIMIC = 0x1

	// UARTDMACR: DMA Control Register, UARTDMACR
	// Position of DMAONERR field.
	UART0_UARTDMACR_DMAONERR_Pos = 0x2
	// Bit mask of DMAONERR field.
	UART0_UARTDMACR_DMAONERR_Msk = 0x4
	// Bit DMAONERR.
	UART0_UARTDMACR_DMAONERR = 0x4
	// Position of TXDMAE field.
	UART0_UARTDMACR_TXDMAE_Pos = 0x1
	// Bit mask of TXDMAE field.
	UART0_UARTDMACR_TXDMAE_Msk = 0x2
	// Bit TXDMAE.
	UART0_UARTDMACR_TXDMAE = 0x2
	// Position of RXDMAE field.
	UART0_UARTDMACR_RXDMAE_Pos = 0x0
	// Bit mask of RXDMAE field.
	UART0_UARTDMACR_RXDMAE_Msk = 0x1
	// Bit RXDMAE.
	UART0_UARTDMACR_RXDMAE = 0x1

	// UARTPERIPHID0: UARTPeriphID0 Register
	// Position of PARTNUMBER0 field.
	UART0_UARTPERIPHID0_PARTNUMBER0_Pos = 0x0
	// Bit mask of PARTNUMBER0 field.
	UART0_UARTPERIPHID0_PARTNUMBER0_Msk = 0xff

	// UARTPERIPHID1: UARTPeriphID1 Register
	// Position of DESIGNER0 field.
	UART0_UARTPERIPHID1_DESIGNER0_Pos = 0x4
	// Bit mask of DESIGNER0 field.
	UART0_UARTPERIPHID1_DESIGNER0_Msk = 0xf0
	// Position of PARTNUMBER1 field.
	UART0_UARTPERIPHID1_PARTNUMBER1_Pos = 0x0
	// Bit mask of PARTNUMBER1 field.
	UART0_UARTPERIPHID1_PARTNUMBER1_Msk = 0xf

	// UARTPERIPHID2: UARTPeriphID2 Register
	// Position of REVISION field.
	UART0_UARTPERIPHID2_REVISION_Pos = 0x4
	// Bit mask of REVISION field.
	UART0_UARTPERIPHID2_REVISION_Msk = 0xf0
	// Position of DESIGNER1 field.
	UART0_UARTPERIPHID2_DESIGNER1_Pos = 0x0
	// Bit mask of DESIGNER1 field.
	UART0_UARTPERIPHID2_DESIGNER1_Msk = 0xf

	// UARTPERIPHID3: UARTPeriphID3 Register
	// Position of CONFIGURATION field.
	UART0_UARTPERIPHID3_CONFIGURATION_Pos = 0x0
	// Bit mask of CONFIGURATION field.
	UART0_UARTPERIPHID3_CONFIGURATION_Msk = 0xff

	// UARTPCELLID0: UARTPCellID0 Register
	// Position of UARTPCELLID0 field.
	UART0_UARTPCELLID0_UARTPCELLID0_Pos = 0x0
	// Bit mask of UARTPCELLID0 field.
	UART0_UARTPCELLID0_UARTPCELLID0_Msk = 0xff

	// UARTPCELLID1: UARTPCellID1 Register
	// Position of UARTPCELLID1 field.
	UART0_UARTPCELLID1_UARTPCELLID1_Pos = 0x0
	// Bit mask of UARTPCELLID1 field.
	UART0_UARTPCELLID1_UARTPCELLID1_Msk = 0xff

	// UARTPCELLID2: UARTPCellID2 Register
	// Position of UARTPCELLID2 field.
	UART0_UARTPCELLID2_UARTPCELLID2_Pos = 0x0
	// Bit mask of UARTPCELLID2 field.
	UART0_UARTPCELLID2_UARTPCELLID2_Msk = 0xff

	// UARTPCELLID3: UARTPCellID3 Register
	// Position of UARTPCELLID3 field.
	UART0_UARTPCELLID3_UARTPCELLID3_Pos = 0x0
	// Bit mask of UARTPCELLID3 field.
	UART0_UARTPCELLID3_UARTPCELLID3_Msk = 0xff
)

// Constants for SPI0
const (
	// SSPCR0: Control register 0, SSPCR0 on page 3-4
	// Position of SCR field.
	SPI0_SSPCR0_SCR_Pos = 0x8
	// Bit mask of SCR field.
	SPI0_SSPCR0_SCR_Msk = 0xff00
	// Position of SPH field.
	SPI0_SSPCR0_SPH_Pos = 0x7
	// Bit mask of SPH field.
	SPI0_SSPCR0_SPH_Msk = 0x80
	// Bit SPH.
	SPI0_SSPCR0_SPH = 0x80
	// Position of SPO field.
	SPI0_SSPCR0_SPO_Pos = 0x6
	// Bit mask of SPO field.
	SPI0_SSPCR0_SPO_Msk = 0x40
	// Bit SPO.
	SPI0_SSPCR0_SPO = 0x40
	// Position of FRF field.
	SPI0_SSPCR0_FRF_Pos = 0x4
	// Bit mask of FRF field.
	SPI0_SSPCR0_FRF_Msk = 0x30
	// Position of DSS field.
	SPI0_SSPCR0_DSS_Pos = 0x0
	// Bit mask of DSS field.
	SPI0_SSPCR0_DSS_Msk = 0xf

	// SSPCR1: Control register 1, SSPCR1 on page 3-5
	// Position of SOD field.
	SPI0_SSPCR1_SOD_Pos = 0x3
	// Bit mask of SOD field.
	SPI0_SSPCR1_SOD_Msk = 0x8
	// Bit SOD.
	SPI0_SSPCR1_SOD = 0x8
	// Position of MS field.
	SPI0_SSPCR1_MS_Pos = 0x2
	// Bit mask of MS field.
	SPI0_SSPCR1_MS_Msk = 0x4
	// Bit MS.
	SPI0_SSPCR1_MS = 0x4
	// Position of SSE field.
	SPI0_SSPCR1_SSE_Pos = 0x1
	// Bit mask of SSE field.
	SPI0_SSPCR1_SSE_Msk = 0x2
	// Bit SSE.
	SPI0_SSPCR1_SSE = 0x2
	// Position of LBM field.
	SPI0_SSPCR1_LBM_Pos = 0x0
	// Bit mask of LBM field.
	SPI0_SSPCR1_LBM_Msk = 0x1
	// Bit LBM.
	SPI0_SSPCR1_LBM = 0x1

	// SSPDR: Data register, SSPDR on page 3-6
	// Position of DATA field.
	SPI0_SSPDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	SPI0_SSPDR_DATA_Msk = 0xffff

	// SSPSR: Status register, SSPSR on page 3-7
	// Position of BSY field.
	SPI0_SSPSR_BSY_Pos = 0x4
	// Bit mask of BSY field.
	SPI0_SSPSR_BSY_Msk = 0x10
	// Bit BSY.
	SPI0_SSPSR_BSY = 0x10
	// Position of RFF field.
	SPI0_SSPSR_RFF_Pos = 0x3
	// Bit mask of RFF field.
	SPI0_SSPSR_RFF_Msk = 0x8
	// Bit RFF.
	SPI0_SSPSR_RFF = 0x8
	// Position of RNE field.
	SPI0_SSPSR_RNE_Pos = 0x2
	// Bit mask of RNE field.
	SPI0_SSPSR_RNE_Msk = 0x4
	// Bit RNE.
	SPI0_SSPSR_RNE = 0x4
	// Position of TNF field.
	SPI0_SSPSR_TNF_Pos = 0x1
	// Bit mask of TNF field.
	SPI0_SSPSR_TNF_Msk = 0x2
	// Bit TNF.
	SPI0_SSPSR_TNF = 0x2
	// Position of TFE field.
	SPI0_SSPSR_TFE_Pos = 0x0
	// Bit mask of TFE field.
	SPI0_SSPSR_TFE_Msk = 0x1
	// Bit TFE.
	SPI0_SSPSR_TFE = 0x1

	// SSPCPSR: Clock prescale register, SSPCPSR on page 3-8
	// Position of CPSDVSR field.
	SPI0_SSPCPSR_CPSDVSR_Pos = 0x0
	// Bit mask of CPSDVSR field.
	SPI0_SSPCPSR_CPSDVSR_Msk = 0xff

	// SSPIMSC: Interrupt mask set or clear register, SSPIMSC on page 3-9
	// Position of TXIM field.
	SPI0_SSPIMSC_TXIM_Pos = 0x3
	// Bit mask of TXIM field.
	SPI0_SSPIMSC_TXIM_Msk = 0x8
	// Bit TXIM.
	SPI0_SSPIMSC_TXIM = 0x8
	// Position of RXIM field.
	SPI0_SSPIMSC_RXIM_Pos = 0x2
	// Bit mask of RXIM field.
	SPI0_SSPIMSC_RXIM_Msk = 0x4
	// Bit RXIM.
	SPI0_SSPIMSC_RXIM = 0x4
	// Position of RTIM field.
	SPI0_SSPIMSC_RTIM_Pos = 0x1
	// Bit mask of RTIM field.
	SPI0_SSPIMSC_RTIM_Msk = 0x2
	// Bit RTIM.
	SPI0_SSPIMSC_RTIM = 0x2
	// Position of RORIM field.
	SPI0_SSPIMSC_RORIM_Pos = 0x0
	// Bit mask of RORIM field.
	SPI0_SSPIMSC_RORIM_Msk = 0x1
	// Bit RORIM.
	SPI0_SSPIMSC_RORIM = 0x1

	// SSPRIS: Raw interrupt status register, SSPRIS on page 3-10
	// Position of TXRIS field.
	SPI0_SSPRIS_TXRIS_Pos = 0x3
	// Bit mask of TXRIS field.
	SPI0_SSPRIS_TXRIS_Msk = 0x8
	// Bit TXRIS.
	SPI0_SSPRIS_TXRIS = 0x8
	// Position of RXRIS field.
	SPI0_SSPRIS_RXRIS_Pos = 0x2
	// Bit mask of RXRIS field.
	SPI0_SSPRIS_RXRIS_Msk = 0x4
	// Bit RXRIS.
	SPI0_SSPRIS_RXRIS = 0x4
	// Position of RTRIS field.
	SPI0_SSPRIS_RTRIS_Pos = 0x1
	// Bit mask of RTRIS field.
	SPI0_SSPRIS_RTRIS_Msk = 0x2
	// Bit RTRIS.
	SPI0_SSPRIS_RTRIS = 0x2
	// Position of RORRIS field.
	SPI0_SSPRIS_RORRIS_Pos = 0x0
	// Bit mask of RORRIS field.
	SPI0_SSPRIS_RORRIS_Msk = 0x1
	// Bit RORRIS.
	SPI0_SSPRIS_RORRIS = 0x1

	// SSPMIS: Masked interrupt status register, SSPMIS on page 3-11
	// Position of TXMIS field.
	SPI0_SSPMIS_TXMIS_Pos = 0x3
	// Bit mask of TXMIS field.
	SPI0_SSPMIS_TXMIS_Msk = 0x8
	// Bit TXMIS.
	SPI0_SSPMIS_TXMIS = 0x8
	// Position of RXMIS field.
	SPI0_SSPMIS_RXMIS_Pos = 0x2
	// Bit mask of RXMIS field.
	SPI0_SSPMIS_RXMIS_Msk = 0x4
	// Bit RXMIS.
	SPI0_SSPMIS_RXMIS = 0x4
	// Position of RTMIS field.
	SPI0_SSPMIS_RTMIS_Pos = 0x1
	// Bit mask of RTMIS field.
	SPI0_SSPMIS_RTMIS_Msk = 0x2
	// Bit RTMIS.
	SPI0_SSPMIS_RTMIS = 0x2
	// Position of RORMIS field.
	SPI0_SSPMIS_RORMIS_Pos = 0x0
	// Bit mask of RORMIS field.
	SPI0_SSPMIS_RORMIS_Msk = 0x1
	// Bit RORMIS.
	SPI0_SSPMIS_RORMIS = 0x1

	// SSPICR: Interrupt clear register, SSPICR on page 3-11
	// Position of RTIC field.
	SPI0_SSPICR_RTIC_Pos = 0x1
	// Bit mask of RTIC field.
	SPI0_SSPICR_RTIC_Msk = 0x2
	// Bit RTIC.
	SPI0_SSPICR_RTIC = 0x2
	// Position of RORIC field.
	SPI0_SSPICR_RORIC_Pos = 0x0
	// Bit mask of RORIC field.
	SPI0_SSPICR_RORIC_Msk = 0x1
	// Bit RORIC.
	SPI0_SSPICR_RORIC = 0x1

	// SSPDMACR: DMA control register, SSPDMACR on page 3-12
	// Position of TXDMAE field.
	SPI0_SSPDMACR_TXDMAE_Pos = 0x1
	// Bit mask of TXDMAE field.
	SPI0_SSPDMACR_TXDMAE_Msk = 0x2
	// Bit TXDMAE.
	SPI0_SSPDMACR_TXDMAE = 0x2
	// Position of RXDMAE field.
	SPI0_SSPDMACR_RXDMAE_Pos = 0x0
	// Bit mask of RXDMAE field.
	SPI0_SSPDMACR_RXDMAE_Msk = 0x1
	// Bit RXDMAE.
	SPI0_SSPDMACR_RXDMAE = 0x1

	// SSPPERIPHID0: Peripheral identification registers, SSPPeriphID0-3 on page 3-13
	// Position of PARTNUMBER0 field.
	SPI0_SSPPERIPHID0_PARTNUMBER0_Pos = 0x0
	// Bit mask of PARTNUMBER0 field.
	SPI0_SSPPERIPHID0_PARTNUMBER0_Msk = 0xff

	// SSPPERIPHID1: Peripheral identification registers, SSPPeriphID0-3 on page 3-13
	// Position of DESIGNER0 field.
	SPI0_SSPPERIPHID1_DESIGNER0_Pos = 0x4
	// Bit mask of DESIGNER0 field.
	SPI0_SSPPERIPHID1_DESIGNER0_Msk = 0xf0
	// Position of PARTNUMBER1 field.
	SPI0_SSPPERIPHID1_PARTNUMBER1_Pos = 0x0
	// Bit mask of PARTNUMBER1 field.
	SPI0_SSPPERIPHID1_PARTNUMBER1_Msk = 0xf

	// SSPPERIPHID2: Peripheral identification registers, SSPPeriphID0-3 on page 3-13
	// Position of REVISION field.
	SPI0_SSPPERIPHID2_REVISION_Pos = 0x4
	// Bit mask of REVISION field.
	SPI0_SSPPERIPHID2_REVISION_Msk = 0xf0
	// Position of DESIGNER1 field.
	SPI0_SSPPERIPHID2_DESIGNER1_Pos = 0x0
	// Bit mask of DESIGNER1 field.
	SPI0_SSPPERIPHID2_DESIGNER1_Msk = 0xf

	// SSPPERIPHID3: Peripheral identification registers, SSPPeriphID0-3 on page 3-13
	// Position of CONFIGURATION field.
	SPI0_SSPPERIPHID3_CONFIGURATION_Pos = 0x0
	// Bit mask of CONFIGURATION field.
	SPI0_SSPPERIPHID3_CONFIGURATION_Msk = 0xff

	// SSPPCELLID0: PrimeCell identification registers, SSPPCellID0-3 on page 3-16
	// Position of SSPPCELLID0 field.
	SPI0_SSPPCELLID0_SSPPCELLID0_Pos = 0x0
	// Bit mask of SSPPCELLID0 field.
	SPI0_SSPPCELLID0_SSPPCELLID0_Msk = 0xff

	// SSPPCELLID1: PrimeCell identification registers, SSPPCellID0-3 on page 3-16
	// Position of SSPPCELLID1 field.
	SPI0_SSPPCELLID1_SSPPCELLID1_Pos = 0x0
	// Bit mask of SSPPCELLID1 field.
	SPI0_SSPPCELLID1_SSPPCELLID1_Msk = 0xff

	// SSPPCELLID2: PrimeCell identification registers, SSPPCellID0-3 on page 3-16
	// Position of SSPPCELLID2 field.
	SPI0_SSPPCELLID2_SSPPCELLID2_Pos = 0x0
	// Bit mask of SSPPCELLID2 field.
	SPI0_SSPPCELLID2_SSPPCELLID2_Msk = 0xff

	// SSPPCELLID3: PrimeCell identification registers, SSPPCellID0-3 on page 3-16
	// Position of SSPPCELLID3 field.
	SPI0_SSPPCELLID3_SSPPCELLID3_Pos = 0x0
	// Bit mask of SSPPCELLID3 field.
	SPI0_SSPPCELLID3_SSPPCELLID3_Msk = 0xff
)

// Constants for I2C0: DW_apb_i2c address block
const (
	// IC_CON
	// I2C Control Register. This register can be written only when the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n
	// Read/Write Access: - bit 10 is read only. - bit 11 is read only - bit 16 is read only - bit 17 is read only - bits 18 and 19 are read only.
	// Position of STOP_DET_IF_MASTER_ACTIVE field.
	I2C0_IC_CON_STOP_DET_IF_MASTER_ACTIVE_Pos = 0xa
	// Bit mask of STOP_DET_IF_MASTER_ACTIVE field.
	I2C0_IC_CON_STOP_DET_IF_MASTER_ACTIVE_Msk = 0x400
	// Bit STOP_DET_IF_MASTER_ACTIVE.
	I2C0_IC_CON_STOP_DET_IF_MASTER_ACTIVE = 0x400
	// Position of RX_FIFO_FULL_HLD_CTRL field.
	I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL_Pos = 0x9
	// Bit mask of RX_FIFO_FULL_HLD_CTRL field.
	I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL_Msk = 0x200
	// Bit RX_FIFO_FULL_HLD_CTRL.
	I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL = 0x200
	// Overflow when RX_FIFO is full
	I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL_DISABLED = 0x0
	// Hold bus when RX_FIFO is full
	I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL_ENABLED = 0x1
	// Position of TX_EMPTY_CTRL field.
	I2C0_IC_CON_TX_EMPTY_CTRL_Pos = 0x8
	// Bit mask of TX_EMPTY_CTRL field.
	I2C0_IC_CON_TX_EMPTY_CTRL_Msk = 0x100
	// Bit TX_EMPTY_CTRL.
	I2C0_IC_CON_TX_EMPTY_CTRL = 0x100
	// Default behaviour of TX_EMPTY interrupt
	I2C0_IC_CON_TX_EMPTY_CTRL_DISABLED = 0x0
	// Controlled generation of TX_EMPTY interrupt
	I2C0_IC_CON_TX_EMPTY_CTRL_ENABLED = 0x1
	// Position of STOP_DET_IFADDRESSED field.
	I2C0_IC_CON_STOP_DET_IFADDRESSED_Pos = 0x7
	// Bit mask of STOP_DET_IFADDRESSED field.
	I2C0_IC_CON_STOP_DET_IFADDRESSED_Msk = 0x80
	// Bit STOP_DET_IFADDRESSED.
	I2C0_IC_CON_STOP_DET_IFADDRESSED = 0x80
	// slave issues STOP_DET intr always
	I2C0_IC_CON_STOP_DET_IFADDRESSED_DISABLED = 0x0
	// slave issues STOP_DET intr only if addressed
	I2C0_IC_CON_STOP_DET_IFADDRESSED_ENABLED = 0x1
	// Position of IC_SLAVE_DISABLE field.
	I2C0_IC_CON_IC_SLAVE_DISABLE_Pos = 0x6
	// Bit mask of IC_SLAVE_DISABLE field.
	I2C0_IC_CON_IC_SLAVE_DISABLE_Msk = 0x40
	// Bit IC_SLAVE_DISABLE.
	I2C0_IC_CON_IC_SLAVE_DISABLE = 0x40
	// Slave mode is enabled
	I2C0_IC_CON_IC_SLAVE_DISABLE_SLAVE_ENABLED = 0x0
	// Slave mode is disabled
	I2C0_IC_CON_IC_SLAVE_DISABLE_SLAVE_DISABLED = 0x1
	// Position of IC_RESTART_EN field.
	I2C0_IC_CON_IC_RESTART_EN_Pos = 0x5
	// Bit mask of IC_RESTART_EN field.
	I2C0_IC_CON_IC_RESTART_EN_Msk = 0x20
	// Bit IC_RESTART_EN.
	I2C0_IC_CON_IC_RESTART_EN = 0x20
	// Master restart disabled
	I2C0_IC_CON_IC_RESTART_EN_DISABLED = 0x0
	// Master restart enabled
	I2C0_IC_CON_IC_RESTART_EN_ENABLED = 0x1
	// Position of IC_10BITADDR_MASTER field.
	I2C0_IC_CON_IC_10BITADDR_MASTER_Pos = 0x4
	// Bit mask of IC_10BITADDR_MASTER field.
	I2C0_IC_CON_IC_10BITADDR_MASTER_Msk = 0x10
	// Bit IC_10BITADDR_MASTER.
	I2C0_IC_CON_IC_10BITADDR_MASTER = 0x10
	// Master 7Bit addressing mode
	I2C0_IC_CON_IC_10BITADDR_MASTER_ADDR_7BITS = 0x0
	// Master 10Bit addressing mode
	I2C0_IC_CON_IC_10BITADDR_MASTER_ADDR_10BITS = 0x1
	// Position of IC_10BITADDR_SLAVE field.
	I2C0_IC_CON_IC_10BITADDR_SLAVE_Pos = 0x3
	// Bit mask of IC_10BITADDR_SLAVE field.
	I2C0_IC_CON_IC_10BITADDR_SLAVE_Msk = 0x8
	// Bit IC_10BITADDR_SLAVE.
	I2C0_IC_CON_IC_10BITADDR_SLAVE = 0x8
	// Slave 7Bit addressing
	I2C0_IC_CON_IC_10BITADDR_SLAVE_ADDR_7BITS = 0x0
	// Slave 10Bit addressing
	I2C0_IC_CON_IC_10BITADDR_SLAVE_ADDR_10BITS = 0x1
	// Position of SPEED field.
	I2C0_IC_CON_SPEED_Pos = 0x1
	// Bit mask of SPEED field.
	I2C0_IC_CON_SPEED_Msk = 0x6
	// Standard Speed mode of operation
	I2C0_IC_CON_SPEED_STANDARD = 0x1
	// Fast or Fast Plus mode of operation
	I2C0_IC_CON_SPEED_FAST = 0x2
	// High Speed mode of operation
	I2C0_IC_CON_SPEED_HIGH = 0x3
	// Position of MASTER_MODE field.
	I2C0_IC_CON_MASTER_MODE_Pos = 0x0
	// Bit mask of MASTER_MODE field.
	I2C0_IC_CON_MASTER_MODE_Msk = 0x1
	// Bit MASTER_MODE.
	I2C0_IC_CON_MASTER_MODE = 0x1
	// Master mode is disabled
	I2C0_IC_CON_MASTER_MODE_DISABLED = 0x0
	// Master mode is enabled
	I2C0_IC_CON_MASTER_MODE_ENABLED = 0x1

	// IC_TAR
	// I2C Target Address Register\n
	// This register is 12 bits wide, and bits 31:12 are reserved. This register can be written to only when IC_ENABLE[0] is set to 0.\n
	// Note: If the software or application is aware that the DW_apb_i2c is not using the TAR address for the pending commands in the Tx FIFO, then it is possible to update the TAR address even while the Tx FIFO has entries (IC_STATUS[2]= 0). - It is not necessary to perform any write to this register if DW_apb_i2c is enabled as an I2C slave only.
	// Position of SPECIAL field.
	I2C0_IC_TAR_SPECIAL_Pos = 0xb
	// Bit mask of SPECIAL field.
	I2C0_IC_TAR_SPECIAL_Msk = 0x800
	// Bit SPECIAL.
	I2C0_IC_TAR_SPECIAL = 0x800
	// Disables programming of GENERAL_CALL or START_BYTE transmission
	I2C0_IC_TAR_SPECIAL_DISABLED = 0x0
	// Enables programming of GENERAL_CALL or START_BYTE transmission
	I2C0_IC_TAR_SPECIAL_ENABLED = 0x1
	// Position of GC_OR_START field.
	I2C0_IC_TAR_GC_OR_START_Pos = 0xa
	// Bit mask of GC_OR_START field.
	I2C0_IC_TAR_GC_OR_START_Msk = 0x400
	// Bit GC_OR_START.
	I2C0_IC_TAR_GC_OR_START = 0x400
	// GENERAL_CALL byte transmission
	I2C0_IC_TAR_GC_OR_START_GENERAL_CALL = 0x0
	// START byte transmission
	I2C0_IC_TAR_GC_OR_START_START_BYTE = 0x1
	// Position of IC_TAR field.
	I2C0_IC_TAR_IC_TAR_Pos = 0x0
	// Bit mask of IC_TAR field.
	I2C0_IC_TAR_IC_TAR_Msk = 0x3ff

	// IC_SAR: I2C Slave Address Register
	// Position of IC_SAR field.
	I2C0_IC_SAR_IC_SAR_Pos = 0x0
	// Bit mask of IC_SAR field.
	I2C0_IC_SAR_IC_SAR_Msk = 0x3ff

	// IC_DATA_CMD
	// I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX FIFO.\n
	// The size of the register changes as follows:\n
	// Write: - 11 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read: - 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1 - 8 bits when IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order for the DW_apb_i2c to continue acknowledging reads, a read command should be written for every byte that is to be received; otherwise the DW_apb_i2c will stop acknowledging.
	// Position of FIRST_DATA_BYTE field.
	I2C0_IC_DATA_CMD_FIRST_DATA_BYTE_Pos = 0xb
	// Bit mask of FIRST_DATA_BYTE field.
	I2C0_IC_DATA_CMD_FIRST_DATA_BYTE_Msk = 0x800
	// Bit FIRST_DATA_BYTE.
	I2C0_IC_DATA_CMD_FIRST_DATA_BYTE = 0x800
	// Sequential data byte received
	I2C0_IC_DATA_CMD_FIRST_DATA_BYTE_INACTIVE = 0x0
	// Non sequential data byte received
	I2C0_IC_DATA_CMD_FIRST_DATA_BYTE_ACTIVE = 0x1
	// Position of RESTART field.
	I2C0_IC_DATA_CMD_RESTART_Pos = 0xa
	// Bit mask of RESTART field.
	I2C0_IC_DATA_CMD_RESTART_Msk = 0x400
	// Bit RESTART.
	I2C0_IC_DATA_CMD_RESTART = 0x400
	// Don't Issue RESTART before this command
	I2C0_IC_DATA_CMD_RESTART_DISABLE = 0x0
	// Issue RESTART before this command
	I2C0_IC_DATA_CMD_RESTART_ENABLE = 0x1
	// Position of STOP field.
	I2C0_IC_DATA_CMD_STOP_Pos = 0x9
	// Bit mask of STOP field.
	I2C0_IC_DATA_CMD_STOP_Msk = 0x200
	// Bit STOP.
	I2C0_IC_DATA_CMD_STOP = 0x200
	// Don't Issue STOP after this command
	I2C0_IC_DATA_CMD_STOP_DISABLE = 0x0
	// Issue STOP after this command
	I2C0_IC_DATA_CMD_STOP_ENABLE = 0x1
	// Position of CMD field.
	I2C0_IC_DATA_CMD_CMD_Pos = 0x8
	// Bit mask of CMD field.
	I2C0_IC_DATA_CMD_CMD_Msk = 0x100
	// Bit CMD.
	I2C0_IC_DATA_CMD_CMD = 0x100
	// Master Write Command
	I2C0_IC_DATA_CMD_CMD_WRITE = 0x0
	// Master Read Command
	I2C0_IC_DATA_CMD_CMD_READ = 0x1
	// Position of DAT field.
	I2C0_IC_DATA_CMD_DAT_Pos = 0x0
	// Bit mask of DAT field.
	I2C0_IC_DATA_CMD_DAT_Msk = 0xff

	// IC_SS_SCL_HCNT: Standard Speed I2C Clock SCL High Count Register
	// Position of IC_SS_SCL_HCNT field.
	I2C0_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT_Pos = 0x0
	// Bit mask of IC_SS_SCL_HCNT field.
	I2C0_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT_Msk = 0xffff

	// IC_SS_SCL_LCNT: Standard Speed I2C Clock SCL Low Count Register
	// Position of IC_SS_SCL_LCNT field.
	I2C0_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT_Pos = 0x0
	// Bit mask of IC_SS_SCL_LCNT field.
	I2C0_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT_Msk = 0xffff

	// IC_FS_SCL_HCNT: Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register
	// Position of IC_FS_SCL_HCNT field.
	I2C0_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT_Pos = 0x0
	// Bit mask of IC_FS_SCL_HCNT field.
	I2C0_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT_Msk = 0xffff

	// IC_FS_SCL_LCNT: Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register
	// Position of IC_FS_SCL_LCNT field.
	I2C0_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT_Pos = 0x0
	// Bit mask of IC_FS_SCL_LCNT field.
	I2C0_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT_Msk = 0xffff

	// IC_INTR_STAT
	// I2C Interrupt Status Register\n
	// Each bit in this register has a corresponding mask bit in the IC_INTR_MASK register. These bits are cleared by reading the matching interrupt clear register. The unmasked raw versions of these bits are available in the IC_RAW_INTR_STAT register.
	// Position of R_MASTER_ON_HOLD field.
	I2C0_IC_INTR_STAT_R_MASTER_ON_HOLD_Pos = 0xd
	// Bit mask of R_MASTER_ON_HOLD field.
	I2C0_IC_INTR_STAT_R_MASTER_ON_HOLD_Msk = 0x2000
	// Bit R_MASTER_ON_HOLD.
	I2C0_IC_INTR_STAT_R_MASTER_ON_HOLD = 0x2000
	// R_MASTER_ON_HOLD interrupt is inactive
	I2C0_IC_INTR_STAT_R_MASTER_ON_HOLD_INACTIVE = 0x0
	// R_MASTER_ON_HOLD interrupt is active
	I2C0_IC_INTR_STAT_R_MASTER_ON_HOLD_ACTIVE = 0x1
	// Position of R_RESTART_DET field.
	I2C0_IC_INTR_STAT_R_RESTART_DET_Pos = 0xc
	// Bit mask of R_RESTART_DET field.
	I2C0_IC_INTR_STAT_R_RESTART_DET_Msk = 0x1000
	// Bit R_RESTART_DET.
	I2C0_IC_INTR_STAT_R_RESTART_DET = 0x1000
	// R_RESTART_DET interrupt is inactive
	I2C0_IC_INTR_STAT_R_RESTART_DET_INACTIVE = 0x0
	// R_RESTART_DET interrupt is active
	I2C0_IC_INTR_STAT_R_RESTART_DET_ACTIVE = 0x1
	// Position of R_GEN_CALL field.
	I2C0_IC_INTR_STAT_R_GEN_CALL_Pos = 0xb
	// Bit mask of R_GEN_CALL field.
	I2C0_IC_INTR_STAT_R_GEN_CALL_Msk = 0x800
	// Bit R_GEN_CALL.
	I2C0_IC_INTR_STAT_R_GEN_CALL = 0x800
	// R_GEN_CALL interrupt is inactive
	I2C0_IC_INTR_STAT_R_GEN_CALL_INACTIVE = 0x0
	// R_GEN_CALL interrupt is active
	I2C0_IC_INTR_STAT_R_GEN_CALL_ACTIVE = 0x1
	// Position of R_START_DET field.
	I2C0_IC_INTR_STAT_R_START_DET_Pos = 0xa
	// Bit mask of R_START_DET field.
	I2C0_IC_INTR_STAT_R_START_DET_Msk = 0x400
	// Bit R_START_DET.
	I2C0_IC_INTR_STAT_R_START_DET = 0x400
	// R_START_DET interrupt is inactive
	I2C0_IC_INTR_STAT_R_START_DET_INACTIVE = 0x0
	// R_START_DET interrupt is active
	I2C0_IC_INTR_STAT_R_START_DET_ACTIVE = 0x1
	// Position of R_STOP_DET field.
	I2C0_IC_INTR_STAT_R_STOP_DET_Pos = 0x9
	// Bit mask of R_STOP_DET field.
	I2C0_IC_INTR_STAT_R_STOP_DET_Msk = 0x200
	// Bit R_STOP_DET.
	I2C0_IC_INTR_STAT_R_STOP_DET = 0x200
	// R_STOP_DET interrupt is inactive
	I2C0_IC_INTR_STAT_R_STOP_DET_INACTIVE = 0x0
	// R_STOP_DET interrupt is active
	I2C0_IC_INTR_STAT_R_STOP_DET_ACTIVE = 0x1
	// Position of R_ACTIVITY field.
	I2C0_IC_INTR_STAT_R_ACTIVITY_Pos = 0x8
	// Bit mask of R_ACTIVITY field.
	I2C0_IC_INTR_STAT_R_ACTIVITY_Msk = 0x100
	// Bit R_ACTIVITY.
	I2C0_IC_INTR_STAT_R_ACTIVITY = 0x100
	// R_ACTIVITY interrupt is inactive
	I2C0_IC_INTR_STAT_R_ACTIVITY_INACTIVE = 0x0
	// R_ACTIVITY interrupt is active
	I2C0_IC_INTR_STAT_R_ACTIVITY_ACTIVE = 0x1
	// Position of R_RX_DONE field.
	I2C0_IC_INTR_STAT_R_RX_DONE_Pos = 0x7
	// Bit mask of R_RX_DONE field.
	I2C0_IC_INTR_STAT_R_RX_DONE_Msk = 0x80
	// Bit R_RX_DONE.
	I2C0_IC_INTR_STAT_R_RX_DONE = 0x80
	// R_RX_DONE interrupt is inactive
	I2C0_IC_INTR_STAT_R_RX_DONE_INACTIVE = 0x0
	// R_RX_DONE interrupt is active
	I2C0_IC_INTR_STAT_R_RX_DONE_ACTIVE = 0x1
	// Position of R_TX_ABRT field.
	I2C0_IC_INTR_STAT_R_TX_ABRT_Pos = 0x6
	// Bit mask of R_TX_ABRT field.
	I2C0_IC_INTR_STAT_R_TX_ABRT_Msk = 0x40
	// Bit R_TX_ABRT.
	I2C0_IC_INTR_STAT_R_TX_ABRT = 0x40
	// R_TX_ABRT interrupt is inactive
	I2C0_IC_INTR_STAT_R_TX_ABRT_INACTIVE = 0x0
	// R_TX_ABRT interrupt is active
	I2C0_IC_INTR_STAT_R_TX_ABRT_ACTIVE = 0x1
	// Position of R_RD_REQ field.
	I2C0_IC_INTR_STAT_R_RD_REQ_Pos = 0x5
	// Bit mask of R_RD_REQ field.
	I2C0_IC_INTR_STAT_R_RD_REQ_Msk = 0x20
	// Bit R_RD_REQ.
	I2C0_IC_INTR_STAT_R_RD_REQ = 0x20
	// R_RD_REQ interrupt is inactive
	I2C0_IC_INTR_STAT_R_RD_REQ_INACTIVE = 0x0
	// R_RD_REQ interrupt is active
	I2C0_IC_INTR_STAT_R_RD_REQ_ACTIVE = 0x1
	// Position of R_TX_EMPTY field.
	I2C0_IC_INTR_STAT_R_TX_EMPTY_Pos = 0x4
	// Bit mask of R_TX_EMPTY field.
	I2C0_IC_INTR_STAT_R_TX_EMPTY_Msk = 0x10
	// Bit R_TX_EMPTY.
	I2C0_IC_INTR_STAT_R_TX_EMPTY = 0x10
	// R_TX_EMPTY interrupt is inactive
	I2C0_IC_INTR_STAT_R_TX_EMPTY_INACTIVE = 0x0
	// R_TX_EMPTY interrupt is active
	I2C0_IC_INTR_STAT_R_TX_EMPTY_ACTIVE = 0x1
	// Position of R_TX_OVER field.
	I2C0_IC_INTR_STAT_R_TX_OVER_Pos = 0x3
	// Bit mask of R_TX_OVER field.
	I2C0_IC_INTR_STAT_R_TX_OVER_Msk = 0x8
	// Bit R_TX_OVER.
	I2C0_IC_INTR_STAT_R_TX_OVER = 0x8
	// R_TX_OVER interrupt is inactive
	I2C0_IC_INTR_STAT_R_TX_OVER_INACTIVE = 0x0
	// R_TX_OVER interrupt is active
	I2C0_IC_INTR_STAT_R_TX_OVER_ACTIVE = 0x1
	// Position of R_RX_FULL field.
	I2C0_IC_INTR_STAT_R_RX_FULL_Pos = 0x2
	// Bit mask of R_RX_FULL field.
	I2C0_IC_INTR_STAT_R_RX_FULL_Msk = 0x4
	// Bit R_RX_FULL.
	I2C0_IC_INTR_STAT_R_RX_FULL = 0x4
	// R_RX_FULL interrupt is inactive
	I2C0_IC_INTR_STAT_R_RX_FULL_INACTIVE = 0x0
	// R_RX_FULL interrupt is active
	I2C0_IC_INTR_STAT_R_RX_FULL_ACTIVE = 0x1
	// Position of R_RX_OVER field.
	I2C0_IC_INTR_STAT_R_RX_OVER_Pos = 0x1
	// Bit mask of R_RX_OVER field.
	I2C0_IC_INTR_STAT_R_RX_OVER_Msk = 0x2
	// Bit R_RX_OVER.
	I2C0_IC_INTR_STAT_R_RX_OVER = 0x2
	// R_RX_OVER interrupt is inactive
	I2C0_IC_INTR_STAT_R_RX_OVER_INACTIVE = 0x0
	// R_RX_OVER interrupt is active
	I2C0_IC_INTR_STAT_R_RX_OVER_ACTIVE = 0x1
	// Position of R_RX_UNDER field.
	I2C0_IC_INTR_STAT_R_RX_UNDER_Pos = 0x0
	// Bit mask of R_RX_UNDER field.
	I2C0_IC_INTR_STAT_R_RX_UNDER_Msk = 0x1
	// Bit R_RX_UNDER.
	I2C0_IC_INTR_STAT_R_RX_UNDER = 0x1
	// RX_UNDER interrupt is inactive
	I2C0_IC_INTR_STAT_R_RX_UNDER_INACTIVE = 0x0
	// RX_UNDER interrupt is active
	I2C0_IC_INTR_STAT_R_RX_UNDER_ACTIVE = 0x1

	// IC_INTR_MASK
	// I2C Interrupt Mask Register.\n
	// These bits mask their corresponding interrupt status bits. This register is active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the interrupt.
	// Position of M_MASTER_ON_HOLD_READ_ONLY field.
	I2C0_IC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY_Pos = 0xd
	// Bit mask of M_MASTER_ON_HOLD_READ_ONLY field.
	I2C0_IC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY_Msk = 0x2000
	// Bit M_MASTER_ON_HOLD_READ_ONLY.
	I2C0_IC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY = 0x2000
	// MASTER_ON_HOLD interrupt is masked
	I2C0_IC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY_ENABLED = 0x0
	// MASTER_ON_HOLD interrupt is unmasked
	I2C0_IC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY_DISABLED = 0x1
	// Position of M_RESTART_DET field.
	I2C0_IC_INTR_MASK_M_RESTART_DET_Pos = 0xc
	// Bit mask of M_RESTART_DET field.
	I2C0_IC_INTR_MASK_M_RESTART_DET_Msk = 0x1000
	// Bit M_RESTART_DET.
	I2C0_IC_INTR_MASK_M_RESTART_DET = 0x1000
	// RESTART_DET interrupt is masked
	I2C0_IC_INTR_MASK_M_RESTART_DET_ENABLED = 0x0
	// RESTART_DET interrupt is unmasked
	I2C0_IC_INTR_MASK_M_RESTART_DET_DISABLED = 0x1
	// Position of M_GEN_CALL field.
	I2C0_IC_INTR_MASK_M_GEN_CALL_Pos = 0xb
	// Bit mask of M_GEN_CALL field.
	I2C0_IC_INTR_MASK_M_GEN_CALL_Msk = 0x800
	// Bit M_GEN_CALL.
	I2C0_IC_INTR_MASK_M_GEN_CALL = 0x800
	// GEN_CALL interrupt is masked
	I2C0_IC_INTR_MASK_M_GEN_CALL_ENABLED = 0x0
	// GEN_CALL interrupt is unmasked
	I2C0_IC_INTR_MASK_M_GEN_CALL_DISABLED = 0x1
	// Position of M_START_DET field.
	I2C0_IC_INTR_MASK_M_START_DET_Pos = 0xa
	// Bit mask of M_START_DET field.
	I2C0_IC_INTR_MASK_M_START_DET_Msk = 0x400
	// Bit M_START_DET.
	I2C0_IC_INTR_MASK_M_START_DET = 0x400
	// START_DET interrupt is masked
	I2C0_IC_INTR_MASK_M_START_DET_ENABLED = 0x0
	// START_DET interrupt is unmasked
	I2C0_IC_INTR_MASK_M_START_DET_DISABLED = 0x1
	// Position of M_STOP_DET field.
	I2C0_IC_INTR_MASK_M_STOP_DET_Pos = 0x9
	// Bit mask of M_STOP_DET field.
	I2C0_IC_INTR_MASK_M_STOP_DET_Msk = 0x200
	// Bit M_STOP_DET.
	I2C0_IC_INTR_MASK_M_STOP_DET = 0x200
	// STOP_DET interrupt is masked
	I2C0_IC_INTR_MASK_M_STOP_DET_ENABLED = 0x0
	// STOP_DET interrupt is unmasked
	I2C0_IC_INTR_MASK_M_STOP_DET_DISABLED = 0x1
	// Position of M_ACTIVITY field.
	I2C0_IC_INTR_MASK_M_ACTIVITY_Pos = 0x8
	// Bit mask of M_ACTIVITY field.
	I2C0_IC_INTR_MASK_M_ACTIVITY_Msk = 0x100
	// Bit M_ACTIVITY.
	I2C0_IC_INTR_MASK_M_ACTIVITY = 0x100
	// ACTIVITY interrupt is masked
	I2C0_IC_INTR_MASK_M_ACTIVITY_ENABLED = 0x0
	// ACTIVITY interrupt is unmasked
	I2C0_IC_INTR_MASK_M_ACTIVITY_DISABLED = 0x1
	// Position of M_RX_DONE field.
	I2C0_IC_INTR_MASK_M_RX_DONE_Pos = 0x7
	// Bit mask of M_RX_DONE field.
	I2C0_IC_INTR_MASK_M_RX_DONE_Msk = 0x80
	// Bit M_RX_DONE.
	I2C0_IC_INTR_MASK_M_RX_DONE = 0x80
	// RX_DONE interrupt is masked
	I2C0_IC_INTR_MASK_M_RX_DONE_ENABLED = 0x0
	// RX_DONE interrupt is unmasked
	I2C0_IC_INTR_MASK_M_RX_DONE_DISABLED = 0x1
	// Position of M_TX_ABRT field.
	I2C0_IC_INTR_MASK_M_TX_ABRT_Pos = 0x6
	// Bit mask of M_TX_ABRT field.
	I2C0_IC_INTR_MASK_M_TX_ABRT_Msk = 0x40
	// Bit M_TX_ABRT.
	I2C0_IC_INTR_MASK_M_TX_ABRT = 0x40
	// TX_ABORT interrupt is masked
	I2C0_IC_INTR_MASK_M_TX_ABRT_ENABLED = 0x0
	// TX_ABORT interrupt is unmasked
	I2C0_IC_INTR_MASK_M_TX_ABRT_DISABLED = 0x1
	// Position of M_RD_REQ field.
	I2C0_IC_INTR_MASK_M_RD_REQ_Pos = 0x5
	// Bit mask of M_RD_REQ field.
	I2C0_IC_INTR_MASK_M_RD_REQ_Msk = 0x20
	// Bit M_RD_REQ.
	I2C0_IC_INTR_MASK_M_RD_REQ = 0x20
	// RD_REQ interrupt is masked
	I2C0_IC_INTR_MASK_M_RD_REQ_ENABLED = 0x0
	// RD_REQ interrupt is unmasked
	I2C0_IC_INTR_MASK_M_RD_REQ_DISABLED = 0x1
	// Position of M_TX_EMPTY field.
	I2C0_IC_INTR_MASK_M_TX_EMPTY_Pos = 0x4
	// Bit mask of M_TX_EMPTY field.
	I2C0_IC_INTR_MASK_M_TX_EMPTY_Msk = 0x10
	// Bit M_TX_EMPTY.
	I2C0_IC_INTR_MASK_M_TX_EMPTY = 0x10
	// TX_EMPTY interrupt is masked
	I2C0_IC_INTR_MASK_M_TX_EMPTY_ENABLED = 0x0
	// TX_EMPTY interrupt is unmasked
	I2C0_IC_INTR_MASK_M_TX_EMPTY_DISABLED = 0x1
	// Position of M_TX_OVER field.
	I2C0_IC_INTR_MASK_M_TX_OVER_Pos = 0x3
	// Bit mask of M_TX_OVER field.
	I2C0_IC_INTR_MASK_M_TX_OVER_Msk = 0x8
	// Bit M_TX_OVER.
	I2C0_IC_INTR_MASK_M_TX_OVER = 0x8
	// TX_OVER interrupt is masked
	I2C0_IC_INTR_MASK_M_TX_OVER_ENABLED = 0x0
	// TX_OVER interrupt is unmasked
	I2C0_IC_INTR_MASK_M_TX_OVER_DISABLED = 0x1
	// Position of M_RX_FULL field.
	I2C0_IC_INTR_MASK_M_RX_FULL_Pos = 0x2
	// Bit mask of M_RX_FULL field.
	I2C0_IC_INTR_MASK_M_RX_FULL_Msk = 0x4
	// Bit M_RX_FULL.
	I2C0_IC_INTR_MASK_M_RX_FULL = 0x4
	// RX_FULL interrupt is masked
	I2C0_IC_INTR_MASK_M_RX_FULL_ENABLED = 0x0
	// RX_FULL interrupt is unmasked
	I2C0_IC_INTR_MASK_M_RX_FULL_DISABLED = 0x1
	// Position of M_RX_OVER field.
	I2C0_IC_INTR_MASK_M_RX_OVER_Pos = 0x1
	// Bit mask of M_RX_OVER field.
	I2C0_IC_INTR_MASK_M_RX_OVER_Msk = 0x2
	// Bit M_RX_OVER.
	I2C0_IC_INTR_MASK_M_RX_OVER = 0x2
	// RX_OVER interrupt is masked
	I2C0_IC_INTR_MASK_M_RX_OVER_ENABLED = 0x0
	// RX_OVER interrupt is unmasked
	I2C0_IC_INTR_MASK_M_RX_OVER_DISABLED = 0x1
	// Position of M_RX_UNDER field.
	I2C0_IC_INTR_MASK_M_RX_UNDER_Pos = 0x0
	// Bit mask of M_RX_UNDER field.
	I2C0_IC_INTR_MASK_M_RX_UNDER_Msk = 0x1
	// Bit M_RX_UNDER.
	I2C0_IC_INTR_MASK_M_RX_UNDER = 0x1
	// RX_UNDER interrupt is masked
	I2C0_IC_INTR_MASK_M_RX_UNDER_ENABLED = 0x0
	// RX_UNDER interrupt is unmasked
	I2C0_IC_INTR_MASK_M_RX_UNDER_DISABLED = 0x1

	// IC_RAW_INTR_STAT
	// I2C Raw Interrupt Status Register\n
	// Unlike the IC_INTR_STAT register, these bits are not masked so they always show the true status of the DW_apb_i2c.
	// Position of MASTER_ON_HOLD field.
	I2C0_IC_RAW_INTR_STAT_MASTER_ON_HOLD_Pos = 0xd
	// Bit mask of MASTER_ON_HOLD field.
	I2C0_IC_RAW_INTR_STAT_MASTER_ON_HOLD_Msk = 0x2000
	// Bit MASTER_ON_HOLD.
	I2C0_IC_RAW_INTR_STAT_MASTER_ON_HOLD = 0x2000
	// MASTER_ON_HOLD interrupt is inactive
	I2C0_IC_RAW_INTR_STAT_MASTER_ON_HOLD_INACTIVE = 0x0
	// MASTER_ON_HOLD interrupt is active
	I2C0_IC_RAW_INTR_STAT_MASTER_ON_HOLD_ACTIVE = 0x1
	// Position of RESTART_DET field.
	I2C0_IC_RAW_INTR_STAT_RESTART_DET_Pos = 0xc
	// Bit mask of RESTART_DET field.
	I2C0_IC_RAW_INTR_STAT_RESTART_DET_Msk = 0x1000
	// Bit RESTART_DET.
	I2C0_IC_RAW_INTR_STAT_RESTART_DET = 0x1000
	// RESTART_DET interrupt is inactive
	I2C0_IC_RAW_INTR_STAT_RESTART_DET_INACTIVE = 0x0
	// RESTART_DET interrupt is active
	I2C0_IC_RAW_INTR_STAT_RESTART_DET_ACTIVE = 0x1
	// Position of GEN_CALL field.
	I2C0_IC_RAW_INTR_STAT_GEN_CALL_Pos = 0xb
	// Bit mask of GEN_CALL field.
	I2C0_IC_RAW_INTR_STAT_GEN_CALL_Msk = 0x800
	// Bit GEN_CALL.
	I2C0_IC_RAW_INTR_STAT_GEN_CALL = 0x800
	// GEN_CALL interrupt is inactive
	I2C0_IC_RAW_INTR_STAT_GEN_CALL_INACTIVE = 0x0
	// GEN_CALL interrupt is active
	I2C0_IC_RAW_INTR_STAT_GEN_CALL_ACTIVE = 0x1
	// Position of START_DET field.
	I2C0_IC_RAW_INTR_STAT_START_DET_Pos = 0xa
	// Bit mask of START_DET field.
	I2C0_IC_RAW_INTR_STAT_START_DET_Msk = 0x400
	// Bit START_DET.
	I2C0_IC_RAW_INTR_STAT_START_DET = 0x400
	// START_DET interrupt is inactive
	I2C0_IC_RAW_INTR_STAT_START_DET_INACTIVE = 0x0
	// START_DET interrupt is active
	I2C0_IC_RAW_INTR_STAT_START_DET_ACTIVE = 0x1
	// Position of STOP_DET field.
	I2C0_IC_RAW_INTR_STAT_STOP_DET_Pos = 0x9
	// Bit mask of STOP_DET field.
	I2C0_IC_RAW_INTR_STAT_STOP_DET_Msk = 0x200
	// Bit STOP_DET.
	I2C0_IC_RAW_INTR_STAT_STOP_DET = 0x200
	// STOP_DET interrupt is inactive
	I2C0_IC_RAW_INTR_STAT_STOP_DET_INACTIVE = 0x0
	// STOP_DET interrupt is active
	I2C0_IC_RAW_INTR_STAT_STOP_DET_ACTIVE = 0x1
	// Position of ACTIVITY field.
	I2C0_IC_RAW_INTR_STAT_ACTIVITY_Pos = 0x8
	// Bit mask of ACTIVITY field.
	I2C0_IC_RAW_INTR_STAT_ACTIVITY_Msk = 0x100
	// Bit ACTIVITY.
	I2C0_IC_RAW_INTR_STAT_ACTIVITY = 0x100
	// RAW_INTR_ACTIVITY interrupt is inactive
	I2C0_IC_RAW_INTR_STAT_ACTIVITY_INACTIVE = 0x0
	// RAW_INTR_ACTIVITY interrupt is active
	I2C0_IC_RAW_INTR_STAT_ACTIVITY_ACTIVE = 0x1
	// Position of RX_DONE field.
	I2C0_IC_RAW_INTR_STAT_RX_DONE_Pos = 0x7
	// Bit mask of RX_DONE field.
	I2C0_IC_RAW_INTR_STAT_RX_DONE_Msk = 0x80
	// Bit RX_DONE.
	I2C0_IC_RAW_INTR_STAT_RX_DONE = 0x80
	// RX_DONE interrupt is inactive
	I2C0_IC_RAW_INTR_STAT_RX_DONE_INACTIVE = 0x0
	// RX_DONE interrupt is active
	I2C0_IC_RAW_INTR_STAT_RX_DONE_ACTIVE = 0x1
	// Position of TX_ABRT field.
	I2C0_IC_RAW_INTR_STAT_TX_ABRT_Pos = 0x6
	// Bit mask of TX_ABRT field.
	I2C0_IC_RAW_INTR_STAT_TX_ABRT_Msk = 0x40
	// Bit TX_ABRT.
	I2C0_IC_RAW_INTR_STAT_TX_ABRT = 0x40
	// TX_ABRT interrupt is inactive
	I2C0_IC_RAW_INTR_STAT_TX_ABRT_INACTIVE = 0x0
	// TX_ABRT interrupt is active
	I2C0_IC_RAW_INTR_STAT_TX_ABRT_ACTIVE = 0x1
	// Position of RD_REQ field.
	I2C0_IC_RAW_INTR_STAT_RD_REQ_Pos = 0x5
	// Bit mask of RD_REQ field.
	I2C0_IC_RAW_INTR_STAT_RD_REQ_Msk = 0x20
	// Bit RD_REQ.
	I2C0_IC_RAW_INTR_STAT_RD_REQ = 0x20
	// RD_REQ interrupt is inactive
	I2C0_IC_RAW_INTR_STAT_RD_REQ_INACTIVE = 0x0
	// RD_REQ interrupt is active
	I2C0_IC_RAW_INTR_STAT_RD_REQ_ACTIVE = 0x1
	// Position of TX_EMPTY field.
	I2C0_IC_RAW_INTR_STAT_TX_EMPTY_Pos = 0x4
	// Bit mask of TX_EMPTY field.
	I2C0_IC_RAW_INTR_STAT_TX_EMPTY_Msk = 0x10
	// Bit TX_EMPTY.
	I2C0_IC_RAW_INTR_STAT_TX_EMPTY = 0x10
	// TX_EMPTY interrupt is inactive
	I2C0_IC_RAW_INTR_STAT_TX_EMPTY_INACTIVE = 0x0
	// TX_EMPTY interrupt is active
	I2C0_IC_RAW_INTR_STAT_TX_EMPTY_ACTIVE = 0x1
	// Position of TX_OVER field.
	I2C0_IC_RAW_INTR_STAT_TX_OVER_Pos = 0x3
	// Bit mask of TX_OVER field.
	I2C0_IC_RAW_INTR_STAT_TX_OVER_Msk = 0x8
	// Bit TX_OVER.
	I2C0_IC_RAW_INTR_STAT_TX_OVER = 0x8
	// TX_OVER interrupt is inactive
	I2C0_IC_RAW_INTR_STAT_TX_OVER_INACTIVE = 0x0
	// TX_OVER interrupt is active
	I2C0_IC_RAW_INTR_STAT_TX_OVER_ACTIVE = 0x1
	// Position of RX_FULL field.
	I2C0_IC_RAW_INTR_STAT_RX_FULL_Pos = 0x2
	// Bit mask of RX_FULL field.
	I2C0_IC_RAW_INTR_STAT_RX_FULL_Msk = 0x4
	// Bit RX_FULL.
	I2C0_IC_RAW_INTR_STAT_RX_FULL = 0x4
	// RX_FULL interrupt is inactive
	I2C0_IC_RAW_INTR_STAT_RX_FULL_INACTIVE = 0x0
	// RX_FULL interrupt is active
	I2C0_IC_RAW_INTR_STAT_RX_FULL_ACTIVE = 0x1
	// Position of RX_OVER field.
	I2C0_IC_RAW_INTR_STAT_RX_OVER_Pos = 0x1
	// Bit mask of RX_OVER field.
	I2C0_IC_RAW_INTR_STAT_RX_OVER_Msk = 0x2
	// Bit RX_OVER.
	I2C0_IC_RAW_INTR_STAT_RX_OVER = 0x2
	// RX_OVER interrupt is inactive
	I2C0_IC_RAW_INTR_STAT_RX_OVER_INACTIVE = 0x0
	// RX_OVER interrupt is active
	I2C0_IC_RAW_INTR_STAT_RX_OVER_ACTIVE = 0x1
	// Position of RX_UNDER field.
	I2C0_IC_RAW_INTR_STAT_RX_UNDER_Pos = 0x0
	// Bit mask of RX_UNDER field.
	I2C0_IC_RAW_INTR_STAT_RX_UNDER_Msk = 0x1
	// Bit RX_UNDER.
	I2C0_IC_RAW_INTR_STAT_RX_UNDER = 0x1
	// RX_UNDER interrupt is inactive
	I2C0_IC_RAW_INTR_STAT_RX_UNDER_INACTIVE = 0x0
	// RX_UNDER interrupt is active
	I2C0_IC_RAW_INTR_STAT_RX_UNDER_ACTIVE = 0x1

	// IC_RX_TL: I2C Receive FIFO Threshold Register
	// Position of RX_TL field.
	I2C0_IC_RX_TL_RX_TL_Pos = 0x0
	// Bit mask of RX_TL field.
	I2C0_IC_RX_TL_RX_TL_Msk = 0xff

	// IC_TX_TL: I2C Transmit FIFO Threshold Register
	// Position of TX_TL field.
	I2C0_IC_TX_TL_TX_TL_Pos = 0x0
	// Bit mask of TX_TL field.
	I2C0_IC_TX_TL_TX_TL_Msk = 0xff

	// IC_CLR_INTR: Clear Combined and Individual Interrupt Register
	// Position of CLR_INTR field.
	I2C0_IC_CLR_INTR_CLR_INTR_Pos = 0x0
	// Bit mask of CLR_INTR field.
	I2C0_IC_CLR_INTR_CLR_INTR_Msk = 0x1
	// Bit CLR_INTR.
	I2C0_IC_CLR_INTR_CLR_INTR = 0x1

	// IC_CLR_RX_UNDER: Clear RX_UNDER Interrupt Register
	// Position of CLR_RX_UNDER field.
	I2C0_IC_CLR_RX_UNDER_CLR_RX_UNDER_Pos = 0x0
	// Bit mask of CLR_RX_UNDER field.
	I2C0_IC_CLR_RX_UNDER_CLR_RX_UNDER_Msk = 0x1
	// Bit CLR_RX_UNDER.
	I2C0_IC_CLR_RX_UNDER_CLR_RX_UNDER = 0x1

	// IC_CLR_RX_OVER: Clear RX_OVER Interrupt Register
	// Position of CLR_RX_OVER field.
	I2C0_IC_CLR_RX_OVER_CLR_RX_OVER_Pos = 0x0
	// Bit mask of CLR_RX_OVER field.
	I2C0_IC_CLR_RX_OVER_CLR_RX_OVER_Msk = 0x1
	// Bit CLR_RX_OVER.
	I2C0_IC_CLR_RX_OVER_CLR_RX_OVER = 0x1

	// IC_CLR_TX_OVER: Clear TX_OVER Interrupt Register
	// Position of CLR_TX_OVER field.
	I2C0_IC_CLR_TX_OVER_CLR_TX_OVER_Pos = 0x0
	// Bit mask of CLR_TX_OVER field.
	I2C0_IC_CLR_TX_OVER_CLR_TX_OVER_Msk = 0x1
	// Bit CLR_TX_OVER.
	I2C0_IC_CLR_TX_OVER_CLR_TX_OVER = 0x1

	// IC_CLR_RD_REQ: Clear RD_REQ Interrupt Register
	// Position of CLR_RD_REQ field.
	I2C0_IC_CLR_RD_REQ_CLR_RD_REQ_Pos = 0x0
	// Bit mask of CLR_RD_REQ field.
	I2C0_IC_CLR_RD_REQ_CLR_RD_REQ_Msk = 0x1
	// Bit CLR_RD_REQ.
	I2C0_IC_CLR_RD_REQ_CLR_RD_REQ = 0x1

	// IC_CLR_TX_ABRT: Clear TX_ABRT Interrupt Register
	// Position of CLR_TX_ABRT field.
	I2C0_IC_CLR_TX_ABRT_CLR_TX_ABRT_Pos = 0x0
	// Bit mask of CLR_TX_ABRT field.
	I2C0_IC_CLR_TX_ABRT_CLR_TX_ABRT_Msk = 0x1
	// Bit CLR_TX_ABRT.
	I2C0_IC_CLR_TX_ABRT_CLR_TX_ABRT = 0x1

	// IC_CLR_RX_DONE: Clear RX_DONE Interrupt Register
	// Position of CLR_RX_DONE field.
	I2C0_IC_CLR_RX_DONE_CLR_RX_DONE_Pos = 0x0
	// Bit mask of CLR_RX_DONE field.
	I2C0_IC_CLR_RX_DONE_CLR_RX_DONE_Msk = 0x1
	// Bit CLR_RX_DONE.
	I2C0_IC_CLR_RX_DONE_CLR_RX_DONE = 0x1

	// IC_CLR_ACTIVITY: Clear ACTIVITY Interrupt Register
	// Position of CLR_ACTIVITY field.
	I2C0_IC_CLR_ACTIVITY_CLR_ACTIVITY_Pos = 0x0
	// Bit mask of CLR_ACTIVITY field.
	I2C0_IC_CLR_ACTIVITY_CLR_ACTIVITY_Msk = 0x1
	// Bit CLR_ACTIVITY.
	I2C0_IC_CLR_ACTIVITY_CLR_ACTIVITY = 0x1

	// IC_CLR_STOP_DET: Clear STOP_DET Interrupt Register
	// Position of CLR_STOP_DET field.
	I2C0_IC_CLR_STOP_DET_CLR_STOP_DET_Pos = 0x0
	// Bit mask of CLR_STOP_DET field.
	I2C0_IC_CLR_STOP_DET_CLR_STOP_DET_Msk = 0x1
	// Bit CLR_STOP_DET.
	I2C0_IC_CLR_STOP_DET_CLR_STOP_DET = 0x1

	// IC_CLR_START_DET: Clear START_DET Interrupt Register
	// Position of CLR_START_DET field.
	I2C0_IC_CLR_START_DET_CLR_START_DET_Pos = 0x0
	// Bit mask of CLR_START_DET field.
	I2C0_IC_CLR_START_DET_CLR_START_DET_Msk = 0x1
	// Bit CLR_START_DET.
	I2C0_IC_CLR_START_DET_CLR_START_DET = 0x1

	// IC_CLR_GEN_CALL: Clear GEN_CALL Interrupt Register
	// Position of CLR_GEN_CALL field.
	I2C0_IC_CLR_GEN_CALL_CLR_GEN_CALL_Pos = 0x0
	// Bit mask of CLR_GEN_CALL field.
	I2C0_IC_CLR_GEN_CALL_CLR_GEN_CALL_Msk = 0x1
	// Bit CLR_GEN_CALL.
	I2C0_IC_CLR_GEN_CALL_CLR_GEN_CALL = 0x1

	// IC_ENABLE: I2C Enable Register
	// Position of TX_CMD_BLOCK field.
	I2C0_IC_ENABLE_TX_CMD_BLOCK_Pos = 0x2
	// Bit mask of TX_CMD_BLOCK field.
	I2C0_IC_ENABLE_TX_CMD_BLOCK_Msk = 0x4
	// Bit TX_CMD_BLOCK.
	I2C0_IC_ENABLE_TX_CMD_BLOCK = 0x4
	// Tx Command execution not blocked
	I2C0_IC_ENABLE_TX_CMD_BLOCK_NOT_BLOCKED = 0x0
	// Tx Command execution blocked
	I2C0_IC_ENABLE_TX_CMD_BLOCK_BLOCKED = 0x1
	// Position of ABORT field.
	I2C0_IC_ENABLE_ABORT_Pos = 0x1
	// Bit mask of ABORT field.
	I2C0_IC_ENABLE_ABORT_Msk = 0x2
	// Bit ABORT.
	I2C0_IC_ENABLE_ABORT = 0x2
	// ABORT operation not in progress
	I2C0_IC_ENABLE_ABORT_DISABLE = 0x0
	// ABORT operation in progress
	I2C0_IC_ENABLE_ABORT_ENABLED = 0x1
	// Position of ENABLE field.
	I2C0_IC_ENABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	I2C0_IC_ENABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	I2C0_IC_ENABLE_ENABLE = 0x1
	// I2C is disabled
	I2C0_IC_ENABLE_ENABLE_DISABLED = 0x0
	// I2C is enabled
	I2C0_IC_ENABLE_ENABLE_ENABLED = 0x1

	// IC_STATUS
	// I2C Status Register\n
	// This is a read-only register used to indicate the current transfer status and FIFO status. The status register may be read at any time. None of the bits in this register request an interrupt.\n
	// When the I2C is disabled by writing 0 in bit 0 of the IC_ENABLE register: - Bits 1 and 2 are set to 1 - Bits 3 and 10 are set to 0 When the master or slave state machines goes to idle and ic_en=0: - Bits 5 and 6 are set to 0
	// Position of SLV_ACTIVITY field.
	I2C0_IC_STATUS_SLV_ACTIVITY_Pos = 0x6
	// Bit mask of SLV_ACTIVITY field.
	I2C0_IC_STATUS_SLV_ACTIVITY_Msk = 0x40
	// Bit SLV_ACTIVITY.
	I2C0_IC_STATUS_SLV_ACTIVITY = 0x40
	// Slave is idle
	I2C0_IC_STATUS_SLV_ACTIVITY_IDLE = 0x0
	// Slave not idle
	I2C0_IC_STATUS_SLV_ACTIVITY_ACTIVE = 0x1
	// Position of MST_ACTIVITY field.
	I2C0_IC_STATUS_MST_ACTIVITY_Pos = 0x5
	// Bit mask of MST_ACTIVITY field.
	I2C0_IC_STATUS_MST_ACTIVITY_Msk = 0x20
	// Bit MST_ACTIVITY.
	I2C0_IC_STATUS_MST_ACTIVITY = 0x20
	// Master is idle
	I2C0_IC_STATUS_MST_ACTIVITY_IDLE = 0x0
	// Master not idle
	I2C0_IC_STATUS_MST_ACTIVITY_ACTIVE = 0x1
	// Position of RFF field.
	I2C0_IC_STATUS_RFF_Pos = 0x4
	// Bit mask of RFF field.
	I2C0_IC_STATUS_RFF_Msk = 0x10
	// Bit RFF.
	I2C0_IC_STATUS_RFF = 0x10
	// Rx FIFO not full
	I2C0_IC_STATUS_RFF_NOT_FULL = 0x0
	// Rx FIFO is full
	I2C0_IC_STATUS_RFF_FULL = 0x1
	// Position of RFNE field.
	I2C0_IC_STATUS_RFNE_Pos = 0x3
	// Bit mask of RFNE field.
	I2C0_IC_STATUS_RFNE_Msk = 0x8
	// Bit RFNE.
	I2C0_IC_STATUS_RFNE = 0x8
	// Rx FIFO is empty
	I2C0_IC_STATUS_RFNE_EMPTY = 0x0
	// Rx FIFO not empty
	I2C0_IC_STATUS_RFNE_NOT_EMPTY = 0x1
	// Position of TFE field.
	I2C0_IC_STATUS_TFE_Pos = 0x2
	// Bit mask of TFE field.
	I2C0_IC_STATUS_TFE_Msk = 0x4
	// Bit TFE.
	I2C0_IC_STATUS_TFE = 0x4
	// Tx FIFO not empty
	I2C0_IC_STATUS_TFE_NON_EMPTY = 0x0
	// Tx FIFO is empty
	I2C0_IC_STATUS_TFE_EMPTY = 0x1
	// Position of TFNF field.
	I2C0_IC_STATUS_TFNF_Pos = 0x1
	// Bit mask of TFNF field.
	I2C0_IC_STATUS_TFNF_Msk = 0x2
	// Bit TFNF.
	I2C0_IC_STATUS_TFNF = 0x2
	// Tx FIFO is full
	I2C0_IC_STATUS_TFNF_FULL = 0x0
	// Tx FIFO not full
	I2C0_IC_STATUS_TFNF_NOT_FULL = 0x1
	// Position of ACTIVITY field.
	I2C0_IC_STATUS_ACTIVITY_Pos = 0x0
	// Bit mask of ACTIVITY field.
	I2C0_IC_STATUS_ACTIVITY_Msk = 0x1
	// Bit ACTIVITY.
	I2C0_IC_STATUS_ACTIVITY = 0x1
	// I2C is idle
	I2C0_IC_STATUS_ACTIVITY_INACTIVE = 0x0
	// I2C is active
	I2C0_IC_STATUS_ACTIVITY_ACTIVE = 0x1

	// IC_TXFLR: I2C Transmit FIFO Level Register This register contains the number of valid data entries in the transmit FIFO buffer. It is cleared whenever: - The I2C is disabled - There is a transmit abort - that is, TX_ABRT bit is set in the IC_RAW_INTR_STAT register - The slave bulk transmit mode is aborted The register increments whenever data is placed into the transmit FIFO and decrements when data is taken from the transmit FIFO.
	// Position of TXFLR field.
	I2C0_IC_TXFLR_TXFLR_Pos = 0x0
	// Bit mask of TXFLR field.
	I2C0_IC_TXFLR_TXFLR_Msk = 0x1f

	// IC_RXFLR: I2C Receive FIFO Level Register This register contains the number of valid data entries in the receive FIFO buffer. It is cleared whenever: - The I2C is disabled - Whenever there is a transmit abort caused by any of the events tracked in IC_TX_ABRT_SOURCE The register increments whenever data is placed into the receive FIFO and decrements when data is taken from the receive FIFO.
	// Position of RXFLR field.
	I2C0_IC_RXFLR_RXFLR_Pos = 0x0
	// Bit mask of RXFLR field.
	I2C0_IC_RXFLR_RXFLR_Msk = 0x1f

	// IC_SDA_HOLD
	// I2C SDA Hold Time Length Register\n
	// The bits [15:0] of this register are used to control the hold time of SDA during transmit in both slave and master mode (after SCL goes from HIGH to LOW).\n
	// The bits [23:16] of this register are used to extend the SDA transition (if any) whenever SCL is HIGH in the receiver in either master or slave mode.\n
	// Writes to this register succeed only when IC_ENABLE[0]=0.\n
	// The values in this register are in units of ic_clk period. The value programmed in IC_SDA_TX_HOLD must be greater than the minimum hold time in each mode one cycle in master mode, seven cycles in slave mode for the value to be implemented.\n
	// The programmed SDA hold time during transmit (IC_SDA_TX_HOLD) cannot exceed at any time the duration of the low part of scl. Therefore the programmed value cannot be larger than N_SCL_LOW-2, where N_SCL_LOW is the duration of the low part of the scl period measured in ic_clk cycles.
	// Position of IC_SDA_RX_HOLD field.
	I2C0_IC_SDA_HOLD_IC_SDA_RX_HOLD_Pos = 0x10
	// Bit mask of IC_SDA_RX_HOLD field.
	I2C0_IC_SDA_HOLD_IC_SDA_RX_HOLD_Msk = 0xff0000
	// Position of IC_SDA_TX_HOLD field.
	I2C0_IC_SDA_HOLD_IC_SDA_TX_HOLD_Pos = 0x0
	// Bit mask of IC_SDA_TX_HOLD field.
	I2C0_IC_SDA_HOLD_IC_SDA_TX_HOLD_Msk = 0xffff

	// IC_TX_ABRT_SOURCE
	// I2C Transmit Abort Source Register\n
	// This register has 32 bits that indicate the source of the TX_ABRT bit. Except for Bit 9, this register is cleared whenever the IC_CLR_TX_ABRT register or the IC_CLR_INTR register is read. To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; RESTART must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]).\n
	// Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, Bit 9 clears for one cycle and is then re-asserted.
	// Position of TX_FLUSH_CNT field.
	I2C0_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT_Pos = 0x17
	// Bit mask of TX_FLUSH_CNT field.
	I2C0_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT_Msk = 0xff800000
	// Position of ABRT_USER_ABRT field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_Pos = 0x10
	// Bit mask of ABRT_USER_ABRT field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_Msk = 0x10000
	// Bit ABRT_USER_ABRT.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT = 0x10000
	// Transfer abort detected by master- scenario not present
	I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_ABRT_USER_ABRT_VOID = 0x0
	// Transfer abort detected by master
	I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_ABRT_USER_ABRT_GENERATED = 0x1
	// Position of ABRT_SLVRD_INTX field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_Pos = 0xf
	// Bit mask of ABRT_SLVRD_INTX field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_Msk = 0x8000
	// Bit ABRT_SLVRD_INTX.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX = 0x8000
	// Slave trying to transmit to remote master in read mode- scenario not present
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_ABRT_SLVRD_INTX_VOID = 0x0
	// Slave trying to transmit to remote master in read mode
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_ABRT_SLVRD_INTX_GENERATED = 0x1
	// Position of ABRT_SLV_ARBLOST field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_Pos = 0xe
	// Bit mask of ABRT_SLV_ARBLOST field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_Msk = 0x4000
	// Bit ABRT_SLV_ARBLOST.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST = 0x4000
	// Slave lost arbitration to remote master- scenario not present
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_ABRT_SLV_ARBLOST_VOID = 0x0
	// Slave lost arbitration to remote master
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_ABRT_SLV_ARBLOST_GENERATED = 0x1
	// Position of ABRT_SLVFLUSH_TXFIFO field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_Pos = 0xd
	// Bit mask of ABRT_SLVFLUSH_TXFIFO field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_Msk = 0x2000
	// Bit ABRT_SLVFLUSH_TXFIFO.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO = 0x2000
	// Slave flushes existing data in TX-FIFO upon getting read command- scenario not present
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_ABRT_SLVFLUSH_TXFIFO_VOID = 0x0
	// Slave flushes existing data in TX-FIFO upon getting read command
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_ABRT_SLVFLUSH_TXFIFO_GENERATED = 0x1
	// Position of ARB_LOST field.
	I2C0_IC_TX_ABRT_SOURCE_ARB_LOST_Pos = 0xc
	// Bit mask of ARB_LOST field.
	I2C0_IC_TX_ABRT_SOURCE_ARB_LOST_Msk = 0x1000
	// Bit ARB_LOST.
	I2C0_IC_TX_ABRT_SOURCE_ARB_LOST = 0x1000
	// Master or Slave-Transmitter lost arbitration- scenario not present
	I2C0_IC_TX_ABRT_SOURCE_ARB_LOST_ABRT_LOST_VOID = 0x0
	// Master or Slave-Transmitter lost arbitration
	I2C0_IC_TX_ABRT_SOURCE_ARB_LOST_ABRT_LOST_GENERATED = 0x1
	// Position of ABRT_MASTER_DIS field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_Pos = 0xb
	// Bit mask of ABRT_MASTER_DIS field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_Msk = 0x800
	// Bit ABRT_MASTER_DIS.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS = 0x800
	// User initiating master operation when MASTER disabled- scenario not present
	I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_ABRT_MASTER_DIS_VOID = 0x0
	// User initiating master operation when MASTER disabled
	I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_ABRT_MASTER_DIS_GENERATED = 0x1
	// Position of ABRT_10B_RD_NORSTRT field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_Pos = 0xa
	// Bit mask of ABRT_10B_RD_NORSTRT field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_Msk = 0x400
	// Bit ABRT_10B_RD_NORSTRT.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT = 0x400
	// Master not trying to read in 10Bit addressing mode when RESTART disabled
	I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_ABRT_10B_RD_VOID = 0x0
	// Master trying to read in 10Bit addressing mode when RESTART disabled
	I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_ABRT_10B_RD_GENERATED = 0x1
	// Position of ABRT_SBYTE_NORSTRT field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_Pos = 0x9
	// Bit mask of ABRT_SBYTE_NORSTRT field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_Msk = 0x200
	// Bit ABRT_SBYTE_NORSTRT.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT = 0x200
	// User trying to send START byte when RESTART disabled- scenario not present
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_ABRT_SBYTE_NORSTRT_VOID = 0x0
	// User trying to send START byte when RESTART disabled
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_ABRT_SBYTE_NORSTRT_GENERATED = 0x1
	// Position of ABRT_HS_NORSTRT field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_Pos = 0x8
	// Bit mask of ABRT_HS_NORSTRT field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_Msk = 0x100
	// Bit ABRT_HS_NORSTRT.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT = 0x100
	// User trying to switch Master to HS mode when RESTART disabled- scenario not present
	I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_ABRT_HS_NORSTRT_VOID = 0x0
	// User trying to switch Master to HS mode when RESTART disabled
	I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_ABRT_HS_NORSTRT_GENERATED = 0x1
	// Position of ABRT_SBYTE_ACKDET field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_Pos = 0x7
	// Bit mask of ABRT_SBYTE_ACKDET field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_Msk = 0x80
	// Bit ABRT_SBYTE_ACKDET.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET = 0x80
	// ACK detected for START byte- scenario not present
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_ABRT_SBYTE_ACKDET_VOID = 0x0
	// ACK detected for START byte
	I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_ABRT_SBYTE_ACKDET_GENERATED = 0x1
	// Position of ABRT_HS_ACKDET field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_Pos = 0x6
	// Bit mask of ABRT_HS_ACKDET field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_Msk = 0x40
	// Bit ABRT_HS_ACKDET.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET = 0x40
	// HS Master code ACKed in HS Mode- scenario not present
	I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_ABRT_HS_ACK_VOID = 0x0
	// HS Master code ACKed in HS Mode
	I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_ABRT_HS_ACK_GENERATED = 0x1
	// Position of ABRT_GCALL_READ field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_Pos = 0x5
	// Bit mask of ABRT_GCALL_READ field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_Msk = 0x20
	// Bit ABRT_GCALL_READ.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ = 0x20
	// GCALL is followed by read from bus-scenario not present
	I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_ABRT_GCALL_READ_VOID = 0x0
	// GCALL is followed by read from bus
	I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_ABRT_GCALL_READ_GENERATED = 0x1
	// Position of ABRT_GCALL_NOACK field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_Pos = 0x4
	// Bit mask of ABRT_GCALL_NOACK field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_Msk = 0x10
	// Bit ABRT_GCALL_NOACK.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK = 0x10
	// GCALL not ACKed by any slave-scenario not present
	I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_ABRT_GCALL_NOACK_VOID = 0x0
	// GCALL not ACKed by any slave
	I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_ABRT_GCALL_NOACK_GENERATED = 0x1
	// Position of ABRT_TXDATA_NOACK field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_Pos = 0x3
	// Bit mask of ABRT_TXDATA_NOACK field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_Msk = 0x8
	// Bit ABRT_TXDATA_NOACK.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK = 0x8
	// Transmitted data non-ACKed by addressed slave-scenario not present
	I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_ABRT_TXDATA_NOACK_VOID = 0x0
	// Transmitted data not ACKed by addressed slave
	I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_ABRT_TXDATA_NOACK_GENERATED = 0x1
	// Position of ABRT_10ADDR2_NOACK field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_Pos = 0x2
	// Bit mask of ABRT_10ADDR2_NOACK field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_Msk = 0x4
	// Bit ABRT_10ADDR2_NOACK.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK = 0x4
	// This abort is not generated
	I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_INACTIVE = 0x0
	// Byte 2 of 10Bit Address not ACKed by any slave
	I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_ACTIVE = 0x1
	// Position of ABRT_10ADDR1_NOACK field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_Pos = 0x1
	// Bit mask of ABRT_10ADDR1_NOACK field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_Msk = 0x2
	// Bit ABRT_10ADDR1_NOACK.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK = 0x2
	// This abort is not generated
	I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_INACTIVE = 0x0
	// Byte 1 of 10Bit Address not ACKed by any slave
	I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_ACTIVE = 0x1
	// Position of ABRT_7B_ADDR_NOACK field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_Pos = 0x0
	// Bit mask of ABRT_7B_ADDR_NOACK field.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_Msk = 0x1
	// Bit ABRT_7B_ADDR_NOACK.
	I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK = 0x1
	// This abort is not generated
	I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_INACTIVE = 0x0
	// This abort is generated because of NOACK for 7-bit address
	I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_ACTIVE = 0x1

	// IC_SLV_DATA_NACK_ONLY
	// Generate Slave Data NACK Register\n
	// The register is used to generate a NACK for the data part of a transfer when DW_apb_i2c is acting as a slave-receiver. This register only exists when the IC_SLV_DATA_NACK_ONLY parameter is set to 1. When this parameter disabled, this register does not exist and writing to the register's address has no effect.\n
	// A write can occur on this register if both of the following conditions are met: - DW_apb_i2c is disabled (IC_ENABLE[0] = 0) - Slave part is inactive (IC_STATUS[6] = 0) Note: The IC_STATUS[6] is a register read-back location for the internal slv_activity signal; the user should poll this before writing the ic_slv_data_nack_only bit.
	// Position of NACK field.
	I2C0_IC_SLV_DATA_NACK_ONLY_NACK_Pos = 0x0
	// Bit mask of NACK field.
	I2C0_IC_SLV_DATA_NACK_ONLY_NACK_Msk = 0x1
	// Bit NACK.
	I2C0_IC_SLV_DATA_NACK_ONLY_NACK = 0x1
	// Slave receiver generates NACK normally
	I2C0_IC_SLV_DATA_NACK_ONLY_NACK_DISABLED = 0x0
	// Slave receiver generates NACK upon data reception only
	I2C0_IC_SLV_DATA_NACK_ONLY_NACK_ENABLED = 0x1

	// IC_DMA_CR
	// DMA Control Register\n
	// The register is used to enable the DMA Controller interface operation. There is a separate bit for transmit and receive. This can be programmed regardless of the state of IC_ENABLE.
	// Position of TDMAE field.
	I2C0_IC_DMA_CR_TDMAE_Pos = 0x1
	// Bit mask of TDMAE field.
	I2C0_IC_DMA_CR_TDMAE_Msk = 0x2
	// Bit TDMAE.
	I2C0_IC_DMA_CR_TDMAE = 0x2
	// transmit FIFO DMA channel disabled
	I2C0_IC_DMA_CR_TDMAE_DISABLED = 0x0
	// Transmit FIFO DMA channel enabled
	I2C0_IC_DMA_CR_TDMAE_ENABLED = 0x1
	// Position of RDMAE field.
	I2C0_IC_DMA_CR_RDMAE_Pos = 0x0
	// Bit mask of RDMAE field.
	I2C0_IC_DMA_CR_RDMAE_Msk = 0x1
	// Bit RDMAE.
	I2C0_IC_DMA_CR_RDMAE = 0x1
	// Receive FIFO DMA channel disabled
	I2C0_IC_DMA_CR_RDMAE_DISABLED = 0x0
	// Receive FIFO DMA channel enabled
	I2C0_IC_DMA_CR_RDMAE_ENABLED = 0x1

	// IC_DMA_TDLR: DMA Transmit Data Level Register
	// Position of DMATDL field.
	I2C0_IC_DMA_TDLR_DMATDL_Pos = 0x0
	// Bit mask of DMATDL field.
	I2C0_IC_DMA_TDLR_DMATDL_Msk = 0xf

	// IC_DMA_RDLR: I2C Receive Data Level Register
	// Position of DMARDL field.
	I2C0_IC_DMA_RDLR_DMARDL_Pos = 0x0
	// Bit mask of DMARDL field.
	I2C0_IC_DMA_RDLR_DMARDL_Msk = 0xf

	// IC_SDA_SETUP
	// I2C SDA Setup Register\n
	// This register controls the amount of time delay (in terms of number of ic_clk clock periods) introduced in the rising edge of SCL - relative to SDA changing - when DW_apb_i2c services a read request in a slave-transmitter operation. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2.\n
	// Writes to this register succeed only when IC_ENABLE[0] = 0.\n
	// Note: The length of setup time is calculated using [(IC_SDA_SETUP - 1) * (ic_clk_period)], so if the user requires 10 ic_clk periods of setup time, they should program a value of 11. The IC_SDA_SETUP register is only used by the DW_apb_i2c when operating as a slave transmitter.
	// Position of SDA_SETUP field.
	I2C0_IC_SDA_SETUP_SDA_SETUP_Pos = 0x0
	// Bit mask of SDA_SETUP field.
	I2C0_IC_SDA_SETUP_SDA_SETUP_Msk = 0xff

	// IC_ACK_GENERAL_CALL
	// I2C ACK General Call Register\n
	// The register controls whether DW_apb_i2c responds with a ACK or NACK when it receives an I2C General Call address.\n
	// This register is applicable only when the DW_apb_i2c is in slave mode.
	// Position of ACK_GEN_CALL field.
	I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_Pos = 0x0
	// Bit mask of ACK_GEN_CALL field.
	I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_Msk = 0x1
	// Bit ACK_GEN_CALL.
	I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL = 0x1
	// Generate NACK for a General Call
	I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_DISABLED = 0x0
	// Generate ACK for a General Call
	I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_ENABLED = 0x1

	// IC_ENABLE_STATUS
	// I2C Enable Status Register\n
	// The register is used to report the DW_apb_i2c hardware status when the IC_ENABLE[0] register is set from 1 to 0; that is, when DW_apb_i2c is disabled.\n
	// If IC_ENABLE[0] has been set to 1, bits 2:1 are forced to 0, and bit 0 is forced to 1.\n
	// If IC_ENABLE[0] has been set to 0, bits 2:1 is only be valid as soon as bit 0 is read as '0'.\n
	// Note: When IC_ENABLE[0] has been set to 0, a delay occurs for bit 0 to be read as 0 because disabling the DW_apb_i2c depends on I2C bus activities.
	// Position of SLV_RX_DATA_LOST field.
	I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_Pos = 0x2
	// Bit mask of SLV_RX_DATA_LOST field.
	I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_Msk = 0x4
	// Bit SLV_RX_DATA_LOST.
	I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST = 0x4
	// Slave RX Data is not lost
	I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_INACTIVE = 0x0
	// Slave RX Data is lost
	I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_ACTIVE = 0x1
	// Position of SLV_DISABLED_WHILE_BUSY field.
	I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_Pos = 0x1
	// Bit mask of SLV_DISABLED_WHILE_BUSY field.
	I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_Msk = 0x2
	// Bit SLV_DISABLED_WHILE_BUSY.
	I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY = 0x2
	// Slave is disabled when it is idle
	I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_INACTIVE = 0x0
	// Slave is disabled when it is active
	I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_ACTIVE = 0x1
	// Position of IC_EN field.
	I2C0_IC_ENABLE_STATUS_IC_EN_Pos = 0x0
	// Bit mask of IC_EN field.
	I2C0_IC_ENABLE_STATUS_IC_EN_Msk = 0x1
	// Bit IC_EN.
	I2C0_IC_ENABLE_STATUS_IC_EN = 0x1
	// I2C disabled
	I2C0_IC_ENABLE_STATUS_IC_EN_DISABLED = 0x0
	// I2C enabled
	I2C0_IC_ENABLE_STATUS_IC_EN_ENABLED = 0x1

	// IC_FS_SPKLEN
	// I2C SS, FS or FM+ spike suppression limit\n
	// This register is used to store the duration, measured in ic_clk cycles, of the longest spike that is filtered out by the spike suppression logic when the component is operating in SS, FS or FM+ modes. The relevant I2C requirement is tSP (table 4) as detailed in the I2C Bus Specification. This register must be programmed with a minimum value of 1.
	// Position of IC_FS_SPKLEN field.
	I2C0_IC_FS_SPKLEN_IC_FS_SPKLEN_Pos = 0x0
	// Bit mask of IC_FS_SPKLEN field.
	I2C0_IC_FS_SPKLEN_IC_FS_SPKLEN_Msk = 0xff

	// IC_CLR_RESTART_DET: Clear RESTART_DET Interrupt Register
	// Position of CLR_RESTART_DET field.
	I2C0_IC_CLR_RESTART_DET_CLR_RESTART_DET_Pos = 0x0
	// Bit mask of CLR_RESTART_DET field.
	I2C0_IC_CLR_RESTART_DET_CLR_RESTART_DET_Msk = 0x1
	// Bit CLR_RESTART_DET.
	I2C0_IC_CLR_RESTART_DET_CLR_RESTART_DET = 0x1

	// IC_COMP_PARAM_1
	// Component Parameter Register 1\n
	// Note This register is not implemented and therefore reads as 0. If it was implemented it would be a constant read-only register that contains encoded information about the component's parameter settings. Fields shown below are the settings for those parameters
	// Position of TX_BUFFER_DEPTH field.
	I2C0_IC_COMP_PARAM_1_TX_BUFFER_DEPTH_Pos = 0x10
	// Bit mask of TX_BUFFER_DEPTH field.
	I2C0_IC_COMP_PARAM_1_TX_BUFFER_DEPTH_Msk = 0xff0000
	// Position of RX_BUFFER_DEPTH field.
	I2C0_IC_COMP_PARAM_1_RX_BUFFER_DEPTH_Pos = 0x8
	// Bit mask of RX_BUFFER_DEPTH field.
	I2C0_IC_COMP_PARAM_1_RX_BUFFER_DEPTH_Msk = 0xff00
	// Position of ADD_ENCODED_PARAMS field.
	I2C0_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS_Pos = 0x7
	// Bit mask of ADD_ENCODED_PARAMS field.
	I2C0_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS_Msk = 0x80
	// Bit ADD_ENCODED_PARAMS.
	I2C0_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS = 0x80
	// Position of HAS_DMA field.
	I2C0_IC_COMP_PARAM_1_HAS_DMA_Pos = 0x6
	// Bit mask of HAS_DMA field.
	I2C0_IC_COMP_PARAM_1_HAS_DMA_Msk = 0x40
	// Bit HAS_DMA.
	I2C0_IC_COMP_PARAM_1_HAS_DMA = 0x40
	// Position of INTR_IO field.
	I2C0_IC_COMP_PARAM_1_INTR_IO_Pos = 0x5
	// Bit mask of INTR_IO field.
	I2C0_IC_COMP_PARAM_1_INTR_IO_Msk = 0x20
	// Bit INTR_IO.
	I2C0_IC_COMP_PARAM_1_INTR_IO = 0x20
	// Position of HC_COUNT_VALUES field.
	I2C0_IC_COMP_PARAM_1_HC_COUNT_VALUES_Pos = 0x4
	// Bit mask of HC_COUNT_VALUES field.
	I2C0_IC_COMP_PARAM_1_HC_COUNT_VALUES_Msk = 0x10
	// Bit HC_COUNT_VALUES.
	I2C0_IC_COMP_PARAM_1_HC_COUNT_VALUES = 0x10
	// Position of MAX_SPEED_MODE field.
	I2C0_IC_COMP_PARAM_1_MAX_SPEED_MODE_Pos = 0x2
	// Bit mask of MAX_SPEED_MODE field.
	I2C0_IC_COMP_PARAM_1_MAX_SPEED_MODE_Msk = 0xc
	// Position of APB_DATA_WIDTH field.
	I2C0_IC_COMP_PARAM_1_APB_DATA_WIDTH_Pos = 0x0
	// Bit mask of APB_DATA_WIDTH field.
	I2C0_IC_COMP_PARAM_1_APB_DATA_WIDTH_Msk = 0x3

	// IC_COMP_VERSION: I2C Component Version Register
	// Position of IC_COMP_VERSION field.
	I2C0_IC_COMP_VERSION_IC_COMP_VERSION_Pos = 0x0
	// Bit mask of IC_COMP_VERSION field.
	I2C0_IC_COMP_VERSION_IC_COMP_VERSION_Msk = 0xffffffff

	// IC_COMP_TYPE: I2C Component Type Register
	// Position of IC_COMP_TYPE field.
	I2C0_IC_COMP_TYPE_IC_COMP_TYPE_Pos = 0x0
	// Bit mask of IC_COMP_TYPE field.
	I2C0_IC_COMP_TYPE_IC_COMP_TYPE_Msk = 0xffffffff
)

// Constants for ADC: Control and data interface to SAR ADC
const (
	// CS: ADC Control and Status
	// Position of RROBIN field.
	ADC_CS_RROBIN_Pos = 0x10
	// Bit mask of RROBIN field.
	ADC_CS_RROBIN_Msk = 0x1f0000
	// Position of AINSEL field.
	ADC_CS_AINSEL_Pos = 0xc
	// Bit mask of AINSEL field.
	ADC_CS_AINSEL_Msk = 0x7000
	// Position of ERR_STICKY field.
	ADC_CS_ERR_STICKY_Pos = 0xa
	// Bit mask of ERR_STICKY field.
	ADC_CS_ERR_STICKY_Msk = 0x400
	// Bit ERR_STICKY.
	ADC_CS_ERR_STICKY = 0x400
	// Position of ERR field.
	ADC_CS_ERR_Pos = 0x9
	// Bit mask of ERR field.
	ADC_CS_ERR_Msk = 0x200
	// Bit ERR.
	ADC_CS_ERR = 0x200
	// Position of READY field.
	ADC_CS_READY_Pos = 0x8
	// Bit mask of READY field.
	ADC_CS_READY_Msk = 0x100
	// Bit READY.
	ADC_CS_READY = 0x100
	// Position of START_MANY field.
	ADC_CS_START_MANY_Pos = 0x3
	// Bit mask of START_MANY field.
	ADC_CS_START_MANY_Msk = 0x8
	// Bit START_MANY.
	ADC_CS_START_MANY = 0x8
	// Position of START_ONCE field.
	ADC_CS_START_ONCE_Pos = 0x2
	// Bit mask of START_ONCE field.
	ADC_CS_START_ONCE_Msk = 0x4
	// Bit START_ONCE.
	ADC_CS_START_ONCE = 0x4
	// Position of TS_EN field.
	ADC_CS_TS_EN_Pos = 0x1
	// Bit mask of TS_EN field.
	ADC_CS_TS_EN_Msk = 0x2
	// Bit TS_EN.
	ADC_CS_TS_EN = 0x2
	// Position of EN field.
	ADC_CS_EN_Pos = 0x0
	// Bit mask of EN field.
	ADC_CS_EN_Msk = 0x1
	// Bit EN.
	ADC_CS_EN = 0x1

	// RESULT: Result of most recent ADC conversion
	// Position of RESULT field.
	ADC_RESULT_RESULT_Pos = 0x0
	// Bit mask of RESULT field.
	ADC_RESULT_RESULT_Msk = 0xfff

	// FCS: FIFO control and status
	// Position of THRESH field.
	ADC_FCS_THRESH_Pos = 0x18
	// Bit mask of THRESH field.
	ADC_FCS_THRESH_Msk = 0xf000000
	// Position of LEVEL field.
	ADC_FCS_LEVEL_Pos = 0x10
	// Bit mask of LEVEL field.
	ADC_FCS_LEVEL_Msk = 0xf0000
	// Position of OVER field.
	ADC_FCS_OVER_Pos = 0xb
	// Bit mask of OVER field.
	ADC_FCS_OVER_Msk = 0x800
	// Bit OVER.
	ADC_FCS_OVER = 0x800
	// Position of UNDER field.
	ADC_FCS_UNDER_Pos = 0xa
	// Bit mask of UNDER field.
	ADC_FCS_UNDER_Msk = 0x400
	// Bit UNDER.
	ADC_FCS_UNDER = 0x400
	// Position of FULL field.
	ADC_FCS_FULL_Pos = 0x9
	// Bit mask of FULL field.
	ADC_FCS_FULL_Msk = 0x200
	// Bit FULL.
	ADC_FCS_FULL = 0x200
	// Position of EMPTY field.
	ADC_FCS_EMPTY_Pos = 0x8
	// Bit mask of EMPTY field.
	ADC_FCS_EMPTY_Msk = 0x100
	// Bit EMPTY.
	ADC_FCS_EMPTY = 0x100
	// Position of DREQ_EN field.
	ADC_FCS_DREQ_EN_Pos = 0x3
	// Bit mask of DREQ_EN field.
	ADC_FCS_DREQ_EN_Msk = 0x8
	// Bit DREQ_EN.
	ADC_FCS_DREQ_EN = 0x8
	// Position of ERR field.
	ADC_FCS_ERR_Pos = 0x2
	// Bit mask of ERR field.
	ADC_FCS_ERR_Msk = 0x4
	// Bit ERR.
	ADC_FCS_ERR = 0x4
	// Position of SHIFT field.
	ADC_FCS_SHIFT_Pos = 0x1
	// Bit mask of SHIFT field.
	ADC_FCS_SHIFT_Msk = 0x2
	// Bit SHIFT.
	ADC_FCS_SHIFT = 0x2
	// Position of EN field.
	ADC_FCS_EN_Pos = 0x0
	// Bit mask of EN field.
	ADC_FCS_EN_Msk = 0x1
	// Bit EN.
	ADC_FCS_EN = 0x1

	// FIFO: Conversion result FIFO
	// Position of ERR field.
	ADC_FIFO_ERR_Pos = 0xf
	// Bit mask of ERR field.
	ADC_FIFO_ERR_Msk = 0x8000
	// Bit ERR.
	ADC_FIFO_ERR = 0x8000
	// Position of VAL field.
	ADC_FIFO_VAL_Pos = 0x0
	// Bit mask of VAL field.
	ADC_FIFO_VAL_Msk = 0xfff

	// DIV
	// Clock divider. If non-zero, CS_START_MANY will start conversions
	// at regular intervals rather than back-to-back.
	// The divider is reset when either of these fields are written.
	// Total period is 1 + INT + FRAC / 256
	// Position of INT field.
	ADC_DIV_INT_Pos = 0x8
	// Bit mask of INT field.
	ADC_DIV_INT_Msk = 0xffff00
	// Position of FRAC field.
	ADC_DIV_FRAC_Pos = 0x0
	// Bit mask of FRAC field.
	ADC_DIV_FRAC_Msk = 0xff

	// INTR: Raw Interrupts
	// Position of FIFO field.
	ADC_INTR_FIFO_Pos = 0x0
	// Bit mask of FIFO field.
	ADC_INTR_FIFO_Msk = 0x1
	// Bit FIFO.
	ADC_INTR_FIFO = 0x1

	// INTE: Interrupt Enable
	// Position of FIFO field.
	ADC_INTE_FIFO_Pos = 0x0
	// Bit mask of FIFO field.
	ADC_INTE_FIFO_Msk = 0x1
	// Bit FIFO.
	ADC_INTE_FIFO = 0x1

	// INTF: Interrupt Force
	// Position of FIFO field.
	ADC_INTF_FIFO_Pos = 0x0
	// Bit mask of FIFO field.
	ADC_INTF_FIFO_Msk = 0x1
	// Bit FIFO.
	ADC_INTF_FIFO = 0x1

	// INTS: Interrupt status after masking & forcing
	// Position of FIFO field.
	ADC_INTS_FIFO_Pos = 0x0
	// Bit mask of FIFO field.
	ADC_INTS_FIFO_Msk = 0x1
	// Bit FIFO.
	ADC_INTS_FIFO = 0x1
)

// Constants for PWM: Simple PWM
const (
	// CH0_CSR: Control and status register
	// Position of PH_ADV field.
	PWM_CH0_CSR_PH_ADV_Pos = 0x7
	// Bit mask of PH_ADV field.
	PWM_CH0_CSR_PH_ADV_Msk = 0x80
	// Bit PH_ADV.
	PWM_CH0_CSR_PH_ADV = 0x80
	// Position of PH_RET field.
	PWM_CH0_CSR_PH_RET_Pos = 0x6
	// Bit mask of PH_RET field.
	PWM_CH0_CSR_PH_RET_Msk = 0x40
	// Bit PH_RET.
	PWM_CH0_CSR_PH_RET = 0x40
	// Position of DIVMODE field.
	PWM_CH0_CSR_DIVMODE_Pos = 0x4
	// Bit mask of DIVMODE field.
	PWM_CH0_CSR_DIVMODE_Msk = 0x30
	// Free-running counting at rate dictated by fractional divider
	PWM_CH0_CSR_DIVMODE_DIV = 0x0
	// Fractional divider operation is gated by the PWM B pin.
	PWM_CH0_CSR_DIVMODE_LEVEL = 0x1
	// Counter advances with each rising edge of the PWM B pin.
	PWM_CH0_CSR_DIVMODE_RISE = 0x2
	// Counter advances with each falling edge of the PWM B pin.
	PWM_CH0_CSR_DIVMODE_FALL = 0x3
	// Position of B_INV field.
	PWM_CH0_CSR_B_INV_Pos = 0x3
	// Bit mask of B_INV field.
	PWM_CH0_CSR_B_INV_Msk = 0x8
	// Bit B_INV.
	PWM_CH0_CSR_B_INV = 0x8
	// Position of A_INV field.
	PWM_CH0_CSR_A_INV_Pos = 0x2
	// Bit mask of A_INV field.
	PWM_CH0_CSR_A_INV_Msk = 0x4
	// Bit A_INV.
	PWM_CH0_CSR_A_INV = 0x4
	// Position of PH_CORRECT field.
	PWM_CH0_CSR_PH_CORRECT_Pos = 0x1
	// Bit mask of PH_CORRECT field.
	PWM_CH0_CSR_PH_CORRECT_Msk = 0x2
	// Bit PH_CORRECT.
	PWM_CH0_CSR_PH_CORRECT = 0x2
	// Position of EN field.
	PWM_CH0_CSR_EN_Pos = 0x0
	// Bit mask of EN field.
	PWM_CH0_CSR_EN_Msk = 0x1
	// Bit EN.
	PWM_CH0_CSR_EN = 0x1

	// CH0_DIV
	// INT and FRAC form a fixed-point fractional number.
	// Counting rate is system clock frequency divided by this number.
	// Fractional division uses simple 1st-order sigma-delta.
	// Position of INT field.
	PWM_CH0_DIV_INT_Pos = 0x4
	// Bit mask of INT field.
	PWM_CH0_DIV_INT_Msk = 0xff0
	// Position of FRAC field.
	PWM_CH0_DIV_FRAC_Pos = 0x0
	// Bit mask of FRAC field.
	PWM_CH0_DIV_FRAC_Msk = 0xf

	// CH0_CTR: Direct access to the PWM counter
	// Position of CH0_CTR field.
	PWM_CH0_CTR_CH0_CTR_Pos = 0x0
	// Bit mask of CH0_CTR field.
	PWM_CH0_CTR_CH0_CTR_Msk = 0xffff

	// CH0_CC: Counter compare values
	// Position of B field.
	PWM_CH0_CC_B_Pos = 0x10
	// Bit mask of B field.
	PWM_CH0_CC_B_Msk = 0xffff0000
	// Position of A field.
	PWM_CH0_CC_A_Pos = 0x0
	// Bit mask of A field.
	PWM_CH0_CC_A_Msk = 0xffff

	// CH0_TOP: Counter wrap value
	// Position of CH0_TOP field.
	PWM_CH0_TOP_CH0_TOP_Pos = 0x0
	// Bit mask of CH0_TOP field.
	PWM_CH0_TOP_CH0_TOP_Msk = 0xffff

	// CH1_CSR: Control and status register
	// Position of PH_ADV field.
	PWM_CH1_CSR_PH_ADV_Pos = 0x7
	// Bit mask of PH_ADV field.
	PWM_CH1_CSR_PH_ADV_Msk = 0x80
	// Bit PH_ADV.
	PWM_CH1_CSR_PH_ADV = 0x80
	// Position of PH_RET field.
	PWM_CH1_CSR_PH_RET_Pos = 0x6
	// Bit mask of PH_RET field.
	PWM_CH1_CSR_PH_RET_Msk = 0x40
	// Bit PH_RET.
	PWM_CH1_CSR_PH_RET = 0x40
	// Position of DIVMODE field.
	PWM_CH1_CSR_DIVMODE_Pos = 0x4
	// Bit mask of DIVMODE field.
	PWM_CH1_CSR_DIVMODE_Msk = 0x30
	// Free-running counting at rate dictated by fractional divider
	PWM_CH1_CSR_DIVMODE_DIV = 0x0
	// Fractional divider operation is gated by the PWM B pin.
	PWM_CH1_CSR_DIVMODE_LEVEL = 0x1
	// Counter advances with each rising edge of the PWM B pin.
	PWM_CH1_CSR_DIVMODE_RISE = 0x2
	// Counter advances with each falling edge of the PWM B pin.
	PWM_CH1_CSR_DIVMODE_FALL = 0x3
	// Position of B_INV field.
	PWM_CH1_CSR_B_INV_Pos = 0x3
	// Bit mask of B_INV field.
	PWM_CH1_CSR_B_INV_Msk = 0x8
	// Bit B_INV.
	PWM_CH1_CSR_B_INV = 0x8
	// Position of A_INV field.
	PWM_CH1_CSR_A_INV_Pos = 0x2
	// Bit mask of A_INV field.
	PWM_CH1_CSR_A_INV_Msk = 0x4
	// Bit A_INV.
	PWM_CH1_CSR_A_INV = 0x4
	// Position of PH_CORRECT field.
	PWM_CH1_CSR_PH_CORRECT_Pos = 0x1
	// Bit mask of PH_CORRECT field.
	PWM_CH1_CSR_PH_CORRECT_Msk = 0x2
	// Bit PH_CORRECT.
	PWM_CH1_CSR_PH_CORRECT = 0x2
	// Position of EN field.
	PWM_CH1_CSR_EN_Pos = 0x0
	// Bit mask of EN field.
	PWM_CH1_CSR_EN_Msk = 0x1
	// Bit EN.
	PWM_CH1_CSR_EN = 0x1

	// CH1_DIV
	// INT and FRAC form a fixed-point fractional number.
	// Counting rate is system clock frequency divided by this number.
	// Fractional division uses simple 1st-order sigma-delta.
	// Position of INT field.
	PWM_CH1_DIV_INT_Pos = 0x4
	// Bit mask of INT field.
	PWM_CH1_DIV_INT_Msk = 0xff0
	// Position of FRAC field.
	PWM_CH1_DIV_FRAC_Pos = 0x0
	// Bit mask of FRAC field.
	PWM_CH1_DIV_FRAC_Msk = 0xf

	// CH1_CTR: Direct access to the PWM counter
	// Position of CH1_CTR field.
	PWM_CH1_CTR_CH1_CTR_Pos = 0x0
	// Bit mask of CH1_CTR field.
	PWM_CH1_CTR_CH1_CTR_Msk = 0xffff

	// CH1_CC: Counter compare values
	// Position of B field.
	PWM_CH1_CC_B_Pos = 0x10
	// Bit mask of B field.
	PWM_CH1_CC_B_Msk = 0xffff0000
	// Position of A field.
	PWM_CH1_CC_A_Pos = 0x0
	// Bit mask of A field.
	PWM_CH1_CC_A_Msk = 0xffff

	// CH1_TOP: Counter wrap value
	// Position of CH1_TOP field.
	PWM_CH1_TOP_CH1_TOP_Pos = 0x0
	// Bit mask of CH1_TOP field.
	PWM_CH1_TOP_CH1_TOP_Msk = 0xffff

	// CH2_CSR: Control and status register
	// Position of PH_ADV field.
	PWM_CH2_CSR_PH_ADV_Pos = 0x7
	// Bit mask of PH_ADV field.
	PWM_CH2_CSR_PH_ADV_Msk = 0x80
	// Bit PH_ADV.
	PWM_CH2_CSR_PH_ADV = 0x80
	// Position of PH_RET field.
	PWM_CH2_CSR_PH_RET_Pos = 0x6
	// Bit mask of PH_RET field.
	PWM_CH2_CSR_PH_RET_Msk = 0x40
	// Bit PH_RET.
	PWM_CH2_CSR_PH_RET = 0x40
	// Position of DIVMODE field.
	PWM_CH2_CSR_DIVMODE_Pos = 0x4
	// Bit mask of DIVMODE field.
	PWM_CH2_CSR_DIVMODE_Msk = 0x30
	// Free-running counting at rate dictated by fractional divider
	PWM_CH2_CSR_DIVMODE_DIV = 0x0
	// Fractional divider operation is gated by the PWM B pin.
	PWM_CH2_CSR_DIVMODE_LEVEL = 0x1
	// Counter advances with each rising edge of the PWM B pin.
	PWM_CH2_CSR_DIVMODE_RISE = 0x2
	// Counter advances with each falling edge of the PWM B pin.
	PWM_CH2_CSR_DIVMODE_FALL = 0x3
	// Position of B_INV field.
	PWM_CH2_CSR_B_INV_Pos = 0x3
	// Bit mask of B_INV field.
	PWM_CH2_CSR_B_INV_Msk = 0x8
	// Bit B_INV.
	PWM_CH2_CSR_B_INV = 0x8
	// Position of A_INV field.
	PWM_CH2_CSR_A_INV_Pos = 0x2
	// Bit mask of A_INV field.
	PWM_CH2_CSR_A_INV_Msk = 0x4
	// Bit A_INV.
	PWM_CH2_CSR_A_INV = 0x4
	// Position of PH_CORRECT field.
	PWM_CH2_CSR_PH_CORRECT_Pos = 0x1
	// Bit mask of PH_CORRECT field.
	PWM_CH2_CSR_PH_CORRECT_Msk = 0x2
	// Bit PH_CORRECT.
	PWM_CH2_CSR_PH_CORRECT = 0x2
	// Position of EN field.
	PWM_CH2_CSR_EN_Pos = 0x0
	// Bit mask of EN field.
	PWM_CH2_CSR_EN_Msk = 0x1
	// Bit EN.
	PWM_CH2_CSR_EN = 0x1

	// CH2_DIV
	// INT and FRAC form a fixed-point fractional number.
	// Counting rate is system clock frequency divided by this number.
	// Fractional division uses simple 1st-order sigma-delta.
	// Position of INT field.
	PWM_CH2_DIV_INT_Pos = 0x4
	// Bit mask of INT field.
	PWM_CH2_DIV_INT_Msk = 0xff0
	// Position of FRAC field.
	PWM_CH2_DIV_FRAC_Pos = 0x0
	// Bit mask of FRAC field.
	PWM_CH2_DIV_FRAC_Msk = 0xf

	// CH2_CTR: Direct access to the PWM counter
	// Position of CH2_CTR field.
	PWM_CH2_CTR_CH2_CTR_Pos = 0x0
	// Bit mask of CH2_CTR field.
	PWM_CH2_CTR_CH2_CTR_Msk = 0xffff

	// CH2_CC: Counter compare values
	// Position of B field.
	PWM_CH2_CC_B_Pos = 0x10
	// Bit mask of B field.
	PWM_CH2_CC_B_Msk = 0xffff0000
	// Position of A field.
	PWM_CH2_CC_A_Pos = 0x0
	// Bit mask of A field.
	PWM_CH2_CC_A_Msk = 0xffff

	// CH2_TOP: Counter wrap value
	// Position of CH2_TOP field.
	PWM_CH2_TOP_CH2_TOP_Pos = 0x0
	// Bit mask of CH2_TOP field.
	PWM_CH2_TOP_CH2_TOP_Msk = 0xffff

	// CH3_CSR: Control and status register
	// Position of PH_ADV field.
	PWM_CH3_CSR_PH_ADV_Pos = 0x7
	// Bit mask of PH_ADV field.
	PWM_CH3_CSR_PH_ADV_Msk = 0x80
	// Bit PH_ADV.
	PWM_CH3_CSR_PH_ADV = 0x80
	// Position of PH_RET field.
	PWM_CH3_CSR_PH_RET_Pos = 0x6
	// Bit mask of PH_RET field.
	PWM_CH3_CSR_PH_RET_Msk = 0x40
	// Bit PH_RET.
	PWM_CH3_CSR_PH_RET = 0x40
	// Position of DIVMODE field.
	PWM_CH3_CSR_DIVMODE_Pos = 0x4
	// Bit mask of DIVMODE field.
	PWM_CH3_CSR_DIVMODE_Msk = 0x30
	// Free-running counting at rate dictated by fractional divider
	PWM_CH3_CSR_DIVMODE_DIV = 0x0
	// Fractional divider operation is gated by the PWM B pin.
	PWM_CH3_CSR_DIVMODE_LEVEL = 0x1
	// Counter advances with each rising edge of the PWM B pin.
	PWM_CH3_CSR_DIVMODE_RISE = 0x2
	// Counter advances with each falling edge of the PWM B pin.
	PWM_CH3_CSR_DIVMODE_FALL = 0x3
	// Position of B_INV field.
	PWM_CH3_CSR_B_INV_Pos = 0x3
	// Bit mask of B_INV field.
	PWM_CH3_CSR_B_INV_Msk = 0x8
	// Bit B_INV.
	PWM_CH3_CSR_B_INV = 0x8
	// Position of A_INV field.
	PWM_CH3_CSR_A_INV_Pos = 0x2
	// Bit mask of A_INV field.
	PWM_CH3_CSR_A_INV_Msk = 0x4
	// Bit A_INV.
	PWM_CH3_CSR_A_INV = 0x4
	// Position of PH_CORRECT field.
	PWM_CH3_CSR_PH_CORRECT_Pos = 0x1
	// Bit mask of PH_CORRECT field.
	PWM_CH3_CSR_PH_CORRECT_Msk = 0x2
	// Bit PH_CORRECT.
	PWM_CH3_CSR_PH_CORRECT = 0x2
	// Position of EN field.
	PWM_CH3_CSR_EN_Pos = 0x0
	// Bit mask of EN field.
	PWM_CH3_CSR_EN_Msk = 0x1
	// Bit EN.
	PWM_CH3_CSR_EN = 0x1

	// CH3_DIV
	// INT and FRAC form a fixed-point fractional number.
	// Counting rate is system clock frequency divided by this number.
	// Fractional division uses simple 1st-order sigma-delta.
	// Position of INT field.
	PWM_CH3_DIV_INT_Pos = 0x4
	// Bit mask of INT field.
	PWM_CH3_DIV_INT_Msk = 0xff0
	// Position of FRAC field.
	PWM_CH3_DIV_FRAC_Pos = 0x0
	// Bit mask of FRAC field.
	PWM_CH3_DIV_FRAC_Msk = 0xf

	// CH3_CTR: Direct access to the PWM counter
	// Position of CH3_CTR field.
	PWM_CH3_CTR_CH3_CTR_Pos = 0x0
	// Bit mask of CH3_CTR field.
	PWM_CH3_CTR_CH3_CTR_Msk = 0xffff

	// CH3_CC: Counter compare values
	// Position of B field.
	PWM_CH3_CC_B_Pos = 0x10
	// Bit mask of B field.
	PWM_CH3_CC_B_Msk = 0xffff0000
	// Position of A field.
	PWM_CH3_CC_A_Pos = 0x0
	// Bit mask of A field.
	PWM_CH3_CC_A_Msk = 0xffff

	// CH3_TOP: Counter wrap value
	// Position of CH3_TOP field.
	PWM_CH3_TOP_CH3_TOP_Pos = 0x0
	// Bit mask of CH3_TOP field.
	PWM_CH3_TOP_CH3_TOP_Msk = 0xffff

	// CH4_CSR: Control and status register
	// Position of PH_ADV field.
	PWM_CH4_CSR_PH_ADV_Pos = 0x7
	// Bit mask of PH_ADV field.
	PWM_CH4_CSR_PH_ADV_Msk = 0x80
	// Bit PH_ADV.
	PWM_CH4_CSR_PH_ADV = 0x80
	// Position of PH_RET field.
	PWM_CH4_CSR_PH_RET_Pos = 0x6
	// Bit mask of PH_RET field.
	PWM_CH4_CSR_PH_RET_Msk = 0x40
	// Bit PH_RET.
	PWM_CH4_CSR_PH_RET = 0x40
	// Position of DIVMODE field.
	PWM_CH4_CSR_DIVMODE_Pos = 0x4
	// Bit mask of DIVMODE field.
	PWM_CH4_CSR_DIVMODE_Msk = 0x30
	// Free-running counting at rate dictated by fractional divider
	PWM_CH4_CSR_DIVMODE_DIV = 0x0
	// Fractional divider operation is gated by the PWM B pin.
	PWM_CH4_CSR_DIVMODE_LEVEL = 0x1
	// Counter advances with each rising edge of the PWM B pin.
	PWM_CH4_CSR_DIVMODE_RISE = 0x2
	// Counter advances with each falling edge of the PWM B pin.
	PWM_CH4_CSR_DIVMODE_FALL = 0x3
	// Position of B_INV field.
	PWM_CH4_CSR_B_INV_Pos = 0x3
	// Bit mask of B_INV field.
	PWM_CH4_CSR_B_INV_Msk = 0x8
	// Bit B_INV.
	PWM_CH4_CSR_B_INV = 0x8
	// Position of A_INV field.
	PWM_CH4_CSR_A_INV_Pos = 0x2
	// Bit mask of A_INV field.
	PWM_CH4_CSR_A_INV_Msk = 0x4
	// Bit A_INV.
	PWM_CH4_CSR_A_INV = 0x4
	// Position of PH_CORRECT field.
	PWM_CH4_CSR_PH_CORRECT_Pos = 0x1
	// Bit mask of PH_CORRECT field.
	PWM_CH4_CSR_PH_CORRECT_Msk = 0x2
	// Bit PH_CORRECT.
	PWM_CH4_CSR_PH_CORRECT = 0x2
	// Position of EN field.
	PWM_CH4_CSR_EN_Pos = 0x0
	// Bit mask of EN field.
	PWM_CH4_CSR_EN_Msk = 0x1
	// Bit EN.
	PWM_CH4_CSR_EN = 0x1

	// CH4_DIV
	// INT and FRAC form a fixed-point fractional number.
	// Counting rate is system clock frequency divided by this number.
	// Fractional division uses simple 1st-order sigma-delta.
	// Position of INT field.
	PWM_CH4_DIV_INT_Pos = 0x4
	// Bit mask of INT field.
	PWM_CH4_DIV_INT_Msk = 0xff0
	// Position of FRAC field.
	PWM_CH4_DIV_FRAC_Pos = 0x0
	// Bit mask of FRAC field.
	PWM_CH4_DIV_FRAC_Msk = 0xf

	// CH4_CTR: Direct access to the PWM counter
	// Position of CH4_CTR field.
	PWM_CH4_CTR_CH4_CTR_Pos = 0x0
	// Bit mask of CH4_CTR field.
	PWM_CH4_CTR_CH4_CTR_Msk = 0xffff

	// CH4_CC: Counter compare values
	// Position of B field.
	PWM_CH4_CC_B_Pos = 0x10
	// Bit mask of B field.
	PWM_CH4_CC_B_Msk = 0xffff0000
	// Position of A field.
	PWM_CH4_CC_A_Pos = 0x0
	// Bit mask of A field.
	PWM_CH4_CC_A_Msk = 0xffff

	// CH4_TOP: Counter wrap value
	// Position of CH4_TOP field.
	PWM_CH4_TOP_CH4_TOP_Pos = 0x0
	// Bit mask of CH4_TOP field.
	PWM_CH4_TOP_CH4_TOP_Msk = 0xffff

	// CH5_CSR: Control and status register
	// Position of PH_ADV field.
	PWM_CH5_CSR_PH_ADV_Pos = 0x7
	// Bit mask of PH_ADV field.
	PWM_CH5_CSR_PH_ADV_Msk = 0x80
	// Bit PH_ADV.
	PWM_CH5_CSR_PH_ADV = 0x80
	// Position of PH_RET field.
	PWM_CH5_CSR_PH_RET_Pos = 0x6
	// Bit mask of PH_RET field.
	PWM_CH5_CSR_PH_RET_Msk = 0x40
	// Bit PH_RET.
	PWM_CH5_CSR_PH_RET = 0x40
	// Position of DIVMODE field.
	PWM_CH5_CSR_DIVMODE_Pos = 0x4
	// Bit mask of DIVMODE field.
	PWM_CH5_CSR_DIVMODE_Msk = 0x30
	// Free-running counting at rate dictated by fractional divider
	PWM_CH5_CSR_DIVMODE_DIV = 0x0
	// Fractional divider operation is gated by the PWM B pin.
	PWM_CH5_CSR_DIVMODE_LEVEL = 0x1
	// Counter advances with each rising edge of the PWM B pin.
	PWM_CH5_CSR_DIVMODE_RISE = 0x2
	// Counter advances with each falling edge of the PWM B pin.
	PWM_CH5_CSR_DIVMODE_FALL = 0x3
	// Position of B_INV field.
	PWM_CH5_CSR_B_INV_Pos = 0x3
	// Bit mask of B_INV field.
	PWM_CH5_CSR_B_INV_Msk = 0x8
	// Bit B_INV.
	PWM_CH5_CSR_B_INV = 0x8
	// Position of A_INV field.
	PWM_CH5_CSR_A_INV_Pos = 0x2
	// Bit mask of A_INV field.
	PWM_CH5_CSR_A_INV_Msk = 0x4
	// Bit A_INV.
	PWM_CH5_CSR_A_INV = 0x4
	// Position of PH_CORRECT field.
	PWM_CH5_CSR_PH_CORRECT_Pos = 0x1
	// Bit mask of PH_CORRECT field.
	PWM_CH5_CSR_PH_CORRECT_Msk = 0x2
	// Bit PH_CORRECT.
	PWM_CH5_CSR_PH_CORRECT = 0x2
	// Position of EN field.
	PWM_CH5_CSR_EN_Pos = 0x0
	// Bit mask of EN field.
	PWM_CH5_CSR_EN_Msk = 0x1
	// Bit EN.
	PWM_CH5_CSR_EN = 0x1

	// CH5_DIV
	// INT and FRAC form a fixed-point fractional number.
	// Counting rate is system clock frequency divided by this number.
	// Fractional division uses simple 1st-order sigma-delta.
	// Position of INT field.
	PWM_CH5_DIV_INT_Pos = 0x4
	// Bit mask of INT field.
	PWM_CH5_DIV_INT_Msk = 0xff0
	// Position of FRAC field.
	PWM_CH5_DIV_FRAC_Pos = 0x0
	// Bit mask of FRAC field.
	PWM_CH5_DIV_FRAC_Msk = 0xf

	// CH5_CTR: Direct access to the PWM counter
	// Position of CH5_CTR field.
	PWM_CH5_CTR_CH5_CTR_Pos = 0x0
	// Bit mask of CH5_CTR field.
	PWM_CH5_CTR_CH5_CTR_Msk = 0xffff

	// CH5_CC: Counter compare values
	// Position of B field.
	PWM_CH5_CC_B_Pos = 0x10
	// Bit mask of B field.
	PWM_CH5_CC_B_Msk = 0xffff0000
	// Position of A field.
	PWM_CH5_CC_A_Pos = 0x0
	// Bit mask of A field.
	PWM_CH5_CC_A_Msk = 0xffff

	// CH5_TOP: Counter wrap value
	// Position of CH5_TOP field.
	PWM_CH5_TOP_CH5_TOP_Pos = 0x0
	// Bit mask of CH5_TOP field.
	PWM_CH5_TOP_CH5_TOP_Msk = 0xffff

	// CH6_CSR: Control and status register
	// Position of PH_ADV field.
	PWM_CH6_CSR_PH_ADV_Pos = 0x7
	// Bit mask of PH_ADV field.
	PWM_CH6_CSR_PH_ADV_Msk = 0x80
	// Bit PH_ADV.
	PWM_CH6_CSR_PH_ADV = 0x80
	// Position of PH_RET field.
	PWM_CH6_CSR_PH_RET_Pos = 0x6
	// Bit mask of PH_RET field.
	PWM_CH6_CSR_PH_RET_Msk = 0x40
	// Bit PH_RET.
	PWM_CH6_CSR_PH_RET = 0x40
	// Position of DIVMODE field.
	PWM_CH6_CSR_DIVMODE_Pos = 0x4
	// Bit mask of DIVMODE field.
	PWM_CH6_CSR_DIVMODE_Msk = 0x30
	// Free-running counting at rate dictated by fractional divider
	PWM_CH6_CSR_DIVMODE_DIV = 0x0
	// Fractional divider operation is gated by the PWM B pin.
	PWM_CH6_CSR_DIVMODE_LEVEL = 0x1
	// Counter advances with each rising edge of the PWM B pin.
	PWM_CH6_CSR_DIVMODE_RISE = 0x2
	// Counter advances with each falling edge of the PWM B pin.
	PWM_CH6_CSR_DIVMODE_FALL = 0x3
	// Position of B_INV field.
	PWM_CH6_CSR_B_INV_Pos = 0x3
	// Bit mask of B_INV field.
	PWM_CH6_CSR_B_INV_Msk = 0x8
	// Bit B_INV.
	PWM_CH6_CSR_B_INV = 0x8
	// Position of A_INV field.
	PWM_CH6_CSR_A_INV_Pos = 0x2
	// Bit mask of A_INV field.
	PWM_CH6_CSR_A_INV_Msk = 0x4
	// Bit A_INV.
	PWM_CH6_CSR_A_INV = 0x4
	// Position of PH_CORRECT field.
	PWM_CH6_CSR_PH_CORRECT_Pos = 0x1
	// Bit mask of PH_CORRECT field.
	PWM_CH6_CSR_PH_CORRECT_Msk = 0x2
	// Bit PH_CORRECT.
	PWM_CH6_CSR_PH_CORRECT = 0x2
	// Position of EN field.
	PWM_CH6_CSR_EN_Pos = 0x0
	// Bit mask of EN field.
	PWM_CH6_CSR_EN_Msk = 0x1
	// Bit EN.
	PWM_CH6_CSR_EN = 0x1

	// CH6_DIV
	// INT and FRAC form a fixed-point fractional number.
	// Counting rate is system clock frequency divided by this number.
	// Fractional division uses simple 1st-order sigma-delta.
	// Position of INT field.
	PWM_CH6_DIV_INT_Pos = 0x4
	// Bit mask of INT field.
	PWM_CH6_DIV_INT_Msk = 0xff0
	// Position of FRAC field.
	PWM_CH6_DIV_FRAC_Pos = 0x0
	// Bit mask of FRAC field.
	PWM_CH6_DIV_FRAC_Msk = 0xf

	// CH6_CTR: Direct access to the PWM counter
	// Position of CH6_CTR field.
	PWM_CH6_CTR_CH6_CTR_Pos = 0x0
	// Bit mask of CH6_CTR field.
	PWM_CH6_CTR_CH6_CTR_Msk = 0xffff

	// CH6_CC: Counter compare values
	// Position of B field.
	PWM_CH6_CC_B_Pos = 0x10
	// Bit mask of B field.
	PWM_CH6_CC_B_Msk = 0xffff0000
	// Position of A field.
	PWM_CH6_CC_A_Pos = 0x0
	// Bit mask of A field.
	PWM_CH6_CC_A_Msk = 0xffff

	// CH6_TOP: Counter wrap value
	// Position of CH6_TOP field.
	PWM_CH6_TOP_CH6_TOP_Pos = 0x0
	// Bit mask of CH6_TOP field.
	PWM_CH6_TOP_CH6_TOP_Msk = 0xffff

	// CH7_CSR: Control and status register
	// Position of PH_ADV field.
	PWM_CH7_CSR_PH_ADV_Pos = 0x7
	// Bit mask of PH_ADV field.
	PWM_CH7_CSR_PH_ADV_Msk = 0x80
	// Bit PH_ADV.
	PWM_CH7_CSR_PH_ADV = 0x80
	// Position of PH_RET field.
	PWM_CH7_CSR_PH_RET_Pos = 0x6
	// Bit mask of PH_RET field.
	PWM_CH7_CSR_PH_RET_Msk = 0x40
	// Bit PH_RET.
	PWM_CH7_CSR_PH_RET = 0x40
	// Position of DIVMODE field.
	PWM_CH7_CSR_DIVMODE_Pos = 0x4
	// Bit mask of DIVMODE field.
	PWM_CH7_CSR_DIVMODE_Msk = 0x30
	// Free-running counting at rate dictated by fractional divider
	PWM_CH7_CSR_DIVMODE_DIV = 0x0
	// Fractional divider operation is gated by the PWM B pin.
	PWM_CH7_CSR_DIVMODE_LEVEL = 0x1
	// Counter advances with each rising edge of the PWM B pin.
	PWM_CH7_CSR_DIVMODE_RISE = 0x2
	// Counter advances with each falling edge of the PWM B pin.
	PWM_CH7_CSR_DIVMODE_FALL = 0x3
	// Position of B_INV field.
	PWM_CH7_CSR_B_INV_Pos = 0x3
	// Bit mask of B_INV field.
	PWM_CH7_CSR_B_INV_Msk = 0x8
	// Bit B_INV.
	PWM_CH7_CSR_B_INV = 0x8
	// Position of A_INV field.
	PWM_CH7_CSR_A_INV_Pos = 0x2
	// Bit mask of A_INV field.
	PWM_CH7_CSR_A_INV_Msk = 0x4
	// Bit A_INV.
	PWM_CH7_CSR_A_INV = 0x4
	// Position of PH_CORRECT field.
	PWM_CH7_CSR_PH_CORRECT_Pos = 0x1
	// Bit mask of PH_CORRECT field.
	PWM_CH7_CSR_PH_CORRECT_Msk = 0x2
	// Bit PH_CORRECT.
	PWM_CH7_CSR_PH_CORRECT = 0x2
	// Position of EN field.
	PWM_CH7_CSR_EN_Pos = 0x0
	// Bit mask of EN field.
	PWM_CH7_CSR_EN_Msk = 0x1
	// Bit EN.
	PWM_CH7_CSR_EN = 0x1

	// CH7_DIV
	// INT and FRAC form a fixed-point fractional number.
	// Counting rate is system clock frequency divided by this number.
	// Fractional division uses simple 1st-order sigma-delta.
	// Position of INT field.
	PWM_CH7_DIV_INT_Pos = 0x4
	// Bit mask of INT field.
	PWM_CH7_DIV_INT_Msk = 0xff0
	// Position of FRAC field.
	PWM_CH7_DIV_FRAC_Pos = 0x0
	// Bit mask of FRAC field.
	PWM_CH7_DIV_FRAC_Msk = 0xf

	// CH7_CTR: Direct access to the PWM counter
	// Position of CH7_CTR field.
	PWM_CH7_CTR_CH7_CTR_Pos = 0x0
	// Bit mask of CH7_CTR field.
	PWM_CH7_CTR_CH7_CTR_Msk = 0xffff

	// CH7_CC: Counter compare values
	// Position of B field.
	PWM_CH7_CC_B_Pos = 0x10
	// Bit mask of B field.
	PWM_CH7_CC_B_Msk = 0xffff0000
	// Position of A field.
	PWM_CH7_CC_A_Pos = 0x0
	// Bit mask of A field.
	PWM_CH7_CC_A_Msk = 0xffff

	// CH7_TOP: Counter wrap value
	// Position of CH7_TOP field.
	PWM_CH7_TOP_CH7_TOP_Pos = 0x0
	// Bit mask of CH7_TOP field.
	PWM_CH7_TOP_CH7_TOP_Msk = 0xffff

	// EN
	// This register aliases the CSR_EN bits for all channels.
	// Writing to this register allows multiple channels to be enabled
	// or disabled simultaneously, so they can run in perfect sync.
	// For each channel, there is only one physical EN register bit,
	// which can be accessed through here or CHx_CSR.
	// Position of CH7 field.
	PWM_EN_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	PWM_EN_CH7_Msk = 0x80
	// Bit CH7.
	PWM_EN_CH7 = 0x80
	// Position of CH6 field.
	PWM_EN_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	PWM_EN_CH6_Msk = 0x40
	// Bit CH6.
	PWM_EN_CH6 = 0x40
	// Position of CH5 field.
	PWM_EN_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	PWM_EN_CH5_Msk = 0x20
	// Bit CH5.
	PWM_EN_CH5 = 0x20
	// Position of CH4 field.
	PWM_EN_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	PWM_EN_CH4_Msk = 0x10
	// Bit CH4.
	PWM_EN_CH4 = 0x10
	// Position of CH3 field.
	PWM_EN_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	PWM_EN_CH3_Msk = 0x8
	// Bit CH3.
	PWM_EN_CH3 = 0x8
	// Position of CH2 field.
	PWM_EN_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	PWM_EN_CH2_Msk = 0x4
	// Bit CH2.
	PWM_EN_CH2 = 0x4
	// Position of CH1 field.
	PWM_EN_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	PWM_EN_CH1_Msk = 0x2
	// Bit CH1.
	PWM_EN_CH1 = 0x2
	// Position of CH0 field.
	PWM_EN_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	PWM_EN_CH0_Msk = 0x1
	// Bit CH0.
	PWM_EN_CH0 = 0x1

	// INTR: Raw Interrupts
	// Position of CH7 field.
	PWM_INTR_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	PWM_INTR_CH7_Msk = 0x80
	// Bit CH7.
	PWM_INTR_CH7 = 0x80
	// Position of CH6 field.
	PWM_INTR_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	PWM_INTR_CH6_Msk = 0x40
	// Bit CH6.
	PWM_INTR_CH6 = 0x40
	// Position of CH5 field.
	PWM_INTR_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	PWM_INTR_CH5_Msk = 0x20
	// Bit CH5.
	PWM_INTR_CH5 = 0x20
	// Position of CH4 field.
	PWM_INTR_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	PWM_INTR_CH4_Msk = 0x10
	// Bit CH4.
	PWM_INTR_CH4 = 0x10
	// Position of CH3 field.
	PWM_INTR_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	PWM_INTR_CH3_Msk = 0x8
	// Bit CH3.
	PWM_INTR_CH3 = 0x8
	// Position of CH2 field.
	PWM_INTR_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	PWM_INTR_CH2_Msk = 0x4
	// Bit CH2.
	PWM_INTR_CH2 = 0x4
	// Position of CH1 field.
	PWM_INTR_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	PWM_INTR_CH1_Msk = 0x2
	// Bit CH1.
	PWM_INTR_CH1 = 0x2
	// Position of CH0 field.
	PWM_INTR_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	PWM_INTR_CH0_Msk = 0x1
	// Bit CH0.
	PWM_INTR_CH0 = 0x1

	// INTE: Interrupt Enable
	// Position of CH7 field.
	PWM_INTE_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	PWM_INTE_CH7_Msk = 0x80
	// Bit CH7.
	PWM_INTE_CH7 = 0x80
	// Position of CH6 field.
	PWM_INTE_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	PWM_INTE_CH6_Msk = 0x40
	// Bit CH6.
	PWM_INTE_CH6 = 0x40
	// Position of CH5 field.
	PWM_INTE_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	PWM_INTE_CH5_Msk = 0x20
	// Bit CH5.
	PWM_INTE_CH5 = 0x20
	// Position of CH4 field.
	PWM_INTE_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	PWM_INTE_CH4_Msk = 0x10
	// Bit CH4.
	PWM_INTE_CH4 = 0x10
	// Position of CH3 field.
	PWM_INTE_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	PWM_INTE_CH3_Msk = 0x8
	// Bit CH3.
	PWM_INTE_CH3 = 0x8
	// Position of CH2 field.
	PWM_INTE_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	PWM_INTE_CH2_Msk = 0x4
	// Bit CH2.
	PWM_INTE_CH2 = 0x4
	// Position of CH1 field.
	PWM_INTE_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	PWM_INTE_CH1_Msk = 0x2
	// Bit CH1.
	PWM_INTE_CH1 = 0x2
	// Position of CH0 field.
	PWM_INTE_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	PWM_INTE_CH0_Msk = 0x1
	// Bit CH0.
	PWM_INTE_CH0 = 0x1

	// INTF: Interrupt Force
	// Position of CH7 field.
	PWM_INTF_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	PWM_INTF_CH7_Msk = 0x80
	// Bit CH7.
	PWM_INTF_CH7 = 0x80
	// Position of CH6 field.
	PWM_INTF_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	PWM_INTF_CH6_Msk = 0x40
	// Bit CH6.
	PWM_INTF_CH6 = 0x40
	// Position of CH5 field.
	PWM_INTF_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	PWM_INTF_CH5_Msk = 0x20
	// Bit CH5.
	PWM_INTF_CH5 = 0x20
	// Position of CH4 field.
	PWM_INTF_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	PWM_INTF_CH4_Msk = 0x10
	// Bit CH4.
	PWM_INTF_CH4 = 0x10
	// Position of CH3 field.
	PWM_INTF_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	PWM_INTF_CH3_Msk = 0x8
	// Bit CH3.
	PWM_INTF_CH3 = 0x8
	// Position of CH2 field.
	PWM_INTF_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	PWM_INTF_CH2_Msk = 0x4
	// Bit CH2.
	PWM_INTF_CH2 = 0x4
	// Position of CH1 field.
	PWM_INTF_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	PWM_INTF_CH1_Msk = 0x2
	// Bit CH1.
	PWM_INTF_CH1 = 0x2
	// Position of CH0 field.
	PWM_INTF_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	PWM_INTF_CH0_Msk = 0x1
	// Bit CH0.
	PWM_INTF_CH0 = 0x1

	// INTS: Interrupt status after masking & forcing
	// Position of CH7 field.
	PWM_INTS_CH7_Pos = 0x7
	// Bit mask of CH7 field.
	PWM_INTS_CH7_Msk = 0x80
	// Bit CH7.
	PWM_INTS_CH7 = 0x80
	// Position of CH6 field.
	PWM_INTS_CH6_Pos = 0x6
	// Bit mask of CH6 field.
	PWM_INTS_CH6_Msk = 0x40
	// Bit CH6.
	PWM_INTS_CH6 = 0x40
	// Position of CH5 field.
	PWM_INTS_CH5_Pos = 0x5
	// Bit mask of CH5 field.
	PWM_INTS_CH5_Msk = 0x20
	// Bit CH5.
	PWM_INTS_CH5 = 0x20
	// Position of CH4 field.
	PWM_INTS_CH4_Pos = 0x4
	// Bit mask of CH4 field.
	PWM_INTS_CH4_Msk = 0x10
	// Bit CH4.
	PWM_INTS_CH4 = 0x10
	// Position of CH3 field.
	PWM_INTS_CH3_Pos = 0x3
	// Bit mask of CH3 field.
	PWM_INTS_CH3_Msk = 0x8
	// Bit CH3.
	PWM_INTS_CH3 = 0x8
	// Position of CH2 field.
	PWM_INTS_CH2_Pos = 0x2
	// Bit mask of CH2 field.
	PWM_INTS_CH2_Msk = 0x4
	// Bit CH2.
	PWM_INTS_CH2 = 0x4
	// Position of CH1 field.
	PWM_INTS_CH1_Pos = 0x1
	// Bit mask of CH1 field.
	PWM_INTS_CH1_Msk = 0x2
	// Bit CH1.
	PWM_INTS_CH1 = 0x2
	// Position of CH0 field.
	PWM_INTS_CH0_Pos = 0x0
	// Bit mask of CH0 field.
	PWM_INTS_CH0_Msk = 0x1
	// Bit CH0.
	PWM_INTS_CH0 = 0x1
)

// Constants for TIMER
// Controls time and alarms
// time is a 64 bit value indicating the time in usec since power-on
// timeh is the top 32 bits of time & timel is the bottom 32 bits
// to change time write to timelw before timehw
// to read time read from timelr before timehr
// An alarm is set by setting alarm_enable and writing to the corresponding alarm register
// When an alarm is pending, the corresponding alarm_running signal will be high
// An alarm can be cancelled before it has finished by clearing the alarm_enable
// When an alarm fires, the corresponding alarm_irq is set and alarm_running is cleared
// To clear the interrupt write a 1 to the corresponding alarm_irq
const (
	// ARMED
	// Indicates the armed/disarmed status of each alarm.
	// A write to the corresponding ALARMx register arms the alarm.
	// Alarms automatically disarm upon firing, but writing ones here
	// will disarm immediately without waiting to fire.
	// Position of ARMED field.
	TIMER_ARMED_ARMED_Pos = 0x0
	// Bit mask of ARMED field.
	TIMER_ARMED_ARMED_Msk = 0xf

	// DBGPAUSE: Set bits high to enable pause when the corresponding debug ports are active
	// Position of DBG1 field.
	TIMER_DBGPAUSE_DBG1_Pos = 0x2
	// Bit mask of DBG1 field.
	TIMER_DBGPAUSE_DBG1_Msk = 0x4
	// Bit DBG1.
	TIMER_DBGPAUSE_DBG1 = 0x4
	// Position of DBG0 field.
	TIMER_DBGPAUSE_DBG0_Pos = 0x1
	// Bit mask of DBG0 field.
	TIMER_DBGPAUSE_DBG0_Msk = 0x2
	// Bit DBG0.
	TIMER_DBGPAUSE_DBG0 = 0x2

	// PAUSE: Set high to pause the timer
	// Position of PAUSE field.
	TIMER_PAUSE_PAUSE_Pos = 0x0
	// Bit mask of PAUSE field.
	TIMER_PAUSE_PAUSE_Msk = 0x1
	// Bit PAUSE.
	TIMER_PAUSE_PAUSE = 0x1

	// INTR: Raw Interrupts
	// Position of ALARM_3 field.
	TIMER_INTR_ALARM_3_Pos = 0x3
	// Bit mask of ALARM_3 field.
	TIMER_INTR_ALARM_3_Msk = 0x8
	// Bit ALARM_3.
	TIMER_INTR_ALARM_3 = 0x8
	// Position of ALARM_2 field.
	TIMER_INTR_ALARM_2_Pos = 0x2
	// Bit mask of ALARM_2 field.
	TIMER_INTR_ALARM_2_Msk = 0x4
	// Bit ALARM_2.
	TIMER_INTR_ALARM_2 = 0x4
	// Position of ALARM_1 field.
	TIMER_INTR_ALARM_1_Pos = 0x1
	// Bit mask of ALARM_1 field.
	TIMER_INTR_ALARM_1_Msk = 0x2
	// Bit ALARM_1.
	TIMER_INTR_ALARM_1 = 0x2
	// Position of ALARM_0 field.
	TIMER_INTR_ALARM_0_Pos = 0x0
	// Bit mask of ALARM_0 field.
	TIMER_INTR_ALARM_0_Msk = 0x1
	// Bit ALARM_0.
	TIMER_INTR_ALARM_0 = 0x1

	// INTE: Interrupt Enable
	// Position of ALARM_3 field.
	TIMER_INTE_ALARM_3_Pos = 0x3
	// Bit mask of ALARM_3 field.
	TIMER_INTE_ALARM_3_Msk = 0x8
	// Bit ALARM_3.
	TIMER_INTE_ALARM_3 = 0x8
	// Position of ALARM_2 field.
	TIMER_INTE_ALARM_2_Pos = 0x2
	// Bit mask of ALARM_2 field.
	TIMER_INTE_ALARM_2_Msk = 0x4
	// Bit ALARM_2.
	TIMER_INTE_ALARM_2 = 0x4
	// Position of ALARM_1 field.
	TIMER_INTE_ALARM_1_Pos = 0x1
	// Bit mask of ALARM_1 field.
	TIMER_INTE_ALARM_1_Msk = 0x2
	// Bit ALARM_1.
	TIMER_INTE_ALARM_1 = 0x2
	// Position of ALARM_0 field.
	TIMER_INTE_ALARM_0_Pos = 0x0
	// Bit mask of ALARM_0 field.
	TIMER_INTE_ALARM_0_Msk = 0x1
	// Bit ALARM_0.
	TIMER_INTE_ALARM_0 = 0x1

	// INTF: Interrupt Force
	// Position of ALARM_3 field.
	TIMER_INTF_ALARM_3_Pos = 0x3
	// Bit mask of ALARM_3 field.
	TIMER_INTF_ALARM_3_Msk = 0x8
	// Bit ALARM_3.
	TIMER_INTF_ALARM_3 = 0x8
	// Position of ALARM_2 field.
	TIMER_INTF_ALARM_2_Pos = 0x2
	// Bit mask of ALARM_2 field.
	TIMER_INTF_ALARM_2_Msk = 0x4
	// Bit ALARM_2.
	TIMER_INTF_ALARM_2 = 0x4
	// Position of ALARM_1 field.
	TIMER_INTF_ALARM_1_Pos = 0x1
	// Bit mask of ALARM_1 field.
	TIMER_INTF_ALARM_1_Msk = 0x2
	// Bit ALARM_1.
	TIMER_INTF_ALARM_1 = 0x2
	// Position of ALARM_0 field.
	TIMER_INTF_ALARM_0_Pos = 0x0
	// Bit mask of ALARM_0 field.
	TIMER_INTF_ALARM_0_Msk = 0x1
	// Bit ALARM_0.
	TIMER_INTF_ALARM_0 = 0x1

	// INTS: Interrupt status after masking & forcing
	// Position of ALARM_3 field.
	TIMER_INTS_ALARM_3_Pos = 0x3
	// Bit mask of ALARM_3 field.
	TIMER_INTS_ALARM_3_Msk = 0x8
	// Bit ALARM_3.
	TIMER_INTS_ALARM_3 = 0x8
	// Position of ALARM_2 field.
	TIMER_INTS_ALARM_2_Pos = 0x2
	// Bit mask of ALARM_2 field.
	TIMER_INTS_ALARM_2_Msk = 0x4
	// Bit ALARM_2.
	TIMER_INTS_ALARM_2 = 0x4
	// Position of ALARM_1 field.
	TIMER_INTS_ALARM_1_Pos = 0x1
	// Bit mask of ALARM_1 field.
	TIMER_INTS_ALARM_1_Msk = 0x2
	// Bit ALARM_1.
	TIMER_INTS_ALARM_1 = 0x2
	// Position of ALARM_0 field.
	TIMER_INTS_ALARM_0_Pos = 0x0
	// Bit mask of ALARM_0 field.
	TIMER_INTS_ALARM_0_Msk = 0x1
	// Bit ALARM_0.
	TIMER_INTS_ALARM_0 = 0x1
)

// Constants for WATCHDOG
const (
	// CTRL
	// Watchdog control
	// The rst_wdsel register determines which subsystems are reset when the watchdog is triggered.
	// The watchdog can be triggered in software.
	// Position of TRIGGER field.
	WATCHDOG_CTRL_TRIGGER_Pos = 0x1f
	// Bit mask of TRIGGER field.
	WATCHDOG_CTRL_TRIGGER_Msk = 0x80000000
	// Bit TRIGGER.
	WATCHDOG_CTRL_TRIGGER = 0x80000000
	// Position of ENABLE field.
	WATCHDOG_CTRL_ENABLE_Pos = 0x1e
	// Bit mask of ENABLE field.
	WATCHDOG_CTRL_ENABLE_Msk = 0x40000000
	// Bit ENABLE.
	WATCHDOG_CTRL_ENABLE = 0x40000000
	// Position of PAUSE_DBG1 field.
	WATCHDOG_CTRL_PAUSE_DBG1_Pos = 0x1a
	// Bit mask of PAUSE_DBG1 field.
	WATCHDOG_CTRL_PAUSE_DBG1_Msk = 0x4000000
	// Bit PAUSE_DBG1.
	WATCHDOG_CTRL_PAUSE_DBG1 = 0x4000000
	// Position of PAUSE_DBG0 field.
	WATCHDOG_CTRL_PAUSE_DBG0_Pos = 0x19
	// Bit mask of PAUSE_DBG0 field.
	WATCHDOG_CTRL_PAUSE_DBG0_Msk = 0x2000000
	// Bit PAUSE_DBG0.
	WATCHDOG_CTRL_PAUSE_DBG0 = 0x2000000
	// Position of PAUSE_JTAG field.
	WATCHDOG_CTRL_PAUSE_JTAG_Pos = 0x18
	// Bit mask of PAUSE_JTAG field.
	WATCHDOG_CTRL_PAUSE_JTAG_Msk = 0x1000000
	// Bit PAUSE_JTAG.
	WATCHDOG_CTRL_PAUSE_JTAG = 0x1000000
	// Position of TIME field.
	WATCHDOG_CTRL_TIME_Pos = 0x0
	// Bit mask of TIME field.
	WATCHDOG_CTRL_TIME_Msk = 0xffffff

	// LOAD: Load the watchdog timer. The maximum setting is 0xffffff which corresponds to 0xffffff / 2 ticks before triggering a watchdog reset (see errata RP2040-E1).
	// Position of LOAD field.
	WATCHDOG_LOAD_LOAD_Pos = 0x0
	// Bit mask of LOAD field.
	WATCHDOG_LOAD_LOAD_Msk = 0xffffff

	// REASON: Logs the reason for the last reset. Both bits are zero for the case of a hardware reset.
	// Position of FORCE field.
	WATCHDOG_REASON_FORCE_Pos = 0x1
	// Bit mask of FORCE field.
	WATCHDOG_REASON_FORCE_Msk = 0x2
	// Bit FORCE.
	WATCHDOG_REASON_FORCE = 0x2
	// Position of TIMER field.
	WATCHDOG_REASON_TIMER_Pos = 0x0
	// Bit mask of TIMER field.
	WATCHDOG_REASON_TIMER_Msk = 0x1
	// Bit TIMER.
	WATCHDOG_REASON_TIMER = 0x1

	// TICK: Controls the tick generator
	// Position of COUNT field.
	WATCHDOG_TICK_COUNT_Pos = 0xb
	// Bit mask of COUNT field.
	WATCHDOG_TICK_COUNT_Msk = 0xff800
	// Position of RUNNING field.
	WATCHDOG_TICK_RUNNING_Pos = 0xa
	// Bit mask of RUNNING field.
	WATCHDOG_TICK_RUNNING_Msk = 0x400
	// Bit RUNNING.
	WATCHDOG_TICK_RUNNING = 0x400
	// Position of ENABLE field.
	WATCHDOG_TICK_ENABLE_Pos = 0x9
	// Bit mask of ENABLE field.
	WATCHDOG_TICK_ENABLE_Msk = 0x200
	// Bit ENABLE.
	WATCHDOG_TICK_ENABLE = 0x200
	// Position of CYCLES field.
	WATCHDOG_TICK_CYCLES_Pos = 0x0
	// Bit mask of CYCLES field.
	WATCHDOG_TICK_CYCLES_Msk = 0x1ff
)

// Constants for RTC: Register block to control RTC
const (
	// CLKDIV_M1: Divider minus 1 for the 1 second counter. Safe to change the value when RTC is not enabled.
	// Position of CLKDIV_M1 field.
	RTC_CLKDIV_M1_CLKDIV_M1_Pos = 0x0
	// Bit mask of CLKDIV_M1 field.
	RTC_CLKDIV_M1_CLKDIV_M1_Msk = 0xffff

	// SETUP_0: RTC setup register 0
	// Position of YEAR field.
	RTC_SETUP_0_YEAR_Pos = 0xc
	// Bit mask of YEAR field.
	RTC_SETUP_0_YEAR_Msk = 0xfff000
	// Position of MONTH field.
	RTC_SETUP_0_MONTH_Pos = 0x8
	// Bit mask of MONTH field.
	RTC_SETUP_0_MONTH_Msk = 0xf00
	// Position of DAY field.
	RTC_SETUP_0_DAY_Pos = 0x0
	// Bit mask of DAY field.
	RTC_SETUP_0_DAY_Msk = 0x1f

	// SETUP_1: RTC setup register 1
	// Position of DOTW field.
	RTC_SETUP_1_DOTW_Pos = 0x18
	// Bit mask of DOTW field.
	RTC_SETUP_1_DOTW_Msk = 0x7000000
	// Position of HOUR field.
	RTC_SETUP_1_HOUR_Pos = 0x10
	// Bit mask of HOUR field.
	RTC_SETUP_1_HOUR_Msk = 0x1f0000
	// Position of MIN field.
	RTC_SETUP_1_MIN_Pos = 0x8
	// Bit mask of MIN field.
	RTC_SETUP_1_MIN_Msk = 0x3f00
	// Position of SEC field.
	RTC_SETUP_1_SEC_Pos = 0x0
	// Bit mask of SEC field.
	RTC_SETUP_1_SEC_Msk = 0x3f

	// CTRL: RTC Control and status
	// Position of FORCE_NOTLEAPYEAR field.
	RTC_CTRL_FORCE_NOTLEAPYEAR_Pos = 0x8
	// Bit mask of FORCE_NOTLEAPYEAR field.
	RTC_CTRL_FORCE_NOTLEAPYEAR_Msk = 0x100
	// Bit FORCE_NOTLEAPYEAR.
	RTC_CTRL_FORCE_NOTLEAPYEAR = 0x100
	// Position of LOAD field.
	RTC_CTRL_LOAD_Pos = 0x4
	// Bit mask of LOAD field.
	RTC_CTRL_LOAD_Msk = 0x10
	// Bit LOAD.
	RTC_CTRL_LOAD = 0x10
	// Position of RTC_ACTIVE field.
	RTC_CTRL_RTC_ACTIVE_Pos = 0x1
	// Bit mask of RTC_ACTIVE field.
	RTC_CTRL_RTC_ACTIVE_Msk = 0x2
	// Bit RTC_ACTIVE.
	RTC_CTRL_RTC_ACTIVE = 0x2
	// Position of RTC_ENABLE field.
	RTC_CTRL_RTC_ENABLE_Pos = 0x0
	// Bit mask of RTC_ENABLE field.
	RTC_CTRL_RTC_ENABLE_Msk = 0x1
	// Bit RTC_ENABLE.
	RTC_CTRL_RTC_ENABLE = 0x1

	// IRQ_SETUP_0: Interrupt setup register 0
	// Position of MATCH_ACTIVE field.
	RTC_IRQ_SETUP_0_MATCH_ACTIVE_Pos = 0x1d
	// Bit mask of MATCH_ACTIVE field.
	RTC_IRQ_SETUP_0_MATCH_ACTIVE_Msk = 0x20000000
	// Bit MATCH_ACTIVE.
	RTC_IRQ_SETUP_0_MATCH_ACTIVE = 0x20000000
	// Position of MATCH_ENA field.
	RTC_IRQ_SETUP_0_MATCH_ENA_Pos = 0x1c
	// Bit mask of MATCH_ENA field.
	RTC_IRQ_SETUP_0_MATCH_ENA_Msk = 0x10000000
	// Bit MATCH_ENA.
	RTC_IRQ_SETUP_0_MATCH_ENA = 0x10000000
	// Position of YEAR_ENA field.
	RTC_IRQ_SETUP_0_YEAR_ENA_Pos = 0x1a
	// Bit mask of YEAR_ENA field.
	RTC_IRQ_SETUP_0_YEAR_ENA_Msk = 0x4000000
	// Bit YEAR_ENA.
	RTC_IRQ_SETUP_0_YEAR_ENA = 0x4000000
	// Position of MONTH_ENA field.
	RTC_IRQ_SETUP_0_MONTH_ENA_Pos = 0x19
	// Bit mask of MONTH_ENA field.
	RTC_IRQ_SETUP_0_MONTH_ENA_Msk = 0x2000000
	// Bit MONTH_ENA.
	RTC_IRQ_SETUP_0_MONTH_ENA = 0x2000000
	// Position of DAY_ENA field.
	RTC_IRQ_SETUP_0_DAY_ENA_Pos = 0x18
	// Bit mask of DAY_ENA field.
	RTC_IRQ_SETUP_0_DAY_ENA_Msk = 0x1000000
	// Bit DAY_ENA.
	RTC_IRQ_SETUP_0_DAY_ENA = 0x1000000
	// Position of YEAR field.
	RTC_IRQ_SETUP_0_YEAR_Pos = 0xc
	// Bit mask of YEAR field.
	RTC_IRQ_SETUP_0_YEAR_Msk = 0xfff000
	// Position of MONTH field.
	RTC_IRQ_SETUP_0_MONTH_Pos = 0x8
	// Bit mask of MONTH field.
	RTC_IRQ_SETUP_0_MONTH_Msk = 0xf00
	// Position of DAY field.
	RTC_IRQ_SETUP_0_DAY_Pos = 0x0
	// Bit mask of DAY field.
	RTC_IRQ_SETUP_0_DAY_Msk = 0x1f

	// IRQ_SETUP_1: Interrupt setup register 1
	// Position of DOTW_ENA field.
	RTC_IRQ_SETUP_1_DOTW_ENA_Pos = 0x1f
	// Bit mask of DOTW_ENA field.
	RTC_IRQ_SETUP_1_DOTW_ENA_Msk = 0x80000000
	// Bit DOTW_ENA.
	RTC_IRQ_SETUP_1_DOTW_ENA = 0x80000000
	// Position of HOUR_ENA field.
	RTC_IRQ_SETUP_1_HOUR_ENA_Pos = 0x1e
	// Bit mask of HOUR_ENA field.
	RTC_IRQ_SETUP_1_HOUR_ENA_Msk = 0x40000000
	// Bit HOUR_ENA.
	RTC_IRQ_SETUP_1_HOUR_ENA = 0x40000000
	// Position of MIN_ENA field.
	RTC_IRQ_SETUP_1_MIN_ENA_Pos = 0x1d
	// Bit mask of MIN_ENA field.
	RTC_IRQ_SETUP_1_MIN_ENA_Msk = 0x20000000
	// Bit MIN_ENA.
	RTC_IRQ_SETUP_1_MIN_ENA = 0x20000000
	// Position of SEC_ENA field.
	RTC_IRQ_SETUP_1_SEC_ENA_Pos = 0x1c
	// Bit mask of SEC_ENA field.
	RTC_IRQ_SETUP_1_SEC_ENA_Msk = 0x10000000
	// Bit SEC_ENA.
	RTC_IRQ_SETUP_1_SEC_ENA = 0x10000000
	// Position of DOTW field.
	RTC_IRQ_SETUP_1_DOTW_Pos = 0x18
	// Bit mask of DOTW field.
	RTC_IRQ_SETUP_1_DOTW_Msk = 0x7000000
	// Position of HOUR field.
	RTC_IRQ_SETUP_1_HOUR_Pos = 0x10
	// Bit mask of HOUR field.
	RTC_IRQ_SETUP_1_HOUR_Msk = 0x1f0000
	// Position of MIN field.
	RTC_IRQ_SETUP_1_MIN_Pos = 0x8
	// Bit mask of MIN field.
	RTC_IRQ_SETUP_1_MIN_Msk = 0x3f00
	// Position of SEC field.
	RTC_IRQ_SETUP_1_SEC_Pos = 0x0
	// Bit mask of SEC field.
	RTC_IRQ_SETUP_1_SEC_Msk = 0x3f

	// RTC_1: RTC register 1.
	// Position of YEAR field.
	RTC_RTC_1_YEAR_Pos = 0xc
	// Bit mask of YEAR field.
	RTC_RTC_1_YEAR_Msk = 0xfff000
	// Position of MONTH field.
	RTC_RTC_1_MONTH_Pos = 0x8
	// Bit mask of MONTH field.
	RTC_RTC_1_MONTH_Msk = 0xf00
	// Position of DAY field.
	RTC_RTC_1_DAY_Pos = 0x0
	// Bit mask of DAY field.
	RTC_RTC_1_DAY_Msk = 0x1f

	// RTC_0
	// RTC register 0
	// Read this before RTC 1!
	// Position of DOTW field.
	RTC_RTC_0_DOTW_Pos = 0x18
	// Bit mask of DOTW field.
	RTC_RTC_0_DOTW_Msk = 0x7000000
	// Position of HOUR field.
	RTC_RTC_0_HOUR_Pos = 0x10
	// Bit mask of HOUR field.
	RTC_RTC_0_HOUR_Msk = 0x1f0000
	// Position of MIN field.
	RTC_RTC_0_MIN_Pos = 0x8
	// Bit mask of MIN field.
	RTC_RTC_0_MIN_Msk = 0x3f00
	// Position of SEC field.
	RTC_RTC_0_SEC_Pos = 0x0
	// Bit mask of SEC field.
	RTC_RTC_0_SEC_Msk = 0x3f

	// INTR: Raw Interrupts
	// Position of RTC field.
	RTC_INTR_RTC_Pos = 0x0
	// Bit mask of RTC field.
	RTC_INTR_RTC_Msk = 0x1
	// Bit RTC.
	RTC_INTR_RTC = 0x1

	// INTE: Interrupt Enable
	// Position of RTC field.
	RTC_INTE_RTC_Pos = 0x0
	// Bit mask of RTC field.
	RTC_INTE_RTC_Msk = 0x1
	// Bit RTC.
	RTC_INTE_RTC = 0x1

	// INTF: Interrupt Force
	// Position of RTC field.
	RTC_INTF_RTC_Pos = 0x0
	// Bit mask of RTC field.
	RTC_INTF_RTC_Msk = 0x1
	// Bit RTC.
	RTC_INTF_RTC = 0x1

	// INTS: Interrupt status after masking & forcing
	// Position of RTC field.
	RTC_INTS_RTC_Pos = 0x0
	// Bit mask of RTC field.
	RTC_INTS_RTC_Msk = 0x1
	// Bit RTC.
	RTC_INTS_RTC = 0x1
)

// Constants for ROSC
const (
	// CTRL: Ring Oscillator control
	// Position of ENABLE field.
	ROSC_CTRL_ENABLE_Pos = 0xc
	// Bit mask of ENABLE field.
	ROSC_CTRL_ENABLE_Msk     = 0xfff000
	ROSC_CTRL_ENABLE_DISABLE = 0xd1e
	ROSC_CTRL_ENABLE_ENABLE  = 0xfab
	// Position of FREQ_RANGE field.
	ROSC_CTRL_FREQ_RANGE_Pos = 0x0
	// Bit mask of FREQ_RANGE field.
	ROSC_CTRL_FREQ_RANGE_Msk     = 0xfff
	ROSC_CTRL_FREQ_RANGE_LOW     = 0xfa4
	ROSC_CTRL_FREQ_RANGE_MEDIUM  = 0xfa5
	ROSC_CTRL_FREQ_RANGE_HIGH    = 0xfa7
	ROSC_CTRL_FREQ_RANGE_TOOHIGH = 0xfa6

	// FREQA
	// The FREQA & FREQB registers control the frequency by controlling the drive strength of each stage
	// The drive strength has 4 levels determined by the number of bits set
	// Increasing the number of bits set increases the drive strength and increases the oscillation frequency
	// 0 bits set is the default drive strength
	// 1 bit set doubles the drive strength
	// 2 bits set triples drive strength
	// 3 bits set quadruples drive strength
	// Position of PASSWD field.
	ROSC_FREQA_PASSWD_Pos = 0x10
	// Bit mask of PASSWD field.
	ROSC_FREQA_PASSWD_Msk  = 0xffff0000
	ROSC_FREQA_PASSWD_PASS = 0x9696
	// Position of DS3 field.
	ROSC_FREQA_DS3_Pos = 0xc
	// Bit mask of DS3 field.
	ROSC_FREQA_DS3_Msk = 0x7000
	// Position of DS2 field.
	ROSC_FREQA_DS2_Pos = 0x8
	// Bit mask of DS2 field.
	ROSC_FREQA_DS2_Msk = 0x700
	// Position of DS1 field.
	ROSC_FREQA_DS1_Pos = 0x4
	// Bit mask of DS1 field.
	ROSC_FREQA_DS1_Msk = 0x70
	// Position of DS0 field.
	ROSC_FREQA_DS0_Pos = 0x0
	// Bit mask of DS0 field.
	ROSC_FREQA_DS0_Msk = 0x7

	// FREQB: For a detailed description see freqa register
	// Position of PASSWD field.
	ROSC_FREQB_PASSWD_Pos = 0x10
	// Bit mask of PASSWD field.
	ROSC_FREQB_PASSWD_Msk  = 0xffff0000
	ROSC_FREQB_PASSWD_PASS = 0x9696
	// Position of DS7 field.
	ROSC_FREQB_DS7_Pos = 0xc
	// Bit mask of DS7 field.
	ROSC_FREQB_DS7_Msk = 0x7000
	// Position of DS6 field.
	ROSC_FREQB_DS6_Pos = 0x8
	// Bit mask of DS6 field.
	ROSC_FREQB_DS6_Msk = 0x700
	// Position of DS5 field.
	ROSC_FREQB_DS5_Pos = 0x4
	// Bit mask of DS5 field.
	ROSC_FREQB_DS5_Msk = 0x70
	// Position of DS4 field.
	ROSC_FREQB_DS4_Pos = 0x0
	// Bit mask of DS4 field.
	ROSC_FREQB_DS4_Msk = 0x7

	// DIV: Controls the output divider
	// Position of DIV field.
	ROSC_DIV_DIV_Pos = 0x0
	// Bit mask of DIV field.
	ROSC_DIV_DIV_Msk  = 0xfff
	ROSC_DIV_DIV_PASS = 0xaa0

	// PHASE: Controls the phase shifted output
	// Position of PASSWD field.
	ROSC_PHASE_PASSWD_Pos = 0x4
	// Bit mask of PASSWD field.
	ROSC_PHASE_PASSWD_Msk = 0xff0
	// Position of ENABLE field.
	ROSC_PHASE_ENABLE_Pos = 0x3
	// Bit mask of ENABLE field.
	ROSC_PHASE_ENABLE_Msk = 0x8
	// Bit ENABLE.
	ROSC_PHASE_ENABLE = 0x8
	// Position of FLIP field.
	ROSC_PHASE_FLIP_Pos = 0x2
	// Bit mask of FLIP field.
	ROSC_PHASE_FLIP_Msk = 0x4
	// Bit FLIP.
	ROSC_PHASE_FLIP = 0x4
	// Position of SHIFT field.
	ROSC_PHASE_SHIFT_Pos = 0x0
	// Bit mask of SHIFT field.
	ROSC_PHASE_SHIFT_Msk = 0x3

	// STATUS: Ring Oscillator Status
	// Position of STABLE field.
	ROSC_STATUS_STABLE_Pos = 0x1f
	// Bit mask of STABLE field.
	ROSC_STATUS_STABLE_Msk = 0x80000000
	// Bit STABLE.
	ROSC_STATUS_STABLE = 0x80000000
	// Position of BADWRITE field.
	ROSC_STATUS_BADWRITE_Pos = 0x18
	// Bit mask of BADWRITE field.
	ROSC_STATUS_BADWRITE_Msk = 0x1000000
	// Bit BADWRITE.
	ROSC_STATUS_BADWRITE = 0x1000000
	// Position of DIV_RUNNING field.
	ROSC_STATUS_DIV_RUNNING_Pos = 0x10
	// Bit mask of DIV_RUNNING field.
	ROSC_STATUS_DIV_RUNNING_Msk = 0x10000
	// Bit DIV_RUNNING.
	ROSC_STATUS_DIV_RUNNING = 0x10000
	// Position of ENABLED field.
	ROSC_STATUS_ENABLED_Pos = 0xc
	// Bit mask of ENABLED field.
	ROSC_STATUS_ENABLED_Msk = 0x1000
	// Bit ENABLED.
	ROSC_STATUS_ENABLED = 0x1000

	// RANDOMBIT: This just reads the state of the oscillator output so randomness is compromised if the ring oscillator is stopped or run at a harmonic of the bus frequency
	// Position of RANDOMBIT field.
	ROSC_RANDOMBIT_RANDOMBIT_Pos = 0x0
	// Bit mask of RANDOMBIT field.
	ROSC_RANDOMBIT_RANDOMBIT_Msk = 0x1
	// Bit RANDOMBIT.
	ROSC_RANDOMBIT_RANDOMBIT = 0x1

	// COUNT
	// A down counter running at the ROSC frequency which counts to zero and stops.
	// To start the counter write a non-zero value.
	// Can be used for short software pauses when setting up time sensitive hardware.
	// Position of COUNT field.
	ROSC_COUNT_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	ROSC_COUNT_COUNT_Msk = 0xff
)

// Constants for VREG_AND_CHIP_RESET: control and status for on-chip voltage regulator and chip level reset subsystem
const (
	// VREG: Voltage regulator control and status
	// Position of ROK field.
	VREG_AND_CHIP_RESET_VREG_ROK_Pos = 0xc
	// Bit mask of ROK field.
	VREG_AND_CHIP_RESET_VREG_ROK_Msk = 0x1000
	// Bit ROK.
	VREG_AND_CHIP_RESET_VREG_ROK = 0x1000
	// Position of VSEL field.
	VREG_AND_CHIP_RESET_VREG_VSEL_Pos = 0x4
	// Bit mask of VSEL field.
	VREG_AND_CHIP_RESET_VREG_VSEL_Msk = 0xf0
	// Position of HIZ field.
	VREG_AND_CHIP_RESET_VREG_HIZ_Pos = 0x1
	// Bit mask of HIZ field.
	VREG_AND_CHIP_RESET_VREG_HIZ_Msk = 0x2
	// Bit HIZ.
	VREG_AND_CHIP_RESET_VREG_HIZ = 0x2
	// Position of EN field.
	VREG_AND_CHIP_RESET_VREG_EN_Pos = 0x0
	// Bit mask of EN field.
	VREG_AND_CHIP_RESET_VREG_EN_Msk = 0x1
	// Bit EN.
	VREG_AND_CHIP_RESET_VREG_EN = 0x1

	// BOD: brown-out detection control
	// Position of VSEL field.
	VREG_AND_CHIP_RESET_BOD_VSEL_Pos = 0x4
	// Bit mask of VSEL field.
	VREG_AND_CHIP_RESET_BOD_VSEL_Msk = 0xf0
	// Position of EN field.
	VREG_AND_CHIP_RESET_BOD_EN_Pos = 0x0
	// Bit mask of EN field.
	VREG_AND_CHIP_RESET_BOD_EN_Msk = 0x1
	// Bit EN.
	VREG_AND_CHIP_RESET_BOD_EN = 0x1

	// CHIP_RESET: Chip reset control and status
	// Position of PSM_RESTART_FLAG field.
	VREG_AND_CHIP_RESET_CHIP_RESET_PSM_RESTART_FLAG_Pos = 0x18
	// Bit mask of PSM_RESTART_FLAG field.
	VREG_AND_CHIP_RESET_CHIP_RESET_PSM_RESTART_FLAG_Msk = 0x1000000
	// Bit PSM_RESTART_FLAG.
	VREG_AND_CHIP_RESET_CHIP_RESET_PSM_RESTART_FLAG = 0x1000000
	// Position of HAD_PSM_RESTART field.
	VREG_AND_CHIP_RESET_CHIP_RESET_HAD_PSM_RESTART_Pos = 0x14
	// Bit mask of HAD_PSM_RESTART field.
	VREG_AND_CHIP_RESET_CHIP_RESET_HAD_PSM_RESTART_Msk = 0x100000
	// Bit HAD_PSM_RESTART.
	VREG_AND_CHIP_RESET_CHIP_RESET_HAD_PSM_RESTART = 0x100000
	// Position of HAD_RUN field.
	VREG_AND_CHIP_RESET_CHIP_RESET_HAD_RUN_Pos = 0x10
	// Bit mask of HAD_RUN field.
	VREG_AND_CHIP_RESET_CHIP_RESET_HAD_RUN_Msk = 0x10000
	// Bit HAD_RUN.
	VREG_AND_CHIP_RESET_CHIP_RESET_HAD_RUN = 0x10000
	// Position of HAD_POR field.
	VREG_AND_CHIP_RESET_CHIP_RESET_HAD_POR_Pos = 0x8
	// Bit mask of HAD_POR field.
	VREG_AND_CHIP_RESET_CHIP_RESET_HAD_POR_Msk = 0x100
	// Bit HAD_POR.
	VREG_AND_CHIP_RESET_CHIP_RESET_HAD_POR = 0x100
)

// Constants for TBMAN: Testbench manager. Allows the programmer to know what platform their software is running on.
const (
	// PLATFORM: Indicates the type of platform in use
	// Position of FPGA field.
	TBMAN_PLATFORM_FPGA_Pos = 0x1
	// Bit mask of FPGA field.
	TBMAN_PLATFORM_FPGA_Msk = 0x2
	// Bit FPGA.
	TBMAN_PLATFORM_FPGA = 0x2
	// Position of ASIC field.
	TBMAN_PLATFORM_ASIC_Pos = 0x0
	// Bit mask of ASIC field.
	TBMAN_PLATFORM_ASIC_Msk = 0x1
	// Bit ASIC.
	TBMAN_PLATFORM_ASIC = 0x1
)

// Constants for DMA: DMA with separate read and write masters
const (
	// CH0_CTRL_TRIG: DMA Channel 0 Control and Status
	// Position of AHB_ERROR field.
	DMA_CH0_CTRL_TRIG_AHB_ERROR_Pos = 0x1f
	// Bit mask of AHB_ERROR field.
	DMA_CH0_CTRL_TRIG_AHB_ERROR_Msk = 0x80000000
	// Bit AHB_ERROR.
	DMA_CH0_CTRL_TRIG_AHB_ERROR = 0x80000000
	// Position of READ_ERROR field.
	DMA_CH0_CTRL_TRIG_READ_ERROR_Pos = 0x1e
	// Bit mask of READ_ERROR field.
	DMA_CH0_CTRL_TRIG_READ_ERROR_Msk = 0x40000000
	// Bit READ_ERROR.
	DMA_CH0_CTRL_TRIG_READ_ERROR = 0x40000000
	// Position of WRITE_ERROR field.
	DMA_CH0_CTRL_TRIG_WRITE_ERROR_Pos = 0x1d
	// Bit mask of WRITE_ERROR field.
	DMA_CH0_CTRL_TRIG_WRITE_ERROR_Msk = 0x20000000
	// Bit WRITE_ERROR.
	DMA_CH0_CTRL_TRIG_WRITE_ERROR = 0x20000000
	// Position of BUSY field.
	DMA_CH0_CTRL_TRIG_BUSY_Pos = 0x18
	// Bit mask of BUSY field.
	DMA_CH0_CTRL_TRIG_BUSY_Msk = 0x1000000
	// Bit BUSY.
	DMA_CH0_CTRL_TRIG_BUSY = 0x1000000
	// Position of SNIFF_EN field.
	DMA_CH0_CTRL_TRIG_SNIFF_EN_Pos = 0x17
	// Bit mask of SNIFF_EN field.
	DMA_CH0_CTRL_TRIG_SNIFF_EN_Msk = 0x800000
	// Bit SNIFF_EN.
	DMA_CH0_CTRL_TRIG_SNIFF_EN = 0x800000
	// Position of BSWAP field.
	DMA_CH0_CTRL_TRIG_BSWAP_Pos = 0x16
	// Bit mask of BSWAP field.
	DMA_CH0_CTRL_TRIG_BSWAP_Msk = 0x400000
	// Bit BSWAP.
	DMA_CH0_CTRL_TRIG_BSWAP = 0x400000
	// Position of IRQ_QUIET field.
	DMA_CH0_CTRL_TRIG_IRQ_QUIET_Pos = 0x15
	// Bit mask of IRQ_QUIET field.
	DMA_CH0_CTRL_TRIG_IRQ_QUIET_Msk = 0x200000
	// Bit IRQ_QUIET.
	DMA_CH0_CTRL_TRIG_IRQ_QUIET = 0x200000
	// Position of TREQ_SEL field.
	DMA_CH0_CTRL_TRIG_TREQ_SEL_Pos = 0xf
	// Bit mask of TREQ_SEL field.
	DMA_CH0_CTRL_TRIG_TREQ_SEL_Msk = 0x1f8000
	// Select Timer 0 as TREQ
	DMA_CH0_CTRL_TRIG_TREQ_SEL_TIMER0 = 0x3b
	// Select Timer 1 as TREQ
	DMA_CH0_CTRL_TRIG_TREQ_SEL_TIMER1 = 0x3c
	// Select Timer 2 as TREQ (Optional)
	DMA_CH0_CTRL_TRIG_TREQ_SEL_TIMER2 = 0x3d
	// Select Timer 3 as TREQ (Optional)
	DMA_CH0_CTRL_TRIG_TREQ_SEL_TIMER3 = 0x3e
	// Permanent request, for unpaced transfers.
	DMA_CH0_CTRL_TRIG_TREQ_SEL_PERMANENT = 0x3f
	// Position of CHAIN_TO field.
	DMA_CH0_CTRL_TRIG_CHAIN_TO_Pos = 0xb
	// Bit mask of CHAIN_TO field.
	DMA_CH0_CTRL_TRIG_CHAIN_TO_Msk = 0x7800
	// Position of RING_SEL field.
	DMA_CH0_CTRL_TRIG_RING_SEL_Pos = 0xa
	// Bit mask of RING_SEL field.
	DMA_CH0_CTRL_TRIG_RING_SEL_Msk = 0x400
	// Bit RING_SEL.
	DMA_CH0_CTRL_TRIG_RING_SEL = 0x400
	// Position of RING_SIZE field.
	DMA_CH0_CTRL_TRIG_RING_SIZE_Pos = 0x6
	// Bit mask of RING_SIZE field.
	DMA_CH0_CTRL_TRIG_RING_SIZE_Msk       = 0x3c0
	DMA_CH0_CTRL_TRIG_RING_SIZE_RING_NONE = 0x0
	// Position of INCR_WRITE field.
	DMA_CH0_CTRL_TRIG_INCR_WRITE_Pos = 0x5
	// Bit mask of INCR_WRITE field.
	DMA_CH0_CTRL_TRIG_INCR_WRITE_Msk = 0x20
	// Bit INCR_WRITE.
	DMA_CH0_CTRL_TRIG_INCR_WRITE = 0x20
	// Position of INCR_READ field.
	DMA_CH0_CTRL_TRIG_INCR_READ_Pos = 0x4
	// Bit mask of INCR_READ field.
	DMA_CH0_CTRL_TRIG_INCR_READ_Msk = 0x10
	// Bit INCR_READ.
	DMA_CH0_CTRL_TRIG_INCR_READ = 0x10
	// Position of DATA_SIZE field.
	DMA_CH0_CTRL_TRIG_DATA_SIZE_Pos = 0x2
	// Bit mask of DATA_SIZE field.
	DMA_CH0_CTRL_TRIG_DATA_SIZE_Msk           = 0xc
	DMA_CH0_CTRL_TRIG_DATA_SIZE_SIZE_BYTE     = 0x0
	DMA_CH0_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 0x1
	DMA_CH0_CTRL_TRIG_DATA_SIZE_SIZE_WORD     = 0x2
	// Position of HIGH_PRIORITY field.
	DMA_CH0_CTRL_TRIG_HIGH_PRIORITY_Pos = 0x1
	// Bit mask of HIGH_PRIORITY field.
	DMA_CH0_CTRL_TRIG_HIGH_PRIORITY_Msk = 0x2
	// Bit HIGH_PRIORITY.
	DMA_CH0_CTRL_TRIG_HIGH_PRIORITY = 0x2
	// Position of EN field.
	DMA_CH0_CTRL_TRIG_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CH0_CTRL_TRIG_EN_Msk = 0x1
	// Bit EN.
	DMA_CH0_CTRL_TRIG_EN = 0x1

	// CH1_CTRL_TRIG: DMA Channel 1 Control and Status
	// Position of AHB_ERROR field.
	DMA_CH1_CTRL_TRIG_AHB_ERROR_Pos = 0x1f
	// Bit mask of AHB_ERROR field.
	DMA_CH1_CTRL_TRIG_AHB_ERROR_Msk = 0x80000000
	// Bit AHB_ERROR.
	DMA_CH1_CTRL_TRIG_AHB_ERROR = 0x80000000
	// Position of READ_ERROR field.
	DMA_CH1_CTRL_TRIG_READ_ERROR_Pos = 0x1e
	// Bit mask of READ_ERROR field.
	DMA_CH1_CTRL_TRIG_READ_ERROR_Msk = 0x40000000
	// Bit READ_ERROR.
	DMA_CH1_CTRL_TRIG_READ_ERROR = 0x40000000
	// Position of WRITE_ERROR field.
	DMA_CH1_CTRL_TRIG_WRITE_ERROR_Pos = 0x1d
	// Bit mask of WRITE_ERROR field.
	DMA_CH1_CTRL_TRIG_WRITE_ERROR_Msk = 0x20000000
	// Bit WRITE_ERROR.
	DMA_CH1_CTRL_TRIG_WRITE_ERROR = 0x20000000
	// Position of BUSY field.
	DMA_CH1_CTRL_TRIG_BUSY_Pos = 0x18
	// Bit mask of BUSY field.
	DMA_CH1_CTRL_TRIG_BUSY_Msk = 0x1000000
	// Bit BUSY.
	DMA_CH1_CTRL_TRIG_BUSY = 0x1000000
	// Position of SNIFF_EN field.
	DMA_CH1_CTRL_TRIG_SNIFF_EN_Pos = 0x17
	// Bit mask of SNIFF_EN field.
	DMA_CH1_CTRL_TRIG_SNIFF_EN_Msk = 0x800000
	// Bit SNIFF_EN.
	DMA_CH1_CTRL_TRIG_SNIFF_EN = 0x800000
	// Position of BSWAP field.
	DMA_CH1_CTRL_TRIG_BSWAP_Pos = 0x16
	// Bit mask of BSWAP field.
	DMA_CH1_CTRL_TRIG_BSWAP_Msk = 0x400000
	// Bit BSWAP.
	DMA_CH1_CTRL_TRIG_BSWAP = 0x400000
	// Position of IRQ_QUIET field.
	DMA_CH1_CTRL_TRIG_IRQ_QUIET_Pos = 0x15
	// Bit mask of IRQ_QUIET field.
	DMA_CH1_CTRL_TRIG_IRQ_QUIET_Msk = 0x200000
	// Bit IRQ_QUIET.
	DMA_CH1_CTRL_TRIG_IRQ_QUIET = 0x200000
	// Position of TREQ_SEL field.
	DMA_CH1_CTRL_TRIG_TREQ_SEL_Pos = 0xf
	// Bit mask of TREQ_SEL field.
	DMA_CH1_CTRL_TRIG_TREQ_SEL_Msk = 0x1f8000
	// Select Timer 0 as TREQ
	DMA_CH1_CTRL_TRIG_TREQ_SEL_TIMER0 = 0x3b
	// Select Timer 1 as TREQ
	DMA_CH1_CTRL_TRIG_TREQ_SEL_TIMER1 = 0x3c
	// Select Timer 2 as TREQ (Optional)
	DMA_CH1_CTRL_TRIG_TREQ_SEL_TIMER2 = 0x3d
	// Select Timer 3 as TREQ (Optional)
	DMA_CH1_CTRL_TRIG_TREQ_SEL_TIMER3 = 0x3e
	// Permanent request, for unpaced transfers.
	DMA_CH1_CTRL_TRIG_TREQ_SEL_PERMANENT = 0x3f
	// Position of CHAIN_TO field.
	DMA_CH1_CTRL_TRIG_CHAIN_TO_Pos = 0xb
	// Bit mask of CHAIN_TO field.
	DMA_CH1_CTRL_TRIG_CHAIN_TO_Msk = 0x7800
	// Position of RING_SEL field.
	DMA_CH1_CTRL_TRIG_RING_SEL_Pos = 0xa
	// Bit mask of RING_SEL field.
	DMA_CH1_CTRL_TRIG_RING_SEL_Msk = 0x400
	// Bit RING_SEL.
	DMA_CH1_CTRL_TRIG_RING_SEL = 0x400
	// Position of RING_SIZE field.
	DMA_CH1_CTRL_TRIG_RING_SIZE_Pos = 0x6
	// Bit mask of RING_SIZE field.
	DMA_CH1_CTRL_TRIG_RING_SIZE_Msk       = 0x3c0
	DMA_CH1_CTRL_TRIG_RING_SIZE_RING_NONE = 0x0
	// Position of INCR_WRITE field.
	DMA_CH1_CTRL_TRIG_INCR_WRITE_Pos = 0x5
	// Bit mask of INCR_WRITE field.
	DMA_CH1_CTRL_TRIG_INCR_WRITE_Msk = 0x20
	// Bit INCR_WRITE.
	DMA_CH1_CTRL_TRIG_INCR_WRITE = 0x20
	// Position of INCR_READ field.
	DMA_CH1_CTRL_TRIG_INCR_READ_Pos = 0x4
	// Bit mask of INCR_READ field.
	DMA_CH1_CTRL_TRIG_INCR_READ_Msk = 0x10
	// Bit INCR_READ.
	DMA_CH1_CTRL_TRIG_INCR_READ = 0x10
	// Position of DATA_SIZE field.
	DMA_CH1_CTRL_TRIG_DATA_SIZE_Pos = 0x2
	// Bit mask of DATA_SIZE field.
	DMA_CH1_CTRL_TRIG_DATA_SIZE_Msk           = 0xc
	DMA_CH1_CTRL_TRIG_DATA_SIZE_SIZE_BYTE     = 0x0
	DMA_CH1_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 0x1
	DMA_CH1_CTRL_TRIG_DATA_SIZE_SIZE_WORD     = 0x2
	// Position of HIGH_PRIORITY field.
	DMA_CH1_CTRL_TRIG_HIGH_PRIORITY_Pos = 0x1
	// Bit mask of HIGH_PRIORITY field.
	DMA_CH1_CTRL_TRIG_HIGH_PRIORITY_Msk = 0x2
	// Bit HIGH_PRIORITY.
	DMA_CH1_CTRL_TRIG_HIGH_PRIORITY = 0x2
	// Position of EN field.
	DMA_CH1_CTRL_TRIG_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CH1_CTRL_TRIG_EN_Msk = 0x1
	// Bit EN.
	DMA_CH1_CTRL_TRIG_EN = 0x1

	// CH2_CTRL_TRIG: DMA Channel 2 Control and Status
	// Position of AHB_ERROR field.
	DMA_CH2_CTRL_TRIG_AHB_ERROR_Pos = 0x1f
	// Bit mask of AHB_ERROR field.
	DMA_CH2_CTRL_TRIG_AHB_ERROR_Msk = 0x80000000
	// Bit AHB_ERROR.
	DMA_CH2_CTRL_TRIG_AHB_ERROR = 0x80000000
	// Position of READ_ERROR field.
	DMA_CH2_CTRL_TRIG_READ_ERROR_Pos = 0x1e
	// Bit mask of READ_ERROR field.
	DMA_CH2_CTRL_TRIG_READ_ERROR_Msk = 0x40000000
	// Bit READ_ERROR.
	DMA_CH2_CTRL_TRIG_READ_ERROR = 0x40000000
	// Position of WRITE_ERROR field.
	DMA_CH2_CTRL_TRIG_WRITE_ERROR_Pos = 0x1d
	// Bit mask of WRITE_ERROR field.
	DMA_CH2_CTRL_TRIG_WRITE_ERROR_Msk = 0x20000000
	// Bit WRITE_ERROR.
	DMA_CH2_CTRL_TRIG_WRITE_ERROR = 0x20000000
	// Position of BUSY field.
	DMA_CH2_CTRL_TRIG_BUSY_Pos = 0x18
	// Bit mask of BUSY field.
	DMA_CH2_CTRL_TRIG_BUSY_Msk = 0x1000000
	// Bit BUSY.
	DMA_CH2_CTRL_TRIG_BUSY = 0x1000000
	// Position of SNIFF_EN field.
	DMA_CH2_CTRL_TRIG_SNIFF_EN_Pos = 0x17
	// Bit mask of SNIFF_EN field.
	DMA_CH2_CTRL_TRIG_SNIFF_EN_Msk = 0x800000
	// Bit SNIFF_EN.
	DMA_CH2_CTRL_TRIG_SNIFF_EN = 0x800000
	// Position of BSWAP field.
	DMA_CH2_CTRL_TRIG_BSWAP_Pos = 0x16
	// Bit mask of BSWAP field.
	DMA_CH2_CTRL_TRIG_BSWAP_Msk = 0x400000
	// Bit BSWAP.
	DMA_CH2_CTRL_TRIG_BSWAP = 0x400000
	// Position of IRQ_QUIET field.
	DMA_CH2_CTRL_TRIG_IRQ_QUIET_Pos = 0x15
	// Bit mask of IRQ_QUIET field.
	DMA_CH2_CTRL_TRIG_IRQ_QUIET_Msk = 0x200000
	// Bit IRQ_QUIET.
	DMA_CH2_CTRL_TRIG_IRQ_QUIET = 0x200000
	// Position of TREQ_SEL field.
	DMA_CH2_CTRL_TRIG_TREQ_SEL_Pos = 0xf
	// Bit mask of TREQ_SEL field.
	DMA_CH2_CTRL_TRIG_TREQ_SEL_Msk = 0x1f8000
	// Select Timer 0 as TREQ
	DMA_CH2_CTRL_TRIG_TREQ_SEL_TIMER0 = 0x3b
	// Select Timer 1 as TREQ
	DMA_CH2_CTRL_TRIG_TREQ_SEL_TIMER1 = 0x3c
	// Select Timer 2 as TREQ (Optional)
	DMA_CH2_CTRL_TRIG_TREQ_SEL_TIMER2 = 0x3d
	// Select Timer 3 as TREQ (Optional)
	DMA_CH2_CTRL_TRIG_TREQ_SEL_TIMER3 = 0x3e
	// Permanent request, for unpaced transfers.
	DMA_CH2_CTRL_TRIG_TREQ_SEL_PERMANENT = 0x3f
	// Position of CHAIN_TO field.
	DMA_CH2_CTRL_TRIG_CHAIN_TO_Pos = 0xb
	// Bit mask of CHAIN_TO field.
	DMA_CH2_CTRL_TRIG_CHAIN_TO_Msk = 0x7800
	// Position of RING_SEL field.
	DMA_CH2_CTRL_TRIG_RING_SEL_Pos = 0xa
	// Bit mask of RING_SEL field.
	DMA_CH2_CTRL_TRIG_RING_SEL_Msk = 0x400
	// Bit RING_SEL.
	DMA_CH2_CTRL_TRIG_RING_SEL = 0x400
	// Position of RING_SIZE field.
	DMA_CH2_CTRL_TRIG_RING_SIZE_Pos = 0x6
	// Bit mask of RING_SIZE field.
	DMA_CH2_CTRL_TRIG_RING_SIZE_Msk       = 0x3c0
	DMA_CH2_CTRL_TRIG_RING_SIZE_RING_NONE = 0x0
	// Position of INCR_WRITE field.
	DMA_CH2_CTRL_TRIG_INCR_WRITE_Pos = 0x5
	// Bit mask of INCR_WRITE field.
	DMA_CH2_CTRL_TRIG_INCR_WRITE_Msk = 0x20
	// Bit INCR_WRITE.
	DMA_CH2_CTRL_TRIG_INCR_WRITE = 0x20
	// Position of INCR_READ field.
	DMA_CH2_CTRL_TRIG_INCR_READ_Pos = 0x4
	// Bit mask of INCR_READ field.
	DMA_CH2_CTRL_TRIG_INCR_READ_Msk = 0x10
	// Bit INCR_READ.
	DMA_CH2_CTRL_TRIG_INCR_READ = 0x10
	// Position of DATA_SIZE field.
	DMA_CH2_CTRL_TRIG_DATA_SIZE_Pos = 0x2
	// Bit mask of DATA_SIZE field.
	DMA_CH2_CTRL_TRIG_DATA_SIZE_Msk           = 0xc
	DMA_CH2_CTRL_TRIG_DATA_SIZE_SIZE_BYTE     = 0x0
	DMA_CH2_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 0x1
	DMA_CH2_CTRL_TRIG_DATA_SIZE_SIZE_WORD     = 0x2
	// Position of HIGH_PRIORITY field.
	DMA_CH2_CTRL_TRIG_HIGH_PRIORITY_Pos = 0x1
	// Bit mask of HIGH_PRIORITY field.
	DMA_CH2_CTRL_TRIG_HIGH_PRIORITY_Msk = 0x2
	// Bit HIGH_PRIORITY.
	DMA_CH2_CTRL_TRIG_HIGH_PRIORITY = 0x2
	// Position of EN field.
	DMA_CH2_CTRL_TRIG_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CH2_CTRL_TRIG_EN_Msk = 0x1
	// Bit EN.
	DMA_CH2_CTRL_TRIG_EN = 0x1

	// CH3_CTRL_TRIG: DMA Channel 3 Control and Status
	// Position of AHB_ERROR field.
	DMA_CH3_CTRL_TRIG_AHB_ERROR_Pos = 0x1f
	// Bit mask of AHB_ERROR field.
	DMA_CH3_CTRL_TRIG_AHB_ERROR_Msk = 0x80000000
	// Bit AHB_ERROR.
	DMA_CH3_CTRL_TRIG_AHB_ERROR = 0x80000000
	// Position of READ_ERROR field.
	DMA_CH3_CTRL_TRIG_READ_ERROR_Pos = 0x1e
	// Bit mask of READ_ERROR field.
	DMA_CH3_CTRL_TRIG_READ_ERROR_Msk = 0x40000000
	// Bit READ_ERROR.
	DMA_CH3_CTRL_TRIG_READ_ERROR = 0x40000000
	// Position of WRITE_ERROR field.
	DMA_CH3_CTRL_TRIG_WRITE_ERROR_Pos = 0x1d
	// Bit mask of WRITE_ERROR field.
	DMA_CH3_CTRL_TRIG_WRITE_ERROR_Msk = 0x20000000
	// Bit WRITE_ERROR.
	DMA_CH3_CTRL_TRIG_WRITE_ERROR = 0x20000000
	// Position of BUSY field.
	DMA_CH3_CTRL_TRIG_BUSY_Pos = 0x18
	// Bit mask of BUSY field.
	DMA_CH3_CTRL_TRIG_BUSY_Msk = 0x1000000
	// Bit BUSY.
	DMA_CH3_CTRL_TRIG_BUSY = 0x1000000
	// Position of SNIFF_EN field.
	DMA_CH3_CTRL_TRIG_SNIFF_EN_Pos = 0x17
	// Bit mask of SNIFF_EN field.
	DMA_CH3_CTRL_TRIG_SNIFF_EN_Msk = 0x800000
	// Bit SNIFF_EN.
	DMA_CH3_CTRL_TRIG_SNIFF_EN = 0x800000
	// Position of BSWAP field.
	DMA_CH3_CTRL_TRIG_BSWAP_Pos = 0x16
	// Bit mask of BSWAP field.
	DMA_CH3_CTRL_TRIG_BSWAP_Msk = 0x400000
	// Bit BSWAP.
	DMA_CH3_CTRL_TRIG_BSWAP = 0x400000
	// Position of IRQ_QUIET field.
	DMA_CH3_CTRL_TRIG_IRQ_QUIET_Pos = 0x15
	// Bit mask of IRQ_QUIET field.
	DMA_CH3_CTRL_TRIG_IRQ_QUIET_Msk = 0x200000
	// Bit IRQ_QUIET.
	DMA_CH3_CTRL_TRIG_IRQ_QUIET = 0x200000
	// Position of TREQ_SEL field.
	DMA_CH3_CTRL_TRIG_TREQ_SEL_Pos = 0xf
	// Bit mask of TREQ_SEL field.
	DMA_CH3_CTRL_TRIG_TREQ_SEL_Msk = 0x1f8000
	// Select Timer 0 as TREQ
	DMA_CH3_CTRL_TRIG_TREQ_SEL_TIMER0 = 0x3b
	// Select Timer 1 as TREQ
	DMA_CH3_CTRL_TRIG_TREQ_SEL_TIMER1 = 0x3c
	// Select Timer 2 as TREQ (Optional)
	DMA_CH3_CTRL_TRIG_TREQ_SEL_TIMER2 = 0x3d
	// Select Timer 3 as TREQ (Optional)
	DMA_CH3_CTRL_TRIG_TREQ_SEL_TIMER3 = 0x3e
	// Permanent request, for unpaced transfers.
	DMA_CH3_CTRL_TRIG_TREQ_SEL_PERMANENT = 0x3f
	// Position of CHAIN_TO field.
	DMA_CH3_CTRL_TRIG_CHAIN_TO_Pos = 0xb
	// Bit mask of CHAIN_TO field.
	DMA_CH3_CTRL_TRIG_CHAIN_TO_Msk = 0x7800
	// Position of RING_SEL field.
	DMA_CH3_CTRL_TRIG_RING_SEL_Pos = 0xa
	// Bit mask of RING_SEL field.
	DMA_CH3_CTRL_TRIG_RING_SEL_Msk = 0x400
	// Bit RING_SEL.
	DMA_CH3_CTRL_TRIG_RING_SEL = 0x400
	// Position of RING_SIZE field.
	DMA_CH3_CTRL_TRIG_RING_SIZE_Pos = 0x6
	// Bit mask of RING_SIZE field.
	DMA_CH3_CTRL_TRIG_RING_SIZE_Msk       = 0x3c0
	DMA_CH3_CTRL_TRIG_RING_SIZE_RING_NONE = 0x0
	// Position of INCR_WRITE field.
	DMA_CH3_CTRL_TRIG_INCR_WRITE_Pos = 0x5
	// Bit mask of INCR_WRITE field.
	DMA_CH3_CTRL_TRIG_INCR_WRITE_Msk = 0x20
	// Bit INCR_WRITE.
	DMA_CH3_CTRL_TRIG_INCR_WRITE = 0x20
	// Position of INCR_READ field.
	DMA_CH3_CTRL_TRIG_INCR_READ_Pos = 0x4
	// Bit mask of INCR_READ field.
	DMA_CH3_CTRL_TRIG_INCR_READ_Msk = 0x10
	// Bit INCR_READ.
	DMA_CH3_CTRL_TRIG_INCR_READ = 0x10
	// Position of DATA_SIZE field.
	DMA_CH3_CTRL_TRIG_DATA_SIZE_Pos = 0x2
	// Bit mask of DATA_SIZE field.
	DMA_CH3_CTRL_TRIG_DATA_SIZE_Msk           = 0xc
	DMA_CH3_CTRL_TRIG_DATA_SIZE_SIZE_BYTE     = 0x0
	DMA_CH3_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 0x1
	DMA_CH3_CTRL_TRIG_DATA_SIZE_SIZE_WORD     = 0x2
	// Position of HIGH_PRIORITY field.
	DMA_CH3_CTRL_TRIG_HIGH_PRIORITY_Pos = 0x1
	// Bit mask of HIGH_PRIORITY field.
	DMA_CH3_CTRL_TRIG_HIGH_PRIORITY_Msk = 0x2
	// Bit HIGH_PRIORITY.
	DMA_CH3_CTRL_TRIG_HIGH_PRIORITY = 0x2
	// Position of EN field.
	DMA_CH3_CTRL_TRIG_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CH3_CTRL_TRIG_EN_Msk = 0x1
	// Bit EN.
	DMA_CH3_CTRL_TRIG_EN = 0x1

	// CH4_CTRL_TRIG: DMA Channel 4 Control and Status
	// Position of AHB_ERROR field.
	DMA_CH4_CTRL_TRIG_AHB_ERROR_Pos = 0x1f
	// Bit mask of AHB_ERROR field.
	DMA_CH4_CTRL_TRIG_AHB_ERROR_Msk = 0x80000000
	// Bit AHB_ERROR.
	DMA_CH4_CTRL_TRIG_AHB_ERROR = 0x80000000
	// Position of READ_ERROR field.
	DMA_CH4_CTRL_TRIG_READ_ERROR_Pos = 0x1e
	// Bit mask of READ_ERROR field.
	DMA_CH4_CTRL_TRIG_READ_ERROR_Msk = 0x40000000
	// Bit READ_ERROR.
	DMA_CH4_CTRL_TRIG_READ_ERROR = 0x40000000
	// Position of WRITE_ERROR field.
	DMA_CH4_CTRL_TRIG_WRITE_ERROR_Pos = 0x1d
	// Bit mask of WRITE_ERROR field.
	DMA_CH4_CTRL_TRIG_WRITE_ERROR_Msk = 0x20000000
	// Bit WRITE_ERROR.
	DMA_CH4_CTRL_TRIG_WRITE_ERROR = 0x20000000
	// Position of BUSY field.
	DMA_CH4_CTRL_TRIG_BUSY_Pos = 0x18
	// Bit mask of BUSY field.
	DMA_CH4_CTRL_TRIG_BUSY_Msk = 0x1000000
	// Bit BUSY.
	DMA_CH4_CTRL_TRIG_BUSY = 0x1000000
	// Position of SNIFF_EN field.
	DMA_CH4_CTRL_TRIG_SNIFF_EN_Pos = 0x17
	// Bit mask of SNIFF_EN field.
	DMA_CH4_CTRL_TRIG_SNIFF_EN_Msk = 0x800000
	// Bit SNIFF_EN.
	DMA_CH4_CTRL_TRIG_SNIFF_EN = 0x800000
	// Position of BSWAP field.
	DMA_CH4_CTRL_TRIG_BSWAP_Pos = 0x16
	// Bit mask of BSWAP field.
	DMA_CH4_CTRL_TRIG_BSWAP_Msk = 0x400000
	// Bit BSWAP.
	DMA_CH4_CTRL_TRIG_BSWAP = 0x400000
	// Position of IRQ_QUIET field.
	DMA_CH4_CTRL_TRIG_IRQ_QUIET_Pos = 0x15
	// Bit mask of IRQ_QUIET field.
	DMA_CH4_CTRL_TRIG_IRQ_QUIET_Msk = 0x200000
	// Bit IRQ_QUIET.
	DMA_CH4_CTRL_TRIG_IRQ_QUIET = 0x200000
	// Position of TREQ_SEL field.
	DMA_CH4_CTRL_TRIG_TREQ_SEL_Pos = 0xf
	// Bit mask of TREQ_SEL field.
	DMA_CH4_CTRL_TRIG_TREQ_SEL_Msk = 0x1f8000
	// Select Timer 0 as TREQ
	DMA_CH4_CTRL_TRIG_TREQ_SEL_TIMER0 = 0x3b
	// Select Timer 1 as TREQ
	DMA_CH4_CTRL_TRIG_TREQ_SEL_TIMER1 = 0x3c
	// Select Timer 2 as TREQ (Optional)
	DMA_CH4_CTRL_TRIG_TREQ_SEL_TIMER2 = 0x3d
	// Select Timer 3 as TREQ (Optional)
	DMA_CH4_CTRL_TRIG_TREQ_SEL_TIMER3 = 0x3e
	// Permanent request, for unpaced transfers.
	DMA_CH4_CTRL_TRIG_TREQ_SEL_PERMANENT = 0x3f
	// Position of CHAIN_TO field.
	DMA_CH4_CTRL_TRIG_CHAIN_TO_Pos = 0xb
	// Bit mask of CHAIN_TO field.
	DMA_CH4_CTRL_TRIG_CHAIN_TO_Msk = 0x7800
	// Position of RING_SEL field.
	DMA_CH4_CTRL_TRIG_RING_SEL_Pos = 0xa
	// Bit mask of RING_SEL field.
	DMA_CH4_CTRL_TRIG_RING_SEL_Msk = 0x400
	// Bit RING_SEL.
	DMA_CH4_CTRL_TRIG_RING_SEL = 0x400
	// Position of RING_SIZE field.
	DMA_CH4_CTRL_TRIG_RING_SIZE_Pos = 0x6
	// Bit mask of RING_SIZE field.
	DMA_CH4_CTRL_TRIG_RING_SIZE_Msk       = 0x3c0
	DMA_CH4_CTRL_TRIG_RING_SIZE_RING_NONE = 0x0
	// Position of INCR_WRITE field.
	DMA_CH4_CTRL_TRIG_INCR_WRITE_Pos = 0x5
	// Bit mask of INCR_WRITE field.
	DMA_CH4_CTRL_TRIG_INCR_WRITE_Msk = 0x20
	// Bit INCR_WRITE.
	DMA_CH4_CTRL_TRIG_INCR_WRITE = 0x20
	// Position of INCR_READ field.
	DMA_CH4_CTRL_TRIG_INCR_READ_Pos = 0x4
	// Bit mask of INCR_READ field.
	DMA_CH4_CTRL_TRIG_INCR_READ_Msk = 0x10
	// Bit INCR_READ.
	DMA_CH4_CTRL_TRIG_INCR_READ = 0x10
	// Position of DATA_SIZE field.
	DMA_CH4_CTRL_TRIG_DATA_SIZE_Pos = 0x2
	// Bit mask of DATA_SIZE field.
	DMA_CH4_CTRL_TRIG_DATA_SIZE_Msk           = 0xc
	DMA_CH4_CTRL_TRIG_DATA_SIZE_SIZE_BYTE     = 0x0
	DMA_CH4_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 0x1
	DMA_CH4_CTRL_TRIG_DATA_SIZE_SIZE_WORD     = 0x2
	// Position of HIGH_PRIORITY field.
	DMA_CH4_CTRL_TRIG_HIGH_PRIORITY_Pos = 0x1
	// Bit mask of HIGH_PRIORITY field.
	DMA_CH4_CTRL_TRIG_HIGH_PRIORITY_Msk = 0x2
	// Bit HIGH_PRIORITY.
	DMA_CH4_CTRL_TRIG_HIGH_PRIORITY = 0x2
	// Position of EN field.
	DMA_CH4_CTRL_TRIG_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CH4_CTRL_TRIG_EN_Msk = 0x1
	// Bit EN.
	DMA_CH4_CTRL_TRIG_EN = 0x1

	// CH5_CTRL_TRIG: DMA Channel 5 Control and Status
	// Position of AHB_ERROR field.
	DMA_CH5_CTRL_TRIG_AHB_ERROR_Pos = 0x1f
	// Bit mask of AHB_ERROR field.
	DMA_CH5_CTRL_TRIG_AHB_ERROR_Msk = 0x80000000
	// Bit AHB_ERROR.
	DMA_CH5_CTRL_TRIG_AHB_ERROR = 0x80000000
	// Position of READ_ERROR field.
	DMA_CH5_CTRL_TRIG_READ_ERROR_Pos = 0x1e
	// Bit mask of READ_ERROR field.
	DMA_CH5_CTRL_TRIG_READ_ERROR_Msk = 0x40000000
	// Bit READ_ERROR.
	DMA_CH5_CTRL_TRIG_READ_ERROR = 0x40000000
	// Position of WRITE_ERROR field.
	DMA_CH5_CTRL_TRIG_WRITE_ERROR_Pos = 0x1d
	// Bit mask of WRITE_ERROR field.
	DMA_CH5_CTRL_TRIG_WRITE_ERROR_Msk = 0x20000000
	// Bit WRITE_ERROR.
	DMA_CH5_CTRL_TRIG_WRITE_ERROR = 0x20000000
	// Position of BUSY field.
	DMA_CH5_CTRL_TRIG_BUSY_Pos = 0x18
	// Bit mask of BUSY field.
	DMA_CH5_CTRL_TRIG_BUSY_Msk = 0x1000000
	// Bit BUSY.
	DMA_CH5_CTRL_TRIG_BUSY = 0x1000000
	// Position of SNIFF_EN field.
	DMA_CH5_CTRL_TRIG_SNIFF_EN_Pos = 0x17
	// Bit mask of SNIFF_EN field.
	DMA_CH5_CTRL_TRIG_SNIFF_EN_Msk = 0x800000
	// Bit SNIFF_EN.
	DMA_CH5_CTRL_TRIG_SNIFF_EN = 0x800000
	// Position of BSWAP field.
	DMA_CH5_CTRL_TRIG_BSWAP_Pos = 0x16
	// Bit mask of BSWAP field.
	DMA_CH5_CTRL_TRIG_BSWAP_Msk = 0x400000
	// Bit BSWAP.
	DMA_CH5_CTRL_TRIG_BSWAP = 0x400000
	// Position of IRQ_QUIET field.
	DMA_CH5_CTRL_TRIG_IRQ_QUIET_Pos = 0x15
	// Bit mask of IRQ_QUIET field.
	DMA_CH5_CTRL_TRIG_IRQ_QUIET_Msk = 0x200000
	// Bit IRQ_QUIET.
	DMA_CH5_CTRL_TRIG_IRQ_QUIET = 0x200000
	// Position of TREQ_SEL field.
	DMA_CH5_CTRL_TRIG_TREQ_SEL_Pos = 0xf
	// Bit mask of TREQ_SEL field.
	DMA_CH5_CTRL_TRIG_TREQ_SEL_Msk = 0x1f8000
	// Select Timer 0 as TREQ
	DMA_CH5_CTRL_TRIG_TREQ_SEL_TIMER0 = 0x3b
	// Select Timer 1 as TREQ
	DMA_CH5_CTRL_TRIG_TREQ_SEL_TIMER1 = 0x3c
	// Select Timer 2 as TREQ (Optional)
	DMA_CH5_CTRL_TRIG_TREQ_SEL_TIMER2 = 0x3d
	// Select Timer 3 as TREQ (Optional)
	DMA_CH5_CTRL_TRIG_TREQ_SEL_TIMER3 = 0x3e
	// Permanent request, for unpaced transfers.
	DMA_CH5_CTRL_TRIG_TREQ_SEL_PERMANENT = 0x3f
	// Position of CHAIN_TO field.
	DMA_CH5_CTRL_TRIG_CHAIN_TO_Pos = 0xb
	// Bit mask of CHAIN_TO field.
	DMA_CH5_CTRL_TRIG_CHAIN_TO_Msk = 0x7800
	// Position of RING_SEL field.
	DMA_CH5_CTRL_TRIG_RING_SEL_Pos = 0xa
	// Bit mask of RING_SEL field.
	DMA_CH5_CTRL_TRIG_RING_SEL_Msk = 0x400
	// Bit RING_SEL.
	DMA_CH5_CTRL_TRIG_RING_SEL = 0x400
	// Position of RING_SIZE field.
	DMA_CH5_CTRL_TRIG_RING_SIZE_Pos = 0x6
	// Bit mask of RING_SIZE field.
	DMA_CH5_CTRL_TRIG_RING_SIZE_Msk       = 0x3c0
	DMA_CH5_CTRL_TRIG_RING_SIZE_RING_NONE = 0x0
	// Position of INCR_WRITE field.
	DMA_CH5_CTRL_TRIG_INCR_WRITE_Pos = 0x5
	// Bit mask of INCR_WRITE field.
	DMA_CH5_CTRL_TRIG_INCR_WRITE_Msk = 0x20
	// Bit INCR_WRITE.
	DMA_CH5_CTRL_TRIG_INCR_WRITE = 0x20
	// Position of INCR_READ field.
	DMA_CH5_CTRL_TRIG_INCR_READ_Pos = 0x4
	// Bit mask of INCR_READ field.
	DMA_CH5_CTRL_TRIG_INCR_READ_Msk = 0x10
	// Bit INCR_READ.
	DMA_CH5_CTRL_TRIG_INCR_READ = 0x10
	// Position of DATA_SIZE field.
	DMA_CH5_CTRL_TRIG_DATA_SIZE_Pos = 0x2
	// Bit mask of DATA_SIZE field.
	DMA_CH5_CTRL_TRIG_DATA_SIZE_Msk           = 0xc
	DMA_CH5_CTRL_TRIG_DATA_SIZE_SIZE_BYTE     = 0x0
	DMA_CH5_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 0x1
	DMA_CH5_CTRL_TRIG_DATA_SIZE_SIZE_WORD     = 0x2
	// Position of HIGH_PRIORITY field.
	DMA_CH5_CTRL_TRIG_HIGH_PRIORITY_Pos = 0x1
	// Bit mask of HIGH_PRIORITY field.
	DMA_CH5_CTRL_TRIG_HIGH_PRIORITY_Msk = 0x2
	// Bit HIGH_PRIORITY.
	DMA_CH5_CTRL_TRIG_HIGH_PRIORITY = 0x2
	// Position of EN field.
	DMA_CH5_CTRL_TRIG_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CH5_CTRL_TRIG_EN_Msk = 0x1
	// Bit EN.
	DMA_CH5_CTRL_TRIG_EN = 0x1

	// CH6_CTRL_TRIG: DMA Channel 6 Control and Status
	// Position of AHB_ERROR field.
	DMA_CH6_CTRL_TRIG_AHB_ERROR_Pos = 0x1f
	// Bit mask of AHB_ERROR field.
	DMA_CH6_CTRL_TRIG_AHB_ERROR_Msk = 0x80000000
	// Bit AHB_ERROR.
	DMA_CH6_CTRL_TRIG_AHB_ERROR = 0x80000000
	// Position of READ_ERROR field.
	DMA_CH6_CTRL_TRIG_READ_ERROR_Pos = 0x1e
	// Bit mask of READ_ERROR field.
	DMA_CH6_CTRL_TRIG_READ_ERROR_Msk = 0x40000000
	// Bit READ_ERROR.
	DMA_CH6_CTRL_TRIG_READ_ERROR = 0x40000000
	// Position of WRITE_ERROR field.
	DMA_CH6_CTRL_TRIG_WRITE_ERROR_Pos = 0x1d
	// Bit mask of WRITE_ERROR field.
	DMA_CH6_CTRL_TRIG_WRITE_ERROR_Msk = 0x20000000
	// Bit WRITE_ERROR.
	DMA_CH6_CTRL_TRIG_WRITE_ERROR = 0x20000000
	// Position of BUSY field.
	DMA_CH6_CTRL_TRIG_BUSY_Pos = 0x18
	// Bit mask of BUSY field.
	DMA_CH6_CTRL_TRIG_BUSY_Msk = 0x1000000
	// Bit BUSY.
	DMA_CH6_CTRL_TRIG_BUSY = 0x1000000
	// Position of SNIFF_EN field.
	DMA_CH6_CTRL_TRIG_SNIFF_EN_Pos = 0x17
	// Bit mask of SNIFF_EN field.
	DMA_CH6_CTRL_TRIG_SNIFF_EN_Msk = 0x800000
	// Bit SNIFF_EN.
	DMA_CH6_CTRL_TRIG_SNIFF_EN = 0x800000
	// Position of BSWAP field.
	DMA_CH6_CTRL_TRIG_BSWAP_Pos = 0x16
	// Bit mask of BSWAP field.
	DMA_CH6_CTRL_TRIG_BSWAP_Msk = 0x400000
	// Bit BSWAP.
	DMA_CH6_CTRL_TRIG_BSWAP = 0x400000
	// Position of IRQ_QUIET field.
	DMA_CH6_CTRL_TRIG_IRQ_QUIET_Pos = 0x15
	// Bit mask of IRQ_QUIET field.
	DMA_CH6_CTRL_TRIG_IRQ_QUIET_Msk = 0x200000
	// Bit IRQ_QUIET.
	DMA_CH6_CTRL_TRIG_IRQ_QUIET = 0x200000
	// Position of TREQ_SEL field.
	DMA_CH6_CTRL_TRIG_TREQ_SEL_Pos = 0xf
	// Bit mask of TREQ_SEL field.
	DMA_CH6_CTRL_TRIG_TREQ_SEL_Msk = 0x1f8000
	// Select Timer 0 as TREQ
	DMA_CH6_CTRL_TRIG_TREQ_SEL_TIMER0 = 0x3b
	// Select Timer 1 as TREQ
	DMA_CH6_CTRL_TRIG_TREQ_SEL_TIMER1 = 0x3c
	// Select Timer 2 as TREQ (Optional)
	DMA_CH6_CTRL_TRIG_TREQ_SEL_TIMER2 = 0x3d
	// Select Timer 3 as TREQ (Optional)
	DMA_CH6_CTRL_TRIG_TREQ_SEL_TIMER3 = 0x3e
	// Permanent request, for unpaced transfers.
	DMA_CH6_CTRL_TRIG_TREQ_SEL_PERMANENT = 0x3f
	// Position of CHAIN_TO field.
	DMA_CH6_CTRL_TRIG_CHAIN_TO_Pos = 0xb
	// Bit mask of CHAIN_TO field.
	DMA_CH6_CTRL_TRIG_CHAIN_TO_Msk = 0x7800
	// Position of RING_SEL field.
	DMA_CH6_CTRL_TRIG_RING_SEL_Pos = 0xa
	// Bit mask of RING_SEL field.
	DMA_CH6_CTRL_TRIG_RING_SEL_Msk = 0x400
	// Bit RING_SEL.
	DMA_CH6_CTRL_TRIG_RING_SEL = 0x400
	// Position of RING_SIZE field.
	DMA_CH6_CTRL_TRIG_RING_SIZE_Pos = 0x6
	// Bit mask of RING_SIZE field.
	DMA_CH6_CTRL_TRIG_RING_SIZE_Msk       = 0x3c0
	DMA_CH6_CTRL_TRIG_RING_SIZE_RING_NONE = 0x0
	// Position of INCR_WRITE field.
	DMA_CH6_CTRL_TRIG_INCR_WRITE_Pos = 0x5
	// Bit mask of INCR_WRITE field.
	DMA_CH6_CTRL_TRIG_INCR_WRITE_Msk = 0x20
	// Bit INCR_WRITE.
	DMA_CH6_CTRL_TRIG_INCR_WRITE = 0x20
	// Position of INCR_READ field.
	DMA_CH6_CTRL_TRIG_INCR_READ_Pos = 0x4
	// Bit mask of INCR_READ field.
	DMA_CH6_CTRL_TRIG_INCR_READ_Msk = 0x10
	// Bit INCR_READ.
	DMA_CH6_CTRL_TRIG_INCR_READ = 0x10
	// Position of DATA_SIZE field.
	DMA_CH6_CTRL_TRIG_DATA_SIZE_Pos = 0x2
	// Bit mask of DATA_SIZE field.
	DMA_CH6_CTRL_TRIG_DATA_SIZE_Msk           = 0xc
	DMA_CH6_CTRL_TRIG_DATA_SIZE_SIZE_BYTE     = 0x0
	DMA_CH6_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 0x1
	DMA_CH6_CTRL_TRIG_DATA_SIZE_SIZE_WORD     = 0x2
	// Position of HIGH_PRIORITY field.
	DMA_CH6_CTRL_TRIG_HIGH_PRIORITY_Pos = 0x1
	// Bit mask of HIGH_PRIORITY field.
	DMA_CH6_CTRL_TRIG_HIGH_PRIORITY_Msk = 0x2
	// Bit HIGH_PRIORITY.
	DMA_CH6_CTRL_TRIG_HIGH_PRIORITY = 0x2
	// Position of EN field.
	DMA_CH6_CTRL_TRIG_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CH6_CTRL_TRIG_EN_Msk = 0x1
	// Bit EN.
	DMA_CH6_CTRL_TRIG_EN = 0x1

	// CH7_CTRL_TRIG: DMA Channel 7 Control and Status
	// Position of AHB_ERROR field.
	DMA_CH7_CTRL_TRIG_AHB_ERROR_Pos = 0x1f
	// Bit mask of AHB_ERROR field.
	DMA_CH7_CTRL_TRIG_AHB_ERROR_Msk = 0x80000000
	// Bit AHB_ERROR.
	DMA_CH7_CTRL_TRIG_AHB_ERROR = 0x80000000
	// Position of READ_ERROR field.
	DMA_CH7_CTRL_TRIG_READ_ERROR_Pos = 0x1e
	// Bit mask of READ_ERROR field.
	DMA_CH7_CTRL_TRIG_READ_ERROR_Msk = 0x40000000
	// Bit READ_ERROR.
	DMA_CH7_CTRL_TRIG_READ_ERROR = 0x40000000
	// Position of WRITE_ERROR field.
	DMA_CH7_CTRL_TRIG_WRITE_ERROR_Pos = 0x1d
	// Bit mask of WRITE_ERROR field.
	DMA_CH7_CTRL_TRIG_WRITE_ERROR_Msk = 0x20000000
	// Bit WRITE_ERROR.
	DMA_CH7_CTRL_TRIG_WRITE_ERROR = 0x20000000
	// Position of BUSY field.
	DMA_CH7_CTRL_TRIG_BUSY_Pos = 0x18
	// Bit mask of BUSY field.
	DMA_CH7_CTRL_TRIG_BUSY_Msk = 0x1000000
	// Bit BUSY.
	DMA_CH7_CTRL_TRIG_BUSY = 0x1000000
	// Position of SNIFF_EN field.
	DMA_CH7_CTRL_TRIG_SNIFF_EN_Pos = 0x17
	// Bit mask of SNIFF_EN field.
	DMA_CH7_CTRL_TRIG_SNIFF_EN_Msk = 0x800000
	// Bit SNIFF_EN.
	DMA_CH7_CTRL_TRIG_SNIFF_EN = 0x800000
	// Position of BSWAP field.
	DMA_CH7_CTRL_TRIG_BSWAP_Pos = 0x16
	// Bit mask of BSWAP field.
	DMA_CH7_CTRL_TRIG_BSWAP_Msk = 0x400000
	// Bit BSWAP.
	DMA_CH7_CTRL_TRIG_BSWAP = 0x400000
	// Position of IRQ_QUIET field.
	DMA_CH7_CTRL_TRIG_IRQ_QUIET_Pos = 0x15
	// Bit mask of IRQ_QUIET field.
	DMA_CH7_CTRL_TRIG_IRQ_QUIET_Msk = 0x200000
	// Bit IRQ_QUIET.
	DMA_CH7_CTRL_TRIG_IRQ_QUIET = 0x200000
	// Position of TREQ_SEL field.
	DMA_CH7_CTRL_TRIG_TREQ_SEL_Pos = 0xf
	// Bit mask of TREQ_SEL field.
	DMA_CH7_CTRL_TRIG_TREQ_SEL_Msk = 0x1f8000
	// Select Timer 0 as TREQ
	DMA_CH7_CTRL_TRIG_TREQ_SEL_TIMER0 = 0x3b
	// Select Timer 1 as TREQ
	DMA_CH7_CTRL_TRIG_TREQ_SEL_TIMER1 = 0x3c
	// Select Timer 2 as TREQ (Optional)
	DMA_CH7_CTRL_TRIG_TREQ_SEL_TIMER2 = 0x3d
	// Select Timer 3 as TREQ (Optional)
	DMA_CH7_CTRL_TRIG_TREQ_SEL_TIMER3 = 0x3e
	// Permanent request, for unpaced transfers.
	DMA_CH7_CTRL_TRIG_TREQ_SEL_PERMANENT = 0x3f
	// Position of CHAIN_TO field.
	DMA_CH7_CTRL_TRIG_CHAIN_TO_Pos = 0xb
	// Bit mask of CHAIN_TO field.
	DMA_CH7_CTRL_TRIG_CHAIN_TO_Msk = 0x7800
	// Position of RING_SEL field.
	DMA_CH7_CTRL_TRIG_RING_SEL_Pos = 0xa
	// Bit mask of RING_SEL field.
	DMA_CH7_CTRL_TRIG_RING_SEL_Msk = 0x400
	// Bit RING_SEL.
	DMA_CH7_CTRL_TRIG_RING_SEL = 0x400
	// Position of RING_SIZE field.
	DMA_CH7_CTRL_TRIG_RING_SIZE_Pos = 0x6
	// Bit mask of RING_SIZE field.
	DMA_CH7_CTRL_TRIG_RING_SIZE_Msk       = 0x3c0
	DMA_CH7_CTRL_TRIG_RING_SIZE_RING_NONE = 0x0
	// Position of INCR_WRITE field.
	DMA_CH7_CTRL_TRIG_INCR_WRITE_Pos = 0x5
	// Bit mask of INCR_WRITE field.
	DMA_CH7_CTRL_TRIG_INCR_WRITE_Msk = 0x20
	// Bit INCR_WRITE.
	DMA_CH7_CTRL_TRIG_INCR_WRITE = 0x20
	// Position of INCR_READ field.
	DMA_CH7_CTRL_TRIG_INCR_READ_Pos = 0x4
	// Bit mask of INCR_READ field.
	DMA_CH7_CTRL_TRIG_INCR_READ_Msk = 0x10
	// Bit INCR_READ.
	DMA_CH7_CTRL_TRIG_INCR_READ = 0x10
	// Position of DATA_SIZE field.
	DMA_CH7_CTRL_TRIG_DATA_SIZE_Pos = 0x2
	// Bit mask of DATA_SIZE field.
	DMA_CH7_CTRL_TRIG_DATA_SIZE_Msk           = 0xc
	DMA_CH7_CTRL_TRIG_DATA_SIZE_SIZE_BYTE     = 0x0
	DMA_CH7_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 0x1
	DMA_CH7_CTRL_TRIG_DATA_SIZE_SIZE_WORD     = 0x2
	// Position of HIGH_PRIORITY field.
	DMA_CH7_CTRL_TRIG_HIGH_PRIORITY_Pos = 0x1
	// Bit mask of HIGH_PRIORITY field.
	DMA_CH7_CTRL_TRIG_HIGH_PRIORITY_Msk = 0x2
	// Bit HIGH_PRIORITY.
	DMA_CH7_CTRL_TRIG_HIGH_PRIORITY = 0x2
	// Position of EN field.
	DMA_CH7_CTRL_TRIG_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CH7_CTRL_TRIG_EN_Msk = 0x1
	// Bit EN.
	DMA_CH7_CTRL_TRIG_EN = 0x1

	// CH8_CTRL_TRIG: DMA Channel 8 Control and Status
	// Position of AHB_ERROR field.
	DMA_CH8_CTRL_TRIG_AHB_ERROR_Pos = 0x1f
	// Bit mask of AHB_ERROR field.
	DMA_CH8_CTRL_TRIG_AHB_ERROR_Msk = 0x80000000
	// Bit AHB_ERROR.
	DMA_CH8_CTRL_TRIG_AHB_ERROR = 0x80000000
	// Position of READ_ERROR field.
	DMA_CH8_CTRL_TRIG_READ_ERROR_Pos = 0x1e
	// Bit mask of READ_ERROR field.
	DMA_CH8_CTRL_TRIG_READ_ERROR_Msk = 0x40000000
	// Bit READ_ERROR.
	DMA_CH8_CTRL_TRIG_READ_ERROR = 0x40000000
	// Position of WRITE_ERROR field.
	DMA_CH8_CTRL_TRIG_WRITE_ERROR_Pos = 0x1d
	// Bit mask of WRITE_ERROR field.
	DMA_CH8_CTRL_TRIG_WRITE_ERROR_Msk = 0x20000000
	// Bit WRITE_ERROR.
	DMA_CH8_CTRL_TRIG_WRITE_ERROR = 0x20000000
	// Position of BUSY field.
	DMA_CH8_CTRL_TRIG_BUSY_Pos = 0x18
	// Bit mask of BUSY field.
	DMA_CH8_CTRL_TRIG_BUSY_Msk = 0x1000000
	// Bit BUSY.
	DMA_CH8_CTRL_TRIG_BUSY = 0x1000000
	// Position of SNIFF_EN field.
	DMA_CH8_CTRL_TRIG_SNIFF_EN_Pos = 0x17
	// Bit mask of SNIFF_EN field.
	DMA_CH8_CTRL_TRIG_SNIFF_EN_Msk = 0x800000
	// Bit SNIFF_EN.
	DMA_CH8_CTRL_TRIG_SNIFF_EN = 0x800000
	// Position of BSWAP field.
	DMA_CH8_CTRL_TRIG_BSWAP_Pos = 0x16
	// Bit mask of BSWAP field.
	DMA_CH8_CTRL_TRIG_BSWAP_Msk = 0x400000
	// Bit BSWAP.
	DMA_CH8_CTRL_TRIG_BSWAP = 0x400000
	// Position of IRQ_QUIET field.
	DMA_CH8_CTRL_TRIG_IRQ_QUIET_Pos = 0x15
	// Bit mask of IRQ_QUIET field.
	DMA_CH8_CTRL_TRIG_IRQ_QUIET_Msk = 0x200000
	// Bit IRQ_QUIET.
	DMA_CH8_CTRL_TRIG_IRQ_QUIET = 0x200000
	// Position of TREQ_SEL field.
	DMA_CH8_CTRL_TRIG_TREQ_SEL_Pos = 0xf
	// Bit mask of TREQ_SEL field.
	DMA_CH8_CTRL_TRIG_TREQ_SEL_Msk = 0x1f8000
	// Select Timer 0 as TREQ
	DMA_CH8_CTRL_TRIG_TREQ_SEL_TIMER0 = 0x3b
	// Select Timer 1 as TREQ
	DMA_CH8_CTRL_TRIG_TREQ_SEL_TIMER1 = 0x3c
	// Select Timer 2 as TREQ (Optional)
	DMA_CH8_CTRL_TRIG_TREQ_SEL_TIMER2 = 0x3d
	// Select Timer 3 as TREQ (Optional)
	DMA_CH8_CTRL_TRIG_TREQ_SEL_TIMER3 = 0x3e
	// Permanent request, for unpaced transfers.
	DMA_CH8_CTRL_TRIG_TREQ_SEL_PERMANENT = 0x3f
	// Position of CHAIN_TO field.
	DMA_CH8_CTRL_TRIG_CHAIN_TO_Pos = 0xb
	// Bit mask of CHAIN_TO field.
	DMA_CH8_CTRL_TRIG_CHAIN_TO_Msk = 0x7800
	// Position of RING_SEL field.
	DMA_CH8_CTRL_TRIG_RING_SEL_Pos = 0xa
	// Bit mask of RING_SEL field.
	DMA_CH8_CTRL_TRIG_RING_SEL_Msk = 0x400
	// Bit RING_SEL.
	DMA_CH8_CTRL_TRIG_RING_SEL = 0x400
	// Position of RING_SIZE field.
	DMA_CH8_CTRL_TRIG_RING_SIZE_Pos = 0x6
	// Bit mask of RING_SIZE field.
	DMA_CH8_CTRL_TRIG_RING_SIZE_Msk       = 0x3c0
	DMA_CH8_CTRL_TRIG_RING_SIZE_RING_NONE = 0x0
	// Position of INCR_WRITE field.
	DMA_CH8_CTRL_TRIG_INCR_WRITE_Pos = 0x5
	// Bit mask of INCR_WRITE field.
	DMA_CH8_CTRL_TRIG_INCR_WRITE_Msk = 0x20
	// Bit INCR_WRITE.
	DMA_CH8_CTRL_TRIG_INCR_WRITE = 0x20
	// Position of INCR_READ field.
	DMA_CH8_CTRL_TRIG_INCR_READ_Pos = 0x4
	// Bit mask of INCR_READ field.
	DMA_CH8_CTRL_TRIG_INCR_READ_Msk = 0x10
	// Bit INCR_READ.
	DMA_CH8_CTRL_TRIG_INCR_READ = 0x10
	// Position of DATA_SIZE field.
	DMA_CH8_CTRL_TRIG_DATA_SIZE_Pos = 0x2
	// Bit mask of DATA_SIZE field.
	DMA_CH8_CTRL_TRIG_DATA_SIZE_Msk           = 0xc
	DMA_CH8_CTRL_TRIG_DATA_SIZE_SIZE_BYTE     = 0x0
	DMA_CH8_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 0x1
	DMA_CH8_CTRL_TRIG_DATA_SIZE_SIZE_WORD     = 0x2
	// Position of HIGH_PRIORITY field.
	DMA_CH8_CTRL_TRIG_HIGH_PRIORITY_Pos = 0x1
	// Bit mask of HIGH_PRIORITY field.
	DMA_CH8_CTRL_TRIG_HIGH_PRIORITY_Msk = 0x2
	// Bit HIGH_PRIORITY.
	DMA_CH8_CTRL_TRIG_HIGH_PRIORITY = 0x2
	// Position of EN field.
	DMA_CH8_CTRL_TRIG_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CH8_CTRL_TRIG_EN_Msk = 0x1
	// Bit EN.
	DMA_CH8_CTRL_TRIG_EN = 0x1

	// CH9_CTRL_TRIG: DMA Channel 9 Control and Status
	// Position of AHB_ERROR field.
	DMA_CH9_CTRL_TRIG_AHB_ERROR_Pos = 0x1f
	// Bit mask of AHB_ERROR field.
	DMA_CH9_CTRL_TRIG_AHB_ERROR_Msk = 0x80000000
	// Bit AHB_ERROR.
	DMA_CH9_CTRL_TRIG_AHB_ERROR = 0x80000000
	// Position of READ_ERROR field.
	DMA_CH9_CTRL_TRIG_READ_ERROR_Pos = 0x1e
	// Bit mask of READ_ERROR field.
	DMA_CH9_CTRL_TRIG_READ_ERROR_Msk = 0x40000000
	// Bit READ_ERROR.
	DMA_CH9_CTRL_TRIG_READ_ERROR = 0x40000000
	// Position of WRITE_ERROR field.
	DMA_CH9_CTRL_TRIG_WRITE_ERROR_Pos = 0x1d
	// Bit mask of WRITE_ERROR field.
	DMA_CH9_CTRL_TRIG_WRITE_ERROR_Msk = 0x20000000
	// Bit WRITE_ERROR.
	DMA_CH9_CTRL_TRIG_WRITE_ERROR = 0x20000000
	// Position of BUSY field.
	DMA_CH9_CTRL_TRIG_BUSY_Pos = 0x18
	// Bit mask of BUSY field.
	DMA_CH9_CTRL_TRIG_BUSY_Msk = 0x1000000
	// Bit BUSY.
	DMA_CH9_CTRL_TRIG_BUSY = 0x1000000
	// Position of SNIFF_EN field.
	DMA_CH9_CTRL_TRIG_SNIFF_EN_Pos = 0x17
	// Bit mask of SNIFF_EN field.
	DMA_CH9_CTRL_TRIG_SNIFF_EN_Msk = 0x800000
	// Bit SNIFF_EN.
	DMA_CH9_CTRL_TRIG_SNIFF_EN = 0x800000
	// Position of BSWAP field.
	DMA_CH9_CTRL_TRIG_BSWAP_Pos = 0x16
	// Bit mask of BSWAP field.
	DMA_CH9_CTRL_TRIG_BSWAP_Msk = 0x400000
	// Bit BSWAP.
	DMA_CH9_CTRL_TRIG_BSWAP = 0x400000
	// Position of IRQ_QUIET field.
	DMA_CH9_CTRL_TRIG_IRQ_QUIET_Pos = 0x15
	// Bit mask of IRQ_QUIET field.
	DMA_CH9_CTRL_TRIG_IRQ_QUIET_Msk = 0x200000
	// Bit IRQ_QUIET.
	DMA_CH9_CTRL_TRIG_IRQ_QUIET = 0x200000
	// Position of TREQ_SEL field.
	DMA_CH9_CTRL_TRIG_TREQ_SEL_Pos = 0xf
	// Bit mask of TREQ_SEL field.
	DMA_CH9_CTRL_TRIG_TREQ_SEL_Msk = 0x1f8000
	// Select Timer 0 as TREQ
	DMA_CH9_CTRL_TRIG_TREQ_SEL_TIMER0 = 0x3b
	// Select Timer 1 as TREQ
	DMA_CH9_CTRL_TRIG_TREQ_SEL_TIMER1 = 0x3c
	// Select Timer 2 as TREQ (Optional)
	DMA_CH9_CTRL_TRIG_TREQ_SEL_TIMER2 = 0x3d
	// Select Timer 3 as TREQ (Optional)
	DMA_CH9_CTRL_TRIG_TREQ_SEL_TIMER3 = 0x3e
	// Permanent request, for unpaced transfers.
	DMA_CH9_CTRL_TRIG_TREQ_SEL_PERMANENT = 0x3f
	// Position of CHAIN_TO field.
	DMA_CH9_CTRL_TRIG_CHAIN_TO_Pos = 0xb
	// Bit mask of CHAIN_TO field.
	DMA_CH9_CTRL_TRIG_CHAIN_TO_Msk = 0x7800
	// Position of RING_SEL field.
	DMA_CH9_CTRL_TRIG_RING_SEL_Pos = 0xa
	// Bit mask of RING_SEL field.
	DMA_CH9_CTRL_TRIG_RING_SEL_Msk = 0x400
	// Bit RING_SEL.
	DMA_CH9_CTRL_TRIG_RING_SEL = 0x400
	// Position of RING_SIZE field.
	DMA_CH9_CTRL_TRIG_RING_SIZE_Pos = 0x6
	// Bit mask of RING_SIZE field.
	DMA_CH9_CTRL_TRIG_RING_SIZE_Msk       = 0x3c0
	DMA_CH9_CTRL_TRIG_RING_SIZE_RING_NONE = 0x0
	// Position of INCR_WRITE field.
	DMA_CH9_CTRL_TRIG_INCR_WRITE_Pos = 0x5
	// Bit mask of INCR_WRITE field.
	DMA_CH9_CTRL_TRIG_INCR_WRITE_Msk = 0x20
	// Bit INCR_WRITE.
	DMA_CH9_CTRL_TRIG_INCR_WRITE = 0x20
	// Position of INCR_READ field.
	DMA_CH9_CTRL_TRIG_INCR_READ_Pos = 0x4
	// Bit mask of INCR_READ field.
	DMA_CH9_CTRL_TRIG_INCR_READ_Msk = 0x10
	// Bit INCR_READ.
	DMA_CH9_CTRL_TRIG_INCR_READ = 0x10
	// Position of DATA_SIZE field.
	DMA_CH9_CTRL_TRIG_DATA_SIZE_Pos = 0x2
	// Bit mask of DATA_SIZE field.
	DMA_CH9_CTRL_TRIG_DATA_SIZE_Msk           = 0xc
	DMA_CH9_CTRL_TRIG_DATA_SIZE_SIZE_BYTE     = 0x0
	DMA_CH9_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 0x1
	DMA_CH9_CTRL_TRIG_DATA_SIZE_SIZE_WORD     = 0x2
	// Position of HIGH_PRIORITY field.
	DMA_CH9_CTRL_TRIG_HIGH_PRIORITY_Pos = 0x1
	// Bit mask of HIGH_PRIORITY field.
	DMA_CH9_CTRL_TRIG_HIGH_PRIORITY_Msk = 0x2
	// Bit HIGH_PRIORITY.
	DMA_CH9_CTRL_TRIG_HIGH_PRIORITY = 0x2
	// Position of EN field.
	DMA_CH9_CTRL_TRIG_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CH9_CTRL_TRIG_EN_Msk = 0x1
	// Bit EN.
	DMA_CH9_CTRL_TRIG_EN = 0x1

	// CH10_CTRL_TRIG: DMA Channel 10 Control and Status
	// Position of AHB_ERROR field.
	DMA_CH10_CTRL_TRIG_AHB_ERROR_Pos = 0x1f
	// Bit mask of AHB_ERROR field.
	DMA_CH10_CTRL_TRIG_AHB_ERROR_Msk = 0x80000000
	// Bit AHB_ERROR.
	DMA_CH10_CTRL_TRIG_AHB_ERROR = 0x80000000
	// Position of READ_ERROR field.
	DMA_CH10_CTRL_TRIG_READ_ERROR_Pos = 0x1e
	// Bit mask of READ_ERROR field.
	DMA_CH10_CTRL_TRIG_READ_ERROR_Msk = 0x40000000
	// Bit READ_ERROR.
	DMA_CH10_CTRL_TRIG_READ_ERROR = 0x40000000
	// Position of WRITE_ERROR field.
	DMA_CH10_CTRL_TRIG_WRITE_ERROR_Pos = 0x1d
	// Bit mask of WRITE_ERROR field.
	DMA_CH10_CTRL_TRIG_WRITE_ERROR_Msk = 0x20000000
	// Bit WRITE_ERROR.
	DMA_CH10_CTRL_TRIG_WRITE_ERROR = 0x20000000
	// Position of BUSY field.
	DMA_CH10_CTRL_TRIG_BUSY_Pos = 0x18
	// Bit mask of BUSY field.
	DMA_CH10_CTRL_TRIG_BUSY_Msk = 0x1000000
	// Bit BUSY.
	DMA_CH10_CTRL_TRIG_BUSY = 0x1000000
	// Position of SNIFF_EN field.
	DMA_CH10_CTRL_TRIG_SNIFF_EN_Pos = 0x17
	// Bit mask of SNIFF_EN field.
	DMA_CH10_CTRL_TRIG_SNIFF_EN_Msk = 0x800000
	// Bit SNIFF_EN.
	DMA_CH10_CTRL_TRIG_SNIFF_EN = 0x800000
	// Position of BSWAP field.
	DMA_CH10_CTRL_TRIG_BSWAP_Pos = 0x16
	// Bit mask of BSWAP field.
	DMA_CH10_CTRL_TRIG_BSWAP_Msk = 0x400000
	// Bit BSWAP.
	DMA_CH10_CTRL_TRIG_BSWAP = 0x400000
	// Position of IRQ_QUIET field.
	DMA_CH10_CTRL_TRIG_IRQ_QUIET_Pos = 0x15
	// Bit mask of IRQ_QUIET field.
	DMA_CH10_CTRL_TRIG_IRQ_QUIET_Msk = 0x200000
	// Bit IRQ_QUIET.
	DMA_CH10_CTRL_TRIG_IRQ_QUIET = 0x200000
	// Position of TREQ_SEL field.
	DMA_CH10_CTRL_TRIG_TREQ_SEL_Pos = 0xf
	// Bit mask of TREQ_SEL field.
	DMA_CH10_CTRL_TRIG_TREQ_SEL_Msk = 0x1f8000
	// Select Timer 0 as TREQ
	DMA_CH10_CTRL_TRIG_TREQ_SEL_TIMER0 = 0x3b
	// Select Timer 1 as TREQ
	DMA_CH10_CTRL_TRIG_TREQ_SEL_TIMER1 = 0x3c
	// Select Timer 2 as TREQ (Optional)
	DMA_CH10_CTRL_TRIG_TREQ_SEL_TIMER2 = 0x3d
	// Select Timer 3 as TREQ (Optional)
	DMA_CH10_CTRL_TRIG_TREQ_SEL_TIMER3 = 0x3e
	// Permanent request, for unpaced transfers.
	DMA_CH10_CTRL_TRIG_TREQ_SEL_PERMANENT = 0x3f
	// Position of CHAIN_TO field.
	DMA_CH10_CTRL_TRIG_CHAIN_TO_Pos = 0xb
	// Bit mask of CHAIN_TO field.
	DMA_CH10_CTRL_TRIG_CHAIN_TO_Msk = 0x7800
	// Position of RING_SEL field.
	DMA_CH10_CTRL_TRIG_RING_SEL_Pos = 0xa
	// Bit mask of RING_SEL field.
	DMA_CH10_CTRL_TRIG_RING_SEL_Msk = 0x400
	// Bit RING_SEL.
	DMA_CH10_CTRL_TRIG_RING_SEL = 0x400
	// Position of RING_SIZE field.
	DMA_CH10_CTRL_TRIG_RING_SIZE_Pos = 0x6
	// Bit mask of RING_SIZE field.
	DMA_CH10_CTRL_TRIG_RING_SIZE_Msk       = 0x3c0
	DMA_CH10_CTRL_TRIG_RING_SIZE_RING_NONE = 0x0
	// Position of INCR_WRITE field.
	DMA_CH10_CTRL_TRIG_INCR_WRITE_Pos = 0x5
	// Bit mask of INCR_WRITE field.
	DMA_CH10_CTRL_TRIG_INCR_WRITE_Msk = 0x20
	// Bit INCR_WRITE.
	DMA_CH10_CTRL_TRIG_INCR_WRITE = 0x20
	// Position of INCR_READ field.
	DMA_CH10_CTRL_TRIG_INCR_READ_Pos = 0x4
	// Bit mask of INCR_READ field.
	DMA_CH10_CTRL_TRIG_INCR_READ_Msk = 0x10
	// Bit INCR_READ.
	DMA_CH10_CTRL_TRIG_INCR_READ = 0x10
	// Position of DATA_SIZE field.
	DMA_CH10_CTRL_TRIG_DATA_SIZE_Pos = 0x2
	// Bit mask of DATA_SIZE field.
	DMA_CH10_CTRL_TRIG_DATA_SIZE_Msk           = 0xc
	DMA_CH10_CTRL_TRIG_DATA_SIZE_SIZE_BYTE     = 0x0
	DMA_CH10_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 0x1
	DMA_CH10_CTRL_TRIG_DATA_SIZE_SIZE_WORD     = 0x2
	// Position of HIGH_PRIORITY field.
	DMA_CH10_CTRL_TRIG_HIGH_PRIORITY_Pos = 0x1
	// Bit mask of HIGH_PRIORITY field.
	DMA_CH10_CTRL_TRIG_HIGH_PRIORITY_Msk = 0x2
	// Bit HIGH_PRIORITY.
	DMA_CH10_CTRL_TRIG_HIGH_PRIORITY = 0x2
	// Position of EN field.
	DMA_CH10_CTRL_TRIG_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CH10_CTRL_TRIG_EN_Msk = 0x1
	// Bit EN.
	DMA_CH10_CTRL_TRIG_EN = 0x1

	// CH11_CTRL_TRIG: DMA Channel 11 Control and Status
	// Position of AHB_ERROR field.
	DMA_CH11_CTRL_TRIG_AHB_ERROR_Pos = 0x1f
	// Bit mask of AHB_ERROR field.
	DMA_CH11_CTRL_TRIG_AHB_ERROR_Msk = 0x80000000
	// Bit AHB_ERROR.
	DMA_CH11_CTRL_TRIG_AHB_ERROR = 0x80000000
	// Position of READ_ERROR field.
	DMA_CH11_CTRL_TRIG_READ_ERROR_Pos = 0x1e
	// Bit mask of READ_ERROR field.
	DMA_CH11_CTRL_TRIG_READ_ERROR_Msk = 0x40000000
	// Bit READ_ERROR.
	DMA_CH11_CTRL_TRIG_READ_ERROR = 0x40000000
	// Position of WRITE_ERROR field.
	DMA_CH11_CTRL_TRIG_WRITE_ERROR_Pos = 0x1d
	// Bit mask of WRITE_ERROR field.
	DMA_CH11_CTRL_TRIG_WRITE_ERROR_Msk = 0x20000000
	// Bit WRITE_ERROR.
	DMA_CH11_CTRL_TRIG_WRITE_ERROR = 0x20000000
	// Position of BUSY field.
	DMA_CH11_CTRL_TRIG_BUSY_Pos = 0x18
	// Bit mask of BUSY field.
	DMA_CH11_CTRL_TRIG_BUSY_Msk = 0x1000000
	// Bit BUSY.
	DMA_CH11_CTRL_TRIG_BUSY = 0x1000000
	// Position of SNIFF_EN field.
	DMA_CH11_CTRL_TRIG_SNIFF_EN_Pos = 0x17
	// Bit mask of SNIFF_EN field.
	DMA_CH11_CTRL_TRIG_SNIFF_EN_Msk = 0x800000
	// Bit SNIFF_EN.
	DMA_CH11_CTRL_TRIG_SNIFF_EN = 0x800000
	// Position of BSWAP field.
	DMA_CH11_CTRL_TRIG_BSWAP_Pos = 0x16
	// Bit mask of BSWAP field.
	DMA_CH11_CTRL_TRIG_BSWAP_Msk = 0x400000
	// Bit BSWAP.
	DMA_CH11_CTRL_TRIG_BSWAP = 0x400000
	// Position of IRQ_QUIET field.
	DMA_CH11_CTRL_TRIG_IRQ_QUIET_Pos = 0x15
	// Bit mask of IRQ_QUIET field.
	DMA_CH11_CTRL_TRIG_IRQ_QUIET_Msk = 0x200000
	// Bit IRQ_QUIET.
	DMA_CH11_CTRL_TRIG_IRQ_QUIET = 0x200000
	// Position of TREQ_SEL field.
	DMA_CH11_CTRL_TRIG_TREQ_SEL_Pos = 0xf
	// Bit mask of TREQ_SEL field.
	DMA_CH11_CTRL_TRIG_TREQ_SEL_Msk = 0x1f8000
	// Select Timer 0 as TREQ
	DMA_CH11_CTRL_TRIG_TREQ_SEL_TIMER0 = 0x3b
	// Select Timer 1 as TREQ
	DMA_CH11_CTRL_TRIG_TREQ_SEL_TIMER1 = 0x3c
	// Select Timer 2 as TREQ (Optional)
	DMA_CH11_CTRL_TRIG_TREQ_SEL_TIMER2 = 0x3d
	// Select Timer 3 as TREQ (Optional)
	DMA_CH11_CTRL_TRIG_TREQ_SEL_TIMER3 = 0x3e
	// Permanent request, for unpaced transfers.
	DMA_CH11_CTRL_TRIG_TREQ_SEL_PERMANENT = 0x3f
	// Position of CHAIN_TO field.
	DMA_CH11_CTRL_TRIG_CHAIN_TO_Pos = 0xb
	// Bit mask of CHAIN_TO field.
	DMA_CH11_CTRL_TRIG_CHAIN_TO_Msk = 0x7800
	// Position of RING_SEL field.
	DMA_CH11_CTRL_TRIG_RING_SEL_Pos = 0xa
	// Bit mask of RING_SEL field.
	DMA_CH11_CTRL_TRIG_RING_SEL_Msk = 0x400
	// Bit RING_SEL.
	DMA_CH11_CTRL_TRIG_RING_SEL = 0x400
	// Position of RING_SIZE field.
	DMA_CH11_CTRL_TRIG_RING_SIZE_Pos = 0x6
	// Bit mask of RING_SIZE field.
	DMA_CH11_CTRL_TRIG_RING_SIZE_Msk       = 0x3c0
	DMA_CH11_CTRL_TRIG_RING_SIZE_RING_NONE = 0x0
	// Position of INCR_WRITE field.
	DMA_CH11_CTRL_TRIG_INCR_WRITE_Pos = 0x5
	// Bit mask of INCR_WRITE field.
	DMA_CH11_CTRL_TRIG_INCR_WRITE_Msk = 0x20
	// Bit INCR_WRITE.
	DMA_CH11_CTRL_TRIG_INCR_WRITE = 0x20
	// Position of INCR_READ field.
	DMA_CH11_CTRL_TRIG_INCR_READ_Pos = 0x4
	// Bit mask of INCR_READ field.
	DMA_CH11_CTRL_TRIG_INCR_READ_Msk = 0x10
	// Bit INCR_READ.
	DMA_CH11_CTRL_TRIG_INCR_READ = 0x10
	// Position of DATA_SIZE field.
	DMA_CH11_CTRL_TRIG_DATA_SIZE_Pos = 0x2
	// Bit mask of DATA_SIZE field.
	DMA_CH11_CTRL_TRIG_DATA_SIZE_Msk           = 0xc
	DMA_CH11_CTRL_TRIG_DATA_SIZE_SIZE_BYTE     = 0x0
	DMA_CH11_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 0x1
	DMA_CH11_CTRL_TRIG_DATA_SIZE_SIZE_WORD     = 0x2
	// Position of HIGH_PRIORITY field.
	DMA_CH11_CTRL_TRIG_HIGH_PRIORITY_Pos = 0x1
	// Bit mask of HIGH_PRIORITY field.
	DMA_CH11_CTRL_TRIG_HIGH_PRIORITY_Msk = 0x2
	// Bit HIGH_PRIORITY.
	DMA_CH11_CTRL_TRIG_HIGH_PRIORITY = 0x2
	// Position of EN field.
	DMA_CH11_CTRL_TRIG_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_CH11_CTRL_TRIG_EN_Msk = 0x1
	// Bit EN.
	DMA_CH11_CTRL_TRIG_EN = 0x1

	// INTR: Interrupt Status (raw)
	// Position of INTR field.
	DMA_INTR_INTR_Pos = 0x0
	// Bit mask of INTR field.
	DMA_INTR_INTR_Msk = 0xffff

	// INTE0: Interrupt Enables for IRQ 0
	// Position of INTE0 field.
	DMA_INTE0_INTE0_Pos = 0x0
	// Bit mask of INTE0 field.
	DMA_INTE0_INTE0_Msk = 0xffff

	// INTF0: Force Interrupts
	// Position of INTF0 field.
	DMA_INTF0_INTF0_Pos = 0x0
	// Bit mask of INTF0 field.
	DMA_INTF0_INTF0_Msk = 0xffff

	// INTS0: Interrupt Status for IRQ 0
	// Position of INTS0 field.
	DMA_INTS0_INTS0_Pos = 0x0
	// Bit mask of INTS0 field.
	DMA_INTS0_INTS0_Msk = 0xffff

	// INTE1: Interrupt Enables for IRQ 1
	// Position of INTE1 field.
	DMA_INTE1_INTE1_Pos = 0x0
	// Bit mask of INTE1 field.
	DMA_INTE1_INTE1_Msk = 0xffff

	// INTF1: Force Interrupts for IRQ 1
	// Position of INTF1 field.
	DMA_INTF1_INTF1_Pos = 0x0
	// Bit mask of INTF1 field.
	DMA_INTF1_INTF1_Msk = 0xffff

	// INTS1: Interrupt Status (masked) for IRQ 1
	// Position of INTS1 field.
	DMA_INTS1_INTS1_Pos = 0x0
	// Bit mask of INTS1 field.
	DMA_INTS1_INTS1_Msk = 0xffff

	// TIMER0
	// Pacing (X/Y) Fractional Timer
	// The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
	// Position of X field.
	DMA_TIMER0_X_Pos = 0x10
	// Bit mask of X field.
	DMA_TIMER0_X_Msk = 0xffff0000
	// Position of Y field.
	DMA_TIMER0_Y_Pos = 0x0
	// Bit mask of Y field.
	DMA_TIMER0_Y_Msk = 0xffff

	// TIMER1
	// Pacing (X/Y) Fractional Timer
	// The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
	// Position of X field.
	DMA_TIMER1_X_Pos = 0x10
	// Bit mask of X field.
	DMA_TIMER1_X_Msk = 0xffff0000
	// Position of Y field.
	DMA_TIMER1_Y_Pos = 0x0
	// Bit mask of Y field.
	DMA_TIMER1_Y_Msk = 0xffff

	// MULTI_CHAN_TRIGGER: Trigger one or more channels simultaneously
	// Position of MULTI_CHAN_TRIGGER field.
	DMA_MULTI_CHAN_TRIGGER_MULTI_CHAN_TRIGGER_Pos = 0x0
	// Bit mask of MULTI_CHAN_TRIGGER field.
	DMA_MULTI_CHAN_TRIGGER_MULTI_CHAN_TRIGGER_Msk = 0xffff

	// SNIFF_CTRL: Sniffer Control
	// Position of OUT_INV field.
	DMA_SNIFF_CTRL_OUT_INV_Pos = 0xb
	// Bit mask of OUT_INV field.
	DMA_SNIFF_CTRL_OUT_INV_Msk = 0x800
	// Bit OUT_INV.
	DMA_SNIFF_CTRL_OUT_INV = 0x800
	// Position of OUT_REV field.
	DMA_SNIFF_CTRL_OUT_REV_Pos = 0xa
	// Bit mask of OUT_REV field.
	DMA_SNIFF_CTRL_OUT_REV_Msk = 0x400
	// Bit OUT_REV.
	DMA_SNIFF_CTRL_OUT_REV = 0x400
	// Position of BSWAP field.
	DMA_SNIFF_CTRL_BSWAP_Pos = 0x9
	// Bit mask of BSWAP field.
	DMA_SNIFF_CTRL_BSWAP_Msk = 0x200
	// Bit BSWAP.
	DMA_SNIFF_CTRL_BSWAP = 0x200
	// Position of CALC field.
	DMA_SNIFF_CTRL_CALC_Pos = 0x5
	// Bit mask of CALC field.
	DMA_SNIFF_CTRL_CALC_Msk = 0x1e0
	// Calculate a CRC-32 (IEEE802.3 polynomial)
	DMA_SNIFF_CTRL_CALC_CRC32 = 0x0
	// Calculate a CRC-32 (IEEE802.3 polynomial) with bit reversed data
	DMA_SNIFF_CTRL_CALC_CRC32R = 0x1
	// Calculate a CRC-16-CCITT
	DMA_SNIFF_CTRL_CALC_CRC16 = 0x2
	// Calculate a CRC-16-CCITT with bit reversed data
	DMA_SNIFF_CTRL_CALC_CRC16R = 0x3
	// XOR reduction over all data. == 1 if the total 1 population count is odd.
	DMA_SNIFF_CTRL_CALC_EVEN = 0xe
	// Calculate a simple 32-bit checksum (addition with a 32 bit accumulator)
	DMA_SNIFF_CTRL_CALC_SUM = 0xf
	// Position of DMACH field.
	DMA_SNIFF_CTRL_DMACH_Pos = 0x1
	// Bit mask of DMACH field.
	DMA_SNIFF_CTRL_DMACH_Msk = 0x1e
	// Position of EN field.
	DMA_SNIFF_CTRL_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_SNIFF_CTRL_EN_Msk = 0x1
	// Bit EN.
	DMA_SNIFF_CTRL_EN = 0x1

	// FIFO_LEVELS: Debug RAF, WAF, TDF levels
	// Position of RAF_LVL field.
	DMA_FIFO_LEVELS_RAF_LVL_Pos = 0x10
	// Bit mask of RAF_LVL field.
	DMA_FIFO_LEVELS_RAF_LVL_Msk = 0xff0000
	// Position of WAF_LVL field.
	DMA_FIFO_LEVELS_WAF_LVL_Pos = 0x8
	// Bit mask of WAF_LVL field.
	DMA_FIFO_LEVELS_WAF_LVL_Msk = 0xff00
	// Position of TDF_LVL field.
	DMA_FIFO_LEVELS_TDF_LVL_Pos = 0x0
	// Bit mask of TDF_LVL field.
	DMA_FIFO_LEVELS_TDF_LVL_Msk = 0xff

	// CHAN_ABORT: Abort an in-progress transfer sequence on one or more channels
	// Position of CHAN_ABORT field.
	DMA_CHAN_ABORT_CHAN_ABORT_Pos = 0x0
	// Bit mask of CHAN_ABORT field.
	DMA_CHAN_ABORT_CHAN_ABORT_Msk = 0xffff

	// N_CHANNELS: The number of channels this DMA instance is equipped with. This DMA supports up to 16 hardware channels, but can be configured with as few as one, to minimise silicon area.
	// Position of N_CHANNELS field.
	DMA_N_CHANNELS_N_CHANNELS_Pos = 0x0
	// Bit mask of N_CHANNELS field.
	DMA_N_CHANNELS_N_CHANNELS_Msk = 0x1f

	// CH0_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
	// Position of CH0_DBG_CTDREQ field.
	DMA_CH0_DBG_CTDREQ_CH0_DBG_CTDREQ_Pos = 0x0
	// Bit mask of CH0_DBG_CTDREQ field.
	DMA_CH0_DBG_CTDREQ_CH0_DBG_CTDREQ_Msk = 0x3f

	// CH1_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
	// Position of CH1_DBG_CTDREQ field.
	DMA_CH1_DBG_CTDREQ_CH1_DBG_CTDREQ_Pos = 0x0
	// Bit mask of CH1_DBG_CTDREQ field.
	DMA_CH1_DBG_CTDREQ_CH1_DBG_CTDREQ_Msk = 0x3f

	// CH2_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
	// Position of CH2_DBG_CTDREQ field.
	DMA_CH2_DBG_CTDREQ_CH2_DBG_CTDREQ_Pos = 0x0
	// Bit mask of CH2_DBG_CTDREQ field.
	DMA_CH2_DBG_CTDREQ_CH2_DBG_CTDREQ_Msk = 0x3f

	// CH3_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
	// Position of CH3_DBG_CTDREQ field.
	DMA_CH3_DBG_CTDREQ_CH3_DBG_CTDREQ_Pos = 0x0
	// Bit mask of CH3_DBG_CTDREQ field.
	DMA_CH3_DBG_CTDREQ_CH3_DBG_CTDREQ_Msk = 0x3f

	// CH4_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
	// Position of CH4_DBG_CTDREQ field.
	DMA_CH4_DBG_CTDREQ_CH4_DBG_CTDREQ_Pos = 0x0
	// Bit mask of CH4_DBG_CTDREQ field.
	DMA_CH4_DBG_CTDREQ_CH4_DBG_CTDREQ_Msk = 0x3f

	// CH5_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
	// Position of CH5_DBG_CTDREQ field.
	DMA_CH5_DBG_CTDREQ_CH5_DBG_CTDREQ_Pos = 0x0
	// Bit mask of CH5_DBG_CTDREQ field.
	DMA_CH5_DBG_CTDREQ_CH5_DBG_CTDREQ_Msk = 0x3f

	// CH6_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
	// Position of CH6_DBG_CTDREQ field.
	DMA_CH6_DBG_CTDREQ_CH6_DBG_CTDREQ_Pos = 0x0
	// Bit mask of CH6_DBG_CTDREQ field.
	DMA_CH6_DBG_CTDREQ_CH6_DBG_CTDREQ_Msk = 0x3f

	// CH7_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
	// Position of CH7_DBG_CTDREQ field.
	DMA_CH7_DBG_CTDREQ_CH7_DBG_CTDREQ_Pos = 0x0
	// Bit mask of CH7_DBG_CTDREQ field.
	DMA_CH7_DBG_CTDREQ_CH7_DBG_CTDREQ_Msk = 0x3f

	// CH8_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
	// Position of CH8_DBG_CTDREQ field.
	DMA_CH8_DBG_CTDREQ_CH8_DBG_CTDREQ_Pos = 0x0
	// Bit mask of CH8_DBG_CTDREQ field.
	DMA_CH8_DBG_CTDREQ_CH8_DBG_CTDREQ_Msk = 0x3f

	// CH9_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
	// Position of CH9_DBG_CTDREQ field.
	DMA_CH9_DBG_CTDREQ_CH9_DBG_CTDREQ_Pos = 0x0
	// Bit mask of CH9_DBG_CTDREQ field.
	DMA_CH9_DBG_CTDREQ_CH9_DBG_CTDREQ_Msk = 0x3f

	// CH10_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
	// Position of CH10_DBG_CTDREQ field.
	DMA_CH10_DBG_CTDREQ_CH10_DBG_CTDREQ_Pos = 0x0
	// Bit mask of CH10_DBG_CTDREQ field.
	DMA_CH10_DBG_CTDREQ_CH10_DBG_CTDREQ_Msk = 0x3f

	// CH11_DBG_CTDREQ: Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
	// Position of CH11_DBG_CTDREQ field.
	DMA_CH11_DBG_CTDREQ_CH11_DBG_CTDREQ_Pos = 0x0
	// Bit mask of CH11_DBG_CTDREQ field.
	DMA_CH11_DBG_CTDREQ_CH11_DBG_CTDREQ_Msk = 0x3f
)

// Constants for USBCTRL_REGS: USB FS/LS controller device registers
const (
	// ADDR_ENDP: Device address and endpoint control
	// Position of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP_ENDPOINT_Pos = 0x10
	// Bit mask of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP_ENDPOINT_Msk = 0xf0000
	// Position of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP_ADDRESS_Msk = 0x7f

	// ADDR_ENDP1: Interrupt endpoint 1. Only valid for HOST mode.
	// Position of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP1_INTEP_PREAMBLE_Pos = 0x1a
	// Bit mask of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP1_INTEP_PREAMBLE_Msk = 0x4000000
	// Bit INTEP_PREAMBLE.
	USBCTRL_REGS_ADDR_ENDP1_INTEP_PREAMBLE = 0x4000000
	// Position of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP1_INTEP_DIR_Pos = 0x19
	// Bit mask of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP1_INTEP_DIR_Msk = 0x2000000
	// Bit INTEP_DIR.
	USBCTRL_REGS_ADDR_ENDP1_INTEP_DIR = 0x2000000
	// Position of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP1_ENDPOINT_Pos = 0x10
	// Bit mask of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP1_ENDPOINT_Msk = 0xf0000
	// Position of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP1_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP1_ADDRESS_Msk = 0x7f

	// ADDR_ENDP2: Interrupt endpoint 2. Only valid for HOST mode.
	// Position of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP2_INTEP_PREAMBLE_Pos = 0x1a
	// Bit mask of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP2_INTEP_PREAMBLE_Msk = 0x4000000
	// Bit INTEP_PREAMBLE.
	USBCTRL_REGS_ADDR_ENDP2_INTEP_PREAMBLE = 0x4000000
	// Position of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP2_INTEP_DIR_Pos = 0x19
	// Bit mask of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP2_INTEP_DIR_Msk = 0x2000000
	// Bit INTEP_DIR.
	USBCTRL_REGS_ADDR_ENDP2_INTEP_DIR = 0x2000000
	// Position of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP2_ENDPOINT_Pos = 0x10
	// Bit mask of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP2_ENDPOINT_Msk = 0xf0000
	// Position of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP2_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP2_ADDRESS_Msk = 0x7f

	// ADDR_ENDP3: Interrupt endpoint 3. Only valid for HOST mode.
	// Position of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP3_INTEP_PREAMBLE_Pos = 0x1a
	// Bit mask of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP3_INTEP_PREAMBLE_Msk = 0x4000000
	// Bit INTEP_PREAMBLE.
	USBCTRL_REGS_ADDR_ENDP3_INTEP_PREAMBLE = 0x4000000
	// Position of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP3_INTEP_DIR_Pos = 0x19
	// Bit mask of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP3_INTEP_DIR_Msk = 0x2000000
	// Bit INTEP_DIR.
	USBCTRL_REGS_ADDR_ENDP3_INTEP_DIR = 0x2000000
	// Position of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP3_ENDPOINT_Pos = 0x10
	// Bit mask of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP3_ENDPOINT_Msk = 0xf0000
	// Position of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP3_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP3_ADDRESS_Msk = 0x7f

	// ADDR_ENDP4: Interrupt endpoint 4. Only valid for HOST mode.
	// Position of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP4_INTEP_PREAMBLE_Pos = 0x1a
	// Bit mask of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP4_INTEP_PREAMBLE_Msk = 0x4000000
	// Bit INTEP_PREAMBLE.
	USBCTRL_REGS_ADDR_ENDP4_INTEP_PREAMBLE = 0x4000000
	// Position of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP4_INTEP_DIR_Pos = 0x19
	// Bit mask of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP4_INTEP_DIR_Msk = 0x2000000
	// Bit INTEP_DIR.
	USBCTRL_REGS_ADDR_ENDP4_INTEP_DIR = 0x2000000
	// Position of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP4_ENDPOINT_Pos = 0x10
	// Bit mask of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP4_ENDPOINT_Msk = 0xf0000
	// Position of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP4_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP4_ADDRESS_Msk = 0x7f

	// ADDR_ENDP5: Interrupt endpoint 5. Only valid for HOST mode.
	// Position of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP5_INTEP_PREAMBLE_Pos = 0x1a
	// Bit mask of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP5_INTEP_PREAMBLE_Msk = 0x4000000
	// Bit INTEP_PREAMBLE.
	USBCTRL_REGS_ADDR_ENDP5_INTEP_PREAMBLE = 0x4000000
	// Position of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP5_INTEP_DIR_Pos = 0x19
	// Bit mask of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP5_INTEP_DIR_Msk = 0x2000000
	// Bit INTEP_DIR.
	USBCTRL_REGS_ADDR_ENDP5_INTEP_DIR = 0x2000000
	// Position of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP5_ENDPOINT_Pos = 0x10
	// Bit mask of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP5_ENDPOINT_Msk = 0xf0000
	// Position of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP5_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP5_ADDRESS_Msk = 0x7f

	// ADDR_ENDP6: Interrupt endpoint 6. Only valid for HOST mode.
	// Position of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP6_INTEP_PREAMBLE_Pos = 0x1a
	// Bit mask of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP6_INTEP_PREAMBLE_Msk = 0x4000000
	// Bit INTEP_PREAMBLE.
	USBCTRL_REGS_ADDR_ENDP6_INTEP_PREAMBLE = 0x4000000
	// Position of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP6_INTEP_DIR_Pos = 0x19
	// Bit mask of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP6_INTEP_DIR_Msk = 0x2000000
	// Bit INTEP_DIR.
	USBCTRL_REGS_ADDR_ENDP6_INTEP_DIR = 0x2000000
	// Position of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP6_ENDPOINT_Pos = 0x10
	// Bit mask of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP6_ENDPOINT_Msk = 0xf0000
	// Position of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP6_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP6_ADDRESS_Msk = 0x7f

	// ADDR_ENDP7: Interrupt endpoint 7. Only valid for HOST mode.
	// Position of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP7_INTEP_PREAMBLE_Pos = 0x1a
	// Bit mask of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP7_INTEP_PREAMBLE_Msk = 0x4000000
	// Bit INTEP_PREAMBLE.
	USBCTRL_REGS_ADDR_ENDP7_INTEP_PREAMBLE = 0x4000000
	// Position of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP7_INTEP_DIR_Pos = 0x19
	// Bit mask of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP7_INTEP_DIR_Msk = 0x2000000
	// Bit INTEP_DIR.
	USBCTRL_REGS_ADDR_ENDP7_INTEP_DIR = 0x2000000
	// Position of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP7_ENDPOINT_Pos = 0x10
	// Bit mask of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP7_ENDPOINT_Msk = 0xf0000
	// Position of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP7_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP7_ADDRESS_Msk = 0x7f

	// ADDR_ENDP8: Interrupt endpoint 8. Only valid for HOST mode.
	// Position of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP8_INTEP_PREAMBLE_Pos = 0x1a
	// Bit mask of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP8_INTEP_PREAMBLE_Msk = 0x4000000
	// Bit INTEP_PREAMBLE.
	USBCTRL_REGS_ADDR_ENDP8_INTEP_PREAMBLE = 0x4000000
	// Position of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP8_INTEP_DIR_Pos = 0x19
	// Bit mask of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP8_INTEP_DIR_Msk = 0x2000000
	// Bit INTEP_DIR.
	USBCTRL_REGS_ADDR_ENDP8_INTEP_DIR = 0x2000000
	// Position of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP8_ENDPOINT_Pos = 0x10
	// Bit mask of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP8_ENDPOINT_Msk = 0xf0000
	// Position of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP8_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP8_ADDRESS_Msk = 0x7f

	// ADDR_ENDP9: Interrupt endpoint 9. Only valid for HOST mode.
	// Position of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP9_INTEP_PREAMBLE_Pos = 0x1a
	// Bit mask of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP9_INTEP_PREAMBLE_Msk = 0x4000000
	// Bit INTEP_PREAMBLE.
	USBCTRL_REGS_ADDR_ENDP9_INTEP_PREAMBLE = 0x4000000
	// Position of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP9_INTEP_DIR_Pos = 0x19
	// Bit mask of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP9_INTEP_DIR_Msk = 0x2000000
	// Bit INTEP_DIR.
	USBCTRL_REGS_ADDR_ENDP9_INTEP_DIR = 0x2000000
	// Position of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP9_ENDPOINT_Pos = 0x10
	// Bit mask of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP9_ENDPOINT_Msk = 0xf0000
	// Position of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP9_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP9_ADDRESS_Msk = 0x7f

	// ADDR_ENDP10: Interrupt endpoint 10. Only valid for HOST mode.
	// Position of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP10_INTEP_PREAMBLE_Pos = 0x1a
	// Bit mask of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP10_INTEP_PREAMBLE_Msk = 0x4000000
	// Bit INTEP_PREAMBLE.
	USBCTRL_REGS_ADDR_ENDP10_INTEP_PREAMBLE = 0x4000000
	// Position of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP10_INTEP_DIR_Pos = 0x19
	// Bit mask of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP10_INTEP_DIR_Msk = 0x2000000
	// Bit INTEP_DIR.
	USBCTRL_REGS_ADDR_ENDP10_INTEP_DIR = 0x2000000
	// Position of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP10_ENDPOINT_Pos = 0x10
	// Bit mask of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP10_ENDPOINT_Msk = 0xf0000
	// Position of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP10_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP10_ADDRESS_Msk = 0x7f

	// ADDR_ENDP11: Interrupt endpoint 11. Only valid for HOST mode.
	// Position of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP11_INTEP_PREAMBLE_Pos = 0x1a
	// Bit mask of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP11_INTEP_PREAMBLE_Msk = 0x4000000
	// Bit INTEP_PREAMBLE.
	USBCTRL_REGS_ADDR_ENDP11_INTEP_PREAMBLE = 0x4000000
	// Position of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP11_INTEP_DIR_Pos = 0x19
	// Bit mask of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP11_INTEP_DIR_Msk = 0x2000000
	// Bit INTEP_DIR.
	USBCTRL_REGS_ADDR_ENDP11_INTEP_DIR = 0x2000000
	// Position of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP11_ENDPOINT_Pos = 0x10
	// Bit mask of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP11_ENDPOINT_Msk = 0xf0000
	// Position of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP11_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP11_ADDRESS_Msk = 0x7f

	// ADDR_ENDP12: Interrupt endpoint 12. Only valid for HOST mode.
	// Position of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP12_INTEP_PREAMBLE_Pos = 0x1a
	// Bit mask of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP12_INTEP_PREAMBLE_Msk = 0x4000000
	// Bit INTEP_PREAMBLE.
	USBCTRL_REGS_ADDR_ENDP12_INTEP_PREAMBLE = 0x4000000
	// Position of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP12_INTEP_DIR_Pos = 0x19
	// Bit mask of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP12_INTEP_DIR_Msk = 0x2000000
	// Bit INTEP_DIR.
	USBCTRL_REGS_ADDR_ENDP12_INTEP_DIR = 0x2000000
	// Position of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP12_ENDPOINT_Pos = 0x10
	// Bit mask of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP12_ENDPOINT_Msk = 0xf0000
	// Position of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP12_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP12_ADDRESS_Msk = 0x7f

	// ADDR_ENDP13: Interrupt endpoint 13. Only valid for HOST mode.
	// Position of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP13_INTEP_PREAMBLE_Pos = 0x1a
	// Bit mask of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP13_INTEP_PREAMBLE_Msk = 0x4000000
	// Bit INTEP_PREAMBLE.
	USBCTRL_REGS_ADDR_ENDP13_INTEP_PREAMBLE = 0x4000000
	// Position of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP13_INTEP_DIR_Pos = 0x19
	// Bit mask of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP13_INTEP_DIR_Msk = 0x2000000
	// Bit INTEP_DIR.
	USBCTRL_REGS_ADDR_ENDP13_INTEP_DIR = 0x2000000
	// Position of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP13_ENDPOINT_Pos = 0x10
	// Bit mask of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP13_ENDPOINT_Msk = 0xf0000
	// Position of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP13_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP13_ADDRESS_Msk = 0x7f

	// ADDR_ENDP14: Interrupt endpoint 14. Only valid for HOST mode.
	// Position of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP14_INTEP_PREAMBLE_Pos = 0x1a
	// Bit mask of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP14_INTEP_PREAMBLE_Msk = 0x4000000
	// Bit INTEP_PREAMBLE.
	USBCTRL_REGS_ADDR_ENDP14_INTEP_PREAMBLE = 0x4000000
	// Position of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP14_INTEP_DIR_Pos = 0x19
	// Bit mask of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP14_INTEP_DIR_Msk = 0x2000000
	// Bit INTEP_DIR.
	USBCTRL_REGS_ADDR_ENDP14_INTEP_DIR = 0x2000000
	// Position of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP14_ENDPOINT_Pos = 0x10
	// Bit mask of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP14_ENDPOINT_Msk = 0xf0000
	// Position of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP14_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP14_ADDRESS_Msk = 0x7f

	// ADDR_ENDP15: Interrupt endpoint 15. Only valid for HOST mode.
	// Position of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP15_INTEP_PREAMBLE_Pos = 0x1a
	// Bit mask of INTEP_PREAMBLE field.
	USBCTRL_REGS_ADDR_ENDP15_INTEP_PREAMBLE_Msk = 0x4000000
	// Bit INTEP_PREAMBLE.
	USBCTRL_REGS_ADDR_ENDP15_INTEP_PREAMBLE = 0x4000000
	// Position of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP15_INTEP_DIR_Pos = 0x19
	// Bit mask of INTEP_DIR field.
	USBCTRL_REGS_ADDR_ENDP15_INTEP_DIR_Msk = 0x2000000
	// Bit INTEP_DIR.
	USBCTRL_REGS_ADDR_ENDP15_INTEP_DIR = 0x2000000
	// Position of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP15_ENDPOINT_Pos = 0x10
	// Bit mask of ENDPOINT field.
	USBCTRL_REGS_ADDR_ENDP15_ENDPOINT_Msk = 0xf0000
	// Position of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP15_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	USBCTRL_REGS_ADDR_ENDP15_ADDRESS_Msk = 0x7f

	// MAIN_CTRL: Main control register
	// Position of SIM_TIMING field.
	USBCTRL_REGS_MAIN_CTRL_SIM_TIMING_Pos = 0x1f
	// Bit mask of SIM_TIMING field.
	USBCTRL_REGS_MAIN_CTRL_SIM_TIMING_Msk = 0x80000000
	// Bit SIM_TIMING.
	USBCTRL_REGS_MAIN_CTRL_SIM_TIMING = 0x80000000
	// Position of HOST_NDEVICE field.
	USBCTRL_REGS_MAIN_CTRL_HOST_NDEVICE_Pos = 0x1
	// Bit mask of HOST_NDEVICE field.
	USBCTRL_REGS_MAIN_CTRL_HOST_NDEVICE_Msk = 0x2
	// Bit HOST_NDEVICE.
	USBCTRL_REGS_MAIN_CTRL_HOST_NDEVICE = 0x2
	// Position of CONTROLLER_EN field.
	USBCTRL_REGS_MAIN_CTRL_CONTROLLER_EN_Pos = 0x0
	// Bit mask of CONTROLLER_EN field.
	USBCTRL_REGS_MAIN_CTRL_CONTROLLER_EN_Msk = 0x1
	// Bit CONTROLLER_EN.
	USBCTRL_REGS_MAIN_CTRL_CONTROLLER_EN = 0x1

	// SOF_WR: Set the SOF (Start of Frame) frame number in the host controller. The SOF packet is sent every 1ms and the host will increment the frame number by 1 each time.
	// Position of COUNT field.
	USBCTRL_REGS_SOF_WR_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	USBCTRL_REGS_SOF_WR_COUNT_Msk = 0x7ff

	// SOF_RD: Read the last SOF (Start of Frame) frame number seen. In device mode the last SOF received from the host. In host mode the last SOF sent by the host.
	// Position of COUNT field.
	USBCTRL_REGS_SOF_RD_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	USBCTRL_REGS_SOF_RD_COUNT_Msk = 0x7ff

	// SIE_CTRL: SIE control register
	// Position of EP0_INT_STALL field.
	USBCTRL_REGS_SIE_CTRL_EP0_INT_STALL_Pos = 0x1f
	// Bit mask of EP0_INT_STALL field.
	USBCTRL_REGS_SIE_CTRL_EP0_INT_STALL_Msk = 0x80000000
	// Bit EP0_INT_STALL.
	USBCTRL_REGS_SIE_CTRL_EP0_INT_STALL = 0x80000000
	// Position of EP0_DOUBLE_BUF field.
	USBCTRL_REGS_SIE_CTRL_EP0_DOUBLE_BUF_Pos = 0x1e
	// Bit mask of EP0_DOUBLE_BUF field.
	USBCTRL_REGS_SIE_CTRL_EP0_DOUBLE_BUF_Msk = 0x40000000
	// Bit EP0_DOUBLE_BUF.
	USBCTRL_REGS_SIE_CTRL_EP0_DOUBLE_BUF = 0x40000000
	// Position of EP0_INT_1BUF field.
	USBCTRL_REGS_SIE_CTRL_EP0_INT_1BUF_Pos = 0x1d
	// Bit mask of EP0_INT_1BUF field.
	USBCTRL_REGS_SIE_CTRL_EP0_INT_1BUF_Msk = 0x20000000
	// Bit EP0_INT_1BUF.
	USBCTRL_REGS_SIE_CTRL_EP0_INT_1BUF = 0x20000000
	// Position of EP0_INT_2BUF field.
	USBCTRL_REGS_SIE_CTRL_EP0_INT_2BUF_Pos = 0x1c
	// Bit mask of EP0_INT_2BUF field.
	USBCTRL_REGS_SIE_CTRL_EP0_INT_2BUF_Msk = 0x10000000
	// Bit EP0_INT_2BUF.
	USBCTRL_REGS_SIE_CTRL_EP0_INT_2BUF = 0x10000000
	// Position of EP0_INT_NAK field.
	USBCTRL_REGS_SIE_CTRL_EP0_INT_NAK_Pos = 0x1b
	// Bit mask of EP0_INT_NAK field.
	USBCTRL_REGS_SIE_CTRL_EP0_INT_NAK_Msk = 0x8000000
	// Bit EP0_INT_NAK.
	USBCTRL_REGS_SIE_CTRL_EP0_INT_NAK = 0x8000000
	// Position of DIRECT_EN field.
	USBCTRL_REGS_SIE_CTRL_DIRECT_EN_Pos = 0x1a
	// Bit mask of DIRECT_EN field.
	USBCTRL_REGS_SIE_CTRL_DIRECT_EN_Msk = 0x4000000
	// Bit DIRECT_EN.
	USBCTRL_REGS_SIE_CTRL_DIRECT_EN = 0x4000000
	// Position of DIRECT_DP field.
	USBCTRL_REGS_SIE_CTRL_DIRECT_DP_Pos = 0x19
	// Bit mask of DIRECT_DP field.
	USBCTRL_REGS_SIE_CTRL_DIRECT_DP_Msk = 0x2000000
	// Bit DIRECT_DP.
	USBCTRL_REGS_SIE_CTRL_DIRECT_DP = 0x2000000
	// Position of DIRECT_DM field.
	USBCTRL_REGS_SIE_CTRL_DIRECT_DM_Pos = 0x18
	// Bit mask of DIRECT_DM field.
	USBCTRL_REGS_SIE_CTRL_DIRECT_DM_Msk = 0x1000000
	// Bit DIRECT_DM.
	USBCTRL_REGS_SIE_CTRL_DIRECT_DM = 0x1000000
	// Position of TRANSCEIVER_PD field.
	USBCTRL_REGS_SIE_CTRL_TRANSCEIVER_PD_Pos = 0x12
	// Bit mask of TRANSCEIVER_PD field.
	USBCTRL_REGS_SIE_CTRL_TRANSCEIVER_PD_Msk = 0x40000
	// Bit TRANSCEIVER_PD.
	USBCTRL_REGS_SIE_CTRL_TRANSCEIVER_PD = 0x40000
	// Position of RPU_OPT field.
	USBCTRL_REGS_SIE_CTRL_RPU_OPT_Pos = 0x11
	// Bit mask of RPU_OPT field.
	USBCTRL_REGS_SIE_CTRL_RPU_OPT_Msk = 0x20000
	// Bit RPU_OPT.
	USBCTRL_REGS_SIE_CTRL_RPU_OPT = 0x20000
	// Position of PULLUP_EN field.
	USBCTRL_REGS_SIE_CTRL_PULLUP_EN_Pos = 0x10
	// Bit mask of PULLUP_EN field.
	USBCTRL_REGS_SIE_CTRL_PULLUP_EN_Msk = 0x10000
	// Bit PULLUP_EN.
	USBCTRL_REGS_SIE_CTRL_PULLUP_EN = 0x10000
	// Position of PULLDOWN_EN field.
	USBCTRL_REGS_SIE_CTRL_PULLDOWN_EN_Pos = 0xf
	// Bit mask of PULLDOWN_EN field.
	USBCTRL_REGS_SIE_CTRL_PULLDOWN_EN_Msk = 0x8000
	// Bit PULLDOWN_EN.
	USBCTRL_REGS_SIE_CTRL_PULLDOWN_EN = 0x8000
	// Position of RESET_BUS field.
	USBCTRL_REGS_SIE_CTRL_RESET_BUS_Pos = 0xd
	// Bit mask of RESET_BUS field.
	USBCTRL_REGS_SIE_CTRL_RESET_BUS_Msk = 0x2000
	// Bit RESET_BUS.
	USBCTRL_REGS_SIE_CTRL_RESET_BUS = 0x2000
	// Position of RESUME field.
	USBCTRL_REGS_SIE_CTRL_RESUME_Pos = 0xc
	// Bit mask of RESUME field.
	USBCTRL_REGS_SIE_CTRL_RESUME_Msk = 0x1000
	// Bit RESUME.
	USBCTRL_REGS_SIE_CTRL_RESUME = 0x1000
	// Position of VBUS_EN field.
	USBCTRL_REGS_SIE_CTRL_VBUS_EN_Pos = 0xb
	// Bit mask of VBUS_EN field.
	USBCTRL_REGS_SIE_CTRL_VBUS_EN_Msk = 0x800
	// Bit VBUS_EN.
	USBCTRL_REGS_SIE_CTRL_VBUS_EN = 0x800
	// Position of KEEP_ALIVE_EN field.
	USBCTRL_REGS_SIE_CTRL_KEEP_ALIVE_EN_Pos = 0xa
	// Bit mask of KEEP_ALIVE_EN field.
	USBCTRL_REGS_SIE_CTRL_KEEP_ALIVE_EN_Msk = 0x400
	// Bit KEEP_ALIVE_EN.
	USBCTRL_REGS_SIE_CTRL_KEEP_ALIVE_EN = 0x400
	// Position of SOF_EN field.
	USBCTRL_REGS_SIE_CTRL_SOF_EN_Pos = 0x9
	// Bit mask of SOF_EN field.
	USBCTRL_REGS_SIE_CTRL_SOF_EN_Msk = 0x200
	// Bit SOF_EN.
	USBCTRL_REGS_SIE_CTRL_SOF_EN = 0x200
	// Position of SOF_SYNC field.
	USBCTRL_REGS_SIE_CTRL_SOF_SYNC_Pos = 0x8
	// Bit mask of SOF_SYNC field.
	USBCTRL_REGS_SIE_CTRL_SOF_SYNC_Msk = 0x100
	// Bit SOF_SYNC.
	USBCTRL_REGS_SIE_CTRL_SOF_SYNC = 0x100
	// Position of PREAMBLE_EN field.
	USBCTRL_REGS_SIE_CTRL_PREAMBLE_EN_Pos = 0x6
	// Bit mask of PREAMBLE_EN field.
	USBCTRL_REGS_SIE_CTRL_PREAMBLE_EN_Msk = 0x40
	// Bit PREAMBLE_EN.
	USBCTRL_REGS_SIE_CTRL_PREAMBLE_EN = 0x40
	// Position of STOP_TRANS field.
	USBCTRL_REGS_SIE_CTRL_STOP_TRANS_Pos = 0x4
	// Bit mask of STOP_TRANS field.
	USBCTRL_REGS_SIE_CTRL_STOP_TRANS_Msk = 0x10
	// Bit STOP_TRANS.
	USBCTRL_REGS_SIE_CTRL_STOP_TRANS = 0x10
	// Position of RECEIVE_DATA field.
	USBCTRL_REGS_SIE_CTRL_RECEIVE_DATA_Pos = 0x3
	// Bit mask of RECEIVE_DATA field.
	USBCTRL_REGS_SIE_CTRL_RECEIVE_DATA_Msk = 0x8
	// Bit RECEIVE_DATA.
	USBCTRL_REGS_SIE_CTRL_RECEIVE_DATA = 0x8
	// Position of SEND_DATA field.
	USBCTRL_REGS_SIE_CTRL_SEND_DATA_Pos = 0x2
	// Bit mask of SEND_DATA field.
	USBCTRL_REGS_SIE_CTRL_SEND_DATA_Msk = 0x4
	// Bit SEND_DATA.
	USBCTRL_REGS_SIE_CTRL_SEND_DATA = 0x4
	// Position of SEND_SETUP field.
	USBCTRL_REGS_SIE_CTRL_SEND_SETUP_Pos = 0x1
	// Bit mask of SEND_SETUP field.
	USBCTRL_REGS_SIE_CTRL_SEND_SETUP_Msk = 0x2
	// Bit SEND_SETUP.
	USBCTRL_REGS_SIE_CTRL_SEND_SETUP = 0x2
	// Position of START_TRANS field.
	USBCTRL_REGS_SIE_CTRL_START_TRANS_Pos = 0x0
	// Bit mask of START_TRANS field.
	USBCTRL_REGS_SIE_CTRL_START_TRANS_Msk = 0x1
	// Bit START_TRANS.
	USBCTRL_REGS_SIE_CTRL_START_TRANS = 0x1

	// SIE_STATUS: SIE status register
	// Position of DATA_SEQ_ERROR field.
	USBCTRL_REGS_SIE_STATUS_DATA_SEQ_ERROR_Pos = 0x1f
	// Bit mask of DATA_SEQ_ERROR field.
	USBCTRL_REGS_SIE_STATUS_DATA_SEQ_ERROR_Msk = 0x80000000
	// Bit DATA_SEQ_ERROR.
	USBCTRL_REGS_SIE_STATUS_DATA_SEQ_ERROR = 0x80000000
	// Position of ACK_REC field.
	USBCTRL_REGS_SIE_STATUS_ACK_REC_Pos = 0x1e
	// Bit mask of ACK_REC field.
	USBCTRL_REGS_SIE_STATUS_ACK_REC_Msk = 0x40000000
	// Bit ACK_REC.
	USBCTRL_REGS_SIE_STATUS_ACK_REC = 0x40000000
	// Position of STALL_REC field.
	USBCTRL_REGS_SIE_STATUS_STALL_REC_Pos = 0x1d
	// Bit mask of STALL_REC field.
	USBCTRL_REGS_SIE_STATUS_STALL_REC_Msk = 0x20000000
	// Bit STALL_REC.
	USBCTRL_REGS_SIE_STATUS_STALL_REC = 0x20000000
	// Position of NAK_REC field.
	USBCTRL_REGS_SIE_STATUS_NAK_REC_Pos = 0x1c
	// Bit mask of NAK_REC field.
	USBCTRL_REGS_SIE_STATUS_NAK_REC_Msk = 0x10000000
	// Bit NAK_REC.
	USBCTRL_REGS_SIE_STATUS_NAK_REC = 0x10000000
	// Position of RX_TIMEOUT field.
	USBCTRL_REGS_SIE_STATUS_RX_TIMEOUT_Pos = 0x1b
	// Bit mask of RX_TIMEOUT field.
	USBCTRL_REGS_SIE_STATUS_RX_TIMEOUT_Msk = 0x8000000
	// Bit RX_TIMEOUT.
	USBCTRL_REGS_SIE_STATUS_RX_TIMEOUT = 0x8000000
	// Position of RX_OVERFLOW field.
	USBCTRL_REGS_SIE_STATUS_RX_OVERFLOW_Pos = 0x1a
	// Bit mask of RX_OVERFLOW field.
	USBCTRL_REGS_SIE_STATUS_RX_OVERFLOW_Msk = 0x4000000
	// Bit RX_OVERFLOW.
	USBCTRL_REGS_SIE_STATUS_RX_OVERFLOW = 0x4000000
	// Position of BIT_STUFF_ERROR field.
	USBCTRL_REGS_SIE_STATUS_BIT_STUFF_ERROR_Pos = 0x19
	// Bit mask of BIT_STUFF_ERROR field.
	USBCTRL_REGS_SIE_STATUS_BIT_STUFF_ERROR_Msk = 0x2000000
	// Bit BIT_STUFF_ERROR.
	USBCTRL_REGS_SIE_STATUS_BIT_STUFF_ERROR = 0x2000000
	// Position of CRC_ERROR field.
	USBCTRL_REGS_SIE_STATUS_CRC_ERROR_Pos = 0x18
	// Bit mask of CRC_ERROR field.
	USBCTRL_REGS_SIE_STATUS_CRC_ERROR_Msk = 0x1000000
	// Bit CRC_ERROR.
	USBCTRL_REGS_SIE_STATUS_CRC_ERROR = 0x1000000
	// Position of BUS_RESET field.
	USBCTRL_REGS_SIE_STATUS_BUS_RESET_Pos = 0x13
	// Bit mask of BUS_RESET field.
	USBCTRL_REGS_SIE_STATUS_BUS_RESET_Msk = 0x80000
	// Bit BUS_RESET.
	USBCTRL_REGS_SIE_STATUS_BUS_RESET = 0x80000
	// Position of TRANS_COMPLETE field.
	USBCTRL_REGS_SIE_STATUS_TRANS_COMPLETE_Pos = 0x12
	// Bit mask of TRANS_COMPLETE field.
	USBCTRL_REGS_SIE_STATUS_TRANS_COMPLETE_Msk = 0x40000
	// Bit TRANS_COMPLETE.
	USBCTRL_REGS_SIE_STATUS_TRANS_COMPLETE = 0x40000
	// Position of SETUP_REC field.
	USBCTRL_REGS_SIE_STATUS_SETUP_REC_Pos = 0x11
	// Bit mask of SETUP_REC field.
	USBCTRL_REGS_SIE_STATUS_SETUP_REC_Msk = 0x20000
	// Bit SETUP_REC.
	USBCTRL_REGS_SIE_STATUS_SETUP_REC = 0x20000
	// Position of CONNECTED field.
	USBCTRL_REGS_SIE_STATUS_CONNECTED_Pos = 0x10
	// Bit mask of CONNECTED field.
	USBCTRL_REGS_SIE_STATUS_CONNECTED_Msk = 0x10000
	// Bit CONNECTED.
	USBCTRL_REGS_SIE_STATUS_CONNECTED = 0x10000
	// Position of RESUME field.
	USBCTRL_REGS_SIE_STATUS_RESUME_Pos = 0xb
	// Bit mask of RESUME field.
	USBCTRL_REGS_SIE_STATUS_RESUME_Msk = 0x800
	// Bit RESUME.
	USBCTRL_REGS_SIE_STATUS_RESUME = 0x800
	// Position of VBUS_OVER_CURR field.
	USBCTRL_REGS_SIE_STATUS_VBUS_OVER_CURR_Pos = 0xa
	// Bit mask of VBUS_OVER_CURR field.
	USBCTRL_REGS_SIE_STATUS_VBUS_OVER_CURR_Msk = 0x400
	// Bit VBUS_OVER_CURR.
	USBCTRL_REGS_SIE_STATUS_VBUS_OVER_CURR = 0x400
	// Position of SPEED field.
	USBCTRL_REGS_SIE_STATUS_SPEED_Pos = 0x8
	// Bit mask of SPEED field.
	USBCTRL_REGS_SIE_STATUS_SPEED_Msk = 0x300
	// Position of SUSPENDED field.
	USBCTRL_REGS_SIE_STATUS_SUSPENDED_Pos = 0x4
	// Bit mask of SUSPENDED field.
	USBCTRL_REGS_SIE_STATUS_SUSPENDED_Msk = 0x10
	// Bit SUSPENDED.
	USBCTRL_REGS_SIE_STATUS_SUSPENDED = 0x10
	// Position of LINE_STATE field.
	USBCTRL_REGS_SIE_STATUS_LINE_STATE_Pos = 0x2
	// Bit mask of LINE_STATE field.
	USBCTRL_REGS_SIE_STATUS_LINE_STATE_Msk = 0xc
	// Position of VBUS_DETECTED field.
	USBCTRL_REGS_SIE_STATUS_VBUS_DETECTED_Pos = 0x0
	// Bit mask of VBUS_DETECTED field.
	USBCTRL_REGS_SIE_STATUS_VBUS_DETECTED_Msk = 0x1
	// Bit VBUS_DETECTED.
	USBCTRL_REGS_SIE_STATUS_VBUS_DETECTED = 0x1

	// INT_EP_CTRL: interrupt endpoint control register
	// Position of INT_EP_ACTIVE field.
	USBCTRL_REGS_INT_EP_CTRL_INT_EP_ACTIVE_Pos = 0x1
	// Bit mask of INT_EP_ACTIVE field.
	USBCTRL_REGS_INT_EP_CTRL_INT_EP_ACTIVE_Msk = 0xfffe

	// BUFF_STATUS: Buffer status register. A bit set here indicates that a buffer has completed on the endpoint (if the buffer interrupt is enabled). It is possible for 2 buffers to be completed, so clearing the buffer status bit may instantly re set it on the next clock cycle.
	// Position of EP15_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP15_OUT_Pos = 0x1f
	// Bit mask of EP15_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP15_OUT_Msk = 0x80000000
	// Bit EP15_OUT.
	USBCTRL_REGS_BUFF_STATUS_EP15_OUT = 0x80000000
	// Position of EP15_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP15_IN_Pos = 0x1e
	// Bit mask of EP15_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP15_IN_Msk = 0x40000000
	// Bit EP15_IN.
	USBCTRL_REGS_BUFF_STATUS_EP15_IN = 0x40000000
	// Position of EP14_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP14_OUT_Pos = 0x1d
	// Bit mask of EP14_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP14_OUT_Msk = 0x20000000
	// Bit EP14_OUT.
	USBCTRL_REGS_BUFF_STATUS_EP14_OUT = 0x20000000
	// Position of EP14_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP14_IN_Pos = 0x1c
	// Bit mask of EP14_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP14_IN_Msk = 0x10000000
	// Bit EP14_IN.
	USBCTRL_REGS_BUFF_STATUS_EP14_IN = 0x10000000
	// Position of EP13_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP13_OUT_Pos = 0x1b
	// Bit mask of EP13_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP13_OUT_Msk = 0x8000000
	// Bit EP13_OUT.
	USBCTRL_REGS_BUFF_STATUS_EP13_OUT = 0x8000000
	// Position of EP13_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP13_IN_Pos = 0x1a
	// Bit mask of EP13_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP13_IN_Msk = 0x4000000
	// Bit EP13_IN.
	USBCTRL_REGS_BUFF_STATUS_EP13_IN = 0x4000000
	// Position of EP12_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP12_OUT_Pos = 0x19
	// Bit mask of EP12_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP12_OUT_Msk = 0x2000000
	// Bit EP12_OUT.
	USBCTRL_REGS_BUFF_STATUS_EP12_OUT = 0x2000000
	// Position of EP12_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP12_IN_Pos = 0x18
	// Bit mask of EP12_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP12_IN_Msk = 0x1000000
	// Bit EP12_IN.
	USBCTRL_REGS_BUFF_STATUS_EP12_IN = 0x1000000
	// Position of EP11_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP11_OUT_Pos = 0x17
	// Bit mask of EP11_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP11_OUT_Msk = 0x800000
	// Bit EP11_OUT.
	USBCTRL_REGS_BUFF_STATUS_EP11_OUT = 0x800000
	// Position of EP11_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP11_IN_Pos = 0x16
	// Bit mask of EP11_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP11_IN_Msk = 0x400000
	// Bit EP11_IN.
	USBCTRL_REGS_BUFF_STATUS_EP11_IN = 0x400000
	// Position of EP10_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP10_OUT_Pos = 0x15
	// Bit mask of EP10_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP10_OUT_Msk = 0x200000
	// Bit EP10_OUT.
	USBCTRL_REGS_BUFF_STATUS_EP10_OUT = 0x200000
	// Position of EP10_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP10_IN_Pos = 0x14
	// Bit mask of EP10_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP10_IN_Msk = 0x100000
	// Bit EP10_IN.
	USBCTRL_REGS_BUFF_STATUS_EP10_IN = 0x100000
	// Position of EP9_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP9_OUT_Pos = 0x13
	// Bit mask of EP9_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP9_OUT_Msk = 0x80000
	// Bit EP9_OUT.
	USBCTRL_REGS_BUFF_STATUS_EP9_OUT = 0x80000
	// Position of EP9_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP9_IN_Pos = 0x12
	// Bit mask of EP9_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP9_IN_Msk = 0x40000
	// Bit EP9_IN.
	USBCTRL_REGS_BUFF_STATUS_EP9_IN = 0x40000
	// Position of EP8_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP8_OUT_Pos = 0x11
	// Bit mask of EP8_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP8_OUT_Msk = 0x20000
	// Bit EP8_OUT.
	USBCTRL_REGS_BUFF_STATUS_EP8_OUT = 0x20000
	// Position of EP8_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP8_IN_Pos = 0x10
	// Bit mask of EP8_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP8_IN_Msk = 0x10000
	// Bit EP8_IN.
	USBCTRL_REGS_BUFF_STATUS_EP8_IN = 0x10000
	// Position of EP7_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP7_OUT_Pos = 0xf
	// Bit mask of EP7_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP7_OUT_Msk = 0x8000
	// Bit EP7_OUT.
	USBCTRL_REGS_BUFF_STATUS_EP7_OUT = 0x8000
	// Position of EP7_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP7_IN_Pos = 0xe
	// Bit mask of EP7_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP7_IN_Msk = 0x4000
	// Bit EP7_IN.
	USBCTRL_REGS_BUFF_STATUS_EP7_IN = 0x4000
	// Position of EP6_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP6_OUT_Pos = 0xd
	// Bit mask of EP6_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP6_OUT_Msk = 0x2000
	// Bit EP6_OUT.
	USBCTRL_REGS_BUFF_STATUS_EP6_OUT = 0x2000
	// Position of EP6_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP6_IN_Pos = 0xc
	// Bit mask of EP6_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP6_IN_Msk = 0x1000
	// Bit EP6_IN.
	USBCTRL_REGS_BUFF_STATUS_EP6_IN = 0x1000
	// Position of EP5_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP5_OUT_Pos = 0xb
	// Bit mask of EP5_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP5_OUT_Msk = 0x800
	// Bit EP5_OUT.
	USBCTRL_REGS_BUFF_STATUS_EP5_OUT = 0x800
	// Position of EP5_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP5_IN_Pos = 0xa
	// Bit mask of EP5_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP5_IN_Msk = 0x400
	// Bit EP5_IN.
	USBCTRL_REGS_BUFF_STATUS_EP5_IN = 0x400
	// Position of EP4_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP4_OUT_Pos = 0x9
	// Bit mask of EP4_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP4_OUT_Msk = 0x200
	// Bit EP4_OUT.
	USBCTRL_REGS_BUFF_STATUS_EP4_OUT = 0x200
	// Position of EP4_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP4_IN_Pos = 0x8
	// Bit mask of EP4_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP4_IN_Msk = 0x100
	// Bit EP4_IN.
	USBCTRL_REGS_BUFF_STATUS_EP4_IN = 0x100
	// Position of EP3_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP3_OUT_Pos = 0x7
	// Bit mask of EP3_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP3_OUT_Msk = 0x80
	// Bit EP3_OUT.
	USBCTRL_REGS_BUFF_STATUS_EP3_OUT = 0x80
	// Position of EP3_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP3_IN_Pos = 0x6
	// Bit mask of EP3_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP3_IN_Msk = 0x40
	// Bit EP3_IN.
	USBCTRL_REGS_BUFF_STATUS_EP3_IN = 0x40
	// Position of EP2_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP2_OUT_Pos = 0x5
	// Bit mask of EP2_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP2_OUT_Msk = 0x20
	// Bit EP2_OUT.
	USBCTRL_REGS_BUFF_STATUS_EP2_OUT = 0x20
	// Position of EP2_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP2_IN_Pos = 0x4
	// Bit mask of EP2_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP2_IN_Msk = 0x10
	// Bit EP2_IN.
	USBCTRL_REGS_BUFF_STATUS_EP2_IN = 0x10
	// Position of EP1_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP1_OUT_Pos = 0x3
	// Bit mask of EP1_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP1_OUT_Msk = 0x8
	// Bit EP1_OUT.
	USBCTRL_REGS_BUFF_STATUS_EP1_OUT = 0x8
	// Position of EP1_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP1_IN_Pos = 0x2
	// Bit mask of EP1_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP1_IN_Msk = 0x4
	// Bit EP1_IN.
	USBCTRL_REGS_BUFF_STATUS_EP1_IN = 0x4
	// Position of EP0_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP0_OUT_Pos = 0x1
	// Bit mask of EP0_OUT field.
	USBCTRL_REGS_BUFF_STATUS_EP0_OUT_Msk = 0x2
	// Bit EP0_OUT.
	USBCTRL_REGS_BUFF_STATUS_EP0_OUT = 0x2
	// Position of EP0_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP0_IN_Pos = 0x0
	// Bit mask of EP0_IN field.
	USBCTRL_REGS_BUFF_STATUS_EP0_IN_Msk = 0x1
	// Bit EP0_IN.
	USBCTRL_REGS_BUFF_STATUS_EP0_IN = 0x1

	// BUFF_CPU_SHOULD_HANDLE: Which of the double buffers should be handled. Only valid if using an interrupt per buffer (i.e. not per 2 buffers). Not valid for host interrupt endpoint polling because they are only single buffered.
	// Position of EP15_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP15_OUT_Pos = 0x1f
	// Bit mask of EP15_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP15_OUT_Msk = 0x80000000
	// Bit EP15_OUT.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP15_OUT = 0x80000000
	// Position of EP15_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP15_IN_Pos = 0x1e
	// Bit mask of EP15_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP15_IN_Msk = 0x40000000
	// Bit EP15_IN.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP15_IN = 0x40000000
	// Position of EP14_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP14_OUT_Pos = 0x1d
	// Bit mask of EP14_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP14_OUT_Msk = 0x20000000
	// Bit EP14_OUT.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP14_OUT = 0x20000000
	// Position of EP14_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP14_IN_Pos = 0x1c
	// Bit mask of EP14_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP14_IN_Msk = 0x10000000
	// Bit EP14_IN.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP14_IN = 0x10000000
	// Position of EP13_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP13_OUT_Pos = 0x1b
	// Bit mask of EP13_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP13_OUT_Msk = 0x8000000
	// Bit EP13_OUT.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP13_OUT = 0x8000000
	// Position of EP13_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP13_IN_Pos = 0x1a
	// Bit mask of EP13_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP13_IN_Msk = 0x4000000
	// Bit EP13_IN.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP13_IN = 0x4000000
	// Position of EP12_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP12_OUT_Pos = 0x19
	// Bit mask of EP12_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP12_OUT_Msk = 0x2000000
	// Bit EP12_OUT.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP12_OUT = 0x2000000
	// Position of EP12_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP12_IN_Pos = 0x18
	// Bit mask of EP12_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP12_IN_Msk = 0x1000000
	// Bit EP12_IN.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP12_IN = 0x1000000
	// Position of EP11_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP11_OUT_Pos = 0x17
	// Bit mask of EP11_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP11_OUT_Msk = 0x800000
	// Bit EP11_OUT.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP11_OUT = 0x800000
	// Position of EP11_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP11_IN_Pos = 0x16
	// Bit mask of EP11_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP11_IN_Msk = 0x400000
	// Bit EP11_IN.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP11_IN = 0x400000
	// Position of EP10_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP10_OUT_Pos = 0x15
	// Bit mask of EP10_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP10_OUT_Msk = 0x200000
	// Bit EP10_OUT.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP10_OUT = 0x200000
	// Position of EP10_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP10_IN_Pos = 0x14
	// Bit mask of EP10_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP10_IN_Msk = 0x100000
	// Bit EP10_IN.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP10_IN = 0x100000
	// Position of EP9_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP9_OUT_Pos = 0x13
	// Bit mask of EP9_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP9_OUT_Msk = 0x80000
	// Bit EP9_OUT.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP9_OUT = 0x80000
	// Position of EP9_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP9_IN_Pos = 0x12
	// Bit mask of EP9_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP9_IN_Msk = 0x40000
	// Bit EP9_IN.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP9_IN = 0x40000
	// Position of EP8_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP8_OUT_Pos = 0x11
	// Bit mask of EP8_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP8_OUT_Msk = 0x20000
	// Bit EP8_OUT.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP8_OUT = 0x20000
	// Position of EP8_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP8_IN_Pos = 0x10
	// Bit mask of EP8_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP8_IN_Msk = 0x10000
	// Bit EP8_IN.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP8_IN = 0x10000
	// Position of EP7_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP7_OUT_Pos = 0xf
	// Bit mask of EP7_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP7_OUT_Msk = 0x8000
	// Bit EP7_OUT.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP7_OUT = 0x8000
	// Position of EP7_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP7_IN_Pos = 0xe
	// Bit mask of EP7_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP7_IN_Msk = 0x4000
	// Bit EP7_IN.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP7_IN = 0x4000
	// Position of EP6_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP6_OUT_Pos = 0xd
	// Bit mask of EP6_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP6_OUT_Msk = 0x2000
	// Bit EP6_OUT.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP6_OUT = 0x2000
	// Position of EP6_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP6_IN_Pos = 0xc
	// Bit mask of EP6_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP6_IN_Msk = 0x1000
	// Bit EP6_IN.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP6_IN = 0x1000
	// Position of EP5_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP5_OUT_Pos = 0xb
	// Bit mask of EP5_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP5_OUT_Msk = 0x800
	// Bit EP5_OUT.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP5_OUT = 0x800
	// Position of EP5_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP5_IN_Pos = 0xa
	// Bit mask of EP5_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP5_IN_Msk = 0x400
	// Bit EP5_IN.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP5_IN = 0x400
	// Position of EP4_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP4_OUT_Pos = 0x9
	// Bit mask of EP4_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP4_OUT_Msk = 0x200
	// Bit EP4_OUT.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP4_OUT = 0x200
	// Position of EP4_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP4_IN_Pos = 0x8
	// Bit mask of EP4_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP4_IN_Msk = 0x100
	// Bit EP4_IN.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP4_IN = 0x100
	// Position of EP3_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP3_OUT_Pos = 0x7
	// Bit mask of EP3_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP3_OUT_Msk = 0x80
	// Bit EP3_OUT.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP3_OUT = 0x80
	// Position of EP3_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP3_IN_Pos = 0x6
	// Bit mask of EP3_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP3_IN_Msk = 0x40
	// Bit EP3_IN.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP3_IN = 0x40
	// Position of EP2_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP2_OUT_Pos = 0x5
	// Bit mask of EP2_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP2_OUT_Msk = 0x20
	// Bit EP2_OUT.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP2_OUT = 0x20
	// Position of EP2_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP2_IN_Pos = 0x4
	// Bit mask of EP2_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP2_IN_Msk = 0x10
	// Bit EP2_IN.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP2_IN = 0x10
	// Position of EP1_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP1_OUT_Pos = 0x3
	// Bit mask of EP1_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP1_OUT_Msk = 0x8
	// Bit EP1_OUT.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP1_OUT = 0x8
	// Position of EP1_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP1_IN_Pos = 0x2
	// Bit mask of EP1_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP1_IN_Msk = 0x4
	// Bit EP1_IN.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP1_IN = 0x4
	// Position of EP0_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP0_OUT_Pos = 0x1
	// Bit mask of EP0_OUT field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP0_OUT_Msk = 0x2
	// Bit EP0_OUT.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP0_OUT = 0x2
	// Position of EP0_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP0_IN_Pos = 0x0
	// Bit mask of EP0_IN field.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP0_IN_Msk = 0x1
	// Bit EP0_IN.
	USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP0_IN = 0x1

	// EP_ABORT: Device only: Can be set to ignore the buffer control register for this endpoint in case you would like to revoke a buffer. A NAK will be sent for every access to the endpoint until this bit is cleared. A corresponding bit in `EP_ABORT_DONE` is set when it is safe to modify the buffer control register.
	// Position of EP15_OUT field.
	USBCTRL_REGS_EP_ABORT_EP15_OUT_Pos = 0x1f
	// Bit mask of EP15_OUT field.
	USBCTRL_REGS_EP_ABORT_EP15_OUT_Msk = 0x80000000
	// Bit EP15_OUT.
	USBCTRL_REGS_EP_ABORT_EP15_OUT = 0x80000000
	// Position of EP15_IN field.
	USBCTRL_REGS_EP_ABORT_EP15_IN_Pos = 0x1e
	// Bit mask of EP15_IN field.
	USBCTRL_REGS_EP_ABORT_EP15_IN_Msk = 0x40000000
	// Bit EP15_IN.
	USBCTRL_REGS_EP_ABORT_EP15_IN = 0x40000000
	// Position of EP14_OUT field.
	USBCTRL_REGS_EP_ABORT_EP14_OUT_Pos = 0x1d
	// Bit mask of EP14_OUT field.
	USBCTRL_REGS_EP_ABORT_EP14_OUT_Msk = 0x20000000
	// Bit EP14_OUT.
	USBCTRL_REGS_EP_ABORT_EP14_OUT = 0x20000000
	// Position of EP14_IN field.
	USBCTRL_REGS_EP_ABORT_EP14_IN_Pos = 0x1c
	// Bit mask of EP14_IN field.
	USBCTRL_REGS_EP_ABORT_EP14_IN_Msk = 0x10000000
	// Bit EP14_IN.
	USBCTRL_REGS_EP_ABORT_EP14_IN = 0x10000000
	// Position of EP13_OUT field.
	USBCTRL_REGS_EP_ABORT_EP13_OUT_Pos = 0x1b
	// Bit mask of EP13_OUT field.
	USBCTRL_REGS_EP_ABORT_EP13_OUT_Msk = 0x8000000
	// Bit EP13_OUT.
	USBCTRL_REGS_EP_ABORT_EP13_OUT = 0x8000000
	// Position of EP13_IN field.
	USBCTRL_REGS_EP_ABORT_EP13_IN_Pos = 0x1a
	// Bit mask of EP13_IN field.
	USBCTRL_REGS_EP_ABORT_EP13_IN_Msk = 0x4000000
	// Bit EP13_IN.
	USBCTRL_REGS_EP_ABORT_EP13_IN = 0x4000000
	// Position of EP12_OUT field.
	USBCTRL_REGS_EP_ABORT_EP12_OUT_Pos = 0x19
	// Bit mask of EP12_OUT field.
	USBCTRL_REGS_EP_ABORT_EP12_OUT_Msk = 0x2000000
	// Bit EP12_OUT.
	USBCTRL_REGS_EP_ABORT_EP12_OUT = 0x2000000
	// Position of EP12_IN field.
	USBCTRL_REGS_EP_ABORT_EP12_IN_Pos = 0x18
	// Bit mask of EP12_IN field.
	USBCTRL_REGS_EP_ABORT_EP12_IN_Msk = 0x1000000
	// Bit EP12_IN.
	USBCTRL_REGS_EP_ABORT_EP12_IN = 0x1000000
	// Position of EP11_OUT field.
	USBCTRL_REGS_EP_ABORT_EP11_OUT_Pos = 0x17
	// Bit mask of EP11_OUT field.
	USBCTRL_REGS_EP_ABORT_EP11_OUT_Msk = 0x800000
	// Bit EP11_OUT.
	USBCTRL_REGS_EP_ABORT_EP11_OUT = 0x800000
	// Position of EP11_IN field.
	USBCTRL_REGS_EP_ABORT_EP11_IN_Pos = 0x16
	// Bit mask of EP11_IN field.
	USBCTRL_REGS_EP_ABORT_EP11_IN_Msk = 0x400000
	// Bit EP11_IN.
	USBCTRL_REGS_EP_ABORT_EP11_IN = 0x400000
	// Position of EP10_OUT field.
	USBCTRL_REGS_EP_ABORT_EP10_OUT_Pos = 0x15
	// Bit mask of EP10_OUT field.
	USBCTRL_REGS_EP_ABORT_EP10_OUT_Msk = 0x200000
	// Bit EP10_OUT.
	USBCTRL_REGS_EP_ABORT_EP10_OUT = 0x200000
	// Position of EP10_IN field.
	USBCTRL_REGS_EP_ABORT_EP10_IN_Pos = 0x14
	// Bit mask of EP10_IN field.
	USBCTRL_REGS_EP_ABORT_EP10_IN_Msk = 0x100000
	// Bit EP10_IN.
	USBCTRL_REGS_EP_ABORT_EP10_IN = 0x100000
	// Position of EP9_OUT field.
	USBCTRL_REGS_EP_ABORT_EP9_OUT_Pos = 0x13
	// Bit mask of EP9_OUT field.
	USBCTRL_REGS_EP_ABORT_EP9_OUT_Msk = 0x80000
	// Bit EP9_OUT.
	USBCTRL_REGS_EP_ABORT_EP9_OUT = 0x80000
	// Position of EP9_IN field.
	USBCTRL_REGS_EP_ABORT_EP9_IN_Pos = 0x12
	// Bit mask of EP9_IN field.
	USBCTRL_REGS_EP_ABORT_EP9_IN_Msk = 0x40000
	// Bit EP9_IN.
	USBCTRL_REGS_EP_ABORT_EP9_IN = 0x40000
	// Position of EP8_OUT field.
	USBCTRL_REGS_EP_ABORT_EP8_OUT_Pos = 0x11
	// Bit mask of EP8_OUT field.
	USBCTRL_REGS_EP_ABORT_EP8_OUT_Msk = 0x20000
	// Bit EP8_OUT.
	USBCTRL_REGS_EP_ABORT_EP8_OUT = 0x20000
	// Position of EP8_IN field.
	USBCTRL_REGS_EP_ABORT_EP8_IN_Pos = 0x10
	// Bit mask of EP8_IN field.
	USBCTRL_REGS_EP_ABORT_EP8_IN_Msk = 0x10000
	// Bit EP8_IN.
	USBCTRL_REGS_EP_ABORT_EP8_IN = 0x10000
	// Position of EP7_OUT field.
	USBCTRL_REGS_EP_ABORT_EP7_OUT_Pos = 0xf
	// Bit mask of EP7_OUT field.
	USBCTRL_REGS_EP_ABORT_EP7_OUT_Msk = 0x8000
	// Bit EP7_OUT.
	USBCTRL_REGS_EP_ABORT_EP7_OUT = 0x8000
	// Position of EP7_IN field.
	USBCTRL_REGS_EP_ABORT_EP7_IN_Pos = 0xe
	// Bit mask of EP7_IN field.
	USBCTRL_REGS_EP_ABORT_EP7_IN_Msk = 0x4000
	// Bit EP7_IN.
	USBCTRL_REGS_EP_ABORT_EP7_IN = 0x4000
	// Position of EP6_OUT field.
	USBCTRL_REGS_EP_ABORT_EP6_OUT_Pos = 0xd
	// Bit mask of EP6_OUT field.
	USBCTRL_REGS_EP_ABORT_EP6_OUT_Msk = 0x2000
	// Bit EP6_OUT.
	USBCTRL_REGS_EP_ABORT_EP6_OUT = 0x2000
	// Position of EP6_IN field.
	USBCTRL_REGS_EP_ABORT_EP6_IN_Pos = 0xc
	// Bit mask of EP6_IN field.
	USBCTRL_REGS_EP_ABORT_EP6_IN_Msk = 0x1000
	// Bit EP6_IN.
	USBCTRL_REGS_EP_ABORT_EP6_IN = 0x1000
	// Position of EP5_OUT field.
	USBCTRL_REGS_EP_ABORT_EP5_OUT_Pos = 0xb
	// Bit mask of EP5_OUT field.
	USBCTRL_REGS_EP_ABORT_EP5_OUT_Msk = 0x800
	// Bit EP5_OUT.
	USBCTRL_REGS_EP_ABORT_EP5_OUT = 0x800
	// Position of EP5_IN field.
	USBCTRL_REGS_EP_ABORT_EP5_IN_Pos = 0xa
	// Bit mask of EP5_IN field.
	USBCTRL_REGS_EP_ABORT_EP5_IN_Msk = 0x400
	// Bit EP5_IN.
	USBCTRL_REGS_EP_ABORT_EP5_IN = 0x400
	// Position of EP4_OUT field.
	USBCTRL_REGS_EP_ABORT_EP4_OUT_Pos = 0x9
	// Bit mask of EP4_OUT field.
	USBCTRL_REGS_EP_ABORT_EP4_OUT_Msk = 0x200
	// Bit EP4_OUT.
	USBCTRL_REGS_EP_ABORT_EP4_OUT = 0x200
	// Position of EP4_IN field.
	USBCTRL_REGS_EP_ABORT_EP4_IN_Pos = 0x8
	// Bit mask of EP4_IN field.
	USBCTRL_REGS_EP_ABORT_EP4_IN_Msk = 0x100
	// Bit EP4_IN.
	USBCTRL_REGS_EP_ABORT_EP4_IN = 0x100
	// Position of EP3_OUT field.
	USBCTRL_REGS_EP_ABORT_EP3_OUT_Pos = 0x7
	// Bit mask of EP3_OUT field.
	USBCTRL_REGS_EP_ABORT_EP3_OUT_Msk = 0x80
	// Bit EP3_OUT.
	USBCTRL_REGS_EP_ABORT_EP3_OUT = 0x80
	// Position of EP3_IN field.
	USBCTRL_REGS_EP_ABORT_EP3_IN_Pos = 0x6
	// Bit mask of EP3_IN field.
	USBCTRL_REGS_EP_ABORT_EP3_IN_Msk = 0x40
	// Bit EP3_IN.
	USBCTRL_REGS_EP_ABORT_EP3_IN = 0x40
	// Position of EP2_OUT field.
	USBCTRL_REGS_EP_ABORT_EP2_OUT_Pos = 0x5
	// Bit mask of EP2_OUT field.
	USBCTRL_REGS_EP_ABORT_EP2_OUT_Msk = 0x20
	// Bit EP2_OUT.
	USBCTRL_REGS_EP_ABORT_EP2_OUT = 0x20
	// Position of EP2_IN field.
	USBCTRL_REGS_EP_ABORT_EP2_IN_Pos = 0x4
	// Bit mask of EP2_IN field.
	USBCTRL_REGS_EP_ABORT_EP2_IN_Msk = 0x10
	// Bit EP2_IN.
	USBCTRL_REGS_EP_ABORT_EP2_IN = 0x10
	// Position of EP1_OUT field.
	USBCTRL_REGS_EP_ABORT_EP1_OUT_Pos = 0x3
	// Bit mask of EP1_OUT field.
	USBCTRL_REGS_EP_ABORT_EP1_OUT_Msk = 0x8
	// Bit EP1_OUT.
	USBCTRL_REGS_EP_ABORT_EP1_OUT = 0x8
	// Position of EP1_IN field.
	USBCTRL_REGS_EP_ABORT_EP1_IN_Pos = 0x2
	// Bit mask of EP1_IN field.
	USBCTRL_REGS_EP_ABORT_EP1_IN_Msk = 0x4
	// Bit EP1_IN.
	USBCTRL_REGS_EP_ABORT_EP1_IN = 0x4
	// Position of EP0_OUT field.
	USBCTRL_REGS_EP_ABORT_EP0_OUT_Pos = 0x1
	// Bit mask of EP0_OUT field.
	USBCTRL_REGS_EP_ABORT_EP0_OUT_Msk = 0x2
	// Bit EP0_OUT.
	USBCTRL_REGS_EP_ABORT_EP0_OUT = 0x2
	// Position of EP0_IN field.
	USBCTRL_REGS_EP_ABORT_EP0_IN_Pos = 0x0
	// Bit mask of EP0_IN field.
	USBCTRL_REGS_EP_ABORT_EP0_IN_Msk = 0x1
	// Bit EP0_IN.
	USBCTRL_REGS_EP_ABORT_EP0_IN = 0x1

	// EP_ABORT_DONE: Device only: Used in conjunction with `EP_ABORT`. Set once an endpoint is idle so the programmer knows it is safe to modify the buffer control register.
	// Position of EP15_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP15_OUT_Pos = 0x1f
	// Bit mask of EP15_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP15_OUT_Msk = 0x80000000
	// Bit EP15_OUT.
	USBCTRL_REGS_EP_ABORT_DONE_EP15_OUT = 0x80000000
	// Position of EP15_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP15_IN_Pos = 0x1e
	// Bit mask of EP15_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP15_IN_Msk = 0x40000000
	// Bit EP15_IN.
	USBCTRL_REGS_EP_ABORT_DONE_EP15_IN = 0x40000000
	// Position of EP14_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP14_OUT_Pos = 0x1d
	// Bit mask of EP14_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP14_OUT_Msk = 0x20000000
	// Bit EP14_OUT.
	USBCTRL_REGS_EP_ABORT_DONE_EP14_OUT = 0x20000000
	// Position of EP14_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP14_IN_Pos = 0x1c
	// Bit mask of EP14_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP14_IN_Msk = 0x10000000
	// Bit EP14_IN.
	USBCTRL_REGS_EP_ABORT_DONE_EP14_IN = 0x10000000
	// Position of EP13_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP13_OUT_Pos = 0x1b
	// Bit mask of EP13_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP13_OUT_Msk = 0x8000000
	// Bit EP13_OUT.
	USBCTRL_REGS_EP_ABORT_DONE_EP13_OUT = 0x8000000
	// Position of EP13_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP13_IN_Pos = 0x1a
	// Bit mask of EP13_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP13_IN_Msk = 0x4000000
	// Bit EP13_IN.
	USBCTRL_REGS_EP_ABORT_DONE_EP13_IN = 0x4000000
	// Position of EP12_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP12_OUT_Pos = 0x19
	// Bit mask of EP12_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP12_OUT_Msk = 0x2000000
	// Bit EP12_OUT.
	USBCTRL_REGS_EP_ABORT_DONE_EP12_OUT = 0x2000000
	// Position of EP12_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP12_IN_Pos = 0x18
	// Bit mask of EP12_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP12_IN_Msk = 0x1000000
	// Bit EP12_IN.
	USBCTRL_REGS_EP_ABORT_DONE_EP12_IN = 0x1000000
	// Position of EP11_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP11_OUT_Pos = 0x17
	// Bit mask of EP11_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP11_OUT_Msk = 0x800000
	// Bit EP11_OUT.
	USBCTRL_REGS_EP_ABORT_DONE_EP11_OUT = 0x800000
	// Position of EP11_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP11_IN_Pos = 0x16
	// Bit mask of EP11_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP11_IN_Msk = 0x400000
	// Bit EP11_IN.
	USBCTRL_REGS_EP_ABORT_DONE_EP11_IN = 0x400000
	// Position of EP10_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP10_OUT_Pos = 0x15
	// Bit mask of EP10_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP10_OUT_Msk = 0x200000
	// Bit EP10_OUT.
	USBCTRL_REGS_EP_ABORT_DONE_EP10_OUT = 0x200000
	// Position of EP10_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP10_IN_Pos = 0x14
	// Bit mask of EP10_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP10_IN_Msk = 0x100000
	// Bit EP10_IN.
	USBCTRL_REGS_EP_ABORT_DONE_EP10_IN = 0x100000
	// Position of EP9_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP9_OUT_Pos = 0x13
	// Bit mask of EP9_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP9_OUT_Msk = 0x80000
	// Bit EP9_OUT.
	USBCTRL_REGS_EP_ABORT_DONE_EP9_OUT = 0x80000
	// Position of EP9_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP9_IN_Pos = 0x12
	// Bit mask of EP9_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP9_IN_Msk = 0x40000
	// Bit EP9_IN.
	USBCTRL_REGS_EP_ABORT_DONE_EP9_IN = 0x40000
	// Position of EP8_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP8_OUT_Pos = 0x11
	// Bit mask of EP8_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP8_OUT_Msk = 0x20000
	// Bit EP8_OUT.
	USBCTRL_REGS_EP_ABORT_DONE_EP8_OUT = 0x20000
	// Position of EP8_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP8_IN_Pos = 0x10
	// Bit mask of EP8_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP8_IN_Msk = 0x10000
	// Bit EP8_IN.
	USBCTRL_REGS_EP_ABORT_DONE_EP8_IN = 0x10000
	// Position of EP7_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP7_OUT_Pos = 0xf
	// Bit mask of EP7_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP7_OUT_Msk = 0x8000
	// Bit EP7_OUT.
	USBCTRL_REGS_EP_ABORT_DONE_EP7_OUT = 0x8000
	// Position of EP7_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP7_IN_Pos = 0xe
	// Bit mask of EP7_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP7_IN_Msk = 0x4000
	// Bit EP7_IN.
	USBCTRL_REGS_EP_ABORT_DONE_EP7_IN = 0x4000
	// Position of EP6_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP6_OUT_Pos = 0xd
	// Bit mask of EP6_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP6_OUT_Msk = 0x2000
	// Bit EP6_OUT.
	USBCTRL_REGS_EP_ABORT_DONE_EP6_OUT = 0x2000
	// Position of EP6_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP6_IN_Pos = 0xc
	// Bit mask of EP6_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP6_IN_Msk = 0x1000
	// Bit EP6_IN.
	USBCTRL_REGS_EP_ABORT_DONE_EP6_IN = 0x1000
	// Position of EP5_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP5_OUT_Pos = 0xb
	// Bit mask of EP5_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP5_OUT_Msk = 0x800
	// Bit EP5_OUT.
	USBCTRL_REGS_EP_ABORT_DONE_EP5_OUT = 0x800
	// Position of EP5_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP5_IN_Pos = 0xa
	// Bit mask of EP5_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP5_IN_Msk = 0x400
	// Bit EP5_IN.
	USBCTRL_REGS_EP_ABORT_DONE_EP5_IN = 0x400
	// Position of EP4_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP4_OUT_Pos = 0x9
	// Bit mask of EP4_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP4_OUT_Msk = 0x200
	// Bit EP4_OUT.
	USBCTRL_REGS_EP_ABORT_DONE_EP4_OUT = 0x200
	// Position of EP4_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP4_IN_Pos = 0x8
	// Bit mask of EP4_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP4_IN_Msk = 0x100
	// Bit EP4_IN.
	USBCTRL_REGS_EP_ABORT_DONE_EP4_IN = 0x100
	// Position of EP3_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP3_OUT_Pos = 0x7
	// Bit mask of EP3_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP3_OUT_Msk = 0x80
	// Bit EP3_OUT.
	USBCTRL_REGS_EP_ABORT_DONE_EP3_OUT = 0x80
	// Position of EP3_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP3_IN_Pos = 0x6
	// Bit mask of EP3_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP3_IN_Msk = 0x40
	// Bit EP3_IN.
	USBCTRL_REGS_EP_ABORT_DONE_EP3_IN = 0x40
	// Position of EP2_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP2_OUT_Pos = 0x5
	// Bit mask of EP2_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP2_OUT_Msk = 0x20
	// Bit EP2_OUT.
	USBCTRL_REGS_EP_ABORT_DONE_EP2_OUT = 0x20
	// Position of EP2_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP2_IN_Pos = 0x4
	// Bit mask of EP2_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP2_IN_Msk = 0x10
	// Bit EP2_IN.
	USBCTRL_REGS_EP_ABORT_DONE_EP2_IN = 0x10
	// Position of EP1_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP1_OUT_Pos = 0x3
	// Bit mask of EP1_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP1_OUT_Msk = 0x8
	// Bit EP1_OUT.
	USBCTRL_REGS_EP_ABORT_DONE_EP1_OUT = 0x8
	// Position of EP1_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP1_IN_Pos = 0x2
	// Bit mask of EP1_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP1_IN_Msk = 0x4
	// Bit EP1_IN.
	USBCTRL_REGS_EP_ABORT_DONE_EP1_IN = 0x4
	// Position of EP0_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP0_OUT_Pos = 0x1
	// Bit mask of EP0_OUT field.
	USBCTRL_REGS_EP_ABORT_DONE_EP0_OUT_Msk = 0x2
	// Bit EP0_OUT.
	USBCTRL_REGS_EP_ABORT_DONE_EP0_OUT = 0x2
	// Position of EP0_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP0_IN_Pos = 0x0
	// Bit mask of EP0_IN field.
	USBCTRL_REGS_EP_ABORT_DONE_EP0_IN_Msk = 0x1
	// Bit EP0_IN.
	USBCTRL_REGS_EP_ABORT_DONE_EP0_IN = 0x1

	// EP_STALL_ARM: Device: this bit must be set in conjunction with the `STALL` bit in the buffer control register to send a STALL on EP0. The device controller clears these bits when a SETUP packet is received because the USB spec requires that a STALL condition is cleared when a SETUP packet is received.
	// Position of EP0_OUT field.
	USBCTRL_REGS_EP_STALL_ARM_EP0_OUT_Pos = 0x1
	// Bit mask of EP0_OUT field.
	USBCTRL_REGS_EP_STALL_ARM_EP0_OUT_Msk = 0x2
	// Bit EP0_OUT.
	USBCTRL_REGS_EP_STALL_ARM_EP0_OUT = 0x2
	// Position of EP0_IN field.
	USBCTRL_REGS_EP_STALL_ARM_EP0_IN_Pos = 0x0
	// Bit mask of EP0_IN field.
	USBCTRL_REGS_EP_STALL_ARM_EP0_IN_Msk = 0x1
	// Bit EP0_IN.
	USBCTRL_REGS_EP_STALL_ARM_EP0_IN = 0x1

	// NAK_POLL: Used by the host controller. Sets the wait time in microseconds before trying again if the device replies with a NAK.
	// Position of DELAY_FS field.
	USBCTRL_REGS_NAK_POLL_DELAY_FS_Pos = 0x10
	// Bit mask of DELAY_FS field.
	USBCTRL_REGS_NAK_POLL_DELAY_FS_Msk = 0x3ff0000
	// Position of DELAY_LS field.
	USBCTRL_REGS_NAK_POLL_DELAY_LS_Pos = 0x0
	// Bit mask of DELAY_LS field.
	USBCTRL_REGS_NAK_POLL_DELAY_LS_Msk = 0x3ff

	// EP_STATUS_STALL_NAK: Device: bits are set when the `IRQ_ON_NAK` or `IRQ_ON_STALL` bits are set. For EP0 this comes from `SIE_CTRL`. For all other endpoints it comes from the endpoint control register.
	// Position of EP15_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP15_OUT_Pos = 0x1f
	// Bit mask of EP15_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP15_OUT_Msk = 0x80000000
	// Bit EP15_OUT.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP15_OUT = 0x80000000
	// Position of EP15_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP15_IN_Pos = 0x1e
	// Bit mask of EP15_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP15_IN_Msk = 0x40000000
	// Bit EP15_IN.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP15_IN = 0x40000000
	// Position of EP14_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP14_OUT_Pos = 0x1d
	// Bit mask of EP14_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP14_OUT_Msk = 0x20000000
	// Bit EP14_OUT.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP14_OUT = 0x20000000
	// Position of EP14_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP14_IN_Pos = 0x1c
	// Bit mask of EP14_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP14_IN_Msk = 0x10000000
	// Bit EP14_IN.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP14_IN = 0x10000000
	// Position of EP13_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP13_OUT_Pos = 0x1b
	// Bit mask of EP13_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP13_OUT_Msk = 0x8000000
	// Bit EP13_OUT.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP13_OUT = 0x8000000
	// Position of EP13_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP13_IN_Pos = 0x1a
	// Bit mask of EP13_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP13_IN_Msk = 0x4000000
	// Bit EP13_IN.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP13_IN = 0x4000000
	// Position of EP12_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP12_OUT_Pos = 0x19
	// Bit mask of EP12_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP12_OUT_Msk = 0x2000000
	// Bit EP12_OUT.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP12_OUT = 0x2000000
	// Position of EP12_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP12_IN_Pos = 0x18
	// Bit mask of EP12_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP12_IN_Msk = 0x1000000
	// Bit EP12_IN.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP12_IN = 0x1000000
	// Position of EP11_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP11_OUT_Pos = 0x17
	// Bit mask of EP11_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP11_OUT_Msk = 0x800000
	// Bit EP11_OUT.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP11_OUT = 0x800000
	// Position of EP11_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP11_IN_Pos = 0x16
	// Bit mask of EP11_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP11_IN_Msk = 0x400000
	// Bit EP11_IN.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP11_IN = 0x400000
	// Position of EP10_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP10_OUT_Pos = 0x15
	// Bit mask of EP10_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP10_OUT_Msk = 0x200000
	// Bit EP10_OUT.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP10_OUT = 0x200000
	// Position of EP10_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP10_IN_Pos = 0x14
	// Bit mask of EP10_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP10_IN_Msk = 0x100000
	// Bit EP10_IN.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP10_IN = 0x100000
	// Position of EP9_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP9_OUT_Pos = 0x13
	// Bit mask of EP9_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP9_OUT_Msk = 0x80000
	// Bit EP9_OUT.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP9_OUT = 0x80000
	// Position of EP9_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP9_IN_Pos = 0x12
	// Bit mask of EP9_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP9_IN_Msk = 0x40000
	// Bit EP9_IN.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP9_IN = 0x40000
	// Position of EP8_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP8_OUT_Pos = 0x11
	// Bit mask of EP8_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP8_OUT_Msk = 0x20000
	// Bit EP8_OUT.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP8_OUT = 0x20000
	// Position of EP8_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP8_IN_Pos = 0x10
	// Bit mask of EP8_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP8_IN_Msk = 0x10000
	// Bit EP8_IN.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP8_IN = 0x10000
	// Position of EP7_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP7_OUT_Pos = 0xf
	// Bit mask of EP7_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP7_OUT_Msk = 0x8000
	// Bit EP7_OUT.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP7_OUT = 0x8000
	// Position of EP7_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP7_IN_Pos = 0xe
	// Bit mask of EP7_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP7_IN_Msk = 0x4000
	// Bit EP7_IN.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP7_IN = 0x4000
	// Position of EP6_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP6_OUT_Pos = 0xd
	// Bit mask of EP6_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP6_OUT_Msk = 0x2000
	// Bit EP6_OUT.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP6_OUT = 0x2000
	// Position of EP6_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP6_IN_Pos = 0xc
	// Bit mask of EP6_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP6_IN_Msk = 0x1000
	// Bit EP6_IN.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP6_IN = 0x1000
	// Position of EP5_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP5_OUT_Pos = 0xb
	// Bit mask of EP5_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP5_OUT_Msk = 0x800
	// Bit EP5_OUT.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP5_OUT = 0x800
	// Position of EP5_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP5_IN_Pos = 0xa
	// Bit mask of EP5_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP5_IN_Msk = 0x400
	// Bit EP5_IN.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP5_IN = 0x400
	// Position of EP4_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP4_OUT_Pos = 0x9
	// Bit mask of EP4_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP4_OUT_Msk = 0x200
	// Bit EP4_OUT.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP4_OUT = 0x200
	// Position of EP4_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP4_IN_Pos = 0x8
	// Bit mask of EP4_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP4_IN_Msk = 0x100
	// Bit EP4_IN.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP4_IN = 0x100
	// Position of EP3_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP3_OUT_Pos = 0x7
	// Bit mask of EP3_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP3_OUT_Msk = 0x80
	// Bit EP3_OUT.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP3_OUT = 0x80
	// Position of EP3_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP3_IN_Pos = 0x6
	// Bit mask of EP3_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP3_IN_Msk = 0x40
	// Bit EP3_IN.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP3_IN = 0x40
	// Position of EP2_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP2_OUT_Pos = 0x5
	// Bit mask of EP2_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP2_OUT_Msk = 0x20
	// Bit EP2_OUT.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP2_OUT = 0x20
	// Position of EP2_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP2_IN_Pos = 0x4
	// Bit mask of EP2_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP2_IN_Msk = 0x10
	// Bit EP2_IN.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP2_IN = 0x10
	// Position of EP1_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP1_OUT_Pos = 0x3
	// Bit mask of EP1_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP1_OUT_Msk = 0x8
	// Bit EP1_OUT.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP1_OUT = 0x8
	// Position of EP1_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP1_IN_Pos = 0x2
	// Bit mask of EP1_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP1_IN_Msk = 0x4
	// Bit EP1_IN.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP1_IN = 0x4
	// Position of EP0_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP0_OUT_Pos = 0x1
	// Bit mask of EP0_OUT field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP0_OUT_Msk = 0x2
	// Bit EP0_OUT.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP0_OUT = 0x2
	// Position of EP0_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP0_IN_Pos = 0x0
	// Bit mask of EP0_IN field.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP0_IN_Msk = 0x1
	// Bit EP0_IN.
	USBCTRL_REGS_EP_STATUS_STALL_NAK_EP0_IN = 0x1

	// USB_MUXING: Where to connect the USB controller. Should be to_phy by default.
	// Position of SOFTCON field.
	USBCTRL_REGS_USB_MUXING_SOFTCON_Pos = 0x3
	// Bit mask of SOFTCON field.
	USBCTRL_REGS_USB_MUXING_SOFTCON_Msk = 0x8
	// Bit SOFTCON.
	USBCTRL_REGS_USB_MUXING_SOFTCON = 0x8
	// Position of TO_DIGITAL_PAD field.
	USBCTRL_REGS_USB_MUXING_TO_DIGITAL_PAD_Pos = 0x2
	// Bit mask of TO_DIGITAL_PAD field.
	USBCTRL_REGS_USB_MUXING_TO_DIGITAL_PAD_Msk = 0x4
	// Bit TO_DIGITAL_PAD.
	USBCTRL_REGS_USB_MUXING_TO_DIGITAL_PAD = 0x4
	// Position of TO_EXTPHY field.
	USBCTRL_REGS_USB_MUXING_TO_EXTPHY_Pos = 0x1
	// Bit mask of TO_EXTPHY field.
	USBCTRL_REGS_USB_MUXING_TO_EXTPHY_Msk = 0x2
	// Bit TO_EXTPHY.
	USBCTRL_REGS_USB_MUXING_TO_EXTPHY = 0x2
	// Position of TO_PHY field.
	USBCTRL_REGS_USB_MUXING_TO_PHY_Pos = 0x0
	// Bit mask of TO_PHY field.
	USBCTRL_REGS_USB_MUXING_TO_PHY_Msk = 0x1
	// Bit TO_PHY.
	USBCTRL_REGS_USB_MUXING_TO_PHY = 0x1

	// USB_PWR: Overrides for the power signals in the event that the VBUS signals are not hooked up to GPIO. Set the value of the override and then the override enable to switch over to the override value.
	// Position of OVERCURR_DETECT_EN field.
	USBCTRL_REGS_USB_PWR_OVERCURR_DETECT_EN_Pos = 0x5
	// Bit mask of OVERCURR_DETECT_EN field.
	USBCTRL_REGS_USB_PWR_OVERCURR_DETECT_EN_Msk = 0x20
	// Bit OVERCURR_DETECT_EN.
	USBCTRL_REGS_USB_PWR_OVERCURR_DETECT_EN = 0x20
	// Position of OVERCURR_DETECT field.
	USBCTRL_REGS_USB_PWR_OVERCURR_DETECT_Pos = 0x4
	// Bit mask of OVERCURR_DETECT field.
	USBCTRL_REGS_USB_PWR_OVERCURR_DETECT_Msk = 0x10
	// Bit OVERCURR_DETECT.
	USBCTRL_REGS_USB_PWR_OVERCURR_DETECT = 0x10
	// Position of VBUS_DETECT_OVERRIDE_EN field.
	USBCTRL_REGS_USB_PWR_VBUS_DETECT_OVERRIDE_EN_Pos = 0x3
	// Bit mask of VBUS_DETECT_OVERRIDE_EN field.
	USBCTRL_REGS_USB_PWR_VBUS_DETECT_OVERRIDE_EN_Msk = 0x8
	// Bit VBUS_DETECT_OVERRIDE_EN.
	USBCTRL_REGS_USB_PWR_VBUS_DETECT_OVERRIDE_EN = 0x8
	// Position of VBUS_DETECT field.
	USBCTRL_REGS_USB_PWR_VBUS_DETECT_Pos = 0x2
	// Bit mask of VBUS_DETECT field.
	USBCTRL_REGS_USB_PWR_VBUS_DETECT_Msk = 0x4
	// Bit VBUS_DETECT.
	USBCTRL_REGS_USB_PWR_VBUS_DETECT = 0x4
	// Position of VBUS_EN_OVERRIDE_EN field.
	USBCTRL_REGS_USB_PWR_VBUS_EN_OVERRIDE_EN_Pos = 0x1
	// Bit mask of VBUS_EN_OVERRIDE_EN field.
	USBCTRL_REGS_USB_PWR_VBUS_EN_OVERRIDE_EN_Msk = 0x2
	// Bit VBUS_EN_OVERRIDE_EN.
	USBCTRL_REGS_USB_PWR_VBUS_EN_OVERRIDE_EN = 0x2
	// Position of VBUS_EN field.
	USBCTRL_REGS_USB_PWR_VBUS_EN_Pos = 0x0
	// Bit mask of VBUS_EN field.
	USBCTRL_REGS_USB_PWR_VBUS_EN_Msk = 0x1
	// Bit VBUS_EN.
	USBCTRL_REGS_USB_PWR_VBUS_EN = 0x1

	// USBPHY_DIRECT: This register allows for direct control of the USB phy. Use in conjunction with usbphy_direct_override register to enable each override bit.
	// Position of DM_OVV field.
	USBCTRL_REGS_USBPHY_DIRECT_DM_OVV_Pos = 0x16
	// Bit mask of DM_OVV field.
	USBCTRL_REGS_USBPHY_DIRECT_DM_OVV_Msk = 0x400000
	// Bit DM_OVV.
	USBCTRL_REGS_USBPHY_DIRECT_DM_OVV = 0x400000
	// Position of DP_OVV field.
	USBCTRL_REGS_USBPHY_DIRECT_DP_OVV_Pos = 0x15
	// Bit mask of DP_OVV field.
	USBCTRL_REGS_USBPHY_DIRECT_DP_OVV_Msk = 0x200000
	// Bit DP_OVV.
	USBCTRL_REGS_USBPHY_DIRECT_DP_OVV = 0x200000
	// Position of DM_OVCN field.
	USBCTRL_REGS_USBPHY_DIRECT_DM_OVCN_Pos = 0x14
	// Bit mask of DM_OVCN field.
	USBCTRL_REGS_USBPHY_DIRECT_DM_OVCN_Msk = 0x100000
	// Bit DM_OVCN.
	USBCTRL_REGS_USBPHY_DIRECT_DM_OVCN = 0x100000
	// Position of DP_OVCN field.
	USBCTRL_REGS_USBPHY_DIRECT_DP_OVCN_Pos = 0x13
	// Bit mask of DP_OVCN field.
	USBCTRL_REGS_USBPHY_DIRECT_DP_OVCN_Msk = 0x80000
	// Bit DP_OVCN.
	USBCTRL_REGS_USBPHY_DIRECT_DP_OVCN = 0x80000
	// Position of RX_DM field.
	USBCTRL_REGS_USBPHY_DIRECT_RX_DM_Pos = 0x12
	// Bit mask of RX_DM field.
	USBCTRL_REGS_USBPHY_DIRECT_RX_DM_Msk = 0x40000
	// Bit RX_DM.
	USBCTRL_REGS_USBPHY_DIRECT_RX_DM = 0x40000
	// Position of RX_DP field.
	USBCTRL_REGS_USBPHY_DIRECT_RX_DP_Pos = 0x11
	// Bit mask of RX_DP field.
	USBCTRL_REGS_USBPHY_DIRECT_RX_DP_Msk = 0x20000
	// Bit RX_DP.
	USBCTRL_REGS_USBPHY_DIRECT_RX_DP = 0x20000
	// Position of RX_DD field.
	USBCTRL_REGS_USBPHY_DIRECT_RX_DD_Pos = 0x10
	// Bit mask of RX_DD field.
	USBCTRL_REGS_USBPHY_DIRECT_RX_DD_Msk = 0x10000
	// Bit RX_DD.
	USBCTRL_REGS_USBPHY_DIRECT_RX_DD = 0x10000
	// Position of TX_DIFFMODE field.
	USBCTRL_REGS_USBPHY_DIRECT_TX_DIFFMODE_Pos = 0xf
	// Bit mask of TX_DIFFMODE field.
	USBCTRL_REGS_USBPHY_DIRECT_TX_DIFFMODE_Msk = 0x8000
	// Bit TX_DIFFMODE.
	USBCTRL_REGS_USBPHY_DIRECT_TX_DIFFMODE = 0x8000
	// Position of TX_FSSLEW field.
	USBCTRL_REGS_USBPHY_DIRECT_TX_FSSLEW_Pos = 0xe
	// Bit mask of TX_FSSLEW field.
	USBCTRL_REGS_USBPHY_DIRECT_TX_FSSLEW_Msk = 0x4000
	// Bit TX_FSSLEW.
	USBCTRL_REGS_USBPHY_DIRECT_TX_FSSLEW = 0x4000
	// Position of TX_PD field.
	USBCTRL_REGS_USBPHY_DIRECT_TX_PD_Pos = 0xd
	// Bit mask of TX_PD field.
	USBCTRL_REGS_USBPHY_DIRECT_TX_PD_Msk = 0x2000
	// Bit TX_PD.
	USBCTRL_REGS_USBPHY_DIRECT_TX_PD = 0x2000
	// Position of RX_PD field.
	USBCTRL_REGS_USBPHY_DIRECT_RX_PD_Pos = 0xc
	// Bit mask of RX_PD field.
	USBCTRL_REGS_USBPHY_DIRECT_RX_PD_Msk = 0x1000
	// Bit RX_PD.
	USBCTRL_REGS_USBPHY_DIRECT_RX_PD = 0x1000
	// Position of TX_DM field.
	USBCTRL_REGS_USBPHY_DIRECT_TX_DM_Pos = 0xb
	// Bit mask of TX_DM field.
	USBCTRL_REGS_USBPHY_DIRECT_TX_DM_Msk = 0x800
	// Bit TX_DM.
	USBCTRL_REGS_USBPHY_DIRECT_TX_DM = 0x800
	// Position of TX_DP field.
	USBCTRL_REGS_USBPHY_DIRECT_TX_DP_Pos = 0xa
	// Bit mask of TX_DP field.
	USBCTRL_REGS_USBPHY_DIRECT_TX_DP_Msk = 0x400
	// Bit TX_DP.
	USBCTRL_REGS_USBPHY_DIRECT_TX_DP = 0x400
	// Position of TX_DM_OE field.
	USBCTRL_REGS_USBPHY_DIRECT_TX_DM_OE_Pos = 0x9
	// Bit mask of TX_DM_OE field.
	USBCTRL_REGS_USBPHY_DIRECT_TX_DM_OE_Msk = 0x200
	// Bit TX_DM_OE.
	USBCTRL_REGS_USBPHY_DIRECT_TX_DM_OE = 0x200
	// Position of TX_DP_OE field.
	USBCTRL_REGS_USBPHY_DIRECT_TX_DP_OE_Pos = 0x8
	// Bit mask of TX_DP_OE field.
	USBCTRL_REGS_USBPHY_DIRECT_TX_DP_OE_Msk = 0x100
	// Bit TX_DP_OE.
	USBCTRL_REGS_USBPHY_DIRECT_TX_DP_OE = 0x100
	// Position of DM_PULLDN_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_DM_PULLDN_EN_Pos = 0x6
	// Bit mask of DM_PULLDN_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_DM_PULLDN_EN_Msk = 0x40
	// Bit DM_PULLDN_EN.
	USBCTRL_REGS_USBPHY_DIRECT_DM_PULLDN_EN = 0x40
	// Position of DM_PULLUP_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_DM_PULLUP_EN_Pos = 0x5
	// Bit mask of DM_PULLUP_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_DM_PULLUP_EN_Msk = 0x20
	// Bit DM_PULLUP_EN.
	USBCTRL_REGS_USBPHY_DIRECT_DM_PULLUP_EN = 0x20
	// Position of DM_PULLUP_HISEL field.
	USBCTRL_REGS_USBPHY_DIRECT_DM_PULLUP_HISEL_Pos = 0x4
	// Bit mask of DM_PULLUP_HISEL field.
	USBCTRL_REGS_USBPHY_DIRECT_DM_PULLUP_HISEL_Msk = 0x10
	// Bit DM_PULLUP_HISEL.
	USBCTRL_REGS_USBPHY_DIRECT_DM_PULLUP_HISEL = 0x10
	// Position of DP_PULLDN_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_DP_PULLDN_EN_Pos = 0x2
	// Bit mask of DP_PULLDN_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_DP_PULLDN_EN_Msk = 0x4
	// Bit DP_PULLDN_EN.
	USBCTRL_REGS_USBPHY_DIRECT_DP_PULLDN_EN = 0x4
	// Position of DP_PULLUP_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_DP_PULLUP_EN_Pos = 0x1
	// Bit mask of DP_PULLUP_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_DP_PULLUP_EN_Msk = 0x2
	// Bit DP_PULLUP_EN.
	USBCTRL_REGS_USBPHY_DIRECT_DP_PULLUP_EN = 0x2
	// Position of DP_PULLUP_HISEL field.
	USBCTRL_REGS_USBPHY_DIRECT_DP_PULLUP_HISEL_Pos = 0x0
	// Bit mask of DP_PULLUP_HISEL field.
	USBCTRL_REGS_USBPHY_DIRECT_DP_PULLUP_HISEL_Msk = 0x1
	// Bit DP_PULLUP_HISEL.
	USBCTRL_REGS_USBPHY_DIRECT_DP_PULLUP_HISEL = 0x1

	// USBPHY_DIRECT_OVERRIDE: Override enable for each control in usbphy_direct
	// Position of TX_DIFFMODE_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DIFFMODE_OVERRIDE_EN_Pos = 0xf
	// Bit mask of TX_DIFFMODE_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DIFFMODE_OVERRIDE_EN_Msk = 0x8000
	// Bit TX_DIFFMODE_OVERRIDE_EN.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DIFFMODE_OVERRIDE_EN = 0x8000
	// Position of DM_PULLUP_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_OVERRIDE_EN_Pos = 0xc
	// Bit mask of DM_PULLUP_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_OVERRIDE_EN_Msk = 0x1000
	// Bit DM_PULLUP_OVERRIDE_EN.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_OVERRIDE_EN = 0x1000
	// Position of TX_FSSLEW_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_FSSLEW_OVERRIDE_EN_Pos = 0xb
	// Bit mask of TX_FSSLEW_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_FSSLEW_OVERRIDE_EN_Msk = 0x800
	// Bit TX_FSSLEW_OVERRIDE_EN.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_FSSLEW_OVERRIDE_EN = 0x800
	// Position of TX_PD_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_PD_OVERRIDE_EN_Pos = 0xa
	// Bit mask of TX_PD_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_PD_OVERRIDE_EN_Msk = 0x400
	// Bit TX_PD_OVERRIDE_EN.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_PD_OVERRIDE_EN = 0x400
	// Position of RX_PD_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_RX_PD_OVERRIDE_EN_Pos = 0x9
	// Bit mask of RX_PD_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_RX_PD_OVERRIDE_EN_Msk = 0x200
	// Bit RX_PD_OVERRIDE_EN.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_RX_PD_OVERRIDE_EN = 0x200
	// Position of TX_DM_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DM_OVERRIDE_EN_Pos = 0x8
	// Bit mask of TX_DM_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DM_OVERRIDE_EN_Msk = 0x100
	// Bit TX_DM_OVERRIDE_EN.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DM_OVERRIDE_EN = 0x100
	// Position of TX_DP_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DP_OVERRIDE_EN_Pos = 0x7
	// Bit mask of TX_DP_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DP_OVERRIDE_EN_Msk = 0x80
	// Bit TX_DP_OVERRIDE_EN.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DP_OVERRIDE_EN = 0x80
	// Position of TX_DM_OE_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DM_OE_OVERRIDE_EN_Pos = 0x6
	// Bit mask of TX_DM_OE_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DM_OE_OVERRIDE_EN_Msk = 0x40
	// Bit TX_DM_OE_OVERRIDE_EN.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DM_OE_OVERRIDE_EN = 0x40
	// Position of TX_DP_OE_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DP_OE_OVERRIDE_EN_Pos = 0x5
	// Bit mask of TX_DP_OE_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DP_OE_OVERRIDE_EN_Msk = 0x20
	// Bit TX_DP_OE_OVERRIDE_EN.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DP_OE_OVERRIDE_EN = 0x20
	// Position of DM_PULLDN_EN_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLDN_EN_OVERRIDE_EN_Pos = 0x4
	// Bit mask of DM_PULLDN_EN_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLDN_EN_OVERRIDE_EN_Msk = 0x10
	// Bit DM_PULLDN_EN_OVERRIDE_EN.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLDN_EN_OVERRIDE_EN = 0x10
	// Position of DP_PULLDN_EN_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLDN_EN_OVERRIDE_EN_Pos = 0x3
	// Bit mask of DP_PULLDN_EN_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLDN_EN_OVERRIDE_EN_Msk = 0x8
	// Bit DP_PULLDN_EN_OVERRIDE_EN.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLDN_EN_OVERRIDE_EN = 0x8
	// Position of DP_PULLUP_EN_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_EN_OVERRIDE_EN_Pos = 0x2
	// Bit mask of DP_PULLUP_EN_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_EN_OVERRIDE_EN_Msk = 0x4
	// Bit DP_PULLUP_EN_OVERRIDE_EN.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_EN_OVERRIDE_EN = 0x4
	// Position of DM_PULLUP_HISEL_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_HISEL_OVERRIDE_EN_Pos = 0x1
	// Bit mask of DM_PULLUP_HISEL_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_HISEL_OVERRIDE_EN_Msk = 0x2
	// Bit DM_PULLUP_HISEL_OVERRIDE_EN.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_HISEL_OVERRIDE_EN = 0x2
	// Position of DP_PULLUP_HISEL_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_HISEL_OVERRIDE_EN_Pos = 0x0
	// Bit mask of DP_PULLUP_HISEL_OVERRIDE_EN field.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_HISEL_OVERRIDE_EN_Msk = 0x1
	// Bit DP_PULLUP_HISEL_OVERRIDE_EN.
	USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_HISEL_OVERRIDE_EN = 0x1

	// USBPHY_TRIM: Used to adjust trim values of USB phy pull down resistors.
	// Position of DM_PULLDN_TRIM field.
	USBCTRL_REGS_USBPHY_TRIM_DM_PULLDN_TRIM_Pos = 0x8
	// Bit mask of DM_PULLDN_TRIM field.
	USBCTRL_REGS_USBPHY_TRIM_DM_PULLDN_TRIM_Msk = 0x1f00
	// Position of DP_PULLDN_TRIM field.
	USBCTRL_REGS_USBPHY_TRIM_DP_PULLDN_TRIM_Pos = 0x0
	// Bit mask of DP_PULLDN_TRIM field.
	USBCTRL_REGS_USBPHY_TRIM_DP_PULLDN_TRIM_Msk = 0x1f

	// INTR: Raw Interrupts
	// Position of EP_STALL_NAK field.
	USBCTRL_REGS_INTR_EP_STALL_NAK_Pos = 0x13
	// Bit mask of EP_STALL_NAK field.
	USBCTRL_REGS_INTR_EP_STALL_NAK_Msk = 0x80000
	// Bit EP_STALL_NAK.
	USBCTRL_REGS_INTR_EP_STALL_NAK = 0x80000
	// Position of ABORT_DONE field.
	USBCTRL_REGS_INTR_ABORT_DONE_Pos = 0x12
	// Bit mask of ABORT_DONE field.
	USBCTRL_REGS_INTR_ABORT_DONE_Msk = 0x40000
	// Bit ABORT_DONE.
	USBCTRL_REGS_INTR_ABORT_DONE = 0x40000
	// Position of DEV_SOF field.
	USBCTRL_REGS_INTR_DEV_SOF_Pos = 0x11
	// Bit mask of DEV_SOF field.
	USBCTRL_REGS_INTR_DEV_SOF_Msk = 0x20000
	// Bit DEV_SOF.
	USBCTRL_REGS_INTR_DEV_SOF = 0x20000
	// Position of SETUP_REQ field.
	USBCTRL_REGS_INTR_SETUP_REQ_Pos = 0x10
	// Bit mask of SETUP_REQ field.
	USBCTRL_REGS_INTR_SETUP_REQ_Msk = 0x10000
	// Bit SETUP_REQ.
	USBCTRL_REGS_INTR_SETUP_REQ = 0x10000
	// Position of DEV_RESUME_FROM_HOST field.
	USBCTRL_REGS_INTR_DEV_RESUME_FROM_HOST_Pos = 0xf
	// Bit mask of DEV_RESUME_FROM_HOST field.
	USBCTRL_REGS_INTR_DEV_RESUME_FROM_HOST_Msk = 0x8000
	// Bit DEV_RESUME_FROM_HOST.
	USBCTRL_REGS_INTR_DEV_RESUME_FROM_HOST = 0x8000
	// Position of DEV_SUSPEND field.
	USBCTRL_REGS_INTR_DEV_SUSPEND_Pos = 0xe
	// Bit mask of DEV_SUSPEND field.
	USBCTRL_REGS_INTR_DEV_SUSPEND_Msk = 0x4000
	// Bit DEV_SUSPEND.
	USBCTRL_REGS_INTR_DEV_SUSPEND = 0x4000
	// Position of DEV_CONN_DIS field.
	USBCTRL_REGS_INTR_DEV_CONN_DIS_Pos = 0xd
	// Bit mask of DEV_CONN_DIS field.
	USBCTRL_REGS_INTR_DEV_CONN_DIS_Msk = 0x2000
	// Bit DEV_CONN_DIS.
	USBCTRL_REGS_INTR_DEV_CONN_DIS = 0x2000
	// Position of BUS_RESET field.
	USBCTRL_REGS_INTR_BUS_RESET_Pos = 0xc
	// Bit mask of BUS_RESET field.
	USBCTRL_REGS_INTR_BUS_RESET_Msk = 0x1000
	// Bit BUS_RESET.
	USBCTRL_REGS_INTR_BUS_RESET = 0x1000
	// Position of VBUS_DETECT field.
	USBCTRL_REGS_INTR_VBUS_DETECT_Pos = 0xb
	// Bit mask of VBUS_DETECT field.
	USBCTRL_REGS_INTR_VBUS_DETECT_Msk = 0x800
	// Bit VBUS_DETECT.
	USBCTRL_REGS_INTR_VBUS_DETECT = 0x800
	// Position of STALL field.
	USBCTRL_REGS_INTR_STALL_Pos = 0xa
	// Bit mask of STALL field.
	USBCTRL_REGS_INTR_STALL_Msk = 0x400
	// Bit STALL.
	USBCTRL_REGS_INTR_STALL = 0x400
	// Position of ERROR_CRC field.
	USBCTRL_REGS_INTR_ERROR_CRC_Pos = 0x9
	// Bit mask of ERROR_CRC field.
	USBCTRL_REGS_INTR_ERROR_CRC_Msk = 0x200
	// Bit ERROR_CRC.
	USBCTRL_REGS_INTR_ERROR_CRC = 0x200
	// Position of ERROR_BIT_STUFF field.
	USBCTRL_REGS_INTR_ERROR_BIT_STUFF_Pos = 0x8
	// Bit mask of ERROR_BIT_STUFF field.
	USBCTRL_REGS_INTR_ERROR_BIT_STUFF_Msk = 0x100
	// Bit ERROR_BIT_STUFF.
	USBCTRL_REGS_INTR_ERROR_BIT_STUFF = 0x100
	// Position of ERROR_RX_OVERFLOW field.
	USBCTRL_REGS_INTR_ERROR_RX_OVERFLOW_Pos = 0x7
	// Bit mask of ERROR_RX_OVERFLOW field.
	USBCTRL_REGS_INTR_ERROR_RX_OVERFLOW_Msk = 0x80
	// Bit ERROR_RX_OVERFLOW.
	USBCTRL_REGS_INTR_ERROR_RX_OVERFLOW = 0x80
	// Position of ERROR_RX_TIMEOUT field.
	USBCTRL_REGS_INTR_ERROR_RX_TIMEOUT_Pos = 0x6
	// Bit mask of ERROR_RX_TIMEOUT field.
	USBCTRL_REGS_INTR_ERROR_RX_TIMEOUT_Msk = 0x40
	// Bit ERROR_RX_TIMEOUT.
	USBCTRL_REGS_INTR_ERROR_RX_TIMEOUT = 0x40
	// Position of ERROR_DATA_SEQ field.
	USBCTRL_REGS_INTR_ERROR_DATA_SEQ_Pos = 0x5
	// Bit mask of ERROR_DATA_SEQ field.
	USBCTRL_REGS_INTR_ERROR_DATA_SEQ_Msk = 0x20
	// Bit ERROR_DATA_SEQ.
	USBCTRL_REGS_INTR_ERROR_DATA_SEQ = 0x20
	// Position of BUFF_STATUS field.
	USBCTRL_REGS_INTR_BUFF_STATUS_Pos = 0x4
	// Bit mask of BUFF_STATUS field.
	USBCTRL_REGS_INTR_BUFF_STATUS_Msk = 0x10
	// Bit BUFF_STATUS.
	USBCTRL_REGS_INTR_BUFF_STATUS = 0x10
	// Position of TRANS_COMPLETE field.
	USBCTRL_REGS_INTR_TRANS_COMPLETE_Pos = 0x3
	// Bit mask of TRANS_COMPLETE field.
	USBCTRL_REGS_INTR_TRANS_COMPLETE_Msk = 0x8
	// Bit TRANS_COMPLETE.
	USBCTRL_REGS_INTR_TRANS_COMPLETE = 0x8
	// Position of HOST_SOF field.
	USBCTRL_REGS_INTR_HOST_SOF_Pos = 0x2
	// Bit mask of HOST_SOF field.
	USBCTRL_REGS_INTR_HOST_SOF_Msk = 0x4
	// Bit HOST_SOF.
	USBCTRL_REGS_INTR_HOST_SOF = 0x4
	// Position of HOST_RESUME field.
	USBCTRL_REGS_INTR_HOST_RESUME_Pos = 0x1
	// Bit mask of HOST_RESUME field.
	USBCTRL_REGS_INTR_HOST_RESUME_Msk = 0x2
	// Bit HOST_RESUME.
	USBCTRL_REGS_INTR_HOST_RESUME = 0x2
	// Position of HOST_CONN_DIS field.
	USBCTRL_REGS_INTR_HOST_CONN_DIS_Pos = 0x0
	// Bit mask of HOST_CONN_DIS field.
	USBCTRL_REGS_INTR_HOST_CONN_DIS_Msk = 0x1
	// Bit HOST_CONN_DIS.
	USBCTRL_REGS_INTR_HOST_CONN_DIS = 0x1

	// INTE: Interrupt Enable
	// Position of EP_STALL_NAK field.
	USBCTRL_REGS_INTE_EP_STALL_NAK_Pos = 0x13
	// Bit mask of EP_STALL_NAK field.
	USBCTRL_REGS_INTE_EP_STALL_NAK_Msk = 0x80000
	// Bit EP_STALL_NAK.
	USBCTRL_REGS_INTE_EP_STALL_NAK = 0x80000
	// Position of ABORT_DONE field.
	USBCTRL_REGS_INTE_ABORT_DONE_Pos = 0x12
	// Bit mask of ABORT_DONE field.
	USBCTRL_REGS_INTE_ABORT_DONE_Msk = 0x40000
	// Bit ABORT_DONE.
	USBCTRL_REGS_INTE_ABORT_DONE = 0x40000
	// Position of DEV_SOF field.
	USBCTRL_REGS_INTE_DEV_SOF_Pos = 0x11
	// Bit mask of DEV_SOF field.
	USBCTRL_REGS_INTE_DEV_SOF_Msk = 0x20000
	// Bit DEV_SOF.
	USBCTRL_REGS_INTE_DEV_SOF = 0x20000
	// Position of SETUP_REQ field.
	USBCTRL_REGS_INTE_SETUP_REQ_Pos = 0x10
	// Bit mask of SETUP_REQ field.
	USBCTRL_REGS_INTE_SETUP_REQ_Msk = 0x10000
	// Bit SETUP_REQ.
	USBCTRL_REGS_INTE_SETUP_REQ = 0x10000
	// Position of DEV_RESUME_FROM_HOST field.
	USBCTRL_REGS_INTE_DEV_RESUME_FROM_HOST_Pos = 0xf
	// Bit mask of DEV_RESUME_FROM_HOST field.
	USBCTRL_REGS_INTE_DEV_RESUME_FROM_HOST_Msk = 0x8000
	// Bit DEV_RESUME_FROM_HOST.
	USBCTRL_REGS_INTE_DEV_RESUME_FROM_HOST = 0x8000
	// Position of DEV_SUSPEND field.
	USBCTRL_REGS_INTE_DEV_SUSPEND_Pos = 0xe
	// Bit mask of DEV_SUSPEND field.
	USBCTRL_REGS_INTE_DEV_SUSPEND_Msk = 0x4000
	// Bit DEV_SUSPEND.
	USBCTRL_REGS_INTE_DEV_SUSPEND = 0x4000
	// Position of DEV_CONN_DIS field.
	USBCTRL_REGS_INTE_DEV_CONN_DIS_Pos = 0xd
	// Bit mask of DEV_CONN_DIS field.
	USBCTRL_REGS_INTE_DEV_CONN_DIS_Msk = 0x2000
	// Bit DEV_CONN_DIS.
	USBCTRL_REGS_INTE_DEV_CONN_DIS = 0x2000
	// Position of BUS_RESET field.
	USBCTRL_REGS_INTE_BUS_RESET_Pos = 0xc
	// Bit mask of BUS_RESET field.
	USBCTRL_REGS_INTE_BUS_RESET_Msk = 0x1000
	// Bit BUS_RESET.
	USBCTRL_REGS_INTE_BUS_RESET = 0x1000
	// Position of VBUS_DETECT field.
	USBCTRL_REGS_INTE_VBUS_DETECT_Pos = 0xb
	// Bit mask of VBUS_DETECT field.
	USBCTRL_REGS_INTE_VBUS_DETECT_Msk = 0x800
	// Bit VBUS_DETECT.
	USBCTRL_REGS_INTE_VBUS_DETECT = 0x800
	// Position of STALL field.
	USBCTRL_REGS_INTE_STALL_Pos = 0xa
	// Bit mask of STALL field.
	USBCTRL_REGS_INTE_STALL_Msk = 0x400
	// Bit STALL.
	USBCTRL_REGS_INTE_STALL = 0x400
	// Position of ERROR_CRC field.
	USBCTRL_REGS_INTE_ERROR_CRC_Pos = 0x9
	// Bit mask of ERROR_CRC field.
	USBCTRL_REGS_INTE_ERROR_CRC_Msk = 0x200
	// Bit ERROR_CRC.
	USBCTRL_REGS_INTE_ERROR_CRC = 0x200
	// Position of ERROR_BIT_STUFF field.
	USBCTRL_REGS_INTE_ERROR_BIT_STUFF_Pos = 0x8
	// Bit mask of ERROR_BIT_STUFF field.
	USBCTRL_REGS_INTE_ERROR_BIT_STUFF_Msk = 0x100
	// Bit ERROR_BIT_STUFF.
	USBCTRL_REGS_INTE_ERROR_BIT_STUFF = 0x100
	// Position of ERROR_RX_OVERFLOW field.
	USBCTRL_REGS_INTE_ERROR_RX_OVERFLOW_Pos = 0x7
	// Bit mask of ERROR_RX_OVERFLOW field.
	USBCTRL_REGS_INTE_ERROR_RX_OVERFLOW_Msk = 0x80
	// Bit ERROR_RX_OVERFLOW.
	USBCTRL_REGS_INTE_ERROR_RX_OVERFLOW = 0x80
	// Position of ERROR_RX_TIMEOUT field.
	USBCTRL_REGS_INTE_ERROR_RX_TIMEOUT_Pos = 0x6
	// Bit mask of ERROR_RX_TIMEOUT field.
	USBCTRL_REGS_INTE_ERROR_RX_TIMEOUT_Msk = 0x40
	// Bit ERROR_RX_TIMEOUT.
	USBCTRL_REGS_INTE_ERROR_RX_TIMEOUT = 0x40
	// Position of ERROR_DATA_SEQ field.
	USBCTRL_REGS_INTE_ERROR_DATA_SEQ_Pos = 0x5
	// Bit mask of ERROR_DATA_SEQ field.
	USBCTRL_REGS_INTE_ERROR_DATA_SEQ_Msk = 0x20
	// Bit ERROR_DATA_SEQ.
	USBCTRL_REGS_INTE_ERROR_DATA_SEQ = 0x20
	// Position of BUFF_STATUS field.
	USBCTRL_REGS_INTE_BUFF_STATUS_Pos = 0x4
	// Bit mask of BUFF_STATUS field.
	USBCTRL_REGS_INTE_BUFF_STATUS_Msk = 0x10
	// Bit BUFF_STATUS.
	USBCTRL_REGS_INTE_BUFF_STATUS = 0x10
	// Position of TRANS_COMPLETE field.
	USBCTRL_REGS_INTE_TRANS_COMPLETE_Pos = 0x3
	// Bit mask of TRANS_COMPLETE field.
	USBCTRL_REGS_INTE_TRANS_COMPLETE_Msk = 0x8
	// Bit TRANS_COMPLETE.
	USBCTRL_REGS_INTE_TRANS_COMPLETE = 0x8
	// Position of HOST_SOF field.
	USBCTRL_REGS_INTE_HOST_SOF_Pos = 0x2
	// Bit mask of HOST_SOF field.
	USBCTRL_REGS_INTE_HOST_SOF_Msk = 0x4
	// Bit HOST_SOF.
	USBCTRL_REGS_INTE_HOST_SOF = 0x4
	// Position of HOST_RESUME field.
	USBCTRL_REGS_INTE_HOST_RESUME_Pos = 0x1
	// Bit mask of HOST_RESUME field.
	USBCTRL_REGS_INTE_HOST_RESUME_Msk = 0x2
	// Bit HOST_RESUME.
	USBCTRL_REGS_INTE_HOST_RESUME = 0x2
	// Position of HOST_CONN_DIS field.
	USBCTRL_REGS_INTE_HOST_CONN_DIS_Pos = 0x0
	// Bit mask of HOST_CONN_DIS field.
	USBCTRL_REGS_INTE_HOST_CONN_DIS_Msk = 0x1
	// Bit HOST_CONN_DIS.
	USBCTRL_REGS_INTE_HOST_CONN_DIS = 0x1

	// INTF: Interrupt Force
	// Position of EP_STALL_NAK field.
	USBCTRL_REGS_INTF_EP_STALL_NAK_Pos = 0x13
	// Bit mask of EP_STALL_NAK field.
	USBCTRL_REGS_INTF_EP_STALL_NAK_Msk = 0x80000
	// Bit EP_STALL_NAK.
	USBCTRL_REGS_INTF_EP_STALL_NAK = 0x80000
	// Position of ABORT_DONE field.
	USBCTRL_REGS_INTF_ABORT_DONE_Pos = 0x12
	// Bit mask of ABORT_DONE field.
	USBCTRL_REGS_INTF_ABORT_DONE_Msk = 0x40000
	// Bit ABORT_DONE.
	USBCTRL_REGS_INTF_ABORT_DONE = 0x40000
	// Position of DEV_SOF field.
	USBCTRL_REGS_INTF_DEV_SOF_Pos = 0x11
	// Bit mask of DEV_SOF field.
	USBCTRL_REGS_INTF_DEV_SOF_Msk = 0x20000
	// Bit DEV_SOF.
	USBCTRL_REGS_INTF_DEV_SOF = 0x20000
	// Position of SETUP_REQ field.
	USBCTRL_REGS_INTF_SETUP_REQ_Pos = 0x10
	// Bit mask of SETUP_REQ field.
	USBCTRL_REGS_INTF_SETUP_REQ_Msk = 0x10000
	// Bit SETUP_REQ.
	USBCTRL_REGS_INTF_SETUP_REQ = 0x10000
	// Position of DEV_RESUME_FROM_HOST field.
	USBCTRL_REGS_INTF_DEV_RESUME_FROM_HOST_Pos = 0xf
	// Bit mask of DEV_RESUME_FROM_HOST field.
	USBCTRL_REGS_INTF_DEV_RESUME_FROM_HOST_Msk = 0x8000
	// Bit DEV_RESUME_FROM_HOST.
	USBCTRL_REGS_INTF_DEV_RESUME_FROM_HOST = 0x8000
	// Position of DEV_SUSPEND field.
	USBCTRL_REGS_INTF_DEV_SUSPEND_Pos = 0xe
	// Bit mask of DEV_SUSPEND field.
	USBCTRL_REGS_INTF_DEV_SUSPEND_Msk = 0x4000
	// Bit DEV_SUSPEND.
	USBCTRL_REGS_INTF_DEV_SUSPEND = 0x4000
	// Position of DEV_CONN_DIS field.
	USBCTRL_REGS_INTF_DEV_CONN_DIS_Pos = 0xd
	// Bit mask of DEV_CONN_DIS field.
	USBCTRL_REGS_INTF_DEV_CONN_DIS_Msk = 0x2000
	// Bit DEV_CONN_DIS.
	USBCTRL_REGS_INTF_DEV_CONN_DIS = 0x2000
	// Position of BUS_RESET field.
	USBCTRL_REGS_INTF_BUS_RESET_Pos = 0xc
	// Bit mask of BUS_RESET field.
	USBCTRL_REGS_INTF_BUS_RESET_Msk = 0x1000
	// Bit BUS_RESET.
	USBCTRL_REGS_INTF_BUS_RESET = 0x1000
	// Position of VBUS_DETECT field.
	USBCTRL_REGS_INTF_VBUS_DETECT_Pos = 0xb
	// Bit mask of VBUS_DETECT field.
	USBCTRL_REGS_INTF_VBUS_DETECT_Msk = 0x800
	// Bit VBUS_DETECT.
	USBCTRL_REGS_INTF_VBUS_DETECT = 0x800
	// Position of STALL field.
	USBCTRL_REGS_INTF_STALL_Pos = 0xa
	// Bit mask of STALL field.
	USBCTRL_REGS_INTF_STALL_Msk = 0x400
	// Bit STALL.
	USBCTRL_REGS_INTF_STALL = 0x400
	// Position of ERROR_CRC field.
	USBCTRL_REGS_INTF_ERROR_CRC_Pos = 0x9
	// Bit mask of ERROR_CRC field.
	USBCTRL_REGS_INTF_ERROR_CRC_Msk = 0x200
	// Bit ERROR_CRC.
	USBCTRL_REGS_INTF_ERROR_CRC = 0x200
	// Position of ERROR_BIT_STUFF field.
	USBCTRL_REGS_INTF_ERROR_BIT_STUFF_Pos = 0x8
	// Bit mask of ERROR_BIT_STUFF field.
	USBCTRL_REGS_INTF_ERROR_BIT_STUFF_Msk = 0x100
	// Bit ERROR_BIT_STUFF.
	USBCTRL_REGS_INTF_ERROR_BIT_STUFF = 0x100
	// Position of ERROR_RX_OVERFLOW field.
	USBCTRL_REGS_INTF_ERROR_RX_OVERFLOW_Pos = 0x7
	// Bit mask of ERROR_RX_OVERFLOW field.
	USBCTRL_REGS_INTF_ERROR_RX_OVERFLOW_Msk = 0x80
	// Bit ERROR_RX_OVERFLOW.
	USBCTRL_REGS_INTF_ERROR_RX_OVERFLOW = 0x80
	// Position of ERROR_RX_TIMEOUT field.
	USBCTRL_REGS_INTF_ERROR_RX_TIMEOUT_Pos = 0x6
	// Bit mask of ERROR_RX_TIMEOUT field.
	USBCTRL_REGS_INTF_ERROR_RX_TIMEOUT_Msk = 0x40
	// Bit ERROR_RX_TIMEOUT.
	USBCTRL_REGS_INTF_ERROR_RX_TIMEOUT = 0x40
	// Position of ERROR_DATA_SEQ field.
	USBCTRL_REGS_INTF_ERROR_DATA_SEQ_Pos = 0x5
	// Bit mask of ERROR_DATA_SEQ field.
	USBCTRL_REGS_INTF_ERROR_DATA_SEQ_Msk = 0x20
	// Bit ERROR_DATA_SEQ.
	USBCTRL_REGS_INTF_ERROR_DATA_SEQ = 0x20
	// Position of BUFF_STATUS field.
	USBCTRL_REGS_INTF_BUFF_STATUS_Pos = 0x4
	// Bit mask of BUFF_STATUS field.
	USBCTRL_REGS_INTF_BUFF_STATUS_Msk = 0x10
	// Bit BUFF_STATUS.
	USBCTRL_REGS_INTF_BUFF_STATUS = 0x10
	// Position of TRANS_COMPLETE field.
	USBCTRL_REGS_INTF_TRANS_COMPLETE_Pos = 0x3
	// Bit mask of TRANS_COMPLETE field.
	USBCTRL_REGS_INTF_TRANS_COMPLETE_Msk = 0x8
	// Bit TRANS_COMPLETE.
	USBCTRL_REGS_INTF_TRANS_COMPLETE = 0x8
	// Position of HOST_SOF field.
	USBCTRL_REGS_INTF_HOST_SOF_Pos = 0x2
	// Bit mask of HOST_SOF field.
	USBCTRL_REGS_INTF_HOST_SOF_Msk = 0x4
	// Bit HOST_SOF.
	USBCTRL_REGS_INTF_HOST_SOF = 0x4
	// Position of HOST_RESUME field.
	USBCTRL_REGS_INTF_HOST_RESUME_Pos = 0x1
	// Bit mask of HOST_RESUME field.
	USBCTRL_REGS_INTF_HOST_RESUME_Msk = 0x2
	// Bit HOST_RESUME.
	USBCTRL_REGS_INTF_HOST_RESUME = 0x2
	// Position of HOST_CONN_DIS field.
	USBCTRL_REGS_INTF_HOST_CONN_DIS_Pos = 0x0
	// Bit mask of HOST_CONN_DIS field.
	USBCTRL_REGS_INTF_HOST_CONN_DIS_Msk = 0x1
	// Bit HOST_CONN_DIS.
	USBCTRL_REGS_INTF_HOST_CONN_DIS = 0x1

	// INTS: Interrupt status after masking & forcing
	// Position of EP_STALL_NAK field.
	USBCTRL_REGS_INTS_EP_STALL_NAK_Pos = 0x13
	// Bit mask of EP_STALL_NAK field.
	USBCTRL_REGS_INTS_EP_STALL_NAK_Msk = 0x80000
	// Bit EP_STALL_NAK.
	USBCTRL_REGS_INTS_EP_STALL_NAK = 0x80000
	// Position of ABORT_DONE field.
	USBCTRL_REGS_INTS_ABORT_DONE_Pos = 0x12
	// Bit mask of ABORT_DONE field.
	USBCTRL_REGS_INTS_ABORT_DONE_Msk = 0x40000
	// Bit ABORT_DONE.
	USBCTRL_REGS_INTS_ABORT_DONE = 0x40000
	// Position of DEV_SOF field.
	USBCTRL_REGS_INTS_DEV_SOF_Pos = 0x11
	// Bit mask of DEV_SOF field.
	USBCTRL_REGS_INTS_DEV_SOF_Msk = 0x20000
	// Bit DEV_SOF.
	USBCTRL_REGS_INTS_DEV_SOF = 0x20000
	// Position of SETUP_REQ field.
	USBCTRL_REGS_INTS_SETUP_REQ_Pos = 0x10
	// Bit mask of SETUP_REQ field.
	USBCTRL_REGS_INTS_SETUP_REQ_Msk = 0x10000
	// Bit SETUP_REQ.
	USBCTRL_REGS_INTS_SETUP_REQ = 0x10000
	// Position of DEV_RESUME_FROM_HOST field.
	USBCTRL_REGS_INTS_DEV_RESUME_FROM_HOST_Pos = 0xf
	// Bit mask of DEV_RESUME_FROM_HOST field.
	USBCTRL_REGS_INTS_DEV_RESUME_FROM_HOST_Msk = 0x8000
	// Bit DEV_RESUME_FROM_HOST.
	USBCTRL_REGS_INTS_DEV_RESUME_FROM_HOST = 0x8000
	// Position of DEV_SUSPEND field.
	USBCTRL_REGS_INTS_DEV_SUSPEND_Pos = 0xe
	// Bit mask of DEV_SUSPEND field.
	USBCTRL_REGS_INTS_DEV_SUSPEND_Msk = 0x4000
	// Bit DEV_SUSPEND.
	USBCTRL_REGS_INTS_DEV_SUSPEND = 0x4000
	// Position of DEV_CONN_DIS field.
	USBCTRL_REGS_INTS_DEV_CONN_DIS_Pos = 0xd
	// Bit mask of DEV_CONN_DIS field.
	USBCTRL_REGS_INTS_DEV_CONN_DIS_Msk = 0x2000
	// Bit DEV_CONN_DIS.
	USBCTRL_REGS_INTS_DEV_CONN_DIS = 0x2000
	// Position of BUS_RESET field.
	USBCTRL_REGS_INTS_BUS_RESET_Pos = 0xc
	// Bit mask of BUS_RESET field.
	USBCTRL_REGS_INTS_BUS_RESET_Msk = 0x1000
	// Bit BUS_RESET.
	USBCTRL_REGS_INTS_BUS_RESET = 0x1000
	// Position of VBUS_DETECT field.
	USBCTRL_REGS_INTS_VBUS_DETECT_Pos = 0xb
	// Bit mask of VBUS_DETECT field.
	USBCTRL_REGS_INTS_VBUS_DETECT_Msk = 0x800
	// Bit VBUS_DETECT.
	USBCTRL_REGS_INTS_VBUS_DETECT = 0x800
	// Position of STALL field.
	USBCTRL_REGS_INTS_STALL_Pos = 0xa
	// Bit mask of STALL field.
	USBCTRL_REGS_INTS_STALL_Msk = 0x400
	// Bit STALL.
	USBCTRL_REGS_INTS_STALL = 0x400
	// Position of ERROR_CRC field.
	USBCTRL_REGS_INTS_ERROR_CRC_Pos = 0x9
	// Bit mask of ERROR_CRC field.
	USBCTRL_REGS_INTS_ERROR_CRC_Msk = 0x200
	// Bit ERROR_CRC.
	USBCTRL_REGS_INTS_ERROR_CRC = 0x200
	// Position of ERROR_BIT_STUFF field.
	USBCTRL_REGS_INTS_ERROR_BIT_STUFF_Pos = 0x8
	// Bit mask of ERROR_BIT_STUFF field.
	USBCTRL_REGS_INTS_ERROR_BIT_STUFF_Msk = 0x100
	// Bit ERROR_BIT_STUFF.
	USBCTRL_REGS_INTS_ERROR_BIT_STUFF = 0x100
	// Position of ERROR_RX_OVERFLOW field.
	USBCTRL_REGS_INTS_ERROR_RX_OVERFLOW_Pos = 0x7
	// Bit mask of ERROR_RX_OVERFLOW field.
	USBCTRL_REGS_INTS_ERROR_RX_OVERFLOW_Msk = 0x80
	// Bit ERROR_RX_OVERFLOW.
	USBCTRL_REGS_INTS_ERROR_RX_OVERFLOW = 0x80
	// Position of ERROR_RX_TIMEOUT field.
	USBCTRL_REGS_INTS_ERROR_RX_TIMEOUT_Pos = 0x6
	// Bit mask of ERROR_RX_TIMEOUT field.
	USBCTRL_REGS_INTS_ERROR_RX_TIMEOUT_Msk = 0x40
	// Bit ERROR_RX_TIMEOUT.
	USBCTRL_REGS_INTS_ERROR_RX_TIMEOUT = 0x40
	// Position of ERROR_DATA_SEQ field.
	USBCTRL_REGS_INTS_ERROR_DATA_SEQ_Pos = 0x5
	// Bit mask of ERROR_DATA_SEQ field.
	USBCTRL_REGS_INTS_ERROR_DATA_SEQ_Msk = 0x20
	// Bit ERROR_DATA_SEQ.
	USBCTRL_REGS_INTS_ERROR_DATA_SEQ = 0x20
	// Position of BUFF_STATUS field.
	USBCTRL_REGS_INTS_BUFF_STATUS_Pos = 0x4
	// Bit mask of BUFF_STATUS field.
	USBCTRL_REGS_INTS_BUFF_STATUS_Msk = 0x10
	// Bit BUFF_STATUS.
	USBCTRL_REGS_INTS_BUFF_STATUS = 0x10
	// Position of TRANS_COMPLETE field.
	USBCTRL_REGS_INTS_TRANS_COMPLETE_Pos = 0x3
	// Bit mask of TRANS_COMPLETE field.
	USBCTRL_REGS_INTS_TRANS_COMPLETE_Msk = 0x8
	// Bit TRANS_COMPLETE.
	USBCTRL_REGS_INTS_TRANS_COMPLETE = 0x8
	// Position of HOST_SOF field.
	USBCTRL_REGS_INTS_HOST_SOF_Pos = 0x2
	// Bit mask of HOST_SOF field.
	USBCTRL_REGS_INTS_HOST_SOF_Msk = 0x4
	// Bit HOST_SOF.
	USBCTRL_REGS_INTS_HOST_SOF = 0x4
	// Position of HOST_RESUME field.
	USBCTRL_REGS_INTS_HOST_RESUME_Pos = 0x1
	// Bit mask of HOST_RESUME field.
	USBCTRL_REGS_INTS_HOST_RESUME_Msk = 0x2
	// Bit HOST_RESUME.
	USBCTRL_REGS_INTS_HOST_RESUME = 0x2
	// Position of HOST_CONN_DIS field.
	USBCTRL_REGS_INTS_HOST_CONN_DIS_Pos = 0x0
	// Bit mask of HOST_CONN_DIS field.
	USBCTRL_REGS_INTS_HOST_CONN_DIS_Msk = 0x1
	// Bit HOST_CONN_DIS.
	USBCTRL_REGS_INTS_HOST_CONN_DIS = 0x1
)

// Constants for PIO0: Programmable IO block
const (
	// CTRL: PIO control register
	// Position of CLKDIV_RESTART field.
	PIO0_CTRL_CLKDIV_RESTART_Pos = 0x8
	// Bit mask of CLKDIV_RESTART field.
	PIO0_CTRL_CLKDIV_RESTART_Msk = 0xf00
	// Position of SM_RESTART field.
	PIO0_CTRL_SM_RESTART_Pos = 0x4
	// Bit mask of SM_RESTART field.
	PIO0_CTRL_SM_RESTART_Msk = 0xf0
	// Position of SM_ENABLE field.
	PIO0_CTRL_SM_ENABLE_Pos = 0x0
	// Bit mask of SM_ENABLE field.
	PIO0_CTRL_SM_ENABLE_Msk = 0xf

	// FSTAT: FIFO status register
	// Position of TXEMPTY field.
	PIO0_FSTAT_TXEMPTY_Pos = 0x18
	// Bit mask of TXEMPTY field.
	PIO0_FSTAT_TXEMPTY_Msk = 0xf000000
	// Position of TXFULL field.
	PIO0_FSTAT_TXFULL_Pos = 0x10
	// Bit mask of TXFULL field.
	PIO0_FSTAT_TXFULL_Msk = 0xf0000
	// Position of RXEMPTY field.
	PIO0_FSTAT_RXEMPTY_Pos = 0x8
	// Bit mask of RXEMPTY field.
	PIO0_FSTAT_RXEMPTY_Msk = 0xf00
	// Position of RXFULL field.
	PIO0_FSTAT_RXFULL_Pos = 0x0
	// Bit mask of RXFULL field.
	PIO0_FSTAT_RXFULL_Msk = 0xf

	// FDEBUG: FIFO debug register
	// Position of TXSTALL field.
	PIO0_FDEBUG_TXSTALL_Pos = 0x18
	// Bit mask of TXSTALL field.
	PIO0_FDEBUG_TXSTALL_Msk = 0xf000000
	// Position of TXOVER field.
	PIO0_FDEBUG_TXOVER_Pos = 0x10
	// Bit mask of TXOVER field.
	PIO0_FDEBUG_TXOVER_Msk = 0xf0000
	// Position of RXUNDER field.
	PIO0_FDEBUG_RXUNDER_Pos = 0x8
	// Bit mask of RXUNDER field.
	PIO0_FDEBUG_RXUNDER_Msk = 0xf00
	// Position of RXSTALL field.
	PIO0_FDEBUG_RXSTALL_Pos = 0x0
	// Bit mask of RXSTALL field.
	PIO0_FDEBUG_RXSTALL_Msk = 0xf

	// FLEVEL: FIFO levels
	// Position of RX3 field.
	PIO0_FLEVEL_RX3_Pos = 0x1c
	// Bit mask of RX3 field.
	PIO0_FLEVEL_RX3_Msk = 0xf0000000
	// Position of TX3 field.
	PIO0_FLEVEL_TX3_Pos = 0x18
	// Bit mask of TX3 field.
	PIO0_FLEVEL_TX3_Msk = 0xf000000
	// Position of RX2 field.
	PIO0_FLEVEL_RX2_Pos = 0x14
	// Bit mask of RX2 field.
	PIO0_FLEVEL_RX2_Msk = 0xf00000
	// Position of TX2 field.
	PIO0_FLEVEL_TX2_Pos = 0x10
	// Bit mask of TX2 field.
	PIO0_FLEVEL_TX2_Msk = 0xf0000
	// Position of RX1 field.
	PIO0_FLEVEL_RX1_Pos = 0xc
	// Bit mask of RX1 field.
	PIO0_FLEVEL_RX1_Msk = 0xf000
	// Position of TX1 field.
	PIO0_FLEVEL_TX1_Pos = 0x8
	// Bit mask of TX1 field.
	PIO0_FLEVEL_TX1_Msk = 0xf00
	// Position of RX0 field.
	PIO0_FLEVEL_RX0_Pos = 0x4
	// Bit mask of RX0 field.
	PIO0_FLEVEL_RX0_Msk = 0xf0
	// Position of TX0 field.
	PIO0_FLEVEL_TX0_Pos = 0x0
	// Bit mask of TX0 field.
	PIO0_FLEVEL_TX0_Msk = 0xf

	// IRQ: Interrupt request register. Write 1 to clear
	// Position of IRQ field.
	PIO0_IRQ_IRQ_Pos = 0x0
	// Bit mask of IRQ field.
	PIO0_IRQ_IRQ_Msk = 0xff

	// IRQ_FORCE
	// Writing a 1 to each of these bits will forcibly assert the corresponding IRQ.
	// Note this is different to the INTF register: writing here affects PIO internal
	// state. INTF just asserts the processor-facing IRQ signal for testing ISRs,
	// and is not visible to the state machines.
	// Position of IRQ_FORCE field.
	PIO0_IRQ_FORCE_IRQ_FORCE_Pos = 0x0
	// Bit mask of IRQ_FORCE field.
	PIO0_IRQ_FORCE_IRQ_FORCE_Msk = 0xff

	// DBG_CFGINFO
	// The PIO hardware has some free parameters that may vary between chip products.
	// These should be provided in the chip datasheet, but are also exposed here.
	// Position of IMEM_SIZE field.
	PIO0_DBG_CFGINFO_IMEM_SIZE_Pos = 0x10
	// Bit mask of IMEM_SIZE field.
	PIO0_DBG_CFGINFO_IMEM_SIZE_Msk = 0x3f0000
	// Position of SM_COUNT field.
	PIO0_DBG_CFGINFO_SM_COUNT_Pos = 0x8
	// Bit mask of SM_COUNT field.
	PIO0_DBG_CFGINFO_SM_COUNT_Msk = 0xf00
	// Position of FIFO_DEPTH field.
	PIO0_DBG_CFGINFO_FIFO_DEPTH_Pos = 0x0
	// Bit mask of FIFO_DEPTH field.
	PIO0_DBG_CFGINFO_FIFO_DEPTH_Msk = 0x3f

	// INSTR_MEM0: Write-only access to instruction memory location 0
	// Position of INSTR_MEM0 field.
	PIO0_INSTR_MEM0_INSTR_MEM0_Pos = 0x0
	// Bit mask of INSTR_MEM0 field.
	PIO0_INSTR_MEM0_INSTR_MEM0_Msk = 0xffff

	// INSTR_MEM1: Write-only access to instruction memory location 1
	// Position of INSTR_MEM1 field.
	PIO0_INSTR_MEM1_INSTR_MEM1_Pos = 0x0
	// Bit mask of INSTR_MEM1 field.
	PIO0_INSTR_MEM1_INSTR_MEM1_Msk = 0xffff

	// INSTR_MEM2: Write-only access to instruction memory location 2
	// Position of INSTR_MEM2 field.
	PIO0_INSTR_MEM2_INSTR_MEM2_Pos = 0x0
	// Bit mask of INSTR_MEM2 field.
	PIO0_INSTR_MEM2_INSTR_MEM2_Msk = 0xffff

	// INSTR_MEM3: Write-only access to instruction memory location 3
	// Position of INSTR_MEM3 field.
	PIO0_INSTR_MEM3_INSTR_MEM3_Pos = 0x0
	// Bit mask of INSTR_MEM3 field.
	PIO0_INSTR_MEM3_INSTR_MEM3_Msk = 0xffff

	// INSTR_MEM4: Write-only access to instruction memory location 4
	// Position of INSTR_MEM4 field.
	PIO0_INSTR_MEM4_INSTR_MEM4_Pos = 0x0
	// Bit mask of INSTR_MEM4 field.
	PIO0_INSTR_MEM4_INSTR_MEM4_Msk = 0xffff

	// INSTR_MEM5: Write-only access to instruction memory location 5
	// Position of INSTR_MEM5 field.
	PIO0_INSTR_MEM5_INSTR_MEM5_Pos = 0x0
	// Bit mask of INSTR_MEM5 field.
	PIO0_INSTR_MEM5_INSTR_MEM5_Msk = 0xffff

	// INSTR_MEM6: Write-only access to instruction memory location 6
	// Position of INSTR_MEM6 field.
	PIO0_INSTR_MEM6_INSTR_MEM6_Pos = 0x0
	// Bit mask of INSTR_MEM6 field.
	PIO0_INSTR_MEM6_INSTR_MEM6_Msk = 0xffff

	// INSTR_MEM7: Write-only access to instruction memory location 7
	// Position of INSTR_MEM7 field.
	PIO0_INSTR_MEM7_INSTR_MEM7_Pos = 0x0
	// Bit mask of INSTR_MEM7 field.
	PIO0_INSTR_MEM7_INSTR_MEM7_Msk = 0xffff

	// INSTR_MEM8: Write-only access to instruction memory location 8
	// Position of INSTR_MEM8 field.
	PIO0_INSTR_MEM8_INSTR_MEM8_Pos = 0x0
	// Bit mask of INSTR_MEM8 field.
	PIO0_INSTR_MEM8_INSTR_MEM8_Msk = 0xffff

	// INSTR_MEM9: Write-only access to instruction memory location 9
	// Position of INSTR_MEM9 field.
	PIO0_INSTR_MEM9_INSTR_MEM9_Pos = 0x0
	// Bit mask of INSTR_MEM9 field.
	PIO0_INSTR_MEM9_INSTR_MEM9_Msk = 0xffff

	// INSTR_MEM10: Write-only access to instruction memory location 10
	// Position of INSTR_MEM10 field.
	PIO0_INSTR_MEM10_INSTR_MEM10_Pos = 0x0
	// Bit mask of INSTR_MEM10 field.
	PIO0_INSTR_MEM10_INSTR_MEM10_Msk = 0xffff

	// INSTR_MEM11: Write-only access to instruction memory location 11
	// Position of INSTR_MEM11 field.
	PIO0_INSTR_MEM11_INSTR_MEM11_Pos = 0x0
	// Bit mask of INSTR_MEM11 field.
	PIO0_INSTR_MEM11_INSTR_MEM11_Msk = 0xffff

	// INSTR_MEM12: Write-only access to instruction memory location 12
	// Position of INSTR_MEM12 field.
	PIO0_INSTR_MEM12_INSTR_MEM12_Pos = 0x0
	// Bit mask of INSTR_MEM12 field.
	PIO0_INSTR_MEM12_INSTR_MEM12_Msk = 0xffff

	// INSTR_MEM13: Write-only access to instruction memory location 13
	// Position of INSTR_MEM13 field.
	PIO0_INSTR_MEM13_INSTR_MEM13_Pos = 0x0
	// Bit mask of INSTR_MEM13 field.
	PIO0_INSTR_MEM13_INSTR_MEM13_Msk = 0xffff

	// INSTR_MEM14: Write-only access to instruction memory location 14
	// Position of INSTR_MEM14 field.
	PIO0_INSTR_MEM14_INSTR_MEM14_Pos = 0x0
	// Bit mask of INSTR_MEM14 field.
	PIO0_INSTR_MEM14_INSTR_MEM14_Msk = 0xffff

	// INSTR_MEM15: Write-only access to instruction memory location 15
	// Position of INSTR_MEM15 field.
	PIO0_INSTR_MEM15_INSTR_MEM15_Pos = 0x0
	// Bit mask of INSTR_MEM15 field.
	PIO0_INSTR_MEM15_INSTR_MEM15_Msk = 0xffff

	// INSTR_MEM16: Write-only access to instruction memory location 16
	// Position of INSTR_MEM16 field.
	PIO0_INSTR_MEM16_INSTR_MEM16_Pos = 0x0
	// Bit mask of INSTR_MEM16 field.
	PIO0_INSTR_MEM16_INSTR_MEM16_Msk = 0xffff

	// INSTR_MEM17: Write-only access to instruction memory location 17
	// Position of INSTR_MEM17 field.
	PIO0_INSTR_MEM17_INSTR_MEM17_Pos = 0x0
	// Bit mask of INSTR_MEM17 field.
	PIO0_INSTR_MEM17_INSTR_MEM17_Msk = 0xffff

	// INSTR_MEM18: Write-only access to instruction memory location 18
	// Position of INSTR_MEM18 field.
	PIO0_INSTR_MEM18_INSTR_MEM18_Pos = 0x0
	// Bit mask of INSTR_MEM18 field.
	PIO0_INSTR_MEM18_INSTR_MEM18_Msk = 0xffff

	// INSTR_MEM19: Write-only access to instruction memory location 19
	// Position of INSTR_MEM19 field.
	PIO0_INSTR_MEM19_INSTR_MEM19_Pos = 0x0
	// Bit mask of INSTR_MEM19 field.
	PIO0_INSTR_MEM19_INSTR_MEM19_Msk = 0xffff

	// INSTR_MEM20: Write-only access to instruction memory location 20
	// Position of INSTR_MEM20 field.
	PIO0_INSTR_MEM20_INSTR_MEM20_Pos = 0x0
	// Bit mask of INSTR_MEM20 field.
	PIO0_INSTR_MEM20_INSTR_MEM20_Msk = 0xffff

	// INSTR_MEM21: Write-only access to instruction memory location 21
	// Position of INSTR_MEM21 field.
	PIO0_INSTR_MEM21_INSTR_MEM21_Pos = 0x0
	// Bit mask of INSTR_MEM21 field.
	PIO0_INSTR_MEM21_INSTR_MEM21_Msk = 0xffff

	// INSTR_MEM22: Write-only access to instruction memory location 22
	// Position of INSTR_MEM22 field.
	PIO0_INSTR_MEM22_INSTR_MEM22_Pos = 0x0
	// Bit mask of INSTR_MEM22 field.
	PIO0_INSTR_MEM22_INSTR_MEM22_Msk = 0xffff

	// INSTR_MEM23: Write-only access to instruction memory location 23
	// Position of INSTR_MEM23 field.
	PIO0_INSTR_MEM23_INSTR_MEM23_Pos = 0x0
	// Bit mask of INSTR_MEM23 field.
	PIO0_INSTR_MEM23_INSTR_MEM23_Msk = 0xffff

	// INSTR_MEM24: Write-only access to instruction memory location 24
	// Position of INSTR_MEM24 field.
	PIO0_INSTR_MEM24_INSTR_MEM24_Pos = 0x0
	// Bit mask of INSTR_MEM24 field.
	PIO0_INSTR_MEM24_INSTR_MEM24_Msk = 0xffff

	// INSTR_MEM25: Write-only access to instruction memory location 25
	// Position of INSTR_MEM25 field.
	PIO0_INSTR_MEM25_INSTR_MEM25_Pos = 0x0
	// Bit mask of INSTR_MEM25 field.
	PIO0_INSTR_MEM25_INSTR_MEM25_Msk = 0xffff

	// INSTR_MEM26: Write-only access to instruction memory location 26
	// Position of INSTR_MEM26 field.
	PIO0_INSTR_MEM26_INSTR_MEM26_Pos = 0x0
	// Bit mask of INSTR_MEM26 field.
	PIO0_INSTR_MEM26_INSTR_MEM26_Msk = 0xffff

	// INSTR_MEM27: Write-only access to instruction memory location 27
	// Position of INSTR_MEM27 field.
	PIO0_INSTR_MEM27_INSTR_MEM27_Pos = 0x0
	// Bit mask of INSTR_MEM27 field.
	PIO0_INSTR_MEM27_INSTR_MEM27_Msk = 0xffff

	// INSTR_MEM28: Write-only access to instruction memory location 28
	// Position of INSTR_MEM28 field.
	PIO0_INSTR_MEM28_INSTR_MEM28_Pos = 0x0
	// Bit mask of INSTR_MEM28 field.
	PIO0_INSTR_MEM28_INSTR_MEM28_Msk = 0xffff

	// INSTR_MEM29: Write-only access to instruction memory location 29
	// Position of INSTR_MEM29 field.
	PIO0_INSTR_MEM29_INSTR_MEM29_Pos = 0x0
	// Bit mask of INSTR_MEM29 field.
	PIO0_INSTR_MEM29_INSTR_MEM29_Msk = 0xffff

	// INSTR_MEM30: Write-only access to instruction memory location 30
	// Position of INSTR_MEM30 field.
	PIO0_INSTR_MEM30_INSTR_MEM30_Pos = 0x0
	// Bit mask of INSTR_MEM30 field.
	PIO0_INSTR_MEM30_INSTR_MEM30_Msk = 0xffff

	// INSTR_MEM31: Write-only access to instruction memory location 31
	// Position of INSTR_MEM31 field.
	PIO0_INSTR_MEM31_INSTR_MEM31_Pos = 0x0
	// Bit mask of INSTR_MEM31 field.
	PIO0_INSTR_MEM31_INSTR_MEM31_Msk = 0xffff

	// SM0_CLKDIV
	// Clock divider register for state machine 0
	// Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
	// Position of INT field.
	PIO0_SM0_CLKDIV_INT_Pos = 0x10
	// Bit mask of INT field.
	PIO0_SM0_CLKDIV_INT_Msk = 0xffff0000
	// Position of FRAC field.
	PIO0_SM0_CLKDIV_FRAC_Pos = 0x8
	// Bit mask of FRAC field.
	PIO0_SM0_CLKDIV_FRAC_Msk = 0xff00

	// SM0_EXECCTRL: Execution/behavioural settings for state machine 0
	// Position of EXEC_STALLED field.
	PIO0_SM0_EXECCTRL_EXEC_STALLED_Pos = 0x1f
	// Bit mask of EXEC_STALLED field.
	PIO0_SM0_EXECCTRL_EXEC_STALLED_Msk = 0x80000000
	// Bit EXEC_STALLED.
	PIO0_SM0_EXECCTRL_EXEC_STALLED = 0x80000000
	// Position of SIDE_EN field.
	PIO0_SM0_EXECCTRL_SIDE_EN_Pos = 0x1e
	// Bit mask of SIDE_EN field.
	PIO0_SM0_EXECCTRL_SIDE_EN_Msk = 0x40000000
	// Bit SIDE_EN.
	PIO0_SM0_EXECCTRL_SIDE_EN = 0x40000000
	// Position of SIDE_PINDIR field.
	PIO0_SM0_EXECCTRL_SIDE_PINDIR_Pos = 0x1d
	// Bit mask of SIDE_PINDIR field.
	PIO0_SM0_EXECCTRL_SIDE_PINDIR_Msk = 0x20000000
	// Bit SIDE_PINDIR.
	PIO0_SM0_EXECCTRL_SIDE_PINDIR = 0x20000000
	// Position of JMP_PIN field.
	PIO0_SM0_EXECCTRL_JMP_PIN_Pos = 0x18
	// Bit mask of JMP_PIN field.
	PIO0_SM0_EXECCTRL_JMP_PIN_Msk = 0x1f000000
	// Position of OUT_EN_SEL field.
	PIO0_SM0_EXECCTRL_OUT_EN_SEL_Pos = 0x13
	// Bit mask of OUT_EN_SEL field.
	PIO0_SM0_EXECCTRL_OUT_EN_SEL_Msk = 0xf80000
	// Position of INLINE_OUT_EN field.
	PIO0_SM0_EXECCTRL_INLINE_OUT_EN_Pos = 0x12
	// Bit mask of INLINE_OUT_EN field.
	PIO0_SM0_EXECCTRL_INLINE_OUT_EN_Msk = 0x40000
	// Bit INLINE_OUT_EN.
	PIO0_SM0_EXECCTRL_INLINE_OUT_EN = 0x40000
	// Position of OUT_STICKY field.
	PIO0_SM0_EXECCTRL_OUT_STICKY_Pos = 0x11
	// Bit mask of OUT_STICKY field.
	PIO0_SM0_EXECCTRL_OUT_STICKY_Msk = 0x20000
	// Bit OUT_STICKY.
	PIO0_SM0_EXECCTRL_OUT_STICKY = 0x20000
	// Position of WRAP_TOP field.
	PIO0_SM0_EXECCTRL_WRAP_TOP_Pos = 0xc
	// Bit mask of WRAP_TOP field.
	PIO0_SM0_EXECCTRL_WRAP_TOP_Msk = 0x1f000
	// Position of WRAP_BOTTOM field.
	PIO0_SM0_EXECCTRL_WRAP_BOTTOM_Pos = 0x7
	// Bit mask of WRAP_BOTTOM field.
	PIO0_SM0_EXECCTRL_WRAP_BOTTOM_Msk = 0xf80
	// Position of STATUS_SEL field.
	PIO0_SM0_EXECCTRL_STATUS_SEL_Pos = 0x4
	// Bit mask of STATUS_SEL field.
	PIO0_SM0_EXECCTRL_STATUS_SEL_Msk = 0x10
	// Bit STATUS_SEL.
	PIO0_SM0_EXECCTRL_STATUS_SEL = 0x10
	// All-ones if TX FIFO level < N, otherwise all-zeroes
	PIO0_SM0_EXECCTRL_STATUS_SEL_TXLEVEL = 0x0
	// All-ones if RX FIFO level < N, otherwise all-zeroes
	PIO0_SM0_EXECCTRL_STATUS_SEL_RXLEVEL = 0x1
	// Position of STATUS_N field.
	PIO0_SM0_EXECCTRL_STATUS_N_Pos = 0x0
	// Bit mask of STATUS_N field.
	PIO0_SM0_EXECCTRL_STATUS_N_Msk = 0xf

	// SM0_SHIFTCTRL: Control behaviour of the input/output shift registers for state machine 0
	// Position of FJOIN_RX field.
	PIO0_SM0_SHIFTCTRL_FJOIN_RX_Pos = 0x1f
	// Bit mask of FJOIN_RX field.
	PIO0_SM0_SHIFTCTRL_FJOIN_RX_Msk = 0x80000000
	// Bit FJOIN_RX.
	PIO0_SM0_SHIFTCTRL_FJOIN_RX = 0x80000000
	// Position of FJOIN_TX field.
	PIO0_SM0_SHIFTCTRL_FJOIN_TX_Pos = 0x1e
	// Bit mask of FJOIN_TX field.
	PIO0_SM0_SHIFTCTRL_FJOIN_TX_Msk = 0x40000000
	// Bit FJOIN_TX.
	PIO0_SM0_SHIFTCTRL_FJOIN_TX = 0x40000000
	// Position of PULL_THRESH field.
	PIO0_SM0_SHIFTCTRL_PULL_THRESH_Pos = 0x19
	// Bit mask of PULL_THRESH field.
	PIO0_SM0_SHIFTCTRL_PULL_THRESH_Msk = 0x3e000000
	// Position of PUSH_THRESH field.
	PIO0_SM0_SHIFTCTRL_PUSH_THRESH_Pos = 0x14
	// Bit mask of PUSH_THRESH field.
	PIO0_SM0_SHIFTCTRL_PUSH_THRESH_Msk = 0x1f00000
	// Position of OUT_SHIFTDIR field.
	PIO0_SM0_SHIFTCTRL_OUT_SHIFTDIR_Pos = 0x13
	// Bit mask of OUT_SHIFTDIR field.
	PIO0_SM0_SHIFTCTRL_OUT_SHIFTDIR_Msk = 0x80000
	// Bit OUT_SHIFTDIR.
	PIO0_SM0_SHIFTCTRL_OUT_SHIFTDIR = 0x80000
	// Position of IN_SHIFTDIR field.
	PIO0_SM0_SHIFTCTRL_IN_SHIFTDIR_Pos = 0x12
	// Bit mask of IN_SHIFTDIR field.
	PIO0_SM0_SHIFTCTRL_IN_SHIFTDIR_Msk = 0x40000
	// Bit IN_SHIFTDIR.
	PIO0_SM0_SHIFTCTRL_IN_SHIFTDIR = 0x40000
	// Position of AUTOPULL field.
	PIO0_SM0_SHIFTCTRL_AUTOPULL_Pos = 0x11
	// Bit mask of AUTOPULL field.
	PIO0_SM0_SHIFTCTRL_AUTOPULL_Msk = 0x20000
	// Bit AUTOPULL.
	PIO0_SM0_SHIFTCTRL_AUTOPULL = 0x20000
	// Position of AUTOPUSH field.
	PIO0_SM0_SHIFTCTRL_AUTOPUSH_Pos = 0x10
	// Bit mask of AUTOPUSH field.
	PIO0_SM0_SHIFTCTRL_AUTOPUSH_Msk = 0x10000
	// Bit AUTOPUSH.
	PIO0_SM0_SHIFTCTRL_AUTOPUSH = 0x10000

	// SM0_ADDR: Current instruction address of state machine 0
	// Position of SM0_ADDR field.
	PIO0_SM0_ADDR_SM0_ADDR_Pos = 0x0
	// Bit mask of SM0_ADDR field.
	PIO0_SM0_ADDR_SM0_ADDR_Msk = 0x1f

	// SM0_INSTR
	// Instruction currently being executed by state machine 0
	// Write to execute an instruction immediately (including jumps) and then resume execution.
	// Position of SM0_INSTR field.
	PIO0_SM0_INSTR_SM0_INSTR_Pos = 0x0
	// Bit mask of SM0_INSTR field.
	PIO0_SM0_INSTR_SM0_INSTR_Msk = 0xffff

	// SM0_PINCTRL: State machine pin control
	// Position of SIDESET_COUNT field.
	PIO0_SM0_PINCTRL_SIDESET_COUNT_Pos = 0x1d
	// Bit mask of SIDESET_COUNT field.
	PIO0_SM0_PINCTRL_SIDESET_COUNT_Msk = 0xe0000000
	// Position of SET_COUNT field.
	PIO0_SM0_PINCTRL_SET_COUNT_Pos = 0x1a
	// Bit mask of SET_COUNT field.
	PIO0_SM0_PINCTRL_SET_COUNT_Msk = 0x1c000000
	// Position of OUT_COUNT field.
	PIO0_SM0_PINCTRL_OUT_COUNT_Pos = 0x14
	// Bit mask of OUT_COUNT field.
	PIO0_SM0_PINCTRL_OUT_COUNT_Msk = 0x3f00000
	// Position of IN_BASE field.
	PIO0_SM0_PINCTRL_IN_BASE_Pos = 0xf
	// Bit mask of IN_BASE field.
	PIO0_SM0_PINCTRL_IN_BASE_Msk = 0xf8000
	// Position of SIDESET_BASE field.
	PIO0_SM0_PINCTRL_SIDESET_BASE_Pos = 0xa
	// Bit mask of SIDESET_BASE field.
	PIO0_SM0_PINCTRL_SIDESET_BASE_Msk = 0x7c00
	// Position of SET_BASE field.
	PIO0_SM0_PINCTRL_SET_BASE_Pos = 0x5
	// Bit mask of SET_BASE field.
	PIO0_SM0_PINCTRL_SET_BASE_Msk = 0x3e0
	// Position of OUT_BASE field.
	PIO0_SM0_PINCTRL_OUT_BASE_Pos = 0x0
	// Bit mask of OUT_BASE field.
	PIO0_SM0_PINCTRL_OUT_BASE_Msk = 0x1f

	// SM1_CLKDIV
	// Clock divider register for state machine 1
	// Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
	// Position of INT field.
	PIO0_SM1_CLKDIV_INT_Pos = 0x10
	// Bit mask of INT field.
	PIO0_SM1_CLKDIV_INT_Msk = 0xffff0000
	// Position of FRAC field.
	PIO0_SM1_CLKDIV_FRAC_Pos = 0x8
	// Bit mask of FRAC field.
	PIO0_SM1_CLKDIV_FRAC_Msk = 0xff00

	// SM1_EXECCTRL: Execution/behavioural settings for state machine 1
	// Position of EXEC_STALLED field.
	PIO0_SM1_EXECCTRL_EXEC_STALLED_Pos = 0x1f
	// Bit mask of EXEC_STALLED field.
	PIO0_SM1_EXECCTRL_EXEC_STALLED_Msk = 0x80000000
	// Bit EXEC_STALLED.
	PIO0_SM1_EXECCTRL_EXEC_STALLED = 0x80000000
	// Position of SIDE_EN field.
	PIO0_SM1_EXECCTRL_SIDE_EN_Pos = 0x1e
	// Bit mask of SIDE_EN field.
	PIO0_SM1_EXECCTRL_SIDE_EN_Msk = 0x40000000
	// Bit SIDE_EN.
	PIO0_SM1_EXECCTRL_SIDE_EN = 0x40000000
	// Position of SIDE_PINDIR field.
	PIO0_SM1_EXECCTRL_SIDE_PINDIR_Pos = 0x1d
	// Bit mask of SIDE_PINDIR field.
	PIO0_SM1_EXECCTRL_SIDE_PINDIR_Msk = 0x20000000
	// Bit SIDE_PINDIR.
	PIO0_SM1_EXECCTRL_SIDE_PINDIR = 0x20000000
	// Position of JMP_PIN field.
	PIO0_SM1_EXECCTRL_JMP_PIN_Pos = 0x18
	// Bit mask of JMP_PIN field.
	PIO0_SM1_EXECCTRL_JMP_PIN_Msk = 0x1f000000
	// Position of OUT_EN_SEL field.
	PIO0_SM1_EXECCTRL_OUT_EN_SEL_Pos = 0x13
	// Bit mask of OUT_EN_SEL field.
	PIO0_SM1_EXECCTRL_OUT_EN_SEL_Msk = 0xf80000
	// Position of INLINE_OUT_EN field.
	PIO0_SM1_EXECCTRL_INLINE_OUT_EN_Pos = 0x12
	// Bit mask of INLINE_OUT_EN field.
	PIO0_SM1_EXECCTRL_INLINE_OUT_EN_Msk = 0x40000
	// Bit INLINE_OUT_EN.
	PIO0_SM1_EXECCTRL_INLINE_OUT_EN = 0x40000
	// Position of OUT_STICKY field.
	PIO0_SM1_EXECCTRL_OUT_STICKY_Pos = 0x11
	// Bit mask of OUT_STICKY field.
	PIO0_SM1_EXECCTRL_OUT_STICKY_Msk = 0x20000
	// Bit OUT_STICKY.
	PIO0_SM1_EXECCTRL_OUT_STICKY = 0x20000
	// Position of WRAP_TOP field.
	PIO0_SM1_EXECCTRL_WRAP_TOP_Pos = 0xc
	// Bit mask of WRAP_TOP field.
	PIO0_SM1_EXECCTRL_WRAP_TOP_Msk = 0x1f000
	// Position of WRAP_BOTTOM field.
	PIO0_SM1_EXECCTRL_WRAP_BOTTOM_Pos = 0x7
	// Bit mask of WRAP_BOTTOM field.
	PIO0_SM1_EXECCTRL_WRAP_BOTTOM_Msk = 0xf80
	// Position of STATUS_SEL field.
	PIO0_SM1_EXECCTRL_STATUS_SEL_Pos = 0x4
	// Bit mask of STATUS_SEL field.
	PIO0_SM1_EXECCTRL_STATUS_SEL_Msk = 0x10
	// Bit STATUS_SEL.
	PIO0_SM1_EXECCTRL_STATUS_SEL = 0x10
	// All-ones if TX FIFO level < N, otherwise all-zeroes
	PIO0_SM1_EXECCTRL_STATUS_SEL_TXLEVEL = 0x0
	// All-ones if RX FIFO level < N, otherwise all-zeroes
	PIO0_SM1_EXECCTRL_STATUS_SEL_RXLEVEL = 0x1
	// Position of STATUS_N field.
	PIO0_SM1_EXECCTRL_STATUS_N_Pos = 0x0
	// Bit mask of STATUS_N field.
	PIO0_SM1_EXECCTRL_STATUS_N_Msk = 0xf

	// SM1_SHIFTCTRL: Control behaviour of the input/output shift registers for state machine 1
	// Position of FJOIN_RX field.
	PIO0_SM1_SHIFTCTRL_FJOIN_RX_Pos = 0x1f
	// Bit mask of FJOIN_RX field.
	PIO0_SM1_SHIFTCTRL_FJOIN_RX_Msk = 0x80000000
	// Bit FJOIN_RX.
	PIO0_SM1_SHIFTCTRL_FJOIN_RX = 0x80000000
	// Position of FJOIN_TX field.
	PIO0_SM1_SHIFTCTRL_FJOIN_TX_Pos = 0x1e
	// Bit mask of FJOIN_TX field.
	PIO0_SM1_SHIFTCTRL_FJOIN_TX_Msk = 0x40000000
	// Bit FJOIN_TX.
	PIO0_SM1_SHIFTCTRL_FJOIN_TX = 0x40000000
	// Position of PULL_THRESH field.
	PIO0_SM1_SHIFTCTRL_PULL_THRESH_Pos = 0x19
	// Bit mask of PULL_THRESH field.
	PIO0_SM1_SHIFTCTRL_PULL_THRESH_Msk = 0x3e000000
	// Position of PUSH_THRESH field.
	PIO0_SM1_SHIFTCTRL_PUSH_THRESH_Pos = 0x14
	// Bit mask of PUSH_THRESH field.
	PIO0_SM1_SHIFTCTRL_PUSH_THRESH_Msk = 0x1f00000
	// Position of OUT_SHIFTDIR field.
	PIO0_SM1_SHIFTCTRL_OUT_SHIFTDIR_Pos = 0x13
	// Bit mask of OUT_SHIFTDIR field.
	PIO0_SM1_SHIFTCTRL_OUT_SHIFTDIR_Msk = 0x80000
	// Bit OUT_SHIFTDIR.
	PIO0_SM1_SHIFTCTRL_OUT_SHIFTDIR = 0x80000
	// Position of IN_SHIFTDIR field.
	PIO0_SM1_SHIFTCTRL_IN_SHIFTDIR_Pos = 0x12
	// Bit mask of IN_SHIFTDIR field.
	PIO0_SM1_SHIFTCTRL_IN_SHIFTDIR_Msk = 0x40000
	// Bit IN_SHIFTDIR.
	PIO0_SM1_SHIFTCTRL_IN_SHIFTDIR = 0x40000
	// Position of AUTOPULL field.
	PIO0_SM1_SHIFTCTRL_AUTOPULL_Pos = 0x11
	// Bit mask of AUTOPULL field.
	PIO0_SM1_SHIFTCTRL_AUTOPULL_Msk = 0x20000
	// Bit AUTOPULL.
	PIO0_SM1_SHIFTCTRL_AUTOPULL = 0x20000
	// Position of AUTOPUSH field.
	PIO0_SM1_SHIFTCTRL_AUTOPUSH_Pos = 0x10
	// Bit mask of AUTOPUSH field.
	PIO0_SM1_SHIFTCTRL_AUTOPUSH_Msk = 0x10000
	// Bit AUTOPUSH.
	PIO0_SM1_SHIFTCTRL_AUTOPUSH = 0x10000

	// SM1_ADDR: Current instruction address of state machine 1
	// Position of SM1_ADDR field.
	PIO0_SM1_ADDR_SM1_ADDR_Pos = 0x0
	// Bit mask of SM1_ADDR field.
	PIO0_SM1_ADDR_SM1_ADDR_Msk = 0x1f

	// SM1_INSTR
	// Instruction currently being executed by state machine 1
	// Write to execute an instruction immediately (including jumps) and then resume execution.
	// Position of SM1_INSTR field.
	PIO0_SM1_INSTR_SM1_INSTR_Pos = 0x0
	// Bit mask of SM1_INSTR field.
	PIO0_SM1_INSTR_SM1_INSTR_Msk = 0xffff

	// SM1_PINCTRL: State machine pin control
	// Position of SIDESET_COUNT field.
	PIO0_SM1_PINCTRL_SIDESET_COUNT_Pos = 0x1d
	// Bit mask of SIDESET_COUNT field.
	PIO0_SM1_PINCTRL_SIDESET_COUNT_Msk = 0xe0000000
	// Position of SET_COUNT field.
	PIO0_SM1_PINCTRL_SET_COUNT_Pos = 0x1a
	// Bit mask of SET_COUNT field.
	PIO0_SM1_PINCTRL_SET_COUNT_Msk = 0x1c000000
	// Position of OUT_COUNT field.
	PIO0_SM1_PINCTRL_OUT_COUNT_Pos = 0x14
	// Bit mask of OUT_COUNT field.
	PIO0_SM1_PINCTRL_OUT_COUNT_Msk = 0x3f00000
	// Position of IN_BASE field.
	PIO0_SM1_PINCTRL_IN_BASE_Pos = 0xf
	// Bit mask of IN_BASE field.
	PIO0_SM1_PINCTRL_IN_BASE_Msk = 0xf8000
	// Position of SIDESET_BASE field.
	PIO0_SM1_PINCTRL_SIDESET_BASE_Pos = 0xa
	// Bit mask of SIDESET_BASE field.
	PIO0_SM1_PINCTRL_SIDESET_BASE_Msk = 0x7c00
	// Position of SET_BASE field.
	PIO0_SM1_PINCTRL_SET_BASE_Pos = 0x5
	// Bit mask of SET_BASE field.
	PIO0_SM1_PINCTRL_SET_BASE_Msk = 0x3e0
	// Position of OUT_BASE field.
	PIO0_SM1_PINCTRL_OUT_BASE_Pos = 0x0
	// Bit mask of OUT_BASE field.
	PIO0_SM1_PINCTRL_OUT_BASE_Msk = 0x1f

	// SM2_CLKDIV
	// Clock divider register for state machine 2
	// Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
	// Position of INT field.
	PIO0_SM2_CLKDIV_INT_Pos = 0x10
	// Bit mask of INT field.
	PIO0_SM2_CLKDIV_INT_Msk = 0xffff0000
	// Position of FRAC field.
	PIO0_SM2_CLKDIV_FRAC_Pos = 0x8
	// Bit mask of FRAC field.
	PIO0_SM2_CLKDIV_FRAC_Msk = 0xff00

	// SM2_EXECCTRL: Execution/behavioural settings for state machine 2
	// Position of EXEC_STALLED field.
	PIO0_SM2_EXECCTRL_EXEC_STALLED_Pos = 0x1f
	// Bit mask of EXEC_STALLED field.
	PIO0_SM2_EXECCTRL_EXEC_STALLED_Msk = 0x80000000
	// Bit EXEC_STALLED.
	PIO0_SM2_EXECCTRL_EXEC_STALLED = 0x80000000
	// Position of SIDE_EN field.
	PIO0_SM2_EXECCTRL_SIDE_EN_Pos = 0x1e
	// Bit mask of SIDE_EN field.
	PIO0_SM2_EXECCTRL_SIDE_EN_Msk = 0x40000000
	// Bit SIDE_EN.
	PIO0_SM2_EXECCTRL_SIDE_EN = 0x40000000
	// Position of SIDE_PINDIR field.
	PIO0_SM2_EXECCTRL_SIDE_PINDIR_Pos = 0x1d
	// Bit mask of SIDE_PINDIR field.
	PIO0_SM2_EXECCTRL_SIDE_PINDIR_Msk = 0x20000000
	// Bit SIDE_PINDIR.
	PIO0_SM2_EXECCTRL_SIDE_PINDIR = 0x20000000
	// Position of JMP_PIN field.
	PIO0_SM2_EXECCTRL_JMP_PIN_Pos = 0x18
	// Bit mask of JMP_PIN field.
	PIO0_SM2_EXECCTRL_JMP_PIN_Msk = 0x1f000000
	// Position of OUT_EN_SEL field.
	PIO0_SM2_EXECCTRL_OUT_EN_SEL_Pos = 0x13
	// Bit mask of OUT_EN_SEL field.
	PIO0_SM2_EXECCTRL_OUT_EN_SEL_Msk = 0xf80000
	// Position of INLINE_OUT_EN field.
	PIO0_SM2_EXECCTRL_INLINE_OUT_EN_Pos = 0x12
	// Bit mask of INLINE_OUT_EN field.
	PIO0_SM2_EXECCTRL_INLINE_OUT_EN_Msk = 0x40000
	// Bit INLINE_OUT_EN.
	PIO0_SM2_EXECCTRL_INLINE_OUT_EN = 0x40000
	// Position of OUT_STICKY field.
	PIO0_SM2_EXECCTRL_OUT_STICKY_Pos = 0x11
	// Bit mask of OUT_STICKY field.
	PIO0_SM2_EXECCTRL_OUT_STICKY_Msk = 0x20000
	// Bit OUT_STICKY.
	PIO0_SM2_EXECCTRL_OUT_STICKY = 0x20000
	// Position of WRAP_TOP field.
	PIO0_SM2_EXECCTRL_WRAP_TOP_Pos = 0xc
	// Bit mask of WRAP_TOP field.
	PIO0_SM2_EXECCTRL_WRAP_TOP_Msk = 0x1f000
	// Position of WRAP_BOTTOM field.
	PIO0_SM2_EXECCTRL_WRAP_BOTTOM_Pos = 0x7
	// Bit mask of WRAP_BOTTOM field.
	PIO0_SM2_EXECCTRL_WRAP_BOTTOM_Msk = 0xf80
	// Position of STATUS_SEL field.
	PIO0_SM2_EXECCTRL_STATUS_SEL_Pos = 0x4
	// Bit mask of STATUS_SEL field.
	PIO0_SM2_EXECCTRL_STATUS_SEL_Msk = 0x10
	// Bit STATUS_SEL.
	PIO0_SM2_EXECCTRL_STATUS_SEL = 0x10
	// All-ones if TX FIFO level < N, otherwise all-zeroes
	PIO0_SM2_EXECCTRL_STATUS_SEL_TXLEVEL = 0x0
	// All-ones if RX FIFO level < N, otherwise all-zeroes
	PIO0_SM2_EXECCTRL_STATUS_SEL_RXLEVEL = 0x1
	// Position of STATUS_N field.
	PIO0_SM2_EXECCTRL_STATUS_N_Pos = 0x0
	// Bit mask of STATUS_N field.
	PIO0_SM2_EXECCTRL_STATUS_N_Msk = 0xf

	// SM2_SHIFTCTRL: Control behaviour of the input/output shift registers for state machine 2
	// Position of FJOIN_RX field.
	PIO0_SM2_SHIFTCTRL_FJOIN_RX_Pos = 0x1f
	// Bit mask of FJOIN_RX field.
	PIO0_SM2_SHIFTCTRL_FJOIN_RX_Msk = 0x80000000
	// Bit FJOIN_RX.
	PIO0_SM2_SHIFTCTRL_FJOIN_RX = 0x80000000
	// Position of FJOIN_TX field.
	PIO0_SM2_SHIFTCTRL_FJOIN_TX_Pos = 0x1e
	// Bit mask of FJOIN_TX field.
	PIO0_SM2_SHIFTCTRL_FJOIN_TX_Msk = 0x40000000
	// Bit FJOIN_TX.
	PIO0_SM2_SHIFTCTRL_FJOIN_TX = 0x40000000
	// Position of PULL_THRESH field.
	PIO0_SM2_SHIFTCTRL_PULL_THRESH_Pos = 0x19
	// Bit mask of PULL_THRESH field.
	PIO0_SM2_SHIFTCTRL_PULL_THRESH_Msk = 0x3e000000
	// Position of PUSH_THRESH field.
	PIO0_SM2_SHIFTCTRL_PUSH_THRESH_Pos = 0x14
	// Bit mask of PUSH_THRESH field.
	PIO0_SM2_SHIFTCTRL_PUSH_THRESH_Msk = 0x1f00000
	// Position of OUT_SHIFTDIR field.
	PIO0_SM2_SHIFTCTRL_OUT_SHIFTDIR_Pos = 0x13
	// Bit mask of OUT_SHIFTDIR field.
	PIO0_SM2_SHIFTCTRL_OUT_SHIFTDIR_Msk = 0x80000
	// Bit OUT_SHIFTDIR.
	PIO0_SM2_SHIFTCTRL_OUT_SHIFTDIR = 0x80000
	// Position of IN_SHIFTDIR field.
	PIO0_SM2_SHIFTCTRL_IN_SHIFTDIR_Pos = 0x12
	// Bit mask of IN_SHIFTDIR field.
	PIO0_SM2_SHIFTCTRL_IN_SHIFTDIR_Msk = 0x40000
	// Bit IN_SHIFTDIR.
	PIO0_SM2_SHIFTCTRL_IN_SHIFTDIR = 0x40000
	// Position of AUTOPULL field.
	PIO0_SM2_SHIFTCTRL_AUTOPULL_Pos = 0x11
	// Bit mask of AUTOPULL field.
	PIO0_SM2_SHIFTCTRL_AUTOPULL_Msk = 0x20000
	// Bit AUTOPULL.
	PIO0_SM2_SHIFTCTRL_AUTOPULL = 0x20000
	// Position of AUTOPUSH field.
	PIO0_SM2_SHIFTCTRL_AUTOPUSH_Pos = 0x10
	// Bit mask of AUTOPUSH field.
	PIO0_SM2_SHIFTCTRL_AUTOPUSH_Msk = 0x10000
	// Bit AUTOPUSH.
	PIO0_SM2_SHIFTCTRL_AUTOPUSH = 0x10000

	// SM2_ADDR: Current instruction address of state machine 2
	// Position of SM2_ADDR field.
	PIO0_SM2_ADDR_SM2_ADDR_Pos = 0x0
	// Bit mask of SM2_ADDR field.
	PIO0_SM2_ADDR_SM2_ADDR_Msk = 0x1f

	// SM2_INSTR
	// Instruction currently being executed by state machine 2
	// Write to execute an instruction immediately (including jumps) and then resume execution.
	// Position of SM2_INSTR field.
	PIO0_SM2_INSTR_SM2_INSTR_Pos = 0x0
	// Bit mask of SM2_INSTR field.
	PIO0_SM2_INSTR_SM2_INSTR_Msk = 0xffff

	// SM2_PINCTRL: State machine pin control
	// Position of SIDESET_COUNT field.
	PIO0_SM2_PINCTRL_SIDESET_COUNT_Pos = 0x1d
	// Bit mask of SIDESET_COUNT field.
	PIO0_SM2_PINCTRL_SIDESET_COUNT_Msk = 0xe0000000
	// Position of SET_COUNT field.
	PIO0_SM2_PINCTRL_SET_COUNT_Pos = 0x1a
	// Bit mask of SET_COUNT field.
	PIO0_SM2_PINCTRL_SET_COUNT_Msk = 0x1c000000
	// Position of OUT_COUNT field.
	PIO0_SM2_PINCTRL_OUT_COUNT_Pos = 0x14
	// Bit mask of OUT_COUNT field.
	PIO0_SM2_PINCTRL_OUT_COUNT_Msk = 0x3f00000
	// Position of IN_BASE field.
	PIO0_SM2_PINCTRL_IN_BASE_Pos = 0xf
	// Bit mask of IN_BASE field.
	PIO0_SM2_PINCTRL_IN_BASE_Msk = 0xf8000
	// Position of SIDESET_BASE field.
	PIO0_SM2_PINCTRL_SIDESET_BASE_Pos = 0xa
	// Bit mask of SIDESET_BASE field.
	PIO0_SM2_PINCTRL_SIDESET_BASE_Msk = 0x7c00
	// Position of SET_BASE field.
	PIO0_SM2_PINCTRL_SET_BASE_Pos = 0x5
	// Bit mask of SET_BASE field.
	PIO0_SM2_PINCTRL_SET_BASE_Msk = 0x3e0
	// Position of OUT_BASE field.
	PIO0_SM2_PINCTRL_OUT_BASE_Pos = 0x0
	// Bit mask of OUT_BASE field.
	PIO0_SM2_PINCTRL_OUT_BASE_Msk = 0x1f

	// SM3_CLKDIV
	// Clock divider register for state machine 3
	// Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
	// Position of INT field.
	PIO0_SM3_CLKDIV_INT_Pos = 0x10
	// Bit mask of INT field.
	PIO0_SM3_CLKDIV_INT_Msk = 0xffff0000
	// Position of FRAC field.
	PIO0_SM3_CLKDIV_FRAC_Pos = 0x8
	// Bit mask of FRAC field.
	PIO0_SM3_CLKDIV_FRAC_Msk = 0xff00

	// SM3_EXECCTRL: Execution/behavioural settings for state machine 3
	// Position of EXEC_STALLED field.
	PIO0_SM3_EXECCTRL_EXEC_STALLED_Pos = 0x1f
	// Bit mask of EXEC_STALLED field.
	PIO0_SM3_EXECCTRL_EXEC_STALLED_Msk = 0x80000000
	// Bit EXEC_STALLED.
	PIO0_SM3_EXECCTRL_EXEC_STALLED = 0x80000000
	// Position of SIDE_EN field.
	PIO0_SM3_EXECCTRL_SIDE_EN_Pos = 0x1e
	// Bit mask of SIDE_EN field.
	PIO0_SM3_EXECCTRL_SIDE_EN_Msk = 0x40000000
	// Bit SIDE_EN.
	PIO0_SM3_EXECCTRL_SIDE_EN = 0x40000000
	// Position of SIDE_PINDIR field.
	PIO0_SM3_EXECCTRL_SIDE_PINDIR_Pos = 0x1d
	// Bit mask of SIDE_PINDIR field.
	PIO0_SM3_EXECCTRL_SIDE_PINDIR_Msk = 0x20000000
	// Bit SIDE_PINDIR.
	PIO0_SM3_EXECCTRL_SIDE_PINDIR = 0x20000000
	// Position of JMP_PIN field.
	PIO0_SM3_EXECCTRL_JMP_PIN_Pos = 0x18
	// Bit mask of JMP_PIN field.
	PIO0_SM3_EXECCTRL_JMP_PIN_Msk = 0x1f000000
	// Position of OUT_EN_SEL field.
	PIO0_SM3_EXECCTRL_OUT_EN_SEL_Pos = 0x13
	// Bit mask of OUT_EN_SEL field.
	PIO0_SM3_EXECCTRL_OUT_EN_SEL_Msk = 0xf80000
	// Position of INLINE_OUT_EN field.
	PIO0_SM3_EXECCTRL_INLINE_OUT_EN_Pos = 0x12
	// Bit mask of INLINE_OUT_EN field.
	PIO0_SM3_EXECCTRL_INLINE_OUT_EN_Msk = 0x40000
	// Bit INLINE_OUT_EN.
	PIO0_SM3_EXECCTRL_INLINE_OUT_EN = 0x40000
	// Position of OUT_STICKY field.
	PIO0_SM3_EXECCTRL_OUT_STICKY_Pos = 0x11
	// Bit mask of OUT_STICKY field.
	PIO0_SM3_EXECCTRL_OUT_STICKY_Msk = 0x20000
	// Bit OUT_STICKY.
	PIO0_SM3_EXECCTRL_OUT_STICKY = 0x20000
	// Position of WRAP_TOP field.
	PIO0_SM3_EXECCTRL_WRAP_TOP_Pos = 0xc
	// Bit mask of WRAP_TOP field.
	PIO0_SM3_EXECCTRL_WRAP_TOP_Msk = 0x1f000
	// Position of WRAP_BOTTOM field.
	PIO0_SM3_EXECCTRL_WRAP_BOTTOM_Pos = 0x7
	// Bit mask of WRAP_BOTTOM field.
	PIO0_SM3_EXECCTRL_WRAP_BOTTOM_Msk = 0xf80
	// Position of STATUS_SEL field.
	PIO0_SM3_EXECCTRL_STATUS_SEL_Pos = 0x4
	// Bit mask of STATUS_SEL field.
	PIO0_SM3_EXECCTRL_STATUS_SEL_Msk = 0x10
	// Bit STATUS_SEL.
	PIO0_SM3_EXECCTRL_STATUS_SEL = 0x10
	// All-ones if TX FIFO level < N, otherwise all-zeroes
	PIO0_SM3_EXECCTRL_STATUS_SEL_TXLEVEL = 0x0
	// All-ones if RX FIFO level < N, otherwise all-zeroes
	PIO0_SM3_EXECCTRL_STATUS_SEL_RXLEVEL = 0x1
	// Position of STATUS_N field.
	PIO0_SM3_EXECCTRL_STATUS_N_Pos = 0x0
	// Bit mask of STATUS_N field.
	PIO0_SM3_EXECCTRL_STATUS_N_Msk = 0xf

	// SM3_SHIFTCTRL: Control behaviour of the input/output shift registers for state machine 3
	// Position of FJOIN_RX field.
	PIO0_SM3_SHIFTCTRL_FJOIN_RX_Pos = 0x1f
	// Bit mask of FJOIN_RX field.
	PIO0_SM3_SHIFTCTRL_FJOIN_RX_Msk = 0x80000000
	// Bit FJOIN_RX.
	PIO0_SM3_SHIFTCTRL_FJOIN_RX = 0x80000000
	// Position of FJOIN_TX field.
	PIO0_SM3_SHIFTCTRL_FJOIN_TX_Pos = 0x1e
	// Bit mask of FJOIN_TX field.
	PIO0_SM3_SHIFTCTRL_FJOIN_TX_Msk = 0x40000000
	// Bit FJOIN_TX.
	PIO0_SM3_SHIFTCTRL_FJOIN_TX = 0x40000000
	// Position of PULL_THRESH field.
	PIO0_SM3_SHIFTCTRL_PULL_THRESH_Pos = 0x19
	// Bit mask of PULL_THRESH field.
	PIO0_SM3_SHIFTCTRL_PULL_THRESH_Msk = 0x3e000000
	// Position of PUSH_THRESH field.
	PIO0_SM3_SHIFTCTRL_PUSH_THRESH_Pos = 0x14
	// Bit mask of PUSH_THRESH field.
	PIO0_SM3_SHIFTCTRL_PUSH_THRESH_Msk = 0x1f00000
	// Position of OUT_SHIFTDIR field.
	PIO0_SM3_SHIFTCTRL_OUT_SHIFTDIR_Pos = 0x13
	// Bit mask of OUT_SHIFTDIR field.
	PIO0_SM3_SHIFTCTRL_OUT_SHIFTDIR_Msk = 0x80000
	// Bit OUT_SHIFTDIR.
	PIO0_SM3_SHIFTCTRL_OUT_SHIFTDIR = 0x80000
	// Position of IN_SHIFTDIR field.
	PIO0_SM3_SHIFTCTRL_IN_SHIFTDIR_Pos = 0x12
	// Bit mask of IN_SHIFTDIR field.
	PIO0_SM3_SHIFTCTRL_IN_SHIFTDIR_Msk = 0x40000
	// Bit IN_SHIFTDIR.
	PIO0_SM3_SHIFTCTRL_IN_SHIFTDIR = 0x40000
	// Position of AUTOPULL field.
	PIO0_SM3_SHIFTCTRL_AUTOPULL_Pos = 0x11
	// Bit mask of AUTOPULL field.
	PIO0_SM3_SHIFTCTRL_AUTOPULL_Msk = 0x20000
	// Bit AUTOPULL.
	PIO0_SM3_SHIFTCTRL_AUTOPULL = 0x20000
	// Position of AUTOPUSH field.
	PIO0_SM3_SHIFTCTRL_AUTOPUSH_Pos = 0x10
	// Bit mask of AUTOPUSH field.
	PIO0_SM3_SHIFTCTRL_AUTOPUSH_Msk = 0x10000
	// Bit AUTOPUSH.
	PIO0_SM3_SHIFTCTRL_AUTOPUSH = 0x10000

	// SM3_ADDR: Current instruction address of state machine 3
	// Position of SM3_ADDR field.
	PIO0_SM3_ADDR_SM3_ADDR_Pos = 0x0
	// Bit mask of SM3_ADDR field.
	PIO0_SM3_ADDR_SM3_ADDR_Msk = 0x1f

	// SM3_INSTR
	// Instruction currently being executed by state machine 3
	// Write to execute an instruction immediately (including jumps) and then resume execution.
	// Position of SM3_INSTR field.
	PIO0_SM3_INSTR_SM3_INSTR_Pos = 0x0
	// Bit mask of SM3_INSTR field.
	PIO0_SM3_INSTR_SM3_INSTR_Msk = 0xffff

	// SM3_PINCTRL: State machine pin control
	// Position of SIDESET_COUNT field.
	PIO0_SM3_PINCTRL_SIDESET_COUNT_Pos = 0x1d
	// Bit mask of SIDESET_COUNT field.
	PIO0_SM3_PINCTRL_SIDESET_COUNT_Msk = 0xe0000000
	// Position of SET_COUNT field.
	PIO0_SM3_PINCTRL_SET_COUNT_Pos = 0x1a
	// Bit mask of SET_COUNT field.
	PIO0_SM3_PINCTRL_SET_COUNT_Msk = 0x1c000000
	// Position of OUT_COUNT field.
	PIO0_SM3_PINCTRL_OUT_COUNT_Pos = 0x14
	// Bit mask of OUT_COUNT field.
	PIO0_SM3_PINCTRL_OUT_COUNT_Msk = 0x3f00000
	// Position of IN_BASE field.
	PIO0_SM3_PINCTRL_IN_BASE_Pos = 0xf
	// Bit mask of IN_BASE field.
	PIO0_SM3_PINCTRL_IN_BASE_Msk = 0xf8000
	// Position of SIDESET_BASE field.
	PIO0_SM3_PINCTRL_SIDESET_BASE_Pos = 0xa
	// Bit mask of SIDESET_BASE field.
	PIO0_SM3_PINCTRL_SIDESET_BASE_Msk = 0x7c00
	// Position of SET_BASE field.
	PIO0_SM3_PINCTRL_SET_BASE_Pos = 0x5
	// Bit mask of SET_BASE field.
	PIO0_SM3_PINCTRL_SET_BASE_Msk = 0x3e0
	// Position of OUT_BASE field.
	PIO0_SM3_PINCTRL_OUT_BASE_Pos = 0x0
	// Bit mask of OUT_BASE field.
	PIO0_SM3_PINCTRL_OUT_BASE_Msk = 0x1f

	// INTR: Raw Interrupts
	// Position of SM3 field.
	PIO0_INTR_SM3_Pos = 0xb
	// Bit mask of SM3 field.
	PIO0_INTR_SM3_Msk = 0x800
	// Bit SM3.
	PIO0_INTR_SM3 = 0x800
	// Position of SM2 field.
	PIO0_INTR_SM2_Pos = 0xa
	// Bit mask of SM2 field.
	PIO0_INTR_SM2_Msk = 0x400
	// Bit SM2.
	PIO0_INTR_SM2 = 0x400
	// Position of SM1 field.
	PIO0_INTR_SM1_Pos = 0x9
	// Bit mask of SM1 field.
	PIO0_INTR_SM1_Msk = 0x200
	// Bit SM1.
	PIO0_INTR_SM1 = 0x200
	// Position of SM0 field.
	PIO0_INTR_SM0_Pos = 0x8
	// Bit mask of SM0 field.
	PIO0_INTR_SM0_Msk = 0x100
	// Bit SM0.
	PIO0_INTR_SM0 = 0x100
	// Position of SM3_TXNFULL field.
	PIO0_INTR_SM3_TXNFULL_Pos = 0x7
	// Bit mask of SM3_TXNFULL field.
	PIO0_INTR_SM3_TXNFULL_Msk = 0x80
	// Bit SM3_TXNFULL.
	PIO0_INTR_SM3_TXNFULL = 0x80
	// Position of SM2_TXNFULL field.
	PIO0_INTR_SM2_TXNFULL_Pos = 0x6
	// Bit mask of SM2_TXNFULL field.
	PIO0_INTR_SM2_TXNFULL_Msk = 0x40
	// Bit SM2_TXNFULL.
	PIO0_INTR_SM2_TXNFULL = 0x40
	// Position of SM1_TXNFULL field.
	PIO0_INTR_SM1_TXNFULL_Pos = 0x5
	// Bit mask of SM1_TXNFULL field.
	PIO0_INTR_SM1_TXNFULL_Msk = 0x20
	// Bit SM1_TXNFULL.
	PIO0_INTR_SM1_TXNFULL = 0x20
	// Position of SM0_TXNFULL field.
	PIO0_INTR_SM0_TXNFULL_Pos = 0x4
	// Bit mask of SM0_TXNFULL field.
	PIO0_INTR_SM0_TXNFULL_Msk = 0x10
	// Bit SM0_TXNFULL.
	PIO0_INTR_SM0_TXNFULL = 0x10
	// Position of SM3_RXNEMPTY field.
	PIO0_INTR_SM3_RXNEMPTY_Pos = 0x3
	// Bit mask of SM3_RXNEMPTY field.
	PIO0_INTR_SM3_RXNEMPTY_Msk = 0x8
	// Bit SM3_RXNEMPTY.
	PIO0_INTR_SM3_RXNEMPTY = 0x8
	// Position of SM2_RXNEMPTY field.
	PIO0_INTR_SM2_RXNEMPTY_Pos = 0x2
	// Bit mask of SM2_RXNEMPTY field.
	PIO0_INTR_SM2_RXNEMPTY_Msk = 0x4
	// Bit SM2_RXNEMPTY.
	PIO0_INTR_SM2_RXNEMPTY = 0x4
	// Position of SM1_RXNEMPTY field.
	PIO0_INTR_SM1_RXNEMPTY_Pos = 0x1
	// Bit mask of SM1_RXNEMPTY field.
	PIO0_INTR_SM1_RXNEMPTY_Msk = 0x2
	// Bit SM1_RXNEMPTY.
	PIO0_INTR_SM1_RXNEMPTY = 0x2
	// Position of SM0_RXNEMPTY field.
	PIO0_INTR_SM0_RXNEMPTY_Pos = 0x0
	// Bit mask of SM0_RXNEMPTY field.
	PIO0_INTR_SM0_RXNEMPTY_Msk = 0x1
	// Bit SM0_RXNEMPTY.
	PIO0_INTR_SM0_RXNEMPTY = 0x1

	// IRQ0_INTE: Interrupt Enable for irq0
	// Position of SM3 field.
	PIO0_IRQ0_INTE_SM3_Pos = 0xb
	// Bit mask of SM3 field.
	PIO0_IRQ0_INTE_SM3_Msk = 0x800
	// Bit SM3.
	PIO0_IRQ0_INTE_SM3 = 0x800
	// Position of SM2 field.
	PIO0_IRQ0_INTE_SM2_Pos = 0xa
	// Bit mask of SM2 field.
	PIO0_IRQ0_INTE_SM2_Msk = 0x400
	// Bit SM2.
	PIO0_IRQ0_INTE_SM2 = 0x400
	// Position of SM1 field.
	PIO0_IRQ0_INTE_SM1_Pos = 0x9
	// Bit mask of SM1 field.
	PIO0_IRQ0_INTE_SM1_Msk = 0x200
	// Bit SM1.
	PIO0_IRQ0_INTE_SM1 = 0x200
	// Position of SM0 field.
	PIO0_IRQ0_INTE_SM0_Pos = 0x8
	// Bit mask of SM0 field.
	PIO0_IRQ0_INTE_SM0_Msk = 0x100
	// Bit SM0.
	PIO0_IRQ0_INTE_SM0 = 0x100
	// Position of SM3_TXNFULL field.
	PIO0_IRQ0_INTE_SM3_TXNFULL_Pos = 0x7
	// Bit mask of SM3_TXNFULL field.
	PIO0_IRQ0_INTE_SM3_TXNFULL_Msk = 0x80
	// Bit SM3_TXNFULL.
	PIO0_IRQ0_INTE_SM3_TXNFULL = 0x80
	// Position of SM2_TXNFULL field.
	PIO0_IRQ0_INTE_SM2_TXNFULL_Pos = 0x6
	// Bit mask of SM2_TXNFULL field.
	PIO0_IRQ0_INTE_SM2_TXNFULL_Msk = 0x40
	// Bit SM2_TXNFULL.
	PIO0_IRQ0_INTE_SM2_TXNFULL = 0x40
	// Position of SM1_TXNFULL field.
	PIO0_IRQ0_INTE_SM1_TXNFULL_Pos = 0x5
	// Bit mask of SM1_TXNFULL field.
	PIO0_IRQ0_INTE_SM1_TXNFULL_Msk = 0x20
	// Bit SM1_TXNFULL.
	PIO0_IRQ0_INTE_SM1_TXNFULL = 0x20
	// Position of SM0_TXNFULL field.
	PIO0_IRQ0_INTE_SM0_TXNFULL_Pos = 0x4
	// Bit mask of SM0_TXNFULL field.
	PIO0_IRQ0_INTE_SM0_TXNFULL_Msk = 0x10
	// Bit SM0_TXNFULL.
	PIO0_IRQ0_INTE_SM0_TXNFULL = 0x10
	// Position of SM3_RXNEMPTY field.
	PIO0_IRQ0_INTE_SM3_RXNEMPTY_Pos = 0x3
	// Bit mask of SM3_RXNEMPTY field.
	PIO0_IRQ0_INTE_SM3_RXNEMPTY_Msk = 0x8
	// Bit SM3_RXNEMPTY.
	PIO0_IRQ0_INTE_SM3_RXNEMPTY = 0x8
	// Position of SM2_RXNEMPTY field.
	PIO0_IRQ0_INTE_SM2_RXNEMPTY_Pos = 0x2
	// Bit mask of SM2_RXNEMPTY field.
	PIO0_IRQ0_INTE_SM2_RXNEMPTY_Msk = 0x4
	// Bit SM2_RXNEMPTY.
	PIO0_IRQ0_INTE_SM2_RXNEMPTY = 0x4
	// Position of SM1_RXNEMPTY field.
	PIO0_IRQ0_INTE_SM1_RXNEMPTY_Pos = 0x1
	// Bit mask of SM1_RXNEMPTY field.
	PIO0_IRQ0_INTE_SM1_RXNEMPTY_Msk = 0x2
	// Bit SM1_RXNEMPTY.
	PIO0_IRQ0_INTE_SM1_RXNEMPTY = 0x2
	// Position of SM0_RXNEMPTY field.
	PIO0_IRQ0_INTE_SM0_RXNEMPTY_Pos = 0x0
	// Bit mask of SM0_RXNEMPTY field.
	PIO0_IRQ0_INTE_SM0_RXNEMPTY_Msk = 0x1
	// Bit SM0_RXNEMPTY.
	PIO0_IRQ0_INTE_SM0_RXNEMPTY = 0x1

	// IRQ0_INTF: Interrupt Force for irq0
	// Position of SM3 field.
	PIO0_IRQ0_INTF_SM3_Pos = 0xb
	// Bit mask of SM3 field.
	PIO0_IRQ0_INTF_SM3_Msk = 0x800
	// Bit SM3.
	PIO0_IRQ0_INTF_SM3 = 0x800
	// Position of SM2 field.
	PIO0_IRQ0_INTF_SM2_Pos = 0xa
	// Bit mask of SM2 field.
	PIO0_IRQ0_INTF_SM2_Msk = 0x400
	// Bit SM2.
	PIO0_IRQ0_INTF_SM2 = 0x400
	// Position of SM1 field.
	PIO0_IRQ0_INTF_SM1_Pos = 0x9
	// Bit mask of SM1 field.
	PIO0_IRQ0_INTF_SM1_Msk = 0x200
	// Bit SM1.
	PIO0_IRQ0_INTF_SM1 = 0x200
	// Position of SM0 field.
	PIO0_IRQ0_INTF_SM0_Pos = 0x8
	// Bit mask of SM0 field.
	PIO0_IRQ0_INTF_SM0_Msk = 0x100
	// Bit SM0.
	PIO0_IRQ0_INTF_SM0 = 0x100
	// Position of SM3_TXNFULL field.
	PIO0_IRQ0_INTF_SM3_TXNFULL_Pos = 0x7
	// Bit mask of SM3_TXNFULL field.
	PIO0_IRQ0_INTF_SM3_TXNFULL_Msk = 0x80
	// Bit SM3_TXNFULL.
	PIO0_IRQ0_INTF_SM3_TXNFULL = 0x80
	// Position of SM2_TXNFULL field.
	PIO0_IRQ0_INTF_SM2_TXNFULL_Pos = 0x6
	// Bit mask of SM2_TXNFULL field.
	PIO0_IRQ0_INTF_SM2_TXNFULL_Msk = 0x40
	// Bit SM2_TXNFULL.
	PIO0_IRQ0_INTF_SM2_TXNFULL = 0x40
	// Position of SM1_TXNFULL field.
	PIO0_IRQ0_INTF_SM1_TXNFULL_Pos = 0x5
	// Bit mask of SM1_TXNFULL field.
	PIO0_IRQ0_INTF_SM1_TXNFULL_Msk = 0x20
	// Bit SM1_TXNFULL.
	PIO0_IRQ0_INTF_SM1_TXNFULL = 0x20
	// Position of SM0_TXNFULL field.
	PIO0_IRQ0_INTF_SM0_TXNFULL_Pos = 0x4
	// Bit mask of SM0_TXNFULL field.
	PIO0_IRQ0_INTF_SM0_TXNFULL_Msk = 0x10
	// Bit SM0_TXNFULL.
	PIO0_IRQ0_INTF_SM0_TXNFULL = 0x10
	// Position of SM3_RXNEMPTY field.
	PIO0_IRQ0_INTF_SM3_RXNEMPTY_Pos = 0x3
	// Bit mask of SM3_RXNEMPTY field.
	PIO0_IRQ0_INTF_SM3_RXNEMPTY_Msk = 0x8
	// Bit SM3_RXNEMPTY.
	PIO0_IRQ0_INTF_SM3_RXNEMPTY = 0x8
	// Position of SM2_RXNEMPTY field.
	PIO0_IRQ0_INTF_SM2_RXNEMPTY_Pos = 0x2
	// Bit mask of SM2_RXNEMPTY field.
	PIO0_IRQ0_INTF_SM2_RXNEMPTY_Msk = 0x4
	// Bit SM2_RXNEMPTY.
	PIO0_IRQ0_INTF_SM2_RXNEMPTY = 0x4
	// Position of SM1_RXNEMPTY field.
	PIO0_IRQ0_INTF_SM1_RXNEMPTY_Pos = 0x1
	// Bit mask of SM1_RXNEMPTY field.
	PIO0_IRQ0_INTF_SM1_RXNEMPTY_Msk = 0x2
	// Bit SM1_RXNEMPTY.
	PIO0_IRQ0_INTF_SM1_RXNEMPTY = 0x2
	// Position of SM0_RXNEMPTY field.
	PIO0_IRQ0_INTF_SM0_RXNEMPTY_Pos = 0x0
	// Bit mask of SM0_RXNEMPTY field.
	PIO0_IRQ0_INTF_SM0_RXNEMPTY_Msk = 0x1
	// Bit SM0_RXNEMPTY.
	PIO0_IRQ0_INTF_SM0_RXNEMPTY = 0x1

	// IRQ0_INTS: Interrupt status after masking & forcing for irq0
	// Position of SM3 field.
	PIO0_IRQ0_INTS_SM3_Pos = 0xb
	// Bit mask of SM3 field.
	PIO0_IRQ0_INTS_SM3_Msk = 0x800
	// Bit SM3.
	PIO0_IRQ0_INTS_SM3 = 0x800
	// Position of SM2 field.
	PIO0_IRQ0_INTS_SM2_Pos = 0xa
	// Bit mask of SM2 field.
	PIO0_IRQ0_INTS_SM2_Msk = 0x400
	// Bit SM2.
	PIO0_IRQ0_INTS_SM2 = 0x400
	// Position of SM1 field.
	PIO0_IRQ0_INTS_SM1_Pos = 0x9
	// Bit mask of SM1 field.
	PIO0_IRQ0_INTS_SM1_Msk = 0x200
	// Bit SM1.
	PIO0_IRQ0_INTS_SM1 = 0x200
	// Position of SM0 field.
	PIO0_IRQ0_INTS_SM0_Pos = 0x8
	// Bit mask of SM0 field.
	PIO0_IRQ0_INTS_SM0_Msk = 0x100
	// Bit SM0.
	PIO0_IRQ0_INTS_SM0 = 0x100
	// Position of SM3_TXNFULL field.
	PIO0_IRQ0_INTS_SM3_TXNFULL_Pos = 0x7
	// Bit mask of SM3_TXNFULL field.
	PIO0_IRQ0_INTS_SM3_TXNFULL_Msk = 0x80
	// Bit SM3_TXNFULL.
	PIO0_IRQ0_INTS_SM3_TXNFULL = 0x80
	// Position of SM2_TXNFULL field.
	PIO0_IRQ0_INTS_SM2_TXNFULL_Pos = 0x6
	// Bit mask of SM2_TXNFULL field.
	PIO0_IRQ0_INTS_SM2_TXNFULL_Msk = 0x40
	// Bit SM2_TXNFULL.
	PIO0_IRQ0_INTS_SM2_TXNFULL = 0x40
	// Position of SM1_TXNFULL field.
	PIO0_IRQ0_INTS_SM1_TXNFULL_Pos = 0x5
	// Bit mask of SM1_TXNFULL field.
	PIO0_IRQ0_INTS_SM1_TXNFULL_Msk = 0x20
	// Bit SM1_TXNFULL.
	PIO0_IRQ0_INTS_SM1_TXNFULL = 0x20
	// Position of SM0_TXNFULL field.
	PIO0_IRQ0_INTS_SM0_TXNFULL_Pos = 0x4
	// Bit mask of SM0_TXNFULL field.
	PIO0_IRQ0_INTS_SM0_TXNFULL_Msk = 0x10
	// Bit SM0_TXNFULL.
	PIO0_IRQ0_INTS_SM0_TXNFULL = 0x10
	// Position of SM3_RXNEMPTY field.
	PIO0_IRQ0_INTS_SM3_RXNEMPTY_Pos = 0x3
	// Bit mask of SM3_RXNEMPTY field.
	PIO0_IRQ0_INTS_SM3_RXNEMPTY_Msk = 0x8
	// Bit SM3_RXNEMPTY.
	PIO0_IRQ0_INTS_SM3_RXNEMPTY = 0x8
	// Position of SM2_RXNEMPTY field.
	PIO0_IRQ0_INTS_SM2_RXNEMPTY_Pos = 0x2
	// Bit mask of SM2_RXNEMPTY field.
	PIO0_IRQ0_INTS_SM2_RXNEMPTY_Msk = 0x4
	// Bit SM2_RXNEMPTY.
	PIO0_IRQ0_INTS_SM2_RXNEMPTY = 0x4
	// Position of SM1_RXNEMPTY field.
	PIO0_IRQ0_INTS_SM1_RXNEMPTY_Pos = 0x1
	// Bit mask of SM1_RXNEMPTY field.
	PIO0_IRQ0_INTS_SM1_RXNEMPTY_Msk = 0x2
	// Bit SM1_RXNEMPTY.
	PIO0_IRQ0_INTS_SM1_RXNEMPTY = 0x2
	// Position of SM0_RXNEMPTY field.
	PIO0_IRQ0_INTS_SM0_RXNEMPTY_Pos = 0x0
	// Bit mask of SM0_RXNEMPTY field.
	PIO0_IRQ0_INTS_SM0_RXNEMPTY_Msk = 0x1
	// Bit SM0_RXNEMPTY.
	PIO0_IRQ0_INTS_SM0_RXNEMPTY = 0x1

	// IRQ1_INTE: Interrupt Enable for irq1
	// Position of SM3 field.
	PIO0_IRQ1_INTE_SM3_Pos = 0xb
	// Bit mask of SM3 field.
	PIO0_IRQ1_INTE_SM3_Msk = 0x800
	// Bit SM3.
	PIO0_IRQ1_INTE_SM3 = 0x800
	// Position of SM2 field.
	PIO0_IRQ1_INTE_SM2_Pos = 0xa
	// Bit mask of SM2 field.
	PIO0_IRQ1_INTE_SM2_Msk = 0x400
	// Bit SM2.
	PIO0_IRQ1_INTE_SM2 = 0x400
	// Position of SM1 field.
	PIO0_IRQ1_INTE_SM1_Pos = 0x9
	// Bit mask of SM1 field.
	PIO0_IRQ1_INTE_SM1_Msk = 0x200
	// Bit SM1.
	PIO0_IRQ1_INTE_SM1 = 0x200
	// Position of SM0 field.
	PIO0_IRQ1_INTE_SM0_Pos = 0x8
	// Bit mask of SM0 field.
	PIO0_IRQ1_INTE_SM0_Msk = 0x100
	// Bit SM0.
	PIO0_IRQ1_INTE_SM0 = 0x100
	// Position of SM3_TXNFULL field.
	PIO0_IRQ1_INTE_SM3_TXNFULL_Pos = 0x7
	// Bit mask of SM3_TXNFULL field.
	PIO0_IRQ1_INTE_SM3_TXNFULL_Msk = 0x80
	// Bit SM3_TXNFULL.
	PIO0_IRQ1_INTE_SM3_TXNFULL = 0x80
	// Position of SM2_TXNFULL field.
	PIO0_IRQ1_INTE_SM2_TXNFULL_Pos = 0x6
	// Bit mask of SM2_TXNFULL field.
	PIO0_IRQ1_INTE_SM2_TXNFULL_Msk = 0x40
	// Bit SM2_TXNFULL.
	PIO0_IRQ1_INTE_SM2_TXNFULL = 0x40
	// Position of SM1_TXNFULL field.
	PIO0_IRQ1_INTE_SM1_TXNFULL_Pos = 0x5
	// Bit mask of SM1_TXNFULL field.
	PIO0_IRQ1_INTE_SM1_TXNFULL_Msk = 0x20
	// Bit SM1_TXNFULL.
	PIO0_IRQ1_INTE_SM1_TXNFULL = 0x20
	// Position of SM0_TXNFULL field.
	PIO0_IRQ1_INTE_SM0_TXNFULL_Pos = 0x4
	// Bit mask of SM0_TXNFULL field.
	PIO0_IRQ1_INTE_SM0_TXNFULL_Msk = 0x10
	// Bit SM0_TXNFULL.
	PIO0_IRQ1_INTE_SM0_TXNFULL = 0x10
	// Position of SM3_RXNEMPTY field.
	PIO0_IRQ1_INTE_SM3_RXNEMPTY_Pos = 0x3
	// Bit mask of SM3_RXNEMPTY field.
	PIO0_IRQ1_INTE_SM3_RXNEMPTY_Msk = 0x8
	// Bit SM3_RXNEMPTY.
	PIO0_IRQ1_INTE_SM3_RXNEMPTY = 0x8
	// Position of SM2_RXNEMPTY field.
	PIO0_IRQ1_INTE_SM2_RXNEMPTY_Pos = 0x2
	// Bit mask of SM2_RXNEMPTY field.
	PIO0_IRQ1_INTE_SM2_RXNEMPTY_Msk = 0x4
	// Bit SM2_RXNEMPTY.
	PIO0_IRQ1_INTE_SM2_RXNEMPTY = 0x4
	// Position of SM1_RXNEMPTY field.
	PIO0_IRQ1_INTE_SM1_RXNEMPTY_Pos = 0x1
	// Bit mask of SM1_RXNEMPTY field.
	PIO0_IRQ1_INTE_SM1_RXNEMPTY_Msk = 0x2
	// Bit SM1_RXNEMPTY.
	PIO0_IRQ1_INTE_SM1_RXNEMPTY = 0x2
	// Position of SM0_RXNEMPTY field.
	PIO0_IRQ1_INTE_SM0_RXNEMPTY_Pos = 0x0
	// Bit mask of SM0_RXNEMPTY field.
	PIO0_IRQ1_INTE_SM0_RXNEMPTY_Msk = 0x1
	// Bit SM0_RXNEMPTY.
	PIO0_IRQ1_INTE_SM0_RXNEMPTY = 0x1

	// IRQ1_INTF: Interrupt Force for irq1
	// Position of SM3 field.
	PIO0_IRQ1_INTF_SM3_Pos = 0xb
	// Bit mask of SM3 field.
	PIO0_IRQ1_INTF_SM3_Msk = 0x800
	// Bit SM3.
	PIO0_IRQ1_INTF_SM3 = 0x800
	// Position of SM2 field.
	PIO0_IRQ1_INTF_SM2_Pos = 0xa
	// Bit mask of SM2 field.
	PIO0_IRQ1_INTF_SM2_Msk = 0x400
	// Bit SM2.
	PIO0_IRQ1_INTF_SM2 = 0x400
	// Position of SM1 field.
	PIO0_IRQ1_INTF_SM1_Pos = 0x9
	// Bit mask of SM1 field.
	PIO0_IRQ1_INTF_SM1_Msk = 0x200
	// Bit SM1.
	PIO0_IRQ1_INTF_SM1 = 0x200
	// Position of SM0 field.
	PIO0_IRQ1_INTF_SM0_Pos = 0x8
	// Bit mask of SM0 field.
	PIO0_IRQ1_INTF_SM0_Msk = 0x100
	// Bit SM0.
	PIO0_IRQ1_INTF_SM0 = 0x100
	// Position of SM3_TXNFULL field.
	PIO0_IRQ1_INTF_SM3_TXNFULL_Pos = 0x7
	// Bit mask of SM3_TXNFULL field.
	PIO0_IRQ1_INTF_SM3_TXNFULL_Msk = 0x80
	// Bit SM3_TXNFULL.
	PIO0_IRQ1_INTF_SM3_TXNFULL = 0x80
	// Position of SM2_TXNFULL field.
	PIO0_IRQ1_INTF_SM2_TXNFULL_Pos = 0x6
	// Bit mask of SM2_TXNFULL field.
	PIO0_IRQ1_INTF_SM2_TXNFULL_Msk = 0x40
	// Bit SM2_TXNFULL.
	PIO0_IRQ1_INTF_SM2_TXNFULL = 0x40
	// Position of SM1_TXNFULL field.
	PIO0_IRQ1_INTF_SM1_TXNFULL_Pos = 0x5
	// Bit mask of SM1_TXNFULL field.
	PIO0_IRQ1_INTF_SM1_TXNFULL_Msk = 0x20
	// Bit SM1_TXNFULL.
	PIO0_IRQ1_INTF_SM1_TXNFULL = 0x20
	// Position of SM0_TXNFULL field.
	PIO0_IRQ1_INTF_SM0_TXNFULL_Pos = 0x4
	// Bit mask of SM0_TXNFULL field.
	PIO0_IRQ1_INTF_SM0_TXNFULL_Msk = 0x10
	// Bit SM0_TXNFULL.
	PIO0_IRQ1_INTF_SM0_TXNFULL = 0x10
	// Position of SM3_RXNEMPTY field.
	PIO0_IRQ1_INTF_SM3_RXNEMPTY_Pos = 0x3
	// Bit mask of SM3_RXNEMPTY field.
	PIO0_IRQ1_INTF_SM3_RXNEMPTY_Msk = 0x8
	// Bit SM3_RXNEMPTY.
	PIO0_IRQ1_INTF_SM3_RXNEMPTY = 0x8
	// Position of SM2_RXNEMPTY field.
	PIO0_IRQ1_INTF_SM2_RXNEMPTY_Pos = 0x2
	// Bit mask of SM2_RXNEMPTY field.
	PIO0_IRQ1_INTF_SM2_RXNEMPTY_Msk = 0x4
	// Bit SM2_RXNEMPTY.
	PIO0_IRQ1_INTF_SM2_RXNEMPTY = 0x4
	// Position of SM1_RXNEMPTY field.
	PIO0_IRQ1_INTF_SM1_RXNEMPTY_Pos = 0x1
	// Bit mask of SM1_RXNEMPTY field.
	PIO0_IRQ1_INTF_SM1_RXNEMPTY_Msk = 0x2
	// Bit SM1_RXNEMPTY.
	PIO0_IRQ1_INTF_SM1_RXNEMPTY = 0x2
	// Position of SM0_RXNEMPTY field.
	PIO0_IRQ1_INTF_SM0_RXNEMPTY_Pos = 0x0
	// Bit mask of SM0_RXNEMPTY field.
	PIO0_IRQ1_INTF_SM0_RXNEMPTY_Msk = 0x1
	// Bit SM0_RXNEMPTY.
	PIO0_IRQ1_INTF_SM0_RXNEMPTY = 0x1

	// IRQ1_INTS: Interrupt status after masking & forcing for irq1
	// Position of SM3 field.
	PIO0_IRQ1_INTS_SM3_Pos = 0xb
	// Bit mask of SM3 field.
	PIO0_IRQ1_INTS_SM3_Msk = 0x800
	// Bit SM3.
	PIO0_IRQ1_INTS_SM3 = 0x800
	// Position of SM2 field.
	PIO0_IRQ1_INTS_SM2_Pos = 0xa
	// Bit mask of SM2 field.
	PIO0_IRQ1_INTS_SM2_Msk = 0x400
	// Bit SM2.
	PIO0_IRQ1_INTS_SM2 = 0x400
	// Position of SM1 field.
	PIO0_IRQ1_INTS_SM1_Pos = 0x9
	// Bit mask of SM1 field.
	PIO0_IRQ1_INTS_SM1_Msk = 0x200
	// Bit SM1.
	PIO0_IRQ1_INTS_SM1 = 0x200
	// Position of SM0 field.
	PIO0_IRQ1_INTS_SM0_Pos = 0x8
	// Bit mask of SM0 field.
	PIO0_IRQ1_INTS_SM0_Msk = 0x100
	// Bit SM0.
	PIO0_IRQ1_INTS_SM0 = 0x100
	// Position of SM3_TXNFULL field.
	PIO0_IRQ1_INTS_SM3_TXNFULL_Pos = 0x7
	// Bit mask of SM3_TXNFULL field.
	PIO0_IRQ1_INTS_SM3_TXNFULL_Msk = 0x80
	// Bit SM3_TXNFULL.
	PIO0_IRQ1_INTS_SM3_TXNFULL = 0x80
	// Position of SM2_TXNFULL field.
	PIO0_IRQ1_INTS_SM2_TXNFULL_Pos = 0x6
	// Bit mask of SM2_TXNFULL field.
	PIO0_IRQ1_INTS_SM2_TXNFULL_Msk = 0x40
	// Bit SM2_TXNFULL.
	PIO0_IRQ1_INTS_SM2_TXNFULL = 0x40
	// Position of SM1_TXNFULL field.
	PIO0_IRQ1_INTS_SM1_TXNFULL_Pos = 0x5
	// Bit mask of SM1_TXNFULL field.
	PIO0_IRQ1_INTS_SM1_TXNFULL_Msk = 0x20
	// Bit SM1_TXNFULL.
	PIO0_IRQ1_INTS_SM1_TXNFULL = 0x20
	// Position of SM0_TXNFULL field.
	PIO0_IRQ1_INTS_SM0_TXNFULL_Pos = 0x4
	// Bit mask of SM0_TXNFULL field.
	PIO0_IRQ1_INTS_SM0_TXNFULL_Msk = 0x10
	// Bit SM0_TXNFULL.
	PIO0_IRQ1_INTS_SM0_TXNFULL = 0x10
	// Position of SM3_RXNEMPTY field.
	PIO0_IRQ1_INTS_SM3_RXNEMPTY_Pos = 0x3
	// Bit mask of SM3_RXNEMPTY field.
	PIO0_IRQ1_INTS_SM3_RXNEMPTY_Msk = 0x8
	// Bit SM3_RXNEMPTY.
	PIO0_IRQ1_INTS_SM3_RXNEMPTY = 0x8
	// Position of SM2_RXNEMPTY field.
	PIO0_IRQ1_INTS_SM2_RXNEMPTY_Pos = 0x2
	// Bit mask of SM2_RXNEMPTY field.
	PIO0_IRQ1_INTS_SM2_RXNEMPTY_Msk = 0x4
	// Bit SM2_RXNEMPTY.
	PIO0_IRQ1_INTS_SM2_RXNEMPTY = 0x4
	// Position of SM1_RXNEMPTY field.
	PIO0_IRQ1_INTS_SM1_RXNEMPTY_Pos = 0x1
	// Bit mask of SM1_RXNEMPTY field.
	PIO0_IRQ1_INTS_SM1_RXNEMPTY_Msk = 0x2
	// Bit SM1_RXNEMPTY.
	PIO0_IRQ1_INTS_SM1_RXNEMPTY = 0x2
	// Position of SM0_RXNEMPTY field.
	PIO0_IRQ1_INTS_SM0_RXNEMPTY_Pos = 0x0
	// Bit mask of SM0_RXNEMPTY field.
	PIO0_IRQ1_INTS_SM0_RXNEMPTY_Msk = 0x1
	// Bit SM0_RXNEMPTY.
	PIO0_IRQ1_INTS_SM0_RXNEMPTY = 0x1
)

// Constants for SIO
// Single-cycle IO block
// Provides core-local and inter-core hardware for the two processors, with single-cycle access.
const (
	// GPIO_IN: Input value for GPIO pins
	// Position of GPIO_IN field.
	SIO_GPIO_IN_GPIO_IN_Pos = 0x0
	// Bit mask of GPIO_IN field.
	SIO_GPIO_IN_GPIO_IN_Msk = 0x3fffffff

	// GPIO_HI_IN: Input value for QSPI pins
	// Position of GPIO_HI_IN field.
	SIO_GPIO_HI_IN_GPIO_HI_IN_Pos = 0x0
	// Bit mask of GPIO_HI_IN field.
	SIO_GPIO_HI_IN_GPIO_HI_IN_Msk = 0x3f

	// GPIO_OUT: GPIO output value
	// Position of GPIO_OUT field.
	SIO_GPIO_OUT_GPIO_OUT_Pos = 0x0
	// Bit mask of GPIO_OUT field.
	SIO_GPIO_OUT_GPIO_OUT_Msk = 0x3fffffff

	// GPIO_OUT_SET: GPIO output value set
	// Position of GPIO_OUT_SET field.
	SIO_GPIO_OUT_SET_GPIO_OUT_SET_Pos = 0x0
	// Bit mask of GPIO_OUT_SET field.
	SIO_GPIO_OUT_SET_GPIO_OUT_SET_Msk = 0x3fffffff

	// GPIO_OUT_CLR: GPIO output value clear
	// Position of GPIO_OUT_CLR field.
	SIO_GPIO_OUT_CLR_GPIO_OUT_CLR_Pos = 0x0
	// Bit mask of GPIO_OUT_CLR field.
	SIO_GPIO_OUT_CLR_GPIO_OUT_CLR_Msk = 0x3fffffff

	// GPIO_OUT_XOR: GPIO output value XOR
	// Position of GPIO_OUT_XOR field.
	SIO_GPIO_OUT_XOR_GPIO_OUT_XOR_Pos = 0x0
	// Bit mask of GPIO_OUT_XOR field.
	SIO_GPIO_OUT_XOR_GPIO_OUT_XOR_Msk = 0x3fffffff

	// GPIO_OE: GPIO output enable
	// Position of GPIO_OE field.
	SIO_GPIO_OE_GPIO_OE_Pos = 0x0
	// Bit mask of GPIO_OE field.
	SIO_GPIO_OE_GPIO_OE_Msk = 0x3fffffff

	// GPIO_OE_SET: GPIO output enable set
	// Position of GPIO_OE_SET field.
	SIO_GPIO_OE_SET_GPIO_OE_SET_Pos = 0x0
	// Bit mask of GPIO_OE_SET field.
	SIO_GPIO_OE_SET_GPIO_OE_SET_Msk = 0x3fffffff

	// GPIO_OE_CLR: GPIO output enable clear
	// Position of GPIO_OE_CLR field.
	SIO_GPIO_OE_CLR_GPIO_OE_CLR_Pos = 0x0
	// Bit mask of GPIO_OE_CLR field.
	SIO_GPIO_OE_CLR_GPIO_OE_CLR_Msk = 0x3fffffff

	// GPIO_OE_XOR: GPIO output enable XOR
	// Position of GPIO_OE_XOR field.
	SIO_GPIO_OE_XOR_GPIO_OE_XOR_Pos = 0x0
	// Bit mask of GPIO_OE_XOR field.
	SIO_GPIO_OE_XOR_GPIO_OE_XOR_Msk = 0x3fffffff

	// GPIO_HI_OUT: QSPI output value
	// Position of GPIO_HI_OUT field.
	SIO_GPIO_HI_OUT_GPIO_HI_OUT_Pos = 0x0
	// Bit mask of GPIO_HI_OUT field.
	SIO_GPIO_HI_OUT_GPIO_HI_OUT_Msk = 0x3f

	// GPIO_HI_OUT_SET: QSPI output value set
	// Position of GPIO_HI_OUT_SET field.
	SIO_GPIO_HI_OUT_SET_GPIO_HI_OUT_SET_Pos = 0x0
	// Bit mask of GPIO_HI_OUT_SET field.
	SIO_GPIO_HI_OUT_SET_GPIO_HI_OUT_SET_Msk = 0x3f

	// GPIO_HI_OUT_CLR: QSPI output value clear
	// Position of GPIO_HI_OUT_CLR field.
	SIO_GPIO_HI_OUT_CLR_GPIO_HI_OUT_CLR_Pos = 0x0
	// Bit mask of GPIO_HI_OUT_CLR field.
	SIO_GPIO_HI_OUT_CLR_GPIO_HI_OUT_CLR_Msk = 0x3f

	// GPIO_HI_OUT_XOR: QSPI output value XOR
	// Position of GPIO_HI_OUT_XOR field.
	SIO_GPIO_HI_OUT_XOR_GPIO_HI_OUT_XOR_Pos = 0x0
	// Bit mask of GPIO_HI_OUT_XOR field.
	SIO_GPIO_HI_OUT_XOR_GPIO_HI_OUT_XOR_Msk = 0x3f

	// GPIO_HI_OE: QSPI output enable
	// Position of GPIO_HI_OE field.
	SIO_GPIO_HI_OE_GPIO_HI_OE_Pos = 0x0
	// Bit mask of GPIO_HI_OE field.
	SIO_GPIO_HI_OE_GPIO_HI_OE_Msk = 0x3f

	// GPIO_HI_OE_SET: QSPI output enable set
	// Position of GPIO_HI_OE_SET field.
	SIO_GPIO_HI_OE_SET_GPIO_HI_OE_SET_Pos = 0x0
	// Bit mask of GPIO_HI_OE_SET field.
	SIO_GPIO_HI_OE_SET_GPIO_HI_OE_SET_Msk = 0x3f

	// GPIO_HI_OE_CLR: QSPI output enable clear
	// Position of GPIO_HI_OE_CLR field.
	SIO_GPIO_HI_OE_CLR_GPIO_HI_OE_CLR_Pos = 0x0
	// Bit mask of GPIO_HI_OE_CLR field.
	SIO_GPIO_HI_OE_CLR_GPIO_HI_OE_CLR_Msk = 0x3f

	// GPIO_HI_OE_XOR: QSPI output enable XOR
	// Position of GPIO_HI_OE_XOR field.
	SIO_GPIO_HI_OE_XOR_GPIO_HI_OE_XOR_Pos = 0x0
	// Bit mask of GPIO_HI_OE_XOR field.
	SIO_GPIO_HI_OE_XOR_GPIO_HI_OE_XOR_Msk = 0x3f

	// FIFO_ST
	// Status register for inter-core FIFOs (mailboxes).
	// There is one FIFO in the core 0 -> core 1 direction, and one core 1 -> core 0. Both are 32 bits wide and 8 words deep.
	// Core 0 can see the read side of the 1->0 FIFO (RX), and the write side of 0->1 FIFO (TX).
	// Core 1 can see the read side of the 0->1 FIFO (RX), and the write side of 1->0 FIFO (TX).
	// The SIO IRQ for each core is the logical OR of the VLD, WOF and ROE fields of its FIFO_ST register.
	// Position of ROE field.
	SIO_FIFO_ST_ROE_Pos = 0x3
	// Bit mask of ROE field.
	SIO_FIFO_ST_ROE_Msk = 0x8
	// Bit ROE.
	SIO_FIFO_ST_ROE = 0x8
	// Position of WOF field.
	SIO_FIFO_ST_WOF_Pos = 0x2
	// Bit mask of WOF field.
	SIO_FIFO_ST_WOF_Msk = 0x4
	// Bit WOF.
	SIO_FIFO_ST_WOF = 0x4
	// Position of RDY field.
	SIO_FIFO_ST_RDY_Pos = 0x1
	// Bit mask of RDY field.
	SIO_FIFO_ST_RDY_Msk = 0x2
	// Bit RDY.
	SIO_FIFO_ST_RDY = 0x2
	// Position of VLD field.
	SIO_FIFO_ST_VLD_Pos = 0x0
	// Bit mask of VLD field.
	SIO_FIFO_ST_VLD_Msk = 0x1
	// Bit VLD.
	SIO_FIFO_ST_VLD = 0x1

	// DIV_CSR: Control and status register for divider.
	// Position of DIRTY field.
	SIO_DIV_CSR_DIRTY_Pos = 0x1
	// Bit mask of DIRTY field.
	SIO_DIV_CSR_DIRTY_Msk = 0x2
	// Bit DIRTY.
	SIO_DIV_CSR_DIRTY = 0x2
	// Position of READY field.
	SIO_DIV_CSR_READY_Pos = 0x0
	// Bit mask of READY field.
	SIO_DIV_CSR_READY_Msk = 0x1
	// Bit READY.
	SIO_DIV_CSR_READY = 0x1

	// INTERP0_CTRL_LANE0: Control register for lane 0
	// Position of OVERF field.
	SIO_INTERP0_CTRL_LANE0_OVERF_Pos = 0x19
	// Bit mask of OVERF field.
	SIO_INTERP0_CTRL_LANE0_OVERF_Msk = 0x2000000
	// Bit OVERF.
	SIO_INTERP0_CTRL_LANE0_OVERF = 0x2000000
	// Position of OVERF1 field.
	SIO_INTERP0_CTRL_LANE0_OVERF1_Pos = 0x18
	// Bit mask of OVERF1 field.
	SIO_INTERP0_CTRL_LANE0_OVERF1_Msk = 0x1000000
	// Bit OVERF1.
	SIO_INTERP0_CTRL_LANE0_OVERF1 = 0x1000000
	// Position of OVERF0 field.
	SIO_INTERP0_CTRL_LANE0_OVERF0_Pos = 0x17
	// Bit mask of OVERF0 field.
	SIO_INTERP0_CTRL_LANE0_OVERF0_Msk = 0x800000
	// Bit OVERF0.
	SIO_INTERP0_CTRL_LANE0_OVERF0 = 0x800000
	// Position of BLEND field.
	SIO_INTERP0_CTRL_LANE0_BLEND_Pos = 0x15
	// Bit mask of BLEND field.
	SIO_INTERP0_CTRL_LANE0_BLEND_Msk = 0x200000
	// Bit BLEND.
	SIO_INTERP0_CTRL_LANE0_BLEND = 0x200000
	// Position of FORCE_MSB field.
	SIO_INTERP0_CTRL_LANE0_FORCE_MSB_Pos = 0x13
	// Bit mask of FORCE_MSB field.
	SIO_INTERP0_CTRL_LANE0_FORCE_MSB_Msk = 0x180000
	// Position of ADD_RAW field.
	SIO_INTERP0_CTRL_LANE0_ADD_RAW_Pos = 0x12
	// Bit mask of ADD_RAW field.
	SIO_INTERP0_CTRL_LANE0_ADD_RAW_Msk = 0x40000
	// Bit ADD_RAW.
	SIO_INTERP0_CTRL_LANE0_ADD_RAW = 0x40000
	// Position of CROSS_RESULT field.
	SIO_INTERP0_CTRL_LANE0_CROSS_RESULT_Pos = 0x11
	// Bit mask of CROSS_RESULT field.
	SIO_INTERP0_CTRL_LANE0_CROSS_RESULT_Msk = 0x20000
	// Bit CROSS_RESULT.
	SIO_INTERP0_CTRL_LANE0_CROSS_RESULT = 0x20000
	// Position of CROSS_INPUT field.
	SIO_INTERP0_CTRL_LANE0_CROSS_INPUT_Pos = 0x10
	// Bit mask of CROSS_INPUT field.
	SIO_INTERP0_CTRL_LANE0_CROSS_INPUT_Msk = 0x10000
	// Bit CROSS_INPUT.
	SIO_INTERP0_CTRL_LANE0_CROSS_INPUT = 0x10000
	// Position of SIGNED field.
	SIO_INTERP0_CTRL_LANE0_SIGNED_Pos = 0xf
	// Bit mask of SIGNED field.
	SIO_INTERP0_CTRL_LANE0_SIGNED_Msk = 0x8000
	// Bit SIGNED.
	SIO_INTERP0_CTRL_LANE0_SIGNED = 0x8000
	// Position of MASK_MSB field.
	SIO_INTERP0_CTRL_LANE0_MASK_MSB_Pos = 0xa
	// Bit mask of MASK_MSB field.
	SIO_INTERP0_CTRL_LANE0_MASK_MSB_Msk = 0x7c00
	// Position of MASK_LSB field.
	SIO_INTERP0_CTRL_LANE0_MASK_LSB_Pos = 0x5
	// Bit mask of MASK_LSB field.
	SIO_INTERP0_CTRL_LANE0_MASK_LSB_Msk = 0x3e0
	// Position of SHIFT field.
	SIO_INTERP0_CTRL_LANE0_SHIFT_Pos = 0x0
	// Bit mask of SHIFT field.
	SIO_INTERP0_CTRL_LANE0_SHIFT_Msk = 0x1f

	// INTERP0_CTRL_LANE1: Control register for lane 1
	// Position of FORCE_MSB field.
	SIO_INTERP0_CTRL_LANE1_FORCE_MSB_Pos = 0x13
	// Bit mask of FORCE_MSB field.
	SIO_INTERP0_CTRL_LANE1_FORCE_MSB_Msk = 0x180000
	// Position of ADD_RAW field.
	SIO_INTERP0_CTRL_LANE1_ADD_RAW_Pos = 0x12
	// Bit mask of ADD_RAW field.
	SIO_INTERP0_CTRL_LANE1_ADD_RAW_Msk = 0x40000
	// Bit ADD_RAW.
	SIO_INTERP0_CTRL_LANE1_ADD_RAW = 0x40000
	// Position of CROSS_RESULT field.
	SIO_INTERP0_CTRL_LANE1_CROSS_RESULT_Pos = 0x11
	// Bit mask of CROSS_RESULT field.
	SIO_INTERP0_CTRL_LANE1_CROSS_RESULT_Msk = 0x20000
	// Bit CROSS_RESULT.
	SIO_INTERP0_CTRL_LANE1_CROSS_RESULT = 0x20000
	// Position of CROSS_INPUT field.
	SIO_INTERP0_CTRL_LANE1_CROSS_INPUT_Pos = 0x10
	// Bit mask of CROSS_INPUT field.
	SIO_INTERP0_CTRL_LANE1_CROSS_INPUT_Msk = 0x10000
	// Bit CROSS_INPUT.
	SIO_INTERP0_CTRL_LANE1_CROSS_INPUT = 0x10000
	// Position of SIGNED field.
	SIO_INTERP0_CTRL_LANE1_SIGNED_Pos = 0xf
	// Bit mask of SIGNED field.
	SIO_INTERP0_CTRL_LANE1_SIGNED_Msk = 0x8000
	// Bit SIGNED.
	SIO_INTERP0_CTRL_LANE1_SIGNED = 0x8000
	// Position of MASK_MSB field.
	SIO_INTERP0_CTRL_LANE1_MASK_MSB_Pos = 0xa
	// Bit mask of MASK_MSB field.
	SIO_INTERP0_CTRL_LANE1_MASK_MSB_Msk = 0x7c00
	// Position of MASK_LSB field.
	SIO_INTERP0_CTRL_LANE1_MASK_LSB_Pos = 0x5
	// Bit mask of MASK_LSB field.
	SIO_INTERP0_CTRL_LANE1_MASK_LSB_Msk = 0x3e0
	// Position of SHIFT field.
	SIO_INTERP0_CTRL_LANE1_SHIFT_Pos = 0x0
	// Bit mask of SHIFT field.
	SIO_INTERP0_CTRL_LANE1_SHIFT_Msk = 0x1f

	// INTERP0_ACCUM0_ADD
	// Values written here are atomically added to ACCUM0
	// Reading yields lane 0's raw shift and mask value (BASE0 not added).
	// Position of INTERP0_ACCUM0_ADD field.
	SIO_INTERP0_ACCUM0_ADD_INTERP0_ACCUM0_ADD_Pos = 0x0
	// Bit mask of INTERP0_ACCUM0_ADD field.
	SIO_INTERP0_ACCUM0_ADD_INTERP0_ACCUM0_ADD_Msk = 0xffffff

	// INTERP0_ACCUM1_ADD
	// Values written here are atomically added to ACCUM1
	// Reading yields lane 1's raw shift and mask value (BASE1 not added).
	// Position of INTERP0_ACCUM1_ADD field.
	SIO_INTERP0_ACCUM1_ADD_INTERP0_ACCUM1_ADD_Pos = 0x0
	// Bit mask of INTERP0_ACCUM1_ADD field.
	SIO_INTERP0_ACCUM1_ADD_INTERP0_ACCUM1_ADD_Msk = 0xffffff

	// INTERP1_CTRL_LANE0: Control register for lane 0
	// Position of OVERF field.
	SIO_INTERP1_CTRL_LANE0_OVERF_Pos = 0x19
	// Bit mask of OVERF field.
	SIO_INTERP1_CTRL_LANE0_OVERF_Msk = 0x2000000
	// Bit OVERF.
	SIO_INTERP1_CTRL_LANE0_OVERF = 0x2000000
	// Position of OVERF1 field.
	SIO_INTERP1_CTRL_LANE0_OVERF1_Pos = 0x18
	// Bit mask of OVERF1 field.
	SIO_INTERP1_CTRL_LANE0_OVERF1_Msk = 0x1000000
	// Bit OVERF1.
	SIO_INTERP1_CTRL_LANE0_OVERF1 = 0x1000000
	// Position of OVERF0 field.
	SIO_INTERP1_CTRL_LANE0_OVERF0_Pos = 0x17
	// Bit mask of OVERF0 field.
	SIO_INTERP1_CTRL_LANE0_OVERF0_Msk = 0x800000
	// Bit OVERF0.
	SIO_INTERP1_CTRL_LANE0_OVERF0 = 0x800000
	// Position of CLAMP field.
	SIO_INTERP1_CTRL_LANE0_CLAMP_Pos = 0x16
	// Bit mask of CLAMP field.
	SIO_INTERP1_CTRL_LANE0_CLAMP_Msk = 0x400000
	// Bit CLAMP.
	SIO_INTERP1_CTRL_LANE0_CLAMP = 0x400000
	// Position of FORCE_MSB field.
	SIO_INTERP1_CTRL_LANE0_FORCE_MSB_Pos = 0x13
	// Bit mask of FORCE_MSB field.
	SIO_INTERP1_CTRL_LANE0_FORCE_MSB_Msk = 0x180000
	// Position of ADD_RAW field.
	SIO_INTERP1_CTRL_LANE0_ADD_RAW_Pos = 0x12
	// Bit mask of ADD_RAW field.
	SIO_INTERP1_CTRL_LANE0_ADD_RAW_Msk = 0x40000
	// Bit ADD_RAW.
	SIO_INTERP1_CTRL_LANE0_ADD_RAW = 0x40000
	// Position of CROSS_RESULT field.
	SIO_INTERP1_CTRL_LANE0_CROSS_RESULT_Pos = 0x11
	// Bit mask of CROSS_RESULT field.
	SIO_INTERP1_CTRL_LANE0_CROSS_RESULT_Msk = 0x20000
	// Bit CROSS_RESULT.
	SIO_INTERP1_CTRL_LANE0_CROSS_RESULT = 0x20000
	// Position of CROSS_INPUT field.
	SIO_INTERP1_CTRL_LANE0_CROSS_INPUT_Pos = 0x10
	// Bit mask of CROSS_INPUT field.
	SIO_INTERP1_CTRL_LANE0_CROSS_INPUT_Msk = 0x10000
	// Bit CROSS_INPUT.
	SIO_INTERP1_CTRL_LANE0_CROSS_INPUT = 0x10000
	// Position of SIGNED field.
	SIO_INTERP1_CTRL_LANE0_SIGNED_Pos = 0xf
	// Bit mask of SIGNED field.
	SIO_INTERP1_CTRL_LANE0_SIGNED_Msk = 0x8000
	// Bit SIGNED.
	SIO_INTERP1_CTRL_LANE0_SIGNED = 0x8000
	// Position of MASK_MSB field.
	SIO_INTERP1_CTRL_LANE0_MASK_MSB_Pos = 0xa
	// Bit mask of MASK_MSB field.
	SIO_INTERP1_CTRL_LANE0_MASK_MSB_Msk = 0x7c00
	// Position of MASK_LSB field.
	SIO_INTERP1_CTRL_LANE0_MASK_LSB_Pos = 0x5
	// Bit mask of MASK_LSB field.
	SIO_INTERP1_CTRL_LANE0_MASK_LSB_Msk = 0x3e0
	// Position of SHIFT field.
	SIO_INTERP1_CTRL_LANE0_SHIFT_Pos = 0x0
	// Bit mask of SHIFT field.
	SIO_INTERP1_CTRL_LANE0_SHIFT_Msk = 0x1f

	// INTERP1_CTRL_LANE1: Control register for lane 1
	// Position of FORCE_MSB field.
	SIO_INTERP1_CTRL_LANE1_FORCE_MSB_Pos = 0x13
	// Bit mask of FORCE_MSB field.
	SIO_INTERP1_CTRL_LANE1_FORCE_MSB_Msk = 0x180000
	// Position of ADD_RAW field.
	SIO_INTERP1_CTRL_LANE1_ADD_RAW_Pos = 0x12
	// Bit mask of ADD_RAW field.
	SIO_INTERP1_CTRL_LANE1_ADD_RAW_Msk = 0x40000
	// Bit ADD_RAW.
	SIO_INTERP1_CTRL_LANE1_ADD_RAW = 0x40000
	// Position of CROSS_RESULT field.
	SIO_INTERP1_CTRL_LANE1_CROSS_RESULT_Pos = 0x11
	// Bit mask of CROSS_RESULT field.
	SIO_INTERP1_CTRL_LANE1_CROSS_RESULT_Msk = 0x20000
	// Bit CROSS_RESULT.
	SIO_INTERP1_CTRL_LANE1_CROSS_RESULT = 0x20000
	// Position of CROSS_INPUT field.
	SIO_INTERP1_CTRL_LANE1_CROSS_INPUT_Pos = 0x10
	// Bit mask of CROSS_INPUT field.
	SIO_INTERP1_CTRL_LANE1_CROSS_INPUT_Msk = 0x10000
	// Bit CROSS_INPUT.
	SIO_INTERP1_CTRL_LANE1_CROSS_INPUT = 0x10000
	// Position of SIGNED field.
	SIO_INTERP1_CTRL_LANE1_SIGNED_Pos = 0xf
	// Bit mask of SIGNED field.
	SIO_INTERP1_CTRL_LANE1_SIGNED_Msk = 0x8000
	// Bit SIGNED.
	SIO_INTERP1_CTRL_LANE1_SIGNED = 0x8000
	// Position of MASK_MSB field.
	SIO_INTERP1_CTRL_LANE1_MASK_MSB_Pos = 0xa
	// Bit mask of MASK_MSB field.
	SIO_INTERP1_CTRL_LANE1_MASK_MSB_Msk = 0x7c00
	// Position of MASK_LSB field.
	SIO_INTERP1_CTRL_LANE1_MASK_LSB_Pos = 0x5
	// Bit mask of MASK_LSB field.
	SIO_INTERP1_CTRL_LANE1_MASK_LSB_Msk = 0x3e0
	// Position of SHIFT field.
	SIO_INTERP1_CTRL_LANE1_SHIFT_Pos = 0x0
	// Bit mask of SHIFT field.
	SIO_INTERP1_CTRL_LANE1_SHIFT_Msk = 0x1f

	// INTERP1_ACCUM0_ADD
	// Values written here are atomically added to ACCUM0
	// Reading yields lane 0's raw shift and mask value (BASE0 not added).
	// Position of INTERP1_ACCUM0_ADD field.
	SIO_INTERP1_ACCUM0_ADD_INTERP1_ACCUM0_ADD_Pos = 0x0
	// Bit mask of INTERP1_ACCUM0_ADD field.
	SIO_INTERP1_ACCUM0_ADD_INTERP1_ACCUM0_ADD_Msk = 0xffffff

	// INTERP1_ACCUM1_ADD
	// Values written here are atomically added to ACCUM1
	// Reading yields lane 1's raw shift and mask value (BASE1 not added).
	// Position of INTERP1_ACCUM1_ADD field.
	SIO_INTERP1_ACCUM1_ADD_INTERP1_ACCUM1_ADD_Pos = 0x0
	// Bit mask of INTERP1_ACCUM1_ADD field.
	SIO_INTERP1_ACCUM1_ADD_INTERP1_ACCUM1_ADD_Msk = 0xffffff
)

// Constants for PPB
const (
	// SYST_CSR: Use the SysTick Control and Status Register to enable the SysTick features.
	// Position of COUNTFLAG field.
	PPB_SYST_CSR_COUNTFLAG_Pos = 0x10
	// Bit mask of COUNTFLAG field.
	PPB_SYST_CSR_COUNTFLAG_Msk = 0x10000
	// Bit COUNTFLAG.
	PPB_SYST_CSR_COUNTFLAG = 0x10000
	// Position of CLKSOURCE field.
	PPB_SYST_CSR_CLKSOURCE_Pos = 0x2
	// Bit mask of CLKSOURCE field.
	PPB_SYST_CSR_CLKSOURCE_Msk = 0x4
	// Bit CLKSOURCE.
	PPB_SYST_CSR_CLKSOURCE = 0x4
	// Position of TICKINT field.
	PPB_SYST_CSR_TICKINT_Pos = 0x1
	// Bit mask of TICKINT field.
	PPB_SYST_CSR_TICKINT_Msk = 0x2
	// Bit TICKINT.
	PPB_SYST_CSR_TICKINT = 0x2
	// Position of ENABLE field.
	PPB_SYST_CSR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	PPB_SYST_CSR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	PPB_SYST_CSR_ENABLE = 0x1

	// SYST_RVR
	// Use the SysTick Reload Value Register to specify the start value to load into the current value register when the counter reaches 0. It can be any value between 0 and 0x00FFFFFF. A start value of 0 is possible, but has no effect because the SysTick interrupt and COUNTFLAG are activated when counting from 1 to 0. The reset value of this register is UNKNOWN.
	// To generate a multi-shot timer with a period of N processor clock cycles, use a RELOAD value of N-1. For example, if the SysTick interrupt is required every 100 clock pulses, set RELOAD to 99.
	// Position of RELOAD field.
	PPB_SYST_RVR_RELOAD_Pos = 0x0
	// Bit mask of RELOAD field.
	PPB_SYST_RVR_RELOAD_Msk = 0xffffff

	// SYST_CVR: Use the SysTick Current Value Register to find the current value in the register. The reset value of this register is UNKNOWN.
	// Position of CURRENT field.
	PPB_SYST_CVR_CURRENT_Pos = 0x0
	// Bit mask of CURRENT field.
	PPB_SYST_CVR_CURRENT_Msk = 0xffffff

	// SYST_CALIB: Use the SysTick Calibration Value Register to enable software to scale to any required speed using divide and multiply.
	// Position of NOREF field.
	PPB_SYST_CALIB_NOREF_Pos = 0x1f
	// Bit mask of NOREF field.
	PPB_SYST_CALIB_NOREF_Msk = 0x80000000
	// Bit NOREF.
	PPB_SYST_CALIB_NOREF = 0x80000000
	// Position of SKEW field.
	PPB_SYST_CALIB_SKEW_Pos = 0x1e
	// Bit mask of SKEW field.
	PPB_SYST_CALIB_SKEW_Msk = 0x40000000
	// Bit SKEW.
	PPB_SYST_CALIB_SKEW = 0x40000000
	// Position of TENMS field.
	PPB_SYST_CALIB_TENMS_Pos = 0x0
	// Bit mask of TENMS field.
	PPB_SYST_CALIB_TENMS_Msk = 0xffffff

	// NVIC_ISER
	// Use the Interrupt Set-Enable Register to enable interrupts and determine which interrupts are currently enabled.
	// If a pending interrupt is enabled, the NVIC activates the interrupt based on its priority. If an interrupt is not enabled, asserting its interrupt signal changes the interrupt state to pending, but the NVIC never activates the interrupt, regardless of its priority.
	// Position of SETENA field.
	PPB_NVIC_ISER_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	PPB_NVIC_ISER_SETENA_Msk = 0xffffffff

	// NVIC_ICER: Use the Interrupt Clear-Enable Registers to disable interrupts and determine which interrupts are currently enabled.
	// Position of CLRENA field.
	PPB_NVIC_ICER_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	PPB_NVIC_ICER_CLRENA_Msk = 0xffffffff

	// NVIC_ISPR: The NVIC_ISPR forces interrupts into the pending state, and shows which interrupts are pending.
	// Position of SETPEND field.
	PPB_NVIC_ISPR_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	PPB_NVIC_ISPR_SETPEND_Msk = 0xffffffff

	// NVIC_ICPR: Use the Interrupt Clear-Pending Register to clear pending interrupts and determine which interrupts are currently pending.
	// Position of CLRPEND field.
	PPB_NVIC_ICPR_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	PPB_NVIC_ICPR_CLRPEND_Msk = 0xffffffff

	// NVIC_IPR0
	// Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
	// Note: Writing 1 to an NVIC_ICPR bit does not affect the active state of the corresponding interrupt.
	// These registers are only word-accessible
	// Position of IP_3 field.
	PPB_NVIC_IPR0_IP_3_Pos = 0x1e
	// Bit mask of IP_3 field.
	PPB_NVIC_IPR0_IP_3_Msk = 0xc0000000
	// Position of IP_2 field.
	PPB_NVIC_IPR0_IP_2_Pos = 0x16
	// Bit mask of IP_2 field.
	PPB_NVIC_IPR0_IP_2_Msk = 0xc00000
	// Position of IP_1 field.
	PPB_NVIC_IPR0_IP_1_Pos = 0xe
	// Bit mask of IP_1 field.
	PPB_NVIC_IPR0_IP_1_Msk = 0xc000
	// Position of IP_0 field.
	PPB_NVIC_IPR0_IP_0_Pos = 0x6
	// Bit mask of IP_0 field.
	PPB_NVIC_IPR0_IP_0_Msk = 0xc0

	// NVIC_IPR1: Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
	// Position of IP_7 field.
	PPB_NVIC_IPR1_IP_7_Pos = 0x1e
	// Bit mask of IP_7 field.
	PPB_NVIC_IPR1_IP_7_Msk = 0xc0000000
	// Position of IP_6 field.
	PPB_NVIC_IPR1_IP_6_Pos = 0x16
	// Bit mask of IP_6 field.
	PPB_NVIC_IPR1_IP_6_Msk = 0xc00000
	// Position of IP_5 field.
	PPB_NVIC_IPR1_IP_5_Pos = 0xe
	// Bit mask of IP_5 field.
	PPB_NVIC_IPR1_IP_5_Msk = 0xc000
	// Position of IP_4 field.
	PPB_NVIC_IPR1_IP_4_Pos = 0x6
	// Bit mask of IP_4 field.
	PPB_NVIC_IPR1_IP_4_Msk = 0xc0

	// NVIC_IPR2: Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
	// Position of IP_11 field.
	PPB_NVIC_IPR2_IP_11_Pos = 0x1e
	// Bit mask of IP_11 field.
	PPB_NVIC_IPR2_IP_11_Msk = 0xc0000000
	// Position of IP_10 field.
	PPB_NVIC_IPR2_IP_10_Pos = 0x16
	// Bit mask of IP_10 field.
	PPB_NVIC_IPR2_IP_10_Msk = 0xc00000
	// Position of IP_9 field.
	PPB_NVIC_IPR2_IP_9_Pos = 0xe
	// Bit mask of IP_9 field.
	PPB_NVIC_IPR2_IP_9_Msk = 0xc000
	// Position of IP_8 field.
	PPB_NVIC_IPR2_IP_8_Pos = 0x6
	// Bit mask of IP_8 field.
	PPB_NVIC_IPR2_IP_8_Msk = 0xc0

	// NVIC_IPR3: Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
	// Position of IP_15 field.
	PPB_NVIC_IPR3_IP_15_Pos = 0x1e
	// Bit mask of IP_15 field.
	PPB_NVIC_IPR3_IP_15_Msk = 0xc0000000
	// Position of IP_14 field.
	PPB_NVIC_IPR3_IP_14_Pos = 0x16
	// Bit mask of IP_14 field.
	PPB_NVIC_IPR3_IP_14_Msk = 0xc00000
	// Position of IP_13 field.
	PPB_NVIC_IPR3_IP_13_Pos = 0xe
	// Bit mask of IP_13 field.
	PPB_NVIC_IPR3_IP_13_Msk = 0xc000
	// Position of IP_12 field.
	PPB_NVIC_IPR3_IP_12_Pos = 0x6
	// Bit mask of IP_12 field.
	PPB_NVIC_IPR3_IP_12_Msk = 0xc0

	// NVIC_IPR4: Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
	// Position of IP_19 field.
	PPB_NVIC_IPR4_IP_19_Pos = 0x1e
	// Bit mask of IP_19 field.
	PPB_NVIC_IPR4_IP_19_Msk = 0xc0000000
	// Position of IP_18 field.
	PPB_NVIC_IPR4_IP_18_Pos = 0x16
	// Bit mask of IP_18 field.
	PPB_NVIC_IPR4_IP_18_Msk = 0xc00000
	// Position of IP_17 field.
	PPB_NVIC_IPR4_IP_17_Pos = 0xe
	// Bit mask of IP_17 field.
	PPB_NVIC_IPR4_IP_17_Msk = 0xc000
	// Position of IP_16 field.
	PPB_NVIC_IPR4_IP_16_Pos = 0x6
	// Bit mask of IP_16 field.
	PPB_NVIC_IPR4_IP_16_Msk = 0xc0

	// NVIC_IPR5: Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
	// Position of IP_23 field.
	PPB_NVIC_IPR5_IP_23_Pos = 0x1e
	// Bit mask of IP_23 field.
	PPB_NVIC_IPR5_IP_23_Msk = 0xc0000000
	// Position of IP_22 field.
	PPB_NVIC_IPR5_IP_22_Pos = 0x16
	// Bit mask of IP_22 field.
	PPB_NVIC_IPR5_IP_22_Msk = 0xc00000
	// Position of IP_21 field.
	PPB_NVIC_IPR5_IP_21_Pos = 0xe
	// Bit mask of IP_21 field.
	PPB_NVIC_IPR5_IP_21_Msk = 0xc000
	// Position of IP_20 field.
	PPB_NVIC_IPR5_IP_20_Pos = 0x6
	// Bit mask of IP_20 field.
	PPB_NVIC_IPR5_IP_20_Msk = 0xc0

	// NVIC_IPR6: Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
	// Position of IP_27 field.
	PPB_NVIC_IPR6_IP_27_Pos = 0x1e
	// Bit mask of IP_27 field.
	PPB_NVIC_IPR6_IP_27_Msk = 0xc0000000
	// Position of IP_26 field.
	PPB_NVIC_IPR6_IP_26_Pos = 0x16
	// Bit mask of IP_26 field.
	PPB_NVIC_IPR6_IP_26_Msk = 0xc00000
	// Position of IP_25 field.
	PPB_NVIC_IPR6_IP_25_Pos = 0xe
	// Bit mask of IP_25 field.
	PPB_NVIC_IPR6_IP_25_Msk = 0xc000
	// Position of IP_24 field.
	PPB_NVIC_IPR6_IP_24_Pos = 0x6
	// Bit mask of IP_24 field.
	PPB_NVIC_IPR6_IP_24_Msk = 0xc0

	// NVIC_IPR7: Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
	// Position of IP_31 field.
	PPB_NVIC_IPR7_IP_31_Pos = 0x1e
	// Bit mask of IP_31 field.
	PPB_NVIC_IPR7_IP_31_Msk = 0xc0000000
	// Position of IP_30 field.
	PPB_NVIC_IPR7_IP_30_Pos = 0x16
	// Bit mask of IP_30 field.
	PPB_NVIC_IPR7_IP_30_Msk = 0xc00000
	// Position of IP_29 field.
	PPB_NVIC_IPR7_IP_29_Pos = 0xe
	// Bit mask of IP_29 field.
	PPB_NVIC_IPR7_IP_29_Msk = 0xc000
	// Position of IP_28 field.
	PPB_NVIC_IPR7_IP_28_Pos = 0x6
	// Bit mask of IP_28 field.
	PPB_NVIC_IPR7_IP_28_Msk = 0xc0

	// CPUID: Read the CPU ID Base Register to determine: the ID number of the processor core, the version number of the processor core, the implementation details of the processor core.
	// Position of IMPLEMENTER field.
	PPB_CPUID_IMPLEMENTER_Pos = 0x18
	// Bit mask of IMPLEMENTER field.
	PPB_CPUID_IMPLEMENTER_Msk = 0xff000000
	// Position of VARIANT field.
	PPB_CPUID_VARIANT_Pos = 0x14
	// Bit mask of VARIANT field.
	PPB_CPUID_VARIANT_Msk = 0xf00000
	// Position of ARCHITECTURE field.
	PPB_CPUID_ARCHITECTURE_Pos = 0x10
	// Bit mask of ARCHITECTURE field.
	PPB_CPUID_ARCHITECTURE_Msk = 0xf0000
	// Position of PARTNO field.
	PPB_CPUID_PARTNO_Pos = 0x4
	// Bit mask of PARTNO field.
	PPB_CPUID_PARTNO_Msk = 0xfff0
	// Position of REVISION field.
	PPB_CPUID_REVISION_Pos = 0x0
	// Bit mask of REVISION field.
	PPB_CPUID_REVISION_Msk = 0xf

	// ICSR: Use the Interrupt Control State Register to set a pending Non-Maskable Interrupt (NMI), set or clear a pending PendSV, set or clear a pending SysTick, check for pending exceptions, check the vector number of the highest priority pended exception, check the vector number of the active exception.
	// Position of NMIPENDSET field.
	PPB_ICSR_NMIPENDSET_Pos = 0x1f
	// Bit mask of NMIPENDSET field.
	PPB_ICSR_NMIPENDSET_Msk = 0x80000000
	// Bit NMIPENDSET.
	PPB_ICSR_NMIPENDSET = 0x80000000
	// Position of PENDSVSET field.
	PPB_ICSR_PENDSVSET_Pos = 0x1c
	// Bit mask of PENDSVSET field.
	PPB_ICSR_PENDSVSET_Msk = 0x10000000
	// Bit PENDSVSET.
	PPB_ICSR_PENDSVSET = 0x10000000
	// Position of PENDSVCLR field.
	PPB_ICSR_PENDSVCLR_Pos = 0x1b
	// Bit mask of PENDSVCLR field.
	PPB_ICSR_PENDSVCLR_Msk = 0x8000000
	// Bit PENDSVCLR.
	PPB_ICSR_PENDSVCLR = 0x8000000
	// Position of PENDSTSET field.
	PPB_ICSR_PENDSTSET_Pos = 0x1a
	// Bit mask of PENDSTSET field.
	PPB_ICSR_PENDSTSET_Msk = 0x4000000
	// Bit PENDSTSET.
	PPB_ICSR_PENDSTSET = 0x4000000
	// Position of PENDSTCLR field.
	PPB_ICSR_PENDSTCLR_Pos = 0x19
	// Bit mask of PENDSTCLR field.
	PPB_ICSR_PENDSTCLR_Msk = 0x2000000
	// Bit PENDSTCLR.
	PPB_ICSR_PENDSTCLR = 0x2000000
	// Position of ISRPREEMPT field.
	PPB_ICSR_ISRPREEMPT_Pos = 0x17
	// Bit mask of ISRPREEMPT field.
	PPB_ICSR_ISRPREEMPT_Msk = 0x800000
	// Bit ISRPREEMPT.
	PPB_ICSR_ISRPREEMPT = 0x800000
	// Position of ISRPENDING field.
	PPB_ICSR_ISRPENDING_Pos = 0x16
	// Bit mask of ISRPENDING field.
	PPB_ICSR_ISRPENDING_Msk = 0x400000
	// Bit ISRPENDING.
	PPB_ICSR_ISRPENDING = 0x400000
	// Position of VECTPENDING field.
	PPB_ICSR_VECTPENDING_Pos = 0xc
	// Bit mask of VECTPENDING field.
	PPB_ICSR_VECTPENDING_Msk = 0x1ff000
	// Position of VECTACTIVE field.
	PPB_ICSR_VECTACTIVE_Pos = 0x0
	// Bit mask of VECTACTIVE field.
	PPB_ICSR_VECTACTIVE_Msk = 0x1ff

	// VTOR: The VTOR holds the vector table offset address.
	// Position of TBLOFF field.
	PPB_VTOR_TBLOFF_Pos = 0x8
	// Bit mask of TBLOFF field.
	PPB_VTOR_TBLOFF_Msk = 0xffffff00

	// AIRCR: Use the Application Interrupt and Reset Control Register to: determine data endianness, clear all active state information from debug halt mode, request a system reset.
	// Position of VECTKEY field.
	PPB_AIRCR_VECTKEY_Pos = 0x10
	// Bit mask of VECTKEY field.
	PPB_AIRCR_VECTKEY_Msk = 0xffff0000
	// Position of ENDIANESS field.
	PPB_AIRCR_ENDIANESS_Pos = 0xf
	// Bit mask of ENDIANESS field.
	PPB_AIRCR_ENDIANESS_Msk = 0x8000
	// Bit ENDIANESS.
	PPB_AIRCR_ENDIANESS = 0x8000
	// Position of SYSRESETREQ field.
	PPB_AIRCR_SYSRESETREQ_Pos = 0x2
	// Bit mask of SYSRESETREQ field.
	PPB_AIRCR_SYSRESETREQ_Msk = 0x4
	// Bit SYSRESETREQ.
	PPB_AIRCR_SYSRESETREQ = 0x4
	// Position of VECTCLRACTIVE field.
	PPB_AIRCR_VECTCLRACTIVE_Pos = 0x1
	// Bit mask of VECTCLRACTIVE field.
	PPB_AIRCR_VECTCLRACTIVE_Msk = 0x2
	// Bit VECTCLRACTIVE.
	PPB_AIRCR_VECTCLRACTIVE = 0x2

	// SCR: System Control Register. Use the System Control Register for power-management functions: signal to the system when the processor can enter a low power state, control how the processor enters and exits low power states.
	// Position of SEVONPEND field.
	PPB_SCR_SEVONPEND_Pos = 0x4
	// Bit mask of SEVONPEND field.
	PPB_SCR_SEVONPEND_Msk = 0x10
	// Bit SEVONPEND.
	PPB_SCR_SEVONPEND = 0x10
	// Position of SLEEPDEEP field.
	PPB_SCR_SLEEPDEEP_Pos = 0x2
	// Bit mask of SLEEPDEEP field.
	PPB_SCR_SLEEPDEEP_Msk = 0x4
	// Bit SLEEPDEEP.
	PPB_SCR_SLEEPDEEP = 0x4
	// Position of SLEEPONEXIT field.
	PPB_SCR_SLEEPONEXIT_Pos = 0x1
	// Bit mask of SLEEPONEXIT field.
	PPB_SCR_SLEEPONEXIT_Msk = 0x2
	// Bit SLEEPONEXIT.
	PPB_SCR_SLEEPONEXIT = 0x2

	// CCR: The Configuration and Control Register permanently enables stack alignment and causes unaligned accesses to result in a Hard Fault.
	// Position of STKALIGN field.
	PPB_CCR_STKALIGN_Pos = 0x9
	// Bit mask of STKALIGN field.
	PPB_CCR_STKALIGN_Msk = 0x200
	// Bit STKALIGN.
	PPB_CCR_STKALIGN = 0x200
	// Position of UNALIGN_TRP field.
	PPB_CCR_UNALIGN_TRP_Pos = 0x3
	// Bit mask of UNALIGN_TRP field.
	PPB_CCR_UNALIGN_TRP_Msk = 0x8
	// Bit UNALIGN_TRP.
	PPB_CCR_UNALIGN_TRP = 0x8

	// SHPR2: System handlers are a special class of exception handler that can have their priority set to any of the priority levels. Use the System Handler Priority Register 2 to set the priority of SVCall.
	// Position of PRI_11 field.
	PPB_SHPR2_PRI_11_Pos = 0x1e
	// Bit mask of PRI_11 field.
	PPB_SHPR2_PRI_11_Msk = 0xc0000000

	// SHPR3: System handlers are a special class of exception handler that can have their priority set to any of the priority levels. Use the System Handler Priority Register 3 to set the priority of PendSV and SysTick.
	// Position of PRI_15 field.
	PPB_SHPR3_PRI_15_Pos = 0x1e
	// Bit mask of PRI_15 field.
	PPB_SHPR3_PRI_15_Msk = 0xc0000000
	// Position of PRI_14 field.
	PPB_SHPR3_PRI_14_Pos = 0x16
	// Bit mask of PRI_14 field.
	PPB_SHPR3_PRI_14_Msk = 0xc00000

	// SHCSR: Use the System Handler Control and State Register to determine or clear the pending status of SVCall.
	// Position of SVCALLPENDED field.
	PPB_SHCSR_SVCALLPENDED_Pos = 0xf
	// Bit mask of SVCALLPENDED field.
	PPB_SHCSR_SVCALLPENDED_Msk = 0x8000
	// Bit SVCALLPENDED.
	PPB_SHCSR_SVCALLPENDED = 0x8000

	// MPU_TYPE: Read the MPU Type Register to determine if the processor implements an MPU, and how many regions the MPU supports.
	// Position of IREGION field.
	PPB_MPU_TYPE_IREGION_Pos = 0x10
	// Bit mask of IREGION field.
	PPB_MPU_TYPE_IREGION_Msk = 0xff0000
	// Position of DREGION field.
	PPB_MPU_TYPE_DREGION_Pos = 0x8
	// Bit mask of DREGION field.
	PPB_MPU_TYPE_DREGION_Msk = 0xff00
	// Position of SEPARATE field.
	PPB_MPU_TYPE_SEPARATE_Pos = 0x0
	// Bit mask of SEPARATE field.
	PPB_MPU_TYPE_SEPARATE_Msk = 0x1
	// Bit SEPARATE.
	PPB_MPU_TYPE_SEPARATE = 0x1

	// MPU_CTRL: Use the MPU Control Register to enable and disable the MPU, and to control whether the default memory map is enabled as a background region for privileged accesses, and whether the MPU is enabled for HardFaults and NMIs.
	// Position of PRIVDEFENA field.
	PPB_MPU_CTRL_PRIVDEFENA_Pos = 0x2
	// Bit mask of PRIVDEFENA field.
	PPB_MPU_CTRL_PRIVDEFENA_Msk = 0x4
	// Bit PRIVDEFENA.
	PPB_MPU_CTRL_PRIVDEFENA = 0x4
	// Position of HFNMIENA field.
	PPB_MPU_CTRL_HFNMIENA_Pos = 0x1
	// Bit mask of HFNMIENA field.
	PPB_MPU_CTRL_HFNMIENA_Msk = 0x2
	// Bit HFNMIENA.
	PPB_MPU_CTRL_HFNMIENA = 0x2
	// Position of ENABLE field.
	PPB_MPU_CTRL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	PPB_MPU_CTRL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	PPB_MPU_CTRL_ENABLE = 0x1

	// MPU_RNR: Use the MPU Region Number Register to select the region currently accessed by MPU_RBAR and MPU_RASR.
	// Position of REGION field.
	PPB_MPU_RNR_REGION_Pos = 0x0
	// Bit mask of REGION field.
	PPB_MPU_RNR_REGION_Msk = 0xf

	// MPU_RBAR: Read the MPU Region Base Address Register to determine the base address of the region identified by MPU_RNR. Write to update the base address of said region or that of a specified region, with whose number MPU_RNR will also be updated.
	// Position of ADDR field.
	PPB_MPU_RBAR_ADDR_Pos = 0x8
	// Bit mask of ADDR field.
	PPB_MPU_RBAR_ADDR_Msk = 0xffffff00
	// Position of VALID field.
	PPB_MPU_RBAR_VALID_Pos = 0x4
	// Bit mask of VALID field.
	PPB_MPU_RBAR_VALID_Msk = 0x10
	// Bit VALID.
	PPB_MPU_RBAR_VALID = 0x10
	// Position of REGION field.
	PPB_MPU_RBAR_REGION_Pos = 0x0
	// Bit mask of REGION field.
	PPB_MPU_RBAR_REGION_Msk = 0xf

	// MPU_RASR: Use the MPU Region Attribute and Size Register to define the size, access behaviour and memory type of the region identified by MPU_RNR, and enable that region.
	// Position of ATTRS field.
	PPB_MPU_RASR_ATTRS_Pos = 0x10
	// Bit mask of ATTRS field.
	PPB_MPU_RASR_ATTRS_Msk = 0xffff0000
	// Position of SRD field.
	PPB_MPU_RASR_SRD_Pos = 0x8
	// Bit mask of SRD field.
	PPB_MPU_RASR_SRD_Msk = 0xff00
	// Position of SIZE field.
	PPB_MPU_RASR_SIZE_Pos = 0x1
	// Bit mask of SIZE field.
	PPB_MPU_RASR_SIZE_Msk = 0x3e
	// Position of ENABLE field.
	PPB_MPU_RASR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	PPB_MPU_RASR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	PPB_MPU_RASR_ENABLE = 0x1
)
