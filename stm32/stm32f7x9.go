// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from stm32f7x9.svd, see https://github.com/tinygo-org/stm32-svd

//go:build stm32 && stm32f7x9
// +build stm32,stm32f7x9

// STM32F7x9
//

package stm32

import (
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "STM32F7x9"
	CPU          = "CM7"
	FPUPresent   = true
	NVICPrioBits = 4
)

// Interrupt numbers.
const (
	// Window watchdog
	IRQ_WWDG = 0

	// Power control // External interrupt/event controller
	IRQ_PVD = 1

	// External interrupt/event controller
	IRQ_TAMP_STAMP = 2

	// Real-time clock
	IRQ_RTC_WKUP = 3

	// FLASH
	IRQ_FLASH = 4

	// Reset and clock control
	IRQ_RCC = 5

	// External interrupt/event controller
	IRQ_EXTI0 = 6

	// External interrupt/event controller
	IRQ_EXTI1 = 7

	// External interrupt/event controller
	IRQ_EXTI2 = 8

	// External interrupt/event controller
	IRQ_EXTI3 = 9

	// External interrupt/event controller
	IRQ_EXTI4 = 10

	IRQ_DMA1_Stream0 = 11

	IRQ_DMA1_Stream1 = 12

	IRQ_DMA1_Stream2 = 13

	IRQ_DMA1_Stream3 = 14

	IRQ_DMA1_Stream4 = 15

	IRQ_DMA1_Stream5 = 16

	IRQ_DMA1_Stream6 = 17

	// Analog-to-digital converter
	IRQ_ADC = 18

	// Controller area network
	IRQ_CAN1_TX = 19

	// Controller area network
	IRQ_CAN1_RX0 = 20

	// Controller area network
	IRQ_CAN1_RX1 = 21

	// Controller area network
	IRQ_CAN1_SCE = 22

	// External interrupt/event controller
	IRQ_EXTI9_5 = 23

	// Advanced-timers
	IRQ_TIM1_BRK_TIM9 = 24

	// Advanced-timers
	IRQ_TIM1_UP_TIM10 = 25

	// Advanced-timers
	IRQ_TIM1_TRG_COM_TIM11 = 26

	// Advanced-timers
	IRQ_TIM1_CC = 27

	// General purpose timers
	IRQ_TIM2 = 28

	// General purpose timers
	IRQ_TIM3 = 29

	IRQ_TIM4 = 30

	// Inter-integrated circuit
	IRQ_I2C1_EV = 31

	// Inter-integrated circuit
	IRQ_I2C1_ER = 32

	// Inter-integrated circuit //
	IRQ_I2C2_EV = 33

	// Inter-integrated circuit //
	IRQ_I2C2_ER = 34

	// Serial peripheral interface
	IRQ_SPI1 = 35

	IRQ_SPI2 = 36

	// Universal synchronous asynchronous receiver transmitter
	IRQ_USART1 = 37

	IRQ_USART2 = 38

	IRQ_USART3 = 39

	// External interrupt/event controller
	IRQ_EXTI15_10 = 40

	// Real-time clock
	IRQ_RTC_ALARM = 41

	// USB on the go full speed
	IRQ_OTG_FS_WKUP = 42

	IRQ_TIM8_BRK_TIM12 = 43

	IRQ_TIM8_UP_TIM13 = 44

	IRQ_TIM8_TRG_COM_TIM14 = 45

	IRQ_TIM8_CC = 46

	IRQ_DMA1_Stream7 = 47

	// Flexible memory controller
	IRQ_FMC = 48

	// Secure digital input/output interface
	IRQ_SDMMC1 = 49

	// General purpose timers
	IRQ_TIM5 = 50

	IRQ_SPI3 = 51

	// Universal synchronous asynchronous receiver transmitter //
	IRQ_UART4 = 52

	IRQ_UART5 = 53

	// Basic timers
	IRQ_TIM6_DAC = 54

	IRQ_TIM7 = 55

	// DMA controller
	IRQ_DMA2_Stream0 = 56

	// DMA controller
	IRQ_DMA2_Stream1 = 57

	// DMA controller
	IRQ_DMA2_Stream2 = 58

	// DMA controller
	IRQ_DMA2_Stream3 = 59

	// DMA controller
	IRQ_DMA2_Stream4 = 60

	// Ethernet: media access control (MAC)
	IRQ_ETH = 61

	// Ethernet: media access control (MAC)
	IRQ_ETH_WKUP = 62

	IRQ_CAN2_TX = 63

	IRQ_CAN2_RX0 = 64

	IRQ_CAN2_RX1 = 65

	IRQ_CAN2_SCE = 66

	// USB on the go full speed
	IRQ_OTG_FS = 67

	// DMA controller
	IRQ_DMA2_Stream5 = 68

	// DMA controller
	IRQ_DMA2_Stream6 = 69

	// DMA controller
	IRQ_DMA2_Stream7 = 70

	// Universal synchronous asynchronous receiver transmitter //
	IRQ_USART6 = 71

	// Inter-integrated circuit //
	IRQ_I2C3_EV = 72

	// Inter-integrated circuit //
	IRQ_I2C3_ER = 73

	// USB on the go high speed
	IRQ_OTG_HS_EP1_OUT = 74

	// USB on the go high speed
	IRQ_OTG_HS_EP1_IN = 75

	// USB on the go high speed
	IRQ_OTG_HS_WKUP = 76

	// USB on the go high speed
	IRQ_OTG_HS = 77

	// Digital camera interface
	IRQ_DCMI = 78

	// Cryptographic processor
	IRQ_CRYP = 79

	// Random number generator
	IRQ_HASH_RNG = 80

	// Floting point unit
	IRQ_FPU = 81

	// Universal synchronous asynchronous receiver transmitter //
	IRQ_UART7 = 82

	IRQ_UART8 = 83

	IRQ_SPI4 = 84

	IRQ_SPI5 = 85

	IRQ_SPI6 = 86

	// Serial audio interface
	IRQ_SAI1 = 87

	// LCD-TFT Controller
	IRQ_LTDC = 88

	// LCD-TFT Controller
	IRQ_LCD_TFT_1 = 89

	// LCD-TFT Controller
	IRQ_LTDC_ER = 89

	// DMA2D controller
	IRQ_DMA2D = 90

	// Serial audio interface //
	IRQ_SAI2 = 91

	// QuadSPI interface
	IRQ_QuadSPI = 92

	// Low power timer
	IRQ_LPTimer1 = 93

	// Low power timer
	IRQ_LP_Timer1 = 93

	// Cryptographic processor // HDMI-CEC controller
	IRQ_HDMI_CEC = 94

	// Inter-integrated circuit //
	IRQ_I2C4_EV = 95

	// Inter-integrated circuit //
	IRQ_I2C4_ER = 96

	// Receiver Interface
	IRQ_SPDIFRX = 97

	// DSI Host
	IRQ_DSIHOST = 98

	// Digital filter for sigma delta modulators
	IRQ_DFSDM1_FLT0 = 99

	// Digital filter for sigma delta modulators
	IRQ_DFSDM1_FLT1 = 100

	// Digital filter for sigma delta modulators
	IRQ_DFSDM1_FLT2 = 101

	// Digital filter for sigma delta modulators
	IRQ_DFSDM1_FLT3 = 102

	IRQ_SDMMC2 = 103

	IRQ_CAN3_TX = 104

	IRQ_CAN3_RX0 = 105

	IRQ_CAN3_RX1 = 106

	IRQ_CAN3_SCE = 107

	// JPEG codec
	IRQ_JPEG = 108

	// Management data input/output slave
	IRQ_MDIOS = 109

	// Highest interrupt number on this device.
	IRQ_max = 109
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int)

//export WWDG_IRQHandler
func interruptWWDG() {
	callHandlers(IRQ_WWDG)
}

//export PVD_IRQHandler
func interruptPVD() {
	callHandlers(IRQ_PVD)
}

//export TAMP_STAMP_IRQHandler
func interruptTAMP_STAMP() {
	callHandlers(IRQ_TAMP_STAMP)
}

//export RTC_WKUP_IRQHandler
func interruptRTC_WKUP() {
	callHandlers(IRQ_RTC_WKUP)
}

//export FLASH_IRQHandler
func interruptFLASH() {
	callHandlers(IRQ_FLASH)
}

//export RCC_IRQHandler
func interruptRCC() {
	callHandlers(IRQ_RCC)
}

//export EXTI0_IRQHandler
func interruptEXTI0() {
	callHandlers(IRQ_EXTI0)
}

//export EXTI1_IRQHandler
func interruptEXTI1() {
	callHandlers(IRQ_EXTI1)
}

//export EXTI2_IRQHandler
func interruptEXTI2() {
	callHandlers(IRQ_EXTI2)
}

//export EXTI3_IRQHandler
func interruptEXTI3() {
	callHandlers(IRQ_EXTI3)
}

//export EXTI4_IRQHandler
func interruptEXTI4() {
	callHandlers(IRQ_EXTI4)
}

//export DMA1_Stream0_IRQHandler
func interruptDMA1_Stream0() {
	callHandlers(IRQ_DMA1_Stream0)
}

//export DMA1_Stream1_IRQHandler
func interruptDMA1_Stream1() {
	callHandlers(IRQ_DMA1_Stream1)
}

//export DMA1_Stream2_IRQHandler
func interruptDMA1_Stream2() {
	callHandlers(IRQ_DMA1_Stream2)
}

//export DMA1_Stream3_IRQHandler
func interruptDMA1_Stream3() {
	callHandlers(IRQ_DMA1_Stream3)
}

//export DMA1_Stream4_IRQHandler
func interruptDMA1_Stream4() {
	callHandlers(IRQ_DMA1_Stream4)
}

//export DMA1_Stream5_IRQHandler
func interruptDMA1_Stream5() {
	callHandlers(IRQ_DMA1_Stream5)
}

//export DMA1_Stream6_IRQHandler
func interruptDMA1_Stream6() {
	callHandlers(IRQ_DMA1_Stream6)
}

//export ADC_IRQHandler
func interruptADC() {
	callHandlers(IRQ_ADC)
}

//export CAN1_TX_IRQHandler
func interruptCAN1_TX() {
	callHandlers(IRQ_CAN1_TX)
}

//export CAN1_RX0_IRQHandler
func interruptCAN1_RX0() {
	callHandlers(IRQ_CAN1_RX0)
}

//export CAN1_RX1_IRQHandler
func interruptCAN1_RX1() {
	callHandlers(IRQ_CAN1_RX1)
}

//export CAN1_SCE_IRQHandler
func interruptCAN1_SCE() {
	callHandlers(IRQ_CAN1_SCE)
}

//export EXTI9_5_IRQHandler
func interruptEXTI9_5() {
	callHandlers(IRQ_EXTI9_5)
}

//export TIM1_BRK_TIM9_IRQHandler
func interruptTIM1_BRK_TIM9() {
	callHandlers(IRQ_TIM1_BRK_TIM9)
}

//export TIM1_UP_TIM10_IRQHandler
func interruptTIM1_UP_TIM10() {
	callHandlers(IRQ_TIM1_UP_TIM10)
}

//export TIM1_TRG_COM_TIM11_IRQHandler
func interruptTIM1_TRG_COM_TIM11() {
	callHandlers(IRQ_TIM1_TRG_COM_TIM11)
}

//export TIM1_CC_IRQHandler
func interruptTIM1_CC() {
	callHandlers(IRQ_TIM1_CC)
}

//export TIM2_IRQHandler
func interruptTIM2() {
	callHandlers(IRQ_TIM2)
}

//export TIM3_IRQHandler
func interruptTIM3() {
	callHandlers(IRQ_TIM3)
}

//export TIM4_IRQHandler
func interruptTIM4() {
	callHandlers(IRQ_TIM4)
}

//export I2C1_EV_IRQHandler
func interruptI2C1_EV() {
	callHandlers(IRQ_I2C1_EV)
}

//export I2C1_ER_IRQHandler
func interruptI2C1_ER() {
	callHandlers(IRQ_I2C1_ER)
}

//export I2C2_EV_IRQHandler
func interruptI2C2_EV() {
	callHandlers(IRQ_I2C2_EV)
}

//export I2C2_ER_IRQHandler
func interruptI2C2_ER() {
	callHandlers(IRQ_I2C2_ER)
}

//export SPI1_IRQHandler
func interruptSPI1() {
	callHandlers(IRQ_SPI1)
}

//export SPI2_IRQHandler
func interruptSPI2() {
	callHandlers(IRQ_SPI2)
}

//export USART1_IRQHandler
func interruptUSART1() {
	callHandlers(IRQ_USART1)
}

//export USART2_IRQHandler
func interruptUSART2() {
	callHandlers(IRQ_USART2)
}

//export USART3_IRQHandler
func interruptUSART3() {
	callHandlers(IRQ_USART3)
}

//export EXTI15_10_IRQHandler
func interruptEXTI15_10() {
	callHandlers(IRQ_EXTI15_10)
}

//export RTC_ALARM_IRQHandler
func interruptRTC_ALARM() {
	callHandlers(IRQ_RTC_ALARM)
}

//export OTG_FS_WKUP_IRQHandler
func interruptOTG_FS_WKUP() {
	callHandlers(IRQ_OTG_FS_WKUP)
}

//export TIM8_BRK_TIM12_IRQHandler
func interruptTIM8_BRK_TIM12() {
	callHandlers(IRQ_TIM8_BRK_TIM12)
}

//export TIM8_UP_TIM13_IRQHandler
func interruptTIM8_UP_TIM13() {
	callHandlers(IRQ_TIM8_UP_TIM13)
}

//export TIM8_TRG_COM_TIM14_IRQHandler
func interruptTIM8_TRG_COM_TIM14() {
	callHandlers(IRQ_TIM8_TRG_COM_TIM14)
}

//export TIM8_CC_IRQHandler
func interruptTIM8_CC() {
	callHandlers(IRQ_TIM8_CC)
}

//export DMA1_Stream7_IRQHandler
func interruptDMA1_Stream7() {
	callHandlers(IRQ_DMA1_Stream7)
}

//export FMC_IRQHandler
func interruptFMC() {
	callHandlers(IRQ_FMC)
}

//export SDMMC1_IRQHandler
func interruptSDMMC1() {
	callHandlers(IRQ_SDMMC1)
}

//export TIM5_IRQHandler
func interruptTIM5() {
	callHandlers(IRQ_TIM5)
}

//export SPI3_IRQHandler
func interruptSPI3() {
	callHandlers(IRQ_SPI3)
}

//export UART4_IRQHandler
func interruptUART4() {
	callHandlers(IRQ_UART4)
}

//export UART5_IRQHandler
func interruptUART5() {
	callHandlers(IRQ_UART5)
}

//export TIM6_DAC_IRQHandler
func interruptTIM6_DAC() {
	callHandlers(IRQ_TIM6_DAC)
}

//export TIM7_IRQHandler
func interruptTIM7() {
	callHandlers(IRQ_TIM7)
}

//export DMA2_Stream0_IRQHandler
func interruptDMA2_Stream0() {
	callHandlers(IRQ_DMA2_Stream0)
}

//export DMA2_Stream1_IRQHandler
func interruptDMA2_Stream1() {
	callHandlers(IRQ_DMA2_Stream1)
}

//export DMA2_Stream2_IRQHandler
func interruptDMA2_Stream2() {
	callHandlers(IRQ_DMA2_Stream2)
}

//export DMA2_Stream3_IRQHandler
func interruptDMA2_Stream3() {
	callHandlers(IRQ_DMA2_Stream3)
}

//export DMA2_Stream4_IRQHandler
func interruptDMA2_Stream4() {
	callHandlers(IRQ_DMA2_Stream4)
}

//export ETH_IRQHandler
func interruptETH() {
	callHandlers(IRQ_ETH)
}

//export ETH_WKUP_IRQHandler
func interruptETH_WKUP() {
	callHandlers(IRQ_ETH_WKUP)
}

//export CAN2_TX_IRQHandler
func interruptCAN2_TX() {
	callHandlers(IRQ_CAN2_TX)
}

//export CAN2_RX0_IRQHandler
func interruptCAN2_RX0() {
	callHandlers(IRQ_CAN2_RX0)
}

//export CAN2_RX1_IRQHandler
func interruptCAN2_RX1() {
	callHandlers(IRQ_CAN2_RX1)
}

//export CAN2_SCE_IRQHandler
func interruptCAN2_SCE() {
	callHandlers(IRQ_CAN2_SCE)
}

//export OTG_FS_IRQHandler
func interruptOTG_FS() {
	callHandlers(IRQ_OTG_FS)
}

//export DMA2_Stream5_IRQHandler
func interruptDMA2_Stream5() {
	callHandlers(IRQ_DMA2_Stream5)
}

//export DMA2_Stream6_IRQHandler
func interruptDMA2_Stream6() {
	callHandlers(IRQ_DMA2_Stream6)
}

//export DMA2_Stream7_IRQHandler
func interruptDMA2_Stream7() {
	callHandlers(IRQ_DMA2_Stream7)
}

//export USART6_IRQHandler
func interruptUSART6() {
	callHandlers(IRQ_USART6)
}

//export I2C3_EV_IRQHandler
func interruptI2C3_EV() {
	callHandlers(IRQ_I2C3_EV)
}

//export I2C3_ER_IRQHandler
func interruptI2C3_ER() {
	callHandlers(IRQ_I2C3_ER)
}

//export OTG_HS_EP1_OUT_IRQHandler
func interruptOTG_HS_EP1_OUT() {
	callHandlers(IRQ_OTG_HS_EP1_OUT)
}

//export OTG_HS_EP1_IN_IRQHandler
func interruptOTG_HS_EP1_IN() {
	callHandlers(IRQ_OTG_HS_EP1_IN)
}

//export OTG_HS_WKUP_IRQHandler
func interruptOTG_HS_WKUP() {
	callHandlers(IRQ_OTG_HS_WKUP)
}

//export OTG_HS_IRQHandler
func interruptOTG_HS() {
	callHandlers(IRQ_OTG_HS)
}

//export DCMI_IRQHandler
func interruptDCMI() {
	callHandlers(IRQ_DCMI)
}

//export CRYP_IRQHandler
func interruptCRYP() {
	callHandlers(IRQ_CRYP)
}

//export HASH_RNG_IRQHandler
func interruptHASH_RNG() {
	callHandlers(IRQ_HASH_RNG)
}

//export FPU_IRQHandler
func interruptFPU() {
	callHandlers(IRQ_FPU)
}

//export UART7_IRQHandler
func interruptUART7() {
	callHandlers(IRQ_UART7)
}

//export UART8_IRQHandler
func interruptUART8() {
	callHandlers(IRQ_UART8)
}

//export SPI4_IRQHandler
func interruptSPI4() {
	callHandlers(IRQ_SPI4)
}

//export SPI5_IRQHandler
func interruptSPI5() {
	callHandlers(IRQ_SPI5)
}

//export SPI6_IRQHandler
func interruptSPI6() {
	callHandlers(IRQ_SPI6)
}

//export SAI1_IRQHandler
func interruptSAI1() {
	callHandlers(IRQ_SAI1)
}

//export LTDC_IRQHandler
func interruptLTDC() {
	callHandlers(IRQ_LTDC)
}

//export LCD_TFT_1_IRQHandler
func interruptLCD_TFT_1() {
	callHandlers(IRQ_LCD_TFT_1)
}

//export LTDC_ER_IRQHandler
func interruptLTDC_ER() {
	callHandlers(IRQ_LTDC_ER)
}

//export DMA2D_IRQHandler
func interruptDMA2D() {
	callHandlers(IRQ_DMA2D)
}

//export SAI2_IRQHandler
func interruptSAI2() {
	callHandlers(IRQ_SAI2)
}

//export QuadSPI_IRQHandler
func interruptQuadSPI() {
	callHandlers(IRQ_QuadSPI)
}

//export LPTimer1_IRQHandler
func interruptLPTimer1() {
	callHandlers(IRQ_LPTimer1)
}

//export LP_Timer1_IRQHandler
func interruptLP_Timer1() {
	callHandlers(IRQ_LP_Timer1)
}

//export HDMI_CEC_IRQHandler
func interruptHDMI_CEC() {
	callHandlers(IRQ_HDMI_CEC)
}

//export I2C4_EV_IRQHandler
func interruptI2C4_EV() {
	callHandlers(IRQ_I2C4_EV)
}

//export I2C4_ER_IRQHandler
func interruptI2C4_ER() {
	callHandlers(IRQ_I2C4_ER)
}

//export SPDIFRX_IRQHandler
func interruptSPDIFRX() {
	callHandlers(IRQ_SPDIFRX)
}

//export DSIHOST_IRQHandler
func interruptDSIHOST() {
	callHandlers(IRQ_DSIHOST)
}

//export DFSDM1_FLT0_IRQHandler
func interruptDFSDM1_FLT0() {
	callHandlers(IRQ_DFSDM1_FLT0)
}

//export DFSDM1_FLT1_IRQHandler
func interruptDFSDM1_FLT1() {
	callHandlers(IRQ_DFSDM1_FLT1)
}

//export DFSDM1_FLT2_IRQHandler
func interruptDFSDM1_FLT2() {
	callHandlers(IRQ_DFSDM1_FLT2)
}

//export DFSDM1_FLT3_IRQHandler
func interruptDFSDM1_FLT3() {
	callHandlers(IRQ_DFSDM1_FLT3)
}

//export SDMMC2_IRQHandler
func interruptSDMMC2() {
	callHandlers(IRQ_SDMMC2)
}

//export CAN3_TX_IRQHandler
func interruptCAN3_TX() {
	callHandlers(IRQ_CAN3_TX)
}

//export CAN3_RX0_IRQHandler
func interruptCAN3_RX0() {
	callHandlers(IRQ_CAN3_RX0)
}

//export CAN3_RX1_IRQHandler
func interruptCAN3_RX1() {
	callHandlers(IRQ_CAN3_RX1)
}

//export CAN3_SCE_IRQHandler
func interruptCAN3_SCE() {
	callHandlers(IRQ_CAN3_SCE)
}

//export JPEG_IRQHandler
func interruptJPEG() {
	callHandlers(IRQ_JPEG)
}

//export MDIOS_IRQHandler
func interruptMDIOS() {
	callHandlers(IRQ_MDIOS)
}

// Peripherals.
var (
	// Random number generator
	RNG = (*RNG_Type)(unsafe.Pointer(uintptr(0x50060800)))

	// Hash processor
	HASH = (*HASH_Type)(unsafe.Pointer(uintptr(0x50060400)))

	// Cryptographic processor
	CRYP = (*CRYP_Type)(unsafe.Pointer(uintptr(0x50060000)))

	// Digital camera interface
	DCMI = (*DCMI_Type)(unsafe.Pointer(uintptr(0x50050000)))

	// Flexible memory controller
	FMC = (*FSMC_Type)(unsafe.Pointer(uintptr(0xa0000000)))

	// DMA controller
	DMA2 = (*DMA_Type)(unsafe.Pointer(uintptr(0x40026400)))

	// Reset and clock control
	RCC = (*RCC_Type)(unsafe.Pointer(uintptr(0x40023800)))

	// General-purpose I/Os
	GPIOD = (*GPIO_Type)(unsafe.Pointer(uintptr(0x40020c00)))

	// General-purpose I/Os
	GPIOB = (*GPIO_Type)(unsafe.Pointer(uintptr(0x40020400)))

	// General-purpose I/Os
	GPIOA = (*GPIO_Type)(unsafe.Pointer(uintptr(0x40020000)))

	// System configuration controller
	SYSCFG = (*SYSCFG_Type)(unsafe.Pointer(uintptr(0x40013800)))

	// Serial peripheral interface
	SPI1 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40013000)))

	// Analog-to-digital converter
	ADC1 = (*ADC_Type)(unsafe.Pointer(uintptr(0x40012000)))

	// Digital-to-analog converter
	DAC = (*DAC_Type)(unsafe.Pointer(uintptr(0x40007400)))

	// Power control
	PWR = (*PWR_Type)(unsafe.Pointer(uintptr(0x40007000)))

	// Independent watchdog
	IWDG = (*IWDG_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// Window watchdog
	WWDG = (*WWDG_Type)(unsafe.Pointer(uintptr(0x40002c00)))

	// Advanced-timers
	TIM1 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40010000)))

	// General purpose timers
	TIM2 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// General purpose timers
	TIM3 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40000400)))

	// General purpose timers
	TIM9 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40014000)))

	// General-purpose-timers
	TIM10 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40014400)))

	// Basic timers
	TIM6 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40001000)))

	// Ethernet: media access control (MAC)
	Ethernet_MAC = (*Ethernet_Type)(unsafe.Pointer(uintptr(0x40028000)))

	// Cryptographic processor
	CRC = (*CRC_Type)(unsafe.Pointer(uintptr(0x40023000)))

	// Controller area network
	CAN1 = (*CAN_Type)(unsafe.Pointer(uintptr(0x40006400)))

	// FLASH
	FLASH = (*FLASH_Type)(unsafe.Pointer(uintptr(0x40023c00)))

	// External interrupt/event controller
	EXTI = (*EXTI_Type)(unsafe.Pointer(uintptr(0x40013c00)))

	// LCD-TFT Controller
	LTDC = (*LTDC_Type)(unsafe.Pointer(uintptr(0x40016800)))

	// Serial audio interface
	SAI1 = (*SAI_Type)(unsafe.Pointer(uintptr(0x40015800)))

	// DMA2D controller
	DMA2D = (*DMA2D_Type)(unsafe.Pointer(uintptr(0x4002b000)))

	// QuadSPI interface
	QUADSPI = (*QUADSPI_Type)(unsafe.Pointer(uintptr(0xa0001000)))

	// HDMI-CEC controller
	CEC = (*CEC_Type)(unsafe.Pointer(uintptr(0x40006c00)))

	// Receiver Interface
	SPDIFRX = (*SPDIF_RX_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// Secure digital input/output interface
	SDMMC1 = (*SDMMC_Type)(unsafe.Pointer(uintptr(0x40012c00)))

	// Low power timer
	LPTIM1 = (*LPTIM_Type)(unsafe.Pointer(uintptr(0x40002400)))

	// Inter-integrated circuit
	I2C1 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40005400)))

	// Real-time clock
	RTC = (*RTC_Type)(unsafe.Pointer(uintptr(0x40002800)))

	// Universal synchronous asynchronous receiver transmitter
	USART1 = (*USART_Type)(unsafe.Pointer(uintptr(0x40011000)))

	// USB on the go full speed
	OTG_FS_GLOBAL = (*USB_OTG_FS_Type)(unsafe.Pointer(uintptr(0x50000000)))

	// USB on the go high speed
	OTG_HS_GLOBAL = (*USB_OTG_HS_Type)(unsafe.Pointer(uintptr(0x40040000)))

	// Management data input/output slave
	MDIOS = (*MDIOS_Type)(unsafe.Pointer(uintptr(0x40017800)))

	// Digital filter for sigma delta modulators
	DFSDM = (*DFSDM_Type)(unsafe.Pointer(uintptr(0x40017400)))

	// JPEG codec
	JPEG = (*JPEG_Type)(unsafe.Pointer(uintptr(0x50051000)))

	// Ethernet: MAC management counters
	Ethernet_MMC = (*Ethernet_Type)(unsafe.Pointer(uintptr(0x40028100)))

	// Ethernet: Precision time protocol
	Ethernet_PTP = (*Ethernet_Type)(unsafe.Pointer(uintptr(0x40028700)))

	// Ethernet: DMA controller operation
	Ethernet_DMA = (*Ethernet_Type)(unsafe.Pointer(uintptr(0x40029000)))

	// USB on the go full speed
	OTG_FS_HOST = (*USB_OTG_FS_Type)(unsafe.Pointer(uintptr(0x50000400)))

	// USB on the go full speed
	OTG_FS_DEVICE = (*USB_OTG_FS_Type)(unsafe.Pointer(uintptr(0x50000800)))

	// USB on the go full speed
	OTG_FS_PWRCLK = (*USB_OTG_FS_Type)(unsafe.Pointer(uintptr(0x50000e00)))

	// USB on the go high speed
	OTG_HS_HOST = (*USB_OTG_HS_Type)(unsafe.Pointer(uintptr(0x40040400)))

	// USB on the go high speed
	OTG_HS_DEVICE = (*USB_OTG_HS_Type)(unsafe.Pointer(uintptr(0x40040800)))

	// USB on the go high speed
	OTG_HS_PWRCLK = (*USB_OTG_HS_Type)(unsafe.Pointer(uintptr(0x40040e00)))

	// DSI Host
	DSI = (*DSI_Type)(unsafe.Pointer(uintptr(0x40016c00)))

	// Nested Vectored Interrupt Controller
	NVIC = (*NVIC_Type)(unsafe.Pointer(uintptr(0xe000e100)))

	// Memory protection unit
	MPU = (*MPU_Type)(unsafe.Pointer(uintptr(0xe000ed90)))

	// SysTick timer
	STK = (*STK_Type)(unsafe.Pointer(uintptr(0xe000e010)))

	// Nested vectored interrupt controller
	NVIC_STIR = (*NVIC_Type)(unsafe.Pointer(uintptr(0xe000ef00)))

	// Floating point unit CPACR
	FPU_CPACR = (*FPU_Type)(unsafe.Pointer(uintptr(0xe000ed88)))

	// System control block ACTLR
	SCB_ACTRL = (*SCB_Type)(unsafe.Pointer(uintptr(0xe000e008)))

	// Floting point unit
	FPU = (*FPU_Type)(unsafe.Pointer(uintptr(0xe000ef34)))

	// System control block
	SCB = (*SCB_Type)(unsafe.Pointer(uintptr(0xe000ed00)))

	// Processor features
	PF = (*PF_Type)(unsafe.Pointer(uintptr(0xe000ed78)))

	// Access control
	AC = (*AC_Type)(unsafe.Pointer(uintptr(0xe000ef90)))

	// General purpose timers
	TIM5 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40000c00)))

	// ADC common registers
	ADC_Common = (*ADC_Type)(unsafe.Pointer(uintptr(0x40012300)))

	// Debug support
	DBGMCU = (*DBGMCU_Type)(unsafe.Pointer(uintptr(0xe0042000)))

	// DMA controller
	DMA1 = (*DMA_Type)(unsafe.Pointer(uintptr(0x40026000)))

	// General-purpose I/Os
	GPIOC = (*GPIO_Type)(unsafe.Pointer(uintptr(0x40020800)))

	// General-purpose I/Os
	GPIOK = (*GPIO_Type)(unsafe.Pointer(uintptr(0x40022800)))

	// General-purpose I/Os
	GPIOJ = (*GPIO_Type)(unsafe.Pointer(uintptr(0x40022400)))

	// General-purpose I/Os
	GPIOI = (*GPIO_Type)(unsafe.Pointer(uintptr(0x40022000)))

	// General-purpose I/Os
	GPIOH = (*GPIO_Type)(unsafe.Pointer(uintptr(0x40021c00)))

	// General-purpose I/Os
	GPIOG = (*GPIO_Type)(unsafe.Pointer(uintptr(0x40021800)))

	// General-purpose I/Os
	GPIOF = (*GPIO_Type)(unsafe.Pointer(uintptr(0x40021400)))

	// General-purpose I/Os
	GPIOE = (*GPIO_Type)(unsafe.Pointer(uintptr(0x40021000)))

	// Serial peripheral interface
	SPI2 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40003800)))

	// Serial peripheral interface
	SPI3 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40003c00)))

	// Serial peripheral interface
	SPI4 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40013400)))

	// Serial peripheral interface
	SPI5 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40015000)))

	// Serial peripheral interface
	SPI6 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40015400)))

	// Analog-to-digital converter
	ADC2 = (*ADC_Type)(unsafe.Pointer(uintptr(0x40012100)))

	// Analog-to-digital converter
	ADC3 = (*ADC_Type)(unsafe.Pointer(uintptr(0x40012200)))

	// Advanced-timers
	TIM8 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40010400)))

	// General purpose timers
	TIM4 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40000800)))

	// General purpose timers
	TIM12 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40001800)))

	// General-purpose-timers
	TIM11 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40014800)))

	// General-purpose-timers
	TIM13 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40001c00)))

	// General-purpose-timers
	TIM14 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40002000)))

	// Basic timers
	TIM7 = (*TIM_Type)(unsafe.Pointer(uintptr(0x40001400)))

	// Controller area network
	CAN2 = (*CAN_Type)(unsafe.Pointer(uintptr(0x40006800)))

	// Controller area network
	CAN3 = (*CAN_Type)(unsafe.Pointer(uintptr(0x40003400)))

	// Serial audio interface
	SAI2 = (*SAI_Type)(unsafe.Pointer(uintptr(0x40015c00)))

	// Secure digital input/output interface
	SDMMC2 = (*SDMMC_Type)(unsafe.Pointer(uintptr(0x40011c00)))

	// Inter-integrated circuit
	I2C2 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40005800)))

	// Inter-integrated circuit
	I2C3 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40005c00)))

	// Inter-integrated circuit
	I2C4 = (*I2C_Type)(unsafe.Pointer(uintptr(0x40006000)))

	// Universal synchronous asynchronous receiver transmitter
	USART6 = (*USART_Type)(unsafe.Pointer(uintptr(0x40011400)))

	// Universal synchronous asynchronous receiver transmitter
	USART3 = (*USART_Type)(unsafe.Pointer(uintptr(0x40004800)))

	// Universal synchronous asynchronous receiver transmitter
	USART2 = (*USART_Type)(unsafe.Pointer(uintptr(0x40004400)))

	// Universal synchronous asynchronous receiver transmitter
	UART5 = (*USART_Type)(unsafe.Pointer(uintptr(0x40005000)))

	// Universal synchronous asynchronous receiver transmitter
	UART4 = (*USART_Type)(unsafe.Pointer(uintptr(0x40004c00)))

	// Universal synchronous asynchronous receiver transmitter
	UART8 = (*USART_Type)(unsafe.Pointer(uintptr(0x40007c00)))

	// Universal synchronous asynchronous receiver transmitter
	UART7 = (*USART_Type)(unsafe.Pointer(uintptr(0x40007800)))
)

// Random number generator
type RNG_Type struct {
	CR volatile.Register32 // 0x0
	SR volatile.Register32 // 0x4
	DR volatile.Register32 // 0x8
}

// RNG.CR: control register
func (o *RNG_Type) SetCR_IE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *RNG_Type) GetCR_IE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *RNG_Type) SetCR_RNGEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *RNG_Type) GetCR_RNGEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}

// RNG.SR: status register
func (o *RNG_Type) SetSR_SEIS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *RNG_Type) GetSR_SEIS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *RNG_Type) SetSR_CEIS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *RNG_Type) GetSR_CEIS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *RNG_Type) SetSR_SECS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *RNG_Type) GetSR_SECS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *RNG_Type) SetSR_CECS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *RNG_Type) GetSR_CECS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *RNG_Type) SetSR_DRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *RNG_Type) GetSR_DRDY() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// RNG.DR: data register
func (o *RNG_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, value)
}
func (o *RNG_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg)
}

// Hash processor
type HASH_Type struct {
	CR       volatile.Register32 // 0x0
	DIN      volatile.Register32 // 0x4
	STR      volatile.Register32 // 0x8
	HR0      volatile.Register32 // 0xC
	HR1      volatile.Register32 // 0x10
	HR2      volatile.Register32 // 0x14
	HR3      volatile.Register32 // 0x18
	HR4      volatile.Register32 // 0x1C
	IMR      volatile.Register32 // 0x20
	SR       volatile.Register32 // 0x24
	_        [208]byte
	CSR0     volatile.Register32 // 0xF8
	CSR1     volatile.Register32 // 0xFC
	CSR2     volatile.Register32 // 0x100
	CSR3     volatile.Register32 // 0x104
	CSR4     volatile.Register32 // 0x108
	CSR5     volatile.Register32 // 0x10C
	CSR6     volatile.Register32 // 0x110
	CSR7     volatile.Register32 // 0x114
	CSR8     volatile.Register32 // 0x118
	CSR9     volatile.Register32 // 0x11C
	CSR10    volatile.Register32 // 0x120
	CSR11    volatile.Register32 // 0x124
	CSR12    volatile.Register32 // 0x128
	CSR13    volatile.Register32 // 0x12C
	CSR14    volatile.Register32 // 0x130
	CSR15    volatile.Register32 // 0x134
	CSR16    volatile.Register32 // 0x138
	CSR17    volatile.Register32 // 0x13C
	CSR18    volatile.Register32 // 0x140
	CSR19    volatile.Register32 // 0x144
	CSR20    volatile.Register32 // 0x148
	CSR21    volatile.Register32 // 0x14C
	CSR22    volatile.Register32 // 0x150
	CSR23    volatile.Register32 // 0x154
	CSR24    volatile.Register32 // 0x158
	CSR25    volatile.Register32 // 0x15C
	CSR26    volatile.Register32 // 0x160
	CSR27    volatile.Register32 // 0x164
	CSR28    volatile.Register32 // 0x168
	CSR29    volatile.Register32 // 0x16C
	CSR30    volatile.Register32 // 0x170
	CSR31    volatile.Register32 // 0x174
	CSR32    volatile.Register32 // 0x178
	CSR33    volatile.Register32 // 0x17C
	CSR34    volatile.Register32 // 0x180
	CSR35    volatile.Register32 // 0x184
	CSR36    volatile.Register32 // 0x188
	CSR37    volatile.Register32 // 0x18C
	CSR38    volatile.Register32 // 0x190
	CSR39    volatile.Register32 // 0x194
	CSR40    volatile.Register32 // 0x198
	CSR41    volatile.Register32 // 0x19C
	CSR42    volatile.Register32 // 0x1A0
	CSR43    volatile.Register32 // 0x1A4
	CSR44    volatile.Register32 // 0x1A8
	CSR45    volatile.Register32 // 0x1AC
	CSR46    volatile.Register32 // 0x1B0
	CSR47    volatile.Register32 // 0x1B4
	CSR48    volatile.Register32 // 0x1B8
	CSR49    volatile.Register32 // 0x1BC
	CSR50    volatile.Register32 // 0x1C0
	CSR51    volatile.Register32 // 0x1C4
	CSR52    volatile.Register32 // 0x1C8
	CSR53    volatile.Register32 // 0x1CC
	_        [320]byte
	HASH_HR0 volatile.Register32 // 0x310
	HASH_HR1 volatile.Register32 // 0x314
	HASH_HR2 volatile.Register32 // 0x318
	HASH_HR3 volatile.Register32 // 0x31C
	HASH_HR4 volatile.Register32 // 0x320
	HASH_HR5 volatile.Register32 // 0x324
	HASH_HR6 volatile.Register32 // 0x328
	HASH_HR7 volatile.Register32 // 0x32C
}

// HASH.CR: control register
func (o *HASH_Type) SetCR_INIT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *HASH_Type) GetCR_INIT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *HASH_Type) SetCR_DMAE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *HASH_Type) GetCR_DMAE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *HASH_Type) SetCR_DATATYPE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x30)|value<<4)
}
func (o *HASH_Type) GetCR_DATATYPE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x30) >> 4
}
func (o *HASH_Type) SetCR_MODE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *HASH_Type) GetCR_MODE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *HASH_Type) SetCR_ALGO0(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *HASH_Type) GetCR_ALGO0() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *HASH_Type) SetCR_NBW(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf00)|value<<8)
}
func (o *HASH_Type) GetCR_NBW() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf00) >> 8
}
func (o *HASH_Type) SetCR_DINNE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *HASH_Type) GetCR_DINNE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *HASH_Type) SetCR_MDMAT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *HASH_Type) GetCR_MDMAT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *HASH_Type) SetCR_LKEY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *HASH_Type) GetCR_LKEY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *HASH_Type) SetCR_ALGO1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *HASH_Type) GetCR_ALGO1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}

// HASH.DIN: data input register
func (o *HASH_Type) SetDIN(value uint32) {
	volatile.StoreUint32(&o.DIN.Reg, value)
}
func (o *HASH_Type) GetDIN() uint32 {
	return volatile.LoadUint32(&o.DIN.Reg)
}

// HASH.STR: start register
func (o *HASH_Type) SetSTR_DCAL(value uint32) {
	volatile.StoreUint32(&o.STR.Reg, volatile.LoadUint32(&o.STR.Reg)&^(0x100)|value<<8)
}
func (o *HASH_Type) GetSTR_DCAL() uint32 {
	return (volatile.LoadUint32(&o.STR.Reg) & 0x100) >> 8
}
func (o *HASH_Type) SetSTR_NBLW(value uint32) {
	volatile.StoreUint32(&o.STR.Reg, volatile.LoadUint32(&o.STR.Reg)&^(0x1f)|value)
}
func (o *HASH_Type) GetSTR_NBLW() uint32 {
	return volatile.LoadUint32(&o.STR.Reg) & 0x1f
}

// HASH.HR0: digest registers
func (o *HASH_Type) SetHR0(value uint32) {
	volatile.StoreUint32(&o.HR0.Reg, value)
}
func (o *HASH_Type) GetHR0() uint32 {
	return volatile.LoadUint32(&o.HR0.Reg)
}

// HASH.HR1: digest registers
func (o *HASH_Type) SetHR1(value uint32) {
	volatile.StoreUint32(&o.HR1.Reg, value)
}
func (o *HASH_Type) GetHR1() uint32 {
	return volatile.LoadUint32(&o.HR1.Reg)
}

// HASH.HR2: digest registers
func (o *HASH_Type) SetHR2(value uint32) {
	volatile.StoreUint32(&o.HR2.Reg, value)
}
func (o *HASH_Type) GetHR2() uint32 {
	return volatile.LoadUint32(&o.HR2.Reg)
}

// HASH.HR3: digest registers
func (o *HASH_Type) SetHR3(value uint32) {
	volatile.StoreUint32(&o.HR3.Reg, value)
}
func (o *HASH_Type) GetHR3() uint32 {
	return volatile.LoadUint32(&o.HR3.Reg)
}

// HASH.HR4: digest registers
func (o *HASH_Type) SetHR4(value uint32) {
	volatile.StoreUint32(&o.HR4.Reg, value)
}
func (o *HASH_Type) GetHR4() uint32 {
	return volatile.LoadUint32(&o.HR4.Reg)
}

// HASH.IMR: interrupt enable register
func (o *HASH_Type) SetIMR_DCIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *HASH_Type) GetIMR_DCIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *HASH_Type) SetIMR_DINIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *HASH_Type) GetIMR_DINIE() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}

// HASH.SR: status register
func (o *HASH_Type) SetSR_BUSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *HASH_Type) GetSR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *HASH_Type) SetSR_DMAS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *HASH_Type) GetSR_DMAS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *HASH_Type) SetSR_DCIS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *HASH_Type) GetSR_DCIS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *HASH_Type) SetSR_DINIS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *HASH_Type) GetSR_DINIS() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// HASH.CSR0: context swap registers
func (o *HASH_Type) SetCSR0(value uint32) {
	volatile.StoreUint32(&o.CSR0.Reg, value)
}
func (o *HASH_Type) GetCSR0() uint32 {
	return volatile.LoadUint32(&o.CSR0.Reg)
}

// HASH.CSR1: context swap registers
func (o *HASH_Type) SetCSR1(value uint32) {
	volatile.StoreUint32(&o.CSR1.Reg, value)
}
func (o *HASH_Type) GetCSR1() uint32 {
	return volatile.LoadUint32(&o.CSR1.Reg)
}

// HASH.CSR2: context swap registers
func (o *HASH_Type) SetCSR2(value uint32) {
	volatile.StoreUint32(&o.CSR2.Reg, value)
}
func (o *HASH_Type) GetCSR2() uint32 {
	return volatile.LoadUint32(&o.CSR2.Reg)
}

// HASH.CSR3: context swap registers
func (o *HASH_Type) SetCSR3(value uint32) {
	volatile.StoreUint32(&o.CSR3.Reg, value)
}
func (o *HASH_Type) GetCSR3() uint32 {
	return volatile.LoadUint32(&o.CSR3.Reg)
}

// HASH.CSR4: context swap registers
func (o *HASH_Type) SetCSR4(value uint32) {
	volatile.StoreUint32(&o.CSR4.Reg, value)
}
func (o *HASH_Type) GetCSR4() uint32 {
	return volatile.LoadUint32(&o.CSR4.Reg)
}

// HASH.CSR5: context swap registers
func (o *HASH_Type) SetCSR5(value uint32) {
	volatile.StoreUint32(&o.CSR5.Reg, value)
}
func (o *HASH_Type) GetCSR5() uint32 {
	return volatile.LoadUint32(&o.CSR5.Reg)
}

// HASH.CSR6: context swap registers
func (o *HASH_Type) SetCSR6(value uint32) {
	volatile.StoreUint32(&o.CSR6.Reg, value)
}
func (o *HASH_Type) GetCSR6() uint32 {
	return volatile.LoadUint32(&o.CSR6.Reg)
}

// HASH.CSR7: context swap registers
func (o *HASH_Type) SetCSR7(value uint32) {
	volatile.StoreUint32(&o.CSR7.Reg, value)
}
func (o *HASH_Type) GetCSR7() uint32 {
	return volatile.LoadUint32(&o.CSR7.Reg)
}

// HASH.CSR8: context swap registers
func (o *HASH_Type) SetCSR8(value uint32) {
	volatile.StoreUint32(&o.CSR8.Reg, value)
}
func (o *HASH_Type) GetCSR8() uint32 {
	return volatile.LoadUint32(&o.CSR8.Reg)
}

// HASH.CSR9: context swap registers
func (o *HASH_Type) SetCSR9(value uint32) {
	volatile.StoreUint32(&o.CSR9.Reg, value)
}
func (o *HASH_Type) GetCSR9() uint32 {
	return volatile.LoadUint32(&o.CSR9.Reg)
}

// HASH.CSR10: context swap registers
func (o *HASH_Type) SetCSR10(value uint32) {
	volatile.StoreUint32(&o.CSR10.Reg, value)
}
func (o *HASH_Type) GetCSR10() uint32 {
	return volatile.LoadUint32(&o.CSR10.Reg)
}

// HASH.CSR11: context swap registers
func (o *HASH_Type) SetCSR11(value uint32) {
	volatile.StoreUint32(&o.CSR11.Reg, value)
}
func (o *HASH_Type) GetCSR11() uint32 {
	return volatile.LoadUint32(&o.CSR11.Reg)
}

// HASH.CSR12: context swap registers
func (o *HASH_Type) SetCSR12(value uint32) {
	volatile.StoreUint32(&o.CSR12.Reg, value)
}
func (o *HASH_Type) GetCSR12() uint32 {
	return volatile.LoadUint32(&o.CSR12.Reg)
}

// HASH.CSR13: context swap registers
func (o *HASH_Type) SetCSR13(value uint32) {
	volatile.StoreUint32(&o.CSR13.Reg, value)
}
func (o *HASH_Type) GetCSR13() uint32 {
	return volatile.LoadUint32(&o.CSR13.Reg)
}

// HASH.CSR14: context swap registers
func (o *HASH_Type) SetCSR14(value uint32) {
	volatile.StoreUint32(&o.CSR14.Reg, value)
}
func (o *HASH_Type) GetCSR14() uint32 {
	return volatile.LoadUint32(&o.CSR14.Reg)
}

// HASH.CSR15: context swap registers
func (o *HASH_Type) SetCSR15(value uint32) {
	volatile.StoreUint32(&o.CSR15.Reg, value)
}
func (o *HASH_Type) GetCSR15() uint32 {
	return volatile.LoadUint32(&o.CSR15.Reg)
}

// HASH.CSR16: context swap registers
func (o *HASH_Type) SetCSR16(value uint32) {
	volatile.StoreUint32(&o.CSR16.Reg, value)
}
func (o *HASH_Type) GetCSR16() uint32 {
	return volatile.LoadUint32(&o.CSR16.Reg)
}

// HASH.CSR17: context swap registers
func (o *HASH_Type) SetCSR17(value uint32) {
	volatile.StoreUint32(&o.CSR17.Reg, value)
}
func (o *HASH_Type) GetCSR17() uint32 {
	return volatile.LoadUint32(&o.CSR17.Reg)
}

// HASH.CSR18: context swap registers
func (o *HASH_Type) SetCSR18(value uint32) {
	volatile.StoreUint32(&o.CSR18.Reg, value)
}
func (o *HASH_Type) GetCSR18() uint32 {
	return volatile.LoadUint32(&o.CSR18.Reg)
}

// HASH.CSR19: context swap registers
func (o *HASH_Type) SetCSR19(value uint32) {
	volatile.StoreUint32(&o.CSR19.Reg, value)
}
func (o *HASH_Type) GetCSR19() uint32 {
	return volatile.LoadUint32(&o.CSR19.Reg)
}

// HASH.CSR20: context swap registers
func (o *HASH_Type) SetCSR20(value uint32) {
	volatile.StoreUint32(&o.CSR20.Reg, value)
}
func (o *HASH_Type) GetCSR20() uint32 {
	return volatile.LoadUint32(&o.CSR20.Reg)
}

// HASH.CSR21: context swap registers
func (o *HASH_Type) SetCSR21(value uint32) {
	volatile.StoreUint32(&o.CSR21.Reg, value)
}
func (o *HASH_Type) GetCSR21() uint32 {
	return volatile.LoadUint32(&o.CSR21.Reg)
}

// HASH.CSR22: context swap registers
func (o *HASH_Type) SetCSR22(value uint32) {
	volatile.StoreUint32(&o.CSR22.Reg, value)
}
func (o *HASH_Type) GetCSR22() uint32 {
	return volatile.LoadUint32(&o.CSR22.Reg)
}

// HASH.CSR23: context swap registers
func (o *HASH_Type) SetCSR23(value uint32) {
	volatile.StoreUint32(&o.CSR23.Reg, value)
}
func (o *HASH_Type) GetCSR23() uint32 {
	return volatile.LoadUint32(&o.CSR23.Reg)
}

// HASH.CSR24: context swap registers
func (o *HASH_Type) SetCSR24(value uint32) {
	volatile.StoreUint32(&o.CSR24.Reg, value)
}
func (o *HASH_Type) GetCSR24() uint32 {
	return volatile.LoadUint32(&o.CSR24.Reg)
}

// HASH.CSR25: context swap registers
func (o *HASH_Type) SetCSR25(value uint32) {
	volatile.StoreUint32(&o.CSR25.Reg, value)
}
func (o *HASH_Type) GetCSR25() uint32 {
	return volatile.LoadUint32(&o.CSR25.Reg)
}

// HASH.CSR26: context swap registers
func (o *HASH_Type) SetCSR26(value uint32) {
	volatile.StoreUint32(&o.CSR26.Reg, value)
}
func (o *HASH_Type) GetCSR26() uint32 {
	return volatile.LoadUint32(&o.CSR26.Reg)
}

// HASH.CSR27: context swap registers
func (o *HASH_Type) SetCSR27(value uint32) {
	volatile.StoreUint32(&o.CSR27.Reg, value)
}
func (o *HASH_Type) GetCSR27() uint32 {
	return volatile.LoadUint32(&o.CSR27.Reg)
}

// HASH.CSR28: context swap registers
func (o *HASH_Type) SetCSR28(value uint32) {
	volatile.StoreUint32(&o.CSR28.Reg, value)
}
func (o *HASH_Type) GetCSR28() uint32 {
	return volatile.LoadUint32(&o.CSR28.Reg)
}

// HASH.CSR29: context swap registers
func (o *HASH_Type) SetCSR29(value uint32) {
	volatile.StoreUint32(&o.CSR29.Reg, value)
}
func (o *HASH_Type) GetCSR29() uint32 {
	return volatile.LoadUint32(&o.CSR29.Reg)
}

// HASH.CSR30: context swap registers
func (o *HASH_Type) SetCSR30(value uint32) {
	volatile.StoreUint32(&o.CSR30.Reg, value)
}
func (o *HASH_Type) GetCSR30() uint32 {
	return volatile.LoadUint32(&o.CSR30.Reg)
}

// HASH.CSR31: context swap registers
func (o *HASH_Type) SetCSR31(value uint32) {
	volatile.StoreUint32(&o.CSR31.Reg, value)
}
func (o *HASH_Type) GetCSR31() uint32 {
	return volatile.LoadUint32(&o.CSR31.Reg)
}

// HASH.CSR32: context swap registers
func (o *HASH_Type) SetCSR32(value uint32) {
	volatile.StoreUint32(&o.CSR32.Reg, value)
}
func (o *HASH_Type) GetCSR32() uint32 {
	return volatile.LoadUint32(&o.CSR32.Reg)
}

// HASH.CSR33: context swap registers
func (o *HASH_Type) SetCSR33(value uint32) {
	volatile.StoreUint32(&o.CSR33.Reg, value)
}
func (o *HASH_Type) GetCSR33() uint32 {
	return volatile.LoadUint32(&o.CSR33.Reg)
}

// HASH.CSR34: context swap registers
func (o *HASH_Type) SetCSR34(value uint32) {
	volatile.StoreUint32(&o.CSR34.Reg, value)
}
func (o *HASH_Type) GetCSR34() uint32 {
	return volatile.LoadUint32(&o.CSR34.Reg)
}

// HASH.CSR35: context swap registers
func (o *HASH_Type) SetCSR35(value uint32) {
	volatile.StoreUint32(&o.CSR35.Reg, value)
}
func (o *HASH_Type) GetCSR35() uint32 {
	return volatile.LoadUint32(&o.CSR35.Reg)
}

// HASH.CSR36: context swap registers
func (o *HASH_Type) SetCSR36(value uint32) {
	volatile.StoreUint32(&o.CSR36.Reg, value)
}
func (o *HASH_Type) GetCSR36() uint32 {
	return volatile.LoadUint32(&o.CSR36.Reg)
}

// HASH.CSR37: context swap registers
func (o *HASH_Type) SetCSR37(value uint32) {
	volatile.StoreUint32(&o.CSR37.Reg, value)
}
func (o *HASH_Type) GetCSR37() uint32 {
	return volatile.LoadUint32(&o.CSR37.Reg)
}

// HASH.CSR38: context swap registers
func (o *HASH_Type) SetCSR38(value uint32) {
	volatile.StoreUint32(&o.CSR38.Reg, value)
}
func (o *HASH_Type) GetCSR38() uint32 {
	return volatile.LoadUint32(&o.CSR38.Reg)
}

// HASH.CSR39: context swap registers
func (o *HASH_Type) SetCSR39(value uint32) {
	volatile.StoreUint32(&o.CSR39.Reg, value)
}
func (o *HASH_Type) GetCSR39() uint32 {
	return volatile.LoadUint32(&o.CSR39.Reg)
}

// HASH.CSR40: context swap registers
func (o *HASH_Type) SetCSR40(value uint32) {
	volatile.StoreUint32(&o.CSR40.Reg, value)
}
func (o *HASH_Type) GetCSR40() uint32 {
	return volatile.LoadUint32(&o.CSR40.Reg)
}

// HASH.CSR41: context swap registers
func (o *HASH_Type) SetCSR41(value uint32) {
	volatile.StoreUint32(&o.CSR41.Reg, value)
}
func (o *HASH_Type) GetCSR41() uint32 {
	return volatile.LoadUint32(&o.CSR41.Reg)
}

// HASH.CSR42: context swap registers
func (o *HASH_Type) SetCSR42(value uint32) {
	volatile.StoreUint32(&o.CSR42.Reg, value)
}
func (o *HASH_Type) GetCSR42() uint32 {
	return volatile.LoadUint32(&o.CSR42.Reg)
}

// HASH.CSR43: context swap registers
func (o *HASH_Type) SetCSR43(value uint32) {
	volatile.StoreUint32(&o.CSR43.Reg, value)
}
func (o *HASH_Type) GetCSR43() uint32 {
	return volatile.LoadUint32(&o.CSR43.Reg)
}

// HASH.CSR44: context swap registers
func (o *HASH_Type) SetCSR44(value uint32) {
	volatile.StoreUint32(&o.CSR44.Reg, value)
}
func (o *HASH_Type) GetCSR44() uint32 {
	return volatile.LoadUint32(&o.CSR44.Reg)
}

// HASH.CSR45: context swap registers
func (o *HASH_Type) SetCSR45(value uint32) {
	volatile.StoreUint32(&o.CSR45.Reg, value)
}
func (o *HASH_Type) GetCSR45() uint32 {
	return volatile.LoadUint32(&o.CSR45.Reg)
}

// HASH.CSR46: context swap registers
func (o *HASH_Type) SetCSR46(value uint32) {
	volatile.StoreUint32(&o.CSR46.Reg, value)
}
func (o *HASH_Type) GetCSR46() uint32 {
	return volatile.LoadUint32(&o.CSR46.Reg)
}

// HASH.CSR47: context swap registers
func (o *HASH_Type) SetCSR47(value uint32) {
	volatile.StoreUint32(&o.CSR47.Reg, value)
}
func (o *HASH_Type) GetCSR47() uint32 {
	return volatile.LoadUint32(&o.CSR47.Reg)
}

// HASH.CSR48: context swap registers
func (o *HASH_Type) SetCSR48(value uint32) {
	volatile.StoreUint32(&o.CSR48.Reg, value)
}
func (o *HASH_Type) GetCSR48() uint32 {
	return volatile.LoadUint32(&o.CSR48.Reg)
}

// HASH.CSR49: context swap registers
func (o *HASH_Type) SetCSR49(value uint32) {
	volatile.StoreUint32(&o.CSR49.Reg, value)
}
func (o *HASH_Type) GetCSR49() uint32 {
	return volatile.LoadUint32(&o.CSR49.Reg)
}

// HASH.CSR50: context swap registers
func (o *HASH_Type) SetCSR50(value uint32) {
	volatile.StoreUint32(&o.CSR50.Reg, value)
}
func (o *HASH_Type) GetCSR50() uint32 {
	return volatile.LoadUint32(&o.CSR50.Reg)
}

// HASH.CSR51: context swap registers
func (o *HASH_Type) SetCSR51(value uint32) {
	volatile.StoreUint32(&o.CSR51.Reg, value)
}
func (o *HASH_Type) GetCSR51() uint32 {
	return volatile.LoadUint32(&o.CSR51.Reg)
}

// HASH.CSR52: context swap registers
func (o *HASH_Type) SetCSR52(value uint32) {
	volatile.StoreUint32(&o.CSR52.Reg, value)
}
func (o *HASH_Type) GetCSR52() uint32 {
	return volatile.LoadUint32(&o.CSR52.Reg)
}

// HASH.CSR53: context swap registers
func (o *HASH_Type) SetCSR53(value uint32) {
	volatile.StoreUint32(&o.CSR53.Reg, value)
}
func (o *HASH_Type) GetCSR53() uint32 {
	return volatile.LoadUint32(&o.CSR53.Reg)
}

// HASH.HASH_HR0: HASH digest register
func (o *HASH_Type) SetHASH_HR0(value uint32) {
	volatile.StoreUint32(&o.HASH_HR0.Reg, value)
}
func (o *HASH_Type) GetHASH_HR0() uint32 {
	return volatile.LoadUint32(&o.HASH_HR0.Reg)
}

// HASH.HASH_HR1: HASH digest register
func (o *HASH_Type) SetHASH_HR1(value uint32) {
	volatile.StoreUint32(&o.HASH_HR1.Reg, value)
}
func (o *HASH_Type) GetHASH_HR1() uint32 {
	return volatile.LoadUint32(&o.HASH_HR1.Reg)
}

// HASH.HASH_HR2: HASH digest register
func (o *HASH_Type) SetHASH_HR2(value uint32) {
	volatile.StoreUint32(&o.HASH_HR2.Reg, value)
}
func (o *HASH_Type) GetHASH_HR2() uint32 {
	return volatile.LoadUint32(&o.HASH_HR2.Reg)
}

// HASH.HASH_HR3: HASH digest register
func (o *HASH_Type) SetHASH_HR3(value uint32) {
	volatile.StoreUint32(&o.HASH_HR3.Reg, value)
}
func (o *HASH_Type) GetHASH_HR3() uint32 {
	return volatile.LoadUint32(&o.HASH_HR3.Reg)
}

// HASH.HASH_HR4: HASH digest register
func (o *HASH_Type) SetHASH_HR4(value uint32) {
	volatile.StoreUint32(&o.HASH_HR4.Reg, value)
}
func (o *HASH_Type) GetHASH_HR4() uint32 {
	return volatile.LoadUint32(&o.HASH_HR4.Reg)
}

// HASH.HASH_HR5: HASH digest register
func (o *HASH_Type) SetHASH_HR5(value uint32) {
	volatile.StoreUint32(&o.HASH_HR5.Reg, value)
}
func (o *HASH_Type) GetHASH_HR5() uint32 {
	return volatile.LoadUint32(&o.HASH_HR5.Reg)
}

// HASH.HASH_HR6: HASH digest register
func (o *HASH_Type) SetHASH_HR6(value uint32) {
	volatile.StoreUint32(&o.HASH_HR6.Reg, value)
}
func (o *HASH_Type) GetHASH_HR6() uint32 {
	return volatile.LoadUint32(&o.HASH_HR6.Reg)
}

// HASH.HASH_HR7: HASH digest register
func (o *HASH_Type) SetHASH_HR7(value uint32) {
	volatile.StoreUint32(&o.HASH_HR7.Reg, value)
}
func (o *HASH_Type) GetHASH_HR7() uint32 {
	return volatile.LoadUint32(&o.HASH_HR7.Reg)
}

// Cryptographic processor
type CRYP_Type struct {
	CR         volatile.Register32 // 0x0
	SR         volatile.Register32 // 0x4
	DIN        volatile.Register32 // 0x8
	DOUT       volatile.Register32 // 0xC
	DMACR      volatile.Register32 // 0x10
	IMSCR      volatile.Register32 // 0x14
	RISR       volatile.Register32 // 0x18
	MISR       volatile.Register32 // 0x1C
	KEY        [4]CRYP_KEY_Type    // 0x20
	INIT       [2]CRYP_INIT_Type   // 0x40
	CSGCMCCM0R volatile.Register32 // 0x50
	CSGCMCCM1R volatile.Register32 // 0x54
	CSGCMCCM2R volatile.Register32 // 0x58
	CSGCMCCM3R volatile.Register32 // 0x5C
	CSGCMCCM4R volatile.Register32 // 0x60
	CSGCMCCM5R volatile.Register32 // 0x64
	CSGCMCCM6R volatile.Register32 // 0x68
	CSGCMCCM7R volatile.Register32 // 0x6C
	CSGCM0R    volatile.Register32 // 0x70
	CSGCM1R    volatile.Register32 // 0x74
	CSGCM2R    volatile.Register32 // 0x78
	CSGCM3R    volatile.Register32 // 0x7C
	CSGCM4R    volatile.Register32 // 0x80
	CSGCM5R    volatile.Register32 // 0x84
	CSGCM6R    volatile.Register32 // 0x88
	CSGCM7R    volatile.Register32 // 0x8C
}

// CRYP.CR: control register
func (o *CRYP_Type) SetCR_ALGODIR(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *CRYP_Type) GetCR_ALGODIR() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *CRYP_Type) SetCR_ALGOMODE0(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x38)|value<<3)
}
func (o *CRYP_Type) GetCR_ALGOMODE0() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x38) >> 3
}
func (o *CRYP_Type) SetCR_DATATYPE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc0)|value<<6)
}
func (o *CRYP_Type) GetCR_DATATYPE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc0) >> 6
}
func (o *CRYP_Type) SetCR_KEYSIZE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x300)|value<<8)
}
func (o *CRYP_Type) GetCR_KEYSIZE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x300) >> 8
}
func (o *CRYP_Type) SetCR_FFLUSH(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *CRYP_Type) GetCR_FFLUSH() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *CRYP_Type) SetCR_CRYPEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *CRYP_Type) GetCR_CRYPEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}
func (o *CRYP_Type) SetCR_GCM_CCMPH(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x30000)|value<<16)
}
func (o *CRYP_Type) GetCR_GCM_CCMPH() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x30000) >> 16
}
func (o *CRYP_Type) SetCR_ALGOMODE3(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *CRYP_Type) GetCR_ALGOMODE3() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}

// CRYP.SR: status register
func (o *CRYP_Type) SetSR_BUSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *CRYP_Type) GetSR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *CRYP_Type) SetSR_OFFU(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *CRYP_Type) GetSR_OFFU() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *CRYP_Type) SetSR_OFNE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *CRYP_Type) GetSR_OFNE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *CRYP_Type) SetSR_IFNF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *CRYP_Type) GetSR_IFNF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *CRYP_Type) SetSR_IFEM(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *CRYP_Type) GetSR_IFEM() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// CRYP.DIN: data input register
func (o *CRYP_Type) SetDIN(value uint32) {
	volatile.StoreUint32(&o.DIN.Reg, value)
}
func (o *CRYP_Type) GetDIN() uint32 {
	return volatile.LoadUint32(&o.DIN.Reg)
}

// CRYP.DOUT: data output register
func (o *CRYP_Type) SetDOUT(value uint32) {
	volatile.StoreUint32(&o.DOUT.Reg, value)
}
func (o *CRYP_Type) GetDOUT() uint32 {
	return volatile.LoadUint32(&o.DOUT.Reg)
}

// CRYP.DMACR: DMA control register
func (o *CRYP_Type) SetDMACR_DOEN(value uint32) {
	volatile.StoreUint32(&o.DMACR.Reg, volatile.LoadUint32(&o.DMACR.Reg)&^(0x2)|value<<1)
}
func (o *CRYP_Type) GetDMACR_DOEN() uint32 {
	return (volatile.LoadUint32(&o.DMACR.Reg) & 0x2) >> 1
}
func (o *CRYP_Type) SetDMACR_DIEN(value uint32) {
	volatile.StoreUint32(&o.DMACR.Reg, volatile.LoadUint32(&o.DMACR.Reg)&^(0x1)|value)
}
func (o *CRYP_Type) GetDMACR_DIEN() uint32 {
	return volatile.LoadUint32(&o.DMACR.Reg) & 0x1
}

// CRYP.IMSCR: interrupt mask set/clear register
func (o *CRYP_Type) SetIMSCR_OUTIM(value uint32) {
	volatile.StoreUint32(&o.IMSCR.Reg, volatile.LoadUint32(&o.IMSCR.Reg)&^(0x2)|value<<1)
}
func (o *CRYP_Type) GetIMSCR_OUTIM() uint32 {
	return (volatile.LoadUint32(&o.IMSCR.Reg) & 0x2) >> 1
}
func (o *CRYP_Type) SetIMSCR_INIM(value uint32) {
	volatile.StoreUint32(&o.IMSCR.Reg, volatile.LoadUint32(&o.IMSCR.Reg)&^(0x1)|value)
}
func (o *CRYP_Type) GetIMSCR_INIM() uint32 {
	return volatile.LoadUint32(&o.IMSCR.Reg) & 0x1
}

// CRYP.RISR: raw interrupt status register
func (o *CRYP_Type) SetRISR_OUTRIS(value uint32) {
	volatile.StoreUint32(&o.RISR.Reg, volatile.LoadUint32(&o.RISR.Reg)&^(0x2)|value<<1)
}
func (o *CRYP_Type) GetRISR_OUTRIS() uint32 {
	return (volatile.LoadUint32(&o.RISR.Reg) & 0x2) >> 1
}
func (o *CRYP_Type) SetRISR_INRIS(value uint32) {
	volatile.StoreUint32(&o.RISR.Reg, volatile.LoadUint32(&o.RISR.Reg)&^(0x1)|value)
}
func (o *CRYP_Type) GetRISR_INRIS() uint32 {
	return volatile.LoadUint32(&o.RISR.Reg) & 0x1
}

// CRYP.MISR: masked interrupt status register
func (o *CRYP_Type) SetMISR_OUTMIS(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x2)|value<<1)
}
func (o *CRYP_Type) GetMISR_OUTMIS() uint32 {
	return (volatile.LoadUint32(&o.MISR.Reg) & 0x2) >> 1
}
func (o *CRYP_Type) SetMISR_INMIS(value uint32) {
	volatile.StoreUint32(&o.MISR.Reg, volatile.LoadUint32(&o.MISR.Reg)&^(0x1)|value)
}
func (o *CRYP_Type) GetMISR_INMIS() uint32 {
	return volatile.LoadUint32(&o.MISR.Reg) & 0x1
}

// CRYP.CSGCMCCM0R: context swap register
func (o *CRYP_Type) SetCSGCMCCM0R(value uint32) {
	volatile.StoreUint32(&o.CSGCMCCM0R.Reg, value)
}
func (o *CRYP_Type) GetCSGCMCCM0R() uint32 {
	return volatile.LoadUint32(&o.CSGCMCCM0R.Reg)
}

// CRYP.CSGCMCCM1R: context swap register
func (o *CRYP_Type) SetCSGCMCCM1R(value uint32) {
	volatile.StoreUint32(&o.CSGCMCCM1R.Reg, value)
}
func (o *CRYP_Type) GetCSGCMCCM1R() uint32 {
	return volatile.LoadUint32(&o.CSGCMCCM1R.Reg)
}

// CRYP.CSGCMCCM2R: context swap register
func (o *CRYP_Type) SetCSGCMCCM2R(value uint32) {
	volatile.StoreUint32(&o.CSGCMCCM2R.Reg, value)
}
func (o *CRYP_Type) GetCSGCMCCM2R() uint32 {
	return volatile.LoadUint32(&o.CSGCMCCM2R.Reg)
}

// CRYP.CSGCMCCM3R: context swap register
func (o *CRYP_Type) SetCSGCMCCM3R(value uint32) {
	volatile.StoreUint32(&o.CSGCMCCM3R.Reg, value)
}
func (o *CRYP_Type) GetCSGCMCCM3R() uint32 {
	return volatile.LoadUint32(&o.CSGCMCCM3R.Reg)
}

// CRYP.CSGCMCCM4R: context swap register
func (o *CRYP_Type) SetCSGCMCCM4R(value uint32) {
	volatile.StoreUint32(&o.CSGCMCCM4R.Reg, value)
}
func (o *CRYP_Type) GetCSGCMCCM4R() uint32 {
	return volatile.LoadUint32(&o.CSGCMCCM4R.Reg)
}

// CRYP.CSGCMCCM5R: context swap register
func (o *CRYP_Type) SetCSGCMCCM5R(value uint32) {
	volatile.StoreUint32(&o.CSGCMCCM5R.Reg, value)
}
func (o *CRYP_Type) GetCSGCMCCM5R() uint32 {
	return volatile.LoadUint32(&o.CSGCMCCM5R.Reg)
}

// CRYP.CSGCMCCM6R: context swap register
func (o *CRYP_Type) SetCSGCMCCM6R(value uint32) {
	volatile.StoreUint32(&o.CSGCMCCM6R.Reg, value)
}
func (o *CRYP_Type) GetCSGCMCCM6R() uint32 {
	return volatile.LoadUint32(&o.CSGCMCCM6R.Reg)
}

// CRYP.CSGCMCCM7R: context swap register
func (o *CRYP_Type) SetCSGCMCCM7R(value uint32) {
	volatile.StoreUint32(&o.CSGCMCCM7R.Reg, value)
}
func (o *CRYP_Type) GetCSGCMCCM7R() uint32 {
	return volatile.LoadUint32(&o.CSGCMCCM7R.Reg)
}

// CRYP.CSGCM0R: context swap register
func (o *CRYP_Type) SetCSGCM0R(value uint32) {
	volatile.StoreUint32(&o.CSGCM0R.Reg, value)
}
func (o *CRYP_Type) GetCSGCM0R() uint32 {
	return volatile.LoadUint32(&o.CSGCM0R.Reg)
}

// CRYP.CSGCM1R: context swap register
func (o *CRYP_Type) SetCSGCM1R(value uint32) {
	volatile.StoreUint32(&o.CSGCM1R.Reg, value)
}
func (o *CRYP_Type) GetCSGCM1R() uint32 {
	return volatile.LoadUint32(&o.CSGCM1R.Reg)
}

// CRYP.CSGCM2R: context swap register
func (o *CRYP_Type) SetCSGCM2R(value uint32) {
	volatile.StoreUint32(&o.CSGCM2R.Reg, value)
}
func (o *CRYP_Type) GetCSGCM2R() uint32 {
	return volatile.LoadUint32(&o.CSGCM2R.Reg)
}

// CRYP.CSGCM3R: context swap register
func (o *CRYP_Type) SetCSGCM3R(value uint32) {
	volatile.StoreUint32(&o.CSGCM3R.Reg, value)
}
func (o *CRYP_Type) GetCSGCM3R() uint32 {
	return volatile.LoadUint32(&o.CSGCM3R.Reg)
}

// CRYP.CSGCM4R: context swap register
func (o *CRYP_Type) SetCSGCM4R(value uint32) {
	volatile.StoreUint32(&o.CSGCM4R.Reg, value)
}
func (o *CRYP_Type) GetCSGCM4R() uint32 {
	return volatile.LoadUint32(&o.CSGCM4R.Reg)
}

// CRYP.CSGCM5R: context swap register
func (o *CRYP_Type) SetCSGCM5R(value uint32) {
	volatile.StoreUint32(&o.CSGCM5R.Reg, value)
}
func (o *CRYP_Type) GetCSGCM5R() uint32 {
	return volatile.LoadUint32(&o.CSGCM5R.Reg)
}

// CRYP.CSGCM6R: context swap register
func (o *CRYP_Type) SetCSGCM6R(value uint32) {
	volatile.StoreUint32(&o.CSGCM6R.Reg, value)
}
func (o *CRYP_Type) GetCSGCM6R() uint32 {
	return volatile.LoadUint32(&o.CSGCM6R.Reg)
}

// CRYP.CSGCM7R: context swap register
func (o *CRYP_Type) SetCSGCM7R(value uint32) {
	volatile.StoreUint32(&o.CSGCM7R.Reg, value)
}
func (o *CRYP_Type) GetCSGCM7R() uint32 {
	return volatile.LoadUint32(&o.CSGCM7R.Reg)
}

type CRYP_KEY_Type struct {
	KLR volatile.Register32 // 0x20
	KRR volatile.Register32 // 0x24
}

// CRYP_KEY.KLR: key registers
func (o *CRYP_KEY_Type) SetKLR(value uint32) {
	volatile.StoreUint32(&o.KLR.Reg, value)
}
func (o *CRYP_KEY_Type) GetKLR() uint32 {
	return volatile.LoadUint32(&o.KLR.Reg)
}

// CRYP_KEY.KRR: key registers
func (o *CRYP_KEY_Type) SetKRR(value uint32) {
	volatile.StoreUint32(&o.KRR.Reg, value)
}
func (o *CRYP_KEY_Type) GetKRR() uint32 {
	return volatile.LoadUint32(&o.KRR.Reg)
}

type CRYP_INIT_Type struct {
	IVLR volatile.Register32 // 0x40
	IVRR volatile.Register32 // 0x44
}

// CRYP_INIT.IVLR: initialization vector registers
func (o *CRYP_INIT_Type) SetIVLR(value uint32) {
	volatile.StoreUint32(&o.IVLR.Reg, value)
}
func (o *CRYP_INIT_Type) GetIVLR() uint32 {
	return volatile.LoadUint32(&o.IVLR.Reg)
}

// CRYP_INIT.IVRR: initialization vector registers
func (o *CRYP_INIT_Type) SetIVRR(value uint32) {
	volatile.StoreUint32(&o.IVRR.Reg, value)
}
func (o *CRYP_INIT_Type) GetIVRR() uint32 {
	return volatile.LoadUint32(&o.IVRR.Reg)
}

// Digital camera interface
type DCMI_Type struct {
	CR     volatile.Register32 // 0x0
	SR     volatile.Register32 // 0x4
	RIS    volatile.Register32 // 0x8
	IER    volatile.Register32 // 0xC
	MIS    volatile.Register32 // 0x10
	ICR    volatile.Register32 // 0x14
	ESCR   volatile.Register32 // 0x18
	ESUR   volatile.Register32 // 0x1C
	CWSTRT volatile.Register32 // 0x20
	CWSIZE volatile.Register32 // 0x24
	DR     volatile.Register32 // 0x28
}

// DCMI.CR: control register 1
func (o *DCMI_Type) SetCR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *DCMI_Type) GetCR_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *DCMI_Type) SetCR_EDM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc00)|value<<10)
}
func (o *DCMI_Type) GetCR_EDM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc00) >> 10
}
func (o *DCMI_Type) SetCR_FCRC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x300)|value<<8)
}
func (o *DCMI_Type) GetCR_FCRC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x300) >> 8
}
func (o *DCMI_Type) SetCR_VSPOL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *DCMI_Type) GetCR_VSPOL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *DCMI_Type) SetCR_HSPOL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *DCMI_Type) GetCR_HSPOL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *DCMI_Type) SetCR_PCKPOL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *DCMI_Type) GetCR_PCKPOL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *DCMI_Type) SetCR_ESS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *DCMI_Type) GetCR_ESS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *DCMI_Type) SetCR_JPEG(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *DCMI_Type) GetCR_JPEG() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *DCMI_Type) SetCR_CROP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *DCMI_Type) GetCR_CROP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *DCMI_Type) SetCR_CM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *DCMI_Type) GetCR_CM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *DCMI_Type) SetCR_CAPTURE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *DCMI_Type) GetCR_CAPTURE() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// DCMI.SR: status register
func (o *DCMI_Type) SetSR_FNE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *DCMI_Type) GetSR_FNE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *DCMI_Type) SetSR_VSYNC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *DCMI_Type) GetSR_VSYNC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *DCMI_Type) SetSR_HSYNC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *DCMI_Type) GetSR_HSYNC() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// DCMI.RIS: raw interrupt status register
func (o *DCMI_Type) SetRIS_LINE_RIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x10)|value<<4)
}
func (o *DCMI_Type) GetRIS_LINE_RIS() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x10) >> 4
}
func (o *DCMI_Type) SetRIS_VSYNC_RIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x8)|value<<3)
}
func (o *DCMI_Type) GetRIS_VSYNC_RIS() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x8) >> 3
}
func (o *DCMI_Type) SetRIS_ERR_RIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x4)|value<<2)
}
func (o *DCMI_Type) GetRIS_ERR_RIS() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x4) >> 2
}
func (o *DCMI_Type) SetRIS_OVR_RIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x2)|value<<1)
}
func (o *DCMI_Type) GetRIS_OVR_RIS() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x2) >> 1
}
func (o *DCMI_Type) SetRIS_FRAME_RIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x1)|value)
}
func (o *DCMI_Type) GetRIS_FRAME_RIS() uint32 {
	return volatile.LoadUint32(&o.RIS.Reg) & 0x1
}

// DCMI.IER: interrupt enable register
func (o *DCMI_Type) SetIER_LINE_IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *DCMI_Type) GetIER_LINE_IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *DCMI_Type) SetIER_VSYNC_IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *DCMI_Type) GetIER_VSYNC_IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *DCMI_Type) SetIER_ERR_IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *DCMI_Type) GetIER_ERR_IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *DCMI_Type) SetIER_OVR_IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *DCMI_Type) GetIER_OVR_IE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *DCMI_Type) SetIER_FRAME_IE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *DCMI_Type) GetIER_FRAME_IE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// DCMI.MIS: masked interrupt status register
func (o *DCMI_Type) SetMIS_LINE_MIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x10)|value<<4)
}
func (o *DCMI_Type) GetMIS_LINE_MIS() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x10) >> 4
}
func (o *DCMI_Type) SetMIS_VSYNC_MIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x8)|value<<3)
}
func (o *DCMI_Type) GetMIS_VSYNC_MIS() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x8) >> 3
}
func (o *DCMI_Type) SetMIS_ERR_MIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x4)|value<<2)
}
func (o *DCMI_Type) GetMIS_ERR_MIS() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x4) >> 2
}
func (o *DCMI_Type) SetMIS_OVR_MIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x2)|value<<1)
}
func (o *DCMI_Type) GetMIS_OVR_MIS() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x2) >> 1
}
func (o *DCMI_Type) SetMIS_FRAME_MIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x1)|value)
}
func (o *DCMI_Type) GetMIS_FRAME_MIS() uint32 {
	return volatile.LoadUint32(&o.MIS.Reg) & 0x1
}

// DCMI.ICR: interrupt clear register
func (o *DCMI_Type) SetICR_LINE_ISC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *DCMI_Type) GetICR_LINE_ISC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *DCMI_Type) SetICR_VSYNC_ISC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *DCMI_Type) GetICR_VSYNC_ISC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *DCMI_Type) SetICR_ERR_ISC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *DCMI_Type) GetICR_ERR_ISC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *DCMI_Type) SetICR_OVR_ISC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *DCMI_Type) GetICR_OVR_ISC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *DCMI_Type) SetICR_FRAME_ISC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *DCMI_Type) GetICR_FRAME_ISC() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}

// DCMI.ESCR: embedded synchronization code register
func (o *DCMI_Type) SetESCR_FEC(value uint32) {
	volatile.StoreUint32(&o.ESCR.Reg, volatile.LoadUint32(&o.ESCR.Reg)&^(0xff000000)|value<<24)
}
func (o *DCMI_Type) GetESCR_FEC() uint32 {
	return (volatile.LoadUint32(&o.ESCR.Reg) & 0xff000000) >> 24
}
func (o *DCMI_Type) SetESCR_LEC(value uint32) {
	volatile.StoreUint32(&o.ESCR.Reg, volatile.LoadUint32(&o.ESCR.Reg)&^(0xff0000)|value<<16)
}
func (o *DCMI_Type) GetESCR_LEC() uint32 {
	return (volatile.LoadUint32(&o.ESCR.Reg) & 0xff0000) >> 16
}
func (o *DCMI_Type) SetESCR_LSC(value uint32) {
	volatile.StoreUint32(&o.ESCR.Reg, volatile.LoadUint32(&o.ESCR.Reg)&^(0xff00)|value<<8)
}
func (o *DCMI_Type) GetESCR_LSC() uint32 {
	return (volatile.LoadUint32(&o.ESCR.Reg) & 0xff00) >> 8
}
func (o *DCMI_Type) SetESCR_FSC(value uint32) {
	volatile.StoreUint32(&o.ESCR.Reg, volatile.LoadUint32(&o.ESCR.Reg)&^(0xff)|value)
}
func (o *DCMI_Type) GetESCR_FSC() uint32 {
	return volatile.LoadUint32(&o.ESCR.Reg) & 0xff
}

// DCMI.ESUR: embedded synchronization unmask register
func (o *DCMI_Type) SetESUR_FEU(value uint32) {
	volatile.StoreUint32(&o.ESUR.Reg, volatile.LoadUint32(&o.ESUR.Reg)&^(0xff000000)|value<<24)
}
func (o *DCMI_Type) GetESUR_FEU() uint32 {
	return (volatile.LoadUint32(&o.ESUR.Reg) & 0xff000000) >> 24
}
func (o *DCMI_Type) SetESUR_LEU(value uint32) {
	volatile.StoreUint32(&o.ESUR.Reg, volatile.LoadUint32(&o.ESUR.Reg)&^(0xff0000)|value<<16)
}
func (o *DCMI_Type) GetESUR_LEU() uint32 {
	return (volatile.LoadUint32(&o.ESUR.Reg) & 0xff0000) >> 16
}
func (o *DCMI_Type) SetESUR_LSU(value uint32) {
	volatile.StoreUint32(&o.ESUR.Reg, volatile.LoadUint32(&o.ESUR.Reg)&^(0xff00)|value<<8)
}
func (o *DCMI_Type) GetESUR_LSU() uint32 {
	return (volatile.LoadUint32(&o.ESUR.Reg) & 0xff00) >> 8
}
func (o *DCMI_Type) SetESUR_FSU(value uint32) {
	volatile.StoreUint32(&o.ESUR.Reg, volatile.LoadUint32(&o.ESUR.Reg)&^(0xff)|value)
}
func (o *DCMI_Type) GetESUR_FSU() uint32 {
	return volatile.LoadUint32(&o.ESUR.Reg) & 0xff
}

// DCMI.CWSTRT: crop window start
func (o *DCMI_Type) SetCWSTRT_VST(value uint32) {
	volatile.StoreUint32(&o.CWSTRT.Reg, volatile.LoadUint32(&o.CWSTRT.Reg)&^(0x1fff0000)|value<<16)
}
func (o *DCMI_Type) GetCWSTRT_VST() uint32 {
	return (volatile.LoadUint32(&o.CWSTRT.Reg) & 0x1fff0000) >> 16
}
func (o *DCMI_Type) SetCWSTRT_HOFFCNT(value uint32) {
	volatile.StoreUint32(&o.CWSTRT.Reg, volatile.LoadUint32(&o.CWSTRT.Reg)&^(0x3fff)|value)
}
func (o *DCMI_Type) GetCWSTRT_HOFFCNT() uint32 {
	return volatile.LoadUint32(&o.CWSTRT.Reg) & 0x3fff
}

// DCMI.CWSIZE: crop window size
func (o *DCMI_Type) SetCWSIZE_VLINE(value uint32) {
	volatile.StoreUint32(&o.CWSIZE.Reg, volatile.LoadUint32(&o.CWSIZE.Reg)&^(0x3fff0000)|value<<16)
}
func (o *DCMI_Type) GetCWSIZE_VLINE() uint32 {
	return (volatile.LoadUint32(&o.CWSIZE.Reg) & 0x3fff0000) >> 16
}
func (o *DCMI_Type) SetCWSIZE_CAPCNT(value uint32) {
	volatile.StoreUint32(&o.CWSIZE.Reg, volatile.LoadUint32(&o.CWSIZE.Reg)&^(0x3fff)|value)
}
func (o *DCMI_Type) GetCWSIZE_CAPCNT() uint32 {
	return volatile.LoadUint32(&o.CWSIZE.Reg) & 0x3fff
}

// DCMI.DR: data register
func (o *DCMI_Type) SetDR_Byte3(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xff000000)|value<<24)
}
func (o *DCMI_Type) GetDR_Byte3() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xff000000) >> 24
}
func (o *DCMI_Type) SetDR_Byte2(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xff0000)|value<<16)
}
func (o *DCMI_Type) GetDR_Byte2() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xff0000) >> 16
}
func (o *DCMI_Type) SetDR_Byte1(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xff00)|value<<8)
}
func (o *DCMI_Type) GetDR_Byte1() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xff00) >> 8
}
func (o *DCMI_Type) SetDR_Byte0(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xff)|value)
}
func (o *DCMI_Type) GetDR_Byte0() uint32 {
	return volatile.LoadUint32(&o.DR.Reg) & 0xff
}

// Flexible memory controller
type FSMC_Type struct {
	BCR1  volatile.Register32 // 0x0
	BTR1  volatile.Register32 // 0x4
	BCR2  volatile.Register32 // 0x8
	BTR2  volatile.Register32 // 0xC
	BCR3  volatile.Register32 // 0x10
	BTR3  volatile.Register32 // 0x14
	BCR4  volatile.Register32 // 0x18
	BTR4  volatile.Register32 // 0x1C
	_     [96]byte
	PCR   volatile.Register32 // 0x80
	SR    volatile.Register32 // 0x84
	PMEM  volatile.Register32 // 0x88
	PATT  volatile.Register32 // 0x8C
	_     [4]byte
	ECCR  volatile.Register32 // 0x94
	_     [108]byte
	BWTR1 volatile.Register32 // 0x104
	_     [4]byte
	BWTR2 volatile.Register32 // 0x10C
	_     [4]byte
	BWTR3 volatile.Register32 // 0x114
	_     [4]byte
	BWTR4 volatile.Register32 // 0x11C
	_     [32]byte
	SDCR1 volatile.Register32 // 0x140
	SDCR2 volatile.Register32 // 0x144
	SDTR1 volatile.Register32 // 0x148
	SDTR2 volatile.Register32 // 0x14C
	SDCMR volatile.Register32 // 0x150
	SDRTR volatile.Register32 // 0x154
	SDSR  volatile.Register32 // 0x158
}

// FSMC.BCR1: SRAM/NOR-Flash chip-select control register 1
func (o *FSMC_Type) SetBCR1_CCLKEN(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x100000)|value<<20)
}
func (o *FSMC_Type) GetBCR1_CCLKEN() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x100000) >> 20
}
func (o *FSMC_Type) SetBCR1_CBURSTRW(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x80000)|value<<19)
}
func (o *FSMC_Type) GetBCR1_CBURSTRW() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x80000) >> 19
}
func (o *FSMC_Type) SetBCR1_ASYNCWAIT(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x8000)|value<<15)
}
func (o *FSMC_Type) GetBCR1_ASYNCWAIT() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x8000) >> 15
}
func (o *FSMC_Type) SetBCR1_EXTMOD(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x4000)|value<<14)
}
func (o *FSMC_Type) GetBCR1_EXTMOD() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x4000) >> 14
}
func (o *FSMC_Type) SetBCR1_WAITEN(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x2000)|value<<13)
}
func (o *FSMC_Type) GetBCR1_WAITEN() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x2000) >> 13
}
func (o *FSMC_Type) SetBCR1_WREN(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x1000)|value<<12)
}
func (o *FSMC_Type) GetBCR1_WREN() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x1000) >> 12
}
func (o *FSMC_Type) SetBCR1_WAITCFG(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x800)|value<<11)
}
func (o *FSMC_Type) GetBCR1_WAITCFG() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x800) >> 11
}
func (o *FSMC_Type) SetBCR1_WAITPOL(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x200)|value<<9)
}
func (o *FSMC_Type) GetBCR1_WAITPOL() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x200) >> 9
}
func (o *FSMC_Type) SetBCR1_BURSTEN(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x100)|value<<8)
}
func (o *FSMC_Type) GetBCR1_BURSTEN() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x100) >> 8
}
func (o *FSMC_Type) SetBCR1_FACCEN(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x40)|value<<6)
}
func (o *FSMC_Type) GetBCR1_FACCEN() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x40) >> 6
}
func (o *FSMC_Type) SetBCR1_MWID(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x30)|value<<4)
}
func (o *FSMC_Type) GetBCR1_MWID() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x30) >> 4
}
func (o *FSMC_Type) SetBCR1_MTYP(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0xc)|value<<2)
}
func (o *FSMC_Type) GetBCR1_MTYP() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0xc) >> 2
}
func (o *FSMC_Type) SetBCR1_MUXEN(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x2)|value<<1)
}
func (o *FSMC_Type) GetBCR1_MUXEN() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x2) >> 1
}
func (o *FSMC_Type) SetBCR1_MBKEN(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x1)|value)
}
func (o *FSMC_Type) GetBCR1_MBKEN() uint32 {
	return volatile.LoadUint32(&o.BCR1.Reg) & 0x1
}
func (o *FSMC_Type) SetBCR1_WRAPMOD(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x400)|value<<10)
}
func (o *FSMC_Type) GetBCR1_WRAPMOD() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x400) >> 10
}
func (o *FSMC_Type) SetBCR1_WFDIS(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x200000)|value<<21)
}
func (o *FSMC_Type) GetBCR1_WFDIS() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x200000) >> 21
}
func (o *FSMC_Type) SetBCR1_CPSIZE(value uint32) {
	volatile.StoreUint32(&o.BCR1.Reg, volatile.LoadUint32(&o.BCR1.Reg)&^(0x70000)|value<<16)
}
func (o *FSMC_Type) GetBCR1_CPSIZE() uint32 {
	return (volatile.LoadUint32(&o.BCR1.Reg) & 0x70000) >> 16
}

// FSMC.BTR1: SRAM/NOR-Flash chip-select timing register 1
func (o *FSMC_Type) SetBTR1_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BTR1.Reg, volatile.LoadUint32(&o.BTR1.Reg)&^(0x30000000)|value<<28)
}
func (o *FSMC_Type) GetBTR1_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BTR1.Reg) & 0x30000000) >> 28
}
func (o *FSMC_Type) SetBTR1_DATLAT(value uint32) {
	volatile.StoreUint32(&o.BTR1.Reg, volatile.LoadUint32(&o.BTR1.Reg)&^(0xf000000)|value<<24)
}
func (o *FSMC_Type) GetBTR1_DATLAT() uint32 {
	return (volatile.LoadUint32(&o.BTR1.Reg) & 0xf000000) >> 24
}
func (o *FSMC_Type) SetBTR1_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.BTR1.Reg, volatile.LoadUint32(&o.BTR1.Reg)&^(0xf00000)|value<<20)
}
func (o *FSMC_Type) GetBTR1_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.BTR1.Reg) & 0xf00000) >> 20
}
func (o *FSMC_Type) SetBTR1_BUSTURN(value uint32) {
	volatile.StoreUint32(&o.BTR1.Reg, volatile.LoadUint32(&o.BTR1.Reg)&^(0xf0000)|value<<16)
}
func (o *FSMC_Type) GetBTR1_BUSTURN() uint32 {
	return (volatile.LoadUint32(&o.BTR1.Reg) & 0xf0000) >> 16
}
func (o *FSMC_Type) SetBTR1_DATAST(value uint32) {
	volatile.StoreUint32(&o.BTR1.Reg, volatile.LoadUint32(&o.BTR1.Reg)&^(0xff00)|value<<8)
}
func (o *FSMC_Type) GetBTR1_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BTR1.Reg) & 0xff00) >> 8
}
func (o *FSMC_Type) SetBTR1_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BTR1.Reg, volatile.LoadUint32(&o.BTR1.Reg)&^(0xf0)|value<<4)
}
func (o *FSMC_Type) GetBTR1_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BTR1.Reg) & 0xf0) >> 4
}
func (o *FSMC_Type) SetBTR1_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BTR1.Reg, volatile.LoadUint32(&o.BTR1.Reg)&^(0xf)|value)
}
func (o *FSMC_Type) GetBTR1_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BTR1.Reg) & 0xf
}

// FSMC.BCR2: SRAM/NOR-Flash chip-select control register 2
func (o *FSMC_Type) SetBCR2_CBURSTRW(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x80000)|value<<19)
}
func (o *FSMC_Type) GetBCR2_CBURSTRW() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x80000) >> 19
}
func (o *FSMC_Type) SetBCR2_ASYNCWAIT(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x8000)|value<<15)
}
func (o *FSMC_Type) GetBCR2_ASYNCWAIT() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x8000) >> 15
}
func (o *FSMC_Type) SetBCR2_EXTMOD(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x4000)|value<<14)
}
func (o *FSMC_Type) GetBCR2_EXTMOD() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x4000) >> 14
}
func (o *FSMC_Type) SetBCR2_WAITEN(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x2000)|value<<13)
}
func (o *FSMC_Type) GetBCR2_WAITEN() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x2000) >> 13
}
func (o *FSMC_Type) SetBCR2_WREN(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x1000)|value<<12)
}
func (o *FSMC_Type) GetBCR2_WREN() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x1000) >> 12
}
func (o *FSMC_Type) SetBCR2_WAITCFG(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x800)|value<<11)
}
func (o *FSMC_Type) GetBCR2_WAITCFG() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x800) >> 11
}
func (o *FSMC_Type) SetBCR2_WRAPMOD(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x400)|value<<10)
}
func (o *FSMC_Type) GetBCR2_WRAPMOD() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x400) >> 10
}
func (o *FSMC_Type) SetBCR2_WAITPOL(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x200)|value<<9)
}
func (o *FSMC_Type) GetBCR2_WAITPOL() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x200) >> 9
}
func (o *FSMC_Type) SetBCR2_BURSTEN(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x100)|value<<8)
}
func (o *FSMC_Type) GetBCR2_BURSTEN() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x100) >> 8
}
func (o *FSMC_Type) SetBCR2_FACCEN(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x40)|value<<6)
}
func (o *FSMC_Type) GetBCR2_FACCEN() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x40) >> 6
}
func (o *FSMC_Type) SetBCR2_MWID(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x30)|value<<4)
}
func (o *FSMC_Type) GetBCR2_MWID() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x30) >> 4
}
func (o *FSMC_Type) SetBCR2_MTYP(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0xc)|value<<2)
}
func (o *FSMC_Type) GetBCR2_MTYP() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0xc) >> 2
}
func (o *FSMC_Type) SetBCR2_MUXEN(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x2)|value<<1)
}
func (o *FSMC_Type) GetBCR2_MUXEN() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x2) >> 1
}
func (o *FSMC_Type) SetBCR2_MBKEN(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x1)|value)
}
func (o *FSMC_Type) GetBCR2_MBKEN() uint32 {
	return volatile.LoadUint32(&o.BCR2.Reg) & 0x1
}
func (o *FSMC_Type) SetBCR2_CPSIZE(value uint32) {
	volatile.StoreUint32(&o.BCR2.Reg, volatile.LoadUint32(&o.BCR2.Reg)&^(0x70000)|value<<16)
}
func (o *FSMC_Type) GetBCR2_CPSIZE() uint32 {
	return (volatile.LoadUint32(&o.BCR2.Reg) & 0x70000) >> 16
}

// FSMC.BTR2: SRAM/NOR-Flash chip-select timing register 1
func (o *FSMC_Type) SetBTR2_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BTR2.Reg, volatile.LoadUint32(&o.BTR2.Reg)&^(0x30000000)|value<<28)
}
func (o *FSMC_Type) GetBTR2_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BTR2.Reg) & 0x30000000) >> 28
}
func (o *FSMC_Type) SetBTR2_DATLAT(value uint32) {
	volatile.StoreUint32(&o.BTR2.Reg, volatile.LoadUint32(&o.BTR2.Reg)&^(0xf000000)|value<<24)
}
func (o *FSMC_Type) GetBTR2_DATLAT() uint32 {
	return (volatile.LoadUint32(&o.BTR2.Reg) & 0xf000000) >> 24
}
func (o *FSMC_Type) SetBTR2_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.BTR2.Reg, volatile.LoadUint32(&o.BTR2.Reg)&^(0xf00000)|value<<20)
}
func (o *FSMC_Type) GetBTR2_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.BTR2.Reg) & 0xf00000) >> 20
}
func (o *FSMC_Type) SetBTR2_BUSTURN(value uint32) {
	volatile.StoreUint32(&o.BTR2.Reg, volatile.LoadUint32(&o.BTR2.Reg)&^(0xf0000)|value<<16)
}
func (o *FSMC_Type) GetBTR2_BUSTURN() uint32 {
	return (volatile.LoadUint32(&o.BTR2.Reg) & 0xf0000) >> 16
}
func (o *FSMC_Type) SetBTR2_DATAST(value uint32) {
	volatile.StoreUint32(&o.BTR2.Reg, volatile.LoadUint32(&o.BTR2.Reg)&^(0xff00)|value<<8)
}
func (o *FSMC_Type) GetBTR2_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BTR2.Reg) & 0xff00) >> 8
}
func (o *FSMC_Type) SetBTR2_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BTR2.Reg, volatile.LoadUint32(&o.BTR2.Reg)&^(0xf0)|value<<4)
}
func (o *FSMC_Type) GetBTR2_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BTR2.Reg) & 0xf0) >> 4
}
func (o *FSMC_Type) SetBTR2_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BTR2.Reg, volatile.LoadUint32(&o.BTR2.Reg)&^(0xf)|value)
}
func (o *FSMC_Type) GetBTR2_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BTR2.Reg) & 0xf
}

// FSMC.BCR3: SRAM/NOR-Flash chip-select control register 2
func (o *FSMC_Type) SetBCR3_CBURSTRW(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x80000)|value<<19)
}
func (o *FSMC_Type) GetBCR3_CBURSTRW() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x80000) >> 19
}
func (o *FSMC_Type) SetBCR3_ASYNCWAIT(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x8000)|value<<15)
}
func (o *FSMC_Type) GetBCR3_ASYNCWAIT() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x8000) >> 15
}
func (o *FSMC_Type) SetBCR3_EXTMOD(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x4000)|value<<14)
}
func (o *FSMC_Type) GetBCR3_EXTMOD() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x4000) >> 14
}
func (o *FSMC_Type) SetBCR3_WAITEN(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x2000)|value<<13)
}
func (o *FSMC_Type) GetBCR3_WAITEN() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x2000) >> 13
}
func (o *FSMC_Type) SetBCR3_WREN(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x1000)|value<<12)
}
func (o *FSMC_Type) GetBCR3_WREN() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x1000) >> 12
}
func (o *FSMC_Type) SetBCR3_WAITCFG(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x800)|value<<11)
}
func (o *FSMC_Type) GetBCR3_WAITCFG() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x800) >> 11
}
func (o *FSMC_Type) SetBCR3_WRAPMOD(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x400)|value<<10)
}
func (o *FSMC_Type) GetBCR3_WRAPMOD() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x400) >> 10
}
func (o *FSMC_Type) SetBCR3_WAITPOL(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x200)|value<<9)
}
func (o *FSMC_Type) GetBCR3_WAITPOL() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x200) >> 9
}
func (o *FSMC_Type) SetBCR3_BURSTEN(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x100)|value<<8)
}
func (o *FSMC_Type) GetBCR3_BURSTEN() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x100) >> 8
}
func (o *FSMC_Type) SetBCR3_FACCEN(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x40)|value<<6)
}
func (o *FSMC_Type) GetBCR3_FACCEN() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x40) >> 6
}
func (o *FSMC_Type) SetBCR3_MWID(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x30)|value<<4)
}
func (o *FSMC_Type) GetBCR3_MWID() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x30) >> 4
}
func (o *FSMC_Type) SetBCR3_MTYP(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0xc)|value<<2)
}
func (o *FSMC_Type) GetBCR3_MTYP() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0xc) >> 2
}
func (o *FSMC_Type) SetBCR3_MUXEN(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x2)|value<<1)
}
func (o *FSMC_Type) GetBCR3_MUXEN() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x2) >> 1
}
func (o *FSMC_Type) SetBCR3_MBKEN(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x1)|value)
}
func (o *FSMC_Type) GetBCR3_MBKEN() uint32 {
	return volatile.LoadUint32(&o.BCR3.Reg) & 0x1
}
func (o *FSMC_Type) SetBCR3_CPSIZE(value uint32) {
	volatile.StoreUint32(&o.BCR3.Reg, volatile.LoadUint32(&o.BCR3.Reg)&^(0x70000)|value<<16)
}
func (o *FSMC_Type) GetBCR3_CPSIZE() uint32 {
	return (volatile.LoadUint32(&o.BCR3.Reg) & 0x70000) >> 16
}

// FSMC.BTR3: SRAM/NOR-Flash chip-select timing register 1
func (o *FSMC_Type) SetBTR3_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BTR3.Reg, volatile.LoadUint32(&o.BTR3.Reg)&^(0x30000000)|value<<28)
}
func (o *FSMC_Type) GetBTR3_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BTR3.Reg) & 0x30000000) >> 28
}
func (o *FSMC_Type) SetBTR3_DATLAT(value uint32) {
	volatile.StoreUint32(&o.BTR3.Reg, volatile.LoadUint32(&o.BTR3.Reg)&^(0xf000000)|value<<24)
}
func (o *FSMC_Type) GetBTR3_DATLAT() uint32 {
	return (volatile.LoadUint32(&o.BTR3.Reg) & 0xf000000) >> 24
}
func (o *FSMC_Type) SetBTR3_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.BTR3.Reg, volatile.LoadUint32(&o.BTR3.Reg)&^(0xf00000)|value<<20)
}
func (o *FSMC_Type) GetBTR3_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.BTR3.Reg) & 0xf00000) >> 20
}
func (o *FSMC_Type) SetBTR3_BUSTURN(value uint32) {
	volatile.StoreUint32(&o.BTR3.Reg, volatile.LoadUint32(&o.BTR3.Reg)&^(0xf0000)|value<<16)
}
func (o *FSMC_Type) GetBTR3_BUSTURN() uint32 {
	return (volatile.LoadUint32(&o.BTR3.Reg) & 0xf0000) >> 16
}
func (o *FSMC_Type) SetBTR3_DATAST(value uint32) {
	volatile.StoreUint32(&o.BTR3.Reg, volatile.LoadUint32(&o.BTR3.Reg)&^(0xff00)|value<<8)
}
func (o *FSMC_Type) GetBTR3_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BTR3.Reg) & 0xff00) >> 8
}
func (o *FSMC_Type) SetBTR3_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BTR3.Reg, volatile.LoadUint32(&o.BTR3.Reg)&^(0xf0)|value<<4)
}
func (o *FSMC_Type) GetBTR3_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BTR3.Reg) & 0xf0) >> 4
}
func (o *FSMC_Type) SetBTR3_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BTR3.Reg, volatile.LoadUint32(&o.BTR3.Reg)&^(0xf)|value)
}
func (o *FSMC_Type) GetBTR3_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BTR3.Reg) & 0xf
}

// FSMC.BCR4: SRAM/NOR-Flash chip-select control register 2
func (o *FSMC_Type) SetBCR4_CBURSTRW(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x80000)|value<<19)
}
func (o *FSMC_Type) GetBCR4_CBURSTRW() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x80000) >> 19
}
func (o *FSMC_Type) SetBCR4_ASYNCWAIT(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x8000)|value<<15)
}
func (o *FSMC_Type) GetBCR4_ASYNCWAIT() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x8000) >> 15
}
func (o *FSMC_Type) SetBCR4_EXTMOD(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x4000)|value<<14)
}
func (o *FSMC_Type) GetBCR4_EXTMOD() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x4000) >> 14
}
func (o *FSMC_Type) SetBCR4_WAITEN(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x2000)|value<<13)
}
func (o *FSMC_Type) GetBCR4_WAITEN() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x2000) >> 13
}
func (o *FSMC_Type) SetBCR4_WREN(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x1000)|value<<12)
}
func (o *FSMC_Type) GetBCR4_WREN() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x1000) >> 12
}
func (o *FSMC_Type) SetBCR4_WAITCFG(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x800)|value<<11)
}
func (o *FSMC_Type) GetBCR4_WAITCFG() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x800) >> 11
}
func (o *FSMC_Type) SetBCR4_WRAPMOD(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x400)|value<<10)
}
func (o *FSMC_Type) GetBCR4_WRAPMOD() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x400) >> 10
}
func (o *FSMC_Type) SetBCR4_WAITPOL(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x200)|value<<9)
}
func (o *FSMC_Type) GetBCR4_WAITPOL() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x200) >> 9
}
func (o *FSMC_Type) SetBCR4_BURSTEN(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x100)|value<<8)
}
func (o *FSMC_Type) GetBCR4_BURSTEN() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x100) >> 8
}
func (o *FSMC_Type) SetBCR4_FACCEN(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x40)|value<<6)
}
func (o *FSMC_Type) GetBCR4_FACCEN() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x40) >> 6
}
func (o *FSMC_Type) SetBCR4_MWID(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x30)|value<<4)
}
func (o *FSMC_Type) GetBCR4_MWID() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x30) >> 4
}
func (o *FSMC_Type) SetBCR4_MTYP(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0xc)|value<<2)
}
func (o *FSMC_Type) GetBCR4_MTYP() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0xc) >> 2
}
func (o *FSMC_Type) SetBCR4_MUXEN(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x2)|value<<1)
}
func (o *FSMC_Type) GetBCR4_MUXEN() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x2) >> 1
}
func (o *FSMC_Type) SetBCR4_MBKEN(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x1)|value)
}
func (o *FSMC_Type) GetBCR4_MBKEN() uint32 {
	return volatile.LoadUint32(&o.BCR4.Reg) & 0x1
}
func (o *FSMC_Type) SetBCR4_CPSIZE(value uint32) {
	volatile.StoreUint32(&o.BCR4.Reg, volatile.LoadUint32(&o.BCR4.Reg)&^(0x70000)|value<<16)
}
func (o *FSMC_Type) GetBCR4_CPSIZE() uint32 {
	return (volatile.LoadUint32(&o.BCR4.Reg) & 0x70000) >> 16
}

// FSMC.BTR4: SRAM/NOR-Flash chip-select timing register 1
func (o *FSMC_Type) SetBTR4_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BTR4.Reg, volatile.LoadUint32(&o.BTR4.Reg)&^(0x30000000)|value<<28)
}
func (o *FSMC_Type) GetBTR4_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BTR4.Reg) & 0x30000000) >> 28
}
func (o *FSMC_Type) SetBTR4_DATLAT(value uint32) {
	volatile.StoreUint32(&o.BTR4.Reg, volatile.LoadUint32(&o.BTR4.Reg)&^(0xf000000)|value<<24)
}
func (o *FSMC_Type) GetBTR4_DATLAT() uint32 {
	return (volatile.LoadUint32(&o.BTR4.Reg) & 0xf000000) >> 24
}
func (o *FSMC_Type) SetBTR4_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.BTR4.Reg, volatile.LoadUint32(&o.BTR4.Reg)&^(0xf00000)|value<<20)
}
func (o *FSMC_Type) GetBTR4_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.BTR4.Reg) & 0xf00000) >> 20
}
func (o *FSMC_Type) SetBTR4_BUSTURN(value uint32) {
	volatile.StoreUint32(&o.BTR4.Reg, volatile.LoadUint32(&o.BTR4.Reg)&^(0xf0000)|value<<16)
}
func (o *FSMC_Type) GetBTR4_BUSTURN() uint32 {
	return (volatile.LoadUint32(&o.BTR4.Reg) & 0xf0000) >> 16
}
func (o *FSMC_Type) SetBTR4_DATAST(value uint32) {
	volatile.StoreUint32(&o.BTR4.Reg, volatile.LoadUint32(&o.BTR4.Reg)&^(0xff00)|value<<8)
}
func (o *FSMC_Type) GetBTR4_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BTR4.Reg) & 0xff00) >> 8
}
func (o *FSMC_Type) SetBTR4_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BTR4.Reg, volatile.LoadUint32(&o.BTR4.Reg)&^(0xf0)|value<<4)
}
func (o *FSMC_Type) GetBTR4_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BTR4.Reg) & 0xf0) >> 4
}
func (o *FSMC_Type) SetBTR4_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BTR4.Reg, volatile.LoadUint32(&o.BTR4.Reg)&^(0xf)|value)
}
func (o *FSMC_Type) GetBTR4_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BTR4.Reg) & 0xf
}

// FSMC.PCR: PC Card/NAND Flash control register
func (o *FSMC_Type) SetPCR_ECCPS(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0xe0000)|value<<17)
}
func (o *FSMC_Type) GetPCR_ECCPS() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0xe0000) >> 17
}
func (o *FSMC_Type) SetPCR_TAR(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x1e000)|value<<13)
}
func (o *FSMC_Type) GetPCR_TAR() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x1e000) >> 13
}
func (o *FSMC_Type) SetPCR_TCLR(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x1e00)|value<<9)
}
func (o *FSMC_Type) GetPCR_TCLR() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x1e00) >> 9
}
func (o *FSMC_Type) SetPCR_ECCEN(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x40)|value<<6)
}
func (o *FSMC_Type) GetPCR_ECCEN() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x40) >> 6
}
func (o *FSMC_Type) SetPCR_PWID(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x30)|value<<4)
}
func (o *FSMC_Type) GetPCR_PWID() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x30) >> 4
}
func (o *FSMC_Type) SetPCR_PTYP(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x8)|value<<3)
}
func (o *FSMC_Type) GetPCR_PTYP() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x8) >> 3
}
func (o *FSMC_Type) SetPCR_PBKEN(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x4)|value<<2)
}
func (o *FSMC_Type) GetPCR_PBKEN() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x4) >> 2
}
func (o *FSMC_Type) SetPCR_PWAITEN(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x2)|value<<1)
}
func (o *FSMC_Type) GetPCR_PWAITEN() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x2) >> 1
}

// FSMC.SR: FIFO status and interrupt register
func (o *FSMC_Type) SetSR_FEMPT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *FSMC_Type) GetSR_FEMPT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *FSMC_Type) SetSR_IFEN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *FSMC_Type) GetSR_IFEN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *FSMC_Type) SetSR_ILEN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *FSMC_Type) GetSR_ILEN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *FSMC_Type) SetSR_IREN(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *FSMC_Type) GetSR_IREN() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *FSMC_Type) SetSR_IFS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *FSMC_Type) GetSR_IFS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *FSMC_Type) SetSR_ILS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *FSMC_Type) GetSR_ILS() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *FSMC_Type) SetSR_IRS(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *FSMC_Type) GetSR_IRS() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// FSMC.PMEM: Common memory space timing register
func (o *FSMC_Type) SetPMEM_MEMHIZ(value uint32) {
	volatile.StoreUint32(&o.PMEM.Reg, volatile.LoadUint32(&o.PMEM.Reg)&^(0xff000000)|value<<24)
}
func (o *FSMC_Type) GetPMEM_MEMHIZ() uint32 {
	return (volatile.LoadUint32(&o.PMEM.Reg) & 0xff000000) >> 24
}
func (o *FSMC_Type) SetPMEM_MEMHOLD(value uint32) {
	volatile.StoreUint32(&o.PMEM.Reg, volatile.LoadUint32(&o.PMEM.Reg)&^(0xff0000)|value<<16)
}
func (o *FSMC_Type) GetPMEM_MEMHOLD() uint32 {
	return (volatile.LoadUint32(&o.PMEM.Reg) & 0xff0000) >> 16
}
func (o *FSMC_Type) SetPMEM_MEMWAIT(value uint32) {
	volatile.StoreUint32(&o.PMEM.Reg, volatile.LoadUint32(&o.PMEM.Reg)&^(0xff00)|value<<8)
}
func (o *FSMC_Type) GetPMEM_MEMWAIT() uint32 {
	return (volatile.LoadUint32(&o.PMEM.Reg) & 0xff00) >> 8
}
func (o *FSMC_Type) SetPMEM_MEMSET(value uint32) {
	volatile.StoreUint32(&o.PMEM.Reg, volatile.LoadUint32(&o.PMEM.Reg)&^(0xff)|value)
}
func (o *FSMC_Type) GetPMEM_MEMSET() uint32 {
	return volatile.LoadUint32(&o.PMEM.Reg) & 0xff
}

// FSMC.PATT: Attribute memory space timing register
func (o *FSMC_Type) SetPATT_ATTHIZ(value uint32) {
	volatile.StoreUint32(&o.PATT.Reg, volatile.LoadUint32(&o.PATT.Reg)&^(0xff000000)|value<<24)
}
func (o *FSMC_Type) GetPATT_ATTHIZ() uint32 {
	return (volatile.LoadUint32(&o.PATT.Reg) & 0xff000000) >> 24
}
func (o *FSMC_Type) SetPATT_ATTHOLD(value uint32) {
	volatile.StoreUint32(&o.PATT.Reg, volatile.LoadUint32(&o.PATT.Reg)&^(0xff0000)|value<<16)
}
func (o *FSMC_Type) GetPATT_ATTHOLD() uint32 {
	return (volatile.LoadUint32(&o.PATT.Reg) & 0xff0000) >> 16
}
func (o *FSMC_Type) SetPATT_ATTWAIT(value uint32) {
	volatile.StoreUint32(&o.PATT.Reg, volatile.LoadUint32(&o.PATT.Reg)&^(0xff00)|value<<8)
}
func (o *FSMC_Type) GetPATT_ATTWAIT() uint32 {
	return (volatile.LoadUint32(&o.PATT.Reg) & 0xff00) >> 8
}
func (o *FSMC_Type) SetPATT_ATTSET(value uint32) {
	volatile.StoreUint32(&o.PATT.Reg, volatile.LoadUint32(&o.PATT.Reg)&^(0xff)|value)
}
func (o *FSMC_Type) GetPATT_ATTSET() uint32 {
	return volatile.LoadUint32(&o.PATT.Reg) & 0xff
}

// FSMC.ECCR: ECC result register
func (o *FSMC_Type) SetECCR(value uint32) {
	volatile.StoreUint32(&o.ECCR.Reg, value)
}
func (o *FSMC_Type) GetECCR() uint32 {
	return volatile.LoadUint32(&o.ECCR.Reg)
}

// FSMC.BWTR1: SRAM/NOR-Flash write timing registers 1
func (o *FSMC_Type) SetBWTR1_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BWTR1.Reg, volatile.LoadUint32(&o.BWTR1.Reg)&^(0x30000000)|value<<28)
}
func (o *FSMC_Type) GetBWTR1_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BWTR1.Reg) & 0x30000000) >> 28
}
func (o *FSMC_Type) SetBWTR1_DATLAT(value uint32) {
	volatile.StoreUint32(&o.BWTR1.Reg, volatile.LoadUint32(&o.BWTR1.Reg)&^(0xf000000)|value<<24)
}
func (o *FSMC_Type) GetBWTR1_DATLAT() uint32 {
	return (volatile.LoadUint32(&o.BWTR1.Reg) & 0xf000000) >> 24
}
func (o *FSMC_Type) SetBWTR1_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.BWTR1.Reg, volatile.LoadUint32(&o.BWTR1.Reg)&^(0xf00000)|value<<20)
}
func (o *FSMC_Type) GetBWTR1_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.BWTR1.Reg) & 0xf00000) >> 20
}
func (o *FSMC_Type) SetBWTR1_DATAST(value uint32) {
	volatile.StoreUint32(&o.BWTR1.Reg, volatile.LoadUint32(&o.BWTR1.Reg)&^(0xff00)|value<<8)
}
func (o *FSMC_Type) GetBWTR1_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BWTR1.Reg) & 0xff00) >> 8
}
func (o *FSMC_Type) SetBWTR1_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BWTR1.Reg, volatile.LoadUint32(&o.BWTR1.Reg)&^(0xf0)|value<<4)
}
func (o *FSMC_Type) GetBWTR1_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BWTR1.Reg) & 0xf0) >> 4
}
func (o *FSMC_Type) SetBWTR1_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BWTR1.Reg, volatile.LoadUint32(&o.BWTR1.Reg)&^(0xf)|value)
}
func (o *FSMC_Type) GetBWTR1_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BWTR1.Reg) & 0xf
}
func (o *FSMC_Type) SetBWTR1_BUSTURN(value uint32) {
	volatile.StoreUint32(&o.BWTR1.Reg, volatile.LoadUint32(&o.BWTR1.Reg)&^(0xf0000)|value<<16)
}
func (o *FSMC_Type) GetBWTR1_BUSTURN() uint32 {
	return (volatile.LoadUint32(&o.BWTR1.Reg) & 0xf0000) >> 16
}

// FSMC.BWTR2: SRAM/NOR-Flash write timing registers 1
func (o *FSMC_Type) SetBWTR2_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BWTR2.Reg, volatile.LoadUint32(&o.BWTR2.Reg)&^(0x30000000)|value<<28)
}
func (o *FSMC_Type) GetBWTR2_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BWTR2.Reg) & 0x30000000) >> 28
}
func (o *FSMC_Type) SetBWTR2_DATLAT(value uint32) {
	volatile.StoreUint32(&o.BWTR2.Reg, volatile.LoadUint32(&o.BWTR2.Reg)&^(0xf000000)|value<<24)
}
func (o *FSMC_Type) GetBWTR2_DATLAT() uint32 {
	return (volatile.LoadUint32(&o.BWTR2.Reg) & 0xf000000) >> 24
}
func (o *FSMC_Type) SetBWTR2_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.BWTR2.Reg, volatile.LoadUint32(&o.BWTR2.Reg)&^(0xf00000)|value<<20)
}
func (o *FSMC_Type) GetBWTR2_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.BWTR2.Reg) & 0xf00000) >> 20
}
func (o *FSMC_Type) SetBWTR2_DATAST(value uint32) {
	volatile.StoreUint32(&o.BWTR2.Reg, volatile.LoadUint32(&o.BWTR2.Reg)&^(0xff00)|value<<8)
}
func (o *FSMC_Type) GetBWTR2_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BWTR2.Reg) & 0xff00) >> 8
}
func (o *FSMC_Type) SetBWTR2_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BWTR2.Reg, volatile.LoadUint32(&o.BWTR2.Reg)&^(0xf0)|value<<4)
}
func (o *FSMC_Type) GetBWTR2_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BWTR2.Reg) & 0xf0) >> 4
}
func (o *FSMC_Type) SetBWTR2_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BWTR2.Reg, volatile.LoadUint32(&o.BWTR2.Reg)&^(0xf)|value)
}
func (o *FSMC_Type) GetBWTR2_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BWTR2.Reg) & 0xf
}
func (o *FSMC_Type) SetBWTR2_BUSTURN(value uint32) {
	volatile.StoreUint32(&o.BWTR2.Reg, volatile.LoadUint32(&o.BWTR2.Reg)&^(0xf0000)|value<<16)
}
func (o *FSMC_Type) GetBWTR2_BUSTURN() uint32 {
	return (volatile.LoadUint32(&o.BWTR2.Reg) & 0xf0000) >> 16
}

// FSMC.BWTR3: SRAM/NOR-Flash write timing registers 1
func (o *FSMC_Type) SetBWTR3_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BWTR3.Reg, volatile.LoadUint32(&o.BWTR3.Reg)&^(0x30000000)|value<<28)
}
func (o *FSMC_Type) GetBWTR3_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BWTR3.Reg) & 0x30000000) >> 28
}
func (o *FSMC_Type) SetBWTR3_DATLAT(value uint32) {
	volatile.StoreUint32(&o.BWTR3.Reg, volatile.LoadUint32(&o.BWTR3.Reg)&^(0xf000000)|value<<24)
}
func (o *FSMC_Type) GetBWTR3_DATLAT() uint32 {
	return (volatile.LoadUint32(&o.BWTR3.Reg) & 0xf000000) >> 24
}
func (o *FSMC_Type) SetBWTR3_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.BWTR3.Reg, volatile.LoadUint32(&o.BWTR3.Reg)&^(0xf00000)|value<<20)
}
func (o *FSMC_Type) GetBWTR3_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.BWTR3.Reg) & 0xf00000) >> 20
}
func (o *FSMC_Type) SetBWTR3_DATAST(value uint32) {
	volatile.StoreUint32(&o.BWTR3.Reg, volatile.LoadUint32(&o.BWTR3.Reg)&^(0xff00)|value<<8)
}
func (o *FSMC_Type) GetBWTR3_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BWTR3.Reg) & 0xff00) >> 8
}
func (o *FSMC_Type) SetBWTR3_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BWTR3.Reg, volatile.LoadUint32(&o.BWTR3.Reg)&^(0xf0)|value<<4)
}
func (o *FSMC_Type) GetBWTR3_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BWTR3.Reg) & 0xf0) >> 4
}
func (o *FSMC_Type) SetBWTR3_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BWTR3.Reg, volatile.LoadUint32(&o.BWTR3.Reg)&^(0xf)|value)
}
func (o *FSMC_Type) GetBWTR3_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BWTR3.Reg) & 0xf
}
func (o *FSMC_Type) SetBWTR3_BUSTURN(value uint32) {
	volatile.StoreUint32(&o.BWTR3.Reg, volatile.LoadUint32(&o.BWTR3.Reg)&^(0xf0000)|value<<16)
}
func (o *FSMC_Type) GetBWTR3_BUSTURN() uint32 {
	return (volatile.LoadUint32(&o.BWTR3.Reg) & 0xf0000) >> 16
}

// FSMC.BWTR4: SRAM/NOR-Flash write timing registers 1
func (o *FSMC_Type) SetBWTR4_ACCMOD(value uint32) {
	volatile.StoreUint32(&o.BWTR4.Reg, volatile.LoadUint32(&o.BWTR4.Reg)&^(0x30000000)|value<<28)
}
func (o *FSMC_Type) GetBWTR4_ACCMOD() uint32 {
	return (volatile.LoadUint32(&o.BWTR4.Reg) & 0x30000000) >> 28
}
func (o *FSMC_Type) SetBWTR4_DATLAT(value uint32) {
	volatile.StoreUint32(&o.BWTR4.Reg, volatile.LoadUint32(&o.BWTR4.Reg)&^(0xf000000)|value<<24)
}
func (o *FSMC_Type) GetBWTR4_DATLAT() uint32 {
	return (volatile.LoadUint32(&o.BWTR4.Reg) & 0xf000000) >> 24
}
func (o *FSMC_Type) SetBWTR4_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.BWTR4.Reg, volatile.LoadUint32(&o.BWTR4.Reg)&^(0xf00000)|value<<20)
}
func (o *FSMC_Type) GetBWTR4_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.BWTR4.Reg) & 0xf00000) >> 20
}
func (o *FSMC_Type) SetBWTR4_DATAST(value uint32) {
	volatile.StoreUint32(&o.BWTR4.Reg, volatile.LoadUint32(&o.BWTR4.Reg)&^(0xff00)|value<<8)
}
func (o *FSMC_Type) GetBWTR4_DATAST() uint32 {
	return (volatile.LoadUint32(&o.BWTR4.Reg) & 0xff00) >> 8
}
func (o *FSMC_Type) SetBWTR4_ADDHLD(value uint32) {
	volatile.StoreUint32(&o.BWTR4.Reg, volatile.LoadUint32(&o.BWTR4.Reg)&^(0xf0)|value<<4)
}
func (o *FSMC_Type) GetBWTR4_ADDHLD() uint32 {
	return (volatile.LoadUint32(&o.BWTR4.Reg) & 0xf0) >> 4
}
func (o *FSMC_Type) SetBWTR4_ADDSET(value uint32) {
	volatile.StoreUint32(&o.BWTR4.Reg, volatile.LoadUint32(&o.BWTR4.Reg)&^(0xf)|value)
}
func (o *FSMC_Type) GetBWTR4_ADDSET() uint32 {
	return volatile.LoadUint32(&o.BWTR4.Reg) & 0xf
}
func (o *FSMC_Type) SetBWTR4_BUSTURN(value uint32) {
	volatile.StoreUint32(&o.BWTR4.Reg, volatile.LoadUint32(&o.BWTR4.Reg)&^(0xf0000)|value<<16)
}
func (o *FSMC_Type) GetBWTR4_BUSTURN() uint32 {
	return (volatile.LoadUint32(&o.BWTR4.Reg) & 0xf0000) >> 16
}

// FSMC.SDCR1: SDRAM Control Register 1
func (o *FSMC_Type) SetSDCR1_NC(value uint32) {
	volatile.StoreUint32(&o.SDCR1.Reg, volatile.LoadUint32(&o.SDCR1.Reg)&^(0x3)|value)
}
func (o *FSMC_Type) GetSDCR1_NC() uint32 {
	return volatile.LoadUint32(&o.SDCR1.Reg) & 0x3
}
func (o *FSMC_Type) SetSDCR1_NR(value uint32) {
	volatile.StoreUint32(&o.SDCR1.Reg, volatile.LoadUint32(&o.SDCR1.Reg)&^(0xc)|value<<2)
}
func (o *FSMC_Type) GetSDCR1_NR() uint32 {
	return (volatile.LoadUint32(&o.SDCR1.Reg) & 0xc) >> 2
}
func (o *FSMC_Type) SetSDCR1_MWID(value uint32) {
	volatile.StoreUint32(&o.SDCR1.Reg, volatile.LoadUint32(&o.SDCR1.Reg)&^(0x30)|value<<4)
}
func (o *FSMC_Type) GetSDCR1_MWID() uint32 {
	return (volatile.LoadUint32(&o.SDCR1.Reg) & 0x30) >> 4
}
func (o *FSMC_Type) SetSDCR1_NB(value uint32) {
	volatile.StoreUint32(&o.SDCR1.Reg, volatile.LoadUint32(&o.SDCR1.Reg)&^(0x40)|value<<6)
}
func (o *FSMC_Type) GetSDCR1_NB() uint32 {
	return (volatile.LoadUint32(&o.SDCR1.Reg) & 0x40) >> 6
}
func (o *FSMC_Type) SetSDCR1_CAS(value uint32) {
	volatile.StoreUint32(&o.SDCR1.Reg, volatile.LoadUint32(&o.SDCR1.Reg)&^(0x180)|value<<7)
}
func (o *FSMC_Type) GetSDCR1_CAS() uint32 {
	return (volatile.LoadUint32(&o.SDCR1.Reg) & 0x180) >> 7
}
func (o *FSMC_Type) SetSDCR1_WP(value uint32) {
	volatile.StoreUint32(&o.SDCR1.Reg, volatile.LoadUint32(&o.SDCR1.Reg)&^(0x200)|value<<9)
}
func (o *FSMC_Type) GetSDCR1_WP() uint32 {
	return (volatile.LoadUint32(&o.SDCR1.Reg) & 0x200) >> 9
}
func (o *FSMC_Type) SetSDCR1_SDCLK(value uint32) {
	volatile.StoreUint32(&o.SDCR1.Reg, volatile.LoadUint32(&o.SDCR1.Reg)&^(0xc00)|value<<10)
}
func (o *FSMC_Type) GetSDCR1_SDCLK() uint32 {
	return (volatile.LoadUint32(&o.SDCR1.Reg) & 0xc00) >> 10
}
func (o *FSMC_Type) SetSDCR1_RBURST(value uint32) {
	volatile.StoreUint32(&o.SDCR1.Reg, volatile.LoadUint32(&o.SDCR1.Reg)&^(0x1000)|value<<12)
}
func (o *FSMC_Type) GetSDCR1_RBURST() uint32 {
	return (volatile.LoadUint32(&o.SDCR1.Reg) & 0x1000) >> 12
}
func (o *FSMC_Type) SetSDCR1_RPIPE(value uint32) {
	volatile.StoreUint32(&o.SDCR1.Reg, volatile.LoadUint32(&o.SDCR1.Reg)&^(0x6000)|value<<13)
}
func (o *FSMC_Type) GetSDCR1_RPIPE() uint32 {
	return (volatile.LoadUint32(&o.SDCR1.Reg) & 0x6000) >> 13
}

// FSMC.SDCR2: SDRAM Control Register 1
func (o *FSMC_Type) SetSDCR2_NC(value uint32) {
	volatile.StoreUint32(&o.SDCR2.Reg, volatile.LoadUint32(&o.SDCR2.Reg)&^(0x3)|value)
}
func (o *FSMC_Type) GetSDCR2_NC() uint32 {
	return volatile.LoadUint32(&o.SDCR2.Reg) & 0x3
}
func (o *FSMC_Type) SetSDCR2_NR(value uint32) {
	volatile.StoreUint32(&o.SDCR2.Reg, volatile.LoadUint32(&o.SDCR2.Reg)&^(0xc)|value<<2)
}
func (o *FSMC_Type) GetSDCR2_NR() uint32 {
	return (volatile.LoadUint32(&o.SDCR2.Reg) & 0xc) >> 2
}
func (o *FSMC_Type) SetSDCR2_MWID(value uint32) {
	volatile.StoreUint32(&o.SDCR2.Reg, volatile.LoadUint32(&o.SDCR2.Reg)&^(0x30)|value<<4)
}
func (o *FSMC_Type) GetSDCR2_MWID() uint32 {
	return (volatile.LoadUint32(&o.SDCR2.Reg) & 0x30) >> 4
}
func (o *FSMC_Type) SetSDCR2_NB(value uint32) {
	volatile.StoreUint32(&o.SDCR2.Reg, volatile.LoadUint32(&o.SDCR2.Reg)&^(0x40)|value<<6)
}
func (o *FSMC_Type) GetSDCR2_NB() uint32 {
	return (volatile.LoadUint32(&o.SDCR2.Reg) & 0x40) >> 6
}
func (o *FSMC_Type) SetSDCR2_CAS(value uint32) {
	volatile.StoreUint32(&o.SDCR2.Reg, volatile.LoadUint32(&o.SDCR2.Reg)&^(0x180)|value<<7)
}
func (o *FSMC_Type) GetSDCR2_CAS() uint32 {
	return (volatile.LoadUint32(&o.SDCR2.Reg) & 0x180) >> 7
}
func (o *FSMC_Type) SetSDCR2_WP(value uint32) {
	volatile.StoreUint32(&o.SDCR2.Reg, volatile.LoadUint32(&o.SDCR2.Reg)&^(0x200)|value<<9)
}
func (o *FSMC_Type) GetSDCR2_WP() uint32 {
	return (volatile.LoadUint32(&o.SDCR2.Reg) & 0x200) >> 9
}
func (o *FSMC_Type) SetSDCR2_SDCLK(value uint32) {
	volatile.StoreUint32(&o.SDCR2.Reg, volatile.LoadUint32(&o.SDCR2.Reg)&^(0xc00)|value<<10)
}
func (o *FSMC_Type) GetSDCR2_SDCLK() uint32 {
	return (volatile.LoadUint32(&o.SDCR2.Reg) & 0xc00) >> 10
}
func (o *FSMC_Type) SetSDCR2_RBURST(value uint32) {
	volatile.StoreUint32(&o.SDCR2.Reg, volatile.LoadUint32(&o.SDCR2.Reg)&^(0x1000)|value<<12)
}
func (o *FSMC_Type) GetSDCR2_RBURST() uint32 {
	return (volatile.LoadUint32(&o.SDCR2.Reg) & 0x1000) >> 12
}
func (o *FSMC_Type) SetSDCR2_RPIPE(value uint32) {
	volatile.StoreUint32(&o.SDCR2.Reg, volatile.LoadUint32(&o.SDCR2.Reg)&^(0x6000)|value<<13)
}
func (o *FSMC_Type) GetSDCR2_RPIPE() uint32 {
	return (volatile.LoadUint32(&o.SDCR2.Reg) & 0x6000) >> 13
}

// FSMC.SDTR1: SDRAM Timing register 1
func (o *FSMC_Type) SetSDTR1_TMRD(value uint32) {
	volatile.StoreUint32(&o.SDTR1.Reg, volatile.LoadUint32(&o.SDTR1.Reg)&^(0xf)|value)
}
func (o *FSMC_Type) GetSDTR1_TMRD() uint32 {
	return volatile.LoadUint32(&o.SDTR1.Reg) & 0xf
}
func (o *FSMC_Type) SetSDTR1_TXSR(value uint32) {
	volatile.StoreUint32(&o.SDTR1.Reg, volatile.LoadUint32(&o.SDTR1.Reg)&^(0xf0)|value<<4)
}
func (o *FSMC_Type) GetSDTR1_TXSR() uint32 {
	return (volatile.LoadUint32(&o.SDTR1.Reg) & 0xf0) >> 4
}
func (o *FSMC_Type) SetSDTR1_TRAS(value uint32) {
	volatile.StoreUint32(&o.SDTR1.Reg, volatile.LoadUint32(&o.SDTR1.Reg)&^(0xf00)|value<<8)
}
func (o *FSMC_Type) GetSDTR1_TRAS() uint32 {
	return (volatile.LoadUint32(&o.SDTR1.Reg) & 0xf00) >> 8
}
func (o *FSMC_Type) SetSDTR1_TRC(value uint32) {
	volatile.StoreUint32(&o.SDTR1.Reg, volatile.LoadUint32(&o.SDTR1.Reg)&^(0xf000)|value<<12)
}
func (o *FSMC_Type) GetSDTR1_TRC() uint32 {
	return (volatile.LoadUint32(&o.SDTR1.Reg) & 0xf000) >> 12
}
func (o *FSMC_Type) SetSDTR1_TWR(value uint32) {
	volatile.StoreUint32(&o.SDTR1.Reg, volatile.LoadUint32(&o.SDTR1.Reg)&^(0xf0000)|value<<16)
}
func (o *FSMC_Type) GetSDTR1_TWR() uint32 {
	return (volatile.LoadUint32(&o.SDTR1.Reg) & 0xf0000) >> 16
}
func (o *FSMC_Type) SetSDTR1_TRP(value uint32) {
	volatile.StoreUint32(&o.SDTR1.Reg, volatile.LoadUint32(&o.SDTR1.Reg)&^(0xf00000)|value<<20)
}
func (o *FSMC_Type) GetSDTR1_TRP() uint32 {
	return (volatile.LoadUint32(&o.SDTR1.Reg) & 0xf00000) >> 20
}
func (o *FSMC_Type) SetSDTR1_TRCD(value uint32) {
	volatile.StoreUint32(&o.SDTR1.Reg, volatile.LoadUint32(&o.SDTR1.Reg)&^(0xf000000)|value<<24)
}
func (o *FSMC_Type) GetSDTR1_TRCD() uint32 {
	return (volatile.LoadUint32(&o.SDTR1.Reg) & 0xf000000) >> 24
}

// FSMC.SDTR2: SDRAM Timing register 1
func (o *FSMC_Type) SetSDTR2_TMRD(value uint32) {
	volatile.StoreUint32(&o.SDTR2.Reg, volatile.LoadUint32(&o.SDTR2.Reg)&^(0xf)|value)
}
func (o *FSMC_Type) GetSDTR2_TMRD() uint32 {
	return volatile.LoadUint32(&o.SDTR2.Reg) & 0xf
}
func (o *FSMC_Type) SetSDTR2_TXSR(value uint32) {
	volatile.StoreUint32(&o.SDTR2.Reg, volatile.LoadUint32(&o.SDTR2.Reg)&^(0xf0)|value<<4)
}
func (o *FSMC_Type) GetSDTR2_TXSR() uint32 {
	return (volatile.LoadUint32(&o.SDTR2.Reg) & 0xf0) >> 4
}
func (o *FSMC_Type) SetSDTR2_TRAS(value uint32) {
	volatile.StoreUint32(&o.SDTR2.Reg, volatile.LoadUint32(&o.SDTR2.Reg)&^(0xf00)|value<<8)
}
func (o *FSMC_Type) GetSDTR2_TRAS() uint32 {
	return (volatile.LoadUint32(&o.SDTR2.Reg) & 0xf00) >> 8
}
func (o *FSMC_Type) SetSDTR2_TRC(value uint32) {
	volatile.StoreUint32(&o.SDTR2.Reg, volatile.LoadUint32(&o.SDTR2.Reg)&^(0xf000)|value<<12)
}
func (o *FSMC_Type) GetSDTR2_TRC() uint32 {
	return (volatile.LoadUint32(&o.SDTR2.Reg) & 0xf000) >> 12
}
func (o *FSMC_Type) SetSDTR2_TWR(value uint32) {
	volatile.StoreUint32(&o.SDTR2.Reg, volatile.LoadUint32(&o.SDTR2.Reg)&^(0xf0000)|value<<16)
}
func (o *FSMC_Type) GetSDTR2_TWR() uint32 {
	return (volatile.LoadUint32(&o.SDTR2.Reg) & 0xf0000) >> 16
}
func (o *FSMC_Type) SetSDTR2_TRP(value uint32) {
	volatile.StoreUint32(&o.SDTR2.Reg, volatile.LoadUint32(&o.SDTR2.Reg)&^(0xf00000)|value<<20)
}
func (o *FSMC_Type) GetSDTR2_TRP() uint32 {
	return (volatile.LoadUint32(&o.SDTR2.Reg) & 0xf00000) >> 20
}
func (o *FSMC_Type) SetSDTR2_TRCD(value uint32) {
	volatile.StoreUint32(&o.SDTR2.Reg, volatile.LoadUint32(&o.SDTR2.Reg)&^(0xf000000)|value<<24)
}
func (o *FSMC_Type) GetSDTR2_TRCD() uint32 {
	return (volatile.LoadUint32(&o.SDTR2.Reg) & 0xf000000) >> 24
}

// FSMC.SDCMR: SDRAM Command Mode register
func (o *FSMC_Type) SetSDCMR_MODE(value uint32) {
	volatile.StoreUint32(&o.SDCMR.Reg, volatile.LoadUint32(&o.SDCMR.Reg)&^(0x7)|value)
}
func (o *FSMC_Type) GetSDCMR_MODE() uint32 {
	return volatile.LoadUint32(&o.SDCMR.Reg) & 0x7
}
func (o *FSMC_Type) SetSDCMR_CTB2(value uint32) {
	volatile.StoreUint32(&o.SDCMR.Reg, volatile.LoadUint32(&o.SDCMR.Reg)&^(0x8)|value<<3)
}
func (o *FSMC_Type) GetSDCMR_CTB2() uint32 {
	return (volatile.LoadUint32(&o.SDCMR.Reg) & 0x8) >> 3
}
func (o *FSMC_Type) SetSDCMR_CTB1(value uint32) {
	volatile.StoreUint32(&o.SDCMR.Reg, volatile.LoadUint32(&o.SDCMR.Reg)&^(0x10)|value<<4)
}
func (o *FSMC_Type) GetSDCMR_CTB1() uint32 {
	return (volatile.LoadUint32(&o.SDCMR.Reg) & 0x10) >> 4
}
func (o *FSMC_Type) SetSDCMR_NRFS(value uint32) {
	volatile.StoreUint32(&o.SDCMR.Reg, volatile.LoadUint32(&o.SDCMR.Reg)&^(0x1e0)|value<<5)
}
func (o *FSMC_Type) GetSDCMR_NRFS() uint32 {
	return (volatile.LoadUint32(&o.SDCMR.Reg) & 0x1e0) >> 5
}
func (o *FSMC_Type) SetSDCMR_MRD(value uint32) {
	volatile.StoreUint32(&o.SDCMR.Reg, volatile.LoadUint32(&o.SDCMR.Reg)&^(0x3ffe00)|value<<9)
}
func (o *FSMC_Type) GetSDCMR_MRD() uint32 {
	return (volatile.LoadUint32(&o.SDCMR.Reg) & 0x3ffe00) >> 9
}

// FSMC.SDRTR: SDRAM Refresh Timer register
func (o *FSMC_Type) SetSDRTR_CRE(value uint32) {
	volatile.StoreUint32(&o.SDRTR.Reg, volatile.LoadUint32(&o.SDRTR.Reg)&^(0x1)|value)
}
func (o *FSMC_Type) GetSDRTR_CRE() uint32 {
	return volatile.LoadUint32(&o.SDRTR.Reg) & 0x1
}
func (o *FSMC_Type) SetSDRTR_COUNT(value uint32) {
	volatile.StoreUint32(&o.SDRTR.Reg, volatile.LoadUint32(&o.SDRTR.Reg)&^(0x3ffe)|value<<1)
}
func (o *FSMC_Type) GetSDRTR_COUNT() uint32 {
	return (volatile.LoadUint32(&o.SDRTR.Reg) & 0x3ffe) >> 1
}
func (o *FSMC_Type) SetSDRTR_REIE(value uint32) {
	volatile.StoreUint32(&o.SDRTR.Reg, volatile.LoadUint32(&o.SDRTR.Reg)&^(0x4000)|value<<14)
}
func (o *FSMC_Type) GetSDRTR_REIE() uint32 {
	return (volatile.LoadUint32(&o.SDRTR.Reg) & 0x4000) >> 14
}

// FSMC.SDSR: SDRAM Status register
func (o *FSMC_Type) SetSDSR_RE(value uint32) {
	volatile.StoreUint32(&o.SDSR.Reg, volatile.LoadUint32(&o.SDSR.Reg)&^(0x1)|value)
}
func (o *FSMC_Type) GetSDSR_RE() uint32 {
	return volatile.LoadUint32(&o.SDSR.Reg) & 0x1
}
func (o *FSMC_Type) SetSDSR_MODES1(value uint32) {
	volatile.StoreUint32(&o.SDSR.Reg, volatile.LoadUint32(&o.SDSR.Reg)&^(0x6)|value<<1)
}
func (o *FSMC_Type) GetSDSR_MODES1() uint32 {
	return (volatile.LoadUint32(&o.SDSR.Reg) & 0x6) >> 1
}
func (o *FSMC_Type) SetSDSR_MODES2(value uint32) {
	volatile.StoreUint32(&o.SDSR.Reg, volatile.LoadUint32(&o.SDSR.Reg)&^(0x18)|value<<3)
}
func (o *FSMC_Type) GetSDSR_MODES2() uint32 {
	return (volatile.LoadUint32(&o.SDSR.Reg) & 0x18) >> 3
}
func (o *FSMC_Type) SetSDSR_BUSY(value uint32) {
	volatile.StoreUint32(&o.SDSR.Reg, volatile.LoadUint32(&o.SDSR.Reg)&^(0x20)|value<<5)
}
func (o *FSMC_Type) GetSDSR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.SDSR.Reg) & 0x20) >> 5
}

// DMA controller
type DMA_Type struct {
	LISR  volatile.Register32 // 0x0
	HISR  volatile.Register32 // 0x4
	LIFCR volatile.Register32 // 0x8
	HIFCR volatile.Register32 // 0xC
	ST    [8]DMA_ST_Type      // 0x10
}

// DMA.LISR: low interrupt status register
func (o *DMA_Type) SetLISR_TCIF3(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetLISR_TCIF3() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x8000000) >> 27
}
func (o *DMA_Type) SetLISR_HTIF3(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetLISR_HTIF3() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetLISR_TEIF3(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetLISR_TEIF3() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetLISR_DMEIF3(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetLISR_DMEIF3() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetLISR_FEIF3(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetLISR_FEIF3() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetLISR_TCIF2(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetLISR_TCIF2() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetLISR_HTIF2(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetLISR_HTIF2() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetLISR_TEIF2(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetLISR_TEIF2() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetLISR_DMEIF2(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetLISR_DMEIF2() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetLISR_FEIF2(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetLISR_FEIF2() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetLISR_TCIF1(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetLISR_TCIF1() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetLISR_HTIF1(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetLISR_HTIF1() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetLISR_TEIF1(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetLISR_TEIF1() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetLISR_DMEIF1(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetLISR_DMEIF1() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetLISR_FEIF1(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetLISR_FEIF1() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetLISR_TCIF0(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetLISR_TCIF0() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetLISR_HTIF0(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetLISR_HTIF0() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetLISR_TEIF0(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetLISR_TEIF0() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetLISR_DMEIF0(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetLISR_DMEIF0() uint32 {
	return (volatile.LoadUint32(&o.LISR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetLISR_FEIF0(value uint32) {
	volatile.StoreUint32(&o.LISR.Reg, volatile.LoadUint32(&o.LISR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetLISR_FEIF0() uint32 {
	return volatile.LoadUint32(&o.LISR.Reg) & 0x1
}

// DMA.HISR: high interrupt status register
func (o *DMA_Type) SetHISR_TCIF7(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetHISR_TCIF7() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x8000000) >> 27
}
func (o *DMA_Type) SetHISR_HTIF7(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetHISR_HTIF7() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetHISR_TEIF7(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetHISR_TEIF7() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetHISR_DMEIF7(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetHISR_DMEIF7() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetHISR_FEIF7(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetHISR_FEIF7() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetHISR_TCIF6(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetHISR_TCIF6() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetHISR_HTIF6(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetHISR_HTIF6() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetHISR_TEIF6(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetHISR_TEIF6() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetHISR_DMEIF6(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetHISR_DMEIF6() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetHISR_FEIF6(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetHISR_FEIF6() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetHISR_TCIF5(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetHISR_TCIF5() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetHISR_HTIF5(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetHISR_HTIF5() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetHISR_TEIF5(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetHISR_TEIF5() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetHISR_DMEIF5(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetHISR_DMEIF5() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetHISR_FEIF5(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetHISR_FEIF5() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetHISR_TCIF4(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetHISR_TCIF4() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetHISR_HTIF4(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetHISR_HTIF4() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetHISR_TEIF4(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetHISR_TEIF4() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetHISR_DMEIF4(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetHISR_DMEIF4() uint32 {
	return (volatile.LoadUint32(&o.HISR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetHISR_FEIF4(value uint32) {
	volatile.StoreUint32(&o.HISR.Reg, volatile.LoadUint32(&o.HISR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetHISR_FEIF4() uint32 {
	return volatile.LoadUint32(&o.HISR.Reg) & 0x1
}

// DMA.LIFCR: low interrupt flag clear register
func (o *DMA_Type) SetLIFCR_CTCIF3(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetLIFCR_CTCIF3() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x8000000) >> 27
}
func (o *DMA_Type) SetLIFCR_CHTIF3(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetLIFCR_CHTIF3() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetLIFCR_CTEIF3(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetLIFCR_CTEIF3() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetLIFCR_CDMEIF3(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetLIFCR_CDMEIF3() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetLIFCR_CFEIF3(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetLIFCR_CFEIF3() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetLIFCR_CTCIF2(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetLIFCR_CTCIF2() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetLIFCR_CHTIF2(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetLIFCR_CHTIF2() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetLIFCR_CTEIF2(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetLIFCR_CTEIF2() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetLIFCR_CDMEIF2(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetLIFCR_CDMEIF2() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetLIFCR_CFEIF2(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetLIFCR_CFEIF2() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetLIFCR_CTCIF1(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetLIFCR_CTCIF1() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetLIFCR_CHTIF1(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetLIFCR_CHTIF1() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetLIFCR_CTEIF1(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetLIFCR_CTEIF1() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetLIFCR_CDMEIF1(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetLIFCR_CDMEIF1() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetLIFCR_CFEIF1(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetLIFCR_CFEIF1() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetLIFCR_CTCIF0(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetLIFCR_CTCIF0() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetLIFCR_CHTIF0(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetLIFCR_CHTIF0() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetLIFCR_CTEIF0(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetLIFCR_CTEIF0() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetLIFCR_CDMEIF0(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetLIFCR_CDMEIF0() uint32 {
	return (volatile.LoadUint32(&o.LIFCR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetLIFCR_CFEIF0(value uint32) {
	volatile.StoreUint32(&o.LIFCR.Reg, volatile.LoadUint32(&o.LIFCR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetLIFCR_CFEIF0() uint32 {
	return volatile.LoadUint32(&o.LIFCR.Reg) & 0x1
}

// DMA.HIFCR: high interrupt flag clear register
func (o *DMA_Type) SetHIFCR_CTCIF7(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x8000000)|value<<27)
}
func (o *DMA_Type) GetHIFCR_CTCIF7() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x8000000) >> 27
}
func (o *DMA_Type) SetHIFCR_CHTIF7(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x4000000)|value<<26)
}
func (o *DMA_Type) GetHIFCR_CHTIF7() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x4000000) >> 26
}
func (o *DMA_Type) SetHIFCR_CTEIF7(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x2000000)|value<<25)
}
func (o *DMA_Type) GetHIFCR_CTEIF7() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x2000000) >> 25
}
func (o *DMA_Type) SetHIFCR_CDMEIF7(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x1000000)|value<<24)
}
func (o *DMA_Type) GetHIFCR_CDMEIF7() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x1000000) >> 24
}
func (o *DMA_Type) SetHIFCR_CFEIF7(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x400000)|value<<22)
}
func (o *DMA_Type) GetHIFCR_CFEIF7() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x400000) >> 22
}
func (o *DMA_Type) SetHIFCR_CTCIF6(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x200000)|value<<21)
}
func (o *DMA_Type) GetHIFCR_CTCIF6() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x200000) >> 21
}
func (o *DMA_Type) SetHIFCR_CHTIF6(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x100000)|value<<20)
}
func (o *DMA_Type) GetHIFCR_CHTIF6() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x100000) >> 20
}
func (o *DMA_Type) SetHIFCR_CTEIF6(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_Type) GetHIFCR_CTEIF6() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x80000) >> 19
}
func (o *DMA_Type) SetHIFCR_CDMEIF6(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_Type) GetHIFCR_CDMEIF6() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x40000) >> 18
}
func (o *DMA_Type) SetHIFCR_CFEIF6(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetHIFCR_CFEIF6() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetHIFCR_CTCIF5(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetHIFCR_CTCIF5() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetHIFCR_CHTIF5(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetHIFCR_CHTIF5() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetHIFCR_CTEIF5(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetHIFCR_CTEIF5() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetHIFCR_CDMEIF5(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetHIFCR_CDMEIF5() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetHIFCR_CFEIF5(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetHIFCR_CFEIF5() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetHIFCR_CTCIF4(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetHIFCR_CTCIF4() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetHIFCR_CHTIF4(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetHIFCR_CHTIF4() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetHIFCR_CTEIF4(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetHIFCR_CTEIF4() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetHIFCR_CDMEIF4(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetHIFCR_CDMEIF4() uint32 {
	return (volatile.LoadUint32(&o.HIFCR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetHIFCR_CFEIF4(value uint32) {
	volatile.StoreUint32(&o.HIFCR.Reg, volatile.LoadUint32(&o.HIFCR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetHIFCR_CFEIF4() uint32 {
	return volatile.LoadUint32(&o.HIFCR.Reg) & 0x1
}

type DMA_ST_Type struct {
	CR   volatile.Register32 // 0x10
	NDTR volatile.Register32 // 0x14
	PAR  volatile.Register32 // 0x18
	M0AR volatile.Register32 // 0x1C
	M1AR volatile.Register32 // 0x20
	FCR  volatile.Register32 // 0x24
}

// DMA_ST.CR: stream x configuration register
func (o *DMA_ST_Type) SetCR_CHSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1e000000)|value<<25)
}
func (o *DMA_ST_Type) GetCR_CHSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1e000000) >> 25
}
func (o *DMA_ST_Type) SetCR_MBURST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1800000)|value<<23)
}
func (o *DMA_ST_Type) GetCR_MBURST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1800000) >> 23
}
func (o *DMA_ST_Type) SetCR_PBURST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x600000)|value<<21)
}
func (o *DMA_ST_Type) GetCR_PBURST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x600000) >> 21
}
func (o *DMA_ST_Type) SetCR_CT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *DMA_ST_Type) GetCR_CT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}
func (o *DMA_ST_Type) SetCR_DBM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *DMA_ST_Type) GetCR_DBM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *DMA_ST_Type) SetCR_PL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x30000)|value<<16)
}
func (o *DMA_ST_Type) GetCR_PL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x30000) >> 16
}
func (o *DMA_ST_Type) SetCR_PINCOS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_ST_Type) GetCR_PINCOS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}
func (o *DMA_ST_Type) SetCR_MSIZE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x6000)|value<<13)
}
func (o *DMA_ST_Type) GetCR_MSIZE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x6000) >> 13
}
func (o *DMA_ST_Type) SetCR_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1800)|value<<11)
}
func (o *DMA_ST_Type) GetCR_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1800) >> 11
}
func (o *DMA_ST_Type) SetCR_MINC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *DMA_ST_Type) GetCR_MINC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *DMA_ST_Type) SetCR_PINC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *DMA_ST_Type) GetCR_PINC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *DMA_ST_Type) SetCR_CIRC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *DMA_ST_Type) GetCR_CIRC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *DMA_ST_Type) SetCR_DIR(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc0)|value<<6)
}
func (o *DMA_ST_Type) GetCR_DIR() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc0) >> 6
}
func (o *DMA_ST_Type) SetCR_PFCTRL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_ST_Type) GetCR_PFCTRL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *DMA_ST_Type) SetCR_TCIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_ST_Type) GetCR_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *DMA_ST_Type) SetCR_HTIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_ST_Type) GetCR_HTIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *DMA_ST_Type) SetCR_TEIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_ST_Type) GetCR_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *DMA_ST_Type) SetCR_DMEIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_ST_Type) GetCR_DMEIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *DMA_ST_Type) SetCR_EN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *DMA_ST_Type) GetCR_EN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// DMA_ST.NDTR: stream x number of data register
func (o *DMA_ST_Type) SetNDTR_NDT(value uint32) {
	volatile.StoreUint32(&o.NDTR.Reg, volatile.LoadUint32(&o.NDTR.Reg)&^(0xffff)|value)
}
func (o *DMA_ST_Type) GetNDTR_NDT() uint32 {
	return volatile.LoadUint32(&o.NDTR.Reg) & 0xffff
}

// DMA_ST.PAR: stream x peripheral address register
func (o *DMA_ST_Type) SetPAR(value uint32) {
	volatile.StoreUint32(&o.PAR.Reg, value)
}
func (o *DMA_ST_Type) GetPAR() uint32 {
	return volatile.LoadUint32(&o.PAR.Reg)
}

// DMA_ST.M0AR: stream x memory 0 address register
func (o *DMA_ST_Type) SetM0AR(value uint32) {
	volatile.StoreUint32(&o.M0AR.Reg, value)
}
func (o *DMA_ST_Type) GetM0AR() uint32 {
	return volatile.LoadUint32(&o.M0AR.Reg)
}

// DMA_ST.M1AR: stream x memory 1 address register
func (o *DMA_ST_Type) SetM1AR(value uint32) {
	volatile.StoreUint32(&o.M1AR.Reg, value)
}
func (o *DMA_ST_Type) GetM1AR() uint32 {
	return volatile.LoadUint32(&o.M1AR.Reg)
}

// DMA_ST.FCR: stream x FIFO control register
func (o *DMA_ST_Type) SetFCR_FEIE(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_ST_Type) GetFCR_FEIE() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0x80) >> 7
}
func (o *DMA_ST_Type) SetFCR_FS(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x38)|value<<3)
}
func (o *DMA_ST_Type) GetFCR_FS() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0x38) >> 3
}
func (o *DMA_ST_Type) SetFCR_DMDIS(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_ST_Type) GetFCR_DMDIS() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0x4) >> 2
}
func (o *DMA_ST_Type) SetFCR_FTH(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x3)|value)
}
func (o *DMA_ST_Type) GetFCR_FTH() uint32 {
	return volatile.LoadUint32(&o.FCR.Reg) & 0x3
}

// Reset and clock control
type RCC_Type struct {
	CR         volatile.Register32 // 0x0
	PLLCFGR    volatile.Register32 // 0x4
	CFGR       volatile.Register32 // 0x8
	CIR        volatile.Register32 // 0xC
	AHB1RSTR   volatile.Register32 // 0x10
	AHB2RSTR   volatile.Register32 // 0x14
	AHB3RSTR   volatile.Register32 // 0x18
	_          [4]byte
	APB1RSTR   volatile.Register32 // 0x20
	APB2RSTR   volatile.Register32 // 0x24
	_          [8]byte
	AHB1ENR    volatile.Register32 // 0x30
	AHB2ENR    volatile.Register32 // 0x34
	AHB3ENR    volatile.Register32 // 0x38
	_          [4]byte
	APB1ENR    volatile.Register32 // 0x40
	APB2ENR    volatile.Register32 // 0x44
	_          [8]byte
	AHB1LPENR  volatile.Register32 // 0x50
	AHB2LPENR  volatile.Register32 // 0x54
	AHB3LPENR  volatile.Register32 // 0x58
	_          [4]byte
	APB1LPENR  volatile.Register32 // 0x60
	APB2LPENR  volatile.Register32 // 0x64
	_          [8]byte
	BDCR       volatile.Register32 // 0x70
	CSR        volatile.Register32 // 0x74
	_          [8]byte
	SSCGR      volatile.Register32 // 0x80
	PLLI2SCFGR volatile.Register32 // 0x84
	PLLSAICFGR volatile.Register32 // 0x88
	DCKCFGR1   volatile.Register32 // 0x8C
	DCKCFGR2   volatile.Register32 // 0x90
}

// RCC.CR: clock control register
func (o *RCC_Type) SetCR_PLLI2SRDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetCR_PLLI2SRDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetCR_PLLI2SON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetCR_PLLI2SON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetCR_PLLRDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetCR_PLLRDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetCR_PLLON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetCR_PLLON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetCR_CSSON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetCR_CSSON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetCR_HSEBYP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetCR_HSEBYP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetCR_HSERDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetCR_HSERDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetCR_HSEON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetCR_HSEON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetCR_HSICAL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xff00)|value<<8)
}
func (o *RCC_Type) GetCR_HSICAL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xff00) >> 8
}
func (o *RCC_Type) SetCR_HSITRIM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf8)|value<<3)
}
func (o *RCC_Type) GetCR_HSITRIM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf8) >> 3
}
func (o *RCC_Type) SetCR_HSIRDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCR_HSIRDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCR_HSION(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCR_HSION() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *RCC_Type) SetCR_PLLSAIRDY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetCR_PLLSAIRDY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetCR_PLLSAION(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetCR_PLLSAION() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000000) >> 28
}

// RCC.PLLCFGR: PLL configuration register
func (o *RCC_Type) SetPLLCFGR_PLLSRC(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetPLLCFGR_PLLSRC() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetPLLCFGR_PLLR(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x70000000)|value<<28)
}
func (o *RCC_Type) GetPLLCFGR_PLLR() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x70000000) >> 28
}
func (o *RCC_Type) SetPLLCFGR_PLLM(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x3f)|value)
}
func (o *RCC_Type) GetPLLCFGR_PLLM() uint32 {
	return volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x3f
}
func (o *RCC_Type) SetPLLCFGR_PLLN(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x7fc0)|value<<6)
}
func (o *RCC_Type) GetPLLCFGR_PLLN() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x7fc0) >> 6
}
func (o *RCC_Type) SetPLLCFGR_PLLP(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0x30000)|value<<16)
}
func (o *RCC_Type) GetPLLCFGR_PLLP() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0x30000) >> 16
}
func (o *RCC_Type) SetPLLCFGR_PLLQ(value uint32) {
	volatile.StoreUint32(&o.PLLCFGR.Reg, volatile.LoadUint32(&o.PLLCFGR.Reg)&^(0xf000000)|value<<24)
}
func (o *RCC_Type) GetPLLCFGR_PLLQ() uint32 {
	return (volatile.LoadUint32(&o.PLLCFGR.Reg) & 0xf000000) >> 24
}

// RCC.CFGR: clock configuration register
func (o *RCC_Type) SetCFGR_MCO2(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xc0000000)|value<<30)
}
func (o *RCC_Type) GetCFGR_MCO2() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xc0000000) >> 30
}
func (o *RCC_Type) SetCFGR_MCO2PRE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x38000000)|value<<27)
}
func (o *RCC_Type) GetCFGR_MCO2PRE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x38000000) >> 27
}
func (o *RCC_Type) SetCFGR_MCO1PRE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x7000000)|value<<24)
}
func (o *RCC_Type) GetCFGR_MCO1PRE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x7000000) >> 24
}
func (o *RCC_Type) SetCFGR_I2SSRC(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetCFGR_I2SSRC() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetCFGR_MCO1(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x600000)|value<<21)
}
func (o *RCC_Type) GetCFGR_MCO1() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x600000) >> 21
}
func (o *RCC_Type) SetCFGR_RTCPRE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x1f0000)|value<<16)
}
func (o *RCC_Type) GetCFGR_RTCPRE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x1f0000) >> 16
}
func (o *RCC_Type) SetCFGR_PPRE2(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xe000)|value<<13)
}
func (o *RCC_Type) GetCFGR_PPRE2() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xe000) >> 13
}
func (o *RCC_Type) SetCFGR_PPRE1(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x1c00)|value<<10)
}
func (o *RCC_Type) GetCFGR_PPRE1() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x1c00) >> 10
}
func (o *RCC_Type) SetCFGR_HPRE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xf0)|value<<4)
}
func (o *RCC_Type) GetCFGR_HPRE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xf0) >> 4
}
func (o *RCC_Type) SetCFGR_SW(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x3)|value)
}
func (o *RCC_Type) GetCFGR_SW() uint32 {
	return volatile.LoadUint32(&o.CFGR.Reg) & 0x3
}
func (o *RCC_Type) SetCFGR_SWS(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xc)|value<<2)
}
func (o *RCC_Type) GetCFGR_SWS() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xc) >> 2
}

// RCC.CIR: clock interrupt register
func (o *RCC_Type) SetCIR_CSSC(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetCIR_CSSC() uint32 {
	return (volatile.LoadUint32(&o.CIR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetCIR_PLLSAIRDYC(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetCIR_PLLSAIRDYC() uint32 {
	return (volatile.LoadUint32(&o.CIR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetCIR_PLLI2SRDYC(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetCIR_PLLI2SRDYC() uint32 {
	return (volatile.LoadUint32(&o.CIR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetCIR_PLLRDYC(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetCIR_PLLRDYC() uint32 {
	return (volatile.LoadUint32(&o.CIR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetCIR_HSERDYC(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetCIR_HSERDYC() uint32 {
	return (volatile.LoadUint32(&o.CIR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetCIR_HSIRDYC(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetCIR_HSIRDYC() uint32 {
	return (volatile.LoadUint32(&o.CIR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetCIR_LSERDYC(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetCIR_LSERDYC() uint32 {
	return (volatile.LoadUint32(&o.CIR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetCIR_LSIRDYC(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetCIR_LSIRDYC() uint32 {
	return (volatile.LoadUint32(&o.CIR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetCIR_PLLSAIRDYIE(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetCIR_PLLSAIRDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetCIR_PLLI2SRDYIE(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x2000)|value<<13)
}
func (o *RCC_Type) GetCIR_PLLI2SRDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIR.Reg) & 0x2000) >> 13
}
func (o *RCC_Type) SetCIR_PLLRDYIE(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetCIR_PLLRDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetCIR_HSERDYIE(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetCIR_HSERDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetCIR_HSIRDYIE(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetCIR_HSIRDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIR.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetCIR_LSERDYIE(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetCIR_LSERDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetCIR_LSIRDYIE(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetCIR_LSIRDYIE() uint32 {
	return (volatile.LoadUint32(&o.CIR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetCIR_CSSF(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetCIR_CSSF() uint32 {
	return (volatile.LoadUint32(&o.CIR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetCIR_PLLSAIRDYF(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetCIR_PLLSAIRDYF() uint32 {
	return (volatile.LoadUint32(&o.CIR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetCIR_PLLI2SRDYF(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetCIR_PLLI2SRDYF() uint32 {
	return (volatile.LoadUint32(&o.CIR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetCIR_PLLRDYF(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetCIR_PLLRDYF() uint32 {
	return (volatile.LoadUint32(&o.CIR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetCIR_HSERDYF(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetCIR_HSERDYF() uint32 {
	return (volatile.LoadUint32(&o.CIR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetCIR_HSIRDYF(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetCIR_HSIRDYF() uint32 {
	return (volatile.LoadUint32(&o.CIR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetCIR_LSERDYF(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCIR_LSERDYF() uint32 {
	return (volatile.LoadUint32(&o.CIR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCIR_LSIRDYF(value uint32) {
	volatile.StoreUint32(&o.CIR.Reg, volatile.LoadUint32(&o.CIR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCIR_LSIRDYF() uint32 {
	return volatile.LoadUint32(&o.CIR.Reg) & 0x1
}

// RCC.AHB1RSTR: AHB1 peripheral reset register
func (o *RCC_Type) SetAHB1RSTR_OTGHSRST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAHB1RSTR_OTGHSRST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAHB1RSTR_ETHMACRST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAHB1RSTR_ETHMACRST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetAHB1RSTR_DMA2DRST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAHB1RSTR_DMA2DRST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetAHB1RSTR_DMA2RST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAHB1RSTR_DMA2RST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAHB1RSTR_DMA1RST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAHB1RSTR_DMA1RST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAHB1RSTR_CRCRST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAHB1RSTR_CRCRST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAHB1RSTR_GPIOKRST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetAHB1RSTR_GPIOKRST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetAHB1RSTR_GPIOJRST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAHB1RSTR_GPIOJRST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAHB1RSTR_GPIOIRST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAHB1RSTR_GPIOIRST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAHB1RSTR_GPIOHRST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAHB1RSTR_GPIOHRST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAHB1RSTR_GPIOGRST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAHB1RSTR_GPIOGRST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAHB1RSTR_GPIOFRST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAHB1RSTR_GPIOFRST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAHB1RSTR_GPIOERST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAHB1RSTR_GPIOERST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAHB1RSTR_GPIODRST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAHB1RSTR_GPIODRST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAHB1RSTR_GPIOCRST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAHB1RSTR_GPIOCRST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAHB1RSTR_GPIOBRST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB1RSTR_GPIOBRST() uint32 {
	return (volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAHB1RSTR_GPIOARST(value uint32) {
	volatile.StoreUint32(&o.AHB1RSTR.Reg, volatile.LoadUint32(&o.AHB1RSTR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB1RSTR_GPIOARST() uint32 {
	return volatile.LoadUint32(&o.AHB1RSTR.Reg) & 0x1
}

// RCC.AHB2RSTR: AHB2 peripheral reset register
func (o *RCC_Type) SetAHB2RSTR_OTGFSRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAHB2RSTR_OTGFSRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAHB2RSTR_RNGRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAHB2RSTR_RNGRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAHB2RSTR_HSAHRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAHB2RSTR_HSAHRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAHB2RSTR_CRYPRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAHB2RSTR_CRYPRST() uint32 {
	return (volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAHB2RSTR_DCMIRST(value uint32) {
	volatile.StoreUint32(&o.AHB2RSTR.Reg, volatile.LoadUint32(&o.AHB2RSTR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB2RSTR_DCMIRST() uint32 {
	return volatile.LoadUint32(&o.AHB2RSTR.Reg) & 0x1
}

// RCC.AHB3RSTR: AHB3 peripheral reset register
func (o *RCC_Type) SetAHB3RSTR_FMCRST(value uint32) {
	volatile.StoreUint32(&o.AHB3RSTR.Reg, volatile.LoadUint32(&o.AHB3RSTR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB3RSTR_FMCRST() uint32 {
	return volatile.LoadUint32(&o.AHB3RSTR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB3RSTR_QSPIRST(value uint32) {
	volatile.StoreUint32(&o.AHB3RSTR.Reg, volatile.LoadUint32(&o.AHB3RSTR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB3RSTR_QSPIRST() uint32 {
	return (volatile.LoadUint32(&o.AHB3RSTR.Reg) & 0x2) >> 1
}

// RCC.APB1RSTR: APB1 peripheral reset register
func (o *RCC_Type) SetAPB1RSTR_TIM2RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB1RSTR_TIM2RST() uint32 {
	return volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x1
}
func (o *RCC_Type) SetAPB1RSTR_TIM3RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB1RSTR_TIM3RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB1RSTR_TIM4RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAPB1RSTR_TIM4RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAPB1RSTR_TIM5RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAPB1RSTR_TIM5RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAPB1RSTR_TIM6RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPB1RSTR_TIM6RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPB1RSTR_TIM7RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB1RSTR_TIM7RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB1RSTR_TIM12RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAPB1RSTR_TIM12RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAPB1RSTR_TIM13RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAPB1RSTR_TIM13RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAPB1RSTR_TIM14RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAPB1RSTR_TIM14RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAPB1RSTR_WWDGRST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB1RSTR_WWDGRST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB1RSTR_SPI2RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB1RSTR_SPI2RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB1RSTR_SPI3RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetAPB1RSTR_SPI3RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetAPB1RSTR_USART2RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB1RSTR_USART2RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB1RSTR_USART3RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPB1RSTR_USART3RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPB1RSTR_UART4RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetAPB1RSTR_UART4RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetAPB1RSTR_UART5RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAPB1RSTR_UART5RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetAPB1RSTR_I2C1RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB1RSTR_I2C1RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB1RSTR_I2C2RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPB1RSTR_I2C2RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPB1RSTR_I2C3RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAPB1RSTR_I2C3RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetAPB1RSTR_CAN1RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAPB1RSTR_CAN1RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetAPB1RSTR_CAN2RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetAPB1RSTR_CAN2RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetAPB1RSTR_PWRRST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetAPB1RSTR_PWRRST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetAPB1RSTR_DACRST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAPB1RSTR_DACRST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAPB1RSTR_UART7RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetAPB1RSTR_UART7RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetAPB1RSTR_UART8RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetAPB1RSTR_UART8RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x80000000) >> 31
}
func (o *RCC_Type) SetAPB1RSTR_SPDIFRXRST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAPB1RSTR_SPDIFRXRST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAPB1RSTR_CECRST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetAPB1RSTR_CECRST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetAPB1RSTR_LPTIM1RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAPB1RSTR_LPTIM1RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAPB1RSTR_I2C4RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetAPB1RSTR_I2C4RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetAPB1RSTR_CAN3RST(value uint32) {
	volatile.StoreUint32(&o.APB1RSTR.Reg, volatile.LoadUint32(&o.APB1RSTR.Reg)&^(0x2000)|value<<13)
}
func (o *RCC_Type) GetAPB1RSTR_CAN3RST() uint32 {
	return (volatile.LoadUint32(&o.APB1RSTR.Reg) & 0x2000) >> 13
}

// RCC.APB2RSTR: APB2 peripheral reset register
func (o *RCC_Type) SetAPB2RSTR_TIM1RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB2RSTR_TIM1RST() uint32 {
	return volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x1
}
func (o *RCC_Type) SetAPB2RSTR_TIM8RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB2RSTR_TIM8RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB2RSTR_USART1RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPB2RSTR_USART1RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPB2RSTR_USART6RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB2RSTR_USART6RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB2RSTR_ADCRST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAPB2RSTR_ADCRST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAPB2RSTR_SPI1RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAPB2RSTR_SPI1RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAPB2RSTR_SPI4RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x2000)|value<<13)
}
func (o *RCC_Type) GetAPB2RSTR_SPI4RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x2000) >> 13
}
func (o *RCC_Type) SetAPB2RSTR_SYSCFGRST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB2RSTR_SYSCFGRST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB2RSTR_TIM9RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAPB2RSTR_TIM9RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAPB2RSTR_TIM10RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB2RSTR_TIM10RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB2RSTR_TIM11RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPB2RSTR_TIM11RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPB2RSTR_SPI5RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAPB2RSTR_SPI5RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetAPB2RSTR_SPI6RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB2RSTR_SPI6RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB2RSTR_SAI1RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPB2RSTR_SAI1RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPB2RSTR_LTDCRST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetAPB2RSTR_LTDCRST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetAPB2RSTR_SAI2RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAPB2RSTR_SAI2RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetAPB2RSTR_SDMMC1RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB2RSTR_SDMMC1RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB2RSTR_MDIORST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetAPB2RSTR_MDIORST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetAPB2RSTR_DFSDM1RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAPB2RSTR_DFSDM1RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAPB2RSTR_DSIRST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetAPB2RSTR_DSIRST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetAPB2RSTR_SDMMC2RST(value uint32) {
	volatile.StoreUint32(&o.APB2RSTR.Reg, volatile.LoadUint32(&o.APB2RSTR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAPB2RSTR_SDMMC2RST() uint32 {
	return (volatile.LoadUint32(&o.APB2RSTR.Reg) & 0x80) >> 7
}

// RCC.AHB1ENR: AHB1 peripheral clock register
func (o *RCC_Type) SetAHB1ENR_OTGHSULPIEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetAHB1ENR_OTGHSULPIEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetAHB1ENR_OTGHSEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAHB1ENR_OTGHSEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAHB1ENR_ETHMACPTPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetAHB1ENR_ETHMACPTPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetAHB1ENR_ETHMACRXEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetAHB1ENR_ETHMACRXEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetAHB1ENR_ETHMACTXEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetAHB1ENR_ETHMACTXEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetAHB1ENR_ETHMACEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAHB1ENR_ETHMACEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetAHB1ENR_DMA2DEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAHB1ENR_DMA2DEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetAHB1ENR_DMA2EN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAHB1ENR_DMA2EN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAHB1ENR_DMA1EN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAHB1ENR_DMA1EN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAHB1ENR_DTCMRAMEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAHB1ENR_DTCMRAMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetAHB1ENR_BKPSRAMEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAHB1ENR_BKPSRAMEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAHB1ENR_CRCEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAHB1ENR_CRCEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAHB1ENR_GPIOKEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetAHB1ENR_GPIOKEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetAHB1ENR_GPIOJEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAHB1ENR_GPIOJEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAHB1ENR_GPIOIEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAHB1ENR_GPIOIEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAHB1ENR_GPIOHEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAHB1ENR_GPIOHEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAHB1ENR_GPIOGEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAHB1ENR_GPIOGEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAHB1ENR_GPIOFEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAHB1ENR_GPIOFEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAHB1ENR_GPIOEEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAHB1ENR_GPIOEEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAHB1ENR_GPIODEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAHB1ENR_GPIODEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAHB1ENR_GPIOCEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAHB1ENR_GPIOCEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAHB1ENR_GPIOBEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB1ENR_GPIOBEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAHB1ENR_GPIOAEN(value uint32) {
	volatile.StoreUint32(&o.AHB1ENR.Reg, volatile.LoadUint32(&o.AHB1ENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB1ENR_GPIOAEN() uint32 {
	return volatile.LoadUint32(&o.AHB1ENR.Reg) & 0x1
}

// RCC.AHB2ENR: AHB2 peripheral clock enable register
func (o *RCC_Type) SetAHB2ENR_OTGFSEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAHB2ENR_OTGFSEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAHB2ENR_RNGEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAHB2ENR_RNGEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAHB2ENR_HASHEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAHB2ENR_HASHEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAHB2ENR_CRYPEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAHB2ENR_CRYPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAHB2ENR_DCMIEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB2ENR_DCMIEN() uint32 {
	return volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB2ENR_JPEGEN(value uint32) {
	volatile.StoreUint32(&o.AHB2ENR.Reg, volatile.LoadUint32(&o.AHB2ENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB2ENR_JPEGEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2ENR.Reg) & 0x2) >> 1
}

// RCC.AHB3ENR: AHB3 peripheral clock enable register
func (o *RCC_Type) SetAHB3ENR_FMCEN(value uint32) {
	volatile.StoreUint32(&o.AHB3ENR.Reg, volatile.LoadUint32(&o.AHB3ENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB3ENR_FMCEN() uint32 {
	return volatile.LoadUint32(&o.AHB3ENR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB3ENR_QSPIEN(value uint32) {
	volatile.StoreUint32(&o.AHB3ENR.Reg, volatile.LoadUint32(&o.AHB3ENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB3ENR_QSPIEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3ENR.Reg) & 0x2) >> 1
}

// RCC.APB1ENR: APB1 peripheral clock enable register
func (o *RCC_Type) SetAPB1ENR_TIM2EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB1ENR_TIM2EN() uint32 {
	return volatile.LoadUint32(&o.APB1ENR.Reg) & 0x1
}
func (o *RCC_Type) SetAPB1ENR_TIM3EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB1ENR_TIM3EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB1ENR_TIM4EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAPB1ENR_TIM4EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAPB1ENR_TIM5EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAPB1ENR_TIM5EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAPB1ENR_TIM6EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPB1ENR_TIM6EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPB1ENR_TIM7EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB1ENR_TIM7EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB1ENR_TIM12EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAPB1ENR_TIM12EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAPB1ENR_TIM13EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAPB1ENR_TIM13EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAPB1ENR_TIM14EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAPB1ENR_TIM14EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAPB1ENR_WWDGEN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB1ENR_WWDGEN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB1ENR_SPI2EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB1ENR_SPI2EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB1ENR_SPI3EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetAPB1ENR_SPI3EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetAPB1ENR_USART2EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB1ENR_USART2EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB1ENR_USART3EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPB1ENR_USART3EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPB1ENR_UART4EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetAPB1ENR_UART4EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetAPB1ENR_UART5EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAPB1ENR_UART5EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetAPB1ENR_I2C1EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB1ENR_I2C1EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB1ENR_I2C2EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPB1ENR_I2C2EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPB1ENR_I2C3EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAPB1ENR_I2C3EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetAPB1ENR_CAN1EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAPB1ENR_CAN1EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetAPB1ENR_CAN2EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetAPB1ENR_CAN2EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetAPB1ENR_PWREN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetAPB1ENR_PWREN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetAPB1ENR_DACEN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAPB1ENR_DACEN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAPB1ENR_UART7EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetAPB1ENR_UART7EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetAPB1ENR_UART8EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetAPB1ENR_UART8EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x80000000) >> 31
}
func (o *RCC_Type) SetAPB1ENR_SPDIFRXEN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAPB1ENR_SPDIFRXEN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAPB1ENR_CECEN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetAPB1ENR_CECEN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetAPB1ENR_LPTIM1EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAPB1ENR_LPTIM1EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAPB1ENR_I2C4EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetAPB1ENR_I2C4EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetAPB1ENR_CAN3EN(value uint32) {
	volatile.StoreUint32(&o.APB1ENR.Reg, volatile.LoadUint32(&o.APB1ENR.Reg)&^(0x2000)|value<<13)
}
func (o *RCC_Type) GetAPB1ENR_CAN3EN() uint32 {
	return (volatile.LoadUint32(&o.APB1ENR.Reg) & 0x2000) >> 13
}

// RCC.APB2ENR: APB2 peripheral clock enable register
func (o *RCC_Type) SetAPB2ENR_TIM1EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB2ENR_TIM1EN() uint32 {
	return volatile.LoadUint32(&o.APB2ENR.Reg) & 0x1
}
func (o *RCC_Type) SetAPB2ENR_TIM8EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB2ENR_TIM8EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB2ENR_USART1EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPB2ENR_USART1EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPB2ENR_USART6EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB2ENR_USART6EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB2ENR_ADC1EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAPB2ENR_ADC1EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAPB2ENR_ADC2EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAPB2ENR_ADC2EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAPB2ENR_ADC3EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetAPB2ENR_ADC3EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetAPB2ENR_SPI1EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAPB2ENR_SPI1EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAPB2ENR_SPI4EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x2000)|value<<13)
}
func (o *RCC_Type) GetAPB2ENR_SPI4EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x2000) >> 13
}
func (o *RCC_Type) SetAPB2ENR_SYSCFGEN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB2ENR_SYSCFGEN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB2ENR_TIM9EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAPB2ENR_TIM9EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAPB2ENR_TIM10EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB2ENR_TIM10EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB2ENR_TIM11EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPB2ENR_TIM11EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPB2ENR_SPI5EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAPB2ENR_SPI5EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetAPB2ENR_SPI6EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB2ENR_SPI6EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB2ENR_SAI1EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPB2ENR_SAI1EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPB2ENR_LTDCEN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetAPB2ENR_LTDCEN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetAPB2ENR_SAI2EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAPB2ENR_SAI2EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetAPB2ENR_SDMMC1EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB2ENR_SDMMC1EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB2ENR_MDIOEN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetAPB2ENR_MDIOEN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetAPB2ENR_DFSDM1EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAPB2ENR_DFSDM1EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAPB2ENR_DSIEN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetAPB2ENR_DSIEN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetAPB2ENR_SDMMC2EN(value uint32) {
	volatile.StoreUint32(&o.APB2ENR.Reg, volatile.LoadUint32(&o.APB2ENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAPB2ENR_SDMMC2EN() uint32 {
	return (volatile.LoadUint32(&o.APB2ENR.Reg) & 0x80) >> 7
}

// RCC.AHB1LPENR: AHB1 peripheral clock enable in low power mode register
func (o *RCC_Type) SetAHB1LPENR_GPIOALPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB1LPENR_GPIOALPEN() uint32 {
	return volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB1LPENR_GPIOBLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB1LPENR_GPIOBLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAHB1LPENR_GPIOCLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAHB1LPENR_GPIOCLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAHB1LPENR_GPIODLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAHB1LPENR_GPIODLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAHB1LPENR_GPIOELPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAHB1LPENR_GPIOELPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAHB1LPENR_GPIOFLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAHB1LPENR_GPIOFLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAHB1LPENR_GPIOGLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAHB1LPENR_GPIOGLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAHB1LPENR_GPIOHLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAHB1LPENR_GPIOHLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAHB1LPENR_GPIOILPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAHB1LPENR_GPIOILPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAHB1LPENR_GPIOJLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAHB1LPENR_GPIOJLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAHB1LPENR_GPIOKLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetAHB1LPENR_GPIOKLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetAHB1LPENR_CRCLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAHB1LPENR_CRCLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAHB1LPENR_FLITFLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetAHB1LPENR_FLITFLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetAHB1LPENR_SRAM1LPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAHB1LPENR_SRAM1LPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAHB1LPENR_SRAM2LPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAHB1LPENR_SRAM2LPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAHB1LPENR_BKPSRAMLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAHB1LPENR_BKPSRAMLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAHB1LPENR_SRAM3LPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetAHB1LPENR_SRAM3LPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetAHB1LPENR_DMA1LPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAHB1LPENR_DMA1LPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAHB1LPENR_DMA2LPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAHB1LPENR_DMA2LPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAHB1LPENR_DMA2DLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAHB1LPENR_DMA2DLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetAHB1LPENR_ETHMACLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAHB1LPENR_ETHMACLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetAHB1LPENR_ETHMACTXLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetAHB1LPENR_ETHMACTXLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetAHB1LPENR_ETHMACRXLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetAHB1LPENR_ETHMACRXLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetAHB1LPENR_ETHMACPTPLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetAHB1LPENR_ETHMACPTPLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetAHB1LPENR_OTGHSLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAHB1LPENR_OTGHSLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAHB1LPENR_OTGHSULPILPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetAHB1LPENR_OTGHSULPILPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetAHB1LPENR_AXILPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x2000)|value<<13)
}
func (o *RCC_Type) GetAHB1LPENR_AXILPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x2000) >> 13
}
func (o *RCC_Type) SetAHB1LPENR_DTCMLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB1LPENR.Reg, volatile.LoadUint32(&o.AHB1LPENR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAHB1LPENR_DTCMLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB1LPENR.Reg) & 0x100000) >> 20
}

// RCC.AHB2LPENR: AHB2 peripheral clock enable in low power mode register
func (o *RCC_Type) SetAHB2LPENR_OTGFSLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB2LPENR.Reg, volatile.LoadUint32(&o.AHB2LPENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAHB2LPENR_OTGFSLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2LPENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAHB2LPENR_RNGLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB2LPENR.Reg, volatile.LoadUint32(&o.AHB2LPENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAHB2LPENR_RNGLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2LPENR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAHB2LPENR_HASHLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB2LPENR.Reg, volatile.LoadUint32(&o.AHB2LPENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAHB2LPENR_HASHLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2LPENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAHB2LPENR_CRYPLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB2LPENR.Reg, volatile.LoadUint32(&o.AHB2LPENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAHB2LPENR_CRYPLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2LPENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAHB2LPENR_DCMILPEN(value uint32) {
	volatile.StoreUint32(&o.AHB2LPENR.Reg, volatile.LoadUint32(&o.AHB2LPENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB2LPENR_DCMILPEN() uint32 {
	return volatile.LoadUint32(&o.AHB2LPENR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB2LPENR_JPEGLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB2LPENR.Reg, volatile.LoadUint32(&o.AHB2LPENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB2LPENR_JPEGLPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB2LPENR.Reg) & 0x2) >> 1
}

// RCC.AHB3LPENR: AHB3 peripheral clock enable in low power mode register
func (o *RCC_Type) SetAHB3LPENR_FMCLPEN(value uint32) {
	volatile.StoreUint32(&o.AHB3LPENR.Reg, volatile.LoadUint32(&o.AHB3LPENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAHB3LPENR_FMCLPEN() uint32 {
	return volatile.LoadUint32(&o.AHB3LPENR.Reg) & 0x1
}
func (o *RCC_Type) SetAHB3LPENR_QSPILPEN(value uint32) {
	volatile.StoreUint32(&o.AHB3LPENR.Reg, volatile.LoadUint32(&o.AHB3LPENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAHB3LPENR_QSPILPEN() uint32 {
	return (volatile.LoadUint32(&o.AHB3LPENR.Reg) & 0x2) >> 1
}

// RCC.APB1LPENR: APB1 peripheral clock enable in low power mode register
func (o *RCC_Type) SetAPB1LPENR_TIM2LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB1LPENR_TIM2LPEN() uint32 {
	return volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x1
}
func (o *RCC_Type) SetAPB1LPENR_TIM3LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB1LPENR_TIM3LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB1LPENR_TIM4LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetAPB1LPENR_TIM4LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetAPB1LPENR_TIM5LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x8)|value<<3)
}
func (o *RCC_Type) GetAPB1LPENR_TIM5LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x8) >> 3
}
func (o *RCC_Type) SetAPB1LPENR_TIM6LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPB1LPENR_TIM6LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPB1LPENR_TIM7LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB1LPENR_TIM7LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB1LPENR_TIM12LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x40)|value<<6)
}
func (o *RCC_Type) GetAPB1LPENR_TIM12LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x40) >> 6
}
func (o *RCC_Type) SetAPB1LPENR_TIM13LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAPB1LPENR_TIM13LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x80) >> 7
}
func (o *RCC_Type) SetAPB1LPENR_TIM14LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAPB1LPENR_TIM14LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAPB1LPENR_WWDGLPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB1LPENR_WWDGLPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB1LPENR_SPI2LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB1LPENR_SPI2LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB1LPENR_SPI3LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetAPB1LPENR_SPI3LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetAPB1LPENR_USART2LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB1LPENR_USART2LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB1LPENR_USART3LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPB1LPENR_USART3LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPB1LPENR_UART4LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x80000)|value<<19)
}
func (o *RCC_Type) GetAPB1LPENR_UART4LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x80000) >> 19
}
func (o *RCC_Type) SetAPB1LPENR_UART5LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAPB1LPENR_UART5LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetAPB1LPENR_I2C1LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB1LPENR_I2C1LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB1LPENR_I2C2LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPB1LPENR_I2C2LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPB1LPENR_I2C3LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAPB1LPENR_I2C3LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetAPB1LPENR_CAN1LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetAPB1LPENR_CAN1LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetAPB1LPENR_CAN2LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetAPB1LPENR_CAN2LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetAPB1LPENR_PWRLPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetAPB1LPENR_PWRLPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetAPB1LPENR_DACLPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAPB1LPENR_DACLPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAPB1LPENR_UART7LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetAPB1LPENR_UART7LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetAPB1LPENR_UART8LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetAPB1LPENR_UART8LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x80000000) >> 31
}
func (o *RCC_Type) SetAPB1LPENR_SPDIFRXLPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAPB1LPENR_SPDIFRXLPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAPB1LPENR_CECLPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetAPB1LPENR_CECLPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetAPB1LPENR_LPTIM1LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAPB1LPENR_LPTIM1LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAPB1LPENR_I2C4LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetAPB1LPENR_I2C4LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetAPB1LPENR_CAN3LPEN(value uint32) {
	volatile.StoreUint32(&o.APB1LPENR.Reg, volatile.LoadUint32(&o.APB1LPENR.Reg)&^(0x2000)|value<<13)
}
func (o *RCC_Type) GetAPB1LPENR_CAN3LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB1LPENR.Reg) & 0x2000) >> 13
}

// RCC.APB2LPENR: APB2 peripheral clock enabled in low power mode register
func (o *RCC_Type) SetAPB2LPENR_TIM1LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetAPB2LPENR_TIM1LPEN() uint32 {
	return volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x1
}
func (o *RCC_Type) SetAPB2LPENR_TIM8LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetAPB2LPENR_TIM8LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetAPB2LPENR_USART1LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x10)|value<<4)
}
func (o *RCC_Type) GetAPB2LPENR_USART1LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x10) >> 4
}
func (o *RCC_Type) SetAPB2LPENR_USART6LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x20)|value<<5)
}
func (o *RCC_Type) GetAPB2LPENR_USART6LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x20) >> 5
}
func (o *RCC_Type) SetAPB2LPENR_ADC1LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x100)|value<<8)
}
func (o *RCC_Type) GetAPB2LPENR_ADC1LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x100) >> 8
}
func (o *RCC_Type) SetAPB2LPENR_ADC2LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x200)|value<<9)
}
func (o *RCC_Type) GetAPB2LPENR_ADC2LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x200) >> 9
}
func (o *RCC_Type) SetAPB2LPENR_ADC3LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x400)|value<<10)
}
func (o *RCC_Type) GetAPB2LPENR_ADC3LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x400) >> 10
}
func (o *RCC_Type) SetAPB2LPENR_SPI1LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x1000)|value<<12)
}
func (o *RCC_Type) GetAPB2LPENR_SPI1LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x1000) >> 12
}
func (o *RCC_Type) SetAPB2LPENR_SPI4LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x2000)|value<<13)
}
func (o *RCC_Type) GetAPB2LPENR_SPI4LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x2000) >> 13
}
func (o *RCC_Type) SetAPB2LPENR_SYSCFGLPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x4000)|value<<14)
}
func (o *RCC_Type) GetAPB2LPENR_SYSCFGLPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x4000) >> 14
}
func (o *RCC_Type) SetAPB2LPENR_TIM9LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetAPB2LPENR_TIM9LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetAPB2LPENR_TIM10LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x20000)|value<<17)
}
func (o *RCC_Type) GetAPB2LPENR_TIM10LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x20000) >> 17
}
func (o *RCC_Type) SetAPB2LPENR_TIM11LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x40000)|value<<18)
}
func (o *RCC_Type) GetAPB2LPENR_TIM11LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x40000) >> 18
}
func (o *RCC_Type) SetAPB2LPENR_SPI5LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x100000)|value<<20)
}
func (o *RCC_Type) GetAPB2LPENR_SPI5LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x100000) >> 20
}
func (o *RCC_Type) SetAPB2LPENR_SPI6LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x200000)|value<<21)
}
func (o *RCC_Type) GetAPB2LPENR_SPI6LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x200000) >> 21
}
func (o *RCC_Type) SetAPB2LPENR_SAI1LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x400000)|value<<22)
}
func (o *RCC_Type) GetAPB2LPENR_SAI1LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x400000) >> 22
}
func (o *RCC_Type) SetAPB2LPENR_LTDCLPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetAPB2LPENR_LTDCLPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetAPB2LPENR_SAI2LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x800000)|value<<23)
}
func (o *RCC_Type) GetAPB2LPENR_SAI2LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x800000) >> 23
}
func (o *RCC_Type) SetAPB2LPENR_SDMMC1LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x800)|value<<11)
}
func (o *RCC_Type) GetAPB2LPENR_SDMMC1LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x800) >> 11
}
func (o *RCC_Type) SetAPB2LPENR_MDIOLPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetAPB2LPENR_MDIOLPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetAPB2LPENR_DFSDM1LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetAPB2LPENR_DFSDM1LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetAPB2LPENR_DSILPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetAPB2LPENR_DSILPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetAPB2LPENR_SDMMC2LPEN(value uint32) {
	volatile.StoreUint32(&o.APB2LPENR.Reg, volatile.LoadUint32(&o.APB2LPENR.Reg)&^(0x80)|value<<7)
}
func (o *RCC_Type) GetAPB2LPENR_SDMMC2LPEN() uint32 {
	return (volatile.LoadUint32(&o.APB2LPENR.Reg) & 0x80) >> 7
}

// RCC.BDCR: Backup domain control register
func (o *RCC_Type) SetBDCR_BDRST(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x10000)|value<<16)
}
func (o *RCC_Type) GetBDCR_BDRST() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x10000) >> 16
}
func (o *RCC_Type) SetBDCR_RTCEN(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x8000)|value<<15)
}
func (o *RCC_Type) GetBDCR_RTCEN() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x8000) >> 15
}
func (o *RCC_Type) SetBDCR_LSEBYP(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x4)|value<<2)
}
func (o *RCC_Type) GetBDCR_LSEBYP() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x4) >> 2
}
func (o *RCC_Type) SetBDCR_LSERDY(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetBDCR_LSERDY() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetBDCR_LSEON(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetBDCR_LSEON() uint32 {
	return volatile.LoadUint32(&o.BDCR.Reg) & 0x1
}
func (o *RCC_Type) SetBDCR_LSEDRV(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x18)|value<<3)
}
func (o *RCC_Type) GetBDCR_LSEDRV() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x18) >> 3
}
func (o *RCC_Type) SetBDCR_RTCSEL(value uint32) {
	volatile.StoreUint32(&o.BDCR.Reg, volatile.LoadUint32(&o.BDCR.Reg)&^(0x300)|value<<8)
}
func (o *RCC_Type) GetBDCR_RTCSEL() uint32 {
	return (volatile.LoadUint32(&o.BDCR.Reg) & 0x300) >> 8
}

// RCC.CSR: clock control & status register
func (o *RCC_Type) SetCSR_LPWRRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetCSR_LPWRRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x80000000) >> 31
}
func (o *RCC_Type) SetCSR_WWDGRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetCSR_WWDGRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetCSR_WDGRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetCSR_WDGRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetCSR_SFTRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetCSR_SFTRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetCSR_PORRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetCSR_PORRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetCSR_PADRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetCSR_PADRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetCSR_BORRSTF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetCSR_BORRSTF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetCSR_RMVF(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetCSR_RMVF() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetCSR_LSIRDY(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *RCC_Type) GetCSR_LSIRDY() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}
func (o *RCC_Type) SetCSR_LSION(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *RCC_Type) GetCSR_LSION() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}

// RCC.SSCGR: spread spectrum clock generation register
func (o *RCC_Type) SetSSCGR_SSCGEN(value uint32) {
	volatile.StoreUint32(&o.SSCGR.Reg, volatile.LoadUint32(&o.SSCGR.Reg)&^(0x80000000)|value<<31)
}
func (o *RCC_Type) GetSSCGR_SSCGEN() uint32 {
	return (volatile.LoadUint32(&o.SSCGR.Reg) & 0x80000000) >> 31
}
func (o *RCC_Type) SetSSCGR_SPREADSEL(value uint32) {
	volatile.StoreUint32(&o.SSCGR.Reg, volatile.LoadUint32(&o.SSCGR.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetSSCGR_SPREADSEL() uint32 {
	return (volatile.LoadUint32(&o.SSCGR.Reg) & 0x40000000) >> 30
}
func (o *RCC_Type) SetSSCGR_INCSTEP(value uint32) {
	volatile.StoreUint32(&o.SSCGR.Reg, volatile.LoadUint32(&o.SSCGR.Reg)&^(0xfffe000)|value<<13)
}
func (o *RCC_Type) GetSSCGR_INCSTEP() uint32 {
	return (volatile.LoadUint32(&o.SSCGR.Reg) & 0xfffe000) >> 13
}
func (o *RCC_Type) SetSSCGR_MODPER(value uint32) {
	volatile.StoreUint32(&o.SSCGR.Reg, volatile.LoadUint32(&o.SSCGR.Reg)&^(0x1fff)|value)
}
func (o *RCC_Type) GetSSCGR_MODPER() uint32 {
	return volatile.LoadUint32(&o.SSCGR.Reg) & 0x1fff
}

// RCC.PLLI2SCFGR: PLLI2S configuration register
func (o *RCC_Type) SetPLLI2SCFGR_PLLI2SR(value uint32) {
	volatile.StoreUint32(&o.PLLI2SCFGR.Reg, volatile.LoadUint32(&o.PLLI2SCFGR.Reg)&^(0x70000000)|value<<28)
}
func (o *RCC_Type) GetPLLI2SCFGR_PLLI2SR() uint32 {
	return (volatile.LoadUint32(&o.PLLI2SCFGR.Reg) & 0x70000000) >> 28
}
func (o *RCC_Type) SetPLLI2SCFGR_PLLI2SQ(value uint32) {
	volatile.StoreUint32(&o.PLLI2SCFGR.Reg, volatile.LoadUint32(&o.PLLI2SCFGR.Reg)&^(0xf000000)|value<<24)
}
func (o *RCC_Type) GetPLLI2SCFGR_PLLI2SQ() uint32 {
	return (volatile.LoadUint32(&o.PLLI2SCFGR.Reg) & 0xf000000) >> 24
}
func (o *RCC_Type) SetPLLI2SCFGR_PLLI2SN(value uint32) {
	volatile.StoreUint32(&o.PLLI2SCFGR.Reg, volatile.LoadUint32(&o.PLLI2SCFGR.Reg)&^(0x7fc0)|value<<6)
}
func (o *RCC_Type) GetPLLI2SCFGR_PLLI2SN() uint32 {
	return (volatile.LoadUint32(&o.PLLI2SCFGR.Reg) & 0x7fc0) >> 6
}
func (o *RCC_Type) SetPLLI2SCFGR_PLLI2SP(value uint32) {
	volatile.StoreUint32(&o.PLLI2SCFGR.Reg, volatile.LoadUint32(&o.PLLI2SCFGR.Reg)&^(0x30000)|value<<16)
}
func (o *RCC_Type) GetPLLI2SCFGR_PLLI2SP() uint32 {
	return (volatile.LoadUint32(&o.PLLI2SCFGR.Reg) & 0x30000) >> 16
}

// RCC.PLLSAICFGR: PLL configuration register
func (o *RCC_Type) SetPLLSAICFGR_PLLSAIN(value uint32) {
	volatile.StoreUint32(&o.PLLSAICFGR.Reg, volatile.LoadUint32(&o.PLLSAICFGR.Reg)&^(0x7fc0)|value<<6)
}
func (o *RCC_Type) GetPLLSAICFGR_PLLSAIN() uint32 {
	return (volatile.LoadUint32(&o.PLLSAICFGR.Reg) & 0x7fc0) >> 6
}
func (o *RCC_Type) SetPLLSAICFGR_PLLSAIP(value uint32) {
	volatile.StoreUint32(&o.PLLSAICFGR.Reg, volatile.LoadUint32(&o.PLLSAICFGR.Reg)&^(0x30000)|value<<16)
}
func (o *RCC_Type) GetPLLSAICFGR_PLLSAIP() uint32 {
	return (volatile.LoadUint32(&o.PLLSAICFGR.Reg) & 0x30000) >> 16
}
func (o *RCC_Type) SetPLLSAICFGR_PLLSAIQ(value uint32) {
	volatile.StoreUint32(&o.PLLSAICFGR.Reg, volatile.LoadUint32(&o.PLLSAICFGR.Reg)&^(0xf000000)|value<<24)
}
func (o *RCC_Type) GetPLLSAICFGR_PLLSAIQ() uint32 {
	return (volatile.LoadUint32(&o.PLLSAICFGR.Reg) & 0xf000000) >> 24
}
func (o *RCC_Type) SetPLLSAICFGR_PLLSAIR(value uint32) {
	volatile.StoreUint32(&o.PLLSAICFGR.Reg, volatile.LoadUint32(&o.PLLSAICFGR.Reg)&^(0x70000000)|value<<28)
}
func (o *RCC_Type) GetPLLSAICFGR_PLLSAIR() uint32 {
	return (volatile.LoadUint32(&o.PLLSAICFGR.Reg) & 0x70000000) >> 28
}

// RCC.DCKCFGR1: dedicated clocks configuration register
func (o *RCC_Type) SetDCKCFGR1_PLLI2SDIVQ(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR1.Reg, volatile.LoadUint32(&o.DCKCFGR1.Reg)&^(0x1f)|value)
}
func (o *RCC_Type) GetDCKCFGR1_PLLI2SDIVQ() uint32 {
	return volatile.LoadUint32(&o.DCKCFGR1.Reg) & 0x1f
}
func (o *RCC_Type) SetDCKCFGR1_PLLSAIDIVQ(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR1.Reg, volatile.LoadUint32(&o.DCKCFGR1.Reg)&^(0x1f00)|value<<8)
}
func (o *RCC_Type) GetDCKCFGR1_PLLSAIDIVQ() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR1.Reg) & 0x1f00) >> 8
}
func (o *RCC_Type) SetDCKCFGR1_PLLSAIDIVR(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR1.Reg, volatile.LoadUint32(&o.DCKCFGR1.Reg)&^(0x30000)|value<<16)
}
func (o *RCC_Type) GetDCKCFGR1_PLLSAIDIVR() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR1.Reg) & 0x30000) >> 16
}
func (o *RCC_Type) SetDCKCFGR1_SAI1SEL(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR1.Reg, volatile.LoadUint32(&o.DCKCFGR1.Reg)&^(0x300000)|value<<20)
}
func (o *RCC_Type) GetDCKCFGR1_SAI1SEL() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR1.Reg) & 0x300000) >> 20
}
func (o *RCC_Type) SetDCKCFGR1_SAI2SEL(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR1.Reg, volatile.LoadUint32(&o.DCKCFGR1.Reg)&^(0xc00000)|value<<22)
}
func (o *RCC_Type) GetDCKCFGR1_SAI2SEL() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR1.Reg) & 0xc00000) >> 22
}
func (o *RCC_Type) SetDCKCFGR1_TIMPRE(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR1.Reg, volatile.LoadUint32(&o.DCKCFGR1.Reg)&^(0x1000000)|value<<24)
}
func (o *RCC_Type) GetDCKCFGR1_TIMPRE() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR1.Reg) & 0x1000000) >> 24
}
func (o *RCC_Type) SetDCKCFGR1_DFSDM1SEL(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR1.Reg, volatile.LoadUint32(&o.DCKCFGR1.Reg)&^(0x2000000)|value<<25)
}
func (o *RCC_Type) GetDCKCFGR1_DFSDM1SEL() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR1.Reg) & 0x2000000) >> 25
}
func (o *RCC_Type) SetDCKCFGR1_ADFSDM1SEL(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR1.Reg, volatile.LoadUint32(&o.DCKCFGR1.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetDCKCFGR1_ADFSDM1SEL() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR1.Reg) & 0x4000000) >> 26
}

// RCC.DCKCFGR2: dedicated clocks configuration register
func (o *RCC_Type) SetDCKCFGR2_USART1SEL(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR2.Reg, volatile.LoadUint32(&o.DCKCFGR2.Reg)&^(0x3)|value)
}
func (o *RCC_Type) GetDCKCFGR2_USART1SEL() uint32 {
	return volatile.LoadUint32(&o.DCKCFGR2.Reg) & 0x3
}
func (o *RCC_Type) SetDCKCFGR2_USART2SEL(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR2.Reg, volatile.LoadUint32(&o.DCKCFGR2.Reg)&^(0xc)|value<<2)
}
func (o *RCC_Type) GetDCKCFGR2_USART2SEL() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR2.Reg) & 0xc) >> 2
}
func (o *RCC_Type) SetDCKCFGR2_USART3SEL(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR2.Reg, volatile.LoadUint32(&o.DCKCFGR2.Reg)&^(0x30)|value<<4)
}
func (o *RCC_Type) GetDCKCFGR2_USART3SEL() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR2.Reg) & 0x30) >> 4
}
func (o *RCC_Type) SetDCKCFGR2_UART4SEL(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR2.Reg, volatile.LoadUint32(&o.DCKCFGR2.Reg)&^(0xc0)|value<<6)
}
func (o *RCC_Type) GetDCKCFGR2_UART4SEL() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR2.Reg) & 0xc0) >> 6
}
func (o *RCC_Type) SetDCKCFGR2_UART5SEL(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR2.Reg, volatile.LoadUint32(&o.DCKCFGR2.Reg)&^(0x300)|value<<8)
}
func (o *RCC_Type) GetDCKCFGR2_UART5SEL() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR2.Reg) & 0x300) >> 8
}
func (o *RCC_Type) SetDCKCFGR2_USART6SEL(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR2.Reg, volatile.LoadUint32(&o.DCKCFGR2.Reg)&^(0xc00)|value<<10)
}
func (o *RCC_Type) GetDCKCFGR2_USART6SEL() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR2.Reg) & 0xc00) >> 10
}
func (o *RCC_Type) SetDCKCFGR2_UART7SEL(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR2.Reg, volatile.LoadUint32(&o.DCKCFGR2.Reg)&^(0x3000)|value<<12)
}
func (o *RCC_Type) GetDCKCFGR2_UART7SEL() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR2.Reg) & 0x3000) >> 12
}
func (o *RCC_Type) SetDCKCFGR2_UART8SEL(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR2.Reg, volatile.LoadUint32(&o.DCKCFGR2.Reg)&^(0xc000)|value<<14)
}
func (o *RCC_Type) GetDCKCFGR2_UART8SEL() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR2.Reg) & 0xc000) >> 14
}
func (o *RCC_Type) SetDCKCFGR2_I2C1SEL(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR2.Reg, volatile.LoadUint32(&o.DCKCFGR2.Reg)&^(0x30000)|value<<16)
}
func (o *RCC_Type) GetDCKCFGR2_I2C1SEL() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR2.Reg) & 0x30000) >> 16
}
func (o *RCC_Type) SetDCKCFGR2_I2C2SEL(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR2.Reg, volatile.LoadUint32(&o.DCKCFGR2.Reg)&^(0xc0000)|value<<18)
}
func (o *RCC_Type) GetDCKCFGR2_I2C2SEL() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR2.Reg) & 0xc0000) >> 18
}
func (o *RCC_Type) SetDCKCFGR2_I2C3SEL(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR2.Reg, volatile.LoadUint32(&o.DCKCFGR2.Reg)&^(0x300000)|value<<20)
}
func (o *RCC_Type) GetDCKCFGR2_I2C3SEL() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR2.Reg) & 0x300000) >> 20
}
func (o *RCC_Type) SetDCKCFGR2_I2C4SEL(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR2.Reg, volatile.LoadUint32(&o.DCKCFGR2.Reg)&^(0xc00000)|value<<22)
}
func (o *RCC_Type) GetDCKCFGR2_I2C4SEL() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR2.Reg) & 0xc00000) >> 22
}
func (o *RCC_Type) SetDCKCFGR2_LPTIM1SEL(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR2.Reg, volatile.LoadUint32(&o.DCKCFGR2.Reg)&^(0x3000000)|value<<24)
}
func (o *RCC_Type) GetDCKCFGR2_LPTIM1SEL() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR2.Reg) & 0x3000000) >> 24
}
func (o *RCC_Type) SetDCKCFGR2_CECSEL(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR2.Reg, volatile.LoadUint32(&o.DCKCFGR2.Reg)&^(0x4000000)|value<<26)
}
func (o *RCC_Type) GetDCKCFGR2_CECSEL() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR2.Reg) & 0x4000000) >> 26
}
func (o *RCC_Type) SetDCKCFGR2_CK48MSEL(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR2.Reg, volatile.LoadUint32(&o.DCKCFGR2.Reg)&^(0x8000000)|value<<27)
}
func (o *RCC_Type) GetDCKCFGR2_CK48MSEL() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR2.Reg) & 0x8000000) >> 27
}
func (o *RCC_Type) SetDCKCFGR2_SDMMC1SEL(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR2.Reg, volatile.LoadUint32(&o.DCKCFGR2.Reg)&^(0x10000000)|value<<28)
}
func (o *RCC_Type) GetDCKCFGR2_SDMMC1SEL() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR2.Reg) & 0x10000000) >> 28
}
func (o *RCC_Type) SetDCKCFGR2_SDMMC2SEL(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR2.Reg, volatile.LoadUint32(&o.DCKCFGR2.Reg)&^(0x20000000)|value<<29)
}
func (o *RCC_Type) GetDCKCFGR2_SDMMC2SEL() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR2.Reg) & 0x20000000) >> 29
}
func (o *RCC_Type) SetDCKCFGR2_DSISEL(value uint32) {
	volatile.StoreUint32(&o.DCKCFGR2.Reg, volatile.LoadUint32(&o.DCKCFGR2.Reg)&^(0x40000000)|value<<30)
}
func (o *RCC_Type) GetDCKCFGR2_DSISEL() uint32 {
	return (volatile.LoadUint32(&o.DCKCFGR2.Reg) & 0x40000000) >> 30
}

// General-purpose I/Os
type GPIO_Type struct {
	MODER   volatile.Register32 // 0x0
	OTYPER  volatile.Register32 // 0x4
	OSPEEDR volatile.Register32 // 0x8
	PUPDR   volatile.Register32 // 0xC
	IDR     volatile.Register32 // 0x10
	ODR     volatile.Register32 // 0x14
	BSRR    volatile.Register32 // 0x18
	LCKR    volatile.Register32 // 0x1C
	AFRL    volatile.Register32 // 0x20
	AFRH    volatile.Register32 // 0x24
	BRR     volatile.Register32 // 0x28
}

// GPIO.MODER: GPIO port mode register
func (o *GPIO_Type) SetMODER_MODER15(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPIO_Type) GetMODER_MODER15() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc0000000) >> 30
}
func (o *GPIO_Type) SetMODER_MODER14(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x30000000)|value<<28)
}
func (o *GPIO_Type) GetMODER_MODER14() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x30000000) >> 28
}
func (o *GPIO_Type) SetMODER_MODER13(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc000000)|value<<26)
}
func (o *GPIO_Type) GetMODER_MODER13() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc000000) >> 26
}
func (o *GPIO_Type) SetMODER_MODER12(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x3000000)|value<<24)
}
func (o *GPIO_Type) GetMODER_MODER12() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x3000000) >> 24
}
func (o *GPIO_Type) SetMODER_MODER11(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc00000)|value<<22)
}
func (o *GPIO_Type) GetMODER_MODER11() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc00000) >> 22
}
func (o *GPIO_Type) SetMODER_MODER10(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x300000)|value<<20)
}
func (o *GPIO_Type) GetMODER_MODER10() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x300000) >> 20
}
func (o *GPIO_Type) SetMODER_MODER9(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc0000)|value<<18)
}
func (o *GPIO_Type) GetMODER_MODER9() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc0000) >> 18
}
func (o *GPIO_Type) SetMODER_MODER8(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x30000)|value<<16)
}
func (o *GPIO_Type) GetMODER_MODER8() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x30000) >> 16
}
func (o *GPIO_Type) SetMODER_MODER7(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc000)|value<<14)
}
func (o *GPIO_Type) GetMODER_MODER7() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc000) >> 14
}
func (o *GPIO_Type) SetMODER_MODER6(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x3000)|value<<12)
}
func (o *GPIO_Type) GetMODER_MODER6() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x3000) >> 12
}
func (o *GPIO_Type) SetMODER_MODER5(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc00)|value<<10)
}
func (o *GPIO_Type) GetMODER_MODER5() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc00) >> 10
}
func (o *GPIO_Type) SetMODER_MODER4(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x300)|value<<8)
}
func (o *GPIO_Type) GetMODER_MODER4() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x300) >> 8
}
func (o *GPIO_Type) SetMODER_MODER3(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc0)|value<<6)
}
func (o *GPIO_Type) GetMODER_MODER3() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc0) >> 6
}
func (o *GPIO_Type) SetMODER_MODER2(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x30)|value<<4)
}
func (o *GPIO_Type) GetMODER_MODER2() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0x30) >> 4
}
func (o *GPIO_Type) SetMODER_MODER1(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0xc)|value<<2)
}
func (o *GPIO_Type) GetMODER_MODER1() uint32 {
	return (volatile.LoadUint32(&o.MODER.Reg) & 0xc) >> 2
}
func (o *GPIO_Type) SetMODER_MODER0(value uint32) {
	volatile.StoreUint32(&o.MODER.Reg, volatile.LoadUint32(&o.MODER.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetMODER_MODER0() uint32 {
	return volatile.LoadUint32(&o.MODER.Reg) & 0x3
}

// GPIO.OTYPER: GPIO port output type register
func (o *GPIO_Type) SetOTYPER_OT15(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetOTYPER_OT15() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetOTYPER_OT14(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetOTYPER_OT14() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetOTYPER_OT13(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetOTYPER_OT13() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetOTYPER_OT12(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetOTYPER_OT12() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetOTYPER_OT11(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetOTYPER_OT11() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetOTYPER_OT10(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetOTYPER_OT10() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetOTYPER_OT9(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetOTYPER_OT9() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetOTYPER_OT8(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetOTYPER_OT8() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetOTYPER_OT7(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetOTYPER_OT7() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetOTYPER_OT6(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetOTYPER_OT6() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetOTYPER_OT5(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetOTYPER_OT5() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetOTYPER_OT4(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetOTYPER_OT4() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetOTYPER_OT3(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetOTYPER_OT3() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetOTYPER_OT2(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetOTYPER_OT2() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetOTYPER_OT1(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetOTYPER_OT1() uint32 {
	return (volatile.LoadUint32(&o.OTYPER.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetOTYPER_OT0(value uint32) {
	volatile.StoreUint32(&o.OTYPER.Reg, volatile.LoadUint32(&o.OTYPER.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetOTYPER_OT0() uint32 {
	return volatile.LoadUint32(&o.OTYPER.Reg) & 0x1
}

// GPIO.OSPEEDR: GPIO port output speed register
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR15(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR15() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc0000000) >> 30
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR14(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x30000000)|value<<28)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR14() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x30000000) >> 28
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR13(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc000000)|value<<26)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR13() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc000000) >> 26
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR12(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x3000000)|value<<24)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR12() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x3000000) >> 24
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR11(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc00000)|value<<22)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR11() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc00000) >> 22
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR10(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x300000)|value<<20)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR10() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x300000) >> 20
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR9(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc0000)|value<<18)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR9() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc0000) >> 18
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR8(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x30000)|value<<16)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR8() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x30000) >> 16
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR7(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc000)|value<<14)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR7() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc000) >> 14
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR6(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x3000)|value<<12)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR6() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x3000) >> 12
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR5(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc00)|value<<10)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR5() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc00) >> 10
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR4(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x300)|value<<8)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR4() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x300) >> 8
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR3(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc0)|value<<6)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR3() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc0) >> 6
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR2(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x30)|value<<4)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR2() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x30) >> 4
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR1(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0xc)|value<<2)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR1() uint32 {
	return (volatile.LoadUint32(&o.OSPEEDR.Reg) & 0xc) >> 2
}
func (o *GPIO_Type) SetOSPEEDR_OSPEEDR0(value uint32) {
	volatile.StoreUint32(&o.OSPEEDR.Reg, volatile.LoadUint32(&o.OSPEEDR.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetOSPEEDR_OSPEEDR0() uint32 {
	return volatile.LoadUint32(&o.OSPEEDR.Reg) & 0x3
}

// GPIO.PUPDR: GPIO port pull-up/pull-down register
func (o *GPIO_Type) SetPUPDR_PUPDR15(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPIO_Type) GetPUPDR_PUPDR15() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc0000000) >> 30
}
func (o *GPIO_Type) SetPUPDR_PUPDR14(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x30000000)|value<<28)
}
func (o *GPIO_Type) GetPUPDR_PUPDR14() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x30000000) >> 28
}
func (o *GPIO_Type) SetPUPDR_PUPDR13(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc000000)|value<<26)
}
func (o *GPIO_Type) GetPUPDR_PUPDR13() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc000000) >> 26
}
func (o *GPIO_Type) SetPUPDR_PUPDR12(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x3000000)|value<<24)
}
func (o *GPIO_Type) GetPUPDR_PUPDR12() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x3000000) >> 24
}
func (o *GPIO_Type) SetPUPDR_PUPDR11(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc00000)|value<<22)
}
func (o *GPIO_Type) GetPUPDR_PUPDR11() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc00000) >> 22
}
func (o *GPIO_Type) SetPUPDR_PUPDR10(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x300000)|value<<20)
}
func (o *GPIO_Type) GetPUPDR_PUPDR10() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x300000) >> 20
}
func (o *GPIO_Type) SetPUPDR_PUPDR9(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc0000)|value<<18)
}
func (o *GPIO_Type) GetPUPDR_PUPDR9() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc0000) >> 18
}
func (o *GPIO_Type) SetPUPDR_PUPDR8(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x30000)|value<<16)
}
func (o *GPIO_Type) GetPUPDR_PUPDR8() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x30000) >> 16
}
func (o *GPIO_Type) SetPUPDR_PUPDR7(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc000)|value<<14)
}
func (o *GPIO_Type) GetPUPDR_PUPDR7() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc000) >> 14
}
func (o *GPIO_Type) SetPUPDR_PUPDR6(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x3000)|value<<12)
}
func (o *GPIO_Type) GetPUPDR_PUPDR6() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x3000) >> 12
}
func (o *GPIO_Type) SetPUPDR_PUPDR5(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc00)|value<<10)
}
func (o *GPIO_Type) GetPUPDR_PUPDR5() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc00) >> 10
}
func (o *GPIO_Type) SetPUPDR_PUPDR4(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x300)|value<<8)
}
func (o *GPIO_Type) GetPUPDR_PUPDR4() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x300) >> 8
}
func (o *GPIO_Type) SetPUPDR_PUPDR3(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc0)|value<<6)
}
func (o *GPIO_Type) GetPUPDR_PUPDR3() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc0) >> 6
}
func (o *GPIO_Type) SetPUPDR_PUPDR2(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x30)|value<<4)
}
func (o *GPIO_Type) GetPUPDR_PUPDR2() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0x30) >> 4
}
func (o *GPIO_Type) SetPUPDR_PUPDR1(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0xc)|value<<2)
}
func (o *GPIO_Type) GetPUPDR_PUPDR1() uint32 {
	return (volatile.LoadUint32(&o.PUPDR.Reg) & 0xc) >> 2
}
func (o *GPIO_Type) SetPUPDR_PUPDR0(value uint32) {
	volatile.StoreUint32(&o.PUPDR.Reg, volatile.LoadUint32(&o.PUPDR.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetPUPDR_PUPDR0() uint32 {
	return volatile.LoadUint32(&o.PUPDR.Reg) & 0x3
}

// GPIO.IDR: GPIO port input data register
func (o *GPIO_Type) SetIDR_IDR15(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetIDR_IDR15() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetIDR_IDR14(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetIDR_IDR14() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetIDR_IDR13(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetIDR_IDR13() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetIDR_IDR12(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetIDR_IDR12() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetIDR_IDR11(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetIDR_IDR11() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetIDR_IDR10(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetIDR_IDR10() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetIDR_IDR9(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetIDR_IDR9() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetIDR_IDR8(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetIDR_IDR8() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetIDR_IDR7(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetIDR_IDR7() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetIDR_IDR6(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetIDR_IDR6() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetIDR_IDR5(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetIDR_IDR5() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetIDR_IDR4(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetIDR_IDR4() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetIDR_IDR3(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetIDR_IDR3() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetIDR_IDR2(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetIDR_IDR2() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetIDR_IDR1(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetIDR_IDR1() uint32 {
	return (volatile.LoadUint32(&o.IDR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetIDR_IDR0(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetIDR_IDR0() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0x1
}

// GPIO.ODR: GPIO port output data register
func (o *GPIO_Type) SetODR_ODR15(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetODR_ODR15() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetODR_ODR14(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetODR_ODR14() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetODR_ODR13(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetODR_ODR13() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetODR_ODR12(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetODR_ODR12() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetODR_ODR11(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetODR_ODR11() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetODR_ODR10(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetODR_ODR10() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetODR_ODR9(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetODR_ODR9() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetODR_ODR8(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetODR_ODR8() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetODR_ODR7(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetODR_ODR7() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetODR_ODR6(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetODR_ODR6() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetODR_ODR5(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetODR_ODR5() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetODR_ODR4(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetODR_ODR4() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetODR_ODR3(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetODR_ODR3() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetODR_ODR2(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetODR_ODR2() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetODR_ODR1(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetODR_ODR1() uint32 {
	return (volatile.LoadUint32(&o.ODR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetODR_ODR0(value uint32) {
	volatile.StoreUint32(&o.ODR.Reg, volatile.LoadUint32(&o.ODR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetODR_ODR0() uint32 {
	return volatile.LoadUint32(&o.ODR.Reg) & 0x1
}

// GPIO.BSRR: GPIO port bit set/reset register
func (o *GPIO_Type) SetBSRR_BR15(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetBSRR_BR15() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x80000000) >> 31
}
func (o *GPIO_Type) SetBSRR_BR14(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetBSRR_BR14() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetBSRR_BR13(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetBSRR_BR13() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetBSRR_BR12(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetBSRR_BR12() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetBSRR_BR11(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetBSRR_BR11() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetBSRR_BR10(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetBSRR_BR10() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetBSRR_BR9(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetBSRR_BR9() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetBSRR_BR8(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetBSRR_BR8() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetBSRR_BR7(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetBSRR_BR7() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetBSRR_BR6(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetBSRR_BR6() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetBSRR_BR5(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetBSRR_BR5() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetBSRR_BR4(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetBSRR_BR4() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetBSRR_BR3(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetBSRR_BR3() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetBSRR_BR2(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetBSRR_BR2() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetBSRR_BR1(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetBSRR_BR1() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetBSRR_BR0(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetBSRR_BR0() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetBSRR_BS15(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetBSRR_BS15() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetBSRR_BS14(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetBSRR_BS14() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetBSRR_BS13(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetBSRR_BS13() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetBSRR_BS12(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetBSRR_BS12() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetBSRR_BS11(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetBSRR_BS11() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetBSRR_BS10(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetBSRR_BS10() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetBSRR_BS9(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetBSRR_BS9() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetBSRR_BS8(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetBSRR_BS8() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetBSRR_BS7(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetBSRR_BS7() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetBSRR_BS6(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetBSRR_BS6() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetBSRR_BS5(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetBSRR_BS5() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetBSRR_BS4(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetBSRR_BS4() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetBSRR_BS3(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetBSRR_BS3() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetBSRR_BS2(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetBSRR_BS2() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetBSRR_BS1(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetBSRR_BS1() uint32 {
	return (volatile.LoadUint32(&o.BSRR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetBSRR_BS0(value uint32) {
	volatile.StoreUint32(&o.BSRR.Reg, volatile.LoadUint32(&o.BSRR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetBSRR_BS0() uint32 {
	return volatile.LoadUint32(&o.BSRR.Reg) & 0x1
}

// GPIO.LCKR: GPIO port configuration lock register
func (o *GPIO_Type) SetLCKR_LCKK(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetLCKR_LCKK() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetLCKR_LCK15(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetLCKR_LCK15() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetLCKR_LCK14(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetLCKR_LCK14() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetLCKR_LCK13(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetLCKR_LCK13() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetLCKR_LCK12(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetLCKR_LCK12() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetLCKR_LCK11(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetLCKR_LCK11() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetLCKR_LCK10(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetLCKR_LCK10() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetLCKR_LCK9(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetLCKR_LCK9() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetLCKR_LCK8(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetLCKR_LCK8() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetLCKR_LCK7(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetLCKR_LCK7() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetLCKR_LCK6(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetLCKR_LCK6() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetLCKR_LCK5(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetLCKR_LCK5() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetLCKR_LCK4(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetLCKR_LCK4() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetLCKR_LCK3(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetLCKR_LCK3() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetLCKR_LCK2(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetLCKR_LCK2() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetLCKR_LCK1(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetLCKR_LCK1() uint32 {
	return (volatile.LoadUint32(&o.LCKR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetLCKR_LCK0(value uint32) {
	volatile.StoreUint32(&o.LCKR.Reg, volatile.LoadUint32(&o.LCKR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetLCKR_LCK0() uint32 {
	return volatile.LoadUint32(&o.LCKR.Reg) & 0x1
}

// GPIO.AFRL: GPIO alternate function lowregister
func (o *GPIO_Type) SetAFRL_AFRL7(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf0000000)|value<<28)
}
func (o *GPIO_Type) GetAFRL_AFRL7() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf0000000) >> 28
}
func (o *GPIO_Type) SetAFRL_AFRL6(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf000000)|value<<24)
}
func (o *GPIO_Type) GetAFRL_AFRL6() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf000000) >> 24
}
func (o *GPIO_Type) SetAFRL_AFRL5(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf00000)|value<<20)
}
func (o *GPIO_Type) GetAFRL_AFRL5() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf00000) >> 20
}
func (o *GPIO_Type) SetAFRL_AFRL4(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf0000)|value<<16)
}
func (o *GPIO_Type) GetAFRL_AFRL4() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf0000) >> 16
}
func (o *GPIO_Type) SetAFRL_AFRL3(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf000)|value<<12)
}
func (o *GPIO_Type) GetAFRL_AFRL3() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf000) >> 12
}
func (o *GPIO_Type) SetAFRL_AFRL2(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf00)|value<<8)
}
func (o *GPIO_Type) GetAFRL_AFRL2() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf00) >> 8
}
func (o *GPIO_Type) SetAFRL_AFRL1(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf0)|value<<4)
}
func (o *GPIO_Type) GetAFRL_AFRL1() uint32 {
	return (volatile.LoadUint32(&o.AFRL.Reg) & 0xf0) >> 4
}
func (o *GPIO_Type) SetAFRL_AFRL0(value uint32) {
	volatile.StoreUint32(&o.AFRL.Reg, volatile.LoadUint32(&o.AFRL.Reg)&^(0xf)|value)
}
func (o *GPIO_Type) GetAFRL_AFRL0() uint32 {
	return volatile.LoadUint32(&o.AFRL.Reg) & 0xf
}

// GPIO.AFRH: GPIO alternate function high register
func (o *GPIO_Type) SetAFRH_AFRH15(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf0000000)|value<<28)
}
func (o *GPIO_Type) GetAFRH_AFRH15() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf0000000) >> 28
}
func (o *GPIO_Type) SetAFRH_AFRH14(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf000000)|value<<24)
}
func (o *GPIO_Type) GetAFRH_AFRH14() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf000000) >> 24
}
func (o *GPIO_Type) SetAFRH_AFRH13(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf00000)|value<<20)
}
func (o *GPIO_Type) GetAFRH_AFRH13() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf00000) >> 20
}
func (o *GPIO_Type) SetAFRH_AFRH12(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf0000)|value<<16)
}
func (o *GPIO_Type) GetAFRH_AFRH12() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf0000) >> 16
}
func (o *GPIO_Type) SetAFRH_AFRH11(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf000)|value<<12)
}
func (o *GPIO_Type) GetAFRH_AFRH11() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf000) >> 12
}
func (o *GPIO_Type) SetAFRH_AFRH10(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf00)|value<<8)
}
func (o *GPIO_Type) GetAFRH_AFRH10() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf00) >> 8
}
func (o *GPIO_Type) SetAFRH_AFRH9(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf0)|value<<4)
}
func (o *GPIO_Type) GetAFRH_AFRH9() uint32 {
	return (volatile.LoadUint32(&o.AFRH.Reg) & 0xf0) >> 4
}
func (o *GPIO_Type) SetAFRH_AFRH8(value uint32) {
	volatile.StoreUint32(&o.AFRH.Reg, volatile.LoadUint32(&o.AFRH.Reg)&^(0xf)|value)
}
func (o *GPIO_Type) GetAFRH_AFRH8() uint32 {
	return volatile.LoadUint32(&o.AFRH.Reg) & 0xf
}

// GPIO.BRR: GPIO port bit reset register
func (o *GPIO_Type) SetBRR_BR0(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetBRR_BR0() uint32 {
	return volatile.LoadUint32(&o.BRR.Reg) & 0x1
}
func (o *GPIO_Type) SetBRR_BR1(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetBRR_BR1() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetBRR_BR2(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetBRR_BR2() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetBRR_BR3(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetBRR_BR3() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetBRR_BR4(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetBRR_BR4() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetBRR_BR5(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetBRR_BR5() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetBRR_BR6(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetBRR_BR6() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetBRR_BR7(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetBRR_BR7() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetBRR_BR8(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetBRR_BR8() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetBRR_BR9(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetBRR_BR9() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetBRR_BR10(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetBRR_BR10() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetBRR_BR11(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetBRR_BR11() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetBRR_BR12(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetBRR_BR12() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetBRR_BR13(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetBRR_BR13() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetBRR_BR14(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetBRR_BR14() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetBRR_BR15(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetBRR_BR15() uint32 {
	return (volatile.LoadUint32(&o.BRR.Reg) & 0x8000) >> 15
}

// System configuration controller
type SYSCFG_Type struct {
	MEMRMP  volatile.Register32 // 0x0
	PMC     volatile.Register32 // 0x4
	EXTICR1 volatile.Register32 // 0x8
	EXTICR2 volatile.Register32 // 0xC
	EXTICR3 volatile.Register32 // 0x10
	EXTICR4 volatile.Register32 // 0x14
	_       [8]byte
	CMPCR   volatile.Register32 // 0x20
}

// SYSCFG.MEMRMP: memory remap register
func (o *SYSCFG_Type) SetMEMRMP_MEM_BOOT(value uint32) {
	volatile.StoreUint32(&o.MEMRMP.Reg, volatile.LoadUint32(&o.MEMRMP.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetMEMRMP_MEM_BOOT() uint32 {
	return volatile.LoadUint32(&o.MEMRMP.Reg) & 0x1
}
func (o *SYSCFG_Type) SetMEMRMP_FB_MODE(value uint32) {
	volatile.StoreUint32(&o.MEMRMP.Reg, volatile.LoadUint32(&o.MEMRMP.Reg)&^(0x100)|value<<8)
}
func (o *SYSCFG_Type) GetMEMRMP_FB_MODE() uint32 {
	return (volatile.LoadUint32(&o.MEMRMP.Reg) & 0x100) >> 8
}
func (o *SYSCFG_Type) SetMEMRMP_SWP_FMC(value uint32) {
	volatile.StoreUint32(&o.MEMRMP.Reg, volatile.LoadUint32(&o.MEMRMP.Reg)&^(0xc00)|value<<10)
}
func (o *SYSCFG_Type) GetMEMRMP_SWP_FMC() uint32 {
	return (volatile.LoadUint32(&o.MEMRMP.Reg) & 0xc00) >> 10
}

// SYSCFG.PMC: peripheral mode configuration register
func (o *SYSCFG_Type) SetPMC_MII_RMII_SEL(value uint32) {
	volatile.StoreUint32(&o.PMC.Reg, volatile.LoadUint32(&o.PMC.Reg)&^(0x800000)|value<<23)
}
func (o *SYSCFG_Type) GetPMC_MII_RMII_SEL() uint32 {
	return (volatile.LoadUint32(&o.PMC.Reg) & 0x800000) >> 23
}
func (o *SYSCFG_Type) SetPMC_ADC1DC2(value uint32) {
	volatile.StoreUint32(&o.PMC.Reg, volatile.LoadUint32(&o.PMC.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCFG_Type) GetPMC_ADC1DC2() uint32 {
	return (volatile.LoadUint32(&o.PMC.Reg) & 0x10000) >> 16
}
func (o *SYSCFG_Type) SetPMC_ADC2DC2(value uint32) {
	volatile.StoreUint32(&o.PMC.Reg, volatile.LoadUint32(&o.PMC.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCFG_Type) GetPMC_ADC2DC2() uint32 {
	return (volatile.LoadUint32(&o.PMC.Reg) & 0x20000) >> 17
}
func (o *SYSCFG_Type) SetPMC_ADC3DC2(value uint32) {
	volatile.StoreUint32(&o.PMC.Reg, volatile.LoadUint32(&o.PMC.Reg)&^(0x40000)|value<<18)
}
func (o *SYSCFG_Type) GetPMC_ADC3DC2() uint32 {
	return (volatile.LoadUint32(&o.PMC.Reg) & 0x40000) >> 18
}
func (o *SYSCFG_Type) SetPMC_PB9_FMP(value uint32) {
	volatile.StoreUint32(&o.PMC.Reg, volatile.LoadUint32(&o.PMC.Reg)&^(0x80)|value<<7)
}
func (o *SYSCFG_Type) GetPMC_PB9_FMP() uint32 {
	return (volatile.LoadUint32(&o.PMC.Reg) & 0x80) >> 7
}
func (o *SYSCFG_Type) SetPMC_PB8_FMP(value uint32) {
	volatile.StoreUint32(&o.PMC.Reg, volatile.LoadUint32(&o.PMC.Reg)&^(0x40)|value<<6)
}
func (o *SYSCFG_Type) GetPMC_PB8_FMP() uint32 {
	return (volatile.LoadUint32(&o.PMC.Reg) & 0x40) >> 6
}
func (o *SYSCFG_Type) SetPMC_PB7_FMP(value uint32) {
	volatile.StoreUint32(&o.PMC.Reg, volatile.LoadUint32(&o.PMC.Reg)&^(0x20)|value<<5)
}
func (o *SYSCFG_Type) GetPMC_PB7_FMP() uint32 {
	return (volatile.LoadUint32(&o.PMC.Reg) & 0x20) >> 5
}
func (o *SYSCFG_Type) SetPMC_PB6_FMP(value uint32) {
	volatile.StoreUint32(&o.PMC.Reg, volatile.LoadUint32(&o.PMC.Reg)&^(0x10)|value<<4)
}
func (o *SYSCFG_Type) GetPMC_PB6_FMP() uint32 {
	return (volatile.LoadUint32(&o.PMC.Reg) & 0x10) >> 4
}
func (o *SYSCFG_Type) SetPMC_I2C4_FMP(value uint32) {
	volatile.StoreUint32(&o.PMC.Reg, volatile.LoadUint32(&o.PMC.Reg)&^(0x8)|value<<3)
}
func (o *SYSCFG_Type) GetPMC_I2C4_FMP() uint32 {
	return (volatile.LoadUint32(&o.PMC.Reg) & 0x8) >> 3
}
func (o *SYSCFG_Type) SetPMC_I2C3_FMP(value uint32) {
	volatile.StoreUint32(&o.PMC.Reg, volatile.LoadUint32(&o.PMC.Reg)&^(0x4)|value<<2)
}
func (o *SYSCFG_Type) GetPMC_I2C3_FMP() uint32 {
	return (volatile.LoadUint32(&o.PMC.Reg) & 0x4) >> 2
}
func (o *SYSCFG_Type) SetPMC_I2C2_FMP(value uint32) {
	volatile.StoreUint32(&o.PMC.Reg, volatile.LoadUint32(&o.PMC.Reg)&^(0x2)|value<<1)
}
func (o *SYSCFG_Type) GetPMC_I2C2_FMP() uint32 {
	return (volatile.LoadUint32(&o.PMC.Reg) & 0x2) >> 1
}
func (o *SYSCFG_Type) SetPMC_I2C1_FMP(value uint32) {
	volatile.StoreUint32(&o.PMC.Reg, volatile.LoadUint32(&o.PMC.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetPMC_I2C1_FMP() uint32 {
	return volatile.LoadUint32(&o.PMC.Reg) & 0x1
}

// SYSCFG.EXTICR1: external interrupt configuration register 1
func (o *SYSCFG_Type) SetEXTICR1_EXTI3(value uint32) {
	volatile.StoreUint32(&o.EXTICR1.Reg, volatile.LoadUint32(&o.EXTICR1.Reg)&^(0xf000)|value<<12)
}
func (o *SYSCFG_Type) GetEXTICR1_EXTI3() uint32 {
	return (volatile.LoadUint32(&o.EXTICR1.Reg) & 0xf000) >> 12
}
func (o *SYSCFG_Type) SetEXTICR1_EXTI2(value uint32) {
	volatile.StoreUint32(&o.EXTICR1.Reg, volatile.LoadUint32(&o.EXTICR1.Reg)&^(0xf00)|value<<8)
}
func (o *SYSCFG_Type) GetEXTICR1_EXTI2() uint32 {
	return (volatile.LoadUint32(&o.EXTICR1.Reg) & 0xf00) >> 8
}
func (o *SYSCFG_Type) SetEXTICR1_EXTI1(value uint32) {
	volatile.StoreUint32(&o.EXTICR1.Reg, volatile.LoadUint32(&o.EXTICR1.Reg)&^(0xf0)|value<<4)
}
func (o *SYSCFG_Type) GetEXTICR1_EXTI1() uint32 {
	return (volatile.LoadUint32(&o.EXTICR1.Reg) & 0xf0) >> 4
}
func (o *SYSCFG_Type) SetEXTICR1_EXTI0(value uint32) {
	volatile.StoreUint32(&o.EXTICR1.Reg, volatile.LoadUint32(&o.EXTICR1.Reg)&^(0xf)|value)
}
func (o *SYSCFG_Type) GetEXTICR1_EXTI0() uint32 {
	return volatile.LoadUint32(&o.EXTICR1.Reg) & 0xf
}

// SYSCFG.EXTICR2: external interrupt configuration register 2
func (o *SYSCFG_Type) SetEXTICR2_EXTI7(value uint32) {
	volatile.StoreUint32(&o.EXTICR2.Reg, volatile.LoadUint32(&o.EXTICR2.Reg)&^(0xf000)|value<<12)
}
func (o *SYSCFG_Type) GetEXTICR2_EXTI7() uint32 {
	return (volatile.LoadUint32(&o.EXTICR2.Reg) & 0xf000) >> 12
}
func (o *SYSCFG_Type) SetEXTICR2_EXTI6(value uint32) {
	volatile.StoreUint32(&o.EXTICR2.Reg, volatile.LoadUint32(&o.EXTICR2.Reg)&^(0xf00)|value<<8)
}
func (o *SYSCFG_Type) GetEXTICR2_EXTI6() uint32 {
	return (volatile.LoadUint32(&o.EXTICR2.Reg) & 0xf00) >> 8
}
func (o *SYSCFG_Type) SetEXTICR2_EXTI5(value uint32) {
	volatile.StoreUint32(&o.EXTICR2.Reg, volatile.LoadUint32(&o.EXTICR2.Reg)&^(0xf0)|value<<4)
}
func (o *SYSCFG_Type) GetEXTICR2_EXTI5() uint32 {
	return (volatile.LoadUint32(&o.EXTICR2.Reg) & 0xf0) >> 4
}
func (o *SYSCFG_Type) SetEXTICR2_EXTI4(value uint32) {
	volatile.StoreUint32(&o.EXTICR2.Reg, volatile.LoadUint32(&o.EXTICR2.Reg)&^(0xf)|value)
}
func (o *SYSCFG_Type) GetEXTICR2_EXTI4() uint32 {
	return volatile.LoadUint32(&o.EXTICR2.Reg) & 0xf
}

// SYSCFG.EXTICR3: external interrupt configuration register 3
func (o *SYSCFG_Type) SetEXTICR3_EXTI11(value uint32) {
	volatile.StoreUint32(&o.EXTICR3.Reg, volatile.LoadUint32(&o.EXTICR3.Reg)&^(0xf000)|value<<12)
}
func (o *SYSCFG_Type) GetEXTICR3_EXTI11() uint32 {
	return (volatile.LoadUint32(&o.EXTICR3.Reg) & 0xf000) >> 12
}
func (o *SYSCFG_Type) SetEXTICR3_EXTI10(value uint32) {
	volatile.StoreUint32(&o.EXTICR3.Reg, volatile.LoadUint32(&o.EXTICR3.Reg)&^(0xf00)|value<<8)
}
func (o *SYSCFG_Type) GetEXTICR3_EXTI10() uint32 {
	return (volatile.LoadUint32(&o.EXTICR3.Reg) & 0xf00) >> 8
}
func (o *SYSCFG_Type) SetEXTICR3_EXTI9(value uint32) {
	volatile.StoreUint32(&o.EXTICR3.Reg, volatile.LoadUint32(&o.EXTICR3.Reg)&^(0xf0)|value<<4)
}
func (o *SYSCFG_Type) GetEXTICR3_EXTI9() uint32 {
	return (volatile.LoadUint32(&o.EXTICR3.Reg) & 0xf0) >> 4
}
func (o *SYSCFG_Type) SetEXTICR3_EXTI8(value uint32) {
	volatile.StoreUint32(&o.EXTICR3.Reg, volatile.LoadUint32(&o.EXTICR3.Reg)&^(0xf)|value)
}
func (o *SYSCFG_Type) GetEXTICR3_EXTI8() uint32 {
	return volatile.LoadUint32(&o.EXTICR3.Reg) & 0xf
}

// SYSCFG.EXTICR4: external interrupt configuration register 4
func (o *SYSCFG_Type) SetEXTICR4_EXTI15(value uint32) {
	volatile.StoreUint32(&o.EXTICR4.Reg, volatile.LoadUint32(&o.EXTICR4.Reg)&^(0xf000)|value<<12)
}
func (o *SYSCFG_Type) GetEXTICR4_EXTI15() uint32 {
	return (volatile.LoadUint32(&o.EXTICR4.Reg) & 0xf000) >> 12
}
func (o *SYSCFG_Type) SetEXTICR4_EXTI14(value uint32) {
	volatile.StoreUint32(&o.EXTICR4.Reg, volatile.LoadUint32(&o.EXTICR4.Reg)&^(0xf00)|value<<8)
}
func (o *SYSCFG_Type) GetEXTICR4_EXTI14() uint32 {
	return (volatile.LoadUint32(&o.EXTICR4.Reg) & 0xf00) >> 8
}
func (o *SYSCFG_Type) SetEXTICR4_EXTI13(value uint32) {
	volatile.StoreUint32(&o.EXTICR4.Reg, volatile.LoadUint32(&o.EXTICR4.Reg)&^(0xf0)|value<<4)
}
func (o *SYSCFG_Type) GetEXTICR4_EXTI13() uint32 {
	return (volatile.LoadUint32(&o.EXTICR4.Reg) & 0xf0) >> 4
}
func (o *SYSCFG_Type) SetEXTICR4_EXTI12(value uint32) {
	volatile.StoreUint32(&o.EXTICR4.Reg, volatile.LoadUint32(&o.EXTICR4.Reg)&^(0xf)|value)
}
func (o *SYSCFG_Type) GetEXTICR4_EXTI12() uint32 {
	return volatile.LoadUint32(&o.EXTICR4.Reg) & 0xf
}

// SYSCFG.CMPCR: Compensation cell control register
func (o *SYSCFG_Type) SetCMPCR_READY(value uint32) {
	volatile.StoreUint32(&o.CMPCR.Reg, volatile.LoadUint32(&o.CMPCR.Reg)&^(0x100)|value<<8)
}
func (o *SYSCFG_Type) GetCMPCR_READY() uint32 {
	return (volatile.LoadUint32(&o.CMPCR.Reg) & 0x100) >> 8
}
func (o *SYSCFG_Type) SetCMPCR_CMP_PD(value uint32) {
	volatile.StoreUint32(&o.CMPCR.Reg, volatile.LoadUint32(&o.CMPCR.Reg)&^(0x1)|value)
}
func (o *SYSCFG_Type) GetCMPCR_CMP_PD() uint32 {
	return volatile.LoadUint32(&o.CMPCR.Reg) & 0x1
}

// Serial peripheral interface
type SPI_Type struct {
	CR1     volatile.Register32 // 0x0
	CR2     volatile.Register32 // 0x4
	SR      volatile.Register32 // 0x8
	DR      volatile.Register32 // 0xC
	CRCPR   volatile.Register32 // 0x10
	RXCRCR  volatile.Register32 // 0x14
	TXCRCR  volatile.Register32 // 0x18
	I2SCFGR volatile.Register32 // 0x1C
	I2SPR   volatile.Register32 // 0x20
}

// SPI.CR1: control register 1
func (o *SPI_Type) SetCR1_BIDIMODE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8000)|value<<15)
}
func (o *SPI_Type) GetCR1_BIDIMODE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8000) >> 15
}
func (o *SPI_Type) SetCR1_BIDIOE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000)|value<<14)
}
func (o *SPI_Type) GetCR1_BIDIOE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000) >> 14
}
func (o *SPI_Type) SetCR1_CRCEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2000)|value<<13)
}
func (o *SPI_Type) GetCR1_CRCEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2000) >> 13
}
func (o *SPI_Type) SetCR1_CRCNEXT(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetCR1_CRCNEXT() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1000) >> 12
}
func (o *SPI_Type) SetCR1_CRCL(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetCR1_CRCL() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800) >> 11
}
func (o *SPI_Type) SetCR1_RXONLY(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetCR1_RXONLY() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetCR1_SSM(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetCR1_SSM() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetCR1_SSI(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetCR1_SSI() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetCR1_LSBFIRST(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetCR1_LSBFIRST() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetCR1_SPE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetCR1_SPE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetCR1_BR(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x38)|value<<3)
}
func (o *SPI_Type) GetCR1_BR() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x38) >> 3
}
func (o *SPI_Type) SetCR1_MSTR(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetCR1_MSTR() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetCR1_CPOL(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetCR1_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetCR1_CPHA(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetCR1_CPHA() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}

// SPI.CR2: control register 2
func (o *SPI_Type) SetCR2_RXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetCR2_RXDMAEN() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x1
}
func (o *SPI_Type) SetCR2_TXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetCR2_TXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetCR2_SSOE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetCR2_SSOE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetCR2_NSSP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetCR2_NSSP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetCR2_FRF(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetCR2_FRF() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetCR2_ERRIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetCR2_ERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetCR2_RXNEIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetCR2_RXNEIE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetCR2_TXEIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetCR2_TXEIE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetCR2_DS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xf00)|value<<8)
}
func (o *SPI_Type) GetCR2_DS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xf00) >> 8
}
func (o *SPI_Type) SetCR2_FRXTH(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetCR2_FRXTH() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1000) >> 12
}
func (o *SPI_Type) SetCR2_LDMA_RX(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000)|value<<13)
}
func (o *SPI_Type) GetCR2_LDMA_RX() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000) >> 13
}
func (o *SPI_Type) SetCR2_LDMA_TX(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4000)|value<<14)
}
func (o *SPI_Type) GetCR2_LDMA_TX() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4000) >> 14
}

// SPI.SR: status register
func (o *SPI_Type) SetSR_FRE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetSR_FRE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetSR_BSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetSR_BSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetSR_OVR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetSR_OVR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetSR_MODF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *SPI_Type) GetSR_MODF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *SPI_Type) SetSR_CRCERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetSR_CRCERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetSR_UDR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetSR_UDR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetSR_CHSIDE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetSR_CHSIDE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetSR_TXE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetSR_TXE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetSR_RXNE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetSR_RXNE() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *SPI_Type) SetSR_FRLVL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x600)|value<<9)
}
func (o *SPI_Type) GetSR_FRLVL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x600) >> 9
}
func (o *SPI_Type) SetSR_FTLVL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1800)|value<<11)
}
func (o *SPI_Type) GetSR_FTLVL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1800) >> 11
}

// SPI.DR: data register
func (o *SPI_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg) & 0xffff
}

// SPI.CRCPR: CRC polynomial register
func (o *SPI_Type) SetCRCPR_CRCPOLY(value uint32) {
	volatile.StoreUint32(&o.CRCPR.Reg, volatile.LoadUint32(&o.CRCPR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetCRCPR_CRCPOLY() uint32 {
	return volatile.LoadUint32(&o.CRCPR.Reg) & 0xffff
}

// SPI.RXCRCR: RX CRC register
func (o *SPI_Type) SetRXCRCR_RxCRC(value uint32) {
	volatile.StoreUint32(&o.RXCRCR.Reg, volatile.LoadUint32(&o.RXCRCR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetRXCRCR_RxCRC() uint32 {
	return volatile.LoadUint32(&o.RXCRCR.Reg) & 0xffff
}

// SPI.TXCRCR: TX CRC register
func (o *SPI_Type) SetTXCRCR_TxCRC(value uint32) {
	volatile.StoreUint32(&o.TXCRCR.Reg, volatile.LoadUint32(&o.TXCRCR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetTXCRCR_TxCRC() uint32 {
	return volatile.LoadUint32(&o.TXCRCR.Reg) & 0xffff
}

// SPI.I2SCFGR: I2S configuration register
func (o *SPI_Type) SetI2SCFGR_I2SMOD(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x800)|value<<11)
}
func (o *SPI_Type) GetI2SCFGR_I2SMOD() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x800) >> 11
}
func (o *SPI_Type) SetI2SCFGR_I2SE(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x400)|value<<10)
}
func (o *SPI_Type) GetI2SCFGR_I2SE() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x400) >> 10
}
func (o *SPI_Type) SetI2SCFGR_I2SCFG(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x300)|value<<8)
}
func (o *SPI_Type) GetI2SCFGR_I2SCFG() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x300) >> 8
}
func (o *SPI_Type) SetI2SCFGR_PCMSYNC(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetI2SCFGR_PCMSYNC() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetI2SCFGR_I2SSTD(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x30)|value<<4)
}
func (o *SPI_Type) GetI2SCFGR_I2SSTD() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x30) >> 4
}
func (o *SPI_Type) SetI2SCFGR_CKPOL(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetI2SCFGR_CKPOL() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetI2SCFGR_DATLEN(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x6)|value<<1)
}
func (o *SPI_Type) GetI2SCFGR_DATLEN() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x6) >> 1
}
func (o *SPI_Type) SetI2SCFGR_CHLEN(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetI2SCFGR_CHLEN() uint32 {
	return volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x1
}
func (o *SPI_Type) SetI2SCFGR_ASTRTEN(value uint32) {
	volatile.StoreUint32(&o.I2SCFGR.Reg, volatile.LoadUint32(&o.I2SCFGR.Reg)&^(0x1000)|value<<12)
}
func (o *SPI_Type) GetI2SCFGR_ASTRTEN() uint32 {
	return (volatile.LoadUint32(&o.I2SCFGR.Reg) & 0x1000) >> 12
}

// SPI.I2SPR: I2S prescaler register
func (o *SPI_Type) SetI2SPR_MCKOE(value uint32) {
	volatile.StoreUint32(&o.I2SPR.Reg, volatile.LoadUint32(&o.I2SPR.Reg)&^(0x200)|value<<9)
}
func (o *SPI_Type) GetI2SPR_MCKOE() uint32 {
	return (volatile.LoadUint32(&o.I2SPR.Reg) & 0x200) >> 9
}
func (o *SPI_Type) SetI2SPR_ODD(value uint32) {
	volatile.StoreUint32(&o.I2SPR.Reg, volatile.LoadUint32(&o.I2SPR.Reg)&^(0x100)|value<<8)
}
func (o *SPI_Type) GetI2SPR_ODD() uint32 {
	return (volatile.LoadUint32(&o.I2SPR.Reg) & 0x100) >> 8
}
func (o *SPI_Type) SetI2SPR_I2SDIV(value uint32) {
	volatile.StoreUint32(&o.I2SPR.Reg, volatile.LoadUint32(&o.I2SPR.Reg)&^(0xff)|value)
}
func (o *SPI_Type) GetI2SPR_I2SDIV() uint32 {
	return volatile.LoadUint32(&o.I2SPR.Reg) & 0xff
}

// Analog-to-digital converter
type ADC_Type struct {
	SR    volatile.Register32 // 0x0
	CR1   volatile.Register32 // 0x4
	CR2   volatile.Register32 // 0x8
	SMPR1 volatile.Register32 // 0xC
	SMPR2 volatile.Register32 // 0x10
	JOFR1 volatile.Register32 // 0x14
	JOFR2 volatile.Register32 // 0x18
	JOFR3 volatile.Register32 // 0x1C
	JOFR4 volatile.Register32 // 0x20
	HTR   volatile.Register32 // 0x24
	LTR   volatile.Register32 // 0x28
	SQR1  volatile.Register32 // 0x2C
	SQR2  volatile.Register32 // 0x30
	SQR3  volatile.Register32 // 0x34
	JSQR  volatile.Register32 // 0x38
	JDR1  volatile.Register32 // 0x3C
	JDR2  volatile.Register32 // 0x40
	JDR3  volatile.Register32 // 0x44
	JDR4  volatile.Register32 // 0x48
	DR    volatile.Register32 // 0x4C
}

// ADC.SR: status register
func (o *ADC_Type) SetSR_OVR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetSR_OVR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetSR_STRT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetSR_STRT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetSR_JSTRT(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetSR_JSTRT() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetSR_JEOC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetSR_JEOC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetSR_EOC(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetSR_EOC() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetSR_AWD(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetSR_AWD() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// ADC.CR1: control register 1
func (o *ADC_Type) SetCR1_OVRIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000000)|value<<26)
}
func (o *ADC_Type) GetCR1_OVRIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000000) >> 26
}
func (o *ADC_Type) SetCR1_RES(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x3000000)|value<<24)
}
func (o *ADC_Type) GetCR1_RES() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x3000000) >> 24
}
func (o *ADC_Type) SetCR1_AWDEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_Type) GetCR1_AWDEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800000) >> 23
}
func (o *ADC_Type) SetCR1_JAWDEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_Type) GetCR1_JAWDEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x400000) >> 22
}
func (o *ADC_Type) SetCR1_DISCNUM(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xe000)|value<<13)
}
func (o *ADC_Type) GetCR1_DISCNUM() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xe000) >> 13
}
func (o *ADC_Type) SetCR1_JDISCEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_Type) GetCR1_JDISCEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1000) >> 12
}
func (o *ADC_Type) SetCR1_DISCEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetCR1_DISCEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetCR1_JAUTO(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetCR1_JAUTO() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetCR1_AWDSGL(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetCR1_AWDSGL() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetCR1_SCAN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetCR1_SCAN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetCR1_JEOCIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetCR1_JEOCIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetCR1_AWDIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetCR1_AWDIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetCR1_EOCIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetCR1_EOCIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetCR1_AWDCH(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetCR1_AWDCH() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1f
}

// ADC.CR2: control register 2
func (o *ADC_Type) SetCR2_SWSTART(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetCR2_SWSTART() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40000000) >> 30
}
func (o *ADC_Type) SetCR2_EXTEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x30000000)|value<<28)
}
func (o *ADC_Type) GetCR2_EXTEN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x30000000) >> 28
}
func (o *ADC_Type) SetCR2_EXTSEL(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xf000000)|value<<24)
}
func (o *ADC_Type) GetCR2_EXTSEL() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xf000000) >> 24
}
func (o *ADC_Type) SetCR2_JSWSTART(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_Type) GetCR2_JSWSTART() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x400000) >> 22
}
func (o *ADC_Type) SetCR2_JEXTEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x300000)|value<<20)
}
func (o *ADC_Type) GetCR2_JEXTEN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x300000) >> 20
}
func (o *ADC_Type) SetCR2_JEXTSEL(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_Type) GetCR2_JEXTSEL() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xf0000) >> 16
}
func (o *ADC_Type) SetCR2_ALIGN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetCR2_ALIGN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetCR2_EOCS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetCR2_EOCS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetCR2_DDS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetCR2_DDS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetCR2_DMA(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetCR2_DMA() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetCR2_CONT(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetCR2_CONT() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetCR2_ADON(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetCR2_ADON() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x1
}

// ADC.SMPR1: sample time register 1
func (o *ADC_Type) SetSMPR1(value uint32) {
	volatile.StoreUint32(&o.SMPR1.Reg, value)
}
func (o *ADC_Type) GetSMPR1() uint32 {
	return volatile.LoadUint32(&o.SMPR1.Reg)
}

// ADC.SMPR2: sample time register 2
func (o *ADC_Type) SetSMPR2(value uint32) {
	volatile.StoreUint32(&o.SMPR2.Reg, value)
}
func (o *ADC_Type) GetSMPR2() uint32 {
	return volatile.LoadUint32(&o.SMPR2.Reg)
}

// ADC.JOFR1: injected channel data offset register x
func (o *ADC_Type) SetJOFR1_JOFFSET(value uint32) {
	volatile.StoreUint32(&o.JOFR1.Reg, volatile.LoadUint32(&o.JOFR1.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetJOFR1_JOFFSET() uint32 {
	return volatile.LoadUint32(&o.JOFR1.Reg) & 0xfff
}

// ADC.JOFR2: injected channel data offset register x
func (o *ADC_Type) SetJOFR2_JOFFSET(value uint32) {
	volatile.StoreUint32(&o.JOFR2.Reg, volatile.LoadUint32(&o.JOFR2.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetJOFR2_JOFFSET() uint32 {
	return volatile.LoadUint32(&o.JOFR2.Reg) & 0xfff
}

// ADC.JOFR3: injected channel data offset register x
func (o *ADC_Type) SetJOFR3_JOFFSET(value uint32) {
	volatile.StoreUint32(&o.JOFR3.Reg, volatile.LoadUint32(&o.JOFR3.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetJOFR3_JOFFSET() uint32 {
	return volatile.LoadUint32(&o.JOFR3.Reg) & 0xfff
}

// ADC.JOFR4: injected channel data offset register x
func (o *ADC_Type) SetJOFR4_JOFFSET(value uint32) {
	volatile.StoreUint32(&o.JOFR4.Reg, volatile.LoadUint32(&o.JOFR4.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetJOFR4_JOFFSET() uint32 {
	return volatile.LoadUint32(&o.JOFR4.Reg) & 0xfff
}

// ADC.HTR: watchdog higher threshold register
func (o *ADC_Type) SetHTR_HT(value uint32) {
	volatile.StoreUint32(&o.HTR.Reg, volatile.LoadUint32(&o.HTR.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetHTR_HT() uint32 {
	return volatile.LoadUint32(&o.HTR.Reg) & 0xfff
}

// ADC.LTR: watchdog lower threshold register
func (o *ADC_Type) SetLTR_LT(value uint32) {
	volatile.StoreUint32(&o.LTR.Reg, volatile.LoadUint32(&o.LTR.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetLTR_LT() uint32 {
	return volatile.LoadUint32(&o.LTR.Reg) & 0xfff
}

// ADC.SQR1: regular sequence register 1
func (o *ADC_Type) SetSQR1_L(value uint32) {
	volatile.StoreUint32(&o.SQR1.Reg, volatile.LoadUint32(&o.SQR1.Reg)&^(0xf00000)|value<<20)
}
func (o *ADC_Type) GetSQR1_L() uint32 {
	return (volatile.LoadUint32(&o.SQR1.Reg) & 0xf00000) >> 20
}
func (o *ADC_Type) SetSQR1_SQ16(value uint32) {
	volatile.StoreUint32(&o.SQR1.Reg, volatile.LoadUint32(&o.SQR1.Reg)&^(0xf8000)|value<<15)
}
func (o *ADC_Type) GetSQR1_SQ16() uint32 {
	return (volatile.LoadUint32(&o.SQR1.Reg) & 0xf8000) >> 15
}
func (o *ADC_Type) SetSQR1_SQ15(value uint32) {
	volatile.StoreUint32(&o.SQR1.Reg, volatile.LoadUint32(&o.SQR1.Reg)&^(0x7c00)|value<<10)
}
func (o *ADC_Type) GetSQR1_SQ15() uint32 {
	return (volatile.LoadUint32(&o.SQR1.Reg) & 0x7c00) >> 10
}
func (o *ADC_Type) SetSQR1_SQ14(value uint32) {
	volatile.StoreUint32(&o.SQR1.Reg, volatile.LoadUint32(&o.SQR1.Reg)&^(0x3e0)|value<<5)
}
func (o *ADC_Type) GetSQR1_SQ14() uint32 {
	return (volatile.LoadUint32(&o.SQR1.Reg) & 0x3e0) >> 5
}
func (o *ADC_Type) SetSQR1_SQ13(value uint32) {
	volatile.StoreUint32(&o.SQR1.Reg, volatile.LoadUint32(&o.SQR1.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetSQR1_SQ13() uint32 {
	return volatile.LoadUint32(&o.SQR1.Reg) & 0x1f
}

// ADC.SQR2: regular sequence register 2
func (o *ADC_Type) SetSQR2_SQ12(value uint32) {
	volatile.StoreUint32(&o.SQR2.Reg, volatile.LoadUint32(&o.SQR2.Reg)&^(0x3e000000)|value<<25)
}
func (o *ADC_Type) GetSQR2_SQ12() uint32 {
	return (volatile.LoadUint32(&o.SQR2.Reg) & 0x3e000000) >> 25
}
func (o *ADC_Type) SetSQR2_SQ11(value uint32) {
	volatile.StoreUint32(&o.SQR2.Reg, volatile.LoadUint32(&o.SQR2.Reg)&^(0x1f00000)|value<<20)
}
func (o *ADC_Type) GetSQR2_SQ11() uint32 {
	return (volatile.LoadUint32(&o.SQR2.Reg) & 0x1f00000) >> 20
}
func (o *ADC_Type) SetSQR2_SQ10(value uint32) {
	volatile.StoreUint32(&o.SQR2.Reg, volatile.LoadUint32(&o.SQR2.Reg)&^(0xf8000)|value<<15)
}
func (o *ADC_Type) GetSQR2_SQ10() uint32 {
	return (volatile.LoadUint32(&o.SQR2.Reg) & 0xf8000) >> 15
}
func (o *ADC_Type) SetSQR2_SQ9(value uint32) {
	volatile.StoreUint32(&o.SQR2.Reg, volatile.LoadUint32(&o.SQR2.Reg)&^(0x7c00)|value<<10)
}
func (o *ADC_Type) GetSQR2_SQ9() uint32 {
	return (volatile.LoadUint32(&o.SQR2.Reg) & 0x7c00) >> 10
}
func (o *ADC_Type) SetSQR2_SQ8(value uint32) {
	volatile.StoreUint32(&o.SQR2.Reg, volatile.LoadUint32(&o.SQR2.Reg)&^(0x3e0)|value<<5)
}
func (o *ADC_Type) GetSQR2_SQ8() uint32 {
	return (volatile.LoadUint32(&o.SQR2.Reg) & 0x3e0) >> 5
}
func (o *ADC_Type) SetSQR2_SQ7(value uint32) {
	volatile.StoreUint32(&o.SQR2.Reg, volatile.LoadUint32(&o.SQR2.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetSQR2_SQ7() uint32 {
	return volatile.LoadUint32(&o.SQR2.Reg) & 0x1f
}

// ADC.SQR3: regular sequence register 3
func (o *ADC_Type) SetSQR3_SQ6(value uint32) {
	volatile.StoreUint32(&o.SQR3.Reg, volatile.LoadUint32(&o.SQR3.Reg)&^(0x3e000000)|value<<25)
}
func (o *ADC_Type) GetSQR3_SQ6() uint32 {
	return (volatile.LoadUint32(&o.SQR3.Reg) & 0x3e000000) >> 25
}
func (o *ADC_Type) SetSQR3_SQ5(value uint32) {
	volatile.StoreUint32(&o.SQR3.Reg, volatile.LoadUint32(&o.SQR3.Reg)&^(0x1f00000)|value<<20)
}
func (o *ADC_Type) GetSQR3_SQ5() uint32 {
	return (volatile.LoadUint32(&o.SQR3.Reg) & 0x1f00000) >> 20
}
func (o *ADC_Type) SetSQR3_SQ4(value uint32) {
	volatile.StoreUint32(&o.SQR3.Reg, volatile.LoadUint32(&o.SQR3.Reg)&^(0xf8000)|value<<15)
}
func (o *ADC_Type) GetSQR3_SQ4() uint32 {
	return (volatile.LoadUint32(&o.SQR3.Reg) & 0xf8000) >> 15
}
func (o *ADC_Type) SetSQR3_SQ3(value uint32) {
	volatile.StoreUint32(&o.SQR3.Reg, volatile.LoadUint32(&o.SQR3.Reg)&^(0x7c00)|value<<10)
}
func (o *ADC_Type) GetSQR3_SQ3() uint32 {
	return (volatile.LoadUint32(&o.SQR3.Reg) & 0x7c00) >> 10
}
func (o *ADC_Type) SetSQR3_SQ2(value uint32) {
	volatile.StoreUint32(&o.SQR3.Reg, volatile.LoadUint32(&o.SQR3.Reg)&^(0x3e0)|value<<5)
}
func (o *ADC_Type) GetSQR3_SQ2() uint32 {
	return (volatile.LoadUint32(&o.SQR3.Reg) & 0x3e0) >> 5
}
func (o *ADC_Type) SetSQR3_SQ1(value uint32) {
	volatile.StoreUint32(&o.SQR3.Reg, volatile.LoadUint32(&o.SQR3.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetSQR3_SQ1() uint32 {
	return volatile.LoadUint32(&o.SQR3.Reg) & 0x1f
}

// ADC.JSQR: injected sequence register
func (o *ADC_Type) SetJSQR_JL(value uint32) {
	volatile.StoreUint32(&o.JSQR.Reg, volatile.LoadUint32(&o.JSQR.Reg)&^(0x300000)|value<<20)
}
func (o *ADC_Type) GetJSQR_JL() uint32 {
	return (volatile.LoadUint32(&o.JSQR.Reg) & 0x300000) >> 20
}
func (o *ADC_Type) SetJSQR_JSQ4(value uint32) {
	volatile.StoreUint32(&o.JSQR.Reg, volatile.LoadUint32(&o.JSQR.Reg)&^(0xf8000)|value<<15)
}
func (o *ADC_Type) GetJSQR_JSQ4() uint32 {
	return (volatile.LoadUint32(&o.JSQR.Reg) & 0xf8000) >> 15
}
func (o *ADC_Type) SetJSQR_JSQ3(value uint32) {
	volatile.StoreUint32(&o.JSQR.Reg, volatile.LoadUint32(&o.JSQR.Reg)&^(0x7c00)|value<<10)
}
func (o *ADC_Type) GetJSQR_JSQ3() uint32 {
	return (volatile.LoadUint32(&o.JSQR.Reg) & 0x7c00) >> 10
}
func (o *ADC_Type) SetJSQR_JSQ2(value uint32) {
	volatile.StoreUint32(&o.JSQR.Reg, volatile.LoadUint32(&o.JSQR.Reg)&^(0x3e0)|value<<5)
}
func (o *ADC_Type) GetJSQR_JSQ2() uint32 {
	return (volatile.LoadUint32(&o.JSQR.Reg) & 0x3e0) >> 5
}
func (o *ADC_Type) SetJSQR_JSQ1(value uint32) {
	volatile.StoreUint32(&o.JSQR.Reg, volatile.LoadUint32(&o.JSQR.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetJSQR_JSQ1() uint32 {
	return volatile.LoadUint32(&o.JSQR.Reg) & 0x1f
}

// ADC.JDR1: injected data register x
func (o *ADC_Type) SetJDR1_JDATA(value uint32) {
	volatile.StoreUint32(&o.JDR1.Reg, volatile.LoadUint32(&o.JDR1.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetJDR1_JDATA() uint32 {
	return volatile.LoadUint32(&o.JDR1.Reg) & 0xffff
}

// ADC.JDR2: injected data register x
func (o *ADC_Type) SetJDR2_JDATA(value uint32) {
	volatile.StoreUint32(&o.JDR2.Reg, volatile.LoadUint32(&o.JDR2.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetJDR2_JDATA() uint32 {
	return volatile.LoadUint32(&o.JDR2.Reg) & 0xffff
}

// ADC.JDR3: injected data register x
func (o *ADC_Type) SetJDR3_JDATA(value uint32) {
	volatile.StoreUint32(&o.JDR3.Reg, volatile.LoadUint32(&o.JDR3.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetJDR3_JDATA() uint32 {
	return volatile.LoadUint32(&o.JDR3.Reg) & 0xffff
}

// ADC.JDR4: injected data register x
func (o *ADC_Type) SetJDR4_JDATA(value uint32) {
	volatile.StoreUint32(&o.JDR4.Reg, volatile.LoadUint32(&o.JDR4.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetJDR4_JDATA() uint32 {
	return volatile.LoadUint32(&o.JDR4.Reg) & 0xffff
}

// ADC.DR: regular data register
func (o *ADC_Type) SetDR_DATA(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xffff)|value)
}
func (o *ADC_Type) GetDR_DATA() uint32 {
	return volatile.LoadUint32(&o.DR.Reg) & 0xffff
}

// Digital-to-analog converter
type DAC_Type struct {
	CR      volatile.Register32 // 0x0
	SWTRIGR volatile.Register32 // 0x4
	DHR12R1 volatile.Register32 // 0x8
	DHR12L1 volatile.Register32 // 0xC
	DHR8R1  volatile.Register32 // 0x10
	DHR12R2 volatile.Register32 // 0x14
	DHR12L2 volatile.Register32 // 0x18
	DHR8R2  volatile.Register32 // 0x1C
	DHR12RD volatile.Register32 // 0x20
	DHR12LD volatile.Register32 // 0x24
	DHR8RD  volatile.Register32 // 0x28
	DOR1    volatile.Register32 // 0x2C
	DOR2    volatile.Register32 // 0x30
	SR      volatile.Register32 // 0x34
}

// DAC.CR: control register
func (o *DAC_Type) SetCR_DMAUDRIE2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000000)|value<<29)
}
func (o *DAC_Type) GetCR_DMAUDRIE2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000000) >> 29
}
func (o *DAC_Type) SetCR_DMAEN2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000000)|value<<28)
}
func (o *DAC_Type) GetCR_DMAEN2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000000) >> 28
}
func (o *DAC_Type) SetCR_MAMP2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf000000)|value<<24)
}
func (o *DAC_Type) GetCR_MAMP2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf000000) >> 24
}
func (o *DAC_Type) SetCR_WAVE2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc00000)|value<<22)
}
func (o *DAC_Type) GetCR_WAVE2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc00000) >> 22
}
func (o *DAC_Type) SetCR_TSEL2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x380000)|value<<19)
}
func (o *DAC_Type) GetCR_TSEL2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x380000) >> 19
}
func (o *DAC_Type) SetCR_TEN2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *DAC_Type) GetCR_TEN2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *DAC_Type) SetCR_BOFF2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *DAC_Type) GetCR_BOFF2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *DAC_Type) SetCR_EN2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *DAC_Type) GetCR_EN2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *DAC_Type) SetCR_DMAUDRIE1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *DAC_Type) GetCR_DMAUDRIE1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *DAC_Type) SetCR_DMAEN1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *DAC_Type) GetCR_DMAEN1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *DAC_Type) SetCR_MAMP1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf00)|value<<8)
}
func (o *DAC_Type) GetCR_MAMP1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf00) >> 8
}
func (o *DAC_Type) SetCR_WAVE1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc0)|value<<6)
}
func (o *DAC_Type) GetCR_WAVE1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc0) >> 6
}
func (o *DAC_Type) SetCR_TSEL1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x38)|value<<3)
}
func (o *DAC_Type) GetCR_TSEL1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x38) >> 3
}
func (o *DAC_Type) SetCR_TEN1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *DAC_Type) GetCR_TEN1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *DAC_Type) SetCR_BOFF1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetCR_BOFF1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *DAC_Type) SetCR_EN1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetCR_EN1() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// DAC.SWTRIGR: software trigger register
func (o *DAC_Type) SetSWTRIGR_SWTRIG2(value uint32) {
	volatile.StoreUint32(&o.SWTRIGR.Reg, volatile.LoadUint32(&o.SWTRIGR.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetSWTRIGR_SWTRIG2() uint32 {
	return (volatile.LoadUint32(&o.SWTRIGR.Reg) & 0x2) >> 1
}
func (o *DAC_Type) SetSWTRIGR_SWTRIG1(value uint32) {
	volatile.StoreUint32(&o.SWTRIGR.Reg, volatile.LoadUint32(&o.SWTRIGR.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetSWTRIGR_SWTRIG1() uint32 {
	return volatile.LoadUint32(&o.SWTRIGR.Reg) & 0x1
}

// DAC.DHR12R1: channel1 12-bit right-aligned data holding register
func (o *DAC_Type) SetDHR12R1_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12R1.Reg, volatile.LoadUint32(&o.DHR12R1.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDHR12R1_DACC1DHR() uint32 {
	return volatile.LoadUint32(&o.DHR12R1.Reg) & 0xfff
}

// DAC.DHR12L1: channel1 12-bit left aligned data holding register
func (o *DAC_Type) SetDHR12L1_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12L1.Reg, volatile.LoadUint32(&o.DHR12L1.Reg)&^(0xfff0)|value<<4)
}
func (o *DAC_Type) GetDHR12L1_DACC1DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR12L1.Reg) & 0xfff0) >> 4
}

// DAC.DHR8R1: channel1 8-bit right aligned data holding register
func (o *DAC_Type) SetDHR8R1_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR8R1.Reg, volatile.LoadUint32(&o.DHR8R1.Reg)&^(0xff)|value)
}
func (o *DAC_Type) GetDHR8R1_DACC1DHR() uint32 {
	return volatile.LoadUint32(&o.DHR8R1.Reg) & 0xff
}

// DAC.DHR12R2: channel2 12-bit right aligned data holding register
func (o *DAC_Type) SetDHR12R2_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12R2.Reg, volatile.LoadUint32(&o.DHR12R2.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDHR12R2_DACC2DHR() uint32 {
	return volatile.LoadUint32(&o.DHR12R2.Reg) & 0xfff
}

// DAC.DHR12L2: channel2 12-bit left aligned data holding register
func (o *DAC_Type) SetDHR12L2_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12L2.Reg, volatile.LoadUint32(&o.DHR12L2.Reg)&^(0xfff0)|value<<4)
}
func (o *DAC_Type) GetDHR12L2_DACC2DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR12L2.Reg) & 0xfff0) >> 4
}

// DAC.DHR8R2: channel2 8-bit right-aligned data holding register
func (o *DAC_Type) SetDHR8R2_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR8R2.Reg, volatile.LoadUint32(&o.DHR8R2.Reg)&^(0xff)|value)
}
func (o *DAC_Type) GetDHR8R2_DACC2DHR() uint32 {
	return volatile.LoadUint32(&o.DHR8R2.Reg) & 0xff
}

// DAC.DHR12RD: Dual DAC 12-bit right-aligned data holding register
func (o *DAC_Type) SetDHR12RD_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12RD.Reg, volatile.LoadUint32(&o.DHR12RD.Reg)&^(0xfff0000)|value<<16)
}
func (o *DAC_Type) GetDHR12RD_DACC2DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR12RD.Reg) & 0xfff0000) >> 16
}
func (o *DAC_Type) SetDHR12RD_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12RD.Reg, volatile.LoadUint32(&o.DHR12RD.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDHR12RD_DACC1DHR() uint32 {
	return volatile.LoadUint32(&o.DHR12RD.Reg) & 0xfff
}

// DAC.DHR12LD: DUAL DAC 12-bit left aligned data holding register
func (o *DAC_Type) SetDHR12LD_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12LD.Reg, volatile.LoadUint32(&o.DHR12LD.Reg)&^(0xfff00000)|value<<20)
}
func (o *DAC_Type) GetDHR12LD_DACC2DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR12LD.Reg) & 0xfff00000) >> 20
}
func (o *DAC_Type) SetDHR12LD_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR12LD.Reg, volatile.LoadUint32(&o.DHR12LD.Reg)&^(0xfff0)|value<<4)
}
func (o *DAC_Type) GetDHR12LD_DACC1DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR12LD.Reg) & 0xfff0) >> 4
}

// DAC.DHR8RD: DUAL DAC 8-bit right aligned data holding register
func (o *DAC_Type) SetDHR8RD_DACC2DHR(value uint32) {
	volatile.StoreUint32(&o.DHR8RD.Reg, volatile.LoadUint32(&o.DHR8RD.Reg)&^(0xff00)|value<<8)
}
func (o *DAC_Type) GetDHR8RD_DACC2DHR() uint32 {
	return (volatile.LoadUint32(&o.DHR8RD.Reg) & 0xff00) >> 8
}
func (o *DAC_Type) SetDHR8RD_DACC1DHR(value uint32) {
	volatile.StoreUint32(&o.DHR8RD.Reg, volatile.LoadUint32(&o.DHR8RD.Reg)&^(0xff)|value)
}
func (o *DAC_Type) GetDHR8RD_DACC1DHR() uint32 {
	return volatile.LoadUint32(&o.DHR8RD.Reg) & 0xff
}

// DAC.DOR1: channel1 data output register
func (o *DAC_Type) SetDOR1_DACC1DOR(value uint32) {
	volatile.StoreUint32(&o.DOR1.Reg, volatile.LoadUint32(&o.DOR1.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDOR1_DACC1DOR() uint32 {
	return volatile.LoadUint32(&o.DOR1.Reg) & 0xfff
}

// DAC.DOR2: channel2 data output register
func (o *DAC_Type) SetDOR2_DACC2DOR(value uint32) {
	volatile.StoreUint32(&o.DOR2.Reg, volatile.LoadUint32(&o.DOR2.Reg)&^(0xfff)|value)
}
func (o *DAC_Type) GetDOR2_DACC2DOR() uint32 {
	return volatile.LoadUint32(&o.DOR2.Reg) & 0xfff
}

// DAC.SR: status register
func (o *DAC_Type) SetSR_DMAUDR2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000000)|value<<29)
}
func (o *DAC_Type) GetSR_DMAUDR2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000000) >> 29
}
func (o *DAC_Type) SetSR_DMAUDR1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000)|value<<13)
}
func (o *DAC_Type) GetSR_DMAUDR1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000) >> 13
}

// Power control
type PWR_Type struct {
	CR1  volatile.Register32 // 0x0
	CSR1 volatile.Register32 // 0x4
	CR2  volatile.Register32 // 0x8
	CSR2 volatile.Register32 // 0xC
}

// PWR.CR1: power control register
func (o *PWR_Type) SetCR1_LPDS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetCR1_LPDS() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}
func (o *PWR_Type) SetCR1_PDDS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetCR1_PDDS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetCR1_CSBF(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetCR1_CSBF() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetCR1_PVDE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetCR1_PVDE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetCR1_PLS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xe0)|value<<5)
}
func (o *PWR_Type) GetCR1_PLS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xe0) >> 5
}
func (o *PWR_Type) SetCR1_DBP(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetCR1_DBP() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetCR1_FPDS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetCR1_FPDS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetCR1_LPUDS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetCR1_LPUDS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetCR1_MRUDS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetCR1_MRUDS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetCR1_ADCDC1(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetCR1_ADCDC1() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2000) >> 13
}
func (o *PWR_Type) SetCR1_VOS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xc000)|value<<14)
}
func (o *PWR_Type) GetCR1_VOS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xc000) >> 14
}
func (o *PWR_Type) SetCR1_ODEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10000)|value<<16)
}
func (o *PWR_Type) GetCR1_ODEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10000) >> 16
}
func (o *PWR_Type) SetCR1_ODSWEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20000)|value<<17)
}
func (o *PWR_Type) GetCR1_ODSWEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20000) >> 17
}
func (o *PWR_Type) SetCR1_UDEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xc0000)|value<<18)
}
func (o *PWR_Type) GetCR1_UDEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xc0000) >> 18
}

// PWR.CSR1: power control/status register
func (o *PWR_Type) SetCSR1_WUIF(value uint32) {
	volatile.StoreUint32(&o.CSR1.Reg, volatile.LoadUint32(&o.CSR1.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetCSR1_WUIF() uint32 {
	return volatile.LoadUint32(&o.CSR1.Reg) & 0x1
}
func (o *PWR_Type) SetCSR1_SBF(value uint32) {
	volatile.StoreUint32(&o.CSR1.Reg, volatile.LoadUint32(&o.CSR1.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetCSR1_SBF() uint32 {
	return (volatile.LoadUint32(&o.CSR1.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetCSR1_PVDO(value uint32) {
	volatile.StoreUint32(&o.CSR1.Reg, volatile.LoadUint32(&o.CSR1.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetCSR1_PVDO() uint32 {
	return (volatile.LoadUint32(&o.CSR1.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetCSR1_BRR(value uint32) {
	volatile.StoreUint32(&o.CSR1.Reg, volatile.LoadUint32(&o.CSR1.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetCSR1_BRR() uint32 {
	return (volatile.LoadUint32(&o.CSR1.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetCSR1_BRE(value uint32) {
	volatile.StoreUint32(&o.CSR1.Reg, volatile.LoadUint32(&o.CSR1.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetCSR1_BRE() uint32 {
	return (volatile.LoadUint32(&o.CSR1.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetCSR1_VOSRDY(value uint32) {
	volatile.StoreUint32(&o.CSR1.Reg, volatile.LoadUint32(&o.CSR1.Reg)&^(0x4000)|value<<14)
}
func (o *PWR_Type) GetCSR1_VOSRDY() uint32 {
	return (volatile.LoadUint32(&o.CSR1.Reg) & 0x4000) >> 14
}
func (o *PWR_Type) SetCSR1_ODRDY(value uint32) {
	volatile.StoreUint32(&o.CSR1.Reg, volatile.LoadUint32(&o.CSR1.Reg)&^(0x10000)|value<<16)
}
func (o *PWR_Type) GetCSR1_ODRDY() uint32 {
	return (volatile.LoadUint32(&o.CSR1.Reg) & 0x10000) >> 16
}
func (o *PWR_Type) SetCSR1_ODSWRDY(value uint32) {
	volatile.StoreUint32(&o.CSR1.Reg, volatile.LoadUint32(&o.CSR1.Reg)&^(0x20000)|value<<17)
}
func (o *PWR_Type) GetCSR1_ODSWRDY() uint32 {
	return (volatile.LoadUint32(&o.CSR1.Reg) & 0x20000) >> 17
}
func (o *PWR_Type) SetCSR1_UDRDY(value uint32) {
	volatile.StoreUint32(&o.CSR1.Reg, volatile.LoadUint32(&o.CSR1.Reg)&^(0xc0000)|value<<18)
}
func (o *PWR_Type) GetCSR1_UDRDY() uint32 {
	return (volatile.LoadUint32(&o.CSR1.Reg) & 0xc0000) >> 18
}

// PWR.CR2: power control register
func (o *PWR_Type) SetCR2_CWUPF1(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetCR2_CWUPF1() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x1
}
func (o *PWR_Type) SetCR2_CWUPF2(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetCR2_CWUPF2() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetCR2_CWUPF3(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetCR2_CWUPF3() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetCR2_CWUPF4(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetCR2_CWUPF4() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetCR2_CWUPF5(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetCR2_CWUPF5() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetCR2_CWUPF6(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetCR2_CWUPF6() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetCR2_WUPP1(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetCR2_WUPP1() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetCR2_WUPP2(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetCR2_WUPP2() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetCR2_WUPP3(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetCR2_WUPP3() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetCR2_WUPP4(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetCR2_WUPP4() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetCR2_WUPP5(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetCR2_WUPP5() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetCR2_WUPP6(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetCR2_WUPP6() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000) >> 13
}

// PWR.CSR2: power control/status register
func (o *PWR_Type) SetCSR2_WUPF1(value uint32) {
	volatile.StoreUint32(&o.CSR2.Reg, volatile.LoadUint32(&o.CSR2.Reg)&^(0x1)|value)
}
func (o *PWR_Type) GetCSR2_WUPF1() uint32 {
	return volatile.LoadUint32(&o.CSR2.Reg) & 0x1
}
func (o *PWR_Type) SetCSR2_WUPF2(value uint32) {
	volatile.StoreUint32(&o.CSR2.Reg, volatile.LoadUint32(&o.CSR2.Reg)&^(0x2)|value<<1)
}
func (o *PWR_Type) GetCSR2_WUPF2() uint32 {
	return (volatile.LoadUint32(&o.CSR2.Reg) & 0x2) >> 1
}
func (o *PWR_Type) SetCSR2_WUPF3(value uint32) {
	volatile.StoreUint32(&o.CSR2.Reg, volatile.LoadUint32(&o.CSR2.Reg)&^(0x4)|value<<2)
}
func (o *PWR_Type) GetCSR2_WUPF3() uint32 {
	return (volatile.LoadUint32(&o.CSR2.Reg) & 0x4) >> 2
}
func (o *PWR_Type) SetCSR2_WUPF4(value uint32) {
	volatile.StoreUint32(&o.CSR2.Reg, volatile.LoadUint32(&o.CSR2.Reg)&^(0x8)|value<<3)
}
func (o *PWR_Type) GetCSR2_WUPF4() uint32 {
	return (volatile.LoadUint32(&o.CSR2.Reg) & 0x8) >> 3
}
func (o *PWR_Type) SetCSR2_WUPF5(value uint32) {
	volatile.StoreUint32(&o.CSR2.Reg, volatile.LoadUint32(&o.CSR2.Reg)&^(0x10)|value<<4)
}
func (o *PWR_Type) GetCSR2_WUPF5() uint32 {
	return (volatile.LoadUint32(&o.CSR2.Reg) & 0x10) >> 4
}
func (o *PWR_Type) SetCSR2_WUPF6(value uint32) {
	volatile.StoreUint32(&o.CSR2.Reg, volatile.LoadUint32(&o.CSR2.Reg)&^(0x20)|value<<5)
}
func (o *PWR_Type) GetCSR2_WUPF6() uint32 {
	return (volatile.LoadUint32(&o.CSR2.Reg) & 0x20) >> 5
}
func (o *PWR_Type) SetCSR2_EWUP1(value uint32) {
	volatile.StoreUint32(&o.CSR2.Reg, volatile.LoadUint32(&o.CSR2.Reg)&^(0x100)|value<<8)
}
func (o *PWR_Type) GetCSR2_EWUP1() uint32 {
	return (volatile.LoadUint32(&o.CSR2.Reg) & 0x100) >> 8
}
func (o *PWR_Type) SetCSR2_EWUP2(value uint32) {
	volatile.StoreUint32(&o.CSR2.Reg, volatile.LoadUint32(&o.CSR2.Reg)&^(0x200)|value<<9)
}
func (o *PWR_Type) GetCSR2_EWUP2() uint32 {
	return (volatile.LoadUint32(&o.CSR2.Reg) & 0x200) >> 9
}
func (o *PWR_Type) SetCSR2_EWUP3(value uint32) {
	volatile.StoreUint32(&o.CSR2.Reg, volatile.LoadUint32(&o.CSR2.Reg)&^(0x400)|value<<10)
}
func (o *PWR_Type) GetCSR2_EWUP3() uint32 {
	return (volatile.LoadUint32(&o.CSR2.Reg) & 0x400) >> 10
}
func (o *PWR_Type) SetCSR2_EWUP4(value uint32) {
	volatile.StoreUint32(&o.CSR2.Reg, volatile.LoadUint32(&o.CSR2.Reg)&^(0x800)|value<<11)
}
func (o *PWR_Type) GetCSR2_EWUP4() uint32 {
	return (volatile.LoadUint32(&o.CSR2.Reg) & 0x800) >> 11
}
func (o *PWR_Type) SetCSR2_EWUP5(value uint32) {
	volatile.StoreUint32(&o.CSR2.Reg, volatile.LoadUint32(&o.CSR2.Reg)&^(0x1000)|value<<12)
}
func (o *PWR_Type) GetCSR2_EWUP5() uint32 {
	return (volatile.LoadUint32(&o.CSR2.Reg) & 0x1000) >> 12
}
func (o *PWR_Type) SetCSR2_EWUP6(value uint32) {
	volatile.StoreUint32(&o.CSR2.Reg, volatile.LoadUint32(&o.CSR2.Reg)&^(0x2000)|value<<13)
}
func (o *PWR_Type) GetCSR2_EWUP6() uint32 {
	return (volatile.LoadUint32(&o.CSR2.Reg) & 0x2000) >> 13
}

// Independent watchdog
type IWDG_Type struct {
	KR   volatile.Register32 // 0x0
	PR   volatile.Register32 // 0x4
	RLR  volatile.Register32 // 0x8
	SR   volatile.Register32 // 0xC
	WINR volatile.Register32 // 0x10
}

// IWDG.KR: Key register
func (o *IWDG_Type) SetKR_KEY(value uint32) {
	volatile.StoreUint32(&o.KR.Reg, volatile.LoadUint32(&o.KR.Reg)&^(0xffff)|value)
}
func (o *IWDG_Type) GetKR_KEY() uint32 {
	return volatile.LoadUint32(&o.KR.Reg) & 0xffff
}

// IWDG.PR: Prescaler register
func (o *IWDG_Type) SetPR(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x7)|value)
}
func (o *IWDG_Type) GetPR() uint32 {
	return volatile.LoadUint32(&o.PR.Reg) & 0x7
}

// IWDG.RLR: Reload register
func (o *IWDG_Type) SetRLR_RL(value uint32) {
	volatile.StoreUint32(&o.RLR.Reg, volatile.LoadUint32(&o.RLR.Reg)&^(0xfff)|value)
}
func (o *IWDG_Type) GetRLR_RL() uint32 {
	return volatile.LoadUint32(&o.RLR.Reg) & 0xfff
}

// IWDG.SR: Status register
func (o *IWDG_Type) SetSR_RVU(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *IWDG_Type) GetSR_RVU() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *IWDG_Type) SetSR_PVU(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *IWDG_Type) GetSR_PVU() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// IWDG.WINR: Window register
func (o *IWDG_Type) SetWINR_WIN(value uint32) {
	volatile.StoreUint32(&o.WINR.Reg, volatile.LoadUint32(&o.WINR.Reg)&^(0xfff)|value)
}
func (o *IWDG_Type) GetWINR_WIN() uint32 {
	return volatile.LoadUint32(&o.WINR.Reg) & 0xfff
}

// Window watchdog
type WWDG_Type struct {
	CR  volatile.Register32 // 0x0
	CFR volatile.Register32 // 0x4
	SR  volatile.Register32 // 0x8
}

// WWDG.CR: Control register
func (o *WWDG_Type) SetCR_WDGA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *WWDG_Type) GetCR_WDGA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *WWDG_Type) SetCR_T(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x7f)|value)
}
func (o *WWDG_Type) GetCR_T() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x7f
}

// WWDG.CFR: Configuration register
func (o *WWDG_Type) SetCFR_EWI(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x200)|value<<9)
}
func (o *WWDG_Type) GetCFR_EWI() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x200) >> 9
}
func (o *WWDG_Type) SetCFR_W(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x7f)|value)
}
func (o *WWDG_Type) GetCFR_W() uint32 {
	return volatile.LoadUint32(&o.CFR.Reg) & 0x7f
}
func (o *WWDG_Type) SetCFR_WDGTB(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x180)|value<<7)
}
func (o *WWDG_Type) GetCFR_WDGTB() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x180) >> 7
}

// WWDG.SR: Status register
func (o *WWDG_Type) SetSR_EWIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *WWDG_Type) GetSR_EWIF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// Advanced-timers
type TIM_Type struct {
	CR1          volatile.Register32 // 0x0
	CR2          volatile.Register32 // 0x4
	SMCR         volatile.Register32 // 0x8
	DIER         volatile.Register32 // 0xC
	SR           volatile.Register32 // 0x10
	EGR          volatile.Register32 // 0x14
	CCMR1_Output volatile.Register32 // 0x18
	CCMR2_Output volatile.Register32 // 0x1C
	CCER         volatile.Register32 // 0x20
	CNT          volatile.Register32 // 0x24
	PSC          volatile.Register32 // 0x28
	ARR          volatile.Register32 // 0x2C
	RCR          volatile.Register32 // 0x30
	CCR1         volatile.Register32 // 0x34
	CCR2         volatile.Register32 // 0x38
	CCR3         volatile.Register32 // 0x3C
	CCR4         volatile.Register32 // 0x40
	BDTR         volatile.Register32 // 0x44
	DCR          volatile.Register32 // 0x48
	DMAR         volatile.Register32 // 0x4C
	_            [4]byte
	CCMR3_Output volatile.Register32 // 0x54
	CCR5         volatile.Register32 // 0x58
	CCR6         volatile.Register32 // 0x5C
	AF1          volatile.Register32 // 0x60
	AF2          volatile.Register32 // 0x64
}

// TIM.CR1: control register 1
func (o *TIM_Type) SetCR1_CKD(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x300)|value<<8)
}
func (o *TIM_Type) GetCR1_CKD() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x300) >> 8
}
func (o *TIM_Type) SetCR1_ARPE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCR1_ARPE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCR1_CMS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x60)|value<<5)
}
func (o *TIM_Type) GetCR1_CMS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x60) >> 5
}
func (o *TIM_Type) SetCR1_DIR(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetCR1_DIR() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetCR1_OPM(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCR1_OPM() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCR1_URS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCR1_URS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCR1_UDIS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetCR1_UDIS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetCR1_CEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetCR1_CEN() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}
func (o *TIM_Type) SetCR1_UIFREMAP(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCR1_UIFREMAP() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800) >> 11
}

// TIM.CR2: control register 2
func (o *TIM_Type) SetCR2_OIS4(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4000)|value<<14)
}
func (o *TIM_Type) GetCR2_OIS4() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4000) >> 14
}
func (o *TIM_Type) SetCR2_OIS3N(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000)|value<<13)
}
func (o *TIM_Type) GetCR2_OIS3N() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000) >> 13
}
func (o *TIM_Type) SetCR2_OIS3(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetCR2_OIS3() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetCR2_OIS2N(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCR2_OIS2N() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCR2_OIS2(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetCR2_OIS2() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetCR2_OIS1N(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetCR2_OIS1N() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetCR2_OIS1(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetCR2_OIS1() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetCR2_TI1S(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCR2_TI1S() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCR2_MMS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetCR2_MMS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetCR2_CCDS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCR2_CCDS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCR2_CCUS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCR2_CCUS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCR2_CCPC(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetCR2_CCPC() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x1
}
func (o *TIM_Type) SetCR2_OIS5(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetCR2_OIS5() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10000) >> 16
}
func (o *TIM_Type) SetCR2_OIS6(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40000)|value<<18)
}
func (o *TIM_Type) GetCR2_OIS6() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40000) >> 18
}
func (o *TIM_Type) SetCR2_MMS2(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xf00000)|value<<20)
}
func (o *TIM_Type) GetCR2_MMS2() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xf00000) >> 20
}

// TIM.SMCR: slave mode control register
func (o *TIM_Type) SetSMCR_ETP(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetSMCR_ETP() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetSMCR_ECE(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x4000)|value<<14)
}
func (o *TIM_Type) GetSMCR_ECE() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x4000) >> 14
}
func (o *TIM_Type) SetSMCR_ETPS(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x3000)|value<<12)
}
func (o *TIM_Type) GetSMCR_ETPS() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x3000) >> 12
}
func (o *TIM_Type) SetSMCR_ETF(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0xf00)|value<<8)
}
func (o *TIM_Type) GetSMCR_ETF() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0xf00) >> 8
}
func (o *TIM_Type) SetSMCR_MSM(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetSMCR_MSM() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetSMCR_TS(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetSMCR_TS() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetSMCR_SMS(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x7)|value)
}
func (o *TIM_Type) GetSMCR_SMS() uint32 {
	return volatile.LoadUint32(&o.SMCR.Reg) & 0x7
}
func (o *TIM_Type) SetSMCR_SMS_3(value uint32) {
	volatile.StoreUint32(&o.SMCR.Reg, volatile.LoadUint32(&o.SMCR.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetSMCR_SMS_3() uint32 {
	return (volatile.LoadUint32(&o.SMCR.Reg) & 0x10000) >> 16
}

// TIM.DIER: DMA/Interrupt enable register
func (o *TIM_Type) SetDIER_TDE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x4000)|value<<14)
}
func (o *TIM_Type) GetDIER_TDE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x4000) >> 14
}
func (o *TIM_Type) SetDIER_COMDE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x2000)|value<<13)
}
func (o *TIM_Type) GetDIER_COMDE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x2000) >> 13
}
func (o *TIM_Type) SetDIER_CC4DE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetDIER_CC4DE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetDIER_CC3DE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetDIER_CC3DE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetDIER_CC2DE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetDIER_CC2DE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetDIER_CC1DE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetDIER_CC1DE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetDIER_UDE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetDIER_UDE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetDIER_TIE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x40)|value<<6)
}
func (o *TIM_Type) GetDIER_TIE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x40) >> 6
}
func (o *TIM_Type) SetDIER_CC4IE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetDIER_CC4IE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetDIER_CC3IE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetDIER_CC3IE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetDIER_CC2IE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetDIER_CC2IE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetDIER_CC1IE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetDIER_CC1IE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetDIER_UIE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetDIER_UIE() uint32 {
	return volatile.LoadUint32(&o.DIER.Reg) & 0x1
}
func (o *TIM_Type) SetDIER_BIE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetDIER_BIE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetDIER_COMIE(value uint32) {
	volatile.StoreUint32(&o.DIER.Reg, volatile.LoadUint32(&o.DIER.Reg)&^(0x20)|value<<5)
}
func (o *TIM_Type) GetDIER_COMIE() uint32 {
	return (volatile.LoadUint32(&o.DIER.Reg) & 0x20) >> 5
}

// TIM.SR: status register
func (o *TIM_Type) SetSR_CC4OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetSR_CC4OF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetSR_CC3OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetSR_CC3OF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetSR_CC2OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetSR_CC2OF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetSR_CC1OF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetSR_CC1OF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetSR_BIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetSR_BIF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetSR_TIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *TIM_Type) GetSR_TIF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *TIM_Type) SetSR_COMIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *TIM_Type) GetSR_COMIF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *TIM_Type) SetSR_CC4IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetSR_CC4IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetSR_CC3IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetSR_CC3IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetSR_CC2IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetSR_CC2IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetSR_CC1IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetSR_CC1IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetSR_UIF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetSR_UIF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *TIM_Type) SetSR_B2IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetSR_B2IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetSR_CC5IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetSR_CC5IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *TIM_Type) SetSR_CC6IF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *TIM_Type) GetSR_CC6IF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}

// TIM.EGR: event generation register
func (o *TIM_Type) SetEGR_BG(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetEGR_BG() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetEGR_TG(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x40)|value<<6)
}
func (o *TIM_Type) GetEGR_TG() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x40) >> 6
}
func (o *TIM_Type) SetEGR_COMG(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x20)|value<<5)
}
func (o *TIM_Type) GetEGR_COMG() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x20) >> 5
}
func (o *TIM_Type) SetEGR_CC4G(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetEGR_CC4G() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetEGR_CC3G(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetEGR_CC3G() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetEGR_CC2G(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetEGR_CC2G() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetEGR_CC1G(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetEGR_CC1G() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetEGR_UG(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetEGR_UG() uint32 {
	return volatile.LoadUint32(&o.EGR.Reg) & 0x1
}
func (o *TIM_Type) SetEGR_B2G(value uint32) {
	volatile.StoreUint32(&o.EGR.Reg, volatile.LoadUint32(&o.EGR.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetEGR_B2G() uint32 {
	return (volatile.LoadUint32(&o.EGR.Reg) & 0x100) >> 8
}

// TIM.CCMR1_Output: capture/compare mode register 1 (output mode)
func (o *TIM_Type) SetCCMR1_Output_OC2CE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetCCMR1_Output_OC2CE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetCCMR1_Output_OC2M(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x7000)|value<<12)
}
func (o *TIM_Type) GetCCMR1_Output_OC2M() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x7000) >> 12
}
func (o *TIM_Type) SetCCMR1_Output_OC2PE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCCMR1_Output_OC2PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCCMR1_Output_OC2FE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetCCMR1_Output_OC2FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetCCMR1_Output_CC2S(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x300)|value<<8)
}
func (o *TIM_Type) GetCCMR1_Output_CC2S() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x300) >> 8
}
func (o *TIM_Type) SetCCMR1_Output_OC1CE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCCMR1_Output_OC1CE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCCMR1_Output_OC1M(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetCCMR1_Output_OC1M() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetCCMR1_Output_OC1PE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCCMR1_Output_OC1PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCCMR1_Output_OC1FE(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCCMR1_Output_OC1FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCCMR1_Output_CC1S(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x3)|value)
}
func (o *TIM_Type) GetCCMR1_Output_CC1S() uint32 {
	return volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x3
}
func (o *TIM_Type) SetCCMR1_Output_OC2M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x1000000)|value<<24)
}
func (o *TIM_Type) GetCCMR1_Output_OC2M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x1000000) >> 24
}
func (o *TIM_Type) SetCCMR1_Output_OC1M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR1_Output.Reg, volatile.LoadUint32(&o.CCMR1_Output.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetCCMR1_Output_OC1M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR1_Output.Reg) & 0x10000) >> 16
}

// TIM.CCMR2_Output: capture/compare mode register 2 (output mode)
func (o *TIM_Type) SetCCMR2_Output_OC4CE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetCCMR2_Output_OC4CE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetCCMR2_Output_OC4M(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x7000)|value<<12)
}
func (o *TIM_Type) GetCCMR2_Output_OC4M() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x7000) >> 12
}
func (o *TIM_Type) SetCCMR2_Output_OC4PE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCCMR2_Output_OC4PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCCMR2_Output_OC4FE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetCCMR2_Output_OC4FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetCCMR2_Output_CC4S(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x300)|value<<8)
}
func (o *TIM_Type) GetCCMR2_Output_CC4S() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x300) >> 8
}
func (o *TIM_Type) SetCCMR2_Output_OC3CE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCCMR2_Output_OC3CE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCCMR2_Output_OC3M(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetCCMR2_Output_OC3M() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetCCMR2_Output_OC3PE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCCMR2_Output_OC3PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCCMR2_Output_OC3FE(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCCMR2_Output_OC3FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCCMR2_Output_CC3S(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x3)|value)
}
func (o *TIM_Type) GetCCMR2_Output_CC3S() uint32 {
	return volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x3
}
func (o *TIM_Type) SetCCMR2_Output_OC3M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetCCMR2_Output_OC3M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x10000) >> 16
}
func (o *TIM_Type) SetCCMR2_Output_OC4M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR2_Output.Reg, volatile.LoadUint32(&o.CCMR2_Output.Reg)&^(0x1000000)|value<<24)
}
func (o *TIM_Type) GetCCMR2_Output_OC4M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR2_Output.Reg) & 0x1000000) >> 24
}

// TIM.CCER: capture/compare enable register
func (o *TIM_Type) SetCCER_CC4P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x2000)|value<<13)
}
func (o *TIM_Type) GetCCER_CC4P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x2000) >> 13
}
func (o *TIM_Type) SetCCER_CC4E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetCCER_CC4E() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetCCER_CC3NP(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCCER_CC3NP() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCCER_CC3NE(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetCCER_CC3NE() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetCCER_CC3P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetCCER_CC3P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x200) >> 9
}
func (o *TIM_Type) SetCCER_CC3E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetCCER_CC3E() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetCCER_CC2NP(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCCER_CC2NP() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCCER_CC2NE(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x40)|value<<6)
}
func (o *TIM_Type) GetCCER_CC2NE() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x40) >> 6
}
func (o *TIM_Type) SetCCER_CC2P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x20)|value<<5)
}
func (o *TIM_Type) GetCCER_CC2P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x20) >> 5
}
func (o *TIM_Type) SetCCER_CC2E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x10)|value<<4)
}
func (o *TIM_Type) GetCCER_CC2E() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x10) >> 4
}
func (o *TIM_Type) SetCCER_CC1NP(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCCER_CC1NP() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCCER_CC1NE(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCCER_CC1NE() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCCER_CC1P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x2)|value<<1)
}
func (o *TIM_Type) GetCCER_CC1P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x2) >> 1
}
func (o *TIM_Type) SetCCER_CC1E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetCCER_CC1E() uint32 {
	return volatile.LoadUint32(&o.CCER.Reg) & 0x1
}
func (o *TIM_Type) SetCCER_CC5E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetCCER_CC5E() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x10000) >> 16
}
func (o *TIM_Type) SetCCER_CC5P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x20000)|value<<17)
}
func (o *TIM_Type) GetCCER_CC5P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x20000) >> 17
}
func (o *TIM_Type) SetCCER_CC6E(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x100000)|value<<20)
}
func (o *TIM_Type) GetCCER_CC6E() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x100000) >> 20
}
func (o *TIM_Type) SetCCER_CC6P(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x200000)|value<<21)
}
func (o *TIM_Type) GetCCER_CC6P() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x200000) >> 21
}
func (o *TIM_Type) SetCCER_CC4NP(value uint32) {
	volatile.StoreUint32(&o.CCER.Reg, volatile.LoadUint32(&o.CCER.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetCCER_CC4NP() uint32 {
	return (volatile.LoadUint32(&o.CCER.Reg) & 0x8000) >> 15
}

// TIM.CNT: counter
func (o *TIM_Type) SetCNT(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCNT() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg) & 0xffff
}
func (o *TIM_Type) SetCNT_UIFCPY(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0x80000000)|value<<31)
}
func (o *TIM_Type) GetCNT_UIFCPY() uint32 {
	return (volatile.LoadUint32(&o.CNT.Reg) & 0x80000000) >> 31
}

// TIM.PSC: prescaler
func (o *TIM_Type) SetPSC(value uint32) {
	volatile.StoreUint32(&o.PSC.Reg, volatile.LoadUint32(&o.PSC.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetPSC() uint32 {
	return volatile.LoadUint32(&o.PSC.Reg) & 0xffff
}

// TIM.ARR: auto-reload register
func (o *TIM_Type) SetARR(value uint32) {
	volatile.StoreUint32(&o.ARR.Reg, volatile.LoadUint32(&o.ARR.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetARR() uint32 {
	return volatile.LoadUint32(&o.ARR.Reg) & 0xffff
}

// TIM.RCR: repetition counter register
func (o *TIM_Type) SetRCR_REP(value uint32) {
	volatile.StoreUint32(&o.RCR.Reg, volatile.LoadUint32(&o.RCR.Reg)&^(0xff)|value)
}
func (o *TIM_Type) GetRCR_REP() uint32 {
	return volatile.LoadUint32(&o.RCR.Reg) & 0xff
}

// TIM.CCR1: capture/compare register
func (o *TIM_Type) SetCCR1_CCR(value uint32) {
	volatile.StoreUint32(&o.CCR1.Reg, volatile.LoadUint32(&o.CCR1.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCCR1_CCR() uint32 {
	return volatile.LoadUint32(&o.CCR1.Reg) & 0xffff
}

// TIM.CCR2: capture/compare register
func (o *TIM_Type) SetCCR2_CCR(value uint32) {
	volatile.StoreUint32(&o.CCR2.Reg, volatile.LoadUint32(&o.CCR2.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCCR2_CCR() uint32 {
	return volatile.LoadUint32(&o.CCR2.Reg) & 0xffff
}

// TIM.CCR3: capture/compare register
func (o *TIM_Type) SetCCR3_CCR(value uint32) {
	volatile.StoreUint32(&o.CCR3.Reg, volatile.LoadUint32(&o.CCR3.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCCR3_CCR() uint32 {
	return volatile.LoadUint32(&o.CCR3.Reg) & 0xffff
}

// TIM.CCR4: capture/compare register
func (o *TIM_Type) SetCCR4_CCR(value uint32) {
	volatile.StoreUint32(&o.CCR4.Reg, volatile.LoadUint32(&o.CCR4.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCCR4_CCR() uint32 {
	return volatile.LoadUint32(&o.CCR4.Reg) & 0xffff
}

// TIM.BDTR: break and dead-time register
func (o *TIM_Type) SetBDTR_MOE(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetBDTR_MOE() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetBDTR_AOE(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x4000)|value<<14)
}
func (o *TIM_Type) GetBDTR_AOE() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x4000) >> 14
}
func (o *TIM_Type) SetBDTR_BKP(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x2000)|value<<13)
}
func (o *TIM_Type) GetBDTR_BKP() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x2000) >> 13
}
func (o *TIM_Type) SetBDTR_BKE(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x1000)|value<<12)
}
func (o *TIM_Type) GetBDTR_BKE() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x1000) >> 12
}
func (o *TIM_Type) SetBDTR_OSSR(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetBDTR_OSSR() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetBDTR_OSSI(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetBDTR_OSSI() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetBDTR_LOCK(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x300)|value<<8)
}
func (o *TIM_Type) GetBDTR_LOCK() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x300) >> 8
}
func (o *TIM_Type) SetBDTR_DTG(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0xff)|value)
}
func (o *TIM_Type) GetBDTR_DTG() uint32 {
	return volatile.LoadUint32(&o.BDTR.Reg) & 0xff
}
func (o *TIM_Type) SetBDTR_BKF(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0xf0000)|value<<16)
}
func (o *TIM_Type) GetBDTR_BKF() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0xf0000) >> 16
}
func (o *TIM_Type) SetBDTR_BK2F(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0xf00000)|value<<20)
}
func (o *TIM_Type) GetBDTR_BK2F() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0xf00000) >> 20
}
func (o *TIM_Type) SetBDTR_BK2E(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x1000000)|value<<24)
}
func (o *TIM_Type) GetBDTR_BK2E() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x1000000) >> 24
}
func (o *TIM_Type) SetBDTR_BK2P(value uint32) {
	volatile.StoreUint32(&o.BDTR.Reg, volatile.LoadUint32(&o.BDTR.Reg)&^(0x2000000)|value<<25)
}
func (o *TIM_Type) GetBDTR_BK2P() uint32 {
	return (volatile.LoadUint32(&o.BDTR.Reg) & 0x2000000) >> 25
}

// TIM.DCR: DMA control register
func (o *TIM_Type) SetDCR_DBL(value uint32) {
	volatile.StoreUint32(&o.DCR.Reg, volatile.LoadUint32(&o.DCR.Reg)&^(0x1f00)|value<<8)
}
func (o *TIM_Type) GetDCR_DBL() uint32 {
	return (volatile.LoadUint32(&o.DCR.Reg) & 0x1f00) >> 8
}
func (o *TIM_Type) SetDCR_DBA(value uint32) {
	volatile.StoreUint32(&o.DCR.Reg, volatile.LoadUint32(&o.DCR.Reg)&^(0x1f)|value)
}
func (o *TIM_Type) GetDCR_DBA() uint32 {
	return volatile.LoadUint32(&o.DCR.Reg) & 0x1f
}

// TIM.DMAR: DMA address for full transfer
func (o *TIM_Type) SetDMAR(value uint32) {
	volatile.StoreUint32(&o.DMAR.Reg, value)
}
func (o *TIM_Type) GetDMAR() uint32 {
	return volatile.LoadUint32(&o.DMAR.Reg)
}

// TIM.CCMR3_Output: capture/compare mode register 3 (output mode)
func (o *TIM_Type) SetCCMR3_Output_OC5FE(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x4)|value<<2)
}
func (o *TIM_Type) GetCCMR3_Output_OC5FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x4) >> 2
}
func (o *TIM_Type) SetCCMR3_Output_OC5PE(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x8)|value<<3)
}
func (o *TIM_Type) GetCCMR3_Output_OC5PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x8) >> 3
}
func (o *TIM_Type) SetCCMR3_Output_OC5M(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x70)|value<<4)
}
func (o *TIM_Type) GetCCMR3_Output_OC5M() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x70) >> 4
}
func (o *TIM_Type) SetCCMR3_Output_OC5CE(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x80)|value<<7)
}
func (o *TIM_Type) GetCCMR3_Output_OC5CE() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x80) >> 7
}
func (o *TIM_Type) SetCCMR3_Output_OC6FE(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x400)|value<<10)
}
func (o *TIM_Type) GetCCMR3_Output_OC6FE() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x400) >> 10
}
func (o *TIM_Type) SetCCMR3_Output_OC6PE(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x800)|value<<11)
}
func (o *TIM_Type) GetCCMR3_Output_OC6PE() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x800) >> 11
}
func (o *TIM_Type) SetCCMR3_Output_OC6M(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x7000)|value<<12)
}
func (o *TIM_Type) GetCCMR3_Output_OC6M() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x7000) >> 12
}
func (o *TIM_Type) SetCCMR3_Output_OC6CE(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x8000)|value<<15)
}
func (o *TIM_Type) GetCCMR3_Output_OC6CE() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x8000) >> 15
}
func (o *TIM_Type) SetCCMR3_Output_OC5M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x10000)|value<<16)
}
func (o *TIM_Type) GetCCMR3_Output_OC5M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x10000) >> 16
}
func (o *TIM_Type) SetCCMR3_Output_OC6M_3(value uint32) {
	volatile.StoreUint32(&o.CCMR3_Output.Reg, volatile.LoadUint32(&o.CCMR3_Output.Reg)&^(0x1000000)|value<<24)
}
func (o *TIM_Type) GetCCMR3_Output_OC6M_3() uint32 {
	return (volatile.LoadUint32(&o.CCMR3_Output.Reg) & 0x1000000) >> 24
}

// TIM.CCR5: capture/compare register
func (o *TIM_Type) SetCCR5_CCR(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCCR5_CCR() uint32 {
	return volatile.LoadUint32(&o.CCR5.Reg) & 0xffff
}
func (o *TIM_Type) SetCCR5_GC5C1(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x20000000)|value<<29)
}
func (o *TIM_Type) GetCCR5_GC5C1() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x20000000) >> 29
}
func (o *TIM_Type) SetCCR5_GC5C2(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x40000000)|value<<30)
}
func (o *TIM_Type) GetCCR5_GC5C2() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x40000000) >> 30
}
func (o *TIM_Type) SetCCR5_GC5C3(value uint32) {
	volatile.StoreUint32(&o.CCR5.Reg, volatile.LoadUint32(&o.CCR5.Reg)&^(0x80000000)|value<<31)
}
func (o *TIM_Type) GetCCR5_GC5C3() uint32 {
	return (volatile.LoadUint32(&o.CCR5.Reg) & 0x80000000) >> 31
}

// TIM.CCR6: capture/compare register
func (o *TIM_Type) SetCCR6_CCR(value uint32) {
	volatile.StoreUint32(&o.CCR6.Reg, volatile.LoadUint32(&o.CCR6.Reg)&^(0xffff)|value)
}
func (o *TIM_Type) GetCCR6_CCR() uint32 {
	return volatile.LoadUint32(&o.CCR6.Reg) & 0xffff
}

// TIM.AF1: alternate function option register 1
func (o *TIM_Type) SetAF1_BKINE(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetAF1_BKINE() uint32 {
	return volatile.LoadUint32(&o.AF1.Reg) & 0x1
}
func (o *TIM_Type) SetAF1_BKDFBKE(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetAF1_BKDFBKE() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetAF1_BKINP(value uint32) {
	volatile.StoreUint32(&o.AF1.Reg, volatile.LoadUint32(&o.AF1.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetAF1_BKINP() uint32 {
	return (volatile.LoadUint32(&o.AF1.Reg) & 0x200) >> 9
}

// TIM.AF2: alternate function option register 2
func (o *TIM_Type) SetAF2_BK2INE(value uint32) {
	volatile.StoreUint32(&o.AF2.Reg, volatile.LoadUint32(&o.AF2.Reg)&^(0x1)|value)
}
func (o *TIM_Type) GetAF2_BK2INE() uint32 {
	return volatile.LoadUint32(&o.AF2.Reg) & 0x1
}
func (o *TIM_Type) SetAF2_BK2DFBKE(value uint32) {
	volatile.StoreUint32(&o.AF2.Reg, volatile.LoadUint32(&o.AF2.Reg)&^(0x100)|value<<8)
}
func (o *TIM_Type) GetAF2_BK2DFBKE() uint32 {
	return (volatile.LoadUint32(&o.AF2.Reg) & 0x100) >> 8
}
func (o *TIM_Type) SetAF2_BK2INP(value uint32) {
	volatile.StoreUint32(&o.AF2.Reg, volatile.LoadUint32(&o.AF2.Reg)&^(0x200)|value<<9)
}
func (o *TIM_Type) GetAF2_BK2INP() uint32 {
	return (volatile.LoadUint32(&o.AF2.Reg) & 0x200) >> 9
}

// Ethernet: media access control (MAC)
type Ethernet_Type struct {
	MACCR      volatile.Register32 // 0x0
	MACFFR     volatile.Register32 // 0x4
	MACHTHR    volatile.Register32 // 0x8
	MACHTLR    volatile.Register32 // 0xC
	MACMIIAR   volatile.Register32 // 0x10
	MACMIIDR   volatile.Register32 // 0x14
	MACFCR     volatile.Register32 // 0x18
	MACVLANTR  volatile.Register32 // 0x1C
	_          [12]byte
	MACPMTCSR  volatile.Register32 // 0x2C
	_          [4]byte
	MACDBGR    volatile.Register32 // 0x34
	MACSR      volatile.Register32 // 0x38
	MACIMR     volatile.Register32 // 0x3C
	MACA0HR    volatile.Register32 // 0x40
	MACA0LR    volatile.Register32 // 0x44
	MACA1HR    volatile.Register32 // 0x48
	MACA1LR    volatile.Register32 // 0x4C
	MACA2HR    volatile.Register32 // 0x50
	MACA2LR    volatile.Register32 // 0x54
	MACA3HR    volatile.Register32 // 0x58
	MACA3LR    volatile.Register32 // 0x5C
	MACRWUFFER volatile.Register32 // 0x60
}

// Ethernet.MACCR: Ethernet MAC configuration register
func (o *Ethernet_Type) SetMACCR_RE(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x4)|value<<2)
}
func (o *Ethernet_Type) GetMACCR_RE() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x4) >> 2
}
func (o *Ethernet_Type) SetMACCR_TE(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x8)|value<<3)
}
func (o *Ethernet_Type) GetMACCR_TE() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x8) >> 3
}
func (o *Ethernet_Type) SetMACCR_DC(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x10)|value<<4)
}
func (o *Ethernet_Type) GetMACCR_DC() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x10) >> 4
}
func (o *Ethernet_Type) SetMACCR_BL(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x60)|value<<5)
}
func (o *Ethernet_Type) GetMACCR_BL() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x60) >> 5
}
func (o *Ethernet_Type) SetMACCR_APCS(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x80)|value<<7)
}
func (o *Ethernet_Type) GetMACCR_APCS() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x80) >> 7
}
func (o *Ethernet_Type) SetMACCR_RD(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x200)|value<<9)
}
func (o *Ethernet_Type) GetMACCR_RD() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x200) >> 9
}
func (o *Ethernet_Type) SetMACCR_IPCO(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x400)|value<<10)
}
func (o *Ethernet_Type) GetMACCR_IPCO() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x400) >> 10
}
func (o *Ethernet_Type) SetMACCR_DM(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x800)|value<<11)
}
func (o *Ethernet_Type) GetMACCR_DM() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x800) >> 11
}
func (o *Ethernet_Type) SetMACCR_LM(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x1000)|value<<12)
}
func (o *Ethernet_Type) GetMACCR_LM() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x1000) >> 12
}
func (o *Ethernet_Type) SetMACCR_ROD(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x2000)|value<<13)
}
func (o *Ethernet_Type) GetMACCR_ROD() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x2000) >> 13
}
func (o *Ethernet_Type) SetMACCR_FES(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x4000)|value<<14)
}
func (o *Ethernet_Type) GetMACCR_FES() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x4000) >> 14
}
func (o *Ethernet_Type) SetMACCR_CSD(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x10000)|value<<16)
}
func (o *Ethernet_Type) GetMACCR_CSD() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x10000) >> 16
}
func (o *Ethernet_Type) SetMACCR_IFG(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0xe0000)|value<<17)
}
func (o *Ethernet_Type) GetMACCR_IFG() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0xe0000) >> 17
}
func (o *Ethernet_Type) SetMACCR_JD(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x400000)|value<<22)
}
func (o *Ethernet_Type) GetMACCR_JD() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x400000) >> 22
}
func (o *Ethernet_Type) SetMACCR_WD(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x800000)|value<<23)
}
func (o *Ethernet_Type) GetMACCR_WD() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x800000) >> 23
}
func (o *Ethernet_Type) SetMACCR_CSTF(value uint32) {
	volatile.StoreUint32(&o.MACCR.Reg, volatile.LoadUint32(&o.MACCR.Reg)&^(0x2000000)|value<<25)
}
func (o *Ethernet_Type) GetMACCR_CSTF() uint32 {
	return (volatile.LoadUint32(&o.MACCR.Reg) & 0x2000000) >> 25
}

// Ethernet.MACFFR: Ethernet MAC frame filter register
func (o *Ethernet_Type) SetMACFFR_PM(value uint32) {
	volatile.StoreUint32(&o.MACFFR.Reg, volatile.LoadUint32(&o.MACFFR.Reg)&^(0x1)|value)
}
func (o *Ethernet_Type) GetMACFFR_PM() uint32 {
	return volatile.LoadUint32(&o.MACFFR.Reg) & 0x1
}
func (o *Ethernet_Type) SetMACFFR_HU(value uint32) {
	volatile.StoreUint32(&o.MACFFR.Reg, volatile.LoadUint32(&o.MACFFR.Reg)&^(0x2)|value<<1)
}
func (o *Ethernet_Type) GetMACFFR_HU() uint32 {
	return (volatile.LoadUint32(&o.MACFFR.Reg) & 0x2) >> 1
}
func (o *Ethernet_Type) SetMACFFR_HM(value uint32) {
	volatile.StoreUint32(&o.MACFFR.Reg, volatile.LoadUint32(&o.MACFFR.Reg)&^(0x4)|value<<2)
}
func (o *Ethernet_Type) GetMACFFR_HM() uint32 {
	return (volatile.LoadUint32(&o.MACFFR.Reg) & 0x4) >> 2
}
func (o *Ethernet_Type) SetMACFFR_DAIF(value uint32) {
	volatile.StoreUint32(&o.MACFFR.Reg, volatile.LoadUint32(&o.MACFFR.Reg)&^(0x8)|value<<3)
}
func (o *Ethernet_Type) GetMACFFR_DAIF() uint32 {
	return (volatile.LoadUint32(&o.MACFFR.Reg) & 0x8) >> 3
}
func (o *Ethernet_Type) SetMACFFR_PAM(value uint32) {
	volatile.StoreUint32(&o.MACFFR.Reg, volatile.LoadUint32(&o.MACFFR.Reg)&^(0x10)|value<<4)
}
func (o *Ethernet_Type) GetMACFFR_PAM() uint32 {
	return (volatile.LoadUint32(&o.MACFFR.Reg) & 0x10) >> 4
}
func (o *Ethernet_Type) SetMACFFR_BFD(value uint32) {
	volatile.StoreUint32(&o.MACFFR.Reg, volatile.LoadUint32(&o.MACFFR.Reg)&^(0x20)|value<<5)
}
func (o *Ethernet_Type) GetMACFFR_BFD() uint32 {
	return (volatile.LoadUint32(&o.MACFFR.Reg) & 0x20) >> 5
}
func (o *Ethernet_Type) SetMACFFR_PCF(value uint32) {
	volatile.StoreUint32(&o.MACFFR.Reg, volatile.LoadUint32(&o.MACFFR.Reg)&^(0xc0)|value<<6)
}
func (o *Ethernet_Type) GetMACFFR_PCF() uint32 {
	return (volatile.LoadUint32(&o.MACFFR.Reg) & 0xc0) >> 6
}
func (o *Ethernet_Type) SetMACFFR_SAIF(value uint32) {
	volatile.StoreUint32(&o.MACFFR.Reg, volatile.LoadUint32(&o.MACFFR.Reg)&^(0x80)|value<<7)
}
func (o *Ethernet_Type) GetMACFFR_SAIF() uint32 {
	return (volatile.LoadUint32(&o.MACFFR.Reg) & 0x80) >> 7
}
func (o *Ethernet_Type) SetMACFFR_SAF(value uint32) {
	volatile.StoreUint32(&o.MACFFR.Reg, volatile.LoadUint32(&o.MACFFR.Reg)&^(0x100)|value<<8)
}
func (o *Ethernet_Type) GetMACFFR_SAF() uint32 {
	return (volatile.LoadUint32(&o.MACFFR.Reg) & 0x100) >> 8
}
func (o *Ethernet_Type) SetMACFFR_HPF(value uint32) {
	volatile.StoreUint32(&o.MACFFR.Reg, volatile.LoadUint32(&o.MACFFR.Reg)&^(0x200)|value<<9)
}
func (o *Ethernet_Type) GetMACFFR_HPF() uint32 {
	return (volatile.LoadUint32(&o.MACFFR.Reg) & 0x200) >> 9
}
func (o *Ethernet_Type) SetMACFFR_RA(value uint32) {
	volatile.StoreUint32(&o.MACFFR.Reg, volatile.LoadUint32(&o.MACFFR.Reg)&^(0x80000000)|value<<31)
}
func (o *Ethernet_Type) GetMACFFR_RA() uint32 {
	return (volatile.LoadUint32(&o.MACFFR.Reg) & 0x80000000) >> 31
}

// Ethernet.MACHTHR: Ethernet MAC hash table high register
func (o *Ethernet_Type) SetMACHTHR(value uint32) {
	volatile.StoreUint32(&o.MACHTHR.Reg, value)
}
func (o *Ethernet_Type) GetMACHTHR() uint32 {
	return volatile.LoadUint32(&o.MACHTHR.Reg)
}

// Ethernet.MACHTLR: Ethernet MAC hash table low register
func (o *Ethernet_Type) SetMACHTLR(value uint32) {
	volatile.StoreUint32(&o.MACHTLR.Reg, value)
}
func (o *Ethernet_Type) GetMACHTLR() uint32 {
	return volatile.LoadUint32(&o.MACHTLR.Reg)
}

// Ethernet.MACMIIAR: Ethernet MAC MII address register
func (o *Ethernet_Type) SetMACMIIAR_MB(value uint32) {
	volatile.StoreUint32(&o.MACMIIAR.Reg, volatile.LoadUint32(&o.MACMIIAR.Reg)&^(0x1)|value)
}
func (o *Ethernet_Type) GetMACMIIAR_MB() uint32 {
	return volatile.LoadUint32(&o.MACMIIAR.Reg) & 0x1
}
func (o *Ethernet_Type) SetMACMIIAR_MW(value uint32) {
	volatile.StoreUint32(&o.MACMIIAR.Reg, volatile.LoadUint32(&o.MACMIIAR.Reg)&^(0x2)|value<<1)
}
func (o *Ethernet_Type) GetMACMIIAR_MW() uint32 {
	return (volatile.LoadUint32(&o.MACMIIAR.Reg) & 0x2) >> 1
}
func (o *Ethernet_Type) SetMACMIIAR_CR(value uint32) {
	volatile.StoreUint32(&o.MACMIIAR.Reg, volatile.LoadUint32(&o.MACMIIAR.Reg)&^(0x1c)|value<<2)
}
func (o *Ethernet_Type) GetMACMIIAR_CR() uint32 {
	return (volatile.LoadUint32(&o.MACMIIAR.Reg) & 0x1c) >> 2
}
func (o *Ethernet_Type) SetMACMIIAR_MR(value uint32) {
	volatile.StoreUint32(&o.MACMIIAR.Reg, volatile.LoadUint32(&o.MACMIIAR.Reg)&^(0x7c0)|value<<6)
}
func (o *Ethernet_Type) GetMACMIIAR_MR() uint32 {
	return (volatile.LoadUint32(&o.MACMIIAR.Reg) & 0x7c0) >> 6
}
func (o *Ethernet_Type) SetMACMIIAR_PA(value uint32) {
	volatile.StoreUint32(&o.MACMIIAR.Reg, volatile.LoadUint32(&o.MACMIIAR.Reg)&^(0xf800)|value<<11)
}
func (o *Ethernet_Type) GetMACMIIAR_PA() uint32 {
	return (volatile.LoadUint32(&o.MACMIIAR.Reg) & 0xf800) >> 11
}

// Ethernet.MACMIIDR: Ethernet MAC MII data register
func (o *Ethernet_Type) SetMACMIIDR_MD(value uint32) {
	volatile.StoreUint32(&o.MACMIIDR.Reg, volatile.LoadUint32(&o.MACMIIDR.Reg)&^(0xffff)|value)
}
func (o *Ethernet_Type) GetMACMIIDR_MD() uint32 {
	return volatile.LoadUint32(&o.MACMIIDR.Reg) & 0xffff
}

// Ethernet.MACFCR: Ethernet MAC flow control register
func (o *Ethernet_Type) SetMACFCR_FCB(value uint32) {
	volatile.StoreUint32(&o.MACFCR.Reg, volatile.LoadUint32(&o.MACFCR.Reg)&^(0x1)|value)
}
func (o *Ethernet_Type) GetMACFCR_FCB() uint32 {
	return volatile.LoadUint32(&o.MACFCR.Reg) & 0x1
}
func (o *Ethernet_Type) SetMACFCR_TFCE(value uint32) {
	volatile.StoreUint32(&o.MACFCR.Reg, volatile.LoadUint32(&o.MACFCR.Reg)&^(0x2)|value<<1)
}
func (o *Ethernet_Type) GetMACFCR_TFCE() uint32 {
	return (volatile.LoadUint32(&o.MACFCR.Reg) & 0x2) >> 1
}
func (o *Ethernet_Type) SetMACFCR_RFCE(value uint32) {
	volatile.StoreUint32(&o.MACFCR.Reg, volatile.LoadUint32(&o.MACFCR.Reg)&^(0x4)|value<<2)
}
func (o *Ethernet_Type) GetMACFCR_RFCE() uint32 {
	return (volatile.LoadUint32(&o.MACFCR.Reg) & 0x4) >> 2
}
func (o *Ethernet_Type) SetMACFCR_UPFD(value uint32) {
	volatile.StoreUint32(&o.MACFCR.Reg, volatile.LoadUint32(&o.MACFCR.Reg)&^(0x8)|value<<3)
}
func (o *Ethernet_Type) GetMACFCR_UPFD() uint32 {
	return (volatile.LoadUint32(&o.MACFCR.Reg) & 0x8) >> 3
}
func (o *Ethernet_Type) SetMACFCR_PLT(value uint32) {
	volatile.StoreUint32(&o.MACFCR.Reg, volatile.LoadUint32(&o.MACFCR.Reg)&^(0x30)|value<<4)
}
func (o *Ethernet_Type) GetMACFCR_PLT() uint32 {
	return (volatile.LoadUint32(&o.MACFCR.Reg) & 0x30) >> 4
}
func (o *Ethernet_Type) SetMACFCR_ZQPD(value uint32) {
	volatile.StoreUint32(&o.MACFCR.Reg, volatile.LoadUint32(&o.MACFCR.Reg)&^(0x80)|value<<7)
}
func (o *Ethernet_Type) GetMACFCR_ZQPD() uint32 {
	return (volatile.LoadUint32(&o.MACFCR.Reg) & 0x80) >> 7
}
func (o *Ethernet_Type) SetMACFCR_PT(value uint32) {
	volatile.StoreUint32(&o.MACFCR.Reg, volatile.LoadUint32(&o.MACFCR.Reg)&^(0xffff0000)|value<<16)
}
func (o *Ethernet_Type) GetMACFCR_PT() uint32 {
	return (volatile.LoadUint32(&o.MACFCR.Reg) & 0xffff0000) >> 16
}

// Ethernet.MACVLANTR: Ethernet MAC VLAN tag register
func (o *Ethernet_Type) SetMACVLANTR_VLANTI(value uint32) {
	volatile.StoreUint32(&o.MACVLANTR.Reg, volatile.LoadUint32(&o.MACVLANTR.Reg)&^(0xffff)|value)
}
func (o *Ethernet_Type) GetMACVLANTR_VLANTI() uint32 {
	return volatile.LoadUint32(&o.MACVLANTR.Reg) & 0xffff
}
func (o *Ethernet_Type) SetMACVLANTR_VLANTC(value uint32) {
	volatile.StoreUint32(&o.MACVLANTR.Reg, volatile.LoadUint32(&o.MACVLANTR.Reg)&^(0x10000)|value<<16)
}
func (o *Ethernet_Type) GetMACVLANTR_VLANTC() uint32 {
	return (volatile.LoadUint32(&o.MACVLANTR.Reg) & 0x10000) >> 16
}

// Ethernet.MACPMTCSR: Ethernet MAC PMT control and status register
func (o *Ethernet_Type) SetMACPMTCSR_PD(value uint32) {
	volatile.StoreUint32(&o.MACPMTCSR.Reg, volatile.LoadUint32(&o.MACPMTCSR.Reg)&^(0x1)|value)
}
func (o *Ethernet_Type) GetMACPMTCSR_PD() uint32 {
	return volatile.LoadUint32(&o.MACPMTCSR.Reg) & 0x1
}
func (o *Ethernet_Type) SetMACPMTCSR_MPE(value uint32) {
	volatile.StoreUint32(&o.MACPMTCSR.Reg, volatile.LoadUint32(&o.MACPMTCSR.Reg)&^(0x2)|value<<1)
}
func (o *Ethernet_Type) GetMACPMTCSR_MPE() uint32 {
	return (volatile.LoadUint32(&o.MACPMTCSR.Reg) & 0x2) >> 1
}
func (o *Ethernet_Type) SetMACPMTCSR_WFE(value uint32) {
	volatile.StoreUint32(&o.MACPMTCSR.Reg, volatile.LoadUint32(&o.MACPMTCSR.Reg)&^(0x4)|value<<2)
}
func (o *Ethernet_Type) GetMACPMTCSR_WFE() uint32 {
	return (volatile.LoadUint32(&o.MACPMTCSR.Reg) & 0x4) >> 2
}
func (o *Ethernet_Type) SetMACPMTCSR_MPR(value uint32) {
	volatile.StoreUint32(&o.MACPMTCSR.Reg, volatile.LoadUint32(&o.MACPMTCSR.Reg)&^(0x20)|value<<5)
}
func (o *Ethernet_Type) GetMACPMTCSR_MPR() uint32 {
	return (volatile.LoadUint32(&o.MACPMTCSR.Reg) & 0x20) >> 5
}
func (o *Ethernet_Type) SetMACPMTCSR_WFR(value uint32) {
	volatile.StoreUint32(&o.MACPMTCSR.Reg, volatile.LoadUint32(&o.MACPMTCSR.Reg)&^(0x40)|value<<6)
}
func (o *Ethernet_Type) GetMACPMTCSR_WFR() uint32 {
	return (volatile.LoadUint32(&o.MACPMTCSR.Reg) & 0x40) >> 6
}
func (o *Ethernet_Type) SetMACPMTCSR_GU(value uint32) {
	volatile.StoreUint32(&o.MACPMTCSR.Reg, volatile.LoadUint32(&o.MACPMTCSR.Reg)&^(0x200)|value<<9)
}
func (o *Ethernet_Type) GetMACPMTCSR_GU() uint32 {
	return (volatile.LoadUint32(&o.MACPMTCSR.Reg) & 0x200) >> 9
}
func (o *Ethernet_Type) SetMACPMTCSR_WFFRPR(value uint32) {
	volatile.StoreUint32(&o.MACPMTCSR.Reg, volatile.LoadUint32(&o.MACPMTCSR.Reg)&^(0x80000000)|value<<31)
}
func (o *Ethernet_Type) GetMACPMTCSR_WFFRPR() uint32 {
	return (volatile.LoadUint32(&o.MACPMTCSR.Reg) & 0x80000000) >> 31
}

// Ethernet.MACDBGR: Ethernet MAC debug register
func (o *Ethernet_Type) SetMACDBGR_TFF(value uint32) {
	volatile.StoreUint32(&o.MACDBGR.Reg, volatile.LoadUint32(&o.MACDBGR.Reg)&^(0x2000000)|value<<25)
}
func (o *Ethernet_Type) GetMACDBGR_TFF() uint32 {
	return (volatile.LoadUint32(&o.MACDBGR.Reg) & 0x2000000) >> 25
}
func (o *Ethernet_Type) SetMACDBGR_TFNE(value uint32) {
	volatile.StoreUint32(&o.MACDBGR.Reg, volatile.LoadUint32(&o.MACDBGR.Reg)&^(0x1000000)|value<<24)
}
func (o *Ethernet_Type) GetMACDBGR_TFNE() uint32 {
	return (volatile.LoadUint32(&o.MACDBGR.Reg) & 0x1000000) >> 24
}
func (o *Ethernet_Type) SetMACDBGR_TFWA(value uint32) {
	volatile.StoreUint32(&o.MACDBGR.Reg, volatile.LoadUint32(&o.MACDBGR.Reg)&^(0x400000)|value<<22)
}
func (o *Ethernet_Type) GetMACDBGR_TFWA() uint32 {
	return (volatile.LoadUint32(&o.MACDBGR.Reg) & 0x400000) >> 22
}
func (o *Ethernet_Type) SetMACDBGR_TFRS(value uint32) {
	volatile.StoreUint32(&o.MACDBGR.Reg, volatile.LoadUint32(&o.MACDBGR.Reg)&^(0x300000)|value<<20)
}
func (o *Ethernet_Type) GetMACDBGR_TFRS() uint32 {
	return (volatile.LoadUint32(&o.MACDBGR.Reg) & 0x300000) >> 20
}
func (o *Ethernet_Type) SetMACDBGR_MTP(value uint32) {
	volatile.StoreUint32(&o.MACDBGR.Reg, volatile.LoadUint32(&o.MACDBGR.Reg)&^(0x80000)|value<<19)
}
func (o *Ethernet_Type) GetMACDBGR_MTP() uint32 {
	return (volatile.LoadUint32(&o.MACDBGR.Reg) & 0x80000) >> 19
}
func (o *Ethernet_Type) SetMACDBGR_MTFCS(value uint32) {
	volatile.StoreUint32(&o.MACDBGR.Reg, volatile.LoadUint32(&o.MACDBGR.Reg)&^(0x60000)|value<<17)
}
func (o *Ethernet_Type) GetMACDBGR_MTFCS() uint32 {
	return (volatile.LoadUint32(&o.MACDBGR.Reg) & 0x60000) >> 17
}
func (o *Ethernet_Type) SetMACDBGR_MMTEA(value uint32) {
	volatile.StoreUint32(&o.MACDBGR.Reg, volatile.LoadUint32(&o.MACDBGR.Reg)&^(0x10000)|value<<16)
}
func (o *Ethernet_Type) GetMACDBGR_MMTEA() uint32 {
	return (volatile.LoadUint32(&o.MACDBGR.Reg) & 0x10000) >> 16
}
func (o *Ethernet_Type) SetMACDBGR_RFFL(value uint32) {
	volatile.StoreUint32(&o.MACDBGR.Reg, volatile.LoadUint32(&o.MACDBGR.Reg)&^(0x300)|value<<8)
}
func (o *Ethernet_Type) GetMACDBGR_RFFL() uint32 {
	return (volatile.LoadUint32(&o.MACDBGR.Reg) & 0x300) >> 8
}
func (o *Ethernet_Type) SetMACDBGR_RFRCS(value uint32) {
	volatile.StoreUint32(&o.MACDBGR.Reg, volatile.LoadUint32(&o.MACDBGR.Reg)&^(0x60)|value<<5)
}
func (o *Ethernet_Type) GetMACDBGR_RFRCS() uint32 {
	return (volatile.LoadUint32(&o.MACDBGR.Reg) & 0x60) >> 5
}
func (o *Ethernet_Type) SetMACDBGR_RFWRA(value uint32) {
	volatile.StoreUint32(&o.MACDBGR.Reg, volatile.LoadUint32(&o.MACDBGR.Reg)&^(0x10)|value<<4)
}
func (o *Ethernet_Type) GetMACDBGR_RFWRA() uint32 {
	return (volatile.LoadUint32(&o.MACDBGR.Reg) & 0x10) >> 4
}
func (o *Ethernet_Type) SetMACDBGR_MSFRWCS(value uint32) {
	volatile.StoreUint32(&o.MACDBGR.Reg, volatile.LoadUint32(&o.MACDBGR.Reg)&^(0x6)|value<<1)
}
func (o *Ethernet_Type) GetMACDBGR_MSFRWCS() uint32 {
	return (volatile.LoadUint32(&o.MACDBGR.Reg) & 0x6) >> 1
}
func (o *Ethernet_Type) SetMACDBGR_MMRPEA(value uint32) {
	volatile.StoreUint32(&o.MACDBGR.Reg, volatile.LoadUint32(&o.MACDBGR.Reg)&^(0x1)|value)
}
func (o *Ethernet_Type) GetMACDBGR_MMRPEA() uint32 {
	return volatile.LoadUint32(&o.MACDBGR.Reg) & 0x1
}

// Ethernet.MACSR: Ethernet MAC interrupt status register
func (o *Ethernet_Type) SetMACSR_PMTS(value uint32) {
	volatile.StoreUint32(&o.MACSR.Reg, volatile.LoadUint32(&o.MACSR.Reg)&^(0x8)|value<<3)
}
func (o *Ethernet_Type) GetMACSR_PMTS() uint32 {
	return (volatile.LoadUint32(&o.MACSR.Reg) & 0x8) >> 3
}
func (o *Ethernet_Type) SetMACSR_MMCS(value uint32) {
	volatile.StoreUint32(&o.MACSR.Reg, volatile.LoadUint32(&o.MACSR.Reg)&^(0x10)|value<<4)
}
func (o *Ethernet_Type) GetMACSR_MMCS() uint32 {
	return (volatile.LoadUint32(&o.MACSR.Reg) & 0x10) >> 4
}
func (o *Ethernet_Type) SetMACSR_MMCRS(value uint32) {
	volatile.StoreUint32(&o.MACSR.Reg, volatile.LoadUint32(&o.MACSR.Reg)&^(0x20)|value<<5)
}
func (o *Ethernet_Type) GetMACSR_MMCRS() uint32 {
	return (volatile.LoadUint32(&o.MACSR.Reg) & 0x20) >> 5
}
func (o *Ethernet_Type) SetMACSR_MMCTS(value uint32) {
	volatile.StoreUint32(&o.MACSR.Reg, volatile.LoadUint32(&o.MACSR.Reg)&^(0x40)|value<<6)
}
func (o *Ethernet_Type) GetMACSR_MMCTS() uint32 {
	return (volatile.LoadUint32(&o.MACSR.Reg) & 0x40) >> 6
}
func (o *Ethernet_Type) SetMACSR_TSTS(value uint32) {
	volatile.StoreUint32(&o.MACSR.Reg, volatile.LoadUint32(&o.MACSR.Reg)&^(0x200)|value<<9)
}
func (o *Ethernet_Type) GetMACSR_TSTS() uint32 {
	return (volatile.LoadUint32(&o.MACSR.Reg) & 0x200) >> 9
}

// Ethernet.MACIMR: Ethernet MAC interrupt mask register
func (o *Ethernet_Type) SetMACIMR_PMTIM(value uint32) {
	volatile.StoreUint32(&o.MACIMR.Reg, volatile.LoadUint32(&o.MACIMR.Reg)&^(0x8)|value<<3)
}
func (o *Ethernet_Type) GetMACIMR_PMTIM() uint32 {
	return (volatile.LoadUint32(&o.MACIMR.Reg) & 0x8) >> 3
}
func (o *Ethernet_Type) SetMACIMR_TSTIM(value uint32) {
	volatile.StoreUint32(&o.MACIMR.Reg, volatile.LoadUint32(&o.MACIMR.Reg)&^(0x200)|value<<9)
}
func (o *Ethernet_Type) GetMACIMR_TSTIM() uint32 {
	return (volatile.LoadUint32(&o.MACIMR.Reg) & 0x200) >> 9
}

// Ethernet.MACA0HR: Ethernet MAC address 0 high register
func (o *Ethernet_Type) SetMACA0HR_MACA0H(value uint32) {
	volatile.StoreUint32(&o.MACA0HR.Reg, volatile.LoadUint32(&o.MACA0HR.Reg)&^(0xffff)|value)
}
func (o *Ethernet_Type) GetMACA0HR_MACA0H() uint32 {
	return volatile.LoadUint32(&o.MACA0HR.Reg) & 0xffff
}
func (o *Ethernet_Type) SetMACA0HR_MO(value uint32) {
	volatile.StoreUint32(&o.MACA0HR.Reg, volatile.LoadUint32(&o.MACA0HR.Reg)&^(0x80000000)|value<<31)
}
func (o *Ethernet_Type) GetMACA0HR_MO() uint32 {
	return (volatile.LoadUint32(&o.MACA0HR.Reg) & 0x80000000) >> 31
}

// Ethernet.MACA0LR: Ethernet MAC address 0 low register
func (o *Ethernet_Type) SetMACA0LR(value uint32) {
	volatile.StoreUint32(&o.MACA0LR.Reg, value)
}
func (o *Ethernet_Type) GetMACA0LR() uint32 {
	return volatile.LoadUint32(&o.MACA0LR.Reg)
}

// Ethernet.MACA1HR: Ethernet MAC address 1 high register
func (o *Ethernet_Type) SetMACA1HR_MACA1H(value uint32) {
	volatile.StoreUint32(&o.MACA1HR.Reg, volatile.LoadUint32(&o.MACA1HR.Reg)&^(0xffff)|value)
}
func (o *Ethernet_Type) GetMACA1HR_MACA1H() uint32 {
	return volatile.LoadUint32(&o.MACA1HR.Reg) & 0xffff
}
func (o *Ethernet_Type) SetMACA1HR_MBC(value uint32) {
	volatile.StoreUint32(&o.MACA1HR.Reg, volatile.LoadUint32(&o.MACA1HR.Reg)&^(0x3f000000)|value<<24)
}
func (o *Ethernet_Type) GetMACA1HR_MBC() uint32 {
	return (volatile.LoadUint32(&o.MACA1HR.Reg) & 0x3f000000) >> 24
}
func (o *Ethernet_Type) SetMACA1HR_SA(value uint32) {
	volatile.StoreUint32(&o.MACA1HR.Reg, volatile.LoadUint32(&o.MACA1HR.Reg)&^(0x40000000)|value<<30)
}
func (o *Ethernet_Type) GetMACA1HR_SA() uint32 {
	return (volatile.LoadUint32(&o.MACA1HR.Reg) & 0x40000000) >> 30
}
func (o *Ethernet_Type) SetMACA1HR_AE(value uint32) {
	volatile.StoreUint32(&o.MACA1HR.Reg, volatile.LoadUint32(&o.MACA1HR.Reg)&^(0x80000000)|value<<31)
}
func (o *Ethernet_Type) GetMACA1HR_AE() uint32 {
	return (volatile.LoadUint32(&o.MACA1HR.Reg) & 0x80000000) >> 31
}

// Ethernet.MACA1LR: Ethernet MAC address1 low register
func (o *Ethernet_Type) SetMACA1LR(value uint32) {
	volatile.StoreUint32(&o.MACA1LR.Reg, value)
}
func (o *Ethernet_Type) GetMACA1LR() uint32 {
	return volatile.LoadUint32(&o.MACA1LR.Reg)
}

// Ethernet.MACA2HR: Ethernet MAC address 2 high register
func (o *Ethernet_Type) SetMACA2HR_MACA2H(value uint32) {
	volatile.StoreUint32(&o.MACA2HR.Reg, volatile.LoadUint32(&o.MACA2HR.Reg)&^(0xffff)|value)
}
func (o *Ethernet_Type) GetMACA2HR_MACA2H() uint32 {
	return volatile.LoadUint32(&o.MACA2HR.Reg) & 0xffff
}
func (o *Ethernet_Type) SetMACA2HR_MBC(value uint32) {
	volatile.StoreUint32(&o.MACA2HR.Reg, volatile.LoadUint32(&o.MACA2HR.Reg)&^(0x3f000000)|value<<24)
}
func (o *Ethernet_Type) GetMACA2HR_MBC() uint32 {
	return (volatile.LoadUint32(&o.MACA2HR.Reg) & 0x3f000000) >> 24
}
func (o *Ethernet_Type) SetMACA2HR_SA(value uint32) {
	volatile.StoreUint32(&o.MACA2HR.Reg, volatile.LoadUint32(&o.MACA2HR.Reg)&^(0x40000000)|value<<30)
}
func (o *Ethernet_Type) GetMACA2HR_SA() uint32 {
	return (volatile.LoadUint32(&o.MACA2HR.Reg) & 0x40000000) >> 30
}
func (o *Ethernet_Type) SetMACA2HR_AE(value uint32) {
	volatile.StoreUint32(&o.MACA2HR.Reg, volatile.LoadUint32(&o.MACA2HR.Reg)&^(0x80000000)|value<<31)
}
func (o *Ethernet_Type) GetMACA2HR_AE() uint32 {
	return (volatile.LoadUint32(&o.MACA2HR.Reg) & 0x80000000) >> 31
}

// Ethernet.MACA2LR: Ethernet MAC address 2 low register
func (o *Ethernet_Type) SetMACA2LR(value uint32) {
	volatile.StoreUint32(&o.MACA2LR.Reg, value)
}
func (o *Ethernet_Type) GetMACA2LR() uint32 {
	return volatile.LoadUint32(&o.MACA2LR.Reg)
}

// Ethernet.MACA3HR: Ethernet MAC address 3 high register
func (o *Ethernet_Type) SetMACA3HR_MACA3H(value uint32) {
	volatile.StoreUint32(&o.MACA3HR.Reg, volatile.LoadUint32(&o.MACA3HR.Reg)&^(0xffff)|value)
}
func (o *Ethernet_Type) GetMACA3HR_MACA3H() uint32 {
	return volatile.LoadUint32(&o.MACA3HR.Reg) & 0xffff
}
func (o *Ethernet_Type) SetMACA3HR_MBC(value uint32) {
	volatile.StoreUint32(&o.MACA3HR.Reg, volatile.LoadUint32(&o.MACA3HR.Reg)&^(0x3f000000)|value<<24)
}
func (o *Ethernet_Type) GetMACA3HR_MBC() uint32 {
	return (volatile.LoadUint32(&o.MACA3HR.Reg) & 0x3f000000) >> 24
}
func (o *Ethernet_Type) SetMACA3HR_SA(value uint32) {
	volatile.StoreUint32(&o.MACA3HR.Reg, volatile.LoadUint32(&o.MACA3HR.Reg)&^(0x40000000)|value<<30)
}
func (o *Ethernet_Type) GetMACA3HR_SA() uint32 {
	return (volatile.LoadUint32(&o.MACA3HR.Reg) & 0x40000000) >> 30
}
func (o *Ethernet_Type) SetMACA3HR_AE(value uint32) {
	volatile.StoreUint32(&o.MACA3HR.Reg, volatile.LoadUint32(&o.MACA3HR.Reg)&^(0x80000000)|value<<31)
}
func (o *Ethernet_Type) GetMACA3HR_AE() uint32 {
	return (volatile.LoadUint32(&o.MACA3HR.Reg) & 0x80000000) >> 31
}

// Ethernet.MACA3LR: Ethernet MAC address 3 low register
func (o *Ethernet_Type) SetMACA3LR(value uint32) {
	volatile.StoreUint32(&o.MACA3LR.Reg, value)
}
func (o *Ethernet_Type) GetMACA3LR() uint32 {
	return volatile.LoadUint32(&o.MACA3LR.Reg)
}

// Cryptographic processor
type CRC_Type struct {
	DR   volatile.Register32 // 0x0
	IDR  volatile.Register32 // 0x4
	CR   volatile.Register32 // 0x8
	_    [4]byte
	INIT volatile.Register32 // 0x10
	POL  volatile.Register32 // 0x14
}

// CRC.DR: Data register
func (o *CRC_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, value)
}
func (o *CRC_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg)
}

// CRC.IDR: Independent Data register
func (o *CRC_Type) SetIDR(value uint32) {
	volatile.StoreUint32(&o.IDR.Reg, volatile.LoadUint32(&o.IDR.Reg)&^(0xff)|value)
}
func (o *CRC_Type) GetIDR() uint32 {
	return volatile.LoadUint32(&o.IDR.Reg) & 0xff
}

// CRC.CR: Control register
func (o *CRC_Type) SetCR_RESET(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *CRC_Type) GetCR_RESET() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *CRC_Type) SetCR_REV_OUT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *CRC_Type) GetCR_REV_OUT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *CRC_Type) SetCR_REV_IN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x60)|value<<5)
}
func (o *CRC_Type) GetCR_REV_IN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x60) >> 5
}
func (o *CRC_Type) SetCR_POLYSIZE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x18)|value<<3)
}
func (o *CRC_Type) GetCR_POLYSIZE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x18) >> 3
}

// CRC.INIT: Initial CRC value
func (o *CRC_Type) SetINIT(value uint32) {
	volatile.StoreUint32(&o.INIT.Reg, value)
}
func (o *CRC_Type) GetINIT() uint32 {
	return volatile.LoadUint32(&o.INIT.Reg)
}

// CRC.POL: CRC polynomial
func (o *CRC_Type) SetPOL(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, value)
}
func (o *CRC_Type) GetPOL() uint32 {
	return volatile.LoadUint32(&o.POL.Reg)
}

// Controller area network
type CAN_Type struct {
	MCR   volatile.Register32 // 0x0
	MSR   volatile.Register32 // 0x4
	TSR   volatile.Register32 // 0x8
	RF0R  volatile.Register32 // 0xC
	RF1R  volatile.Register32 // 0x10
	IER   volatile.Register32 // 0x14
	ESR   volatile.Register32 // 0x18
	BTR   volatile.Register32 // 0x1C
	_     [352]byte
	TX    [3]CAN_TX_Type // 0x180
	RX    [2]CAN_RX_Type // 0x1B0
	_     [48]byte
	FMR   volatile.Register32 // 0x200
	FM1R  volatile.Register32 // 0x204
	_     [4]byte
	FS1R  volatile.Register32 // 0x20C
	_     [4]byte
	FFA1R volatile.Register32 // 0x214
	_     [4]byte
	FA1R  volatile.Register32 // 0x21C
	_     [32]byte
	FB    [28]CAN_FB_Type // 0x240
}

// CAN.MCR: master control register
func (o *CAN_Type) SetMCR_DBF(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetMCR_DBF() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetMCR_RESET(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetMCR_RESET() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetMCR_TTCM(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetMCR_TTCM() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetMCR_ABOM(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetMCR_ABOM() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetMCR_AWUM(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetMCR_AWUM() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetMCR_NART(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetMCR_NART() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetMCR_RFLM(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetMCR_RFLM() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetMCR_TXFP(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetMCR_TXFP() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetMCR_SLEEP(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetMCR_SLEEP() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetMCR_INRQ(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetMCR_INRQ() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x1
}

// CAN.MSR: master status register
func (o *CAN_Type) SetMSR_RX(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetMSR_RX() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetMSR_SAMP(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetMSR_SAMP() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetMSR_RXM(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetMSR_RXM() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetMSR_TXM(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetMSR_TXM() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetMSR_SLAKI(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetMSR_SLAKI() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetMSR_WKUI(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetMSR_WKUI() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetMSR_ERRI(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetMSR_ERRI() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetMSR_SLAK(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetMSR_SLAK() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetMSR_INAK(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetMSR_INAK() uint32 {
	return volatile.LoadUint32(&o.MSR.Reg) & 0x1
}

// CAN.TSR: transmit status register
func (o *CAN_Type) SetTSR_LOW2(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetTSR_LOW2() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x80000000) >> 31
}
func (o *CAN_Type) SetTSR_LOW1(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetTSR_LOW1() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetTSR_LOW0(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN_Type) GetTSR_LOW0() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x20000000) >> 29
}
func (o *CAN_Type) SetTSR_TME2(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN_Type) GetTSR_TME2() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x10000000) >> 28
}
func (o *CAN_Type) SetTSR_TME1(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetTSR_TME1() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x8000000) >> 27
}
func (o *CAN_Type) SetTSR_TME0(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetTSR_TME0() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetTSR_CODE(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x3000000)|value<<24)
}
func (o *CAN_Type) GetTSR_CODE() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x3000000) >> 24
}
func (o *CAN_Type) SetTSR_ABRQ2(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetTSR_ABRQ2() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetTSR_TERR2(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetTSR_TERR2() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetTSR_ALST2(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetTSR_ALST2() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetTSR_TXOK2(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetTSR_TXOK2() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetTSR_RQCP2(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetTSR_RQCP2() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetTSR_ABRQ1(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetTSR_ABRQ1() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetTSR_TERR1(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetTSR_TERR1() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetTSR_ALST1(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetTSR_ALST1() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetTSR_TXOK1(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetTSR_TXOK1() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetTSR_RQCP1(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetTSR_RQCP1() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetTSR_ABRQ0(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetTSR_ABRQ0() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetTSR_TERR0(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetTSR_TERR0() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetTSR_ALST0(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetTSR_ALST0() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetTSR_TXOK0(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetTSR_TXOK0() uint32 {
	return (volatile.LoadUint32(&o.TSR.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetTSR_RQCP0(value uint32) {
	volatile.StoreUint32(&o.TSR.Reg, volatile.LoadUint32(&o.TSR.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetTSR_RQCP0() uint32 {
	return volatile.LoadUint32(&o.TSR.Reg) & 0x1
}

// CAN.RF0R: receive FIFO %s register
func (o *CAN_Type) SetRF0R_RFOM(value uint32) {
	volatile.StoreUint32(&o.RF0R.Reg, volatile.LoadUint32(&o.RF0R.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRF0R_RFOM() uint32 {
	return (volatile.LoadUint32(&o.RF0R.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRF0R_FOVR(value uint32) {
	volatile.StoreUint32(&o.RF0R.Reg, volatile.LoadUint32(&o.RF0R.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRF0R_FOVR() uint32 {
	return (volatile.LoadUint32(&o.RF0R.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRF0R_FULL(value uint32) {
	volatile.StoreUint32(&o.RF0R.Reg, volatile.LoadUint32(&o.RF0R.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRF0R_FULL() uint32 {
	return (volatile.LoadUint32(&o.RF0R.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRF0R_FMP(value uint32) {
	volatile.StoreUint32(&o.RF0R.Reg, volatile.LoadUint32(&o.RF0R.Reg)&^(0x3)|value)
}
func (o *CAN_Type) GetRF0R_FMP() uint32 {
	return volatile.LoadUint32(&o.RF0R.Reg) & 0x3
}

// CAN.RF1R: receive FIFO %s register
func (o *CAN_Type) SetRF1R_RFOM(value uint32) {
	volatile.StoreUint32(&o.RF1R.Reg, volatile.LoadUint32(&o.RF1R.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetRF1R_RFOM() uint32 {
	return (volatile.LoadUint32(&o.RF1R.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetRF1R_FOVR(value uint32) {
	volatile.StoreUint32(&o.RF1R.Reg, volatile.LoadUint32(&o.RF1R.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetRF1R_FOVR() uint32 {
	return (volatile.LoadUint32(&o.RF1R.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetRF1R_FULL(value uint32) {
	volatile.StoreUint32(&o.RF1R.Reg, volatile.LoadUint32(&o.RF1R.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetRF1R_FULL() uint32 {
	return (volatile.LoadUint32(&o.RF1R.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetRF1R_FMP(value uint32) {
	volatile.StoreUint32(&o.RF1R.Reg, volatile.LoadUint32(&o.RF1R.Reg)&^(0x3)|value)
}
func (o *CAN_Type) GetRF1R_FMP() uint32 {
	return volatile.LoadUint32(&o.RF1R.Reg) & 0x3
}

// CAN.IER: interrupt enable register
func (o *CAN_Type) SetIER_SLKIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetIER_SLKIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetIER_WKUIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetIER_WKUIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetIER_ERRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetIER_ERRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetIER_LECIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetIER_LECIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetIER_BOFIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetIER_BOFIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetIER_EPVIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetIER_EPVIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetIER_EWGIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetIER_EWGIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetIER_FOVIE1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetIER_FOVIE1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetIER_FFIE1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetIER_FFIE1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetIER_FMPIE1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetIER_FMPIE1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetIER_FOVIE0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetIER_FOVIE0() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetIER_FFIE0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetIER_FFIE0() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetIER_FMPIE0(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetIER_FMPIE0() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetIER_TMEIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetIER_TMEIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// CAN.ESR: interrupt enable register
func (o *CAN_Type) SetESR_REC(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetESR_REC() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0xff000000) >> 24
}
func (o *CAN_Type) SetESR_TEC(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetESR_TEC() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetESR_LEC(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x70)|value<<4)
}
func (o *CAN_Type) GetESR_LEC() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x70) >> 4
}
func (o *CAN_Type) SetESR_BOFF(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetESR_BOFF() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetESR_EPVF(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetESR_EPVF() uint32 {
	return (volatile.LoadUint32(&o.ESR.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetESR_EWGF(value uint32) {
	volatile.StoreUint32(&o.ESR.Reg, volatile.LoadUint32(&o.ESR.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetESR_EWGF() uint32 {
	return volatile.LoadUint32(&o.ESR.Reg) & 0x1
}

// CAN.BTR: bit timing register
func (o *CAN_Type) SetBTR_SILM(value uint32) {
	volatile.StoreUint32(&o.BTR.Reg, volatile.LoadUint32(&o.BTR.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetBTR_SILM() uint32 {
	return (volatile.LoadUint32(&o.BTR.Reg) & 0x80000000) >> 31
}
func (o *CAN_Type) SetBTR_LBKM(value uint32) {
	volatile.StoreUint32(&o.BTR.Reg, volatile.LoadUint32(&o.BTR.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetBTR_LBKM() uint32 {
	return (volatile.LoadUint32(&o.BTR.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetBTR_SJW(value uint32) {
	volatile.StoreUint32(&o.BTR.Reg, volatile.LoadUint32(&o.BTR.Reg)&^(0x3000000)|value<<24)
}
func (o *CAN_Type) GetBTR_SJW() uint32 {
	return (volatile.LoadUint32(&o.BTR.Reg) & 0x3000000) >> 24
}
func (o *CAN_Type) SetBTR_TS2(value uint32) {
	volatile.StoreUint32(&o.BTR.Reg, volatile.LoadUint32(&o.BTR.Reg)&^(0x700000)|value<<20)
}
func (o *CAN_Type) GetBTR_TS2() uint32 {
	return (volatile.LoadUint32(&o.BTR.Reg) & 0x700000) >> 20
}
func (o *CAN_Type) SetBTR_TS1(value uint32) {
	volatile.StoreUint32(&o.BTR.Reg, volatile.LoadUint32(&o.BTR.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetBTR_TS1() uint32 {
	return (volatile.LoadUint32(&o.BTR.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetBTR_BRP(value uint32) {
	volatile.StoreUint32(&o.BTR.Reg, volatile.LoadUint32(&o.BTR.Reg)&^(0x3ff)|value)
}
func (o *CAN_Type) GetBTR_BRP() uint32 {
	return volatile.LoadUint32(&o.BTR.Reg) & 0x3ff
}

// CAN.FMR: filter master register
func (o *CAN_Type) SetFMR_CAN2SB(value uint32) {
	volatile.StoreUint32(&o.FMR.Reg, volatile.LoadUint32(&o.FMR.Reg)&^(0x3f00)|value<<8)
}
func (o *CAN_Type) GetFMR_CAN2SB() uint32 {
	return (volatile.LoadUint32(&o.FMR.Reg) & 0x3f00) >> 8
}
func (o *CAN_Type) SetFMR_FINIT(value uint32) {
	volatile.StoreUint32(&o.FMR.Reg, volatile.LoadUint32(&o.FMR.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetFMR_FINIT() uint32 {
	return volatile.LoadUint32(&o.FMR.Reg) & 0x1
}

// CAN.FM1R: filter mode register
func (o *CAN_Type) SetFM1R_FBM0(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetFM1R_FBM0() uint32 {
	return volatile.LoadUint32(&o.FM1R.Reg) & 0x1
}
func (o *CAN_Type) SetFM1R_FBM1(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetFM1R_FBM1() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetFM1R_FBM2(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetFM1R_FBM2() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetFM1R_FBM3(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetFM1R_FBM3() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetFM1R_FBM4(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetFM1R_FBM4() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetFM1R_FBM5(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetFM1R_FBM5() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetFM1R_FBM6(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetFM1R_FBM6() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetFM1R_FBM7(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetFM1R_FBM7() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetFM1R_FBM8(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetFM1R_FBM8() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetFM1R_FBM9(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetFM1R_FBM9() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetFM1R_FBM10(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetFM1R_FBM10() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetFM1R_FBM11(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetFM1R_FBM11() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetFM1R_FBM12(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetFM1R_FBM12() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetFM1R_FBM13(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetFM1R_FBM13() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetFM1R_FBM14(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetFM1R_FBM14() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetFM1R_FBM15(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetFM1R_FBM15() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetFM1R_FBM16(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetFM1R_FBM16() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetFM1R_FBM17(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetFM1R_FBM17() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetFM1R_FBM18(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetFM1R_FBM18() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetFM1R_FBM19(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetFM1R_FBM19() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetFM1R_FBM20(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetFM1R_FBM20() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetFM1R_FBM21(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetFM1R_FBM21() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetFM1R_FBM22(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetFM1R_FBM22() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetFM1R_FBM23(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetFM1R_FBM23() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetFM1R_FBM24(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetFM1R_FBM24() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetFM1R_FBM25(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetFM1R_FBM25() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetFM1R_FBM26(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetFM1R_FBM26() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetFM1R_FBM27(value uint32) {
	volatile.StoreUint32(&o.FM1R.Reg, volatile.LoadUint32(&o.FM1R.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetFM1R_FBM27() uint32 {
	return (volatile.LoadUint32(&o.FM1R.Reg) & 0x8000000) >> 27
}

// CAN.FS1R: filter scale register
func (o *CAN_Type) SetFS1R_FSC0(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetFS1R_FSC0() uint32 {
	return volatile.LoadUint32(&o.FS1R.Reg) & 0x1
}
func (o *CAN_Type) SetFS1R_FSC1(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetFS1R_FSC1() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetFS1R_FSC2(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetFS1R_FSC2() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetFS1R_FSC3(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetFS1R_FSC3() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetFS1R_FSC4(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetFS1R_FSC4() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetFS1R_FSC5(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetFS1R_FSC5() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetFS1R_FSC6(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetFS1R_FSC6() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetFS1R_FSC7(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetFS1R_FSC7() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetFS1R_FSC8(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetFS1R_FSC8() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetFS1R_FSC9(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetFS1R_FSC9() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetFS1R_FSC10(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetFS1R_FSC10() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetFS1R_FSC11(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetFS1R_FSC11() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetFS1R_FSC12(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetFS1R_FSC12() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetFS1R_FSC13(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetFS1R_FSC13() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetFS1R_FSC14(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetFS1R_FSC14() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetFS1R_FSC15(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetFS1R_FSC15() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetFS1R_FSC16(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetFS1R_FSC16() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetFS1R_FSC17(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetFS1R_FSC17() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetFS1R_FSC18(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetFS1R_FSC18() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetFS1R_FSC19(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetFS1R_FSC19() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetFS1R_FSC20(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetFS1R_FSC20() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetFS1R_FSC21(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetFS1R_FSC21() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetFS1R_FSC22(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetFS1R_FSC22() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetFS1R_FSC23(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetFS1R_FSC23() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetFS1R_FSC24(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetFS1R_FSC24() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetFS1R_FSC25(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetFS1R_FSC25() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetFS1R_FSC26(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetFS1R_FSC26() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetFS1R_FSC27(value uint32) {
	volatile.StoreUint32(&o.FS1R.Reg, volatile.LoadUint32(&o.FS1R.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetFS1R_FSC27() uint32 {
	return (volatile.LoadUint32(&o.FS1R.Reg) & 0x8000000) >> 27
}

// CAN.FFA1R: filter FIFO assignment register
func (o *CAN_Type) SetFFA1R_FFA0(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetFFA1R_FFA0() uint32 {
	return volatile.LoadUint32(&o.FFA1R.Reg) & 0x1
}
func (o *CAN_Type) SetFFA1R_FFA1(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetFFA1R_FFA1() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetFFA1R_FFA2(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetFFA1R_FFA2() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetFFA1R_FFA3(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetFFA1R_FFA3() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetFFA1R_FFA4(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetFFA1R_FFA4() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetFFA1R_FFA5(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetFFA1R_FFA5() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetFFA1R_FFA6(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetFFA1R_FFA6() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetFFA1R_FFA7(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetFFA1R_FFA7() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetFFA1R_FFA8(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetFFA1R_FFA8() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetFFA1R_FFA9(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetFFA1R_FFA9() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetFFA1R_FFA10(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetFFA1R_FFA10() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetFFA1R_FFA11(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetFFA1R_FFA11() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetFFA1R_FFA12(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetFFA1R_FFA12() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetFFA1R_FFA13(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetFFA1R_FFA13() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetFFA1R_FFA14(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetFFA1R_FFA14() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetFFA1R_FFA15(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetFFA1R_FFA15() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetFFA1R_FFA16(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetFFA1R_FFA16() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetFFA1R_FFA17(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetFFA1R_FFA17() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetFFA1R_FFA18(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetFFA1R_FFA18() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetFFA1R_FFA19(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetFFA1R_FFA19() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetFFA1R_FFA20(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetFFA1R_FFA20() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetFFA1R_FFA21(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetFFA1R_FFA21() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetFFA1R_FFA22(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetFFA1R_FFA22() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetFFA1R_FFA23(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetFFA1R_FFA23() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetFFA1R_FFA24(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetFFA1R_FFA24() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetFFA1R_FFA25(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetFFA1R_FFA25() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetFFA1R_FFA26(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetFFA1R_FFA26() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetFFA1R_FFA27(value uint32) {
	volatile.StoreUint32(&o.FFA1R.Reg, volatile.LoadUint32(&o.FFA1R.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetFFA1R_FFA27() uint32 {
	return (volatile.LoadUint32(&o.FFA1R.Reg) & 0x8000000) >> 27
}

// CAN.FA1R: filter activation register
func (o *CAN_Type) SetFA1R_FACT0(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetFA1R_FACT0() uint32 {
	return volatile.LoadUint32(&o.FA1R.Reg) & 0x1
}
func (o *CAN_Type) SetFA1R_FACT1(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetFA1R_FACT1() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetFA1R_FACT2(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetFA1R_FACT2() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetFA1R_FACT3(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetFA1R_FACT3() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetFA1R_FACT4(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetFA1R_FACT4() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetFA1R_FACT5(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetFA1R_FACT5() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetFA1R_FACT6(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetFA1R_FACT6() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetFA1R_FACT7(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetFA1R_FACT7() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetFA1R_FACT8(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetFA1R_FACT8() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetFA1R_FACT9(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetFA1R_FACT9() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetFA1R_FACT10(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetFA1R_FACT10() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetFA1R_FACT11(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetFA1R_FACT11() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetFA1R_FACT12(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetFA1R_FACT12() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetFA1R_FACT13(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetFA1R_FACT13() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetFA1R_FACT14(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetFA1R_FACT14() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetFA1R_FACT15(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetFA1R_FACT15() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetFA1R_FACT16(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetFA1R_FACT16() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetFA1R_FACT17(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetFA1R_FACT17() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetFA1R_FACT18(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetFA1R_FACT18() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetFA1R_FACT19(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetFA1R_FACT19() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetFA1R_FACT20(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetFA1R_FACT20() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetFA1R_FACT21(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetFA1R_FACT21() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetFA1R_FACT22(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetFA1R_FACT22() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetFA1R_FACT23(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetFA1R_FACT23() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetFA1R_FACT24(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN_Type) GetFA1R_FACT24() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x1000000) >> 24
}
func (o *CAN_Type) SetFA1R_FACT25(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN_Type) GetFA1R_FACT25() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x2000000) >> 25
}
func (o *CAN_Type) SetFA1R_FACT26(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN_Type) GetFA1R_FACT26() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x4000000) >> 26
}
func (o *CAN_Type) SetFA1R_FACT27(value uint32) {
	volatile.StoreUint32(&o.FA1R.Reg, volatile.LoadUint32(&o.FA1R.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN_Type) GetFA1R_FACT27() uint32 {
	return (volatile.LoadUint32(&o.FA1R.Reg) & 0x8000000) >> 27
}

type CAN_TX_Type struct {
	TIR  volatile.Register32 // 0x180
	TDTR volatile.Register32 // 0x184
	TDLR volatile.Register32 // 0x188
	TDHR volatile.Register32 // 0x18C
}

// CAN_TX.TIR: TX mailbox identifier register
func (o *CAN_TX_Type) SetTIR_STID(value uint32) {
	volatile.StoreUint32(&o.TIR.Reg, volatile.LoadUint32(&o.TIR.Reg)&^(0xffe00000)|value<<21)
}
func (o *CAN_TX_Type) GetTIR_STID() uint32 {
	return (volatile.LoadUint32(&o.TIR.Reg) & 0xffe00000) >> 21
}
func (o *CAN_TX_Type) SetTIR_EXID(value uint32) {
	volatile.StoreUint32(&o.TIR.Reg, volatile.LoadUint32(&o.TIR.Reg)&^(0x1ffff8)|value<<3)
}
func (o *CAN_TX_Type) GetTIR_EXID() uint32 {
	return (volatile.LoadUint32(&o.TIR.Reg) & 0x1ffff8) >> 3
}
func (o *CAN_TX_Type) SetTIR_IDE(value uint32) {
	volatile.StoreUint32(&o.TIR.Reg, volatile.LoadUint32(&o.TIR.Reg)&^(0x4)|value<<2)
}
func (o *CAN_TX_Type) GetTIR_IDE() uint32 {
	return (volatile.LoadUint32(&o.TIR.Reg) & 0x4) >> 2
}
func (o *CAN_TX_Type) SetTIR_RTR(value uint32) {
	volatile.StoreUint32(&o.TIR.Reg, volatile.LoadUint32(&o.TIR.Reg)&^(0x2)|value<<1)
}
func (o *CAN_TX_Type) GetTIR_RTR() uint32 {
	return (volatile.LoadUint32(&o.TIR.Reg) & 0x2) >> 1
}
func (o *CAN_TX_Type) SetTIR_TXRQ(value uint32) {
	volatile.StoreUint32(&o.TIR.Reg, volatile.LoadUint32(&o.TIR.Reg)&^(0x1)|value)
}
func (o *CAN_TX_Type) GetTIR_TXRQ() uint32 {
	return volatile.LoadUint32(&o.TIR.Reg) & 0x1
}

// CAN_TX.TDTR: mailbox data length control and time stamp register
func (o *CAN_TX_Type) SetTDTR_TIME(value uint32) {
	volatile.StoreUint32(&o.TDTR.Reg, volatile.LoadUint32(&o.TDTR.Reg)&^(0xffff0000)|value<<16)
}
func (o *CAN_TX_Type) GetTDTR_TIME() uint32 {
	return (volatile.LoadUint32(&o.TDTR.Reg) & 0xffff0000) >> 16
}
func (o *CAN_TX_Type) SetTDTR_TGT(value uint32) {
	volatile.StoreUint32(&o.TDTR.Reg, volatile.LoadUint32(&o.TDTR.Reg)&^(0x100)|value<<8)
}
func (o *CAN_TX_Type) GetTDTR_TGT() uint32 {
	return (volatile.LoadUint32(&o.TDTR.Reg) & 0x100) >> 8
}
func (o *CAN_TX_Type) SetTDTR_DLC(value uint32) {
	volatile.StoreUint32(&o.TDTR.Reg, volatile.LoadUint32(&o.TDTR.Reg)&^(0xf)|value)
}
func (o *CAN_TX_Type) GetTDTR_DLC() uint32 {
	return volatile.LoadUint32(&o.TDTR.Reg) & 0xf
}

// CAN_TX.TDLR: mailbox data low register
func (o *CAN_TX_Type) SetTDLR_DATA3(value uint32) {
	volatile.StoreUint32(&o.TDLR.Reg, volatile.LoadUint32(&o.TDLR.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_TX_Type) GetTDLR_DATA3() uint32 {
	return (volatile.LoadUint32(&o.TDLR.Reg) & 0xff000000) >> 24
}
func (o *CAN_TX_Type) SetTDLR_DATA2(value uint32) {
	volatile.StoreUint32(&o.TDLR.Reg, volatile.LoadUint32(&o.TDLR.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_TX_Type) GetTDLR_DATA2() uint32 {
	return (volatile.LoadUint32(&o.TDLR.Reg) & 0xff0000) >> 16
}
func (o *CAN_TX_Type) SetTDLR_DATA1(value uint32) {
	volatile.StoreUint32(&o.TDLR.Reg, volatile.LoadUint32(&o.TDLR.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_TX_Type) GetTDLR_DATA1() uint32 {
	return (volatile.LoadUint32(&o.TDLR.Reg) & 0xff00) >> 8
}
func (o *CAN_TX_Type) SetTDLR_DATA0(value uint32) {
	volatile.StoreUint32(&o.TDLR.Reg, volatile.LoadUint32(&o.TDLR.Reg)&^(0xff)|value)
}
func (o *CAN_TX_Type) GetTDLR_DATA0() uint32 {
	return volatile.LoadUint32(&o.TDLR.Reg) & 0xff
}

// CAN_TX.TDHR: mailbox data high register
func (o *CAN_TX_Type) SetTDHR_DATA7(value uint32) {
	volatile.StoreUint32(&o.TDHR.Reg, volatile.LoadUint32(&o.TDHR.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_TX_Type) GetTDHR_DATA7() uint32 {
	return (volatile.LoadUint32(&o.TDHR.Reg) & 0xff000000) >> 24
}
func (o *CAN_TX_Type) SetTDHR_DATA6(value uint32) {
	volatile.StoreUint32(&o.TDHR.Reg, volatile.LoadUint32(&o.TDHR.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_TX_Type) GetTDHR_DATA6() uint32 {
	return (volatile.LoadUint32(&o.TDHR.Reg) & 0xff0000) >> 16
}
func (o *CAN_TX_Type) SetTDHR_DATA5(value uint32) {
	volatile.StoreUint32(&o.TDHR.Reg, volatile.LoadUint32(&o.TDHR.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_TX_Type) GetTDHR_DATA5() uint32 {
	return (volatile.LoadUint32(&o.TDHR.Reg) & 0xff00) >> 8
}
func (o *CAN_TX_Type) SetTDHR_DATA4(value uint32) {
	volatile.StoreUint32(&o.TDHR.Reg, volatile.LoadUint32(&o.TDHR.Reg)&^(0xff)|value)
}
func (o *CAN_TX_Type) GetTDHR_DATA4() uint32 {
	return volatile.LoadUint32(&o.TDHR.Reg) & 0xff
}

type CAN_RX_Type struct {
	RIR  volatile.Register32 // 0x1B0
	RDTR volatile.Register32 // 0x1B4
	RDLR volatile.Register32 // 0x1B8
	RDHR volatile.Register32 // 0x1BC
}

// CAN_RX.RIR: receive FIFO mailbox identifier register
func (o *CAN_RX_Type) SetRIR_STID(value uint32) {
	volatile.StoreUint32(&o.RIR.Reg, volatile.LoadUint32(&o.RIR.Reg)&^(0xffe00000)|value<<21)
}
func (o *CAN_RX_Type) GetRIR_STID() uint32 {
	return (volatile.LoadUint32(&o.RIR.Reg) & 0xffe00000) >> 21
}
func (o *CAN_RX_Type) SetRIR_EXID(value uint32) {
	volatile.StoreUint32(&o.RIR.Reg, volatile.LoadUint32(&o.RIR.Reg)&^(0x1ffff8)|value<<3)
}
func (o *CAN_RX_Type) GetRIR_EXID() uint32 {
	return (volatile.LoadUint32(&o.RIR.Reg) & 0x1ffff8) >> 3
}
func (o *CAN_RX_Type) SetRIR_IDE(value uint32) {
	volatile.StoreUint32(&o.RIR.Reg, volatile.LoadUint32(&o.RIR.Reg)&^(0x4)|value<<2)
}
func (o *CAN_RX_Type) GetRIR_IDE() uint32 {
	return (volatile.LoadUint32(&o.RIR.Reg) & 0x4) >> 2
}
func (o *CAN_RX_Type) SetRIR_RTR(value uint32) {
	volatile.StoreUint32(&o.RIR.Reg, volatile.LoadUint32(&o.RIR.Reg)&^(0x2)|value<<1)
}
func (o *CAN_RX_Type) GetRIR_RTR() uint32 {
	return (volatile.LoadUint32(&o.RIR.Reg) & 0x2) >> 1
}

// CAN_RX.RDTR: mailbox data high register
func (o *CAN_RX_Type) SetRDTR_TIME(value uint32) {
	volatile.StoreUint32(&o.RDTR.Reg, volatile.LoadUint32(&o.RDTR.Reg)&^(0xffff0000)|value<<16)
}
func (o *CAN_RX_Type) GetRDTR_TIME() uint32 {
	return (volatile.LoadUint32(&o.RDTR.Reg) & 0xffff0000) >> 16
}
func (o *CAN_RX_Type) SetRDTR_FMI(value uint32) {
	volatile.StoreUint32(&o.RDTR.Reg, volatile.LoadUint32(&o.RDTR.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_RX_Type) GetRDTR_FMI() uint32 {
	return (volatile.LoadUint32(&o.RDTR.Reg) & 0xff00) >> 8
}
func (o *CAN_RX_Type) SetRDTR_DLC(value uint32) {
	volatile.StoreUint32(&o.RDTR.Reg, volatile.LoadUint32(&o.RDTR.Reg)&^(0xf)|value)
}
func (o *CAN_RX_Type) GetRDTR_DLC() uint32 {
	return volatile.LoadUint32(&o.RDTR.Reg) & 0xf
}

// CAN_RX.RDLR: mailbox data high register
func (o *CAN_RX_Type) SetRDLR_DATA3(value uint32) {
	volatile.StoreUint32(&o.RDLR.Reg, volatile.LoadUint32(&o.RDLR.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_RX_Type) GetRDLR_DATA3() uint32 {
	return (volatile.LoadUint32(&o.RDLR.Reg) & 0xff000000) >> 24
}
func (o *CAN_RX_Type) SetRDLR_DATA2(value uint32) {
	volatile.StoreUint32(&o.RDLR.Reg, volatile.LoadUint32(&o.RDLR.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_RX_Type) GetRDLR_DATA2() uint32 {
	return (volatile.LoadUint32(&o.RDLR.Reg) & 0xff0000) >> 16
}
func (o *CAN_RX_Type) SetRDLR_DATA1(value uint32) {
	volatile.StoreUint32(&o.RDLR.Reg, volatile.LoadUint32(&o.RDLR.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_RX_Type) GetRDLR_DATA1() uint32 {
	return (volatile.LoadUint32(&o.RDLR.Reg) & 0xff00) >> 8
}
func (o *CAN_RX_Type) SetRDLR_DATA0(value uint32) {
	volatile.StoreUint32(&o.RDLR.Reg, volatile.LoadUint32(&o.RDLR.Reg)&^(0xff)|value)
}
func (o *CAN_RX_Type) GetRDLR_DATA0() uint32 {
	return volatile.LoadUint32(&o.RDLR.Reg) & 0xff
}

// CAN_RX.RDHR: receive FIFO mailbox data high register
func (o *CAN_RX_Type) SetRDHR_DATA7(value uint32) {
	volatile.StoreUint32(&o.RDHR.Reg, volatile.LoadUint32(&o.RDHR.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_RX_Type) GetRDHR_DATA7() uint32 {
	return (volatile.LoadUint32(&o.RDHR.Reg) & 0xff000000) >> 24
}
func (o *CAN_RX_Type) SetRDHR_DATA6(value uint32) {
	volatile.StoreUint32(&o.RDHR.Reg, volatile.LoadUint32(&o.RDHR.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_RX_Type) GetRDHR_DATA6() uint32 {
	return (volatile.LoadUint32(&o.RDHR.Reg) & 0xff0000) >> 16
}
func (o *CAN_RX_Type) SetRDHR_DATA5(value uint32) {
	volatile.StoreUint32(&o.RDHR.Reg, volatile.LoadUint32(&o.RDHR.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_RX_Type) GetRDHR_DATA5() uint32 {
	return (volatile.LoadUint32(&o.RDHR.Reg) & 0xff00) >> 8
}
func (o *CAN_RX_Type) SetRDHR_DATA4(value uint32) {
	volatile.StoreUint32(&o.RDHR.Reg, volatile.LoadUint32(&o.RDHR.Reg)&^(0xff)|value)
}
func (o *CAN_RX_Type) GetRDHR_DATA4() uint32 {
	return volatile.LoadUint32(&o.RDHR.Reg) & 0xff
}

type CAN_FB_Type struct {
	FR1 volatile.Register32 // 0x240
	FR2 volatile.Register32 // 0x244
}

// CAN_FB.FR1: Filter bank 0 register 1
func (o *CAN_FB_Type) SetFR1(value uint32) {
	volatile.StoreUint32(&o.FR1.Reg, value)
}
func (o *CAN_FB_Type) GetFR1() uint32 {
	return volatile.LoadUint32(&o.FR1.Reg)
}

// CAN_FB.FR2: Filter bank 0 register 2
func (o *CAN_FB_Type) SetFR2(value uint32) {
	volatile.StoreUint32(&o.FR2.Reg, value)
}
func (o *CAN_FB_Type) GetFR2() uint32 {
	return volatile.LoadUint32(&o.FR2.Reg)
}

// FLASH
type FLASH_Type struct {
	ACR     volatile.Register32 // 0x0
	KEYR    volatile.Register32 // 0x4
	OPTKEYR volatile.Register32 // 0x8
	SR      volatile.Register32 // 0xC
	CR      volatile.Register32 // 0x10
	OPTCR   volatile.Register32 // 0x14
	OPTCR1  volatile.Register32 // 0x18
}

// FLASH.ACR: Flash access control register
func (o *FLASH_Type) SetACR_LATENCY(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0xf)|value)
}
func (o *FLASH_Type) GetACR_LATENCY() uint32 {
	return volatile.LoadUint32(&o.ACR.Reg) & 0xf
}
func (o *FLASH_Type) SetACR_PRFTEN(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x100)|value<<8)
}
func (o *FLASH_Type) GetACR_PRFTEN() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x100) >> 8
}
func (o *FLASH_Type) SetACR_ARTEN(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x200)|value<<9)
}
func (o *FLASH_Type) GetACR_ARTEN() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x200) >> 9
}
func (o *FLASH_Type) SetACR_ARTRST(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x800)|value<<11)
}
func (o *FLASH_Type) GetACR_ARTRST() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x800) >> 11
}

// FLASH.KEYR: Flash key register
func (o *FLASH_Type) SetKEYR(value uint32) {
	volatile.StoreUint32(&o.KEYR.Reg, value)
}
func (o *FLASH_Type) GetKEYR() uint32 {
	return volatile.LoadUint32(&o.KEYR.Reg)
}

// FLASH.OPTKEYR: Flash option key register
func (o *FLASH_Type) SetOPTKEYR(value uint32) {
	volatile.StoreUint32(&o.OPTKEYR.Reg, value)
}
func (o *FLASH_Type) GetOPTKEYR() uint32 {
	return volatile.LoadUint32(&o.OPTKEYR.Reg)
}

// FLASH.SR: Status register
func (o *FLASH_Type) SetSR_EOP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *FLASH_Type) GetSR_EOP() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *FLASH_Type) SetSR_OPERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *FLASH_Type) GetSR_OPERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *FLASH_Type) SetSR_WRPERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *FLASH_Type) GetSR_WRPERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *FLASH_Type) SetSR_PGAERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *FLASH_Type) GetSR_PGAERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *FLASH_Type) SetSR_PGPERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *FLASH_Type) GetSR_PGPERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *FLASH_Type) SetSR_ERSERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *FLASH_Type) GetSR_ERSERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *FLASH_Type) SetSR_BSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *FLASH_Type) GetSR_BSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}

// FLASH.CR: Control register
func (o *FLASH_Type) SetCR_PG(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *FLASH_Type) GetCR_PG() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *FLASH_Type) SetCR_SER(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *FLASH_Type) GetCR_SER() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *FLASH_Type) SetCR_MER1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *FLASH_Type) GetCR_MER1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *FLASH_Type) SetCR_SNB(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf8)|value<<3)
}
func (o *FLASH_Type) GetCR_SNB() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf8) >> 3
}
func (o *FLASH_Type) SetCR_PSIZE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x300)|value<<8)
}
func (o *FLASH_Type) GetCR_PSIZE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x300) >> 8
}
func (o *FLASH_Type) SetCR_MER2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *FLASH_Type) GetCR_MER2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}
func (o *FLASH_Type) SetCR_STRT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *FLASH_Type) GetCR_STRT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *FLASH_Type) SetCR_EOPIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000000)|value<<24)
}
func (o *FLASH_Type) GetCR_EOPIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000000) >> 24
}
func (o *FLASH_Type) SetCR_ERRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000000)|value<<25)
}
func (o *FLASH_Type) GetCR_ERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000000) >> 25
}
func (o *FLASH_Type) SetCR_LOCK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000000)|value<<31)
}
func (o *FLASH_Type) GetCR_LOCK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000000) >> 31
}

// FLASH.OPTCR: Flash option control register
func (o *FLASH_Type) SetOPTCR_OPTLOCK(value uint32) {
	volatile.StoreUint32(&o.OPTCR.Reg, volatile.LoadUint32(&o.OPTCR.Reg)&^(0x1)|value)
}
func (o *FLASH_Type) GetOPTCR_OPTLOCK() uint32 {
	return volatile.LoadUint32(&o.OPTCR.Reg) & 0x1
}
func (o *FLASH_Type) SetOPTCR_OPTSTRT(value uint32) {
	volatile.StoreUint32(&o.OPTCR.Reg, volatile.LoadUint32(&o.OPTCR.Reg)&^(0x2)|value<<1)
}
func (o *FLASH_Type) GetOPTCR_OPTSTRT() uint32 {
	return (volatile.LoadUint32(&o.OPTCR.Reg) & 0x2) >> 1
}
func (o *FLASH_Type) SetOPTCR_BOR_LEV(value uint32) {
	volatile.StoreUint32(&o.OPTCR.Reg, volatile.LoadUint32(&o.OPTCR.Reg)&^(0xc)|value<<2)
}
func (o *FLASH_Type) GetOPTCR_BOR_LEV() uint32 {
	return (volatile.LoadUint32(&o.OPTCR.Reg) & 0xc) >> 2
}
func (o *FLASH_Type) SetOPTCR_WWDG_SW(value uint32) {
	volatile.StoreUint32(&o.OPTCR.Reg, volatile.LoadUint32(&o.OPTCR.Reg)&^(0x10)|value<<4)
}
func (o *FLASH_Type) GetOPTCR_WWDG_SW() uint32 {
	return (volatile.LoadUint32(&o.OPTCR.Reg) & 0x10) >> 4
}
func (o *FLASH_Type) SetOPTCR_IWDG_SW(value uint32) {
	volatile.StoreUint32(&o.OPTCR.Reg, volatile.LoadUint32(&o.OPTCR.Reg)&^(0x20)|value<<5)
}
func (o *FLASH_Type) GetOPTCR_IWDG_SW() uint32 {
	return (volatile.LoadUint32(&o.OPTCR.Reg) & 0x20) >> 5
}
func (o *FLASH_Type) SetOPTCR_NRST_STOP(value uint32) {
	volatile.StoreUint32(&o.OPTCR.Reg, volatile.LoadUint32(&o.OPTCR.Reg)&^(0x40)|value<<6)
}
func (o *FLASH_Type) GetOPTCR_NRST_STOP() uint32 {
	return (volatile.LoadUint32(&o.OPTCR.Reg) & 0x40) >> 6
}
func (o *FLASH_Type) SetOPTCR_NRST_STDBY(value uint32) {
	volatile.StoreUint32(&o.OPTCR.Reg, volatile.LoadUint32(&o.OPTCR.Reg)&^(0x80)|value<<7)
}
func (o *FLASH_Type) GetOPTCR_NRST_STDBY() uint32 {
	return (volatile.LoadUint32(&o.OPTCR.Reg) & 0x80) >> 7
}
func (o *FLASH_Type) SetOPTCR_RDP(value uint32) {
	volatile.StoreUint32(&o.OPTCR.Reg, volatile.LoadUint32(&o.OPTCR.Reg)&^(0xff00)|value<<8)
}
func (o *FLASH_Type) GetOPTCR_RDP() uint32 {
	return (volatile.LoadUint32(&o.OPTCR.Reg) & 0xff00) >> 8
}
func (o *FLASH_Type) SetOPTCR_NWRP(value uint32) {
	volatile.StoreUint32(&o.OPTCR.Reg, volatile.LoadUint32(&o.OPTCR.Reg)&^(0xfff0000)|value<<16)
}
func (o *FLASH_Type) GetOPTCR_NWRP() uint32 {
	return (volatile.LoadUint32(&o.OPTCR.Reg) & 0xfff0000) >> 16
}
func (o *FLASH_Type) SetOPTCR_NDBOOT(value uint32) {
	volatile.StoreUint32(&o.OPTCR.Reg, volatile.LoadUint32(&o.OPTCR.Reg)&^(0x10000000)|value<<28)
}
func (o *FLASH_Type) GetOPTCR_NDBOOT() uint32 {
	return (volatile.LoadUint32(&o.OPTCR.Reg) & 0x10000000) >> 28
}
func (o *FLASH_Type) SetOPTCR_NDBANK(value uint32) {
	volatile.StoreUint32(&o.OPTCR.Reg, volatile.LoadUint32(&o.OPTCR.Reg)&^(0x20000000)|value<<29)
}
func (o *FLASH_Type) GetOPTCR_NDBANK() uint32 {
	return (volatile.LoadUint32(&o.OPTCR.Reg) & 0x20000000) >> 29
}
func (o *FLASH_Type) SetOPTCR_IWDG_STDBY(value uint32) {
	volatile.StoreUint32(&o.OPTCR.Reg, volatile.LoadUint32(&o.OPTCR.Reg)&^(0x40000000)|value<<30)
}
func (o *FLASH_Type) GetOPTCR_IWDG_STDBY() uint32 {
	return (volatile.LoadUint32(&o.OPTCR.Reg) & 0x40000000) >> 30
}
func (o *FLASH_Type) SetOPTCR_IWDG_STOP(value uint32) {
	volatile.StoreUint32(&o.OPTCR.Reg, volatile.LoadUint32(&o.OPTCR.Reg)&^(0x80000000)|value<<31)
}
func (o *FLASH_Type) GetOPTCR_IWDG_STOP() uint32 {
	return (volatile.LoadUint32(&o.OPTCR.Reg) & 0x80000000) >> 31
}

// FLASH.OPTCR1: Flash option control register 1
func (o *FLASH_Type) SetOPTCR1_BOOT_ADD0(value uint32) {
	volatile.StoreUint32(&o.OPTCR1.Reg, volatile.LoadUint32(&o.OPTCR1.Reg)&^(0xffff)|value)
}
func (o *FLASH_Type) GetOPTCR1_BOOT_ADD0() uint32 {
	return volatile.LoadUint32(&o.OPTCR1.Reg) & 0xffff
}
func (o *FLASH_Type) SetOPTCR1_BOOT_ADD1(value uint32) {
	volatile.StoreUint32(&o.OPTCR1.Reg, volatile.LoadUint32(&o.OPTCR1.Reg)&^(0xffff0000)|value<<16)
}
func (o *FLASH_Type) GetOPTCR1_BOOT_ADD1() uint32 {
	return (volatile.LoadUint32(&o.OPTCR1.Reg) & 0xffff0000) >> 16
}

// External interrupt/event controller
type EXTI_Type struct {
	IMR   volatile.Register32 // 0x0
	EMR   volatile.Register32 // 0x4
	RTSR  volatile.Register32 // 0x8
	FTSR  volatile.Register32 // 0xC
	SWIER volatile.Register32 // 0x10
	PR    volatile.Register32 // 0x14
}

// EXTI.IMR: Interrupt mask register (EXTI_IMR)
func (o *EXTI_Type) SetIMR_MR0(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetIMR_MR0() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *EXTI_Type) SetIMR_MR1(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetIMR_MR1() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetIMR_MR2(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetIMR_MR2() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetIMR_MR3(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetIMR_MR3() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetIMR_MR4(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetIMR_MR4() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetIMR_MR5(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetIMR_MR5() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetIMR_MR6(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetIMR_MR6() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetIMR_MR7(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetIMR_MR7() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetIMR_MR8(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetIMR_MR8() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetIMR_MR9(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetIMR_MR9() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetIMR_MR10(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetIMR_MR10() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetIMR_MR11(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetIMR_MR11() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetIMR_MR12(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetIMR_MR12() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetIMR_MR13(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetIMR_MR13() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetIMR_MR14(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetIMR_MR14() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetIMR_MR15(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetIMR_MR15() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetIMR_MR16(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetIMR_MR16() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetIMR_MR17(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetIMR_MR17() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetIMR_MR18(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetIMR_MR18() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetIMR_MR19(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetIMR_MR19() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetIMR_MR20(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetIMR_MR20() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetIMR_MR21(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetIMR_MR21() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetIMR_MR22(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetIMR_MR22() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x400000) >> 22
}

// EXTI.EMR: Event mask register (EXTI_EMR)
func (o *EXTI_Type) SetEMR_MR0(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetEMR_MR0() uint32 {
	return volatile.LoadUint32(&o.EMR.Reg) & 0x1
}
func (o *EXTI_Type) SetEMR_MR1(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetEMR_MR1() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetEMR_MR2(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetEMR_MR2() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetEMR_MR3(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetEMR_MR3() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetEMR_MR4(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetEMR_MR4() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetEMR_MR5(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetEMR_MR5() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetEMR_MR6(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetEMR_MR6() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetEMR_MR7(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetEMR_MR7() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetEMR_MR8(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetEMR_MR8() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetEMR_MR9(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetEMR_MR9() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetEMR_MR10(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetEMR_MR10() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetEMR_MR11(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetEMR_MR11() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetEMR_MR12(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetEMR_MR12() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetEMR_MR13(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetEMR_MR13() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetEMR_MR14(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetEMR_MR14() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetEMR_MR15(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetEMR_MR15() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetEMR_MR16(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetEMR_MR16() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetEMR_MR17(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetEMR_MR17() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetEMR_MR18(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetEMR_MR18() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetEMR_MR19(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetEMR_MR19() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetEMR_MR20(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetEMR_MR20() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetEMR_MR21(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetEMR_MR21() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetEMR_MR22(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetEMR_MR22() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x400000) >> 22
}

// EXTI.RTSR: Rising Trigger selection register (EXTI_RTSR)
func (o *EXTI_Type) SetRTSR_TR0(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetRTSR_TR0() uint32 {
	return volatile.LoadUint32(&o.RTSR.Reg) & 0x1
}
func (o *EXTI_Type) SetRTSR_TR1(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetRTSR_TR1() uint32 {
	return (volatile.LoadUint32(&o.RTSR.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetRTSR_TR2(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetRTSR_TR2() uint32 {
	return (volatile.LoadUint32(&o.RTSR.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetRTSR_TR3(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetRTSR_TR3() uint32 {
	return (volatile.LoadUint32(&o.RTSR.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetRTSR_TR4(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetRTSR_TR4() uint32 {
	return (volatile.LoadUint32(&o.RTSR.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetRTSR_TR5(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetRTSR_TR5() uint32 {
	return (volatile.LoadUint32(&o.RTSR.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetRTSR_TR6(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetRTSR_TR6() uint32 {
	return (volatile.LoadUint32(&o.RTSR.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetRTSR_TR7(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetRTSR_TR7() uint32 {
	return (volatile.LoadUint32(&o.RTSR.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetRTSR_TR8(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetRTSR_TR8() uint32 {
	return (volatile.LoadUint32(&o.RTSR.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetRTSR_TR9(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetRTSR_TR9() uint32 {
	return (volatile.LoadUint32(&o.RTSR.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetRTSR_TR10(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetRTSR_TR10() uint32 {
	return (volatile.LoadUint32(&o.RTSR.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetRTSR_TR11(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetRTSR_TR11() uint32 {
	return (volatile.LoadUint32(&o.RTSR.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetRTSR_TR12(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetRTSR_TR12() uint32 {
	return (volatile.LoadUint32(&o.RTSR.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetRTSR_TR13(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetRTSR_TR13() uint32 {
	return (volatile.LoadUint32(&o.RTSR.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetRTSR_TR14(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetRTSR_TR14() uint32 {
	return (volatile.LoadUint32(&o.RTSR.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetRTSR_TR15(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetRTSR_TR15() uint32 {
	return (volatile.LoadUint32(&o.RTSR.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetRTSR_TR16(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetRTSR_TR16() uint32 {
	return (volatile.LoadUint32(&o.RTSR.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetRTSR_TR17(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetRTSR_TR17() uint32 {
	return (volatile.LoadUint32(&o.RTSR.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetRTSR_TR18(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetRTSR_TR18() uint32 {
	return (volatile.LoadUint32(&o.RTSR.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetRTSR_TR19(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetRTSR_TR19() uint32 {
	return (volatile.LoadUint32(&o.RTSR.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetRTSR_TR20(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetRTSR_TR20() uint32 {
	return (volatile.LoadUint32(&o.RTSR.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetRTSR_TR21(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetRTSR_TR21() uint32 {
	return (volatile.LoadUint32(&o.RTSR.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetRTSR_TR22(value uint32) {
	volatile.StoreUint32(&o.RTSR.Reg, volatile.LoadUint32(&o.RTSR.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetRTSR_TR22() uint32 {
	return (volatile.LoadUint32(&o.RTSR.Reg) & 0x400000) >> 22
}

// EXTI.FTSR: Falling Trigger selection register (EXTI_FTSR)
func (o *EXTI_Type) SetFTSR_TR0(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetFTSR_TR0() uint32 {
	return volatile.LoadUint32(&o.FTSR.Reg) & 0x1
}
func (o *EXTI_Type) SetFTSR_TR1(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetFTSR_TR1() uint32 {
	return (volatile.LoadUint32(&o.FTSR.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetFTSR_TR2(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetFTSR_TR2() uint32 {
	return (volatile.LoadUint32(&o.FTSR.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetFTSR_TR3(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetFTSR_TR3() uint32 {
	return (volatile.LoadUint32(&o.FTSR.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetFTSR_TR4(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetFTSR_TR4() uint32 {
	return (volatile.LoadUint32(&o.FTSR.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetFTSR_TR5(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetFTSR_TR5() uint32 {
	return (volatile.LoadUint32(&o.FTSR.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetFTSR_TR6(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetFTSR_TR6() uint32 {
	return (volatile.LoadUint32(&o.FTSR.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetFTSR_TR7(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetFTSR_TR7() uint32 {
	return (volatile.LoadUint32(&o.FTSR.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetFTSR_TR8(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetFTSR_TR8() uint32 {
	return (volatile.LoadUint32(&o.FTSR.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetFTSR_TR9(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetFTSR_TR9() uint32 {
	return (volatile.LoadUint32(&o.FTSR.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetFTSR_TR10(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetFTSR_TR10() uint32 {
	return (volatile.LoadUint32(&o.FTSR.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetFTSR_TR11(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetFTSR_TR11() uint32 {
	return (volatile.LoadUint32(&o.FTSR.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetFTSR_TR12(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetFTSR_TR12() uint32 {
	return (volatile.LoadUint32(&o.FTSR.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetFTSR_TR13(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetFTSR_TR13() uint32 {
	return (volatile.LoadUint32(&o.FTSR.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetFTSR_TR14(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetFTSR_TR14() uint32 {
	return (volatile.LoadUint32(&o.FTSR.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetFTSR_TR15(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetFTSR_TR15() uint32 {
	return (volatile.LoadUint32(&o.FTSR.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetFTSR_TR16(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetFTSR_TR16() uint32 {
	return (volatile.LoadUint32(&o.FTSR.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetFTSR_TR17(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetFTSR_TR17() uint32 {
	return (volatile.LoadUint32(&o.FTSR.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetFTSR_TR18(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetFTSR_TR18() uint32 {
	return (volatile.LoadUint32(&o.FTSR.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetFTSR_TR19(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetFTSR_TR19() uint32 {
	return (volatile.LoadUint32(&o.FTSR.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetFTSR_TR20(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetFTSR_TR20() uint32 {
	return (volatile.LoadUint32(&o.FTSR.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetFTSR_TR21(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetFTSR_TR21() uint32 {
	return (volatile.LoadUint32(&o.FTSR.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetFTSR_TR22(value uint32) {
	volatile.StoreUint32(&o.FTSR.Reg, volatile.LoadUint32(&o.FTSR.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetFTSR_TR22() uint32 {
	return (volatile.LoadUint32(&o.FTSR.Reg) & 0x400000) >> 22
}

// EXTI.SWIER: Software interrupt event register (EXTI_SWIER)
func (o *EXTI_Type) SetSWIER_SWIER0(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetSWIER_SWIER0() uint32 {
	return volatile.LoadUint32(&o.SWIER.Reg) & 0x1
}
func (o *EXTI_Type) SetSWIER_SWIER1(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetSWIER_SWIER1() uint32 {
	return (volatile.LoadUint32(&o.SWIER.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetSWIER_SWIER2(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetSWIER_SWIER2() uint32 {
	return (volatile.LoadUint32(&o.SWIER.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetSWIER_SWIER3(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetSWIER_SWIER3() uint32 {
	return (volatile.LoadUint32(&o.SWIER.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetSWIER_SWIER4(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetSWIER_SWIER4() uint32 {
	return (volatile.LoadUint32(&o.SWIER.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetSWIER_SWIER5(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetSWIER_SWIER5() uint32 {
	return (volatile.LoadUint32(&o.SWIER.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetSWIER_SWIER6(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetSWIER_SWIER6() uint32 {
	return (volatile.LoadUint32(&o.SWIER.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetSWIER_SWIER7(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetSWIER_SWIER7() uint32 {
	return (volatile.LoadUint32(&o.SWIER.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetSWIER_SWIER8(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetSWIER_SWIER8() uint32 {
	return (volatile.LoadUint32(&o.SWIER.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetSWIER_SWIER9(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetSWIER_SWIER9() uint32 {
	return (volatile.LoadUint32(&o.SWIER.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetSWIER_SWIER10(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetSWIER_SWIER10() uint32 {
	return (volatile.LoadUint32(&o.SWIER.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetSWIER_SWIER11(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetSWIER_SWIER11() uint32 {
	return (volatile.LoadUint32(&o.SWIER.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetSWIER_SWIER12(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetSWIER_SWIER12() uint32 {
	return (volatile.LoadUint32(&o.SWIER.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetSWIER_SWIER13(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetSWIER_SWIER13() uint32 {
	return (volatile.LoadUint32(&o.SWIER.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetSWIER_SWIER14(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetSWIER_SWIER14() uint32 {
	return (volatile.LoadUint32(&o.SWIER.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetSWIER_SWIER15(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetSWIER_SWIER15() uint32 {
	return (volatile.LoadUint32(&o.SWIER.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetSWIER_SWIER16(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetSWIER_SWIER16() uint32 {
	return (volatile.LoadUint32(&o.SWIER.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetSWIER_SWIER17(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetSWIER_SWIER17() uint32 {
	return (volatile.LoadUint32(&o.SWIER.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetSWIER_SWIER18(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetSWIER_SWIER18() uint32 {
	return (volatile.LoadUint32(&o.SWIER.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetSWIER_SWIER19(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetSWIER_SWIER19() uint32 {
	return (volatile.LoadUint32(&o.SWIER.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetSWIER_SWIER20(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetSWIER_SWIER20() uint32 {
	return (volatile.LoadUint32(&o.SWIER.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetSWIER_SWIER21(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetSWIER_SWIER21() uint32 {
	return (volatile.LoadUint32(&o.SWIER.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetSWIER_SWIER22(value uint32) {
	volatile.StoreUint32(&o.SWIER.Reg, volatile.LoadUint32(&o.SWIER.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetSWIER_SWIER22() uint32 {
	return (volatile.LoadUint32(&o.SWIER.Reg) & 0x400000) >> 22
}

// EXTI.PR: Pending register (EXTI_PR)
func (o *EXTI_Type) SetPR_PR0(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x1)|value)
}
func (o *EXTI_Type) GetPR_PR0() uint32 {
	return volatile.LoadUint32(&o.PR.Reg) & 0x1
}
func (o *EXTI_Type) SetPR_PR1(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x2)|value<<1)
}
func (o *EXTI_Type) GetPR_PR1() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0x2) >> 1
}
func (o *EXTI_Type) SetPR_PR2(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x4)|value<<2)
}
func (o *EXTI_Type) GetPR_PR2() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0x4) >> 2
}
func (o *EXTI_Type) SetPR_PR3(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x8)|value<<3)
}
func (o *EXTI_Type) GetPR_PR3() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0x8) >> 3
}
func (o *EXTI_Type) SetPR_PR4(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x10)|value<<4)
}
func (o *EXTI_Type) GetPR_PR4() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0x10) >> 4
}
func (o *EXTI_Type) SetPR_PR5(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x20)|value<<5)
}
func (o *EXTI_Type) GetPR_PR5() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0x20) >> 5
}
func (o *EXTI_Type) SetPR_PR6(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x40)|value<<6)
}
func (o *EXTI_Type) GetPR_PR6() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0x40) >> 6
}
func (o *EXTI_Type) SetPR_PR7(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x80)|value<<7)
}
func (o *EXTI_Type) GetPR_PR7() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0x80) >> 7
}
func (o *EXTI_Type) SetPR_PR8(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x100)|value<<8)
}
func (o *EXTI_Type) GetPR_PR8() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0x100) >> 8
}
func (o *EXTI_Type) SetPR_PR9(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x200)|value<<9)
}
func (o *EXTI_Type) GetPR_PR9() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0x200) >> 9
}
func (o *EXTI_Type) SetPR_PR10(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x400)|value<<10)
}
func (o *EXTI_Type) GetPR_PR10() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0x400) >> 10
}
func (o *EXTI_Type) SetPR_PR11(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x800)|value<<11)
}
func (o *EXTI_Type) GetPR_PR11() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0x800) >> 11
}
func (o *EXTI_Type) SetPR_PR12(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x1000)|value<<12)
}
func (o *EXTI_Type) GetPR_PR12() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0x1000) >> 12
}
func (o *EXTI_Type) SetPR_PR13(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x2000)|value<<13)
}
func (o *EXTI_Type) GetPR_PR13() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0x2000) >> 13
}
func (o *EXTI_Type) SetPR_PR14(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x4000)|value<<14)
}
func (o *EXTI_Type) GetPR_PR14() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0x4000) >> 14
}
func (o *EXTI_Type) SetPR_PR15(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x8000)|value<<15)
}
func (o *EXTI_Type) GetPR_PR15() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0x8000) >> 15
}
func (o *EXTI_Type) SetPR_PR16(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x10000)|value<<16)
}
func (o *EXTI_Type) GetPR_PR16() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0x10000) >> 16
}
func (o *EXTI_Type) SetPR_PR17(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x20000)|value<<17)
}
func (o *EXTI_Type) GetPR_PR17() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0x20000) >> 17
}
func (o *EXTI_Type) SetPR_PR18(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x40000)|value<<18)
}
func (o *EXTI_Type) GetPR_PR18() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0x40000) >> 18
}
func (o *EXTI_Type) SetPR_PR19(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x80000)|value<<19)
}
func (o *EXTI_Type) GetPR_PR19() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0x80000) >> 19
}
func (o *EXTI_Type) SetPR_PR20(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x100000)|value<<20)
}
func (o *EXTI_Type) GetPR_PR20() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0x100000) >> 20
}
func (o *EXTI_Type) SetPR_PR21(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x200000)|value<<21)
}
func (o *EXTI_Type) GetPR_PR21() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0x200000) >> 21
}
func (o *EXTI_Type) SetPR_PR22(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0x400000)|value<<22)
}
func (o *EXTI_Type) GetPR_PR22() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0x400000) >> 22
}

// LCD-TFT Controller
type LTDC_Type struct {
	_     [8]byte
	SSCR  volatile.Register32 // 0x8
	BPCR  volatile.Register32 // 0xC
	AWCR  volatile.Register32 // 0x10
	TWCR  volatile.Register32 // 0x14
	GCR   volatile.Register32 // 0x18
	_     [8]byte
	SRCR  volatile.Register32 // 0x24
	_     [4]byte
	BCCR  volatile.Register32 // 0x2C
	_     [4]byte
	IER   volatile.Register32 // 0x34
	ISR   volatile.Register32 // 0x38
	ICR   volatile.Register32 // 0x3C
	LIPCR volatile.Register32 // 0x40
	CPSR  volatile.Register32 // 0x44
	CDSR  volatile.Register32 // 0x48
	_     [56]byte
	LAYER [2]LTDC_LAYER_Type // 0x84
}

// LTDC.SSCR: Synchronization Size Configuration Register
func (o *LTDC_Type) SetSSCR_HSW(value uint32) {
	volatile.StoreUint32(&o.SSCR.Reg, volatile.LoadUint32(&o.SSCR.Reg)&^(0xfff0000)|value<<16)
}
func (o *LTDC_Type) GetSSCR_HSW() uint32 {
	return (volatile.LoadUint32(&o.SSCR.Reg) & 0xfff0000) >> 16
}
func (o *LTDC_Type) SetSSCR_VSH(value uint32) {
	volatile.StoreUint32(&o.SSCR.Reg, volatile.LoadUint32(&o.SSCR.Reg)&^(0x7ff)|value)
}
func (o *LTDC_Type) GetSSCR_VSH() uint32 {
	return volatile.LoadUint32(&o.SSCR.Reg) & 0x7ff
}

// LTDC.BPCR: Back Porch Configuration Register
func (o *LTDC_Type) SetBPCR_AHBP(value uint32) {
	volatile.StoreUint32(&o.BPCR.Reg, volatile.LoadUint32(&o.BPCR.Reg)&^(0xfff0000)|value<<16)
}
func (o *LTDC_Type) GetBPCR_AHBP() uint32 {
	return (volatile.LoadUint32(&o.BPCR.Reg) & 0xfff0000) >> 16
}
func (o *LTDC_Type) SetBPCR_AVBP(value uint32) {
	volatile.StoreUint32(&o.BPCR.Reg, volatile.LoadUint32(&o.BPCR.Reg)&^(0x7ff)|value)
}
func (o *LTDC_Type) GetBPCR_AVBP() uint32 {
	return volatile.LoadUint32(&o.BPCR.Reg) & 0x7ff
}

// LTDC.AWCR: Active Width Configuration Register
func (o *LTDC_Type) SetAWCR_AAW(value uint32) {
	volatile.StoreUint32(&o.AWCR.Reg, volatile.LoadUint32(&o.AWCR.Reg)&^(0xfff0000)|value<<16)
}
func (o *LTDC_Type) GetAWCR_AAW() uint32 {
	return (volatile.LoadUint32(&o.AWCR.Reg) & 0xfff0000) >> 16
}
func (o *LTDC_Type) SetAWCR_AAH(value uint32) {
	volatile.StoreUint32(&o.AWCR.Reg, volatile.LoadUint32(&o.AWCR.Reg)&^(0x7ff)|value)
}
func (o *LTDC_Type) GetAWCR_AAH() uint32 {
	return volatile.LoadUint32(&o.AWCR.Reg) & 0x7ff
}

// LTDC.TWCR: Total Width Configuration Register
func (o *LTDC_Type) SetTWCR_TOTALW(value uint32) {
	volatile.StoreUint32(&o.TWCR.Reg, volatile.LoadUint32(&o.TWCR.Reg)&^(0xfff0000)|value<<16)
}
func (o *LTDC_Type) GetTWCR_TOTALW() uint32 {
	return (volatile.LoadUint32(&o.TWCR.Reg) & 0xfff0000) >> 16
}
func (o *LTDC_Type) SetTWCR_TOTALH(value uint32) {
	volatile.StoreUint32(&o.TWCR.Reg, volatile.LoadUint32(&o.TWCR.Reg)&^(0x7ff)|value)
}
func (o *LTDC_Type) GetTWCR_TOTALH() uint32 {
	return volatile.LoadUint32(&o.TWCR.Reg) & 0x7ff
}

// LTDC.GCR: Global Control Register
func (o *LTDC_Type) SetGCR_HSPOL(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x80000000)|value<<31)
}
func (o *LTDC_Type) GetGCR_HSPOL() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x80000000) >> 31
}
func (o *LTDC_Type) SetGCR_VSPOL(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x40000000)|value<<30)
}
func (o *LTDC_Type) GetGCR_VSPOL() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x40000000) >> 30
}
func (o *LTDC_Type) SetGCR_DEPOL(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x20000000)|value<<29)
}
func (o *LTDC_Type) GetGCR_DEPOL() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x20000000) >> 29
}
func (o *LTDC_Type) SetGCR_PCPOL(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x10000000)|value<<28)
}
func (o *LTDC_Type) GetGCR_PCPOL() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x10000000) >> 28
}
func (o *LTDC_Type) SetGCR_DEN(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x10000)|value<<16)
}
func (o *LTDC_Type) GetGCR_DEN() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x10000) >> 16
}
func (o *LTDC_Type) SetGCR_DRW(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x7000)|value<<12)
}
func (o *LTDC_Type) GetGCR_DRW() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x7000) >> 12
}
func (o *LTDC_Type) SetGCR_DGW(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x700)|value<<8)
}
func (o *LTDC_Type) GetGCR_DGW() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x700) >> 8
}
func (o *LTDC_Type) SetGCR_DBW(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x70)|value<<4)
}
func (o *LTDC_Type) GetGCR_DBW() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x70) >> 4
}
func (o *LTDC_Type) SetGCR_LTDCEN(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x1)|value)
}
func (o *LTDC_Type) GetGCR_LTDCEN() uint32 {
	return volatile.LoadUint32(&o.GCR.Reg) & 0x1
}

// LTDC.SRCR: Shadow Reload Configuration Register
func (o *LTDC_Type) SetSRCR_VBR(value uint32) {
	volatile.StoreUint32(&o.SRCR.Reg, volatile.LoadUint32(&o.SRCR.Reg)&^(0x2)|value<<1)
}
func (o *LTDC_Type) GetSRCR_VBR() uint32 {
	return (volatile.LoadUint32(&o.SRCR.Reg) & 0x2) >> 1
}
func (o *LTDC_Type) SetSRCR_IMR(value uint32) {
	volatile.StoreUint32(&o.SRCR.Reg, volatile.LoadUint32(&o.SRCR.Reg)&^(0x1)|value)
}
func (o *LTDC_Type) GetSRCR_IMR() uint32 {
	return volatile.LoadUint32(&o.SRCR.Reg) & 0x1
}

// LTDC.BCCR: Background Color Configuration Register
func (o *LTDC_Type) SetBCCR_BCBLUE(value uint32) {
	volatile.StoreUint32(&o.BCCR.Reg, volatile.LoadUint32(&o.BCCR.Reg)&^(0xff)|value)
}
func (o *LTDC_Type) GetBCCR_BCBLUE() uint32 {
	return volatile.LoadUint32(&o.BCCR.Reg) & 0xff
}
func (o *LTDC_Type) SetBCCR_BCGREEN(value uint32) {
	volatile.StoreUint32(&o.BCCR.Reg, volatile.LoadUint32(&o.BCCR.Reg)&^(0xff00)|value<<8)
}
func (o *LTDC_Type) GetBCCR_BCGREEN() uint32 {
	return (volatile.LoadUint32(&o.BCCR.Reg) & 0xff00) >> 8
}
func (o *LTDC_Type) SetBCCR_BCRED(value uint32) {
	volatile.StoreUint32(&o.BCCR.Reg, volatile.LoadUint32(&o.BCCR.Reg)&^(0xff0000)|value<<16)
}
func (o *LTDC_Type) GetBCCR_BCRED() uint32 {
	return (volatile.LoadUint32(&o.BCCR.Reg) & 0xff0000) >> 16
}

// LTDC.IER: Interrupt Enable Register
func (o *LTDC_Type) SetIER_RRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *LTDC_Type) GetIER_RRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *LTDC_Type) SetIER_TERRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *LTDC_Type) GetIER_TERRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *LTDC_Type) SetIER_FUIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *LTDC_Type) GetIER_FUIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *LTDC_Type) SetIER_LIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *LTDC_Type) GetIER_LIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// LTDC.ISR: Interrupt Status Register
func (o *LTDC_Type) SetISR_RRIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *LTDC_Type) GetISR_RRIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *LTDC_Type) SetISR_TERRIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *LTDC_Type) GetISR_TERRIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *LTDC_Type) SetISR_FUIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *LTDC_Type) GetISR_FUIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *LTDC_Type) SetISR_LIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *LTDC_Type) GetISR_LIF() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// LTDC.ICR: Interrupt Clear Register
func (o *LTDC_Type) SetICR_CRRIF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *LTDC_Type) GetICR_CRRIF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *LTDC_Type) SetICR_CTERRIF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *LTDC_Type) GetICR_CTERRIF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *LTDC_Type) SetICR_CFUIF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *LTDC_Type) GetICR_CFUIF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *LTDC_Type) SetICR_CLIF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *LTDC_Type) GetICR_CLIF() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}

// LTDC.LIPCR: Line Interrupt Position Configuration Register
func (o *LTDC_Type) SetLIPCR_LIPOS(value uint32) {
	volatile.StoreUint32(&o.LIPCR.Reg, volatile.LoadUint32(&o.LIPCR.Reg)&^(0x7ff)|value)
}
func (o *LTDC_Type) GetLIPCR_LIPOS() uint32 {
	return volatile.LoadUint32(&o.LIPCR.Reg) & 0x7ff
}

// LTDC.CPSR: Current Position Status Register
func (o *LTDC_Type) SetCPSR_CXPOS(value uint32) {
	volatile.StoreUint32(&o.CPSR.Reg, volatile.LoadUint32(&o.CPSR.Reg)&^(0xffff0000)|value<<16)
}
func (o *LTDC_Type) GetCPSR_CXPOS() uint32 {
	return (volatile.LoadUint32(&o.CPSR.Reg) & 0xffff0000) >> 16
}
func (o *LTDC_Type) SetCPSR_CYPOS(value uint32) {
	volatile.StoreUint32(&o.CPSR.Reg, volatile.LoadUint32(&o.CPSR.Reg)&^(0xffff)|value)
}
func (o *LTDC_Type) GetCPSR_CYPOS() uint32 {
	return volatile.LoadUint32(&o.CPSR.Reg) & 0xffff
}

// LTDC.CDSR: Current Display Status Register
func (o *LTDC_Type) SetCDSR_HSYNCS(value uint32) {
	volatile.StoreUint32(&o.CDSR.Reg, volatile.LoadUint32(&o.CDSR.Reg)&^(0x8)|value<<3)
}
func (o *LTDC_Type) GetCDSR_HSYNCS() uint32 {
	return (volatile.LoadUint32(&o.CDSR.Reg) & 0x8) >> 3
}
func (o *LTDC_Type) SetCDSR_VSYNCS(value uint32) {
	volatile.StoreUint32(&o.CDSR.Reg, volatile.LoadUint32(&o.CDSR.Reg)&^(0x4)|value<<2)
}
func (o *LTDC_Type) GetCDSR_VSYNCS() uint32 {
	return (volatile.LoadUint32(&o.CDSR.Reg) & 0x4) >> 2
}
func (o *LTDC_Type) SetCDSR_HDES(value uint32) {
	volatile.StoreUint32(&o.CDSR.Reg, volatile.LoadUint32(&o.CDSR.Reg)&^(0x2)|value<<1)
}
func (o *LTDC_Type) GetCDSR_HDES() uint32 {
	return (volatile.LoadUint32(&o.CDSR.Reg) & 0x2) >> 1
}
func (o *LTDC_Type) SetCDSR_VDES(value uint32) {
	volatile.StoreUint32(&o.CDSR.Reg, volatile.LoadUint32(&o.CDSR.Reg)&^(0x1)|value)
}
func (o *LTDC_Type) GetCDSR_VDES() uint32 {
	return volatile.LoadUint32(&o.CDSR.Reg) & 0x1
}

type LTDC_LAYER_Type struct {
	CR     volatile.Register32 // 0x84
	WHPCR  volatile.Register32 // 0x88
	WVPCR  volatile.Register32 // 0x8C
	CKCR   volatile.Register32 // 0x90
	PFCR   volatile.Register32 // 0x94
	CACR   volatile.Register32 // 0x98
	DCCR   volatile.Register32 // 0x9C
	BFCR   volatile.Register32 // 0xA0
	_      [8]byte
	CFBAR  volatile.Register32 // 0xAC
	CFBLR  volatile.Register32 // 0xB0
	CFBLNR volatile.Register32 // 0xB4
	_      [12]byte
	CLUTWR volatile.Register32 // 0xC4
	_      [60]byte
}

// LTDC_LAYER.CR: Layerx Control Register
func (o *LTDC_LAYER_Type) SetCR_CLUTEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *LTDC_LAYER_Type) GetCR_CLUTEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *LTDC_LAYER_Type) SetCR_COLKEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *LTDC_LAYER_Type) GetCR_COLKEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *LTDC_LAYER_Type) SetCR_LEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *LTDC_LAYER_Type) GetCR_LEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// LTDC_LAYER.WHPCR: Layerx Window Horizontal Position Configuration Register
func (o *LTDC_LAYER_Type) SetWHPCR_WHSPPOS(value uint32) {
	volatile.StoreUint32(&o.WHPCR.Reg, volatile.LoadUint32(&o.WHPCR.Reg)&^(0xfff0000)|value<<16)
}
func (o *LTDC_LAYER_Type) GetWHPCR_WHSPPOS() uint32 {
	return (volatile.LoadUint32(&o.WHPCR.Reg) & 0xfff0000) >> 16
}
func (o *LTDC_LAYER_Type) SetWHPCR_WHSTPOS(value uint32) {
	volatile.StoreUint32(&o.WHPCR.Reg, volatile.LoadUint32(&o.WHPCR.Reg)&^(0xfff)|value)
}
func (o *LTDC_LAYER_Type) GetWHPCR_WHSTPOS() uint32 {
	return volatile.LoadUint32(&o.WHPCR.Reg) & 0xfff
}

// LTDC_LAYER.WVPCR: Layerx Window Vertical Position Configuration Register
func (o *LTDC_LAYER_Type) SetWVPCR_WVSPPOS(value uint32) {
	volatile.StoreUint32(&o.WVPCR.Reg, volatile.LoadUint32(&o.WVPCR.Reg)&^(0x7ff0000)|value<<16)
}
func (o *LTDC_LAYER_Type) GetWVPCR_WVSPPOS() uint32 {
	return (volatile.LoadUint32(&o.WVPCR.Reg) & 0x7ff0000) >> 16
}
func (o *LTDC_LAYER_Type) SetWVPCR_WVSTPOS(value uint32) {
	volatile.StoreUint32(&o.WVPCR.Reg, volatile.LoadUint32(&o.WVPCR.Reg)&^(0x7ff)|value)
}
func (o *LTDC_LAYER_Type) GetWVPCR_WVSTPOS() uint32 {
	return volatile.LoadUint32(&o.WVPCR.Reg) & 0x7ff
}

// LTDC_LAYER.CKCR: Layerx Color Keying Configuration Register
func (o *LTDC_LAYER_Type) SetCKCR_CKRED(value uint32) {
	volatile.StoreUint32(&o.CKCR.Reg, volatile.LoadUint32(&o.CKCR.Reg)&^(0xff0000)|value<<16)
}
func (o *LTDC_LAYER_Type) GetCKCR_CKRED() uint32 {
	return (volatile.LoadUint32(&o.CKCR.Reg) & 0xff0000) >> 16
}
func (o *LTDC_LAYER_Type) SetCKCR_CKGREEN(value uint32) {
	volatile.StoreUint32(&o.CKCR.Reg, volatile.LoadUint32(&o.CKCR.Reg)&^(0xff00)|value<<8)
}
func (o *LTDC_LAYER_Type) GetCKCR_CKGREEN() uint32 {
	return (volatile.LoadUint32(&o.CKCR.Reg) & 0xff00) >> 8
}
func (o *LTDC_LAYER_Type) SetCKCR_CKBLUE(value uint32) {
	volatile.StoreUint32(&o.CKCR.Reg, volatile.LoadUint32(&o.CKCR.Reg)&^(0xff)|value)
}
func (o *LTDC_LAYER_Type) GetCKCR_CKBLUE() uint32 {
	return volatile.LoadUint32(&o.CKCR.Reg) & 0xff
}

// LTDC_LAYER.PFCR: Layerx Pixel Format Configuration Register
func (o *LTDC_LAYER_Type) SetPFCR_PF(value uint32) {
	volatile.StoreUint32(&o.PFCR.Reg, volatile.LoadUint32(&o.PFCR.Reg)&^(0x7)|value)
}
func (o *LTDC_LAYER_Type) GetPFCR_PF() uint32 {
	return volatile.LoadUint32(&o.PFCR.Reg) & 0x7
}

// LTDC_LAYER.CACR: Layerx Constant Alpha Configuration Register
func (o *LTDC_LAYER_Type) SetCACR_CONSTA(value uint32) {
	volatile.StoreUint32(&o.CACR.Reg, volatile.LoadUint32(&o.CACR.Reg)&^(0xff)|value)
}
func (o *LTDC_LAYER_Type) GetCACR_CONSTA() uint32 {
	return volatile.LoadUint32(&o.CACR.Reg) & 0xff
}

// LTDC_LAYER.DCCR: Layerx Default Color Configuration Register
func (o *LTDC_LAYER_Type) SetDCCR_DCALPHA(value uint32) {
	volatile.StoreUint32(&o.DCCR.Reg, volatile.LoadUint32(&o.DCCR.Reg)&^(0xff000000)|value<<24)
}
func (o *LTDC_LAYER_Type) GetDCCR_DCALPHA() uint32 {
	return (volatile.LoadUint32(&o.DCCR.Reg) & 0xff000000) >> 24
}
func (o *LTDC_LAYER_Type) SetDCCR_DCRED(value uint32) {
	volatile.StoreUint32(&o.DCCR.Reg, volatile.LoadUint32(&o.DCCR.Reg)&^(0xff0000)|value<<16)
}
func (o *LTDC_LAYER_Type) GetDCCR_DCRED() uint32 {
	return (volatile.LoadUint32(&o.DCCR.Reg) & 0xff0000) >> 16
}
func (o *LTDC_LAYER_Type) SetDCCR_DCGREEN(value uint32) {
	volatile.StoreUint32(&o.DCCR.Reg, volatile.LoadUint32(&o.DCCR.Reg)&^(0xff00)|value<<8)
}
func (o *LTDC_LAYER_Type) GetDCCR_DCGREEN() uint32 {
	return (volatile.LoadUint32(&o.DCCR.Reg) & 0xff00) >> 8
}
func (o *LTDC_LAYER_Type) SetDCCR_DCBLUE(value uint32) {
	volatile.StoreUint32(&o.DCCR.Reg, volatile.LoadUint32(&o.DCCR.Reg)&^(0xff)|value)
}
func (o *LTDC_LAYER_Type) GetDCCR_DCBLUE() uint32 {
	return volatile.LoadUint32(&o.DCCR.Reg) & 0xff
}

// LTDC_LAYER.BFCR: Layerx Blending Factors Configuration Register
func (o *LTDC_LAYER_Type) SetBFCR_BF1(value uint32) {
	volatile.StoreUint32(&o.BFCR.Reg, volatile.LoadUint32(&o.BFCR.Reg)&^(0x700)|value<<8)
}
func (o *LTDC_LAYER_Type) GetBFCR_BF1() uint32 {
	return (volatile.LoadUint32(&o.BFCR.Reg) & 0x700) >> 8
}
func (o *LTDC_LAYER_Type) SetBFCR_BF2(value uint32) {
	volatile.StoreUint32(&o.BFCR.Reg, volatile.LoadUint32(&o.BFCR.Reg)&^(0x7)|value)
}
func (o *LTDC_LAYER_Type) GetBFCR_BF2() uint32 {
	return volatile.LoadUint32(&o.BFCR.Reg) & 0x7
}

// LTDC_LAYER.CFBAR: Layerx Color Frame Buffer Address Register
func (o *LTDC_LAYER_Type) SetCFBAR(value uint32) {
	volatile.StoreUint32(&o.CFBAR.Reg, value)
}
func (o *LTDC_LAYER_Type) GetCFBAR() uint32 {
	return volatile.LoadUint32(&o.CFBAR.Reg)
}

// LTDC_LAYER.CFBLR: Layerx Color Frame Buffer Length Register
func (o *LTDC_LAYER_Type) SetCFBLR_CFBP(value uint32) {
	volatile.StoreUint32(&o.CFBLR.Reg, volatile.LoadUint32(&o.CFBLR.Reg)&^(0x1fff0000)|value<<16)
}
func (o *LTDC_LAYER_Type) GetCFBLR_CFBP() uint32 {
	return (volatile.LoadUint32(&o.CFBLR.Reg) & 0x1fff0000) >> 16
}
func (o *LTDC_LAYER_Type) SetCFBLR_CFBLL(value uint32) {
	volatile.StoreUint32(&o.CFBLR.Reg, volatile.LoadUint32(&o.CFBLR.Reg)&^(0x1fff)|value)
}
func (o *LTDC_LAYER_Type) GetCFBLR_CFBLL() uint32 {
	return volatile.LoadUint32(&o.CFBLR.Reg) & 0x1fff
}

// LTDC_LAYER.CFBLNR: Layerx ColorFrame Buffer Line Number Register
func (o *LTDC_LAYER_Type) SetCFBLNR_CFBLNBR(value uint32) {
	volatile.StoreUint32(&o.CFBLNR.Reg, volatile.LoadUint32(&o.CFBLNR.Reg)&^(0x7ff)|value)
}
func (o *LTDC_LAYER_Type) GetCFBLNR_CFBLNBR() uint32 {
	return volatile.LoadUint32(&o.CFBLNR.Reg) & 0x7ff
}

// LTDC_LAYER.CLUTWR: Layerx CLUT Write Register
func (o *LTDC_LAYER_Type) SetCLUTWR_CLUTADD(value uint32) {
	volatile.StoreUint32(&o.CLUTWR.Reg, volatile.LoadUint32(&o.CLUTWR.Reg)&^(0xff000000)|value<<24)
}
func (o *LTDC_LAYER_Type) GetCLUTWR_CLUTADD() uint32 {
	return (volatile.LoadUint32(&o.CLUTWR.Reg) & 0xff000000) >> 24
}
func (o *LTDC_LAYER_Type) SetCLUTWR_RED(value uint32) {
	volatile.StoreUint32(&o.CLUTWR.Reg, volatile.LoadUint32(&o.CLUTWR.Reg)&^(0xff0000)|value<<16)
}
func (o *LTDC_LAYER_Type) GetCLUTWR_RED() uint32 {
	return (volatile.LoadUint32(&o.CLUTWR.Reg) & 0xff0000) >> 16
}
func (o *LTDC_LAYER_Type) SetCLUTWR_GREEN(value uint32) {
	volatile.StoreUint32(&o.CLUTWR.Reg, volatile.LoadUint32(&o.CLUTWR.Reg)&^(0xff00)|value<<8)
}
func (o *LTDC_LAYER_Type) GetCLUTWR_GREEN() uint32 {
	return (volatile.LoadUint32(&o.CLUTWR.Reg) & 0xff00) >> 8
}
func (o *LTDC_LAYER_Type) SetCLUTWR_BLUE(value uint32) {
	volatile.StoreUint32(&o.CLUTWR.Reg, volatile.LoadUint32(&o.CLUTWR.Reg)&^(0xff)|value)
}
func (o *LTDC_LAYER_Type) GetCLUTWR_BLUE() uint32 {
	return volatile.LoadUint32(&o.CLUTWR.Reg) & 0xff
}

// Serial audio interface
type SAI_Type struct {
	GCR volatile.Register32 // 0x0
	CH  [2]SAI_CH_Type      // 0x4
}

// SAI.GCR: Global configuration register
func (o *SAI_Type) SetGCR_SYNCIN(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x3)|value)
}
func (o *SAI_Type) GetGCR_SYNCIN() uint32 {
	return volatile.LoadUint32(&o.GCR.Reg) & 0x3
}
func (o *SAI_Type) SetGCR_SYNCOUT(value uint32) {
	volatile.StoreUint32(&o.GCR.Reg, volatile.LoadUint32(&o.GCR.Reg)&^(0x30)|value<<4)
}
func (o *SAI_Type) GetGCR_SYNCOUT() uint32 {
	return (volatile.LoadUint32(&o.GCR.Reg) & 0x30) >> 4
}

type SAI_CH_Type struct {
	CR1   volatile.Register32 // 0x4
	CR2   volatile.Register32 // 0x8
	FRCR  volatile.Register32 // 0xC
	SLOTR volatile.Register32 // 0x10
	IM    volatile.Register32 // 0x14
	SR    volatile.Register32 // 0x18
	CLRFR volatile.Register32 // 0x1C
	DR    volatile.Register32 // 0x20
}

// SAI_CH.CR1: AConfiguration register 1
func (o *SAI_CH_Type) SetCR1_MCKDIV(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xf00000)|value<<20)
}
func (o *SAI_CH_Type) GetCR1_MCKDIV() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xf00000) >> 20
}
func (o *SAI_CH_Type) SetCR1_NODIV(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80000)|value<<19)
}
func (o *SAI_CH_Type) GetCR1_NODIV() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80000) >> 19
}
func (o *SAI_CH_Type) SetCR1_DMAEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20000)|value<<17)
}
func (o *SAI_CH_Type) GetCR1_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20000) >> 17
}
func (o *SAI_CH_Type) SetCR1_SAIEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10000)|value<<16)
}
func (o *SAI_CH_Type) GetCR1_SAIEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10000) >> 16
}
func (o *SAI_CH_Type) SetCR1_OUTDRIV(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2000)|value<<13)
}
func (o *SAI_CH_Type) GetCR1_OUTDRIV() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2000) >> 13
}
func (o *SAI_CH_Type) SetCR1_MONO(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1000)|value<<12)
}
func (o *SAI_CH_Type) GetCR1_MONO() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1000) >> 12
}
func (o *SAI_CH_Type) SetCR1_SYNCEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xc00)|value<<10)
}
func (o *SAI_CH_Type) GetCR1_SYNCEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xc00) >> 10
}
func (o *SAI_CH_Type) SetCR1_CKSTR(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200)|value<<9)
}
func (o *SAI_CH_Type) GetCR1_CKSTR() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200) >> 9
}
func (o *SAI_CH_Type) SetCR1_LSBFIRST(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100)|value<<8)
}
func (o *SAI_CH_Type) GetCR1_LSBFIRST() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100) >> 8
}
func (o *SAI_CH_Type) SetCR1_DS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xe0)|value<<5)
}
func (o *SAI_CH_Type) GetCR1_DS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xe0) >> 5
}
func (o *SAI_CH_Type) SetCR1_PRTCFG(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xc)|value<<2)
}
func (o *SAI_CH_Type) GetCR1_PRTCFG() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xc) >> 2
}
func (o *SAI_CH_Type) SetCR1_MODE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x3)|value)
}
func (o *SAI_CH_Type) GetCR1_MODE() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x3
}

// SAI_CH.CR2: AConfiguration register 2
func (o *SAI_CH_Type) SetCR2_COMP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xc000)|value<<14)
}
func (o *SAI_CH_Type) GetCR2_COMP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xc000) >> 14
}
func (o *SAI_CH_Type) SetCR2_CPL(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000)|value<<13)
}
func (o *SAI_CH_Type) GetCR2_CPL() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000) >> 13
}
func (o *SAI_CH_Type) SetCR2_MUTECN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1f80)|value<<7)
}
func (o *SAI_CH_Type) GetCR2_MUTECN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1f80) >> 7
}
func (o *SAI_CH_Type) SetCR2_MUTEVAL(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40)|value<<6)
}
func (o *SAI_CH_Type) GetCR2_MUTEVAL() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40) >> 6
}
func (o *SAI_CH_Type) SetCR2_MUTE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x20)|value<<5)
}
func (o *SAI_CH_Type) GetCR2_MUTE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x20) >> 5
}
func (o *SAI_CH_Type) SetCR2_TRIS(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10)|value<<4)
}
func (o *SAI_CH_Type) GetCR2_TRIS() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10) >> 4
}
func (o *SAI_CH_Type) SetCR2_FFLUSH(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8)|value<<3)
}
func (o *SAI_CH_Type) GetCR2_FFLUSH() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8) >> 3
}
func (o *SAI_CH_Type) SetCR2_FTH(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x7)|value)
}
func (o *SAI_CH_Type) GetCR2_FTH() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x7
}

// SAI_CH.FRCR: AFRCR
func (o *SAI_CH_Type) SetFRCR_FSOFF(value uint32) {
	volatile.StoreUint32(&o.FRCR.Reg, volatile.LoadUint32(&o.FRCR.Reg)&^(0x40000)|value<<18)
}
func (o *SAI_CH_Type) GetFRCR_FSOFF() uint32 {
	return (volatile.LoadUint32(&o.FRCR.Reg) & 0x40000) >> 18
}
func (o *SAI_CH_Type) SetFRCR_FSPOL(value uint32) {
	volatile.StoreUint32(&o.FRCR.Reg, volatile.LoadUint32(&o.FRCR.Reg)&^(0x20000)|value<<17)
}
func (o *SAI_CH_Type) GetFRCR_FSPOL() uint32 {
	return (volatile.LoadUint32(&o.FRCR.Reg) & 0x20000) >> 17
}
func (o *SAI_CH_Type) SetFRCR_FSDEF(value uint32) {
	volatile.StoreUint32(&o.FRCR.Reg, volatile.LoadUint32(&o.FRCR.Reg)&^(0x10000)|value<<16)
}
func (o *SAI_CH_Type) GetFRCR_FSDEF() uint32 {
	return (volatile.LoadUint32(&o.FRCR.Reg) & 0x10000) >> 16
}
func (o *SAI_CH_Type) SetFRCR_FSALL(value uint32) {
	volatile.StoreUint32(&o.FRCR.Reg, volatile.LoadUint32(&o.FRCR.Reg)&^(0x7f00)|value<<8)
}
func (o *SAI_CH_Type) GetFRCR_FSALL() uint32 {
	return (volatile.LoadUint32(&o.FRCR.Reg) & 0x7f00) >> 8
}
func (o *SAI_CH_Type) SetFRCR_FRL(value uint32) {
	volatile.StoreUint32(&o.FRCR.Reg, volatile.LoadUint32(&o.FRCR.Reg)&^(0xff)|value)
}
func (o *SAI_CH_Type) GetFRCR_FRL() uint32 {
	return volatile.LoadUint32(&o.FRCR.Reg) & 0xff
}

// SAI_CH.SLOTR: ASlot register
func (o *SAI_CH_Type) SetSLOTR_SLOTEN(value uint32) {
	volatile.StoreUint32(&o.SLOTR.Reg, volatile.LoadUint32(&o.SLOTR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SAI_CH_Type) GetSLOTR_SLOTEN() uint32 {
	return (volatile.LoadUint32(&o.SLOTR.Reg) & 0xffff0000) >> 16
}
func (o *SAI_CH_Type) SetSLOTR_NBSLOT(value uint32) {
	volatile.StoreUint32(&o.SLOTR.Reg, volatile.LoadUint32(&o.SLOTR.Reg)&^(0xf00)|value<<8)
}
func (o *SAI_CH_Type) GetSLOTR_NBSLOT() uint32 {
	return (volatile.LoadUint32(&o.SLOTR.Reg) & 0xf00) >> 8
}
func (o *SAI_CH_Type) SetSLOTR_SLOTSZ(value uint32) {
	volatile.StoreUint32(&o.SLOTR.Reg, volatile.LoadUint32(&o.SLOTR.Reg)&^(0xc0)|value<<6)
}
func (o *SAI_CH_Type) GetSLOTR_SLOTSZ() uint32 {
	return (volatile.LoadUint32(&o.SLOTR.Reg) & 0xc0) >> 6
}
func (o *SAI_CH_Type) SetSLOTR_FBOFF(value uint32) {
	volatile.StoreUint32(&o.SLOTR.Reg, volatile.LoadUint32(&o.SLOTR.Reg)&^(0x1f)|value)
}
func (o *SAI_CH_Type) GetSLOTR_FBOFF() uint32 {
	return volatile.LoadUint32(&o.SLOTR.Reg) & 0x1f
}

// SAI_CH.IM: AInterrupt mask register2
func (o *SAI_CH_Type) SetIM_LFSDETIE(value uint32) {
	volatile.StoreUint32(&o.IM.Reg, volatile.LoadUint32(&o.IM.Reg)&^(0x40)|value<<6)
}
func (o *SAI_CH_Type) GetIM_LFSDETIE() uint32 {
	return (volatile.LoadUint32(&o.IM.Reg) & 0x40) >> 6
}
func (o *SAI_CH_Type) SetIM_AFSDETIE(value uint32) {
	volatile.StoreUint32(&o.IM.Reg, volatile.LoadUint32(&o.IM.Reg)&^(0x20)|value<<5)
}
func (o *SAI_CH_Type) GetIM_AFSDETIE() uint32 {
	return (volatile.LoadUint32(&o.IM.Reg) & 0x20) >> 5
}
func (o *SAI_CH_Type) SetIM_CNRDYIE(value uint32) {
	volatile.StoreUint32(&o.IM.Reg, volatile.LoadUint32(&o.IM.Reg)&^(0x10)|value<<4)
}
func (o *SAI_CH_Type) GetIM_CNRDYIE() uint32 {
	return (volatile.LoadUint32(&o.IM.Reg) & 0x10) >> 4
}
func (o *SAI_CH_Type) SetIM_FREQIE(value uint32) {
	volatile.StoreUint32(&o.IM.Reg, volatile.LoadUint32(&o.IM.Reg)&^(0x8)|value<<3)
}
func (o *SAI_CH_Type) GetIM_FREQIE() uint32 {
	return (volatile.LoadUint32(&o.IM.Reg) & 0x8) >> 3
}
func (o *SAI_CH_Type) SetIM_WCKCFGIE(value uint32) {
	volatile.StoreUint32(&o.IM.Reg, volatile.LoadUint32(&o.IM.Reg)&^(0x4)|value<<2)
}
func (o *SAI_CH_Type) GetIM_WCKCFGIE() uint32 {
	return (volatile.LoadUint32(&o.IM.Reg) & 0x4) >> 2
}
func (o *SAI_CH_Type) SetIM_MUTEDETIE(value uint32) {
	volatile.StoreUint32(&o.IM.Reg, volatile.LoadUint32(&o.IM.Reg)&^(0x2)|value<<1)
}
func (o *SAI_CH_Type) GetIM_MUTEDETIE() uint32 {
	return (volatile.LoadUint32(&o.IM.Reg) & 0x2) >> 1
}
func (o *SAI_CH_Type) SetIM_OVRUDRIE(value uint32) {
	volatile.StoreUint32(&o.IM.Reg, volatile.LoadUint32(&o.IM.Reg)&^(0x1)|value)
}
func (o *SAI_CH_Type) GetIM_OVRUDRIE() uint32 {
	return volatile.LoadUint32(&o.IM.Reg) & 0x1
}

// SAI_CH.SR: AStatus register
func (o *SAI_CH_Type) SetSR_FLVL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x70000)|value<<16)
}
func (o *SAI_CH_Type) GetSR_FLVL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x70000) >> 16
}
func (o *SAI_CH_Type) SetSR_LFSDET(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *SAI_CH_Type) GetSR_LFSDET() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *SAI_CH_Type) SetSR_AFSDET(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *SAI_CH_Type) GetSR_AFSDET() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *SAI_CH_Type) SetSR_CNRDY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *SAI_CH_Type) GetSR_CNRDY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *SAI_CH_Type) SetSR_FREQ(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *SAI_CH_Type) GetSR_FREQ() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *SAI_CH_Type) SetSR_WCKCFG(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *SAI_CH_Type) GetSR_WCKCFG() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *SAI_CH_Type) SetSR_MUTEDET(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *SAI_CH_Type) GetSR_MUTEDET() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *SAI_CH_Type) SetSR_OVRUDR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SAI_CH_Type) GetSR_OVRUDR() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// SAI_CH.CLRFR: AClear flag register
func (o *SAI_CH_Type) SetCLRFR_CLFSDET(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x40)|value<<6)
}
func (o *SAI_CH_Type) GetCLRFR_CLFSDET() uint32 {
	return (volatile.LoadUint32(&o.CLRFR.Reg) & 0x40) >> 6
}
func (o *SAI_CH_Type) SetCLRFR_CAFSDET(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x20)|value<<5)
}
func (o *SAI_CH_Type) GetCLRFR_CAFSDET() uint32 {
	return (volatile.LoadUint32(&o.CLRFR.Reg) & 0x20) >> 5
}
func (o *SAI_CH_Type) SetCLRFR_CCNRDY(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x10)|value<<4)
}
func (o *SAI_CH_Type) GetCLRFR_CCNRDY() uint32 {
	return (volatile.LoadUint32(&o.CLRFR.Reg) & 0x10) >> 4
}
func (o *SAI_CH_Type) SetCLRFR_CWCKCFG(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x4)|value<<2)
}
func (o *SAI_CH_Type) GetCLRFR_CWCKCFG() uint32 {
	return (volatile.LoadUint32(&o.CLRFR.Reg) & 0x4) >> 2
}
func (o *SAI_CH_Type) SetCLRFR_CMUTEDET(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x2)|value<<1)
}
func (o *SAI_CH_Type) GetCLRFR_CMUTEDET() uint32 {
	return (volatile.LoadUint32(&o.CLRFR.Reg) & 0x2) >> 1
}
func (o *SAI_CH_Type) SetCLRFR_COVRUDR(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x1)|value)
}
func (o *SAI_CH_Type) GetCLRFR_COVRUDR() uint32 {
	return volatile.LoadUint32(&o.CLRFR.Reg) & 0x1
}

// SAI_CH.DR: AData register
func (o *SAI_CH_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, value)
}
func (o *SAI_CH_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg)
}

// DMA2D controller
type DMA2D_Type struct {
	CR      volatile.Register32 // 0x0
	ISR     volatile.Register32 // 0x4
	IFCR    volatile.Register32 // 0x8
	FGMAR   volatile.Register32 // 0xC
	FGOR    volatile.Register32 // 0x10
	BGMAR   volatile.Register32 // 0x14
	BGOR    volatile.Register32 // 0x18
	FGPFCCR volatile.Register32 // 0x1C
	FGCOLR  volatile.Register32 // 0x20
	BGPFCCR volatile.Register32 // 0x24
	BGCOLR  volatile.Register32 // 0x28
	FGCMAR  volatile.Register32 // 0x2C
	BGCMAR  volatile.Register32 // 0x30
	OPFCCR  volatile.Register32 // 0x34
	OCOLR   volatile.Register32 // 0x38
	OMAR    volatile.Register32 // 0x3C
	OOR     volatile.Register32 // 0x40
	NLR     volatile.Register32 // 0x44
	LWR     volatile.Register32 // 0x48
	AMTCR   volatile.Register32 // 0x4C
	_       [944]byte
	FGCLUT  volatile.Register32 // 0x400
	_       [1020]byte
	BGCLUT  volatile.Register32 // 0x800
}

// DMA2D.CR: control register
func (o *DMA2D_Type) SetCR_MODE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x30000)|value<<16)
}
func (o *DMA2D_Type) GetCR_MODE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x30000) >> 16
}
func (o *DMA2D_Type) SetCR_CEIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *DMA2D_Type) GetCR_CEIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *DMA2D_Type) SetCR_CTCIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *DMA2D_Type) GetCR_CTCIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *DMA2D_Type) SetCR_CAEIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *DMA2D_Type) GetCR_CAEIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *DMA2D_Type) SetCR_TWIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *DMA2D_Type) GetCR_TWIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *DMA2D_Type) SetCR_TCIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *DMA2D_Type) GetCR_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *DMA2D_Type) SetCR_TEIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *DMA2D_Type) GetCR_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *DMA2D_Type) SetCR_ABORT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *DMA2D_Type) GetCR_ABORT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *DMA2D_Type) SetCR_SUSP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *DMA2D_Type) GetCR_SUSP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *DMA2D_Type) SetCR_START(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *DMA2D_Type) GetCR_START() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// DMA2D.ISR: Interrupt Status Register
func (o *DMA2D_Type) SetISR_CEIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *DMA2D_Type) GetISR_CEIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *DMA2D_Type) SetISR_CTCIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *DMA2D_Type) GetISR_CTCIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *DMA2D_Type) SetISR_CAEIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *DMA2D_Type) GetISR_CAEIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *DMA2D_Type) SetISR_TWIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *DMA2D_Type) GetISR_TWIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *DMA2D_Type) SetISR_TCIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *DMA2D_Type) GetISR_TCIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *DMA2D_Type) SetISR_TEIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *DMA2D_Type) GetISR_TEIF() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// DMA2D.IFCR: interrupt flag clear register
func (o *DMA2D_Type) SetIFCR_CCEIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x20)|value<<5)
}
func (o *DMA2D_Type) GetIFCR_CCEIF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x20) >> 5
}
func (o *DMA2D_Type) SetIFCR_CCTCIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x10)|value<<4)
}
func (o *DMA2D_Type) GetIFCR_CCTCIF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x10) >> 4
}
func (o *DMA2D_Type) SetIFCR_CAECIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x8)|value<<3)
}
func (o *DMA2D_Type) GetIFCR_CAECIF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x8) >> 3
}
func (o *DMA2D_Type) SetIFCR_CTWIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x4)|value<<2)
}
func (o *DMA2D_Type) GetIFCR_CTWIF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x4) >> 2
}
func (o *DMA2D_Type) SetIFCR_CTCIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x2)|value<<1)
}
func (o *DMA2D_Type) GetIFCR_CTCIF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x2) >> 1
}
func (o *DMA2D_Type) SetIFCR_CTEIF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x1)|value)
}
func (o *DMA2D_Type) GetIFCR_CTEIF() uint32 {
	return volatile.LoadUint32(&o.IFCR.Reg) & 0x1
}

// DMA2D.FGMAR: foreground memory address register
func (o *DMA2D_Type) SetFGMAR(value uint32) {
	volatile.StoreUint32(&o.FGMAR.Reg, value)
}
func (o *DMA2D_Type) GetFGMAR() uint32 {
	return volatile.LoadUint32(&o.FGMAR.Reg)
}

// DMA2D.FGOR: foreground offset register
func (o *DMA2D_Type) SetFGOR_LO(value uint32) {
	volatile.StoreUint32(&o.FGOR.Reg, volatile.LoadUint32(&o.FGOR.Reg)&^(0x3fff)|value)
}
func (o *DMA2D_Type) GetFGOR_LO() uint32 {
	return volatile.LoadUint32(&o.FGOR.Reg) & 0x3fff
}

// DMA2D.BGMAR: background memory address register
func (o *DMA2D_Type) SetBGMAR(value uint32) {
	volatile.StoreUint32(&o.BGMAR.Reg, value)
}
func (o *DMA2D_Type) GetBGMAR() uint32 {
	return volatile.LoadUint32(&o.BGMAR.Reg)
}

// DMA2D.BGOR: background offset register
func (o *DMA2D_Type) SetBGOR_LO(value uint32) {
	volatile.StoreUint32(&o.BGOR.Reg, volatile.LoadUint32(&o.BGOR.Reg)&^(0x3fff)|value)
}
func (o *DMA2D_Type) GetBGOR_LO() uint32 {
	return volatile.LoadUint32(&o.BGOR.Reg) & 0x3fff
}

// DMA2D.FGPFCCR: foreground PFC control register
func (o *DMA2D_Type) SetFGPFCCR_ALPHA(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0xff000000)|value<<24)
}
func (o *DMA2D_Type) GetFGPFCCR_ALPHA() uint32 {
	return (volatile.LoadUint32(&o.FGPFCCR.Reg) & 0xff000000) >> 24
}
func (o *DMA2D_Type) SetFGPFCCR_AM(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0x30000)|value<<16)
}
func (o *DMA2D_Type) GetFGPFCCR_AM() uint32 {
	return (volatile.LoadUint32(&o.FGPFCCR.Reg) & 0x30000) >> 16
}
func (o *DMA2D_Type) SetFGPFCCR_CS(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0xff00)|value<<8)
}
func (o *DMA2D_Type) GetFGPFCCR_CS() uint32 {
	return (volatile.LoadUint32(&o.FGPFCCR.Reg) & 0xff00) >> 8
}
func (o *DMA2D_Type) SetFGPFCCR_START(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0x20)|value<<5)
}
func (o *DMA2D_Type) GetFGPFCCR_START() uint32 {
	return (volatile.LoadUint32(&o.FGPFCCR.Reg) & 0x20) >> 5
}
func (o *DMA2D_Type) SetFGPFCCR_CCM(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0x10)|value<<4)
}
func (o *DMA2D_Type) GetFGPFCCR_CCM() uint32 {
	return (volatile.LoadUint32(&o.FGPFCCR.Reg) & 0x10) >> 4
}
func (o *DMA2D_Type) SetFGPFCCR_CM(value uint32) {
	volatile.StoreUint32(&o.FGPFCCR.Reg, volatile.LoadUint32(&o.FGPFCCR.Reg)&^(0xf)|value)
}
func (o *DMA2D_Type) GetFGPFCCR_CM() uint32 {
	return volatile.LoadUint32(&o.FGPFCCR.Reg) & 0xf
}

// DMA2D.FGCOLR: foreground color register
func (o *DMA2D_Type) SetFGCOLR_RED(value uint32) {
	volatile.StoreUint32(&o.FGCOLR.Reg, volatile.LoadUint32(&o.FGCOLR.Reg)&^(0xff0000)|value<<16)
}
func (o *DMA2D_Type) GetFGCOLR_RED() uint32 {
	return (volatile.LoadUint32(&o.FGCOLR.Reg) & 0xff0000) >> 16
}
func (o *DMA2D_Type) SetFGCOLR_GREEN(value uint32) {
	volatile.StoreUint32(&o.FGCOLR.Reg, volatile.LoadUint32(&o.FGCOLR.Reg)&^(0xff00)|value<<8)
}
func (o *DMA2D_Type) GetFGCOLR_GREEN() uint32 {
	return (volatile.LoadUint32(&o.FGCOLR.Reg) & 0xff00) >> 8
}
func (o *DMA2D_Type) SetFGCOLR_BLUE(value uint32) {
	volatile.StoreUint32(&o.FGCOLR.Reg, volatile.LoadUint32(&o.FGCOLR.Reg)&^(0xff)|value)
}
func (o *DMA2D_Type) GetFGCOLR_BLUE() uint32 {
	return volatile.LoadUint32(&o.FGCOLR.Reg) & 0xff
}

// DMA2D.BGPFCCR: background PFC control register
func (o *DMA2D_Type) SetBGPFCCR_ALPHA(value uint32) {
	volatile.StoreUint32(&o.BGPFCCR.Reg, volatile.LoadUint32(&o.BGPFCCR.Reg)&^(0xff000000)|value<<24)
}
func (o *DMA2D_Type) GetBGPFCCR_ALPHA() uint32 {
	return (volatile.LoadUint32(&o.BGPFCCR.Reg) & 0xff000000) >> 24
}
func (o *DMA2D_Type) SetBGPFCCR_AM(value uint32) {
	volatile.StoreUint32(&o.BGPFCCR.Reg, volatile.LoadUint32(&o.BGPFCCR.Reg)&^(0x30000)|value<<16)
}
func (o *DMA2D_Type) GetBGPFCCR_AM() uint32 {
	return (volatile.LoadUint32(&o.BGPFCCR.Reg) & 0x30000) >> 16
}
func (o *DMA2D_Type) SetBGPFCCR_CS(value uint32) {
	volatile.StoreUint32(&o.BGPFCCR.Reg, volatile.LoadUint32(&o.BGPFCCR.Reg)&^(0xff00)|value<<8)
}
func (o *DMA2D_Type) GetBGPFCCR_CS() uint32 {
	return (volatile.LoadUint32(&o.BGPFCCR.Reg) & 0xff00) >> 8
}
func (o *DMA2D_Type) SetBGPFCCR_START(value uint32) {
	volatile.StoreUint32(&o.BGPFCCR.Reg, volatile.LoadUint32(&o.BGPFCCR.Reg)&^(0x20)|value<<5)
}
func (o *DMA2D_Type) GetBGPFCCR_START() uint32 {
	return (volatile.LoadUint32(&o.BGPFCCR.Reg) & 0x20) >> 5
}
func (o *DMA2D_Type) SetBGPFCCR_CCM(value uint32) {
	volatile.StoreUint32(&o.BGPFCCR.Reg, volatile.LoadUint32(&o.BGPFCCR.Reg)&^(0x10)|value<<4)
}
func (o *DMA2D_Type) GetBGPFCCR_CCM() uint32 {
	return (volatile.LoadUint32(&o.BGPFCCR.Reg) & 0x10) >> 4
}
func (o *DMA2D_Type) SetBGPFCCR_CM(value uint32) {
	volatile.StoreUint32(&o.BGPFCCR.Reg, volatile.LoadUint32(&o.BGPFCCR.Reg)&^(0xf)|value)
}
func (o *DMA2D_Type) GetBGPFCCR_CM() uint32 {
	return volatile.LoadUint32(&o.BGPFCCR.Reg) & 0xf
}

// DMA2D.BGCOLR: background color register
func (o *DMA2D_Type) SetBGCOLR_RED(value uint32) {
	volatile.StoreUint32(&o.BGCOLR.Reg, volatile.LoadUint32(&o.BGCOLR.Reg)&^(0xff0000)|value<<16)
}
func (o *DMA2D_Type) GetBGCOLR_RED() uint32 {
	return (volatile.LoadUint32(&o.BGCOLR.Reg) & 0xff0000) >> 16
}
func (o *DMA2D_Type) SetBGCOLR_GREEN(value uint32) {
	volatile.StoreUint32(&o.BGCOLR.Reg, volatile.LoadUint32(&o.BGCOLR.Reg)&^(0xff00)|value<<8)
}
func (o *DMA2D_Type) GetBGCOLR_GREEN() uint32 {
	return (volatile.LoadUint32(&o.BGCOLR.Reg) & 0xff00) >> 8
}
func (o *DMA2D_Type) SetBGCOLR_BLUE(value uint32) {
	volatile.StoreUint32(&o.BGCOLR.Reg, volatile.LoadUint32(&o.BGCOLR.Reg)&^(0xff)|value)
}
func (o *DMA2D_Type) GetBGCOLR_BLUE() uint32 {
	return volatile.LoadUint32(&o.BGCOLR.Reg) & 0xff
}

// DMA2D.FGCMAR: foreground CLUT memory address register
func (o *DMA2D_Type) SetFGCMAR(value uint32) {
	volatile.StoreUint32(&o.FGCMAR.Reg, value)
}
func (o *DMA2D_Type) GetFGCMAR() uint32 {
	return volatile.LoadUint32(&o.FGCMAR.Reg)
}

// DMA2D.BGCMAR: background CLUT memory address register
func (o *DMA2D_Type) SetBGCMAR(value uint32) {
	volatile.StoreUint32(&o.BGCMAR.Reg, value)
}
func (o *DMA2D_Type) GetBGCMAR() uint32 {
	return volatile.LoadUint32(&o.BGCMAR.Reg)
}

// DMA2D.OPFCCR: output PFC control register
func (o *DMA2D_Type) SetOPFCCR_CM(value uint32) {
	volatile.StoreUint32(&o.OPFCCR.Reg, volatile.LoadUint32(&o.OPFCCR.Reg)&^(0x7)|value)
}
func (o *DMA2D_Type) GetOPFCCR_CM() uint32 {
	return volatile.LoadUint32(&o.OPFCCR.Reg) & 0x7
}

// DMA2D.OCOLR: output color register
func (o *DMA2D_Type) SetOCOLR_APLHA(value uint32) {
	volatile.StoreUint32(&o.OCOLR.Reg, volatile.LoadUint32(&o.OCOLR.Reg)&^(0xff000000)|value<<24)
}
func (o *DMA2D_Type) GetOCOLR_APLHA() uint32 {
	return (volatile.LoadUint32(&o.OCOLR.Reg) & 0xff000000) >> 24
}
func (o *DMA2D_Type) SetOCOLR_RED(value uint32) {
	volatile.StoreUint32(&o.OCOLR.Reg, volatile.LoadUint32(&o.OCOLR.Reg)&^(0xff0000)|value<<16)
}
func (o *DMA2D_Type) GetOCOLR_RED() uint32 {
	return (volatile.LoadUint32(&o.OCOLR.Reg) & 0xff0000) >> 16
}
func (o *DMA2D_Type) SetOCOLR_GREEN(value uint32) {
	volatile.StoreUint32(&o.OCOLR.Reg, volatile.LoadUint32(&o.OCOLR.Reg)&^(0xff00)|value<<8)
}
func (o *DMA2D_Type) GetOCOLR_GREEN() uint32 {
	return (volatile.LoadUint32(&o.OCOLR.Reg) & 0xff00) >> 8
}
func (o *DMA2D_Type) SetOCOLR_BLUE(value uint32) {
	volatile.StoreUint32(&o.OCOLR.Reg, volatile.LoadUint32(&o.OCOLR.Reg)&^(0xff)|value)
}
func (o *DMA2D_Type) GetOCOLR_BLUE() uint32 {
	return volatile.LoadUint32(&o.OCOLR.Reg) & 0xff
}

// DMA2D.OMAR: output memory address register
func (o *DMA2D_Type) SetOMAR(value uint32) {
	volatile.StoreUint32(&o.OMAR.Reg, value)
}
func (o *DMA2D_Type) GetOMAR() uint32 {
	return volatile.LoadUint32(&o.OMAR.Reg)
}

// DMA2D.OOR: output offset register
func (o *DMA2D_Type) SetOOR_LO(value uint32) {
	volatile.StoreUint32(&o.OOR.Reg, volatile.LoadUint32(&o.OOR.Reg)&^(0x3fff)|value)
}
func (o *DMA2D_Type) GetOOR_LO() uint32 {
	return volatile.LoadUint32(&o.OOR.Reg) & 0x3fff
}

// DMA2D.NLR: number of line register
func (o *DMA2D_Type) SetNLR_PL(value uint32) {
	volatile.StoreUint32(&o.NLR.Reg, volatile.LoadUint32(&o.NLR.Reg)&^(0x3fff0000)|value<<16)
}
func (o *DMA2D_Type) GetNLR_PL() uint32 {
	return (volatile.LoadUint32(&o.NLR.Reg) & 0x3fff0000) >> 16
}
func (o *DMA2D_Type) SetNLR_NL(value uint32) {
	volatile.StoreUint32(&o.NLR.Reg, volatile.LoadUint32(&o.NLR.Reg)&^(0xffff)|value)
}
func (o *DMA2D_Type) GetNLR_NL() uint32 {
	return volatile.LoadUint32(&o.NLR.Reg) & 0xffff
}

// DMA2D.LWR: line watermark register
func (o *DMA2D_Type) SetLWR_LW(value uint32) {
	volatile.StoreUint32(&o.LWR.Reg, volatile.LoadUint32(&o.LWR.Reg)&^(0xffff)|value)
}
func (o *DMA2D_Type) GetLWR_LW() uint32 {
	return volatile.LoadUint32(&o.LWR.Reg) & 0xffff
}

// DMA2D.AMTCR: AHB master timer configuration register
func (o *DMA2D_Type) SetAMTCR_DT(value uint32) {
	volatile.StoreUint32(&o.AMTCR.Reg, volatile.LoadUint32(&o.AMTCR.Reg)&^(0xff00)|value<<8)
}
func (o *DMA2D_Type) GetAMTCR_DT() uint32 {
	return (volatile.LoadUint32(&o.AMTCR.Reg) & 0xff00) >> 8
}
func (o *DMA2D_Type) SetAMTCR_EN(value uint32) {
	volatile.StoreUint32(&o.AMTCR.Reg, volatile.LoadUint32(&o.AMTCR.Reg)&^(0x1)|value)
}
func (o *DMA2D_Type) GetAMTCR_EN() uint32 {
	return volatile.LoadUint32(&o.AMTCR.Reg) & 0x1
}

// DMA2D.FGCLUT: FGCLUT
func (o *DMA2D_Type) SetFGCLUT_APLHA(value uint32) {
	volatile.StoreUint32(&o.FGCLUT.Reg, volatile.LoadUint32(&o.FGCLUT.Reg)&^(0xff000000)|value<<24)
}
func (o *DMA2D_Type) GetFGCLUT_APLHA() uint32 {
	return (volatile.LoadUint32(&o.FGCLUT.Reg) & 0xff000000) >> 24
}
func (o *DMA2D_Type) SetFGCLUT_RED(value uint32) {
	volatile.StoreUint32(&o.FGCLUT.Reg, volatile.LoadUint32(&o.FGCLUT.Reg)&^(0xff0000)|value<<16)
}
func (o *DMA2D_Type) GetFGCLUT_RED() uint32 {
	return (volatile.LoadUint32(&o.FGCLUT.Reg) & 0xff0000) >> 16
}
func (o *DMA2D_Type) SetFGCLUT_GREEN(value uint32) {
	volatile.StoreUint32(&o.FGCLUT.Reg, volatile.LoadUint32(&o.FGCLUT.Reg)&^(0xff00)|value<<8)
}
func (o *DMA2D_Type) GetFGCLUT_GREEN() uint32 {
	return (volatile.LoadUint32(&o.FGCLUT.Reg) & 0xff00) >> 8
}
func (o *DMA2D_Type) SetFGCLUT_BLUE(value uint32) {
	volatile.StoreUint32(&o.FGCLUT.Reg, volatile.LoadUint32(&o.FGCLUT.Reg)&^(0xff)|value)
}
func (o *DMA2D_Type) GetFGCLUT_BLUE() uint32 {
	return volatile.LoadUint32(&o.FGCLUT.Reg) & 0xff
}

// DMA2D.BGCLUT: BGCLUT
func (o *DMA2D_Type) SetBGCLUT_APLHA(value uint32) {
	volatile.StoreUint32(&o.BGCLUT.Reg, volatile.LoadUint32(&o.BGCLUT.Reg)&^(0xff000000)|value<<24)
}
func (o *DMA2D_Type) GetBGCLUT_APLHA() uint32 {
	return (volatile.LoadUint32(&o.BGCLUT.Reg) & 0xff000000) >> 24
}
func (o *DMA2D_Type) SetBGCLUT_RED(value uint32) {
	volatile.StoreUint32(&o.BGCLUT.Reg, volatile.LoadUint32(&o.BGCLUT.Reg)&^(0xff0000)|value<<16)
}
func (o *DMA2D_Type) GetBGCLUT_RED() uint32 {
	return (volatile.LoadUint32(&o.BGCLUT.Reg) & 0xff0000) >> 16
}
func (o *DMA2D_Type) SetBGCLUT_GREEN(value uint32) {
	volatile.StoreUint32(&o.BGCLUT.Reg, volatile.LoadUint32(&o.BGCLUT.Reg)&^(0xff00)|value<<8)
}
func (o *DMA2D_Type) GetBGCLUT_GREEN() uint32 {
	return (volatile.LoadUint32(&o.BGCLUT.Reg) & 0xff00) >> 8
}
func (o *DMA2D_Type) SetBGCLUT_BLUE(value uint32) {
	volatile.StoreUint32(&o.BGCLUT.Reg, volatile.LoadUint32(&o.BGCLUT.Reg)&^(0xff)|value)
}
func (o *DMA2D_Type) GetBGCLUT_BLUE() uint32 {
	return volatile.LoadUint32(&o.BGCLUT.Reg) & 0xff
}

// QuadSPI interface
type QUADSPI_Type struct {
	CR    volatile.Register32 // 0x0
	DCR   volatile.Register32 // 0x4
	SR    volatile.Register32 // 0x8
	FCR   volatile.Register32 // 0xC
	DLR   volatile.Register32 // 0x10
	CCR   volatile.Register32 // 0x14
	AR    volatile.Register32 // 0x18
	ABR   volatile.Register32 // 0x1C
	DR    volatile.Register32 // 0x20
	PSMKR volatile.Register32 // 0x24
	PSMAR volatile.Register32 // 0x28
	PIR   volatile.Register32 // 0x2C
	LPTR  volatile.Register32 // 0x30
}

// QUADSPI.CR: control register
func (o *QUADSPI_Type) SetCR_PRESCALER(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xff000000)|value<<24)
}
func (o *QUADSPI_Type) GetCR_PRESCALER() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xff000000) >> 24
}
func (o *QUADSPI_Type) SetCR_PMM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800000)|value<<23)
}
func (o *QUADSPI_Type) GetCR_PMM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800000) >> 23
}
func (o *QUADSPI_Type) SetCR_APMS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400000)|value<<22)
}
func (o *QUADSPI_Type) GetCR_APMS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400000) >> 22
}
func (o *QUADSPI_Type) SetCR_TOIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100000)|value<<20)
}
func (o *QUADSPI_Type) GetCR_TOIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100000) >> 20
}
func (o *QUADSPI_Type) SetCR_SMIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *QUADSPI_Type) GetCR_SMIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}
func (o *QUADSPI_Type) SetCR_FTIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *QUADSPI_Type) GetCR_FTIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *QUADSPI_Type) SetCR_TCIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *QUADSPI_Type) GetCR_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *QUADSPI_Type) SetCR_TEIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *QUADSPI_Type) GetCR_TEIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *QUADSPI_Type) SetCR_FTHRES(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1f00)|value<<8)
}
func (o *QUADSPI_Type) GetCR_FTHRES() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1f00) >> 8
}
func (o *QUADSPI_Type) SetCR_FSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *QUADSPI_Type) GetCR_FSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *QUADSPI_Type) SetCR_DFM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *QUADSPI_Type) GetCR_DFM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *QUADSPI_Type) SetCR_SSHIFT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *QUADSPI_Type) GetCR_SSHIFT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *QUADSPI_Type) SetCR_TCEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *QUADSPI_Type) GetCR_TCEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *QUADSPI_Type) SetCR_DMAEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *QUADSPI_Type) GetCR_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *QUADSPI_Type) SetCR_ABORT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *QUADSPI_Type) GetCR_ABORT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *QUADSPI_Type) SetCR_EN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *QUADSPI_Type) GetCR_EN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// QUADSPI.DCR: device configuration register
func (o *QUADSPI_Type) SetDCR_FSIZE(value uint32) {
	volatile.StoreUint32(&o.DCR.Reg, volatile.LoadUint32(&o.DCR.Reg)&^(0x1f0000)|value<<16)
}
func (o *QUADSPI_Type) GetDCR_FSIZE() uint32 {
	return (volatile.LoadUint32(&o.DCR.Reg) & 0x1f0000) >> 16
}
func (o *QUADSPI_Type) SetDCR_CSHT(value uint32) {
	volatile.StoreUint32(&o.DCR.Reg, volatile.LoadUint32(&o.DCR.Reg)&^(0x700)|value<<8)
}
func (o *QUADSPI_Type) GetDCR_CSHT() uint32 {
	return (volatile.LoadUint32(&o.DCR.Reg) & 0x700) >> 8
}
func (o *QUADSPI_Type) SetDCR_CKMODE(value uint32) {
	volatile.StoreUint32(&o.DCR.Reg, volatile.LoadUint32(&o.DCR.Reg)&^(0x1)|value)
}
func (o *QUADSPI_Type) GetDCR_CKMODE() uint32 {
	return volatile.LoadUint32(&o.DCR.Reg) & 0x1
}

// QUADSPI.SR: status register
func (o *QUADSPI_Type) SetSR_FLEVEL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x7f00)|value<<8)
}
func (o *QUADSPI_Type) GetSR_FLEVEL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x7f00) >> 8
}
func (o *QUADSPI_Type) SetSR_BUSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *QUADSPI_Type) GetSR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *QUADSPI_Type) SetSR_TOF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *QUADSPI_Type) GetSR_TOF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *QUADSPI_Type) SetSR_SMF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *QUADSPI_Type) GetSR_SMF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *QUADSPI_Type) SetSR_FTF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *QUADSPI_Type) GetSR_FTF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *QUADSPI_Type) SetSR_TCF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *QUADSPI_Type) GetSR_TCF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *QUADSPI_Type) SetSR_TEF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *QUADSPI_Type) GetSR_TEF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}

// QUADSPI.FCR: flag clear register
func (o *QUADSPI_Type) SetFCR_CTOF(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x10)|value<<4)
}
func (o *QUADSPI_Type) GetFCR_CTOF() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0x10) >> 4
}
func (o *QUADSPI_Type) SetFCR_CSMF(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x8)|value<<3)
}
func (o *QUADSPI_Type) GetFCR_CSMF() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0x8) >> 3
}
func (o *QUADSPI_Type) SetFCR_CTCF(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x2)|value<<1)
}
func (o *QUADSPI_Type) GetFCR_CTCF() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0x2) >> 1
}
func (o *QUADSPI_Type) SetFCR_CTEF(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0x1)|value)
}
func (o *QUADSPI_Type) GetFCR_CTEF() uint32 {
	return volatile.LoadUint32(&o.FCR.Reg) & 0x1
}

// QUADSPI.DLR: data length register
func (o *QUADSPI_Type) SetDLR(value uint32) {
	volatile.StoreUint32(&o.DLR.Reg, value)
}
func (o *QUADSPI_Type) GetDLR() uint32 {
	return volatile.LoadUint32(&o.DLR.Reg)
}

// QUADSPI.CCR: communication configuration register
func (o *QUADSPI_Type) SetCCR_DDRM(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x80000000)|value<<31)
}
func (o *QUADSPI_Type) GetCCR_DDRM() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x80000000) >> 31
}
func (o *QUADSPI_Type) SetCCR_DHHC(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x40000000)|value<<30)
}
func (o *QUADSPI_Type) GetCCR_DHHC() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x40000000) >> 30
}
func (o *QUADSPI_Type) SetCCR_SIOO(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x10000000)|value<<28)
}
func (o *QUADSPI_Type) GetCCR_SIOO() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x10000000) >> 28
}
func (o *QUADSPI_Type) SetCCR_FMODE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0xc000000)|value<<26)
}
func (o *QUADSPI_Type) GetCCR_FMODE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0xc000000) >> 26
}
func (o *QUADSPI_Type) SetCCR_DMODE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x3000000)|value<<24)
}
func (o *QUADSPI_Type) GetCCR_DMODE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x3000000) >> 24
}
func (o *QUADSPI_Type) SetCCR_DCYC(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x7c0000)|value<<18)
}
func (o *QUADSPI_Type) GetCCR_DCYC() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x7c0000) >> 18
}
func (o *QUADSPI_Type) SetCCR_ABSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x30000)|value<<16)
}
func (o *QUADSPI_Type) GetCCR_ABSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x30000) >> 16
}
func (o *QUADSPI_Type) SetCCR_ABMODE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0xc000)|value<<14)
}
func (o *QUADSPI_Type) GetCCR_ABMODE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0xc000) >> 14
}
func (o *QUADSPI_Type) SetCCR_ADSIZE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x3000)|value<<12)
}
func (o *QUADSPI_Type) GetCCR_ADSIZE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x3000) >> 12
}
func (o *QUADSPI_Type) SetCCR_ADMODE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0xc00)|value<<10)
}
func (o *QUADSPI_Type) GetCCR_ADMODE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0xc00) >> 10
}
func (o *QUADSPI_Type) SetCCR_IMODE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x300)|value<<8)
}
func (o *QUADSPI_Type) GetCCR_IMODE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x300) >> 8
}
func (o *QUADSPI_Type) SetCCR_INSTRUCTION(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0xff)|value)
}
func (o *QUADSPI_Type) GetCCR_INSTRUCTION() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0xff
}

// QUADSPI.AR: address register
func (o *QUADSPI_Type) SetAR(value uint32) {
	volatile.StoreUint32(&o.AR.Reg, value)
}
func (o *QUADSPI_Type) GetAR() uint32 {
	return volatile.LoadUint32(&o.AR.Reg)
}

// QUADSPI.ABR: ABR
func (o *QUADSPI_Type) SetABR(value uint32) {
	volatile.StoreUint32(&o.ABR.Reg, value)
}
func (o *QUADSPI_Type) GetABR() uint32 {
	return volatile.LoadUint32(&o.ABR.Reg)
}

// QUADSPI.DR: data register
func (o *QUADSPI_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, value)
}
func (o *QUADSPI_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg)
}

// QUADSPI.PSMKR: polling status mask register
func (o *QUADSPI_Type) SetPSMKR(value uint32) {
	volatile.StoreUint32(&o.PSMKR.Reg, value)
}
func (o *QUADSPI_Type) GetPSMKR() uint32 {
	return volatile.LoadUint32(&o.PSMKR.Reg)
}

// QUADSPI.PSMAR: polling status match register
func (o *QUADSPI_Type) SetPSMAR(value uint32) {
	volatile.StoreUint32(&o.PSMAR.Reg, value)
}
func (o *QUADSPI_Type) GetPSMAR() uint32 {
	return volatile.LoadUint32(&o.PSMAR.Reg)
}

// QUADSPI.PIR: polling interval register
func (o *QUADSPI_Type) SetPIR_INTERVAL(value uint32) {
	volatile.StoreUint32(&o.PIR.Reg, volatile.LoadUint32(&o.PIR.Reg)&^(0xffff)|value)
}
func (o *QUADSPI_Type) GetPIR_INTERVAL() uint32 {
	return volatile.LoadUint32(&o.PIR.Reg) & 0xffff
}

// QUADSPI.LPTR: low-power timeout register
func (o *QUADSPI_Type) SetLPTR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.LPTR.Reg, volatile.LoadUint32(&o.LPTR.Reg)&^(0xffff)|value)
}
func (o *QUADSPI_Type) GetLPTR_TIMEOUT() uint32 {
	return volatile.LoadUint32(&o.LPTR.Reg) & 0xffff
}

// HDMI-CEC controller
type CEC_Type struct {
	CR   volatile.Register32 // 0x0
	CFGR volatile.Register32 // 0x4
	TXDR volatile.Register32 // 0x8
	RXDR volatile.Register32 // 0xC
	ISR  volatile.Register32 // 0x10
	IER  volatile.Register32 // 0x14
}

// CEC.CR: control register
func (o *CEC_Type) SetCR_TXEOM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *CEC_Type) GetCR_TXEOM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *CEC_Type) SetCR_TXSOM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *CEC_Type) GetCR_TXSOM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *CEC_Type) SetCR_CECEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *CEC_Type) GetCR_CECEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// CEC.CFGR: configuration register
func (o *CEC_Type) SetCFGR_SFT(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x7)|value)
}
func (o *CEC_Type) GetCFGR_SFT() uint32 {
	return volatile.LoadUint32(&o.CFGR.Reg) & 0x7
}
func (o *CEC_Type) SetCFGR_RXTOL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x8)|value<<3)
}
func (o *CEC_Type) GetCFGR_RXTOL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x8) >> 3
}
func (o *CEC_Type) SetCFGR_BRESTP(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x10)|value<<4)
}
func (o *CEC_Type) GetCFGR_BRESTP() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x10) >> 4
}
func (o *CEC_Type) SetCFGR_BREGEN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x20)|value<<5)
}
func (o *CEC_Type) GetCFGR_BREGEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x20) >> 5
}
func (o *CEC_Type) SetCFGR_LBPEGEN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x40)|value<<6)
}
func (o *CEC_Type) GetCFGR_LBPEGEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x40) >> 6
}
func (o *CEC_Type) SetCFGR_BRDNOGEN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x80)|value<<7)
}
func (o *CEC_Type) GetCFGR_BRDNOGEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x80) >> 7
}
func (o *CEC_Type) SetCFGR_SFTOP(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x100)|value<<8)
}
func (o *CEC_Type) GetCFGR_SFTOP() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x100) >> 8
}
func (o *CEC_Type) SetCFGR_OAR(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x7fff0000)|value<<16)
}
func (o *CEC_Type) GetCFGR_OAR() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x7fff0000) >> 16
}
func (o *CEC_Type) SetCFGR_LSTN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x80000000)|value<<31)
}
func (o *CEC_Type) GetCFGR_LSTN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x80000000) >> 31
}

// CEC.TXDR: Tx data register
func (o *CEC_Type) SetTXDR_TXD(value uint32) {
	volatile.StoreUint32(&o.TXDR.Reg, volatile.LoadUint32(&o.TXDR.Reg)&^(0xff)|value)
}
func (o *CEC_Type) GetTXDR_TXD() uint32 {
	return volatile.LoadUint32(&o.TXDR.Reg) & 0xff
}

// CEC.RXDR: Rx Data Register
func (o *CEC_Type) SetRXDR(value uint32) {
	volatile.StoreUint32(&o.RXDR.Reg, volatile.LoadUint32(&o.RXDR.Reg)&^(0xff)|value)
}
func (o *CEC_Type) GetRXDR() uint32 {
	return volatile.LoadUint32(&o.RXDR.Reg) & 0xff
}

// CEC.ISR: Interrupt and Status Register
func (o *CEC_Type) SetISR_TXACKE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *CEC_Type) GetISR_TXACKE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *CEC_Type) SetISR_TXERR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *CEC_Type) GetISR_TXERR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *CEC_Type) SetISR_TXUDR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *CEC_Type) GetISR_TXUDR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *CEC_Type) SetISR_TXEND(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *CEC_Type) GetISR_TXEND() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *CEC_Type) SetISR_TXBR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *CEC_Type) GetISR_TXBR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *CEC_Type) SetISR_ARBLST(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *CEC_Type) GetISR_ARBLST() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *CEC_Type) SetISR_RXACKE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *CEC_Type) GetISR_RXACKE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *CEC_Type) SetISR_LBPE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *CEC_Type) GetISR_LBPE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *CEC_Type) SetISR_SBPE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *CEC_Type) GetISR_SBPE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *CEC_Type) SetISR_BRE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *CEC_Type) GetISR_BRE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *CEC_Type) SetISR_RXOVR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *CEC_Type) GetISR_RXOVR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *CEC_Type) SetISR_RXEND(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *CEC_Type) GetISR_RXEND() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *CEC_Type) SetISR_RXBR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *CEC_Type) GetISR_RXBR() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// CEC.IER: interrupt enable register
func (o *CEC_Type) SetIER_TXACKIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000)|value<<12)
}
func (o *CEC_Type) GetIER_TXACKIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000) >> 12
}
func (o *CEC_Type) SetIER_TXERRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *CEC_Type) GetIER_TXERRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *CEC_Type) SetIER_TXUDRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *CEC_Type) GetIER_TXUDRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *CEC_Type) SetIER_TXENDIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *CEC_Type) GetIER_TXENDIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *CEC_Type) SetIER_TXBRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *CEC_Type) GetIER_TXBRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *CEC_Type) SetIER_ARBLSTIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *CEC_Type) GetIER_ARBLSTIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *CEC_Type) SetIER_RXACKIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *CEC_Type) GetIER_RXACKIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *CEC_Type) SetIER_LBPEIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *CEC_Type) GetIER_LBPEIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *CEC_Type) SetIER_SBPEIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *CEC_Type) GetIER_SBPEIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *CEC_Type) SetIER_BREIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *CEC_Type) GetIER_BREIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *CEC_Type) SetIER_RXOVRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *CEC_Type) GetIER_RXOVRIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *CEC_Type) SetIER_RXENDIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *CEC_Type) GetIER_RXENDIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *CEC_Type) SetIER_RXBRIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *CEC_Type) GetIER_RXBRIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// Receiver Interface
type SPDIF_RX_Type struct {
	CR   volatile.Register32 // 0x0
	IMR  volatile.Register32 // 0x4
	SR   volatile.Register32 // 0x8
	IFCR volatile.Register32 // 0xC
	DR   volatile.Register32 // 0x10
	CSR  volatile.Register32 // 0x14
	DIR  volatile.Register32 // 0x18
}

// SPDIF_RX.CR: Control register
func (o *SPDIF_RX_Type) SetCR_SPDIFEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3)|value)
}
func (o *SPDIF_RX_Type) GetCR_SPDIFEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x3
}
func (o *SPDIF_RX_Type) SetCR_RXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *SPDIF_RX_Type) GetCR_RXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *SPDIF_RX_Type) SetCR_RXSTEO(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *SPDIF_RX_Type) GetCR_RXSTEO() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *SPDIF_RX_Type) SetCR_DRFMT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x30)|value<<4)
}
func (o *SPDIF_RX_Type) GetCR_DRFMT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x30) >> 4
}
func (o *SPDIF_RX_Type) SetCR_PMSK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *SPDIF_RX_Type) GetCR_PMSK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *SPDIF_RX_Type) SetCR_VMSK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *SPDIF_RX_Type) GetCR_VMSK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *SPDIF_RX_Type) SetCR_CUMSK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *SPDIF_RX_Type) GetCR_CUMSK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *SPDIF_RX_Type) SetCR_PTMSK(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *SPDIF_RX_Type) GetCR_PTMSK() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *SPDIF_RX_Type) SetCR_CBDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *SPDIF_RX_Type) GetCR_CBDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *SPDIF_RX_Type) SetCR_CHSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *SPDIF_RX_Type) GetCR_CHSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *SPDIF_RX_Type) SetCR_NBTR(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3000)|value<<12)
}
func (o *SPDIF_RX_Type) GetCR_NBTR() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x3000) >> 12
}
func (o *SPDIF_RX_Type) SetCR_WFA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *SPDIF_RX_Type) GetCR_WFA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *SPDIF_RX_Type) SetCR_INSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x70000)|value<<16)
}
func (o *SPDIF_RX_Type) GetCR_INSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x70000) >> 16
}

// SPDIF_RX.IMR: Interrupt mask register
func (o *SPDIF_RX_Type) SetIMR_RXNEIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x1)|value)
}
func (o *SPDIF_RX_Type) GetIMR_RXNEIE() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg) & 0x1
}
func (o *SPDIF_RX_Type) SetIMR_CSRNEIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x2)|value<<1)
}
func (o *SPDIF_RX_Type) GetIMR_CSRNEIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x2) >> 1
}
func (o *SPDIF_RX_Type) SetIMR_PERRIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x4)|value<<2)
}
func (o *SPDIF_RX_Type) GetIMR_PERRIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x4) >> 2
}
func (o *SPDIF_RX_Type) SetIMR_OVRIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x8)|value<<3)
}
func (o *SPDIF_RX_Type) GetIMR_OVRIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x8) >> 3
}
func (o *SPDIF_RX_Type) SetIMR_SBLKIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x10)|value<<4)
}
func (o *SPDIF_RX_Type) GetIMR_SBLKIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x10) >> 4
}
func (o *SPDIF_RX_Type) SetIMR_SYNCDIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x20)|value<<5)
}
func (o *SPDIF_RX_Type) GetIMR_SYNCDIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x20) >> 5
}
func (o *SPDIF_RX_Type) SetIMR_IFEIE(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, volatile.LoadUint32(&o.IMR.Reg)&^(0x40)|value<<6)
}
func (o *SPDIF_RX_Type) GetIMR_IFEIE() uint32 {
	return (volatile.LoadUint32(&o.IMR.Reg) & 0x40) >> 6
}

// SPDIF_RX.SR: Status register
func (o *SPDIF_RX_Type) SetSR_RXNE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SPDIF_RX_Type) GetSR_RXNE() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *SPDIF_RX_Type) SetSR_CSRNE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *SPDIF_RX_Type) GetSR_CSRNE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *SPDIF_RX_Type) SetSR_PERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *SPDIF_RX_Type) GetSR_PERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *SPDIF_RX_Type) SetSR_OVR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *SPDIF_RX_Type) GetSR_OVR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *SPDIF_RX_Type) SetSR_SBD(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *SPDIF_RX_Type) GetSR_SBD() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *SPDIF_RX_Type) SetSR_SYNCD(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *SPDIF_RX_Type) GetSR_SYNCD() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *SPDIF_RX_Type) SetSR_FERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *SPDIF_RX_Type) GetSR_FERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *SPDIF_RX_Type) SetSR_SERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *SPDIF_RX_Type) GetSR_SERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *SPDIF_RX_Type) SetSR_TERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *SPDIF_RX_Type) GetSR_TERR() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *SPDIF_RX_Type) SetSR_WIDTH5(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x7fff0000)|value<<16)
}
func (o *SPDIF_RX_Type) GetSR_WIDTH5() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x7fff0000) >> 16
}

// SPDIF_RX.IFCR: Interrupt Flag Clear register
func (o *SPDIF_RX_Type) SetIFCR_PERRCF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x4)|value<<2)
}
func (o *SPDIF_RX_Type) GetIFCR_PERRCF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x4) >> 2
}
func (o *SPDIF_RX_Type) SetIFCR_OVRCF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x8)|value<<3)
}
func (o *SPDIF_RX_Type) GetIFCR_OVRCF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x8) >> 3
}
func (o *SPDIF_RX_Type) SetIFCR_SBDCF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x10)|value<<4)
}
func (o *SPDIF_RX_Type) GetIFCR_SBDCF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x10) >> 4
}
func (o *SPDIF_RX_Type) SetIFCR_SYNCDCF(value uint32) {
	volatile.StoreUint32(&o.IFCR.Reg, volatile.LoadUint32(&o.IFCR.Reg)&^(0x20)|value<<5)
}
func (o *SPDIF_RX_Type) GetIFCR_SYNCDCF() uint32 {
	return (volatile.LoadUint32(&o.IFCR.Reg) & 0x20) >> 5
}

// SPDIF_RX.DR: Data input register
func (o *SPDIF_RX_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xffffff)|value)
}
func (o *SPDIF_RX_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg) & 0xffffff
}
func (o *SPDIF_RX_Type) SetDR_PE(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0x1000000)|value<<24)
}
func (o *SPDIF_RX_Type) GetDR_PE() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0x1000000) >> 24
}
func (o *SPDIF_RX_Type) SetDR_V(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0x2000000)|value<<25)
}
func (o *SPDIF_RX_Type) GetDR_V() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0x2000000) >> 25
}
func (o *SPDIF_RX_Type) SetDR_U(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0x4000000)|value<<26)
}
func (o *SPDIF_RX_Type) GetDR_U() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0x4000000) >> 26
}
func (o *SPDIF_RX_Type) SetDR_C(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0x8000000)|value<<27)
}
func (o *SPDIF_RX_Type) GetDR_C() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0x8000000) >> 27
}
func (o *SPDIF_RX_Type) SetDR_PT(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0x30000000)|value<<28)
}
func (o *SPDIF_RX_Type) GetDR_PT() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0x30000000) >> 28
}

// SPDIF_RX.CSR: Channel Status register
func (o *SPDIF_RX_Type) SetCSR_USR(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0xffff)|value)
}
func (o *SPDIF_RX_Type) GetCSR_USR() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0xffff
}
func (o *SPDIF_RX_Type) SetCSR_CS(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0xff0000)|value<<16)
}
func (o *SPDIF_RX_Type) GetCSR_CS() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0xff0000) >> 16
}
func (o *SPDIF_RX_Type) SetCSR_SOB(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1000000)|value<<24)
}
func (o *SPDIF_RX_Type) GetCSR_SOB() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x1000000) >> 24
}

// SPDIF_RX.DIR: Debug Information register
func (o *SPDIF_RX_Type) SetDIR_THI(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x1fff)|value)
}
func (o *SPDIF_RX_Type) GetDIR_THI() uint32 {
	return volatile.LoadUint32(&o.DIR.Reg) & 0x1fff
}
func (o *SPDIF_RX_Type) SetDIR_TLO(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x1fff0000)|value<<16)
}
func (o *SPDIF_RX_Type) GetDIR_TLO() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x1fff0000) >> 16
}

// Secure digital input/output interface
type SDMMC_Type struct {
	POWER   volatile.Register32 // 0x0
	CLKCR   volatile.Register32 // 0x4
	ARG     volatile.Register32 // 0x8
	CMD     volatile.Register32 // 0xC
	RESPCMD volatile.Register32 // 0x10
	RESP1   volatile.Register32 // 0x14
	RESP2   volatile.Register32 // 0x18
	RESP3   volatile.Register32 // 0x1C
	RESP4   volatile.Register32 // 0x20
	DTIMER  volatile.Register32 // 0x24
	DLEN    volatile.Register32 // 0x28
	DCTRL   volatile.Register32 // 0x2C
	DCOUNT  volatile.Register32 // 0x30
	STA     volatile.Register32 // 0x34
	ICR     volatile.Register32 // 0x38
	MASK    volatile.Register32 // 0x3C
	_       [8]byte
	FIFOCNT volatile.Register32 // 0x48
	_       [52]byte
	FIFO    volatile.Register32 // 0x80
}

// SDMMC.POWER: power control register
func (o *SDMMC_Type) SetPOWER_PWRCTRL(value uint32) {
	volatile.StoreUint32(&o.POWER.Reg, volatile.LoadUint32(&o.POWER.Reg)&^(0x3)|value)
}
func (o *SDMMC_Type) GetPOWER_PWRCTRL() uint32 {
	return volatile.LoadUint32(&o.POWER.Reg) & 0x3
}

// SDMMC.CLKCR: SDI clock control register
func (o *SDMMC_Type) SetCLKCR_HWFC_EN(value uint32) {
	volatile.StoreUint32(&o.CLKCR.Reg, volatile.LoadUint32(&o.CLKCR.Reg)&^(0x4000)|value<<14)
}
func (o *SDMMC_Type) GetCLKCR_HWFC_EN() uint32 {
	return (volatile.LoadUint32(&o.CLKCR.Reg) & 0x4000) >> 14
}
func (o *SDMMC_Type) SetCLKCR_NEGEDGE(value uint32) {
	volatile.StoreUint32(&o.CLKCR.Reg, volatile.LoadUint32(&o.CLKCR.Reg)&^(0x2000)|value<<13)
}
func (o *SDMMC_Type) GetCLKCR_NEGEDGE() uint32 {
	return (volatile.LoadUint32(&o.CLKCR.Reg) & 0x2000) >> 13
}
func (o *SDMMC_Type) SetCLKCR_WIDBUS(value uint32) {
	volatile.StoreUint32(&o.CLKCR.Reg, volatile.LoadUint32(&o.CLKCR.Reg)&^(0x1800)|value<<11)
}
func (o *SDMMC_Type) GetCLKCR_WIDBUS() uint32 {
	return (volatile.LoadUint32(&o.CLKCR.Reg) & 0x1800) >> 11
}
func (o *SDMMC_Type) SetCLKCR_BYPASS(value uint32) {
	volatile.StoreUint32(&o.CLKCR.Reg, volatile.LoadUint32(&o.CLKCR.Reg)&^(0x400)|value<<10)
}
func (o *SDMMC_Type) GetCLKCR_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.CLKCR.Reg) & 0x400) >> 10
}
func (o *SDMMC_Type) SetCLKCR_PWRSAV(value uint32) {
	volatile.StoreUint32(&o.CLKCR.Reg, volatile.LoadUint32(&o.CLKCR.Reg)&^(0x200)|value<<9)
}
func (o *SDMMC_Type) GetCLKCR_PWRSAV() uint32 {
	return (volatile.LoadUint32(&o.CLKCR.Reg) & 0x200) >> 9
}
func (o *SDMMC_Type) SetCLKCR_CLKEN(value uint32) {
	volatile.StoreUint32(&o.CLKCR.Reg, volatile.LoadUint32(&o.CLKCR.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetCLKCR_CLKEN() uint32 {
	return (volatile.LoadUint32(&o.CLKCR.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetCLKCR_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.CLKCR.Reg, volatile.LoadUint32(&o.CLKCR.Reg)&^(0xff)|value)
}
func (o *SDMMC_Type) GetCLKCR_CLKDIV() uint32 {
	return volatile.LoadUint32(&o.CLKCR.Reg) & 0xff
}

// SDMMC.ARG: argument register
func (o *SDMMC_Type) SetARG(value uint32) {
	volatile.StoreUint32(&o.ARG.Reg, value)
}
func (o *SDMMC_Type) GetARG() uint32 {
	return volatile.LoadUint32(&o.ARG.Reg)
}

// SDMMC.CMD: command register
func (o *SDMMC_Type) SetCMD_SDIOSuspend(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x800)|value<<11)
}
func (o *SDMMC_Type) GetCMD_SDIOSuspend() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x800) >> 11
}
func (o *SDMMC_Type) SetCMD_CPSMEN(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x400)|value<<10)
}
func (o *SDMMC_Type) GetCMD_CPSMEN() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x400) >> 10
}
func (o *SDMMC_Type) SetCMD_WAITPEND(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x200)|value<<9)
}
func (o *SDMMC_Type) GetCMD_WAITPEND() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x200) >> 9
}
func (o *SDMMC_Type) SetCMD_WAITINT(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetCMD_WAITINT() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetCMD_WAITRESP(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0xc0)|value<<6)
}
func (o *SDMMC_Type) GetCMD_WAITRESP() uint32 {
	return (volatile.LoadUint32(&o.CMD.Reg) & 0xc0) >> 6
}
func (o *SDMMC_Type) SetCMD_CMDINDEX(value uint32) {
	volatile.StoreUint32(&o.CMD.Reg, volatile.LoadUint32(&o.CMD.Reg)&^(0x3f)|value)
}
func (o *SDMMC_Type) GetCMD_CMDINDEX() uint32 {
	return volatile.LoadUint32(&o.CMD.Reg) & 0x3f
}

// SDMMC.RESPCMD: command response register
func (o *SDMMC_Type) SetRESPCMD(value uint32) {
	volatile.StoreUint32(&o.RESPCMD.Reg, volatile.LoadUint32(&o.RESPCMD.Reg)&^(0x3f)|value)
}
func (o *SDMMC_Type) GetRESPCMD() uint32 {
	return volatile.LoadUint32(&o.RESPCMD.Reg) & 0x3f
}

// SDMMC.RESP1: response 1..4 register
func (o *SDMMC_Type) SetRESP1(value uint32) {
	volatile.StoreUint32(&o.RESP1.Reg, value)
}
func (o *SDMMC_Type) GetRESP1() uint32 {
	return volatile.LoadUint32(&o.RESP1.Reg)
}

// SDMMC.RESP2: response 1..4 register
func (o *SDMMC_Type) SetRESP2(value uint32) {
	volatile.StoreUint32(&o.RESP2.Reg, value)
}
func (o *SDMMC_Type) GetRESP2() uint32 {
	return volatile.LoadUint32(&o.RESP2.Reg)
}

// SDMMC.RESP3: response 1..4 register
func (o *SDMMC_Type) SetRESP3(value uint32) {
	volatile.StoreUint32(&o.RESP3.Reg, value)
}
func (o *SDMMC_Type) GetRESP3() uint32 {
	return volatile.LoadUint32(&o.RESP3.Reg)
}

// SDMMC.RESP4: response 1..4 register
func (o *SDMMC_Type) SetRESP4(value uint32) {
	volatile.StoreUint32(&o.RESP4.Reg, value)
}
func (o *SDMMC_Type) GetRESP4() uint32 {
	return volatile.LoadUint32(&o.RESP4.Reg)
}

// SDMMC.DTIMER: data timer register
func (o *SDMMC_Type) SetDTIMER(value uint32) {
	volatile.StoreUint32(&o.DTIMER.Reg, value)
}
func (o *SDMMC_Type) GetDTIMER() uint32 {
	return volatile.LoadUint32(&o.DTIMER.Reg)
}

// SDMMC.DLEN: data length register
func (o *SDMMC_Type) SetDLEN_DATALENGTH(value uint32) {
	volatile.StoreUint32(&o.DLEN.Reg, volatile.LoadUint32(&o.DLEN.Reg)&^(0x1ffffff)|value)
}
func (o *SDMMC_Type) GetDLEN_DATALENGTH() uint32 {
	return volatile.LoadUint32(&o.DLEN.Reg) & 0x1ffffff
}

// SDMMC.DCTRL: data control register
func (o *SDMMC_Type) SetDCTRL_SDIOEN(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x800)|value<<11)
}
func (o *SDMMC_Type) GetDCTRL_SDIOEN() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0x800) >> 11
}
func (o *SDMMC_Type) SetDCTRL_RWMOD(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x400)|value<<10)
}
func (o *SDMMC_Type) GetDCTRL_RWMOD() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0x400) >> 10
}
func (o *SDMMC_Type) SetDCTRL_RWSTOP(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x200)|value<<9)
}
func (o *SDMMC_Type) GetDCTRL_RWSTOP() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0x200) >> 9
}
func (o *SDMMC_Type) SetDCTRL_RWSTART(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetDCTRL_RWSTART() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetDCTRL_DBLOCKSIZE(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0xf0)|value<<4)
}
func (o *SDMMC_Type) GetDCTRL_DBLOCKSIZE() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0xf0) >> 4
}
func (o *SDMMC_Type) SetDCTRL_DMAEN(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x8)|value<<3)
}
func (o *SDMMC_Type) GetDCTRL_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0x8) >> 3
}
func (o *SDMMC_Type) SetDCTRL_DTMODE(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x4)|value<<2)
}
func (o *SDMMC_Type) GetDCTRL_DTMODE() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0x4) >> 2
}
func (o *SDMMC_Type) SetDCTRL_DTDIR(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x2)|value<<1)
}
func (o *SDMMC_Type) GetDCTRL_DTDIR() uint32 {
	return (volatile.LoadUint32(&o.DCTRL.Reg) & 0x2) >> 1
}
func (o *SDMMC_Type) SetDCTRL_DTEN(value uint32) {
	volatile.StoreUint32(&o.DCTRL.Reg, volatile.LoadUint32(&o.DCTRL.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetDCTRL_DTEN() uint32 {
	return volatile.LoadUint32(&o.DCTRL.Reg) & 0x1
}

// SDMMC.DCOUNT: data counter register
func (o *SDMMC_Type) SetDCOUNT_DATACOUNT(value uint32) {
	volatile.StoreUint32(&o.DCOUNT.Reg, volatile.LoadUint32(&o.DCOUNT.Reg)&^(0x1ffffff)|value)
}
func (o *SDMMC_Type) GetDCOUNT_DATACOUNT() uint32 {
	return volatile.LoadUint32(&o.DCOUNT.Reg) & 0x1ffffff
}

// SDMMC.STA: status register
func (o *SDMMC_Type) SetSTA_SDIOIT(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x400000)|value<<22)
}
func (o *SDMMC_Type) GetSTA_SDIOIT() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x400000) >> 22
}
func (o *SDMMC_Type) SetSTA_RXDAVL(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x200000)|value<<21)
}
func (o *SDMMC_Type) GetSTA_RXDAVL() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x200000) >> 21
}
func (o *SDMMC_Type) SetSTA_TXDAVL(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x100000)|value<<20)
}
func (o *SDMMC_Type) GetSTA_TXDAVL() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x100000) >> 20
}
func (o *SDMMC_Type) SetSTA_RXFIFOE(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x80000)|value<<19)
}
func (o *SDMMC_Type) GetSTA_RXFIFOE() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x80000) >> 19
}
func (o *SDMMC_Type) SetSTA_TXFIFOE(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x40000)|value<<18)
}
func (o *SDMMC_Type) GetSTA_TXFIFOE() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x40000) >> 18
}
func (o *SDMMC_Type) SetSTA_RXFIFOF(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x20000)|value<<17)
}
func (o *SDMMC_Type) GetSTA_RXFIFOF() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x20000) >> 17
}
func (o *SDMMC_Type) SetSTA_TXFIFOF(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x10000)|value<<16)
}
func (o *SDMMC_Type) GetSTA_TXFIFOF() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x10000) >> 16
}
func (o *SDMMC_Type) SetSTA_RXFIFOHF(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x8000)|value<<15)
}
func (o *SDMMC_Type) GetSTA_RXFIFOHF() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x8000) >> 15
}
func (o *SDMMC_Type) SetSTA_TXFIFOHE(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x4000)|value<<14)
}
func (o *SDMMC_Type) GetSTA_TXFIFOHE() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x4000) >> 14
}
func (o *SDMMC_Type) SetSTA_RXACT(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x2000)|value<<13)
}
func (o *SDMMC_Type) GetSTA_RXACT() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x2000) >> 13
}
func (o *SDMMC_Type) SetSTA_TXACT(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x1000)|value<<12)
}
func (o *SDMMC_Type) GetSTA_TXACT() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x1000) >> 12
}
func (o *SDMMC_Type) SetSTA_CMDACT(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x800)|value<<11)
}
func (o *SDMMC_Type) GetSTA_CMDACT() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x800) >> 11
}
func (o *SDMMC_Type) SetSTA_DBCKEND(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x400)|value<<10)
}
func (o *SDMMC_Type) GetSTA_DBCKEND() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x400) >> 10
}
func (o *SDMMC_Type) SetSTA_DATAEND(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetSTA_DATAEND() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetSTA_CMDSENT(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x80)|value<<7)
}
func (o *SDMMC_Type) GetSTA_CMDSENT() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x80) >> 7
}
func (o *SDMMC_Type) SetSTA_CMDREND(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x40)|value<<6)
}
func (o *SDMMC_Type) GetSTA_CMDREND() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x40) >> 6
}
func (o *SDMMC_Type) SetSTA_RXOVERR(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x20)|value<<5)
}
func (o *SDMMC_Type) GetSTA_RXOVERR() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x20) >> 5
}
func (o *SDMMC_Type) SetSTA_TXUNDERR(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x10)|value<<4)
}
func (o *SDMMC_Type) GetSTA_TXUNDERR() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x10) >> 4
}
func (o *SDMMC_Type) SetSTA_DTIMEOUT(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x8)|value<<3)
}
func (o *SDMMC_Type) GetSTA_DTIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x8) >> 3
}
func (o *SDMMC_Type) SetSTA_CTIMEOUT(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x4)|value<<2)
}
func (o *SDMMC_Type) GetSTA_CTIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x4) >> 2
}
func (o *SDMMC_Type) SetSTA_DCRCFAIL(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x2)|value<<1)
}
func (o *SDMMC_Type) GetSTA_DCRCFAIL() uint32 {
	return (volatile.LoadUint32(&o.STA.Reg) & 0x2) >> 1
}
func (o *SDMMC_Type) SetSTA_CCRCFAIL(value uint32) {
	volatile.StoreUint32(&o.STA.Reg, volatile.LoadUint32(&o.STA.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetSTA_CCRCFAIL() uint32 {
	return volatile.LoadUint32(&o.STA.Reg) & 0x1
}

// SDMMC.ICR: interrupt clear register
func (o *SDMMC_Type) SetICR_SDIOITC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x400000)|value<<22)
}
func (o *SDMMC_Type) GetICR_SDIOITC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x400000) >> 22
}
func (o *SDMMC_Type) SetICR_DBCKENDC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x400)|value<<10)
}
func (o *SDMMC_Type) GetICR_DBCKENDC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x400) >> 10
}
func (o *SDMMC_Type) SetICR_DATAENDC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetICR_DATAENDC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetICR_CMDSENTC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x80)|value<<7)
}
func (o *SDMMC_Type) GetICR_CMDSENTC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x80) >> 7
}
func (o *SDMMC_Type) SetICR_CMDRENDC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x40)|value<<6)
}
func (o *SDMMC_Type) GetICR_CMDRENDC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x40) >> 6
}
func (o *SDMMC_Type) SetICR_RXOVERRC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20)|value<<5)
}
func (o *SDMMC_Type) GetICR_RXOVERRC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20) >> 5
}
func (o *SDMMC_Type) SetICR_TXUNDERRC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *SDMMC_Type) GetICR_TXUNDERRC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *SDMMC_Type) SetICR_DTIMEOUTC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *SDMMC_Type) GetICR_DTIMEOUTC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *SDMMC_Type) SetICR_CTIMEOUTC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *SDMMC_Type) GetICR_CTIMEOUTC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *SDMMC_Type) SetICR_DCRCFAILC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *SDMMC_Type) GetICR_DCRCFAILC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *SDMMC_Type) SetICR_CCRCFAILC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetICR_CCRCFAILC() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}

// SDMMC.MASK: mask register
func (o *SDMMC_Type) SetMASK_SDIOITIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x400000)|value<<22)
}
func (o *SDMMC_Type) GetMASK_SDIOITIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x400000) >> 22
}
func (o *SDMMC_Type) SetMASK_RXDAVLIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x200000)|value<<21)
}
func (o *SDMMC_Type) GetMASK_RXDAVLIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x200000) >> 21
}
func (o *SDMMC_Type) SetMASK_TXDAVLIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x100000)|value<<20)
}
func (o *SDMMC_Type) GetMASK_TXDAVLIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x100000) >> 20
}
func (o *SDMMC_Type) SetMASK_RXFIFOEIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x80000)|value<<19)
}
func (o *SDMMC_Type) GetMASK_RXFIFOEIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x80000) >> 19
}
func (o *SDMMC_Type) SetMASK_TXFIFOEIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x40000)|value<<18)
}
func (o *SDMMC_Type) GetMASK_TXFIFOEIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x40000) >> 18
}
func (o *SDMMC_Type) SetMASK_RXFIFOFIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x20000)|value<<17)
}
func (o *SDMMC_Type) GetMASK_RXFIFOFIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x20000) >> 17
}
func (o *SDMMC_Type) SetMASK_TXFIFOFIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x10000)|value<<16)
}
func (o *SDMMC_Type) GetMASK_TXFIFOFIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x10000) >> 16
}
func (o *SDMMC_Type) SetMASK_RXFIFOHFIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x8000)|value<<15)
}
func (o *SDMMC_Type) GetMASK_RXFIFOHFIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x8000) >> 15
}
func (o *SDMMC_Type) SetMASK_TXFIFOHEIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x4000)|value<<14)
}
func (o *SDMMC_Type) GetMASK_TXFIFOHEIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x4000) >> 14
}
func (o *SDMMC_Type) SetMASK_RXACTIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x2000)|value<<13)
}
func (o *SDMMC_Type) GetMASK_RXACTIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x2000) >> 13
}
func (o *SDMMC_Type) SetMASK_TXACTIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x1000)|value<<12)
}
func (o *SDMMC_Type) GetMASK_TXACTIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x1000) >> 12
}
func (o *SDMMC_Type) SetMASK_CMDACTIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x800)|value<<11)
}
func (o *SDMMC_Type) GetMASK_CMDACTIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x800) >> 11
}
func (o *SDMMC_Type) SetMASK_DBCKENDIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x400)|value<<10)
}
func (o *SDMMC_Type) GetMASK_DBCKENDIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x400) >> 10
}
func (o *SDMMC_Type) SetMASK_DATAENDIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetMASK_DATAENDIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetMASK_CMDSENTIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x80)|value<<7)
}
func (o *SDMMC_Type) GetMASK_CMDSENTIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x80) >> 7
}
func (o *SDMMC_Type) SetMASK_CMDRENDIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x40)|value<<6)
}
func (o *SDMMC_Type) GetMASK_CMDRENDIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x40) >> 6
}
func (o *SDMMC_Type) SetMASK_RXOVERRIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x20)|value<<5)
}
func (o *SDMMC_Type) GetMASK_RXOVERRIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x20) >> 5
}
func (o *SDMMC_Type) SetMASK_TXUNDERRIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x10)|value<<4)
}
func (o *SDMMC_Type) GetMASK_TXUNDERRIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x10) >> 4
}
func (o *SDMMC_Type) SetMASK_DTIMEOUTIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x8)|value<<3)
}
func (o *SDMMC_Type) GetMASK_DTIMEOUTIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x8) >> 3
}
func (o *SDMMC_Type) SetMASK_CTIMEOUTIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x4)|value<<2)
}
func (o *SDMMC_Type) GetMASK_CTIMEOUTIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x4) >> 2
}
func (o *SDMMC_Type) SetMASK_DCRCFAILIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x2)|value<<1)
}
func (o *SDMMC_Type) GetMASK_DCRCFAILIE() uint32 {
	return (volatile.LoadUint32(&o.MASK.Reg) & 0x2) >> 1
}
func (o *SDMMC_Type) SetMASK_CCRCFAILIE(value uint32) {
	volatile.StoreUint32(&o.MASK.Reg, volatile.LoadUint32(&o.MASK.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetMASK_CCRCFAILIE() uint32 {
	return volatile.LoadUint32(&o.MASK.Reg) & 0x1
}

// SDMMC.FIFOCNT: FIFO counter register
func (o *SDMMC_Type) SetFIFOCNT_FIFOCOUNT(value uint32) {
	volatile.StoreUint32(&o.FIFOCNT.Reg, volatile.LoadUint32(&o.FIFOCNT.Reg)&^(0xffffff)|value)
}
func (o *SDMMC_Type) GetFIFOCNT_FIFOCOUNT() uint32 {
	return volatile.LoadUint32(&o.FIFOCNT.Reg) & 0xffffff
}

// SDMMC.FIFO: data FIFO register
func (o *SDMMC_Type) SetFIFO(value uint32) {
	volatile.StoreUint32(&o.FIFO.Reg, value)
}
func (o *SDMMC_Type) GetFIFO() uint32 {
	return volatile.LoadUint32(&o.FIFO.Reg)
}

// Low power timer
type LPTIM_Type struct {
	ISR  volatile.Register32 // 0x0
	ICR  volatile.Register32 // 0x4
	IER  volatile.Register32 // 0x8
	CFGR volatile.Register32 // 0xC
	CR   volatile.Register32 // 0x10
	CMP  volatile.Register32 // 0x14
	ARR  volatile.Register32 // 0x18
	CNT  volatile.Register32 // 0x1C
}

// LPTIM.ISR: Interrupt and Status Register
func (o *LPTIM_Type) SetISR_DOWN(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *LPTIM_Type) GetISR_DOWN() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *LPTIM_Type) SetISR_UP(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *LPTIM_Type) GetISR_UP() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *LPTIM_Type) SetISR_ARROK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *LPTIM_Type) GetISR_ARROK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *LPTIM_Type) SetISR_CMPOK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *LPTIM_Type) GetISR_CMPOK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *LPTIM_Type) SetISR_EXTTRIG(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *LPTIM_Type) GetISR_EXTTRIG() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *LPTIM_Type) SetISR_ARRM(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *LPTIM_Type) GetISR_ARRM() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *LPTIM_Type) SetISR_CMPM(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetISR_CMPM() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// LPTIM.ICR: Interrupt Clear Register
func (o *LPTIM_Type) SetICR_DOWNCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x40)|value<<6)
}
func (o *LPTIM_Type) GetICR_DOWNCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x40) >> 6
}
func (o *LPTIM_Type) SetICR_UPCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20)|value<<5)
}
func (o *LPTIM_Type) GetICR_UPCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20) >> 5
}
func (o *LPTIM_Type) SetICR_ARROKCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *LPTIM_Type) GetICR_ARROKCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *LPTIM_Type) SetICR_CMPOKCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *LPTIM_Type) GetICR_CMPOKCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *LPTIM_Type) SetICR_EXTTRIGCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *LPTIM_Type) GetICR_EXTTRIGCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *LPTIM_Type) SetICR_ARRMCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *LPTIM_Type) GetICR_ARRMCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *LPTIM_Type) SetICR_CMPMCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetICR_CMPMCF() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}

// LPTIM.IER: Interrupt Enable Register
func (o *LPTIM_Type) SetIER_DOWNIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *LPTIM_Type) GetIER_DOWNIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *LPTIM_Type) SetIER_UPIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *LPTIM_Type) GetIER_UPIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *LPTIM_Type) SetIER_ARROKIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *LPTIM_Type) GetIER_ARROKIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *LPTIM_Type) SetIER_CMPOKIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *LPTIM_Type) GetIER_CMPOKIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *LPTIM_Type) SetIER_EXTTRIGIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *LPTIM_Type) GetIER_EXTTRIGIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *LPTIM_Type) SetIER_ARRMIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *LPTIM_Type) GetIER_ARRMIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *LPTIM_Type) SetIER_CMPMIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetIER_CMPMIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}

// LPTIM.CFGR: Configuration Register
func (o *LPTIM_Type) SetCFGR_ENC(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x1000000)|value<<24)
}
func (o *LPTIM_Type) GetCFGR_ENC() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x1000000) >> 24
}
func (o *LPTIM_Type) SetCFGR_COUNTMODE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x800000)|value<<23)
}
func (o *LPTIM_Type) GetCFGR_COUNTMODE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x800000) >> 23
}
func (o *LPTIM_Type) SetCFGR_PRELOAD(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x400000)|value<<22)
}
func (o *LPTIM_Type) GetCFGR_PRELOAD() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x400000) >> 22
}
func (o *LPTIM_Type) SetCFGR_WAVPOL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x200000)|value<<21)
}
func (o *LPTIM_Type) GetCFGR_WAVPOL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x200000) >> 21
}
func (o *LPTIM_Type) SetCFGR_WAVE(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x100000)|value<<20)
}
func (o *LPTIM_Type) GetCFGR_WAVE() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x100000) >> 20
}
func (o *LPTIM_Type) SetCFGR_TIMOUT(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x80000)|value<<19)
}
func (o *LPTIM_Type) GetCFGR_TIMOUT() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x80000) >> 19
}
func (o *LPTIM_Type) SetCFGR_TRIGEN(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x60000)|value<<17)
}
func (o *LPTIM_Type) GetCFGR_TRIGEN() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x60000) >> 17
}
func (o *LPTIM_Type) SetCFGR_TRIGSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xe000)|value<<13)
}
func (o *LPTIM_Type) GetCFGR_TRIGSEL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xe000) >> 13
}
func (o *LPTIM_Type) SetCFGR_PRESC(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xe00)|value<<9)
}
func (o *LPTIM_Type) GetCFGR_PRESC() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xe00) >> 9
}
func (o *LPTIM_Type) SetCFGR_TRGFLT(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0xc0)|value<<6)
}
func (o *LPTIM_Type) GetCFGR_TRGFLT() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0xc0) >> 6
}
func (o *LPTIM_Type) SetCFGR_CKFLT(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x18)|value<<3)
}
func (o *LPTIM_Type) GetCFGR_CKFLT() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x18) >> 3
}
func (o *LPTIM_Type) SetCFGR_CKPOL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x6)|value<<1)
}
func (o *LPTIM_Type) GetCFGR_CKPOL() uint32 {
	return (volatile.LoadUint32(&o.CFGR.Reg) & 0x6) >> 1
}
func (o *LPTIM_Type) SetCFGR_CKSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR.Reg, volatile.LoadUint32(&o.CFGR.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetCFGR_CKSEL() uint32 {
	return volatile.LoadUint32(&o.CFGR.Reg) & 0x1
}

// LPTIM.CR: Control Register
func (o *LPTIM_Type) SetCR_CNTSTRT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *LPTIM_Type) GetCR_CNTSTRT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *LPTIM_Type) SetCR_SNGSTRT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *LPTIM_Type) GetCR_SNGSTRT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *LPTIM_Type) SetCR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *LPTIM_Type) GetCR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// LPTIM.CMP: Compare Register
func (o *LPTIM_Type) SetCMP(value uint32) {
	volatile.StoreUint32(&o.CMP.Reg, volatile.LoadUint32(&o.CMP.Reg)&^(0xffff)|value)
}
func (o *LPTIM_Type) GetCMP() uint32 {
	return volatile.LoadUint32(&o.CMP.Reg) & 0xffff
}

// LPTIM.ARR: Autoreload Register
func (o *LPTIM_Type) SetARR(value uint32) {
	volatile.StoreUint32(&o.ARR.Reg, volatile.LoadUint32(&o.ARR.Reg)&^(0xffff)|value)
}
func (o *LPTIM_Type) GetARR() uint32 {
	return volatile.LoadUint32(&o.ARR.Reg) & 0xffff
}

// LPTIM.CNT: Counter Register
func (o *LPTIM_Type) SetCNT(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0xffff)|value)
}
func (o *LPTIM_Type) GetCNT() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg) & 0xffff
}

// Inter-integrated circuit
type I2C_Type struct {
	CR1      volatile.Register32 // 0x0
	CR2      volatile.Register32 // 0x4
	OAR1     volatile.Register32 // 0x8
	OAR2     volatile.Register32 // 0xC
	TIMINGR  volatile.Register32 // 0x10
	TIMEOUTR volatile.Register32 // 0x14
	ISR      volatile.Register32 // 0x18
	ICR      volatile.Register32 // 0x1C
	PECR     volatile.Register32 // 0x20
	RXDR     volatile.Register32 // 0x24
	TXDR     volatile.Register32 // 0x28
}

// I2C.CR1: Control register 1
func (o *I2C_Type) SetCR1_PE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetCR1_PE() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}
func (o *I2C_Type) SetCR1_TXIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetCR1_TXIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetCR1_RXIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetCR1_RXIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetCR1_ADDRIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetCR1_ADDRIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetCR1_NACKIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetCR1_NACKIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetCR1_STOPIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetCR1_STOPIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetCR1_TCIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetCR1_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetCR1_ERRIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetCR1_ERRIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetCR1_DNF(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xf00)|value<<8)
}
func (o *I2C_Type) GetCR1_DNF() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xf00) >> 8
}
func (o *I2C_Type) SetCR1_ANFOFF(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetCR1_ANFOFF() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetCR1_TXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000)|value<<14)
}
func (o *I2C_Type) GetCR1_TXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000) >> 14
}
func (o *I2C_Type) SetCR1_RXDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetCR1_RXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetCR1_SBC(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10000)|value<<16)
}
func (o *I2C_Type) GetCR1_SBC() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10000) >> 16
}
func (o *I2C_Type) SetCR1_NOSTRETCH(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20000)|value<<17)
}
func (o *I2C_Type) GetCR1_NOSTRETCH() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20000) >> 17
}
func (o *I2C_Type) SetCR1_WUPEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40000)|value<<18)
}
func (o *I2C_Type) GetCR1_WUPEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40000) >> 18
}
func (o *I2C_Type) SetCR1_GCEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80000)|value<<19)
}
func (o *I2C_Type) GetCR1_GCEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80000) >> 19
}
func (o *I2C_Type) SetCR1_SMBHEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100000)|value<<20)
}
func (o *I2C_Type) GetCR1_SMBHEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100000) >> 20
}
func (o *I2C_Type) SetCR1_SMBDEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200000)|value<<21)
}
func (o *I2C_Type) GetCR1_SMBDEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200000) >> 21
}
func (o *I2C_Type) SetCR1_ALERTEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x400000)|value<<22)
}
func (o *I2C_Type) GetCR1_ALERTEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x400000) >> 22
}
func (o *I2C_Type) SetCR1_PECEN(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800000)|value<<23)
}
func (o *I2C_Type) GetCR1_PECEN() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800000) >> 23
}

// I2C.CR2: Control register 2
func (o *I2C_Type) SetCR2_PECBYTE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4000000)|value<<26)
}
func (o *I2C_Type) GetCR2_PECBYTE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4000000) >> 26
}
func (o *I2C_Type) SetCR2_AUTOEND(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000000)|value<<25)
}
func (o *I2C_Type) GetCR2_AUTOEND() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000000) >> 25
}
func (o *I2C_Type) SetCR2_RELOAD(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1000000)|value<<24)
}
func (o *I2C_Type) GetCR2_RELOAD() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1000000) >> 24
}
func (o *I2C_Type) SetCR2_NBYTES(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xff0000)|value<<16)
}
func (o *I2C_Type) GetCR2_NBYTES() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xff0000) >> 16
}
func (o *I2C_Type) SetCR2_NACK(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetCR2_NACK() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetCR2_STOP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4000)|value<<14)
}
func (o *I2C_Type) GetCR2_STOP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4000) >> 14
}
func (o *I2C_Type) SetCR2_START(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetCR2_START() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetCR2_HEAD10R(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetCR2_HEAD10R() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetCR2_ADD10(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetCR2_ADD10() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetCR2_RD_WRN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetCR2_RD_WRN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetCR2_SADD(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x3ff)|value)
}
func (o *I2C_Type) GetCR2_SADD() uint32 {
	return volatile.LoadUint32(&o.CR2.Reg) & 0x3ff
}

// I2C.OAR1: Own address register 1
func (o *I2C_Type) SetOAR1_OA1(value uint32) {
	volatile.StoreUint32(&o.OAR1.Reg, volatile.LoadUint32(&o.OAR1.Reg)&^(0x3ff)|value)
}
func (o *I2C_Type) GetOAR1_OA1() uint32 {
	return volatile.LoadUint32(&o.OAR1.Reg) & 0x3ff
}
func (o *I2C_Type) SetOAR1_OA1MODE(value uint32) {
	volatile.StoreUint32(&o.OAR1.Reg, volatile.LoadUint32(&o.OAR1.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetOAR1_OA1MODE() uint32 {
	return (volatile.LoadUint32(&o.OAR1.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetOAR1_OA1EN(value uint32) {
	volatile.StoreUint32(&o.OAR1.Reg, volatile.LoadUint32(&o.OAR1.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetOAR1_OA1EN() uint32 {
	return (volatile.LoadUint32(&o.OAR1.Reg) & 0x8000) >> 15
}

// I2C.OAR2: Own address register 2
func (o *I2C_Type) SetOAR2_OA2(value uint32) {
	volatile.StoreUint32(&o.OAR2.Reg, volatile.LoadUint32(&o.OAR2.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetOAR2_OA2() uint32 {
	return (volatile.LoadUint32(&o.OAR2.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetOAR2_OA2MSK(value uint32) {
	volatile.StoreUint32(&o.OAR2.Reg, volatile.LoadUint32(&o.OAR2.Reg)&^(0x700)|value<<8)
}
func (o *I2C_Type) GetOAR2_OA2MSK() uint32 {
	return (volatile.LoadUint32(&o.OAR2.Reg) & 0x700) >> 8
}
func (o *I2C_Type) SetOAR2_OA2EN(value uint32) {
	volatile.StoreUint32(&o.OAR2.Reg, volatile.LoadUint32(&o.OAR2.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetOAR2_OA2EN() uint32 {
	return (volatile.LoadUint32(&o.OAR2.Reg) & 0x8000) >> 15
}

// I2C.TIMINGR: Timing register
func (o *I2C_Type) SetTIMINGR_SCLL(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetTIMINGR_SCLL() uint32 {
	return volatile.LoadUint32(&o.TIMINGR.Reg) & 0xff
}
func (o *I2C_Type) SetTIMINGR_SCLH(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xff00)|value<<8)
}
func (o *I2C_Type) GetTIMINGR_SCLH() uint32 {
	return (volatile.LoadUint32(&o.TIMINGR.Reg) & 0xff00) >> 8
}
func (o *I2C_Type) SetTIMINGR_SDADEL(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xf0000)|value<<16)
}
func (o *I2C_Type) GetTIMINGR_SDADEL() uint32 {
	return (volatile.LoadUint32(&o.TIMINGR.Reg) & 0xf0000) >> 16
}
func (o *I2C_Type) SetTIMINGR_SCLDEL(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xf00000)|value<<20)
}
func (o *I2C_Type) GetTIMINGR_SCLDEL() uint32 {
	return (volatile.LoadUint32(&o.TIMINGR.Reg) & 0xf00000) >> 20
}
func (o *I2C_Type) SetTIMINGR_PRESC(value uint32) {
	volatile.StoreUint32(&o.TIMINGR.Reg, volatile.LoadUint32(&o.TIMINGR.Reg)&^(0xf0000000)|value<<28)
}
func (o *I2C_Type) GetTIMINGR_PRESC() uint32 {
	return (volatile.LoadUint32(&o.TIMINGR.Reg) & 0xf0000000) >> 28
}

// I2C.TIMEOUTR: Status register 1
func (o *I2C_Type) SetTIMEOUTR_TIMEOUTA(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0xfff)|value)
}
func (o *I2C_Type) GetTIMEOUTR_TIMEOUTA() uint32 {
	return volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0xfff
}
func (o *I2C_Type) SetTIMEOUTR_TIDLE(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetTIMEOUTR_TIDLE() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetTIMEOUTR_TIMOUTEN(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetTIMEOUTR_TIMOUTEN() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetTIMEOUTR_TIMEOUTB(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0xfff0000)|value<<16)
}
func (o *I2C_Type) GetTIMEOUTR_TIMEOUTB() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0xfff0000) >> 16
}
func (o *I2C_Type) SetTIMEOUTR_TEXTEN(value uint32) {
	volatile.StoreUint32(&o.TIMEOUTR.Reg, volatile.LoadUint32(&o.TIMEOUTR.Reg)&^(0x80000000)|value<<31)
}
func (o *I2C_Type) GetTIMEOUTR_TEXTEN() uint32 {
	return (volatile.LoadUint32(&o.TIMEOUTR.Reg) & 0x80000000) >> 31
}

// I2C.ISR: Interrupt and Status register
func (o *I2C_Type) SetISR_ADDCODE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0xfe0000)|value<<17)
}
func (o *I2C_Type) GetISR_ADDCODE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0xfe0000) >> 17
}
func (o *I2C_Type) SetISR_DIR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *I2C_Type) GetISR_DIR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}
func (o *I2C_Type) SetISR_BUSY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *I2C_Type) GetISR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *I2C_Type) SetISR_ALERT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetISR_ALERT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetISR_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetISR_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetISR_PECERR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetISR_PECERR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetISR_OVR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetISR_OVR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetISR_ARLO(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetISR_ARLO() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetISR_BERR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetISR_BERR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetISR_TCR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetISR_TCR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetISR_TC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetISR_TC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetISR_STOPF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetISR_STOPF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetISR_NACKF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetISR_NACKF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetISR_ADDR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetISR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetISR_RXNE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetISR_RXNE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetISR_TXIS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetISR_TXIS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetISR_TXE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetISR_TXE() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// I2C.ICR: Interrupt clear register
func (o *I2C_Type) SetICR_ALERTCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2000)|value<<13)
}
func (o *I2C_Type) GetICR_ALERTCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2000) >> 13
}
func (o *I2C_Type) SetICR_TIMOUTCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1000)|value<<12)
}
func (o *I2C_Type) GetICR_TIMOUTCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x1000) >> 12
}
func (o *I2C_Type) SetICR_PECCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x800)|value<<11)
}
func (o *I2C_Type) GetICR_PECCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x800) >> 11
}
func (o *I2C_Type) SetICR_OVRCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x400)|value<<10)
}
func (o *I2C_Type) GetICR_OVRCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x400) >> 10
}
func (o *I2C_Type) SetICR_ARLOCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x200)|value<<9)
}
func (o *I2C_Type) GetICR_ARLOCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x200) >> 9
}
func (o *I2C_Type) SetICR_BERRCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100)|value<<8)
}
func (o *I2C_Type) GetICR_BERRCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100) >> 8
}
func (o *I2C_Type) SetICR_STOPCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetICR_STOPCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetICR_NACKCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetICR_NACKCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetICR_ADDRCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetICR_ADDRCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}

// I2C.PECR: PEC register
func (o *I2C_Type) SetPECR_PEC(value uint32) {
	volatile.StoreUint32(&o.PECR.Reg, volatile.LoadUint32(&o.PECR.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetPECR_PEC() uint32 {
	return volatile.LoadUint32(&o.PECR.Reg) & 0xff
}

// I2C.RXDR: Receive data register
func (o *I2C_Type) SetRXDR_RXDATA(value uint32) {
	volatile.StoreUint32(&o.RXDR.Reg, volatile.LoadUint32(&o.RXDR.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetRXDR_RXDATA() uint32 {
	return volatile.LoadUint32(&o.RXDR.Reg) & 0xff
}

// I2C.TXDR: Transmit data register
func (o *I2C_Type) SetTXDR_TXDATA(value uint32) {
	volatile.StoreUint32(&o.TXDR.Reg, volatile.LoadUint32(&o.TXDR.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetTXDR_TXDATA() uint32 {
	return volatile.LoadUint32(&o.TXDR.Reg) & 0xff
}

// Real-time clock
type RTC_Type struct {
	TR       volatile.Register32 // 0x0
	DR       volatile.Register32 // 0x4
	CR       volatile.Register32 // 0x8
	ISR      volatile.Register32 // 0xC
	PRER     volatile.Register32 // 0x10
	WUTR     volatile.Register32 // 0x14
	_        [4]byte
	ALRMAR   volatile.Register32 // 0x1C
	ALRMBR   volatile.Register32 // 0x20
	WPR      volatile.Register32 // 0x24
	SSR      volatile.Register32 // 0x28
	SHIFTR   volatile.Register32 // 0x2C
	TSTR     volatile.Register32 // 0x30
	TSDR     volatile.Register32 // 0x34
	TSSSR    volatile.Register32 // 0x38
	CALR     volatile.Register32 // 0x3C
	TAMPCR   volatile.Register32 // 0x40
	ALRMASSR volatile.Register32 // 0x44
	ALRMBSSR volatile.Register32 // 0x48
	OR       volatile.Register32 // 0x4C
	BKP0R    volatile.Register32 // 0x50
	BKP1R    volatile.Register32 // 0x54
	BKP2R    volatile.Register32 // 0x58
	BKP3R    volatile.Register32 // 0x5C
	BKP4R    volatile.Register32 // 0x60
	BKP5R    volatile.Register32 // 0x64
	BKP6R    volatile.Register32 // 0x68
	BKP7R    volatile.Register32 // 0x6C
	BKP8R    volatile.Register32 // 0x70
	BKP9R    volatile.Register32 // 0x74
	BKP10R   volatile.Register32 // 0x78
	BKP11R   volatile.Register32 // 0x7C
	BKP12R   volatile.Register32 // 0x80
	BKP13R   volatile.Register32 // 0x84
	BKP14R   volatile.Register32 // 0x88
	BKP15R   volatile.Register32 // 0x8C
	BKP16R   volatile.Register32 // 0x90
	BKP17R   volatile.Register32 // 0x94
	BKP18R   volatile.Register32 // 0x98
	BKP19R   volatile.Register32 // 0x9C
	BKP20R   volatile.Register32 // 0xA0
	BKP21R   volatile.Register32 // 0xA4
	BKP22R   volatile.Register32 // 0xA8
	BKP23R   volatile.Register32 // 0xAC
	BKP24R   volatile.Register32 // 0xB0
	BKP25R   volatile.Register32 // 0xB4
	BKP26R   volatile.Register32 // 0xB8
	BKP27R   volatile.Register32 // 0xBC
	BKP28R   volatile.Register32 // 0xC0
	BKP29R   volatile.Register32 // 0xC4
	BKP30R   volatile.Register32 // 0xC8
	BKP31R   volatile.Register32 // 0xCC
}

// RTC.TR: time register
func (o *RTC_Type) SetTR_PM(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetTR_PM() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0x400000) >> 22
}
func (o *RTC_Type) SetTR_HT(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0x300000)|value<<20)
}
func (o *RTC_Type) GetTR_HT() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0x300000) >> 20
}
func (o *RTC_Type) SetTR_HU(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetTR_HU() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetTR_MNT(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_Type) GetTR_MNT() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0x7000) >> 12
}
func (o *RTC_Type) SetTR_MNU(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetTR_MNU() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetTR_ST(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetTR_ST() uint32 {
	return (volatile.LoadUint32(&o.TR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetTR_SU(value uint32) {
	volatile.StoreUint32(&o.TR.Reg, volatile.LoadUint32(&o.TR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetTR_SU() uint32 {
	return volatile.LoadUint32(&o.TR.Reg) & 0xf
}

// RTC.DR: date register
func (o *RTC_Type) SetDR_YT(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xf00000)|value<<20)
}
func (o *RTC_Type) GetDR_YT() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xf00000) >> 20
}
func (o *RTC_Type) SetDR_YU(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetDR_YU() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetDR_WDU(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xe000)|value<<13)
}
func (o *RTC_Type) GetDR_WDU() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xe000) >> 13
}
func (o *RTC_Type) SetDR_MT(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetDR_MT() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetDR_MU(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetDR_MU() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetDR_DT(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetDR_DT() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetDR_DU(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetDR_DU() uint32 {
	return volatile.LoadUint32(&o.DR.Reg) & 0xf
}

// RTC.CR: control register
func (o *RTC_Type) SetCR_WUCKSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x7)|value)
}
func (o *RTC_Type) GetCR_WUCKSEL() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x7
}
func (o *RTC_Type) SetCR_TSEDGE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetCR_TSEDGE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetCR_REFCKON(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetCR_REFCKON() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetCR_BYPSHAD(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetCR_BYPSHAD() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetCR_FMT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetCR_FMT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetCR_ALRAE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *RTC_Type) GetCR_ALRAE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *RTC_Type) SetCR_ALRBE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *RTC_Type) GetCR_ALRBE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *RTC_Type) SetCR_WUTE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *RTC_Type) GetCR_WUTE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *RTC_Type) SetCR_TSE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *RTC_Type) GetCR_TSE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *RTC_Type) SetCR_ALRAIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetCR_ALRAIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetCR_ALRBIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_Type) GetCR_ALRBIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *RTC_Type) SetCR_WUTIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_Type) GetCR_WUTIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}
func (o *RTC_Type) SetCR_TSIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetCR_TSIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetCR_ADD1H(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetCR_ADD1H() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetCR_SUB1H(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetCR_SUB1H() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetCR_BKP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetCR_BKP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetCR_COSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetCR_COSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000) >> 19
}
func (o *RTC_Type) SetCR_POL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_Type) GetCR_POL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100000) >> 20
}
func (o *RTC_Type) SetCR_OSEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x600000)|value<<21)
}
func (o *RTC_Type) GetCR_OSEL() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x600000) >> 21
}
func (o *RTC_Type) SetCR_COE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetCR_COE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800000) >> 23
}
func (o *RTC_Type) SetCR_ITSE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_Type) GetCR_ITSE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000000) >> 24
}

// RTC.ISR: initialization and status register
func (o *RTC_Type) SetISR_ALRAWF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetISR_ALRAWF() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}
func (o *RTC_Type) SetISR_ALRBWF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetISR_ALRBWF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetISR_WUTWF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetISR_WUTWF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetISR_SHPF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetISR_SHPF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetISR_INITS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetISR_INITS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetISR_RSF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetISR_RSF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetISR_INITF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetISR_INITF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetISR_INIT(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetISR_INIT() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetISR_ALRAF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *RTC_Type) GetISR_ALRAF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *RTC_Type) SetISR_ALRBF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *RTC_Type) GetISR_ALRBF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *RTC_Type) SetISR_WUTF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *RTC_Type) GetISR_WUTF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *RTC_Type) SetISR_TSF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *RTC_Type) GetISR_TSF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *RTC_Type) SetISR_TSOVF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetISR_TSOVF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetISR_TAMP1F(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_Type) GetISR_TAMP1F() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2000) >> 13
}
func (o *RTC_Type) SetISR_TAMP2F(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_Type) GetISR_TAMP2F() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000) >> 14
}
func (o *RTC_Type) SetISR_TAMP3F(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetISR_TAMP3F() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetISR_RECALPF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetISR_RECALPF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}

// RTC.PRER: prescaler register
func (o *RTC_Type) SetPRER_PREDIV_A(value uint32) {
	volatile.StoreUint32(&o.PRER.Reg, volatile.LoadUint32(&o.PRER.Reg)&^(0x7f0000)|value<<16)
}
func (o *RTC_Type) GetPRER_PREDIV_A() uint32 {
	return (volatile.LoadUint32(&o.PRER.Reg) & 0x7f0000) >> 16
}
func (o *RTC_Type) SetPRER_PREDIV_S(value uint32) {
	volatile.StoreUint32(&o.PRER.Reg, volatile.LoadUint32(&o.PRER.Reg)&^(0x7fff)|value)
}
func (o *RTC_Type) GetPRER_PREDIV_S() uint32 {
	return volatile.LoadUint32(&o.PRER.Reg) & 0x7fff
}

// RTC.WUTR: wakeup timer register
func (o *RTC_Type) SetWUTR_WUT(value uint32) {
	volatile.StoreUint32(&o.WUTR.Reg, volatile.LoadUint32(&o.WUTR.Reg)&^(0xffff)|value)
}
func (o *RTC_Type) GetWUTR_WUT() uint32 {
	return volatile.LoadUint32(&o.WUTR.Reg) & 0xffff
}

// RTC.ALRMAR: alarm A register
func (o *RTC_Type) SetALRMAR_MSK4(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetALRMAR_MSK4() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x80000000) >> 31
}
func (o *RTC_Type) SetALRMAR_WDSEL(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_Type) GetALRMAR_WDSEL() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x40000000) >> 30
}
func (o *RTC_Type) SetALRMAR_DT(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x30000000)|value<<28)
}
func (o *RTC_Type) GetALRMAR_DT() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x30000000) >> 28
}
func (o *RTC_Type) SetALRMAR_DU(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0xf000000)|value<<24)
}
func (o *RTC_Type) GetALRMAR_DU() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0xf000000) >> 24
}
func (o *RTC_Type) SetALRMAR_MSK3(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetALRMAR_MSK3() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x800000) >> 23
}
func (o *RTC_Type) SetALRMAR_PM(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetALRMAR_PM() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x400000) >> 22
}
func (o *RTC_Type) SetALRMAR_HT(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x300000)|value<<20)
}
func (o *RTC_Type) GetALRMAR_HT() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x300000) >> 20
}
func (o *RTC_Type) SetALRMAR_HU(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetALRMAR_HU() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetALRMAR_MSK2(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetALRMAR_MSK2() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetALRMAR_MNT(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_Type) GetALRMAR_MNT() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x7000) >> 12
}
func (o *RTC_Type) SetALRMAR_MNU(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetALRMAR_MNU() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetALRMAR_MSK1(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetALRMAR_MSK1() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetALRMAR_ST(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetALRMAR_ST() uint32 {
	return (volatile.LoadUint32(&o.ALRMAR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetALRMAR_SU(value uint32) {
	volatile.StoreUint32(&o.ALRMAR.Reg, volatile.LoadUint32(&o.ALRMAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetALRMAR_SU() uint32 {
	return volatile.LoadUint32(&o.ALRMAR.Reg) & 0xf
}

// RTC.ALRMBR: alarm B register
func (o *RTC_Type) SetALRMBR_MSK4(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetALRMBR_MSK4() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x80000000) >> 31
}
func (o *RTC_Type) SetALRMBR_WDSEL(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x40000000)|value<<30)
}
func (o *RTC_Type) GetALRMBR_WDSEL() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x40000000) >> 30
}
func (o *RTC_Type) SetALRMBR_DT(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x30000000)|value<<28)
}
func (o *RTC_Type) GetALRMBR_DT() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x30000000) >> 28
}
func (o *RTC_Type) SetALRMBR_DU(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0xf000000)|value<<24)
}
func (o *RTC_Type) GetALRMBR_DU() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0xf000000) >> 24
}
func (o *RTC_Type) SetALRMBR_MSK3(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetALRMBR_MSK3() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x800000) >> 23
}
func (o *RTC_Type) SetALRMBR_PM(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetALRMBR_PM() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x400000) >> 22
}
func (o *RTC_Type) SetALRMBR_HT(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x300000)|value<<20)
}
func (o *RTC_Type) GetALRMBR_HT() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x300000) >> 20
}
func (o *RTC_Type) SetALRMBR_HU(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetALRMBR_HU() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetALRMBR_MSK2(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetALRMBR_MSK2() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetALRMBR_MNT(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_Type) GetALRMBR_MNT() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x7000) >> 12
}
func (o *RTC_Type) SetALRMBR_MNU(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetALRMBR_MNU() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetALRMBR_MSK1(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetALRMBR_MSK1() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetALRMBR_ST(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetALRMBR_ST() uint32 {
	return (volatile.LoadUint32(&o.ALRMBR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetALRMBR_SU(value uint32) {
	volatile.StoreUint32(&o.ALRMBR.Reg, volatile.LoadUint32(&o.ALRMBR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetALRMBR_SU() uint32 {
	return volatile.LoadUint32(&o.ALRMBR.Reg) & 0xf
}

// RTC.WPR: write protection register
func (o *RTC_Type) SetWPR_KEY(value uint32) {
	volatile.StoreUint32(&o.WPR.Reg, volatile.LoadUint32(&o.WPR.Reg)&^(0xff)|value)
}
func (o *RTC_Type) GetWPR_KEY() uint32 {
	return volatile.LoadUint32(&o.WPR.Reg) & 0xff
}

// RTC.SSR: sub second register
func (o *RTC_Type) SetSSR_SS(value uint32) {
	volatile.StoreUint32(&o.SSR.Reg, volatile.LoadUint32(&o.SSR.Reg)&^(0xffff)|value)
}
func (o *RTC_Type) GetSSR_SS() uint32 {
	return volatile.LoadUint32(&o.SSR.Reg) & 0xffff
}

// RTC.SHIFTR: shift control register
func (o *RTC_Type) SetSHIFTR_ADD1S(value uint32) {
	volatile.StoreUint32(&o.SHIFTR.Reg, volatile.LoadUint32(&o.SHIFTR.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetSHIFTR_ADD1S() uint32 {
	return (volatile.LoadUint32(&o.SHIFTR.Reg) & 0x80000000) >> 31
}
func (o *RTC_Type) SetSHIFTR_SUBFS(value uint32) {
	volatile.StoreUint32(&o.SHIFTR.Reg, volatile.LoadUint32(&o.SHIFTR.Reg)&^(0x7fff)|value)
}
func (o *RTC_Type) GetSHIFTR_SUBFS() uint32 {
	return volatile.LoadUint32(&o.SHIFTR.Reg) & 0x7fff
}

// RTC.TSTR: time stamp time register
func (o *RTC_Type) SetTSTR_SU(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetTSTR_SU() uint32 {
	return volatile.LoadUint32(&o.TSTR.Reg) & 0xf
}
func (o *RTC_Type) SetTSTR_ST(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetTSTR_ST() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetTSTR_MNU(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetTSTR_MNU() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetTSTR_MNT(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0x7000)|value<<12)
}
func (o *RTC_Type) GetTSTR_MNT() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0x7000) >> 12
}
func (o *RTC_Type) SetTSTR_HU(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0xf0000)|value<<16)
}
func (o *RTC_Type) GetTSTR_HU() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0xf0000) >> 16
}
func (o *RTC_Type) SetTSTR_HT(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0x300000)|value<<20)
}
func (o *RTC_Type) GetTSTR_HT() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0x300000) >> 20
}
func (o *RTC_Type) SetTSTR_PM(value uint32) {
	volatile.StoreUint32(&o.TSTR.Reg, volatile.LoadUint32(&o.TSTR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetTSTR_PM() uint32 {
	return (volatile.LoadUint32(&o.TSTR.Reg) & 0x400000) >> 22
}

// RTC.TSDR: time stamp date register
func (o *RTC_Type) SetTSDR_WDU(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0xe000)|value<<13)
}
func (o *RTC_Type) GetTSDR_WDU() uint32 {
	return (volatile.LoadUint32(&o.TSDR.Reg) & 0xe000) >> 13
}
func (o *RTC_Type) SetTSDR_MT(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetTSDR_MT() uint32 {
	return (volatile.LoadUint32(&o.TSDR.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetTSDR_MU(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetTSDR_MU() uint32 {
	return (volatile.LoadUint32(&o.TSDR.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetTSDR_DT(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetTSDR_DT() uint32 {
	return (volatile.LoadUint32(&o.TSDR.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetTSDR_DU(value uint32) {
	volatile.StoreUint32(&o.TSDR.Reg, volatile.LoadUint32(&o.TSDR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetTSDR_DU() uint32 {
	return volatile.LoadUint32(&o.TSDR.Reg) & 0xf
}

// RTC.TSSSR: timestamp sub second register
func (o *RTC_Type) SetTSSSR_SS(value uint32) {
	volatile.StoreUint32(&o.TSSSR.Reg, volatile.LoadUint32(&o.TSSSR.Reg)&^(0xffff)|value)
}
func (o *RTC_Type) GetTSSSR_SS() uint32 {
	return volatile.LoadUint32(&o.TSSSR.Reg) & 0xffff
}

// RTC.CALR: calibration register
func (o *RTC_Type) SetCALR_CALP(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetCALR_CALP() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetCALR_CALW8(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x4000)|value<<14)
}
func (o *RTC_Type) GetCALR_CALW8() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0x4000) >> 14
}
func (o *RTC_Type) SetCALR_CALW16(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_Type) GetCALR_CALW16() uint32 {
	return (volatile.LoadUint32(&o.CALR.Reg) & 0x2000) >> 13
}
func (o *RTC_Type) SetCALR_CALM(value uint32) {
	volatile.StoreUint32(&o.CALR.Reg, volatile.LoadUint32(&o.CALR.Reg)&^(0x1ff)|value)
}
func (o *RTC_Type) GetCALR_CALM() uint32 {
	return volatile.LoadUint32(&o.CALR.Reg) & 0x1ff
}

// RTC.TAMPCR: tamper configuration register
func (o *RTC_Type) SetTAMPCR_TAMP1E(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetTAMPCR_TAMP1E() uint32 {
	return volatile.LoadUint32(&o.TAMPCR.Reg) & 0x1
}
func (o *RTC_Type) SetTAMPCR_TAMP1TRG(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetTAMPCR_TAMP1TRG() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetTAMPCR_TAMPIE(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetTAMPCR_TAMPIE() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetTAMPCR_TAMP2E(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetTAMPCR_TAMP2E() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetTAMPCR_TAMP2TRG(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetTAMPCR_TAMP2TRG() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetTAMPCR_TAMP3E(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetTAMPCR_TAMP3E() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetTAMPCR_TAMP3TRG(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetTAMPCR_TAMP3TRG() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetTAMPCR_TAMPTS(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetTAMPCR_TAMPTS() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetTAMPCR_TAMPFREQ(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x700)|value<<8)
}
func (o *RTC_Type) GetTAMPCR_TAMPFREQ() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x700) >> 8
}
func (o *RTC_Type) SetTAMPCR_TAMPFLT(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x1800)|value<<11)
}
func (o *RTC_Type) GetTAMPCR_TAMPFLT() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x1800) >> 11
}
func (o *RTC_Type) SetTAMPCR_TAMPPRCH(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x6000)|value<<13)
}
func (o *RTC_Type) GetTAMPCR_TAMPPRCH() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x6000) >> 13
}
func (o *RTC_Type) SetTAMPCR_TAMPPUDIS(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x8000)|value<<15)
}
func (o *RTC_Type) GetTAMPCR_TAMPPUDIS() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x8000) >> 15
}
func (o *RTC_Type) SetTAMPCR_TAMP1IE(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x10000)|value<<16)
}
func (o *RTC_Type) GetTAMPCR_TAMP1IE() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x10000) >> 16
}
func (o *RTC_Type) SetTAMPCR_TAMP1NOERASE(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetTAMPCR_TAMP1NOERASE() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x20000) >> 17
}
func (o *RTC_Type) SetTAMPCR_TAMP1MF(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x40000)|value<<18)
}
func (o *RTC_Type) GetTAMPCR_TAMP1MF() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x40000) >> 18
}
func (o *RTC_Type) SetTAMPCR_TAMP2IE(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x80000)|value<<19)
}
func (o *RTC_Type) GetTAMPCR_TAMP2IE() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x80000) >> 19
}
func (o *RTC_Type) SetTAMPCR_TAMP2NOERASE(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_Type) GetTAMPCR_TAMP2NOERASE() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x100000) >> 20
}
func (o *RTC_Type) SetTAMPCR_TAMP2MF(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_Type) GetTAMPCR_TAMP2MF() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x200000) >> 21
}
func (o *RTC_Type) SetTAMPCR_TAMP3IE(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetTAMPCR_TAMP3IE() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x400000) >> 22
}
func (o *RTC_Type) SetTAMPCR_TAMP3NOERASE(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetTAMPCR_TAMP3NOERASE() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x800000) >> 23
}
func (o *RTC_Type) SetTAMPCR_TAMP3MF(value uint32) {
	volatile.StoreUint32(&o.TAMPCR.Reg, volatile.LoadUint32(&o.TAMPCR.Reg)&^(0x1000000)|value<<24)
}
func (o *RTC_Type) GetTAMPCR_TAMP3MF() uint32 {
	return (volatile.LoadUint32(&o.TAMPCR.Reg) & 0x1000000) >> 24
}

// RTC.ALRMASSR: alarm A sub second register
func (o *RTC_Type) SetALRMASSR_MASKSS(value uint32) {
	volatile.StoreUint32(&o.ALRMASSR.Reg, volatile.LoadUint32(&o.ALRMASSR.Reg)&^(0xf000000)|value<<24)
}
func (o *RTC_Type) GetALRMASSR_MASKSS() uint32 {
	return (volatile.LoadUint32(&o.ALRMASSR.Reg) & 0xf000000) >> 24
}
func (o *RTC_Type) SetALRMASSR_SS(value uint32) {
	volatile.StoreUint32(&o.ALRMASSR.Reg, volatile.LoadUint32(&o.ALRMASSR.Reg)&^(0x7fff)|value)
}
func (o *RTC_Type) GetALRMASSR_SS() uint32 {
	return volatile.LoadUint32(&o.ALRMASSR.Reg) & 0x7fff
}

// RTC.ALRMBSSR: alarm B sub second register
func (o *RTC_Type) SetALRMBSSR_MASKSS(value uint32) {
	volatile.StoreUint32(&o.ALRMBSSR.Reg, volatile.LoadUint32(&o.ALRMBSSR.Reg)&^(0xf000000)|value<<24)
}
func (o *RTC_Type) GetALRMBSSR_MASKSS() uint32 {
	return (volatile.LoadUint32(&o.ALRMBSSR.Reg) & 0xf000000) >> 24
}
func (o *RTC_Type) SetALRMBSSR_SS(value uint32) {
	volatile.StoreUint32(&o.ALRMBSSR.Reg, volatile.LoadUint32(&o.ALRMBSSR.Reg)&^(0x7fff)|value)
}
func (o *RTC_Type) GetALRMBSSR_SS() uint32 {
	return volatile.LoadUint32(&o.ALRMBSSR.Reg) & 0x7fff
}

// RTC.OR: option register
func (o *RTC_Type) SetOR_RTC_ALARM_TYPE(value uint32) {
	volatile.StoreUint32(&o.OR.Reg, volatile.LoadUint32(&o.OR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetOR_RTC_ALARM_TYPE() uint32 {
	return volatile.LoadUint32(&o.OR.Reg) & 0x1
}
func (o *RTC_Type) SetOR_RTC_OUT_RMP(value uint32) {
	volatile.StoreUint32(&o.OR.Reg, volatile.LoadUint32(&o.OR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetOR_RTC_OUT_RMP() uint32 {
	return (volatile.LoadUint32(&o.OR.Reg) & 0x2) >> 1
}

// RTC.BKP0R: backup register
func (o *RTC_Type) SetBKP0R(value uint32) {
	volatile.StoreUint32(&o.BKP0R.Reg, value)
}
func (o *RTC_Type) GetBKP0R() uint32 {
	return volatile.LoadUint32(&o.BKP0R.Reg)
}

// RTC.BKP1R: backup register
func (o *RTC_Type) SetBKP1R(value uint32) {
	volatile.StoreUint32(&o.BKP1R.Reg, value)
}
func (o *RTC_Type) GetBKP1R() uint32 {
	return volatile.LoadUint32(&o.BKP1R.Reg)
}

// RTC.BKP2R: backup register
func (o *RTC_Type) SetBKP2R(value uint32) {
	volatile.StoreUint32(&o.BKP2R.Reg, value)
}
func (o *RTC_Type) GetBKP2R() uint32 {
	return volatile.LoadUint32(&o.BKP2R.Reg)
}

// RTC.BKP3R: backup register
func (o *RTC_Type) SetBKP3R(value uint32) {
	volatile.StoreUint32(&o.BKP3R.Reg, value)
}
func (o *RTC_Type) GetBKP3R() uint32 {
	return volatile.LoadUint32(&o.BKP3R.Reg)
}

// RTC.BKP4R: backup register
func (o *RTC_Type) SetBKP4R(value uint32) {
	volatile.StoreUint32(&o.BKP4R.Reg, value)
}
func (o *RTC_Type) GetBKP4R() uint32 {
	return volatile.LoadUint32(&o.BKP4R.Reg)
}

// RTC.BKP5R: backup register
func (o *RTC_Type) SetBKP5R(value uint32) {
	volatile.StoreUint32(&o.BKP5R.Reg, value)
}
func (o *RTC_Type) GetBKP5R() uint32 {
	return volatile.LoadUint32(&o.BKP5R.Reg)
}

// RTC.BKP6R: backup register
func (o *RTC_Type) SetBKP6R(value uint32) {
	volatile.StoreUint32(&o.BKP6R.Reg, value)
}
func (o *RTC_Type) GetBKP6R() uint32 {
	return volatile.LoadUint32(&o.BKP6R.Reg)
}

// RTC.BKP7R: backup register
func (o *RTC_Type) SetBKP7R(value uint32) {
	volatile.StoreUint32(&o.BKP7R.Reg, value)
}
func (o *RTC_Type) GetBKP7R() uint32 {
	return volatile.LoadUint32(&o.BKP7R.Reg)
}

// RTC.BKP8R: backup register
func (o *RTC_Type) SetBKP8R(value uint32) {
	volatile.StoreUint32(&o.BKP8R.Reg, value)
}
func (o *RTC_Type) GetBKP8R() uint32 {
	return volatile.LoadUint32(&o.BKP8R.Reg)
}

// RTC.BKP9R: backup register
func (o *RTC_Type) SetBKP9R(value uint32) {
	volatile.StoreUint32(&o.BKP9R.Reg, value)
}
func (o *RTC_Type) GetBKP9R() uint32 {
	return volatile.LoadUint32(&o.BKP9R.Reg)
}

// RTC.BKP10R: backup register
func (o *RTC_Type) SetBKP10R(value uint32) {
	volatile.StoreUint32(&o.BKP10R.Reg, value)
}
func (o *RTC_Type) GetBKP10R() uint32 {
	return volatile.LoadUint32(&o.BKP10R.Reg)
}

// RTC.BKP11R: backup register
func (o *RTC_Type) SetBKP11R(value uint32) {
	volatile.StoreUint32(&o.BKP11R.Reg, value)
}
func (o *RTC_Type) GetBKP11R() uint32 {
	return volatile.LoadUint32(&o.BKP11R.Reg)
}

// RTC.BKP12R: backup register
func (o *RTC_Type) SetBKP12R(value uint32) {
	volatile.StoreUint32(&o.BKP12R.Reg, value)
}
func (o *RTC_Type) GetBKP12R() uint32 {
	return volatile.LoadUint32(&o.BKP12R.Reg)
}

// RTC.BKP13R: backup register
func (o *RTC_Type) SetBKP13R(value uint32) {
	volatile.StoreUint32(&o.BKP13R.Reg, value)
}
func (o *RTC_Type) GetBKP13R() uint32 {
	return volatile.LoadUint32(&o.BKP13R.Reg)
}

// RTC.BKP14R: backup register
func (o *RTC_Type) SetBKP14R(value uint32) {
	volatile.StoreUint32(&o.BKP14R.Reg, value)
}
func (o *RTC_Type) GetBKP14R() uint32 {
	return volatile.LoadUint32(&o.BKP14R.Reg)
}

// RTC.BKP15R: backup register
func (o *RTC_Type) SetBKP15R(value uint32) {
	volatile.StoreUint32(&o.BKP15R.Reg, value)
}
func (o *RTC_Type) GetBKP15R() uint32 {
	return volatile.LoadUint32(&o.BKP15R.Reg)
}

// RTC.BKP16R: backup register
func (o *RTC_Type) SetBKP16R(value uint32) {
	volatile.StoreUint32(&o.BKP16R.Reg, value)
}
func (o *RTC_Type) GetBKP16R() uint32 {
	return volatile.LoadUint32(&o.BKP16R.Reg)
}

// RTC.BKP17R: backup register
func (o *RTC_Type) SetBKP17R(value uint32) {
	volatile.StoreUint32(&o.BKP17R.Reg, value)
}
func (o *RTC_Type) GetBKP17R() uint32 {
	return volatile.LoadUint32(&o.BKP17R.Reg)
}

// RTC.BKP18R: backup register
func (o *RTC_Type) SetBKP18R(value uint32) {
	volatile.StoreUint32(&o.BKP18R.Reg, value)
}
func (o *RTC_Type) GetBKP18R() uint32 {
	return volatile.LoadUint32(&o.BKP18R.Reg)
}

// RTC.BKP19R: backup register
func (o *RTC_Type) SetBKP19R(value uint32) {
	volatile.StoreUint32(&o.BKP19R.Reg, value)
}
func (o *RTC_Type) GetBKP19R() uint32 {
	return volatile.LoadUint32(&o.BKP19R.Reg)
}

// RTC.BKP20R: backup register
func (o *RTC_Type) SetBKP20R(value uint32) {
	volatile.StoreUint32(&o.BKP20R.Reg, value)
}
func (o *RTC_Type) GetBKP20R() uint32 {
	return volatile.LoadUint32(&o.BKP20R.Reg)
}

// RTC.BKP21R: backup register
func (o *RTC_Type) SetBKP21R(value uint32) {
	volatile.StoreUint32(&o.BKP21R.Reg, value)
}
func (o *RTC_Type) GetBKP21R() uint32 {
	return volatile.LoadUint32(&o.BKP21R.Reg)
}

// RTC.BKP22R: backup register
func (o *RTC_Type) SetBKP22R(value uint32) {
	volatile.StoreUint32(&o.BKP22R.Reg, value)
}
func (o *RTC_Type) GetBKP22R() uint32 {
	return volatile.LoadUint32(&o.BKP22R.Reg)
}

// RTC.BKP23R: backup register
func (o *RTC_Type) SetBKP23R(value uint32) {
	volatile.StoreUint32(&o.BKP23R.Reg, value)
}
func (o *RTC_Type) GetBKP23R() uint32 {
	return volatile.LoadUint32(&o.BKP23R.Reg)
}

// RTC.BKP24R: backup register
func (o *RTC_Type) SetBKP24R(value uint32) {
	volatile.StoreUint32(&o.BKP24R.Reg, value)
}
func (o *RTC_Type) GetBKP24R() uint32 {
	return volatile.LoadUint32(&o.BKP24R.Reg)
}

// RTC.BKP25R: backup register
func (o *RTC_Type) SetBKP25R(value uint32) {
	volatile.StoreUint32(&o.BKP25R.Reg, value)
}
func (o *RTC_Type) GetBKP25R() uint32 {
	return volatile.LoadUint32(&o.BKP25R.Reg)
}

// RTC.BKP26R: backup register
func (o *RTC_Type) SetBKP26R(value uint32) {
	volatile.StoreUint32(&o.BKP26R.Reg, value)
}
func (o *RTC_Type) GetBKP26R() uint32 {
	return volatile.LoadUint32(&o.BKP26R.Reg)
}

// RTC.BKP27R: backup register
func (o *RTC_Type) SetBKP27R(value uint32) {
	volatile.StoreUint32(&o.BKP27R.Reg, value)
}
func (o *RTC_Type) GetBKP27R() uint32 {
	return volatile.LoadUint32(&o.BKP27R.Reg)
}

// RTC.BKP28R: backup register
func (o *RTC_Type) SetBKP28R(value uint32) {
	volatile.StoreUint32(&o.BKP28R.Reg, value)
}
func (o *RTC_Type) GetBKP28R() uint32 {
	return volatile.LoadUint32(&o.BKP28R.Reg)
}

// RTC.BKP29R: backup register
func (o *RTC_Type) SetBKP29R(value uint32) {
	volatile.StoreUint32(&o.BKP29R.Reg, value)
}
func (o *RTC_Type) GetBKP29R() uint32 {
	return volatile.LoadUint32(&o.BKP29R.Reg)
}

// RTC.BKP30R: backup register
func (o *RTC_Type) SetBKP30R(value uint32) {
	volatile.StoreUint32(&o.BKP30R.Reg, value)
}
func (o *RTC_Type) GetBKP30R() uint32 {
	return volatile.LoadUint32(&o.BKP30R.Reg)
}

// RTC.BKP31R: backup register
func (o *RTC_Type) SetBKP31R(value uint32) {
	volatile.StoreUint32(&o.BKP31R.Reg, value)
}
func (o *RTC_Type) GetBKP31R() uint32 {
	return volatile.LoadUint32(&o.BKP31R.Reg)
}

// Universal synchronous asynchronous receiver transmitter
type USART_Type struct {
	CR1  volatile.Register32 // 0x0
	CR2  volatile.Register32 // 0x4
	CR3  volatile.Register32 // 0x8
	BRR  volatile.Register32 // 0xC
	GTPR volatile.Register32 // 0x10
	RTOR volatile.Register32 // 0x14
	RQR  volatile.Register32 // 0x18
	ISR  volatile.Register32 // 0x1C
	ICR  volatile.Register32 // 0x20
	RDR  volatile.Register32 // 0x24
	TDR  volatile.Register32 // 0x28
}

// USART.CR1: Control register 1
func (o *USART_Type) SetCR1_M1(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10000000)|value<<28)
}
func (o *USART_Type) GetCR1_M1() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10000000) >> 28
}
func (o *USART_Type) SetCR1_EOBIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8000000)|value<<27)
}
func (o *USART_Type) GetCR1_EOBIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8000000) >> 27
}
func (o *USART_Type) SetCR1_RTOIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000000)|value<<26)
}
func (o *USART_Type) GetCR1_RTOIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000000) >> 26
}
func (o *USART_Type) SetCR1_OVER8(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetCR1_OVER8() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetCR1_CMIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetCR1_CMIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetCR1_MME(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetCR1_MME() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetCR1_M0(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetCR1_M0() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetCR1_WAKE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetCR1_WAKE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetCR1_PCE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCR1_PCE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCR1_PS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCR1_PS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCR1_PEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCR1_PEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCR1_TXEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetCR1_TXEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetCR1_TCIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCR1_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCR1_RXNEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetCR1_RXNEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetCR1_IDLEIE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetCR1_IDLEIE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetCR1_TE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetCR1_TE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetCR1_RE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetCR1_RE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetCR1_UESM(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetCR1_UESM() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetCR1_UE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetCR1_UE() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}
func (o *USART_Type) SetCR1_DEAT(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x3e00000)|value<<21)
}
func (o *USART_Type) GetCR1_DEAT() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x3e00000) >> 21
}
func (o *USART_Type) SetCR1_DEDT(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1f0000)|value<<16)
}
func (o *USART_Type) GetCR1_DEDT() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x1f0000) >> 16
}

// USART.CR2: Control register 2
func (o *USART_Type) SetCR2_RTOEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x800000)|value<<23)
}
func (o *USART_Type) GetCR2_RTOEN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x800000) >> 23
}
func (o *USART_Type) SetCR2_ABREN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x100000)|value<<20)
}
func (o *USART_Type) GetCR2_ABREN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x100000) >> 20
}
func (o *USART_Type) SetCR2_MSBFIRST(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetCR2_MSBFIRST() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetCR2_DATAINV(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetCR2_DATAINV() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetCR2_TXINV(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetCR2_TXINV() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetCR2_RXINV(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetCR2_RXINV() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10000) >> 16
}
func (o *USART_Type) SetCR2_SWAP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetCR2_SWAP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetCR2_LINEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetCR2_LINEN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetCR2_STOP(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x3000)|value<<12)
}
func (o *USART_Type) GetCR2_STOP() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x3000) >> 12
}
func (o *USART_Type) SetCR2_CLKEN(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetCR2_CLKEN() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetCR2_CPOL(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCR2_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCR2_CPHA(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCR2_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCR2_LBCL(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCR2_LBCL() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCR2_LBDIE(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCR2_LBDIE() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCR2_LBDL(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetCR2_LBDL() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetCR2_ADDM7(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetCR2_ADDM7() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetCR2_ABRMOD(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0x600000)|value<<21)
}
func (o *USART_Type) GetCR2_ABRMOD() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0x600000) >> 21
}
func (o *USART_Type) SetCR2_ADD(value uint32) {
	volatile.StoreUint32(&o.CR2.Reg, volatile.LoadUint32(&o.CR2.Reg)&^(0xff000000)|value<<24)
}
func (o *USART_Type) GetCR2_ADD() uint32 {
	return (volatile.LoadUint32(&o.CR2.Reg) & 0xff000000) >> 24
}

// USART.CR3: Control register 3
func (o *USART_Type) SetCR3_WUFIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x400000)|value<<22)
}
func (o *USART_Type) GetCR3_WUFIE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x400000) >> 22
}
func (o *USART_Type) SetCR3_WUS(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x300000)|value<<20)
}
func (o *USART_Type) GetCR3_WUS() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x300000) >> 20
}
func (o *USART_Type) SetCR3_SCARCNT(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0xe0000)|value<<17)
}
func (o *USART_Type) GetCR3_SCARCNT() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0xe0000) >> 17
}
func (o *USART_Type) SetCR3_DEP(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetCR3_DEP() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetCR3_DEM(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetCR3_DEM() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetCR3_DDRE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x2000)|value<<13)
}
func (o *USART_Type) GetCR3_DDRE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x2000) >> 13
}
func (o *USART_Type) SetCR3_OVRDIS(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetCR3_OVRDIS() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetCR3_ONEBIT(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetCR3_ONEBIT() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetCR3_CTSIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetCR3_CTSIE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetCR3_CTSE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetCR3_CTSE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetCR3_RTSE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetCR3_RTSE() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetCR3_DMAT(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetCR3_DMAT() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetCR3_DMAR(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetCR3_DMAR() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetCR3_SCEN(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetCR3_SCEN() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetCR3_NACK(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetCR3_NACK() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetCR3_HDSEL(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetCR3_HDSEL() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetCR3_IRLP(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetCR3_IRLP() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetCR3_IREN(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetCR3_IREN() uint32 {
	return (volatile.LoadUint32(&o.CR3.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetCR3_EIE(value uint32) {
	volatile.StoreUint32(&o.CR3.Reg, volatile.LoadUint32(&o.CR3.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetCR3_EIE() uint32 {
	return volatile.LoadUint32(&o.CR3.Reg) & 0x1
}

// USART.BRR: Baud rate register
func (o *USART_Type) SetBRR(value uint32) {
	volatile.StoreUint32(&o.BRR.Reg, volatile.LoadUint32(&o.BRR.Reg)&^(0xffff)|value)
}
func (o *USART_Type) GetBRR() uint32 {
	return volatile.LoadUint32(&o.BRR.Reg) & 0xffff
}

// USART.GTPR: Guard time and prescaler register
func (o *USART_Type) SetGTPR_GT(value uint32) {
	volatile.StoreUint32(&o.GTPR.Reg, volatile.LoadUint32(&o.GTPR.Reg)&^(0xff00)|value<<8)
}
func (o *USART_Type) GetGTPR_GT() uint32 {
	return (volatile.LoadUint32(&o.GTPR.Reg) & 0xff00) >> 8
}
func (o *USART_Type) SetGTPR_PSC(value uint32) {
	volatile.StoreUint32(&o.GTPR.Reg, volatile.LoadUint32(&o.GTPR.Reg)&^(0xff)|value)
}
func (o *USART_Type) GetGTPR_PSC() uint32 {
	return volatile.LoadUint32(&o.GTPR.Reg) & 0xff
}

// USART.RTOR: Receiver timeout register
func (o *USART_Type) SetRTOR_BLEN(value uint32) {
	volatile.StoreUint32(&o.RTOR.Reg, volatile.LoadUint32(&o.RTOR.Reg)&^(0xff000000)|value<<24)
}
func (o *USART_Type) GetRTOR_BLEN() uint32 {
	return (volatile.LoadUint32(&o.RTOR.Reg) & 0xff000000) >> 24
}
func (o *USART_Type) SetRTOR_RTO(value uint32) {
	volatile.StoreUint32(&o.RTOR.Reg, volatile.LoadUint32(&o.RTOR.Reg)&^(0xffffff)|value)
}
func (o *USART_Type) GetRTOR_RTO() uint32 {
	return volatile.LoadUint32(&o.RTOR.Reg) & 0xffffff
}

// USART.RQR: Request register
func (o *USART_Type) SetRQR_TXFRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetRQR_TXFRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetRQR_RXFRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetRQR_RXFRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetRQR_MMRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetRQR_MMRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetRQR_SBKRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetRQR_SBKRQ() uint32 {
	return (volatile.LoadUint32(&o.RQR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetRQR_ABRRQ(value uint32) {
	volatile.StoreUint32(&o.RQR.Reg, volatile.LoadUint32(&o.RQR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetRQR_ABRRQ() uint32 {
	return volatile.LoadUint32(&o.RQR.Reg) & 0x1
}

// USART.ISR: Interrupt & status register
func (o *USART_Type) SetISR_REACK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400000)|value<<22)
}
func (o *USART_Type) GetISR_REACK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400000) >> 22
}
func (o *USART_Type) SetISR_TEACK(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200000)|value<<21)
}
func (o *USART_Type) GetISR_TEACK() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200000) >> 21
}
func (o *USART_Type) SetISR_WUF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100000)|value<<20)
}
func (o *USART_Type) GetISR_WUF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100000) >> 20
}
func (o *USART_Type) SetISR_RWU(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80000)|value<<19)
}
func (o *USART_Type) GetISR_RWU() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80000) >> 19
}
func (o *USART_Type) SetISR_SBKF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40000)|value<<18)
}
func (o *USART_Type) GetISR_SBKF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40000) >> 18
}
func (o *USART_Type) SetISR_CMF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetISR_CMF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetISR_BUSY(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10000)|value<<16)
}
func (o *USART_Type) GetISR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10000) >> 16
}
func (o *USART_Type) SetISR_ABRF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8000)|value<<15)
}
func (o *USART_Type) GetISR_ABRF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8000) >> 15
}
func (o *USART_Type) SetISR_ABRE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4000)|value<<14)
}
func (o *USART_Type) GetISR_ABRE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4000) >> 14
}
func (o *USART_Type) SetISR_EOBF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetISR_EOBF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetISR_RTOF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetISR_RTOF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetISR_CTS(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x400)|value<<10)
}
func (o *USART_Type) GetISR_CTS() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x400) >> 10
}
func (o *USART_Type) SetISR_CTSIF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetISR_CTSIF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetISR_LBDF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetISR_LBDF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetISR_TXE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x80)|value<<7)
}
func (o *USART_Type) GetISR_TXE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x80) >> 7
}
func (o *USART_Type) SetISR_TC(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetISR_TC() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetISR_RXNE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x20)|value<<5)
}
func (o *USART_Type) GetISR_RXNE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x20) >> 5
}
func (o *USART_Type) SetISR_IDLE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetISR_IDLE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetISR_ORE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetISR_ORE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetISR_NF(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetISR_NF() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetISR_FE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetISR_FE() uint32 {
	return (volatile.LoadUint32(&o.ISR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetISR_PE(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, volatile.LoadUint32(&o.ISR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetISR_PE() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg) & 0x1
}

// USART.ICR: Interrupt flag clear register
func (o *USART_Type) SetICR_WUCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100000)|value<<20)
}
func (o *USART_Type) GetICR_WUCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100000) >> 20
}
func (o *USART_Type) SetICR_CMCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20000)|value<<17)
}
func (o *USART_Type) GetICR_CMCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20000) >> 17
}
func (o *USART_Type) SetICR_EOBCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1000)|value<<12)
}
func (o *USART_Type) GetICR_EOBCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x1000) >> 12
}
func (o *USART_Type) SetICR_RTOCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x800)|value<<11)
}
func (o *USART_Type) GetICR_RTOCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x800) >> 11
}
func (o *USART_Type) SetICR_CTSCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x200)|value<<9)
}
func (o *USART_Type) GetICR_CTSCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x200) >> 9
}
func (o *USART_Type) SetICR_LBDCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100)|value<<8)
}
func (o *USART_Type) GetICR_LBDCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100) >> 8
}
func (o *USART_Type) SetICR_TCCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x40)|value<<6)
}
func (o *USART_Type) GetICR_TCCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x40) >> 6
}
func (o *USART_Type) SetICR_IDLECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *USART_Type) GetICR_IDLECF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *USART_Type) SetICR_ORECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *USART_Type) GetICR_ORECF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *USART_Type) SetICR_NCF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *USART_Type) GetICR_NCF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *USART_Type) SetICR_FECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *USART_Type) GetICR_FECF() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *USART_Type) SetICR_PECF(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *USART_Type) GetICR_PECF() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}

// USART.RDR: Receive data register
func (o *USART_Type) SetRDR(value uint32) {
	volatile.StoreUint32(&o.RDR.Reg, volatile.LoadUint32(&o.RDR.Reg)&^(0x1ff)|value)
}
func (o *USART_Type) GetRDR() uint32 {
	return volatile.LoadUint32(&o.RDR.Reg) & 0x1ff
}

// USART.TDR: Transmit data register
func (o *USART_Type) SetTDR(value uint32) {
	volatile.StoreUint32(&o.TDR.Reg, volatile.LoadUint32(&o.TDR.Reg)&^(0x1ff)|value)
}
func (o *USART_Type) GetTDR() uint32 {
	return volatile.LoadUint32(&o.TDR.Reg) & 0x1ff
}

// USB on the go full speed
type USB_OTG_FS_Type struct {
	OTG_FS_GOTGCTL         volatile.Register32 // 0x0
	OTG_FS_GOTGINT         volatile.Register32 // 0x4
	OTG_FS_GAHBCFG         volatile.Register32 // 0x8
	OTG_FS_GUSBCFG         volatile.Register32 // 0xC
	OTG_FS_GRSTCTL         volatile.Register32 // 0x10
	OTG_FS_GINTSTS         volatile.Register32 // 0x14
	OTG_FS_GINTMSK         volatile.Register32 // 0x18
	OTG_FS_GRXSTSR_Device  volatile.Register32 // 0x1C
	OTG_FS_GRXSTSP_Device  volatile.Register32 // 0x20
	OTG_FS_GRXFSIZ         volatile.Register32 // 0x24
	OTG_FS_DIEPTXF0_Device volatile.Register32 // 0x28
	OTG_FS_HNPTXSTS        volatile.Register32 // 0x2C
	OTG_FS_GI2CCTL         volatile.Register32 // 0x30
	_                      [4]byte
	OTG_FS_GCCFG           volatile.Register32 // 0x38
	OTG_FS_CID             volatile.Register32 // 0x3C
	_                      [20]byte
	OTG_FS_GLPMCFG         volatile.Register32 // 0x54
	OTG_FS_GPWRDN          volatile.Register32 // 0x58
	_                      [4]byte
	OTG_FS_GADPCTL         volatile.Register32 // 0x60
	_                      [156]byte
	OTG_FS_HPTXFSIZ        volatile.Register32 // 0x100
	OTG_FS_DIEPTXF1        volatile.Register32 // 0x104
	OTG_FS_DIEPTXF2        volatile.Register32 // 0x108
	OTG_FS_DIEPTXF3        volatile.Register32 // 0x10C
	OTG_FS_DIEPTXF4        volatile.Register32 // 0x110
	OTG_FS_DIEPTXF5        volatile.Register32 // 0x114
}

// USB_OTG_FS.OTG_FS_GOTGCTL: OTG_FS control and status register (OTG_FS_GOTGCTL)
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGCTL_SRQSCS(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg)&^(0x1)|value)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGCTL_SRQSCS() uint32 {
	return volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg) & 0x1
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGCTL_SRQ(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGCTL_SRQ() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg) & 0x2) >> 1
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGCTL_HNGSCS(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGCTL_HNGSCS() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg) & 0x100) >> 8
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGCTL_HNPRQ(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg)&^(0x200)|value<<9)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGCTL_HNPRQ() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg) & 0x200) >> 9
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGCTL_HSHNPEN(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg)&^(0x400)|value<<10)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGCTL_HSHNPEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg) & 0x400) >> 10
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGCTL_DHNPEN(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg)&^(0x800)|value<<11)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGCTL_DHNPEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg) & 0x800) >> 11
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGCTL_CIDSTS(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGCTL_CIDSTS() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGCTL_DBCT(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGCTL_DBCT() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGCTL_ASVLD(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg)&^(0x40000)|value<<18)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGCTL_ASVLD() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg) & 0x40000) >> 18
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGCTL_BSVLD(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg)&^(0x80000)|value<<19)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGCTL_BSVLD() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg) & 0x80000) >> 19
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGCTL_VBVALOEN(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg)&^(0x4)|value<<2)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGCTL_VBVALOEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg) & 0x4) >> 2
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGCTL_VBVALOVAL(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGCTL_VBVALOVAL() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg) & 0x8) >> 3
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGCTL_AVALOEN(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGCTL_AVALOEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg) & 0x10) >> 4
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGCTL_AVALOVAL(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg)&^(0x20)|value<<5)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGCTL_AVALOVAL() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg) & 0x20) >> 5
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGCTL_BVALOEN(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGCTL_BVALOEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg) & 0x40) >> 6
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGCTL_BVALOVAL(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg)&^(0x80)|value<<7)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGCTL_BVALOVAL() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg) & 0x80) >> 7
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGCTL_EHEN(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg)&^(0x1000)|value<<12)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGCTL_EHEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg) & 0x1000) >> 12
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGCTL_OTGVER(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg)&^(0x100000)|value<<20)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGCTL_OTGVER() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGCTL.Reg) & 0x100000) >> 20
}

// USB_OTG_FS.OTG_FS_GOTGINT: OTG_FS interrupt register (OTG_FS_GOTGINT)
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGINT_SEDET(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGINT.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGINT.Reg)&^(0x4)|value<<2)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGINT_SEDET() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGINT.Reg) & 0x4) >> 2
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGINT_SRSSCHG(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGINT.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGINT.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGINT_SRSSCHG() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGINT.Reg) & 0x100) >> 8
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGINT_HNSSCHG(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGINT.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGINT.Reg)&^(0x200)|value<<9)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGINT_HNSSCHG() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGINT.Reg) & 0x200) >> 9
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGINT_HNGDET(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGINT.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGINT.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGINT_HNGDET() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGINT.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGINT_ADTOCHG(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGINT.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGINT.Reg)&^(0x40000)|value<<18)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGINT_ADTOCHG() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGINT.Reg) & 0x40000) >> 18
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGINT_DBCDNE(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGINT.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGINT.Reg)&^(0x80000)|value<<19)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGINT_DBCDNE() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGINT.Reg) & 0x80000) >> 19
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GOTGINT_IDCHNG(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GOTGINT.Reg, volatile.LoadUint32(&o.OTG_FS_GOTGINT.Reg)&^(0x100000)|value<<20)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GOTGINT_IDCHNG() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GOTGINT.Reg) & 0x100000) >> 20
}

// USB_OTG_FS.OTG_FS_GAHBCFG: OTG_FS AHB configuration register (OTG_FS_GAHBCFG)
func (o *USB_OTG_FS_Type) SetOTG_FS_GAHBCFG_GINT(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GAHBCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GAHBCFG.Reg)&^(0x1)|value)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GAHBCFG_GINT() uint32 {
	return volatile.LoadUint32(&o.OTG_FS_GAHBCFG.Reg) & 0x1
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GAHBCFG_TXFELVL(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GAHBCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GAHBCFG.Reg)&^(0x80)|value<<7)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GAHBCFG_TXFELVL() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GAHBCFG.Reg) & 0x80) >> 7
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GAHBCFG_PTXFELVL(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GAHBCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GAHBCFG.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GAHBCFG_PTXFELVL() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GAHBCFG.Reg) & 0x100) >> 8
}

// USB_OTG_FS.OTG_FS_GUSBCFG: OTG_FS USB configuration register (OTG_FS_GUSBCFG)
func (o *USB_OTG_FS_Type) SetOTG_FS_GUSBCFG_TOCAL(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GUSBCFG.Reg)&^(0x7)|value)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GUSBCFG_TOCAL() uint32 {
	return volatile.LoadUint32(&o.OTG_FS_GUSBCFG.Reg) & 0x7
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GUSBCFG_PHYSEL(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GUSBCFG.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GUSBCFG_PHYSEL() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GUSBCFG.Reg) & 0x40) >> 6
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GUSBCFG_SRPCAP(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GUSBCFG.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GUSBCFG_SRPCAP() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GUSBCFG.Reg) & 0x100) >> 8
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GUSBCFG_HNPCAP(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GUSBCFG.Reg)&^(0x200)|value<<9)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GUSBCFG_HNPCAP() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GUSBCFG.Reg) & 0x200) >> 9
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GUSBCFG_TRDT(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GUSBCFG.Reg)&^(0x3c00)|value<<10)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GUSBCFG_TRDT() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GUSBCFG.Reg) & 0x3c00) >> 10
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GUSBCFG_FHMOD(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GUSBCFG.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GUSBCFG_FHMOD() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GUSBCFG.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GUSBCFG_FDMOD(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GUSBCFG.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GUSBCFG_FDMOD() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GUSBCFG.Reg) & 0x40000000) >> 30
}

// USB_OTG_FS.OTG_FS_GRSTCTL: OTG_FS reset register (OTG_FS_GRSTCTL)
func (o *USB_OTG_FS_Type) SetOTG_FS_GRSTCTL_CSRST(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GRSTCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GRSTCTL.Reg)&^(0x1)|value)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GRSTCTL_CSRST() uint32 {
	return volatile.LoadUint32(&o.OTG_FS_GRSTCTL.Reg) & 0x1
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GRSTCTL_HSRST(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GRSTCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GRSTCTL.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GRSTCTL_HSRST() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GRSTCTL.Reg) & 0x2) >> 1
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GRSTCTL_FCRST(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GRSTCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GRSTCTL.Reg)&^(0x4)|value<<2)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GRSTCTL_FCRST() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GRSTCTL.Reg) & 0x4) >> 2
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GRSTCTL_RXFFLSH(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GRSTCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GRSTCTL.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GRSTCTL_RXFFLSH() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GRSTCTL.Reg) & 0x10) >> 4
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GRSTCTL_TXFFLSH(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GRSTCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GRSTCTL.Reg)&^(0x20)|value<<5)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GRSTCTL_TXFFLSH() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GRSTCTL.Reg) & 0x20) >> 5
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GRSTCTL_TXFNUM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GRSTCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GRSTCTL.Reg)&^(0x7c0)|value<<6)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GRSTCTL_TXFNUM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GRSTCTL.Reg) & 0x7c0) >> 6
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GRSTCTL_AHBIDL(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GRSTCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GRSTCTL.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GRSTCTL_AHBIDL() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GRSTCTL.Reg) & 0x80000000) >> 31
}

// USB_OTG_FS.OTG_FS_GINTSTS: OTG_FS core interrupt register (OTG_FS_GINTSTS)
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_CMOD(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x1)|value)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_CMOD() uint32 {
	return volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x1
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_MMIS(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_MMIS() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x2) >> 1
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_OTGINT(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x4)|value<<2)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_OTGINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x4) >> 2
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_SOF(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_SOF() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x8) >> 3
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_RXFLVL(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_RXFLVL() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x10) >> 4
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_NPTXFE(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x20)|value<<5)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_NPTXFE() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x20) >> 5
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_GINAKEFF(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_GINAKEFF() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x40) >> 6
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_GOUTNAKEFF(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x80)|value<<7)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_GOUTNAKEFF() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x80) >> 7
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_ESUSP(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x400)|value<<10)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_ESUSP() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x400) >> 10
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_USBSUSP(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x800)|value<<11)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_USBSUSP() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x800) >> 11
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_USBRST(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x1000)|value<<12)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_USBRST() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x1000) >> 12
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_ENUMDNE(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x2000)|value<<13)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_ENUMDNE() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x2000) >> 13
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_ISOODRP(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x4000)|value<<14)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_ISOODRP() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x4000) >> 14
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_EOPF(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_EOPF() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_IEPINT(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x40000)|value<<18)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_IEPINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x40000) >> 18
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_OEPINT(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x80000)|value<<19)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_OEPINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x80000) >> 19
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_IISOIXFR(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x100000)|value<<20)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_IISOIXFR() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x100000) >> 20
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_IPXFR_INCOMPISOOUT(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_IPXFR_INCOMPISOOUT() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_HPRTINT(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_HPRTINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x1000000) >> 24
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_HCINT(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_HCINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x2000000) >> 25
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_PTXFE(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_PTXFE() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_CIDSCHG(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_CIDSCHG() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x10000000) >> 28
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_DISCINT(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_DISCINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_SRQINT(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_SRQINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_WKUPINT(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_WKUPINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x80000000) >> 31
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTSTS_RSTDET(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg)&^(0x800000)|value<<23)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTSTS_RSTDET() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTSTS.Reg) & 0x800000) >> 23
}

// USB_OTG_FS.OTG_FS_GINTMSK: OTG_FS interrupt mask register (OTG_FS_GINTMSK)
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_MMISM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_MMISM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x2) >> 1
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_OTGINT(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x4)|value<<2)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_OTGINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x4) >> 2
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_SOFM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_SOFM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x8) >> 3
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_RXFLVLM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_RXFLVLM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x10) >> 4
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_NPTXFEM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x20)|value<<5)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_NPTXFEM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x20) >> 5
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_GINAKEFFM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_GINAKEFFM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x40) >> 6
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_GONAKEFFM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x80)|value<<7)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_GONAKEFFM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x80) >> 7
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_ESUSPM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x400)|value<<10)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_ESUSPM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x400) >> 10
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_USBSUSPM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x800)|value<<11)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_USBSUSPM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x800) >> 11
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_USBRST(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x1000)|value<<12)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_USBRST() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x1000) >> 12
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_ENUMDNEM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x2000)|value<<13)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_ENUMDNEM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x2000) >> 13
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_ISOODRPM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x4000)|value<<14)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_ISOODRPM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x4000) >> 14
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_EOPFM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_EOPFM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_IEPINT(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x40000)|value<<18)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_IEPINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x40000) >> 18
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_OEPINT(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x80000)|value<<19)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_OEPINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x80000) >> 19
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_IISOIXFRM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x100000)|value<<20)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_IISOIXFRM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x100000) >> 20
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_IPXFRM_IISOOXFRM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_IPXFRM_IISOOXFRM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_PRTIM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_PRTIM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x1000000) >> 24
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_HCIM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_HCIM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x2000000) >> 25
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_PTXFEM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_PTXFEM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_CIDSCHGM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_CIDSCHGM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x10000000) >> 28
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_DISCINT(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_DISCINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_SRQIM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_SRQIM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_WUIM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_WUIM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x80000000) >> 31
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_RSTDETM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x800000)|value<<23)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_RSTDETM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x800000) >> 23
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GINTMSK_LPMIN(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GINTMSK_LPMIN() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GINTMSK.Reg) & 0x8000000) >> 27
}

// USB_OTG_FS.OTG_FS_GRXSTSR_Device: OTG_FS Receive status debug read(Device mode)
func (o *USB_OTG_FS_Type) SetOTG_FS_GRXSTSR_Device_EPNUM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GRXSTSR_Device.Reg, volatile.LoadUint32(&o.OTG_FS_GRXSTSR_Device.Reg)&^(0xf)|value)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GRXSTSR_Device_EPNUM() uint32 {
	return volatile.LoadUint32(&o.OTG_FS_GRXSTSR_Device.Reg) & 0xf
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GRXSTSR_Device_BCNT(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GRXSTSR_Device.Reg, volatile.LoadUint32(&o.OTG_FS_GRXSTSR_Device.Reg)&^(0x7ff0)|value<<4)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GRXSTSR_Device_BCNT() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GRXSTSR_Device.Reg) & 0x7ff0) >> 4
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GRXSTSR_Device_DPID(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GRXSTSR_Device.Reg, volatile.LoadUint32(&o.OTG_FS_GRXSTSR_Device.Reg)&^(0x18000)|value<<15)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GRXSTSR_Device_DPID() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GRXSTSR_Device.Reg) & 0x18000) >> 15
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GRXSTSR_Device_PKTSTS(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GRXSTSR_Device.Reg, volatile.LoadUint32(&o.OTG_FS_GRXSTSR_Device.Reg)&^(0x1e0000)|value<<17)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GRXSTSR_Device_PKTSTS() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GRXSTSR_Device.Reg) & 0x1e0000) >> 17
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GRXSTSR_Device_FRMNUM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GRXSTSR_Device.Reg, volatile.LoadUint32(&o.OTG_FS_GRXSTSR_Device.Reg)&^(0x1e00000)|value<<21)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GRXSTSR_Device_FRMNUM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GRXSTSR_Device.Reg) & 0x1e00000) >> 21
}

// USB_OTG_FS.OTG_FS_GRXSTSP_Device: OTG status read and pop register (Device mode)
func (o *USB_OTG_FS_Type) SetOTG_FS_GRXSTSP_Device_EPNUM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GRXSTSP_Device.Reg, volatile.LoadUint32(&o.OTG_FS_GRXSTSP_Device.Reg)&^(0xf)|value)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GRXSTSP_Device_EPNUM() uint32 {
	return volatile.LoadUint32(&o.OTG_FS_GRXSTSP_Device.Reg) & 0xf
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GRXSTSP_Device_BCNT(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GRXSTSP_Device.Reg, volatile.LoadUint32(&o.OTG_FS_GRXSTSP_Device.Reg)&^(0x7ff0)|value<<4)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GRXSTSP_Device_BCNT() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GRXSTSP_Device.Reg) & 0x7ff0) >> 4
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GRXSTSP_Device_DPID(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GRXSTSP_Device.Reg, volatile.LoadUint32(&o.OTG_FS_GRXSTSP_Device.Reg)&^(0x18000)|value<<15)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GRXSTSP_Device_DPID() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GRXSTSP_Device.Reg) & 0x18000) >> 15
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GRXSTSP_Device_PKTSTS(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GRXSTSP_Device.Reg, volatile.LoadUint32(&o.OTG_FS_GRXSTSP_Device.Reg)&^(0x1e0000)|value<<17)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GRXSTSP_Device_PKTSTS() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GRXSTSP_Device.Reg) & 0x1e0000) >> 17
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GRXSTSP_Device_FRMNUM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GRXSTSP_Device.Reg, volatile.LoadUint32(&o.OTG_FS_GRXSTSP_Device.Reg)&^(0x1e00000)|value<<21)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GRXSTSP_Device_FRMNUM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GRXSTSP_Device.Reg) & 0x1e00000) >> 21
}

// USB_OTG_FS.OTG_FS_GRXFSIZ: OTG_FS Receive FIFO size register (OTG_FS_GRXFSIZ)
func (o *USB_OTG_FS_Type) SetOTG_FS_GRXFSIZ_RXFD(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GRXFSIZ.Reg, volatile.LoadUint32(&o.OTG_FS_GRXFSIZ.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GRXFSIZ_RXFD() uint32 {
	return volatile.LoadUint32(&o.OTG_FS_GRXFSIZ.Reg) & 0xffff
}

// USB_OTG_FS.OTG_FS_DIEPTXF0_Device: OTG_FS Endpoint 0 Transmit FIFO size
func (o *USB_OTG_FS_Type) SetOTG_FS_DIEPTXF0_Device_TX0FSA(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_DIEPTXF0_Device.Reg, volatile.LoadUint32(&o.OTG_FS_DIEPTXF0_Device.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_DIEPTXF0_Device_TX0FSA() uint32 {
	return volatile.LoadUint32(&o.OTG_FS_DIEPTXF0_Device.Reg) & 0xffff
}
func (o *USB_OTG_FS_Type) SetOTG_FS_DIEPTXF0_Device_TX0FD(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_DIEPTXF0_Device.Reg, volatile.LoadUint32(&o.OTG_FS_DIEPTXF0_Device.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_DIEPTXF0_Device_TX0FD() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_DIEPTXF0_Device.Reg) & 0xffff0000) >> 16
}

// USB_OTG_FS.OTG_FS_HNPTXSTS: OTG_FS non-periodic transmit FIFO/queue status register (OTG_FS_GNPTXSTS)
func (o *USB_OTG_FS_Type) SetOTG_FS_HNPTXSTS_NPTXFSAV(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_HNPTXSTS.Reg, volatile.LoadUint32(&o.OTG_FS_HNPTXSTS.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_HNPTXSTS_NPTXFSAV() uint32 {
	return volatile.LoadUint32(&o.OTG_FS_HNPTXSTS.Reg) & 0xffff
}
func (o *USB_OTG_FS_Type) SetOTG_FS_HNPTXSTS_NPTQXSAV(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_HNPTXSTS.Reg, volatile.LoadUint32(&o.OTG_FS_HNPTXSTS.Reg)&^(0xff0000)|value<<16)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_HNPTXSTS_NPTQXSAV() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_HNPTXSTS.Reg) & 0xff0000) >> 16
}
func (o *USB_OTG_FS_Type) SetOTG_FS_HNPTXSTS_NPTXQTOP(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_HNPTXSTS.Reg, volatile.LoadUint32(&o.OTG_FS_HNPTXSTS.Reg)&^(0x7f000000)|value<<24)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_HNPTXSTS_NPTXQTOP() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_HNPTXSTS.Reg) & 0x7f000000) >> 24
}

// USB_OTG_FS.OTG_FS_GI2CCTL: OTG I2C access register
func (o *USB_OTG_FS_Type) SetOTG_FS_GI2CCTL_RWDATA(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GI2CCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GI2CCTL.Reg)&^(0xff)|value)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GI2CCTL_RWDATA() uint32 {
	return volatile.LoadUint32(&o.OTG_FS_GI2CCTL.Reg) & 0xff
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GI2CCTL_REGADDR(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GI2CCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GI2CCTL.Reg)&^(0xff00)|value<<8)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GI2CCTL_REGADDR() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GI2CCTL.Reg) & 0xff00) >> 8
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GI2CCTL_ADDR(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GI2CCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GI2CCTL.Reg)&^(0x7f0000)|value<<16)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GI2CCTL_ADDR() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GI2CCTL.Reg) & 0x7f0000) >> 16
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GI2CCTL_I2CEN(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GI2CCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GI2CCTL.Reg)&^(0x800000)|value<<23)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GI2CCTL_I2CEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GI2CCTL.Reg) & 0x800000) >> 23
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GI2CCTL_ACK(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GI2CCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GI2CCTL.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GI2CCTL_ACK() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GI2CCTL.Reg) & 0x1000000) >> 24
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GI2CCTL_I2CDEVADR(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GI2CCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GI2CCTL.Reg)&^(0xc000000)|value<<26)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GI2CCTL_I2CDEVADR() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GI2CCTL.Reg) & 0xc000000) >> 26
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GI2CCTL_I2CDATSE0(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GI2CCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GI2CCTL.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GI2CCTL_I2CDATSE0() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GI2CCTL.Reg) & 0x10000000) >> 28
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GI2CCTL_RW(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GI2CCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GI2CCTL.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GI2CCTL_RW() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GI2CCTL.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GI2CCTL_BSYDNE(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GI2CCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GI2CCTL.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GI2CCTL_BSYDNE() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GI2CCTL.Reg) & 0x80000000) >> 31
}

// USB_OTG_FS.OTG_FS_GCCFG: OTG_FS general core configuration register (OTG_FS_GCCFG)
func (o *USB_OTG_FS_Type) SetOTG_FS_GCCFG_PWRDWN(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GCCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GCCFG.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GCCFG_PWRDWN() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GCCFG.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GCCFG_BCDEN(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GCCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GCCFG.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GCCFG_BCDEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GCCFG.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GCCFG_DCDEN(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GCCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GCCFG.Reg)&^(0x40000)|value<<18)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GCCFG_DCDEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GCCFG.Reg) & 0x40000) >> 18
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GCCFG_PDEN(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GCCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GCCFG.Reg)&^(0x80000)|value<<19)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GCCFG_PDEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GCCFG.Reg) & 0x80000) >> 19
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GCCFG_SDEN(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GCCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GCCFG.Reg)&^(0x100000)|value<<20)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GCCFG_SDEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GCCFG.Reg) & 0x100000) >> 20
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GCCFG_VBDEN(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GCCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GCCFG.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GCCFG_VBDEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GCCFG.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GCCFG_DCDET(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GCCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GCCFG.Reg)&^(0x1)|value)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GCCFG_DCDET() uint32 {
	return volatile.LoadUint32(&o.OTG_FS_GCCFG.Reg) & 0x1
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GCCFG_PDET(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GCCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GCCFG.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GCCFG_PDET() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GCCFG.Reg) & 0x2) >> 1
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GCCFG_SDET(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GCCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GCCFG.Reg)&^(0x4)|value<<2)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GCCFG_SDET() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GCCFG.Reg) & 0x4) >> 2
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GCCFG_PS2DET(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GCCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GCCFG.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GCCFG_PS2DET() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GCCFG.Reg) & 0x8) >> 3
}

// USB_OTG_FS.OTG_FS_CID: core ID register
func (o *USB_OTG_FS_Type) SetOTG_FS_CID(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_CID.Reg, value)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_CID() uint32 {
	return volatile.LoadUint32(&o.OTG_FS_CID.Reg)
}

// USB_OTG_FS.OTG_FS_GLPMCFG: OTG core LPM configuration register
func (o *USB_OTG_FS_Type) SetOTG_FS_GLPMCFG_LPMEN(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg)&^(0x1)|value)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GLPMCFG_LPMEN() uint32 {
	return volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg) & 0x1
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GLPMCFG_LPMACK(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GLPMCFG_LPMACK() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg) & 0x2) >> 1
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GLPMCFG_BESL(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg)&^(0x3c)|value<<2)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GLPMCFG_BESL() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg) & 0x3c) >> 2
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GLPMCFG_REMWAKE(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GLPMCFG_REMWAKE() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg) & 0x40) >> 6
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GLPMCFG_L1SSEN(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg)&^(0x80)|value<<7)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GLPMCFG_L1SSEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg) & 0x80) >> 7
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GLPMCFG_BESLTHRS(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg)&^(0xf00)|value<<8)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GLPMCFG_BESLTHRS() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg) & 0xf00) >> 8
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GLPMCFG_L1DSEN(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg)&^(0x1000)|value<<12)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GLPMCFG_L1DSEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg) & 0x1000) >> 12
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GLPMCFG_LPMRST(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg)&^(0x6000)|value<<13)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GLPMCFG_LPMRST() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg) & 0x6000) >> 13
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GLPMCFG_SLPSTS(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GLPMCFG_SLPSTS() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GLPMCFG_L1RSMOK(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GLPMCFG_L1RSMOK() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GLPMCFG_LPMCHIDX(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg)&^(0x1e0000)|value<<17)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GLPMCFG_LPMCHIDX() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg) & 0x1e0000) >> 17
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GLPMCFG_LPMRCNT(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg)&^(0xe00000)|value<<21)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GLPMCFG_LPMRCNT() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg) & 0xe00000) >> 21
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GLPMCFG_SNDLPM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GLPMCFG_SNDLPM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg) & 0x1000000) >> 24
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GLPMCFG_LPMRCNTSTS(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg)&^(0xe000000)|value<<25)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GLPMCFG_LPMRCNTSTS() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg) & 0xe000000) >> 25
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GLPMCFG_ENBESL(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GLPMCFG_ENBESL() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GLPMCFG.Reg) & 0x10000000) >> 28
}

// USB_OTG_FS.OTG_FS_GPWRDN: OTG power down register
func (o *USB_OTG_FS_Type) SetOTG_FS_GPWRDN_ADPMEN(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GPWRDN.Reg, volatile.LoadUint32(&o.OTG_FS_GPWRDN.Reg)&^(0x1)|value)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GPWRDN_ADPMEN() uint32 {
	return volatile.LoadUint32(&o.OTG_FS_GPWRDN.Reg) & 0x1
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GPWRDN_ADPIF(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GPWRDN.Reg, volatile.LoadUint32(&o.OTG_FS_GPWRDN.Reg)&^(0x800000)|value<<23)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GPWRDN_ADPIF() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GPWRDN.Reg) & 0x800000) >> 23
}

// USB_OTG_FS.OTG_FS_GADPCTL: OTG ADP timer, control and status register
func (o *USB_OTG_FS_Type) SetOTG_FS_GADPCTL_PRBDSCHG(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GADPCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg)&^(0x3)|value)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GADPCTL_PRBDSCHG() uint32 {
	return volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg) & 0x3
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GADPCTL_PRBDELTA(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GADPCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg)&^(0xc)|value<<2)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GADPCTL_PRBDELTA() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg) & 0xc) >> 2
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GADPCTL_PRBPER(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GADPCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg)&^(0x30)|value<<4)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GADPCTL_PRBPER() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg) & 0x30) >> 4
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GADPCTL_RTIM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GADPCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg)&^(0x1ffc0)|value<<6)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GADPCTL_RTIM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg) & 0x1ffc0) >> 6
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GADPCTL_ENAPRB(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GADPCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GADPCTL_ENAPRB() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GADPCTL_ENASNS(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GADPCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg)&^(0x40000)|value<<18)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GADPCTL_ENASNS() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg) & 0x40000) >> 18
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GADPCTL_ADPRST(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GADPCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg)&^(0x80000)|value<<19)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GADPCTL_ADPRST() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg) & 0x80000) >> 19
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GADPCTL_ADPEN(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GADPCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg)&^(0x100000)|value<<20)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GADPCTL_ADPEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg) & 0x100000) >> 20
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GADPCTL_ADPPRBIF(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GADPCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GADPCTL_ADPPRBIF() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GADPCTL_ADPSNSIF(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GADPCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg)&^(0x400000)|value<<22)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GADPCTL_ADPSNSIF() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg) & 0x400000) >> 22
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GADPCTL_ADPTOIF(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GADPCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg)&^(0x800000)|value<<23)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GADPCTL_ADPTOIF() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg) & 0x800000) >> 23
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GADPCTL_ADPPRBIM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GADPCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GADPCTL_ADPPRBIM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg) & 0x1000000) >> 24
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GADPCTL_ADPSNSIM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GADPCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GADPCTL_ADPSNSIM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg) & 0x2000000) >> 25
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GADPCTL_ADPTOIM(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GADPCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GADPCTL_ADPTOIM() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_FS_Type) SetOTG_FS_GADPCTL_AR(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_GADPCTL.Reg, volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg)&^(0x18000000)|value<<27)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_GADPCTL_AR() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_GADPCTL.Reg) & 0x18000000) >> 27
}

// USB_OTG_FS.OTG_FS_HPTXFSIZ: OTG_FS Host periodic transmit FIFO size register (OTG_FS_HPTXFSIZ)
func (o *USB_OTG_FS_Type) SetOTG_FS_HPTXFSIZ_PTXSA(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_HPTXFSIZ.Reg, volatile.LoadUint32(&o.OTG_FS_HPTXFSIZ.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_HPTXFSIZ_PTXSA() uint32 {
	return volatile.LoadUint32(&o.OTG_FS_HPTXFSIZ.Reg) & 0xffff
}
func (o *USB_OTG_FS_Type) SetOTG_FS_HPTXFSIZ_PTXFSIZ(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_HPTXFSIZ.Reg, volatile.LoadUint32(&o.OTG_FS_HPTXFSIZ.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_HPTXFSIZ_PTXFSIZ() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_HPTXFSIZ.Reg) & 0xffff0000) >> 16
}

// USB_OTG_FS.OTG_FS_DIEPTXF1: OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF1)
func (o *USB_OTG_FS_Type) SetOTG_FS_DIEPTXF1_INEPTXSA(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_DIEPTXF1.Reg, volatile.LoadUint32(&o.OTG_FS_DIEPTXF1.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_DIEPTXF1_INEPTXSA() uint32 {
	return volatile.LoadUint32(&o.OTG_FS_DIEPTXF1.Reg) & 0xffff
}
func (o *USB_OTG_FS_Type) SetOTG_FS_DIEPTXF1_INEPTXFD(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_DIEPTXF1.Reg, volatile.LoadUint32(&o.OTG_FS_DIEPTXF1.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_DIEPTXF1_INEPTXFD() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_DIEPTXF1.Reg) & 0xffff0000) >> 16
}

// USB_OTG_FS.OTG_FS_DIEPTXF2: OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF2)
func (o *USB_OTG_FS_Type) SetOTG_FS_DIEPTXF2_INEPTXSA(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_DIEPTXF2.Reg, volatile.LoadUint32(&o.OTG_FS_DIEPTXF2.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_DIEPTXF2_INEPTXSA() uint32 {
	return volatile.LoadUint32(&o.OTG_FS_DIEPTXF2.Reg) & 0xffff
}
func (o *USB_OTG_FS_Type) SetOTG_FS_DIEPTXF2_INEPTXFD(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_DIEPTXF2.Reg, volatile.LoadUint32(&o.OTG_FS_DIEPTXF2.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_DIEPTXF2_INEPTXFD() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_DIEPTXF2.Reg) & 0xffff0000) >> 16
}

// USB_OTG_FS.OTG_FS_DIEPTXF3: OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF3)
func (o *USB_OTG_FS_Type) SetOTG_FS_DIEPTXF3_INEPTXSA(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_DIEPTXF3.Reg, volatile.LoadUint32(&o.OTG_FS_DIEPTXF3.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_DIEPTXF3_INEPTXSA() uint32 {
	return volatile.LoadUint32(&o.OTG_FS_DIEPTXF3.Reg) & 0xffff
}
func (o *USB_OTG_FS_Type) SetOTG_FS_DIEPTXF3_INEPTXFD(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_DIEPTXF3.Reg, volatile.LoadUint32(&o.OTG_FS_DIEPTXF3.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_DIEPTXF3_INEPTXFD() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_DIEPTXF3.Reg) & 0xffff0000) >> 16
}

// USB_OTG_FS.OTG_FS_DIEPTXF4: OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF4)
func (o *USB_OTG_FS_Type) SetOTG_FS_DIEPTXF4_INEPTXSA(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_DIEPTXF4.Reg, volatile.LoadUint32(&o.OTG_FS_DIEPTXF4.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_DIEPTXF4_INEPTXSA() uint32 {
	return volatile.LoadUint32(&o.OTG_FS_DIEPTXF4.Reg) & 0xffff
}
func (o *USB_OTG_FS_Type) SetOTG_FS_DIEPTXF4_INEPTXFD(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_DIEPTXF4.Reg, volatile.LoadUint32(&o.OTG_FS_DIEPTXF4.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_DIEPTXF4_INEPTXFD() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_DIEPTXF4.Reg) & 0xffff0000) >> 16
}

// USB_OTG_FS.OTG_FS_DIEPTXF5: OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF5)
func (o *USB_OTG_FS_Type) SetOTG_FS_DIEPTXF5_INEPTXSA(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_DIEPTXF5.Reg, volatile.LoadUint32(&o.OTG_FS_DIEPTXF5.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_DIEPTXF5_INEPTXSA() uint32 {
	return volatile.LoadUint32(&o.OTG_FS_DIEPTXF5.Reg) & 0xffff
}
func (o *USB_OTG_FS_Type) SetOTG_FS_DIEPTXF5_INEPTXFD(value uint32) {
	volatile.StoreUint32(&o.OTG_FS_DIEPTXF5.Reg, volatile.LoadUint32(&o.OTG_FS_DIEPTXF5.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_FS_Type) GetOTG_FS_DIEPTXF5_INEPTXFD() uint32 {
	return (volatile.LoadUint32(&o.OTG_FS_DIEPTXF5.Reg) & 0xffff0000) >> 16
}

// USB on the go high speed
type USB_OTG_HS_Type struct {
	OTG_HS_GOTGCTL        volatile.Register32 // 0x0
	OTG_HS_GOTGINT        volatile.Register32 // 0x4
	OTG_HS_GAHBCFG        volatile.Register32 // 0x8
	OTG_HS_GUSBCFG        volatile.Register32 // 0xC
	OTG_HS_GRSTCTL        volatile.Register32 // 0x10
	OTG_HS_GINTSTS        volatile.Register32 // 0x14
	OTG_HS_GINTMSK        volatile.Register32 // 0x18
	OTG_HS_GRXSTSR_Host   volatile.Register32 // 0x1C
	OTG_HS_GRXSTSP_Host   volatile.Register32 // 0x20
	OTG_HS_GRXFSIZ        volatile.Register32 // 0x24
	OTG_HS_HNPTXFSIZ_Host volatile.Register32 // 0x28
	OTG_HS_GNPTXSTS       volatile.Register32 // 0x2C
	_                     [8]byte
	OTG_HS_GCCFG          volatile.Register32 // 0x38
	OTG_HS_CID            volatile.Register32 // 0x3C
	_                     [20]byte
	OTG_HS_GLPMCFG        volatile.Register32 // 0x54
	_                     [168]byte
	OTG_HS_HPTXFSIZ       volatile.Register32 // 0x100
	OTG_HS_DIEPTXF1       volatile.Register32 // 0x104
	OTG_HS_DIEPTXF2       volatile.Register32 // 0x108
	_                     [16]byte
	OTG_HS_DIEPTXF3       volatile.Register32 // 0x11C
	OTG_HS_DIEPTXF4       volatile.Register32 // 0x120
	OTG_HS_DIEPTXF5       volatile.Register32 // 0x124
	OTG_HS_DIEPTXF6       volatile.Register32 // 0x128
	OTG_HS_DIEPTXF7       volatile.Register32 // 0x12C
}

// USB_OTG_HS.OTG_HS_GOTGCTL: OTG_HS control and status register
func (o *USB_OTG_HS_Type) SetOTG_HS_GOTGCTL_SRQSCS(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_HS_GOTGCTL.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GOTGCTL_SRQSCS() uint32 {
	return volatile.LoadUint32(&o.OTG_HS_GOTGCTL.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GOTGCTL_SRQ(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_HS_GOTGCTL.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GOTGCTL_SRQ() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GOTGCTL.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GOTGCTL_HNGSCS(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_HS_GOTGCTL.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GOTGCTL_HNGSCS() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GOTGCTL.Reg) & 0x100) >> 8
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GOTGCTL_HNPRQ(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_HS_GOTGCTL.Reg)&^(0x200)|value<<9)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GOTGCTL_HNPRQ() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GOTGCTL.Reg) & 0x200) >> 9
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GOTGCTL_HSHNPEN(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_HS_GOTGCTL.Reg)&^(0x400)|value<<10)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GOTGCTL_HSHNPEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GOTGCTL.Reg) & 0x400) >> 10
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GOTGCTL_DHNPEN(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_HS_GOTGCTL.Reg)&^(0x800)|value<<11)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GOTGCTL_DHNPEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GOTGCTL.Reg) & 0x800) >> 11
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GOTGCTL_CIDSTS(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_HS_GOTGCTL.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GOTGCTL_CIDSTS() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GOTGCTL.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GOTGCTL_DBCT(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_HS_GOTGCTL.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GOTGCTL_DBCT() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GOTGCTL.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GOTGCTL_ASVLD(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_HS_GOTGCTL.Reg)&^(0x40000)|value<<18)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GOTGCTL_ASVLD() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GOTGCTL.Reg) & 0x40000) >> 18
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GOTGCTL_BSVLD(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_HS_GOTGCTL.Reg)&^(0x80000)|value<<19)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GOTGCTL_BSVLD() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GOTGCTL.Reg) & 0x80000) >> 19
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GOTGCTL_EHEN(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GOTGCTL.Reg, volatile.LoadUint32(&o.OTG_HS_GOTGCTL.Reg)&^(0x1000)|value<<12)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GOTGCTL_EHEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GOTGCTL.Reg) & 0x1000) >> 12
}

// USB_OTG_HS.OTG_HS_GOTGINT: OTG_HS interrupt register
func (o *USB_OTG_HS_Type) SetOTG_HS_GOTGINT_SEDET(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GOTGINT.Reg, volatile.LoadUint32(&o.OTG_HS_GOTGINT.Reg)&^(0x4)|value<<2)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GOTGINT_SEDET() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GOTGINT.Reg) & 0x4) >> 2
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GOTGINT_SRSSCHG(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GOTGINT.Reg, volatile.LoadUint32(&o.OTG_HS_GOTGINT.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GOTGINT_SRSSCHG() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GOTGINT.Reg) & 0x100) >> 8
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GOTGINT_HNSSCHG(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GOTGINT.Reg, volatile.LoadUint32(&o.OTG_HS_GOTGINT.Reg)&^(0x200)|value<<9)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GOTGINT_HNSSCHG() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GOTGINT.Reg) & 0x200) >> 9
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GOTGINT_HNGDET(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GOTGINT.Reg, volatile.LoadUint32(&o.OTG_HS_GOTGINT.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GOTGINT_HNGDET() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GOTGINT.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GOTGINT_ADTOCHG(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GOTGINT.Reg, volatile.LoadUint32(&o.OTG_HS_GOTGINT.Reg)&^(0x40000)|value<<18)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GOTGINT_ADTOCHG() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GOTGINT.Reg) & 0x40000) >> 18
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GOTGINT_DBCDNE(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GOTGINT.Reg, volatile.LoadUint32(&o.OTG_HS_GOTGINT.Reg)&^(0x80000)|value<<19)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GOTGINT_DBCDNE() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GOTGINT.Reg) & 0x80000) >> 19
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GOTGINT_IDCHNG(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GOTGINT.Reg, volatile.LoadUint32(&o.OTG_HS_GOTGINT.Reg)&^(0x100000)|value<<20)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GOTGINT_IDCHNG() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GOTGINT.Reg) & 0x100000) >> 20
}

// USB_OTG_HS.OTG_HS_GAHBCFG: OTG_HS AHB configuration register
func (o *USB_OTG_HS_Type) SetOTG_HS_GAHBCFG_GINT(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GAHBCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GAHBCFG.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GAHBCFG_GINT() uint32 {
	return volatile.LoadUint32(&o.OTG_HS_GAHBCFG.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GAHBCFG_HBSTLEN(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GAHBCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GAHBCFG.Reg)&^(0x1e)|value<<1)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GAHBCFG_HBSTLEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GAHBCFG.Reg) & 0x1e) >> 1
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GAHBCFG_DMAEN(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GAHBCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GAHBCFG.Reg)&^(0x20)|value<<5)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GAHBCFG_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GAHBCFG.Reg) & 0x20) >> 5
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GAHBCFG_TXFELVL(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GAHBCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GAHBCFG.Reg)&^(0x80)|value<<7)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GAHBCFG_TXFELVL() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GAHBCFG.Reg) & 0x80) >> 7
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GAHBCFG_PTXFELVL(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GAHBCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GAHBCFG.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GAHBCFG_PTXFELVL() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GAHBCFG.Reg) & 0x100) >> 8
}

// USB_OTG_HS.OTG_HS_GUSBCFG: OTG_HS USB configuration register
func (o *USB_OTG_HS_Type) SetOTG_HS_GUSBCFG_TOCAL(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg)&^(0x7)|value)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GUSBCFG_TOCAL() uint32 {
	return volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg) & 0x7
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GUSBCFG_PHYSEL(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GUSBCFG_PHYSEL() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg) & 0x40) >> 6
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GUSBCFG_SRPCAP(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg)&^(0x100)|value<<8)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GUSBCFG_SRPCAP() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg) & 0x100) >> 8
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GUSBCFG_HNPCAP(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg)&^(0x200)|value<<9)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GUSBCFG_HNPCAP() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg) & 0x200) >> 9
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GUSBCFG_TRDT(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg)&^(0x3c00)|value<<10)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GUSBCFG_TRDT() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg) & 0x3c00) >> 10
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GUSBCFG_PHYLPCS(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GUSBCFG_PHYLPCS() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GUSBCFG_ULPIFSLS(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GUSBCFG_ULPIFSLS() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GUSBCFG_ULPIAR(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg)&^(0x40000)|value<<18)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GUSBCFG_ULPIAR() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg) & 0x40000) >> 18
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GUSBCFG_ULPICSM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg)&^(0x80000)|value<<19)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GUSBCFG_ULPICSM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg) & 0x80000) >> 19
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GUSBCFG_ULPIEVBUSD(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg)&^(0x100000)|value<<20)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GUSBCFG_ULPIEVBUSD() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg) & 0x100000) >> 20
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GUSBCFG_ULPIEVBUSI(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GUSBCFG_ULPIEVBUSI() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GUSBCFG_TSDPS(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg)&^(0x400000)|value<<22)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GUSBCFG_TSDPS() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg) & 0x400000) >> 22
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GUSBCFG_PCCI(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg)&^(0x800000)|value<<23)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GUSBCFG_PCCI() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg) & 0x800000) >> 23
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GUSBCFG_PTCI(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GUSBCFG_PTCI() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg) & 0x1000000) >> 24
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GUSBCFG_ULPIIPD(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GUSBCFG_ULPIIPD() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg) & 0x2000000) >> 25
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GUSBCFG_FHMOD(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GUSBCFG_FHMOD() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GUSBCFG_FDMOD(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GUSBCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GUSBCFG_FDMOD() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GUSBCFG.Reg) & 0x40000000) >> 30
}

// USB_OTG_HS.OTG_HS_GRSTCTL: OTG_HS reset register
func (o *USB_OTG_HS_Type) SetOTG_HS_GRSTCTL_CSRST(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GRSTCTL.Reg, volatile.LoadUint32(&o.OTG_HS_GRSTCTL.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GRSTCTL_CSRST() uint32 {
	return volatile.LoadUint32(&o.OTG_HS_GRSTCTL.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GRSTCTL_HSRST(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GRSTCTL.Reg, volatile.LoadUint32(&o.OTG_HS_GRSTCTL.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GRSTCTL_HSRST() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GRSTCTL.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GRSTCTL_FCRST(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GRSTCTL.Reg, volatile.LoadUint32(&o.OTG_HS_GRSTCTL.Reg)&^(0x4)|value<<2)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GRSTCTL_FCRST() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GRSTCTL.Reg) & 0x4) >> 2
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GRSTCTL_RXFFLSH(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GRSTCTL.Reg, volatile.LoadUint32(&o.OTG_HS_GRSTCTL.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GRSTCTL_RXFFLSH() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GRSTCTL.Reg) & 0x10) >> 4
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GRSTCTL_TXFFLSH(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GRSTCTL.Reg, volatile.LoadUint32(&o.OTG_HS_GRSTCTL.Reg)&^(0x20)|value<<5)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GRSTCTL_TXFFLSH() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GRSTCTL.Reg) & 0x20) >> 5
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GRSTCTL_TXFNUM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GRSTCTL.Reg, volatile.LoadUint32(&o.OTG_HS_GRSTCTL.Reg)&^(0x7c0)|value<<6)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GRSTCTL_TXFNUM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GRSTCTL.Reg) & 0x7c0) >> 6
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GRSTCTL_AHBIDL(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GRSTCTL.Reg, volatile.LoadUint32(&o.OTG_HS_GRSTCTL.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GRSTCTL_AHBIDL() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GRSTCTL.Reg) & 0x80000000) >> 31
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GRSTCTL_DMAREQ(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GRSTCTL.Reg, volatile.LoadUint32(&o.OTG_HS_GRSTCTL.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GRSTCTL_DMAREQ() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GRSTCTL.Reg) & 0x40000000) >> 30
}

// USB_OTG_HS.OTG_HS_GINTSTS: OTG_HS core interrupt register
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_CMOD(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_CMOD() uint32 {
	return volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_MMIS(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_MMIS() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_OTGINT(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x4)|value<<2)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_OTGINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x4) >> 2
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_SOF(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_SOF() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x8) >> 3
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_RXFLVL(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_RXFLVL() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x10) >> 4
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_NPTXFE(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x20)|value<<5)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_NPTXFE() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x20) >> 5
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_GINAKEFF(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_GINAKEFF() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x40) >> 6
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_BOUTNAKEFF(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x80)|value<<7)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_BOUTNAKEFF() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x80) >> 7
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_ESUSP(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x400)|value<<10)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_ESUSP() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x400) >> 10
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_USBSUSP(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x800)|value<<11)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_USBSUSP() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x800) >> 11
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_USBRST(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x1000)|value<<12)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_USBRST() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x1000) >> 12
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_ENUMDNE(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x2000)|value<<13)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_ENUMDNE() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x2000) >> 13
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_ISOODRP(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x4000)|value<<14)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_ISOODRP() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x4000) >> 14
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_EOPF(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_EOPF() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_IEPINT(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x40000)|value<<18)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_IEPINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x40000) >> 18
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_OEPINT(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x80000)|value<<19)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_OEPINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x80000) >> 19
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_IISOIXFR(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x100000)|value<<20)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_IISOIXFR() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x100000) >> 20
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_PXFR_INCOMPISOOUT(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_PXFR_INCOMPISOOUT() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_DATAFSUSP(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x400000)|value<<22)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_DATAFSUSP() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x400000) >> 22
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_HPRTINT(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_HPRTINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x1000000) >> 24
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_HCINT(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_HCINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x2000000) >> 25
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_PTXFE(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_PTXFE() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_CIDSCHG(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_CIDSCHG() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x10000000) >> 28
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_DISCINT(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_DISCINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_SRQINT(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_SRQINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTSTS_WKUINT(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTSTS_WKUINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTSTS.Reg) & 0x80000000) >> 31
}

// USB_OTG_HS.OTG_HS_GINTMSK: OTG_HS interrupt mask register
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_MMISM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_MMISM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_OTGINT(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x4)|value<<2)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_OTGINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x4) >> 2
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_SOFM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_SOFM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x8) >> 3
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_RXFLVLM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x10)|value<<4)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_RXFLVLM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x10) >> 4
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_NPTXFEM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x20)|value<<5)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_NPTXFEM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x20) >> 5
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_GINAKEFFM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_GINAKEFFM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x40) >> 6
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_GONAKEFFM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x80)|value<<7)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_GONAKEFFM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x80) >> 7
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_ESUSPM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x400)|value<<10)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_ESUSPM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x400) >> 10
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_USBSUSPM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x800)|value<<11)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_USBSUSPM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x800) >> 11
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_USBRST(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x1000)|value<<12)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_USBRST() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x1000) >> 12
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_ENUMDNEM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x2000)|value<<13)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_ENUMDNEM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x2000) >> 13
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_ISOODRPM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x4000)|value<<14)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_ISOODRPM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x4000) >> 14
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_EOPFM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_EOPFM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_IEPINT(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x40000)|value<<18)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_IEPINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x40000) >> 18
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_OEPINT(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x80000)|value<<19)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_OEPINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x80000) >> 19
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_IISOIXFRM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x100000)|value<<20)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_IISOIXFRM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x100000) >> 20
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_PXFRM_IISOOXFRM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_PXFRM_IISOOXFRM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_FSUSPM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x400000)|value<<22)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_FSUSPM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x400000) >> 22
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_PRTIM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_PRTIM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x1000000) >> 24
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_HCIM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_HCIM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x2000000) >> 25
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_PTXFEM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_PTXFEM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x4000000) >> 26
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_CIDSCHGM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_CIDSCHGM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x10000000) >> 28
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_DISCINT(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_DISCINT() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x20000000) >> 29
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_SRQIM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_SRQIM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x40000000) >> 30
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_WUIM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_WUIM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x80000000) >> 31
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_RSTDE(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x800000)|value<<23)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_RSTDE() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x800000) >> 23
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GINTMSK_LPMINTM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GINTMSK.Reg, volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GINTMSK_LPMINTM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GINTMSK.Reg) & 0x8000000) >> 27
}

// USB_OTG_HS.OTG_HS_GRXSTSR_Host: OTG_HS Receive status debug read register (host mode)
func (o *USB_OTG_HS_Type) SetOTG_HS_GRXSTSR_Host_CHNUM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GRXSTSR_Host.Reg, volatile.LoadUint32(&o.OTG_HS_GRXSTSR_Host.Reg)&^(0xf)|value)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GRXSTSR_Host_CHNUM() uint32 {
	return volatile.LoadUint32(&o.OTG_HS_GRXSTSR_Host.Reg) & 0xf
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GRXSTSR_Host_BCNT(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GRXSTSR_Host.Reg, volatile.LoadUint32(&o.OTG_HS_GRXSTSR_Host.Reg)&^(0x7ff0)|value<<4)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GRXSTSR_Host_BCNT() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GRXSTSR_Host.Reg) & 0x7ff0) >> 4
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GRXSTSR_Host_DPID(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GRXSTSR_Host.Reg, volatile.LoadUint32(&o.OTG_HS_GRXSTSR_Host.Reg)&^(0x18000)|value<<15)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GRXSTSR_Host_DPID() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GRXSTSR_Host.Reg) & 0x18000) >> 15
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GRXSTSR_Host_PKTSTS(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GRXSTSR_Host.Reg, volatile.LoadUint32(&o.OTG_HS_GRXSTSR_Host.Reg)&^(0x1e0000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GRXSTSR_Host_PKTSTS() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GRXSTSR_Host.Reg) & 0x1e0000) >> 17
}

// USB_OTG_HS.OTG_HS_GRXSTSP_Host: OTG_HS status read and pop register (host mode)
func (o *USB_OTG_HS_Type) SetOTG_HS_GRXSTSP_Host_CHNUM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GRXSTSP_Host.Reg, volatile.LoadUint32(&o.OTG_HS_GRXSTSP_Host.Reg)&^(0xf)|value)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GRXSTSP_Host_CHNUM() uint32 {
	return volatile.LoadUint32(&o.OTG_HS_GRXSTSP_Host.Reg) & 0xf
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GRXSTSP_Host_BCNT(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GRXSTSP_Host.Reg, volatile.LoadUint32(&o.OTG_HS_GRXSTSP_Host.Reg)&^(0x7ff0)|value<<4)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GRXSTSP_Host_BCNT() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GRXSTSP_Host.Reg) & 0x7ff0) >> 4
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GRXSTSP_Host_DPID(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GRXSTSP_Host.Reg, volatile.LoadUint32(&o.OTG_HS_GRXSTSP_Host.Reg)&^(0x18000)|value<<15)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GRXSTSP_Host_DPID() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GRXSTSP_Host.Reg) & 0x18000) >> 15
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GRXSTSP_Host_PKTSTS(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GRXSTSP_Host.Reg, volatile.LoadUint32(&o.OTG_HS_GRXSTSP_Host.Reg)&^(0x1e0000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GRXSTSP_Host_PKTSTS() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GRXSTSP_Host.Reg) & 0x1e0000) >> 17
}

// USB_OTG_HS.OTG_HS_GRXFSIZ: OTG_HS Receive FIFO size register
func (o *USB_OTG_HS_Type) SetOTG_HS_GRXFSIZ_RXFD(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GRXFSIZ.Reg, volatile.LoadUint32(&o.OTG_HS_GRXFSIZ.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GRXFSIZ_RXFD() uint32 {
	return volatile.LoadUint32(&o.OTG_HS_GRXFSIZ.Reg) & 0xffff
}

// USB_OTG_HS.OTG_HS_HNPTXFSIZ_Host: OTG_HS nonperiodic transmit FIFO size register (host mode)
func (o *USB_OTG_HS_Type) SetOTG_HS_HNPTXFSIZ_Host_NPTXFSA(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_HNPTXFSIZ_Host.Reg, volatile.LoadUint32(&o.OTG_HS_HNPTXFSIZ_Host.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_HNPTXFSIZ_Host_NPTXFSA() uint32 {
	return volatile.LoadUint32(&o.OTG_HS_HNPTXFSIZ_Host.Reg) & 0xffff
}
func (o *USB_OTG_HS_Type) SetOTG_HS_HNPTXFSIZ_Host_NPTXFD(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_HNPTXFSIZ_Host.Reg, volatile.LoadUint32(&o.OTG_HS_HNPTXFSIZ_Host.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_HNPTXFSIZ_Host_NPTXFD() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_HNPTXFSIZ_Host.Reg) & 0xffff0000) >> 16
}

// USB_OTG_HS.OTG_HS_GNPTXSTS: OTG_HS nonperiodic transmit FIFO/queue status register
func (o *USB_OTG_HS_Type) SetOTG_HS_GNPTXSTS_NPTXFSAV(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GNPTXSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GNPTXSTS.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GNPTXSTS_NPTXFSAV() uint32 {
	return volatile.LoadUint32(&o.OTG_HS_GNPTXSTS.Reg) & 0xffff
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GNPTXSTS_NPTQXSAV(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GNPTXSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GNPTXSTS.Reg)&^(0xff0000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GNPTXSTS_NPTQXSAV() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GNPTXSTS.Reg) & 0xff0000) >> 16
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GNPTXSTS_NPTXQTOP(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GNPTXSTS.Reg, volatile.LoadUint32(&o.OTG_HS_GNPTXSTS.Reg)&^(0x7f000000)|value<<24)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GNPTXSTS_NPTXQTOP() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GNPTXSTS.Reg) & 0x7f000000) >> 24
}

// USB_OTG_HS.OTG_HS_GCCFG: OTG_HS general core configuration register
func (o *USB_OTG_HS_Type) SetOTG_HS_GCCFG_PWRDWN(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GCCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GCCFG.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GCCFG_PWRDWN() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GCCFG.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GCCFG_BCDEN(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GCCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GCCFG.Reg)&^(0x20000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GCCFG_BCDEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GCCFG.Reg) & 0x20000) >> 17
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GCCFG_DCDEN(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GCCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GCCFG.Reg)&^(0x40000)|value<<18)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GCCFG_DCDEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GCCFG.Reg) & 0x40000) >> 18
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GCCFG_PDEN(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GCCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GCCFG.Reg)&^(0x80000)|value<<19)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GCCFG_PDEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GCCFG.Reg) & 0x80000) >> 19
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GCCFG_SDEN(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GCCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GCCFG.Reg)&^(0x100000)|value<<20)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GCCFG_SDEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GCCFG.Reg) & 0x100000) >> 20
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GCCFG_VBDEN(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GCCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GCCFG.Reg)&^(0x200000)|value<<21)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GCCFG_VBDEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GCCFG.Reg) & 0x200000) >> 21
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GCCFG_DCDET(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GCCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GCCFG.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GCCFG_DCDET() uint32 {
	return volatile.LoadUint32(&o.OTG_HS_GCCFG.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GCCFG_PDET(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GCCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GCCFG.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GCCFG_PDET() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GCCFG.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GCCFG_SDET(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GCCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GCCFG.Reg)&^(0x4)|value<<2)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GCCFG_SDET() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GCCFG.Reg) & 0x4) >> 2
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GCCFG_PS2DET(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GCCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GCCFG.Reg)&^(0x8)|value<<3)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GCCFG_PS2DET() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GCCFG.Reg) & 0x8) >> 3
}

// USB_OTG_HS.OTG_HS_CID: OTG_HS core ID register
func (o *USB_OTG_HS_Type) SetOTG_HS_CID(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_CID.Reg, value)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_CID() uint32 {
	return volatile.LoadUint32(&o.OTG_HS_CID.Reg)
}

// USB_OTG_HS.OTG_HS_GLPMCFG: OTG core LPM configuration register
func (o *USB_OTG_HS_Type) SetOTG_HS_GLPMCFG_LPMEN(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg)&^(0x1)|value)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GLPMCFG_LPMEN() uint32 {
	return volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg) & 0x1
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GLPMCFG_LPMACK(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg)&^(0x2)|value<<1)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GLPMCFG_LPMACK() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg) & 0x2) >> 1
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GLPMCFG_BESL(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg)&^(0x3c)|value<<2)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GLPMCFG_BESL() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg) & 0x3c) >> 2
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GLPMCFG_REMWAKE(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg)&^(0x40)|value<<6)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GLPMCFG_REMWAKE() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg) & 0x40) >> 6
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GLPMCFG_L1SSEN(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg)&^(0x80)|value<<7)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GLPMCFG_L1SSEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg) & 0x80) >> 7
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GLPMCFG_BESLTHRS(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg)&^(0xf00)|value<<8)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GLPMCFG_BESLTHRS() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg) & 0xf00) >> 8
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GLPMCFG_L1DSEN(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg)&^(0x1000)|value<<12)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GLPMCFG_L1DSEN() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg) & 0x1000) >> 12
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GLPMCFG_LPMRST(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg)&^(0x6000)|value<<13)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GLPMCFG_LPMRST() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg) & 0x6000) >> 13
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GLPMCFG_SLPSTS(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg)&^(0x8000)|value<<15)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GLPMCFG_SLPSTS() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg) & 0x8000) >> 15
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GLPMCFG_L1RSMOK(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg)&^(0x10000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GLPMCFG_L1RSMOK() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg) & 0x10000) >> 16
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GLPMCFG_LPMCHIDX(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg)&^(0x1e0000)|value<<17)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GLPMCFG_LPMCHIDX() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg) & 0x1e0000) >> 17
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GLPMCFG_LPMRCNT(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg)&^(0xe00000)|value<<21)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GLPMCFG_LPMRCNT() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg) & 0xe00000) >> 21
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GLPMCFG_SNDLPM(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GLPMCFG_SNDLPM() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg) & 0x1000000) >> 24
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GLPMCFG_LPMRCNTSTS(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg)&^(0xe000000)|value<<25)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GLPMCFG_LPMRCNTSTS() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg) & 0xe000000) >> 25
}
func (o *USB_OTG_HS_Type) SetOTG_HS_GLPMCFG_ENBESL(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_GLPMCFG.Reg, volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_GLPMCFG_ENBESL() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_GLPMCFG.Reg) & 0x10000000) >> 28
}

// USB_OTG_HS.OTG_HS_HPTXFSIZ: OTG_HS Host periodic transmit FIFO size register
func (o *USB_OTG_HS_Type) SetOTG_HS_HPTXFSIZ_PTXSA(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_HPTXFSIZ.Reg, volatile.LoadUint32(&o.OTG_HS_HPTXFSIZ.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_HPTXFSIZ_PTXSA() uint32 {
	return volatile.LoadUint32(&o.OTG_HS_HPTXFSIZ.Reg) & 0xffff
}
func (o *USB_OTG_HS_Type) SetOTG_HS_HPTXFSIZ_PTXFD(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_HPTXFSIZ.Reg, volatile.LoadUint32(&o.OTG_HS_HPTXFSIZ.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_HPTXFSIZ_PTXFD() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_HPTXFSIZ.Reg) & 0xffff0000) >> 16
}

// USB_OTG_HS.OTG_HS_DIEPTXF1: OTG_HS device IN endpoint transmit FIFO size register
func (o *USB_OTG_HS_Type) SetOTG_HS_DIEPTXF1_INEPTXSA(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_DIEPTXF1.Reg, volatile.LoadUint32(&o.OTG_HS_DIEPTXF1.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_DIEPTXF1_INEPTXSA() uint32 {
	return volatile.LoadUint32(&o.OTG_HS_DIEPTXF1.Reg) & 0xffff
}
func (o *USB_OTG_HS_Type) SetOTG_HS_DIEPTXF1_INEPTXFD(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_DIEPTXF1.Reg, volatile.LoadUint32(&o.OTG_HS_DIEPTXF1.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_DIEPTXF1_INEPTXFD() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_DIEPTXF1.Reg) & 0xffff0000) >> 16
}

// USB_OTG_HS.OTG_HS_DIEPTXF2: OTG_HS device IN endpoint transmit FIFO size register
func (o *USB_OTG_HS_Type) SetOTG_HS_DIEPTXF2_INEPTXSA(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_DIEPTXF2.Reg, volatile.LoadUint32(&o.OTG_HS_DIEPTXF2.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_DIEPTXF2_INEPTXSA() uint32 {
	return volatile.LoadUint32(&o.OTG_HS_DIEPTXF2.Reg) & 0xffff
}
func (o *USB_OTG_HS_Type) SetOTG_HS_DIEPTXF2_INEPTXFD(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_DIEPTXF2.Reg, volatile.LoadUint32(&o.OTG_HS_DIEPTXF2.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_DIEPTXF2_INEPTXFD() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_DIEPTXF2.Reg) & 0xffff0000) >> 16
}

// USB_OTG_HS.OTG_HS_DIEPTXF3: OTG_HS device IN endpoint transmit FIFO size register
func (o *USB_OTG_HS_Type) SetOTG_HS_DIEPTXF3_INEPTXSA(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_DIEPTXF3.Reg, volatile.LoadUint32(&o.OTG_HS_DIEPTXF3.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_DIEPTXF3_INEPTXSA() uint32 {
	return volatile.LoadUint32(&o.OTG_HS_DIEPTXF3.Reg) & 0xffff
}
func (o *USB_OTG_HS_Type) SetOTG_HS_DIEPTXF3_INEPTXFD(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_DIEPTXF3.Reg, volatile.LoadUint32(&o.OTG_HS_DIEPTXF3.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_DIEPTXF3_INEPTXFD() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_DIEPTXF3.Reg) & 0xffff0000) >> 16
}

// USB_OTG_HS.OTG_HS_DIEPTXF4: OTG_HS device IN endpoint transmit FIFO size register
func (o *USB_OTG_HS_Type) SetOTG_HS_DIEPTXF4_INEPTXSA(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_DIEPTXF4.Reg, volatile.LoadUint32(&o.OTG_HS_DIEPTXF4.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_DIEPTXF4_INEPTXSA() uint32 {
	return volatile.LoadUint32(&o.OTG_HS_DIEPTXF4.Reg) & 0xffff
}
func (o *USB_OTG_HS_Type) SetOTG_HS_DIEPTXF4_INEPTXFD(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_DIEPTXF4.Reg, volatile.LoadUint32(&o.OTG_HS_DIEPTXF4.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_DIEPTXF4_INEPTXFD() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_DIEPTXF4.Reg) & 0xffff0000) >> 16
}

// USB_OTG_HS.OTG_HS_DIEPTXF5: OTG_HS device IN endpoint transmit FIFO size register
func (o *USB_OTG_HS_Type) SetOTG_HS_DIEPTXF5_INEPTXSA(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_DIEPTXF5.Reg, volatile.LoadUint32(&o.OTG_HS_DIEPTXF5.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_DIEPTXF5_INEPTXSA() uint32 {
	return volatile.LoadUint32(&o.OTG_HS_DIEPTXF5.Reg) & 0xffff
}
func (o *USB_OTG_HS_Type) SetOTG_HS_DIEPTXF5_INEPTXFD(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_DIEPTXF5.Reg, volatile.LoadUint32(&o.OTG_HS_DIEPTXF5.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_DIEPTXF5_INEPTXFD() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_DIEPTXF5.Reg) & 0xffff0000) >> 16
}

// USB_OTG_HS.OTG_HS_DIEPTXF6: OTG_HS device IN endpoint transmit FIFO size register
func (o *USB_OTG_HS_Type) SetOTG_HS_DIEPTXF6_INEPTXSA(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_DIEPTXF6.Reg, volatile.LoadUint32(&o.OTG_HS_DIEPTXF6.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_DIEPTXF6_INEPTXSA() uint32 {
	return volatile.LoadUint32(&o.OTG_HS_DIEPTXF6.Reg) & 0xffff
}
func (o *USB_OTG_HS_Type) SetOTG_HS_DIEPTXF6_INEPTXFD(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_DIEPTXF6.Reg, volatile.LoadUint32(&o.OTG_HS_DIEPTXF6.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_DIEPTXF6_INEPTXFD() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_DIEPTXF6.Reg) & 0xffff0000) >> 16
}

// USB_OTG_HS.OTG_HS_DIEPTXF7: OTG_HS device IN endpoint transmit FIFO size register
func (o *USB_OTG_HS_Type) SetOTG_HS_DIEPTXF7_INEPTXSA(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_DIEPTXF7.Reg, volatile.LoadUint32(&o.OTG_HS_DIEPTXF7.Reg)&^(0xffff)|value)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_DIEPTXF7_INEPTXSA() uint32 {
	return volatile.LoadUint32(&o.OTG_HS_DIEPTXF7.Reg) & 0xffff
}
func (o *USB_OTG_HS_Type) SetOTG_HS_DIEPTXF7_INEPTXFD(value uint32) {
	volatile.StoreUint32(&o.OTG_HS_DIEPTXF7.Reg, volatile.LoadUint32(&o.OTG_HS_DIEPTXF7.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_OTG_HS_Type) GetOTG_HS_DIEPTXF7_INEPTXFD() uint32 {
	return (volatile.LoadUint32(&o.OTG_HS_DIEPTXF7.Reg) & 0xffff0000) >> 16
}

// Management data input/output slave
type MDIOS_Type struct {
	CR      volatile.Register32 // 0x0
	WRFR    volatile.Register32 // 0x4
	CWRFR   volatile.Register32 // 0x8
	RDFR    volatile.Register32 // 0xC
	CRDFR   volatile.Register32 // 0x10
	SR      volatile.Register32 // 0x14
	CLRFR   volatile.Register32 // 0x18
	DINR0   volatile.Register32 // 0x1C
	DINR1   volatile.Register32 // 0x20
	DINR2   volatile.Register32 // 0x24
	DINR3   volatile.Register32 // 0x28
	DINR4   volatile.Register32 // 0x2C
	DINR5   volatile.Register32 // 0x30
	DINR6   volatile.Register32 // 0x34
	DINR7   volatile.Register32 // 0x38
	DINR8   volatile.Register32 // 0x3C
	DINR9   volatile.Register32 // 0x40
	DINR10  volatile.Register32 // 0x44
	DINR11  volatile.Register32 // 0x48
	DINR12  volatile.Register32 // 0x4C
	DINR13  volatile.Register32 // 0x50
	DINR14  volatile.Register32 // 0x54
	DINR15  volatile.Register32 // 0x58
	DINR16  volatile.Register32 // 0x5C
	DINR17  volatile.Register32 // 0x60
	DINR18  volatile.Register32 // 0x64
	DINR19  volatile.Register32 // 0x68
	DINR20  volatile.Register32 // 0x6C
	DINR21  volatile.Register32 // 0x70
	DINR22  volatile.Register32 // 0x74
	DINR23  volatile.Register32 // 0x78
	DINR24  volatile.Register32 // 0x7C
	DINR25  volatile.Register32 // 0x80
	DINR26  volatile.Register32 // 0x84
	DINR27  volatile.Register32 // 0x88
	DINR28  volatile.Register32 // 0x8C
	DINR29  volatile.Register32 // 0x90
	DINR30  volatile.Register32 // 0x94
	DINR31  volatile.Register32 // 0x98
	DOUTR0  volatile.Register32 // 0x9C
	DOUTR1  volatile.Register32 // 0xA0
	DOUTR2  volatile.Register32 // 0xA4
	DOUTR3  volatile.Register32 // 0xA8
	DOUTR4  volatile.Register32 // 0xAC
	DOUTR5  volatile.Register32 // 0xB0
	DOUTR6  volatile.Register32 // 0xB4
	DOUTR7  volatile.Register32 // 0xB8
	DOUTR8  volatile.Register32 // 0xBC
	DOUTR9  volatile.Register32 // 0xC0
	DOUTR10 volatile.Register32 // 0xC4
	DOUTR11 volatile.Register32 // 0xC8
	DOUTR12 volatile.Register32 // 0xCC
	DOUTR13 volatile.Register32 // 0xD0
	DOUTR14 volatile.Register32 // 0xD4
	DOUTR15 volatile.Register32 // 0xD8
	DOUTR16 volatile.Register32 // 0xDC
	DOUTR17 volatile.Register32 // 0xE0
	DOUTR18 volatile.Register32 // 0xE4
	DOUTR19 volatile.Register32 // 0xE8
	DOUTR20 volatile.Register32 // 0xEC
	DOUTR21 volatile.Register32 // 0xF0
	DOUTR22 volatile.Register32 // 0xF4
	DOUTR23 volatile.Register32 // 0xF8
	DOUTR24 volatile.Register32 // 0xFC
	DOUTR25 volatile.Register32 // 0x100
	DOUTR26 volatile.Register32 // 0x104
	DOUTR27 volatile.Register32 // 0x108
	DOUTR28 volatile.Register32 // 0x10C
	DOUTR29 volatile.Register32 // 0x110
	DOUTR30 volatile.Register32 // 0x114
	DOUTR31 volatile.Register32 // 0x118
}

// MDIOS.CR: MDIOS configuration register
func (o *MDIOS_Type) SetCR_EN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *MDIOS_Type) GetCR_EN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *MDIOS_Type) SetCR_WRIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *MDIOS_Type) GetCR_WRIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *MDIOS_Type) SetCR_RDIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *MDIOS_Type) GetCR_RDIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *MDIOS_Type) SetCR_EIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *MDIOS_Type) GetCR_EIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *MDIOS_Type) SetCR_DPC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *MDIOS_Type) GetCR_DPC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *MDIOS_Type) SetCR_PORT_ADDRESS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1f00)|value<<8)
}
func (o *MDIOS_Type) GetCR_PORT_ADDRESS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1f00) >> 8
}

// MDIOS.WRFR: MDIOS write flag register
func (o *MDIOS_Type) SetWRFR(value uint32) {
	volatile.StoreUint32(&o.WRFR.Reg, value)
}
func (o *MDIOS_Type) GetWRFR() uint32 {
	return volatile.LoadUint32(&o.WRFR.Reg)
}

// MDIOS.CWRFR: MDIOS clear write flag register
func (o *MDIOS_Type) SetCWRFR(value uint32) {
	volatile.StoreUint32(&o.CWRFR.Reg, value)
}
func (o *MDIOS_Type) GetCWRFR() uint32 {
	return volatile.LoadUint32(&o.CWRFR.Reg)
}

// MDIOS.RDFR: MDIOS read flag register
func (o *MDIOS_Type) SetRDFR(value uint32) {
	volatile.StoreUint32(&o.RDFR.Reg, value)
}
func (o *MDIOS_Type) GetRDFR() uint32 {
	return volatile.LoadUint32(&o.RDFR.Reg)
}

// MDIOS.CRDFR: MDIOS clear read flag register
func (o *MDIOS_Type) SetCRDFR(value uint32) {
	volatile.StoreUint32(&o.CRDFR.Reg, value)
}
func (o *MDIOS_Type) GetCRDFR() uint32 {
	return volatile.LoadUint32(&o.CRDFR.Reg)
}

// MDIOS.SR: MDIOS status register
func (o *MDIOS_Type) SetSR_PERF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *MDIOS_Type) GetSR_PERF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *MDIOS_Type) SetSR_SERF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *MDIOS_Type) GetSR_SERF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *MDIOS_Type) SetSR_TERF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *MDIOS_Type) GetSR_TERF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}

// MDIOS.CLRFR: MDIOS clear flag register
func (o *MDIOS_Type) SetCLRFR_CPERF(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x1)|value)
}
func (o *MDIOS_Type) GetCLRFR_CPERF() uint32 {
	return volatile.LoadUint32(&o.CLRFR.Reg) & 0x1
}
func (o *MDIOS_Type) SetCLRFR_CSERF(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x2)|value<<1)
}
func (o *MDIOS_Type) GetCLRFR_CSERF() uint32 {
	return (volatile.LoadUint32(&o.CLRFR.Reg) & 0x2) >> 1
}
func (o *MDIOS_Type) SetCLRFR_CTERF(value uint32) {
	volatile.StoreUint32(&o.CLRFR.Reg, volatile.LoadUint32(&o.CLRFR.Reg)&^(0x4)|value<<2)
}
func (o *MDIOS_Type) GetCLRFR_CTERF() uint32 {
	return (volatile.LoadUint32(&o.CLRFR.Reg) & 0x4) >> 2
}

// MDIOS.DINR0: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR0_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR0.Reg, volatile.LoadUint32(&o.DINR0.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR0_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR0.Reg) & 0xffff
}

// MDIOS.DINR1: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR1_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR1.Reg, volatile.LoadUint32(&o.DINR1.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR1_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR1.Reg) & 0xffff
}

// MDIOS.DINR2: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR2_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR2.Reg, volatile.LoadUint32(&o.DINR2.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR2_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR2.Reg) & 0xffff
}

// MDIOS.DINR3: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR3_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR3.Reg, volatile.LoadUint32(&o.DINR3.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR3_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR3.Reg) & 0xffff
}

// MDIOS.DINR4: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR4_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR4.Reg, volatile.LoadUint32(&o.DINR4.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR4_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR4.Reg) & 0xffff
}

// MDIOS.DINR5: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR5_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR5.Reg, volatile.LoadUint32(&o.DINR5.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR5_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR5.Reg) & 0xffff
}

// MDIOS.DINR6: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR6_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR6.Reg, volatile.LoadUint32(&o.DINR6.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR6_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR6.Reg) & 0xffff
}

// MDIOS.DINR7: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR7_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR7.Reg, volatile.LoadUint32(&o.DINR7.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR7_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR7.Reg) & 0xffff
}

// MDIOS.DINR8: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR8_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR8.Reg, volatile.LoadUint32(&o.DINR8.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR8_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR8.Reg) & 0xffff
}

// MDIOS.DINR9: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR9_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR9.Reg, volatile.LoadUint32(&o.DINR9.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR9_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR9.Reg) & 0xffff
}

// MDIOS.DINR10: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR10_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR10.Reg, volatile.LoadUint32(&o.DINR10.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR10_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR10.Reg) & 0xffff
}

// MDIOS.DINR11: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR11_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR11.Reg, volatile.LoadUint32(&o.DINR11.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR11_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR11.Reg) & 0xffff
}

// MDIOS.DINR12: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR12_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR12.Reg, volatile.LoadUint32(&o.DINR12.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR12_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR12.Reg) & 0xffff
}

// MDIOS.DINR13: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR13_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR13.Reg, volatile.LoadUint32(&o.DINR13.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR13_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR13.Reg) & 0xffff
}

// MDIOS.DINR14: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR14_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR14.Reg, volatile.LoadUint32(&o.DINR14.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR14_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR14.Reg) & 0xffff
}

// MDIOS.DINR15: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR15_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR15.Reg, volatile.LoadUint32(&o.DINR15.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR15_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR15.Reg) & 0xffff
}

// MDIOS.DINR16: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR16_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR16.Reg, volatile.LoadUint32(&o.DINR16.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR16_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR16.Reg) & 0xffff
}

// MDIOS.DINR17: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR17_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR17.Reg, volatile.LoadUint32(&o.DINR17.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR17_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR17.Reg) & 0xffff
}

// MDIOS.DINR18: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR18_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR18.Reg, volatile.LoadUint32(&o.DINR18.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR18_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR18.Reg) & 0xffff
}

// MDIOS.DINR19: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR19_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR19.Reg, volatile.LoadUint32(&o.DINR19.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR19_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR19.Reg) & 0xffff
}

// MDIOS.DINR20: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR20_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR20.Reg, volatile.LoadUint32(&o.DINR20.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR20_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR20.Reg) & 0xffff
}

// MDIOS.DINR21: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR21_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR21.Reg, volatile.LoadUint32(&o.DINR21.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR21_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR21.Reg) & 0xffff
}

// MDIOS.DINR22: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR22_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR22.Reg, volatile.LoadUint32(&o.DINR22.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR22_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR22.Reg) & 0xffff
}

// MDIOS.DINR23: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR23_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR23.Reg, volatile.LoadUint32(&o.DINR23.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR23_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR23.Reg) & 0xffff
}

// MDIOS.DINR24: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR24_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR24.Reg, volatile.LoadUint32(&o.DINR24.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR24_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR24.Reg) & 0xffff
}

// MDIOS.DINR25: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR25_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR25.Reg, volatile.LoadUint32(&o.DINR25.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR25_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR25.Reg) & 0xffff
}

// MDIOS.DINR26: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR26_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR26.Reg, volatile.LoadUint32(&o.DINR26.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR26_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR26.Reg) & 0xffff
}

// MDIOS.DINR27: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR27_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR27.Reg, volatile.LoadUint32(&o.DINR27.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR27_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR27.Reg) & 0xffff
}

// MDIOS.DINR28: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR28_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR28.Reg, volatile.LoadUint32(&o.DINR28.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR28_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR28.Reg) & 0xffff
}

// MDIOS.DINR29: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR29_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR29.Reg, volatile.LoadUint32(&o.DINR29.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR29_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR29.Reg) & 0xffff
}

// MDIOS.DINR30: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR30_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR30.Reg, volatile.LoadUint32(&o.DINR30.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR30_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR30.Reg) & 0xffff
}

// MDIOS.DINR31: MDIOS input data register %s
func (o *MDIOS_Type) SetDINR31_DIN(value uint32) {
	volatile.StoreUint32(&o.DINR31.Reg, volatile.LoadUint32(&o.DINR31.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDINR31_DIN() uint32 {
	return volatile.LoadUint32(&o.DINR31.Reg) & 0xffff
}

// MDIOS.DOUTR0: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR0_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR0.Reg, volatile.LoadUint32(&o.DOUTR0.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR0_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR0.Reg) & 0xffff
}

// MDIOS.DOUTR1: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR1_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR1.Reg, volatile.LoadUint32(&o.DOUTR1.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR1_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR1.Reg) & 0xffff
}

// MDIOS.DOUTR2: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR2_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR2.Reg, volatile.LoadUint32(&o.DOUTR2.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR2_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR2.Reg) & 0xffff
}

// MDIOS.DOUTR3: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR3_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR3.Reg, volatile.LoadUint32(&o.DOUTR3.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR3_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR3.Reg) & 0xffff
}

// MDIOS.DOUTR4: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR4_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR4.Reg, volatile.LoadUint32(&o.DOUTR4.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR4_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR4.Reg) & 0xffff
}

// MDIOS.DOUTR5: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR5_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR5.Reg, volatile.LoadUint32(&o.DOUTR5.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR5_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR5.Reg) & 0xffff
}

// MDIOS.DOUTR6: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR6_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR6.Reg, volatile.LoadUint32(&o.DOUTR6.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR6_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR6.Reg) & 0xffff
}

// MDIOS.DOUTR7: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR7_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR7.Reg, volatile.LoadUint32(&o.DOUTR7.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR7_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR7.Reg) & 0xffff
}

// MDIOS.DOUTR8: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR8_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR8.Reg, volatile.LoadUint32(&o.DOUTR8.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR8_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR8.Reg) & 0xffff
}

// MDIOS.DOUTR9: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR9_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR9.Reg, volatile.LoadUint32(&o.DOUTR9.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR9_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR9.Reg) & 0xffff
}

// MDIOS.DOUTR10: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR10_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR10.Reg, volatile.LoadUint32(&o.DOUTR10.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR10_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR10.Reg) & 0xffff
}

// MDIOS.DOUTR11: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR11_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR11.Reg, volatile.LoadUint32(&o.DOUTR11.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR11_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR11.Reg) & 0xffff
}

// MDIOS.DOUTR12: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR12_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR12.Reg, volatile.LoadUint32(&o.DOUTR12.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR12_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR12.Reg) & 0xffff
}

// MDIOS.DOUTR13: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR13_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR13.Reg, volatile.LoadUint32(&o.DOUTR13.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR13_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR13.Reg) & 0xffff
}

// MDIOS.DOUTR14: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR14_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR14.Reg, volatile.LoadUint32(&o.DOUTR14.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR14_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR14.Reg) & 0xffff
}

// MDIOS.DOUTR15: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR15_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR15.Reg, volatile.LoadUint32(&o.DOUTR15.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR15_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR15.Reg) & 0xffff
}

// MDIOS.DOUTR16: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR16_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR16.Reg, volatile.LoadUint32(&o.DOUTR16.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR16_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR16.Reg) & 0xffff
}

// MDIOS.DOUTR17: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR17_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR17.Reg, volatile.LoadUint32(&o.DOUTR17.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR17_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR17.Reg) & 0xffff
}

// MDIOS.DOUTR18: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR18_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR18.Reg, volatile.LoadUint32(&o.DOUTR18.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR18_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR18.Reg) & 0xffff
}

// MDIOS.DOUTR19: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR19_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR19.Reg, volatile.LoadUint32(&o.DOUTR19.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR19_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR19.Reg) & 0xffff
}

// MDIOS.DOUTR20: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR20_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR20.Reg, volatile.LoadUint32(&o.DOUTR20.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR20_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR20.Reg) & 0xffff
}

// MDIOS.DOUTR21: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR21_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR21.Reg, volatile.LoadUint32(&o.DOUTR21.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR21_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR21.Reg) & 0xffff
}

// MDIOS.DOUTR22: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR22_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR22.Reg, volatile.LoadUint32(&o.DOUTR22.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR22_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR22.Reg) & 0xffff
}

// MDIOS.DOUTR23: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR23_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR23.Reg, volatile.LoadUint32(&o.DOUTR23.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR23_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR23.Reg) & 0xffff
}

// MDIOS.DOUTR24: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR24_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR24.Reg, volatile.LoadUint32(&o.DOUTR24.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR24_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR24.Reg) & 0xffff
}

// MDIOS.DOUTR25: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR25_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR25.Reg, volatile.LoadUint32(&o.DOUTR25.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR25_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR25.Reg) & 0xffff
}

// MDIOS.DOUTR26: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR26_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR26.Reg, volatile.LoadUint32(&o.DOUTR26.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR26_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR26.Reg) & 0xffff
}

// MDIOS.DOUTR27: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR27_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR27.Reg, volatile.LoadUint32(&o.DOUTR27.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR27_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR27.Reg) & 0xffff
}

// MDIOS.DOUTR28: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR28_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR28.Reg, volatile.LoadUint32(&o.DOUTR28.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR28_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR28.Reg) & 0xffff
}

// MDIOS.DOUTR29: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR29_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR29.Reg, volatile.LoadUint32(&o.DOUTR29.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR29_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR29.Reg) & 0xffff
}

// MDIOS.DOUTR30: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR30_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR30.Reg, volatile.LoadUint32(&o.DOUTR30.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR30_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR30.Reg) & 0xffff
}

// MDIOS.DOUTR31: MDIOS output data register %s
func (o *MDIOS_Type) SetDOUTR31_DOUT(value uint32) {
	volatile.StoreUint32(&o.DOUTR31.Reg, volatile.LoadUint32(&o.DOUTR31.Reg)&^(0xffff)|value)
}
func (o *MDIOS_Type) GetDOUTR31_DOUT() uint32 {
	return volatile.LoadUint32(&o.DOUTR31.Reg) & 0xffff
}

// Digital filter for sigma delta modulators
type DFSDM_Type struct {
	CHCFG0R1       volatile.Register32 // 0x0
	CHCFG1R1       volatile.Register32 // 0x4
	CHCFG2R1       volatile.Register32 // 0x8
	CHCFG3R1       volatile.Register32 // 0xC
	CHCFG4R1       volatile.Register32 // 0x10
	CHCFG5R1       volatile.Register32 // 0x14
	CHCFG6R1       volatile.Register32 // 0x18
	CHCFG7R1       volatile.Register32 // 0x1C
	CHCFG0R2       volatile.Register32 // 0x20
	CHCFG1R2       volatile.Register32 // 0x24
	CHCFG2R2       volatile.Register32 // 0x28
	CHCFG3R2       volatile.Register32 // 0x2C
	CHCFG4R2       volatile.Register32 // 0x30
	CHCFG5R2       volatile.Register32 // 0x34
	CHCFG6R2       volatile.Register32 // 0x38
	CHCFG7R2       volatile.Register32 // 0x3C
	AWSCD0R        volatile.Register32 // 0x40
	AWSCD1R        volatile.Register32 // 0x44
	AWSCD2R        volatile.Register32 // 0x48
	AWSCD3R        volatile.Register32 // 0x4C
	AWSCD4R        volatile.Register32 // 0x50
	AWSCD5R        volatile.Register32 // 0x54
	AWSCD6R        volatile.Register32 // 0x58
	AWSCD7R        volatile.Register32 // 0x5C
	CHWDAT0R       volatile.Register32 // 0x60
	CHWDAT1R       volatile.Register32 // 0x64
	CHWDAT2R       volatile.Register32 // 0x68
	CHWDAT3R       volatile.Register32 // 0x6C
	CHWDAT4R       volatile.Register32 // 0x70
	CHWDAT5R       volatile.Register32 // 0x74
	CHWDAT6R       volatile.Register32 // 0x78
	CHWDAT7R       volatile.Register32 // 0x7C
	CHDATIN0R      volatile.Register32 // 0x80
	CHDATIN1R      volatile.Register32 // 0x84
	CHDATIN2R      volatile.Register32 // 0x88
	CHDATIN3R      volatile.Register32 // 0x8C
	CHDATIN4R      volatile.Register32 // 0x90
	CHDATIN5R      volatile.Register32 // 0x94
	CHDATIN6R      volatile.Register32 // 0x98
	CHDATIN7R      volatile.Register32 // 0x9C
	DFSDM0_CR1     volatile.Register32 // 0xA0
	DFSDM1_CR1     volatile.Register32 // 0xA4
	DFSDM2_CR1     volatile.Register32 // 0xA8
	DFSDM3_CR1     volatile.Register32 // 0xAC
	DFSDM0_CR2     volatile.Register32 // 0xB0
	DFSDM1_CR2     volatile.Register32 // 0xB4
	DFSDM2_CR2     volatile.Register32 // 0xB8
	DFSDM3_CR2     volatile.Register32 // 0xBC
	DFSDM0_ISR     volatile.Register32 // 0xC0
	DFSDM1_ISR     volatile.Register32 // 0xC4
	DFSDM2_ISR     volatile.Register32 // 0xC8
	DFSDM3_ISR     volatile.Register32 // 0xCC
	DFSDM0_ICR     volatile.Register32 // 0xD0
	DFSDM1_ICR     volatile.Register32 // 0xD4
	DFSDM2_ICR     volatile.Register32 // 0xD8
	DFSDM3_ICR     volatile.Register32 // 0xDC
	DFSDM0_JCHGR   volatile.Register32 // 0xE0
	DFSDM1_JCHGR   volatile.Register32 // 0xE4
	DFSDM2_JCHGR   volatile.Register32 // 0xE8
	DFSDM3_JCHGR   volatile.Register32 // 0xEC
	DFSDM0_FCR     volatile.Register32 // 0xF0
	DFSDM1_FCR     volatile.Register32 // 0xF4
	DFSDM2_FCR     volatile.Register32 // 0xF8
	DFSDM3_FCR     volatile.Register32 // 0xFC
	DFSDM0_JDATAR  volatile.Register32 // 0x100
	DFSDM1_JDATAR  volatile.Register32 // 0x104
	DFSDM2_JDATAR  volatile.Register32 // 0x108
	DFSDM3_JDATAR  volatile.Register32 // 0x10C
	DFSDM0_RDATAR  volatile.Register32 // 0x110
	DFSDM1_RDATAR  volatile.Register32 // 0x114
	DFSDM2_RDATAR  volatile.Register32 // 0x118
	DFSDM3_RDATAR  volatile.Register32 // 0x11C
	DFSDM0_AWHTR   volatile.Register32 // 0x120
	DFSDM1_AWHTR   volatile.Register32 // 0x124
	DFSDM2_AWHTR   volatile.Register32 // 0x128
	DFSDM3_AWHTR   volatile.Register32 // 0x12C
	DFSDM0_AWLTR   volatile.Register32 // 0x130
	DFSDM1_AWLTR   volatile.Register32 // 0x134
	DFSDM2_AWLTR   volatile.Register32 // 0x138
	DFSDM3_AWLTR   volatile.Register32 // 0x13C
	DFSDM0_AWSR    volatile.Register32 // 0x140
	DFSDM1_AWSR    volatile.Register32 // 0x144
	DFSDM2_AWSR    volatile.Register32 // 0x148
	DFSDM3_AWSR    volatile.Register32 // 0x14C
	DFSDM0_AWCFR   volatile.Register32 // 0x150
	DFSDM1_AWCFR   volatile.Register32 // 0x154
	DFSDM2_AWCFR   volatile.Register32 // 0x158
	DFSDM3_AWCFR   volatile.Register32 // 0x15C
	DFSDM0_EXMAX   volatile.Register32 // 0x160
	DFSDM1_EXMAX   volatile.Register32 // 0x164
	DFSDM2_EXMAX   volatile.Register32 // 0x168
	DFSDM3_EXMAX   volatile.Register32 // 0x16C
	DFSDM0_EXMIN   volatile.Register32 // 0x170
	DFSDM1_EXMIN   volatile.Register32 // 0x174
	DFSDM2_EXMIN   volatile.Register32 // 0x178
	DFSDM3_EXMIN   volatile.Register32 // 0x17C
	DFSDM0_CNVTIMR volatile.Register32 // 0x180
	DFSDM1_CNVTIMR volatile.Register32 // 0x184
	DFSDM2_CNVTIMR volatile.Register32 // 0x188
	DFSDM3_CNVTIMR volatile.Register32 // 0x18C
}

// DFSDM.CHCFG0R1: DFSDM channel configuration 0 register 1
func (o *DFSDM_Type) SetCHCFG0R1_SITP(value uint32) {
	volatile.StoreUint32(&o.CHCFG0R1.Reg, volatile.LoadUint32(&o.CHCFG0R1.Reg)&^(0x3)|value)
}
func (o *DFSDM_Type) GetCHCFG0R1_SITP() uint32 {
	return volatile.LoadUint32(&o.CHCFG0R1.Reg) & 0x3
}
func (o *DFSDM_Type) SetCHCFG0R1_SPICKSEL(value uint32) {
	volatile.StoreUint32(&o.CHCFG0R1.Reg, volatile.LoadUint32(&o.CHCFG0R1.Reg)&^(0xc)|value<<2)
}
func (o *DFSDM_Type) GetCHCFG0R1_SPICKSEL() uint32 {
	return (volatile.LoadUint32(&o.CHCFG0R1.Reg) & 0xc) >> 2
}
func (o *DFSDM_Type) SetCHCFG0R1_SCDEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG0R1.Reg, volatile.LoadUint32(&o.CHCFG0R1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetCHCFG0R1_SCDEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG0R1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetCHCFG0R1_CKABEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG0R1.Reg, volatile.LoadUint32(&o.CHCFG0R1.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetCHCFG0R1_CKABEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG0R1.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetCHCFG0R1_CHEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG0R1.Reg, volatile.LoadUint32(&o.CHCFG0R1.Reg)&^(0x80)|value<<7)
}
func (o *DFSDM_Type) GetCHCFG0R1_CHEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG0R1.Reg) & 0x80) >> 7
}
func (o *DFSDM_Type) SetCHCFG0R1_CHINSEL(value uint32) {
	volatile.StoreUint32(&o.CHCFG0R1.Reg, volatile.LoadUint32(&o.CHCFG0R1.Reg)&^(0x100)|value<<8)
}
func (o *DFSDM_Type) GetCHCFG0R1_CHINSEL() uint32 {
	return (volatile.LoadUint32(&o.CHCFG0R1.Reg) & 0x100) >> 8
}
func (o *DFSDM_Type) SetCHCFG0R1_DATMPX(value uint32) {
	volatile.StoreUint32(&o.CHCFG0R1.Reg, volatile.LoadUint32(&o.CHCFG0R1.Reg)&^(0x3000)|value<<12)
}
func (o *DFSDM_Type) GetCHCFG0R1_DATMPX() uint32 {
	return (volatile.LoadUint32(&o.CHCFG0R1.Reg) & 0x3000) >> 12
}
func (o *DFSDM_Type) SetCHCFG0R1_DATPACK(value uint32) {
	volatile.StoreUint32(&o.CHCFG0R1.Reg, volatile.LoadUint32(&o.CHCFG0R1.Reg)&^(0xc000)|value<<14)
}
func (o *DFSDM_Type) GetCHCFG0R1_DATPACK() uint32 {
	return (volatile.LoadUint32(&o.CHCFG0R1.Reg) & 0xc000) >> 14
}
func (o *DFSDM_Type) SetCHCFG0R1_CKOUTDIV(value uint32) {
	volatile.StoreUint32(&o.CHCFG0R1.Reg, volatile.LoadUint32(&o.CHCFG0R1.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetCHCFG0R1_CKOUTDIV() uint32 {
	return (volatile.LoadUint32(&o.CHCFG0R1.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetCHCFG0R1_CKOUTSRC(value uint32) {
	volatile.StoreUint32(&o.CHCFG0R1.Reg, volatile.LoadUint32(&o.CHCFG0R1.Reg)&^(0x40000000)|value<<30)
}
func (o *DFSDM_Type) GetCHCFG0R1_CKOUTSRC() uint32 {
	return (volatile.LoadUint32(&o.CHCFG0R1.Reg) & 0x40000000) >> 30
}
func (o *DFSDM_Type) SetCHCFG0R1_DFSDMEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG0R1.Reg, volatile.LoadUint32(&o.CHCFG0R1.Reg)&^(0x80000000)|value<<31)
}
func (o *DFSDM_Type) GetCHCFG0R1_DFSDMEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG0R1.Reg) & 0x80000000) >> 31
}

// DFSDM.CHCFG1R1: DFSDM channel configuration 1 register 1
func (o *DFSDM_Type) SetCHCFG1R1_SITP(value uint32) {
	volatile.StoreUint32(&o.CHCFG1R1.Reg, volatile.LoadUint32(&o.CHCFG1R1.Reg)&^(0x3)|value)
}
func (o *DFSDM_Type) GetCHCFG1R1_SITP() uint32 {
	return volatile.LoadUint32(&o.CHCFG1R1.Reg) & 0x3
}
func (o *DFSDM_Type) SetCHCFG1R1_SPICKSEL(value uint32) {
	volatile.StoreUint32(&o.CHCFG1R1.Reg, volatile.LoadUint32(&o.CHCFG1R1.Reg)&^(0xc)|value<<2)
}
func (o *DFSDM_Type) GetCHCFG1R1_SPICKSEL() uint32 {
	return (volatile.LoadUint32(&o.CHCFG1R1.Reg) & 0xc) >> 2
}
func (o *DFSDM_Type) SetCHCFG1R1_SCDEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG1R1.Reg, volatile.LoadUint32(&o.CHCFG1R1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetCHCFG1R1_SCDEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG1R1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetCHCFG1R1_CKABEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG1R1.Reg, volatile.LoadUint32(&o.CHCFG1R1.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetCHCFG1R1_CKABEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG1R1.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetCHCFG1R1_CHEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG1R1.Reg, volatile.LoadUint32(&o.CHCFG1R1.Reg)&^(0x80)|value<<7)
}
func (o *DFSDM_Type) GetCHCFG1R1_CHEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG1R1.Reg) & 0x80) >> 7
}
func (o *DFSDM_Type) SetCHCFG1R1_CHINSEL(value uint32) {
	volatile.StoreUint32(&o.CHCFG1R1.Reg, volatile.LoadUint32(&o.CHCFG1R1.Reg)&^(0x100)|value<<8)
}
func (o *DFSDM_Type) GetCHCFG1R1_CHINSEL() uint32 {
	return (volatile.LoadUint32(&o.CHCFG1R1.Reg) & 0x100) >> 8
}
func (o *DFSDM_Type) SetCHCFG1R1_DATMPX(value uint32) {
	volatile.StoreUint32(&o.CHCFG1R1.Reg, volatile.LoadUint32(&o.CHCFG1R1.Reg)&^(0x3000)|value<<12)
}
func (o *DFSDM_Type) GetCHCFG1R1_DATMPX() uint32 {
	return (volatile.LoadUint32(&o.CHCFG1R1.Reg) & 0x3000) >> 12
}
func (o *DFSDM_Type) SetCHCFG1R1_DATPACK(value uint32) {
	volatile.StoreUint32(&o.CHCFG1R1.Reg, volatile.LoadUint32(&o.CHCFG1R1.Reg)&^(0xc000)|value<<14)
}
func (o *DFSDM_Type) GetCHCFG1R1_DATPACK() uint32 {
	return (volatile.LoadUint32(&o.CHCFG1R1.Reg) & 0xc000) >> 14
}
func (o *DFSDM_Type) SetCHCFG1R1_CKOUTDIV(value uint32) {
	volatile.StoreUint32(&o.CHCFG1R1.Reg, volatile.LoadUint32(&o.CHCFG1R1.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetCHCFG1R1_CKOUTDIV() uint32 {
	return (volatile.LoadUint32(&o.CHCFG1R1.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetCHCFG1R1_CKOUTSRC(value uint32) {
	volatile.StoreUint32(&o.CHCFG1R1.Reg, volatile.LoadUint32(&o.CHCFG1R1.Reg)&^(0x40000000)|value<<30)
}
func (o *DFSDM_Type) GetCHCFG1R1_CKOUTSRC() uint32 {
	return (volatile.LoadUint32(&o.CHCFG1R1.Reg) & 0x40000000) >> 30
}
func (o *DFSDM_Type) SetCHCFG1R1_DFSDMEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG1R1.Reg, volatile.LoadUint32(&o.CHCFG1R1.Reg)&^(0x80000000)|value<<31)
}
func (o *DFSDM_Type) GetCHCFG1R1_DFSDMEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG1R1.Reg) & 0x80000000) >> 31
}

// DFSDM.CHCFG2R1: DFSDM channel configuration 2 register 1
func (o *DFSDM_Type) SetCHCFG2R1_SITP(value uint32) {
	volatile.StoreUint32(&o.CHCFG2R1.Reg, volatile.LoadUint32(&o.CHCFG2R1.Reg)&^(0x3)|value)
}
func (o *DFSDM_Type) GetCHCFG2R1_SITP() uint32 {
	return volatile.LoadUint32(&o.CHCFG2R1.Reg) & 0x3
}
func (o *DFSDM_Type) SetCHCFG2R1_SPICKSEL(value uint32) {
	volatile.StoreUint32(&o.CHCFG2R1.Reg, volatile.LoadUint32(&o.CHCFG2R1.Reg)&^(0xc)|value<<2)
}
func (o *DFSDM_Type) GetCHCFG2R1_SPICKSEL() uint32 {
	return (volatile.LoadUint32(&o.CHCFG2R1.Reg) & 0xc) >> 2
}
func (o *DFSDM_Type) SetCHCFG2R1_SCDEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG2R1.Reg, volatile.LoadUint32(&o.CHCFG2R1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetCHCFG2R1_SCDEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG2R1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetCHCFG2R1_CKABEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG2R1.Reg, volatile.LoadUint32(&o.CHCFG2R1.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetCHCFG2R1_CKABEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG2R1.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetCHCFG2R1_CHEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG2R1.Reg, volatile.LoadUint32(&o.CHCFG2R1.Reg)&^(0x80)|value<<7)
}
func (o *DFSDM_Type) GetCHCFG2R1_CHEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG2R1.Reg) & 0x80) >> 7
}
func (o *DFSDM_Type) SetCHCFG2R1_CHINSEL(value uint32) {
	volatile.StoreUint32(&o.CHCFG2R1.Reg, volatile.LoadUint32(&o.CHCFG2R1.Reg)&^(0x100)|value<<8)
}
func (o *DFSDM_Type) GetCHCFG2R1_CHINSEL() uint32 {
	return (volatile.LoadUint32(&o.CHCFG2R1.Reg) & 0x100) >> 8
}
func (o *DFSDM_Type) SetCHCFG2R1_DATMPX(value uint32) {
	volatile.StoreUint32(&o.CHCFG2R1.Reg, volatile.LoadUint32(&o.CHCFG2R1.Reg)&^(0x3000)|value<<12)
}
func (o *DFSDM_Type) GetCHCFG2R1_DATMPX() uint32 {
	return (volatile.LoadUint32(&o.CHCFG2R1.Reg) & 0x3000) >> 12
}
func (o *DFSDM_Type) SetCHCFG2R1_DATPACK(value uint32) {
	volatile.StoreUint32(&o.CHCFG2R1.Reg, volatile.LoadUint32(&o.CHCFG2R1.Reg)&^(0xc000)|value<<14)
}
func (o *DFSDM_Type) GetCHCFG2R1_DATPACK() uint32 {
	return (volatile.LoadUint32(&o.CHCFG2R1.Reg) & 0xc000) >> 14
}
func (o *DFSDM_Type) SetCHCFG2R1_CKOUTDIV(value uint32) {
	volatile.StoreUint32(&o.CHCFG2R1.Reg, volatile.LoadUint32(&o.CHCFG2R1.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetCHCFG2R1_CKOUTDIV() uint32 {
	return (volatile.LoadUint32(&o.CHCFG2R1.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetCHCFG2R1_CKOUTSRC(value uint32) {
	volatile.StoreUint32(&o.CHCFG2R1.Reg, volatile.LoadUint32(&o.CHCFG2R1.Reg)&^(0x40000000)|value<<30)
}
func (o *DFSDM_Type) GetCHCFG2R1_CKOUTSRC() uint32 {
	return (volatile.LoadUint32(&o.CHCFG2R1.Reg) & 0x40000000) >> 30
}
func (o *DFSDM_Type) SetCHCFG2R1_DFSDMEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG2R1.Reg, volatile.LoadUint32(&o.CHCFG2R1.Reg)&^(0x80000000)|value<<31)
}
func (o *DFSDM_Type) GetCHCFG2R1_DFSDMEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG2R1.Reg) & 0x80000000) >> 31
}

// DFSDM.CHCFG3R1: DFSDM channel configuration 3 register 1
func (o *DFSDM_Type) SetCHCFG3R1_SITP(value uint32) {
	volatile.StoreUint32(&o.CHCFG3R1.Reg, volatile.LoadUint32(&o.CHCFG3R1.Reg)&^(0x3)|value)
}
func (o *DFSDM_Type) GetCHCFG3R1_SITP() uint32 {
	return volatile.LoadUint32(&o.CHCFG3R1.Reg) & 0x3
}
func (o *DFSDM_Type) SetCHCFG3R1_SPICKSEL(value uint32) {
	volatile.StoreUint32(&o.CHCFG3R1.Reg, volatile.LoadUint32(&o.CHCFG3R1.Reg)&^(0xc)|value<<2)
}
func (o *DFSDM_Type) GetCHCFG3R1_SPICKSEL() uint32 {
	return (volatile.LoadUint32(&o.CHCFG3R1.Reg) & 0xc) >> 2
}
func (o *DFSDM_Type) SetCHCFG3R1_SCDEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG3R1.Reg, volatile.LoadUint32(&o.CHCFG3R1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetCHCFG3R1_SCDEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG3R1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetCHCFG3R1_CKABEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG3R1.Reg, volatile.LoadUint32(&o.CHCFG3R1.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetCHCFG3R1_CKABEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG3R1.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetCHCFG3R1_CHEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG3R1.Reg, volatile.LoadUint32(&o.CHCFG3R1.Reg)&^(0x80)|value<<7)
}
func (o *DFSDM_Type) GetCHCFG3R1_CHEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG3R1.Reg) & 0x80) >> 7
}
func (o *DFSDM_Type) SetCHCFG3R1_CHINSEL(value uint32) {
	volatile.StoreUint32(&o.CHCFG3R1.Reg, volatile.LoadUint32(&o.CHCFG3R1.Reg)&^(0x100)|value<<8)
}
func (o *DFSDM_Type) GetCHCFG3R1_CHINSEL() uint32 {
	return (volatile.LoadUint32(&o.CHCFG3R1.Reg) & 0x100) >> 8
}
func (o *DFSDM_Type) SetCHCFG3R1_DATMPX(value uint32) {
	volatile.StoreUint32(&o.CHCFG3R1.Reg, volatile.LoadUint32(&o.CHCFG3R1.Reg)&^(0x3000)|value<<12)
}
func (o *DFSDM_Type) GetCHCFG3R1_DATMPX() uint32 {
	return (volatile.LoadUint32(&o.CHCFG3R1.Reg) & 0x3000) >> 12
}
func (o *DFSDM_Type) SetCHCFG3R1_DATPACK(value uint32) {
	volatile.StoreUint32(&o.CHCFG3R1.Reg, volatile.LoadUint32(&o.CHCFG3R1.Reg)&^(0xc000)|value<<14)
}
func (o *DFSDM_Type) GetCHCFG3R1_DATPACK() uint32 {
	return (volatile.LoadUint32(&o.CHCFG3R1.Reg) & 0xc000) >> 14
}
func (o *DFSDM_Type) SetCHCFG3R1_CKOUTDIV(value uint32) {
	volatile.StoreUint32(&o.CHCFG3R1.Reg, volatile.LoadUint32(&o.CHCFG3R1.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetCHCFG3R1_CKOUTDIV() uint32 {
	return (volatile.LoadUint32(&o.CHCFG3R1.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetCHCFG3R1_CKOUTSRC(value uint32) {
	volatile.StoreUint32(&o.CHCFG3R1.Reg, volatile.LoadUint32(&o.CHCFG3R1.Reg)&^(0x40000000)|value<<30)
}
func (o *DFSDM_Type) GetCHCFG3R1_CKOUTSRC() uint32 {
	return (volatile.LoadUint32(&o.CHCFG3R1.Reg) & 0x40000000) >> 30
}
func (o *DFSDM_Type) SetCHCFG3R1_DFSDMEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG3R1.Reg, volatile.LoadUint32(&o.CHCFG3R1.Reg)&^(0x80000000)|value<<31)
}
func (o *DFSDM_Type) GetCHCFG3R1_DFSDMEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG3R1.Reg) & 0x80000000) >> 31
}

// DFSDM.CHCFG4R1: DFSDM channel configuration 4 register 1
func (o *DFSDM_Type) SetCHCFG4R1_SITP(value uint32) {
	volatile.StoreUint32(&o.CHCFG4R1.Reg, volatile.LoadUint32(&o.CHCFG4R1.Reg)&^(0x3)|value)
}
func (o *DFSDM_Type) GetCHCFG4R1_SITP() uint32 {
	return volatile.LoadUint32(&o.CHCFG4R1.Reg) & 0x3
}
func (o *DFSDM_Type) SetCHCFG4R1_SPICKSEL(value uint32) {
	volatile.StoreUint32(&o.CHCFG4R1.Reg, volatile.LoadUint32(&o.CHCFG4R1.Reg)&^(0xc)|value<<2)
}
func (o *DFSDM_Type) GetCHCFG4R1_SPICKSEL() uint32 {
	return (volatile.LoadUint32(&o.CHCFG4R1.Reg) & 0xc) >> 2
}
func (o *DFSDM_Type) SetCHCFG4R1_SCDEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG4R1.Reg, volatile.LoadUint32(&o.CHCFG4R1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetCHCFG4R1_SCDEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG4R1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetCHCFG4R1_CKABEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG4R1.Reg, volatile.LoadUint32(&o.CHCFG4R1.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetCHCFG4R1_CKABEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG4R1.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetCHCFG4R1_CHEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG4R1.Reg, volatile.LoadUint32(&o.CHCFG4R1.Reg)&^(0x80)|value<<7)
}
func (o *DFSDM_Type) GetCHCFG4R1_CHEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG4R1.Reg) & 0x80) >> 7
}
func (o *DFSDM_Type) SetCHCFG4R1_CHINSEL(value uint32) {
	volatile.StoreUint32(&o.CHCFG4R1.Reg, volatile.LoadUint32(&o.CHCFG4R1.Reg)&^(0x100)|value<<8)
}
func (o *DFSDM_Type) GetCHCFG4R1_CHINSEL() uint32 {
	return (volatile.LoadUint32(&o.CHCFG4R1.Reg) & 0x100) >> 8
}
func (o *DFSDM_Type) SetCHCFG4R1_DATMPX(value uint32) {
	volatile.StoreUint32(&o.CHCFG4R1.Reg, volatile.LoadUint32(&o.CHCFG4R1.Reg)&^(0x3000)|value<<12)
}
func (o *DFSDM_Type) GetCHCFG4R1_DATMPX() uint32 {
	return (volatile.LoadUint32(&o.CHCFG4R1.Reg) & 0x3000) >> 12
}
func (o *DFSDM_Type) SetCHCFG4R1_DATPACK(value uint32) {
	volatile.StoreUint32(&o.CHCFG4R1.Reg, volatile.LoadUint32(&o.CHCFG4R1.Reg)&^(0xc000)|value<<14)
}
func (o *DFSDM_Type) GetCHCFG4R1_DATPACK() uint32 {
	return (volatile.LoadUint32(&o.CHCFG4R1.Reg) & 0xc000) >> 14
}
func (o *DFSDM_Type) SetCHCFG4R1_CKOUTDIV(value uint32) {
	volatile.StoreUint32(&o.CHCFG4R1.Reg, volatile.LoadUint32(&o.CHCFG4R1.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetCHCFG4R1_CKOUTDIV() uint32 {
	return (volatile.LoadUint32(&o.CHCFG4R1.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetCHCFG4R1_CKOUTSRC(value uint32) {
	volatile.StoreUint32(&o.CHCFG4R1.Reg, volatile.LoadUint32(&o.CHCFG4R1.Reg)&^(0x40000000)|value<<30)
}
func (o *DFSDM_Type) GetCHCFG4R1_CKOUTSRC() uint32 {
	return (volatile.LoadUint32(&o.CHCFG4R1.Reg) & 0x40000000) >> 30
}
func (o *DFSDM_Type) SetCHCFG4R1_DFSDMEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG4R1.Reg, volatile.LoadUint32(&o.CHCFG4R1.Reg)&^(0x80000000)|value<<31)
}
func (o *DFSDM_Type) GetCHCFG4R1_DFSDMEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG4R1.Reg) & 0x80000000) >> 31
}

// DFSDM.CHCFG5R1: DFSDM channel configuration 5 register 1
func (o *DFSDM_Type) SetCHCFG5R1_SITP(value uint32) {
	volatile.StoreUint32(&o.CHCFG5R1.Reg, volatile.LoadUint32(&o.CHCFG5R1.Reg)&^(0x3)|value)
}
func (o *DFSDM_Type) GetCHCFG5R1_SITP() uint32 {
	return volatile.LoadUint32(&o.CHCFG5R1.Reg) & 0x3
}
func (o *DFSDM_Type) SetCHCFG5R1_SPICKSEL(value uint32) {
	volatile.StoreUint32(&o.CHCFG5R1.Reg, volatile.LoadUint32(&o.CHCFG5R1.Reg)&^(0xc)|value<<2)
}
func (o *DFSDM_Type) GetCHCFG5R1_SPICKSEL() uint32 {
	return (volatile.LoadUint32(&o.CHCFG5R1.Reg) & 0xc) >> 2
}
func (o *DFSDM_Type) SetCHCFG5R1_SCDEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG5R1.Reg, volatile.LoadUint32(&o.CHCFG5R1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetCHCFG5R1_SCDEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG5R1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetCHCFG5R1_CKABEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG5R1.Reg, volatile.LoadUint32(&o.CHCFG5R1.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetCHCFG5R1_CKABEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG5R1.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetCHCFG5R1_CHEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG5R1.Reg, volatile.LoadUint32(&o.CHCFG5R1.Reg)&^(0x80)|value<<7)
}
func (o *DFSDM_Type) GetCHCFG5R1_CHEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG5R1.Reg) & 0x80) >> 7
}
func (o *DFSDM_Type) SetCHCFG5R1_CHINSEL(value uint32) {
	volatile.StoreUint32(&o.CHCFG5R1.Reg, volatile.LoadUint32(&o.CHCFG5R1.Reg)&^(0x100)|value<<8)
}
func (o *DFSDM_Type) GetCHCFG5R1_CHINSEL() uint32 {
	return (volatile.LoadUint32(&o.CHCFG5R1.Reg) & 0x100) >> 8
}
func (o *DFSDM_Type) SetCHCFG5R1_DATMPX(value uint32) {
	volatile.StoreUint32(&o.CHCFG5R1.Reg, volatile.LoadUint32(&o.CHCFG5R1.Reg)&^(0x3000)|value<<12)
}
func (o *DFSDM_Type) GetCHCFG5R1_DATMPX() uint32 {
	return (volatile.LoadUint32(&o.CHCFG5R1.Reg) & 0x3000) >> 12
}
func (o *DFSDM_Type) SetCHCFG5R1_DATPACK(value uint32) {
	volatile.StoreUint32(&o.CHCFG5R1.Reg, volatile.LoadUint32(&o.CHCFG5R1.Reg)&^(0xc000)|value<<14)
}
func (o *DFSDM_Type) GetCHCFG5R1_DATPACK() uint32 {
	return (volatile.LoadUint32(&o.CHCFG5R1.Reg) & 0xc000) >> 14
}
func (o *DFSDM_Type) SetCHCFG5R1_CKOUTDIV(value uint32) {
	volatile.StoreUint32(&o.CHCFG5R1.Reg, volatile.LoadUint32(&o.CHCFG5R1.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetCHCFG5R1_CKOUTDIV() uint32 {
	return (volatile.LoadUint32(&o.CHCFG5R1.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetCHCFG5R1_CKOUTSRC(value uint32) {
	volatile.StoreUint32(&o.CHCFG5R1.Reg, volatile.LoadUint32(&o.CHCFG5R1.Reg)&^(0x40000000)|value<<30)
}
func (o *DFSDM_Type) GetCHCFG5R1_CKOUTSRC() uint32 {
	return (volatile.LoadUint32(&o.CHCFG5R1.Reg) & 0x40000000) >> 30
}
func (o *DFSDM_Type) SetCHCFG5R1_DFSDMEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG5R1.Reg, volatile.LoadUint32(&o.CHCFG5R1.Reg)&^(0x80000000)|value<<31)
}
func (o *DFSDM_Type) GetCHCFG5R1_DFSDMEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG5R1.Reg) & 0x80000000) >> 31
}

// DFSDM.CHCFG6R1: DFSDM channel configuration 6 register 1
func (o *DFSDM_Type) SetCHCFG6R1_SITP(value uint32) {
	volatile.StoreUint32(&o.CHCFG6R1.Reg, volatile.LoadUint32(&o.CHCFG6R1.Reg)&^(0x3)|value)
}
func (o *DFSDM_Type) GetCHCFG6R1_SITP() uint32 {
	return volatile.LoadUint32(&o.CHCFG6R1.Reg) & 0x3
}
func (o *DFSDM_Type) SetCHCFG6R1_SPICKSEL(value uint32) {
	volatile.StoreUint32(&o.CHCFG6R1.Reg, volatile.LoadUint32(&o.CHCFG6R1.Reg)&^(0xc)|value<<2)
}
func (o *DFSDM_Type) GetCHCFG6R1_SPICKSEL() uint32 {
	return (volatile.LoadUint32(&o.CHCFG6R1.Reg) & 0xc) >> 2
}
func (o *DFSDM_Type) SetCHCFG6R1_SCDEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG6R1.Reg, volatile.LoadUint32(&o.CHCFG6R1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetCHCFG6R1_SCDEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG6R1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetCHCFG6R1_CKABEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG6R1.Reg, volatile.LoadUint32(&o.CHCFG6R1.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetCHCFG6R1_CKABEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG6R1.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetCHCFG6R1_CHEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG6R1.Reg, volatile.LoadUint32(&o.CHCFG6R1.Reg)&^(0x80)|value<<7)
}
func (o *DFSDM_Type) GetCHCFG6R1_CHEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG6R1.Reg) & 0x80) >> 7
}
func (o *DFSDM_Type) SetCHCFG6R1_CHINSEL(value uint32) {
	volatile.StoreUint32(&o.CHCFG6R1.Reg, volatile.LoadUint32(&o.CHCFG6R1.Reg)&^(0x100)|value<<8)
}
func (o *DFSDM_Type) GetCHCFG6R1_CHINSEL() uint32 {
	return (volatile.LoadUint32(&o.CHCFG6R1.Reg) & 0x100) >> 8
}
func (o *DFSDM_Type) SetCHCFG6R1_DATMPX(value uint32) {
	volatile.StoreUint32(&o.CHCFG6R1.Reg, volatile.LoadUint32(&o.CHCFG6R1.Reg)&^(0x3000)|value<<12)
}
func (o *DFSDM_Type) GetCHCFG6R1_DATMPX() uint32 {
	return (volatile.LoadUint32(&o.CHCFG6R1.Reg) & 0x3000) >> 12
}
func (o *DFSDM_Type) SetCHCFG6R1_DATPACK(value uint32) {
	volatile.StoreUint32(&o.CHCFG6R1.Reg, volatile.LoadUint32(&o.CHCFG6R1.Reg)&^(0xc000)|value<<14)
}
func (o *DFSDM_Type) GetCHCFG6R1_DATPACK() uint32 {
	return (volatile.LoadUint32(&o.CHCFG6R1.Reg) & 0xc000) >> 14
}
func (o *DFSDM_Type) SetCHCFG6R1_CKOUTDIV(value uint32) {
	volatile.StoreUint32(&o.CHCFG6R1.Reg, volatile.LoadUint32(&o.CHCFG6R1.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetCHCFG6R1_CKOUTDIV() uint32 {
	return (volatile.LoadUint32(&o.CHCFG6R1.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetCHCFG6R1_CKOUTSRC(value uint32) {
	volatile.StoreUint32(&o.CHCFG6R1.Reg, volatile.LoadUint32(&o.CHCFG6R1.Reg)&^(0x40000000)|value<<30)
}
func (o *DFSDM_Type) GetCHCFG6R1_CKOUTSRC() uint32 {
	return (volatile.LoadUint32(&o.CHCFG6R1.Reg) & 0x40000000) >> 30
}
func (o *DFSDM_Type) SetCHCFG6R1_DFSDMEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG6R1.Reg, volatile.LoadUint32(&o.CHCFG6R1.Reg)&^(0x80000000)|value<<31)
}
func (o *DFSDM_Type) GetCHCFG6R1_DFSDMEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG6R1.Reg) & 0x80000000) >> 31
}

// DFSDM.CHCFG7R1: DFSDM channel configuration 7 register 1
func (o *DFSDM_Type) SetCHCFG7R1_SITP(value uint32) {
	volatile.StoreUint32(&o.CHCFG7R1.Reg, volatile.LoadUint32(&o.CHCFG7R1.Reg)&^(0x3)|value)
}
func (o *DFSDM_Type) GetCHCFG7R1_SITP() uint32 {
	return volatile.LoadUint32(&o.CHCFG7R1.Reg) & 0x3
}
func (o *DFSDM_Type) SetCHCFG7R1_SPICKSEL(value uint32) {
	volatile.StoreUint32(&o.CHCFG7R1.Reg, volatile.LoadUint32(&o.CHCFG7R1.Reg)&^(0xc)|value<<2)
}
func (o *DFSDM_Type) GetCHCFG7R1_SPICKSEL() uint32 {
	return (volatile.LoadUint32(&o.CHCFG7R1.Reg) & 0xc) >> 2
}
func (o *DFSDM_Type) SetCHCFG7R1_SCDEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG7R1.Reg, volatile.LoadUint32(&o.CHCFG7R1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetCHCFG7R1_SCDEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG7R1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetCHCFG7R1_CKABEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG7R1.Reg, volatile.LoadUint32(&o.CHCFG7R1.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetCHCFG7R1_CKABEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG7R1.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetCHCFG7R1_CHEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG7R1.Reg, volatile.LoadUint32(&o.CHCFG7R1.Reg)&^(0x80)|value<<7)
}
func (o *DFSDM_Type) GetCHCFG7R1_CHEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG7R1.Reg) & 0x80) >> 7
}
func (o *DFSDM_Type) SetCHCFG7R1_CHINSEL(value uint32) {
	volatile.StoreUint32(&o.CHCFG7R1.Reg, volatile.LoadUint32(&o.CHCFG7R1.Reg)&^(0x100)|value<<8)
}
func (o *DFSDM_Type) GetCHCFG7R1_CHINSEL() uint32 {
	return (volatile.LoadUint32(&o.CHCFG7R1.Reg) & 0x100) >> 8
}
func (o *DFSDM_Type) SetCHCFG7R1_DATMPX(value uint32) {
	volatile.StoreUint32(&o.CHCFG7R1.Reg, volatile.LoadUint32(&o.CHCFG7R1.Reg)&^(0x3000)|value<<12)
}
func (o *DFSDM_Type) GetCHCFG7R1_DATMPX() uint32 {
	return (volatile.LoadUint32(&o.CHCFG7R1.Reg) & 0x3000) >> 12
}
func (o *DFSDM_Type) SetCHCFG7R1_DATPACK(value uint32) {
	volatile.StoreUint32(&o.CHCFG7R1.Reg, volatile.LoadUint32(&o.CHCFG7R1.Reg)&^(0xc000)|value<<14)
}
func (o *DFSDM_Type) GetCHCFG7R1_DATPACK() uint32 {
	return (volatile.LoadUint32(&o.CHCFG7R1.Reg) & 0xc000) >> 14
}
func (o *DFSDM_Type) SetCHCFG7R1_CKOUTDIV(value uint32) {
	volatile.StoreUint32(&o.CHCFG7R1.Reg, volatile.LoadUint32(&o.CHCFG7R1.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetCHCFG7R1_CKOUTDIV() uint32 {
	return (volatile.LoadUint32(&o.CHCFG7R1.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetCHCFG7R1_CKOUTSRC(value uint32) {
	volatile.StoreUint32(&o.CHCFG7R1.Reg, volatile.LoadUint32(&o.CHCFG7R1.Reg)&^(0x40000000)|value<<30)
}
func (o *DFSDM_Type) GetCHCFG7R1_CKOUTSRC() uint32 {
	return (volatile.LoadUint32(&o.CHCFG7R1.Reg) & 0x40000000) >> 30
}
func (o *DFSDM_Type) SetCHCFG7R1_DFSDMEN(value uint32) {
	volatile.StoreUint32(&o.CHCFG7R1.Reg, volatile.LoadUint32(&o.CHCFG7R1.Reg)&^(0x80000000)|value<<31)
}
func (o *DFSDM_Type) GetCHCFG7R1_DFSDMEN() uint32 {
	return (volatile.LoadUint32(&o.CHCFG7R1.Reg) & 0x80000000) >> 31
}

// DFSDM.CHCFG0R2: DFSDM channel configuration 0 register 2
func (o *DFSDM_Type) SetCHCFG0R2_DTRBS(value uint32) {
	volatile.StoreUint32(&o.CHCFG0R2.Reg, volatile.LoadUint32(&o.CHCFG0R2.Reg)&^(0xf8)|value<<3)
}
func (o *DFSDM_Type) GetCHCFG0R2_DTRBS() uint32 {
	return (volatile.LoadUint32(&o.CHCFG0R2.Reg) & 0xf8) >> 3
}
func (o *DFSDM_Type) SetCHCFG0R2_OFFSET(value uint32) {
	volatile.StoreUint32(&o.CHCFG0R2.Reg, volatile.LoadUint32(&o.CHCFG0R2.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetCHCFG0R2_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.CHCFG0R2.Reg) & 0xffffff00) >> 8
}

// DFSDM.CHCFG1R2: DFSDM channel configuration 1 register 2
func (o *DFSDM_Type) SetCHCFG1R2_DTRBS(value uint32) {
	volatile.StoreUint32(&o.CHCFG1R2.Reg, volatile.LoadUint32(&o.CHCFG1R2.Reg)&^(0xf8)|value<<3)
}
func (o *DFSDM_Type) GetCHCFG1R2_DTRBS() uint32 {
	return (volatile.LoadUint32(&o.CHCFG1R2.Reg) & 0xf8) >> 3
}
func (o *DFSDM_Type) SetCHCFG1R2_OFFSET(value uint32) {
	volatile.StoreUint32(&o.CHCFG1R2.Reg, volatile.LoadUint32(&o.CHCFG1R2.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetCHCFG1R2_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.CHCFG1R2.Reg) & 0xffffff00) >> 8
}

// DFSDM.CHCFG2R2: DFSDM channel configuration 2 register 2
func (o *DFSDM_Type) SetCHCFG2R2_DTRBS(value uint32) {
	volatile.StoreUint32(&o.CHCFG2R2.Reg, volatile.LoadUint32(&o.CHCFG2R2.Reg)&^(0xf8)|value<<3)
}
func (o *DFSDM_Type) GetCHCFG2R2_DTRBS() uint32 {
	return (volatile.LoadUint32(&o.CHCFG2R2.Reg) & 0xf8) >> 3
}
func (o *DFSDM_Type) SetCHCFG2R2_OFFSET(value uint32) {
	volatile.StoreUint32(&o.CHCFG2R2.Reg, volatile.LoadUint32(&o.CHCFG2R2.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetCHCFG2R2_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.CHCFG2R2.Reg) & 0xffffff00) >> 8
}

// DFSDM.CHCFG3R2: DFSDM channel configuration 3 register 2
func (o *DFSDM_Type) SetCHCFG3R2_DTRBS(value uint32) {
	volatile.StoreUint32(&o.CHCFG3R2.Reg, volatile.LoadUint32(&o.CHCFG3R2.Reg)&^(0xf8)|value<<3)
}
func (o *DFSDM_Type) GetCHCFG3R2_DTRBS() uint32 {
	return (volatile.LoadUint32(&o.CHCFG3R2.Reg) & 0xf8) >> 3
}
func (o *DFSDM_Type) SetCHCFG3R2_OFFSET(value uint32) {
	volatile.StoreUint32(&o.CHCFG3R2.Reg, volatile.LoadUint32(&o.CHCFG3R2.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetCHCFG3R2_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.CHCFG3R2.Reg) & 0xffffff00) >> 8
}

// DFSDM.CHCFG4R2: DFSDM channel configuration 4 register 2
func (o *DFSDM_Type) SetCHCFG4R2_DTRBS(value uint32) {
	volatile.StoreUint32(&o.CHCFG4R2.Reg, volatile.LoadUint32(&o.CHCFG4R2.Reg)&^(0xf8)|value<<3)
}
func (o *DFSDM_Type) GetCHCFG4R2_DTRBS() uint32 {
	return (volatile.LoadUint32(&o.CHCFG4R2.Reg) & 0xf8) >> 3
}
func (o *DFSDM_Type) SetCHCFG4R2_OFFSET(value uint32) {
	volatile.StoreUint32(&o.CHCFG4R2.Reg, volatile.LoadUint32(&o.CHCFG4R2.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetCHCFG4R2_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.CHCFG4R2.Reg) & 0xffffff00) >> 8
}

// DFSDM.CHCFG5R2: DFSDM channel configuration 5 register 2
func (o *DFSDM_Type) SetCHCFG5R2_DTRBS(value uint32) {
	volatile.StoreUint32(&o.CHCFG5R2.Reg, volatile.LoadUint32(&o.CHCFG5R2.Reg)&^(0xf8)|value<<3)
}
func (o *DFSDM_Type) GetCHCFG5R2_DTRBS() uint32 {
	return (volatile.LoadUint32(&o.CHCFG5R2.Reg) & 0xf8) >> 3
}
func (o *DFSDM_Type) SetCHCFG5R2_OFFSET(value uint32) {
	volatile.StoreUint32(&o.CHCFG5R2.Reg, volatile.LoadUint32(&o.CHCFG5R2.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetCHCFG5R2_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.CHCFG5R2.Reg) & 0xffffff00) >> 8
}

// DFSDM.CHCFG6R2: DFSDM channel configuration 6 register 2
func (o *DFSDM_Type) SetCHCFG6R2_DTRBS(value uint32) {
	volatile.StoreUint32(&o.CHCFG6R2.Reg, volatile.LoadUint32(&o.CHCFG6R2.Reg)&^(0xf8)|value<<3)
}
func (o *DFSDM_Type) GetCHCFG6R2_DTRBS() uint32 {
	return (volatile.LoadUint32(&o.CHCFG6R2.Reg) & 0xf8) >> 3
}
func (o *DFSDM_Type) SetCHCFG6R2_OFFSET(value uint32) {
	volatile.StoreUint32(&o.CHCFG6R2.Reg, volatile.LoadUint32(&o.CHCFG6R2.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetCHCFG6R2_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.CHCFG6R2.Reg) & 0xffffff00) >> 8
}

// DFSDM.CHCFG7R2: DFSDM channel configuration 7 register 2
func (o *DFSDM_Type) SetCHCFG7R2_DTRBS(value uint32) {
	volatile.StoreUint32(&o.CHCFG7R2.Reg, volatile.LoadUint32(&o.CHCFG7R2.Reg)&^(0xf8)|value<<3)
}
func (o *DFSDM_Type) GetCHCFG7R2_DTRBS() uint32 {
	return (volatile.LoadUint32(&o.CHCFG7R2.Reg) & 0xf8) >> 3
}
func (o *DFSDM_Type) SetCHCFG7R2_OFFSET(value uint32) {
	volatile.StoreUint32(&o.CHCFG7R2.Reg, volatile.LoadUint32(&o.CHCFG7R2.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetCHCFG7R2_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.CHCFG7R2.Reg) & 0xffffff00) >> 8
}

// DFSDM.AWSCD0R: DFSDM analog watchdog and short-circuit detector register
func (o *DFSDM_Type) SetAWSCD0R_SCDT(value uint32) {
	volatile.StoreUint32(&o.AWSCD0R.Reg, volatile.LoadUint32(&o.AWSCD0R.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetAWSCD0R_SCDT() uint32 {
	return volatile.LoadUint32(&o.AWSCD0R.Reg) & 0xff
}
func (o *DFSDM_Type) SetAWSCD0R_BKSCD(value uint32) {
	volatile.StoreUint32(&o.AWSCD0R.Reg, volatile.LoadUint32(&o.AWSCD0R.Reg)&^(0xf000)|value<<12)
}
func (o *DFSDM_Type) GetAWSCD0R_BKSCD() uint32 {
	return (volatile.LoadUint32(&o.AWSCD0R.Reg) & 0xf000) >> 12
}
func (o *DFSDM_Type) SetAWSCD0R_AWFOSR(value uint32) {
	volatile.StoreUint32(&o.AWSCD0R.Reg, volatile.LoadUint32(&o.AWSCD0R.Reg)&^(0x1f0000)|value<<16)
}
func (o *DFSDM_Type) GetAWSCD0R_AWFOSR() uint32 {
	return (volatile.LoadUint32(&o.AWSCD0R.Reg) & 0x1f0000) >> 16
}
func (o *DFSDM_Type) SetAWSCD0R_AWFORD(value uint32) {
	volatile.StoreUint32(&o.AWSCD0R.Reg, volatile.LoadUint32(&o.AWSCD0R.Reg)&^(0xc00000)|value<<22)
}
func (o *DFSDM_Type) GetAWSCD0R_AWFORD() uint32 {
	return (volatile.LoadUint32(&o.AWSCD0R.Reg) & 0xc00000) >> 22
}

// DFSDM.AWSCD1R: DFSDM analog watchdog and short-circuit detector register
func (o *DFSDM_Type) SetAWSCD1R_SCDT(value uint32) {
	volatile.StoreUint32(&o.AWSCD1R.Reg, volatile.LoadUint32(&o.AWSCD1R.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetAWSCD1R_SCDT() uint32 {
	return volatile.LoadUint32(&o.AWSCD1R.Reg) & 0xff
}
func (o *DFSDM_Type) SetAWSCD1R_BKSCD(value uint32) {
	volatile.StoreUint32(&o.AWSCD1R.Reg, volatile.LoadUint32(&o.AWSCD1R.Reg)&^(0xf000)|value<<12)
}
func (o *DFSDM_Type) GetAWSCD1R_BKSCD() uint32 {
	return (volatile.LoadUint32(&o.AWSCD1R.Reg) & 0xf000) >> 12
}
func (o *DFSDM_Type) SetAWSCD1R_AWFOSR(value uint32) {
	volatile.StoreUint32(&o.AWSCD1R.Reg, volatile.LoadUint32(&o.AWSCD1R.Reg)&^(0x1f0000)|value<<16)
}
func (o *DFSDM_Type) GetAWSCD1R_AWFOSR() uint32 {
	return (volatile.LoadUint32(&o.AWSCD1R.Reg) & 0x1f0000) >> 16
}
func (o *DFSDM_Type) SetAWSCD1R_AWFORD(value uint32) {
	volatile.StoreUint32(&o.AWSCD1R.Reg, volatile.LoadUint32(&o.AWSCD1R.Reg)&^(0xc00000)|value<<22)
}
func (o *DFSDM_Type) GetAWSCD1R_AWFORD() uint32 {
	return (volatile.LoadUint32(&o.AWSCD1R.Reg) & 0xc00000) >> 22
}

// DFSDM.AWSCD2R: DFSDM analog watchdog and short-circuit detector register
func (o *DFSDM_Type) SetAWSCD2R_SCDT(value uint32) {
	volatile.StoreUint32(&o.AWSCD2R.Reg, volatile.LoadUint32(&o.AWSCD2R.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetAWSCD2R_SCDT() uint32 {
	return volatile.LoadUint32(&o.AWSCD2R.Reg) & 0xff
}
func (o *DFSDM_Type) SetAWSCD2R_BKSCD(value uint32) {
	volatile.StoreUint32(&o.AWSCD2R.Reg, volatile.LoadUint32(&o.AWSCD2R.Reg)&^(0xf000)|value<<12)
}
func (o *DFSDM_Type) GetAWSCD2R_BKSCD() uint32 {
	return (volatile.LoadUint32(&o.AWSCD2R.Reg) & 0xf000) >> 12
}
func (o *DFSDM_Type) SetAWSCD2R_AWFOSR(value uint32) {
	volatile.StoreUint32(&o.AWSCD2R.Reg, volatile.LoadUint32(&o.AWSCD2R.Reg)&^(0x1f0000)|value<<16)
}
func (o *DFSDM_Type) GetAWSCD2R_AWFOSR() uint32 {
	return (volatile.LoadUint32(&o.AWSCD2R.Reg) & 0x1f0000) >> 16
}
func (o *DFSDM_Type) SetAWSCD2R_AWFORD(value uint32) {
	volatile.StoreUint32(&o.AWSCD2R.Reg, volatile.LoadUint32(&o.AWSCD2R.Reg)&^(0xc00000)|value<<22)
}
func (o *DFSDM_Type) GetAWSCD2R_AWFORD() uint32 {
	return (volatile.LoadUint32(&o.AWSCD2R.Reg) & 0xc00000) >> 22
}

// DFSDM.AWSCD3R: DFSDM analog watchdog and short-circuit detector register
func (o *DFSDM_Type) SetAWSCD3R_SCDT(value uint32) {
	volatile.StoreUint32(&o.AWSCD3R.Reg, volatile.LoadUint32(&o.AWSCD3R.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetAWSCD3R_SCDT() uint32 {
	return volatile.LoadUint32(&o.AWSCD3R.Reg) & 0xff
}
func (o *DFSDM_Type) SetAWSCD3R_BKSCD(value uint32) {
	volatile.StoreUint32(&o.AWSCD3R.Reg, volatile.LoadUint32(&o.AWSCD3R.Reg)&^(0xf000)|value<<12)
}
func (o *DFSDM_Type) GetAWSCD3R_BKSCD() uint32 {
	return (volatile.LoadUint32(&o.AWSCD3R.Reg) & 0xf000) >> 12
}
func (o *DFSDM_Type) SetAWSCD3R_AWFOSR(value uint32) {
	volatile.StoreUint32(&o.AWSCD3R.Reg, volatile.LoadUint32(&o.AWSCD3R.Reg)&^(0x1f0000)|value<<16)
}
func (o *DFSDM_Type) GetAWSCD3R_AWFOSR() uint32 {
	return (volatile.LoadUint32(&o.AWSCD3R.Reg) & 0x1f0000) >> 16
}
func (o *DFSDM_Type) SetAWSCD3R_AWFORD(value uint32) {
	volatile.StoreUint32(&o.AWSCD3R.Reg, volatile.LoadUint32(&o.AWSCD3R.Reg)&^(0xc00000)|value<<22)
}
func (o *DFSDM_Type) GetAWSCD3R_AWFORD() uint32 {
	return (volatile.LoadUint32(&o.AWSCD3R.Reg) & 0xc00000) >> 22
}

// DFSDM.AWSCD4R: DFSDM analog watchdog and short-circuit detector register
func (o *DFSDM_Type) SetAWSCD4R_SCDT(value uint32) {
	volatile.StoreUint32(&o.AWSCD4R.Reg, volatile.LoadUint32(&o.AWSCD4R.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetAWSCD4R_SCDT() uint32 {
	return volatile.LoadUint32(&o.AWSCD4R.Reg) & 0xff
}
func (o *DFSDM_Type) SetAWSCD4R_BKSCD(value uint32) {
	volatile.StoreUint32(&o.AWSCD4R.Reg, volatile.LoadUint32(&o.AWSCD4R.Reg)&^(0xf000)|value<<12)
}
func (o *DFSDM_Type) GetAWSCD4R_BKSCD() uint32 {
	return (volatile.LoadUint32(&o.AWSCD4R.Reg) & 0xf000) >> 12
}
func (o *DFSDM_Type) SetAWSCD4R_AWFOSR(value uint32) {
	volatile.StoreUint32(&o.AWSCD4R.Reg, volatile.LoadUint32(&o.AWSCD4R.Reg)&^(0x1f0000)|value<<16)
}
func (o *DFSDM_Type) GetAWSCD4R_AWFOSR() uint32 {
	return (volatile.LoadUint32(&o.AWSCD4R.Reg) & 0x1f0000) >> 16
}
func (o *DFSDM_Type) SetAWSCD4R_AWFORD(value uint32) {
	volatile.StoreUint32(&o.AWSCD4R.Reg, volatile.LoadUint32(&o.AWSCD4R.Reg)&^(0xc00000)|value<<22)
}
func (o *DFSDM_Type) GetAWSCD4R_AWFORD() uint32 {
	return (volatile.LoadUint32(&o.AWSCD4R.Reg) & 0xc00000) >> 22
}

// DFSDM.AWSCD5R: DFSDM analog watchdog and short-circuit detector register
func (o *DFSDM_Type) SetAWSCD5R_SCDT(value uint32) {
	volatile.StoreUint32(&o.AWSCD5R.Reg, volatile.LoadUint32(&o.AWSCD5R.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetAWSCD5R_SCDT() uint32 {
	return volatile.LoadUint32(&o.AWSCD5R.Reg) & 0xff
}
func (o *DFSDM_Type) SetAWSCD5R_BKSCD(value uint32) {
	volatile.StoreUint32(&o.AWSCD5R.Reg, volatile.LoadUint32(&o.AWSCD5R.Reg)&^(0xf000)|value<<12)
}
func (o *DFSDM_Type) GetAWSCD5R_BKSCD() uint32 {
	return (volatile.LoadUint32(&o.AWSCD5R.Reg) & 0xf000) >> 12
}
func (o *DFSDM_Type) SetAWSCD5R_AWFOSR(value uint32) {
	volatile.StoreUint32(&o.AWSCD5R.Reg, volatile.LoadUint32(&o.AWSCD5R.Reg)&^(0x1f0000)|value<<16)
}
func (o *DFSDM_Type) GetAWSCD5R_AWFOSR() uint32 {
	return (volatile.LoadUint32(&o.AWSCD5R.Reg) & 0x1f0000) >> 16
}
func (o *DFSDM_Type) SetAWSCD5R_AWFORD(value uint32) {
	volatile.StoreUint32(&o.AWSCD5R.Reg, volatile.LoadUint32(&o.AWSCD5R.Reg)&^(0xc00000)|value<<22)
}
func (o *DFSDM_Type) GetAWSCD5R_AWFORD() uint32 {
	return (volatile.LoadUint32(&o.AWSCD5R.Reg) & 0xc00000) >> 22
}

// DFSDM.AWSCD6R: DFSDM analog watchdog and short-circuit detector register
func (o *DFSDM_Type) SetAWSCD6R_SCDT(value uint32) {
	volatile.StoreUint32(&o.AWSCD6R.Reg, volatile.LoadUint32(&o.AWSCD6R.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetAWSCD6R_SCDT() uint32 {
	return volatile.LoadUint32(&o.AWSCD6R.Reg) & 0xff
}
func (o *DFSDM_Type) SetAWSCD6R_BKSCD(value uint32) {
	volatile.StoreUint32(&o.AWSCD6R.Reg, volatile.LoadUint32(&o.AWSCD6R.Reg)&^(0xf000)|value<<12)
}
func (o *DFSDM_Type) GetAWSCD6R_BKSCD() uint32 {
	return (volatile.LoadUint32(&o.AWSCD6R.Reg) & 0xf000) >> 12
}
func (o *DFSDM_Type) SetAWSCD6R_AWFOSR(value uint32) {
	volatile.StoreUint32(&o.AWSCD6R.Reg, volatile.LoadUint32(&o.AWSCD6R.Reg)&^(0x1f0000)|value<<16)
}
func (o *DFSDM_Type) GetAWSCD6R_AWFOSR() uint32 {
	return (volatile.LoadUint32(&o.AWSCD6R.Reg) & 0x1f0000) >> 16
}
func (o *DFSDM_Type) SetAWSCD6R_AWFORD(value uint32) {
	volatile.StoreUint32(&o.AWSCD6R.Reg, volatile.LoadUint32(&o.AWSCD6R.Reg)&^(0xc00000)|value<<22)
}
func (o *DFSDM_Type) GetAWSCD6R_AWFORD() uint32 {
	return (volatile.LoadUint32(&o.AWSCD6R.Reg) & 0xc00000) >> 22
}

// DFSDM.AWSCD7R: DFSDM analog watchdog and short-circuit detector register
func (o *DFSDM_Type) SetAWSCD7R_SCDT(value uint32) {
	volatile.StoreUint32(&o.AWSCD7R.Reg, volatile.LoadUint32(&o.AWSCD7R.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetAWSCD7R_SCDT() uint32 {
	return volatile.LoadUint32(&o.AWSCD7R.Reg) & 0xff
}
func (o *DFSDM_Type) SetAWSCD7R_BKSCD(value uint32) {
	volatile.StoreUint32(&o.AWSCD7R.Reg, volatile.LoadUint32(&o.AWSCD7R.Reg)&^(0xf000)|value<<12)
}
func (o *DFSDM_Type) GetAWSCD7R_BKSCD() uint32 {
	return (volatile.LoadUint32(&o.AWSCD7R.Reg) & 0xf000) >> 12
}
func (o *DFSDM_Type) SetAWSCD7R_AWFOSR(value uint32) {
	volatile.StoreUint32(&o.AWSCD7R.Reg, volatile.LoadUint32(&o.AWSCD7R.Reg)&^(0x1f0000)|value<<16)
}
func (o *DFSDM_Type) GetAWSCD7R_AWFOSR() uint32 {
	return (volatile.LoadUint32(&o.AWSCD7R.Reg) & 0x1f0000) >> 16
}
func (o *DFSDM_Type) SetAWSCD7R_AWFORD(value uint32) {
	volatile.StoreUint32(&o.AWSCD7R.Reg, volatile.LoadUint32(&o.AWSCD7R.Reg)&^(0xc00000)|value<<22)
}
func (o *DFSDM_Type) GetAWSCD7R_AWFORD() uint32 {
	return (volatile.LoadUint32(&o.AWSCD7R.Reg) & 0xc00000) >> 22
}

// DFSDM.CHWDAT0R: DFSDM channel watchdog filter data register
func (o *DFSDM_Type) SetCHWDAT0R_WDATA(value uint32) {
	volatile.StoreUint32(&o.CHWDAT0R.Reg, volatile.LoadUint32(&o.CHWDAT0R.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCHWDAT0R_WDATA() uint32 {
	return volatile.LoadUint32(&o.CHWDAT0R.Reg) & 0xffff
}

// DFSDM.CHWDAT1R: DFSDM channel watchdog filter data register
func (o *DFSDM_Type) SetCHWDAT1R_WDATA(value uint32) {
	volatile.StoreUint32(&o.CHWDAT1R.Reg, volatile.LoadUint32(&o.CHWDAT1R.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCHWDAT1R_WDATA() uint32 {
	return volatile.LoadUint32(&o.CHWDAT1R.Reg) & 0xffff
}

// DFSDM.CHWDAT2R: DFSDM channel watchdog filter data register
func (o *DFSDM_Type) SetCHWDAT2R_WDATA(value uint32) {
	volatile.StoreUint32(&o.CHWDAT2R.Reg, volatile.LoadUint32(&o.CHWDAT2R.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCHWDAT2R_WDATA() uint32 {
	return volatile.LoadUint32(&o.CHWDAT2R.Reg) & 0xffff
}

// DFSDM.CHWDAT3R: DFSDM channel watchdog filter data register
func (o *DFSDM_Type) SetCHWDAT3R_WDATA(value uint32) {
	volatile.StoreUint32(&o.CHWDAT3R.Reg, volatile.LoadUint32(&o.CHWDAT3R.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCHWDAT3R_WDATA() uint32 {
	return volatile.LoadUint32(&o.CHWDAT3R.Reg) & 0xffff
}

// DFSDM.CHWDAT4R: DFSDM channel watchdog filter data register
func (o *DFSDM_Type) SetCHWDAT4R_WDATA(value uint32) {
	volatile.StoreUint32(&o.CHWDAT4R.Reg, volatile.LoadUint32(&o.CHWDAT4R.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCHWDAT4R_WDATA() uint32 {
	return volatile.LoadUint32(&o.CHWDAT4R.Reg) & 0xffff
}

// DFSDM.CHWDAT5R: DFSDM channel watchdog filter data register
func (o *DFSDM_Type) SetCHWDAT5R_WDATA(value uint32) {
	volatile.StoreUint32(&o.CHWDAT5R.Reg, volatile.LoadUint32(&o.CHWDAT5R.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCHWDAT5R_WDATA() uint32 {
	return volatile.LoadUint32(&o.CHWDAT5R.Reg) & 0xffff
}

// DFSDM.CHWDAT6R: DFSDM channel watchdog filter data register
func (o *DFSDM_Type) SetCHWDAT6R_WDATA(value uint32) {
	volatile.StoreUint32(&o.CHWDAT6R.Reg, volatile.LoadUint32(&o.CHWDAT6R.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCHWDAT6R_WDATA() uint32 {
	return volatile.LoadUint32(&o.CHWDAT6R.Reg) & 0xffff
}

// DFSDM.CHWDAT7R: DFSDM channel watchdog filter data register
func (o *DFSDM_Type) SetCHWDAT7R_WDATA(value uint32) {
	volatile.StoreUint32(&o.CHWDAT7R.Reg, volatile.LoadUint32(&o.CHWDAT7R.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCHWDAT7R_WDATA() uint32 {
	return volatile.LoadUint32(&o.CHWDAT7R.Reg) & 0xffff
}

// DFSDM.CHDATIN0R: DFSDM channel data input register
func (o *DFSDM_Type) SetCHDATIN0R_INDAT0(value uint32) {
	volatile.StoreUint32(&o.CHDATIN0R.Reg, volatile.LoadUint32(&o.CHDATIN0R.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCHDATIN0R_INDAT0() uint32 {
	return volatile.LoadUint32(&o.CHDATIN0R.Reg) & 0xffff
}
func (o *DFSDM_Type) SetCHDATIN0R_INDAT1(value uint32) {
	volatile.StoreUint32(&o.CHDATIN0R.Reg, volatile.LoadUint32(&o.CHDATIN0R.Reg)&^(0xffff0000)|value<<16)
}
func (o *DFSDM_Type) GetCHDATIN0R_INDAT1() uint32 {
	return (volatile.LoadUint32(&o.CHDATIN0R.Reg) & 0xffff0000) >> 16
}

// DFSDM.CHDATIN1R: DFSDM channel data input register
func (o *DFSDM_Type) SetCHDATIN1R_INDAT0(value uint32) {
	volatile.StoreUint32(&o.CHDATIN1R.Reg, volatile.LoadUint32(&o.CHDATIN1R.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCHDATIN1R_INDAT0() uint32 {
	return volatile.LoadUint32(&o.CHDATIN1R.Reg) & 0xffff
}
func (o *DFSDM_Type) SetCHDATIN1R_INDAT1(value uint32) {
	volatile.StoreUint32(&o.CHDATIN1R.Reg, volatile.LoadUint32(&o.CHDATIN1R.Reg)&^(0xffff0000)|value<<16)
}
func (o *DFSDM_Type) GetCHDATIN1R_INDAT1() uint32 {
	return (volatile.LoadUint32(&o.CHDATIN1R.Reg) & 0xffff0000) >> 16
}

// DFSDM.CHDATIN2R: DFSDM channel data input register
func (o *DFSDM_Type) SetCHDATIN2R_INDAT0(value uint32) {
	volatile.StoreUint32(&o.CHDATIN2R.Reg, volatile.LoadUint32(&o.CHDATIN2R.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCHDATIN2R_INDAT0() uint32 {
	return volatile.LoadUint32(&o.CHDATIN2R.Reg) & 0xffff
}
func (o *DFSDM_Type) SetCHDATIN2R_INDAT1(value uint32) {
	volatile.StoreUint32(&o.CHDATIN2R.Reg, volatile.LoadUint32(&o.CHDATIN2R.Reg)&^(0xffff0000)|value<<16)
}
func (o *DFSDM_Type) GetCHDATIN2R_INDAT1() uint32 {
	return (volatile.LoadUint32(&o.CHDATIN2R.Reg) & 0xffff0000) >> 16
}

// DFSDM.CHDATIN3R: DFSDM channel data input register
func (o *DFSDM_Type) SetCHDATIN3R_INDAT0(value uint32) {
	volatile.StoreUint32(&o.CHDATIN3R.Reg, volatile.LoadUint32(&o.CHDATIN3R.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCHDATIN3R_INDAT0() uint32 {
	return volatile.LoadUint32(&o.CHDATIN3R.Reg) & 0xffff
}
func (o *DFSDM_Type) SetCHDATIN3R_INDAT1(value uint32) {
	volatile.StoreUint32(&o.CHDATIN3R.Reg, volatile.LoadUint32(&o.CHDATIN3R.Reg)&^(0xffff0000)|value<<16)
}
func (o *DFSDM_Type) GetCHDATIN3R_INDAT1() uint32 {
	return (volatile.LoadUint32(&o.CHDATIN3R.Reg) & 0xffff0000) >> 16
}

// DFSDM.CHDATIN4R: DFSDM channel data input register
func (o *DFSDM_Type) SetCHDATIN4R_INDAT0(value uint32) {
	volatile.StoreUint32(&o.CHDATIN4R.Reg, volatile.LoadUint32(&o.CHDATIN4R.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCHDATIN4R_INDAT0() uint32 {
	return volatile.LoadUint32(&o.CHDATIN4R.Reg) & 0xffff
}
func (o *DFSDM_Type) SetCHDATIN4R_INDAT1(value uint32) {
	volatile.StoreUint32(&o.CHDATIN4R.Reg, volatile.LoadUint32(&o.CHDATIN4R.Reg)&^(0xffff0000)|value<<16)
}
func (o *DFSDM_Type) GetCHDATIN4R_INDAT1() uint32 {
	return (volatile.LoadUint32(&o.CHDATIN4R.Reg) & 0xffff0000) >> 16
}

// DFSDM.CHDATIN5R: DFSDM channel data input register
func (o *DFSDM_Type) SetCHDATIN5R_INDAT0(value uint32) {
	volatile.StoreUint32(&o.CHDATIN5R.Reg, volatile.LoadUint32(&o.CHDATIN5R.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCHDATIN5R_INDAT0() uint32 {
	return volatile.LoadUint32(&o.CHDATIN5R.Reg) & 0xffff
}
func (o *DFSDM_Type) SetCHDATIN5R_INDAT1(value uint32) {
	volatile.StoreUint32(&o.CHDATIN5R.Reg, volatile.LoadUint32(&o.CHDATIN5R.Reg)&^(0xffff0000)|value<<16)
}
func (o *DFSDM_Type) GetCHDATIN5R_INDAT1() uint32 {
	return (volatile.LoadUint32(&o.CHDATIN5R.Reg) & 0xffff0000) >> 16
}

// DFSDM.CHDATIN6R: DFSDM channel data input register
func (o *DFSDM_Type) SetCHDATIN6R_INDAT0(value uint32) {
	volatile.StoreUint32(&o.CHDATIN6R.Reg, volatile.LoadUint32(&o.CHDATIN6R.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCHDATIN6R_INDAT0() uint32 {
	return volatile.LoadUint32(&o.CHDATIN6R.Reg) & 0xffff
}
func (o *DFSDM_Type) SetCHDATIN6R_INDAT1(value uint32) {
	volatile.StoreUint32(&o.CHDATIN6R.Reg, volatile.LoadUint32(&o.CHDATIN6R.Reg)&^(0xffff0000)|value<<16)
}
func (o *DFSDM_Type) GetCHDATIN6R_INDAT1() uint32 {
	return (volatile.LoadUint32(&o.CHDATIN6R.Reg) & 0xffff0000) >> 16
}

// DFSDM.CHDATIN7R: DFSDM channel data input register
func (o *DFSDM_Type) SetCHDATIN7R_INDAT0(value uint32) {
	volatile.StoreUint32(&o.CHDATIN7R.Reg, volatile.LoadUint32(&o.CHDATIN7R.Reg)&^(0xffff)|value)
}
func (o *DFSDM_Type) GetCHDATIN7R_INDAT0() uint32 {
	return volatile.LoadUint32(&o.CHDATIN7R.Reg) & 0xffff
}
func (o *DFSDM_Type) SetCHDATIN7R_INDAT1(value uint32) {
	volatile.StoreUint32(&o.CHDATIN7R.Reg, volatile.LoadUint32(&o.CHDATIN7R.Reg)&^(0xffff0000)|value<<16)
}
func (o *DFSDM_Type) GetCHDATIN7R_INDAT1() uint32 {
	return (volatile.LoadUint32(&o.CHDATIN7R.Reg) & 0xffff0000) >> 16
}

// DFSDM.DFSDM0_CR1: DFSDM control register 1
func (o *DFSDM_Type) SetDFSDM0_CR1_DFEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR1.Reg, volatile.LoadUint32(&o.DFSDM0_CR1.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM0_CR1_DFEN() uint32 {
	return volatile.LoadUint32(&o.DFSDM0_CR1.Reg) & 0x1
}
func (o *DFSDM_Type) SetDFSDM0_CR1_JSWSTART(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR1.Reg, volatile.LoadUint32(&o.DFSDM0_CR1.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM0_CR1_JSWSTART() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_CR1.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM0_CR1_JSYNC(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR1.Reg, volatile.LoadUint32(&o.DFSDM0_CR1.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM0_CR1_JSYNC() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_CR1.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM0_CR1_JSCAN(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR1.Reg, volatile.LoadUint32(&o.DFSDM0_CR1.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM0_CR1_JSCAN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_CR1.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM0_CR1_JDMAEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR1.Reg, volatile.LoadUint32(&o.DFSDM0_CR1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetDFSDM0_CR1_JDMAEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_CR1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetDFSDM0_CR1_JEXTSEL(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR1.Reg, volatile.LoadUint32(&o.DFSDM0_CR1.Reg)&^(0x1f00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM0_CR1_JEXTSEL() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_CR1.Reg) & 0x1f00) >> 8
}
func (o *DFSDM_Type) SetDFSDM0_CR1_JEXTEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR1.Reg, volatile.LoadUint32(&o.DFSDM0_CR1.Reg)&^(0x6000)|value<<13)
}
func (o *DFSDM_Type) GetDFSDM0_CR1_JEXTEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_CR1.Reg) & 0x6000) >> 13
}
func (o *DFSDM_Type) SetDFSDM0_CR1_RSWSTART(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR1.Reg, volatile.LoadUint32(&o.DFSDM0_CR1.Reg)&^(0x20000)|value<<17)
}
func (o *DFSDM_Type) GetDFSDM0_CR1_RSWSTART() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_CR1.Reg) & 0x20000) >> 17
}
func (o *DFSDM_Type) SetDFSDM0_CR1_RCONT(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR1.Reg, volatile.LoadUint32(&o.DFSDM0_CR1.Reg)&^(0x40000)|value<<18)
}
func (o *DFSDM_Type) GetDFSDM0_CR1_RCONT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_CR1.Reg) & 0x40000) >> 18
}
func (o *DFSDM_Type) SetDFSDM0_CR1_RSYNC(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR1.Reg, volatile.LoadUint32(&o.DFSDM0_CR1.Reg)&^(0x80000)|value<<19)
}
func (o *DFSDM_Type) GetDFSDM0_CR1_RSYNC() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_CR1.Reg) & 0x80000) >> 19
}
func (o *DFSDM_Type) SetDFSDM0_CR1_RDMAEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR1.Reg, volatile.LoadUint32(&o.DFSDM0_CR1.Reg)&^(0x200000)|value<<21)
}
func (o *DFSDM_Type) GetDFSDM0_CR1_RDMAEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_CR1.Reg) & 0x200000) >> 21
}
func (o *DFSDM_Type) SetDFSDM0_CR1_RCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR1.Reg, volatile.LoadUint32(&o.DFSDM0_CR1.Reg)&^(0x7000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM0_CR1_RCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_CR1.Reg) & 0x7000000) >> 24
}
func (o *DFSDM_Type) SetDFSDM0_CR1_FAST(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR1.Reg, volatile.LoadUint32(&o.DFSDM0_CR1.Reg)&^(0x20000000)|value<<29)
}
func (o *DFSDM_Type) GetDFSDM0_CR1_FAST() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_CR1.Reg) & 0x20000000) >> 29
}
func (o *DFSDM_Type) SetDFSDM0_CR1_AWFSEL(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR1.Reg, volatile.LoadUint32(&o.DFSDM0_CR1.Reg)&^(0x40000000)|value<<30)
}
func (o *DFSDM_Type) GetDFSDM0_CR1_AWFSEL() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_CR1.Reg) & 0x40000000) >> 30
}

// DFSDM.DFSDM1_CR1: DFSDM control register 1
func (o *DFSDM_Type) SetDFSDM1_CR1_DFEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR1.Reg, volatile.LoadUint32(&o.DFSDM1_CR1.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM1_CR1_DFEN() uint32 {
	return volatile.LoadUint32(&o.DFSDM1_CR1.Reg) & 0x1
}
func (o *DFSDM_Type) SetDFSDM1_CR1_JSWSTART(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR1.Reg, volatile.LoadUint32(&o.DFSDM1_CR1.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM1_CR1_JSWSTART() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_CR1.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM1_CR1_JSYNC(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR1.Reg, volatile.LoadUint32(&o.DFSDM1_CR1.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM1_CR1_JSYNC() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_CR1.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM1_CR1_JSCAN(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR1.Reg, volatile.LoadUint32(&o.DFSDM1_CR1.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM1_CR1_JSCAN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_CR1.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM1_CR1_JDMAEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR1.Reg, volatile.LoadUint32(&o.DFSDM1_CR1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetDFSDM1_CR1_JDMAEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_CR1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetDFSDM1_CR1_JEXTSEL(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR1.Reg, volatile.LoadUint32(&o.DFSDM1_CR1.Reg)&^(0x1f00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM1_CR1_JEXTSEL() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_CR1.Reg) & 0x1f00) >> 8
}
func (o *DFSDM_Type) SetDFSDM1_CR1_JEXTEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR1.Reg, volatile.LoadUint32(&o.DFSDM1_CR1.Reg)&^(0x6000)|value<<13)
}
func (o *DFSDM_Type) GetDFSDM1_CR1_JEXTEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_CR1.Reg) & 0x6000) >> 13
}
func (o *DFSDM_Type) SetDFSDM1_CR1_RSWSTART(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR1.Reg, volatile.LoadUint32(&o.DFSDM1_CR1.Reg)&^(0x20000)|value<<17)
}
func (o *DFSDM_Type) GetDFSDM1_CR1_RSWSTART() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_CR1.Reg) & 0x20000) >> 17
}
func (o *DFSDM_Type) SetDFSDM1_CR1_RCONT(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR1.Reg, volatile.LoadUint32(&o.DFSDM1_CR1.Reg)&^(0x40000)|value<<18)
}
func (o *DFSDM_Type) GetDFSDM1_CR1_RCONT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_CR1.Reg) & 0x40000) >> 18
}
func (o *DFSDM_Type) SetDFSDM1_CR1_RSYNC(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR1.Reg, volatile.LoadUint32(&o.DFSDM1_CR1.Reg)&^(0x80000)|value<<19)
}
func (o *DFSDM_Type) GetDFSDM1_CR1_RSYNC() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_CR1.Reg) & 0x80000) >> 19
}
func (o *DFSDM_Type) SetDFSDM1_CR1_RDMAEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR1.Reg, volatile.LoadUint32(&o.DFSDM1_CR1.Reg)&^(0x200000)|value<<21)
}
func (o *DFSDM_Type) GetDFSDM1_CR1_RDMAEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_CR1.Reg) & 0x200000) >> 21
}
func (o *DFSDM_Type) SetDFSDM1_CR1_RCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR1.Reg, volatile.LoadUint32(&o.DFSDM1_CR1.Reg)&^(0x7000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM1_CR1_RCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_CR1.Reg) & 0x7000000) >> 24
}
func (o *DFSDM_Type) SetDFSDM1_CR1_FAST(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR1.Reg, volatile.LoadUint32(&o.DFSDM1_CR1.Reg)&^(0x20000000)|value<<29)
}
func (o *DFSDM_Type) GetDFSDM1_CR1_FAST() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_CR1.Reg) & 0x20000000) >> 29
}
func (o *DFSDM_Type) SetDFSDM1_CR1_AWFSEL(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR1.Reg, volatile.LoadUint32(&o.DFSDM1_CR1.Reg)&^(0x40000000)|value<<30)
}
func (o *DFSDM_Type) GetDFSDM1_CR1_AWFSEL() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_CR1.Reg) & 0x40000000) >> 30
}

// DFSDM.DFSDM2_CR1: DFSDM control register 1
func (o *DFSDM_Type) SetDFSDM2_CR1_DFEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR1.Reg, volatile.LoadUint32(&o.DFSDM2_CR1.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM2_CR1_DFEN() uint32 {
	return volatile.LoadUint32(&o.DFSDM2_CR1.Reg) & 0x1
}
func (o *DFSDM_Type) SetDFSDM2_CR1_JSWSTART(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR1.Reg, volatile.LoadUint32(&o.DFSDM2_CR1.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM2_CR1_JSWSTART() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_CR1.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM2_CR1_JSYNC(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR1.Reg, volatile.LoadUint32(&o.DFSDM2_CR1.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM2_CR1_JSYNC() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_CR1.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM2_CR1_JSCAN(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR1.Reg, volatile.LoadUint32(&o.DFSDM2_CR1.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM2_CR1_JSCAN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_CR1.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM2_CR1_JDMAEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR1.Reg, volatile.LoadUint32(&o.DFSDM2_CR1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetDFSDM2_CR1_JDMAEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_CR1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetDFSDM2_CR1_JEXTSEL(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR1.Reg, volatile.LoadUint32(&o.DFSDM2_CR1.Reg)&^(0x1f00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM2_CR1_JEXTSEL() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_CR1.Reg) & 0x1f00) >> 8
}
func (o *DFSDM_Type) SetDFSDM2_CR1_JEXTEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR1.Reg, volatile.LoadUint32(&o.DFSDM2_CR1.Reg)&^(0x6000)|value<<13)
}
func (o *DFSDM_Type) GetDFSDM2_CR1_JEXTEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_CR1.Reg) & 0x6000) >> 13
}
func (o *DFSDM_Type) SetDFSDM2_CR1_RSWSTART(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR1.Reg, volatile.LoadUint32(&o.DFSDM2_CR1.Reg)&^(0x20000)|value<<17)
}
func (o *DFSDM_Type) GetDFSDM2_CR1_RSWSTART() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_CR1.Reg) & 0x20000) >> 17
}
func (o *DFSDM_Type) SetDFSDM2_CR1_RCONT(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR1.Reg, volatile.LoadUint32(&o.DFSDM2_CR1.Reg)&^(0x40000)|value<<18)
}
func (o *DFSDM_Type) GetDFSDM2_CR1_RCONT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_CR1.Reg) & 0x40000) >> 18
}
func (o *DFSDM_Type) SetDFSDM2_CR1_RSYNC(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR1.Reg, volatile.LoadUint32(&o.DFSDM2_CR1.Reg)&^(0x80000)|value<<19)
}
func (o *DFSDM_Type) GetDFSDM2_CR1_RSYNC() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_CR1.Reg) & 0x80000) >> 19
}
func (o *DFSDM_Type) SetDFSDM2_CR1_RDMAEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR1.Reg, volatile.LoadUint32(&o.DFSDM2_CR1.Reg)&^(0x200000)|value<<21)
}
func (o *DFSDM_Type) GetDFSDM2_CR1_RDMAEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_CR1.Reg) & 0x200000) >> 21
}
func (o *DFSDM_Type) SetDFSDM2_CR1_RCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR1.Reg, volatile.LoadUint32(&o.DFSDM2_CR1.Reg)&^(0x7000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM2_CR1_RCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_CR1.Reg) & 0x7000000) >> 24
}
func (o *DFSDM_Type) SetDFSDM2_CR1_FAST(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR1.Reg, volatile.LoadUint32(&o.DFSDM2_CR1.Reg)&^(0x20000000)|value<<29)
}
func (o *DFSDM_Type) GetDFSDM2_CR1_FAST() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_CR1.Reg) & 0x20000000) >> 29
}
func (o *DFSDM_Type) SetDFSDM2_CR1_AWFSEL(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR1.Reg, volatile.LoadUint32(&o.DFSDM2_CR1.Reg)&^(0x40000000)|value<<30)
}
func (o *DFSDM_Type) GetDFSDM2_CR1_AWFSEL() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_CR1.Reg) & 0x40000000) >> 30
}

// DFSDM.DFSDM3_CR1: DFSDM control register 1
func (o *DFSDM_Type) SetDFSDM3_CR1_DFEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR1.Reg, volatile.LoadUint32(&o.DFSDM3_CR1.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM3_CR1_DFEN() uint32 {
	return volatile.LoadUint32(&o.DFSDM3_CR1.Reg) & 0x1
}
func (o *DFSDM_Type) SetDFSDM3_CR1_JSWSTART(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR1.Reg, volatile.LoadUint32(&o.DFSDM3_CR1.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM3_CR1_JSWSTART() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_CR1.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM3_CR1_JSYNC(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR1.Reg, volatile.LoadUint32(&o.DFSDM3_CR1.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM3_CR1_JSYNC() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_CR1.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM3_CR1_JSCAN(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR1.Reg, volatile.LoadUint32(&o.DFSDM3_CR1.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM3_CR1_JSCAN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_CR1.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM3_CR1_JDMAEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR1.Reg, volatile.LoadUint32(&o.DFSDM3_CR1.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetDFSDM3_CR1_JDMAEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_CR1.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetDFSDM3_CR1_JEXTSEL(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR1.Reg, volatile.LoadUint32(&o.DFSDM3_CR1.Reg)&^(0x1f00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM3_CR1_JEXTSEL() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_CR1.Reg) & 0x1f00) >> 8
}
func (o *DFSDM_Type) SetDFSDM3_CR1_JEXTEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR1.Reg, volatile.LoadUint32(&o.DFSDM3_CR1.Reg)&^(0x6000)|value<<13)
}
func (o *DFSDM_Type) GetDFSDM3_CR1_JEXTEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_CR1.Reg) & 0x6000) >> 13
}
func (o *DFSDM_Type) SetDFSDM3_CR1_RSWSTART(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR1.Reg, volatile.LoadUint32(&o.DFSDM3_CR1.Reg)&^(0x20000)|value<<17)
}
func (o *DFSDM_Type) GetDFSDM3_CR1_RSWSTART() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_CR1.Reg) & 0x20000) >> 17
}
func (o *DFSDM_Type) SetDFSDM3_CR1_RCONT(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR1.Reg, volatile.LoadUint32(&o.DFSDM3_CR1.Reg)&^(0x40000)|value<<18)
}
func (o *DFSDM_Type) GetDFSDM3_CR1_RCONT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_CR1.Reg) & 0x40000) >> 18
}
func (o *DFSDM_Type) SetDFSDM3_CR1_RSYNC(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR1.Reg, volatile.LoadUint32(&o.DFSDM3_CR1.Reg)&^(0x80000)|value<<19)
}
func (o *DFSDM_Type) GetDFSDM3_CR1_RSYNC() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_CR1.Reg) & 0x80000) >> 19
}
func (o *DFSDM_Type) SetDFSDM3_CR1_RDMAEN(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR1.Reg, volatile.LoadUint32(&o.DFSDM3_CR1.Reg)&^(0x200000)|value<<21)
}
func (o *DFSDM_Type) GetDFSDM3_CR1_RDMAEN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_CR1.Reg) & 0x200000) >> 21
}
func (o *DFSDM_Type) SetDFSDM3_CR1_RCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR1.Reg, volatile.LoadUint32(&o.DFSDM3_CR1.Reg)&^(0x7000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM3_CR1_RCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_CR1.Reg) & 0x7000000) >> 24
}
func (o *DFSDM_Type) SetDFSDM3_CR1_FAST(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR1.Reg, volatile.LoadUint32(&o.DFSDM3_CR1.Reg)&^(0x20000000)|value<<29)
}
func (o *DFSDM_Type) GetDFSDM3_CR1_FAST() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_CR1.Reg) & 0x20000000) >> 29
}
func (o *DFSDM_Type) SetDFSDM3_CR1_AWFSEL(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR1.Reg, volatile.LoadUint32(&o.DFSDM3_CR1.Reg)&^(0x40000000)|value<<30)
}
func (o *DFSDM_Type) GetDFSDM3_CR1_AWFSEL() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_CR1.Reg) & 0x40000000) >> 30
}

// DFSDM.DFSDM0_CR2: DFSDM control register 2
func (o *DFSDM_Type) SetDFSDM0_CR2_JEOCIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR2.Reg, volatile.LoadUint32(&o.DFSDM0_CR2.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM0_CR2_JEOCIE() uint32 {
	return volatile.LoadUint32(&o.DFSDM0_CR2.Reg) & 0x1
}
func (o *DFSDM_Type) SetDFSDM0_CR2_REOCIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR2.Reg, volatile.LoadUint32(&o.DFSDM0_CR2.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM0_CR2_REOCIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_CR2.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM0_CR2_JOVRIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR2.Reg, volatile.LoadUint32(&o.DFSDM0_CR2.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM0_CR2_JOVRIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_CR2.Reg) & 0x4) >> 2
}
func (o *DFSDM_Type) SetDFSDM0_CR2_ROVRIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR2.Reg, volatile.LoadUint32(&o.DFSDM0_CR2.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM0_CR2_ROVRIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_CR2.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM0_CR2_AWDIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR2.Reg, volatile.LoadUint32(&o.DFSDM0_CR2.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM0_CR2_AWDIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_CR2.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM0_CR2_SCDIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR2.Reg, volatile.LoadUint32(&o.DFSDM0_CR2.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetDFSDM0_CR2_SCDIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_CR2.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetDFSDM0_CR2_CKABIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR2.Reg, volatile.LoadUint32(&o.DFSDM0_CR2.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetDFSDM0_CR2_CKABIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_CR2.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetDFSDM0_CR2_EXCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR2.Reg, volatile.LoadUint32(&o.DFSDM0_CR2.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM0_CR2_EXCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_CR2.Reg) & 0xff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM0_CR2_AWDCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CR2.Reg, volatile.LoadUint32(&o.DFSDM0_CR2.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM0_CR2_AWDCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_CR2.Reg) & 0xff0000) >> 16
}

// DFSDM.DFSDM1_CR2: DFSDM control register 2
func (o *DFSDM_Type) SetDFSDM1_CR2_JEOCIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR2.Reg, volatile.LoadUint32(&o.DFSDM1_CR2.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM1_CR2_JEOCIE() uint32 {
	return volatile.LoadUint32(&o.DFSDM1_CR2.Reg) & 0x1
}
func (o *DFSDM_Type) SetDFSDM1_CR2_REOCIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR2.Reg, volatile.LoadUint32(&o.DFSDM1_CR2.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM1_CR2_REOCIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_CR2.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM1_CR2_JOVRIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR2.Reg, volatile.LoadUint32(&o.DFSDM1_CR2.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM1_CR2_JOVRIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_CR2.Reg) & 0x4) >> 2
}
func (o *DFSDM_Type) SetDFSDM1_CR2_ROVRIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR2.Reg, volatile.LoadUint32(&o.DFSDM1_CR2.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM1_CR2_ROVRIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_CR2.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM1_CR2_AWDIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR2.Reg, volatile.LoadUint32(&o.DFSDM1_CR2.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM1_CR2_AWDIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_CR2.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM1_CR2_SCDIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR2.Reg, volatile.LoadUint32(&o.DFSDM1_CR2.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetDFSDM1_CR2_SCDIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_CR2.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetDFSDM1_CR2_CKABIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR2.Reg, volatile.LoadUint32(&o.DFSDM1_CR2.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetDFSDM1_CR2_CKABIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_CR2.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetDFSDM1_CR2_EXCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR2.Reg, volatile.LoadUint32(&o.DFSDM1_CR2.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM1_CR2_EXCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_CR2.Reg) & 0xff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM1_CR2_AWDCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CR2.Reg, volatile.LoadUint32(&o.DFSDM1_CR2.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM1_CR2_AWDCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_CR2.Reg) & 0xff0000) >> 16
}

// DFSDM.DFSDM2_CR2: DFSDM control register 2
func (o *DFSDM_Type) SetDFSDM2_CR2_JEOCIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR2.Reg, volatile.LoadUint32(&o.DFSDM2_CR2.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM2_CR2_JEOCIE() uint32 {
	return volatile.LoadUint32(&o.DFSDM2_CR2.Reg) & 0x1
}
func (o *DFSDM_Type) SetDFSDM2_CR2_REOCIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR2.Reg, volatile.LoadUint32(&o.DFSDM2_CR2.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM2_CR2_REOCIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_CR2.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM2_CR2_JOVRIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR2.Reg, volatile.LoadUint32(&o.DFSDM2_CR2.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM2_CR2_JOVRIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_CR2.Reg) & 0x4) >> 2
}
func (o *DFSDM_Type) SetDFSDM2_CR2_ROVRIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR2.Reg, volatile.LoadUint32(&o.DFSDM2_CR2.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM2_CR2_ROVRIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_CR2.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM2_CR2_AWDIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR2.Reg, volatile.LoadUint32(&o.DFSDM2_CR2.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM2_CR2_AWDIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_CR2.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM2_CR2_SCDIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR2.Reg, volatile.LoadUint32(&o.DFSDM2_CR2.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetDFSDM2_CR2_SCDIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_CR2.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetDFSDM2_CR2_CKABIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR2.Reg, volatile.LoadUint32(&o.DFSDM2_CR2.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetDFSDM2_CR2_CKABIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_CR2.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetDFSDM2_CR2_EXCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR2.Reg, volatile.LoadUint32(&o.DFSDM2_CR2.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM2_CR2_EXCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_CR2.Reg) & 0xff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM2_CR2_AWDCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CR2.Reg, volatile.LoadUint32(&o.DFSDM2_CR2.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM2_CR2_AWDCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_CR2.Reg) & 0xff0000) >> 16
}

// DFSDM.DFSDM3_CR2: DFSDM control register 2
func (o *DFSDM_Type) SetDFSDM3_CR2_JEOCIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR2.Reg, volatile.LoadUint32(&o.DFSDM3_CR2.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM3_CR2_JEOCIE() uint32 {
	return volatile.LoadUint32(&o.DFSDM3_CR2.Reg) & 0x1
}
func (o *DFSDM_Type) SetDFSDM3_CR2_REOCIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR2.Reg, volatile.LoadUint32(&o.DFSDM3_CR2.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM3_CR2_REOCIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_CR2.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM3_CR2_JOVRIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR2.Reg, volatile.LoadUint32(&o.DFSDM3_CR2.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM3_CR2_JOVRIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_CR2.Reg) & 0x4) >> 2
}
func (o *DFSDM_Type) SetDFSDM3_CR2_ROVRIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR2.Reg, volatile.LoadUint32(&o.DFSDM3_CR2.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM3_CR2_ROVRIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_CR2.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM3_CR2_AWDIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR2.Reg, volatile.LoadUint32(&o.DFSDM3_CR2.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM3_CR2_AWDIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_CR2.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM3_CR2_SCDIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR2.Reg, volatile.LoadUint32(&o.DFSDM3_CR2.Reg)&^(0x20)|value<<5)
}
func (o *DFSDM_Type) GetDFSDM3_CR2_SCDIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_CR2.Reg) & 0x20) >> 5
}
func (o *DFSDM_Type) SetDFSDM3_CR2_CKABIE(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR2.Reg, volatile.LoadUint32(&o.DFSDM3_CR2.Reg)&^(0x40)|value<<6)
}
func (o *DFSDM_Type) GetDFSDM3_CR2_CKABIE() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_CR2.Reg) & 0x40) >> 6
}
func (o *DFSDM_Type) SetDFSDM3_CR2_EXCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR2.Reg, volatile.LoadUint32(&o.DFSDM3_CR2.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM3_CR2_EXCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_CR2.Reg) & 0xff00) >> 8
}
func (o *DFSDM_Type) SetDFSDM3_CR2_AWDCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CR2.Reg, volatile.LoadUint32(&o.DFSDM3_CR2.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM3_CR2_AWDCH() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_CR2.Reg) & 0xff0000) >> 16
}

// DFSDM.DFSDM0_ISR: DFSDM interrupt and status register
func (o *DFSDM_Type) SetDFSDM0_ISR_JEOCF(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_ISR.Reg, volatile.LoadUint32(&o.DFSDM0_ISR.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM0_ISR_JEOCF() uint32 {
	return volatile.LoadUint32(&o.DFSDM0_ISR.Reg) & 0x1
}
func (o *DFSDM_Type) SetDFSDM0_ISR_REOCF(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_ISR.Reg, volatile.LoadUint32(&o.DFSDM0_ISR.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM0_ISR_REOCF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_ISR.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM0_ISR_JOVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_ISR.Reg, volatile.LoadUint32(&o.DFSDM0_ISR.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM0_ISR_JOVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_ISR.Reg) & 0x4) >> 2
}
func (o *DFSDM_Type) SetDFSDM0_ISR_ROVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_ISR.Reg, volatile.LoadUint32(&o.DFSDM0_ISR.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM0_ISR_ROVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_ISR.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM0_ISR_AWDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_ISR.Reg, volatile.LoadUint32(&o.DFSDM0_ISR.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM0_ISR_AWDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_ISR.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM0_ISR_JCIP(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_ISR.Reg, volatile.LoadUint32(&o.DFSDM0_ISR.Reg)&^(0x2000)|value<<13)
}
func (o *DFSDM_Type) GetDFSDM0_ISR_JCIP() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_ISR.Reg) & 0x2000) >> 13
}
func (o *DFSDM_Type) SetDFSDM0_ISR_RCIP(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_ISR.Reg, volatile.LoadUint32(&o.DFSDM0_ISR.Reg)&^(0x4000)|value<<14)
}
func (o *DFSDM_Type) GetDFSDM0_ISR_RCIP() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_ISR.Reg) & 0x4000) >> 14
}
func (o *DFSDM_Type) SetDFSDM0_ISR_CKABF(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_ISR.Reg, volatile.LoadUint32(&o.DFSDM0_ISR.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM0_ISR_CKABF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_ISR.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM0_ISR_SCDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_ISR.Reg, volatile.LoadUint32(&o.DFSDM0_ISR.Reg)&^(0xff000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM0_ISR_SCDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_ISR.Reg) & 0xff000000) >> 24
}

// DFSDM.DFSDM1_ISR: DFSDM interrupt and status register
func (o *DFSDM_Type) SetDFSDM1_ISR_JEOCF(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_ISR.Reg, volatile.LoadUint32(&o.DFSDM1_ISR.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM1_ISR_JEOCF() uint32 {
	return volatile.LoadUint32(&o.DFSDM1_ISR.Reg) & 0x1
}
func (o *DFSDM_Type) SetDFSDM1_ISR_REOCF(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_ISR.Reg, volatile.LoadUint32(&o.DFSDM1_ISR.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM1_ISR_REOCF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_ISR.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM1_ISR_JOVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_ISR.Reg, volatile.LoadUint32(&o.DFSDM1_ISR.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM1_ISR_JOVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_ISR.Reg) & 0x4) >> 2
}
func (o *DFSDM_Type) SetDFSDM1_ISR_ROVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_ISR.Reg, volatile.LoadUint32(&o.DFSDM1_ISR.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM1_ISR_ROVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_ISR.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM1_ISR_AWDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_ISR.Reg, volatile.LoadUint32(&o.DFSDM1_ISR.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM1_ISR_AWDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_ISR.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM1_ISR_JCIP(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_ISR.Reg, volatile.LoadUint32(&o.DFSDM1_ISR.Reg)&^(0x2000)|value<<13)
}
func (o *DFSDM_Type) GetDFSDM1_ISR_JCIP() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_ISR.Reg) & 0x2000) >> 13
}
func (o *DFSDM_Type) SetDFSDM1_ISR_RCIP(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_ISR.Reg, volatile.LoadUint32(&o.DFSDM1_ISR.Reg)&^(0x4000)|value<<14)
}
func (o *DFSDM_Type) GetDFSDM1_ISR_RCIP() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_ISR.Reg) & 0x4000) >> 14
}
func (o *DFSDM_Type) SetDFSDM1_ISR_CKABF(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_ISR.Reg, volatile.LoadUint32(&o.DFSDM1_ISR.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM1_ISR_CKABF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_ISR.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM1_ISR_SCDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_ISR.Reg, volatile.LoadUint32(&o.DFSDM1_ISR.Reg)&^(0xff000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM1_ISR_SCDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_ISR.Reg) & 0xff000000) >> 24
}

// DFSDM.DFSDM2_ISR: DFSDM interrupt and status register
func (o *DFSDM_Type) SetDFSDM2_ISR_JEOCF(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_ISR.Reg, volatile.LoadUint32(&o.DFSDM2_ISR.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM2_ISR_JEOCF() uint32 {
	return volatile.LoadUint32(&o.DFSDM2_ISR.Reg) & 0x1
}
func (o *DFSDM_Type) SetDFSDM2_ISR_REOCF(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_ISR.Reg, volatile.LoadUint32(&o.DFSDM2_ISR.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM2_ISR_REOCF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_ISR.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM2_ISR_JOVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_ISR.Reg, volatile.LoadUint32(&o.DFSDM2_ISR.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM2_ISR_JOVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_ISR.Reg) & 0x4) >> 2
}
func (o *DFSDM_Type) SetDFSDM2_ISR_ROVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_ISR.Reg, volatile.LoadUint32(&o.DFSDM2_ISR.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM2_ISR_ROVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_ISR.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM2_ISR_AWDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_ISR.Reg, volatile.LoadUint32(&o.DFSDM2_ISR.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM2_ISR_AWDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_ISR.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM2_ISR_JCIP(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_ISR.Reg, volatile.LoadUint32(&o.DFSDM2_ISR.Reg)&^(0x2000)|value<<13)
}
func (o *DFSDM_Type) GetDFSDM2_ISR_JCIP() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_ISR.Reg) & 0x2000) >> 13
}
func (o *DFSDM_Type) SetDFSDM2_ISR_RCIP(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_ISR.Reg, volatile.LoadUint32(&o.DFSDM2_ISR.Reg)&^(0x4000)|value<<14)
}
func (o *DFSDM_Type) GetDFSDM2_ISR_RCIP() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_ISR.Reg) & 0x4000) >> 14
}
func (o *DFSDM_Type) SetDFSDM2_ISR_CKABF(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_ISR.Reg, volatile.LoadUint32(&o.DFSDM2_ISR.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM2_ISR_CKABF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_ISR.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM2_ISR_SCDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_ISR.Reg, volatile.LoadUint32(&o.DFSDM2_ISR.Reg)&^(0xff000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM2_ISR_SCDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_ISR.Reg) & 0xff000000) >> 24
}

// DFSDM.DFSDM3_ISR: DFSDM interrupt and status register
func (o *DFSDM_Type) SetDFSDM3_ISR_JEOCF(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_ISR.Reg, volatile.LoadUint32(&o.DFSDM3_ISR.Reg)&^(0x1)|value)
}
func (o *DFSDM_Type) GetDFSDM3_ISR_JEOCF() uint32 {
	return volatile.LoadUint32(&o.DFSDM3_ISR.Reg) & 0x1
}
func (o *DFSDM_Type) SetDFSDM3_ISR_REOCF(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_ISR.Reg, volatile.LoadUint32(&o.DFSDM3_ISR.Reg)&^(0x2)|value<<1)
}
func (o *DFSDM_Type) GetDFSDM3_ISR_REOCF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_ISR.Reg) & 0x2) >> 1
}
func (o *DFSDM_Type) SetDFSDM3_ISR_JOVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_ISR.Reg, volatile.LoadUint32(&o.DFSDM3_ISR.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM3_ISR_JOVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_ISR.Reg) & 0x4) >> 2
}
func (o *DFSDM_Type) SetDFSDM3_ISR_ROVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_ISR.Reg, volatile.LoadUint32(&o.DFSDM3_ISR.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM3_ISR_ROVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_ISR.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM3_ISR_AWDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_ISR.Reg, volatile.LoadUint32(&o.DFSDM3_ISR.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM3_ISR_AWDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_ISR.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM3_ISR_JCIP(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_ISR.Reg, volatile.LoadUint32(&o.DFSDM3_ISR.Reg)&^(0x2000)|value<<13)
}
func (o *DFSDM_Type) GetDFSDM3_ISR_JCIP() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_ISR.Reg) & 0x2000) >> 13
}
func (o *DFSDM_Type) SetDFSDM3_ISR_RCIP(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_ISR.Reg, volatile.LoadUint32(&o.DFSDM3_ISR.Reg)&^(0x4000)|value<<14)
}
func (o *DFSDM_Type) GetDFSDM3_ISR_RCIP() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_ISR.Reg) & 0x4000) >> 14
}
func (o *DFSDM_Type) SetDFSDM3_ISR_CKABF(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_ISR.Reg, volatile.LoadUint32(&o.DFSDM3_ISR.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM3_ISR_CKABF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_ISR.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM3_ISR_SCDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_ISR.Reg, volatile.LoadUint32(&o.DFSDM3_ISR.Reg)&^(0xff000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM3_ISR_SCDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_ISR.Reg) & 0xff000000) >> 24
}

// DFSDM.DFSDM0_ICR: DFSDM interrupt flag clear register
func (o *DFSDM_Type) SetDFSDM0_ICR_CLRJOVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_ICR.Reg, volatile.LoadUint32(&o.DFSDM0_ICR.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM0_ICR_CLRJOVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_ICR.Reg) & 0x4) >> 2
}
func (o *DFSDM_Type) SetDFSDM0_ICR_CLRROVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_ICR.Reg, volatile.LoadUint32(&o.DFSDM0_ICR.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM0_ICR_CLRROVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_ICR.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM0_ICR_CLRCKABF(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_ICR.Reg, volatile.LoadUint32(&o.DFSDM0_ICR.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM0_ICR_CLRCKABF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_ICR.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM0_ICR_CLRSCDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_ICR.Reg, volatile.LoadUint32(&o.DFSDM0_ICR.Reg)&^(0xff000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM0_ICR_CLRSCDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_ICR.Reg) & 0xff000000) >> 24
}

// DFSDM.DFSDM1_ICR: DFSDM interrupt flag clear register
func (o *DFSDM_Type) SetDFSDM1_ICR_CLRJOVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_ICR.Reg, volatile.LoadUint32(&o.DFSDM1_ICR.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM1_ICR_CLRJOVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_ICR.Reg) & 0x4) >> 2
}
func (o *DFSDM_Type) SetDFSDM1_ICR_CLRROVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_ICR.Reg, volatile.LoadUint32(&o.DFSDM1_ICR.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM1_ICR_CLRROVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_ICR.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM1_ICR_CLRCKABF(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_ICR.Reg, volatile.LoadUint32(&o.DFSDM1_ICR.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM1_ICR_CLRCKABF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_ICR.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM1_ICR_CLRSCDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_ICR.Reg, volatile.LoadUint32(&o.DFSDM1_ICR.Reg)&^(0xff000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM1_ICR_CLRSCDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_ICR.Reg) & 0xff000000) >> 24
}

// DFSDM.DFSDM2_ICR: DFSDM interrupt flag clear register
func (o *DFSDM_Type) SetDFSDM2_ICR_CLRJOVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_ICR.Reg, volatile.LoadUint32(&o.DFSDM2_ICR.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM2_ICR_CLRJOVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_ICR.Reg) & 0x4) >> 2
}
func (o *DFSDM_Type) SetDFSDM2_ICR_CLRROVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_ICR.Reg, volatile.LoadUint32(&o.DFSDM2_ICR.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM2_ICR_CLRROVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_ICR.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM2_ICR_CLRCKABF(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_ICR.Reg, volatile.LoadUint32(&o.DFSDM2_ICR.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM2_ICR_CLRCKABF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_ICR.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM2_ICR_CLRSCDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_ICR.Reg, volatile.LoadUint32(&o.DFSDM2_ICR.Reg)&^(0xff000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM2_ICR_CLRSCDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_ICR.Reg) & 0xff000000) >> 24
}

// DFSDM.DFSDM3_ICR: DFSDM interrupt flag clear register
func (o *DFSDM_Type) SetDFSDM3_ICR_CLRJOVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_ICR.Reg, volatile.LoadUint32(&o.DFSDM3_ICR.Reg)&^(0x4)|value<<2)
}
func (o *DFSDM_Type) GetDFSDM3_ICR_CLRJOVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_ICR.Reg) & 0x4) >> 2
}
func (o *DFSDM_Type) SetDFSDM3_ICR_CLRROVRF(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_ICR.Reg, volatile.LoadUint32(&o.DFSDM3_ICR.Reg)&^(0x8)|value<<3)
}
func (o *DFSDM_Type) GetDFSDM3_ICR_CLRROVRF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_ICR.Reg) & 0x8) >> 3
}
func (o *DFSDM_Type) SetDFSDM3_ICR_CLRCKABF(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_ICR.Reg, volatile.LoadUint32(&o.DFSDM3_ICR.Reg)&^(0xff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM3_ICR_CLRCKABF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_ICR.Reg) & 0xff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM3_ICR_CLRSCDF(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_ICR.Reg, volatile.LoadUint32(&o.DFSDM3_ICR.Reg)&^(0xff000000)|value<<24)
}
func (o *DFSDM_Type) GetDFSDM3_ICR_CLRSCDF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_ICR.Reg) & 0xff000000) >> 24
}

// DFSDM.DFSDM0_JCHGR: DFSDM injected channel group selection register
func (o *DFSDM_Type) SetDFSDM0_JCHGR_JCHG(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_JCHGR.Reg, volatile.LoadUint32(&o.DFSDM0_JCHGR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM0_JCHGR_JCHG() uint32 {
	return volatile.LoadUint32(&o.DFSDM0_JCHGR.Reg) & 0xff
}

// DFSDM.DFSDM1_JCHGR: DFSDM injected channel group selection register
func (o *DFSDM_Type) SetDFSDM1_JCHGR_JCHG(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_JCHGR.Reg, volatile.LoadUint32(&o.DFSDM1_JCHGR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM1_JCHGR_JCHG() uint32 {
	return volatile.LoadUint32(&o.DFSDM1_JCHGR.Reg) & 0xff
}

// DFSDM.DFSDM2_JCHGR: DFSDM injected channel group selection register
func (o *DFSDM_Type) SetDFSDM2_JCHGR_JCHG(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_JCHGR.Reg, volatile.LoadUint32(&o.DFSDM2_JCHGR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM2_JCHGR_JCHG() uint32 {
	return volatile.LoadUint32(&o.DFSDM2_JCHGR.Reg) & 0xff
}

// DFSDM.DFSDM3_JCHGR: DFSDM injected channel group selection register
func (o *DFSDM_Type) SetDFSDM3_JCHGR_JCHG(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_JCHGR.Reg, volatile.LoadUint32(&o.DFSDM3_JCHGR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM3_JCHGR_JCHG() uint32 {
	return volatile.LoadUint32(&o.DFSDM3_JCHGR.Reg) & 0xff
}

// DFSDM.DFSDM0_FCR: DFSDM filter control register
func (o *DFSDM_Type) SetDFSDM0_FCR_IOSR(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_FCR.Reg, volatile.LoadUint32(&o.DFSDM0_FCR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM0_FCR_IOSR() uint32 {
	return volatile.LoadUint32(&o.DFSDM0_FCR.Reg) & 0xff
}
func (o *DFSDM_Type) SetDFSDM0_FCR_FOSR(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_FCR.Reg, volatile.LoadUint32(&o.DFSDM0_FCR.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM0_FCR_FOSR() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_FCR.Reg) & 0x3ff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM0_FCR_FORD(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_FCR.Reg, volatile.LoadUint32(&o.DFSDM0_FCR.Reg)&^(0xe0000000)|value<<29)
}
func (o *DFSDM_Type) GetDFSDM0_FCR_FORD() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_FCR.Reg) & 0xe0000000) >> 29
}

// DFSDM.DFSDM1_FCR: DFSDM filter control register
func (o *DFSDM_Type) SetDFSDM1_FCR_IOSR(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_FCR.Reg, volatile.LoadUint32(&o.DFSDM1_FCR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM1_FCR_IOSR() uint32 {
	return volatile.LoadUint32(&o.DFSDM1_FCR.Reg) & 0xff
}
func (o *DFSDM_Type) SetDFSDM1_FCR_FOSR(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_FCR.Reg, volatile.LoadUint32(&o.DFSDM1_FCR.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM1_FCR_FOSR() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_FCR.Reg) & 0x3ff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM1_FCR_FORD(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_FCR.Reg, volatile.LoadUint32(&o.DFSDM1_FCR.Reg)&^(0xe0000000)|value<<29)
}
func (o *DFSDM_Type) GetDFSDM1_FCR_FORD() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_FCR.Reg) & 0xe0000000) >> 29
}

// DFSDM.DFSDM2_FCR: DFSDM filter control register
func (o *DFSDM_Type) SetDFSDM2_FCR_IOSR(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_FCR.Reg, volatile.LoadUint32(&o.DFSDM2_FCR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM2_FCR_IOSR() uint32 {
	return volatile.LoadUint32(&o.DFSDM2_FCR.Reg) & 0xff
}
func (o *DFSDM_Type) SetDFSDM2_FCR_FOSR(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_FCR.Reg, volatile.LoadUint32(&o.DFSDM2_FCR.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM2_FCR_FOSR() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_FCR.Reg) & 0x3ff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM2_FCR_FORD(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_FCR.Reg, volatile.LoadUint32(&o.DFSDM2_FCR.Reg)&^(0xe0000000)|value<<29)
}
func (o *DFSDM_Type) GetDFSDM2_FCR_FORD() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_FCR.Reg) & 0xe0000000) >> 29
}

// DFSDM.DFSDM3_FCR: DFSDM filter control register
func (o *DFSDM_Type) SetDFSDM3_FCR_IOSR(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_FCR.Reg, volatile.LoadUint32(&o.DFSDM3_FCR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM3_FCR_IOSR() uint32 {
	return volatile.LoadUint32(&o.DFSDM3_FCR.Reg) & 0xff
}
func (o *DFSDM_Type) SetDFSDM3_FCR_FOSR(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_FCR.Reg, volatile.LoadUint32(&o.DFSDM3_FCR.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DFSDM_Type) GetDFSDM3_FCR_FOSR() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_FCR.Reg) & 0x3ff0000) >> 16
}
func (o *DFSDM_Type) SetDFSDM3_FCR_FORD(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_FCR.Reg, volatile.LoadUint32(&o.DFSDM3_FCR.Reg)&^(0xe0000000)|value<<29)
}
func (o *DFSDM_Type) GetDFSDM3_FCR_FORD() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_FCR.Reg) & 0xe0000000) >> 29
}

// DFSDM.DFSDM0_JDATAR: DFSDM data register for injected group
func (o *DFSDM_Type) SetDFSDM0_JDATAR_JDATACH(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_JDATAR.Reg, volatile.LoadUint32(&o.DFSDM0_JDATAR.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM0_JDATAR_JDATACH() uint32 {
	return volatile.LoadUint32(&o.DFSDM0_JDATAR.Reg) & 0x7
}
func (o *DFSDM_Type) SetDFSDM0_JDATAR_JDATA(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_JDATAR.Reg, volatile.LoadUint32(&o.DFSDM0_JDATAR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM0_JDATAR_JDATA() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_JDATAR.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM1_JDATAR: DFSDM data register for injected group
func (o *DFSDM_Type) SetDFSDM1_JDATAR_JDATACH(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_JDATAR.Reg, volatile.LoadUint32(&o.DFSDM1_JDATAR.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM1_JDATAR_JDATACH() uint32 {
	return volatile.LoadUint32(&o.DFSDM1_JDATAR.Reg) & 0x7
}
func (o *DFSDM_Type) SetDFSDM1_JDATAR_JDATA(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_JDATAR.Reg, volatile.LoadUint32(&o.DFSDM1_JDATAR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM1_JDATAR_JDATA() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_JDATAR.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM2_JDATAR: DFSDM data register for injected group
func (o *DFSDM_Type) SetDFSDM2_JDATAR_JDATACH(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_JDATAR.Reg, volatile.LoadUint32(&o.DFSDM2_JDATAR.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM2_JDATAR_JDATACH() uint32 {
	return volatile.LoadUint32(&o.DFSDM2_JDATAR.Reg) & 0x7
}
func (o *DFSDM_Type) SetDFSDM2_JDATAR_JDATA(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_JDATAR.Reg, volatile.LoadUint32(&o.DFSDM2_JDATAR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM2_JDATAR_JDATA() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_JDATAR.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM3_JDATAR: DFSDM data register for injected group
func (o *DFSDM_Type) SetDFSDM3_JDATAR_JDATACH(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_JDATAR.Reg, volatile.LoadUint32(&o.DFSDM3_JDATAR.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM3_JDATAR_JDATACH() uint32 {
	return volatile.LoadUint32(&o.DFSDM3_JDATAR.Reg) & 0x7
}
func (o *DFSDM_Type) SetDFSDM3_JDATAR_JDATA(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_JDATAR.Reg, volatile.LoadUint32(&o.DFSDM3_JDATAR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM3_JDATAR_JDATA() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_JDATAR.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM0_RDATAR: DFSDM data register for the regular channel
func (o *DFSDM_Type) SetDFSDM0_RDATAR_RDATACH(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_RDATAR.Reg, volatile.LoadUint32(&o.DFSDM0_RDATAR.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM0_RDATAR_RDATACH() uint32 {
	return volatile.LoadUint32(&o.DFSDM0_RDATAR.Reg) & 0x7
}
func (o *DFSDM_Type) SetDFSDM0_RDATAR_RPEND(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_RDATAR.Reg, volatile.LoadUint32(&o.DFSDM0_RDATAR.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM0_RDATAR_RPEND() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_RDATAR.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM0_RDATAR_RDATA(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_RDATAR.Reg, volatile.LoadUint32(&o.DFSDM0_RDATAR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM0_RDATAR_RDATA() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_RDATAR.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM1_RDATAR: DFSDM data register for the regular channel
func (o *DFSDM_Type) SetDFSDM1_RDATAR_RDATACH(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_RDATAR.Reg, volatile.LoadUint32(&o.DFSDM1_RDATAR.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM1_RDATAR_RDATACH() uint32 {
	return volatile.LoadUint32(&o.DFSDM1_RDATAR.Reg) & 0x7
}
func (o *DFSDM_Type) SetDFSDM1_RDATAR_RPEND(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_RDATAR.Reg, volatile.LoadUint32(&o.DFSDM1_RDATAR.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM1_RDATAR_RPEND() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_RDATAR.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM1_RDATAR_RDATA(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_RDATAR.Reg, volatile.LoadUint32(&o.DFSDM1_RDATAR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM1_RDATAR_RDATA() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_RDATAR.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM2_RDATAR: DFSDM data register for the regular channel
func (o *DFSDM_Type) SetDFSDM2_RDATAR_RDATACH(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_RDATAR.Reg, volatile.LoadUint32(&o.DFSDM2_RDATAR.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM2_RDATAR_RDATACH() uint32 {
	return volatile.LoadUint32(&o.DFSDM2_RDATAR.Reg) & 0x7
}
func (o *DFSDM_Type) SetDFSDM2_RDATAR_RPEND(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_RDATAR.Reg, volatile.LoadUint32(&o.DFSDM2_RDATAR.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM2_RDATAR_RPEND() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_RDATAR.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM2_RDATAR_RDATA(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_RDATAR.Reg, volatile.LoadUint32(&o.DFSDM2_RDATAR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM2_RDATAR_RDATA() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_RDATAR.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM3_RDATAR: DFSDM data register for the regular channel
func (o *DFSDM_Type) SetDFSDM3_RDATAR_RDATACH(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_RDATAR.Reg, volatile.LoadUint32(&o.DFSDM3_RDATAR.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM3_RDATAR_RDATACH() uint32 {
	return volatile.LoadUint32(&o.DFSDM3_RDATAR.Reg) & 0x7
}
func (o *DFSDM_Type) SetDFSDM3_RDATAR_RPEND(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_RDATAR.Reg, volatile.LoadUint32(&o.DFSDM3_RDATAR.Reg)&^(0x10)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM3_RDATAR_RPEND() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_RDATAR.Reg) & 0x10) >> 4
}
func (o *DFSDM_Type) SetDFSDM3_RDATAR_RDATA(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_RDATAR.Reg, volatile.LoadUint32(&o.DFSDM3_RDATAR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM3_RDATAR_RDATA() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_RDATAR.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM0_AWHTR: DFSDM analog watchdog high threshold register
func (o *DFSDM_Type) SetDFSDM0_AWHTR_BKAWH(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_AWHTR.Reg, volatile.LoadUint32(&o.DFSDM0_AWHTR.Reg)&^(0xf)|value)
}
func (o *DFSDM_Type) GetDFSDM0_AWHTR_BKAWH() uint32 {
	return volatile.LoadUint32(&o.DFSDM0_AWHTR.Reg) & 0xf
}
func (o *DFSDM_Type) SetDFSDM0_AWHTR_AWHT(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_AWHTR.Reg, volatile.LoadUint32(&o.DFSDM0_AWHTR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM0_AWHTR_AWHT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_AWHTR.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM1_AWHTR: DFSDM analog watchdog high threshold register
func (o *DFSDM_Type) SetDFSDM1_AWHTR_BKAWH(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_AWHTR.Reg, volatile.LoadUint32(&o.DFSDM1_AWHTR.Reg)&^(0xf)|value)
}
func (o *DFSDM_Type) GetDFSDM1_AWHTR_BKAWH() uint32 {
	return volatile.LoadUint32(&o.DFSDM1_AWHTR.Reg) & 0xf
}
func (o *DFSDM_Type) SetDFSDM1_AWHTR_AWHT(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_AWHTR.Reg, volatile.LoadUint32(&o.DFSDM1_AWHTR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM1_AWHTR_AWHT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_AWHTR.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM2_AWHTR: DFSDM analog watchdog high threshold register
func (o *DFSDM_Type) SetDFSDM2_AWHTR_BKAWH(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_AWHTR.Reg, volatile.LoadUint32(&o.DFSDM2_AWHTR.Reg)&^(0xf)|value)
}
func (o *DFSDM_Type) GetDFSDM2_AWHTR_BKAWH() uint32 {
	return volatile.LoadUint32(&o.DFSDM2_AWHTR.Reg) & 0xf
}
func (o *DFSDM_Type) SetDFSDM2_AWHTR_AWHT(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_AWHTR.Reg, volatile.LoadUint32(&o.DFSDM2_AWHTR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM2_AWHTR_AWHT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_AWHTR.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM3_AWHTR: DFSDM analog watchdog high threshold register
func (o *DFSDM_Type) SetDFSDM3_AWHTR_BKAWH(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_AWHTR.Reg, volatile.LoadUint32(&o.DFSDM3_AWHTR.Reg)&^(0xf)|value)
}
func (o *DFSDM_Type) GetDFSDM3_AWHTR_BKAWH() uint32 {
	return volatile.LoadUint32(&o.DFSDM3_AWHTR.Reg) & 0xf
}
func (o *DFSDM_Type) SetDFSDM3_AWHTR_AWHT(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_AWHTR.Reg, volatile.LoadUint32(&o.DFSDM3_AWHTR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM3_AWHTR_AWHT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_AWHTR.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM0_AWLTR: DFSDM analog watchdog low threshold register
func (o *DFSDM_Type) SetDFSDM0_AWLTR_BKAWL(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_AWLTR.Reg, volatile.LoadUint32(&o.DFSDM0_AWLTR.Reg)&^(0xf)|value)
}
func (o *DFSDM_Type) GetDFSDM0_AWLTR_BKAWL() uint32 {
	return volatile.LoadUint32(&o.DFSDM0_AWLTR.Reg) & 0xf
}
func (o *DFSDM_Type) SetDFSDM0_AWLTR_AWLT(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_AWLTR.Reg, volatile.LoadUint32(&o.DFSDM0_AWLTR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM0_AWLTR_AWLT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_AWLTR.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM1_AWLTR: DFSDM analog watchdog low threshold register
func (o *DFSDM_Type) SetDFSDM1_AWLTR_BKAWL(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_AWLTR.Reg, volatile.LoadUint32(&o.DFSDM1_AWLTR.Reg)&^(0xf)|value)
}
func (o *DFSDM_Type) GetDFSDM1_AWLTR_BKAWL() uint32 {
	return volatile.LoadUint32(&o.DFSDM1_AWLTR.Reg) & 0xf
}
func (o *DFSDM_Type) SetDFSDM1_AWLTR_AWLT(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_AWLTR.Reg, volatile.LoadUint32(&o.DFSDM1_AWLTR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM1_AWLTR_AWLT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_AWLTR.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM2_AWLTR: DFSDM analog watchdog low threshold register
func (o *DFSDM_Type) SetDFSDM2_AWLTR_BKAWL(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_AWLTR.Reg, volatile.LoadUint32(&o.DFSDM2_AWLTR.Reg)&^(0xf)|value)
}
func (o *DFSDM_Type) GetDFSDM2_AWLTR_BKAWL() uint32 {
	return volatile.LoadUint32(&o.DFSDM2_AWLTR.Reg) & 0xf
}
func (o *DFSDM_Type) SetDFSDM2_AWLTR_AWLT(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_AWLTR.Reg, volatile.LoadUint32(&o.DFSDM2_AWLTR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM2_AWLTR_AWLT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_AWLTR.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM3_AWLTR: DFSDM analog watchdog low threshold register
func (o *DFSDM_Type) SetDFSDM3_AWLTR_BKAWL(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_AWLTR.Reg, volatile.LoadUint32(&o.DFSDM3_AWLTR.Reg)&^(0xf)|value)
}
func (o *DFSDM_Type) GetDFSDM3_AWLTR_BKAWL() uint32 {
	return volatile.LoadUint32(&o.DFSDM3_AWLTR.Reg) & 0xf
}
func (o *DFSDM_Type) SetDFSDM3_AWLTR_AWLT(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_AWLTR.Reg, volatile.LoadUint32(&o.DFSDM3_AWLTR.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM3_AWLTR_AWLT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_AWLTR.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM0_AWSR: DFSDM analog watchdog status register
func (o *DFSDM_Type) SetDFSDM0_AWSR_AWLTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_AWSR.Reg, volatile.LoadUint32(&o.DFSDM0_AWSR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM0_AWSR_AWLTF() uint32 {
	return volatile.LoadUint32(&o.DFSDM0_AWSR.Reg) & 0xff
}
func (o *DFSDM_Type) SetDFSDM0_AWSR_AWHTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_AWSR.Reg, volatile.LoadUint32(&o.DFSDM0_AWSR.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM0_AWSR_AWHTF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_AWSR.Reg) & 0xff00) >> 8
}

// DFSDM.DFSDM1_AWSR: DFSDM analog watchdog status register
func (o *DFSDM_Type) SetDFSDM1_AWSR_AWLTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_AWSR.Reg, volatile.LoadUint32(&o.DFSDM1_AWSR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM1_AWSR_AWLTF() uint32 {
	return volatile.LoadUint32(&o.DFSDM1_AWSR.Reg) & 0xff
}
func (o *DFSDM_Type) SetDFSDM1_AWSR_AWHTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_AWSR.Reg, volatile.LoadUint32(&o.DFSDM1_AWSR.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM1_AWSR_AWHTF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_AWSR.Reg) & 0xff00) >> 8
}

// DFSDM.DFSDM2_AWSR: DFSDM analog watchdog status register
func (o *DFSDM_Type) SetDFSDM2_AWSR_AWLTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_AWSR.Reg, volatile.LoadUint32(&o.DFSDM2_AWSR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM2_AWSR_AWLTF() uint32 {
	return volatile.LoadUint32(&o.DFSDM2_AWSR.Reg) & 0xff
}
func (o *DFSDM_Type) SetDFSDM2_AWSR_AWHTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_AWSR.Reg, volatile.LoadUint32(&o.DFSDM2_AWSR.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM2_AWSR_AWHTF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_AWSR.Reg) & 0xff00) >> 8
}

// DFSDM.DFSDM3_AWSR: DFSDM analog watchdog status register
func (o *DFSDM_Type) SetDFSDM3_AWSR_AWLTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_AWSR.Reg, volatile.LoadUint32(&o.DFSDM3_AWSR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM3_AWSR_AWLTF() uint32 {
	return volatile.LoadUint32(&o.DFSDM3_AWSR.Reg) & 0xff
}
func (o *DFSDM_Type) SetDFSDM3_AWSR_AWHTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_AWSR.Reg, volatile.LoadUint32(&o.DFSDM3_AWSR.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM3_AWSR_AWHTF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_AWSR.Reg) & 0xff00) >> 8
}

// DFSDM.DFSDM0_AWCFR: DFSDM analog watchdog clear flag register
func (o *DFSDM_Type) SetDFSDM0_AWCFR_CLRAWLTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_AWCFR.Reg, volatile.LoadUint32(&o.DFSDM0_AWCFR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM0_AWCFR_CLRAWLTF() uint32 {
	return volatile.LoadUint32(&o.DFSDM0_AWCFR.Reg) & 0xff
}
func (o *DFSDM_Type) SetDFSDM0_AWCFR_CLRAWHTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_AWCFR.Reg, volatile.LoadUint32(&o.DFSDM0_AWCFR.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM0_AWCFR_CLRAWHTF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_AWCFR.Reg) & 0xff00) >> 8
}

// DFSDM.DFSDM1_AWCFR: DFSDM analog watchdog clear flag register
func (o *DFSDM_Type) SetDFSDM1_AWCFR_CLRAWLTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_AWCFR.Reg, volatile.LoadUint32(&o.DFSDM1_AWCFR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM1_AWCFR_CLRAWLTF() uint32 {
	return volatile.LoadUint32(&o.DFSDM1_AWCFR.Reg) & 0xff
}
func (o *DFSDM_Type) SetDFSDM1_AWCFR_CLRAWHTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_AWCFR.Reg, volatile.LoadUint32(&o.DFSDM1_AWCFR.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM1_AWCFR_CLRAWHTF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_AWCFR.Reg) & 0xff00) >> 8
}

// DFSDM.DFSDM2_AWCFR: DFSDM analog watchdog clear flag register
func (o *DFSDM_Type) SetDFSDM2_AWCFR_CLRAWLTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_AWCFR.Reg, volatile.LoadUint32(&o.DFSDM2_AWCFR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM2_AWCFR_CLRAWLTF() uint32 {
	return volatile.LoadUint32(&o.DFSDM2_AWCFR.Reg) & 0xff
}
func (o *DFSDM_Type) SetDFSDM2_AWCFR_CLRAWHTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_AWCFR.Reg, volatile.LoadUint32(&o.DFSDM2_AWCFR.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM2_AWCFR_CLRAWHTF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_AWCFR.Reg) & 0xff00) >> 8
}

// DFSDM.DFSDM3_AWCFR: DFSDM analog watchdog clear flag register
func (o *DFSDM_Type) SetDFSDM3_AWCFR_CLRAWLTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_AWCFR.Reg, volatile.LoadUint32(&o.DFSDM3_AWCFR.Reg)&^(0xff)|value)
}
func (o *DFSDM_Type) GetDFSDM3_AWCFR_CLRAWLTF() uint32 {
	return volatile.LoadUint32(&o.DFSDM3_AWCFR.Reg) & 0xff
}
func (o *DFSDM_Type) SetDFSDM3_AWCFR_CLRAWHTF(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_AWCFR.Reg, volatile.LoadUint32(&o.DFSDM3_AWCFR.Reg)&^(0xff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM3_AWCFR_CLRAWHTF() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_AWCFR.Reg) & 0xff00) >> 8
}

// DFSDM.DFSDM0_EXMAX: DFSDM Extremes detector maximum register
func (o *DFSDM_Type) SetDFSDM0_EXMAX_EXMAXCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_EXMAX.Reg, volatile.LoadUint32(&o.DFSDM0_EXMAX.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM0_EXMAX_EXMAXCH() uint32 {
	return volatile.LoadUint32(&o.DFSDM0_EXMAX.Reg) & 0x7
}
func (o *DFSDM_Type) SetDFSDM0_EXMAX_EXMAX(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_EXMAX.Reg, volatile.LoadUint32(&o.DFSDM0_EXMAX.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM0_EXMAX_EXMAX() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_EXMAX.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM1_EXMAX: DFSDM Extremes detector maximum register
func (o *DFSDM_Type) SetDFSDM1_EXMAX_EXMAXCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_EXMAX.Reg, volatile.LoadUint32(&o.DFSDM1_EXMAX.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM1_EXMAX_EXMAXCH() uint32 {
	return volatile.LoadUint32(&o.DFSDM1_EXMAX.Reg) & 0x7
}
func (o *DFSDM_Type) SetDFSDM1_EXMAX_EXMAX(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_EXMAX.Reg, volatile.LoadUint32(&o.DFSDM1_EXMAX.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM1_EXMAX_EXMAX() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_EXMAX.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM2_EXMAX: DFSDM Extremes detector maximum register
func (o *DFSDM_Type) SetDFSDM2_EXMAX_EXMAXCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_EXMAX.Reg, volatile.LoadUint32(&o.DFSDM2_EXMAX.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM2_EXMAX_EXMAXCH() uint32 {
	return volatile.LoadUint32(&o.DFSDM2_EXMAX.Reg) & 0x7
}
func (o *DFSDM_Type) SetDFSDM2_EXMAX_EXMAX(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_EXMAX.Reg, volatile.LoadUint32(&o.DFSDM2_EXMAX.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM2_EXMAX_EXMAX() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_EXMAX.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM3_EXMAX: DFSDM Extremes detector maximum register
func (o *DFSDM_Type) SetDFSDM3_EXMAX_EXMAXCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_EXMAX.Reg, volatile.LoadUint32(&o.DFSDM3_EXMAX.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM3_EXMAX_EXMAXCH() uint32 {
	return volatile.LoadUint32(&o.DFSDM3_EXMAX.Reg) & 0x7
}
func (o *DFSDM_Type) SetDFSDM3_EXMAX_EXMAX(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_EXMAX.Reg, volatile.LoadUint32(&o.DFSDM3_EXMAX.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM3_EXMAX_EXMAX() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_EXMAX.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM0_EXMIN: DFSDM Extremes detector minimum register
func (o *DFSDM_Type) SetDFSDM0_EXMIN_EXMINCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_EXMIN.Reg, volatile.LoadUint32(&o.DFSDM0_EXMIN.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM0_EXMIN_EXMINCH() uint32 {
	return volatile.LoadUint32(&o.DFSDM0_EXMIN.Reg) & 0x7
}
func (o *DFSDM_Type) SetDFSDM0_EXMIN_EXMIN(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_EXMIN.Reg, volatile.LoadUint32(&o.DFSDM0_EXMIN.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM0_EXMIN_EXMIN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_EXMIN.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM1_EXMIN: DFSDM Extremes detector minimum register
func (o *DFSDM_Type) SetDFSDM1_EXMIN_EXMINCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_EXMIN.Reg, volatile.LoadUint32(&o.DFSDM1_EXMIN.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM1_EXMIN_EXMINCH() uint32 {
	return volatile.LoadUint32(&o.DFSDM1_EXMIN.Reg) & 0x7
}
func (o *DFSDM_Type) SetDFSDM1_EXMIN_EXMIN(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_EXMIN.Reg, volatile.LoadUint32(&o.DFSDM1_EXMIN.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM1_EXMIN_EXMIN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_EXMIN.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM2_EXMIN: DFSDM Extremes detector minimum register
func (o *DFSDM_Type) SetDFSDM2_EXMIN_EXMINCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_EXMIN.Reg, volatile.LoadUint32(&o.DFSDM2_EXMIN.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM2_EXMIN_EXMINCH() uint32 {
	return volatile.LoadUint32(&o.DFSDM2_EXMIN.Reg) & 0x7
}
func (o *DFSDM_Type) SetDFSDM2_EXMIN_EXMIN(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_EXMIN.Reg, volatile.LoadUint32(&o.DFSDM2_EXMIN.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM2_EXMIN_EXMIN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_EXMIN.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM3_EXMIN: DFSDM Extremes detector minimum register
func (o *DFSDM_Type) SetDFSDM3_EXMIN_EXMINCH(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_EXMIN.Reg, volatile.LoadUint32(&o.DFSDM3_EXMIN.Reg)&^(0x7)|value)
}
func (o *DFSDM_Type) GetDFSDM3_EXMIN_EXMINCH() uint32 {
	return volatile.LoadUint32(&o.DFSDM3_EXMIN.Reg) & 0x7
}
func (o *DFSDM_Type) SetDFSDM3_EXMIN_EXMIN(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_EXMIN.Reg, volatile.LoadUint32(&o.DFSDM3_EXMIN.Reg)&^(0xffffff00)|value<<8)
}
func (o *DFSDM_Type) GetDFSDM3_EXMIN_EXMIN() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_EXMIN.Reg) & 0xffffff00) >> 8
}

// DFSDM.DFSDM0_CNVTIMR: DFSDM conversion timer register
func (o *DFSDM_Type) SetDFSDM0_CNVTIMR_CNVCNT(value uint32) {
	volatile.StoreUint32(&o.DFSDM0_CNVTIMR.Reg, volatile.LoadUint32(&o.DFSDM0_CNVTIMR.Reg)&^(0xfffffff0)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM0_CNVTIMR_CNVCNT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM0_CNVTIMR.Reg) & 0xfffffff0) >> 4
}

// DFSDM.DFSDM1_CNVTIMR: DFSDM conversion timer register
func (o *DFSDM_Type) SetDFSDM1_CNVTIMR_CNVCNT(value uint32) {
	volatile.StoreUint32(&o.DFSDM1_CNVTIMR.Reg, volatile.LoadUint32(&o.DFSDM1_CNVTIMR.Reg)&^(0xfffffff0)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM1_CNVTIMR_CNVCNT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM1_CNVTIMR.Reg) & 0xfffffff0) >> 4
}

// DFSDM.DFSDM2_CNVTIMR: DFSDM conversion timer register
func (o *DFSDM_Type) SetDFSDM2_CNVTIMR_CNVCNT(value uint32) {
	volatile.StoreUint32(&o.DFSDM2_CNVTIMR.Reg, volatile.LoadUint32(&o.DFSDM2_CNVTIMR.Reg)&^(0xfffffff0)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM2_CNVTIMR_CNVCNT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM2_CNVTIMR.Reg) & 0xfffffff0) >> 4
}

// DFSDM.DFSDM3_CNVTIMR: DFSDM conversion timer register
func (o *DFSDM_Type) SetDFSDM3_CNVTIMR_CNVCNT(value uint32) {
	volatile.StoreUint32(&o.DFSDM3_CNVTIMR.Reg, volatile.LoadUint32(&o.DFSDM3_CNVTIMR.Reg)&^(0xfffffff0)|value<<4)
}
func (o *DFSDM_Type) GetDFSDM3_CNVTIMR_CNVCNT() uint32 {
	return (volatile.LoadUint32(&o.DFSDM3_CNVTIMR.Reg) & 0xfffffff0) >> 4
}

// JPEG codec
type JPEG_Type struct {
	CONFR0         volatile.Register32 // 0x0
	CONFR1         volatile.Register32 // 0x4
	CONFR2         volatile.Register32 // 0x8
	CONFR3         volatile.Register32 // 0xC
	CONFR4         volatile.Register32 // 0x10
	CONFR5         volatile.Register32 // 0x14
	CONFR6         volatile.Register32 // 0x18
	CONFR7         volatile.Register32 // 0x1C
	_              [16]byte
	CR             volatile.Register32 // 0x30
	SR             volatile.Register32 // 0x34
	CFR            volatile.Register32 // 0x38
	_              [4]byte
	DIR            volatile.Register32 // 0x40
	DOR            volatile.Register32 // 0x44
	_              [8]byte
	QMEM0_0        volatile.Register32 // 0x50
	QMEM0_1        volatile.Register32 // 0x54
	QMEM0_2        volatile.Register32 // 0x58
	QMEM0_3        volatile.Register32 // 0x5C
	QMEM0_4        volatile.Register32 // 0x60
	QMEM0_5        volatile.Register32 // 0x64
	QMEM0_6        volatile.Register32 // 0x68
	QMEM0_7        volatile.Register32 // 0x6C
	QMEM0_8        volatile.Register32 // 0x70
	QMEM0_9        volatile.Register32 // 0x74
	QMEM0_10       volatile.Register32 // 0x78
	QMEM0_11       volatile.Register32 // 0x7C
	QMEM0_12       volatile.Register32 // 0x80
	QMEM0_13       volatile.Register32 // 0x84
	QMEM0_14       volatile.Register32 // 0x88
	QMEM0_15       volatile.Register32 // 0x8C
	QMEM1_0        volatile.Register32 // 0x90
	QMEM1_1        volatile.Register32 // 0x94
	QMEM1_2        volatile.Register32 // 0x98
	QMEM1_3        volatile.Register32 // 0x9C
	QMEM1_4        volatile.Register32 // 0xA0
	QMEM1_5        volatile.Register32 // 0xA4
	QMEM1_6        volatile.Register32 // 0xA8
	QMEM1_7        volatile.Register32 // 0xAC
	QMEM1_8        volatile.Register32 // 0xB0
	QMEM1_9        volatile.Register32 // 0xB4
	QMEM1_10       volatile.Register32 // 0xB8
	QMEM1_11       volatile.Register32 // 0xBC
	QMEM1_12       volatile.Register32 // 0xC0
	QMEM1_13       volatile.Register32 // 0xC4
	QMEM1_14       volatile.Register32 // 0xC8
	QMEM1_15       volatile.Register32 // 0xCC
	QMEM2_0        volatile.Register32 // 0xD0
	QMEM2_1        volatile.Register32 // 0xD4
	QMEM2_2        volatile.Register32 // 0xD8
	QMEM2_3        volatile.Register32 // 0xDC
	QMEM2_4        volatile.Register32 // 0xE0
	QMEM2_5        volatile.Register32 // 0xE4
	QMEM2_6        volatile.Register32 // 0xE8
	QMEM2_7        volatile.Register32 // 0xEC
	QMEM2_8        volatile.Register32 // 0xF0
	QMEM2_9        volatile.Register32 // 0xF4
	QMEM2_10       volatile.Register32 // 0xF8
	QMEM2_11       volatile.Register32 // 0xFC
	QMEM2_12       volatile.Register32 // 0x100
	QMEM2_13       volatile.Register32 // 0x104
	QMEM2_14       volatile.Register32 // 0x108
	QMEM2_15       volatile.Register32 // 0x10C
	QMEM3_0        volatile.Register32 // 0x110
	QMEM3_1        volatile.Register32 // 0x114
	QMEM3_2        volatile.Register32 // 0x118
	QMEM3_3        volatile.Register32 // 0x11C
	QMEM3_4        volatile.Register32 // 0x120
	QMEM3_5        volatile.Register32 // 0x124
	QMEM3_6        volatile.Register32 // 0x128
	QMEM3_7        volatile.Register32 // 0x12C
	QMEM3_8        volatile.Register32 // 0x130
	QMEM3_9        volatile.Register32 // 0x134
	QMEM3_10       volatile.Register32 // 0x138
	QMEM3_11       volatile.Register32 // 0x13C
	QMEM3_12       volatile.Register32 // 0x140
	QMEM3_13       volatile.Register32 // 0x144
	QMEM3_14       volatile.Register32 // 0x148
	QMEM3_15       volatile.Register32 // 0x14C
	HUFFMIN_0      volatile.Register32 // 0x150
	HUFFMIN_1      volatile.Register32 // 0x154
	HUFFMIN_2      volatile.Register32 // 0x158
	HUFFMIN_3      volatile.Register32 // 0x15C
	HUFFMIN_4      volatile.Register32 // 0x160
	HUFFMIN_5      volatile.Register32 // 0x164
	HUFFMIN_6      volatile.Register32 // 0x168
	HUFFMIN_7      volatile.Register32 // 0x16C
	HUFFMIN_8      volatile.Register32 // 0x170
	HUFFMIN_9      volatile.Register32 // 0x174
	HUFFMIN_10     volatile.Register32 // 0x178
	HUFFMIN_11     volatile.Register32 // 0x17C
	HUFFMIN_12     volatile.Register32 // 0x180
	HUFFMIN_13     volatile.Register32 // 0x184
	HUFFMIN_14     volatile.Register32 // 0x188
	HUFFMIN_15     volatile.Register32 // 0x18C
	HUFFBASE0      volatile.Register32 // 0x190
	HUFFBASE1      volatile.Register32 // 0x194
	HUFFBASE2      volatile.Register32 // 0x198
	HUFFBASE3      volatile.Register32 // 0x19C
	HUFFBASE4      volatile.Register32 // 0x1A0
	HUFFBASE5      volatile.Register32 // 0x1A4
	HUFFBASE6      volatile.Register32 // 0x1A8
	HUFFBASE7      volatile.Register32 // 0x1AC
	HUFFBASE8      volatile.Register32 // 0x1B0
	HUFFBASE9      volatile.Register32 // 0x1B4
	HUFFBASE10     volatile.Register32 // 0x1B8
	HUFFBASE11     volatile.Register32 // 0x1BC
	HUFFBASE12     volatile.Register32 // 0x1C0
	HUFFBASE13     volatile.Register32 // 0x1C4
	HUFFBASE14     volatile.Register32 // 0x1C8
	HUFFBASE15     volatile.Register32 // 0x1CC
	HUFFBASE16     volatile.Register32 // 0x1D0
	HUFFBASE17     volatile.Register32 // 0x1D4
	HUFFBASE18     volatile.Register32 // 0x1D8
	HUFFBASE19     volatile.Register32 // 0x1DC
	HUFFBASE20     volatile.Register32 // 0x1E0
	HUFFBASE21     volatile.Register32 // 0x1E4
	HUFFBASE22     volatile.Register32 // 0x1E8
	HUFFBASE23     volatile.Register32 // 0x1EC
	HUFFBASE24     volatile.Register32 // 0x1F0
	HUFFBASE25     volatile.Register32 // 0x1F4
	HUFFBASE26     volatile.Register32 // 0x1F8
	HUFFBASE27     volatile.Register32 // 0x1FC
	HUFFBASE28     volatile.Register32 // 0x200
	HUFFBASE29     volatile.Register32 // 0x204
	HUFFBASE30     volatile.Register32 // 0x208
	HUFFBASE31     volatile.Register32 // 0x20C
	HUFFSYMB0      volatile.Register32 // 0x210
	HUFFSYMB1      volatile.Register32 // 0x214
	HUFFSYMB2      volatile.Register32 // 0x218
	HUFFSYMB3      volatile.Register32 // 0x21C
	HUFFSYMB4      volatile.Register32 // 0x220
	HUFFSYMB5      volatile.Register32 // 0x224
	HUFFSYMB6      volatile.Register32 // 0x228
	HUFFSYMB7      volatile.Register32 // 0x22C
	HUFFSYMB8      volatile.Register32 // 0x230
	HUFFSYMB9      volatile.Register32 // 0x234
	HUFFSYMB10     volatile.Register32 // 0x238
	HUFFSYMB11     volatile.Register32 // 0x23C
	HUFFSYMB12     volatile.Register32 // 0x240
	HUFFSYMB13     volatile.Register32 // 0x244
	HUFFSYMB14     volatile.Register32 // 0x248
	HUFFSYMB15     volatile.Register32 // 0x24C
	HUFFSYMB16     volatile.Register32 // 0x250
	HUFFSYMB17     volatile.Register32 // 0x254
	HUFFSYMB18     volatile.Register32 // 0x258
	HUFFSYMB19     volatile.Register32 // 0x25C
	HUFFSYMB20     volatile.Register32 // 0x260
	HUFFSYMB21     volatile.Register32 // 0x264
	HUFFSYMB22     volatile.Register32 // 0x268
	HUFFSYMB23     volatile.Register32 // 0x26C
	HUFFSYMB24     volatile.Register32 // 0x270
	HUFFSYMB25     volatile.Register32 // 0x274
	HUFFSYMB26     volatile.Register32 // 0x278
	HUFFSYMB27     volatile.Register32 // 0x27C
	HUFFSYMB28     volatile.Register32 // 0x280
	HUFFSYMB29     volatile.Register32 // 0x284
	HUFFSYMB30     volatile.Register32 // 0x288
	HUFFSYMB31     volatile.Register32 // 0x28C
	HUFFSYMB32     volatile.Register32 // 0x290
	HUFFSYMB33     volatile.Register32 // 0x294
	HUFFSYMB34     volatile.Register32 // 0x298
	HUFFSYMB35     volatile.Register32 // 0x29C
	HUFFSYMB36     volatile.Register32 // 0x2A0
	HUFFSYMB37     volatile.Register32 // 0x2A4
	HUFFSYMB38     volatile.Register32 // 0x2A8
	HUFFSYMB39     volatile.Register32 // 0x2AC
	HUFFSYMB40     volatile.Register32 // 0x2B0
	HUFFSYMB41     volatile.Register32 // 0x2B4
	HUFFSYMB42     volatile.Register32 // 0x2B8
	HUFFSYMB43     volatile.Register32 // 0x2BC
	HUFFSYMB44     volatile.Register32 // 0x2C0
	HUFFSYMB45     volatile.Register32 // 0x2C4
	HUFFSYMB46     volatile.Register32 // 0x2C8
	HUFFSYMB47     volatile.Register32 // 0x2CC
	HUFFSYMB48     volatile.Register32 // 0x2D0
	HUFFSYMB49     volatile.Register32 // 0x2D4
	HUFFSYMB50     volatile.Register32 // 0x2D8
	HUFFSYMB51     volatile.Register32 // 0x2DC
	HUFFSYMB52     volatile.Register32 // 0x2E0
	HUFFSYMB53     volatile.Register32 // 0x2E4
	HUFFSYMB54     volatile.Register32 // 0x2E8
	HUFFSYMB55     volatile.Register32 // 0x2EC
	HUFFSYMB56     volatile.Register32 // 0x2F0
	HUFFSYMB57     volatile.Register32 // 0x2F4
	HUFFSYMB58     volatile.Register32 // 0x2F8
	HUFFSYMB59     volatile.Register32 // 0x2FC
	HUFFSYMB60     volatile.Register32 // 0x300
	HUFFSYMB61     volatile.Register32 // 0x304
	HUFFSYMB62     volatile.Register32 // 0x308
	HUFFSYMB63     volatile.Register32 // 0x30C
	HUFFSYMB64     volatile.Register32 // 0x310
	HUFFSYMB65     volatile.Register32 // 0x314
	HUFFSYMB66     volatile.Register32 // 0x318
	HUFFSYMB67     volatile.Register32 // 0x31C
	HUFFSYMB68     volatile.Register32 // 0x320
	HUFFSYMB69     volatile.Register32 // 0x324
	HUFFSYMB70     volatile.Register32 // 0x328
	HUFFSYMB71     volatile.Register32 // 0x32C
	HUFFSYMB72     volatile.Register32 // 0x330
	HUFFSYMB73     volatile.Register32 // 0x334
	HUFFSYMB74     volatile.Register32 // 0x338
	HUFFSYMB75     volatile.Register32 // 0x33C
	HUFFSYMB76     volatile.Register32 // 0x340
	HUFFSYMB77     volatile.Register32 // 0x344
	HUFFSYMB78     volatile.Register32 // 0x348
	HUFFSYMB79     volatile.Register32 // 0x34C
	HUFFSYMB80     volatile.Register32 // 0x350
	HUFFSYMB81     volatile.Register32 // 0x354
	HUFFSYMB82     volatile.Register32 // 0x358
	HUFFSYMB83     volatile.Register32 // 0x35C
	DHTMEM0        volatile.Register32 // 0x360
	DHTMEM2        volatile.Register32 // 0x364
	DHTMEM3        volatile.Register32 // 0x368
	DHTMEM4        volatile.Register32 // 0x36C
	DHTMEM5        volatile.Register32 // 0x370
	DHTMEM6        volatile.Register32 // 0x374
	DHTMEM7        volatile.Register32 // 0x378
	DHTMEM8        volatile.Register32 // 0x37C
	DHTMEM9        volatile.Register32 // 0x380
	DHTMEM10       volatile.Register32 // 0x384
	DHTMEM11       volatile.Register32 // 0x388
	DHTMEM12       volatile.Register32 // 0x38C
	DHTMEM13       volatile.Register32 // 0x390
	DHTMEM14       volatile.Register32 // 0x394
	DHTMEM15       volatile.Register32 // 0x398
	DHTMEM16       volatile.Register32 // 0x39C
	DHTMEM17       volatile.Register32 // 0x3A0
	DHTMEM18       volatile.Register32 // 0x3A4
	DHTMEM19       volatile.Register32 // 0x3A8
	DHTMEM20       volatile.Register32 // 0x3AC
	DHTMEM21       volatile.Register32 // 0x3B0
	DHTMEM22       volatile.Register32 // 0x3B4
	DHTMEM23       volatile.Register32 // 0x3B8
	DHTMEM24       volatile.Register32 // 0x3BC
	DHTMEM25       volatile.Register32 // 0x3C0
	DHTMEM26       volatile.Register32 // 0x3C4
	DHTMEM27       volatile.Register32 // 0x3C8
	DHTMEM28       volatile.Register32 // 0x3CC
	DHTMEM29       volatile.Register32 // 0x3D0
	DHTMEM30       volatile.Register32 // 0x3D4
	DHTMEM31       volatile.Register32 // 0x3D8
	DHTMEM32       volatile.Register32 // 0x3DC
	DHTMEM33       volatile.Register32 // 0x3E0
	DHTMEM34       volatile.Register32 // 0x3E4
	DHTMEM35       volatile.Register32 // 0x3E8
	DHTMEM36       volatile.Register32 // 0x3EC
	DHTMEM37       volatile.Register32 // 0x3F0
	DHTMEM38       volatile.Register32 // 0x3F4
	DHTMEM39       volatile.Register32 // 0x3F8
	DHTMEM40       volatile.Register32 // 0x3FC
	DHTMEM41       volatile.Register32 // 0x400
	DHTMEM42       volatile.Register32 // 0x404
	DHTMEM43       volatile.Register32 // 0x408
	DHTMEM44       volatile.Register32 // 0x40C
	DHTMEM45       volatile.Register32 // 0x410
	DHTMEM46       volatile.Register32 // 0x414
	DHTMEM47       volatile.Register32 // 0x418
	DHTMEM48       volatile.Register32 // 0x41C
	DHTMEM49       volatile.Register32 // 0x420
	DHTMEM50       volatile.Register32 // 0x424
	DHTMEM51       volatile.Register32 // 0x428
	DHTMEM52       volatile.Register32 // 0x42C
	DHTMEM53       volatile.Register32 // 0x430
	DHTMEM54       volatile.Register32 // 0x434
	DHTMEM55       volatile.Register32 // 0x438
	DHTMEM56       volatile.Register32 // 0x43C
	DHTMEM57       volatile.Register32 // 0x440
	DHTMEM58       volatile.Register32 // 0x444
	DHTMEM59       volatile.Register32 // 0x448
	DHTMEM60       volatile.Register32 // 0x44C
	DHTMEM61       volatile.Register32 // 0x450
	DHTMEM62       volatile.Register32 // 0x454
	DHTMEM63       volatile.Register32 // 0x458
	DHTMEM64       volatile.Register32 // 0x45C
	DHTMEM65       volatile.Register32 // 0x460
	DHTMEM66       volatile.Register32 // 0x464
	DHTMEM67       volatile.Register32 // 0x468
	DHTMEM68       volatile.Register32 // 0x46C
	DHTMEM69       volatile.Register32 // 0x470
	DHTMEM70       volatile.Register32 // 0x474
	DHTMEM71       volatile.Register32 // 0x478
	DHTMEM72       volatile.Register32 // 0x47C
	DHTMEM73       volatile.Register32 // 0x480
	DHTMEM74       volatile.Register32 // 0x484
	DHTMEM75       volatile.Register32 // 0x488
	DHTMEM76       volatile.Register32 // 0x48C
	DHTMEM77       volatile.Register32 // 0x490
	DHTMEM78       volatile.Register32 // 0x494
	DHTMEM79       volatile.Register32 // 0x498
	DHTMEM80       volatile.Register32 // 0x49C
	DHTMEM81       volatile.Register32 // 0x4A0
	DHTMEM82       volatile.Register32 // 0x4A4
	DHTMEM83       volatile.Register32 // 0x4A8
	DHTMEM84       volatile.Register32 // 0x4AC
	DHTMEM85       volatile.Register32 // 0x4B0
	DHTMEM86       volatile.Register32 // 0x4B4
	DHTMEM87       volatile.Register32 // 0x4B8
	DHTMEM88       volatile.Register32 // 0x4BC
	DHTMEM89       volatile.Register32 // 0x4C0
	DHTMEM90       volatile.Register32 // 0x4C4
	DHTMEM91       volatile.Register32 // 0x4C8
	DHTMEM92       volatile.Register32 // 0x4CC
	DHTMEM93       volatile.Register32 // 0x4D0
	DHTMEM94       volatile.Register32 // 0x4D4
	DHTMEM95       volatile.Register32 // 0x4D8
	DHTMEM96       volatile.Register32 // 0x4DC
	DHTMEM97       volatile.Register32 // 0x4E0
	DHTMEM98       volatile.Register32 // 0x4E4
	DHTMEM99       volatile.Register32 // 0x4E8
	DHTMEM100      volatile.Register32 // 0x4EC
	DHTMEM101      volatile.Register32 // 0x4F0
	DHTMEM102      volatile.Register32 // 0x4F4
	DHTMEM103      volatile.Register32 // 0x4F8
	_              [4]byte
	HUFFENC_AC0_0  volatile.Register32 // 0x500
	HUFFENC_AC0_1  volatile.Register32 // 0x504
	HUFFENC_AC0_2  volatile.Register32 // 0x508
	HUFFENC_AC0_3  volatile.Register32 // 0x50C
	HUFFENC_AC0_4  volatile.Register32 // 0x510
	HUFFENC_AC0_5  volatile.Register32 // 0x514
	HUFFENC_AC0_6  volatile.Register32 // 0x518
	HUFFENC_AC0_7  volatile.Register32 // 0x51C
	HUFFENC_AC0_8  volatile.Register32 // 0x520
	HUFFENC_AC0_9  volatile.Register32 // 0x524
	HUFFENC_AC0_10 volatile.Register32 // 0x528
	HUFFENC_AC0_11 volatile.Register32 // 0x52C
	HUFFENC_AC0_12 volatile.Register32 // 0x530
	HUFFENC_AC0_13 volatile.Register32 // 0x534
	HUFFENC_AC0_14 volatile.Register32 // 0x538
	HUFFENC_AC0_15 volatile.Register32 // 0x53C
	HUFFENC_AC0_16 volatile.Register32 // 0x540
	HUFFENC_AC0_17 volatile.Register32 // 0x544
	HUFFENC_AC0_18 volatile.Register32 // 0x548
	HUFFENC_AC0_19 volatile.Register32 // 0x54C
	HUFFENC_AC0_20 volatile.Register32 // 0x550
	HUFFENC_AC0_21 volatile.Register32 // 0x554
	HUFFENC_AC0_22 volatile.Register32 // 0x558
	HUFFENC_AC0_23 volatile.Register32 // 0x55C
	HUFFENC_AC0_24 volatile.Register32 // 0x560
	HUFFENC_AC0_25 volatile.Register32 // 0x564
	HUFFENC_AC0_26 volatile.Register32 // 0x568
	HUFFENC_AC0_27 volatile.Register32 // 0x56C
	HUFFENC_AC0_28 volatile.Register32 // 0x570
	HUFFENC_AC0_29 volatile.Register32 // 0x574
	HUFFENC_AC0_30 volatile.Register32 // 0x578
	HUFFENC_AC0_31 volatile.Register32 // 0x57C
	HUFFENC_AC0_32 volatile.Register32 // 0x580
	HUFFENC_AC0_33 volatile.Register32 // 0x584
	HUFFENC_AC0_34 volatile.Register32 // 0x588
	HUFFENC_AC0_35 volatile.Register32 // 0x58C
	HUFFENC_AC0_36 volatile.Register32 // 0x590
	HUFFENC_AC0_37 volatile.Register32 // 0x594
	HUFFENC_AC0_38 volatile.Register32 // 0x598
	HUFFENC_AC0_39 volatile.Register32 // 0x59C
	HUFFENC_AC0_40 volatile.Register32 // 0x5A0
	HUFFENC_AC0_41 volatile.Register32 // 0x5A4
	HUFFENC_AC0_42 volatile.Register32 // 0x5A8
	HUFFENC_AC0_43 volatile.Register32 // 0x5AC
	HUFFENC_AC0_44 volatile.Register32 // 0x5B0
	HUFFENC_AC0_45 volatile.Register32 // 0x5B4
	HUFFENC_AC0_46 volatile.Register32 // 0x5B8
	HUFFENC_AC0_47 volatile.Register32 // 0x5BC
	HUFFENC_AC0_48 volatile.Register32 // 0x5C0
	HUFFENC_AC0_49 volatile.Register32 // 0x5C4
	HUFFENC_AC0_50 volatile.Register32 // 0x5C8
	HUFFENC_AC0_51 volatile.Register32 // 0x5CC
	HUFFENC_AC0_52 volatile.Register32 // 0x5D0
	HUFFENC_AC0_53 volatile.Register32 // 0x5D4
	HUFFENC_AC0_54 volatile.Register32 // 0x5D8
	HUFFENC_AC0_55 volatile.Register32 // 0x5DC
	HUFFENC_AC0_56 volatile.Register32 // 0x5E0
	HUFFENC_AC0_57 volatile.Register32 // 0x5E4
	HUFFENC_AC0_58 volatile.Register32 // 0x5E8
	HUFFENC_AC0_59 volatile.Register32 // 0x5EC
	HUFFENC_AC0_60 volatile.Register32 // 0x5F0
	HUFFENC_AC0_61 volatile.Register32 // 0x5F4
	HUFFENC_AC0_62 volatile.Register32 // 0x5F8
	HUFFENC_AC0_63 volatile.Register32 // 0x5FC
	HUFFENC_AC0_64 volatile.Register32 // 0x600
	HUFFENC_AC0_65 volatile.Register32 // 0x604
	HUFFENC_AC0_66 volatile.Register32 // 0x608
	HUFFENC_AC0_67 volatile.Register32 // 0x60C
	HUFFENC_AC0_68 volatile.Register32 // 0x610
	HUFFENC_AC0_69 volatile.Register32 // 0x614
	HUFFENC_AC0_70 volatile.Register32 // 0x618
	HUFFENC_AC0_71 volatile.Register32 // 0x61C
	HUFFENC_AC0_72 volatile.Register32 // 0x620
	HUFFENC_AC0_73 volatile.Register32 // 0x624
	HUFFENC_AC0_74 volatile.Register32 // 0x628
	HUFFENC_AC0_75 volatile.Register32 // 0x62C
	HUFFENC_AC0_76 volatile.Register32 // 0x630
	HUFFENC_AC0_77 volatile.Register32 // 0x634
	HUFFENC_AC0_78 volatile.Register32 // 0x638
	HUFFENC_AC0_79 volatile.Register32 // 0x63C
	HUFFENC_AC0_80 volatile.Register32 // 0x640
	HUFFENC_AC0_81 volatile.Register32 // 0x644
	HUFFENC_AC0_82 volatile.Register32 // 0x648
	HUFFENC_AC0_83 volatile.Register32 // 0x64C
	HUFFENC_AC0_84 volatile.Register32 // 0x650
	HUFFENC_AC0_85 volatile.Register32 // 0x654
	HUFFENC_AC0_86 volatile.Register32 // 0x658
	HUFFENC_AC0_87 volatile.Register32 // 0x65C
	HUFFENC_AC1_0  volatile.Register32 // 0x660
	HUFFENC_AC1_1  volatile.Register32 // 0x664
	HUFFENC_AC1_2  volatile.Register32 // 0x668
	HUFFENC_AC1_3  volatile.Register32 // 0x66C
	HUFFENC_AC1_4  volatile.Register32 // 0x670
	HUFFENC_AC1_5  volatile.Register32 // 0x674
	HUFFENC_AC1_6  volatile.Register32 // 0x678
	HUFFENC_AC1_7  volatile.Register32 // 0x67C
	HUFFENC_AC1_8  volatile.Register32 // 0x680
	HUFFENC_AC1_9  volatile.Register32 // 0x684
	HUFFENC_AC1_10 volatile.Register32 // 0x688
	HUFFENC_AC1_11 volatile.Register32 // 0x68C
	HUFFENC_AC1_12 volatile.Register32 // 0x690
	HUFFENC_AC1_13 volatile.Register32 // 0x694
	HUFFENC_AC1_14 volatile.Register32 // 0x698
	HUFFENC_AC1_15 volatile.Register32 // 0x69C
	HUFFENC_AC1_16 volatile.Register32 // 0x6A0
	HUFFENC_AC1_17 volatile.Register32 // 0x6A4
	HUFFENC_AC1_18 volatile.Register32 // 0x6A8
	HUFFENC_AC1_19 volatile.Register32 // 0x6AC
	HUFFENC_AC1_20 volatile.Register32 // 0x6B0
	HUFFENC_AC1_21 volatile.Register32 // 0x6B4
	HUFFENC_AC1_22 volatile.Register32 // 0x6B8
	HUFFENC_AC1_23 volatile.Register32 // 0x6BC
	HUFFENC_AC1_24 volatile.Register32 // 0x6C0
	HUFFENC_AC1_25 volatile.Register32 // 0x6C4
	HUFFENC_AC1_26 volatile.Register32 // 0x6C8
	HUFFENC_AC1_27 volatile.Register32 // 0x6CC
	HUFFENC_AC1_28 volatile.Register32 // 0x6D0
	HUFFENC_AC1_29 volatile.Register32 // 0x6D4
	HUFFENC_AC1_30 volatile.Register32 // 0x6D8
	HUFFENC_AC1_31 volatile.Register32 // 0x6DC
	HUFFENC_AC1_32 volatile.Register32 // 0x6E0
	HUFFENC_AC1_33 volatile.Register32 // 0x6E4
	HUFFENC_AC1_34 volatile.Register32 // 0x6E8
	HUFFENC_AC1_35 volatile.Register32 // 0x6EC
	HUFFENC_AC1_36 volatile.Register32 // 0x6F0
	HUFFENC_AC1_37 volatile.Register32 // 0x6F4
	HUFFENC_AC1_38 volatile.Register32 // 0x6F8
	HUFFENC_AC1_39 volatile.Register32 // 0x6FC
	HUFFENC_AC1_40 volatile.Register32 // 0x700
	HUFFENC_AC1_41 volatile.Register32 // 0x704
	HUFFENC_AC1_42 volatile.Register32 // 0x708
	HUFFENC_AC1_43 volatile.Register32 // 0x70C
	HUFFENC_AC1_44 volatile.Register32 // 0x710
	HUFFENC_AC1_45 volatile.Register32 // 0x714
	HUFFENC_AC1_46 volatile.Register32 // 0x718
	HUFFENC_AC1_47 volatile.Register32 // 0x71C
	HUFFENC_AC1_48 volatile.Register32 // 0x720
	HUFFENC_AC1_49 volatile.Register32 // 0x724
	HUFFENC_AC1_50 volatile.Register32 // 0x728
	HUFFENC_AC1_51 volatile.Register32 // 0x72C
	HUFFENC_AC1_52 volatile.Register32 // 0x730
	HUFFENC_AC1_53 volatile.Register32 // 0x734
	HUFFENC_AC1_54 volatile.Register32 // 0x738
	HUFFENC_AC1_55 volatile.Register32 // 0x73C
	HUFFENC_AC1_56 volatile.Register32 // 0x740
	HUFFENC_AC1_57 volatile.Register32 // 0x744
	HUFFENC_AC1_58 volatile.Register32 // 0x748
	HUFFENC_AC1_59 volatile.Register32 // 0x74C
	HUFFENC_AC1_60 volatile.Register32 // 0x750
	HUFFENC_AC1_61 volatile.Register32 // 0x754
	HUFFENC_AC1_62 volatile.Register32 // 0x758
	HUFFENC_AC1_63 volatile.Register32 // 0x75C
	HUFFENC_AC1_64 volatile.Register32 // 0x760
	HUFFENC_AC1_65 volatile.Register32 // 0x764
	HUFFENC_AC1_66 volatile.Register32 // 0x768
	HUFFENC_AC1_67 volatile.Register32 // 0x76C
	HUFFENC_AC1_68 volatile.Register32 // 0x770
	HUFFENC_AC1_69 volatile.Register32 // 0x774
	HUFFENC_AC1_70 volatile.Register32 // 0x778
	HUFFENC_AC1_71 volatile.Register32 // 0x77C
	HUFFENC_AC1_72 volatile.Register32 // 0x780
	HUFFENC_AC1_73 volatile.Register32 // 0x784
	HUFFENC_AC1_74 volatile.Register32 // 0x788
	HUFFENC_AC1_75 volatile.Register32 // 0x78C
	HUFFENC_AC1_76 volatile.Register32 // 0x790
	HUFFENC_AC1_77 volatile.Register32 // 0x794
	HUFFENC_AC1_78 volatile.Register32 // 0x798
	HUFFENC_AC1_79 volatile.Register32 // 0x79C
	HUFFENC_AC1_80 volatile.Register32 // 0x7A0
	HUFFENC_AC1_81 volatile.Register32 // 0x7A4
	HUFFENC_AC1_82 volatile.Register32 // 0x7A8
	HUFFENC_AC1_83 volatile.Register32 // 0x7AC
	HUFFENC_AC1_84 volatile.Register32 // 0x7B0
	HUFFENC_AC1_85 volatile.Register32 // 0x7B4
	HUFFENC_AC1_86 volatile.Register32 // 0x7B8
	HUFFENC_AC1_87 volatile.Register32 // 0x7BC
	HUFFENC_DC0_0  volatile.Register32 // 0x7C0
	HUFFENC_DC0_1  volatile.Register32 // 0x7C4
	HUFFENC_DC0_2  volatile.Register32 // 0x7C8
	HUFFENC_DC0_3  volatile.Register32 // 0x7CC
	HUFFENC_DC0_4  volatile.Register32 // 0x7D0
	HUFFENC_DC0_5  volatile.Register32 // 0x7D4
	HUFFENC_DC0_6  volatile.Register32 // 0x7D8
	HUFFENC_DC0_7  volatile.Register32 // 0x7DC
	HUFFENC_DC1_0  volatile.Register32 // 0x7E0
	HUFFENC_DC1_1  volatile.Register32 // 0x7E4
	HUFFENC_DC1_2  volatile.Register32 // 0x7E8
	HUFFENC_DC1_3  volatile.Register32 // 0x7EC
	HUFFENC_DC1_4  volatile.Register32 // 0x7F0
	HUFFENC_DC1_5  volatile.Register32 // 0x7F4
	HUFFENC_DC1_6  volatile.Register32 // 0x7F8
	HUFFENC_DC1_7  volatile.Register32 // 0x7FC
}

// JPEG.CONFR0: JPEG codec configuration register 0
func (o *JPEG_Type) SetCONFR0_START(value uint32) {
	volatile.StoreUint32(&o.CONFR0.Reg, volatile.LoadUint32(&o.CONFR0.Reg)&^(0x1)|value)
}
func (o *JPEG_Type) GetCONFR0_START() uint32 {
	return volatile.LoadUint32(&o.CONFR0.Reg) & 0x1
}

// JPEG.CONFR1: JPEG codec configuration register 1
func (o *JPEG_Type) SetCONFR1_NF(value uint32) {
	volatile.StoreUint32(&o.CONFR1.Reg, volatile.LoadUint32(&o.CONFR1.Reg)&^(0x3)|value)
}
func (o *JPEG_Type) GetCONFR1_NF() uint32 {
	return volatile.LoadUint32(&o.CONFR1.Reg) & 0x3
}
func (o *JPEG_Type) SetCONFR1_DE(value uint32) {
	volatile.StoreUint32(&o.CONFR1.Reg, volatile.LoadUint32(&o.CONFR1.Reg)&^(0x8)|value<<3)
}
func (o *JPEG_Type) GetCONFR1_DE() uint32 {
	return (volatile.LoadUint32(&o.CONFR1.Reg) & 0x8) >> 3
}
func (o *JPEG_Type) SetCONFR1_COLORSPACE(value uint32) {
	volatile.StoreUint32(&o.CONFR1.Reg, volatile.LoadUint32(&o.CONFR1.Reg)&^(0x30)|value<<4)
}
func (o *JPEG_Type) GetCONFR1_COLORSPACE() uint32 {
	return (volatile.LoadUint32(&o.CONFR1.Reg) & 0x30) >> 4
}
func (o *JPEG_Type) SetCONFR1_NS(value uint32) {
	volatile.StoreUint32(&o.CONFR1.Reg, volatile.LoadUint32(&o.CONFR1.Reg)&^(0xc0)|value<<6)
}
func (o *JPEG_Type) GetCONFR1_NS() uint32 {
	return (volatile.LoadUint32(&o.CONFR1.Reg) & 0xc0) >> 6
}
func (o *JPEG_Type) SetCONFR1_HDR(value uint32) {
	volatile.StoreUint32(&o.CONFR1.Reg, volatile.LoadUint32(&o.CONFR1.Reg)&^(0x100)|value<<8)
}
func (o *JPEG_Type) GetCONFR1_HDR() uint32 {
	return (volatile.LoadUint32(&o.CONFR1.Reg) & 0x100) >> 8
}
func (o *JPEG_Type) SetCONFR1_YSIZE(value uint32) {
	volatile.StoreUint32(&o.CONFR1.Reg, volatile.LoadUint32(&o.CONFR1.Reg)&^(0xffff0000)|value<<16)
}
func (o *JPEG_Type) GetCONFR1_YSIZE() uint32 {
	return (volatile.LoadUint32(&o.CONFR1.Reg) & 0xffff0000) >> 16
}

// JPEG.CONFR2: JPEG codec configuration register 2
func (o *JPEG_Type) SetCONFR2_NMCU(value uint32) {
	volatile.StoreUint32(&o.CONFR2.Reg, volatile.LoadUint32(&o.CONFR2.Reg)&^(0x3ffffff)|value)
}
func (o *JPEG_Type) GetCONFR2_NMCU() uint32 {
	return volatile.LoadUint32(&o.CONFR2.Reg) & 0x3ffffff
}

// JPEG.CONFR3: JPEG codec configuration register 3
func (o *JPEG_Type) SetCONFR3_XSIZE(value uint32) {
	volatile.StoreUint32(&o.CONFR3.Reg, volatile.LoadUint32(&o.CONFR3.Reg)&^(0xffff0000)|value<<16)
}
func (o *JPEG_Type) GetCONFR3_XSIZE() uint32 {
	return (volatile.LoadUint32(&o.CONFR3.Reg) & 0xffff0000) >> 16
}

// JPEG.CONFR4: JPEG codec configuration register 4
func (o *JPEG_Type) SetCONFR4_HD(value uint32) {
	volatile.StoreUint32(&o.CONFR4.Reg, volatile.LoadUint32(&o.CONFR4.Reg)&^(0x1)|value)
}
func (o *JPEG_Type) GetCONFR4_HD() uint32 {
	return volatile.LoadUint32(&o.CONFR4.Reg) & 0x1
}
func (o *JPEG_Type) SetCONFR4_HA(value uint32) {
	volatile.StoreUint32(&o.CONFR4.Reg, volatile.LoadUint32(&o.CONFR4.Reg)&^(0x2)|value<<1)
}
func (o *JPEG_Type) GetCONFR4_HA() uint32 {
	return (volatile.LoadUint32(&o.CONFR4.Reg) & 0x2) >> 1
}
func (o *JPEG_Type) SetCONFR4_QT(value uint32) {
	volatile.StoreUint32(&o.CONFR4.Reg, volatile.LoadUint32(&o.CONFR4.Reg)&^(0xc)|value<<2)
}
func (o *JPEG_Type) GetCONFR4_QT() uint32 {
	return (volatile.LoadUint32(&o.CONFR4.Reg) & 0xc) >> 2
}
func (o *JPEG_Type) SetCONFR4_NB(value uint32) {
	volatile.StoreUint32(&o.CONFR4.Reg, volatile.LoadUint32(&o.CONFR4.Reg)&^(0xf0)|value<<4)
}
func (o *JPEG_Type) GetCONFR4_NB() uint32 {
	return (volatile.LoadUint32(&o.CONFR4.Reg) & 0xf0) >> 4
}
func (o *JPEG_Type) SetCONFR4_VSF(value uint32) {
	volatile.StoreUint32(&o.CONFR4.Reg, volatile.LoadUint32(&o.CONFR4.Reg)&^(0xf00)|value<<8)
}
func (o *JPEG_Type) GetCONFR4_VSF() uint32 {
	return (volatile.LoadUint32(&o.CONFR4.Reg) & 0xf00) >> 8
}
func (o *JPEG_Type) SetCONFR4_HSF(value uint32) {
	volatile.StoreUint32(&o.CONFR4.Reg, volatile.LoadUint32(&o.CONFR4.Reg)&^(0xf000)|value<<12)
}
func (o *JPEG_Type) GetCONFR4_HSF() uint32 {
	return (volatile.LoadUint32(&o.CONFR4.Reg) & 0xf000) >> 12
}

// JPEG.CONFR5: JPEG codec configuration register 5
func (o *JPEG_Type) SetCONFR5_HD(value uint32) {
	volatile.StoreUint32(&o.CONFR5.Reg, volatile.LoadUint32(&o.CONFR5.Reg)&^(0x1)|value)
}
func (o *JPEG_Type) GetCONFR5_HD() uint32 {
	return volatile.LoadUint32(&o.CONFR5.Reg) & 0x1
}
func (o *JPEG_Type) SetCONFR5_HA(value uint32) {
	volatile.StoreUint32(&o.CONFR5.Reg, volatile.LoadUint32(&o.CONFR5.Reg)&^(0x2)|value<<1)
}
func (o *JPEG_Type) GetCONFR5_HA() uint32 {
	return (volatile.LoadUint32(&o.CONFR5.Reg) & 0x2) >> 1
}
func (o *JPEG_Type) SetCONFR5_QT(value uint32) {
	volatile.StoreUint32(&o.CONFR5.Reg, volatile.LoadUint32(&o.CONFR5.Reg)&^(0xc)|value<<2)
}
func (o *JPEG_Type) GetCONFR5_QT() uint32 {
	return (volatile.LoadUint32(&o.CONFR5.Reg) & 0xc) >> 2
}
func (o *JPEG_Type) SetCONFR5_NB(value uint32) {
	volatile.StoreUint32(&o.CONFR5.Reg, volatile.LoadUint32(&o.CONFR5.Reg)&^(0xf0)|value<<4)
}
func (o *JPEG_Type) GetCONFR5_NB() uint32 {
	return (volatile.LoadUint32(&o.CONFR5.Reg) & 0xf0) >> 4
}
func (o *JPEG_Type) SetCONFR5_VSF(value uint32) {
	volatile.StoreUint32(&o.CONFR5.Reg, volatile.LoadUint32(&o.CONFR5.Reg)&^(0xf00)|value<<8)
}
func (o *JPEG_Type) GetCONFR5_VSF() uint32 {
	return (volatile.LoadUint32(&o.CONFR5.Reg) & 0xf00) >> 8
}
func (o *JPEG_Type) SetCONFR5_HSF(value uint32) {
	volatile.StoreUint32(&o.CONFR5.Reg, volatile.LoadUint32(&o.CONFR5.Reg)&^(0xf000)|value<<12)
}
func (o *JPEG_Type) GetCONFR5_HSF() uint32 {
	return (volatile.LoadUint32(&o.CONFR5.Reg) & 0xf000) >> 12
}

// JPEG.CONFR6: JPEG codec configuration register 6
func (o *JPEG_Type) SetCONFR6_HD(value uint32) {
	volatile.StoreUint32(&o.CONFR6.Reg, volatile.LoadUint32(&o.CONFR6.Reg)&^(0x1)|value)
}
func (o *JPEG_Type) GetCONFR6_HD() uint32 {
	return volatile.LoadUint32(&o.CONFR6.Reg) & 0x1
}
func (o *JPEG_Type) SetCONFR6_HA(value uint32) {
	volatile.StoreUint32(&o.CONFR6.Reg, volatile.LoadUint32(&o.CONFR6.Reg)&^(0x2)|value<<1)
}
func (o *JPEG_Type) GetCONFR6_HA() uint32 {
	return (volatile.LoadUint32(&o.CONFR6.Reg) & 0x2) >> 1
}
func (o *JPEG_Type) SetCONFR6_QT(value uint32) {
	volatile.StoreUint32(&o.CONFR6.Reg, volatile.LoadUint32(&o.CONFR6.Reg)&^(0xc)|value<<2)
}
func (o *JPEG_Type) GetCONFR6_QT() uint32 {
	return (volatile.LoadUint32(&o.CONFR6.Reg) & 0xc) >> 2
}
func (o *JPEG_Type) SetCONFR6_NB(value uint32) {
	volatile.StoreUint32(&o.CONFR6.Reg, volatile.LoadUint32(&o.CONFR6.Reg)&^(0xf0)|value<<4)
}
func (o *JPEG_Type) GetCONFR6_NB() uint32 {
	return (volatile.LoadUint32(&o.CONFR6.Reg) & 0xf0) >> 4
}
func (o *JPEG_Type) SetCONFR6_VSF(value uint32) {
	volatile.StoreUint32(&o.CONFR6.Reg, volatile.LoadUint32(&o.CONFR6.Reg)&^(0xf00)|value<<8)
}
func (o *JPEG_Type) GetCONFR6_VSF() uint32 {
	return (volatile.LoadUint32(&o.CONFR6.Reg) & 0xf00) >> 8
}
func (o *JPEG_Type) SetCONFR6_HSF(value uint32) {
	volatile.StoreUint32(&o.CONFR6.Reg, volatile.LoadUint32(&o.CONFR6.Reg)&^(0xf000)|value<<12)
}
func (o *JPEG_Type) GetCONFR6_HSF() uint32 {
	return (volatile.LoadUint32(&o.CONFR6.Reg) & 0xf000) >> 12
}

// JPEG.CONFR7: JPEG codec configuration register 7
func (o *JPEG_Type) SetCONFR7_HD(value uint32) {
	volatile.StoreUint32(&o.CONFR7.Reg, volatile.LoadUint32(&o.CONFR7.Reg)&^(0x1)|value)
}
func (o *JPEG_Type) GetCONFR7_HD() uint32 {
	return volatile.LoadUint32(&o.CONFR7.Reg) & 0x1
}
func (o *JPEG_Type) SetCONFR7_HA(value uint32) {
	volatile.StoreUint32(&o.CONFR7.Reg, volatile.LoadUint32(&o.CONFR7.Reg)&^(0x2)|value<<1)
}
func (o *JPEG_Type) GetCONFR7_HA() uint32 {
	return (volatile.LoadUint32(&o.CONFR7.Reg) & 0x2) >> 1
}
func (o *JPEG_Type) SetCONFR7_QT(value uint32) {
	volatile.StoreUint32(&o.CONFR7.Reg, volatile.LoadUint32(&o.CONFR7.Reg)&^(0xc)|value<<2)
}
func (o *JPEG_Type) GetCONFR7_QT() uint32 {
	return (volatile.LoadUint32(&o.CONFR7.Reg) & 0xc) >> 2
}
func (o *JPEG_Type) SetCONFR7_NB(value uint32) {
	volatile.StoreUint32(&o.CONFR7.Reg, volatile.LoadUint32(&o.CONFR7.Reg)&^(0xf0)|value<<4)
}
func (o *JPEG_Type) GetCONFR7_NB() uint32 {
	return (volatile.LoadUint32(&o.CONFR7.Reg) & 0xf0) >> 4
}
func (o *JPEG_Type) SetCONFR7_VSF(value uint32) {
	volatile.StoreUint32(&o.CONFR7.Reg, volatile.LoadUint32(&o.CONFR7.Reg)&^(0xf00)|value<<8)
}
func (o *JPEG_Type) GetCONFR7_VSF() uint32 {
	return (volatile.LoadUint32(&o.CONFR7.Reg) & 0xf00) >> 8
}
func (o *JPEG_Type) SetCONFR7_HSF(value uint32) {
	volatile.StoreUint32(&o.CONFR7.Reg, volatile.LoadUint32(&o.CONFR7.Reg)&^(0xf000)|value<<12)
}
func (o *JPEG_Type) GetCONFR7_HSF() uint32 {
	return (volatile.LoadUint32(&o.CONFR7.Reg) & 0xf000) >> 12
}

// JPEG.CR: JPEG control register
func (o *JPEG_Type) SetCR_JCEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *JPEG_Type) GetCR_JCEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *JPEG_Type) SetCR_IFTIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *JPEG_Type) GetCR_IFTIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *JPEG_Type) SetCR_IFNFIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *JPEG_Type) GetCR_IFNFIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *JPEG_Type) SetCR_OFTIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *JPEG_Type) GetCR_OFTIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *JPEG_Type) SetCR_OFNEIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *JPEG_Type) GetCR_OFNEIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *JPEG_Type) SetCR_EOCIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *JPEG_Type) GetCR_EOCIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *JPEG_Type) SetCR_HPDIE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *JPEG_Type) GetCR_HPDIE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *JPEG_Type) SetCR_IDMAEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x800)|value<<11)
}
func (o *JPEG_Type) GetCR_IDMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x800) >> 11
}
func (o *JPEG_Type) SetCR_ODMAEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1000)|value<<12)
}
func (o *JPEG_Type) GetCR_ODMAEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1000) >> 12
}
func (o *JPEG_Type) SetCR_IFF(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2000)|value<<13)
}
func (o *JPEG_Type) GetCR_IFF() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2000) >> 13
}
func (o *JPEG_Type) SetCR_OFF(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4000)|value<<14)
}
func (o *JPEG_Type) GetCR_OFF() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4000) >> 14
}

// JPEG.SR: JPEG status register
func (o *JPEG_Type) SetSR_IFTF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *JPEG_Type) GetSR_IFTF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *JPEG_Type) SetSR_IFNFF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *JPEG_Type) GetSR_IFNFF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *JPEG_Type) SetSR_OFTF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *JPEG_Type) GetSR_OFTF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *JPEG_Type) SetSR_OFNEF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *JPEG_Type) GetSR_OFNEF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *JPEG_Type) SetSR_EOCF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *JPEG_Type) GetSR_EOCF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *JPEG_Type) SetSR_HPDF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *JPEG_Type) GetSR_HPDF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *JPEG_Type) SetSR_COF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *JPEG_Type) GetSR_COF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}

// JPEG.CFR: JPEG clear flag register
func (o *JPEG_Type) SetCFR_CEOCF(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x20)|value<<5)
}
func (o *JPEG_Type) GetCFR_CEOCF() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x20) >> 5
}
func (o *JPEG_Type) SetCFR_CHPDF(value uint32) {
	volatile.StoreUint32(&o.CFR.Reg, volatile.LoadUint32(&o.CFR.Reg)&^(0x40)|value<<6)
}
func (o *JPEG_Type) GetCFR_CHPDF() uint32 {
	return (volatile.LoadUint32(&o.CFR.Reg) & 0x40) >> 6
}

// JPEG.DIR: JPEG data input register
func (o *JPEG_Type) SetDIR(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, value)
}
func (o *JPEG_Type) GetDIR() uint32 {
	return volatile.LoadUint32(&o.DIR.Reg)
}

// JPEG.DOR: JPEG data output register
func (o *JPEG_Type) SetDOR(value uint32) {
	volatile.StoreUint32(&o.DOR.Reg, value)
}
func (o *JPEG_Type) GetDOR() uint32 {
	return volatile.LoadUint32(&o.DOR.Reg)
}

// JPEG.QMEM0_0: JPEG quantization tables
func (o *JPEG_Type) SetQMEM0_0(value uint32) {
	volatile.StoreUint32(&o.QMEM0_0.Reg, value)
}
func (o *JPEG_Type) GetQMEM0_0() uint32 {
	return volatile.LoadUint32(&o.QMEM0_0.Reg)
}

// JPEG.QMEM0_1: JPEG quantization tables
func (o *JPEG_Type) SetQMEM0_1(value uint32) {
	volatile.StoreUint32(&o.QMEM0_1.Reg, value)
}
func (o *JPEG_Type) GetQMEM0_1() uint32 {
	return volatile.LoadUint32(&o.QMEM0_1.Reg)
}

// JPEG.QMEM0_2: JPEG quantization tables
func (o *JPEG_Type) SetQMEM0_2(value uint32) {
	volatile.StoreUint32(&o.QMEM0_2.Reg, value)
}
func (o *JPEG_Type) GetQMEM0_2() uint32 {
	return volatile.LoadUint32(&o.QMEM0_2.Reg)
}

// JPEG.QMEM0_3: JPEG quantization tables
func (o *JPEG_Type) SetQMEM0_3(value uint32) {
	volatile.StoreUint32(&o.QMEM0_3.Reg, value)
}
func (o *JPEG_Type) GetQMEM0_3() uint32 {
	return volatile.LoadUint32(&o.QMEM0_3.Reg)
}

// JPEG.QMEM0_4: JPEG quantization tables
func (o *JPEG_Type) SetQMEM0_4(value uint32) {
	volatile.StoreUint32(&o.QMEM0_4.Reg, value)
}
func (o *JPEG_Type) GetQMEM0_4() uint32 {
	return volatile.LoadUint32(&o.QMEM0_4.Reg)
}

// JPEG.QMEM0_5: JPEG quantization tables
func (o *JPEG_Type) SetQMEM0_5(value uint32) {
	volatile.StoreUint32(&o.QMEM0_5.Reg, value)
}
func (o *JPEG_Type) GetQMEM0_5() uint32 {
	return volatile.LoadUint32(&o.QMEM0_5.Reg)
}

// JPEG.QMEM0_6: JPEG quantization tables
func (o *JPEG_Type) SetQMEM0_6(value uint32) {
	volatile.StoreUint32(&o.QMEM0_6.Reg, value)
}
func (o *JPEG_Type) GetQMEM0_6() uint32 {
	return volatile.LoadUint32(&o.QMEM0_6.Reg)
}

// JPEG.QMEM0_7: JPEG quantization tables
func (o *JPEG_Type) SetQMEM0_7(value uint32) {
	volatile.StoreUint32(&o.QMEM0_7.Reg, value)
}
func (o *JPEG_Type) GetQMEM0_7() uint32 {
	return volatile.LoadUint32(&o.QMEM0_7.Reg)
}

// JPEG.QMEM0_8: JPEG quantization tables
func (o *JPEG_Type) SetQMEM0_8(value uint32) {
	volatile.StoreUint32(&o.QMEM0_8.Reg, value)
}
func (o *JPEG_Type) GetQMEM0_8() uint32 {
	return volatile.LoadUint32(&o.QMEM0_8.Reg)
}

// JPEG.QMEM0_9: JPEG quantization tables
func (o *JPEG_Type) SetQMEM0_9(value uint32) {
	volatile.StoreUint32(&o.QMEM0_9.Reg, value)
}
func (o *JPEG_Type) GetQMEM0_9() uint32 {
	return volatile.LoadUint32(&o.QMEM0_9.Reg)
}

// JPEG.QMEM0_10: JPEG quantization tables
func (o *JPEG_Type) SetQMEM0_10(value uint32) {
	volatile.StoreUint32(&o.QMEM0_10.Reg, value)
}
func (o *JPEG_Type) GetQMEM0_10() uint32 {
	return volatile.LoadUint32(&o.QMEM0_10.Reg)
}

// JPEG.QMEM0_11: JPEG quantization tables
func (o *JPEG_Type) SetQMEM0_11(value uint32) {
	volatile.StoreUint32(&o.QMEM0_11.Reg, value)
}
func (o *JPEG_Type) GetQMEM0_11() uint32 {
	return volatile.LoadUint32(&o.QMEM0_11.Reg)
}

// JPEG.QMEM0_12: JPEG quantization tables
func (o *JPEG_Type) SetQMEM0_12(value uint32) {
	volatile.StoreUint32(&o.QMEM0_12.Reg, value)
}
func (o *JPEG_Type) GetQMEM0_12() uint32 {
	return volatile.LoadUint32(&o.QMEM0_12.Reg)
}

// JPEG.QMEM0_13: JPEG quantization tables
func (o *JPEG_Type) SetQMEM0_13(value uint32) {
	volatile.StoreUint32(&o.QMEM0_13.Reg, value)
}
func (o *JPEG_Type) GetQMEM0_13() uint32 {
	return volatile.LoadUint32(&o.QMEM0_13.Reg)
}

// JPEG.QMEM0_14: JPEG quantization tables
func (o *JPEG_Type) SetQMEM0_14(value uint32) {
	volatile.StoreUint32(&o.QMEM0_14.Reg, value)
}
func (o *JPEG_Type) GetQMEM0_14() uint32 {
	return volatile.LoadUint32(&o.QMEM0_14.Reg)
}

// JPEG.QMEM0_15: JPEG quantization tables
func (o *JPEG_Type) SetQMEM0_15(value uint32) {
	volatile.StoreUint32(&o.QMEM0_15.Reg, value)
}
func (o *JPEG_Type) GetQMEM0_15() uint32 {
	return volatile.LoadUint32(&o.QMEM0_15.Reg)
}

// JPEG.QMEM1_0: JPEG quantization tables
func (o *JPEG_Type) SetQMEM1_0(value uint32) {
	volatile.StoreUint32(&o.QMEM1_0.Reg, value)
}
func (o *JPEG_Type) GetQMEM1_0() uint32 {
	return volatile.LoadUint32(&o.QMEM1_0.Reg)
}

// JPEG.QMEM1_1: JPEG quantization tables
func (o *JPEG_Type) SetQMEM1_1(value uint32) {
	volatile.StoreUint32(&o.QMEM1_1.Reg, value)
}
func (o *JPEG_Type) GetQMEM1_1() uint32 {
	return volatile.LoadUint32(&o.QMEM1_1.Reg)
}

// JPEG.QMEM1_2: JPEG quantization tables
func (o *JPEG_Type) SetQMEM1_2(value uint32) {
	volatile.StoreUint32(&o.QMEM1_2.Reg, value)
}
func (o *JPEG_Type) GetQMEM1_2() uint32 {
	return volatile.LoadUint32(&o.QMEM1_2.Reg)
}

// JPEG.QMEM1_3: JPEG quantization tables
func (o *JPEG_Type) SetQMEM1_3(value uint32) {
	volatile.StoreUint32(&o.QMEM1_3.Reg, value)
}
func (o *JPEG_Type) GetQMEM1_3() uint32 {
	return volatile.LoadUint32(&o.QMEM1_3.Reg)
}

// JPEG.QMEM1_4: JPEG quantization tables
func (o *JPEG_Type) SetQMEM1_4(value uint32) {
	volatile.StoreUint32(&o.QMEM1_4.Reg, value)
}
func (o *JPEG_Type) GetQMEM1_4() uint32 {
	return volatile.LoadUint32(&o.QMEM1_4.Reg)
}

// JPEG.QMEM1_5: JPEG quantization tables
func (o *JPEG_Type) SetQMEM1_5(value uint32) {
	volatile.StoreUint32(&o.QMEM1_5.Reg, value)
}
func (o *JPEG_Type) GetQMEM1_5() uint32 {
	return volatile.LoadUint32(&o.QMEM1_5.Reg)
}

// JPEG.QMEM1_6: JPEG quantization tables
func (o *JPEG_Type) SetQMEM1_6(value uint32) {
	volatile.StoreUint32(&o.QMEM1_6.Reg, value)
}
func (o *JPEG_Type) GetQMEM1_6() uint32 {
	return volatile.LoadUint32(&o.QMEM1_6.Reg)
}

// JPEG.QMEM1_7: JPEG quantization tables
func (o *JPEG_Type) SetQMEM1_7(value uint32) {
	volatile.StoreUint32(&o.QMEM1_7.Reg, value)
}
func (o *JPEG_Type) GetQMEM1_7() uint32 {
	return volatile.LoadUint32(&o.QMEM1_7.Reg)
}

// JPEG.QMEM1_8: JPEG quantization tables
func (o *JPEG_Type) SetQMEM1_8(value uint32) {
	volatile.StoreUint32(&o.QMEM1_8.Reg, value)
}
func (o *JPEG_Type) GetQMEM1_8() uint32 {
	return volatile.LoadUint32(&o.QMEM1_8.Reg)
}

// JPEG.QMEM1_9: JPEG quantization tables
func (o *JPEG_Type) SetQMEM1_9(value uint32) {
	volatile.StoreUint32(&o.QMEM1_9.Reg, value)
}
func (o *JPEG_Type) GetQMEM1_9() uint32 {
	return volatile.LoadUint32(&o.QMEM1_9.Reg)
}

// JPEG.QMEM1_10: JPEG quantization tables
func (o *JPEG_Type) SetQMEM1_10(value uint32) {
	volatile.StoreUint32(&o.QMEM1_10.Reg, value)
}
func (o *JPEG_Type) GetQMEM1_10() uint32 {
	return volatile.LoadUint32(&o.QMEM1_10.Reg)
}

// JPEG.QMEM1_11: JPEG quantization tables
func (o *JPEG_Type) SetQMEM1_11(value uint32) {
	volatile.StoreUint32(&o.QMEM1_11.Reg, value)
}
func (o *JPEG_Type) GetQMEM1_11() uint32 {
	return volatile.LoadUint32(&o.QMEM1_11.Reg)
}

// JPEG.QMEM1_12: JPEG quantization tables
func (o *JPEG_Type) SetQMEM1_12(value uint32) {
	volatile.StoreUint32(&o.QMEM1_12.Reg, value)
}
func (o *JPEG_Type) GetQMEM1_12() uint32 {
	return volatile.LoadUint32(&o.QMEM1_12.Reg)
}

// JPEG.QMEM1_13: JPEG quantization tables
func (o *JPEG_Type) SetQMEM1_13(value uint32) {
	volatile.StoreUint32(&o.QMEM1_13.Reg, value)
}
func (o *JPEG_Type) GetQMEM1_13() uint32 {
	return volatile.LoadUint32(&o.QMEM1_13.Reg)
}

// JPEG.QMEM1_14: JPEG quantization tables
func (o *JPEG_Type) SetQMEM1_14(value uint32) {
	volatile.StoreUint32(&o.QMEM1_14.Reg, value)
}
func (o *JPEG_Type) GetQMEM1_14() uint32 {
	return volatile.LoadUint32(&o.QMEM1_14.Reg)
}

// JPEG.QMEM1_15: JPEG quantization tables
func (o *JPEG_Type) SetQMEM1_15(value uint32) {
	volatile.StoreUint32(&o.QMEM1_15.Reg, value)
}
func (o *JPEG_Type) GetQMEM1_15() uint32 {
	return volatile.LoadUint32(&o.QMEM1_15.Reg)
}

// JPEG.QMEM2_0: JPEG quantization tables
func (o *JPEG_Type) SetQMEM2_0(value uint32) {
	volatile.StoreUint32(&o.QMEM2_0.Reg, value)
}
func (o *JPEG_Type) GetQMEM2_0() uint32 {
	return volatile.LoadUint32(&o.QMEM2_0.Reg)
}

// JPEG.QMEM2_1: JPEG quantization tables
func (o *JPEG_Type) SetQMEM2_1(value uint32) {
	volatile.StoreUint32(&o.QMEM2_1.Reg, value)
}
func (o *JPEG_Type) GetQMEM2_1() uint32 {
	return volatile.LoadUint32(&o.QMEM2_1.Reg)
}

// JPEG.QMEM2_2: JPEG quantization tables
func (o *JPEG_Type) SetQMEM2_2(value uint32) {
	volatile.StoreUint32(&o.QMEM2_2.Reg, value)
}
func (o *JPEG_Type) GetQMEM2_2() uint32 {
	return volatile.LoadUint32(&o.QMEM2_2.Reg)
}

// JPEG.QMEM2_3: JPEG quantization tables
func (o *JPEG_Type) SetQMEM2_3(value uint32) {
	volatile.StoreUint32(&o.QMEM2_3.Reg, value)
}
func (o *JPEG_Type) GetQMEM2_3() uint32 {
	return volatile.LoadUint32(&o.QMEM2_3.Reg)
}

// JPEG.QMEM2_4: JPEG quantization tables
func (o *JPEG_Type) SetQMEM2_4(value uint32) {
	volatile.StoreUint32(&o.QMEM2_4.Reg, value)
}
func (o *JPEG_Type) GetQMEM2_4() uint32 {
	return volatile.LoadUint32(&o.QMEM2_4.Reg)
}

// JPEG.QMEM2_5: JPEG quantization tables
func (o *JPEG_Type) SetQMEM2_5(value uint32) {
	volatile.StoreUint32(&o.QMEM2_5.Reg, value)
}
func (o *JPEG_Type) GetQMEM2_5() uint32 {
	return volatile.LoadUint32(&o.QMEM2_5.Reg)
}

// JPEG.QMEM2_6: JPEG quantization tables
func (o *JPEG_Type) SetQMEM2_6(value uint32) {
	volatile.StoreUint32(&o.QMEM2_6.Reg, value)
}
func (o *JPEG_Type) GetQMEM2_6() uint32 {
	return volatile.LoadUint32(&o.QMEM2_6.Reg)
}

// JPEG.QMEM2_7: JPEG quantization tables
func (o *JPEG_Type) SetQMEM2_7(value uint32) {
	volatile.StoreUint32(&o.QMEM2_7.Reg, value)
}
func (o *JPEG_Type) GetQMEM2_7() uint32 {
	return volatile.LoadUint32(&o.QMEM2_7.Reg)
}

// JPEG.QMEM2_8: JPEG quantization tables
func (o *JPEG_Type) SetQMEM2_8(value uint32) {
	volatile.StoreUint32(&o.QMEM2_8.Reg, value)
}
func (o *JPEG_Type) GetQMEM2_8() uint32 {
	return volatile.LoadUint32(&o.QMEM2_8.Reg)
}

// JPEG.QMEM2_9: JPEG quantization tables
func (o *JPEG_Type) SetQMEM2_9(value uint32) {
	volatile.StoreUint32(&o.QMEM2_9.Reg, value)
}
func (o *JPEG_Type) GetQMEM2_9() uint32 {
	return volatile.LoadUint32(&o.QMEM2_9.Reg)
}

// JPEG.QMEM2_10: JPEG quantization tables
func (o *JPEG_Type) SetQMEM2_10(value uint32) {
	volatile.StoreUint32(&o.QMEM2_10.Reg, value)
}
func (o *JPEG_Type) GetQMEM2_10() uint32 {
	return volatile.LoadUint32(&o.QMEM2_10.Reg)
}

// JPEG.QMEM2_11: JPEG quantization tables
func (o *JPEG_Type) SetQMEM2_11(value uint32) {
	volatile.StoreUint32(&o.QMEM2_11.Reg, value)
}
func (o *JPEG_Type) GetQMEM2_11() uint32 {
	return volatile.LoadUint32(&o.QMEM2_11.Reg)
}

// JPEG.QMEM2_12: JPEG quantization tables
func (o *JPEG_Type) SetQMEM2_12(value uint32) {
	volatile.StoreUint32(&o.QMEM2_12.Reg, value)
}
func (o *JPEG_Type) GetQMEM2_12() uint32 {
	return volatile.LoadUint32(&o.QMEM2_12.Reg)
}

// JPEG.QMEM2_13: JPEG quantization tables
func (o *JPEG_Type) SetQMEM2_13(value uint32) {
	volatile.StoreUint32(&o.QMEM2_13.Reg, value)
}
func (o *JPEG_Type) GetQMEM2_13() uint32 {
	return volatile.LoadUint32(&o.QMEM2_13.Reg)
}

// JPEG.QMEM2_14: JPEG quantization tables
func (o *JPEG_Type) SetQMEM2_14(value uint32) {
	volatile.StoreUint32(&o.QMEM2_14.Reg, value)
}
func (o *JPEG_Type) GetQMEM2_14() uint32 {
	return volatile.LoadUint32(&o.QMEM2_14.Reg)
}

// JPEG.QMEM2_15: JPEG quantization tables
func (o *JPEG_Type) SetQMEM2_15(value uint32) {
	volatile.StoreUint32(&o.QMEM2_15.Reg, value)
}
func (o *JPEG_Type) GetQMEM2_15() uint32 {
	return volatile.LoadUint32(&o.QMEM2_15.Reg)
}

// JPEG.QMEM3_0: JPEG quantization tables
func (o *JPEG_Type) SetQMEM3_0(value uint32) {
	volatile.StoreUint32(&o.QMEM3_0.Reg, value)
}
func (o *JPEG_Type) GetQMEM3_0() uint32 {
	return volatile.LoadUint32(&o.QMEM3_0.Reg)
}

// JPEG.QMEM3_1: JPEG quantization tables
func (o *JPEG_Type) SetQMEM3_1(value uint32) {
	volatile.StoreUint32(&o.QMEM3_1.Reg, value)
}
func (o *JPEG_Type) GetQMEM3_1() uint32 {
	return volatile.LoadUint32(&o.QMEM3_1.Reg)
}

// JPEG.QMEM3_2: JPEG quantization tables
func (o *JPEG_Type) SetQMEM3_2(value uint32) {
	volatile.StoreUint32(&o.QMEM3_2.Reg, value)
}
func (o *JPEG_Type) GetQMEM3_2() uint32 {
	return volatile.LoadUint32(&o.QMEM3_2.Reg)
}

// JPEG.QMEM3_3: JPEG quantization tables
func (o *JPEG_Type) SetQMEM3_3(value uint32) {
	volatile.StoreUint32(&o.QMEM3_3.Reg, value)
}
func (o *JPEG_Type) GetQMEM3_3() uint32 {
	return volatile.LoadUint32(&o.QMEM3_3.Reg)
}

// JPEG.QMEM3_4: JPEG quantization tables
func (o *JPEG_Type) SetQMEM3_4(value uint32) {
	volatile.StoreUint32(&o.QMEM3_4.Reg, value)
}
func (o *JPEG_Type) GetQMEM3_4() uint32 {
	return volatile.LoadUint32(&o.QMEM3_4.Reg)
}

// JPEG.QMEM3_5: JPEG quantization tables
func (o *JPEG_Type) SetQMEM3_5(value uint32) {
	volatile.StoreUint32(&o.QMEM3_5.Reg, value)
}
func (o *JPEG_Type) GetQMEM3_5() uint32 {
	return volatile.LoadUint32(&o.QMEM3_5.Reg)
}

// JPEG.QMEM3_6: JPEG quantization tables
func (o *JPEG_Type) SetQMEM3_6(value uint32) {
	volatile.StoreUint32(&o.QMEM3_6.Reg, value)
}
func (o *JPEG_Type) GetQMEM3_6() uint32 {
	return volatile.LoadUint32(&o.QMEM3_6.Reg)
}

// JPEG.QMEM3_7: JPEG quantization tables
func (o *JPEG_Type) SetQMEM3_7(value uint32) {
	volatile.StoreUint32(&o.QMEM3_7.Reg, value)
}
func (o *JPEG_Type) GetQMEM3_7() uint32 {
	return volatile.LoadUint32(&o.QMEM3_7.Reg)
}

// JPEG.QMEM3_8: JPEG quantization tables
func (o *JPEG_Type) SetQMEM3_8(value uint32) {
	volatile.StoreUint32(&o.QMEM3_8.Reg, value)
}
func (o *JPEG_Type) GetQMEM3_8() uint32 {
	return volatile.LoadUint32(&o.QMEM3_8.Reg)
}

// JPEG.QMEM3_9: JPEG quantization tables
func (o *JPEG_Type) SetQMEM3_9(value uint32) {
	volatile.StoreUint32(&o.QMEM3_9.Reg, value)
}
func (o *JPEG_Type) GetQMEM3_9() uint32 {
	return volatile.LoadUint32(&o.QMEM3_9.Reg)
}

// JPEG.QMEM3_10: JPEG quantization tables
func (o *JPEG_Type) SetQMEM3_10(value uint32) {
	volatile.StoreUint32(&o.QMEM3_10.Reg, value)
}
func (o *JPEG_Type) GetQMEM3_10() uint32 {
	return volatile.LoadUint32(&o.QMEM3_10.Reg)
}

// JPEG.QMEM3_11: JPEG quantization tables
func (o *JPEG_Type) SetQMEM3_11(value uint32) {
	volatile.StoreUint32(&o.QMEM3_11.Reg, value)
}
func (o *JPEG_Type) GetQMEM3_11() uint32 {
	return volatile.LoadUint32(&o.QMEM3_11.Reg)
}

// JPEG.QMEM3_12: JPEG quantization tables
func (o *JPEG_Type) SetQMEM3_12(value uint32) {
	volatile.StoreUint32(&o.QMEM3_12.Reg, value)
}
func (o *JPEG_Type) GetQMEM3_12() uint32 {
	return volatile.LoadUint32(&o.QMEM3_12.Reg)
}

// JPEG.QMEM3_13: JPEG quantization tables
func (o *JPEG_Type) SetQMEM3_13(value uint32) {
	volatile.StoreUint32(&o.QMEM3_13.Reg, value)
}
func (o *JPEG_Type) GetQMEM3_13() uint32 {
	return volatile.LoadUint32(&o.QMEM3_13.Reg)
}

// JPEG.QMEM3_14: JPEG quantization tables
func (o *JPEG_Type) SetQMEM3_14(value uint32) {
	volatile.StoreUint32(&o.QMEM3_14.Reg, value)
}
func (o *JPEG_Type) GetQMEM3_14() uint32 {
	return volatile.LoadUint32(&o.QMEM3_14.Reg)
}

// JPEG.QMEM3_15: JPEG quantization tables
func (o *JPEG_Type) SetQMEM3_15(value uint32) {
	volatile.StoreUint32(&o.QMEM3_15.Reg, value)
}
func (o *JPEG_Type) GetQMEM3_15() uint32 {
	return volatile.LoadUint32(&o.QMEM3_15.Reg)
}

// JPEG.HUFFMIN_0: JPEG HuffMin tables
func (o *JPEG_Type) SetHUFFMIN_0(value uint32) {
	volatile.StoreUint32(&o.HUFFMIN_0.Reg, value)
}
func (o *JPEG_Type) GetHUFFMIN_0() uint32 {
	return volatile.LoadUint32(&o.HUFFMIN_0.Reg)
}

// JPEG.HUFFMIN_1: JPEG HuffMin tables
func (o *JPEG_Type) SetHUFFMIN_1(value uint32) {
	volatile.StoreUint32(&o.HUFFMIN_1.Reg, value)
}
func (o *JPEG_Type) GetHUFFMIN_1() uint32 {
	return volatile.LoadUint32(&o.HUFFMIN_1.Reg)
}

// JPEG.HUFFMIN_2: JPEG HuffMin tables
func (o *JPEG_Type) SetHUFFMIN_2(value uint32) {
	volatile.StoreUint32(&o.HUFFMIN_2.Reg, value)
}
func (o *JPEG_Type) GetHUFFMIN_2() uint32 {
	return volatile.LoadUint32(&o.HUFFMIN_2.Reg)
}

// JPEG.HUFFMIN_3: JPEG HuffMin tables
func (o *JPEG_Type) SetHUFFMIN_3(value uint32) {
	volatile.StoreUint32(&o.HUFFMIN_3.Reg, value)
}
func (o *JPEG_Type) GetHUFFMIN_3() uint32 {
	return volatile.LoadUint32(&o.HUFFMIN_3.Reg)
}

// JPEG.HUFFMIN_4: JPEG HuffMin tables
func (o *JPEG_Type) SetHUFFMIN_4(value uint32) {
	volatile.StoreUint32(&o.HUFFMIN_4.Reg, value)
}
func (o *JPEG_Type) GetHUFFMIN_4() uint32 {
	return volatile.LoadUint32(&o.HUFFMIN_4.Reg)
}

// JPEG.HUFFMIN_5: JPEG HuffMin tables
func (o *JPEG_Type) SetHUFFMIN_5(value uint32) {
	volatile.StoreUint32(&o.HUFFMIN_5.Reg, value)
}
func (o *JPEG_Type) GetHUFFMIN_5() uint32 {
	return volatile.LoadUint32(&o.HUFFMIN_5.Reg)
}

// JPEG.HUFFMIN_6: JPEG HuffMin tables
func (o *JPEG_Type) SetHUFFMIN_6(value uint32) {
	volatile.StoreUint32(&o.HUFFMIN_6.Reg, value)
}
func (o *JPEG_Type) GetHUFFMIN_6() uint32 {
	return volatile.LoadUint32(&o.HUFFMIN_6.Reg)
}

// JPEG.HUFFMIN_7: JPEG HuffMin tables
func (o *JPEG_Type) SetHUFFMIN_7(value uint32) {
	volatile.StoreUint32(&o.HUFFMIN_7.Reg, value)
}
func (o *JPEG_Type) GetHUFFMIN_7() uint32 {
	return volatile.LoadUint32(&o.HUFFMIN_7.Reg)
}

// JPEG.HUFFMIN_8: JPEG HuffMin tables
func (o *JPEG_Type) SetHUFFMIN_8(value uint32) {
	volatile.StoreUint32(&o.HUFFMIN_8.Reg, value)
}
func (o *JPEG_Type) GetHUFFMIN_8() uint32 {
	return volatile.LoadUint32(&o.HUFFMIN_8.Reg)
}

// JPEG.HUFFMIN_9: JPEG HuffMin tables
func (o *JPEG_Type) SetHUFFMIN_9(value uint32) {
	volatile.StoreUint32(&o.HUFFMIN_9.Reg, value)
}
func (o *JPEG_Type) GetHUFFMIN_9() uint32 {
	return volatile.LoadUint32(&o.HUFFMIN_9.Reg)
}

// JPEG.HUFFMIN_10: JPEG HuffMin tables
func (o *JPEG_Type) SetHUFFMIN_10(value uint32) {
	volatile.StoreUint32(&o.HUFFMIN_10.Reg, value)
}
func (o *JPEG_Type) GetHUFFMIN_10() uint32 {
	return volatile.LoadUint32(&o.HUFFMIN_10.Reg)
}

// JPEG.HUFFMIN_11: JPEG HuffMin tables
func (o *JPEG_Type) SetHUFFMIN_11(value uint32) {
	volatile.StoreUint32(&o.HUFFMIN_11.Reg, value)
}
func (o *JPEG_Type) GetHUFFMIN_11() uint32 {
	return volatile.LoadUint32(&o.HUFFMIN_11.Reg)
}

// JPEG.HUFFMIN_12: JPEG HuffMin tables
func (o *JPEG_Type) SetHUFFMIN_12(value uint32) {
	volatile.StoreUint32(&o.HUFFMIN_12.Reg, value)
}
func (o *JPEG_Type) GetHUFFMIN_12() uint32 {
	return volatile.LoadUint32(&o.HUFFMIN_12.Reg)
}

// JPEG.HUFFMIN_13: JPEG HuffMin tables
func (o *JPEG_Type) SetHUFFMIN_13(value uint32) {
	volatile.StoreUint32(&o.HUFFMIN_13.Reg, value)
}
func (o *JPEG_Type) GetHUFFMIN_13() uint32 {
	return volatile.LoadUint32(&o.HUFFMIN_13.Reg)
}

// JPEG.HUFFMIN_14: JPEG HuffMin tables
func (o *JPEG_Type) SetHUFFMIN_14(value uint32) {
	volatile.StoreUint32(&o.HUFFMIN_14.Reg, value)
}
func (o *JPEG_Type) GetHUFFMIN_14() uint32 {
	return volatile.LoadUint32(&o.HUFFMIN_14.Reg)
}

// JPEG.HUFFMIN_15: JPEG HuffMin tables
func (o *JPEG_Type) SetHUFFMIN_15(value uint32) {
	volatile.StoreUint32(&o.HUFFMIN_15.Reg, value)
}
func (o *JPEG_Type) GetHUFFMIN_15() uint32 {
	return volatile.LoadUint32(&o.HUFFMIN_15.Reg)
}

// JPEG.HUFFBASE0: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE0_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE0.Reg, volatile.LoadUint32(&o.HUFFBASE0.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE0_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE0.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE0_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE0.Reg, volatile.LoadUint32(&o.HUFFBASE0.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE0_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE0.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE1: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE1_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE1.Reg, volatile.LoadUint32(&o.HUFFBASE1.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE1_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE1.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE1_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE1.Reg, volatile.LoadUint32(&o.HUFFBASE1.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE1_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE1.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE2: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE2_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE2.Reg, volatile.LoadUint32(&o.HUFFBASE2.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE2_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE2.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE2_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE2.Reg, volatile.LoadUint32(&o.HUFFBASE2.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE2_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE2.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE3: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE3_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE3.Reg, volatile.LoadUint32(&o.HUFFBASE3.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE3_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE3.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE3_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE3.Reg, volatile.LoadUint32(&o.HUFFBASE3.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE3_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE3.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE4: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE4_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE4.Reg, volatile.LoadUint32(&o.HUFFBASE4.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE4_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE4.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE4_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE4.Reg, volatile.LoadUint32(&o.HUFFBASE4.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE4_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE4.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE5: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE5_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE5.Reg, volatile.LoadUint32(&o.HUFFBASE5.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE5_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE5.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE5_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE5.Reg, volatile.LoadUint32(&o.HUFFBASE5.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE5_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE5.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE6: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE6_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE6.Reg, volatile.LoadUint32(&o.HUFFBASE6.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE6_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE6.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE6_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE6.Reg, volatile.LoadUint32(&o.HUFFBASE6.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE6_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE6.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE7: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE7_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE7.Reg, volatile.LoadUint32(&o.HUFFBASE7.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE7_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE7.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE7_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE7.Reg, volatile.LoadUint32(&o.HUFFBASE7.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE7_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE7.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE8: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE8_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE8.Reg, volatile.LoadUint32(&o.HUFFBASE8.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE8_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE8.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE8_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE8.Reg, volatile.LoadUint32(&o.HUFFBASE8.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE8_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE8.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE9: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE9_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE9.Reg, volatile.LoadUint32(&o.HUFFBASE9.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE9_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE9.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE9_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE9.Reg, volatile.LoadUint32(&o.HUFFBASE9.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE9_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE9.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE10: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE10_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE10.Reg, volatile.LoadUint32(&o.HUFFBASE10.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE10_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE10.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE10_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE10.Reg, volatile.LoadUint32(&o.HUFFBASE10.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE10_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE10.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE11: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE11_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE11.Reg, volatile.LoadUint32(&o.HUFFBASE11.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE11_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE11.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE11_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE11.Reg, volatile.LoadUint32(&o.HUFFBASE11.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE11_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE11.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE12: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE12_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE12.Reg, volatile.LoadUint32(&o.HUFFBASE12.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE12_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE12.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE12_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE12.Reg, volatile.LoadUint32(&o.HUFFBASE12.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE12_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE12.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE13: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE13_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE13.Reg, volatile.LoadUint32(&o.HUFFBASE13.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE13_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE13.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE13_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE13.Reg, volatile.LoadUint32(&o.HUFFBASE13.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE13_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE13.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE14: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE14_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE14.Reg, volatile.LoadUint32(&o.HUFFBASE14.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE14_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE14.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE14_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE14.Reg, volatile.LoadUint32(&o.HUFFBASE14.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE14_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE14.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE15: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE15_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE15.Reg, volatile.LoadUint32(&o.HUFFBASE15.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE15_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE15.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE15_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE15.Reg, volatile.LoadUint32(&o.HUFFBASE15.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE15_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE15.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE16: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE16_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE16.Reg, volatile.LoadUint32(&o.HUFFBASE16.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE16_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE16.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE16_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE16.Reg, volatile.LoadUint32(&o.HUFFBASE16.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE16_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE16.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE17: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE17_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE17.Reg, volatile.LoadUint32(&o.HUFFBASE17.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE17_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE17.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE17_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE17.Reg, volatile.LoadUint32(&o.HUFFBASE17.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE17_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE17.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE18: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE18_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE18.Reg, volatile.LoadUint32(&o.HUFFBASE18.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE18_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE18.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE18_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE18.Reg, volatile.LoadUint32(&o.HUFFBASE18.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE18_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE18.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE19: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE19_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE19.Reg, volatile.LoadUint32(&o.HUFFBASE19.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE19_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE19.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE19_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE19.Reg, volatile.LoadUint32(&o.HUFFBASE19.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE19_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE19.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE20: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE20_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE20.Reg, volatile.LoadUint32(&o.HUFFBASE20.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE20_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE20.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE20_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE20.Reg, volatile.LoadUint32(&o.HUFFBASE20.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE20_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE20.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE21: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE21_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE21.Reg, volatile.LoadUint32(&o.HUFFBASE21.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE21_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE21.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE21_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE21.Reg, volatile.LoadUint32(&o.HUFFBASE21.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE21_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE21.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE22: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE22_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE22.Reg, volatile.LoadUint32(&o.HUFFBASE22.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE22_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE22.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE22_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE22.Reg, volatile.LoadUint32(&o.HUFFBASE22.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE22_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE22.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE23: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE23_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE23.Reg, volatile.LoadUint32(&o.HUFFBASE23.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE23_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE23.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE23_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE23.Reg, volatile.LoadUint32(&o.HUFFBASE23.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE23_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE23.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE24: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE24_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE24.Reg, volatile.LoadUint32(&o.HUFFBASE24.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE24_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE24.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE24_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE24.Reg, volatile.LoadUint32(&o.HUFFBASE24.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE24_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE24.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE25: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE25_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE25.Reg, volatile.LoadUint32(&o.HUFFBASE25.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE25_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE25.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE25_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE25.Reg, volatile.LoadUint32(&o.HUFFBASE25.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE25_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE25.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE26: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE26_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE26.Reg, volatile.LoadUint32(&o.HUFFBASE26.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE26_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE26.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE26_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE26.Reg, volatile.LoadUint32(&o.HUFFBASE26.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE26_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE26.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE27: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE27_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE27.Reg, volatile.LoadUint32(&o.HUFFBASE27.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE27_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE27.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE27_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE27.Reg, volatile.LoadUint32(&o.HUFFBASE27.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE27_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE27.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE28: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE28_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE28.Reg, volatile.LoadUint32(&o.HUFFBASE28.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE28_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE28.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE28_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE28.Reg, volatile.LoadUint32(&o.HUFFBASE28.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE28_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE28.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE29: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE29_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE29.Reg, volatile.LoadUint32(&o.HUFFBASE29.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE29_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE29.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE29_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE29.Reg, volatile.LoadUint32(&o.HUFFBASE29.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE29_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE29.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE30: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE30_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE30.Reg, volatile.LoadUint32(&o.HUFFBASE30.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE30_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE30.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE30_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE30.Reg, volatile.LoadUint32(&o.HUFFBASE30.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE30_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE30.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFBASE31: JPEG HuffSymb tables
func (o *JPEG_Type) SetHUFFBASE31_HuffBase_RAM_0(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE31.Reg, volatile.LoadUint32(&o.HUFFBASE31.Reg)&^(0x1ff)|value)
}
func (o *JPEG_Type) GetHUFFBASE31_HuffBase_RAM_0() uint32 {
	return volatile.LoadUint32(&o.HUFFBASE31.Reg) & 0x1ff
}
func (o *JPEG_Type) SetHUFFBASE31_HuffBase_RAM_1(value uint32) {
	volatile.StoreUint32(&o.HUFFBASE31.Reg, volatile.LoadUint32(&o.HUFFBASE31.Reg)&^(0x1ff0000)|value<<16)
}
func (o *JPEG_Type) GetHUFFBASE31_HuffBase_RAM_1() uint32 {
	return (volatile.LoadUint32(&o.HUFFBASE31.Reg) & 0x1ff0000) >> 16
}

// JPEG.HUFFSYMB0: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB0(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB0.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB0() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB0.Reg)
}

// JPEG.HUFFSYMB1: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB1(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB1.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB1() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB1.Reg)
}

// JPEG.HUFFSYMB2: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB2(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB2.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB2() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB2.Reg)
}

// JPEG.HUFFSYMB3: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB3(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB3.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB3() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB3.Reg)
}

// JPEG.HUFFSYMB4: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB4(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB4.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB4() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB4.Reg)
}

// JPEG.HUFFSYMB5: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB5(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB5.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB5() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB5.Reg)
}

// JPEG.HUFFSYMB6: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB6(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB6.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB6() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB6.Reg)
}

// JPEG.HUFFSYMB7: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB7(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB7.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB7() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB7.Reg)
}

// JPEG.HUFFSYMB8: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB8(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB8.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB8() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB8.Reg)
}

// JPEG.HUFFSYMB9: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB9(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB9.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB9() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB9.Reg)
}

// JPEG.HUFFSYMB10: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB10(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB10.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB10() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB10.Reg)
}

// JPEG.HUFFSYMB11: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB11(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB11.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB11() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB11.Reg)
}

// JPEG.HUFFSYMB12: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB12(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB12.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB12() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB12.Reg)
}

// JPEG.HUFFSYMB13: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB13(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB13.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB13() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB13.Reg)
}

// JPEG.HUFFSYMB14: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB14(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB14.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB14() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB14.Reg)
}

// JPEG.HUFFSYMB15: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB15(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB15.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB15() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB15.Reg)
}

// JPEG.HUFFSYMB16: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB16(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB16.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB16() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB16.Reg)
}

// JPEG.HUFFSYMB17: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB17(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB17.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB17() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB17.Reg)
}

// JPEG.HUFFSYMB18: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB18(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB18.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB18() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB18.Reg)
}

// JPEG.HUFFSYMB19: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB19(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB19.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB19() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB19.Reg)
}

// JPEG.HUFFSYMB20: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB20(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB20.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB20() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB20.Reg)
}

// JPEG.HUFFSYMB21: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB21(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB21.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB21() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB21.Reg)
}

// JPEG.HUFFSYMB22: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB22(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB22.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB22() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB22.Reg)
}

// JPEG.HUFFSYMB23: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB23(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB23.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB23() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB23.Reg)
}

// JPEG.HUFFSYMB24: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB24(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB24.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB24() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB24.Reg)
}

// JPEG.HUFFSYMB25: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB25(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB25.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB25() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB25.Reg)
}

// JPEG.HUFFSYMB26: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB26(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB26.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB26() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB26.Reg)
}

// JPEG.HUFFSYMB27: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB27(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB27.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB27() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB27.Reg)
}

// JPEG.HUFFSYMB28: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB28(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB28.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB28() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB28.Reg)
}

// JPEG.HUFFSYMB29: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB29(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB29.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB29() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB29.Reg)
}

// JPEG.HUFFSYMB30: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB30(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB30.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB30() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB30.Reg)
}

// JPEG.HUFFSYMB31: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB31(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB31.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB31() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB31.Reg)
}

// JPEG.HUFFSYMB32: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB32(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB32.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB32() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB32.Reg)
}

// JPEG.HUFFSYMB33: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB33(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB33.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB33() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB33.Reg)
}

// JPEG.HUFFSYMB34: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB34(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB34.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB34() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB34.Reg)
}

// JPEG.HUFFSYMB35: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB35(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB35.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB35() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB35.Reg)
}

// JPEG.HUFFSYMB36: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB36(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB36.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB36() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB36.Reg)
}

// JPEG.HUFFSYMB37: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB37(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB37.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB37() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB37.Reg)
}

// JPEG.HUFFSYMB38: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB38(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB38.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB38() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB38.Reg)
}

// JPEG.HUFFSYMB39: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB39(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB39.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB39() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB39.Reg)
}

// JPEG.HUFFSYMB40: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB40(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB40.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB40() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB40.Reg)
}

// JPEG.HUFFSYMB41: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB41(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB41.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB41() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB41.Reg)
}

// JPEG.HUFFSYMB42: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB42(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB42.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB42() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB42.Reg)
}

// JPEG.HUFFSYMB43: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB43(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB43.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB43() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB43.Reg)
}

// JPEG.HUFFSYMB44: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB44(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB44.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB44() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB44.Reg)
}

// JPEG.HUFFSYMB45: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB45(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB45.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB45() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB45.Reg)
}

// JPEG.HUFFSYMB46: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB46(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB46.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB46() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB46.Reg)
}

// JPEG.HUFFSYMB47: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB47(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB47.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB47() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB47.Reg)
}

// JPEG.HUFFSYMB48: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB48(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB48.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB48() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB48.Reg)
}

// JPEG.HUFFSYMB49: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB49(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB49.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB49() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB49.Reg)
}

// JPEG.HUFFSYMB50: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB50(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB50.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB50() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB50.Reg)
}

// JPEG.HUFFSYMB51: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB51(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB51.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB51() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB51.Reg)
}

// JPEG.HUFFSYMB52: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB52(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB52.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB52() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB52.Reg)
}

// JPEG.HUFFSYMB53: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB53(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB53.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB53() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB53.Reg)
}

// JPEG.HUFFSYMB54: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB54(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB54.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB54() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB54.Reg)
}

// JPEG.HUFFSYMB55: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB55(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB55.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB55() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB55.Reg)
}

// JPEG.HUFFSYMB56: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB56(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB56.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB56() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB56.Reg)
}

// JPEG.HUFFSYMB57: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB57(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB57.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB57() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB57.Reg)
}

// JPEG.HUFFSYMB58: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB58(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB58.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB58() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB58.Reg)
}

// JPEG.HUFFSYMB59: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB59(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB59.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB59() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB59.Reg)
}

// JPEG.HUFFSYMB60: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB60(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB60.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB60() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB60.Reg)
}

// JPEG.HUFFSYMB61: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB61(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB61.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB61() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB61.Reg)
}

// JPEG.HUFFSYMB62: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB62(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB62.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB62() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB62.Reg)
}

// JPEG.HUFFSYMB63: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB63(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB63.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB63() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB63.Reg)
}

// JPEG.HUFFSYMB64: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB64(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB64.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB64() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB64.Reg)
}

// JPEG.HUFFSYMB65: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB65(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB65.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB65() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB65.Reg)
}

// JPEG.HUFFSYMB66: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB66(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB66.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB66() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB66.Reg)
}

// JPEG.HUFFSYMB67: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB67(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB67.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB67() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB67.Reg)
}

// JPEG.HUFFSYMB68: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB68(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB68.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB68() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB68.Reg)
}

// JPEG.HUFFSYMB69: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB69(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB69.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB69() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB69.Reg)
}

// JPEG.HUFFSYMB70: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB70(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB70.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB70() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB70.Reg)
}

// JPEG.HUFFSYMB71: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB71(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB71.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB71() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB71.Reg)
}

// JPEG.HUFFSYMB72: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB72(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB72.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB72() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB72.Reg)
}

// JPEG.HUFFSYMB73: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB73(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB73.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB73() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB73.Reg)
}

// JPEG.HUFFSYMB74: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB74(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB74.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB74() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB74.Reg)
}

// JPEG.HUFFSYMB75: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB75(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB75.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB75() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB75.Reg)
}

// JPEG.HUFFSYMB76: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB76(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB76.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB76() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB76.Reg)
}

// JPEG.HUFFSYMB77: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB77(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB77.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB77() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB77.Reg)
}

// JPEG.HUFFSYMB78: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB78(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB78.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB78() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB78.Reg)
}

// JPEG.HUFFSYMB79: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB79(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB79.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB79() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB79.Reg)
}

// JPEG.HUFFSYMB80: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB80(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB80.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB80() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB80.Reg)
}

// JPEG.HUFFSYMB81: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB81(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB81.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB81() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB81.Reg)
}

// JPEG.HUFFSYMB82: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB82(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB82.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB82() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB82.Reg)
}

// JPEG.HUFFSYMB83: JPEG HUFFSYMB tables
func (o *JPEG_Type) SetHUFFSYMB83(value uint32) {
	volatile.StoreUint32(&o.HUFFSYMB83.Reg, value)
}
func (o *JPEG_Type) GetHUFFSYMB83() uint32 {
	return volatile.LoadUint32(&o.HUFFSYMB83.Reg)
}

// JPEG.DHTMEM0: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM0(value uint32) {
	volatile.StoreUint32(&o.DHTMEM0.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM0() uint32 {
	return volatile.LoadUint32(&o.DHTMEM0.Reg)
}

// JPEG.DHTMEM2: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM2(value uint32) {
	volatile.StoreUint32(&o.DHTMEM2.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM2() uint32 {
	return volatile.LoadUint32(&o.DHTMEM2.Reg)
}

// JPEG.DHTMEM3: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM3(value uint32) {
	volatile.StoreUint32(&o.DHTMEM3.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM3() uint32 {
	return volatile.LoadUint32(&o.DHTMEM3.Reg)
}

// JPEG.DHTMEM4: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM4(value uint32) {
	volatile.StoreUint32(&o.DHTMEM4.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM4() uint32 {
	return volatile.LoadUint32(&o.DHTMEM4.Reg)
}

// JPEG.DHTMEM5: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM5(value uint32) {
	volatile.StoreUint32(&o.DHTMEM5.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM5() uint32 {
	return volatile.LoadUint32(&o.DHTMEM5.Reg)
}

// JPEG.DHTMEM6: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM6(value uint32) {
	volatile.StoreUint32(&o.DHTMEM6.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM6() uint32 {
	return volatile.LoadUint32(&o.DHTMEM6.Reg)
}

// JPEG.DHTMEM7: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM7(value uint32) {
	volatile.StoreUint32(&o.DHTMEM7.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM7() uint32 {
	return volatile.LoadUint32(&o.DHTMEM7.Reg)
}

// JPEG.DHTMEM8: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM8(value uint32) {
	volatile.StoreUint32(&o.DHTMEM8.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM8() uint32 {
	return volatile.LoadUint32(&o.DHTMEM8.Reg)
}

// JPEG.DHTMEM9: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM9(value uint32) {
	volatile.StoreUint32(&o.DHTMEM9.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM9() uint32 {
	return volatile.LoadUint32(&o.DHTMEM9.Reg)
}

// JPEG.DHTMEM10: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM10(value uint32) {
	volatile.StoreUint32(&o.DHTMEM10.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM10() uint32 {
	return volatile.LoadUint32(&o.DHTMEM10.Reg)
}

// JPEG.DHTMEM11: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM11(value uint32) {
	volatile.StoreUint32(&o.DHTMEM11.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM11() uint32 {
	return volatile.LoadUint32(&o.DHTMEM11.Reg)
}

// JPEG.DHTMEM12: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM12(value uint32) {
	volatile.StoreUint32(&o.DHTMEM12.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM12() uint32 {
	return volatile.LoadUint32(&o.DHTMEM12.Reg)
}

// JPEG.DHTMEM13: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM13(value uint32) {
	volatile.StoreUint32(&o.DHTMEM13.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM13() uint32 {
	return volatile.LoadUint32(&o.DHTMEM13.Reg)
}

// JPEG.DHTMEM14: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM14(value uint32) {
	volatile.StoreUint32(&o.DHTMEM14.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM14() uint32 {
	return volatile.LoadUint32(&o.DHTMEM14.Reg)
}

// JPEG.DHTMEM15: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM15(value uint32) {
	volatile.StoreUint32(&o.DHTMEM15.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM15() uint32 {
	return volatile.LoadUint32(&o.DHTMEM15.Reg)
}

// JPEG.DHTMEM16: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM16(value uint32) {
	volatile.StoreUint32(&o.DHTMEM16.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM16() uint32 {
	return volatile.LoadUint32(&o.DHTMEM16.Reg)
}

// JPEG.DHTMEM17: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM17(value uint32) {
	volatile.StoreUint32(&o.DHTMEM17.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM17() uint32 {
	return volatile.LoadUint32(&o.DHTMEM17.Reg)
}

// JPEG.DHTMEM18: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM18(value uint32) {
	volatile.StoreUint32(&o.DHTMEM18.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM18() uint32 {
	return volatile.LoadUint32(&o.DHTMEM18.Reg)
}

// JPEG.DHTMEM19: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM19(value uint32) {
	volatile.StoreUint32(&o.DHTMEM19.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM19() uint32 {
	return volatile.LoadUint32(&o.DHTMEM19.Reg)
}

// JPEG.DHTMEM20: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM20(value uint32) {
	volatile.StoreUint32(&o.DHTMEM20.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM20() uint32 {
	return volatile.LoadUint32(&o.DHTMEM20.Reg)
}

// JPEG.DHTMEM21: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM21(value uint32) {
	volatile.StoreUint32(&o.DHTMEM21.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM21() uint32 {
	return volatile.LoadUint32(&o.DHTMEM21.Reg)
}

// JPEG.DHTMEM22: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM22(value uint32) {
	volatile.StoreUint32(&o.DHTMEM22.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM22() uint32 {
	return volatile.LoadUint32(&o.DHTMEM22.Reg)
}

// JPEG.DHTMEM23: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM23(value uint32) {
	volatile.StoreUint32(&o.DHTMEM23.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM23() uint32 {
	return volatile.LoadUint32(&o.DHTMEM23.Reg)
}

// JPEG.DHTMEM24: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM24(value uint32) {
	volatile.StoreUint32(&o.DHTMEM24.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM24() uint32 {
	return volatile.LoadUint32(&o.DHTMEM24.Reg)
}

// JPEG.DHTMEM25: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM25(value uint32) {
	volatile.StoreUint32(&o.DHTMEM25.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM25() uint32 {
	return volatile.LoadUint32(&o.DHTMEM25.Reg)
}

// JPEG.DHTMEM26: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM26(value uint32) {
	volatile.StoreUint32(&o.DHTMEM26.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM26() uint32 {
	return volatile.LoadUint32(&o.DHTMEM26.Reg)
}

// JPEG.DHTMEM27: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM27(value uint32) {
	volatile.StoreUint32(&o.DHTMEM27.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM27() uint32 {
	return volatile.LoadUint32(&o.DHTMEM27.Reg)
}

// JPEG.DHTMEM28: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM28(value uint32) {
	volatile.StoreUint32(&o.DHTMEM28.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM28() uint32 {
	return volatile.LoadUint32(&o.DHTMEM28.Reg)
}

// JPEG.DHTMEM29: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM29(value uint32) {
	volatile.StoreUint32(&o.DHTMEM29.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM29() uint32 {
	return volatile.LoadUint32(&o.DHTMEM29.Reg)
}

// JPEG.DHTMEM30: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM30(value uint32) {
	volatile.StoreUint32(&o.DHTMEM30.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM30() uint32 {
	return volatile.LoadUint32(&o.DHTMEM30.Reg)
}

// JPEG.DHTMEM31: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM31(value uint32) {
	volatile.StoreUint32(&o.DHTMEM31.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM31() uint32 {
	return volatile.LoadUint32(&o.DHTMEM31.Reg)
}

// JPEG.DHTMEM32: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM32(value uint32) {
	volatile.StoreUint32(&o.DHTMEM32.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM32() uint32 {
	return volatile.LoadUint32(&o.DHTMEM32.Reg)
}

// JPEG.DHTMEM33: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM33(value uint32) {
	volatile.StoreUint32(&o.DHTMEM33.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM33() uint32 {
	return volatile.LoadUint32(&o.DHTMEM33.Reg)
}

// JPEG.DHTMEM34: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM34(value uint32) {
	volatile.StoreUint32(&o.DHTMEM34.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM34() uint32 {
	return volatile.LoadUint32(&o.DHTMEM34.Reg)
}

// JPEG.DHTMEM35: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM35(value uint32) {
	volatile.StoreUint32(&o.DHTMEM35.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM35() uint32 {
	return volatile.LoadUint32(&o.DHTMEM35.Reg)
}

// JPEG.DHTMEM36: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM36(value uint32) {
	volatile.StoreUint32(&o.DHTMEM36.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM36() uint32 {
	return volatile.LoadUint32(&o.DHTMEM36.Reg)
}

// JPEG.DHTMEM37: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM37(value uint32) {
	volatile.StoreUint32(&o.DHTMEM37.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM37() uint32 {
	return volatile.LoadUint32(&o.DHTMEM37.Reg)
}

// JPEG.DHTMEM38: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM38(value uint32) {
	volatile.StoreUint32(&o.DHTMEM38.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM38() uint32 {
	return volatile.LoadUint32(&o.DHTMEM38.Reg)
}

// JPEG.DHTMEM39: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM39(value uint32) {
	volatile.StoreUint32(&o.DHTMEM39.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM39() uint32 {
	return volatile.LoadUint32(&o.DHTMEM39.Reg)
}

// JPEG.DHTMEM40: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM40(value uint32) {
	volatile.StoreUint32(&o.DHTMEM40.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM40() uint32 {
	return volatile.LoadUint32(&o.DHTMEM40.Reg)
}

// JPEG.DHTMEM41: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM41(value uint32) {
	volatile.StoreUint32(&o.DHTMEM41.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM41() uint32 {
	return volatile.LoadUint32(&o.DHTMEM41.Reg)
}

// JPEG.DHTMEM42: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM42(value uint32) {
	volatile.StoreUint32(&o.DHTMEM42.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM42() uint32 {
	return volatile.LoadUint32(&o.DHTMEM42.Reg)
}

// JPEG.DHTMEM43: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM43(value uint32) {
	volatile.StoreUint32(&o.DHTMEM43.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM43() uint32 {
	return volatile.LoadUint32(&o.DHTMEM43.Reg)
}

// JPEG.DHTMEM44: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM44(value uint32) {
	volatile.StoreUint32(&o.DHTMEM44.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM44() uint32 {
	return volatile.LoadUint32(&o.DHTMEM44.Reg)
}

// JPEG.DHTMEM45: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM45(value uint32) {
	volatile.StoreUint32(&o.DHTMEM45.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM45() uint32 {
	return volatile.LoadUint32(&o.DHTMEM45.Reg)
}

// JPEG.DHTMEM46: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM46(value uint32) {
	volatile.StoreUint32(&o.DHTMEM46.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM46() uint32 {
	return volatile.LoadUint32(&o.DHTMEM46.Reg)
}

// JPEG.DHTMEM47: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM47(value uint32) {
	volatile.StoreUint32(&o.DHTMEM47.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM47() uint32 {
	return volatile.LoadUint32(&o.DHTMEM47.Reg)
}

// JPEG.DHTMEM48: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM48(value uint32) {
	volatile.StoreUint32(&o.DHTMEM48.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM48() uint32 {
	return volatile.LoadUint32(&o.DHTMEM48.Reg)
}

// JPEG.DHTMEM49: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM49(value uint32) {
	volatile.StoreUint32(&o.DHTMEM49.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM49() uint32 {
	return volatile.LoadUint32(&o.DHTMEM49.Reg)
}

// JPEG.DHTMEM50: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM50(value uint32) {
	volatile.StoreUint32(&o.DHTMEM50.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM50() uint32 {
	return volatile.LoadUint32(&o.DHTMEM50.Reg)
}

// JPEG.DHTMEM51: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM51(value uint32) {
	volatile.StoreUint32(&o.DHTMEM51.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM51() uint32 {
	return volatile.LoadUint32(&o.DHTMEM51.Reg)
}

// JPEG.DHTMEM52: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM52(value uint32) {
	volatile.StoreUint32(&o.DHTMEM52.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM52() uint32 {
	return volatile.LoadUint32(&o.DHTMEM52.Reg)
}

// JPEG.DHTMEM53: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM53(value uint32) {
	volatile.StoreUint32(&o.DHTMEM53.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM53() uint32 {
	return volatile.LoadUint32(&o.DHTMEM53.Reg)
}

// JPEG.DHTMEM54: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM54(value uint32) {
	volatile.StoreUint32(&o.DHTMEM54.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM54() uint32 {
	return volatile.LoadUint32(&o.DHTMEM54.Reg)
}

// JPEG.DHTMEM55: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM55(value uint32) {
	volatile.StoreUint32(&o.DHTMEM55.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM55() uint32 {
	return volatile.LoadUint32(&o.DHTMEM55.Reg)
}

// JPEG.DHTMEM56: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM56(value uint32) {
	volatile.StoreUint32(&o.DHTMEM56.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM56() uint32 {
	return volatile.LoadUint32(&o.DHTMEM56.Reg)
}

// JPEG.DHTMEM57: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM57(value uint32) {
	volatile.StoreUint32(&o.DHTMEM57.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM57() uint32 {
	return volatile.LoadUint32(&o.DHTMEM57.Reg)
}

// JPEG.DHTMEM58: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM58(value uint32) {
	volatile.StoreUint32(&o.DHTMEM58.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM58() uint32 {
	return volatile.LoadUint32(&o.DHTMEM58.Reg)
}

// JPEG.DHTMEM59: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM59(value uint32) {
	volatile.StoreUint32(&o.DHTMEM59.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM59() uint32 {
	return volatile.LoadUint32(&o.DHTMEM59.Reg)
}

// JPEG.DHTMEM60: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM60(value uint32) {
	volatile.StoreUint32(&o.DHTMEM60.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM60() uint32 {
	return volatile.LoadUint32(&o.DHTMEM60.Reg)
}

// JPEG.DHTMEM61: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM61(value uint32) {
	volatile.StoreUint32(&o.DHTMEM61.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM61() uint32 {
	return volatile.LoadUint32(&o.DHTMEM61.Reg)
}

// JPEG.DHTMEM62: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM62(value uint32) {
	volatile.StoreUint32(&o.DHTMEM62.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM62() uint32 {
	return volatile.LoadUint32(&o.DHTMEM62.Reg)
}

// JPEG.DHTMEM63: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM63(value uint32) {
	volatile.StoreUint32(&o.DHTMEM63.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM63() uint32 {
	return volatile.LoadUint32(&o.DHTMEM63.Reg)
}

// JPEG.DHTMEM64: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM64(value uint32) {
	volatile.StoreUint32(&o.DHTMEM64.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM64() uint32 {
	return volatile.LoadUint32(&o.DHTMEM64.Reg)
}

// JPEG.DHTMEM65: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM65(value uint32) {
	volatile.StoreUint32(&o.DHTMEM65.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM65() uint32 {
	return volatile.LoadUint32(&o.DHTMEM65.Reg)
}

// JPEG.DHTMEM66: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM66(value uint32) {
	volatile.StoreUint32(&o.DHTMEM66.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM66() uint32 {
	return volatile.LoadUint32(&o.DHTMEM66.Reg)
}

// JPEG.DHTMEM67: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM67(value uint32) {
	volatile.StoreUint32(&o.DHTMEM67.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM67() uint32 {
	return volatile.LoadUint32(&o.DHTMEM67.Reg)
}

// JPEG.DHTMEM68: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM68(value uint32) {
	volatile.StoreUint32(&o.DHTMEM68.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM68() uint32 {
	return volatile.LoadUint32(&o.DHTMEM68.Reg)
}

// JPEG.DHTMEM69: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM69(value uint32) {
	volatile.StoreUint32(&o.DHTMEM69.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM69() uint32 {
	return volatile.LoadUint32(&o.DHTMEM69.Reg)
}

// JPEG.DHTMEM70: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM70(value uint32) {
	volatile.StoreUint32(&o.DHTMEM70.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM70() uint32 {
	return volatile.LoadUint32(&o.DHTMEM70.Reg)
}

// JPEG.DHTMEM71: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM71(value uint32) {
	volatile.StoreUint32(&o.DHTMEM71.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM71() uint32 {
	return volatile.LoadUint32(&o.DHTMEM71.Reg)
}

// JPEG.DHTMEM72: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM72(value uint32) {
	volatile.StoreUint32(&o.DHTMEM72.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM72() uint32 {
	return volatile.LoadUint32(&o.DHTMEM72.Reg)
}

// JPEG.DHTMEM73: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM73(value uint32) {
	volatile.StoreUint32(&o.DHTMEM73.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM73() uint32 {
	return volatile.LoadUint32(&o.DHTMEM73.Reg)
}

// JPEG.DHTMEM74: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM74(value uint32) {
	volatile.StoreUint32(&o.DHTMEM74.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM74() uint32 {
	return volatile.LoadUint32(&o.DHTMEM74.Reg)
}

// JPEG.DHTMEM75: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM75(value uint32) {
	volatile.StoreUint32(&o.DHTMEM75.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM75() uint32 {
	return volatile.LoadUint32(&o.DHTMEM75.Reg)
}

// JPEG.DHTMEM76: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM76(value uint32) {
	volatile.StoreUint32(&o.DHTMEM76.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM76() uint32 {
	return volatile.LoadUint32(&o.DHTMEM76.Reg)
}

// JPEG.DHTMEM77: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM77(value uint32) {
	volatile.StoreUint32(&o.DHTMEM77.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM77() uint32 {
	return volatile.LoadUint32(&o.DHTMEM77.Reg)
}

// JPEG.DHTMEM78: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM78(value uint32) {
	volatile.StoreUint32(&o.DHTMEM78.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM78() uint32 {
	return volatile.LoadUint32(&o.DHTMEM78.Reg)
}

// JPEG.DHTMEM79: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM79(value uint32) {
	volatile.StoreUint32(&o.DHTMEM79.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM79() uint32 {
	return volatile.LoadUint32(&o.DHTMEM79.Reg)
}

// JPEG.DHTMEM80: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM80(value uint32) {
	volatile.StoreUint32(&o.DHTMEM80.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM80() uint32 {
	return volatile.LoadUint32(&o.DHTMEM80.Reg)
}

// JPEG.DHTMEM81: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM81(value uint32) {
	volatile.StoreUint32(&o.DHTMEM81.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM81() uint32 {
	return volatile.LoadUint32(&o.DHTMEM81.Reg)
}

// JPEG.DHTMEM82: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM82(value uint32) {
	volatile.StoreUint32(&o.DHTMEM82.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM82() uint32 {
	return volatile.LoadUint32(&o.DHTMEM82.Reg)
}

// JPEG.DHTMEM83: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM83(value uint32) {
	volatile.StoreUint32(&o.DHTMEM83.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM83() uint32 {
	return volatile.LoadUint32(&o.DHTMEM83.Reg)
}

// JPEG.DHTMEM84: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM84(value uint32) {
	volatile.StoreUint32(&o.DHTMEM84.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM84() uint32 {
	return volatile.LoadUint32(&o.DHTMEM84.Reg)
}

// JPEG.DHTMEM85: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM85(value uint32) {
	volatile.StoreUint32(&o.DHTMEM85.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM85() uint32 {
	return volatile.LoadUint32(&o.DHTMEM85.Reg)
}

// JPEG.DHTMEM86: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM86(value uint32) {
	volatile.StoreUint32(&o.DHTMEM86.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM86() uint32 {
	return volatile.LoadUint32(&o.DHTMEM86.Reg)
}

// JPEG.DHTMEM87: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM87(value uint32) {
	volatile.StoreUint32(&o.DHTMEM87.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM87() uint32 {
	return volatile.LoadUint32(&o.DHTMEM87.Reg)
}

// JPEG.DHTMEM88: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM88(value uint32) {
	volatile.StoreUint32(&o.DHTMEM88.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM88() uint32 {
	return volatile.LoadUint32(&o.DHTMEM88.Reg)
}

// JPEG.DHTMEM89: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM89(value uint32) {
	volatile.StoreUint32(&o.DHTMEM89.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM89() uint32 {
	return volatile.LoadUint32(&o.DHTMEM89.Reg)
}

// JPEG.DHTMEM90: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM90(value uint32) {
	volatile.StoreUint32(&o.DHTMEM90.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM90() uint32 {
	return volatile.LoadUint32(&o.DHTMEM90.Reg)
}

// JPEG.DHTMEM91: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM91(value uint32) {
	volatile.StoreUint32(&o.DHTMEM91.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM91() uint32 {
	return volatile.LoadUint32(&o.DHTMEM91.Reg)
}

// JPEG.DHTMEM92: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM92(value uint32) {
	volatile.StoreUint32(&o.DHTMEM92.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM92() uint32 {
	return volatile.LoadUint32(&o.DHTMEM92.Reg)
}

// JPEG.DHTMEM93: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM93(value uint32) {
	volatile.StoreUint32(&o.DHTMEM93.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM93() uint32 {
	return volatile.LoadUint32(&o.DHTMEM93.Reg)
}

// JPEG.DHTMEM94: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM94(value uint32) {
	volatile.StoreUint32(&o.DHTMEM94.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM94() uint32 {
	return volatile.LoadUint32(&o.DHTMEM94.Reg)
}

// JPEG.DHTMEM95: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM95(value uint32) {
	volatile.StoreUint32(&o.DHTMEM95.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM95() uint32 {
	return volatile.LoadUint32(&o.DHTMEM95.Reg)
}

// JPEG.DHTMEM96: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM96(value uint32) {
	volatile.StoreUint32(&o.DHTMEM96.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM96() uint32 {
	return volatile.LoadUint32(&o.DHTMEM96.Reg)
}

// JPEG.DHTMEM97: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM97(value uint32) {
	volatile.StoreUint32(&o.DHTMEM97.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM97() uint32 {
	return volatile.LoadUint32(&o.DHTMEM97.Reg)
}

// JPEG.DHTMEM98: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM98(value uint32) {
	volatile.StoreUint32(&o.DHTMEM98.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM98() uint32 {
	return volatile.LoadUint32(&o.DHTMEM98.Reg)
}

// JPEG.DHTMEM99: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM99(value uint32) {
	volatile.StoreUint32(&o.DHTMEM99.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM99() uint32 {
	return volatile.LoadUint32(&o.DHTMEM99.Reg)
}

// JPEG.DHTMEM100: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM100(value uint32) {
	volatile.StoreUint32(&o.DHTMEM100.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM100() uint32 {
	return volatile.LoadUint32(&o.DHTMEM100.Reg)
}

// JPEG.DHTMEM101: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM101(value uint32) {
	volatile.StoreUint32(&o.DHTMEM101.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM101() uint32 {
	return volatile.LoadUint32(&o.DHTMEM101.Reg)
}

// JPEG.DHTMEM102: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM102(value uint32) {
	volatile.StoreUint32(&o.DHTMEM102.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM102() uint32 {
	return volatile.LoadUint32(&o.DHTMEM102.Reg)
}

// JPEG.DHTMEM103: JPEG DHTMem tables
func (o *JPEG_Type) SetDHTMEM103(value uint32) {
	volatile.StoreUint32(&o.DHTMEM103.Reg, value)
}
func (o *JPEG_Type) GetDHTMEM103() uint32 {
	return volatile.LoadUint32(&o.DHTMEM103.Reg)
}

// JPEG.HUFFENC_AC0_0: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_0(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_0.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_0() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_0.Reg)
}

// JPEG.HUFFENC_AC0_1: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_1(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_1.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_1() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_1.Reg)
}

// JPEG.HUFFENC_AC0_2: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_2(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_2.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_2() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_2.Reg)
}

// JPEG.HUFFENC_AC0_3: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_3(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_3.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_3() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_3.Reg)
}

// JPEG.HUFFENC_AC0_4: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_4(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_4.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_4() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_4.Reg)
}

// JPEG.HUFFENC_AC0_5: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_5(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_5.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_5() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_5.Reg)
}

// JPEG.HUFFENC_AC0_6: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_6(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_6.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_6() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_6.Reg)
}

// JPEG.HUFFENC_AC0_7: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_7(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_7.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_7() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_7.Reg)
}

// JPEG.HUFFENC_AC0_8: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_8(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_8.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_8() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_8.Reg)
}

// JPEG.HUFFENC_AC0_9: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_9(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_9.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_9() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_9.Reg)
}

// JPEG.HUFFENC_AC0_10: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_10(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_10.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_10() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_10.Reg)
}

// JPEG.HUFFENC_AC0_11: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_11(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_11.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_11() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_11.Reg)
}

// JPEG.HUFFENC_AC0_12: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_12(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_12.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_12() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_12.Reg)
}

// JPEG.HUFFENC_AC0_13: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_13(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_13.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_13() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_13.Reg)
}

// JPEG.HUFFENC_AC0_14: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_14(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_14.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_14() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_14.Reg)
}

// JPEG.HUFFENC_AC0_15: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_15(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_15.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_15() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_15.Reg)
}

// JPEG.HUFFENC_AC0_16: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_16(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_16.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_16() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_16.Reg)
}

// JPEG.HUFFENC_AC0_17: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_17(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_17.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_17() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_17.Reg)
}

// JPEG.HUFFENC_AC0_18: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_18(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_18.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_18() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_18.Reg)
}

// JPEG.HUFFENC_AC0_19: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_19(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_19.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_19() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_19.Reg)
}

// JPEG.HUFFENC_AC0_20: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_20(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_20.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_20() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_20.Reg)
}

// JPEG.HUFFENC_AC0_21: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_21(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_21.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_21() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_21.Reg)
}

// JPEG.HUFFENC_AC0_22: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_22(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_22.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_22() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_22.Reg)
}

// JPEG.HUFFENC_AC0_23: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_23(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_23.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_23() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_23.Reg)
}

// JPEG.HUFFENC_AC0_24: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_24(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_24.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_24() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_24.Reg)
}

// JPEG.HUFFENC_AC0_25: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_25(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_25.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_25() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_25.Reg)
}

// JPEG.HUFFENC_AC0_26: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_26(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_26.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_26() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_26.Reg)
}

// JPEG.HUFFENC_AC0_27: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_27(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_27.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_27() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_27.Reg)
}

// JPEG.HUFFENC_AC0_28: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_28(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_28.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_28() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_28.Reg)
}

// JPEG.HUFFENC_AC0_29: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_29(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_29.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_29() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_29.Reg)
}

// JPEG.HUFFENC_AC0_30: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_30(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_30.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_30() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_30.Reg)
}

// JPEG.HUFFENC_AC0_31: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_31(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_31.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_31() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_31.Reg)
}

// JPEG.HUFFENC_AC0_32: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_32(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_32.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_32() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_32.Reg)
}

// JPEG.HUFFENC_AC0_33: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_33(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_33.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_33() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_33.Reg)
}

// JPEG.HUFFENC_AC0_34: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_34(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_34.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_34() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_34.Reg)
}

// JPEG.HUFFENC_AC0_35: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_35(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_35.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_35() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_35.Reg)
}

// JPEG.HUFFENC_AC0_36: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_36(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_36.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_36() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_36.Reg)
}

// JPEG.HUFFENC_AC0_37: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_37(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_37.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_37() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_37.Reg)
}

// JPEG.HUFFENC_AC0_38: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_38(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_38.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_38() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_38.Reg)
}

// JPEG.HUFFENC_AC0_39: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_39(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_39.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_39() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_39.Reg)
}

// JPEG.HUFFENC_AC0_40: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_40(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_40.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_40() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_40.Reg)
}

// JPEG.HUFFENC_AC0_41: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_41(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_41.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_41() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_41.Reg)
}

// JPEG.HUFFENC_AC0_42: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_42(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_42.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_42() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_42.Reg)
}

// JPEG.HUFFENC_AC0_43: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_43(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_43.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_43() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_43.Reg)
}

// JPEG.HUFFENC_AC0_44: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_44(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_44.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_44() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_44.Reg)
}

// JPEG.HUFFENC_AC0_45: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_45(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_45.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_45() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_45.Reg)
}

// JPEG.HUFFENC_AC0_46: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_46(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_46.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_46() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_46.Reg)
}

// JPEG.HUFFENC_AC0_47: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_47(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_47.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_47() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_47.Reg)
}

// JPEG.HUFFENC_AC0_48: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_48(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_48.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_48() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_48.Reg)
}

// JPEG.HUFFENC_AC0_49: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_49(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_49.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_49() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_49.Reg)
}

// JPEG.HUFFENC_AC0_50: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_50(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_50.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_50() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_50.Reg)
}

// JPEG.HUFFENC_AC0_51: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_51(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_51.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_51() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_51.Reg)
}

// JPEG.HUFFENC_AC0_52: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_52(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_52.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_52() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_52.Reg)
}

// JPEG.HUFFENC_AC0_53: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_53(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_53.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_53() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_53.Reg)
}

// JPEG.HUFFENC_AC0_54: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_54(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_54.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_54() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_54.Reg)
}

// JPEG.HUFFENC_AC0_55: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_55(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_55.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_55() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_55.Reg)
}

// JPEG.HUFFENC_AC0_56: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_56(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_56.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_56() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_56.Reg)
}

// JPEG.HUFFENC_AC0_57: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_57(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_57.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_57() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_57.Reg)
}

// JPEG.HUFFENC_AC0_58: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_58(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_58.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_58() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_58.Reg)
}

// JPEG.HUFFENC_AC0_59: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_59(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_59.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_59() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_59.Reg)
}

// JPEG.HUFFENC_AC0_60: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_60(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_60.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_60() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_60.Reg)
}

// JPEG.HUFFENC_AC0_61: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_61(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_61.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_61() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_61.Reg)
}

// JPEG.HUFFENC_AC0_62: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_62(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_62.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_62() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_62.Reg)
}

// JPEG.HUFFENC_AC0_63: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_63(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_63.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_63() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_63.Reg)
}

// JPEG.HUFFENC_AC0_64: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_64(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_64.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_64() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_64.Reg)
}

// JPEG.HUFFENC_AC0_65: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_65(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_65.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_65() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_65.Reg)
}

// JPEG.HUFFENC_AC0_66: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_66(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_66.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_66() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_66.Reg)
}

// JPEG.HUFFENC_AC0_67: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_67(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_67.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_67() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_67.Reg)
}

// JPEG.HUFFENC_AC0_68: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_68(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_68.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_68() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_68.Reg)
}

// JPEG.HUFFENC_AC0_69: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_69(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_69.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_69() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_69.Reg)
}

// JPEG.HUFFENC_AC0_70: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_70(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_70.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_70() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_70.Reg)
}

// JPEG.HUFFENC_AC0_71: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_71(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_71.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_71() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_71.Reg)
}

// JPEG.HUFFENC_AC0_72: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_72(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_72.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_72() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_72.Reg)
}

// JPEG.HUFFENC_AC0_73: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_73(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_73.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_73() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_73.Reg)
}

// JPEG.HUFFENC_AC0_74: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_74(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_74.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_74() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_74.Reg)
}

// JPEG.HUFFENC_AC0_75: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_75(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_75.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_75() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_75.Reg)
}

// JPEG.HUFFENC_AC0_76: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_76(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_76.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_76() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_76.Reg)
}

// JPEG.HUFFENC_AC0_77: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_77(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_77.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_77() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_77.Reg)
}

// JPEG.HUFFENC_AC0_78: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_78(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_78.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_78() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_78.Reg)
}

// JPEG.HUFFENC_AC0_79: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_79(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_79.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_79() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_79.Reg)
}

// JPEG.HUFFENC_AC0_80: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_80(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_80.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_80() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_80.Reg)
}

// JPEG.HUFFENC_AC0_81: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_81(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_81.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_81() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_81.Reg)
}

// JPEG.HUFFENC_AC0_82: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_82(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_82.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_82() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_82.Reg)
}

// JPEG.HUFFENC_AC0_83: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_83(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_83.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_83() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_83.Reg)
}

// JPEG.HUFFENC_AC0_84: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_84(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_84.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_84() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_84.Reg)
}

// JPEG.HUFFENC_AC0_85: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_85(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_85.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_85() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_85.Reg)
}

// JPEG.HUFFENC_AC0_86: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_86(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_86.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_86() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_86.Reg)
}

// JPEG.HUFFENC_AC0_87: JPEG encoder, AC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_AC0_87(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC0_87.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC0_87() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC0_87.Reg)
}

// JPEG.HUFFENC_AC1_0: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_0(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_0.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_0() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_0.Reg)
}

// JPEG.HUFFENC_AC1_1: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_1(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_1.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_1() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_1.Reg)
}

// JPEG.HUFFENC_AC1_2: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_2(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_2.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_2() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_2.Reg)
}

// JPEG.HUFFENC_AC1_3: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_3(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_3.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_3() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_3.Reg)
}

// JPEG.HUFFENC_AC1_4: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_4(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_4.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_4() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_4.Reg)
}

// JPEG.HUFFENC_AC1_5: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_5(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_5.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_5() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_5.Reg)
}

// JPEG.HUFFENC_AC1_6: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_6(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_6.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_6() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_6.Reg)
}

// JPEG.HUFFENC_AC1_7: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_7(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_7.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_7() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_7.Reg)
}

// JPEG.HUFFENC_AC1_8: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_8(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_8.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_8() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_8.Reg)
}

// JPEG.HUFFENC_AC1_9: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_9(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_9.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_9() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_9.Reg)
}

// JPEG.HUFFENC_AC1_10: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_10(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_10.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_10() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_10.Reg)
}

// JPEG.HUFFENC_AC1_11: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_11(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_11.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_11() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_11.Reg)
}

// JPEG.HUFFENC_AC1_12: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_12(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_12.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_12() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_12.Reg)
}

// JPEG.HUFFENC_AC1_13: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_13(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_13.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_13() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_13.Reg)
}

// JPEG.HUFFENC_AC1_14: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_14(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_14.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_14() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_14.Reg)
}

// JPEG.HUFFENC_AC1_15: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_15(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_15.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_15() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_15.Reg)
}

// JPEG.HUFFENC_AC1_16: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_16(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_16.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_16() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_16.Reg)
}

// JPEG.HUFFENC_AC1_17: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_17(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_17.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_17() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_17.Reg)
}

// JPEG.HUFFENC_AC1_18: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_18(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_18.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_18() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_18.Reg)
}

// JPEG.HUFFENC_AC1_19: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_19(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_19.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_19() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_19.Reg)
}

// JPEG.HUFFENC_AC1_20: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_20(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_20.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_20() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_20.Reg)
}

// JPEG.HUFFENC_AC1_21: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_21(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_21.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_21() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_21.Reg)
}

// JPEG.HUFFENC_AC1_22: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_22(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_22.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_22() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_22.Reg)
}

// JPEG.HUFFENC_AC1_23: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_23(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_23.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_23() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_23.Reg)
}

// JPEG.HUFFENC_AC1_24: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_24(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_24.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_24() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_24.Reg)
}

// JPEG.HUFFENC_AC1_25: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_25(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_25.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_25() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_25.Reg)
}

// JPEG.HUFFENC_AC1_26: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_26(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_26.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_26() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_26.Reg)
}

// JPEG.HUFFENC_AC1_27: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_27(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_27.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_27() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_27.Reg)
}

// JPEG.HUFFENC_AC1_28: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_28(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_28.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_28() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_28.Reg)
}

// JPEG.HUFFENC_AC1_29: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_29(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_29.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_29() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_29.Reg)
}

// JPEG.HUFFENC_AC1_30: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_30(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_30.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_30() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_30.Reg)
}

// JPEG.HUFFENC_AC1_31: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_31(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_31.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_31() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_31.Reg)
}

// JPEG.HUFFENC_AC1_32: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_32(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_32.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_32() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_32.Reg)
}

// JPEG.HUFFENC_AC1_33: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_33(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_33.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_33() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_33.Reg)
}

// JPEG.HUFFENC_AC1_34: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_34(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_34.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_34() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_34.Reg)
}

// JPEG.HUFFENC_AC1_35: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_35(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_35.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_35() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_35.Reg)
}

// JPEG.HUFFENC_AC1_36: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_36(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_36.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_36() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_36.Reg)
}

// JPEG.HUFFENC_AC1_37: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_37(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_37.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_37() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_37.Reg)
}

// JPEG.HUFFENC_AC1_38: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_38(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_38.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_38() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_38.Reg)
}

// JPEG.HUFFENC_AC1_39: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_39(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_39.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_39() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_39.Reg)
}

// JPEG.HUFFENC_AC1_40: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_40(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_40.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_40() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_40.Reg)
}

// JPEG.HUFFENC_AC1_41: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_41(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_41.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_41() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_41.Reg)
}

// JPEG.HUFFENC_AC1_42: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_42(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_42.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_42() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_42.Reg)
}

// JPEG.HUFFENC_AC1_43: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_43(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_43.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_43() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_43.Reg)
}

// JPEG.HUFFENC_AC1_44: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_44(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_44.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_44() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_44.Reg)
}

// JPEG.HUFFENC_AC1_45: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_45(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_45.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_45() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_45.Reg)
}

// JPEG.HUFFENC_AC1_46: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_46(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_46.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_46() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_46.Reg)
}

// JPEG.HUFFENC_AC1_47: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_47(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_47.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_47() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_47.Reg)
}

// JPEG.HUFFENC_AC1_48: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_48(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_48.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_48() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_48.Reg)
}

// JPEG.HUFFENC_AC1_49: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_49(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_49.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_49() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_49.Reg)
}

// JPEG.HUFFENC_AC1_50: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_50(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_50.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_50() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_50.Reg)
}

// JPEG.HUFFENC_AC1_51: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_51(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_51.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_51() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_51.Reg)
}

// JPEG.HUFFENC_AC1_52: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_52(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_52.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_52() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_52.Reg)
}

// JPEG.HUFFENC_AC1_53: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_53(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_53.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_53() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_53.Reg)
}

// JPEG.HUFFENC_AC1_54: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_54(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_54.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_54() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_54.Reg)
}

// JPEG.HUFFENC_AC1_55: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_55(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_55.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_55() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_55.Reg)
}

// JPEG.HUFFENC_AC1_56: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_56(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_56.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_56() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_56.Reg)
}

// JPEG.HUFFENC_AC1_57: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_57(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_57.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_57() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_57.Reg)
}

// JPEG.HUFFENC_AC1_58: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_58(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_58.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_58() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_58.Reg)
}

// JPEG.HUFFENC_AC1_59: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_59(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_59.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_59() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_59.Reg)
}

// JPEG.HUFFENC_AC1_60: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_60(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_60.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_60() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_60.Reg)
}

// JPEG.HUFFENC_AC1_61: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_61(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_61.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_61() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_61.Reg)
}

// JPEG.HUFFENC_AC1_62: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_62(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_62.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_62() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_62.Reg)
}

// JPEG.HUFFENC_AC1_63: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_63(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_63.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_63() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_63.Reg)
}

// JPEG.HUFFENC_AC1_64: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_64(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_64.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_64() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_64.Reg)
}

// JPEG.HUFFENC_AC1_65: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_65(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_65.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_65() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_65.Reg)
}

// JPEG.HUFFENC_AC1_66: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_66(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_66.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_66() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_66.Reg)
}

// JPEG.HUFFENC_AC1_67: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_67(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_67.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_67() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_67.Reg)
}

// JPEG.HUFFENC_AC1_68: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_68(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_68.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_68() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_68.Reg)
}

// JPEG.HUFFENC_AC1_69: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_69(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_69.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_69() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_69.Reg)
}

// JPEG.HUFFENC_AC1_70: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_70(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_70.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_70() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_70.Reg)
}

// JPEG.HUFFENC_AC1_71: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_71(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_71.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_71() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_71.Reg)
}

// JPEG.HUFFENC_AC1_72: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_72(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_72.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_72() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_72.Reg)
}

// JPEG.HUFFENC_AC1_73: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_73(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_73.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_73() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_73.Reg)
}

// JPEG.HUFFENC_AC1_74: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_74(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_74.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_74() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_74.Reg)
}

// JPEG.HUFFENC_AC1_75: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_75(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_75.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_75() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_75.Reg)
}

// JPEG.HUFFENC_AC1_76: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_76(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_76.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_76() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_76.Reg)
}

// JPEG.HUFFENC_AC1_77: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_77(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_77.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_77() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_77.Reg)
}

// JPEG.HUFFENC_AC1_78: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_78(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_78.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_78() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_78.Reg)
}

// JPEG.HUFFENC_AC1_79: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_79(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_79.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_79() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_79.Reg)
}

// JPEG.HUFFENC_AC1_80: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_80(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_80.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_80() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_80.Reg)
}

// JPEG.HUFFENC_AC1_81: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_81(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_81.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_81() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_81.Reg)
}

// JPEG.HUFFENC_AC1_82: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_82(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_82.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_82() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_82.Reg)
}

// JPEG.HUFFENC_AC1_83: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_83(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_83.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_83() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_83.Reg)
}

// JPEG.HUFFENC_AC1_84: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_84(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_84.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_84() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_84.Reg)
}

// JPEG.HUFFENC_AC1_85: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_85(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_85.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_85() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_85.Reg)
}

// JPEG.HUFFENC_AC1_86: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_86(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_86.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_86() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_86.Reg)
}

// JPEG.HUFFENC_AC1_87: JPEG encoder, AC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_AC1_87(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_AC1_87.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_AC1_87() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_AC1_87.Reg)
}

// JPEG.HUFFENC_DC0_0: JPEG encoder, DC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_DC0_0(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_DC0_0.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_DC0_0() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_DC0_0.Reg)
}

// JPEG.HUFFENC_DC0_1: JPEG encoder, DC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_DC0_1(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_DC0_1.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_DC0_1() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_DC0_1.Reg)
}

// JPEG.HUFFENC_DC0_2: JPEG encoder, DC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_DC0_2(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_DC0_2.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_DC0_2() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_DC0_2.Reg)
}

// JPEG.HUFFENC_DC0_3: JPEG encoder, DC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_DC0_3(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_DC0_3.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_DC0_3() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_DC0_3.Reg)
}

// JPEG.HUFFENC_DC0_4: JPEG encoder, DC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_DC0_4(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_DC0_4.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_DC0_4() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_DC0_4.Reg)
}

// JPEG.HUFFENC_DC0_5: JPEG encoder, DC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_DC0_5(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_DC0_5.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_DC0_5() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_DC0_5.Reg)
}

// JPEG.HUFFENC_DC0_6: JPEG encoder, DC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_DC0_6(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_DC0_6.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_DC0_6() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_DC0_6.Reg)
}

// JPEG.HUFFENC_DC0_7: JPEG encoder, DC Huffman table 0
func (o *JPEG_Type) SetHUFFENC_DC0_7(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_DC0_7.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_DC0_7() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_DC0_7.Reg)
}

// JPEG.HUFFENC_DC1_0: JPEG encoder, DC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_DC1_0(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_DC1_0.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_DC1_0() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_DC1_0.Reg)
}

// JPEG.HUFFENC_DC1_1: JPEG encoder, DC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_DC1_1(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_DC1_1.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_DC1_1() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_DC1_1.Reg)
}

// JPEG.HUFFENC_DC1_2: JPEG encoder, DC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_DC1_2(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_DC1_2.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_DC1_2() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_DC1_2.Reg)
}

// JPEG.HUFFENC_DC1_3: JPEG encoder, DC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_DC1_3(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_DC1_3.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_DC1_3() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_DC1_3.Reg)
}

// JPEG.HUFFENC_DC1_4: JPEG encoder, DC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_DC1_4(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_DC1_4.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_DC1_4() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_DC1_4.Reg)
}

// JPEG.HUFFENC_DC1_5: JPEG encoder, DC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_DC1_5(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_DC1_5.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_DC1_5() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_DC1_5.Reg)
}

// JPEG.HUFFENC_DC1_6: JPEG encoder, DC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_DC1_6(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_DC1_6.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_DC1_6() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_DC1_6.Reg)
}

// JPEG.HUFFENC_DC1_7: JPEG encoder, DC Huffman table 1
func (o *JPEG_Type) SetHUFFENC_DC1_7(value uint32) {
	volatile.StoreUint32(&o.HUFFENC_DC1_7.Reg, value)
}
func (o *JPEG_Type) GetHUFFENC_DC1_7() uint32 {
	return volatile.LoadUint32(&o.HUFFENC_DC1_7.Reg)
}

// DSI Host
type DSI_Type struct {
	VR      volatile.Register32 // 0x0
	CR      volatile.Register32 // 0x4
	CCR     volatile.Register32 // 0x8
	LVCIDR  volatile.Register32 // 0xC
	LCOLCR  volatile.Register32 // 0x10
	LPCR    volatile.Register32 // 0x14
	LPMCR   volatile.Register32 // 0x18
	_       [16]byte
	PCR     volatile.Register32 // 0x2C
	GVCIDR  volatile.Register32 // 0x30
	MCR     volatile.Register32 // 0x34
	VMCR    volatile.Register32 // 0x38
	VPCR    volatile.Register32 // 0x3C
	VCCR    volatile.Register32 // 0x40
	VNPCR   volatile.Register32 // 0x44
	VHSACR  volatile.Register32 // 0x48
	VHBPCR  volatile.Register32 // 0x4C
	VLCR    volatile.Register32 // 0x50
	VVSACR  volatile.Register32 // 0x54
	VVBPCR  volatile.Register32 // 0x58
	VVFPCR  volatile.Register32 // 0x5C
	VVACR   volatile.Register32 // 0x60
	LCCR    volatile.Register32 // 0x64
	CMCR    volatile.Register32 // 0x68
	GHCR    volatile.Register32 // 0x6C
	GPDR    volatile.Register32 // 0x70
	GPSR    volatile.Register32 // 0x74
	TCCR0   volatile.Register32 // 0x78
	TCCR1   volatile.Register32 // 0x7C
	TCCR2   volatile.Register32 // 0x80
	TCCR3   volatile.Register32 // 0x84
	TCCR4   volatile.Register32 // 0x88
	TCCR5   volatile.Register32 // 0x8C
	_       [4]byte
	CLCR    volatile.Register32 // 0x94
	CLTCR   volatile.Register32 // 0x98
	DLTCR   volatile.Register32 // 0x9C
	PCTLR   volatile.Register32 // 0xA0
	PCONFR  volatile.Register32 // 0xA4
	PUCR    volatile.Register32 // 0xA8
	PTTCR   volatile.Register32 // 0xAC
	PSR     volatile.Register32 // 0xB0
	_       [8]byte
	ISR0    volatile.Register32 // 0xBC
	ISR1    volatile.Register32 // 0xC0
	IER0    volatile.Register32 // 0xC4
	IER1    volatile.Register32 // 0xC8
	_       [12]byte
	FIR0    volatile.Register32 // 0xD8
	FIR1    volatile.Register32 // 0xDC
	_       [32]byte
	VSCR    volatile.Register32 // 0x100
	_       [8]byte
	LCVCIDR volatile.Register32 // 0x10C
	LCCCR   volatile.Register32 // 0x110
	_       [4]byte
	LPMCCR  volatile.Register32 // 0x118
	_       [28]byte
	VMCCR   volatile.Register32 // 0x138
	VPCCR   volatile.Register32 // 0x13C
	VCCCR   volatile.Register32 // 0x140
	VNPCCR  volatile.Register32 // 0x144
	VHSACCR volatile.Register32 // 0x148
	VHBPCCR volatile.Register32 // 0x14C
	VLCCR   volatile.Register32 // 0x150
	VVSACCR volatile.Register32 // 0x154
	VVBPCCR volatile.Register32 // 0x158
	VVFPCCR volatile.Register32 // 0x15C
	VVACCR  volatile.Register32 // 0x160
	_       [668]byte
	WCFGR   volatile.Register32 // 0x400
	WCR     volatile.Register32 // 0x404
	WIER    volatile.Register32 // 0x408
	WISR    volatile.Register32 // 0x40C
	WIFCR   volatile.Register32 // 0x410
	_       [4]byte
	WPCR1   volatile.Register32 // 0x418
	WPCR2   volatile.Register32 // 0x41C
	WPCR3   volatile.Register32 // 0x420
	WPCR4   volatile.Register32 // 0x424
	WPCR5   volatile.Register32 // 0x428
	_       [4]byte
	WRPCR   volatile.Register32 // 0x430
}

// DSI.VR: DSI Host Version Register
func (o *DSI_Type) SetVR(value uint32) {
	volatile.StoreUint32(&o.VR.Reg, value)
}
func (o *DSI_Type) GetVR() uint32 {
	return volatile.LoadUint32(&o.VR.Reg)
}

// DSI.CR: DSI Host Control Register
func (o *DSI_Type) SetCR_EN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetCR_EN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}

// DSI.CCR: DSI HOST Clock Control Register
func (o *DSI_Type) SetCCR_TXECKDIV(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0xff)|value)
}
func (o *DSI_Type) GetCCR_TXECKDIV() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0xff
}
func (o *DSI_Type) SetCCR_TOCKDIV(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0xff00)|value<<8)
}
func (o *DSI_Type) GetCCR_TOCKDIV() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0xff00) >> 8
}

// DSI.LVCIDR: DSI Host LTDC VCID Register
func (o *DSI_Type) SetLVCIDR_VCID(value uint32) {
	volatile.StoreUint32(&o.LVCIDR.Reg, volatile.LoadUint32(&o.LVCIDR.Reg)&^(0x3)|value)
}
func (o *DSI_Type) GetLVCIDR_VCID() uint32 {
	return volatile.LoadUint32(&o.LVCIDR.Reg) & 0x3
}

// DSI.LCOLCR: DSI Host LTDC Color Coding Register
func (o *DSI_Type) SetLCOLCR_COLC(value uint32) {
	volatile.StoreUint32(&o.LCOLCR.Reg, volatile.LoadUint32(&o.LCOLCR.Reg)&^(0xf)|value)
}
func (o *DSI_Type) GetLCOLCR_COLC() uint32 {
	return volatile.LoadUint32(&o.LCOLCR.Reg) & 0xf
}
func (o *DSI_Type) SetLCOLCR_LPE(value uint32) {
	volatile.StoreUint32(&o.LCOLCR.Reg, volatile.LoadUint32(&o.LCOLCR.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetLCOLCR_LPE() uint32 {
	return (volatile.LoadUint32(&o.LCOLCR.Reg) & 0x100) >> 8
}

// DSI.LPCR: DSI Host LTDC Polarity Configuration Register
func (o *DSI_Type) SetLPCR_DEP(value uint32) {
	volatile.StoreUint32(&o.LPCR.Reg, volatile.LoadUint32(&o.LPCR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetLPCR_DEP() uint32 {
	return volatile.LoadUint32(&o.LPCR.Reg) & 0x1
}
func (o *DSI_Type) SetLPCR_VSP(value uint32) {
	volatile.StoreUint32(&o.LPCR.Reg, volatile.LoadUint32(&o.LPCR.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetLPCR_VSP() uint32 {
	return (volatile.LoadUint32(&o.LPCR.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetLPCR_HSP(value uint32) {
	volatile.StoreUint32(&o.LPCR.Reg, volatile.LoadUint32(&o.LPCR.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetLPCR_HSP() uint32 {
	return (volatile.LoadUint32(&o.LPCR.Reg) & 0x4) >> 2
}

// DSI.LPMCR: DSI Host Low-Power mode Configuration Register
func (o *DSI_Type) SetLPMCR_VLPSIZE(value uint32) {
	volatile.StoreUint32(&o.LPMCR.Reg, volatile.LoadUint32(&o.LPMCR.Reg)&^(0xff)|value)
}
func (o *DSI_Type) GetLPMCR_VLPSIZE() uint32 {
	return volatile.LoadUint32(&o.LPMCR.Reg) & 0xff
}
func (o *DSI_Type) SetLPMCR_LPSIZE(value uint32) {
	volatile.StoreUint32(&o.LPMCR.Reg, volatile.LoadUint32(&o.LPMCR.Reg)&^(0xff0000)|value<<16)
}
func (o *DSI_Type) GetLPMCR_LPSIZE() uint32 {
	return (volatile.LoadUint32(&o.LPMCR.Reg) & 0xff0000) >> 16
}

// DSI.PCR: DSI Host Protocol Configuration Register
func (o *DSI_Type) SetPCR_ETTXE(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetPCR_ETTXE() uint32 {
	return volatile.LoadUint32(&o.PCR.Reg) & 0x1
}
func (o *DSI_Type) SetPCR_ETRXE(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetPCR_ETRXE() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetPCR_BTAE(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetPCR_BTAE() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetPCR_ECCRXE(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetPCR_ECCRXE() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x8) >> 3
}
func (o *DSI_Type) SetPCR_CRCRXE(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x10)|value<<4)
}
func (o *DSI_Type) GetPCR_CRCRXE() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x10) >> 4
}

// DSI.GVCIDR: DSI Host Generic VCID Register
func (o *DSI_Type) SetGVCIDR_VCID(value uint32) {
	volatile.StoreUint32(&o.GVCIDR.Reg, volatile.LoadUint32(&o.GVCIDR.Reg)&^(0x3)|value)
}
func (o *DSI_Type) GetGVCIDR_VCID() uint32 {
	return volatile.LoadUint32(&o.GVCIDR.Reg) & 0x3
}

// DSI.MCR: DSI Host mode Configuration Register
func (o *DSI_Type) SetMCR_CMDM(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetMCR_CMDM() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x1
}

// DSI.VMCR: DSI Host Video mode Configuration Register
func (o *DSI_Type) SetVMCR_VMT(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x3)|value)
}
func (o *DSI_Type) GetVMCR_VMT() uint32 {
	return volatile.LoadUint32(&o.VMCR.Reg) & 0x3
}
func (o *DSI_Type) SetVMCR_LPVSAE(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetVMCR_LPVSAE() uint32 {
	return (volatile.LoadUint32(&o.VMCR.Reg) & 0x100) >> 8
}
func (o *DSI_Type) SetVMCR_LPVBPE(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetVMCR_LPVBPE() uint32 {
	return (volatile.LoadUint32(&o.VMCR.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetVMCR_LPVFPE(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetVMCR_LPVFPE() uint32 {
	return (volatile.LoadUint32(&o.VMCR.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetVMCR_LPVAE(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x800)|value<<11)
}
func (o *DSI_Type) GetVMCR_LPVAE() uint32 {
	return (volatile.LoadUint32(&o.VMCR.Reg) & 0x800) >> 11
}
func (o *DSI_Type) SetVMCR_LPHBPE(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x1000)|value<<12)
}
func (o *DSI_Type) GetVMCR_LPHBPE() uint32 {
	return (volatile.LoadUint32(&o.VMCR.Reg) & 0x1000) >> 12
}
func (o *DSI_Type) SetVMCR_LPHFPE(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x2000)|value<<13)
}
func (o *DSI_Type) GetVMCR_LPHFPE() uint32 {
	return (volatile.LoadUint32(&o.VMCR.Reg) & 0x2000) >> 13
}
func (o *DSI_Type) SetVMCR_FBTAAE(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x4000)|value<<14)
}
func (o *DSI_Type) GetVMCR_FBTAAE() uint32 {
	return (volatile.LoadUint32(&o.VMCR.Reg) & 0x4000) >> 14
}
func (o *DSI_Type) SetVMCR_LPCE(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x8000)|value<<15)
}
func (o *DSI_Type) GetVMCR_LPCE() uint32 {
	return (volatile.LoadUint32(&o.VMCR.Reg) & 0x8000) >> 15
}
func (o *DSI_Type) SetVMCR_PGE(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x10000)|value<<16)
}
func (o *DSI_Type) GetVMCR_PGE() uint32 {
	return (volatile.LoadUint32(&o.VMCR.Reg) & 0x10000) >> 16
}
func (o *DSI_Type) SetVMCR_PGM(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x100000)|value<<20)
}
func (o *DSI_Type) GetVMCR_PGM() uint32 {
	return (volatile.LoadUint32(&o.VMCR.Reg) & 0x100000) >> 20
}
func (o *DSI_Type) SetVMCR_PGO(value uint32) {
	volatile.StoreUint32(&o.VMCR.Reg, volatile.LoadUint32(&o.VMCR.Reg)&^(0x1000000)|value<<24)
}
func (o *DSI_Type) GetVMCR_PGO() uint32 {
	return (volatile.LoadUint32(&o.VMCR.Reg) & 0x1000000) >> 24
}

// DSI.VPCR: DSI Host Video Packet Configuration Register
func (o *DSI_Type) SetVPCR_VPSIZE(value uint32) {
	volatile.StoreUint32(&o.VPCR.Reg, volatile.LoadUint32(&o.VPCR.Reg)&^(0x3fff)|value)
}
func (o *DSI_Type) GetVPCR_VPSIZE() uint32 {
	return volatile.LoadUint32(&o.VPCR.Reg) & 0x3fff
}

// DSI.VCCR: DSI Host Video Chunks Configuration Register
func (o *DSI_Type) SetVCCR_NUMC(value uint32) {
	volatile.StoreUint32(&o.VCCR.Reg, volatile.LoadUint32(&o.VCCR.Reg)&^(0x1fff)|value)
}
func (o *DSI_Type) GetVCCR_NUMC() uint32 {
	return volatile.LoadUint32(&o.VCCR.Reg) & 0x1fff
}

// DSI.VNPCR: DSI Host Video Null Packet Configuration Register
func (o *DSI_Type) SetVNPCR_NPSIZE(value uint32) {
	volatile.StoreUint32(&o.VNPCR.Reg, volatile.LoadUint32(&o.VNPCR.Reg)&^(0x1fff)|value)
}
func (o *DSI_Type) GetVNPCR_NPSIZE() uint32 {
	return volatile.LoadUint32(&o.VNPCR.Reg) & 0x1fff
}

// DSI.VHSACR: DSI Host Video HSA Configuration Register
func (o *DSI_Type) SetVHSACR_HSA(value uint32) {
	volatile.StoreUint32(&o.VHSACR.Reg, volatile.LoadUint32(&o.VHSACR.Reg)&^(0xfff)|value)
}
func (o *DSI_Type) GetVHSACR_HSA() uint32 {
	return volatile.LoadUint32(&o.VHSACR.Reg) & 0xfff
}

// DSI.VHBPCR: DSI Host Video HBP Configuration Register
func (o *DSI_Type) SetVHBPCR_HBP(value uint32) {
	volatile.StoreUint32(&o.VHBPCR.Reg, volatile.LoadUint32(&o.VHBPCR.Reg)&^(0xfff)|value)
}
func (o *DSI_Type) GetVHBPCR_HBP() uint32 {
	return volatile.LoadUint32(&o.VHBPCR.Reg) & 0xfff
}

// DSI.VLCR: DSI Host Video Line Configuration Register
func (o *DSI_Type) SetVLCR_HLINE(value uint32) {
	volatile.StoreUint32(&o.VLCR.Reg, volatile.LoadUint32(&o.VLCR.Reg)&^(0x7fff)|value)
}
func (o *DSI_Type) GetVLCR_HLINE() uint32 {
	return volatile.LoadUint32(&o.VLCR.Reg) & 0x7fff
}

// DSI.VVSACR: DSI Host Video VSA Configuration Register
func (o *DSI_Type) SetVVSACR_VSA(value uint32) {
	volatile.StoreUint32(&o.VVSACR.Reg, volatile.LoadUint32(&o.VVSACR.Reg)&^(0x3ff)|value)
}
func (o *DSI_Type) GetVVSACR_VSA() uint32 {
	return volatile.LoadUint32(&o.VVSACR.Reg) & 0x3ff
}

// DSI.VVBPCR: DSI Host Video VBP Configuration Register
func (o *DSI_Type) SetVVBPCR_VBP(value uint32) {
	volatile.StoreUint32(&o.VVBPCR.Reg, volatile.LoadUint32(&o.VVBPCR.Reg)&^(0x3ff)|value)
}
func (o *DSI_Type) GetVVBPCR_VBP() uint32 {
	return volatile.LoadUint32(&o.VVBPCR.Reg) & 0x3ff
}

// DSI.VVFPCR: DSI Host Video VFP Configuration Register
func (o *DSI_Type) SetVVFPCR_VFP(value uint32) {
	volatile.StoreUint32(&o.VVFPCR.Reg, volatile.LoadUint32(&o.VVFPCR.Reg)&^(0x3ff)|value)
}
func (o *DSI_Type) GetVVFPCR_VFP() uint32 {
	return volatile.LoadUint32(&o.VVFPCR.Reg) & 0x3ff
}

// DSI.VVACR: DSI Host Video VA Configuration Register
func (o *DSI_Type) SetVVACR_VA(value uint32) {
	volatile.StoreUint32(&o.VVACR.Reg, volatile.LoadUint32(&o.VVACR.Reg)&^(0x3fff)|value)
}
func (o *DSI_Type) GetVVACR_VA() uint32 {
	return volatile.LoadUint32(&o.VVACR.Reg) & 0x3fff
}

// DSI.LCCR: DSI Host LTDC Command Configuration Register
func (o *DSI_Type) SetLCCR_CMDSIZE(value uint32) {
	volatile.StoreUint32(&o.LCCR.Reg, volatile.LoadUint32(&o.LCCR.Reg)&^(0xffff)|value)
}
func (o *DSI_Type) GetLCCR_CMDSIZE() uint32 {
	return volatile.LoadUint32(&o.LCCR.Reg) & 0xffff
}

// DSI.CMCR: DSI Host Command mode Configuration Register
func (o *DSI_Type) SetCMCR_TEARE(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetCMCR_TEARE() uint32 {
	return volatile.LoadUint32(&o.CMCR.Reg) & 0x1
}
func (o *DSI_Type) SetCMCR_ARE(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetCMCR_ARE() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetCMCR_GSW0TX(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetCMCR_GSW0TX() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x100) >> 8
}
func (o *DSI_Type) SetCMCR_GSW1TX(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetCMCR_GSW1TX() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetCMCR_GSW2TX(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetCMCR_GSW2TX() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetCMCR_GSR0TX(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x800)|value<<11)
}
func (o *DSI_Type) GetCMCR_GSR0TX() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x800) >> 11
}
func (o *DSI_Type) SetCMCR_GSR1TX(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x1000)|value<<12)
}
func (o *DSI_Type) GetCMCR_GSR1TX() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x1000) >> 12
}
func (o *DSI_Type) SetCMCR_GSR2TX(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x2000)|value<<13)
}
func (o *DSI_Type) GetCMCR_GSR2TX() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x2000) >> 13
}
func (o *DSI_Type) SetCMCR_GLWTX(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x4000)|value<<14)
}
func (o *DSI_Type) GetCMCR_GLWTX() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x4000) >> 14
}
func (o *DSI_Type) SetCMCR_DSW0TX(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x10000)|value<<16)
}
func (o *DSI_Type) GetCMCR_DSW0TX() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x10000) >> 16
}
func (o *DSI_Type) SetCMCR_DSW1TX(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x20000)|value<<17)
}
func (o *DSI_Type) GetCMCR_DSW1TX() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x20000) >> 17
}
func (o *DSI_Type) SetCMCR_DSR0TX(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x40000)|value<<18)
}
func (o *DSI_Type) GetCMCR_DSR0TX() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x40000) >> 18
}
func (o *DSI_Type) SetCMCR_DLWTX(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x80000)|value<<19)
}
func (o *DSI_Type) GetCMCR_DLWTX() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x80000) >> 19
}
func (o *DSI_Type) SetCMCR_MRDPS(value uint32) {
	volatile.StoreUint32(&o.CMCR.Reg, volatile.LoadUint32(&o.CMCR.Reg)&^(0x1000000)|value<<24)
}
func (o *DSI_Type) GetCMCR_MRDPS() uint32 {
	return (volatile.LoadUint32(&o.CMCR.Reg) & 0x1000000) >> 24
}

// DSI.GHCR: DSI Host Generic Header Configuration Register
func (o *DSI_Type) SetGHCR_DT(value uint32) {
	volatile.StoreUint32(&o.GHCR.Reg, volatile.LoadUint32(&o.GHCR.Reg)&^(0x3f)|value)
}
func (o *DSI_Type) GetGHCR_DT() uint32 {
	return volatile.LoadUint32(&o.GHCR.Reg) & 0x3f
}
func (o *DSI_Type) SetGHCR_VCID(value uint32) {
	volatile.StoreUint32(&o.GHCR.Reg, volatile.LoadUint32(&o.GHCR.Reg)&^(0xc0)|value<<6)
}
func (o *DSI_Type) GetGHCR_VCID() uint32 {
	return (volatile.LoadUint32(&o.GHCR.Reg) & 0xc0) >> 6
}
func (o *DSI_Type) SetGHCR_WCLSB(value uint32) {
	volatile.StoreUint32(&o.GHCR.Reg, volatile.LoadUint32(&o.GHCR.Reg)&^(0xff00)|value<<8)
}
func (o *DSI_Type) GetGHCR_WCLSB() uint32 {
	return (volatile.LoadUint32(&o.GHCR.Reg) & 0xff00) >> 8
}
func (o *DSI_Type) SetGHCR_WCMSB(value uint32) {
	volatile.StoreUint32(&o.GHCR.Reg, volatile.LoadUint32(&o.GHCR.Reg)&^(0xff0000)|value<<16)
}
func (o *DSI_Type) GetGHCR_WCMSB() uint32 {
	return (volatile.LoadUint32(&o.GHCR.Reg) & 0xff0000) >> 16
}

// DSI.GPDR: DSI Host Generic Payload Data Register
func (o *DSI_Type) SetGPDR_DATA1(value uint32) {
	volatile.StoreUint32(&o.GPDR.Reg, volatile.LoadUint32(&o.GPDR.Reg)&^(0xff)|value)
}
func (o *DSI_Type) GetGPDR_DATA1() uint32 {
	return volatile.LoadUint32(&o.GPDR.Reg) & 0xff
}
func (o *DSI_Type) SetGPDR_DATA2(value uint32) {
	volatile.StoreUint32(&o.GPDR.Reg, volatile.LoadUint32(&o.GPDR.Reg)&^(0xff00)|value<<8)
}
func (o *DSI_Type) GetGPDR_DATA2() uint32 {
	return (volatile.LoadUint32(&o.GPDR.Reg) & 0xff00) >> 8
}
func (o *DSI_Type) SetGPDR_DATA3(value uint32) {
	volatile.StoreUint32(&o.GPDR.Reg, volatile.LoadUint32(&o.GPDR.Reg)&^(0xff0000)|value<<16)
}
func (o *DSI_Type) GetGPDR_DATA3() uint32 {
	return (volatile.LoadUint32(&o.GPDR.Reg) & 0xff0000) >> 16
}
func (o *DSI_Type) SetGPDR_DATA4(value uint32) {
	volatile.StoreUint32(&o.GPDR.Reg, volatile.LoadUint32(&o.GPDR.Reg)&^(0xff000000)|value<<24)
}
func (o *DSI_Type) GetGPDR_DATA4() uint32 {
	return (volatile.LoadUint32(&o.GPDR.Reg) & 0xff000000) >> 24
}

// DSI.GPSR: DSI Host Generic Packet Status Register
func (o *DSI_Type) SetGPSR_CMDFE(value uint32) {
	volatile.StoreUint32(&o.GPSR.Reg, volatile.LoadUint32(&o.GPSR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetGPSR_CMDFE() uint32 {
	return volatile.LoadUint32(&o.GPSR.Reg) & 0x1
}
func (o *DSI_Type) SetGPSR_CMDFF(value uint32) {
	volatile.StoreUint32(&o.GPSR.Reg, volatile.LoadUint32(&o.GPSR.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetGPSR_CMDFF() uint32 {
	return (volatile.LoadUint32(&o.GPSR.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetGPSR_PWRFE(value uint32) {
	volatile.StoreUint32(&o.GPSR.Reg, volatile.LoadUint32(&o.GPSR.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetGPSR_PWRFE() uint32 {
	return (volatile.LoadUint32(&o.GPSR.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetGPSR_PWRFF(value uint32) {
	volatile.StoreUint32(&o.GPSR.Reg, volatile.LoadUint32(&o.GPSR.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetGPSR_PWRFF() uint32 {
	return (volatile.LoadUint32(&o.GPSR.Reg) & 0x8) >> 3
}
func (o *DSI_Type) SetGPSR_PRDFE(value uint32) {
	volatile.StoreUint32(&o.GPSR.Reg, volatile.LoadUint32(&o.GPSR.Reg)&^(0x10)|value<<4)
}
func (o *DSI_Type) GetGPSR_PRDFE() uint32 {
	return (volatile.LoadUint32(&o.GPSR.Reg) & 0x10) >> 4
}
func (o *DSI_Type) SetGPSR_PRDFF(value uint32) {
	volatile.StoreUint32(&o.GPSR.Reg, volatile.LoadUint32(&o.GPSR.Reg)&^(0x20)|value<<5)
}
func (o *DSI_Type) GetGPSR_PRDFF() uint32 {
	return (volatile.LoadUint32(&o.GPSR.Reg) & 0x20) >> 5
}
func (o *DSI_Type) SetGPSR_RCB(value uint32) {
	volatile.StoreUint32(&o.GPSR.Reg, volatile.LoadUint32(&o.GPSR.Reg)&^(0x40)|value<<6)
}
func (o *DSI_Type) GetGPSR_RCB() uint32 {
	return (volatile.LoadUint32(&o.GPSR.Reg) & 0x40) >> 6
}

// DSI.TCCR0: DSI Host Timeout Counter Configuration Register 0
func (o *DSI_Type) SetTCCR0_LPRX_TOCNT(value uint32) {
	volatile.StoreUint32(&o.TCCR0.Reg, volatile.LoadUint32(&o.TCCR0.Reg)&^(0xffff)|value)
}
func (o *DSI_Type) GetTCCR0_LPRX_TOCNT() uint32 {
	return volatile.LoadUint32(&o.TCCR0.Reg) & 0xffff
}
func (o *DSI_Type) SetTCCR0_HSTX_TOCNT(value uint32) {
	volatile.StoreUint32(&o.TCCR0.Reg, volatile.LoadUint32(&o.TCCR0.Reg)&^(0xffff0000)|value<<16)
}
func (o *DSI_Type) GetTCCR0_HSTX_TOCNT() uint32 {
	return (volatile.LoadUint32(&o.TCCR0.Reg) & 0xffff0000) >> 16
}

// DSI.TCCR1: DSI Host Timeout Counter Configuration Register 1
func (o *DSI_Type) SetTCCR1_HSRD_TOCNT(value uint32) {
	volatile.StoreUint32(&o.TCCR1.Reg, volatile.LoadUint32(&o.TCCR1.Reg)&^(0xffff)|value)
}
func (o *DSI_Type) GetTCCR1_HSRD_TOCNT() uint32 {
	return volatile.LoadUint32(&o.TCCR1.Reg) & 0xffff
}

// DSI.TCCR2: DSI Host Timeout Counter Configuration Register 2
func (o *DSI_Type) SetTCCR2_LPRD_TOCNT(value uint32) {
	volatile.StoreUint32(&o.TCCR2.Reg, volatile.LoadUint32(&o.TCCR2.Reg)&^(0xffff)|value)
}
func (o *DSI_Type) GetTCCR2_LPRD_TOCNT() uint32 {
	return volatile.LoadUint32(&o.TCCR2.Reg) & 0xffff
}

// DSI.TCCR3: DSI Host Timeout Counter Configuration Register 3
func (o *DSI_Type) SetTCCR3_HSWR_TOCNT(value uint32) {
	volatile.StoreUint32(&o.TCCR3.Reg, volatile.LoadUint32(&o.TCCR3.Reg)&^(0xffff)|value)
}
func (o *DSI_Type) GetTCCR3_HSWR_TOCNT() uint32 {
	return volatile.LoadUint32(&o.TCCR3.Reg) & 0xffff
}
func (o *DSI_Type) SetTCCR3_PM(value uint32) {
	volatile.StoreUint32(&o.TCCR3.Reg, volatile.LoadUint32(&o.TCCR3.Reg)&^(0x1000000)|value<<24)
}
func (o *DSI_Type) GetTCCR3_PM() uint32 {
	return (volatile.LoadUint32(&o.TCCR3.Reg) & 0x1000000) >> 24
}

// DSI.TCCR4: DSI Host Timeout Counter Configuration Register 4
func (o *DSI_Type) SetTCCR4_LSWR_TOCNT(value uint32) {
	volatile.StoreUint32(&o.TCCR4.Reg, volatile.LoadUint32(&o.TCCR4.Reg)&^(0xffff)|value)
}
func (o *DSI_Type) GetTCCR4_LSWR_TOCNT() uint32 {
	return volatile.LoadUint32(&o.TCCR4.Reg) & 0xffff
}

// DSI.TCCR5: DSI Host Timeout Counter Configuration Register 5
func (o *DSI_Type) SetTCCR5_BTA_TOCNT(value uint32) {
	volatile.StoreUint32(&o.TCCR5.Reg, volatile.LoadUint32(&o.TCCR5.Reg)&^(0xffff)|value)
}
func (o *DSI_Type) GetTCCR5_BTA_TOCNT() uint32 {
	return volatile.LoadUint32(&o.TCCR5.Reg) & 0xffff
}

// DSI.CLCR: DSI Host Clock Lane Configuration Register
func (o *DSI_Type) SetCLCR_DPCC(value uint32) {
	volatile.StoreUint32(&o.CLCR.Reg, volatile.LoadUint32(&o.CLCR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetCLCR_DPCC() uint32 {
	return volatile.LoadUint32(&o.CLCR.Reg) & 0x1
}
func (o *DSI_Type) SetCLCR_ACR(value uint32) {
	volatile.StoreUint32(&o.CLCR.Reg, volatile.LoadUint32(&o.CLCR.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetCLCR_ACR() uint32 {
	return (volatile.LoadUint32(&o.CLCR.Reg) & 0x2) >> 1
}

// DSI.CLTCR: DSI Host Clock Lane Timer Configuration Register
func (o *DSI_Type) SetCLTCR_LP2HS_TIME(value uint32) {
	volatile.StoreUint32(&o.CLTCR.Reg, volatile.LoadUint32(&o.CLTCR.Reg)&^(0x3ff)|value)
}
func (o *DSI_Type) GetCLTCR_LP2HS_TIME() uint32 {
	return volatile.LoadUint32(&o.CLTCR.Reg) & 0x3ff
}
func (o *DSI_Type) SetCLTCR_HS2LP_TIME(value uint32) {
	volatile.StoreUint32(&o.CLTCR.Reg, volatile.LoadUint32(&o.CLTCR.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DSI_Type) GetCLTCR_HS2LP_TIME() uint32 {
	return (volatile.LoadUint32(&o.CLTCR.Reg) & 0x3ff0000) >> 16
}

// DSI.DLTCR: DSI Host Data Lane Timer Configuration Register
func (o *DSI_Type) SetDLTCR_MRD_TIME(value uint32) {
	volatile.StoreUint32(&o.DLTCR.Reg, volatile.LoadUint32(&o.DLTCR.Reg)&^(0x7fff)|value)
}
func (o *DSI_Type) GetDLTCR_MRD_TIME() uint32 {
	return volatile.LoadUint32(&o.DLTCR.Reg) & 0x7fff
}
func (o *DSI_Type) SetDLTCR_LP2HS_TIME(value uint32) {
	volatile.StoreUint32(&o.DLTCR.Reg, volatile.LoadUint32(&o.DLTCR.Reg)&^(0xff0000)|value<<16)
}
func (o *DSI_Type) GetDLTCR_LP2HS_TIME() uint32 {
	return (volatile.LoadUint32(&o.DLTCR.Reg) & 0xff0000) >> 16
}
func (o *DSI_Type) SetDLTCR_HS2LP_TIME(value uint32) {
	volatile.StoreUint32(&o.DLTCR.Reg, volatile.LoadUint32(&o.DLTCR.Reg)&^(0xff000000)|value<<24)
}
func (o *DSI_Type) GetDLTCR_HS2LP_TIME() uint32 {
	return (volatile.LoadUint32(&o.DLTCR.Reg) & 0xff000000) >> 24
}

// DSI.PCTLR: DSI Host PHY Control Register
func (o *DSI_Type) SetPCTLR_DEN(value uint32) {
	volatile.StoreUint32(&o.PCTLR.Reg, volatile.LoadUint32(&o.PCTLR.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetPCTLR_DEN() uint32 {
	return (volatile.LoadUint32(&o.PCTLR.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetPCTLR_CKE(value uint32) {
	volatile.StoreUint32(&o.PCTLR.Reg, volatile.LoadUint32(&o.PCTLR.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetPCTLR_CKE() uint32 {
	return (volatile.LoadUint32(&o.PCTLR.Reg) & 0x4) >> 2
}

// DSI.PCONFR: DSI Host PHY Configuration Register
func (o *DSI_Type) SetPCONFR_NL(value uint32) {
	volatile.StoreUint32(&o.PCONFR.Reg, volatile.LoadUint32(&o.PCONFR.Reg)&^(0x3)|value)
}
func (o *DSI_Type) GetPCONFR_NL() uint32 {
	return volatile.LoadUint32(&o.PCONFR.Reg) & 0x3
}
func (o *DSI_Type) SetPCONFR_SW_TIME(value uint32) {
	volatile.StoreUint32(&o.PCONFR.Reg, volatile.LoadUint32(&o.PCONFR.Reg)&^(0xff00)|value<<8)
}
func (o *DSI_Type) GetPCONFR_SW_TIME() uint32 {
	return (volatile.LoadUint32(&o.PCONFR.Reg) & 0xff00) >> 8
}

// DSI.PUCR: DSI Host PHY ULPS Control Register
func (o *DSI_Type) SetPUCR_URCL(value uint32) {
	volatile.StoreUint32(&o.PUCR.Reg, volatile.LoadUint32(&o.PUCR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetPUCR_URCL() uint32 {
	return volatile.LoadUint32(&o.PUCR.Reg) & 0x1
}
func (o *DSI_Type) SetPUCR_UECL(value uint32) {
	volatile.StoreUint32(&o.PUCR.Reg, volatile.LoadUint32(&o.PUCR.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetPUCR_UECL() uint32 {
	return (volatile.LoadUint32(&o.PUCR.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetPUCR_URDL(value uint32) {
	volatile.StoreUint32(&o.PUCR.Reg, volatile.LoadUint32(&o.PUCR.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetPUCR_URDL() uint32 {
	return (volatile.LoadUint32(&o.PUCR.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetPUCR_UEDL(value uint32) {
	volatile.StoreUint32(&o.PUCR.Reg, volatile.LoadUint32(&o.PUCR.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetPUCR_UEDL() uint32 {
	return (volatile.LoadUint32(&o.PUCR.Reg) & 0x8) >> 3
}

// DSI.PTTCR: DSI Host PHY TX Triggers Configuration Register
func (o *DSI_Type) SetPTTCR_TX_TRIG(value uint32) {
	volatile.StoreUint32(&o.PTTCR.Reg, volatile.LoadUint32(&o.PTTCR.Reg)&^(0xf)|value)
}
func (o *DSI_Type) GetPTTCR_TX_TRIG() uint32 {
	return volatile.LoadUint32(&o.PTTCR.Reg) & 0xf
}

// DSI.PSR: DSI Host PHY Status Register
func (o *DSI_Type) SetPSR_PD(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetPSR_PD() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetPSR_PSSC(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetPSR_PSSC() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetPSR_UANC(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetPSR_UANC() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x8) >> 3
}
func (o *DSI_Type) SetPSR_PSS0(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x10)|value<<4)
}
func (o *DSI_Type) GetPSR_PSS0() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x10) >> 4
}
func (o *DSI_Type) SetPSR_UAN0(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x20)|value<<5)
}
func (o *DSI_Type) GetPSR_UAN0() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x20) >> 5
}
func (o *DSI_Type) SetPSR_RUE0(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x40)|value<<6)
}
func (o *DSI_Type) GetPSR_RUE0() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x40) >> 6
}
func (o *DSI_Type) SetPSR_PSS1(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x80)|value<<7)
}
func (o *DSI_Type) GetPSR_PSS1() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x80) >> 7
}
func (o *DSI_Type) SetPSR_UAN1(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetPSR_UAN1() uint32 {
	return (volatile.LoadUint32(&o.PSR.Reg) & 0x100) >> 8
}

// DSI.ISR0: DSI Host Interrupt & Status Register 0
func (o *DSI_Type) SetISR0_AE0(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetISR0_AE0() uint32 {
	return volatile.LoadUint32(&o.ISR0.Reg) & 0x1
}
func (o *DSI_Type) SetISR0_AE1(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetISR0_AE1() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetISR0_AE2(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetISR0_AE2() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetISR0_AE3(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetISR0_AE3() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x8) >> 3
}
func (o *DSI_Type) SetISR0_AE4(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x10)|value<<4)
}
func (o *DSI_Type) GetISR0_AE4() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x10) >> 4
}
func (o *DSI_Type) SetISR0_AE5(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x20)|value<<5)
}
func (o *DSI_Type) GetISR0_AE5() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x20) >> 5
}
func (o *DSI_Type) SetISR0_AE6(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x40)|value<<6)
}
func (o *DSI_Type) GetISR0_AE6() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x40) >> 6
}
func (o *DSI_Type) SetISR0_AE7(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x80)|value<<7)
}
func (o *DSI_Type) GetISR0_AE7() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x80) >> 7
}
func (o *DSI_Type) SetISR0_AE8(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetISR0_AE8() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x100) >> 8
}
func (o *DSI_Type) SetISR0_AE9(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetISR0_AE9() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetISR0_AE10(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetISR0_AE10() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetISR0_AE11(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x800)|value<<11)
}
func (o *DSI_Type) GetISR0_AE11() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x800) >> 11
}
func (o *DSI_Type) SetISR0_AE12(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x1000)|value<<12)
}
func (o *DSI_Type) GetISR0_AE12() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x1000) >> 12
}
func (o *DSI_Type) SetISR0_AE13(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x2000)|value<<13)
}
func (o *DSI_Type) GetISR0_AE13() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x2000) >> 13
}
func (o *DSI_Type) SetISR0_AE14(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x4000)|value<<14)
}
func (o *DSI_Type) GetISR0_AE14() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x4000) >> 14
}
func (o *DSI_Type) SetISR0_AE15(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x8000)|value<<15)
}
func (o *DSI_Type) GetISR0_AE15() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x8000) >> 15
}
func (o *DSI_Type) SetISR0_PE0(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x10000)|value<<16)
}
func (o *DSI_Type) GetISR0_PE0() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x10000) >> 16
}
func (o *DSI_Type) SetISR0_PE1(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x20000)|value<<17)
}
func (o *DSI_Type) GetISR0_PE1() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x20000) >> 17
}
func (o *DSI_Type) SetISR0_PE2(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x40000)|value<<18)
}
func (o *DSI_Type) GetISR0_PE2() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x40000) >> 18
}
func (o *DSI_Type) SetISR0_PE3(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x80000)|value<<19)
}
func (o *DSI_Type) GetISR0_PE3() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x80000) >> 19
}
func (o *DSI_Type) SetISR0_PE4(value uint32) {
	volatile.StoreUint32(&o.ISR0.Reg, volatile.LoadUint32(&o.ISR0.Reg)&^(0x100000)|value<<20)
}
func (o *DSI_Type) GetISR0_PE4() uint32 {
	return (volatile.LoadUint32(&o.ISR0.Reg) & 0x100000) >> 20
}

// DSI.ISR1: DSI Host Interrupt & Status Register 1
func (o *DSI_Type) SetISR1_TOHSTX(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetISR1_TOHSTX() uint32 {
	return volatile.LoadUint32(&o.ISR1.Reg) & 0x1
}
func (o *DSI_Type) SetISR1_TOLPRX(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetISR1_TOLPRX() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetISR1_ECCSE(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetISR1_ECCSE() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetISR1_ECCME(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetISR1_ECCME() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x8) >> 3
}
func (o *DSI_Type) SetISR1_CRCE(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x10)|value<<4)
}
func (o *DSI_Type) GetISR1_CRCE() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x10) >> 4
}
func (o *DSI_Type) SetISR1_PSE(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x20)|value<<5)
}
func (o *DSI_Type) GetISR1_PSE() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x20) >> 5
}
func (o *DSI_Type) SetISR1_EOTPE(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x40)|value<<6)
}
func (o *DSI_Type) GetISR1_EOTPE() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x40) >> 6
}
func (o *DSI_Type) SetISR1_LPWRE(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x80)|value<<7)
}
func (o *DSI_Type) GetISR1_LPWRE() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x80) >> 7
}
func (o *DSI_Type) SetISR1_GCWRE(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetISR1_GCWRE() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x100) >> 8
}
func (o *DSI_Type) SetISR1_GPWRE(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetISR1_GPWRE() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetISR1_GPTXE(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetISR1_GPTXE() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetISR1_GPRDE(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x800)|value<<11)
}
func (o *DSI_Type) GetISR1_GPRDE() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x800) >> 11
}
func (o *DSI_Type) SetISR1_GPRXE(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, volatile.LoadUint32(&o.ISR1.Reg)&^(0x1000)|value<<12)
}
func (o *DSI_Type) GetISR1_GPRXE() uint32 {
	return (volatile.LoadUint32(&o.ISR1.Reg) & 0x1000) >> 12
}

// DSI.IER0: DSI Host Interrupt Enable Register 0
func (o *DSI_Type) SetIER0_AE0IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetIER0_AE0IE() uint32 {
	return volatile.LoadUint32(&o.IER0.Reg) & 0x1
}
func (o *DSI_Type) SetIER0_AE1IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetIER0_AE1IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetIER0_AE2IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetIER0_AE2IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetIER0_AE3IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetIER0_AE3IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x8) >> 3
}
func (o *DSI_Type) SetIER0_AE4IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x10)|value<<4)
}
func (o *DSI_Type) GetIER0_AE4IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x10) >> 4
}
func (o *DSI_Type) SetIER0_AE5IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x20)|value<<5)
}
func (o *DSI_Type) GetIER0_AE5IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x20) >> 5
}
func (o *DSI_Type) SetIER0_AE6IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x40)|value<<6)
}
func (o *DSI_Type) GetIER0_AE6IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x40) >> 6
}
func (o *DSI_Type) SetIER0_AE7IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x80)|value<<7)
}
func (o *DSI_Type) GetIER0_AE7IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x80) >> 7
}
func (o *DSI_Type) SetIER0_AE8IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetIER0_AE8IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x100) >> 8
}
func (o *DSI_Type) SetIER0_AE9IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetIER0_AE9IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetIER0_AE10IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetIER0_AE10IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetIER0_AE11IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x800)|value<<11)
}
func (o *DSI_Type) GetIER0_AE11IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x800) >> 11
}
func (o *DSI_Type) SetIER0_AE12IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x1000)|value<<12)
}
func (o *DSI_Type) GetIER0_AE12IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x1000) >> 12
}
func (o *DSI_Type) SetIER0_AE13IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x2000)|value<<13)
}
func (o *DSI_Type) GetIER0_AE13IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x2000) >> 13
}
func (o *DSI_Type) SetIER0_AE14IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x4000)|value<<14)
}
func (o *DSI_Type) GetIER0_AE14IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x4000) >> 14
}
func (o *DSI_Type) SetIER0_AE15IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x8000)|value<<15)
}
func (o *DSI_Type) GetIER0_AE15IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x8000) >> 15
}
func (o *DSI_Type) SetIER0_PE0IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x10000)|value<<16)
}
func (o *DSI_Type) GetIER0_PE0IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x10000) >> 16
}
func (o *DSI_Type) SetIER0_PE1IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x20000)|value<<17)
}
func (o *DSI_Type) GetIER0_PE1IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x20000) >> 17
}
func (o *DSI_Type) SetIER0_PE2IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x40000)|value<<18)
}
func (o *DSI_Type) GetIER0_PE2IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x40000) >> 18
}
func (o *DSI_Type) SetIER0_PE3IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x80000)|value<<19)
}
func (o *DSI_Type) GetIER0_PE3IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x80000) >> 19
}
func (o *DSI_Type) SetIER0_PE4IE(value uint32) {
	volatile.StoreUint32(&o.IER0.Reg, volatile.LoadUint32(&o.IER0.Reg)&^(0x100000)|value<<20)
}
func (o *DSI_Type) GetIER0_PE4IE() uint32 {
	return (volatile.LoadUint32(&o.IER0.Reg) & 0x100000) >> 20
}

// DSI.IER1: DSI Host Interrupt Enable Register 1
func (o *DSI_Type) SetIER1_TOHSTXIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetIER1_TOHSTXIE() uint32 {
	return volatile.LoadUint32(&o.IER1.Reg) & 0x1
}
func (o *DSI_Type) SetIER1_TOLPRXIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetIER1_TOLPRXIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetIER1_ECCSEIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetIER1_ECCSEIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetIER1_ECCMEIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetIER1_ECCMEIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x8) >> 3
}
func (o *DSI_Type) SetIER1_CRCEIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x10)|value<<4)
}
func (o *DSI_Type) GetIER1_CRCEIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x10) >> 4
}
func (o *DSI_Type) SetIER1_PSEIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x20)|value<<5)
}
func (o *DSI_Type) GetIER1_PSEIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x20) >> 5
}
func (o *DSI_Type) SetIER1_EOTPEIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x40)|value<<6)
}
func (o *DSI_Type) GetIER1_EOTPEIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x40) >> 6
}
func (o *DSI_Type) SetIER1_LPWREIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x80)|value<<7)
}
func (o *DSI_Type) GetIER1_LPWREIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x80) >> 7
}
func (o *DSI_Type) SetIER1_GCWREIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetIER1_GCWREIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x100) >> 8
}
func (o *DSI_Type) SetIER1_GPWREIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetIER1_GPWREIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetIER1_GPTXEIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetIER1_GPTXEIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetIER1_GPRDEIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x800)|value<<11)
}
func (o *DSI_Type) GetIER1_GPRDEIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x800) >> 11
}
func (o *DSI_Type) SetIER1_GPRXEIE(value uint32) {
	volatile.StoreUint32(&o.IER1.Reg, volatile.LoadUint32(&o.IER1.Reg)&^(0x1000)|value<<12)
}
func (o *DSI_Type) GetIER1_GPRXEIE() uint32 {
	return (volatile.LoadUint32(&o.IER1.Reg) & 0x1000) >> 12
}

// DSI.FIR0: DSI Host Force Interrupt Register 0
func (o *DSI_Type) SetFIR0_FAE0(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetFIR0_FAE0() uint32 {
	return volatile.LoadUint32(&o.FIR0.Reg) & 0x1
}
func (o *DSI_Type) SetFIR0_FAE1(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetFIR0_FAE1() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetFIR0_FAE2(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetFIR0_FAE2() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetFIR0_FAE3(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetFIR0_FAE3() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x8) >> 3
}
func (o *DSI_Type) SetFIR0_FAE4(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x10)|value<<4)
}
func (o *DSI_Type) GetFIR0_FAE4() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x10) >> 4
}
func (o *DSI_Type) SetFIR0_FAE5(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x20)|value<<5)
}
func (o *DSI_Type) GetFIR0_FAE5() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x20) >> 5
}
func (o *DSI_Type) SetFIR0_FAE6(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x40)|value<<6)
}
func (o *DSI_Type) GetFIR0_FAE6() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x40) >> 6
}
func (o *DSI_Type) SetFIR0_FAE7(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x80)|value<<7)
}
func (o *DSI_Type) GetFIR0_FAE7() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x80) >> 7
}
func (o *DSI_Type) SetFIR0_FAE8(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetFIR0_FAE8() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x100) >> 8
}
func (o *DSI_Type) SetFIR0_FAE9(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetFIR0_FAE9() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetFIR0_FAE10(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetFIR0_FAE10() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetFIR0_FAE11(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x800)|value<<11)
}
func (o *DSI_Type) GetFIR0_FAE11() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x800) >> 11
}
func (o *DSI_Type) SetFIR0_FAE12(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x1000)|value<<12)
}
func (o *DSI_Type) GetFIR0_FAE12() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x1000) >> 12
}
func (o *DSI_Type) SetFIR0_FAE13(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x2000)|value<<13)
}
func (o *DSI_Type) GetFIR0_FAE13() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x2000) >> 13
}
func (o *DSI_Type) SetFIR0_FAE14(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x4000)|value<<14)
}
func (o *DSI_Type) GetFIR0_FAE14() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x4000) >> 14
}
func (o *DSI_Type) SetFIR0_FAE15(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x8000)|value<<15)
}
func (o *DSI_Type) GetFIR0_FAE15() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x8000) >> 15
}
func (o *DSI_Type) SetFIR0_FPE0(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x10000)|value<<16)
}
func (o *DSI_Type) GetFIR0_FPE0() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x10000) >> 16
}
func (o *DSI_Type) SetFIR0_FPE1(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x20000)|value<<17)
}
func (o *DSI_Type) GetFIR0_FPE1() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x20000) >> 17
}
func (o *DSI_Type) SetFIR0_FPE2(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x40000)|value<<18)
}
func (o *DSI_Type) GetFIR0_FPE2() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x40000) >> 18
}
func (o *DSI_Type) SetFIR0_FPE3(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x80000)|value<<19)
}
func (o *DSI_Type) GetFIR0_FPE3() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x80000) >> 19
}
func (o *DSI_Type) SetFIR0_FPE4(value uint32) {
	volatile.StoreUint32(&o.FIR0.Reg, volatile.LoadUint32(&o.FIR0.Reg)&^(0x100000)|value<<20)
}
func (o *DSI_Type) GetFIR0_FPE4() uint32 {
	return (volatile.LoadUint32(&o.FIR0.Reg) & 0x100000) >> 20
}

// DSI.FIR1: DSI Host Force Interrupt Register 1
func (o *DSI_Type) SetFIR1_FTOHSTX(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetFIR1_FTOHSTX() uint32 {
	return volatile.LoadUint32(&o.FIR1.Reg) & 0x1
}
func (o *DSI_Type) SetFIR1_FTOLPRX(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetFIR1_FTOLPRX() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetFIR1_FECCSE(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetFIR1_FECCSE() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetFIR1_FECCME(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetFIR1_FECCME() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x8) >> 3
}
func (o *DSI_Type) SetFIR1_FCRCE(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x10)|value<<4)
}
func (o *DSI_Type) GetFIR1_FCRCE() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x10) >> 4
}
func (o *DSI_Type) SetFIR1_FPSE(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x20)|value<<5)
}
func (o *DSI_Type) GetFIR1_FPSE() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x20) >> 5
}
func (o *DSI_Type) SetFIR1_FEOTPE(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x40)|value<<6)
}
func (o *DSI_Type) GetFIR1_FEOTPE() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x40) >> 6
}
func (o *DSI_Type) SetFIR1_FLPWRE(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x80)|value<<7)
}
func (o *DSI_Type) GetFIR1_FLPWRE() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x80) >> 7
}
func (o *DSI_Type) SetFIR1_FGCWRE(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetFIR1_FGCWRE() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x100) >> 8
}
func (o *DSI_Type) SetFIR1_FGPWRE(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetFIR1_FGPWRE() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetFIR1_FGPTXE(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetFIR1_FGPTXE() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetFIR1_FGPRDE(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x800)|value<<11)
}
func (o *DSI_Type) GetFIR1_FGPRDE() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x800) >> 11
}
func (o *DSI_Type) SetFIR1_FGPRXE(value uint32) {
	volatile.StoreUint32(&o.FIR1.Reg, volatile.LoadUint32(&o.FIR1.Reg)&^(0x1000)|value<<12)
}
func (o *DSI_Type) GetFIR1_FGPRXE() uint32 {
	return (volatile.LoadUint32(&o.FIR1.Reg) & 0x1000) >> 12
}

// DSI.VSCR: DSI Host Video Shadow Control Register
func (o *DSI_Type) SetVSCR_EN(value uint32) {
	volatile.StoreUint32(&o.VSCR.Reg, volatile.LoadUint32(&o.VSCR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetVSCR_EN() uint32 {
	return volatile.LoadUint32(&o.VSCR.Reg) & 0x1
}
func (o *DSI_Type) SetVSCR_UR(value uint32) {
	volatile.StoreUint32(&o.VSCR.Reg, volatile.LoadUint32(&o.VSCR.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetVSCR_UR() uint32 {
	return (volatile.LoadUint32(&o.VSCR.Reg) & 0x100) >> 8
}

// DSI.LCVCIDR: DSI Host LTDC Current VCID Register
func (o *DSI_Type) SetLCVCIDR_VCID(value uint32) {
	volatile.StoreUint32(&o.LCVCIDR.Reg, volatile.LoadUint32(&o.LCVCIDR.Reg)&^(0x3)|value)
}
func (o *DSI_Type) GetLCVCIDR_VCID() uint32 {
	return volatile.LoadUint32(&o.LCVCIDR.Reg) & 0x3
}

// DSI.LCCCR: DSI Host LTDC Current Color Coding Register
func (o *DSI_Type) SetLCCCR_COLC(value uint32) {
	volatile.StoreUint32(&o.LCCCR.Reg, volatile.LoadUint32(&o.LCCCR.Reg)&^(0xf)|value)
}
func (o *DSI_Type) GetLCCCR_COLC() uint32 {
	return volatile.LoadUint32(&o.LCCCR.Reg) & 0xf
}
func (o *DSI_Type) SetLCCCR_LPE(value uint32) {
	volatile.StoreUint32(&o.LCCCR.Reg, volatile.LoadUint32(&o.LCCCR.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetLCCCR_LPE() uint32 {
	return (volatile.LoadUint32(&o.LCCCR.Reg) & 0x100) >> 8
}

// DSI.LPMCCR: DSI Host Low-Power mode Current Configuration Register
func (o *DSI_Type) SetLPMCCR_VLPSIZE(value uint32) {
	volatile.StoreUint32(&o.LPMCCR.Reg, volatile.LoadUint32(&o.LPMCCR.Reg)&^(0xff)|value)
}
func (o *DSI_Type) GetLPMCCR_VLPSIZE() uint32 {
	return volatile.LoadUint32(&o.LPMCCR.Reg) & 0xff
}
func (o *DSI_Type) SetLPMCCR_LPSIZE(value uint32) {
	volatile.StoreUint32(&o.LPMCCR.Reg, volatile.LoadUint32(&o.LPMCCR.Reg)&^(0xff0000)|value<<16)
}
func (o *DSI_Type) GetLPMCCR_LPSIZE() uint32 {
	return (volatile.LoadUint32(&o.LPMCCR.Reg) & 0xff0000) >> 16
}

// DSI.VMCCR: DSI Host Video mode Current Configuration Register
func (o *DSI_Type) SetVMCCR_VMT(value uint32) {
	volatile.StoreUint32(&o.VMCCR.Reg, volatile.LoadUint32(&o.VMCCR.Reg)&^(0x3)|value)
}
func (o *DSI_Type) GetVMCCR_VMT() uint32 {
	return volatile.LoadUint32(&o.VMCCR.Reg) & 0x3
}
func (o *DSI_Type) SetVMCCR_LPVSAE(value uint32) {
	volatile.StoreUint32(&o.VMCCR.Reg, volatile.LoadUint32(&o.VMCCR.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetVMCCR_LPVSAE() uint32 {
	return (volatile.LoadUint32(&o.VMCCR.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetVMCCR_LPVBPE(value uint32) {
	volatile.StoreUint32(&o.VMCCR.Reg, volatile.LoadUint32(&o.VMCCR.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetVMCCR_LPVBPE() uint32 {
	return (volatile.LoadUint32(&o.VMCCR.Reg) & 0x8) >> 3
}
func (o *DSI_Type) SetVMCCR_LPVFPE(value uint32) {
	volatile.StoreUint32(&o.VMCCR.Reg, volatile.LoadUint32(&o.VMCCR.Reg)&^(0x10)|value<<4)
}
func (o *DSI_Type) GetVMCCR_LPVFPE() uint32 {
	return (volatile.LoadUint32(&o.VMCCR.Reg) & 0x10) >> 4
}
func (o *DSI_Type) SetVMCCR_LPVAE(value uint32) {
	volatile.StoreUint32(&o.VMCCR.Reg, volatile.LoadUint32(&o.VMCCR.Reg)&^(0x20)|value<<5)
}
func (o *DSI_Type) GetVMCCR_LPVAE() uint32 {
	return (volatile.LoadUint32(&o.VMCCR.Reg) & 0x20) >> 5
}
func (o *DSI_Type) SetVMCCR_LPHBPE(value uint32) {
	volatile.StoreUint32(&o.VMCCR.Reg, volatile.LoadUint32(&o.VMCCR.Reg)&^(0x40)|value<<6)
}
func (o *DSI_Type) GetVMCCR_LPHBPE() uint32 {
	return (volatile.LoadUint32(&o.VMCCR.Reg) & 0x40) >> 6
}
func (o *DSI_Type) SetVMCCR_LPHFE(value uint32) {
	volatile.StoreUint32(&o.VMCCR.Reg, volatile.LoadUint32(&o.VMCCR.Reg)&^(0x80)|value<<7)
}
func (o *DSI_Type) GetVMCCR_LPHFE() uint32 {
	return (volatile.LoadUint32(&o.VMCCR.Reg) & 0x80) >> 7
}
func (o *DSI_Type) SetVMCCR_FBTAAE(value uint32) {
	volatile.StoreUint32(&o.VMCCR.Reg, volatile.LoadUint32(&o.VMCCR.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetVMCCR_FBTAAE() uint32 {
	return (volatile.LoadUint32(&o.VMCCR.Reg) & 0x100) >> 8
}
func (o *DSI_Type) SetVMCCR_LPCE(value uint32) {
	volatile.StoreUint32(&o.VMCCR.Reg, volatile.LoadUint32(&o.VMCCR.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetVMCCR_LPCE() uint32 {
	return (volatile.LoadUint32(&o.VMCCR.Reg) & 0x200) >> 9
}

// DSI.VPCCR: DSI Host Video Packet Current Configuration Register
func (o *DSI_Type) SetVPCCR_VPSIZE(value uint32) {
	volatile.StoreUint32(&o.VPCCR.Reg, volatile.LoadUint32(&o.VPCCR.Reg)&^(0x3fff)|value)
}
func (o *DSI_Type) GetVPCCR_VPSIZE() uint32 {
	return volatile.LoadUint32(&o.VPCCR.Reg) & 0x3fff
}

// DSI.VCCCR: DSI Host Video Chunks Current Configuration Register
func (o *DSI_Type) SetVCCCR_NUMC(value uint32) {
	volatile.StoreUint32(&o.VCCCR.Reg, volatile.LoadUint32(&o.VCCCR.Reg)&^(0x1fff)|value)
}
func (o *DSI_Type) GetVCCCR_NUMC() uint32 {
	return volatile.LoadUint32(&o.VCCCR.Reg) & 0x1fff
}

// DSI.VNPCCR: DSI Host Video Null Packet Current Configuration Register
func (o *DSI_Type) SetVNPCCR_NPSIZE(value uint32) {
	volatile.StoreUint32(&o.VNPCCR.Reg, volatile.LoadUint32(&o.VNPCCR.Reg)&^(0x1fff)|value)
}
func (o *DSI_Type) GetVNPCCR_NPSIZE() uint32 {
	return volatile.LoadUint32(&o.VNPCCR.Reg) & 0x1fff
}

// DSI.VHSACCR: DSI Host Video HSA Current Configuration Register
func (o *DSI_Type) SetVHSACCR_HSA(value uint32) {
	volatile.StoreUint32(&o.VHSACCR.Reg, volatile.LoadUint32(&o.VHSACCR.Reg)&^(0xfff)|value)
}
func (o *DSI_Type) GetVHSACCR_HSA() uint32 {
	return volatile.LoadUint32(&o.VHSACCR.Reg) & 0xfff
}

// DSI.VHBPCCR: DSI Host Video HBP Current Configuration Register
func (o *DSI_Type) SetVHBPCCR_HBP(value uint32) {
	volatile.StoreUint32(&o.VHBPCCR.Reg, volatile.LoadUint32(&o.VHBPCCR.Reg)&^(0xfff)|value)
}
func (o *DSI_Type) GetVHBPCCR_HBP() uint32 {
	return volatile.LoadUint32(&o.VHBPCCR.Reg) & 0xfff
}

// DSI.VLCCR: DSI Host Video Line Current Configuration Register
func (o *DSI_Type) SetVLCCR_HLINE(value uint32) {
	volatile.StoreUint32(&o.VLCCR.Reg, volatile.LoadUint32(&o.VLCCR.Reg)&^(0x7fff)|value)
}
func (o *DSI_Type) GetVLCCR_HLINE() uint32 {
	return volatile.LoadUint32(&o.VLCCR.Reg) & 0x7fff
}

// DSI.VVSACCR: DSI Host Video VSA Current Configuration Register
func (o *DSI_Type) SetVVSACCR_VSA(value uint32) {
	volatile.StoreUint32(&o.VVSACCR.Reg, volatile.LoadUint32(&o.VVSACCR.Reg)&^(0x3ff)|value)
}
func (o *DSI_Type) GetVVSACCR_VSA() uint32 {
	return volatile.LoadUint32(&o.VVSACCR.Reg) & 0x3ff
}

// DSI.VVBPCCR: DSI Host Video VBP Current Configuration Register
func (o *DSI_Type) SetVVBPCCR_VBP(value uint32) {
	volatile.StoreUint32(&o.VVBPCCR.Reg, volatile.LoadUint32(&o.VVBPCCR.Reg)&^(0x3ff)|value)
}
func (o *DSI_Type) GetVVBPCCR_VBP() uint32 {
	return volatile.LoadUint32(&o.VVBPCCR.Reg) & 0x3ff
}

// DSI.VVFPCCR: DSI Host Video VFP Current Configuration Register
func (o *DSI_Type) SetVVFPCCR_VFP(value uint32) {
	volatile.StoreUint32(&o.VVFPCCR.Reg, volatile.LoadUint32(&o.VVFPCCR.Reg)&^(0x3ff)|value)
}
func (o *DSI_Type) GetVVFPCCR_VFP() uint32 {
	return volatile.LoadUint32(&o.VVFPCCR.Reg) & 0x3ff
}

// DSI.VVACCR: DSI Host Video VA Current Configuration Register
func (o *DSI_Type) SetVVACCR_VA(value uint32) {
	volatile.StoreUint32(&o.VVACCR.Reg, volatile.LoadUint32(&o.VVACCR.Reg)&^(0x3fff)|value)
}
func (o *DSI_Type) GetVVACCR_VA() uint32 {
	return volatile.LoadUint32(&o.VVACCR.Reg) & 0x3fff
}

// DSI.WCFGR: DSI Wrapper Configuration Register
func (o *DSI_Type) SetWCFGR_VSPOL(value uint32) {
	volatile.StoreUint32(&o.WCFGR.Reg, volatile.LoadUint32(&o.WCFGR.Reg)&^(0x80)|value<<7)
}
func (o *DSI_Type) GetWCFGR_VSPOL() uint32 {
	return (volatile.LoadUint32(&o.WCFGR.Reg) & 0x80) >> 7
}
func (o *DSI_Type) SetWCFGR_AR(value uint32) {
	volatile.StoreUint32(&o.WCFGR.Reg, volatile.LoadUint32(&o.WCFGR.Reg)&^(0x40)|value<<6)
}
func (o *DSI_Type) GetWCFGR_AR() uint32 {
	return (volatile.LoadUint32(&o.WCFGR.Reg) & 0x40) >> 6
}
func (o *DSI_Type) SetWCFGR_TEPOL(value uint32) {
	volatile.StoreUint32(&o.WCFGR.Reg, volatile.LoadUint32(&o.WCFGR.Reg)&^(0x20)|value<<5)
}
func (o *DSI_Type) GetWCFGR_TEPOL() uint32 {
	return (volatile.LoadUint32(&o.WCFGR.Reg) & 0x20) >> 5
}
func (o *DSI_Type) SetWCFGR_TESRC(value uint32) {
	volatile.StoreUint32(&o.WCFGR.Reg, volatile.LoadUint32(&o.WCFGR.Reg)&^(0x10)|value<<4)
}
func (o *DSI_Type) GetWCFGR_TESRC() uint32 {
	return (volatile.LoadUint32(&o.WCFGR.Reg) & 0x10) >> 4
}
func (o *DSI_Type) SetWCFGR_COLMUX(value uint32) {
	volatile.StoreUint32(&o.WCFGR.Reg, volatile.LoadUint32(&o.WCFGR.Reg)&^(0xe)|value<<1)
}
func (o *DSI_Type) GetWCFGR_COLMUX() uint32 {
	return (volatile.LoadUint32(&o.WCFGR.Reg) & 0xe) >> 1
}
func (o *DSI_Type) SetWCFGR_DSIM(value uint32) {
	volatile.StoreUint32(&o.WCFGR.Reg, volatile.LoadUint32(&o.WCFGR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetWCFGR_DSIM() uint32 {
	return volatile.LoadUint32(&o.WCFGR.Reg) & 0x1
}

// DSI.WCR: DSI Wrapper Control Register
func (o *DSI_Type) SetWCR_DSIEN(value uint32) {
	volatile.StoreUint32(&o.WCR.Reg, volatile.LoadUint32(&o.WCR.Reg)&^(0x8)|value<<3)
}
func (o *DSI_Type) GetWCR_DSIEN() uint32 {
	return (volatile.LoadUint32(&o.WCR.Reg) & 0x8) >> 3
}
func (o *DSI_Type) SetWCR_LTDCEN(value uint32) {
	volatile.StoreUint32(&o.WCR.Reg, volatile.LoadUint32(&o.WCR.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetWCR_LTDCEN() uint32 {
	return (volatile.LoadUint32(&o.WCR.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetWCR_SHTDN(value uint32) {
	volatile.StoreUint32(&o.WCR.Reg, volatile.LoadUint32(&o.WCR.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetWCR_SHTDN() uint32 {
	return (volatile.LoadUint32(&o.WCR.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetWCR_COLM(value uint32) {
	volatile.StoreUint32(&o.WCR.Reg, volatile.LoadUint32(&o.WCR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetWCR_COLM() uint32 {
	return volatile.LoadUint32(&o.WCR.Reg) & 0x1
}

// DSI.WIER: DSI Wrapper Interrupt Enable Register
func (o *DSI_Type) SetWIER_RRIE(value uint32) {
	volatile.StoreUint32(&o.WIER.Reg, volatile.LoadUint32(&o.WIER.Reg)&^(0x2000)|value<<13)
}
func (o *DSI_Type) GetWIER_RRIE() uint32 {
	return (volatile.LoadUint32(&o.WIER.Reg) & 0x2000) >> 13
}
func (o *DSI_Type) SetWIER_PLLUIE(value uint32) {
	volatile.StoreUint32(&o.WIER.Reg, volatile.LoadUint32(&o.WIER.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetWIER_PLLUIE() uint32 {
	return (volatile.LoadUint32(&o.WIER.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetWIER_PLLLIE(value uint32) {
	volatile.StoreUint32(&o.WIER.Reg, volatile.LoadUint32(&o.WIER.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetWIER_PLLLIE() uint32 {
	return (volatile.LoadUint32(&o.WIER.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetWIER_ERIE(value uint32) {
	volatile.StoreUint32(&o.WIER.Reg, volatile.LoadUint32(&o.WIER.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetWIER_ERIE() uint32 {
	return (volatile.LoadUint32(&o.WIER.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetWIER_TEIE(value uint32) {
	volatile.StoreUint32(&o.WIER.Reg, volatile.LoadUint32(&o.WIER.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetWIER_TEIE() uint32 {
	return volatile.LoadUint32(&o.WIER.Reg) & 0x1
}

// DSI.WISR: DSI Wrapper Interrupt & Status Register
func (o *DSI_Type) SetWISR_RRIF(value uint32) {
	volatile.StoreUint32(&o.WISR.Reg, volatile.LoadUint32(&o.WISR.Reg)&^(0x2000)|value<<13)
}
func (o *DSI_Type) GetWISR_RRIF() uint32 {
	return (volatile.LoadUint32(&o.WISR.Reg) & 0x2000) >> 13
}
func (o *DSI_Type) SetWISR_RRS(value uint32) {
	volatile.StoreUint32(&o.WISR.Reg, volatile.LoadUint32(&o.WISR.Reg)&^(0x1000)|value<<12)
}
func (o *DSI_Type) GetWISR_RRS() uint32 {
	return (volatile.LoadUint32(&o.WISR.Reg) & 0x1000) >> 12
}
func (o *DSI_Type) SetWISR_PLLUIF(value uint32) {
	volatile.StoreUint32(&o.WISR.Reg, volatile.LoadUint32(&o.WISR.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetWISR_PLLUIF() uint32 {
	return (volatile.LoadUint32(&o.WISR.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetWISR_PLLLIF(value uint32) {
	volatile.StoreUint32(&o.WISR.Reg, volatile.LoadUint32(&o.WISR.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetWISR_PLLLIF() uint32 {
	return (volatile.LoadUint32(&o.WISR.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetWISR_PLLLS(value uint32) {
	volatile.StoreUint32(&o.WISR.Reg, volatile.LoadUint32(&o.WISR.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetWISR_PLLLS() uint32 {
	return (volatile.LoadUint32(&o.WISR.Reg) & 0x100) >> 8
}
func (o *DSI_Type) SetWISR_BUSY(value uint32) {
	volatile.StoreUint32(&o.WISR.Reg, volatile.LoadUint32(&o.WISR.Reg)&^(0x4)|value<<2)
}
func (o *DSI_Type) GetWISR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.WISR.Reg) & 0x4) >> 2
}
func (o *DSI_Type) SetWISR_ERIF(value uint32) {
	volatile.StoreUint32(&o.WISR.Reg, volatile.LoadUint32(&o.WISR.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetWISR_ERIF() uint32 {
	return (volatile.LoadUint32(&o.WISR.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetWISR_TEIF(value uint32) {
	volatile.StoreUint32(&o.WISR.Reg, volatile.LoadUint32(&o.WISR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetWISR_TEIF() uint32 {
	return volatile.LoadUint32(&o.WISR.Reg) & 0x1
}

// DSI.WIFCR: DSI Wrapper Interrupt Flag Clear Register
func (o *DSI_Type) SetWIFCR_CRRIF(value uint32) {
	volatile.StoreUint32(&o.WIFCR.Reg, volatile.LoadUint32(&o.WIFCR.Reg)&^(0x2000)|value<<13)
}
func (o *DSI_Type) GetWIFCR_CRRIF() uint32 {
	return (volatile.LoadUint32(&o.WIFCR.Reg) & 0x2000) >> 13
}
func (o *DSI_Type) SetWIFCR_CPLLUIF(value uint32) {
	volatile.StoreUint32(&o.WIFCR.Reg, volatile.LoadUint32(&o.WIFCR.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetWIFCR_CPLLUIF() uint32 {
	return (volatile.LoadUint32(&o.WIFCR.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetWIFCR_CPLLLIF(value uint32) {
	volatile.StoreUint32(&o.WIFCR.Reg, volatile.LoadUint32(&o.WIFCR.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetWIFCR_CPLLLIF() uint32 {
	return (volatile.LoadUint32(&o.WIFCR.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetWIFCR_CERIF(value uint32) {
	volatile.StoreUint32(&o.WIFCR.Reg, volatile.LoadUint32(&o.WIFCR.Reg)&^(0x2)|value<<1)
}
func (o *DSI_Type) GetWIFCR_CERIF() uint32 {
	return (volatile.LoadUint32(&o.WIFCR.Reg) & 0x2) >> 1
}
func (o *DSI_Type) SetWIFCR_CTEIF(value uint32) {
	volatile.StoreUint32(&o.WIFCR.Reg, volatile.LoadUint32(&o.WIFCR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetWIFCR_CTEIF() uint32 {
	return volatile.LoadUint32(&o.WIFCR.Reg) & 0x1
}

// DSI.WPCR1: DSI Wrapper PHY Configuration Register 1
func (o *DSI_Type) SetWPCR1_TCLKPOSTEN(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x8000000)|value<<27)
}
func (o *DSI_Type) GetWPCR1_TCLKPOSTEN() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x8000000) >> 27
}
func (o *DSI_Type) SetWPCR1_TLPXCEN(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x4000000)|value<<26)
}
func (o *DSI_Type) GetWPCR1_TLPXCEN() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x4000000) >> 26
}
func (o *DSI_Type) SetWPCR1_THSEXITEN(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x2000000)|value<<25)
}
func (o *DSI_Type) GetWPCR1_THSEXITEN() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x2000000) >> 25
}
func (o *DSI_Type) SetWPCR1_TLPXDEN(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x1000000)|value<<24)
}
func (o *DSI_Type) GetWPCR1_TLPXDEN() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x1000000) >> 24
}
func (o *DSI_Type) SetWPCR1_THSZEROEN(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x800000)|value<<23)
}
func (o *DSI_Type) GetWPCR1_THSZEROEN() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x800000) >> 23
}
func (o *DSI_Type) SetWPCR1_THSTRAILEN(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x400000)|value<<22)
}
func (o *DSI_Type) GetWPCR1_THSTRAILEN() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x400000) >> 22
}
func (o *DSI_Type) SetWPCR1_THSPREPEN(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x200000)|value<<21)
}
func (o *DSI_Type) GetWPCR1_THSPREPEN() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x200000) >> 21
}
func (o *DSI_Type) SetWPCR1_TCLKZEROEN(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x100000)|value<<20)
}
func (o *DSI_Type) GetWPCR1_TCLKZEROEN() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x100000) >> 20
}
func (o *DSI_Type) SetWPCR1_TCLKPREPEN(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x80000)|value<<19)
}
func (o *DSI_Type) GetWPCR1_TCLKPREPEN() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x80000) >> 19
}
func (o *DSI_Type) SetWPCR1_PDEN(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x40000)|value<<18)
}
func (o *DSI_Type) GetWPCR1_PDEN() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x40000) >> 18
}
func (o *DSI_Type) SetWPCR1_TDDL(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x10000)|value<<16)
}
func (o *DSI_Type) GetWPCR1_TDDL() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x10000) >> 16
}
func (o *DSI_Type) SetWPCR1_CDOFFDL(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x4000)|value<<14)
}
func (o *DSI_Type) GetWPCR1_CDOFFDL() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x4000) >> 14
}
func (o *DSI_Type) SetWPCR1_FTXSMDL(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x2000)|value<<13)
}
func (o *DSI_Type) GetWPCR1_FTXSMDL() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x2000) >> 13
}
func (o *DSI_Type) SetWPCR1_FTXSMCL(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x1000)|value<<12)
}
func (o *DSI_Type) GetWPCR1_FTXSMCL() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x1000) >> 12
}
func (o *DSI_Type) SetWPCR1_HSIDL1(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x800)|value<<11)
}
func (o *DSI_Type) GetWPCR1_HSIDL1() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x800) >> 11
}
func (o *DSI_Type) SetWPCR1_HSIDL0(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x400)|value<<10)
}
func (o *DSI_Type) GetWPCR1_HSIDL0() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x400) >> 10
}
func (o *DSI_Type) SetWPCR1_HSICL(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x200)|value<<9)
}
func (o *DSI_Type) GetWPCR1_HSICL() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x200) >> 9
}
func (o *DSI_Type) SetWPCR1_SWDL1(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x100)|value<<8)
}
func (o *DSI_Type) GetWPCR1_SWDL1() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x100) >> 8
}
func (o *DSI_Type) SetWPCR1_SWDL0(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x80)|value<<7)
}
func (o *DSI_Type) GetWPCR1_SWDL0() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x80) >> 7
}
func (o *DSI_Type) SetWPCR1_SWCL(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x40)|value<<6)
}
func (o *DSI_Type) GetWPCR1_SWCL() uint32 {
	return (volatile.LoadUint32(&o.WPCR1.Reg) & 0x40) >> 6
}
func (o *DSI_Type) SetWPCR1_UIX4(value uint32) {
	volatile.StoreUint32(&o.WPCR1.Reg, volatile.LoadUint32(&o.WPCR1.Reg)&^(0x3f)|value)
}
func (o *DSI_Type) GetWPCR1_UIX4() uint32 {
	return volatile.LoadUint32(&o.WPCR1.Reg) & 0x3f
}

// DSI.WPCR2: DSI Wrapper PHY Configuration Register 2
func (o *DSI_Type) SetWPCR2_LPRXFT(value uint32) {
	volatile.StoreUint32(&o.WPCR2.Reg, volatile.LoadUint32(&o.WPCR2.Reg)&^(0x6000000)|value<<25)
}
func (o *DSI_Type) GetWPCR2_LPRXFT() uint32 {
	return (volatile.LoadUint32(&o.WPCR2.Reg) & 0x6000000) >> 25
}
func (o *DSI_Type) SetWPCR2_FLPRXLPM(value uint32) {
	volatile.StoreUint32(&o.WPCR2.Reg, volatile.LoadUint32(&o.WPCR2.Reg)&^(0x400000)|value<<22)
}
func (o *DSI_Type) GetWPCR2_FLPRXLPM() uint32 {
	return (volatile.LoadUint32(&o.WPCR2.Reg) & 0x400000) >> 22
}
func (o *DSI_Type) SetWPCR2_HSTXSRCDL(value uint32) {
	volatile.StoreUint32(&o.WPCR2.Reg, volatile.LoadUint32(&o.WPCR2.Reg)&^(0xc0000)|value<<18)
}
func (o *DSI_Type) GetWPCR2_HSTXSRCDL() uint32 {
	return (volatile.LoadUint32(&o.WPCR2.Reg) & 0xc0000) >> 18
}
func (o *DSI_Type) SetWPCR2_HSTXSRCCL(value uint32) {
	volatile.StoreUint32(&o.WPCR2.Reg, volatile.LoadUint32(&o.WPCR2.Reg)&^(0x30000)|value<<16)
}
func (o *DSI_Type) GetWPCR2_HSTXSRCCL() uint32 {
	return (volatile.LoadUint32(&o.WPCR2.Reg) & 0x30000) >> 16
}
func (o *DSI_Type) SetWPCR2_SDCC(value uint32) {
	volatile.StoreUint32(&o.WPCR2.Reg, volatile.LoadUint32(&o.WPCR2.Reg)&^(0x1000)|value<<12)
}
func (o *DSI_Type) GetWPCR2_SDCC() uint32 {
	return (volatile.LoadUint32(&o.WPCR2.Reg) & 0x1000) >> 12
}
func (o *DSI_Type) SetWPCR2_LPSRDL(value uint32) {
	volatile.StoreUint32(&o.WPCR2.Reg, volatile.LoadUint32(&o.WPCR2.Reg)&^(0x300)|value<<8)
}
func (o *DSI_Type) GetWPCR2_LPSRDL() uint32 {
	return (volatile.LoadUint32(&o.WPCR2.Reg) & 0x300) >> 8
}
func (o *DSI_Type) SetWPCR2_LPSRCL(value uint32) {
	volatile.StoreUint32(&o.WPCR2.Reg, volatile.LoadUint32(&o.WPCR2.Reg)&^(0xc0)|value<<6)
}
func (o *DSI_Type) GetWPCR2_LPSRCL() uint32 {
	return (volatile.LoadUint32(&o.WPCR2.Reg) & 0xc0) >> 6
}
func (o *DSI_Type) SetWPCR2_HSTXDLL(value uint32) {
	volatile.StoreUint32(&o.WPCR2.Reg, volatile.LoadUint32(&o.WPCR2.Reg)&^(0xc)|value<<2)
}
func (o *DSI_Type) GetWPCR2_HSTXDLL() uint32 {
	return (volatile.LoadUint32(&o.WPCR2.Reg) & 0xc) >> 2
}
func (o *DSI_Type) SetWPCR2_HSTXDCL(value uint32) {
	volatile.StoreUint32(&o.WPCR2.Reg, volatile.LoadUint32(&o.WPCR2.Reg)&^(0x3)|value)
}
func (o *DSI_Type) GetWPCR2_HSTXDCL() uint32 {
	return volatile.LoadUint32(&o.WPCR2.Reg) & 0x3
}

// DSI.WPCR3: DSI Wrapper PHY Configuration Register 3
func (o *DSI_Type) SetWPCR3_THSTRAIL(value uint32) {
	volatile.StoreUint32(&o.WPCR3.Reg, volatile.LoadUint32(&o.WPCR3.Reg)&^(0xff000000)|value<<24)
}
func (o *DSI_Type) GetWPCR3_THSTRAIL() uint32 {
	return (volatile.LoadUint32(&o.WPCR3.Reg) & 0xff000000) >> 24
}
func (o *DSI_Type) SetWPCR3_THSPREP(value uint32) {
	volatile.StoreUint32(&o.WPCR3.Reg, volatile.LoadUint32(&o.WPCR3.Reg)&^(0xff0000)|value<<16)
}
func (o *DSI_Type) GetWPCR3_THSPREP() uint32 {
	return (volatile.LoadUint32(&o.WPCR3.Reg) & 0xff0000) >> 16
}
func (o *DSI_Type) SetWPCR3_TCLKZEO(value uint32) {
	volatile.StoreUint32(&o.WPCR3.Reg, volatile.LoadUint32(&o.WPCR3.Reg)&^(0xff00)|value<<8)
}
func (o *DSI_Type) GetWPCR3_TCLKZEO() uint32 {
	return (volatile.LoadUint32(&o.WPCR3.Reg) & 0xff00) >> 8
}
func (o *DSI_Type) SetWPCR3_TCLKPREP(value uint32) {
	volatile.StoreUint32(&o.WPCR3.Reg, volatile.LoadUint32(&o.WPCR3.Reg)&^(0xff)|value)
}
func (o *DSI_Type) GetWPCR3_TCLKPREP() uint32 {
	return volatile.LoadUint32(&o.WPCR3.Reg) & 0xff
}

// DSI.WPCR4: DSI_WPCR4
func (o *DSI_Type) SetWPCR4_TLPXC(value uint32) {
	volatile.StoreUint32(&o.WPCR4.Reg, volatile.LoadUint32(&o.WPCR4.Reg)&^(0xff000000)|value<<24)
}
func (o *DSI_Type) GetWPCR4_TLPXC() uint32 {
	return (volatile.LoadUint32(&o.WPCR4.Reg) & 0xff000000) >> 24
}
func (o *DSI_Type) SetWPCR4_THSEXIT(value uint32) {
	volatile.StoreUint32(&o.WPCR4.Reg, volatile.LoadUint32(&o.WPCR4.Reg)&^(0xff0000)|value<<16)
}
func (o *DSI_Type) GetWPCR4_THSEXIT() uint32 {
	return (volatile.LoadUint32(&o.WPCR4.Reg) & 0xff0000) >> 16
}
func (o *DSI_Type) SetWPCR4_TLPXD(value uint32) {
	volatile.StoreUint32(&o.WPCR4.Reg, volatile.LoadUint32(&o.WPCR4.Reg)&^(0xff00)|value<<8)
}
func (o *DSI_Type) GetWPCR4_TLPXD() uint32 {
	return (volatile.LoadUint32(&o.WPCR4.Reg) & 0xff00) >> 8
}
func (o *DSI_Type) SetWPCR4_THSZERO(value uint32) {
	volatile.StoreUint32(&o.WPCR4.Reg, volatile.LoadUint32(&o.WPCR4.Reg)&^(0xff)|value)
}
func (o *DSI_Type) GetWPCR4_THSZERO() uint32 {
	return volatile.LoadUint32(&o.WPCR4.Reg) & 0xff
}

// DSI.WPCR5: DSI Wrapper PHY Configuration Register 5
func (o *DSI_Type) SetWPCR5_THSZERO(value uint32) {
	volatile.StoreUint32(&o.WPCR5.Reg, volatile.LoadUint32(&o.WPCR5.Reg)&^(0xff)|value)
}
func (o *DSI_Type) GetWPCR5_THSZERO() uint32 {
	return volatile.LoadUint32(&o.WPCR5.Reg) & 0xff
}

// DSI.WRPCR: DSI Wrapper Regulator and PLL Control Register
func (o *DSI_Type) SetWRPCR_REGEN(value uint32) {
	volatile.StoreUint32(&o.WRPCR.Reg, volatile.LoadUint32(&o.WRPCR.Reg)&^(0x1000000)|value<<24)
}
func (o *DSI_Type) GetWRPCR_REGEN() uint32 {
	return (volatile.LoadUint32(&o.WRPCR.Reg) & 0x1000000) >> 24
}
func (o *DSI_Type) SetWRPCR_ODF(value uint32) {
	volatile.StoreUint32(&o.WRPCR.Reg, volatile.LoadUint32(&o.WRPCR.Reg)&^(0x30000)|value<<16)
}
func (o *DSI_Type) GetWRPCR_ODF() uint32 {
	return (volatile.LoadUint32(&o.WRPCR.Reg) & 0x30000) >> 16
}
func (o *DSI_Type) SetWRPCR_IDF(value uint32) {
	volatile.StoreUint32(&o.WRPCR.Reg, volatile.LoadUint32(&o.WRPCR.Reg)&^(0x7800)|value<<11)
}
func (o *DSI_Type) GetWRPCR_IDF() uint32 {
	return (volatile.LoadUint32(&o.WRPCR.Reg) & 0x7800) >> 11
}
func (o *DSI_Type) SetWRPCR_NDIV(value uint32) {
	volatile.StoreUint32(&o.WRPCR.Reg, volatile.LoadUint32(&o.WRPCR.Reg)&^(0x1fc)|value<<2)
}
func (o *DSI_Type) GetWRPCR_NDIV() uint32 {
	return (volatile.LoadUint32(&o.WRPCR.Reg) & 0x1fc) >> 2
}
func (o *DSI_Type) SetWRPCR_PLLEN(value uint32) {
	volatile.StoreUint32(&o.WRPCR.Reg, volatile.LoadUint32(&o.WRPCR.Reg)&^(0x1)|value)
}
func (o *DSI_Type) GetWRPCR_PLLEN() uint32 {
	return volatile.LoadUint32(&o.WRPCR.Reg) & 0x1
}

// Nested Vectored Interrupt Controller
type NVIC_Type struct {
	ISER0 volatile.Register32 // 0x0
	ISER1 volatile.Register32 // 0x4
	ISER2 volatile.Register32 // 0x8
	_     [116]byte
	ICER0 volatile.Register32 // 0x80
	ICER1 volatile.Register32 // 0x84
	ICER2 volatile.Register32 // 0x88
	_     [116]byte
	ISPR0 volatile.Register32 // 0x100
	ISPR1 volatile.Register32 // 0x104
	ISPR2 volatile.Register32 // 0x108
	_     [116]byte
	ICPR0 volatile.Register32 // 0x180
	ICPR1 volatile.Register32 // 0x184
	ICPR2 volatile.Register32 // 0x188
	_     [116]byte
	IABR0 volatile.Register32 // 0x200
	IABR1 volatile.Register32 // 0x204
	IABR2 volatile.Register32 // 0x208
	_     [244]byte
	IPR0  volatile.Register32 // 0x300
	IPR1  volatile.Register32 // 0x304
	IPR2  volatile.Register32 // 0x308
	IPR3  volatile.Register32 // 0x30C
	IPR4  volatile.Register32 // 0x310
	IPR5  volatile.Register32 // 0x314
	IPR6  volatile.Register32 // 0x318
	IPR7  volatile.Register32 // 0x31C
	IPR8  volatile.Register32 // 0x320
	IPR9  volatile.Register32 // 0x324
	IPR10 volatile.Register32 // 0x328
	IPR11 volatile.Register32 // 0x32C
	IPR12 volatile.Register32 // 0x330
	IPR13 volatile.Register32 // 0x334
	IPR14 volatile.Register32 // 0x338
	IPR15 volatile.Register32 // 0x33C
	IPR16 volatile.Register32 // 0x340
	IPR17 volatile.Register32 // 0x344
	IPR18 volatile.Register32 // 0x348
	IPR19 volatile.Register32 // 0x34C
	IPR20 volatile.Register32 // 0x350
	IPR21 volatile.Register32 // 0x354
	IPR22 volatile.Register32 // 0x358
	IPR23 volatile.Register32 // 0x35C
	IPR24 volatile.Register32 // 0x360
	IPR25 volatile.Register32 // 0x364
	IPR26 volatile.Register32 // 0x368
	IPR27 volatile.Register32 // 0x36C
	IPR28 volatile.Register32 // 0x370
}

// NVIC.ISER0: Interrupt Set-Enable Register
func (o *NVIC_Type) SetISER0(value uint32) {
	volatile.StoreUint32(&o.ISER0.Reg, value)
}
func (o *NVIC_Type) GetISER0() uint32 {
	return volatile.LoadUint32(&o.ISER0.Reg)
}

// NVIC.ISER1: Interrupt Set-Enable Register
func (o *NVIC_Type) SetISER1(value uint32) {
	volatile.StoreUint32(&o.ISER1.Reg, value)
}
func (o *NVIC_Type) GetISER1() uint32 {
	return volatile.LoadUint32(&o.ISER1.Reg)
}

// NVIC.ISER2: Interrupt Set-Enable Register
func (o *NVIC_Type) SetISER2(value uint32) {
	volatile.StoreUint32(&o.ISER2.Reg, value)
}
func (o *NVIC_Type) GetISER2() uint32 {
	return volatile.LoadUint32(&o.ISER2.Reg)
}

// NVIC.ICER0: Interrupt Clear-Enable Register
func (o *NVIC_Type) SetICER0(value uint32) {
	volatile.StoreUint32(&o.ICER0.Reg, value)
}
func (o *NVIC_Type) GetICER0() uint32 {
	return volatile.LoadUint32(&o.ICER0.Reg)
}

// NVIC.ICER1: Interrupt Clear-Enable Register
func (o *NVIC_Type) SetICER1(value uint32) {
	volatile.StoreUint32(&o.ICER1.Reg, value)
}
func (o *NVIC_Type) GetICER1() uint32 {
	return volatile.LoadUint32(&o.ICER1.Reg)
}

// NVIC.ICER2: Interrupt Clear-Enable Register
func (o *NVIC_Type) SetICER2(value uint32) {
	volatile.StoreUint32(&o.ICER2.Reg, value)
}
func (o *NVIC_Type) GetICER2() uint32 {
	return volatile.LoadUint32(&o.ICER2.Reg)
}

// NVIC.ISPR0: Interrupt Set-Pending Register
func (o *NVIC_Type) SetISPR0(value uint32) {
	volatile.StoreUint32(&o.ISPR0.Reg, value)
}
func (o *NVIC_Type) GetISPR0() uint32 {
	return volatile.LoadUint32(&o.ISPR0.Reg)
}

// NVIC.ISPR1: Interrupt Set-Pending Register
func (o *NVIC_Type) SetISPR1(value uint32) {
	volatile.StoreUint32(&o.ISPR1.Reg, value)
}
func (o *NVIC_Type) GetISPR1() uint32 {
	return volatile.LoadUint32(&o.ISPR1.Reg)
}

// NVIC.ISPR2: Interrupt Set-Pending Register
func (o *NVIC_Type) SetISPR2(value uint32) {
	volatile.StoreUint32(&o.ISPR2.Reg, value)
}
func (o *NVIC_Type) GetISPR2() uint32 {
	return volatile.LoadUint32(&o.ISPR2.Reg)
}

// NVIC.ICPR0: Interrupt Clear-Pending Register
func (o *NVIC_Type) SetICPR0(value uint32) {
	volatile.StoreUint32(&o.ICPR0.Reg, value)
}
func (o *NVIC_Type) GetICPR0() uint32 {
	return volatile.LoadUint32(&o.ICPR0.Reg)
}

// NVIC.ICPR1: Interrupt Clear-Pending Register
func (o *NVIC_Type) SetICPR1(value uint32) {
	volatile.StoreUint32(&o.ICPR1.Reg, value)
}
func (o *NVIC_Type) GetICPR1() uint32 {
	return volatile.LoadUint32(&o.ICPR1.Reg)
}

// NVIC.ICPR2: Interrupt Clear-Pending Register
func (o *NVIC_Type) SetICPR2(value uint32) {
	volatile.StoreUint32(&o.ICPR2.Reg, value)
}
func (o *NVIC_Type) GetICPR2() uint32 {
	return volatile.LoadUint32(&o.ICPR2.Reg)
}

// NVIC.IABR0: Interrupt Active Bit Register
func (o *NVIC_Type) SetIABR0(value uint32) {
	volatile.StoreUint32(&o.IABR0.Reg, value)
}
func (o *NVIC_Type) GetIABR0() uint32 {
	return volatile.LoadUint32(&o.IABR0.Reg)
}

// NVIC.IABR1: Interrupt Active Bit Register
func (o *NVIC_Type) SetIABR1(value uint32) {
	volatile.StoreUint32(&o.IABR1.Reg, value)
}
func (o *NVIC_Type) GetIABR1() uint32 {
	return volatile.LoadUint32(&o.IABR1.Reg)
}

// NVIC.IABR2: Interrupt Active Bit Register
func (o *NVIC_Type) SetIABR2(value uint32) {
	volatile.StoreUint32(&o.IABR2.Reg, value)
}
func (o *NVIC_Type) GetIABR2() uint32 {
	return volatile.LoadUint32(&o.IABR2.Reg)
}

// NVIC.IPR0: Interrupt Priority Register
func (o *NVIC_Type) SetIPR0_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR0_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR0.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR0_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR0_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR0_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR0_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR0_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR0.Reg, volatile.LoadUint32(&o.IPR0.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR0_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR0.Reg) & 0xff000000) >> 24
}

// NVIC.IPR1: Interrupt Priority Register
func (o *NVIC_Type) SetIPR1_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR1_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR1.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR1_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR1_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR1_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR1_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR1_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR1.Reg, volatile.LoadUint32(&o.IPR1.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR1_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR1.Reg) & 0xff000000) >> 24
}

// NVIC.IPR2: Interrupt Priority Register
func (o *NVIC_Type) SetIPR2_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR2_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR2.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR2_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR2_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR2_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR2_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR2_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR2.Reg, volatile.LoadUint32(&o.IPR2.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR2_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR2.Reg) & 0xff000000) >> 24
}

// NVIC.IPR3: Interrupt Priority Register
func (o *NVIC_Type) SetIPR3_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR3_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR3.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR3_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR3_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR3_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR3_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR3_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR3.Reg, volatile.LoadUint32(&o.IPR3.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR3_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR3.Reg) & 0xff000000) >> 24
}

// NVIC.IPR4: Interrupt Priority Register
func (o *NVIC_Type) SetIPR4_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR4.Reg, volatile.LoadUint32(&o.IPR4.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR4_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR4.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR4_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR4.Reg, volatile.LoadUint32(&o.IPR4.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR4_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR4.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR4_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR4.Reg, volatile.LoadUint32(&o.IPR4.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR4_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR4.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR4_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR4.Reg, volatile.LoadUint32(&o.IPR4.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR4_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR4.Reg) & 0xff000000) >> 24
}

// NVIC.IPR5: Interrupt Priority Register
func (o *NVIC_Type) SetIPR5_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR5.Reg, volatile.LoadUint32(&o.IPR5.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR5_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR5.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR5_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR5.Reg, volatile.LoadUint32(&o.IPR5.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR5_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR5.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR5_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR5.Reg, volatile.LoadUint32(&o.IPR5.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR5_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR5.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR5_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR5.Reg, volatile.LoadUint32(&o.IPR5.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR5_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR5.Reg) & 0xff000000) >> 24
}

// NVIC.IPR6: Interrupt Priority Register
func (o *NVIC_Type) SetIPR6_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR6.Reg, volatile.LoadUint32(&o.IPR6.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR6_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR6.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR6_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR6.Reg, volatile.LoadUint32(&o.IPR6.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR6_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR6.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR6_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR6.Reg, volatile.LoadUint32(&o.IPR6.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR6_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR6.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR6_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR6.Reg, volatile.LoadUint32(&o.IPR6.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR6_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR6.Reg) & 0xff000000) >> 24
}

// NVIC.IPR7: Interrupt Priority Register
func (o *NVIC_Type) SetIPR7_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR7.Reg, volatile.LoadUint32(&o.IPR7.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR7_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR7.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR7_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR7.Reg, volatile.LoadUint32(&o.IPR7.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR7_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR7.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR7_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR7.Reg, volatile.LoadUint32(&o.IPR7.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR7_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR7.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR7_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR7.Reg, volatile.LoadUint32(&o.IPR7.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR7_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR7.Reg) & 0xff000000) >> 24
}

// NVIC.IPR8: Interrupt Priority Register
func (o *NVIC_Type) SetIPR8_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR8.Reg, volatile.LoadUint32(&o.IPR8.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR8_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR8.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR8_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR8.Reg, volatile.LoadUint32(&o.IPR8.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR8_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR8.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR8_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR8.Reg, volatile.LoadUint32(&o.IPR8.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR8_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR8.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR8_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR8.Reg, volatile.LoadUint32(&o.IPR8.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR8_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR8.Reg) & 0xff000000) >> 24
}

// NVIC.IPR9: Interrupt Priority Register
func (o *NVIC_Type) SetIPR9_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR9.Reg, volatile.LoadUint32(&o.IPR9.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR9_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR9.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR9_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR9.Reg, volatile.LoadUint32(&o.IPR9.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR9_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR9.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR9_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR9.Reg, volatile.LoadUint32(&o.IPR9.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR9_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR9.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR9_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR9.Reg, volatile.LoadUint32(&o.IPR9.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR9_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR9.Reg) & 0xff000000) >> 24
}

// NVIC.IPR10: Interrupt Priority Register
func (o *NVIC_Type) SetIPR10_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR10.Reg, volatile.LoadUint32(&o.IPR10.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR10_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR10.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR10_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR10.Reg, volatile.LoadUint32(&o.IPR10.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR10_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR10.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR10_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR10.Reg, volatile.LoadUint32(&o.IPR10.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR10_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR10.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR10_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR10.Reg, volatile.LoadUint32(&o.IPR10.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR10_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR10.Reg) & 0xff000000) >> 24
}

// NVIC.IPR11: Interrupt Priority Register
func (o *NVIC_Type) SetIPR11_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR11.Reg, volatile.LoadUint32(&o.IPR11.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR11_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR11.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR11_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR11.Reg, volatile.LoadUint32(&o.IPR11.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR11_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR11.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR11_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR11.Reg, volatile.LoadUint32(&o.IPR11.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR11_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR11.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR11_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR11.Reg, volatile.LoadUint32(&o.IPR11.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR11_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR11.Reg) & 0xff000000) >> 24
}

// NVIC.IPR12: Interrupt Priority Register
func (o *NVIC_Type) SetIPR12_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR12.Reg, volatile.LoadUint32(&o.IPR12.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR12_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR12.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR12_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR12.Reg, volatile.LoadUint32(&o.IPR12.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR12_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR12.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR12_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR12.Reg, volatile.LoadUint32(&o.IPR12.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR12_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR12.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR12_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR12.Reg, volatile.LoadUint32(&o.IPR12.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR12_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR12.Reg) & 0xff000000) >> 24
}

// NVIC.IPR13: Interrupt Priority Register
func (o *NVIC_Type) SetIPR13_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR13.Reg, volatile.LoadUint32(&o.IPR13.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR13_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR13.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR13_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR13.Reg, volatile.LoadUint32(&o.IPR13.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR13_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR13.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR13_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR13.Reg, volatile.LoadUint32(&o.IPR13.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR13_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR13.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR13_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR13.Reg, volatile.LoadUint32(&o.IPR13.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR13_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR13.Reg) & 0xff000000) >> 24
}

// NVIC.IPR14: Interrupt Priority Register
func (o *NVIC_Type) SetIPR14_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR14.Reg, volatile.LoadUint32(&o.IPR14.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR14_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR14.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR14_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR14.Reg, volatile.LoadUint32(&o.IPR14.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR14_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR14.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR14_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR14.Reg, volatile.LoadUint32(&o.IPR14.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR14_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR14.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR14_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR14.Reg, volatile.LoadUint32(&o.IPR14.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR14_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR14.Reg) & 0xff000000) >> 24
}

// NVIC.IPR15: Interrupt Priority Register
func (o *NVIC_Type) SetIPR15_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR15.Reg, volatile.LoadUint32(&o.IPR15.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR15_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR15.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR15_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR15.Reg, volatile.LoadUint32(&o.IPR15.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR15_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR15.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR15_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR15.Reg, volatile.LoadUint32(&o.IPR15.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR15_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR15.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR15_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR15.Reg, volatile.LoadUint32(&o.IPR15.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR15_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR15.Reg) & 0xff000000) >> 24
}

// NVIC.IPR16: Interrupt Priority Register
func (o *NVIC_Type) SetIPR16_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR16.Reg, volatile.LoadUint32(&o.IPR16.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR16_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR16.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR16_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR16.Reg, volatile.LoadUint32(&o.IPR16.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR16_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR16.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR16_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR16.Reg, volatile.LoadUint32(&o.IPR16.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR16_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR16.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR16_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR16.Reg, volatile.LoadUint32(&o.IPR16.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR16_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR16.Reg) & 0xff000000) >> 24
}

// NVIC.IPR17: Interrupt Priority Register
func (o *NVIC_Type) SetIPR17_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR17.Reg, volatile.LoadUint32(&o.IPR17.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR17_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR17.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR17_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR17.Reg, volatile.LoadUint32(&o.IPR17.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR17_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR17.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR17_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR17.Reg, volatile.LoadUint32(&o.IPR17.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR17_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR17.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR17_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR17.Reg, volatile.LoadUint32(&o.IPR17.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR17_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR17.Reg) & 0xff000000) >> 24
}

// NVIC.IPR18: Interrupt Priority Register
func (o *NVIC_Type) SetIPR18_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR18.Reg, volatile.LoadUint32(&o.IPR18.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR18_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR18.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR18_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR18.Reg, volatile.LoadUint32(&o.IPR18.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR18_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR18.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR18_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR18.Reg, volatile.LoadUint32(&o.IPR18.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR18_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR18.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR18_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR18.Reg, volatile.LoadUint32(&o.IPR18.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR18_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR18.Reg) & 0xff000000) >> 24
}

// NVIC.IPR19: Interrupt Priority Register
func (o *NVIC_Type) SetIPR19_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR19.Reg, volatile.LoadUint32(&o.IPR19.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR19_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR19.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR19_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR19.Reg, volatile.LoadUint32(&o.IPR19.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR19_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR19.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR19_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR19.Reg, volatile.LoadUint32(&o.IPR19.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR19_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR19.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR19_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR19.Reg, volatile.LoadUint32(&o.IPR19.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR19_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR19.Reg) & 0xff000000) >> 24
}

// NVIC.IPR20: Interrupt Priority Register
func (o *NVIC_Type) SetIPR20_IPR_N0(value uint32) {
	volatile.StoreUint32(&o.IPR20.Reg, volatile.LoadUint32(&o.IPR20.Reg)&^(0xff)|value)
}
func (o *NVIC_Type) GetIPR20_IPR_N0() uint32 {
	return volatile.LoadUint32(&o.IPR20.Reg) & 0xff
}
func (o *NVIC_Type) SetIPR20_IPR_N1(value uint32) {
	volatile.StoreUint32(&o.IPR20.Reg, volatile.LoadUint32(&o.IPR20.Reg)&^(0xff00)|value<<8)
}
func (o *NVIC_Type) GetIPR20_IPR_N1() uint32 {
	return (volatile.LoadUint32(&o.IPR20.Reg) & 0xff00) >> 8
}
func (o *NVIC_Type) SetIPR20_IPR_N2(value uint32) {
	volatile.StoreUint32(&o.IPR20.Reg, volatile.LoadUint32(&o.IPR20.Reg)&^(0xff0000)|value<<16)
}
func (o *NVIC_Type) GetIPR20_IPR_N2() uint32 {
	return (volatile.LoadUint32(&o.IPR20.Reg) & 0xff0000) >> 16
}
func (o *NVIC_Type) SetIPR20_IPR_N3(value uint32) {
	volatile.StoreUint32(&o.IPR20.Reg, volatile.LoadUint32(&o.IPR20.Reg)&^(0xff000000)|value<<24)
}
func (o *NVIC_Type) GetIPR20_IPR_N3() uint32 {
	return (volatile.LoadUint32(&o.IPR20.Reg) & 0xff000000) >> 24
}

// Memory protection unit
type MPU_Type struct {
	TYPER volatile.Register32 // 0x0
	CTRL  volatile.Register32 // 0x4
	RNR   volatile.Register32 // 0x8
	RBAR  volatile.Register32 // 0xC
	RASR  volatile.Register32 // 0x10
}

// MPU.TYPER: MPU type register
func (o *MPU_Type) SetTYPER_SEPARATE(value uint32) {
	volatile.StoreUint32(&o.TYPER.Reg, volatile.LoadUint32(&o.TYPER.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetTYPER_SEPARATE() uint32 {
	return volatile.LoadUint32(&o.TYPER.Reg) & 0x1
}
func (o *MPU_Type) SetTYPER_DREGION(value uint32) {
	volatile.StoreUint32(&o.TYPER.Reg, volatile.LoadUint32(&o.TYPER.Reg)&^(0xff00)|value<<8)
}
func (o *MPU_Type) GetTYPER_DREGION() uint32 {
	return (volatile.LoadUint32(&o.TYPER.Reg) & 0xff00) >> 8
}
func (o *MPU_Type) SetTYPER_IREGION(value uint32) {
	volatile.StoreUint32(&o.TYPER.Reg, volatile.LoadUint32(&o.TYPER.Reg)&^(0xff0000)|value<<16)
}
func (o *MPU_Type) GetTYPER_IREGION() uint32 {
	return (volatile.LoadUint32(&o.TYPER.Reg) & 0xff0000) >> 16
}

// MPU.CTRL: MPU control register
func (o *MPU_Type) SetCTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetCTRL_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *MPU_Type) SetCTRL_HFNMIENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *MPU_Type) GetCTRL_HFNMIENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *MPU_Type) SetCTRL_PRIVDEFENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *MPU_Type) GetCTRL_PRIVDEFENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}

// MPU.RNR: MPU region number register
func (o *MPU_Type) SetRNR_REGION(value uint32) {
	volatile.StoreUint32(&o.RNR.Reg, volatile.LoadUint32(&o.RNR.Reg)&^(0xff)|value)
}
func (o *MPU_Type) GetRNR_REGION() uint32 {
	return volatile.LoadUint32(&o.RNR.Reg) & 0xff
}

// MPU.RBAR: MPU region base address register
func (o *MPU_Type) SetRBAR_REGION(value uint32) {
	volatile.StoreUint32(&o.RBAR.Reg, volatile.LoadUint32(&o.RBAR.Reg)&^(0xf)|value)
}
func (o *MPU_Type) GetRBAR_REGION() uint32 {
	return volatile.LoadUint32(&o.RBAR.Reg) & 0xf
}
func (o *MPU_Type) SetRBAR_VALID(value uint32) {
	volatile.StoreUint32(&o.RBAR.Reg, volatile.LoadUint32(&o.RBAR.Reg)&^(0x10)|value<<4)
}
func (o *MPU_Type) GetRBAR_VALID() uint32 {
	return (volatile.LoadUint32(&o.RBAR.Reg) & 0x10) >> 4
}
func (o *MPU_Type) SetRBAR_ADDR(value uint32) {
	volatile.StoreUint32(&o.RBAR.Reg, volatile.LoadUint32(&o.RBAR.Reg)&^(0xffffffe0)|value<<5)
}
func (o *MPU_Type) GetRBAR_ADDR() uint32 {
	return (volatile.LoadUint32(&o.RBAR.Reg) & 0xffffffe0) >> 5
}

// MPU.RASR: MPU region attribute and size register
func (o *MPU_Type) SetRASR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x1)|value)
}
func (o *MPU_Type) GetRASR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.RASR.Reg) & 0x1
}
func (o *MPU_Type) SetRASR_SIZE(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x3e)|value<<1)
}
func (o *MPU_Type) GetRASR_SIZE() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x3e) >> 1
}
func (o *MPU_Type) SetRASR_SRD(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0xff00)|value<<8)
}
func (o *MPU_Type) GetRASR_SRD() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0xff00) >> 8
}
func (o *MPU_Type) SetRASR_B(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x10000)|value<<16)
}
func (o *MPU_Type) GetRASR_B() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x10000) >> 16
}
func (o *MPU_Type) SetRASR_C(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x20000)|value<<17)
}
func (o *MPU_Type) GetRASR_C() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x20000) >> 17
}
func (o *MPU_Type) SetRASR_S(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x40000)|value<<18)
}
func (o *MPU_Type) GetRASR_S() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x40000) >> 18
}
func (o *MPU_Type) SetRASR_TEX(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x380000)|value<<19)
}
func (o *MPU_Type) GetRASR_TEX() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x380000) >> 19
}
func (o *MPU_Type) SetRASR_AP(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x7000000)|value<<24)
}
func (o *MPU_Type) GetRASR_AP() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x7000000) >> 24
}
func (o *MPU_Type) SetRASR_XN(value uint32) {
	volatile.StoreUint32(&o.RASR.Reg, volatile.LoadUint32(&o.RASR.Reg)&^(0x10000000)|value<<28)
}
func (o *MPU_Type) GetRASR_XN() uint32 {
	return (volatile.LoadUint32(&o.RASR.Reg) & 0x10000000) >> 28
}

// SysTick timer
type STK_Type struct {
	CSR   volatile.Register32 // 0x0
	RVR   volatile.Register32 // 0x4
	CVR   volatile.Register32 // 0x8
	CALIB volatile.Register32 // 0xC
}

// STK.CSR: SysTick control and status register
func (o *STK_Type) SetCSR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *STK_Type) GetCSR_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}
func (o *STK_Type) SetCSR_TICKINT(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x2)|value<<1)
}
func (o *STK_Type) GetCSR_TICKINT() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x2) >> 1
}
func (o *STK_Type) SetCSR_CLKSOURCE(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x4)|value<<2)
}
func (o *STK_Type) GetCSR_CLKSOURCE() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x4) >> 2
}
func (o *STK_Type) SetCSR_COUNTFLAG(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x10000)|value<<16)
}
func (o *STK_Type) GetCSR_COUNTFLAG() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x10000) >> 16
}

// STK.RVR: SysTick reload value register
func (o *STK_Type) SetRVR_RELOAD(value uint32) {
	volatile.StoreUint32(&o.RVR.Reg, volatile.LoadUint32(&o.RVR.Reg)&^(0xffffff)|value)
}
func (o *STK_Type) GetRVR_RELOAD() uint32 {
	return volatile.LoadUint32(&o.RVR.Reg) & 0xffffff
}

// STK.CVR: SysTick current value register
func (o *STK_Type) SetCVR_CURRENT(value uint32) {
	volatile.StoreUint32(&o.CVR.Reg, volatile.LoadUint32(&o.CVR.Reg)&^(0xffffff)|value)
}
func (o *STK_Type) GetCVR_CURRENT() uint32 {
	return volatile.LoadUint32(&o.CVR.Reg) & 0xffffff
}

// STK.CALIB: SysTick calibration value register
func (o *STK_Type) SetCALIB_TENMS(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0xffffff)|value)
}
func (o *STK_Type) GetCALIB_TENMS() uint32 {
	return volatile.LoadUint32(&o.CALIB.Reg) & 0xffffff
}
func (o *STK_Type) SetCALIB_SKEW(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0x40000000)|value<<30)
}
func (o *STK_Type) GetCALIB_SKEW() uint32 {
	return (volatile.LoadUint32(&o.CALIB.Reg) & 0x40000000) >> 30
}
func (o *STK_Type) SetCALIB_NOREF(value uint32) {
	volatile.StoreUint32(&o.CALIB.Reg, volatile.LoadUint32(&o.CALIB.Reg)&^(0x80000000)|value<<31)
}
func (o *STK_Type) GetCALIB_NOREF() uint32 {
	return (volatile.LoadUint32(&o.CALIB.Reg) & 0x80000000) >> 31
}

// Floating point unit CPACR
type FPU_Type struct {
	CPACR volatile.Register32 // 0x0
}

// FPU.CPACR: Coprocessor access control register
func (o *FPU_Type) SetCPACR_CP(value uint32) {
	volatile.StoreUint32(&o.CPACR.Reg, volatile.LoadUint32(&o.CPACR.Reg)&^(0xf00000)|value<<20)
}
func (o *FPU_Type) GetCPACR_CP() uint32 {
	return (volatile.LoadUint32(&o.CPACR.Reg) & 0xf00000) >> 20
}

// System control block ACTLR
type SCB_Type struct {
	ACTRL volatile.Register32 // 0x0
}

// SCB.ACTRL: Auxiliary control register
func (o *SCB_Type) SetACTRL_DISFOLD(value uint32) {
	volatile.StoreUint32(&o.ACTRL.Reg, volatile.LoadUint32(&o.ACTRL.Reg)&^(0x4)|value<<2)
}
func (o *SCB_Type) GetACTRL_DISFOLD() uint32 {
	return (volatile.LoadUint32(&o.ACTRL.Reg) & 0x4) >> 2
}
func (o *SCB_Type) SetACTRL_FPEXCODIS(value uint32) {
	volatile.StoreUint32(&o.ACTRL.Reg, volatile.LoadUint32(&o.ACTRL.Reg)&^(0x400)|value<<10)
}
func (o *SCB_Type) GetACTRL_FPEXCODIS() uint32 {
	return (volatile.LoadUint32(&o.ACTRL.Reg) & 0x400) >> 10
}
func (o *SCB_Type) SetACTRL_DISRAMODE(value uint32) {
	volatile.StoreUint32(&o.ACTRL.Reg, volatile.LoadUint32(&o.ACTRL.Reg)&^(0x800)|value<<11)
}
func (o *SCB_Type) GetACTRL_DISRAMODE() uint32 {
	return (volatile.LoadUint32(&o.ACTRL.Reg) & 0x800) >> 11
}
func (o *SCB_Type) SetACTRL_DISITMATBFLUSH(value uint32) {
	volatile.StoreUint32(&o.ACTRL.Reg, volatile.LoadUint32(&o.ACTRL.Reg)&^(0x1000)|value<<12)
}
func (o *SCB_Type) GetACTRL_DISITMATBFLUSH() uint32 {
	return (volatile.LoadUint32(&o.ACTRL.Reg) & 0x1000) >> 12
}

// Processor features
type PF_Type struct {
	CLIDR  volatile.Register32 // 0x0
	CTR    volatile.Register32 // 0x4
	CCSIDR volatile.Register32 // 0x8
}

// PF.CLIDR: Cache Level ID register
func (o *PF_Type) SetCLIDR_CL1(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x7)|value)
}
func (o *PF_Type) GetCLIDR_CL1() uint32 {
	return volatile.LoadUint32(&o.CLIDR.Reg) & 0x7
}
func (o *PF_Type) SetCLIDR_CL2(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x38)|value<<3)
}
func (o *PF_Type) GetCLIDR_CL2() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x38) >> 3
}
func (o *PF_Type) SetCLIDR_CL3(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x1c0)|value<<6)
}
func (o *PF_Type) GetCLIDR_CL3() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x1c0) >> 6
}
func (o *PF_Type) SetCLIDR_CL4(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0xe00)|value<<9)
}
func (o *PF_Type) GetCLIDR_CL4() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0xe00) >> 9
}
func (o *PF_Type) SetCLIDR_CL5(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x7000)|value<<12)
}
func (o *PF_Type) GetCLIDR_CL5() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x7000) >> 12
}
func (o *PF_Type) SetCLIDR_CL6(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x38000)|value<<15)
}
func (o *PF_Type) GetCLIDR_CL6() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x38000) >> 15
}
func (o *PF_Type) SetCLIDR_CL7(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x1c0000)|value<<18)
}
func (o *PF_Type) GetCLIDR_CL7() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x1c0000) >> 18
}
func (o *PF_Type) SetCLIDR_LoUIS(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0xe00000)|value<<21)
}
func (o *PF_Type) GetCLIDR_LoUIS() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0xe00000) >> 21
}
func (o *PF_Type) SetCLIDR_LoC(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x7000000)|value<<24)
}
func (o *PF_Type) GetCLIDR_LoC() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x7000000) >> 24
}
func (o *PF_Type) SetCLIDR_LoU(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x38000000)|value<<27)
}
func (o *PF_Type) GetCLIDR_LoU() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x38000000) >> 27
}

// PF.CTR: Cache Type register
func (o *PF_Type) SetCTR__IMINLINE(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0xf)|value)
}
func (o *PF_Type) GetCTR__IMINLINE() uint32 {
	return volatile.LoadUint32(&o.CTR.Reg) & 0xf
}
func (o *PF_Type) SetCTR_DMinLine(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0xf0000)|value<<16)
}
func (o *PF_Type) GetCTR_DMinLine() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0xf0000) >> 16
}
func (o *PF_Type) SetCTR_ERG(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0xf00000)|value<<20)
}
func (o *PF_Type) GetCTR_ERG() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0xf00000) >> 20
}
func (o *PF_Type) SetCTR_CWG(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0xf000000)|value<<24)
}
func (o *PF_Type) GetCTR_CWG() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0xf000000) >> 24
}
func (o *PF_Type) SetCTR_Format(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0xe0000000)|value<<29)
}
func (o *PF_Type) GetCTR_Format() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0xe0000000) >> 29
}

// PF.CCSIDR: Cache Size ID register
func (o *PF_Type) SetCCSIDR_LineSize(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x7)|value)
}
func (o *PF_Type) GetCCSIDR_LineSize() uint32 {
	return volatile.LoadUint32(&o.CCSIDR.Reg) & 0x7
}
func (o *PF_Type) SetCCSIDR_Associativity(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x1ff8)|value<<3)
}
func (o *PF_Type) GetCCSIDR_Associativity() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0x1ff8) >> 3
}
func (o *PF_Type) SetCCSIDR_NumSets(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0xfffe000)|value<<13)
}
func (o *PF_Type) GetCCSIDR_NumSets() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0xfffe000) >> 13
}
func (o *PF_Type) SetCCSIDR_WA(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x10000000)|value<<28)
}
func (o *PF_Type) GetCCSIDR_WA() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0x10000000) >> 28
}
func (o *PF_Type) SetCCSIDR_RA(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x20000000)|value<<29)
}
func (o *PF_Type) GetCCSIDR_RA() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0x20000000) >> 29
}
func (o *PF_Type) SetCCSIDR_WB(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x40000000)|value<<30)
}
func (o *PF_Type) GetCCSIDR_WB() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0x40000000) >> 30
}
func (o *PF_Type) SetCCSIDR_WT(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x80000000)|value<<31)
}
func (o *PF_Type) GetCCSIDR_WT() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0x80000000) >> 31
}

// Access control
type AC_Type struct {
	ITCMCR volatile.Register32 // 0x0
	DTCMCR volatile.Register32 // 0x4
	AHBPCR volatile.Register32 // 0x8
	CACR   volatile.Register32 // 0xC
	AHBSCR volatile.Register32 // 0x10
	_      [4]byte
	ABFSR  volatile.Register32 // 0x18
}

// AC.ITCMCR: Instruction and Data Tightly-Coupled Memory Control Registers
func (o *AC_Type) SetITCMCR_EN(value uint32) {
	volatile.StoreUint32(&o.ITCMCR.Reg, volatile.LoadUint32(&o.ITCMCR.Reg)&^(0x1)|value)
}
func (o *AC_Type) GetITCMCR_EN() uint32 {
	return volatile.LoadUint32(&o.ITCMCR.Reg) & 0x1
}
func (o *AC_Type) SetITCMCR_RMW(value uint32) {
	volatile.StoreUint32(&o.ITCMCR.Reg, volatile.LoadUint32(&o.ITCMCR.Reg)&^(0x2)|value<<1)
}
func (o *AC_Type) GetITCMCR_RMW() uint32 {
	return (volatile.LoadUint32(&o.ITCMCR.Reg) & 0x2) >> 1
}
func (o *AC_Type) SetITCMCR_RETEN(value uint32) {
	volatile.StoreUint32(&o.ITCMCR.Reg, volatile.LoadUint32(&o.ITCMCR.Reg)&^(0x4)|value<<2)
}
func (o *AC_Type) GetITCMCR_RETEN() uint32 {
	return (volatile.LoadUint32(&o.ITCMCR.Reg) & 0x4) >> 2
}
func (o *AC_Type) SetITCMCR_SZ(value uint32) {
	volatile.StoreUint32(&o.ITCMCR.Reg, volatile.LoadUint32(&o.ITCMCR.Reg)&^(0x78)|value<<3)
}
func (o *AC_Type) GetITCMCR_SZ() uint32 {
	return (volatile.LoadUint32(&o.ITCMCR.Reg) & 0x78) >> 3
}

// AC.DTCMCR: Instruction and Data Tightly-Coupled Memory Control Registers
func (o *AC_Type) SetDTCMCR_EN(value uint32) {
	volatile.StoreUint32(&o.DTCMCR.Reg, volatile.LoadUint32(&o.DTCMCR.Reg)&^(0x1)|value)
}
func (o *AC_Type) GetDTCMCR_EN() uint32 {
	return volatile.LoadUint32(&o.DTCMCR.Reg) & 0x1
}
func (o *AC_Type) SetDTCMCR_RMW(value uint32) {
	volatile.StoreUint32(&o.DTCMCR.Reg, volatile.LoadUint32(&o.DTCMCR.Reg)&^(0x2)|value<<1)
}
func (o *AC_Type) GetDTCMCR_RMW() uint32 {
	return (volatile.LoadUint32(&o.DTCMCR.Reg) & 0x2) >> 1
}
func (o *AC_Type) SetDTCMCR_RETEN(value uint32) {
	volatile.StoreUint32(&o.DTCMCR.Reg, volatile.LoadUint32(&o.DTCMCR.Reg)&^(0x4)|value<<2)
}
func (o *AC_Type) GetDTCMCR_RETEN() uint32 {
	return (volatile.LoadUint32(&o.DTCMCR.Reg) & 0x4) >> 2
}
func (o *AC_Type) SetDTCMCR_SZ(value uint32) {
	volatile.StoreUint32(&o.DTCMCR.Reg, volatile.LoadUint32(&o.DTCMCR.Reg)&^(0x78)|value<<3)
}
func (o *AC_Type) GetDTCMCR_SZ() uint32 {
	return (volatile.LoadUint32(&o.DTCMCR.Reg) & 0x78) >> 3
}

// AC.AHBPCR: AHBP Control register
func (o *AC_Type) SetAHBPCR_EN(value uint32) {
	volatile.StoreUint32(&o.AHBPCR.Reg, volatile.LoadUint32(&o.AHBPCR.Reg)&^(0x1)|value)
}
func (o *AC_Type) GetAHBPCR_EN() uint32 {
	return volatile.LoadUint32(&o.AHBPCR.Reg) & 0x1
}
func (o *AC_Type) SetAHBPCR_SZ(value uint32) {
	volatile.StoreUint32(&o.AHBPCR.Reg, volatile.LoadUint32(&o.AHBPCR.Reg)&^(0xe)|value<<1)
}
func (o *AC_Type) GetAHBPCR_SZ() uint32 {
	return (volatile.LoadUint32(&o.AHBPCR.Reg) & 0xe) >> 1
}

// AC.CACR: Auxiliary Cache Control register
func (o *AC_Type) SetCACR_SIWT(value uint32) {
	volatile.StoreUint32(&o.CACR.Reg, volatile.LoadUint32(&o.CACR.Reg)&^(0x1)|value)
}
func (o *AC_Type) GetCACR_SIWT() uint32 {
	return volatile.LoadUint32(&o.CACR.Reg) & 0x1
}
func (o *AC_Type) SetCACR_ECCEN(value uint32) {
	volatile.StoreUint32(&o.CACR.Reg, volatile.LoadUint32(&o.CACR.Reg)&^(0x2)|value<<1)
}
func (o *AC_Type) GetCACR_ECCEN() uint32 {
	return (volatile.LoadUint32(&o.CACR.Reg) & 0x2) >> 1
}
func (o *AC_Type) SetCACR_FORCEWT(value uint32) {
	volatile.StoreUint32(&o.CACR.Reg, volatile.LoadUint32(&o.CACR.Reg)&^(0x4)|value<<2)
}
func (o *AC_Type) GetCACR_FORCEWT() uint32 {
	return (volatile.LoadUint32(&o.CACR.Reg) & 0x4) >> 2
}

// AC.AHBSCR: AHB Slave Control register
func (o *AC_Type) SetAHBSCR_CTL(value uint32) {
	volatile.StoreUint32(&o.AHBSCR.Reg, volatile.LoadUint32(&o.AHBSCR.Reg)&^(0x3)|value)
}
func (o *AC_Type) GetAHBSCR_CTL() uint32 {
	return volatile.LoadUint32(&o.AHBSCR.Reg) & 0x3
}
func (o *AC_Type) SetAHBSCR_TPRI(value uint32) {
	volatile.StoreUint32(&o.AHBSCR.Reg, volatile.LoadUint32(&o.AHBSCR.Reg)&^(0x7fc)|value<<2)
}
func (o *AC_Type) GetAHBSCR_TPRI() uint32 {
	return (volatile.LoadUint32(&o.AHBSCR.Reg) & 0x7fc) >> 2
}
func (o *AC_Type) SetAHBSCR_INITCOUNT(value uint32) {
	volatile.StoreUint32(&o.AHBSCR.Reg, volatile.LoadUint32(&o.AHBSCR.Reg)&^(0xf800)|value<<11)
}
func (o *AC_Type) GetAHBSCR_INITCOUNT() uint32 {
	return (volatile.LoadUint32(&o.AHBSCR.Reg) & 0xf800) >> 11
}

// AC.ABFSR: Auxiliary Bus Fault Status register
func (o *AC_Type) SetABFSR_ITCM(value uint32) {
	volatile.StoreUint32(&o.ABFSR.Reg, volatile.LoadUint32(&o.ABFSR.Reg)&^(0x1)|value)
}
func (o *AC_Type) GetABFSR_ITCM() uint32 {
	return volatile.LoadUint32(&o.ABFSR.Reg) & 0x1
}
func (o *AC_Type) SetABFSR_DTCM(value uint32) {
	volatile.StoreUint32(&o.ABFSR.Reg, volatile.LoadUint32(&o.ABFSR.Reg)&^(0x2)|value<<1)
}
func (o *AC_Type) GetABFSR_DTCM() uint32 {
	return (volatile.LoadUint32(&o.ABFSR.Reg) & 0x2) >> 1
}
func (o *AC_Type) SetABFSR_AHBP(value uint32) {
	volatile.StoreUint32(&o.ABFSR.Reg, volatile.LoadUint32(&o.ABFSR.Reg)&^(0x4)|value<<2)
}
func (o *AC_Type) GetABFSR_AHBP() uint32 {
	return (volatile.LoadUint32(&o.ABFSR.Reg) & 0x4) >> 2
}
func (o *AC_Type) SetABFSR_AXIM(value uint32) {
	volatile.StoreUint32(&o.ABFSR.Reg, volatile.LoadUint32(&o.ABFSR.Reg)&^(0x8)|value<<3)
}
func (o *AC_Type) GetABFSR_AXIM() uint32 {
	return (volatile.LoadUint32(&o.ABFSR.Reg) & 0x8) >> 3
}
func (o *AC_Type) SetABFSR_EPPB(value uint32) {
	volatile.StoreUint32(&o.ABFSR.Reg, volatile.LoadUint32(&o.ABFSR.Reg)&^(0x10)|value<<4)
}
func (o *AC_Type) GetABFSR_EPPB() uint32 {
	return (volatile.LoadUint32(&o.ABFSR.Reg) & 0x10) >> 4
}
func (o *AC_Type) SetABFSR_AXIMTYPE(value uint32) {
	volatile.StoreUint32(&o.ABFSR.Reg, volatile.LoadUint32(&o.ABFSR.Reg)&^(0x300)|value<<8)
}
func (o *AC_Type) GetABFSR_AXIMTYPE() uint32 {
	return (volatile.LoadUint32(&o.ABFSR.Reg) & 0x300) >> 8
}

// Debug support
type DBGMCU_Type struct {
	IDCODE  volatile.Register32 // 0x0
	CR      volatile.Register32 // 0x4
	APB1_FZ volatile.Register32 // 0x8
	APB2_FZ volatile.Register32 // 0xC
}

// DBGMCU.IDCODE: IDCODE
func (o *DBGMCU_Type) SetIDCODE_DEV_ID(value uint32) {
	volatile.StoreUint32(&o.IDCODE.Reg, volatile.LoadUint32(&o.IDCODE.Reg)&^(0xfff)|value)
}
func (o *DBGMCU_Type) GetIDCODE_DEV_ID() uint32 {
	return volatile.LoadUint32(&o.IDCODE.Reg) & 0xfff
}
func (o *DBGMCU_Type) SetIDCODE_REV_ID(value uint32) {
	volatile.StoreUint32(&o.IDCODE.Reg, volatile.LoadUint32(&o.IDCODE.Reg)&^(0xffff0000)|value<<16)
}
func (o *DBGMCU_Type) GetIDCODE_REV_ID() uint32 {
	return (volatile.LoadUint32(&o.IDCODE.Reg) & 0xffff0000) >> 16
}

// DBGMCU.CR: Control Register
func (o *DBGMCU_Type) SetCR_DBG_SLEEP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *DBGMCU_Type) GetCR_DBG_SLEEP() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *DBGMCU_Type) SetCR_DBG_STOP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *DBGMCU_Type) GetCR_DBG_STOP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *DBGMCU_Type) SetCR_DBG_STANDBY(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *DBGMCU_Type) GetCR_DBG_STANDBY() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *DBGMCU_Type) SetCR_TRACE_IOEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *DBGMCU_Type) GetCR_TRACE_IOEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *DBGMCU_Type) SetCR_TRACE_MODE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc0)|value<<6)
}
func (o *DBGMCU_Type) GetCR_TRACE_MODE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc0) >> 6
}

// DBGMCU.APB1_FZ: Debug MCU APB1 Freeze register
func (o *DBGMCU_Type) SetAPB1_FZ_DBG_TIM2_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZ.Reg, volatile.LoadUint32(&o.APB1_FZ.Reg)&^(0x1)|value)
}
func (o *DBGMCU_Type) GetAPB1_FZ_DBG_TIM2_STOP() uint32 {
	return volatile.LoadUint32(&o.APB1_FZ.Reg) & 0x1
}
func (o *DBGMCU_Type) SetAPB1_FZ_DBG_TIM3_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZ.Reg, volatile.LoadUint32(&o.APB1_FZ.Reg)&^(0x2)|value<<1)
}
func (o *DBGMCU_Type) GetAPB1_FZ_DBG_TIM3_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZ.Reg) & 0x2) >> 1
}
func (o *DBGMCU_Type) SetAPB1_FZ_DBG_TIM4_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZ.Reg, volatile.LoadUint32(&o.APB1_FZ.Reg)&^(0x4)|value<<2)
}
func (o *DBGMCU_Type) GetAPB1_FZ_DBG_TIM4_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZ.Reg) & 0x4) >> 2
}
func (o *DBGMCU_Type) SetAPB1_FZ_DBG_TIM5_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZ.Reg, volatile.LoadUint32(&o.APB1_FZ.Reg)&^(0x8)|value<<3)
}
func (o *DBGMCU_Type) GetAPB1_FZ_DBG_TIM5_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZ.Reg) & 0x8) >> 3
}
func (o *DBGMCU_Type) SetAPB1_FZ_DBG_TIM6_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZ.Reg, volatile.LoadUint32(&o.APB1_FZ.Reg)&^(0x10)|value<<4)
}
func (o *DBGMCU_Type) GetAPB1_FZ_DBG_TIM6_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZ.Reg) & 0x10) >> 4
}
func (o *DBGMCU_Type) SetAPB1_FZ_DBG_TIM7_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZ.Reg, volatile.LoadUint32(&o.APB1_FZ.Reg)&^(0x20)|value<<5)
}
func (o *DBGMCU_Type) GetAPB1_FZ_DBG_TIM7_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZ.Reg) & 0x20) >> 5
}
func (o *DBGMCU_Type) SetAPB1_FZ_DBG_TIM12_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZ.Reg, volatile.LoadUint32(&o.APB1_FZ.Reg)&^(0x40)|value<<6)
}
func (o *DBGMCU_Type) GetAPB1_FZ_DBG_TIM12_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZ.Reg) & 0x40) >> 6
}
func (o *DBGMCU_Type) SetAPB1_FZ_DBG_TIM13_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZ.Reg, volatile.LoadUint32(&o.APB1_FZ.Reg)&^(0x80)|value<<7)
}
func (o *DBGMCU_Type) GetAPB1_FZ_DBG_TIM13_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZ.Reg) & 0x80) >> 7
}
func (o *DBGMCU_Type) SetAPB1_FZ_DBG_TIM14_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZ.Reg, volatile.LoadUint32(&o.APB1_FZ.Reg)&^(0x100)|value<<8)
}
func (o *DBGMCU_Type) GetAPB1_FZ_DBG_TIM14_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZ.Reg) & 0x100) >> 8
}
func (o *DBGMCU_Type) SetAPB1_FZ_DBG_LPTIM1_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZ.Reg, volatile.LoadUint32(&o.APB1_FZ.Reg)&^(0x200)|value<<9)
}
func (o *DBGMCU_Type) GetAPB1_FZ_DBG_LPTIM1_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZ.Reg) & 0x200) >> 9
}
func (o *DBGMCU_Type) SetAPB1_FZ_DBG_RTC_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZ.Reg, volatile.LoadUint32(&o.APB1_FZ.Reg)&^(0x400)|value<<10)
}
func (o *DBGMCU_Type) GetAPB1_FZ_DBG_RTC_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZ.Reg) & 0x400) >> 10
}
func (o *DBGMCU_Type) SetAPB1_FZ_DBG_WWDG_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZ.Reg, volatile.LoadUint32(&o.APB1_FZ.Reg)&^(0x800)|value<<11)
}
func (o *DBGMCU_Type) GetAPB1_FZ_DBG_WWDG_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZ.Reg) & 0x800) >> 11
}
func (o *DBGMCU_Type) SetAPB1_FZ_DBG_IWDG_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZ.Reg, volatile.LoadUint32(&o.APB1_FZ.Reg)&^(0x1000)|value<<12)
}
func (o *DBGMCU_Type) GetAPB1_FZ_DBG_IWDG_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZ.Reg) & 0x1000) >> 12
}
func (o *DBGMCU_Type) SetAPB1_FZ_DBG_CAN3_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZ.Reg, volatile.LoadUint32(&o.APB1_FZ.Reg)&^(0x2000)|value<<13)
}
func (o *DBGMCU_Type) GetAPB1_FZ_DBG_CAN3_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZ.Reg) & 0x2000) >> 13
}
func (o *DBGMCU_Type) SetAPB1_FZ_DBG_I2C1_SMBUS_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.APB1_FZ.Reg, volatile.LoadUint32(&o.APB1_FZ.Reg)&^(0x200000)|value<<21)
}
func (o *DBGMCU_Type) GetAPB1_FZ_DBG_I2C1_SMBUS_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZ.Reg) & 0x200000) >> 21
}
func (o *DBGMCU_Type) SetAPB1_FZ_DBG_I2C2_SMBUS_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.APB1_FZ.Reg, volatile.LoadUint32(&o.APB1_FZ.Reg)&^(0x400000)|value<<22)
}
func (o *DBGMCU_Type) GetAPB1_FZ_DBG_I2C2_SMBUS_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZ.Reg) & 0x400000) >> 22
}
func (o *DBGMCU_Type) SetAPB1_FZ_DBG_I2C3_SMBUS_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.APB1_FZ.Reg, volatile.LoadUint32(&o.APB1_FZ.Reg)&^(0x800000)|value<<23)
}
func (o *DBGMCU_Type) GetAPB1_FZ_DBG_I2C3_SMBUS_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZ.Reg) & 0x800000) >> 23
}
func (o *DBGMCU_Type) SetAPB1_FZ_DBG_I2C4_SMBUS_TIMEOUT(value uint32) {
	volatile.StoreUint32(&o.APB1_FZ.Reg, volatile.LoadUint32(&o.APB1_FZ.Reg)&^(0x1000000)|value<<24)
}
func (o *DBGMCU_Type) GetAPB1_FZ_DBG_I2C4_SMBUS_TIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZ.Reg) & 0x1000000) >> 24
}
func (o *DBGMCU_Type) SetAPB1_FZ_DBG_CAN1_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZ.Reg, volatile.LoadUint32(&o.APB1_FZ.Reg)&^(0x2000000)|value<<25)
}
func (o *DBGMCU_Type) GetAPB1_FZ_DBG_CAN1_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZ.Reg) & 0x2000000) >> 25
}
func (o *DBGMCU_Type) SetAPB1_FZ_DBG_CAN2_STOP(value uint32) {
	volatile.StoreUint32(&o.APB1_FZ.Reg, volatile.LoadUint32(&o.APB1_FZ.Reg)&^(0x4000000)|value<<26)
}
func (o *DBGMCU_Type) GetAPB1_FZ_DBG_CAN2_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB1_FZ.Reg) & 0x4000000) >> 26
}

// DBGMCU.APB2_FZ: Debug MCU APB2 Freeze register
func (o *DBGMCU_Type) SetAPB2_FZ_DBG_TIM1_STOP(value uint32) {
	volatile.StoreUint32(&o.APB2_FZ.Reg, volatile.LoadUint32(&o.APB2_FZ.Reg)&^(0x1)|value)
}
func (o *DBGMCU_Type) GetAPB2_FZ_DBG_TIM1_STOP() uint32 {
	return volatile.LoadUint32(&o.APB2_FZ.Reg) & 0x1
}
func (o *DBGMCU_Type) SetAPB2_FZ_DBG_TIM8_STOP(value uint32) {
	volatile.StoreUint32(&o.APB2_FZ.Reg, volatile.LoadUint32(&o.APB2_FZ.Reg)&^(0x2)|value<<1)
}
func (o *DBGMCU_Type) GetAPB2_FZ_DBG_TIM8_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB2_FZ.Reg) & 0x2) >> 1
}
func (o *DBGMCU_Type) SetAPB2_FZ_DBG_TIM9_STOP(value uint32) {
	volatile.StoreUint32(&o.APB2_FZ.Reg, volatile.LoadUint32(&o.APB2_FZ.Reg)&^(0x10000)|value<<16)
}
func (o *DBGMCU_Type) GetAPB2_FZ_DBG_TIM9_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB2_FZ.Reg) & 0x10000) >> 16
}
func (o *DBGMCU_Type) SetAPB2_FZ_DBG_TIM10_STOP(value uint32) {
	volatile.StoreUint32(&o.APB2_FZ.Reg, volatile.LoadUint32(&o.APB2_FZ.Reg)&^(0x20000)|value<<17)
}
func (o *DBGMCU_Type) GetAPB2_FZ_DBG_TIM10_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB2_FZ.Reg) & 0x20000) >> 17
}
func (o *DBGMCU_Type) SetAPB2_FZ_DBG_TIM11_STOP(value uint32) {
	volatile.StoreUint32(&o.APB2_FZ.Reg, volatile.LoadUint32(&o.APB2_FZ.Reg)&^(0x40000)|value<<18)
}
func (o *DBGMCU_Type) GetAPB2_FZ_DBG_TIM11_STOP() uint32 {
	return (volatile.LoadUint32(&o.APB2_FZ.Reg) & 0x40000) >> 18
}

// Constants for RNG: Random number generator
const (
	// CR: control register
	// Position of IE field.
	RNG_CR_IE_Pos = 0x3
	// Bit mask of IE field.
	RNG_CR_IE_Msk = 0x8
	// Bit IE.
	RNG_CR_IE = 0x8
	// Position of RNGEN field.
	RNG_CR_RNGEN_Pos = 0x2
	// Bit mask of RNGEN field.
	RNG_CR_RNGEN_Msk = 0x4
	// Bit RNGEN.
	RNG_CR_RNGEN = 0x4

	// SR: status register
	// Position of SEIS field.
	RNG_SR_SEIS_Pos = 0x6
	// Bit mask of SEIS field.
	RNG_SR_SEIS_Msk = 0x40
	// Bit SEIS.
	RNG_SR_SEIS = 0x40
	// Position of CEIS field.
	RNG_SR_CEIS_Pos = 0x5
	// Bit mask of CEIS field.
	RNG_SR_CEIS_Msk = 0x20
	// Bit CEIS.
	RNG_SR_CEIS = 0x20
	// Position of SECS field.
	RNG_SR_SECS_Pos = 0x2
	// Bit mask of SECS field.
	RNG_SR_SECS_Msk = 0x4
	// Bit SECS.
	RNG_SR_SECS = 0x4
	// Position of CECS field.
	RNG_SR_CECS_Pos = 0x1
	// Bit mask of CECS field.
	RNG_SR_CECS_Msk = 0x2
	// Bit CECS.
	RNG_SR_CECS = 0x2
	// Position of DRDY field.
	RNG_SR_DRDY_Pos = 0x0
	// Bit mask of DRDY field.
	RNG_SR_DRDY_Msk = 0x1
	// Bit DRDY.
	RNG_SR_DRDY = 0x1

	// DR: data register
	// Position of RNDATA field.
	RNG_DR_RNDATA_Pos = 0x0
	// Bit mask of RNDATA field.
	RNG_DR_RNDATA_Msk = 0xffffffff
)

// Constants for HASH: Hash processor
const (
	// CR: control register
	// Position of INIT field.
	HASH_CR_INIT_Pos = 0x2
	// Bit mask of INIT field.
	HASH_CR_INIT_Msk = 0x4
	// Bit INIT.
	HASH_CR_INIT = 0x4
	// Position of DMAE field.
	HASH_CR_DMAE_Pos = 0x3
	// Bit mask of DMAE field.
	HASH_CR_DMAE_Msk = 0x8
	// Bit DMAE.
	HASH_CR_DMAE = 0x8
	// Position of DATATYPE field.
	HASH_CR_DATATYPE_Pos = 0x4
	// Bit mask of DATATYPE field.
	HASH_CR_DATATYPE_Msk = 0x30
	// Position of MODE field.
	HASH_CR_MODE_Pos = 0x6
	// Bit mask of MODE field.
	HASH_CR_MODE_Msk = 0x40
	// Bit MODE.
	HASH_CR_MODE = 0x40
	// Position of ALGO0 field.
	HASH_CR_ALGO0_Pos = 0x7
	// Bit mask of ALGO0 field.
	HASH_CR_ALGO0_Msk = 0x80
	// Bit ALGO0.
	HASH_CR_ALGO0 = 0x80
	// Position of NBW field.
	HASH_CR_NBW_Pos = 0x8
	// Bit mask of NBW field.
	HASH_CR_NBW_Msk = 0xf00
	// Position of DINNE field.
	HASH_CR_DINNE_Pos = 0xc
	// Bit mask of DINNE field.
	HASH_CR_DINNE_Msk = 0x1000
	// Bit DINNE.
	HASH_CR_DINNE = 0x1000
	// Position of MDMAT field.
	HASH_CR_MDMAT_Pos = 0xd
	// Bit mask of MDMAT field.
	HASH_CR_MDMAT_Msk = 0x2000
	// Bit MDMAT.
	HASH_CR_MDMAT = 0x2000
	// Position of LKEY field.
	HASH_CR_LKEY_Pos = 0x10
	// Bit mask of LKEY field.
	HASH_CR_LKEY_Msk = 0x10000
	// Bit LKEY.
	HASH_CR_LKEY = 0x10000
	// Position of ALGO1 field.
	HASH_CR_ALGO1_Pos = 0x12
	// Bit mask of ALGO1 field.
	HASH_CR_ALGO1_Msk = 0x40000
	// Bit ALGO1.
	HASH_CR_ALGO1 = 0x40000

	// DIN: data input register
	// Position of DATAIN field.
	HASH_DIN_DATAIN_Pos = 0x0
	// Bit mask of DATAIN field.
	HASH_DIN_DATAIN_Msk = 0xffffffff

	// STR: start register
	// Position of DCAL field.
	HASH_STR_DCAL_Pos = 0x8
	// Bit mask of DCAL field.
	HASH_STR_DCAL_Msk = 0x100
	// Bit DCAL.
	HASH_STR_DCAL = 0x100
	// Position of NBLW field.
	HASH_STR_NBLW_Pos = 0x0
	// Bit mask of NBLW field.
	HASH_STR_NBLW_Msk = 0x1f

	// HR0: digest registers
	// Position of H field.
	HASH_HR_H_Pos = 0x0
	// Bit mask of H field.
	HASH_HR_H_Msk = 0xffffffff

	// IMR: interrupt enable register
	// Position of DCIE field.
	HASH_IMR_DCIE_Pos = 0x1
	// Bit mask of DCIE field.
	HASH_IMR_DCIE_Msk = 0x2
	// Bit DCIE.
	HASH_IMR_DCIE = 0x2
	// Position of DINIE field.
	HASH_IMR_DINIE_Pos = 0x0
	// Bit mask of DINIE field.
	HASH_IMR_DINIE_Msk = 0x1
	// Bit DINIE.
	HASH_IMR_DINIE = 0x1

	// SR: status register
	// Position of BUSY field.
	HASH_SR_BUSY_Pos = 0x3
	// Bit mask of BUSY field.
	HASH_SR_BUSY_Msk = 0x8
	// Bit BUSY.
	HASH_SR_BUSY = 0x8
	// Position of DMAS field.
	HASH_SR_DMAS_Pos = 0x2
	// Bit mask of DMAS field.
	HASH_SR_DMAS_Msk = 0x4
	// Bit DMAS.
	HASH_SR_DMAS = 0x4
	// Position of DCIS field.
	HASH_SR_DCIS_Pos = 0x1
	// Bit mask of DCIS field.
	HASH_SR_DCIS_Msk = 0x2
	// Bit DCIS.
	HASH_SR_DCIS = 0x2
	// Position of DINIS field.
	HASH_SR_DINIS_Pos = 0x0
	// Bit mask of DINIS field.
	HASH_SR_DINIS_Msk = 0x1
	// Bit DINIS.
	HASH_SR_DINIS = 0x1

	// CSR0: context swap registers
	// Position of CSR field.
	HASH_CSR_CSR_Pos = 0x0
	// Bit mask of CSR field.
	HASH_CSR_CSR_Msk = 0xffffffff

	// HASH_HR0: HASH digest register
	// Position of H field.
	HASH_HASH_HR_H_Pos = 0x0
	// Bit mask of H field.
	HASH_HASH_HR_H_Msk = 0xffffffff
)

// Constants for CRYP: Cryptographic processor
const (
	// CR: control register
	// Position of ALGODIR field.
	CRYP_CR_ALGODIR_Pos = 0x2
	// Bit mask of ALGODIR field.
	CRYP_CR_ALGODIR_Msk = 0x4
	// Bit ALGODIR.
	CRYP_CR_ALGODIR = 0x4
	// Position of ALGOMODE0 field.
	CRYP_CR_ALGOMODE0_Pos = 0x3
	// Bit mask of ALGOMODE0 field.
	CRYP_CR_ALGOMODE0_Msk = 0x38
	// Position of DATATYPE field.
	CRYP_CR_DATATYPE_Pos = 0x6
	// Bit mask of DATATYPE field.
	CRYP_CR_DATATYPE_Msk = 0xc0
	// Position of KEYSIZE field.
	CRYP_CR_KEYSIZE_Pos = 0x8
	// Bit mask of KEYSIZE field.
	CRYP_CR_KEYSIZE_Msk = 0x300
	// Position of FFLUSH field.
	CRYP_CR_FFLUSH_Pos = 0xe
	// Bit mask of FFLUSH field.
	CRYP_CR_FFLUSH_Msk = 0x4000
	// Bit FFLUSH.
	CRYP_CR_FFLUSH = 0x4000
	// Position of CRYPEN field.
	CRYP_CR_CRYPEN_Pos = 0xf
	// Bit mask of CRYPEN field.
	CRYP_CR_CRYPEN_Msk = 0x8000
	// Bit CRYPEN.
	CRYP_CR_CRYPEN = 0x8000
	// Position of GCM_CCMPH field.
	CRYP_CR_GCM_CCMPH_Pos = 0x10
	// Bit mask of GCM_CCMPH field.
	CRYP_CR_GCM_CCMPH_Msk = 0x30000
	// Position of ALGOMODE3 field.
	CRYP_CR_ALGOMODE3_Pos = 0x13
	// Bit mask of ALGOMODE3 field.
	CRYP_CR_ALGOMODE3_Msk = 0x80000
	// Bit ALGOMODE3.
	CRYP_CR_ALGOMODE3 = 0x80000

	// SR: status register
	// Position of BUSY field.
	CRYP_SR_BUSY_Pos = 0x4
	// Bit mask of BUSY field.
	CRYP_SR_BUSY_Msk = 0x10
	// Bit BUSY.
	CRYP_SR_BUSY = 0x10
	// Position of OFFU field.
	CRYP_SR_OFFU_Pos = 0x3
	// Bit mask of OFFU field.
	CRYP_SR_OFFU_Msk = 0x8
	// Bit OFFU.
	CRYP_SR_OFFU = 0x8
	// Position of OFNE field.
	CRYP_SR_OFNE_Pos = 0x2
	// Bit mask of OFNE field.
	CRYP_SR_OFNE_Msk = 0x4
	// Bit OFNE.
	CRYP_SR_OFNE = 0x4
	// Position of IFNF field.
	CRYP_SR_IFNF_Pos = 0x1
	// Bit mask of IFNF field.
	CRYP_SR_IFNF_Msk = 0x2
	// Bit IFNF.
	CRYP_SR_IFNF = 0x2
	// Position of IFEM field.
	CRYP_SR_IFEM_Pos = 0x0
	// Bit mask of IFEM field.
	CRYP_SR_IFEM_Msk = 0x1
	// Bit IFEM.
	CRYP_SR_IFEM = 0x1

	// DIN: data input register
	// Position of DATAIN field.
	CRYP_DIN_DATAIN_Pos = 0x0
	// Bit mask of DATAIN field.
	CRYP_DIN_DATAIN_Msk = 0xffffffff

	// DOUT: data output register
	// Position of DATAOUT field.
	CRYP_DOUT_DATAOUT_Pos = 0x0
	// Bit mask of DATAOUT field.
	CRYP_DOUT_DATAOUT_Msk = 0xffffffff

	// DMACR: DMA control register
	// Position of DOEN field.
	CRYP_DMACR_DOEN_Pos = 0x1
	// Bit mask of DOEN field.
	CRYP_DMACR_DOEN_Msk = 0x2
	// Bit DOEN.
	CRYP_DMACR_DOEN = 0x2
	// Position of DIEN field.
	CRYP_DMACR_DIEN_Pos = 0x0
	// Bit mask of DIEN field.
	CRYP_DMACR_DIEN_Msk = 0x1
	// Bit DIEN.
	CRYP_DMACR_DIEN = 0x1

	// IMSCR: interrupt mask set/clear register
	// Position of OUTIM field.
	CRYP_IMSCR_OUTIM_Pos = 0x1
	// Bit mask of OUTIM field.
	CRYP_IMSCR_OUTIM_Msk = 0x2
	// Bit OUTIM.
	CRYP_IMSCR_OUTIM = 0x2
	// Position of INIM field.
	CRYP_IMSCR_INIM_Pos = 0x0
	// Bit mask of INIM field.
	CRYP_IMSCR_INIM_Msk = 0x1
	// Bit INIM.
	CRYP_IMSCR_INIM = 0x1

	// RISR: raw interrupt status register
	// Position of OUTRIS field.
	CRYP_RISR_OUTRIS_Pos = 0x1
	// Bit mask of OUTRIS field.
	CRYP_RISR_OUTRIS_Msk = 0x2
	// Bit OUTRIS.
	CRYP_RISR_OUTRIS = 0x2
	// Position of INRIS field.
	CRYP_RISR_INRIS_Pos = 0x0
	// Bit mask of INRIS field.
	CRYP_RISR_INRIS_Msk = 0x1
	// Bit INRIS.
	CRYP_RISR_INRIS = 0x1

	// MISR: masked interrupt status register
	// Position of OUTMIS field.
	CRYP_MISR_OUTMIS_Pos = 0x1
	// Bit mask of OUTMIS field.
	CRYP_MISR_OUTMIS_Msk = 0x2
	// Bit OUTMIS.
	CRYP_MISR_OUTMIS = 0x2
	// Position of INMIS field.
	CRYP_MISR_INMIS_Pos = 0x0
	// Bit mask of INMIS field.
	CRYP_MISR_INMIS_Msk = 0x1
	// Bit INMIS.
	CRYP_MISR_INMIS = 0x1

	// KEY.KLR: key registers
	// Position of B2 field.
	CRYP_KEY_KLR_B2_Pos = 0x0
	// Bit mask of B2 field.
	CRYP_KEY_KLR_B2_Msk = 0xffffffff

	// KEY.KRR: key registers
	// Position of B field.
	CRYP_KEY_KRR_B_Pos = 0x0
	// Bit mask of B field.
	CRYP_KEY_KRR_B_Msk = 0xffffffff

	// INIT.IVLR: initialization vector registers
	// Position of IV field.
	CRYP_INIT_IVLR_IV_Pos = 0x0
	// Bit mask of IV field.
	CRYP_INIT_IVLR_IV_Msk = 0xffffffff

	// INIT.IVRR: initialization vector registers
	// Position of IV field.
	CRYP_INIT_IVRR_IV_Pos = 0x0
	// Bit mask of IV field.
	CRYP_INIT_IVRR_IV_Msk = 0xffffffff

	// CSGCMCCM0R: context swap register
	// Position of CSGCMCCM0R field.
	CRYP_CSGCMCCMR_CSGCMCCM0R_Pos = 0x0
	// Bit mask of CSGCMCCM0R field.
	CRYP_CSGCMCCMR_CSGCMCCM0R_Msk = 0xffffffff

	// CSGCM0R: context swap register
	// Position of CSGCMR field.
	CRYP_CSGCMR_CSGCMR_Pos = 0x0
	// Bit mask of CSGCMR field.
	CRYP_CSGCMR_CSGCMR_Msk = 0xffffffff
)

// Constants for DCMI: Digital camera interface
const (
	// CR: control register 1
	// Position of ENABLE field.
	DCMI_CR_ENABLE_Pos = 0xe
	// Bit mask of ENABLE field.
	DCMI_CR_ENABLE_Msk = 0x4000
	// Bit ENABLE.
	DCMI_CR_ENABLE = 0x4000
	// Position of EDM field.
	DCMI_CR_EDM_Pos = 0xa
	// Bit mask of EDM field.
	DCMI_CR_EDM_Msk = 0xc00
	// Position of FCRC field.
	DCMI_CR_FCRC_Pos = 0x8
	// Bit mask of FCRC field.
	DCMI_CR_FCRC_Msk = 0x300
	// Position of VSPOL field.
	DCMI_CR_VSPOL_Pos = 0x7
	// Bit mask of VSPOL field.
	DCMI_CR_VSPOL_Msk = 0x80
	// Bit VSPOL.
	DCMI_CR_VSPOL = 0x80
	// Position of HSPOL field.
	DCMI_CR_HSPOL_Pos = 0x6
	// Bit mask of HSPOL field.
	DCMI_CR_HSPOL_Msk = 0x40
	// Bit HSPOL.
	DCMI_CR_HSPOL = 0x40
	// Position of PCKPOL field.
	DCMI_CR_PCKPOL_Pos = 0x5
	// Bit mask of PCKPOL field.
	DCMI_CR_PCKPOL_Msk = 0x20
	// Bit PCKPOL.
	DCMI_CR_PCKPOL = 0x20
	// Position of ESS field.
	DCMI_CR_ESS_Pos = 0x4
	// Bit mask of ESS field.
	DCMI_CR_ESS_Msk = 0x10
	// Bit ESS.
	DCMI_CR_ESS = 0x10
	// Position of JPEG field.
	DCMI_CR_JPEG_Pos = 0x3
	// Bit mask of JPEG field.
	DCMI_CR_JPEG_Msk = 0x8
	// Bit JPEG.
	DCMI_CR_JPEG = 0x8
	// Position of CROP field.
	DCMI_CR_CROP_Pos = 0x2
	// Bit mask of CROP field.
	DCMI_CR_CROP_Msk = 0x4
	// Bit CROP.
	DCMI_CR_CROP = 0x4
	// Position of CM field.
	DCMI_CR_CM_Pos = 0x1
	// Bit mask of CM field.
	DCMI_CR_CM_Msk = 0x2
	// Bit CM.
	DCMI_CR_CM = 0x2
	// Position of CAPTURE field.
	DCMI_CR_CAPTURE_Pos = 0x0
	// Bit mask of CAPTURE field.
	DCMI_CR_CAPTURE_Msk = 0x1
	// Bit CAPTURE.
	DCMI_CR_CAPTURE = 0x1

	// SR: status register
	// Position of FNE field.
	DCMI_SR_FNE_Pos = 0x2
	// Bit mask of FNE field.
	DCMI_SR_FNE_Msk = 0x4
	// Bit FNE.
	DCMI_SR_FNE = 0x4
	// Position of VSYNC field.
	DCMI_SR_VSYNC_Pos = 0x1
	// Bit mask of VSYNC field.
	DCMI_SR_VSYNC_Msk = 0x2
	// Bit VSYNC.
	DCMI_SR_VSYNC = 0x2
	// Position of HSYNC field.
	DCMI_SR_HSYNC_Pos = 0x0
	// Bit mask of HSYNC field.
	DCMI_SR_HSYNC_Msk = 0x1
	// Bit HSYNC.
	DCMI_SR_HSYNC = 0x1

	// RIS: raw interrupt status register
	// Position of LINE_RIS field.
	DCMI_RIS_LINE_RIS_Pos = 0x4
	// Bit mask of LINE_RIS field.
	DCMI_RIS_LINE_RIS_Msk = 0x10
	// Bit LINE_RIS.
	DCMI_RIS_LINE_RIS = 0x10
	// Position of VSYNC_RIS field.
	DCMI_RIS_VSYNC_RIS_Pos = 0x3
	// Bit mask of VSYNC_RIS field.
	DCMI_RIS_VSYNC_RIS_Msk = 0x8
	// Bit VSYNC_RIS.
	DCMI_RIS_VSYNC_RIS = 0x8
	// Position of ERR_RIS field.
	DCMI_RIS_ERR_RIS_Pos = 0x2
	// Bit mask of ERR_RIS field.
	DCMI_RIS_ERR_RIS_Msk = 0x4
	// Bit ERR_RIS.
	DCMI_RIS_ERR_RIS = 0x4
	// Position of OVR_RIS field.
	DCMI_RIS_OVR_RIS_Pos = 0x1
	// Bit mask of OVR_RIS field.
	DCMI_RIS_OVR_RIS_Msk = 0x2
	// Bit OVR_RIS.
	DCMI_RIS_OVR_RIS = 0x2
	// Position of FRAME_RIS field.
	DCMI_RIS_FRAME_RIS_Pos = 0x0
	// Bit mask of FRAME_RIS field.
	DCMI_RIS_FRAME_RIS_Msk = 0x1
	// Bit FRAME_RIS.
	DCMI_RIS_FRAME_RIS = 0x1

	// IER: interrupt enable register
	// Position of LINE_IE field.
	DCMI_IER_LINE_IE_Pos = 0x4
	// Bit mask of LINE_IE field.
	DCMI_IER_LINE_IE_Msk = 0x10
	// Bit LINE_IE.
	DCMI_IER_LINE_IE = 0x10
	// Position of VSYNC_IE field.
	DCMI_IER_VSYNC_IE_Pos = 0x3
	// Bit mask of VSYNC_IE field.
	DCMI_IER_VSYNC_IE_Msk = 0x8
	// Bit VSYNC_IE.
	DCMI_IER_VSYNC_IE = 0x8
	// Position of ERR_IE field.
	DCMI_IER_ERR_IE_Pos = 0x2
	// Bit mask of ERR_IE field.
	DCMI_IER_ERR_IE_Msk = 0x4
	// Bit ERR_IE.
	DCMI_IER_ERR_IE = 0x4
	// Position of OVR_IE field.
	DCMI_IER_OVR_IE_Pos = 0x1
	// Bit mask of OVR_IE field.
	DCMI_IER_OVR_IE_Msk = 0x2
	// Bit OVR_IE.
	DCMI_IER_OVR_IE = 0x2
	// Position of FRAME_IE field.
	DCMI_IER_FRAME_IE_Pos = 0x0
	// Bit mask of FRAME_IE field.
	DCMI_IER_FRAME_IE_Msk = 0x1
	// Bit FRAME_IE.
	DCMI_IER_FRAME_IE = 0x1

	// MIS: masked interrupt status register
	// Position of LINE_MIS field.
	DCMI_MIS_LINE_MIS_Pos = 0x4
	// Bit mask of LINE_MIS field.
	DCMI_MIS_LINE_MIS_Msk = 0x10
	// Bit LINE_MIS.
	DCMI_MIS_LINE_MIS = 0x10
	// Position of VSYNC_MIS field.
	DCMI_MIS_VSYNC_MIS_Pos = 0x3
	// Bit mask of VSYNC_MIS field.
	DCMI_MIS_VSYNC_MIS_Msk = 0x8
	// Bit VSYNC_MIS.
	DCMI_MIS_VSYNC_MIS = 0x8
	// Position of ERR_MIS field.
	DCMI_MIS_ERR_MIS_Pos = 0x2
	// Bit mask of ERR_MIS field.
	DCMI_MIS_ERR_MIS_Msk = 0x4
	// Bit ERR_MIS.
	DCMI_MIS_ERR_MIS = 0x4
	// Position of OVR_MIS field.
	DCMI_MIS_OVR_MIS_Pos = 0x1
	// Bit mask of OVR_MIS field.
	DCMI_MIS_OVR_MIS_Msk = 0x2
	// Bit OVR_MIS.
	DCMI_MIS_OVR_MIS = 0x2
	// Position of FRAME_MIS field.
	DCMI_MIS_FRAME_MIS_Pos = 0x0
	// Bit mask of FRAME_MIS field.
	DCMI_MIS_FRAME_MIS_Msk = 0x1
	// Bit FRAME_MIS.
	DCMI_MIS_FRAME_MIS = 0x1

	// ICR: interrupt clear register
	// Position of LINE_ISC field.
	DCMI_ICR_LINE_ISC_Pos = 0x4
	// Bit mask of LINE_ISC field.
	DCMI_ICR_LINE_ISC_Msk = 0x10
	// Bit LINE_ISC.
	DCMI_ICR_LINE_ISC = 0x10
	// Position of VSYNC_ISC field.
	DCMI_ICR_VSYNC_ISC_Pos = 0x3
	// Bit mask of VSYNC_ISC field.
	DCMI_ICR_VSYNC_ISC_Msk = 0x8
	// Bit VSYNC_ISC.
	DCMI_ICR_VSYNC_ISC = 0x8
	// Position of ERR_ISC field.
	DCMI_ICR_ERR_ISC_Pos = 0x2
	// Bit mask of ERR_ISC field.
	DCMI_ICR_ERR_ISC_Msk = 0x4
	// Bit ERR_ISC.
	DCMI_ICR_ERR_ISC = 0x4
	// Position of OVR_ISC field.
	DCMI_ICR_OVR_ISC_Pos = 0x1
	// Bit mask of OVR_ISC field.
	DCMI_ICR_OVR_ISC_Msk = 0x2
	// Bit OVR_ISC.
	DCMI_ICR_OVR_ISC = 0x2
	// Position of FRAME_ISC field.
	DCMI_ICR_FRAME_ISC_Pos = 0x0
	// Bit mask of FRAME_ISC field.
	DCMI_ICR_FRAME_ISC_Msk = 0x1
	// Bit FRAME_ISC.
	DCMI_ICR_FRAME_ISC = 0x1

	// ESCR: embedded synchronization code register
	// Position of FEC field.
	DCMI_ESCR_FEC_Pos = 0x18
	// Bit mask of FEC field.
	DCMI_ESCR_FEC_Msk = 0xff000000
	// Position of LEC field.
	DCMI_ESCR_LEC_Pos = 0x10
	// Bit mask of LEC field.
	DCMI_ESCR_LEC_Msk = 0xff0000
	// Position of LSC field.
	DCMI_ESCR_LSC_Pos = 0x8
	// Bit mask of LSC field.
	DCMI_ESCR_LSC_Msk = 0xff00
	// Position of FSC field.
	DCMI_ESCR_FSC_Pos = 0x0
	// Bit mask of FSC field.
	DCMI_ESCR_FSC_Msk = 0xff

	// ESUR: embedded synchronization unmask register
	// Position of FEU field.
	DCMI_ESUR_FEU_Pos = 0x18
	// Bit mask of FEU field.
	DCMI_ESUR_FEU_Msk = 0xff000000
	// Position of LEU field.
	DCMI_ESUR_LEU_Pos = 0x10
	// Bit mask of LEU field.
	DCMI_ESUR_LEU_Msk = 0xff0000
	// Position of LSU field.
	DCMI_ESUR_LSU_Pos = 0x8
	// Bit mask of LSU field.
	DCMI_ESUR_LSU_Msk = 0xff00
	// Position of FSU field.
	DCMI_ESUR_FSU_Pos = 0x0
	// Bit mask of FSU field.
	DCMI_ESUR_FSU_Msk = 0xff

	// CWSTRT: crop window start
	// Position of VST field.
	DCMI_CWSTRT_VST_Pos = 0x10
	// Bit mask of VST field.
	DCMI_CWSTRT_VST_Msk = 0x1fff0000
	// Position of HOFFCNT field.
	DCMI_CWSTRT_HOFFCNT_Pos = 0x0
	// Bit mask of HOFFCNT field.
	DCMI_CWSTRT_HOFFCNT_Msk = 0x3fff

	// CWSIZE: crop window size
	// Position of VLINE field.
	DCMI_CWSIZE_VLINE_Pos = 0x10
	// Bit mask of VLINE field.
	DCMI_CWSIZE_VLINE_Msk = 0x3fff0000
	// Position of CAPCNT field.
	DCMI_CWSIZE_CAPCNT_Pos = 0x0
	// Bit mask of CAPCNT field.
	DCMI_CWSIZE_CAPCNT_Msk = 0x3fff

	// DR: data register
	// Position of Byte3 field.
	DCMI_DR_Byte3_Pos = 0x18
	// Bit mask of Byte3 field.
	DCMI_DR_Byte3_Msk = 0xff000000
	// Position of Byte2 field.
	DCMI_DR_Byte2_Pos = 0x10
	// Bit mask of Byte2 field.
	DCMI_DR_Byte2_Msk = 0xff0000
	// Position of Byte1 field.
	DCMI_DR_Byte1_Pos = 0x8
	// Bit mask of Byte1 field.
	DCMI_DR_Byte1_Msk = 0xff00
	// Position of Byte0 field.
	DCMI_DR_Byte0_Pos = 0x0
	// Bit mask of Byte0 field.
	DCMI_DR_Byte0_Msk = 0xff
)

// Constants for FMC: Flexible memory controller
const (
	// BCR1: SRAM/NOR-Flash chip-select control register 1
	// Position of CCLKEN field.
	FSMC_BCR1_CCLKEN_Pos = 0x14
	// Bit mask of CCLKEN field.
	FSMC_BCR1_CCLKEN_Msk = 0x100000
	// Bit CCLKEN.
	FSMC_BCR1_CCLKEN = 0x100000
	// The FMC_CLK is only generated during the synchronous memory access (read/write transaction)
	FSMC_BCR1_CCLKEN_Enabled = 0x1
	// The FMC_CLK is generated continuously during asynchronous and synchronous access. The FMC_CLK clock is activated when the CCLKEN is set
	FSMC_BCR1_CCLKEN_Disabled = 0x0
	// Position of CBURSTRW field.
	FSMC_BCR1_CBURSTRW_Pos = 0x13
	// Bit mask of CBURSTRW field.
	FSMC_BCR1_CBURSTRW_Msk = 0x80000
	// Bit CBURSTRW.
	FSMC_BCR1_CBURSTRW = 0x80000
	// Write operations are performed in synchronous mode
	FSMC_BCR1_CBURSTRW_Enabled = 0x1
	// Write operations are always performed in asynchronous mode
	FSMC_BCR1_CBURSTRW_Disabled = 0x0
	// Position of ASYNCWAIT field.
	FSMC_BCR1_ASYNCWAIT_Pos = 0xf
	// Bit mask of ASYNCWAIT field.
	FSMC_BCR1_ASYNCWAIT_Msk = 0x8000
	// Bit ASYNCWAIT.
	FSMC_BCR1_ASYNCWAIT = 0x8000
	// Wait signal not used in asynchronous mode
	FSMC_BCR1_ASYNCWAIT_Disabled = 0x0
	// Wait signal used even in asynchronous mode
	FSMC_BCR1_ASYNCWAIT_Enabled = 0x1
	// Position of EXTMOD field.
	FSMC_BCR1_EXTMOD_Pos = 0xe
	// Bit mask of EXTMOD field.
	FSMC_BCR1_EXTMOD_Msk = 0x4000
	// Bit EXTMOD.
	FSMC_BCR1_EXTMOD = 0x4000
	// Values inside the FMC_BWTR are not taken into account
	FSMC_BCR1_EXTMOD_Disabled = 0x0
	// Values inside the FMC_BWTR are taken into account
	FSMC_BCR1_EXTMOD_Enabled = 0x1
	// Position of WAITEN field.
	FSMC_BCR1_WAITEN_Pos = 0xd
	// Bit mask of WAITEN field.
	FSMC_BCR1_WAITEN_Msk = 0x2000
	// Bit WAITEN.
	FSMC_BCR1_WAITEN = 0x2000
	// Values inside the FMC_BWTR are taken into account
	FSMC_BCR1_WAITEN_Disabled = 0x0
	// NWAIT signal enabled
	FSMC_BCR1_WAITEN_Enabled = 0x1
	// Position of WREN field.
	FSMC_BCR1_WREN_Pos = 0xc
	// Bit mask of WREN field.
	FSMC_BCR1_WREN_Msk = 0x1000
	// Bit WREN.
	FSMC_BCR1_WREN = 0x1000
	// Write operations disabled for the bank by the FMC
	FSMC_BCR1_WREN_Disabled = 0x0
	// Write operations enabled for the bank by the FMC
	FSMC_BCR1_WREN_Enabled = 0x1
	// Position of WAITCFG field.
	FSMC_BCR1_WAITCFG_Pos = 0xb
	// Bit mask of WAITCFG field.
	FSMC_BCR1_WAITCFG_Msk = 0x800
	// Bit WAITCFG.
	FSMC_BCR1_WAITCFG = 0x800
	// NWAIT signal is active one data cycle before wait state
	FSMC_BCR1_WAITCFG_BeforeWaitState = 0x0
	// NWAIT signal is active during wait state
	FSMC_BCR1_WAITCFG_DuringWaitState = 0x1
	// Position of WAITPOL field.
	FSMC_BCR1_WAITPOL_Pos = 0x9
	// Bit mask of WAITPOL field.
	FSMC_BCR1_WAITPOL_Msk = 0x200
	// Bit WAITPOL.
	FSMC_BCR1_WAITPOL = 0x200
	// NWAIT active low
	FSMC_BCR1_WAITPOL_ActiveLow = 0x0
	// NWAIT active high
	FSMC_BCR1_WAITPOL_ActiveHigh = 0x1
	// Position of BURSTEN field.
	FSMC_BCR1_BURSTEN_Pos = 0x8
	// Bit mask of BURSTEN field.
	FSMC_BCR1_BURSTEN_Msk = 0x100
	// Bit BURSTEN.
	FSMC_BCR1_BURSTEN = 0x100
	// Burst mode disabled
	FSMC_BCR1_BURSTEN_Disabled = 0x0
	// Burst mode enabled
	FSMC_BCR1_BURSTEN_Enabled = 0x1
	// Position of FACCEN field.
	FSMC_BCR1_FACCEN_Pos = 0x6
	// Bit mask of FACCEN field.
	FSMC_BCR1_FACCEN_Msk = 0x40
	// Bit FACCEN.
	FSMC_BCR1_FACCEN = 0x40
	// Corresponding NOR Flash memory access is disabled
	FSMC_BCR1_FACCEN_Disabled = 0x0
	// Corresponding NOR Flash memory access is enabled
	FSMC_BCR1_FACCEN_Enabled = 0x1
	// Position of MWID field.
	FSMC_BCR1_MWID_Pos = 0x4
	// Bit mask of MWID field.
	FSMC_BCR1_MWID_Msk = 0x30
	// Memory data bus width 8 bits
	FSMC_BCR1_MWID_Bits8 = 0x0
	// Memory data bus width 16 bits
	FSMC_BCR1_MWID_Bits16 = 0x1
	// Memory data bus width 32 bits
	FSMC_BCR1_MWID_Bits32 = 0x2
	// Position of MTYP field.
	FSMC_BCR1_MTYP_Pos = 0x2
	// Bit mask of MTYP field.
	FSMC_BCR1_MTYP_Msk = 0xc
	// SRAM memory type
	FSMC_BCR1_MTYP_SRAM = 0x0
	// PSRAM (CRAM) memory type
	FSMC_BCR1_MTYP_PSRAM = 0x1
	// NOR Flash/OneNAND Flash
	FSMC_BCR1_MTYP_Flash = 0x2
	// Position of MUXEN field.
	FSMC_BCR1_MUXEN_Pos = 0x1
	// Bit mask of MUXEN field.
	FSMC_BCR1_MUXEN_Msk = 0x2
	// Bit MUXEN.
	FSMC_BCR1_MUXEN = 0x2
	// Address/Data non-multiplexed
	FSMC_BCR1_MUXEN_Disabled = 0x0
	// Address/Data multiplexed on databus
	FSMC_BCR1_MUXEN_Enabled = 0x1
	// Position of MBKEN field.
	FSMC_BCR1_MBKEN_Pos = 0x0
	// Bit mask of MBKEN field.
	FSMC_BCR1_MBKEN_Msk = 0x1
	// Bit MBKEN.
	FSMC_BCR1_MBKEN = 0x1
	// Corresponding memory bank is disabled
	FSMC_BCR1_MBKEN_Disabled = 0x0
	// Corresponding memory bank is enabled
	FSMC_BCR1_MBKEN_Enabled = 0x1
	// Position of WRAPMOD field.
	FSMC_BCR1_WRAPMOD_Pos = 0xa
	// Bit mask of WRAPMOD field.
	FSMC_BCR1_WRAPMOD_Msk = 0x400
	// Bit WRAPMOD.
	FSMC_BCR1_WRAPMOD = 0x400
	// Position of WFDIS field.
	FSMC_BCR1_WFDIS_Pos = 0x15
	// Bit mask of WFDIS field.
	FSMC_BCR1_WFDIS_Msk = 0x200000
	// Bit WFDIS.
	FSMC_BCR1_WFDIS = 0x200000
	// Write FIFO enabled
	FSMC_BCR1_WFDIS_Enabled = 0x0
	// Write FIFO disabled
	FSMC_BCR1_WFDIS_Disabled = 0x1
	// Position of CPSIZE field.
	FSMC_BCR1_CPSIZE_Pos = 0x10
	// Bit mask of CPSIZE field.
	FSMC_BCR1_CPSIZE_Msk = 0x70000
	// No burst split when crossing page boundary
	FSMC_BCR1_CPSIZE_NoBurstSplit = 0x0
	// 128 bytes CRAM page size
	FSMC_BCR1_CPSIZE_Bytes128 = 0x1
	// 256 bytes CRAM page size
	FSMC_BCR1_CPSIZE_Bytes256 = 0x2
	// 512 bytes CRAM page size
	FSMC_BCR1_CPSIZE_Bytes512 = 0x3
	// 1024 bytes CRAM page size
	FSMC_BCR1_CPSIZE_Bytes1024 = 0x4

	// BTR1: SRAM/NOR-Flash chip-select timing register 1
	// Position of ACCMOD field.
	FSMC_BTR_ACCMOD_Pos = 0x1c
	// Bit mask of ACCMOD field.
	FSMC_BTR_ACCMOD_Msk = 0x30000000
	// Access mode A
	FSMC_BTR_ACCMOD_A = 0x0
	// Access mode B
	FSMC_BTR_ACCMOD_B = 0x1
	// Access mode C
	FSMC_BTR_ACCMOD_C = 0x2
	// Access mode D
	FSMC_BTR_ACCMOD_D = 0x3
	// Position of DATLAT field.
	FSMC_BTR_DATLAT_Pos = 0x18
	// Bit mask of DATLAT field.
	FSMC_BTR_DATLAT_Msk = 0xf000000
	// Position of CLKDIV field.
	FSMC_BTR_CLKDIV_Pos = 0x14
	// Bit mask of CLKDIV field.
	FSMC_BTR_CLKDIV_Msk = 0xf00000
	// Position of BUSTURN field.
	FSMC_BTR_BUSTURN_Pos = 0x10
	// Bit mask of BUSTURN field.
	FSMC_BTR_BUSTURN_Msk = 0xf0000
	// Position of DATAST field.
	FSMC_BTR_DATAST_Pos = 0x8
	// Bit mask of DATAST field.
	FSMC_BTR_DATAST_Msk = 0xff00
	// Position of ADDHLD field.
	FSMC_BTR_ADDHLD_Pos = 0x4
	// Bit mask of ADDHLD field.
	FSMC_BTR_ADDHLD_Msk = 0xf0
	// Position of ADDSET field.
	FSMC_BTR_ADDSET_Pos = 0x0
	// Bit mask of ADDSET field.
	FSMC_BTR_ADDSET_Msk = 0xf

	// BCR2: SRAM/NOR-Flash chip-select control register 2
	// Position of CBURSTRW field.
	FSMC_BCR_CBURSTRW_Pos = 0x13
	// Bit mask of CBURSTRW field.
	FSMC_BCR_CBURSTRW_Msk = 0x80000
	// Bit CBURSTRW.
	FSMC_BCR_CBURSTRW = 0x80000
	// Write operations are performed in synchronous mode
	FSMC_BCR_CBURSTRW_Enabled = 0x1
	// Write operations are always performed in asynchronous mode
	FSMC_BCR_CBURSTRW_Disabled = 0x0
	// Position of ASYNCWAIT field.
	FSMC_BCR_ASYNCWAIT_Pos = 0xf
	// Bit mask of ASYNCWAIT field.
	FSMC_BCR_ASYNCWAIT_Msk = 0x8000
	// Bit ASYNCWAIT.
	FSMC_BCR_ASYNCWAIT = 0x8000
	// Wait signal not used in asynchronous mode
	FSMC_BCR_ASYNCWAIT_Disabled = 0x0
	// Wait signal used even in asynchronous mode
	FSMC_BCR_ASYNCWAIT_Enabled = 0x1
	// Position of EXTMOD field.
	FSMC_BCR_EXTMOD_Pos = 0xe
	// Bit mask of EXTMOD field.
	FSMC_BCR_EXTMOD_Msk = 0x4000
	// Bit EXTMOD.
	FSMC_BCR_EXTMOD = 0x4000
	// Values inside the FMC_BWTR are not taken into account
	FSMC_BCR_EXTMOD_Disabled = 0x0
	// Values inside the FMC_BWTR are taken into account
	FSMC_BCR_EXTMOD_Enabled = 0x1
	// Position of WAITEN field.
	FSMC_BCR_WAITEN_Pos = 0xd
	// Bit mask of WAITEN field.
	FSMC_BCR_WAITEN_Msk = 0x2000
	// Bit WAITEN.
	FSMC_BCR_WAITEN = 0x2000
	// Values inside the FMC_BWTR are taken into account
	FSMC_BCR_WAITEN_Disabled = 0x0
	// NWAIT signal enabled
	FSMC_BCR_WAITEN_Enabled = 0x1
	// Position of WREN field.
	FSMC_BCR_WREN_Pos = 0xc
	// Bit mask of WREN field.
	FSMC_BCR_WREN_Msk = 0x1000
	// Bit WREN.
	FSMC_BCR_WREN = 0x1000
	// Write operations disabled for the bank by the FMC
	FSMC_BCR_WREN_Disabled = 0x0
	// Write operations enabled for the bank by the FMC
	FSMC_BCR_WREN_Enabled = 0x1
	// Position of WAITCFG field.
	FSMC_BCR_WAITCFG_Pos = 0xb
	// Bit mask of WAITCFG field.
	FSMC_BCR_WAITCFG_Msk = 0x800
	// Bit WAITCFG.
	FSMC_BCR_WAITCFG = 0x800
	// NWAIT signal is active one data cycle before wait state
	FSMC_BCR_WAITCFG_BeforeWaitState = 0x0
	// NWAIT signal is active during wait state
	FSMC_BCR_WAITCFG_DuringWaitState = 0x1
	// Position of WRAPMOD field.
	FSMC_BCR_WRAPMOD_Pos = 0xa
	// Bit mask of WRAPMOD field.
	FSMC_BCR_WRAPMOD_Msk = 0x400
	// Bit WRAPMOD.
	FSMC_BCR_WRAPMOD = 0x400
	// Position of WAITPOL field.
	FSMC_BCR_WAITPOL_Pos = 0x9
	// Bit mask of WAITPOL field.
	FSMC_BCR_WAITPOL_Msk = 0x200
	// Bit WAITPOL.
	FSMC_BCR_WAITPOL = 0x200
	// NWAIT active low
	FSMC_BCR_WAITPOL_ActiveLow = 0x0
	// NWAIT active high
	FSMC_BCR_WAITPOL_ActiveHigh = 0x1
	// Position of BURSTEN field.
	FSMC_BCR_BURSTEN_Pos = 0x8
	// Bit mask of BURSTEN field.
	FSMC_BCR_BURSTEN_Msk = 0x100
	// Bit BURSTEN.
	FSMC_BCR_BURSTEN = 0x100
	// Burst mode disabled
	FSMC_BCR_BURSTEN_Disabled = 0x0
	// Burst mode enabled
	FSMC_BCR_BURSTEN_Enabled = 0x1
	// Position of FACCEN field.
	FSMC_BCR_FACCEN_Pos = 0x6
	// Bit mask of FACCEN field.
	FSMC_BCR_FACCEN_Msk = 0x40
	// Bit FACCEN.
	FSMC_BCR_FACCEN = 0x40
	// Corresponding NOR Flash memory access is disabled
	FSMC_BCR_FACCEN_Disabled = 0x0
	// Corresponding NOR Flash memory access is enabled
	FSMC_BCR_FACCEN_Enabled = 0x1
	// Position of MWID field.
	FSMC_BCR_MWID_Pos = 0x4
	// Bit mask of MWID field.
	FSMC_BCR_MWID_Msk = 0x30
	// Memory data bus width 8 bits
	FSMC_BCR_MWID_Bits8 = 0x0
	// Memory data bus width 16 bits
	FSMC_BCR_MWID_Bits16 = 0x1
	// Memory data bus width 32 bits
	FSMC_BCR_MWID_Bits32 = 0x2
	// Position of MTYP field.
	FSMC_BCR_MTYP_Pos = 0x2
	// Bit mask of MTYP field.
	FSMC_BCR_MTYP_Msk = 0xc
	// SRAM memory type
	FSMC_BCR_MTYP_SRAM = 0x0
	// PSRAM (CRAM) memory type
	FSMC_BCR_MTYP_PSRAM = 0x1
	// NOR Flash/OneNAND Flash
	FSMC_BCR_MTYP_Flash = 0x2
	// Position of MUXEN field.
	FSMC_BCR_MUXEN_Pos = 0x1
	// Bit mask of MUXEN field.
	FSMC_BCR_MUXEN_Msk = 0x2
	// Bit MUXEN.
	FSMC_BCR_MUXEN = 0x2
	// Address/Data non-multiplexed
	FSMC_BCR_MUXEN_Disabled = 0x0
	// Address/Data multiplexed on databus
	FSMC_BCR_MUXEN_Enabled = 0x1
	// Position of MBKEN field.
	FSMC_BCR_MBKEN_Pos = 0x0
	// Bit mask of MBKEN field.
	FSMC_BCR_MBKEN_Msk = 0x1
	// Bit MBKEN.
	FSMC_BCR_MBKEN = 0x1
	// Corresponding memory bank is disabled
	FSMC_BCR_MBKEN_Disabled = 0x0
	// Corresponding memory bank is enabled
	FSMC_BCR_MBKEN_Enabled = 0x1
	// Position of CPSIZE field.
	FSMC_BCR_CPSIZE_Pos = 0x10
	// Bit mask of CPSIZE field.
	FSMC_BCR_CPSIZE_Msk = 0x70000
	// No burst split when crossing page boundary
	FSMC_BCR_CPSIZE_NoBurstSplit = 0x0
	// 128 bytes CRAM page size
	FSMC_BCR_CPSIZE_Bytes128 = 0x1
	// 256 bytes CRAM page size
	FSMC_BCR_CPSIZE_Bytes256 = 0x2
	// 512 bytes CRAM page size
	FSMC_BCR_CPSIZE_Bytes512 = 0x3
	// 1024 bytes CRAM page size
	FSMC_BCR_CPSIZE_Bytes1024 = 0x4

	// PCR: PC Card/NAND Flash control register
	// Position of ECCPS field.
	FSMC_PCR_ECCPS_Pos = 0x11
	// Bit mask of ECCPS field.
	FSMC_PCR_ECCPS_Msk = 0xe0000
	// ECC page size 256 bytes
	FSMC_PCR_ECCPS_Bytes256 = 0x0
	// ECC page size 512 bytes
	FSMC_PCR_ECCPS_Bytes512 = 0x1
	// ECC page size 1024 bytes
	FSMC_PCR_ECCPS_Bytes1024 = 0x2
	// ECC page size 2048 bytes
	FSMC_PCR_ECCPS_Bytes2048 = 0x3
	// ECC page size 4096 bytes
	FSMC_PCR_ECCPS_Bytes4096 = 0x4
	// ECC page size 8192 bytes
	FSMC_PCR_ECCPS_Bytes8192 = 0x5
	// Position of TAR field.
	FSMC_PCR_TAR_Pos = 0xd
	// Bit mask of TAR field.
	FSMC_PCR_TAR_Msk = 0x1e000
	// Position of TCLR field.
	FSMC_PCR_TCLR_Pos = 0x9
	// Bit mask of TCLR field.
	FSMC_PCR_TCLR_Msk = 0x1e00
	// Position of ECCEN field.
	FSMC_PCR_ECCEN_Pos = 0x6
	// Bit mask of ECCEN field.
	FSMC_PCR_ECCEN_Msk = 0x40
	// Bit ECCEN.
	FSMC_PCR_ECCEN = 0x40
	// ECC logic is disabled and reset
	FSMC_PCR_ECCEN_Disabled = 0x0
	// ECC logic is enabled
	FSMC_PCR_ECCEN_Enabled = 0x1
	// Position of PWID field.
	FSMC_PCR_PWID_Pos = 0x4
	// Bit mask of PWID field.
	FSMC_PCR_PWID_Msk = 0x30
	// External memory device width 8 bits
	FSMC_PCR_PWID_Bits8 = 0x0
	// External memory device width 16 bits
	FSMC_PCR_PWID_Bits16 = 0x1
	// Position of PTYP field.
	FSMC_PCR_PTYP_Pos = 0x3
	// Bit mask of PTYP field.
	FSMC_PCR_PTYP_Msk = 0x8
	// Bit PTYP.
	FSMC_PCR_PTYP = 0x8
	// NAND Flash
	FSMC_PCR_PTYP_NANDFlash = 0x1
	// Position of PBKEN field.
	FSMC_PCR_PBKEN_Pos = 0x2
	// Bit mask of PBKEN field.
	FSMC_PCR_PBKEN_Msk = 0x4
	// Bit PBKEN.
	FSMC_PCR_PBKEN = 0x4
	// Corresponding memory bank is disabled
	FSMC_PCR_PBKEN_Disabled = 0x0
	// Corresponding memory bank is enabled
	FSMC_PCR_PBKEN_Enabled = 0x1
	// Position of PWAITEN field.
	FSMC_PCR_PWAITEN_Pos = 0x1
	// Bit mask of PWAITEN field.
	FSMC_PCR_PWAITEN_Msk = 0x2
	// Bit PWAITEN.
	FSMC_PCR_PWAITEN = 0x2
	// Wait feature disabled
	FSMC_PCR_PWAITEN_Disabled = 0x0
	// Wait feature enabled
	FSMC_PCR_PWAITEN_Enabled = 0x1

	// SR: FIFO status and interrupt register
	// Position of FEMPT field.
	FSMC_SR_FEMPT_Pos = 0x6
	// Bit mask of FEMPT field.
	FSMC_SR_FEMPT_Msk = 0x40
	// Bit FEMPT.
	FSMC_SR_FEMPT = 0x40
	// FIFO not empty
	FSMC_SR_FEMPT_NotEmpty = 0x0
	// FIFO empty
	FSMC_SR_FEMPT_Empty = 0x1
	// Position of IFEN field.
	FSMC_SR_IFEN_Pos = 0x5
	// Bit mask of IFEN field.
	FSMC_SR_IFEN_Msk = 0x20
	// Bit IFEN.
	FSMC_SR_IFEN = 0x20
	// Interrupt falling edge detection request disabled
	FSMC_SR_IFEN_Disabled = 0x0
	// Interrupt falling edge detection request enabled
	FSMC_SR_IFEN_Enabled = 0x1
	// Position of ILEN field.
	FSMC_SR_ILEN_Pos = 0x4
	// Bit mask of ILEN field.
	FSMC_SR_ILEN_Msk = 0x10
	// Bit ILEN.
	FSMC_SR_ILEN = 0x10
	// Interrupt high-level detection request disabled
	FSMC_SR_ILEN_Disabled = 0x0
	// Interrupt high-level detection request enabled
	FSMC_SR_ILEN_Enabled = 0x1
	// Position of IREN field.
	FSMC_SR_IREN_Pos = 0x3
	// Bit mask of IREN field.
	FSMC_SR_IREN_Msk = 0x8
	// Bit IREN.
	FSMC_SR_IREN = 0x8
	// Interrupt rising edge detection request disabled
	FSMC_SR_IREN_Disabled = 0x0
	// Interrupt rising edge detection request enabled
	FSMC_SR_IREN_Enabled = 0x1
	// Position of IFS field.
	FSMC_SR_IFS_Pos = 0x2
	// Bit mask of IFS field.
	FSMC_SR_IFS_Msk = 0x4
	// Bit IFS.
	FSMC_SR_IFS = 0x4
	// Interrupt falling edge did not occur
	FSMC_SR_IFS_DidNotOccur = 0x0
	// Interrupt falling edge occurred
	FSMC_SR_IFS_Occurred = 0x1
	// Position of ILS field.
	FSMC_SR_ILS_Pos = 0x1
	// Bit mask of ILS field.
	FSMC_SR_ILS_Msk = 0x2
	// Bit ILS.
	FSMC_SR_ILS = 0x2
	// Interrupt high-level did not occur
	FSMC_SR_ILS_DidNotOccur = 0x0
	// Interrupt high-level occurred
	FSMC_SR_ILS_Occurred = 0x1
	// Position of IRS field.
	FSMC_SR_IRS_Pos = 0x0
	// Bit mask of IRS field.
	FSMC_SR_IRS_Msk = 0x1
	// Bit IRS.
	FSMC_SR_IRS = 0x1
	// Interrupt rising edge did not occur
	FSMC_SR_IRS_DidNotOccur = 0x0
	// Interrupt rising edge occurred
	FSMC_SR_IRS_Occurred = 0x1

	// PMEM: Common memory space timing register
	// Position of MEMHIZ field.
	FSMC_PMEM_MEMHIZ_Pos = 0x18
	// Bit mask of MEMHIZ field.
	FSMC_PMEM_MEMHIZ_Msk = 0xff000000
	// Position of MEMHOLD field.
	FSMC_PMEM_MEMHOLD_Pos = 0x10
	// Bit mask of MEMHOLD field.
	FSMC_PMEM_MEMHOLD_Msk = 0xff0000
	// Position of MEMWAIT field.
	FSMC_PMEM_MEMWAIT_Pos = 0x8
	// Bit mask of MEMWAIT field.
	FSMC_PMEM_MEMWAIT_Msk = 0xff00
	// Position of MEMSET field.
	FSMC_PMEM_MEMSET_Pos = 0x0
	// Bit mask of MEMSET field.
	FSMC_PMEM_MEMSET_Msk = 0xff

	// PATT: Attribute memory space timing register
	// Position of ATTHIZ field.
	FSMC_PATT_ATTHIZ_Pos = 0x18
	// Bit mask of ATTHIZ field.
	FSMC_PATT_ATTHIZ_Msk = 0xff000000
	// Position of ATTHOLD field.
	FSMC_PATT_ATTHOLD_Pos = 0x10
	// Bit mask of ATTHOLD field.
	FSMC_PATT_ATTHOLD_Msk = 0xff0000
	// Position of ATTWAIT field.
	FSMC_PATT_ATTWAIT_Pos = 0x8
	// Bit mask of ATTWAIT field.
	FSMC_PATT_ATTWAIT_Msk = 0xff00
	// Position of ATTSET field.
	FSMC_PATT_ATTSET_Pos = 0x0
	// Bit mask of ATTSET field.
	FSMC_PATT_ATTSET_Msk = 0xff

	// ECCR: ECC result register
	// Position of ECC field.
	FSMC_ECCR_ECC_Pos = 0x0
	// Bit mask of ECC field.
	FSMC_ECCR_ECC_Msk = 0xffffffff

	// BWTR1: SRAM/NOR-Flash write timing registers 1
	// Position of ACCMOD field.
	FSMC_BWTR_ACCMOD_Pos = 0x1c
	// Bit mask of ACCMOD field.
	FSMC_BWTR_ACCMOD_Msk = 0x30000000
	// Access mode A
	FSMC_BWTR_ACCMOD_A = 0x0
	// Access mode B
	FSMC_BWTR_ACCMOD_B = 0x1
	// Access mode C
	FSMC_BWTR_ACCMOD_C = 0x2
	// Access mode D
	FSMC_BWTR_ACCMOD_D = 0x3
	// Position of DATLAT field.
	FSMC_BWTR_DATLAT_Pos = 0x18
	// Bit mask of DATLAT field.
	FSMC_BWTR_DATLAT_Msk = 0xf000000
	// Position of CLKDIV field.
	FSMC_BWTR_CLKDIV_Pos = 0x14
	// Bit mask of CLKDIV field.
	FSMC_BWTR_CLKDIV_Msk = 0xf00000
	// Position of DATAST field.
	FSMC_BWTR_DATAST_Pos = 0x8
	// Bit mask of DATAST field.
	FSMC_BWTR_DATAST_Msk = 0xff00
	// Position of ADDHLD field.
	FSMC_BWTR_ADDHLD_Pos = 0x4
	// Bit mask of ADDHLD field.
	FSMC_BWTR_ADDHLD_Msk = 0xf0
	// Position of ADDSET field.
	FSMC_BWTR_ADDSET_Pos = 0x0
	// Bit mask of ADDSET field.
	FSMC_BWTR_ADDSET_Msk = 0xf
	// Position of BUSTURN field.
	FSMC_BWTR_BUSTURN_Pos = 0x10
	// Bit mask of BUSTURN field.
	FSMC_BWTR_BUSTURN_Msk = 0xf0000

	// SDCR1: SDRAM Control Register 1
	// Position of NC field.
	FSMC_SDCR_NC_Pos = 0x0
	// Bit mask of NC field.
	FSMC_SDCR_NC_Msk = 0x3
	// 8 bits
	FSMC_SDCR_NC_Bits8 = 0x0
	// 9 bits
	FSMC_SDCR_NC_Bits9 = 0x1
	// 10 bits
	FSMC_SDCR_NC_Bits10 = 0x2
	// 11 bits
	FSMC_SDCR_NC_Bits11 = 0x3
	// Position of NR field.
	FSMC_SDCR_NR_Pos = 0x2
	// Bit mask of NR field.
	FSMC_SDCR_NR_Msk = 0xc
	// 11 bits
	FSMC_SDCR_NR_Bits11 = 0x0
	// 12 bits
	FSMC_SDCR_NR_Bits12 = 0x1
	// 13 bits
	FSMC_SDCR_NR_Bits13 = 0x2
	// Position of MWID field.
	FSMC_SDCR_MWID_Pos = 0x4
	// Bit mask of MWID field.
	FSMC_SDCR_MWID_Msk = 0x30
	// Memory data bus width 8 bits
	FSMC_SDCR_MWID_Bits8 = 0x0
	// Memory data bus width 16 bits
	FSMC_SDCR_MWID_Bits16 = 0x1
	// Memory data bus width 32 bits
	FSMC_SDCR_MWID_Bits32 = 0x2
	// Position of NB field.
	FSMC_SDCR_NB_Pos = 0x6
	// Bit mask of NB field.
	FSMC_SDCR_NB_Msk = 0x40
	// Bit NB.
	FSMC_SDCR_NB = 0x40
	// Two internal Banks
	FSMC_SDCR_NB_NB2 = 0x0
	// Four internal Banks
	FSMC_SDCR_NB_NB4 = 0x1
	// Position of CAS field.
	FSMC_SDCR_CAS_Pos = 0x7
	// Bit mask of CAS field.
	FSMC_SDCR_CAS_Msk = 0x180
	// 1 cycle
	FSMC_SDCR_CAS_Clocks1 = 0x1
	// 2 cycles
	FSMC_SDCR_CAS_Clocks2 = 0x2
	// 3 cycles
	FSMC_SDCR_CAS_Clocks3 = 0x3
	// Position of WP field.
	FSMC_SDCR_WP_Pos = 0x9
	// Bit mask of WP field.
	FSMC_SDCR_WP_Msk = 0x200
	// Bit WP.
	FSMC_SDCR_WP = 0x200
	// Write accesses allowed
	FSMC_SDCR_WP_Disabled = 0x0
	// Write accesses ignored
	FSMC_SDCR_WP_Enabled = 0x1
	// Position of SDCLK field.
	FSMC_SDCR_SDCLK_Pos = 0xa
	// Bit mask of SDCLK field.
	FSMC_SDCR_SDCLK_Msk = 0xc00
	// SDCLK clock disabled
	FSMC_SDCR_SDCLK_Disabled = 0x0
	// SDCLK period = 2 x HCLK period
	FSMC_SDCR_SDCLK_Div2 = 0x2
	// SDCLK period = 3 x HCLK period
	FSMC_SDCR_SDCLK_Div3 = 0x3
	// Position of RBURST field.
	FSMC_SDCR_RBURST_Pos = 0xc
	// Bit mask of RBURST field.
	FSMC_SDCR_RBURST_Msk = 0x1000
	// Bit RBURST.
	FSMC_SDCR_RBURST = 0x1000
	// Single read requests are not managed as bursts
	FSMC_SDCR_RBURST_Disabled = 0x0
	// Single read requests are always managed as bursts
	FSMC_SDCR_RBURST_Enabled = 0x1
	// Position of RPIPE field.
	FSMC_SDCR_RPIPE_Pos = 0xd
	// Bit mask of RPIPE field.
	FSMC_SDCR_RPIPE_Msk = 0x6000
	// No clock cycle delay
	FSMC_SDCR_RPIPE_NoDelay = 0x0
	// One clock cycle delay
	FSMC_SDCR_RPIPE_Clocks1 = 0x1
	// Two clock cycles delay
	FSMC_SDCR_RPIPE_Clocks2 = 0x2

	// SDTR1: SDRAM Timing register 1
	// Position of TMRD field.
	FSMC_SDTR_TMRD_Pos = 0x0
	// Bit mask of TMRD field.
	FSMC_SDTR_TMRD_Msk = 0xf
	// Position of TXSR field.
	FSMC_SDTR_TXSR_Pos = 0x4
	// Bit mask of TXSR field.
	FSMC_SDTR_TXSR_Msk = 0xf0
	// Position of TRAS field.
	FSMC_SDTR_TRAS_Pos = 0x8
	// Bit mask of TRAS field.
	FSMC_SDTR_TRAS_Msk = 0xf00
	// Position of TRC field.
	FSMC_SDTR_TRC_Pos = 0xc
	// Bit mask of TRC field.
	FSMC_SDTR_TRC_Msk = 0xf000
	// Position of TWR field.
	FSMC_SDTR_TWR_Pos = 0x10
	// Bit mask of TWR field.
	FSMC_SDTR_TWR_Msk = 0xf0000
	// Position of TRP field.
	FSMC_SDTR_TRP_Pos = 0x14
	// Bit mask of TRP field.
	FSMC_SDTR_TRP_Msk = 0xf00000
	// Position of TRCD field.
	FSMC_SDTR_TRCD_Pos = 0x18
	// Bit mask of TRCD field.
	FSMC_SDTR_TRCD_Msk = 0xf000000

	// SDCMR: SDRAM Command Mode register
	// Position of MODE field.
	FSMC_SDCMR_MODE_Pos = 0x0
	// Bit mask of MODE field.
	FSMC_SDCMR_MODE_Msk = 0x7
	// Normal Mode
	FSMC_SDCMR_MODE_Normal = 0x0
	// Clock Configuration Enable
	FSMC_SDCMR_MODE_ClockConfigurationEnable = 0x1
	// PALL (All Bank Precharge) command
	FSMC_SDCMR_MODE_PALL = 0x2
	// Auto-refresh command
	FSMC_SDCMR_MODE_AutoRefreshCommand = 0x3
	// Load Mode Resgier
	FSMC_SDCMR_MODE_LoadModeRegister = 0x4
	// Self-refresh command
	FSMC_SDCMR_MODE_SelfRefreshCommand = 0x5
	// Power-down command
	FSMC_SDCMR_MODE_PowerDownCommand = 0x6
	// Position of CTB2 field.
	FSMC_SDCMR_CTB2_Pos = 0x3
	// Bit mask of CTB2 field.
	FSMC_SDCMR_CTB2_Msk = 0x8
	// Bit CTB2.
	FSMC_SDCMR_CTB2 = 0x8
	// Command not issued to SDRAM Bank 1
	FSMC_SDCMR_CTB2_NotIssued = 0x0
	// Command issued to SDRAM Bank 1
	FSMC_SDCMR_CTB2_Issued = 0x1
	// Position of CTB1 field.
	FSMC_SDCMR_CTB1_Pos = 0x4
	// Bit mask of CTB1 field.
	FSMC_SDCMR_CTB1_Msk = 0x10
	// Bit CTB1.
	FSMC_SDCMR_CTB1 = 0x10
	// Command not issued to SDRAM Bank 1
	FSMC_SDCMR_CTB1_NotIssued = 0x0
	// Command issued to SDRAM Bank 1
	FSMC_SDCMR_CTB1_Issued = 0x1
	// Position of NRFS field.
	FSMC_SDCMR_NRFS_Pos = 0x5
	// Bit mask of NRFS field.
	FSMC_SDCMR_NRFS_Msk = 0x1e0
	// Position of MRD field.
	FSMC_SDCMR_MRD_Pos = 0x9
	// Bit mask of MRD field.
	FSMC_SDCMR_MRD_Msk = 0x3ffe00

	// SDRTR: SDRAM Refresh Timer register
	// Position of CRE field.
	FSMC_SDRTR_CRE_Pos = 0x0
	// Bit mask of CRE field.
	FSMC_SDRTR_CRE_Msk = 0x1
	// Bit CRE.
	FSMC_SDRTR_CRE = 0x1
	// Refresh Error Flag is cleared
	FSMC_SDRTR_CRE_Clear = 0x1
	// Position of COUNT field.
	FSMC_SDRTR_COUNT_Pos = 0x1
	// Bit mask of COUNT field.
	FSMC_SDRTR_COUNT_Msk = 0x3ffe
	// Position of REIE field.
	FSMC_SDRTR_REIE_Pos = 0xe
	// Bit mask of REIE field.
	FSMC_SDRTR_REIE_Msk = 0x4000
	// Bit REIE.
	FSMC_SDRTR_REIE = 0x4000
	// Interrupt is disabled
	FSMC_SDRTR_REIE_Disabled = 0x0
	// Interrupt is generated if RE = 1
	FSMC_SDRTR_REIE_Enabled = 0x1

	// SDSR: SDRAM Status register
	// Position of RE field.
	FSMC_SDSR_RE_Pos = 0x0
	// Bit mask of RE field.
	FSMC_SDSR_RE_Msk = 0x1
	// Bit RE.
	FSMC_SDSR_RE = 0x1
	// No refresh error has been detected
	FSMC_SDSR_RE_NoError = 0x0
	// A refresh error has been detected
	FSMC_SDSR_RE_Error = 0x1
	// Position of MODES1 field.
	FSMC_SDSR_MODES1_Pos = 0x1
	// Bit mask of MODES1 field.
	FSMC_SDSR_MODES1_Msk = 0x6
	// Normal Mode
	FSMC_SDSR_MODES1_Normal = 0x0
	// Self-refresh mode
	FSMC_SDSR_MODES1_SelfRefresh = 0x1
	// Power-down mode
	FSMC_SDSR_MODES1_PowerDown = 0x2
	// Position of MODES2 field.
	FSMC_SDSR_MODES2_Pos = 0x3
	// Bit mask of MODES2 field.
	FSMC_SDSR_MODES2_Msk = 0x18
	// Normal Mode
	FSMC_SDSR_MODES2_Normal = 0x0
	// Self-refresh mode
	FSMC_SDSR_MODES2_SelfRefresh = 0x1
	// Power-down mode
	FSMC_SDSR_MODES2_PowerDown = 0x2
	// Position of BUSY field.
	FSMC_SDSR_BUSY_Pos = 0x5
	// Bit mask of BUSY field.
	FSMC_SDSR_BUSY_Msk = 0x20
	// Bit BUSY.
	FSMC_SDSR_BUSY = 0x20
	// SDRAM Controller is ready to accept a new request
	FSMC_SDSR_BUSY_NotBusy = 0x0
	// SDRAM Controller is not ready to accept a new request
	FSMC_SDSR_BUSY_Busy = 0x1
)

// Constants for DMA2: DMA controller
const (
	// LISR: low interrupt status register
	// Position of TCIF3 field.
	DMA_LISR_TCIF3_Pos = 0x1b
	// Bit mask of TCIF3 field.
	DMA_LISR_TCIF3_Msk = 0x8000000
	// Bit TCIF3.
	DMA_LISR_TCIF3 = 0x8000000
	// No transfer complete event on stream x
	DMA_LISR_TCIF3_NotComplete = 0x0
	// A transfer complete event occurred on stream x
	DMA_LISR_TCIF3_Complete = 0x1
	// Position of HTIF3 field.
	DMA_LISR_HTIF3_Pos = 0x1a
	// Bit mask of HTIF3 field.
	DMA_LISR_HTIF3_Msk = 0x4000000
	// Bit HTIF3.
	DMA_LISR_HTIF3 = 0x4000000
	// No half transfer event on stream x
	DMA_LISR_HTIF3_NotHalf = 0x0
	// A half transfer event occurred on stream x
	DMA_LISR_HTIF3_Half = 0x1
	// Position of TEIF3 field.
	DMA_LISR_TEIF3_Pos = 0x19
	// Bit mask of TEIF3 field.
	DMA_LISR_TEIF3_Msk = 0x2000000
	// Bit TEIF3.
	DMA_LISR_TEIF3 = 0x2000000
	// No transfer error on stream x
	DMA_LISR_TEIF3_NoError = 0x0
	// A transfer error occurred on stream x
	DMA_LISR_TEIF3_Error = 0x1
	// Position of DMEIF3 field.
	DMA_LISR_DMEIF3_Pos = 0x18
	// Bit mask of DMEIF3 field.
	DMA_LISR_DMEIF3_Msk = 0x1000000
	// Bit DMEIF3.
	DMA_LISR_DMEIF3 = 0x1000000
	// No Direct Mode error on stream x
	DMA_LISR_DMEIF3_NoError = 0x0
	// A Direct Mode error occurred on stream x
	DMA_LISR_DMEIF3_Error = 0x1
	// Position of FEIF3 field.
	DMA_LISR_FEIF3_Pos = 0x16
	// Bit mask of FEIF3 field.
	DMA_LISR_FEIF3_Msk = 0x400000
	// Bit FEIF3.
	DMA_LISR_FEIF3 = 0x400000
	// No FIFO error event on stream x
	DMA_LISR_FEIF3_NoError = 0x0
	// A FIFO error event occurred on stream x
	DMA_LISR_FEIF3_Error = 0x1
	// Position of TCIF2 field.
	DMA_LISR_TCIF2_Pos = 0x15
	// Bit mask of TCIF2 field.
	DMA_LISR_TCIF2_Msk = 0x200000
	// Bit TCIF2.
	DMA_LISR_TCIF2 = 0x200000
	// No transfer complete event on stream x
	DMA_LISR_TCIF2_NotComplete = 0x0
	// A transfer complete event occurred on stream x
	DMA_LISR_TCIF2_Complete = 0x1
	// Position of HTIF2 field.
	DMA_LISR_HTIF2_Pos = 0x14
	// Bit mask of HTIF2 field.
	DMA_LISR_HTIF2_Msk = 0x100000
	// Bit HTIF2.
	DMA_LISR_HTIF2 = 0x100000
	// No half transfer event on stream x
	DMA_LISR_HTIF2_NotHalf = 0x0
	// A half transfer event occurred on stream x
	DMA_LISR_HTIF2_Half = 0x1
	// Position of TEIF2 field.
	DMA_LISR_TEIF2_Pos = 0x13
	// Bit mask of TEIF2 field.
	DMA_LISR_TEIF2_Msk = 0x80000
	// Bit TEIF2.
	DMA_LISR_TEIF2 = 0x80000
	// No transfer error on stream x
	DMA_LISR_TEIF2_NoError = 0x0
	// A transfer error occurred on stream x
	DMA_LISR_TEIF2_Error = 0x1
	// Position of DMEIF2 field.
	DMA_LISR_DMEIF2_Pos = 0x12
	// Bit mask of DMEIF2 field.
	DMA_LISR_DMEIF2_Msk = 0x40000
	// Bit DMEIF2.
	DMA_LISR_DMEIF2 = 0x40000
	// No Direct Mode error on stream x
	DMA_LISR_DMEIF2_NoError = 0x0
	// A Direct Mode error occurred on stream x
	DMA_LISR_DMEIF2_Error = 0x1
	// Position of FEIF2 field.
	DMA_LISR_FEIF2_Pos = 0x10
	// Bit mask of FEIF2 field.
	DMA_LISR_FEIF2_Msk = 0x10000
	// Bit FEIF2.
	DMA_LISR_FEIF2 = 0x10000
	// No FIFO error event on stream x
	DMA_LISR_FEIF2_NoError = 0x0
	// A FIFO error event occurred on stream x
	DMA_LISR_FEIF2_Error = 0x1
	// Position of TCIF1 field.
	DMA_LISR_TCIF1_Pos = 0xb
	// Bit mask of TCIF1 field.
	DMA_LISR_TCIF1_Msk = 0x800
	// Bit TCIF1.
	DMA_LISR_TCIF1 = 0x800
	// No transfer complete event on stream x
	DMA_LISR_TCIF1_NotComplete = 0x0
	// A transfer complete event occurred on stream x
	DMA_LISR_TCIF1_Complete = 0x1
	// Position of HTIF1 field.
	DMA_LISR_HTIF1_Pos = 0xa
	// Bit mask of HTIF1 field.
	DMA_LISR_HTIF1_Msk = 0x400
	// Bit HTIF1.
	DMA_LISR_HTIF1 = 0x400
	// No half transfer event on stream x
	DMA_LISR_HTIF1_NotHalf = 0x0
	// A half transfer event occurred on stream x
	DMA_LISR_HTIF1_Half = 0x1
	// Position of TEIF1 field.
	DMA_LISR_TEIF1_Pos = 0x9
	// Bit mask of TEIF1 field.
	DMA_LISR_TEIF1_Msk = 0x200
	// Bit TEIF1.
	DMA_LISR_TEIF1 = 0x200
	// No transfer error on stream x
	DMA_LISR_TEIF1_NoError = 0x0
	// A transfer error occurred on stream x
	DMA_LISR_TEIF1_Error = 0x1
	// Position of DMEIF1 field.
	DMA_LISR_DMEIF1_Pos = 0x8
	// Bit mask of DMEIF1 field.
	DMA_LISR_DMEIF1_Msk = 0x100
	// Bit DMEIF1.
	DMA_LISR_DMEIF1 = 0x100
	// No Direct Mode error on stream x
	DMA_LISR_DMEIF1_NoError = 0x0
	// A Direct Mode error occurred on stream x
	DMA_LISR_DMEIF1_Error = 0x1
	// Position of FEIF1 field.
	DMA_LISR_FEIF1_Pos = 0x6
	// Bit mask of FEIF1 field.
	DMA_LISR_FEIF1_Msk = 0x40
	// Bit FEIF1.
	DMA_LISR_FEIF1 = 0x40
	// No FIFO error event on stream x
	DMA_LISR_FEIF1_NoError = 0x0
	// A FIFO error event occurred on stream x
	DMA_LISR_FEIF1_Error = 0x1
	// Position of TCIF0 field.
	DMA_LISR_TCIF0_Pos = 0x5
	// Bit mask of TCIF0 field.
	DMA_LISR_TCIF0_Msk = 0x20
	// Bit TCIF0.
	DMA_LISR_TCIF0 = 0x20
	// No transfer complete event on stream x
	DMA_LISR_TCIF0_NotComplete = 0x0
	// A transfer complete event occurred on stream x
	DMA_LISR_TCIF0_Complete = 0x1
	// Position of HTIF0 field.
	DMA_LISR_HTIF0_Pos = 0x4
	// Bit mask of HTIF0 field.
	DMA_LISR_HTIF0_Msk = 0x10
	// Bit HTIF0.
	DMA_LISR_HTIF0 = 0x10
	// No half transfer event on stream x
	DMA_LISR_HTIF0_NotHalf = 0x0
	// A half transfer event occurred on stream x
	DMA_LISR_HTIF0_Half = 0x1
	// Position of TEIF0 field.
	DMA_LISR_TEIF0_Pos = 0x3
	// Bit mask of TEIF0 field.
	DMA_LISR_TEIF0_Msk = 0x8
	// Bit TEIF0.
	DMA_LISR_TEIF0 = 0x8
	// No transfer error on stream x
	DMA_LISR_TEIF0_NoError = 0x0
	// A transfer error occurred on stream x
	DMA_LISR_TEIF0_Error = 0x1
	// Position of DMEIF0 field.
	DMA_LISR_DMEIF0_Pos = 0x2
	// Bit mask of DMEIF0 field.
	DMA_LISR_DMEIF0_Msk = 0x4
	// Bit DMEIF0.
	DMA_LISR_DMEIF0 = 0x4
	// No Direct Mode error on stream x
	DMA_LISR_DMEIF0_NoError = 0x0
	// A Direct Mode error occurred on stream x
	DMA_LISR_DMEIF0_Error = 0x1
	// Position of FEIF0 field.
	DMA_LISR_FEIF0_Pos = 0x0
	// Bit mask of FEIF0 field.
	DMA_LISR_FEIF0_Msk = 0x1
	// Bit FEIF0.
	DMA_LISR_FEIF0 = 0x1
	// No FIFO error event on stream x
	DMA_LISR_FEIF0_NoError = 0x0
	// A FIFO error event occurred on stream x
	DMA_LISR_FEIF0_Error = 0x1

	// HISR: high interrupt status register
	// Position of TCIF7 field.
	DMA_HISR_TCIF7_Pos = 0x1b
	// Bit mask of TCIF7 field.
	DMA_HISR_TCIF7_Msk = 0x8000000
	// Bit TCIF7.
	DMA_HISR_TCIF7 = 0x8000000
	// No transfer complete event on stream x
	DMA_HISR_TCIF7_NotComplete = 0x0
	// A transfer complete event occurred on stream x
	DMA_HISR_TCIF7_Complete = 0x1
	// Position of HTIF7 field.
	DMA_HISR_HTIF7_Pos = 0x1a
	// Bit mask of HTIF7 field.
	DMA_HISR_HTIF7_Msk = 0x4000000
	// Bit HTIF7.
	DMA_HISR_HTIF7 = 0x4000000
	// No half transfer event on stream x
	DMA_HISR_HTIF7_NotHalf = 0x0
	// A half transfer event occurred on stream x
	DMA_HISR_HTIF7_Half = 0x1
	// Position of TEIF7 field.
	DMA_HISR_TEIF7_Pos = 0x19
	// Bit mask of TEIF7 field.
	DMA_HISR_TEIF7_Msk = 0x2000000
	// Bit TEIF7.
	DMA_HISR_TEIF7 = 0x2000000
	// No transfer error on stream x
	DMA_HISR_TEIF7_NoError = 0x0
	// A transfer error occurred on stream x
	DMA_HISR_TEIF7_Error = 0x1
	// Position of DMEIF7 field.
	DMA_HISR_DMEIF7_Pos = 0x18
	// Bit mask of DMEIF7 field.
	DMA_HISR_DMEIF7_Msk = 0x1000000
	// Bit DMEIF7.
	DMA_HISR_DMEIF7 = 0x1000000
	// No Direct Mode error on stream x
	DMA_HISR_DMEIF7_NoError = 0x0
	// A Direct Mode error occurred on stream x
	DMA_HISR_DMEIF7_Error = 0x1
	// Position of FEIF7 field.
	DMA_HISR_FEIF7_Pos = 0x16
	// Bit mask of FEIF7 field.
	DMA_HISR_FEIF7_Msk = 0x400000
	// Bit FEIF7.
	DMA_HISR_FEIF7 = 0x400000
	// No FIFO error event on stream x
	DMA_HISR_FEIF7_NoError = 0x0
	// A FIFO error event occurred on stream x
	DMA_HISR_FEIF7_Error = 0x1
	// Position of TCIF6 field.
	DMA_HISR_TCIF6_Pos = 0x15
	// Bit mask of TCIF6 field.
	DMA_HISR_TCIF6_Msk = 0x200000
	// Bit TCIF6.
	DMA_HISR_TCIF6 = 0x200000
	// No transfer complete event on stream x
	DMA_HISR_TCIF6_NotComplete = 0x0
	// A transfer complete event occurred on stream x
	DMA_HISR_TCIF6_Complete = 0x1
	// Position of HTIF6 field.
	DMA_HISR_HTIF6_Pos = 0x14
	// Bit mask of HTIF6 field.
	DMA_HISR_HTIF6_Msk = 0x100000
	// Bit HTIF6.
	DMA_HISR_HTIF6 = 0x100000
	// No half transfer event on stream x
	DMA_HISR_HTIF6_NotHalf = 0x0
	// A half transfer event occurred on stream x
	DMA_HISR_HTIF6_Half = 0x1
	// Position of TEIF6 field.
	DMA_HISR_TEIF6_Pos = 0x13
	// Bit mask of TEIF6 field.
	DMA_HISR_TEIF6_Msk = 0x80000
	// Bit TEIF6.
	DMA_HISR_TEIF6 = 0x80000
	// No transfer error on stream x
	DMA_HISR_TEIF6_NoError = 0x0
	// A transfer error occurred on stream x
	DMA_HISR_TEIF6_Error = 0x1
	// Position of DMEIF6 field.
	DMA_HISR_DMEIF6_Pos = 0x12
	// Bit mask of DMEIF6 field.
	DMA_HISR_DMEIF6_Msk = 0x40000
	// Bit DMEIF6.
	DMA_HISR_DMEIF6 = 0x40000
	// No Direct Mode error on stream x
	DMA_HISR_DMEIF6_NoError = 0x0
	// A Direct Mode error occurred on stream x
	DMA_HISR_DMEIF6_Error = 0x1
	// Position of FEIF6 field.
	DMA_HISR_FEIF6_Pos = 0x10
	// Bit mask of FEIF6 field.
	DMA_HISR_FEIF6_Msk = 0x10000
	// Bit FEIF6.
	DMA_HISR_FEIF6 = 0x10000
	// No FIFO error event on stream x
	DMA_HISR_FEIF6_NoError = 0x0
	// A FIFO error event occurred on stream x
	DMA_HISR_FEIF6_Error = 0x1
	// Position of TCIF5 field.
	DMA_HISR_TCIF5_Pos = 0xb
	// Bit mask of TCIF5 field.
	DMA_HISR_TCIF5_Msk = 0x800
	// Bit TCIF5.
	DMA_HISR_TCIF5 = 0x800
	// No transfer complete event on stream x
	DMA_HISR_TCIF5_NotComplete = 0x0
	// A transfer complete event occurred on stream x
	DMA_HISR_TCIF5_Complete = 0x1
	// Position of HTIF5 field.
	DMA_HISR_HTIF5_Pos = 0xa
	// Bit mask of HTIF5 field.
	DMA_HISR_HTIF5_Msk = 0x400
	// Bit HTIF5.
	DMA_HISR_HTIF5 = 0x400
	// No half transfer event on stream x
	DMA_HISR_HTIF5_NotHalf = 0x0
	// A half transfer event occurred on stream x
	DMA_HISR_HTIF5_Half = 0x1
	// Position of TEIF5 field.
	DMA_HISR_TEIF5_Pos = 0x9
	// Bit mask of TEIF5 field.
	DMA_HISR_TEIF5_Msk = 0x200
	// Bit TEIF5.
	DMA_HISR_TEIF5 = 0x200
	// No transfer error on stream x
	DMA_HISR_TEIF5_NoError = 0x0
	// A transfer error occurred on stream x
	DMA_HISR_TEIF5_Error = 0x1
	// Position of DMEIF5 field.
	DMA_HISR_DMEIF5_Pos = 0x8
	// Bit mask of DMEIF5 field.
	DMA_HISR_DMEIF5_Msk = 0x100
	// Bit DMEIF5.
	DMA_HISR_DMEIF5 = 0x100
	// No Direct Mode error on stream x
	DMA_HISR_DMEIF5_NoError = 0x0
	// A Direct Mode error occurred on stream x
	DMA_HISR_DMEIF5_Error = 0x1
	// Position of FEIF5 field.
	DMA_HISR_FEIF5_Pos = 0x6
	// Bit mask of FEIF5 field.
	DMA_HISR_FEIF5_Msk = 0x40
	// Bit FEIF5.
	DMA_HISR_FEIF5 = 0x40
	// No FIFO error event on stream x
	DMA_HISR_FEIF5_NoError = 0x0
	// A FIFO error event occurred on stream x
	DMA_HISR_FEIF5_Error = 0x1
	// Position of TCIF4 field.
	DMA_HISR_TCIF4_Pos = 0x5
	// Bit mask of TCIF4 field.
	DMA_HISR_TCIF4_Msk = 0x20
	// Bit TCIF4.
	DMA_HISR_TCIF4 = 0x20
	// No transfer complete event on stream x
	DMA_HISR_TCIF4_NotComplete = 0x0
	// A transfer complete event occurred on stream x
	DMA_HISR_TCIF4_Complete = 0x1
	// Position of HTIF4 field.
	DMA_HISR_HTIF4_Pos = 0x4
	// Bit mask of HTIF4 field.
	DMA_HISR_HTIF4_Msk = 0x10
	// Bit HTIF4.
	DMA_HISR_HTIF4 = 0x10
	// No half transfer event on stream x
	DMA_HISR_HTIF4_NotHalf = 0x0
	// A half transfer event occurred on stream x
	DMA_HISR_HTIF4_Half = 0x1
	// Position of TEIF4 field.
	DMA_HISR_TEIF4_Pos = 0x3
	// Bit mask of TEIF4 field.
	DMA_HISR_TEIF4_Msk = 0x8
	// Bit TEIF4.
	DMA_HISR_TEIF4 = 0x8
	// No transfer error on stream x
	DMA_HISR_TEIF4_NoError = 0x0
	// A transfer error occurred on stream x
	DMA_HISR_TEIF4_Error = 0x1
	// Position of DMEIF4 field.
	DMA_HISR_DMEIF4_Pos = 0x2
	// Bit mask of DMEIF4 field.
	DMA_HISR_DMEIF4_Msk = 0x4
	// Bit DMEIF4.
	DMA_HISR_DMEIF4 = 0x4
	// No Direct Mode error on stream x
	DMA_HISR_DMEIF4_NoError = 0x0
	// A Direct Mode error occurred on stream x
	DMA_HISR_DMEIF4_Error = 0x1
	// Position of FEIF4 field.
	DMA_HISR_FEIF4_Pos = 0x0
	// Bit mask of FEIF4 field.
	DMA_HISR_FEIF4_Msk = 0x1
	// Bit FEIF4.
	DMA_HISR_FEIF4 = 0x1
	// No FIFO error event on stream x
	DMA_HISR_FEIF4_NoError = 0x0
	// A FIFO error event occurred on stream x
	DMA_HISR_FEIF4_Error = 0x1

	// LIFCR: low interrupt flag clear register
	// Position of CTCIF3 field.
	DMA_LIFCR_CTCIF3_Pos = 0x1b
	// Bit mask of CTCIF3 field.
	DMA_LIFCR_CTCIF3_Msk = 0x8000000
	// Bit CTCIF3.
	DMA_LIFCR_CTCIF3 = 0x8000000
	// Clear the corresponding TCIFx flag
	DMA_LIFCR_CTCIF3_Clear = 0x1
	// Position of CHTIF3 field.
	DMA_LIFCR_CHTIF3_Pos = 0x1a
	// Bit mask of CHTIF3 field.
	DMA_LIFCR_CHTIF3_Msk = 0x4000000
	// Bit CHTIF3.
	DMA_LIFCR_CHTIF3 = 0x4000000
	// Clear the corresponding HTIFx flag
	DMA_LIFCR_CHTIF3_Clear = 0x1
	// Position of CTEIF3 field.
	DMA_LIFCR_CTEIF3_Pos = 0x19
	// Bit mask of CTEIF3 field.
	DMA_LIFCR_CTEIF3_Msk = 0x2000000
	// Bit CTEIF3.
	DMA_LIFCR_CTEIF3 = 0x2000000
	// Clear the corresponding TEIFx flag
	DMA_LIFCR_CTEIF3_Clear = 0x1
	// Position of CDMEIF3 field.
	DMA_LIFCR_CDMEIF3_Pos = 0x18
	// Bit mask of CDMEIF3 field.
	DMA_LIFCR_CDMEIF3_Msk = 0x1000000
	// Bit CDMEIF3.
	DMA_LIFCR_CDMEIF3 = 0x1000000
	// Clear the corresponding DMEIFx flag
	DMA_LIFCR_CDMEIF3_Clear = 0x1
	// Position of CFEIF3 field.
	DMA_LIFCR_CFEIF3_Pos = 0x16
	// Bit mask of CFEIF3 field.
	DMA_LIFCR_CFEIF3_Msk = 0x400000
	// Bit CFEIF3.
	DMA_LIFCR_CFEIF3 = 0x400000
	// Clear the corresponding CFEIFx flag
	DMA_LIFCR_CFEIF3_Clear = 0x1
	// Position of CTCIF2 field.
	DMA_LIFCR_CTCIF2_Pos = 0x15
	// Bit mask of CTCIF2 field.
	DMA_LIFCR_CTCIF2_Msk = 0x200000
	// Bit CTCIF2.
	DMA_LIFCR_CTCIF2 = 0x200000
	// Clear the corresponding TCIFx flag
	DMA_LIFCR_CTCIF2_Clear = 0x1
	// Position of CHTIF2 field.
	DMA_LIFCR_CHTIF2_Pos = 0x14
	// Bit mask of CHTIF2 field.
	DMA_LIFCR_CHTIF2_Msk = 0x100000
	// Bit CHTIF2.
	DMA_LIFCR_CHTIF2 = 0x100000
	// Clear the corresponding HTIFx flag
	DMA_LIFCR_CHTIF2_Clear = 0x1
	// Position of CTEIF2 field.
	DMA_LIFCR_CTEIF2_Pos = 0x13
	// Bit mask of CTEIF2 field.
	DMA_LIFCR_CTEIF2_Msk = 0x80000
	// Bit CTEIF2.
	DMA_LIFCR_CTEIF2 = 0x80000
	// Clear the corresponding TEIFx flag
	DMA_LIFCR_CTEIF2_Clear = 0x1
	// Position of CDMEIF2 field.
	DMA_LIFCR_CDMEIF2_Pos = 0x12
	// Bit mask of CDMEIF2 field.
	DMA_LIFCR_CDMEIF2_Msk = 0x40000
	// Bit CDMEIF2.
	DMA_LIFCR_CDMEIF2 = 0x40000
	// Clear the corresponding DMEIFx flag
	DMA_LIFCR_CDMEIF2_Clear = 0x1
	// Position of CFEIF2 field.
	DMA_LIFCR_CFEIF2_Pos = 0x10
	// Bit mask of CFEIF2 field.
	DMA_LIFCR_CFEIF2_Msk = 0x10000
	// Bit CFEIF2.
	DMA_LIFCR_CFEIF2 = 0x10000
	// Clear the corresponding CFEIFx flag
	DMA_LIFCR_CFEIF2_Clear = 0x1
	// Position of CTCIF1 field.
	DMA_LIFCR_CTCIF1_Pos = 0xb
	// Bit mask of CTCIF1 field.
	DMA_LIFCR_CTCIF1_Msk = 0x800
	// Bit CTCIF1.
	DMA_LIFCR_CTCIF1 = 0x800
	// Clear the corresponding TCIFx flag
	DMA_LIFCR_CTCIF1_Clear = 0x1
	// Position of CHTIF1 field.
	DMA_LIFCR_CHTIF1_Pos = 0xa
	// Bit mask of CHTIF1 field.
	DMA_LIFCR_CHTIF1_Msk = 0x400
	// Bit CHTIF1.
	DMA_LIFCR_CHTIF1 = 0x400
	// Clear the corresponding HTIFx flag
	DMA_LIFCR_CHTIF1_Clear = 0x1
	// Position of CTEIF1 field.
	DMA_LIFCR_CTEIF1_Pos = 0x9
	// Bit mask of CTEIF1 field.
	DMA_LIFCR_CTEIF1_Msk = 0x200
	// Bit CTEIF1.
	DMA_LIFCR_CTEIF1 = 0x200
	// Clear the corresponding TEIFx flag
	DMA_LIFCR_CTEIF1_Clear = 0x1
	// Position of CDMEIF1 field.
	DMA_LIFCR_CDMEIF1_Pos = 0x8
	// Bit mask of CDMEIF1 field.
	DMA_LIFCR_CDMEIF1_Msk = 0x100
	// Bit CDMEIF1.
	DMA_LIFCR_CDMEIF1 = 0x100
	// Clear the corresponding DMEIFx flag
	DMA_LIFCR_CDMEIF1_Clear = 0x1
	// Position of CFEIF1 field.
	DMA_LIFCR_CFEIF1_Pos = 0x6
	// Bit mask of CFEIF1 field.
	DMA_LIFCR_CFEIF1_Msk = 0x40
	// Bit CFEIF1.
	DMA_LIFCR_CFEIF1 = 0x40
	// Clear the corresponding CFEIFx flag
	DMA_LIFCR_CFEIF1_Clear = 0x1
	// Position of CTCIF0 field.
	DMA_LIFCR_CTCIF0_Pos = 0x5
	// Bit mask of CTCIF0 field.
	DMA_LIFCR_CTCIF0_Msk = 0x20
	// Bit CTCIF0.
	DMA_LIFCR_CTCIF0 = 0x20
	// Clear the corresponding TCIFx flag
	DMA_LIFCR_CTCIF0_Clear = 0x1
	// Position of CHTIF0 field.
	DMA_LIFCR_CHTIF0_Pos = 0x4
	// Bit mask of CHTIF0 field.
	DMA_LIFCR_CHTIF0_Msk = 0x10
	// Bit CHTIF0.
	DMA_LIFCR_CHTIF0 = 0x10
	// Clear the corresponding HTIFx flag
	DMA_LIFCR_CHTIF0_Clear = 0x1
	// Position of CTEIF0 field.
	DMA_LIFCR_CTEIF0_Pos = 0x3
	// Bit mask of CTEIF0 field.
	DMA_LIFCR_CTEIF0_Msk = 0x8
	// Bit CTEIF0.
	DMA_LIFCR_CTEIF0 = 0x8
	// Clear the corresponding TEIFx flag
	DMA_LIFCR_CTEIF0_Clear = 0x1
	// Position of CDMEIF0 field.
	DMA_LIFCR_CDMEIF0_Pos = 0x2
	// Bit mask of CDMEIF0 field.
	DMA_LIFCR_CDMEIF0_Msk = 0x4
	// Bit CDMEIF0.
	DMA_LIFCR_CDMEIF0 = 0x4
	// Clear the corresponding DMEIFx flag
	DMA_LIFCR_CDMEIF0_Clear = 0x1
	// Position of CFEIF0 field.
	DMA_LIFCR_CFEIF0_Pos = 0x0
	// Bit mask of CFEIF0 field.
	DMA_LIFCR_CFEIF0_Msk = 0x1
	// Bit CFEIF0.
	DMA_LIFCR_CFEIF0 = 0x1
	// Clear the corresponding CFEIFx flag
	DMA_LIFCR_CFEIF0_Clear = 0x1

	// HIFCR: high interrupt flag clear register
	// Position of CTCIF7 field.
	DMA_HIFCR_CTCIF7_Pos = 0x1b
	// Bit mask of CTCIF7 field.
	DMA_HIFCR_CTCIF7_Msk = 0x8000000
	// Bit CTCIF7.
	DMA_HIFCR_CTCIF7 = 0x8000000
	// Clear the corresponding TCIFx flag
	DMA_HIFCR_CTCIF7_Clear = 0x1
	// Position of CHTIF7 field.
	DMA_HIFCR_CHTIF7_Pos = 0x1a
	// Bit mask of CHTIF7 field.
	DMA_HIFCR_CHTIF7_Msk = 0x4000000
	// Bit CHTIF7.
	DMA_HIFCR_CHTIF7 = 0x4000000
	// Clear the corresponding HTIFx flag
	DMA_HIFCR_CHTIF7_Clear = 0x1
	// Position of CTEIF7 field.
	DMA_HIFCR_CTEIF7_Pos = 0x19
	// Bit mask of CTEIF7 field.
	DMA_HIFCR_CTEIF7_Msk = 0x2000000
	// Bit CTEIF7.
	DMA_HIFCR_CTEIF7 = 0x2000000
	// Clear the corresponding TEIFx flag
	DMA_HIFCR_CTEIF7_Clear = 0x1
	// Position of CDMEIF7 field.
	DMA_HIFCR_CDMEIF7_Pos = 0x18
	// Bit mask of CDMEIF7 field.
	DMA_HIFCR_CDMEIF7_Msk = 0x1000000
	// Bit CDMEIF7.
	DMA_HIFCR_CDMEIF7 = 0x1000000
	// Clear the corresponding DMEIFx flag
	DMA_HIFCR_CDMEIF7_Clear = 0x1
	// Position of CFEIF7 field.
	DMA_HIFCR_CFEIF7_Pos = 0x16
	// Bit mask of CFEIF7 field.
	DMA_HIFCR_CFEIF7_Msk = 0x400000
	// Bit CFEIF7.
	DMA_HIFCR_CFEIF7 = 0x400000
	// Clear the corresponding CFEIFx flag
	DMA_HIFCR_CFEIF7_Clear = 0x1
	// Position of CTCIF6 field.
	DMA_HIFCR_CTCIF6_Pos = 0x15
	// Bit mask of CTCIF6 field.
	DMA_HIFCR_CTCIF6_Msk = 0x200000
	// Bit CTCIF6.
	DMA_HIFCR_CTCIF6 = 0x200000
	// Clear the corresponding TCIFx flag
	DMA_HIFCR_CTCIF6_Clear = 0x1
	// Position of CHTIF6 field.
	DMA_HIFCR_CHTIF6_Pos = 0x14
	// Bit mask of CHTIF6 field.
	DMA_HIFCR_CHTIF6_Msk = 0x100000
	// Bit CHTIF6.
	DMA_HIFCR_CHTIF6 = 0x100000
	// Clear the corresponding HTIFx flag
	DMA_HIFCR_CHTIF6_Clear = 0x1
	// Position of CTEIF6 field.
	DMA_HIFCR_CTEIF6_Pos = 0x13
	// Bit mask of CTEIF6 field.
	DMA_HIFCR_CTEIF6_Msk = 0x80000
	// Bit CTEIF6.
	DMA_HIFCR_CTEIF6 = 0x80000
	// Clear the corresponding TEIFx flag
	DMA_HIFCR_CTEIF6_Clear = 0x1
	// Position of CDMEIF6 field.
	DMA_HIFCR_CDMEIF6_Pos = 0x12
	// Bit mask of CDMEIF6 field.
	DMA_HIFCR_CDMEIF6_Msk = 0x40000
	// Bit CDMEIF6.
	DMA_HIFCR_CDMEIF6 = 0x40000
	// Clear the corresponding DMEIFx flag
	DMA_HIFCR_CDMEIF6_Clear = 0x1
	// Position of CFEIF6 field.
	DMA_HIFCR_CFEIF6_Pos = 0x10
	// Bit mask of CFEIF6 field.
	DMA_HIFCR_CFEIF6_Msk = 0x10000
	// Bit CFEIF6.
	DMA_HIFCR_CFEIF6 = 0x10000
	// Clear the corresponding CFEIFx flag
	DMA_HIFCR_CFEIF6_Clear = 0x1
	// Position of CTCIF5 field.
	DMA_HIFCR_CTCIF5_Pos = 0xb
	// Bit mask of CTCIF5 field.
	DMA_HIFCR_CTCIF5_Msk = 0x800
	// Bit CTCIF5.
	DMA_HIFCR_CTCIF5 = 0x800
	// Clear the corresponding TCIFx flag
	DMA_HIFCR_CTCIF5_Clear = 0x1
	// Position of CHTIF5 field.
	DMA_HIFCR_CHTIF5_Pos = 0xa
	// Bit mask of CHTIF5 field.
	DMA_HIFCR_CHTIF5_Msk = 0x400
	// Bit CHTIF5.
	DMA_HIFCR_CHTIF5 = 0x400
	// Clear the corresponding HTIFx flag
	DMA_HIFCR_CHTIF5_Clear = 0x1
	// Position of CTEIF5 field.
	DMA_HIFCR_CTEIF5_Pos = 0x9
	// Bit mask of CTEIF5 field.
	DMA_HIFCR_CTEIF5_Msk = 0x200
	// Bit CTEIF5.
	DMA_HIFCR_CTEIF5 = 0x200
	// Clear the corresponding TEIFx flag
	DMA_HIFCR_CTEIF5_Clear = 0x1
	// Position of CDMEIF5 field.
	DMA_HIFCR_CDMEIF5_Pos = 0x8
	// Bit mask of CDMEIF5 field.
	DMA_HIFCR_CDMEIF5_Msk = 0x100
	// Bit CDMEIF5.
	DMA_HIFCR_CDMEIF5 = 0x100
	// Clear the corresponding DMEIFx flag
	DMA_HIFCR_CDMEIF5_Clear = 0x1
	// Position of CFEIF5 field.
	DMA_HIFCR_CFEIF5_Pos = 0x6
	// Bit mask of CFEIF5 field.
	DMA_HIFCR_CFEIF5_Msk = 0x40
	// Bit CFEIF5.
	DMA_HIFCR_CFEIF5 = 0x40
	// Clear the corresponding CFEIFx flag
	DMA_HIFCR_CFEIF5_Clear = 0x1
	// Position of CTCIF4 field.
	DMA_HIFCR_CTCIF4_Pos = 0x5
	// Bit mask of CTCIF4 field.
	DMA_HIFCR_CTCIF4_Msk = 0x20
	// Bit CTCIF4.
	DMA_HIFCR_CTCIF4 = 0x20
	// Clear the corresponding TCIFx flag
	DMA_HIFCR_CTCIF4_Clear = 0x1
	// Position of CHTIF4 field.
	DMA_HIFCR_CHTIF4_Pos = 0x4
	// Bit mask of CHTIF4 field.
	DMA_HIFCR_CHTIF4_Msk = 0x10
	// Bit CHTIF4.
	DMA_HIFCR_CHTIF4 = 0x10
	// Clear the corresponding HTIFx flag
	DMA_HIFCR_CHTIF4_Clear = 0x1
	// Position of CTEIF4 field.
	DMA_HIFCR_CTEIF4_Pos = 0x3
	// Bit mask of CTEIF4 field.
	DMA_HIFCR_CTEIF4_Msk = 0x8
	// Bit CTEIF4.
	DMA_HIFCR_CTEIF4 = 0x8
	// Clear the corresponding TEIFx flag
	DMA_HIFCR_CTEIF4_Clear = 0x1
	// Position of CDMEIF4 field.
	DMA_HIFCR_CDMEIF4_Pos = 0x2
	// Bit mask of CDMEIF4 field.
	DMA_HIFCR_CDMEIF4_Msk = 0x4
	// Bit CDMEIF4.
	DMA_HIFCR_CDMEIF4 = 0x4
	// Clear the corresponding DMEIFx flag
	DMA_HIFCR_CDMEIF4_Clear = 0x1
	// Position of CFEIF4 field.
	DMA_HIFCR_CFEIF4_Pos = 0x0
	// Bit mask of CFEIF4 field.
	DMA_HIFCR_CFEIF4_Msk = 0x1
	// Bit CFEIF4.
	DMA_HIFCR_CFEIF4 = 0x1
	// Clear the corresponding CFEIFx flag
	DMA_HIFCR_CFEIF4_Clear = 0x1

	// ST.CR: stream x configuration register
	// Position of CHSEL field.
	DMA_ST_CR_CHSEL_Pos = 0x19
	// Bit mask of CHSEL field.
	DMA_ST_CR_CHSEL_Msk = 0x1e000000
	// Position of MBURST field.
	DMA_ST_CR_MBURST_Pos = 0x17
	// Bit mask of MBURST field.
	DMA_ST_CR_MBURST_Msk = 0x1800000
	// Single transfer
	DMA_ST_CR_MBURST_Single = 0x0
	// Incremental burst of 4 beats
	DMA_ST_CR_MBURST_INCR4 = 0x1
	// Incremental burst of 8 beats
	DMA_ST_CR_MBURST_INCR8 = 0x2
	// Incremental burst of 16 beats
	DMA_ST_CR_MBURST_INCR16 = 0x3
	// Position of PBURST field.
	DMA_ST_CR_PBURST_Pos = 0x15
	// Bit mask of PBURST field.
	DMA_ST_CR_PBURST_Msk = 0x600000
	// Single transfer
	DMA_ST_CR_PBURST_Single = 0x0
	// Incremental burst of 4 beats
	DMA_ST_CR_PBURST_INCR4 = 0x1
	// Incremental burst of 8 beats
	DMA_ST_CR_PBURST_INCR8 = 0x2
	// Incremental burst of 16 beats
	DMA_ST_CR_PBURST_INCR16 = 0x3
	// Position of CT field.
	DMA_ST_CR_CT_Pos = 0x13
	// Bit mask of CT field.
	DMA_ST_CR_CT_Msk = 0x80000
	// Bit CT.
	DMA_ST_CR_CT = 0x80000
	// The current target memory is Memory 0
	DMA_ST_CR_CT_Memory0 = 0x0
	// The current target memory is Memory 1
	DMA_ST_CR_CT_Memory1 = 0x1
	// Position of DBM field.
	DMA_ST_CR_DBM_Pos = 0x12
	// Bit mask of DBM field.
	DMA_ST_CR_DBM_Msk = 0x40000
	// Bit DBM.
	DMA_ST_CR_DBM = 0x40000
	// No buffer switching at the end of transfer
	DMA_ST_CR_DBM_Disabled = 0x0
	// Memory target switched at the end of the DMA transfer
	DMA_ST_CR_DBM_Enabled = 0x1
	// Position of PL field.
	DMA_ST_CR_PL_Pos = 0x10
	// Bit mask of PL field.
	DMA_ST_CR_PL_Msk = 0x30000
	// Low
	DMA_ST_CR_PL_Low = 0x0
	// Medium
	DMA_ST_CR_PL_Medium = 0x1
	// High
	DMA_ST_CR_PL_High = 0x2
	// Very high
	DMA_ST_CR_PL_VeryHigh = 0x3
	// Position of PINCOS field.
	DMA_ST_CR_PINCOS_Pos = 0xf
	// Bit mask of PINCOS field.
	DMA_ST_CR_PINCOS_Msk = 0x8000
	// Bit PINCOS.
	DMA_ST_CR_PINCOS = 0x8000
	// The offset size for the peripheral address calculation is linked to the PSIZE
	DMA_ST_CR_PINCOS_PSIZE = 0x0
	// The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment)
	DMA_ST_CR_PINCOS_Fixed4 = 0x1
	// Position of MSIZE field.
	DMA_ST_CR_MSIZE_Pos = 0xd
	// Bit mask of MSIZE field.
	DMA_ST_CR_MSIZE_Msk = 0x6000
	// Byte (8-bit)
	DMA_ST_CR_MSIZE_Bits8 = 0x0
	// Half-word (16-bit)
	DMA_ST_CR_MSIZE_Bits16 = 0x1
	// Word (32-bit)
	DMA_ST_CR_MSIZE_Bits32 = 0x2
	// Position of PSIZE field.
	DMA_ST_CR_PSIZE_Pos = 0xb
	// Bit mask of PSIZE field.
	DMA_ST_CR_PSIZE_Msk = 0x1800
	// Byte (8-bit)
	DMA_ST_CR_PSIZE_Bits8 = 0x0
	// Half-word (16-bit)
	DMA_ST_CR_PSIZE_Bits16 = 0x1
	// Word (32-bit)
	DMA_ST_CR_PSIZE_Bits32 = 0x2
	// Position of MINC field.
	DMA_ST_CR_MINC_Pos = 0xa
	// Bit mask of MINC field.
	DMA_ST_CR_MINC_Msk = 0x400
	// Bit MINC.
	DMA_ST_CR_MINC = 0x400
	// Address pointer is fixed
	DMA_ST_CR_MINC_Fixed = 0x0
	// Address pointer is incremented after each data transfer
	DMA_ST_CR_MINC_Incremented = 0x1
	// Position of PINC field.
	DMA_ST_CR_PINC_Pos = 0x9
	// Bit mask of PINC field.
	DMA_ST_CR_PINC_Msk = 0x200
	// Bit PINC.
	DMA_ST_CR_PINC = 0x200
	// Address pointer is fixed
	DMA_ST_CR_PINC_Fixed = 0x0
	// Address pointer is incremented after each data transfer
	DMA_ST_CR_PINC_Incremented = 0x1
	// Position of CIRC field.
	DMA_ST_CR_CIRC_Pos = 0x8
	// Bit mask of CIRC field.
	DMA_ST_CR_CIRC_Msk = 0x100
	// Bit CIRC.
	DMA_ST_CR_CIRC = 0x100
	// Circular mode disabled
	DMA_ST_CR_CIRC_Disabled = 0x0
	// Circular mode enabled
	DMA_ST_CR_CIRC_Enabled = 0x1
	// Position of DIR field.
	DMA_ST_CR_DIR_Pos = 0x6
	// Bit mask of DIR field.
	DMA_ST_CR_DIR_Msk = 0xc0
	// Peripheral-to-memory
	DMA_ST_CR_DIR_PeripheralToMemory = 0x0
	// Memory-to-peripheral
	DMA_ST_CR_DIR_MemoryToPeripheral = 0x1
	// Memory-to-memory
	DMA_ST_CR_DIR_MemoryToMemory = 0x2
	// Position of PFCTRL field.
	DMA_ST_CR_PFCTRL_Pos = 0x5
	// Bit mask of PFCTRL field.
	DMA_ST_CR_PFCTRL_Msk = 0x20
	// Bit PFCTRL.
	DMA_ST_CR_PFCTRL = 0x20
	// The DMA is the flow controller
	DMA_ST_CR_PFCTRL_DMA = 0x0
	// The peripheral is the flow controller
	DMA_ST_CR_PFCTRL_Peripheral = 0x1
	// Position of TCIE field.
	DMA_ST_CR_TCIE_Pos = 0x4
	// Bit mask of TCIE field.
	DMA_ST_CR_TCIE_Msk = 0x10
	// Bit TCIE.
	DMA_ST_CR_TCIE = 0x10
	// TC interrupt disabled
	DMA_ST_CR_TCIE_Disabled = 0x0
	// TC interrupt enabled
	DMA_ST_CR_TCIE_Enabled = 0x1
	// Position of HTIE field.
	DMA_ST_CR_HTIE_Pos = 0x3
	// Bit mask of HTIE field.
	DMA_ST_CR_HTIE_Msk = 0x8
	// Bit HTIE.
	DMA_ST_CR_HTIE = 0x8
	// HT interrupt disabled
	DMA_ST_CR_HTIE_Disabled = 0x0
	// HT interrupt enabled
	DMA_ST_CR_HTIE_Enabled = 0x1
	// Position of TEIE field.
	DMA_ST_CR_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	DMA_ST_CR_TEIE_Msk = 0x4
	// Bit TEIE.
	DMA_ST_CR_TEIE = 0x4
	// TE interrupt disabled
	DMA_ST_CR_TEIE_Disabled = 0x0
	// TE interrupt enabled
	DMA_ST_CR_TEIE_Enabled = 0x1
	// Position of DMEIE field.
	DMA_ST_CR_DMEIE_Pos = 0x1
	// Bit mask of DMEIE field.
	DMA_ST_CR_DMEIE_Msk = 0x2
	// Bit DMEIE.
	DMA_ST_CR_DMEIE = 0x2
	// DME interrupt disabled
	DMA_ST_CR_DMEIE_Disabled = 0x0
	// DME interrupt enabled
	DMA_ST_CR_DMEIE_Enabled = 0x1
	// Position of EN field.
	DMA_ST_CR_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA_ST_CR_EN_Msk = 0x1
	// Bit EN.
	DMA_ST_CR_EN = 0x1
	// Stream disabled
	DMA_ST_CR_EN_Disabled = 0x0
	// Stream enabled
	DMA_ST_CR_EN_Enabled = 0x1

	// ST.NDTR: stream x number of data register
	// Position of NDT field.
	DMA_ST_NDTR_NDT_Pos = 0x0
	// Bit mask of NDT field.
	DMA_ST_NDTR_NDT_Msk = 0xffff

	// ST.PAR: stream x peripheral address register
	// Position of PA field.
	DMA_ST_PAR_PA_Pos = 0x0
	// Bit mask of PA field.
	DMA_ST_PAR_PA_Msk = 0xffffffff

	// ST.M0AR: stream x memory 0 address register
	// Position of M0A field.
	DMA_ST_M0AR_M0A_Pos = 0x0
	// Bit mask of M0A field.
	DMA_ST_M0AR_M0A_Msk = 0xffffffff

	// ST.M1AR: stream x memory 1 address register
	// Position of M1A field.
	DMA_ST_M1AR_M1A_Pos = 0x0
	// Bit mask of M1A field.
	DMA_ST_M1AR_M1A_Msk = 0xffffffff

	// ST.FCR: stream x FIFO control register
	// Position of FEIE field.
	DMA_ST_FCR_FEIE_Pos = 0x7
	// Bit mask of FEIE field.
	DMA_ST_FCR_FEIE_Msk = 0x80
	// Bit FEIE.
	DMA_ST_FCR_FEIE = 0x80
	// FE interrupt disabled
	DMA_ST_FCR_FEIE_Disabled = 0x0
	// FE interrupt enabled
	DMA_ST_FCR_FEIE_Enabled = 0x1
	// Position of FS field.
	DMA_ST_FCR_FS_Pos = 0x3
	// Bit mask of FS field.
	DMA_ST_FCR_FS_Msk = 0x38
	// 0 < fifo_level < 1/4
	DMA_ST_FCR_FS_Quarter1 = 0x0
	// 1/4 <= fifo_level < 1/2
	DMA_ST_FCR_FS_Quarter2 = 0x1
	// 1/2 <= fifo_level < 3/4
	DMA_ST_FCR_FS_Quarter3 = 0x2
	// 3/4 <= fifo_level < full
	DMA_ST_FCR_FS_Quarter4 = 0x3
	// FIFO is empty
	DMA_ST_FCR_FS_Empty = 0x4
	// FIFO is full
	DMA_ST_FCR_FS_Full = 0x5
	// Position of DMDIS field.
	DMA_ST_FCR_DMDIS_Pos = 0x2
	// Bit mask of DMDIS field.
	DMA_ST_FCR_DMDIS_Msk = 0x4
	// Bit DMDIS.
	DMA_ST_FCR_DMDIS = 0x4
	// Direct mode is enabled
	DMA_ST_FCR_DMDIS_Enabled = 0x0
	// Direct mode is disabled
	DMA_ST_FCR_DMDIS_Disabled = 0x1
	// Position of FTH field.
	DMA_ST_FCR_FTH_Pos = 0x0
	// Bit mask of FTH field.
	DMA_ST_FCR_FTH_Msk = 0x3
	// 1/4 full FIFO
	DMA_ST_FCR_FTH_Quarter = 0x0
	// 1/2 full FIFO
	DMA_ST_FCR_FTH_Half = 0x1
	// 3/4 full FIFO
	DMA_ST_FCR_FTH_ThreeQuarters = 0x2
	// Full FIFO
	DMA_ST_FCR_FTH_Full = 0x3
)

// Constants for RCC: Reset and clock control
const (
	// CR: clock control register
	// Position of PLLI2SRDY field.
	RCC_CR_PLLI2SRDY_Pos = 0x1b
	// Bit mask of PLLI2SRDY field.
	RCC_CR_PLLI2SRDY_Msk = 0x8000000
	// Bit PLLI2SRDY.
	RCC_CR_PLLI2SRDY = 0x8000000
	// Clock not ready
	RCC_CR_PLLI2SRDY_NotReady = 0x0
	// Clock ready
	RCC_CR_PLLI2SRDY_Ready = 0x1
	// Position of PLLI2SON field.
	RCC_CR_PLLI2SON_Pos = 0x1a
	// Bit mask of PLLI2SON field.
	RCC_CR_PLLI2SON_Msk = 0x4000000
	// Bit PLLI2SON.
	RCC_CR_PLLI2SON = 0x4000000
	// Clock Off
	RCC_CR_PLLI2SON_Off = 0x0
	// Clock On
	RCC_CR_PLLI2SON_On = 0x1
	// Position of PLLRDY field.
	RCC_CR_PLLRDY_Pos = 0x19
	// Bit mask of PLLRDY field.
	RCC_CR_PLLRDY_Msk = 0x2000000
	// Bit PLLRDY.
	RCC_CR_PLLRDY = 0x2000000
	// Clock not ready
	RCC_CR_PLLRDY_NotReady = 0x0
	// Clock ready
	RCC_CR_PLLRDY_Ready = 0x1
	// Position of PLLON field.
	RCC_CR_PLLON_Pos = 0x18
	// Bit mask of PLLON field.
	RCC_CR_PLLON_Msk = 0x1000000
	// Bit PLLON.
	RCC_CR_PLLON = 0x1000000
	// Clock Off
	RCC_CR_PLLON_Off = 0x0
	// Clock On
	RCC_CR_PLLON_On = 0x1
	// Position of CSSON field.
	RCC_CR_CSSON_Pos = 0x13
	// Bit mask of CSSON field.
	RCC_CR_CSSON_Msk = 0x80000
	// Bit CSSON.
	RCC_CR_CSSON = 0x80000
	// Clock security system disabled (clock detector OFF)
	RCC_CR_CSSON_Off = 0x0
	// Clock security system enable (clock detector ON if the HSE is ready, OFF if not)
	RCC_CR_CSSON_On = 0x1
	// Position of HSEBYP field.
	RCC_CR_HSEBYP_Pos = 0x12
	// Bit mask of HSEBYP field.
	RCC_CR_HSEBYP_Msk = 0x40000
	// Bit HSEBYP.
	RCC_CR_HSEBYP = 0x40000
	// HSE crystal oscillator not bypassed
	RCC_CR_HSEBYP_NotBypassed = 0x0
	// HSE crystal oscillator bypassed with external clock
	RCC_CR_HSEBYP_Bypassed = 0x1
	// Position of HSERDY field.
	RCC_CR_HSERDY_Pos = 0x11
	// Bit mask of HSERDY field.
	RCC_CR_HSERDY_Msk = 0x20000
	// Bit HSERDY.
	RCC_CR_HSERDY = 0x20000
	// Clock not ready
	RCC_CR_HSERDY_NotReady = 0x0
	// Clock ready
	RCC_CR_HSERDY_Ready = 0x1
	// Position of HSEON field.
	RCC_CR_HSEON_Pos = 0x10
	// Bit mask of HSEON field.
	RCC_CR_HSEON_Msk = 0x10000
	// Bit HSEON.
	RCC_CR_HSEON = 0x10000
	// Clock Off
	RCC_CR_HSEON_Off = 0x0
	// Clock On
	RCC_CR_HSEON_On = 0x1
	// Position of HSICAL field.
	RCC_CR_HSICAL_Pos = 0x8
	// Bit mask of HSICAL field.
	RCC_CR_HSICAL_Msk = 0xff00
	// Position of HSITRIM field.
	RCC_CR_HSITRIM_Pos = 0x3
	// Bit mask of HSITRIM field.
	RCC_CR_HSITRIM_Msk = 0xf8
	// Position of HSIRDY field.
	RCC_CR_HSIRDY_Pos = 0x1
	// Bit mask of HSIRDY field.
	RCC_CR_HSIRDY_Msk = 0x2
	// Bit HSIRDY.
	RCC_CR_HSIRDY = 0x2
	// Clock not ready
	RCC_CR_HSIRDY_NotReady = 0x0
	// Clock ready
	RCC_CR_HSIRDY_Ready = 0x1
	// Position of HSION field.
	RCC_CR_HSION_Pos = 0x0
	// Bit mask of HSION field.
	RCC_CR_HSION_Msk = 0x1
	// Bit HSION.
	RCC_CR_HSION = 0x1
	// Clock Off
	RCC_CR_HSION_Off = 0x0
	// Clock On
	RCC_CR_HSION_On = 0x1
	// Position of PLLSAIRDY field.
	RCC_CR_PLLSAIRDY_Pos = 0x1d
	// Bit mask of PLLSAIRDY field.
	RCC_CR_PLLSAIRDY_Msk = 0x20000000
	// Bit PLLSAIRDY.
	RCC_CR_PLLSAIRDY = 0x20000000
	// Clock not ready
	RCC_CR_PLLSAIRDY_NotReady = 0x0
	// Clock ready
	RCC_CR_PLLSAIRDY_Ready = 0x1
	// Position of PLLSAION field.
	RCC_CR_PLLSAION_Pos = 0x1c
	// Bit mask of PLLSAION field.
	RCC_CR_PLLSAION_Msk = 0x10000000
	// Bit PLLSAION.
	RCC_CR_PLLSAION = 0x10000000
	// Clock Off
	RCC_CR_PLLSAION_Off = 0x0
	// Clock On
	RCC_CR_PLLSAION_On = 0x1

	// PLLCFGR: PLL configuration register
	// Position of PLLSRC field.
	RCC_PLLCFGR_PLLSRC_Pos = 0x16
	// Bit mask of PLLSRC field.
	RCC_PLLCFGR_PLLSRC_Msk = 0x400000
	// Bit PLLSRC.
	RCC_PLLCFGR_PLLSRC = 0x400000
	// HSI clock selected as PLL and PLLI2S clock entry
	RCC_PLLCFGR_PLLSRC_HSI = 0x0
	// HSE oscillator clock selected as PLL and PLLI2S clock entry
	RCC_PLLCFGR_PLLSRC_HSE = 0x1
	// Position of PLLR field.
	RCC_PLLCFGR_PLLR_Pos = 0x1c
	// Bit mask of PLLR field.
	RCC_PLLCFGR_PLLR_Msk = 0x70000000
	// Position of PLLM field.
	RCC_PLLCFGR_PLLM_Pos = 0x0
	// Bit mask of PLLM field.
	RCC_PLLCFGR_PLLM_Msk = 0x3f
	// Position of PLLN field.
	RCC_PLLCFGR_PLLN_Pos = 0x6
	// Bit mask of PLLN field.
	RCC_PLLCFGR_PLLN_Msk = 0x7fc0
	// Position of PLLP field.
	RCC_PLLCFGR_PLLP_Pos = 0x10
	// Bit mask of PLLP field.
	RCC_PLLCFGR_PLLP_Msk = 0x30000
	// PLLP=2
	RCC_PLLCFGR_PLLP_Div2 = 0x0
	// PLLP=4
	RCC_PLLCFGR_PLLP_Div4 = 0x1
	// PLLP=6
	RCC_PLLCFGR_PLLP_Div6 = 0x2
	// PLLP=8
	RCC_PLLCFGR_PLLP_Div8 = 0x3
	// Position of PLLQ field.
	RCC_PLLCFGR_PLLQ_Pos = 0x18
	// Bit mask of PLLQ field.
	RCC_PLLCFGR_PLLQ_Msk = 0xf000000

	// CFGR: clock configuration register
	// Position of MCO2 field.
	RCC_CFGR_MCO2_Pos = 0x1e
	// Bit mask of MCO2 field.
	RCC_CFGR_MCO2_Msk = 0xc0000000
	// System clock (SYSCLK) selected
	RCC_CFGR_MCO2_SYSCLK = 0x0
	// PLLI2S clock selected
	RCC_CFGR_MCO2_PLLI2S = 0x1
	// HSE oscillator clock selected
	RCC_CFGR_MCO2_HSE = 0x2
	// PLL clock selected
	RCC_CFGR_MCO2_PLL = 0x3
	// Position of MCO2PRE field.
	RCC_CFGR_MCO2PRE_Pos = 0x1b
	// Bit mask of MCO2PRE field.
	RCC_CFGR_MCO2PRE_Msk = 0x38000000
	// No division
	RCC_CFGR_MCO2PRE_Div1 = 0x0
	// Division by 2
	RCC_CFGR_MCO2PRE_Div2 = 0x4
	// Division by 3
	RCC_CFGR_MCO2PRE_Div3 = 0x5
	// Division by 4
	RCC_CFGR_MCO2PRE_Div4 = 0x6
	// Division by 5
	RCC_CFGR_MCO2PRE_Div5 = 0x7
	// Position of MCO1PRE field.
	RCC_CFGR_MCO1PRE_Pos = 0x18
	// Bit mask of MCO1PRE field.
	RCC_CFGR_MCO1PRE_Msk = 0x7000000
	// No division
	RCC_CFGR_MCO1PRE_Div1 = 0x0
	// Division by 2
	RCC_CFGR_MCO1PRE_Div2 = 0x4
	// Division by 3
	RCC_CFGR_MCO1PRE_Div3 = 0x5
	// Division by 4
	RCC_CFGR_MCO1PRE_Div4 = 0x6
	// Division by 5
	RCC_CFGR_MCO1PRE_Div5 = 0x7
	// Position of I2SSRC field.
	RCC_CFGR_I2SSRC_Pos = 0x17
	// Bit mask of I2SSRC field.
	RCC_CFGR_I2SSRC_Msk = 0x800000
	// Bit I2SSRC.
	RCC_CFGR_I2SSRC = 0x800000
	// PLLI2S clock used as I2S clock source
	RCC_CFGR_I2SSRC_PLLI2S = 0x0
	// External clock mapped on the I2S_CKIN pin used as I2S clock source
	RCC_CFGR_I2SSRC_CKIN = 0x1
	// Position of MCO1 field.
	RCC_CFGR_MCO1_Pos = 0x15
	// Bit mask of MCO1 field.
	RCC_CFGR_MCO1_Msk = 0x600000
	// HSI clock selected
	RCC_CFGR_MCO1_HSI = 0x0
	// LSE oscillator selected
	RCC_CFGR_MCO1_LSE = 0x1
	// HSE oscillator clock selected
	RCC_CFGR_MCO1_HSE = 0x2
	// PLL clock selected
	RCC_CFGR_MCO1_PLL = 0x3
	// Position of RTCPRE field.
	RCC_CFGR_RTCPRE_Pos = 0x10
	// Bit mask of RTCPRE field.
	RCC_CFGR_RTCPRE_Msk = 0x1f0000
	// Position of PPRE2 field.
	RCC_CFGR_PPRE2_Pos = 0xd
	// Bit mask of PPRE2 field.
	RCC_CFGR_PPRE2_Msk = 0xe000
	// HCLK not divided
	RCC_CFGR_PPRE2_Div1 = 0x0
	// HCLK divided by 2
	RCC_CFGR_PPRE2_Div2 = 0x4
	// HCLK divided by 4
	RCC_CFGR_PPRE2_Div4 = 0x5
	// HCLK divided by 8
	RCC_CFGR_PPRE2_Div8 = 0x6
	// HCLK divided by 16
	RCC_CFGR_PPRE2_Div16 = 0x7
	// Position of PPRE1 field.
	RCC_CFGR_PPRE1_Pos = 0xa
	// Bit mask of PPRE1 field.
	RCC_CFGR_PPRE1_Msk = 0x1c00
	// HCLK not divided
	RCC_CFGR_PPRE1_Div1 = 0x0
	// HCLK divided by 2
	RCC_CFGR_PPRE1_Div2 = 0x4
	// HCLK divided by 4
	RCC_CFGR_PPRE1_Div4 = 0x5
	// HCLK divided by 8
	RCC_CFGR_PPRE1_Div8 = 0x6
	// HCLK divided by 16
	RCC_CFGR_PPRE1_Div16 = 0x7
	// Position of HPRE field.
	RCC_CFGR_HPRE_Pos = 0x4
	// Bit mask of HPRE field.
	RCC_CFGR_HPRE_Msk = 0xf0
	// SYSCLK not divided
	RCC_CFGR_HPRE_Div1 = 0x0
	// SYSCLK divided by 2
	RCC_CFGR_HPRE_Div2 = 0x8
	// SYSCLK divided by 4
	RCC_CFGR_HPRE_Div4 = 0x9
	// SYSCLK divided by 8
	RCC_CFGR_HPRE_Div8 = 0xa
	// SYSCLK divided by 16
	RCC_CFGR_HPRE_Div16 = 0xb
	// SYSCLK divided by 64
	RCC_CFGR_HPRE_Div64 = 0xc
	// SYSCLK divided by 128
	RCC_CFGR_HPRE_Div128 = 0xd
	// SYSCLK divided by 256
	RCC_CFGR_HPRE_Div256 = 0xe
	// SYSCLK divided by 512
	RCC_CFGR_HPRE_Div512 = 0xf
	// Position of SW field.
	RCC_CFGR_SW_Pos = 0x0
	// Bit mask of SW field.
	RCC_CFGR_SW_Msk = 0x3
	// HSI selected as system clock
	RCC_CFGR_SW_HSI = 0x0
	// HSE selected as system clock
	RCC_CFGR_SW_HSE = 0x1
	// PLL selected as system clock
	RCC_CFGR_SW_PLL = 0x2
	// Position of SWS field.
	RCC_CFGR_SWS_Pos = 0x2
	// Bit mask of SWS field.
	RCC_CFGR_SWS_Msk = 0xc
	// HSI oscillator used as system clock
	RCC_CFGR_SWS_HSI = 0x0
	// HSE oscillator used as system clock
	RCC_CFGR_SWS_HSE = 0x1
	// PLL used as system clock
	RCC_CFGR_SWS_PLL = 0x2

	// CIR: clock interrupt register
	// Position of CSSC field.
	RCC_CIR_CSSC_Pos = 0x17
	// Bit mask of CSSC field.
	RCC_CIR_CSSC_Msk = 0x800000
	// Bit CSSC.
	RCC_CIR_CSSC = 0x800000
	// Clear CSSF flag
	RCC_CIR_CSSC_Clear = 0x1
	// Position of PLLSAIRDYC field.
	RCC_CIR_PLLSAIRDYC_Pos = 0x16
	// Bit mask of PLLSAIRDYC field.
	RCC_CIR_PLLSAIRDYC_Msk = 0x400000
	// Bit PLLSAIRDYC.
	RCC_CIR_PLLSAIRDYC = 0x400000
	// Clear interrupt flag
	RCC_CIR_PLLSAIRDYC_Clear = 0x1
	// Position of PLLI2SRDYC field.
	RCC_CIR_PLLI2SRDYC_Pos = 0x15
	// Bit mask of PLLI2SRDYC field.
	RCC_CIR_PLLI2SRDYC_Msk = 0x200000
	// Bit PLLI2SRDYC.
	RCC_CIR_PLLI2SRDYC = 0x200000
	// Clear interrupt flag
	RCC_CIR_PLLI2SRDYC_Clear = 0x1
	// Position of PLLRDYC field.
	RCC_CIR_PLLRDYC_Pos = 0x14
	// Bit mask of PLLRDYC field.
	RCC_CIR_PLLRDYC_Msk = 0x100000
	// Bit PLLRDYC.
	RCC_CIR_PLLRDYC = 0x100000
	// Clear interrupt flag
	RCC_CIR_PLLRDYC_Clear = 0x1
	// Position of HSERDYC field.
	RCC_CIR_HSERDYC_Pos = 0x13
	// Bit mask of HSERDYC field.
	RCC_CIR_HSERDYC_Msk = 0x80000
	// Bit HSERDYC.
	RCC_CIR_HSERDYC = 0x80000
	// Clear interrupt flag
	RCC_CIR_HSERDYC_Clear = 0x1
	// Position of HSIRDYC field.
	RCC_CIR_HSIRDYC_Pos = 0x12
	// Bit mask of HSIRDYC field.
	RCC_CIR_HSIRDYC_Msk = 0x40000
	// Bit HSIRDYC.
	RCC_CIR_HSIRDYC = 0x40000
	// Clear interrupt flag
	RCC_CIR_HSIRDYC_Clear = 0x1
	// Position of LSERDYC field.
	RCC_CIR_LSERDYC_Pos = 0x11
	// Bit mask of LSERDYC field.
	RCC_CIR_LSERDYC_Msk = 0x20000
	// Bit LSERDYC.
	RCC_CIR_LSERDYC = 0x20000
	// Clear interrupt flag
	RCC_CIR_LSERDYC_Clear = 0x1
	// Position of LSIRDYC field.
	RCC_CIR_LSIRDYC_Pos = 0x10
	// Bit mask of LSIRDYC field.
	RCC_CIR_LSIRDYC_Msk = 0x10000
	// Bit LSIRDYC.
	RCC_CIR_LSIRDYC = 0x10000
	// Clear interrupt flag
	RCC_CIR_LSIRDYC_Clear = 0x1
	// Position of PLLSAIRDYIE field.
	RCC_CIR_PLLSAIRDYIE_Pos = 0xe
	// Bit mask of PLLSAIRDYIE field.
	RCC_CIR_PLLSAIRDYIE_Msk = 0x4000
	// Bit PLLSAIRDYIE.
	RCC_CIR_PLLSAIRDYIE = 0x4000
	// Interrupt disabled
	RCC_CIR_PLLSAIRDYIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIR_PLLSAIRDYIE_Enabled = 0x1
	// Position of PLLI2SRDYIE field.
	RCC_CIR_PLLI2SRDYIE_Pos = 0xd
	// Bit mask of PLLI2SRDYIE field.
	RCC_CIR_PLLI2SRDYIE_Msk = 0x2000
	// Bit PLLI2SRDYIE.
	RCC_CIR_PLLI2SRDYIE = 0x2000
	// Interrupt disabled
	RCC_CIR_PLLI2SRDYIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIR_PLLI2SRDYIE_Enabled = 0x1
	// Position of PLLRDYIE field.
	RCC_CIR_PLLRDYIE_Pos = 0xc
	// Bit mask of PLLRDYIE field.
	RCC_CIR_PLLRDYIE_Msk = 0x1000
	// Bit PLLRDYIE.
	RCC_CIR_PLLRDYIE = 0x1000
	// Interrupt disabled
	RCC_CIR_PLLRDYIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIR_PLLRDYIE_Enabled = 0x1
	// Position of HSERDYIE field.
	RCC_CIR_HSERDYIE_Pos = 0xb
	// Bit mask of HSERDYIE field.
	RCC_CIR_HSERDYIE_Msk = 0x800
	// Bit HSERDYIE.
	RCC_CIR_HSERDYIE = 0x800
	// Interrupt disabled
	RCC_CIR_HSERDYIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIR_HSERDYIE_Enabled = 0x1
	// Position of HSIRDYIE field.
	RCC_CIR_HSIRDYIE_Pos = 0xa
	// Bit mask of HSIRDYIE field.
	RCC_CIR_HSIRDYIE_Msk = 0x400
	// Bit HSIRDYIE.
	RCC_CIR_HSIRDYIE = 0x400
	// Interrupt disabled
	RCC_CIR_HSIRDYIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIR_HSIRDYIE_Enabled = 0x1
	// Position of LSERDYIE field.
	RCC_CIR_LSERDYIE_Pos = 0x9
	// Bit mask of LSERDYIE field.
	RCC_CIR_LSERDYIE_Msk = 0x200
	// Bit LSERDYIE.
	RCC_CIR_LSERDYIE = 0x200
	// Interrupt disabled
	RCC_CIR_LSERDYIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIR_LSERDYIE_Enabled = 0x1
	// Position of LSIRDYIE field.
	RCC_CIR_LSIRDYIE_Pos = 0x8
	// Bit mask of LSIRDYIE field.
	RCC_CIR_LSIRDYIE_Msk = 0x100
	// Bit LSIRDYIE.
	RCC_CIR_LSIRDYIE = 0x100
	// Interrupt disabled
	RCC_CIR_LSIRDYIE_Disabled = 0x0
	// Interrupt enabled
	RCC_CIR_LSIRDYIE_Enabled = 0x1
	// Position of CSSF field.
	RCC_CIR_CSSF_Pos = 0x7
	// Bit mask of CSSF field.
	RCC_CIR_CSSF_Msk = 0x80
	// Bit CSSF.
	RCC_CIR_CSSF = 0x80
	// No clock security interrupt caused by HSE clock failure
	RCC_CIR_CSSF_NotInterrupted = 0x0
	// Clock security interrupt caused by HSE clock failure
	RCC_CIR_CSSF_Interrupted = 0x1
	// Position of PLLSAIRDYF field.
	RCC_CIR_PLLSAIRDYF_Pos = 0x6
	// Bit mask of PLLSAIRDYF field.
	RCC_CIR_PLLSAIRDYF_Msk = 0x40
	// Bit PLLSAIRDYF.
	RCC_CIR_PLLSAIRDYF = 0x40
	// No clock ready interrupt
	RCC_CIR_PLLSAIRDYF_NotInterrupted = 0x0
	// Clock ready interrupt
	RCC_CIR_PLLSAIRDYF_Interrupted = 0x1
	// Position of PLLI2SRDYF field.
	RCC_CIR_PLLI2SRDYF_Pos = 0x5
	// Bit mask of PLLI2SRDYF field.
	RCC_CIR_PLLI2SRDYF_Msk = 0x20
	// Bit PLLI2SRDYF.
	RCC_CIR_PLLI2SRDYF = 0x20
	// No clock ready interrupt
	RCC_CIR_PLLI2SRDYF_NotInterrupted = 0x0
	// Clock ready interrupt
	RCC_CIR_PLLI2SRDYF_Interrupted = 0x1
	// Position of PLLRDYF field.
	RCC_CIR_PLLRDYF_Pos = 0x4
	// Bit mask of PLLRDYF field.
	RCC_CIR_PLLRDYF_Msk = 0x10
	// Bit PLLRDYF.
	RCC_CIR_PLLRDYF = 0x10
	// No clock ready interrupt
	RCC_CIR_PLLRDYF_NotInterrupted = 0x0
	// Clock ready interrupt
	RCC_CIR_PLLRDYF_Interrupted = 0x1
	// Position of HSERDYF field.
	RCC_CIR_HSERDYF_Pos = 0x3
	// Bit mask of HSERDYF field.
	RCC_CIR_HSERDYF_Msk = 0x8
	// Bit HSERDYF.
	RCC_CIR_HSERDYF = 0x8
	// No clock ready interrupt
	RCC_CIR_HSERDYF_NotInterrupted = 0x0
	// Clock ready interrupt
	RCC_CIR_HSERDYF_Interrupted = 0x1
	// Position of HSIRDYF field.
	RCC_CIR_HSIRDYF_Pos = 0x2
	// Bit mask of HSIRDYF field.
	RCC_CIR_HSIRDYF_Msk = 0x4
	// Bit HSIRDYF.
	RCC_CIR_HSIRDYF = 0x4
	// No clock ready interrupt
	RCC_CIR_HSIRDYF_NotInterrupted = 0x0
	// Clock ready interrupt
	RCC_CIR_HSIRDYF_Interrupted = 0x1
	// Position of LSERDYF field.
	RCC_CIR_LSERDYF_Pos = 0x1
	// Bit mask of LSERDYF field.
	RCC_CIR_LSERDYF_Msk = 0x2
	// Bit LSERDYF.
	RCC_CIR_LSERDYF = 0x2
	// No clock ready interrupt
	RCC_CIR_LSERDYF_NotInterrupted = 0x0
	// Clock ready interrupt
	RCC_CIR_LSERDYF_Interrupted = 0x1
	// Position of LSIRDYF field.
	RCC_CIR_LSIRDYF_Pos = 0x0
	// Bit mask of LSIRDYF field.
	RCC_CIR_LSIRDYF_Msk = 0x1
	// Bit LSIRDYF.
	RCC_CIR_LSIRDYF = 0x1
	// No clock ready interrupt
	RCC_CIR_LSIRDYF_NotInterrupted = 0x0
	// Clock ready interrupt
	RCC_CIR_LSIRDYF_Interrupted = 0x1

	// AHB1RSTR: AHB1 peripheral reset register
	// Position of OTGHSRST field.
	RCC_AHB1RSTR_OTGHSRST_Pos = 0x1d
	// Bit mask of OTGHSRST field.
	RCC_AHB1RSTR_OTGHSRST_Msk = 0x20000000
	// Bit OTGHSRST.
	RCC_AHB1RSTR_OTGHSRST = 0x20000000
	// Reset the selected module
	RCC_AHB1RSTR_OTGHSRST_Reset = 0x1
	// Position of ETHMACRST field.
	RCC_AHB1RSTR_ETHMACRST_Pos = 0x19
	// Bit mask of ETHMACRST field.
	RCC_AHB1RSTR_ETHMACRST_Msk = 0x2000000
	// Bit ETHMACRST.
	RCC_AHB1RSTR_ETHMACRST = 0x2000000
	// Reset the selected module
	RCC_AHB1RSTR_ETHMACRST_Reset = 0x1
	// Position of DMA2DRST field.
	RCC_AHB1RSTR_DMA2DRST_Pos = 0x17
	// Bit mask of DMA2DRST field.
	RCC_AHB1RSTR_DMA2DRST_Msk = 0x800000
	// Bit DMA2DRST.
	RCC_AHB1RSTR_DMA2DRST = 0x800000
	// Reset the selected module
	RCC_AHB1RSTR_DMA2DRST_Reset = 0x1
	// Position of DMA2RST field.
	RCC_AHB1RSTR_DMA2RST_Pos = 0x16
	// Bit mask of DMA2RST field.
	RCC_AHB1RSTR_DMA2RST_Msk = 0x400000
	// Bit DMA2RST.
	RCC_AHB1RSTR_DMA2RST = 0x400000
	// Reset the selected module
	RCC_AHB1RSTR_DMA2RST_Reset = 0x1
	// Position of DMA1RST field.
	RCC_AHB1RSTR_DMA1RST_Pos = 0x15
	// Bit mask of DMA1RST field.
	RCC_AHB1RSTR_DMA1RST_Msk = 0x200000
	// Bit DMA1RST.
	RCC_AHB1RSTR_DMA1RST = 0x200000
	// Reset the selected module
	RCC_AHB1RSTR_DMA1RST_Reset = 0x1
	// Position of CRCRST field.
	RCC_AHB1RSTR_CRCRST_Pos = 0xc
	// Bit mask of CRCRST field.
	RCC_AHB1RSTR_CRCRST_Msk = 0x1000
	// Bit CRCRST.
	RCC_AHB1RSTR_CRCRST = 0x1000
	// Reset the selected module
	RCC_AHB1RSTR_CRCRST_Reset = 0x1
	// Position of GPIOKRST field.
	RCC_AHB1RSTR_GPIOKRST_Pos = 0xa
	// Bit mask of GPIOKRST field.
	RCC_AHB1RSTR_GPIOKRST_Msk = 0x400
	// Bit GPIOKRST.
	RCC_AHB1RSTR_GPIOKRST = 0x400
	// Reset the selected module
	RCC_AHB1RSTR_GPIOKRST_Reset = 0x1
	// Position of GPIOJRST field.
	RCC_AHB1RSTR_GPIOJRST_Pos = 0x9
	// Bit mask of GPIOJRST field.
	RCC_AHB1RSTR_GPIOJRST_Msk = 0x200
	// Bit GPIOJRST.
	RCC_AHB1RSTR_GPIOJRST = 0x200
	// Reset the selected module
	RCC_AHB1RSTR_GPIOJRST_Reset = 0x1
	// Position of GPIOIRST field.
	RCC_AHB1RSTR_GPIOIRST_Pos = 0x8
	// Bit mask of GPIOIRST field.
	RCC_AHB1RSTR_GPIOIRST_Msk = 0x100
	// Bit GPIOIRST.
	RCC_AHB1RSTR_GPIOIRST = 0x100
	// Reset the selected module
	RCC_AHB1RSTR_GPIOIRST_Reset = 0x1
	// Position of GPIOHRST field.
	RCC_AHB1RSTR_GPIOHRST_Pos = 0x7
	// Bit mask of GPIOHRST field.
	RCC_AHB1RSTR_GPIOHRST_Msk = 0x80
	// Bit GPIOHRST.
	RCC_AHB1RSTR_GPIOHRST = 0x80
	// Reset the selected module
	RCC_AHB1RSTR_GPIOHRST_Reset = 0x1
	// Position of GPIOGRST field.
	RCC_AHB1RSTR_GPIOGRST_Pos = 0x6
	// Bit mask of GPIOGRST field.
	RCC_AHB1RSTR_GPIOGRST_Msk = 0x40
	// Bit GPIOGRST.
	RCC_AHB1RSTR_GPIOGRST = 0x40
	// Reset the selected module
	RCC_AHB1RSTR_GPIOGRST_Reset = 0x1
	// Position of GPIOFRST field.
	RCC_AHB1RSTR_GPIOFRST_Pos = 0x5
	// Bit mask of GPIOFRST field.
	RCC_AHB1RSTR_GPIOFRST_Msk = 0x20
	// Bit GPIOFRST.
	RCC_AHB1RSTR_GPIOFRST = 0x20
	// Reset the selected module
	RCC_AHB1RSTR_GPIOFRST_Reset = 0x1
	// Position of GPIOERST field.
	RCC_AHB1RSTR_GPIOERST_Pos = 0x4
	// Bit mask of GPIOERST field.
	RCC_AHB1RSTR_GPIOERST_Msk = 0x10
	// Bit GPIOERST.
	RCC_AHB1RSTR_GPIOERST = 0x10
	// Reset the selected module
	RCC_AHB1RSTR_GPIOERST_Reset = 0x1
	// Position of GPIODRST field.
	RCC_AHB1RSTR_GPIODRST_Pos = 0x3
	// Bit mask of GPIODRST field.
	RCC_AHB1RSTR_GPIODRST_Msk = 0x8
	// Bit GPIODRST.
	RCC_AHB1RSTR_GPIODRST = 0x8
	// Reset the selected module
	RCC_AHB1RSTR_GPIODRST_Reset = 0x1
	// Position of GPIOCRST field.
	RCC_AHB1RSTR_GPIOCRST_Pos = 0x2
	// Bit mask of GPIOCRST field.
	RCC_AHB1RSTR_GPIOCRST_Msk = 0x4
	// Bit GPIOCRST.
	RCC_AHB1RSTR_GPIOCRST = 0x4
	// Reset the selected module
	RCC_AHB1RSTR_GPIOCRST_Reset = 0x1
	// Position of GPIOBRST field.
	RCC_AHB1RSTR_GPIOBRST_Pos = 0x1
	// Bit mask of GPIOBRST field.
	RCC_AHB1RSTR_GPIOBRST_Msk = 0x2
	// Bit GPIOBRST.
	RCC_AHB1RSTR_GPIOBRST = 0x2
	// Reset the selected module
	RCC_AHB1RSTR_GPIOBRST_Reset = 0x1
	// Position of GPIOARST field.
	RCC_AHB1RSTR_GPIOARST_Pos = 0x0
	// Bit mask of GPIOARST field.
	RCC_AHB1RSTR_GPIOARST_Msk = 0x1
	// Bit GPIOARST.
	RCC_AHB1RSTR_GPIOARST = 0x1
	// Reset the selected module
	RCC_AHB1RSTR_GPIOARST_Reset = 0x1

	// AHB2RSTR: AHB2 peripheral reset register
	// Position of OTGFSRST field.
	RCC_AHB2RSTR_OTGFSRST_Pos = 0x7
	// Bit mask of OTGFSRST field.
	RCC_AHB2RSTR_OTGFSRST_Msk = 0x80
	// Bit OTGFSRST.
	RCC_AHB2RSTR_OTGFSRST = 0x80
	// Reset the selected module
	RCC_AHB2RSTR_OTGFSRST_Reset = 0x1
	// Position of RNGRST field.
	RCC_AHB2RSTR_RNGRST_Pos = 0x6
	// Bit mask of RNGRST field.
	RCC_AHB2RSTR_RNGRST_Msk = 0x40
	// Bit RNGRST.
	RCC_AHB2RSTR_RNGRST = 0x40
	// Reset the selected module
	RCC_AHB2RSTR_RNGRST_Reset = 0x1
	// Position of HSAHRST field.
	RCC_AHB2RSTR_HSAHRST_Pos = 0x5
	// Bit mask of HSAHRST field.
	RCC_AHB2RSTR_HSAHRST_Msk = 0x20
	// Bit HSAHRST.
	RCC_AHB2RSTR_HSAHRST = 0x20
	// Reset the selected module
	RCC_AHB2RSTR_HSAHRST_Reset = 0x1
	// Position of CRYPRST field.
	RCC_AHB2RSTR_CRYPRST_Pos = 0x4
	// Bit mask of CRYPRST field.
	RCC_AHB2RSTR_CRYPRST_Msk = 0x10
	// Bit CRYPRST.
	RCC_AHB2RSTR_CRYPRST = 0x10
	// Reset the selected module
	RCC_AHB2RSTR_CRYPRST_Reset = 0x1
	// Position of DCMIRST field.
	RCC_AHB2RSTR_DCMIRST_Pos = 0x0
	// Bit mask of DCMIRST field.
	RCC_AHB2RSTR_DCMIRST_Msk = 0x1
	// Bit DCMIRST.
	RCC_AHB2RSTR_DCMIRST = 0x1
	// Reset the selected module
	RCC_AHB2RSTR_DCMIRST_Reset = 0x1

	// AHB3RSTR: AHB3 peripheral reset register
	// Position of FMCRST field.
	RCC_AHB3RSTR_FMCRST_Pos = 0x0
	// Bit mask of FMCRST field.
	RCC_AHB3RSTR_FMCRST_Msk = 0x1
	// Bit FMCRST.
	RCC_AHB3RSTR_FMCRST = 0x1
	// Reset the selected module
	RCC_AHB3RSTR_FMCRST_Reset = 0x1
	// Position of QSPIRST field.
	RCC_AHB3RSTR_QSPIRST_Pos = 0x1
	// Bit mask of QSPIRST field.
	RCC_AHB3RSTR_QSPIRST_Msk = 0x2
	// Bit QSPIRST.
	RCC_AHB3RSTR_QSPIRST = 0x2
	// Reset the selected module
	RCC_AHB3RSTR_QSPIRST_Reset = 0x1

	// APB1RSTR: APB1 peripheral reset register
	// Position of TIM2RST field.
	RCC_APB1RSTR_TIM2RST_Pos = 0x0
	// Bit mask of TIM2RST field.
	RCC_APB1RSTR_TIM2RST_Msk = 0x1
	// Bit TIM2RST.
	RCC_APB1RSTR_TIM2RST = 0x1
	// Reset the selected module
	RCC_APB1RSTR_TIM2RST_Reset = 0x1
	// Position of TIM3RST field.
	RCC_APB1RSTR_TIM3RST_Pos = 0x1
	// Bit mask of TIM3RST field.
	RCC_APB1RSTR_TIM3RST_Msk = 0x2
	// Bit TIM3RST.
	RCC_APB1RSTR_TIM3RST = 0x2
	// Reset the selected module
	RCC_APB1RSTR_TIM3RST_Reset = 0x1
	// Position of TIM4RST field.
	RCC_APB1RSTR_TIM4RST_Pos = 0x2
	// Bit mask of TIM4RST field.
	RCC_APB1RSTR_TIM4RST_Msk = 0x4
	// Bit TIM4RST.
	RCC_APB1RSTR_TIM4RST = 0x4
	// Reset the selected module
	RCC_APB1RSTR_TIM4RST_Reset = 0x1
	// Position of TIM5RST field.
	RCC_APB1RSTR_TIM5RST_Pos = 0x3
	// Bit mask of TIM5RST field.
	RCC_APB1RSTR_TIM5RST_Msk = 0x8
	// Bit TIM5RST.
	RCC_APB1RSTR_TIM5RST = 0x8
	// Reset the selected module
	RCC_APB1RSTR_TIM5RST_Reset = 0x1
	// Position of TIM6RST field.
	RCC_APB1RSTR_TIM6RST_Pos = 0x4
	// Bit mask of TIM6RST field.
	RCC_APB1RSTR_TIM6RST_Msk = 0x10
	// Bit TIM6RST.
	RCC_APB1RSTR_TIM6RST = 0x10
	// Reset the selected module
	RCC_APB1RSTR_TIM6RST_Reset = 0x1
	// Position of TIM7RST field.
	RCC_APB1RSTR_TIM7RST_Pos = 0x5
	// Bit mask of TIM7RST field.
	RCC_APB1RSTR_TIM7RST_Msk = 0x20
	// Bit TIM7RST.
	RCC_APB1RSTR_TIM7RST = 0x20
	// Reset the selected module
	RCC_APB1RSTR_TIM7RST_Reset = 0x1
	// Position of TIM12RST field.
	RCC_APB1RSTR_TIM12RST_Pos = 0x6
	// Bit mask of TIM12RST field.
	RCC_APB1RSTR_TIM12RST_Msk = 0x40
	// Bit TIM12RST.
	RCC_APB1RSTR_TIM12RST = 0x40
	// Reset the selected module
	RCC_APB1RSTR_TIM12RST_Reset = 0x1
	// Position of TIM13RST field.
	RCC_APB1RSTR_TIM13RST_Pos = 0x7
	// Bit mask of TIM13RST field.
	RCC_APB1RSTR_TIM13RST_Msk = 0x80
	// Bit TIM13RST.
	RCC_APB1RSTR_TIM13RST = 0x80
	// Reset the selected module
	RCC_APB1RSTR_TIM13RST_Reset = 0x1
	// Position of TIM14RST field.
	RCC_APB1RSTR_TIM14RST_Pos = 0x8
	// Bit mask of TIM14RST field.
	RCC_APB1RSTR_TIM14RST_Msk = 0x100
	// Bit TIM14RST.
	RCC_APB1RSTR_TIM14RST = 0x100
	// Reset the selected module
	RCC_APB1RSTR_TIM14RST_Reset = 0x1
	// Position of WWDGRST field.
	RCC_APB1RSTR_WWDGRST_Pos = 0xb
	// Bit mask of WWDGRST field.
	RCC_APB1RSTR_WWDGRST_Msk = 0x800
	// Bit WWDGRST.
	RCC_APB1RSTR_WWDGRST = 0x800
	// Reset the selected module
	RCC_APB1RSTR_WWDGRST_Reset = 0x1
	// Position of SPI2RST field.
	RCC_APB1RSTR_SPI2RST_Pos = 0xe
	// Bit mask of SPI2RST field.
	RCC_APB1RSTR_SPI2RST_Msk = 0x4000
	// Bit SPI2RST.
	RCC_APB1RSTR_SPI2RST = 0x4000
	// Reset the selected module
	RCC_APB1RSTR_SPI2RST_Reset = 0x1
	// Position of SPI3RST field.
	RCC_APB1RSTR_SPI3RST_Pos = 0xf
	// Bit mask of SPI3RST field.
	RCC_APB1RSTR_SPI3RST_Msk = 0x8000
	// Bit SPI3RST.
	RCC_APB1RSTR_SPI3RST = 0x8000
	// Reset the selected module
	RCC_APB1RSTR_SPI3RST_Reset = 0x1
	// Position of USART2RST field.
	RCC_APB1RSTR_USART2RST_Pos = 0x11
	// Bit mask of USART2RST field.
	RCC_APB1RSTR_USART2RST_Msk = 0x20000
	// Bit USART2RST.
	RCC_APB1RSTR_USART2RST = 0x20000
	// Reset the selected module
	RCC_APB1RSTR_USART2RST_Reset = 0x1
	// Position of USART3RST field.
	RCC_APB1RSTR_USART3RST_Pos = 0x12
	// Bit mask of USART3RST field.
	RCC_APB1RSTR_USART3RST_Msk = 0x40000
	// Bit USART3RST.
	RCC_APB1RSTR_USART3RST = 0x40000
	// Reset the selected module
	RCC_APB1RSTR_USART3RST_Reset = 0x1
	// Position of UART4RST field.
	RCC_APB1RSTR_UART4RST_Pos = 0x13
	// Bit mask of UART4RST field.
	RCC_APB1RSTR_UART4RST_Msk = 0x80000
	// Bit UART4RST.
	RCC_APB1RSTR_UART4RST = 0x80000
	// Reset the selected module
	RCC_APB1RSTR_UART4RST_Reset = 0x1
	// Position of UART5RST field.
	RCC_APB1RSTR_UART5RST_Pos = 0x14
	// Bit mask of UART5RST field.
	RCC_APB1RSTR_UART5RST_Msk = 0x100000
	// Bit UART5RST.
	RCC_APB1RSTR_UART5RST = 0x100000
	// Reset the selected module
	RCC_APB1RSTR_UART5RST_Reset = 0x1
	// Position of I2C1RST field.
	RCC_APB1RSTR_I2C1RST_Pos = 0x15
	// Bit mask of I2C1RST field.
	RCC_APB1RSTR_I2C1RST_Msk = 0x200000
	// Bit I2C1RST.
	RCC_APB1RSTR_I2C1RST = 0x200000
	// Reset the selected module
	RCC_APB1RSTR_I2C1RST_Reset = 0x1
	// Position of I2C2RST field.
	RCC_APB1RSTR_I2C2RST_Pos = 0x16
	// Bit mask of I2C2RST field.
	RCC_APB1RSTR_I2C2RST_Msk = 0x400000
	// Bit I2C2RST.
	RCC_APB1RSTR_I2C2RST = 0x400000
	// Reset the selected module
	RCC_APB1RSTR_I2C2RST_Reset = 0x1
	// Position of I2C3RST field.
	RCC_APB1RSTR_I2C3RST_Pos = 0x17
	// Bit mask of I2C3RST field.
	RCC_APB1RSTR_I2C3RST_Msk = 0x800000
	// Bit I2C3RST.
	RCC_APB1RSTR_I2C3RST = 0x800000
	// Reset the selected module
	RCC_APB1RSTR_I2C3RST_Reset = 0x1
	// Position of CAN1RST field.
	RCC_APB1RSTR_CAN1RST_Pos = 0x19
	// Bit mask of CAN1RST field.
	RCC_APB1RSTR_CAN1RST_Msk = 0x2000000
	// Bit CAN1RST.
	RCC_APB1RSTR_CAN1RST = 0x2000000
	// Reset the selected module
	RCC_APB1RSTR_CAN1RST_Reset = 0x1
	// Position of CAN2RST field.
	RCC_APB1RSTR_CAN2RST_Pos = 0x1a
	// Bit mask of CAN2RST field.
	RCC_APB1RSTR_CAN2RST_Msk = 0x4000000
	// Bit CAN2RST.
	RCC_APB1RSTR_CAN2RST = 0x4000000
	// Reset the selected module
	RCC_APB1RSTR_CAN2RST_Reset = 0x1
	// Position of PWRRST field.
	RCC_APB1RSTR_PWRRST_Pos = 0x1c
	// Bit mask of PWRRST field.
	RCC_APB1RSTR_PWRRST_Msk = 0x10000000
	// Bit PWRRST.
	RCC_APB1RSTR_PWRRST = 0x10000000
	// Reset the selected module
	RCC_APB1RSTR_PWRRST_Reset = 0x1
	// Position of DACRST field.
	RCC_APB1RSTR_DACRST_Pos = 0x1d
	// Bit mask of DACRST field.
	RCC_APB1RSTR_DACRST_Msk = 0x20000000
	// Bit DACRST.
	RCC_APB1RSTR_DACRST = 0x20000000
	// Reset the selected module
	RCC_APB1RSTR_DACRST_Reset = 0x1
	// Position of UART7RST field.
	RCC_APB1RSTR_UART7RST_Pos = 0x1e
	// Bit mask of UART7RST field.
	RCC_APB1RSTR_UART7RST_Msk = 0x40000000
	// Bit UART7RST.
	RCC_APB1RSTR_UART7RST = 0x40000000
	// Reset the selected module
	RCC_APB1RSTR_UART7RST_Reset = 0x1
	// Position of UART8RST field.
	RCC_APB1RSTR_UART8RST_Pos = 0x1f
	// Bit mask of UART8RST field.
	RCC_APB1RSTR_UART8RST_Msk = 0x80000000
	// Bit UART8RST.
	RCC_APB1RSTR_UART8RST = 0x80000000
	// Reset the selected module
	RCC_APB1RSTR_UART8RST_Reset = 0x1
	// Position of SPDIFRXRST field.
	RCC_APB1RSTR_SPDIFRXRST_Pos = 0x10
	// Bit mask of SPDIFRXRST field.
	RCC_APB1RSTR_SPDIFRXRST_Msk = 0x10000
	// Bit SPDIFRXRST.
	RCC_APB1RSTR_SPDIFRXRST = 0x10000
	// Reset the selected module
	RCC_APB1RSTR_SPDIFRXRST_Reset = 0x1
	// Position of CECRST field.
	RCC_APB1RSTR_CECRST_Pos = 0x1b
	// Bit mask of CECRST field.
	RCC_APB1RSTR_CECRST_Msk = 0x8000000
	// Bit CECRST.
	RCC_APB1RSTR_CECRST = 0x8000000
	// Reset the selected module
	RCC_APB1RSTR_CECRST_Reset = 0x1
	// Position of LPTIM1RST field.
	RCC_APB1RSTR_LPTIM1RST_Pos = 0x9
	// Bit mask of LPTIM1RST field.
	RCC_APB1RSTR_LPTIM1RST_Msk = 0x200
	// Bit LPTIM1RST.
	RCC_APB1RSTR_LPTIM1RST = 0x200
	// Reset the selected module
	RCC_APB1RSTR_LPTIM1RST_Reset = 0x1
	// Position of I2C4RST field.
	RCC_APB1RSTR_I2C4RST_Pos = 0x18
	// Bit mask of I2C4RST field.
	RCC_APB1RSTR_I2C4RST_Msk = 0x1000000
	// Bit I2C4RST.
	RCC_APB1RSTR_I2C4RST = 0x1000000
	// Reset the selected module
	RCC_APB1RSTR_I2C4RST_Reset = 0x1
	// Position of CAN3RST field.
	RCC_APB1RSTR_CAN3RST_Pos = 0xd
	// Bit mask of CAN3RST field.
	RCC_APB1RSTR_CAN3RST_Msk = 0x2000
	// Bit CAN3RST.
	RCC_APB1RSTR_CAN3RST = 0x2000
	// Reset the selected module
	RCC_APB1RSTR_CAN3RST_Reset = 0x1

	// APB2RSTR: APB2 peripheral reset register
	// Position of TIM1RST field.
	RCC_APB2RSTR_TIM1RST_Pos = 0x0
	// Bit mask of TIM1RST field.
	RCC_APB2RSTR_TIM1RST_Msk = 0x1
	// Bit TIM1RST.
	RCC_APB2RSTR_TIM1RST = 0x1
	// Reset the selected module
	RCC_APB2RSTR_TIM1RST_Reset = 0x1
	// Position of TIM8RST field.
	RCC_APB2RSTR_TIM8RST_Pos = 0x1
	// Bit mask of TIM8RST field.
	RCC_APB2RSTR_TIM8RST_Msk = 0x2
	// Bit TIM8RST.
	RCC_APB2RSTR_TIM8RST = 0x2
	// Reset the selected module
	RCC_APB2RSTR_TIM8RST_Reset = 0x1
	// Position of USART1RST field.
	RCC_APB2RSTR_USART1RST_Pos = 0x4
	// Bit mask of USART1RST field.
	RCC_APB2RSTR_USART1RST_Msk = 0x10
	// Bit USART1RST.
	RCC_APB2RSTR_USART1RST = 0x10
	// Reset the selected module
	RCC_APB2RSTR_USART1RST_Reset = 0x1
	// Position of USART6RST field.
	RCC_APB2RSTR_USART6RST_Pos = 0x5
	// Bit mask of USART6RST field.
	RCC_APB2RSTR_USART6RST_Msk = 0x20
	// Bit USART6RST.
	RCC_APB2RSTR_USART6RST = 0x20
	// Reset the selected module
	RCC_APB2RSTR_USART6RST_Reset = 0x1
	// Position of ADCRST field.
	RCC_APB2RSTR_ADCRST_Pos = 0x8
	// Bit mask of ADCRST field.
	RCC_APB2RSTR_ADCRST_Msk = 0x100
	// Bit ADCRST.
	RCC_APB2RSTR_ADCRST = 0x100
	// Reset the selected module
	RCC_APB2RSTR_ADCRST_Reset = 0x1
	// Position of SPI1RST field.
	RCC_APB2RSTR_SPI1RST_Pos = 0xc
	// Bit mask of SPI1RST field.
	RCC_APB2RSTR_SPI1RST_Msk = 0x1000
	// Bit SPI1RST.
	RCC_APB2RSTR_SPI1RST = 0x1000
	// Reset the selected module
	RCC_APB2RSTR_SPI1RST_Reset = 0x1
	// Position of SPI4RST field.
	RCC_APB2RSTR_SPI4RST_Pos = 0xd
	// Bit mask of SPI4RST field.
	RCC_APB2RSTR_SPI4RST_Msk = 0x2000
	// Bit SPI4RST.
	RCC_APB2RSTR_SPI4RST = 0x2000
	// Reset the selected module
	RCC_APB2RSTR_SPI4RST_Reset = 0x1
	// Position of SYSCFGRST field.
	RCC_APB2RSTR_SYSCFGRST_Pos = 0xe
	// Bit mask of SYSCFGRST field.
	RCC_APB2RSTR_SYSCFGRST_Msk = 0x4000
	// Bit SYSCFGRST.
	RCC_APB2RSTR_SYSCFGRST = 0x4000
	// Reset the selected module
	RCC_APB2RSTR_SYSCFGRST_Reset = 0x1
	// Position of TIM9RST field.
	RCC_APB2RSTR_TIM9RST_Pos = 0x10
	// Bit mask of TIM9RST field.
	RCC_APB2RSTR_TIM9RST_Msk = 0x10000
	// Bit TIM9RST.
	RCC_APB2RSTR_TIM9RST = 0x10000
	// Reset the selected module
	RCC_APB2RSTR_TIM9RST_Reset = 0x1
	// Position of TIM10RST field.
	RCC_APB2RSTR_TIM10RST_Pos = 0x11
	// Bit mask of TIM10RST field.
	RCC_APB2RSTR_TIM10RST_Msk = 0x20000
	// Bit TIM10RST.
	RCC_APB2RSTR_TIM10RST = 0x20000
	// Reset the selected module
	RCC_APB2RSTR_TIM10RST_Reset = 0x1
	// Position of TIM11RST field.
	RCC_APB2RSTR_TIM11RST_Pos = 0x12
	// Bit mask of TIM11RST field.
	RCC_APB2RSTR_TIM11RST_Msk = 0x40000
	// Bit TIM11RST.
	RCC_APB2RSTR_TIM11RST = 0x40000
	// Reset the selected module
	RCC_APB2RSTR_TIM11RST_Reset = 0x1
	// Position of SPI5RST field.
	RCC_APB2RSTR_SPI5RST_Pos = 0x14
	// Bit mask of SPI5RST field.
	RCC_APB2RSTR_SPI5RST_Msk = 0x100000
	// Bit SPI5RST.
	RCC_APB2RSTR_SPI5RST = 0x100000
	// Reset the selected module
	RCC_APB2RSTR_SPI5RST_Reset = 0x1
	// Position of SPI6RST field.
	RCC_APB2RSTR_SPI6RST_Pos = 0x15
	// Bit mask of SPI6RST field.
	RCC_APB2RSTR_SPI6RST_Msk = 0x200000
	// Bit SPI6RST.
	RCC_APB2RSTR_SPI6RST = 0x200000
	// Reset the selected module
	RCC_APB2RSTR_SPI6RST_Reset = 0x1
	// Position of SAI1RST field.
	RCC_APB2RSTR_SAI1RST_Pos = 0x16
	// Bit mask of SAI1RST field.
	RCC_APB2RSTR_SAI1RST_Msk = 0x400000
	// Bit SAI1RST.
	RCC_APB2RSTR_SAI1RST = 0x400000
	// Reset the selected module
	RCC_APB2RSTR_SAI1RST_Reset = 0x1
	// Position of LTDCRST field.
	RCC_APB2RSTR_LTDCRST_Pos = 0x1a
	// Bit mask of LTDCRST field.
	RCC_APB2RSTR_LTDCRST_Msk = 0x4000000
	// Bit LTDCRST.
	RCC_APB2RSTR_LTDCRST = 0x4000000
	// Reset the selected module
	RCC_APB2RSTR_LTDCRST_Reset = 0x1
	// Position of SAI2RST field.
	RCC_APB2RSTR_SAI2RST_Pos = 0x17
	// Bit mask of SAI2RST field.
	RCC_APB2RSTR_SAI2RST_Msk = 0x800000
	// Bit SAI2RST.
	RCC_APB2RSTR_SAI2RST = 0x800000
	// Reset the selected module
	RCC_APB2RSTR_SAI2RST_Reset = 0x1
	// Position of SDMMC1RST field.
	RCC_APB2RSTR_SDMMC1RST_Pos = 0xb
	// Bit mask of SDMMC1RST field.
	RCC_APB2RSTR_SDMMC1RST_Msk = 0x800
	// Bit SDMMC1RST.
	RCC_APB2RSTR_SDMMC1RST = 0x800
	// Reset the selected module
	RCC_APB2RSTR_SDMMC1RST_Reset = 0x1
	// Position of MDIORST field.
	RCC_APB2RSTR_MDIORST_Pos = 0x1e
	// Bit mask of MDIORST field.
	RCC_APB2RSTR_MDIORST_Msk = 0x40000000
	// Bit MDIORST.
	RCC_APB2RSTR_MDIORST = 0x40000000
	// Position of DFSDM1RST field.
	RCC_APB2RSTR_DFSDM1RST_Pos = 0x1d
	// Bit mask of DFSDM1RST field.
	RCC_APB2RSTR_DFSDM1RST_Msk = 0x20000000
	// Bit DFSDM1RST.
	RCC_APB2RSTR_DFSDM1RST = 0x20000000
	// Position of DSIRST field.
	RCC_APB2RSTR_DSIRST_Pos = 0x1b
	// Bit mask of DSIRST field.
	RCC_APB2RSTR_DSIRST_Msk = 0x8000000
	// Bit DSIRST.
	RCC_APB2RSTR_DSIRST = 0x8000000
	// Position of SDMMC2RST field.
	RCC_APB2RSTR_SDMMC2RST_Pos = 0x7
	// Bit mask of SDMMC2RST field.
	RCC_APB2RSTR_SDMMC2RST_Msk = 0x80
	// Bit SDMMC2RST.
	RCC_APB2RSTR_SDMMC2RST = 0x80

	// AHB1ENR: AHB1 peripheral clock register
	// Position of OTGHSULPIEN field.
	RCC_AHB1ENR_OTGHSULPIEN_Pos = 0x1e
	// Bit mask of OTGHSULPIEN field.
	RCC_AHB1ENR_OTGHSULPIEN_Msk = 0x40000000
	// Bit OTGHSULPIEN.
	RCC_AHB1ENR_OTGHSULPIEN = 0x40000000
	// The selected clock is disabled
	RCC_AHB1ENR_OTGHSULPIEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_OTGHSULPIEN_Enabled = 0x1
	// Position of OTGHSEN field.
	RCC_AHB1ENR_OTGHSEN_Pos = 0x1d
	// Bit mask of OTGHSEN field.
	RCC_AHB1ENR_OTGHSEN_Msk = 0x20000000
	// Bit OTGHSEN.
	RCC_AHB1ENR_OTGHSEN = 0x20000000
	// The selected clock is disabled
	RCC_AHB1ENR_OTGHSEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_OTGHSEN_Enabled = 0x1
	// Position of ETHMACPTPEN field.
	RCC_AHB1ENR_ETHMACPTPEN_Pos = 0x1c
	// Bit mask of ETHMACPTPEN field.
	RCC_AHB1ENR_ETHMACPTPEN_Msk = 0x10000000
	// Bit ETHMACPTPEN.
	RCC_AHB1ENR_ETHMACPTPEN = 0x10000000
	// The selected clock is disabled
	RCC_AHB1ENR_ETHMACPTPEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_ETHMACPTPEN_Enabled = 0x1
	// Position of ETHMACRXEN field.
	RCC_AHB1ENR_ETHMACRXEN_Pos = 0x1b
	// Bit mask of ETHMACRXEN field.
	RCC_AHB1ENR_ETHMACRXEN_Msk = 0x8000000
	// Bit ETHMACRXEN.
	RCC_AHB1ENR_ETHMACRXEN = 0x8000000
	// The selected clock is disabled
	RCC_AHB1ENR_ETHMACRXEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_ETHMACRXEN_Enabled = 0x1
	// Position of ETHMACTXEN field.
	RCC_AHB1ENR_ETHMACTXEN_Pos = 0x1a
	// Bit mask of ETHMACTXEN field.
	RCC_AHB1ENR_ETHMACTXEN_Msk = 0x4000000
	// Bit ETHMACTXEN.
	RCC_AHB1ENR_ETHMACTXEN = 0x4000000
	// The selected clock is disabled
	RCC_AHB1ENR_ETHMACTXEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_ETHMACTXEN_Enabled = 0x1
	// Position of ETHMACEN field.
	RCC_AHB1ENR_ETHMACEN_Pos = 0x19
	// Bit mask of ETHMACEN field.
	RCC_AHB1ENR_ETHMACEN_Msk = 0x2000000
	// Bit ETHMACEN.
	RCC_AHB1ENR_ETHMACEN = 0x2000000
	// The selected clock is disabled
	RCC_AHB1ENR_ETHMACEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_ETHMACEN_Enabled = 0x1
	// Position of DMA2DEN field.
	RCC_AHB1ENR_DMA2DEN_Pos = 0x17
	// Bit mask of DMA2DEN field.
	RCC_AHB1ENR_DMA2DEN_Msk = 0x800000
	// Bit DMA2DEN.
	RCC_AHB1ENR_DMA2DEN = 0x800000
	// The selected clock is disabled
	RCC_AHB1ENR_DMA2DEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_DMA2DEN_Enabled = 0x1
	// Position of DMA2EN field.
	RCC_AHB1ENR_DMA2EN_Pos = 0x16
	// Bit mask of DMA2EN field.
	RCC_AHB1ENR_DMA2EN_Msk = 0x400000
	// Bit DMA2EN.
	RCC_AHB1ENR_DMA2EN = 0x400000
	// The selected clock is disabled
	RCC_AHB1ENR_DMA2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_DMA2EN_Enabled = 0x1
	// Position of DMA1EN field.
	RCC_AHB1ENR_DMA1EN_Pos = 0x15
	// Bit mask of DMA1EN field.
	RCC_AHB1ENR_DMA1EN_Msk = 0x200000
	// Bit DMA1EN.
	RCC_AHB1ENR_DMA1EN = 0x200000
	// The selected clock is disabled
	RCC_AHB1ENR_DMA1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_DMA1EN_Enabled = 0x1
	// Position of DTCMRAMEN field.
	RCC_AHB1ENR_DTCMRAMEN_Pos = 0x14
	// Bit mask of DTCMRAMEN field.
	RCC_AHB1ENR_DTCMRAMEN_Msk = 0x100000
	// Bit DTCMRAMEN.
	RCC_AHB1ENR_DTCMRAMEN = 0x100000
	// The selected clock is disabled
	RCC_AHB1ENR_DTCMRAMEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_DTCMRAMEN_Enabled = 0x1
	// Position of BKPSRAMEN field.
	RCC_AHB1ENR_BKPSRAMEN_Pos = 0x12
	// Bit mask of BKPSRAMEN field.
	RCC_AHB1ENR_BKPSRAMEN_Msk = 0x40000
	// Bit BKPSRAMEN.
	RCC_AHB1ENR_BKPSRAMEN = 0x40000
	// The selected clock is disabled
	RCC_AHB1ENR_BKPSRAMEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_BKPSRAMEN_Enabled = 0x1
	// Position of CRCEN field.
	RCC_AHB1ENR_CRCEN_Pos = 0xc
	// Bit mask of CRCEN field.
	RCC_AHB1ENR_CRCEN_Msk = 0x1000
	// Bit CRCEN.
	RCC_AHB1ENR_CRCEN = 0x1000
	// The selected clock is disabled
	RCC_AHB1ENR_CRCEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_CRCEN_Enabled = 0x1
	// Position of GPIOKEN field.
	RCC_AHB1ENR_GPIOKEN_Pos = 0xa
	// Bit mask of GPIOKEN field.
	RCC_AHB1ENR_GPIOKEN_Msk = 0x400
	// Bit GPIOKEN.
	RCC_AHB1ENR_GPIOKEN = 0x400
	// The selected clock is disabled
	RCC_AHB1ENR_GPIOKEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_GPIOKEN_Enabled = 0x1
	// Position of GPIOJEN field.
	RCC_AHB1ENR_GPIOJEN_Pos = 0x9
	// Bit mask of GPIOJEN field.
	RCC_AHB1ENR_GPIOJEN_Msk = 0x200
	// Bit GPIOJEN.
	RCC_AHB1ENR_GPIOJEN = 0x200
	// The selected clock is disabled
	RCC_AHB1ENR_GPIOJEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_GPIOJEN_Enabled = 0x1
	// Position of GPIOIEN field.
	RCC_AHB1ENR_GPIOIEN_Pos = 0x8
	// Bit mask of GPIOIEN field.
	RCC_AHB1ENR_GPIOIEN_Msk = 0x100
	// Bit GPIOIEN.
	RCC_AHB1ENR_GPIOIEN = 0x100
	// The selected clock is disabled
	RCC_AHB1ENR_GPIOIEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_GPIOIEN_Enabled = 0x1
	// Position of GPIOHEN field.
	RCC_AHB1ENR_GPIOHEN_Pos = 0x7
	// Bit mask of GPIOHEN field.
	RCC_AHB1ENR_GPIOHEN_Msk = 0x80
	// Bit GPIOHEN.
	RCC_AHB1ENR_GPIOHEN = 0x80
	// The selected clock is disabled
	RCC_AHB1ENR_GPIOHEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_GPIOHEN_Enabled = 0x1
	// Position of GPIOGEN field.
	RCC_AHB1ENR_GPIOGEN_Pos = 0x6
	// Bit mask of GPIOGEN field.
	RCC_AHB1ENR_GPIOGEN_Msk = 0x40
	// Bit GPIOGEN.
	RCC_AHB1ENR_GPIOGEN = 0x40
	// The selected clock is disabled
	RCC_AHB1ENR_GPIOGEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_GPIOGEN_Enabled = 0x1
	// Position of GPIOFEN field.
	RCC_AHB1ENR_GPIOFEN_Pos = 0x5
	// Bit mask of GPIOFEN field.
	RCC_AHB1ENR_GPIOFEN_Msk = 0x20
	// Bit GPIOFEN.
	RCC_AHB1ENR_GPIOFEN = 0x20
	// The selected clock is disabled
	RCC_AHB1ENR_GPIOFEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_GPIOFEN_Enabled = 0x1
	// Position of GPIOEEN field.
	RCC_AHB1ENR_GPIOEEN_Pos = 0x4
	// Bit mask of GPIOEEN field.
	RCC_AHB1ENR_GPIOEEN_Msk = 0x10
	// Bit GPIOEEN.
	RCC_AHB1ENR_GPIOEEN = 0x10
	// The selected clock is disabled
	RCC_AHB1ENR_GPIOEEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_GPIOEEN_Enabled = 0x1
	// Position of GPIODEN field.
	RCC_AHB1ENR_GPIODEN_Pos = 0x3
	// Bit mask of GPIODEN field.
	RCC_AHB1ENR_GPIODEN_Msk = 0x8
	// Bit GPIODEN.
	RCC_AHB1ENR_GPIODEN = 0x8
	// The selected clock is disabled
	RCC_AHB1ENR_GPIODEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_GPIODEN_Enabled = 0x1
	// Position of GPIOCEN field.
	RCC_AHB1ENR_GPIOCEN_Pos = 0x2
	// Bit mask of GPIOCEN field.
	RCC_AHB1ENR_GPIOCEN_Msk = 0x4
	// Bit GPIOCEN.
	RCC_AHB1ENR_GPIOCEN = 0x4
	// The selected clock is disabled
	RCC_AHB1ENR_GPIOCEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_GPIOCEN_Enabled = 0x1
	// Position of GPIOBEN field.
	RCC_AHB1ENR_GPIOBEN_Pos = 0x1
	// Bit mask of GPIOBEN field.
	RCC_AHB1ENR_GPIOBEN_Msk = 0x2
	// Bit GPIOBEN.
	RCC_AHB1ENR_GPIOBEN = 0x2
	// The selected clock is disabled
	RCC_AHB1ENR_GPIOBEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_GPIOBEN_Enabled = 0x1
	// Position of GPIOAEN field.
	RCC_AHB1ENR_GPIOAEN_Pos = 0x0
	// Bit mask of GPIOAEN field.
	RCC_AHB1ENR_GPIOAEN_Msk = 0x1
	// Bit GPIOAEN.
	RCC_AHB1ENR_GPIOAEN = 0x1
	// The selected clock is disabled
	RCC_AHB1ENR_GPIOAEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB1ENR_GPIOAEN_Enabled = 0x1

	// AHB2ENR: AHB2 peripheral clock enable register
	// Position of OTGFSEN field.
	RCC_AHB2ENR_OTGFSEN_Pos = 0x7
	// Bit mask of OTGFSEN field.
	RCC_AHB2ENR_OTGFSEN_Msk = 0x80
	// Bit OTGFSEN.
	RCC_AHB2ENR_OTGFSEN = 0x80
	// The selected clock is disabled
	RCC_AHB2ENR_OTGFSEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB2ENR_OTGFSEN_Enabled = 0x1
	// Position of RNGEN field.
	RCC_AHB2ENR_RNGEN_Pos = 0x6
	// Bit mask of RNGEN field.
	RCC_AHB2ENR_RNGEN_Msk = 0x40
	// Bit RNGEN.
	RCC_AHB2ENR_RNGEN = 0x40
	// The selected clock is disabled
	RCC_AHB2ENR_RNGEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB2ENR_RNGEN_Enabled = 0x1
	// Position of HASHEN field.
	RCC_AHB2ENR_HASHEN_Pos = 0x5
	// Bit mask of HASHEN field.
	RCC_AHB2ENR_HASHEN_Msk = 0x20
	// Bit HASHEN.
	RCC_AHB2ENR_HASHEN = 0x20
	// The selected clock is disabled
	RCC_AHB2ENR_HASHEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB2ENR_HASHEN_Enabled = 0x1
	// Position of CRYPEN field.
	RCC_AHB2ENR_CRYPEN_Pos = 0x4
	// Bit mask of CRYPEN field.
	RCC_AHB2ENR_CRYPEN_Msk = 0x10
	// Bit CRYPEN.
	RCC_AHB2ENR_CRYPEN = 0x10
	// The selected clock is disabled
	RCC_AHB2ENR_CRYPEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB2ENR_CRYPEN_Enabled = 0x1
	// Position of DCMIEN field.
	RCC_AHB2ENR_DCMIEN_Pos = 0x0
	// Bit mask of DCMIEN field.
	RCC_AHB2ENR_DCMIEN_Msk = 0x1
	// Bit DCMIEN.
	RCC_AHB2ENR_DCMIEN = 0x1
	// The selected clock is disabled
	RCC_AHB2ENR_DCMIEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB2ENR_DCMIEN_Enabled = 0x1
	// Position of JPEGEN field.
	RCC_AHB2ENR_JPEGEN_Pos = 0x1
	// Bit mask of JPEGEN field.
	RCC_AHB2ENR_JPEGEN_Msk = 0x2
	// Bit JPEGEN.
	RCC_AHB2ENR_JPEGEN = 0x2

	// AHB3ENR: AHB3 peripheral clock enable register
	// Position of FMCEN field.
	RCC_AHB3ENR_FMCEN_Pos = 0x0
	// Bit mask of FMCEN field.
	RCC_AHB3ENR_FMCEN_Msk = 0x1
	// Bit FMCEN.
	RCC_AHB3ENR_FMCEN = 0x1
	// The selected clock is disabled
	RCC_AHB3ENR_FMCEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB3ENR_FMCEN_Enabled = 0x1
	// Position of QSPIEN field.
	RCC_AHB3ENR_QSPIEN_Pos = 0x1
	// Bit mask of QSPIEN field.
	RCC_AHB3ENR_QSPIEN_Msk = 0x2
	// Bit QSPIEN.
	RCC_AHB3ENR_QSPIEN = 0x2
	// The selected clock is disabled
	RCC_AHB3ENR_QSPIEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_AHB3ENR_QSPIEN_Enabled = 0x1

	// APB1ENR: APB1 peripheral clock enable register
	// Position of TIM2EN field.
	RCC_APB1ENR_TIM2EN_Pos = 0x0
	// Bit mask of TIM2EN field.
	RCC_APB1ENR_TIM2EN_Msk = 0x1
	// Bit TIM2EN.
	RCC_APB1ENR_TIM2EN = 0x1
	// The selected clock is disabled
	RCC_APB1ENR_TIM2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_TIM2EN_Enabled = 0x1
	// Position of TIM3EN field.
	RCC_APB1ENR_TIM3EN_Pos = 0x1
	// Bit mask of TIM3EN field.
	RCC_APB1ENR_TIM3EN_Msk = 0x2
	// Bit TIM3EN.
	RCC_APB1ENR_TIM3EN = 0x2
	// The selected clock is disabled
	RCC_APB1ENR_TIM3EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_TIM3EN_Enabled = 0x1
	// Position of TIM4EN field.
	RCC_APB1ENR_TIM4EN_Pos = 0x2
	// Bit mask of TIM4EN field.
	RCC_APB1ENR_TIM4EN_Msk = 0x4
	// Bit TIM4EN.
	RCC_APB1ENR_TIM4EN = 0x4
	// The selected clock is disabled
	RCC_APB1ENR_TIM4EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_TIM4EN_Enabled = 0x1
	// Position of TIM5EN field.
	RCC_APB1ENR_TIM5EN_Pos = 0x3
	// Bit mask of TIM5EN field.
	RCC_APB1ENR_TIM5EN_Msk = 0x8
	// Bit TIM5EN.
	RCC_APB1ENR_TIM5EN = 0x8
	// The selected clock is disabled
	RCC_APB1ENR_TIM5EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_TIM5EN_Enabled = 0x1
	// Position of TIM6EN field.
	RCC_APB1ENR_TIM6EN_Pos = 0x4
	// Bit mask of TIM6EN field.
	RCC_APB1ENR_TIM6EN_Msk = 0x10
	// Bit TIM6EN.
	RCC_APB1ENR_TIM6EN = 0x10
	// The selected clock is disabled
	RCC_APB1ENR_TIM6EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_TIM6EN_Enabled = 0x1
	// Position of TIM7EN field.
	RCC_APB1ENR_TIM7EN_Pos = 0x5
	// Bit mask of TIM7EN field.
	RCC_APB1ENR_TIM7EN_Msk = 0x20
	// Bit TIM7EN.
	RCC_APB1ENR_TIM7EN = 0x20
	// The selected clock is disabled
	RCC_APB1ENR_TIM7EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_TIM7EN_Enabled = 0x1
	// Position of TIM12EN field.
	RCC_APB1ENR_TIM12EN_Pos = 0x6
	// Bit mask of TIM12EN field.
	RCC_APB1ENR_TIM12EN_Msk = 0x40
	// Bit TIM12EN.
	RCC_APB1ENR_TIM12EN = 0x40
	// The selected clock is disabled
	RCC_APB1ENR_TIM12EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_TIM12EN_Enabled = 0x1
	// Position of TIM13EN field.
	RCC_APB1ENR_TIM13EN_Pos = 0x7
	// Bit mask of TIM13EN field.
	RCC_APB1ENR_TIM13EN_Msk = 0x80
	// Bit TIM13EN.
	RCC_APB1ENR_TIM13EN = 0x80
	// The selected clock is disabled
	RCC_APB1ENR_TIM13EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_TIM13EN_Enabled = 0x1
	// Position of TIM14EN field.
	RCC_APB1ENR_TIM14EN_Pos = 0x8
	// Bit mask of TIM14EN field.
	RCC_APB1ENR_TIM14EN_Msk = 0x100
	// Bit TIM14EN.
	RCC_APB1ENR_TIM14EN = 0x100
	// The selected clock is disabled
	RCC_APB1ENR_TIM14EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_TIM14EN_Enabled = 0x1
	// Position of WWDGEN field.
	RCC_APB1ENR_WWDGEN_Pos = 0xb
	// Bit mask of WWDGEN field.
	RCC_APB1ENR_WWDGEN_Msk = 0x800
	// Bit WWDGEN.
	RCC_APB1ENR_WWDGEN = 0x800
	// The selected clock is disabled
	RCC_APB1ENR_WWDGEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_WWDGEN_Enabled = 0x1
	// Position of SPI2EN field.
	RCC_APB1ENR_SPI2EN_Pos = 0xe
	// Bit mask of SPI2EN field.
	RCC_APB1ENR_SPI2EN_Msk = 0x4000
	// Bit SPI2EN.
	RCC_APB1ENR_SPI2EN = 0x4000
	// The selected clock is disabled
	RCC_APB1ENR_SPI2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_SPI2EN_Enabled = 0x1
	// Position of SPI3EN field.
	RCC_APB1ENR_SPI3EN_Pos = 0xf
	// Bit mask of SPI3EN field.
	RCC_APB1ENR_SPI3EN_Msk = 0x8000
	// Bit SPI3EN.
	RCC_APB1ENR_SPI3EN = 0x8000
	// The selected clock is disabled
	RCC_APB1ENR_SPI3EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_SPI3EN_Enabled = 0x1
	// Position of USART2EN field.
	RCC_APB1ENR_USART2EN_Pos = 0x11
	// Bit mask of USART2EN field.
	RCC_APB1ENR_USART2EN_Msk = 0x20000
	// Bit USART2EN.
	RCC_APB1ENR_USART2EN = 0x20000
	// The selected clock is disabled
	RCC_APB1ENR_USART2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_USART2EN_Enabled = 0x1
	// Position of USART3EN field.
	RCC_APB1ENR_USART3EN_Pos = 0x12
	// Bit mask of USART3EN field.
	RCC_APB1ENR_USART3EN_Msk = 0x40000
	// Bit USART3EN.
	RCC_APB1ENR_USART3EN = 0x40000
	// The selected clock is disabled
	RCC_APB1ENR_USART3EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_USART3EN_Enabled = 0x1
	// Position of UART4EN field.
	RCC_APB1ENR_UART4EN_Pos = 0x13
	// Bit mask of UART4EN field.
	RCC_APB1ENR_UART4EN_Msk = 0x80000
	// Bit UART4EN.
	RCC_APB1ENR_UART4EN = 0x80000
	// The selected clock is disabled
	RCC_APB1ENR_UART4EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_UART4EN_Enabled = 0x1
	// Position of UART5EN field.
	RCC_APB1ENR_UART5EN_Pos = 0x14
	// Bit mask of UART5EN field.
	RCC_APB1ENR_UART5EN_Msk = 0x100000
	// Bit UART5EN.
	RCC_APB1ENR_UART5EN = 0x100000
	// The selected clock is disabled
	RCC_APB1ENR_UART5EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_UART5EN_Enabled = 0x1
	// Position of I2C1EN field.
	RCC_APB1ENR_I2C1EN_Pos = 0x15
	// Bit mask of I2C1EN field.
	RCC_APB1ENR_I2C1EN_Msk = 0x200000
	// Bit I2C1EN.
	RCC_APB1ENR_I2C1EN = 0x200000
	// The selected clock is disabled
	RCC_APB1ENR_I2C1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_I2C1EN_Enabled = 0x1
	// Position of I2C2EN field.
	RCC_APB1ENR_I2C2EN_Pos = 0x16
	// Bit mask of I2C2EN field.
	RCC_APB1ENR_I2C2EN_Msk = 0x400000
	// Bit I2C2EN.
	RCC_APB1ENR_I2C2EN = 0x400000
	// The selected clock is disabled
	RCC_APB1ENR_I2C2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_I2C2EN_Enabled = 0x1
	// Position of I2C3EN field.
	RCC_APB1ENR_I2C3EN_Pos = 0x17
	// Bit mask of I2C3EN field.
	RCC_APB1ENR_I2C3EN_Msk = 0x800000
	// Bit I2C3EN.
	RCC_APB1ENR_I2C3EN = 0x800000
	// The selected clock is disabled
	RCC_APB1ENR_I2C3EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_I2C3EN_Enabled = 0x1
	// Position of CAN1EN field.
	RCC_APB1ENR_CAN1EN_Pos = 0x19
	// Bit mask of CAN1EN field.
	RCC_APB1ENR_CAN1EN_Msk = 0x2000000
	// Bit CAN1EN.
	RCC_APB1ENR_CAN1EN = 0x2000000
	// The selected clock is disabled
	RCC_APB1ENR_CAN1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_CAN1EN_Enabled = 0x1
	// Position of CAN2EN field.
	RCC_APB1ENR_CAN2EN_Pos = 0x1a
	// Bit mask of CAN2EN field.
	RCC_APB1ENR_CAN2EN_Msk = 0x4000000
	// Bit CAN2EN.
	RCC_APB1ENR_CAN2EN = 0x4000000
	// The selected clock is disabled
	RCC_APB1ENR_CAN2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_CAN2EN_Enabled = 0x1
	// Position of PWREN field.
	RCC_APB1ENR_PWREN_Pos = 0x1c
	// Bit mask of PWREN field.
	RCC_APB1ENR_PWREN_Msk = 0x10000000
	// Bit PWREN.
	RCC_APB1ENR_PWREN = 0x10000000
	// The selected clock is disabled
	RCC_APB1ENR_PWREN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_PWREN_Enabled = 0x1
	// Position of DACEN field.
	RCC_APB1ENR_DACEN_Pos = 0x1d
	// Bit mask of DACEN field.
	RCC_APB1ENR_DACEN_Msk = 0x20000000
	// Bit DACEN.
	RCC_APB1ENR_DACEN = 0x20000000
	// The selected clock is disabled
	RCC_APB1ENR_DACEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_DACEN_Enabled = 0x1
	// Position of UART7EN field.
	RCC_APB1ENR_UART7EN_Pos = 0x1e
	// Bit mask of UART7EN field.
	RCC_APB1ENR_UART7EN_Msk = 0x40000000
	// Bit UART7EN.
	RCC_APB1ENR_UART7EN = 0x40000000
	// The selected clock is disabled
	RCC_APB1ENR_UART7EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_UART7EN_Enabled = 0x1
	// Position of UART8EN field.
	RCC_APB1ENR_UART8EN_Pos = 0x1f
	// Bit mask of UART8EN field.
	RCC_APB1ENR_UART8EN_Msk = 0x80000000
	// Bit UART8EN.
	RCC_APB1ENR_UART8EN = 0x80000000
	// The selected clock is disabled
	RCC_APB1ENR_UART8EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_UART8EN_Enabled = 0x1
	// Position of SPDIFRXEN field.
	RCC_APB1ENR_SPDIFRXEN_Pos = 0x10
	// Bit mask of SPDIFRXEN field.
	RCC_APB1ENR_SPDIFRXEN_Msk = 0x10000
	// Bit SPDIFRXEN.
	RCC_APB1ENR_SPDIFRXEN = 0x10000
	// The selected clock is disabled
	RCC_APB1ENR_SPDIFRXEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_SPDIFRXEN_Enabled = 0x1
	// Position of CECEN field.
	RCC_APB1ENR_CECEN_Pos = 0x1b
	// Bit mask of CECEN field.
	RCC_APB1ENR_CECEN_Msk = 0x8000000
	// Bit CECEN.
	RCC_APB1ENR_CECEN = 0x8000000
	// The selected clock is disabled
	RCC_APB1ENR_CECEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_CECEN_Enabled = 0x1
	// Position of LPTIM1EN field.
	RCC_APB1ENR_LPTIM1EN_Pos = 0x9
	// Bit mask of LPTIM1EN field.
	RCC_APB1ENR_LPTIM1EN_Msk = 0x200
	// Bit LPTIM1EN.
	RCC_APB1ENR_LPTIM1EN = 0x200
	// The selected clock is disabled
	RCC_APB1ENR_LPTIM1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_LPTIM1EN_Enabled = 0x1
	// Position of I2C4EN field.
	RCC_APB1ENR_I2C4EN_Pos = 0x18
	// Bit mask of I2C4EN field.
	RCC_APB1ENR_I2C4EN_Msk = 0x1000000
	// Bit I2C4EN.
	RCC_APB1ENR_I2C4EN = 0x1000000
	// The selected clock is disabled
	RCC_APB1ENR_I2C4EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_I2C4EN_Enabled = 0x1
	// Position of CAN3EN field.
	RCC_APB1ENR_CAN3EN_Pos = 0xd
	// Bit mask of CAN3EN field.
	RCC_APB1ENR_CAN3EN_Msk = 0x2000
	// Bit CAN3EN.
	RCC_APB1ENR_CAN3EN = 0x2000
	// The selected clock is disabled
	RCC_APB1ENR_CAN3EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB1ENR_CAN3EN_Enabled = 0x1

	// APB2ENR: APB2 peripheral clock enable register
	// Position of TIM1EN field.
	RCC_APB2ENR_TIM1EN_Pos = 0x0
	// Bit mask of TIM1EN field.
	RCC_APB2ENR_TIM1EN_Msk = 0x1
	// Bit TIM1EN.
	RCC_APB2ENR_TIM1EN = 0x1
	// The selected clock is disabled
	RCC_APB2ENR_TIM1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_TIM1EN_Enabled = 0x1
	// Position of TIM8EN field.
	RCC_APB2ENR_TIM8EN_Pos = 0x1
	// Bit mask of TIM8EN field.
	RCC_APB2ENR_TIM8EN_Msk = 0x2
	// Bit TIM8EN.
	RCC_APB2ENR_TIM8EN = 0x2
	// The selected clock is disabled
	RCC_APB2ENR_TIM8EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_TIM8EN_Enabled = 0x1
	// Position of USART1EN field.
	RCC_APB2ENR_USART1EN_Pos = 0x4
	// Bit mask of USART1EN field.
	RCC_APB2ENR_USART1EN_Msk = 0x10
	// Bit USART1EN.
	RCC_APB2ENR_USART1EN = 0x10
	// The selected clock is disabled
	RCC_APB2ENR_USART1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_USART1EN_Enabled = 0x1
	// Position of USART6EN field.
	RCC_APB2ENR_USART6EN_Pos = 0x5
	// Bit mask of USART6EN field.
	RCC_APB2ENR_USART6EN_Msk = 0x20
	// Bit USART6EN.
	RCC_APB2ENR_USART6EN = 0x20
	// The selected clock is disabled
	RCC_APB2ENR_USART6EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_USART6EN_Enabled = 0x1
	// Position of ADC1EN field.
	RCC_APB2ENR_ADC1EN_Pos = 0x8
	// Bit mask of ADC1EN field.
	RCC_APB2ENR_ADC1EN_Msk = 0x100
	// Bit ADC1EN.
	RCC_APB2ENR_ADC1EN = 0x100
	// The selected clock is disabled
	RCC_APB2ENR_ADC1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_ADC1EN_Enabled = 0x1
	// Position of ADC2EN field.
	RCC_APB2ENR_ADC2EN_Pos = 0x9
	// Bit mask of ADC2EN field.
	RCC_APB2ENR_ADC2EN_Msk = 0x200
	// Bit ADC2EN.
	RCC_APB2ENR_ADC2EN = 0x200
	// The selected clock is disabled
	RCC_APB2ENR_ADC2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_ADC2EN_Enabled = 0x1
	// Position of ADC3EN field.
	RCC_APB2ENR_ADC3EN_Pos = 0xa
	// Bit mask of ADC3EN field.
	RCC_APB2ENR_ADC3EN_Msk = 0x400
	// Bit ADC3EN.
	RCC_APB2ENR_ADC3EN = 0x400
	// The selected clock is disabled
	RCC_APB2ENR_ADC3EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_ADC3EN_Enabled = 0x1
	// Position of SPI1EN field.
	RCC_APB2ENR_SPI1EN_Pos = 0xc
	// Bit mask of SPI1EN field.
	RCC_APB2ENR_SPI1EN_Msk = 0x1000
	// Bit SPI1EN.
	RCC_APB2ENR_SPI1EN = 0x1000
	// The selected clock is disabled
	RCC_APB2ENR_SPI1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_SPI1EN_Enabled = 0x1
	// Position of SPI4EN field.
	RCC_APB2ENR_SPI4EN_Pos = 0xd
	// Bit mask of SPI4EN field.
	RCC_APB2ENR_SPI4EN_Msk = 0x2000
	// Bit SPI4EN.
	RCC_APB2ENR_SPI4EN = 0x2000
	// The selected clock is disabled
	RCC_APB2ENR_SPI4EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_SPI4EN_Enabled = 0x1
	// Position of SYSCFGEN field.
	RCC_APB2ENR_SYSCFGEN_Pos = 0xe
	// Bit mask of SYSCFGEN field.
	RCC_APB2ENR_SYSCFGEN_Msk = 0x4000
	// Bit SYSCFGEN.
	RCC_APB2ENR_SYSCFGEN = 0x4000
	// The selected clock is disabled
	RCC_APB2ENR_SYSCFGEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_SYSCFGEN_Enabled = 0x1
	// Position of TIM9EN field.
	RCC_APB2ENR_TIM9EN_Pos = 0x10
	// Bit mask of TIM9EN field.
	RCC_APB2ENR_TIM9EN_Msk = 0x10000
	// Bit TIM9EN.
	RCC_APB2ENR_TIM9EN = 0x10000
	// The selected clock is disabled
	RCC_APB2ENR_TIM9EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_TIM9EN_Enabled = 0x1
	// Position of TIM10EN field.
	RCC_APB2ENR_TIM10EN_Pos = 0x11
	// Bit mask of TIM10EN field.
	RCC_APB2ENR_TIM10EN_Msk = 0x20000
	// Bit TIM10EN.
	RCC_APB2ENR_TIM10EN = 0x20000
	// The selected clock is disabled
	RCC_APB2ENR_TIM10EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_TIM10EN_Enabled = 0x1
	// Position of TIM11EN field.
	RCC_APB2ENR_TIM11EN_Pos = 0x12
	// Bit mask of TIM11EN field.
	RCC_APB2ENR_TIM11EN_Msk = 0x40000
	// Bit TIM11EN.
	RCC_APB2ENR_TIM11EN = 0x40000
	// The selected clock is disabled
	RCC_APB2ENR_TIM11EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_TIM11EN_Enabled = 0x1
	// Position of SPI5EN field.
	RCC_APB2ENR_SPI5EN_Pos = 0x14
	// Bit mask of SPI5EN field.
	RCC_APB2ENR_SPI5EN_Msk = 0x100000
	// Bit SPI5EN.
	RCC_APB2ENR_SPI5EN = 0x100000
	// The selected clock is disabled
	RCC_APB2ENR_SPI5EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_SPI5EN_Enabled = 0x1
	// Position of SPI6EN field.
	RCC_APB2ENR_SPI6EN_Pos = 0x15
	// Bit mask of SPI6EN field.
	RCC_APB2ENR_SPI6EN_Msk = 0x200000
	// Bit SPI6EN.
	RCC_APB2ENR_SPI6EN = 0x200000
	// The selected clock is disabled
	RCC_APB2ENR_SPI6EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_SPI6EN_Enabled = 0x1
	// Position of SAI1EN field.
	RCC_APB2ENR_SAI1EN_Pos = 0x16
	// Bit mask of SAI1EN field.
	RCC_APB2ENR_SAI1EN_Msk = 0x400000
	// Bit SAI1EN.
	RCC_APB2ENR_SAI1EN = 0x400000
	// The selected clock is disabled
	RCC_APB2ENR_SAI1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_SAI1EN_Enabled = 0x1
	// Position of LTDCEN field.
	RCC_APB2ENR_LTDCEN_Pos = 0x1a
	// Bit mask of LTDCEN field.
	RCC_APB2ENR_LTDCEN_Msk = 0x4000000
	// Bit LTDCEN.
	RCC_APB2ENR_LTDCEN = 0x4000000
	// The selected clock is disabled
	RCC_APB2ENR_LTDCEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_LTDCEN_Enabled = 0x1
	// Position of SAI2EN field.
	RCC_APB2ENR_SAI2EN_Pos = 0x17
	// Bit mask of SAI2EN field.
	RCC_APB2ENR_SAI2EN_Msk = 0x800000
	// Bit SAI2EN.
	RCC_APB2ENR_SAI2EN = 0x800000
	// The selected clock is disabled
	RCC_APB2ENR_SAI2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_SAI2EN_Enabled = 0x1
	// Position of SDMMC1EN field.
	RCC_APB2ENR_SDMMC1EN_Pos = 0xb
	// Bit mask of SDMMC1EN field.
	RCC_APB2ENR_SDMMC1EN_Msk = 0x800
	// Bit SDMMC1EN.
	RCC_APB2ENR_SDMMC1EN = 0x800
	// The selected clock is disabled
	RCC_APB2ENR_SDMMC1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_SDMMC1EN_Enabled = 0x1
	// Position of MDIOEN field.
	RCC_APB2ENR_MDIOEN_Pos = 0x1e
	// Bit mask of MDIOEN field.
	RCC_APB2ENR_MDIOEN_Msk = 0x40000000
	// Bit MDIOEN.
	RCC_APB2ENR_MDIOEN = 0x40000000
	// The selected clock is disabled
	RCC_APB2ENR_MDIOEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_MDIOEN_Enabled = 0x1
	// Position of DFSDM1EN field.
	RCC_APB2ENR_DFSDM1EN_Pos = 0x1d
	// Bit mask of DFSDM1EN field.
	RCC_APB2ENR_DFSDM1EN_Msk = 0x20000000
	// Bit DFSDM1EN.
	RCC_APB2ENR_DFSDM1EN = 0x20000000
	// The selected clock is disabled
	RCC_APB2ENR_DFSDM1EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_DFSDM1EN_Enabled = 0x1
	// Position of DSIEN field.
	RCC_APB2ENR_DSIEN_Pos = 0x1b
	// Bit mask of DSIEN field.
	RCC_APB2ENR_DSIEN_Msk = 0x8000000
	// Bit DSIEN.
	RCC_APB2ENR_DSIEN = 0x8000000
	// The selected clock is disabled
	RCC_APB2ENR_DSIEN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_DSIEN_Enabled = 0x1
	// Position of SDMMC2EN field.
	RCC_APB2ENR_SDMMC2EN_Pos = 0x7
	// Bit mask of SDMMC2EN field.
	RCC_APB2ENR_SDMMC2EN_Msk = 0x80
	// Bit SDMMC2EN.
	RCC_APB2ENR_SDMMC2EN = 0x80
	// The selected clock is disabled
	RCC_APB2ENR_SDMMC2EN_Disabled = 0x0
	// The selected clock is enabled
	RCC_APB2ENR_SDMMC2EN_Enabled = 0x1

	// AHB1LPENR: AHB1 peripheral clock enable in low power mode register
	// Position of GPIOALPEN field.
	RCC_AHB1LPENR_GPIOALPEN_Pos = 0x0
	// Bit mask of GPIOALPEN field.
	RCC_AHB1LPENR_GPIOALPEN_Msk = 0x1
	// Bit GPIOALPEN.
	RCC_AHB1LPENR_GPIOALPEN = 0x1
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_GPIOALPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_GPIOALPEN_EnabledInSleep = 0x1
	// Position of GPIOBLPEN field.
	RCC_AHB1LPENR_GPIOBLPEN_Pos = 0x1
	// Bit mask of GPIOBLPEN field.
	RCC_AHB1LPENR_GPIOBLPEN_Msk = 0x2
	// Bit GPIOBLPEN.
	RCC_AHB1LPENR_GPIOBLPEN = 0x2
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_GPIOBLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_GPIOBLPEN_EnabledInSleep = 0x1
	// Position of GPIOCLPEN field.
	RCC_AHB1LPENR_GPIOCLPEN_Pos = 0x2
	// Bit mask of GPIOCLPEN field.
	RCC_AHB1LPENR_GPIOCLPEN_Msk = 0x4
	// Bit GPIOCLPEN.
	RCC_AHB1LPENR_GPIOCLPEN = 0x4
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_GPIOCLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_GPIOCLPEN_EnabledInSleep = 0x1
	// Position of GPIODLPEN field.
	RCC_AHB1LPENR_GPIODLPEN_Pos = 0x3
	// Bit mask of GPIODLPEN field.
	RCC_AHB1LPENR_GPIODLPEN_Msk = 0x8
	// Bit GPIODLPEN.
	RCC_AHB1LPENR_GPIODLPEN = 0x8
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_GPIODLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_GPIODLPEN_EnabledInSleep = 0x1
	// Position of GPIOELPEN field.
	RCC_AHB1LPENR_GPIOELPEN_Pos = 0x4
	// Bit mask of GPIOELPEN field.
	RCC_AHB1LPENR_GPIOELPEN_Msk = 0x10
	// Bit GPIOELPEN.
	RCC_AHB1LPENR_GPIOELPEN = 0x10
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_GPIOELPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_GPIOELPEN_EnabledInSleep = 0x1
	// Position of GPIOFLPEN field.
	RCC_AHB1LPENR_GPIOFLPEN_Pos = 0x5
	// Bit mask of GPIOFLPEN field.
	RCC_AHB1LPENR_GPIOFLPEN_Msk = 0x20
	// Bit GPIOFLPEN.
	RCC_AHB1LPENR_GPIOFLPEN = 0x20
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_GPIOFLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_GPIOFLPEN_EnabledInSleep = 0x1
	// Position of GPIOGLPEN field.
	RCC_AHB1LPENR_GPIOGLPEN_Pos = 0x6
	// Bit mask of GPIOGLPEN field.
	RCC_AHB1LPENR_GPIOGLPEN_Msk = 0x40
	// Bit GPIOGLPEN.
	RCC_AHB1LPENR_GPIOGLPEN = 0x40
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_GPIOGLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_GPIOGLPEN_EnabledInSleep = 0x1
	// Position of GPIOHLPEN field.
	RCC_AHB1LPENR_GPIOHLPEN_Pos = 0x7
	// Bit mask of GPIOHLPEN field.
	RCC_AHB1LPENR_GPIOHLPEN_Msk = 0x80
	// Bit GPIOHLPEN.
	RCC_AHB1LPENR_GPIOHLPEN = 0x80
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_GPIOHLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_GPIOHLPEN_EnabledInSleep = 0x1
	// Position of GPIOILPEN field.
	RCC_AHB1LPENR_GPIOILPEN_Pos = 0x8
	// Bit mask of GPIOILPEN field.
	RCC_AHB1LPENR_GPIOILPEN_Msk = 0x100
	// Bit GPIOILPEN.
	RCC_AHB1LPENR_GPIOILPEN = 0x100
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_GPIOILPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_GPIOILPEN_EnabledInSleep = 0x1
	// Position of GPIOJLPEN field.
	RCC_AHB1LPENR_GPIOJLPEN_Pos = 0x9
	// Bit mask of GPIOJLPEN field.
	RCC_AHB1LPENR_GPIOJLPEN_Msk = 0x200
	// Bit GPIOJLPEN.
	RCC_AHB1LPENR_GPIOJLPEN = 0x200
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_GPIOJLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_GPIOJLPEN_EnabledInSleep = 0x1
	// Position of GPIOKLPEN field.
	RCC_AHB1LPENR_GPIOKLPEN_Pos = 0xa
	// Bit mask of GPIOKLPEN field.
	RCC_AHB1LPENR_GPIOKLPEN_Msk = 0x400
	// Bit GPIOKLPEN.
	RCC_AHB1LPENR_GPIOKLPEN = 0x400
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_GPIOKLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_GPIOKLPEN_EnabledInSleep = 0x1
	// Position of CRCLPEN field.
	RCC_AHB1LPENR_CRCLPEN_Pos = 0xc
	// Bit mask of CRCLPEN field.
	RCC_AHB1LPENR_CRCLPEN_Msk = 0x1000
	// Bit CRCLPEN.
	RCC_AHB1LPENR_CRCLPEN = 0x1000
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_CRCLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_CRCLPEN_EnabledInSleep = 0x1
	// Position of FLITFLPEN field.
	RCC_AHB1LPENR_FLITFLPEN_Pos = 0xf
	// Bit mask of FLITFLPEN field.
	RCC_AHB1LPENR_FLITFLPEN_Msk = 0x8000
	// Bit FLITFLPEN.
	RCC_AHB1LPENR_FLITFLPEN = 0x8000
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_FLITFLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_FLITFLPEN_EnabledInSleep = 0x1
	// Position of SRAM1LPEN field.
	RCC_AHB1LPENR_SRAM1LPEN_Pos = 0x10
	// Bit mask of SRAM1LPEN field.
	RCC_AHB1LPENR_SRAM1LPEN_Msk = 0x10000
	// Bit SRAM1LPEN.
	RCC_AHB1LPENR_SRAM1LPEN = 0x10000
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_SRAM1LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_SRAM1LPEN_EnabledInSleep = 0x1
	// Position of SRAM2LPEN field.
	RCC_AHB1LPENR_SRAM2LPEN_Pos = 0x11
	// Bit mask of SRAM2LPEN field.
	RCC_AHB1LPENR_SRAM2LPEN_Msk = 0x20000
	// Bit SRAM2LPEN.
	RCC_AHB1LPENR_SRAM2LPEN = 0x20000
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_SRAM2LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_SRAM2LPEN_EnabledInSleep = 0x1
	// Position of BKPSRAMLPEN field.
	RCC_AHB1LPENR_BKPSRAMLPEN_Pos = 0x12
	// Bit mask of BKPSRAMLPEN field.
	RCC_AHB1LPENR_BKPSRAMLPEN_Msk = 0x40000
	// Bit BKPSRAMLPEN.
	RCC_AHB1LPENR_BKPSRAMLPEN = 0x40000
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_BKPSRAMLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_BKPSRAMLPEN_EnabledInSleep = 0x1
	// Position of SRAM3LPEN field.
	RCC_AHB1LPENR_SRAM3LPEN_Pos = 0x13
	// Bit mask of SRAM3LPEN field.
	RCC_AHB1LPENR_SRAM3LPEN_Msk = 0x80000
	// Bit SRAM3LPEN.
	RCC_AHB1LPENR_SRAM3LPEN = 0x80000
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_SRAM3LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_SRAM3LPEN_EnabledInSleep = 0x1
	// Position of DMA1LPEN field.
	RCC_AHB1LPENR_DMA1LPEN_Pos = 0x15
	// Bit mask of DMA1LPEN field.
	RCC_AHB1LPENR_DMA1LPEN_Msk = 0x200000
	// Bit DMA1LPEN.
	RCC_AHB1LPENR_DMA1LPEN = 0x200000
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_DMA1LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_DMA1LPEN_EnabledInSleep = 0x1
	// Position of DMA2LPEN field.
	RCC_AHB1LPENR_DMA2LPEN_Pos = 0x16
	// Bit mask of DMA2LPEN field.
	RCC_AHB1LPENR_DMA2LPEN_Msk = 0x400000
	// Bit DMA2LPEN.
	RCC_AHB1LPENR_DMA2LPEN = 0x400000
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_DMA2LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_DMA2LPEN_EnabledInSleep = 0x1
	// Position of DMA2DLPEN field.
	RCC_AHB1LPENR_DMA2DLPEN_Pos = 0x17
	// Bit mask of DMA2DLPEN field.
	RCC_AHB1LPENR_DMA2DLPEN_Msk = 0x800000
	// Bit DMA2DLPEN.
	RCC_AHB1LPENR_DMA2DLPEN = 0x800000
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_DMA2DLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_DMA2DLPEN_EnabledInSleep = 0x1
	// Position of ETHMACLPEN field.
	RCC_AHB1LPENR_ETHMACLPEN_Pos = 0x19
	// Bit mask of ETHMACLPEN field.
	RCC_AHB1LPENR_ETHMACLPEN_Msk = 0x2000000
	// Bit ETHMACLPEN.
	RCC_AHB1LPENR_ETHMACLPEN = 0x2000000
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_ETHMACLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_ETHMACLPEN_EnabledInSleep = 0x1
	// Position of ETHMACTXLPEN field.
	RCC_AHB1LPENR_ETHMACTXLPEN_Pos = 0x1a
	// Bit mask of ETHMACTXLPEN field.
	RCC_AHB1LPENR_ETHMACTXLPEN_Msk = 0x4000000
	// Bit ETHMACTXLPEN.
	RCC_AHB1LPENR_ETHMACTXLPEN = 0x4000000
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_ETHMACTXLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_ETHMACTXLPEN_EnabledInSleep = 0x1
	// Position of ETHMACRXLPEN field.
	RCC_AHB1LPENR_ETHMACRXLPEN_Pos = 0x1b
	// Bit mask of ETHMACRXLPEN field.
	RCC_AHB1LPENR_ETHMACRXLPEN_Msk = 0x8000000
	// Bit ETHMACRXLPEN.
	RCC_AHB1LPENR_ETHMACRXLPEN = 0x8000000
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_ETHMACRXLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_ETHMACRXLPEN_EnabledInSleep = 0x1
	// Position of ETHMACPTPLPEN field.
	RCC_AHB1LPENR_ETHMACPTPLPEN_Pos = 0x1c
	// Bit mask of ETHMACPTPLPEN field.
	RCC_AHB1LPENR_ETHMACPTPLPEN_Msk = 0x10000000
	// Bit ETHMACPTPLPEN.
	RCC_AHB1LPENR_ETHMACPTPLPEN = 0x10000000
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_ETHMACPTPLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_ETHMACPTPLPEN_EnabledInSleep = 0x1
	// Position of OTGHSLPEN field.
	RCC_AHB1LPENR_OTGHSLPEN_Pos = 0x1d
	// Bit mask of OTGHSLPEN field.
	RCC_AHB1LPENR_OTGHSLPEN_Msk = 0x20000000
	// Bit OTGHSLPEN.
	RCC_AHB1LPENR_OTGHSLPEN = 0x20000000
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_OTGHSLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_OTGHSLPEN_EnabledInSleep = 0x1
	// Position of OTGHSULPILPEN field.
	RCC_AHB1LPENR_OTGHSULPILPEN_Pos = 0x1e
	// Bit mask of OTGHSULPILPEN field.
	RCC_AHB1LPENR_OTGHSULPILPEN_Msk = 0x40000000
	// Bit OTGHSULPILPEN.
	RCC_AHB1LPENR_OTGHSULPILPEN = 0x40000000
	// Selected module is disabled during Sleep mode
	RCC_AHB1LPENR_OTGHSULPILPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB1LPENR_OTGHSULPILPEN_EnabledInSleep = 0x1
	// Position of AXILPEN field.
	RCC_AHB1LPENR_AXILPEN_Pos = 0xd
	// Bit mask of AXILPEN field.
	RCC_AHB1LPENR_AXILPEN_Msk = 0x2000
	// Bit AXILPEN.
	RCC_AHB1LPENR_AXILPEN = 0x2000
	// Position of DTCMLPEN field.
	RCC_AHB1LPENR_DTCMLPEN_Pos = 0x14
	// Bit mask of DTCMLPEN field.
	RCC_AHB1LPENR_DTCMLPEN_Msk = 0x100000
	// Bit DTCMLPEN.
	RCC_AHB1LPENR_DTCMLPEN = 0x100000

	// AHB2LPENR: AHB2 peripheral clock enable in low power mode register
	// Position of OTGFSLPEN field.
	RCC_AHB2LPENR_OTGFSLPEN_Pos = 0x7
	// Bit mask of OTGFSLPEN field.
	RCC_AHB2LPENR_OTGFSLPEN_Msk = 0x80
	// Bit OTGFSLPEN.
	RCC_AHB2LPENR_OTGFSLPEN = 0x80
	// Selected module is disabled during Sleep mode
	RCC_AHB2LPENR_OTGFSLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB2LPENR_OTGFSLPEN_EnabledInSleep = 0x1
	// Position of RNGLPEN field.
	RCC_AHB2LPENR_RNGLPEN_Pos = 0x6
	// Bit mask of RNGLPEN field.
	RCC_AHB2LPENR_RNGLPEN_Msk = 0x40
	// Bit RNGLPEN.
	RCC_AHB2LPENR_RNGLPEN = 0x40
	// Selected module is disabled during Sleep mode
	RCC_AHB2LPENR_RNGLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB2LPENR_RNGLPEN_EnabledInSleep = 0x1
	// Position of HASHLPEN field.
	RCC_AHB2LPENR_HASHLPEN_Pos = 0x5
	// Bit mask of HASHLPEN field.
	RCC_AHB2LPENR_HASHLPEN_Msk = 0x20
	// Bit HASHLPEN.
	RCC_AHB2LPENR_HASHLPEN = 0x20
	// Selected module is disabled during Sleep mode
	RCC_AHB2LPENR_HASHLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB2LPENR_HASHLPEN_EnabledInSleep = 0x1
	// Position of CRYPLPEN field.
	RCC_AHB2LPENR_CRYPLPEN_Pos = 0x4
	// Bit mask of CRYPLPEN field.
	RCC_AHB2LPENR_CRYPLPEN_Msk = 0x10
	// Bit CRYPLPEN.
	RCC_AHB2LPENR_CRYPLPEN = 0x10
	// Selected module is disabled during Sleep mode
	RCC_AHB2LPENR_CRYPLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB2LPENR_CRYPLPEN_EnabledInSleep = 0x1
	// Position of DCMILPEN field.
	RCC_AHB2LPENR_DCMILPEN_Pos = 0x0
	// Bit mask of DCMILPEN field.
	RCC_AHB2LPENR_DCMILPEN_Msk = 0x1
	// Bit DCMILPEN.
	RCC_AHB2LPENR_DCMILPEN = 0x1
	// Selected module is disabled during Sleep mode
	RCC_AHB2LPENR_DCMILPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB2LPENR_DCMILPEN_EnabledInSleep = 0x1
	// Position of JPEGLPEN field.
	RCC_AHB2LPENR_JPEGLPEN_Pos = 0x1
	// Bit mask of JPEGLPEN field.
	RCC_AHB2LPENR_JPEGLPEN_Msk = 0x2
	// Bit JPEGLPEN.
	RCC_AHB2LPENR_JPEGLPEN = 0x2

	// AHB3LPENR: AHB3 peripheral clock enable in low power mode register
	// Position of FMCLPEN field.
	RCC_AHB3LPENR_FMCLPEN_Pos = 0x0
	// Bit mask of FMCLPEN field.
	RCC_AHB3LPENR_FMCLPEN_Msk = 0x1
	// Bit FMCLPEN.
	RCC_AHB3LPENR_FMCLPEN = 0x1
	// Selected module is disabled during Sleep mode
	RCC_AHB3LPENR_FMCLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB3LPENR_FMCLPEN_EnabledInSleep = 0x1
	// Position of QSPILPEN field.
	RCC_AHB3LPENR_QSPILPEN_Pos = 0x1
	// Bit mask of QSPILPEN field.
	RCC_AHB3LPENR_QSPILPEN_Msk = 0x2
	// Bit QSPILPEN.
	RCC_AHB3LPENR_QSPILPEN = 0x2
	// Selected module is disabled during Sleep mode
	RCC_AHB3LPENR_QSPILPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_AHB3LPENR_QSPILPEN_EnabledInSleep = 0x1

	// APB1LPENR: APB1 peripheral clock enable in low power mode register
	// Position of TIM2LPEN field.
	RCC_APB1LPENR_TIM2LPEN_Pos = 0x0
	// Bit mask of TIM2LPEN field.
	RCC_APB1LPENR_TIM2LPEN_Msk = 0x1
	// Bit TIM2LPEN.
	RCC_APB1LPENR_TIM2LPEN = 0x1
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_TIM2LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_TIM2LPEN_EnabledInSleep = 0x1
	// Position of TIM3LPEN field.
	RCC_APB1LPENR_TIM3LPEN_Pos = 0x1
	// Bit mask of TIM3LPEN field.
	RCC_APB1LPENR_TIM3LPEN_Msk = 0x2
	// Bit TIM3LPEN.
	RCC_APB1LPENR_TIM3LPEN = 0x2
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_TIM3LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_TIM3LPEN_EnabledInSleep = 0x1
	// Position of TIM4LPEN field.
	RCC_APB1LPENR_TIM4LPEN_Pos = 0x2
	// Bit mask of TIM4LPEN field.
	RCC_APB1LPENR_TIM4LPEN_Msk = 0x4
	// Bit TIM4LPEN.
	RCC_APB1LPENR_TIM4LPEN = 0x4
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_TIM4LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_TIM4LPEN_EnabledInSleep = 0x1
	// Position of TIM5LPEN field.
	RCC_APB1LPENR_TIM5LPEN_Pos = 0x3
	// Bit mask of TIM5LPEN field.
	RCC_APB1LPENR_TIM5LPEN_Msk = 0x8
	// Bit TIM5LPEN.
	RCC_APB1LPENR_TIM5LPEN = 0x8
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_TIM5LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_TIM5LPEN_EnabledInSleep = 0x1
	// Position of TIM6LPEN field.
	RCC_APB1LPENR_TIM6LPEN_Pos = 0x4
	// Bit mask of TIM6LPEN field.
	RCC_APB1LPENR_TIM6LPEN_Msk = 0x10
	// Bit TIM6LPEN.
	RCC_APB1LPENR_TIM6LPEN = 0x10
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_TIM6LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_TIM6LPEN_EnabledInSleep = 0x1
	// Position of TIM7LPEN field.
	RCC_APB1LPENR_TIM7LPEN_Pos = 0x5
	// Bit mask of TIM7LPEN field.
	RCC_APB1LPENR_TIM7LPEN_Msk = 0x20
	// Bit TIM7LPEN.
	RCC_APB1LPENR_TIM7LPEN = 0x20
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_TIM7LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_TIM7LPEN_EnabledInSleep = 0x1
	// Position of TIM12LPEN field.
	RCC_APB1LPENR_TIM12LPEN_Pos = 0x6
	// Bit mask of TIM12LPEN field.
	RCC_APB1LPENR_TIM12LPEN_Msk = 0x40
	// Bit TIM12LPEN.
	RCC_APB1LPENR_TIM12LPEN = 0x40
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_TIM12LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_TIM12LPEN_EnabledInSleep = 0x1
	// Position of TIM13LPEN field.
	RCC_APB1LPENR_TIM13LPEN_Pos = 0x7
	// Bit mask of TIM13LPEN field.
	RCC_APB1LPENR_TIM13LPEN_Msk = 0x80
	// Bit TIM13LPEN.
	RCC_APB1LPENR_TIM13LPEN = 0x80
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_TIM13LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_TIM13LPEN_EnabledInSleep = 0x1
	// Position of TIM14LPEN field.
	RCC_APB1LPENR_TIM14LPEN_Pos = 0x8
	// Bit mask of TIM14LPEN field.
	RCC_APB1LPENR_TIM14LPEN_Msk = 0x100
	// Bit TIM14LPEN.
	RCC_APB1LPENR_TIM14LPEN = 0x100
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_TIM14LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_TIM14LPEN_EnabledInSleep = 0x1
	// Position of WWDGLPEN field.
	RCC_APB1LPENR_WWDGLPEN_Pos = 0xb
	// Bit mask of WWDGLPEN field.
	RCC_APB1LPENR_WWDGLPEN_Msk = 0x800
	// Bit WWDGLPEN.
	RCC_APB1LPENR_WWDGLPEN = 0x800
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_WWDGLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_WWDGLPEN_EnabledInSleep = 0x1
	// Position of SPI2LPEN field.
	RCC_APB1LPENR_SPI2LPEN_Pos = 0xe
	// Bit mask of SPI2LPEN field.
	RCC_APB1LPENR_SPI2LPEN_Msk = 0x4000
	// Bit SPI2LPEN.
	RCC_APB1LPENR_SPI2LPEN = 0x4000
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_SPI2LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_SPI2LPEN_EnabledInSleep = 0x1
	// Position of SPI3LPEN field.
	RCC_APB1LPENR_SPI3LPEN_Pos = 0xf
	// Bit mask of SPI3LPEN field.
	RCC_APB1LPENR_SPI3LPEN_Msk = 0x8000
	// Bit SPI3LPEN.
	RCC_APB1LPENR_SPI3LPEN = 0x8000
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_SPI3LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_SPI3LPEN_EnabledInSleep = 0x1
	// Position of USART2LPEN field.
	RCC_APB1LPENR_USART2LPEN_Pos = 0x11
	// Bit mask of USART2LPEN field.
	RCC_APB1LPENR_USART2LPEN_Msk = 0x20000
	// Bit USART2LPEN.
	RCC_APB1LPENR_USART2LPEN = 0x20000
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_USART2LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_USART2LPEN_EnabledInSleep = 0x1
	// Position of USART3LPEN field.
	RCC_APB1LPENR_USART3LPEN_Pos = 0x12
	// Bit mask of USART3LPEN field.
	RCC_APB1LPENR_USART3LPEN_Msk = 0x40000
	// Bit USART3LPEN.
	RCC_APB1LPENR_USART3LPEN = 0x40000
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_USART3LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_USART3LPEN_EnabledInSleep = 0x1
	// Position of UART4LPEN field.
	RCC_APB1LPENR_UART4LPEN_Pos = 0x13
	// Bit mask of UART4LPEN field.
	RCC_APB1LPENR_UART4LPEN_Msk = 0x80000
	// Bit UART4LPEN.
	RCC_APB1LPENR_UART4LPEN = 0x80000
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_UART4LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_UART4LPEN_EnabledInSleep = 0x1
	// Position of UART5LPEN field.
	RCC_APB1LPENR_UART5LPEN_Pos = 0x14
	// Bit mask of UART5LPEN field.
	RCC_APB1LPENR_UART5LPEN_Msk = 0x100000
	// Bit UART5LPEN.
	RCC_APB1LPENR_UART5LPEN = 0x100000
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_UART5LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_UART5LPEN_EnabledInSleep = 0x1
	// Position of I2C1LPEN field.
	RCC_APB1LPENR_I2C1LPEN_Pos = 0x15
	// Bit mask of I2C1LPEN field.
	RCC_APB1LPENR_I2C1LPEN_Msk = 0x200000
	// Bit I2C1LPEN.
	RCC_APB1LPENR_I2C1LPEN = 0x200000
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_I2C1LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_I2C1LPEN_EnabledInSleep = 0x1
	// Position of I2C2LPEN field.
	RCC_APB1LPENR_I2C2LPEN_Pos = 0x16
	// Bit mask of I2C2LPEN field.
	RCC_APB1LPENR_I2C2LPEN_Msk = 0x400000
	// Bit I2C2LPEN.
	RCC_APB1LPENR_I2C2LPEN = 0x400000
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_I2C2LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_I2C2LPEN_EnabledInSleep = 0x1
	// Position of I2C3LPEN field.
	RCC_APB1LPENR_I2C3LPEN_Pos = 0x17
	// Bit mask of I2C3LPEN field.
	RCC_APB1LPENR_I2C3LPEN_Msk = 0x800000
	// Bit I2C3LPEN.
	RCC_APB1LPENR_I2C3LPEN = 0x800000
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_I2C3LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_I2C3LPEN_EnabledInSleep = 0x1
	// Position of CAN1LPEN field.
	RCC_APB1LPENR_CAN1LPEN_Pos = 0x19
	// Bit mask of CAN1LPEN field.
	RCC_APB1LPENR_CAN1LPEN_Msk = 0x2000000
	// Bit CAN1LPEN.
	RCC_APB1LPENR_CAN1LPEN = 0x2000000
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_CAN1LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_CAN1LPEN_EnabledInSleep = 0x1
	// Position of CAN2LPEN field.
	RCC_APB1LPENR_CAN2LPEN_Pos = 0x1a
	// Bit mask of CAN2LPEN field.
	RCC_APB1LPENR_CAN2LPEN_Msk = 0x4000000
	// Bit CAN2LPEN.
	RCC_APB1LPENR_CAN2LPEN = 0x4000000
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_CAN2LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_CAN2LPEN_EnabledInSleep = 0x1
	// Position of PWRLPEN field.
	RCC_APB1LPENR_PWRLPEN_Pos = 0x1c
	// Bit mask of PWRLPEN field.
	RCC_APB1LPENR_PWRLPEN_Msk = 0x10000000
	// Bit PWRLPEN.
	RCC_APB1LPENR_PWRLPEN = 0x10000000
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_PWRLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_PWRLPEN_EnabledInSleep = 0x1
	// Position of DACLPEN field.
	RCC_APB1LPENR_DACLPEN_Pos = 0x1d
	// Bit mask of DACLPEN field.
	RCC_APB1LPENR_DACLPEN_Msk = 0x20000000
	// Bit DACLPEN.
	RCC_APB1LPENR_DACLPEN = 0x20000000
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_DACLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_DACLPEN_EnabledInSleep = 0x1
	// Position of UART7LPEN field.
	RCC_APB1LPENR_UART7LPEN_Pos = 0x1e
	// Bit mask of UART7LPEN field.
	RCC_APB1LPENR_UART7LPEN_Msk = 0x40000000
	// Bit UART7LPEN.
	RCC_APB1LPENR_UART7LPEN = 0x40000000
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_UART7LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_UART7LPEN_EnabledInSleep = 0x1
	// Position of UART8LPEN field.
	RCC_APB1LPENR_UART8LPEN_Pos = 0x1f
	// Bit mask of UART8LPEN field.
	RCC_APB1LPENR_UART8LPEN_Msk = 0x80000000
	// Bit UART8LPEN.
	RCC_APB1LPENR_UART8LPEN = 0x80000000
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_UART8LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_UART8LPEN_EnabledInSleep = 0x1
	// Position of SPDIFRXLPEN field.
	RCC_APB1LPENR_SPDIFRXLPEN_Pos = 0x10
	// Bit mask of SPDIFRXLPEN field.
	RCC_APB1LPENR_SPDIFRXLPEN_Msk = 0x10000
	// Bit SPDIFRXLPEN.
	RCC_APB1LPENR_SPDIFRXLPEN = 0x10000
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_SPDIFRXLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_SPDIFRXLPEN_EnabledInSleep = 0x1
	// Position of CECLPEN field.
	RCC_APB1LPENR_CECLPEN_Pos = 0x1b
	// Bit mask of CECLPEN field.
	RCC_APB1LPENR_CECLPEN_Msk = 0x8000000
	// Bit CECLPEN.
	RCC_APB1LPENR_CECLPEN = 0x8000000
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_CECLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_CECLPEN_EnabledInSleep = 0x1
	// Position of LPTIM1LPEN field.
	RCC_APB1LPENR_LPTIM1LPEN_Pos = 0x9
	// Bit mask of LPTIM1LPEN field.
	RCC_APB1LPENR_LPTIM1LPEN_Msk = 0x200
	// Bit LPTIM1LPEN.
	RCC_APB1LPENR_LPTIM1LPEN = 0x200
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_LPTIM1LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_LPTIM1LPEN_EnabledInSleep = 0x1
	// Position of I2C4LPEN field.
	RCC_APB1LPENR_I2C4LPEN_Pos = 0x18
	// Bit mask of I2C4LPEN field.
	RCC_APB1LPENR_I2C4LPEN_Msk = 0x1000000
	// Bit I2C4LPEN.
	RCC_APB1LPENR_I2C4LPEN = 0x1000000
	// Selected module is disabled during Sleep mode
	RCC_APB1LPENR_I2C4LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB1LPENR_I2C4LPEN_EnabledInSleep = 0x1
	// Position of CAN3LPEN field.
	RCC_APB1LPENR_CAN3LPEN_Pos = 0xd
	// Bit mask of CAN3LPEN field.
	RCC_APB1LPENR_CAN3LPEN_Msk = 0x2000
	// Bit CAN3LPEN.
	RCC_APB1LPENR_CAN3LPEN = 0x2000

	// APB2LPENR: APB2 peripheral clock enabled in low power mode register
	// Position of TIM1LPEN field.
	RCC_APB2LPENR_TIM1LPEN_Pos = 0x0
	// Bit mask of TIM1LPEN field.
	RCC_APB2LPENR_TIM1LPEN_Msk = 0x1
	// Bit TIM1LPEN.
	RCC_APB2LPENR_TIM1LPEN = 0x1
	// Selected module is disabled during Sleep mode
	RCC_APB2LPENR_TIM1LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB2LPENR_TIM1LPEN_EnabledInSleep = 0x1
	// Position of TIM8LPEN field.
	RCC_APB2LPENR_TIM8LPEN_Pos = 0x1
	// Bit mask of TIM8LPEN field.
	RCC_APB2LPENR_TIM8LPEN_Msk = 0x2
	// Bit TIM8LPEN.
	RCC_APB2LPENR_TIM8LPEN = 0x2
	// Selected module is disabled during Sleep mode
	RCC_APB2LPENR_TIM8LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB2LPENR_TIM8LPEN_EnabledInSleep = 0x1
	// Position of USART1LPEN field.
	RCC_APB2LPENR_USART1LPEN_Pos = 0x4
	// Bit mask of USART1LPEN field.
	RCC_APB2LPENR_USART1LPEN_Msk = 0x10
	// Bit USART1LPEN.
	RCC_APB2LPENR_USART1LPEN = 0x10
	// Selected module is disabled during Sleep mode
	RCC_APB2LPENR_USART1LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB2LPENR_USART1LPEN_EnabledInSleep = 0x1
	// Position of USART6LPEN field.
	RCC_APB2LPENR_USART6LPEN_Pos = 0x5
	// Bit mask of USART6LPEN field.
	RCC_APB2LPENR_USART6LPEN_Msk = 0x20
	// Bit USART6LPEN.
	RCC_APB2LPENR_USART6LPEN = 0x20
	// Selected module is disabled during Sleep mode
	RCC_APB2LPENR_USART6LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB2LPENR_USART6LPEN_EnabledInSleep = 0x1
	// Position of ADC1LPEN field.
	RCC_APB2LPENR_ADC1LPEN_Pos = 0x8
	// Bit mask of ADC1LPEN field.
	RCC_APB2LPENR_ADC1LPEN_Msk = 0x100
	// Bit ADC1LPEN.
	RCC_APB2LPENR_ADC1LPEN = 0x100
	// Selected module is disabled during Sleep mode
	RCC_APB2LPENR_ADC1LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB2LPENR_ADC1LPEN_EnabledInSleep = 0x1
	// Position of ADC2LPEN field.
	RCC_APB2LPENR_ADC2LPEN_Pos = 0x9
	// Bit mask of ADC2LPEN field.
	RCC_APB2LPENR_ADC2LPEN_Msk = 0x200
	// Bit ADC2LPEN.
	RCC_APB2LPENR_ADC2LPEN = 0x200
	// Selected module is disabled during Sleep mode
	RCC_APB2LPENR_ADC2LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB2LPENR_ADC2LPEN_EnabledInSleep = 0x1
	// Position of ADC3LPEN field.
	RCC_APB2LPENR_ADC3LPEN_Pos = 0xa
	// Bit mask of ADC3LPEN field.
	RCC_APB2LPENR_ADC3LPEN_Msk = 0x400
	// Bit ADC3LPEN.
	RCC_APB2LPENR_ADC3LPEN = 0x400
	// Selected module is disabled during Sleep mode
	RCC_APB2LPENR_ADC3LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB2LPENR_ADC3LPEN_EnabledInSleep = 0x1
	// Position of SPI1LPEN field.
	RCC_APB2LPENR_SPI1LPEN_Pos = 0xc
	// Bit mask of SPI1LPEN field.
	RCC_APB2LPENR_SPI1LPEN_Msk = 0x1000
	// Bit SPI1LPEN.
	RCC_APB2LPENR_SPI1LPEN = 0x1000
	// Selected module is disabled during Sleep mode
	RCC_APB2LPENR_SPI1LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB2LPENR_SPI1LPEN_EnabledInSleep = 0x1
	// Position of SPI4LPEN field.
	RCC_APB2LPENR_SPI4LPEN_Pos = 0xd
	// Bit mask of SPI4LPEN field.
	RCC_APB2LPENR_SPI4LPEN_Msk = 0x2000
	// Bit SPI4LPEN.
	RCC_APB2LPENR_SPI4LPEN = 0x2000
	// Selected module is disabled during Sleep mode
	RCC_APB2LPENR_SPI4LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB2LPENR_SPI4LPEN_EnabledInSleep = 0x1
	// Position of SYSCFGLPEN field.
	RCC_APB2LPENR_SYSCFGLPEN_Pos = 0xe
	// Bit mask of SYSCFGLPEN field.
	RCC_APB2LPENR_SYSCFGLPEN_Msk = 0x4000
	// Bit SYSCFGLPEN.
	RCC_APB2LPENR_SYSCFGLPEN = 0x4000
	// Selected module is disabled during Sleep mode
	RCC_APB2LPENR_SYSCFGLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB2LPENR_SYSCFGLPEN_EnabledInSleep = 0x1
	// Position of TIM9LPEN field.
	RCC_APB2LPENR_TIM9LPEN_Pos = 0x10
	// Bit mask of TIM9LPEN field.
	RCC_APB2LPENR_TIM9LPEN_Msk = 0x10000
	// Bit TIM9LPEN.
	RCC_APB2LPENR_TIM9LPEN = 0x10000
	// Selected module is disabled during Sleep mode
	RCC_APB2LPENR_TIM9LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB2LPENR_TIM9LPEN_EnabledInSleep = 0x1
	// Position of TIM10LPEN field.
	RCC_APB2LPENR_TIM10LPEN_Pos = 0x11
	// Bit mask of TIM10LPEN field.
	RCC_APB2LPENR_TIM10LPEN_Msk = 0x20000
	// Bit TIM10LPEN.
	RCC_APB2LPENR_TIM10LPEN = 0x20000
	// Selected module is disabled during Sleep mode
	RCC_APB2LPENR_TIM10LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB2LPENR_TIM10LPEN_EnabledInSleep = 0x1
	// Position of TIM11LPEN field.
	RCC_APB2LPENR_TIM11LPEN_Pos = 0x12
	// Bit mask of TIM11LPEN field.
	RCC_APB2LPENR_TIM11LPEN_Msk = 0x40000
	// Bit TIM11LPEN.
	RCC_APB2LPENR_TIM11LPEN = 0x40000
	// Selected module is disabled during Sleep mode
	RCC_APB2LPENR_TIM11LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB2LPENR_TIM11LPEN_EnabledInSleep = 0x1
	// Position of SPI5LPEN field.
	RCC_APB2LPENR_SPI5LPEN_Pos = 0x14
	// Bit mask of SPI5LPEN field.
	RCC_APB2LPENR_SPI5LPEN_Msk = 0x100000
	// Bit SPI5LPEN.
	RCC_APB2LPENR_SPI5LPEN = 0x100000
	// Selected module is disabled during Sleep mode
	RCC_APB2LPENR_SPI5LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB2LPENR_SPI5LPEN_EnabledInSleep = 0x1
	// Position of SPI6LPEN field.
	RCC_APB2LPENR_SPI6LPEN_Pos = 0x15
	// Bit mask of SPI6LPEN field.
	RCC_APB2LPENR_SPI6LPEN_Msk = 0x200000
	// Bit SPI6LPEN.
	RCC_APB2LPENR_SPI6LPEN = 0x200000
	// Selected module is disabled during Sleep mode
	RCC_APB2LPENR_SPI6LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB2LPENR_SPI6LPEN_EnabledInSleep = 0x1
	// Position of SAI1LPEN field.
	RCC_APB2LPENR_SAI1LPEN_Pos = 0x16
	// Bit mask of SAI1LPEN field.
	RCC_APB2LPENR_SAI1LPEN_Msk = 0x400000
	// Bit SAI1LPEN.
	RCC_APB2LPENR_SAI1LPEN = 0x400000
	// Selected module is disabled during Sleep mode
	RCC_APB2LPENR_SAI1LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB2LPENR_SAI1LPEN_EnabledInSleep = 0x1
	// Position of LTDCLPEN field.
	RCC_APB2LPENR_LTDCLPEN_Pos = 0x1a
	// Bit mask of LTDCLPEN field.
	RCC_APB2LPENR_LTDCLPEN_Msk = 0x4000000
	// Bit LTDCLPEN.
	RCC_APB2LPENR_LTDCLPEN = 0x4000000
	// Selected module is disabled during Sleep mode
	RCC_APB2LPENR_LTDCLPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB2LPENR_LTDCLPEN_EnabledInSleep = 0x1
	// Position of SAI2LPEN field.
	RCC_APB2LPENR_SAI2LPEN_Pos = 0x17
	// Bit mask of SAI2LPEN field.
	RCC_APB2LPENR_SAI2LPEN_Msk = 0x800000
	// Bit SAI2LPEN.
	RCC_APB2LPENR_SAI2LPEN = 0x800000
	// Selected module is disabled during Sleep mode
	RCC_APB2LPENR_SAI2LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB2LPENR_SAI2LPEN_EnabledInSleep = 0x1
	// Position of SDMMC1LPEN field.
	RCC_APB2LPENR_SDMMC1LPEN_Pos = 0xb
	// Bit mask of SDMMC1LPEN field.
	RCC_APB2LPENR_SDMMC1LPEN_Msk = 0x800
	// Bit SDMMC1LPEN.
	RCC_APB2LPENR_SDMMC1LPEN = 0x800
	// Selected module is disabled during Sleep mode
	RCC_APB2LPENR_SDMMC1LPEN_DisabledInSleep = 0x0
	// Selected module is enabled during Sleep mode
	RCC_APB2LPENR_SDMMC1LPEN_EnabledInSleep = 0x1
	// Position of MDIOLPEN field.
	RCC_APB2LPENR_MDIOLPEN_Pos = 0x1e
	// Bit mask of MDIOLPEN field.
	RCC_APB2LPENR_MDIOLPEN_Msk = 0x40000000
	// Bit MDIOLPEN.
	RCC_APB2LPENR_MDIOLPEN = 0x40000000
	// Position of DFSDM1LPEN field.
	RCC_APB2LPENR_DFSDM1LPEN_Pos = 0x1d
	// Bit mask of DFSDM1LPEN field.
	RCC_APB2LPENR_DFSDM1LPEN_Msk = 0x20000000
	// Bit DFSDM1LPEN.
	RCC_APB2LPENR_DFSDM1LPEN = 0x20000000
	// Position of DSILPEN field.
	RCC_APB2LPENR_DSILPEN_Pos = 0x1b
	// Bit mask of DSILPEN field.
	RCC_APB2LPENR_DSILPEN_Msk = 0x8000000
	// Bit DSILPEN.
	RCC_APB2LPENR_DSILPEN = 0x8000000
	// Position of SDMMC2LPEN field.
	RCC_APB2LPENR_SDMMC2LPEN_Pos = 0x7
	// Bit mask of SDMMC2LPEN field.
	RCC_APB2LPENR_SDMMC2LPEN_Msk = 0x80
	// Bit SDMMC2LPEN.
	RCC_APB2LPENR_SDMMC2LPEN = 0x80

	// BDCR: Backup domain control register
	// Position of BDRST field.
	RCC_BDCR_BDRST_Pos = 0x10
	// Bit mask of BDRST field.
	RCC_BDCR_BDRST_Msk = 0x10000
	// Bit BDRST.
	RCC_BDCR_BDRST = 0x10000
	// Reset not activated
	RCC_BDCR_BDRST_Disabled = 0x0
	// Reset the entire RTC domain
	RCC_BDCR_BDRST_Enabled = 0x1
	// Position of RTCEN field.
	RCC_BDCR_RTCEN_Pos = 0xf
	// Bit mask of RTCEN field.
	RCC_BDCR_RTCEN_Msk = 0x8000
	// Bit RTCEN.
	RCC_BDCR_RTCEN = 0x8000
	// RTC clock disabled
	RCC_BDCR_RTCEN_Disabled = 0x0
	// RTC clock enabled
	RCC_BDCR_RTCEN_Enabled = 0x1
	// Position of LSEBYP field.
	RCC_BDCR_LSEBYP_Pos = 0x2
	// Bit mask of LSEBYP field.
	RCC_BDCR_LSEBYP_Msk = 0x4
	// Bit LSEBYP.
	RCC_BDCR_LSEBYP = 0x4
	// LSE crystal oscillator not bypassed
	RCC_BDCR_LSEBYP_NotBypassed = 0x0
	// LSE crystal oscillator bypassed with external clock
	RCC_BDCR_LSEBYP_Bypassed = 0x1
	// Position of LSERDY field.
	RCC_BDCR_LSERDY_Pos = 0x1
	// Bit mask of LSERDY field.
	RCC_BDCR_LSERDY_Msk = 0x2
	// Bit LSERDY.
	RCC_BDCR_LSERDY = 0x2
	// LSE oscillator not ready
	RCC_BDCR_LSERDY_NotReady = 0x0
	// LSE oscillator ready
	RCC_BDCR_LSERDY_Ready = 0x1
	// Position of LSEON field.
	RCC_BDCR_LSEON_Pos = 0x0
	// Bit mask of LSEON field.
	RCC_BDCR_LSEON_Msk = 0x1
	// Bit LSEON.
	RCC_BDCR_LSEON = 0x1
	// LSE oscillator Off
	RCC_BDCR_LSEON_Off = 0x0
	// LSE oscillator On
	RCC_BDCR_LSEON_On = 0x1
	// Position of LSEDRV field.
	RCC_BDCR_LSEDRV_Pos = 0x3
	// Bit mask of LSEDRV field.
	RCC_BDCR_LSEDRV_Msk = 0x18
	// Low drive capacity
	RCC_BDCR_LSEDRV_Low = 0x0
	// Medium-high drive capacity
	RCC_BDCR_LSEDRV_MediumHigh = 0x1
	// Medium-low drive capacity
	RCC_BDCR_LSEDRV_MediumLow = 0x2
	// High drive capacity
	RCC_BDCR_LSEDRV_High = 0x3
	// Position of RTCSEL field.
	RCC_BDCR_RTCSEL_Pos = 0x8
	// Bit mask of RTCSEL field.
	RCC_BDCR_RTCSEL_Msk = 0x300
	// No clock
	RCC_BDCR_RTCSEL_NoClock = 0x0
	// LSE oscillator clock used as RTC clock
	RCC_BDCR_RTCSEL_LSE = 0x1
	// LSI oscillator clock used as RTC clock
	RCC_BDCR_RTCSEL_LSI = 0x2
	// HSE oscillator clock divided by a prescaler used as RTC clock
	RCC_BDCR_RTCSEL_HSE = 0x3

	// CSR: clock control & status register
	// Position of LPWRRSTF field.
	RCC_CSR_LPWRRSTF_Pos = 0x1f
	// Bit mask of LPWRRSTF field.
	RCC_CSR_LPWRRSTF_Msk = 0x80000000
	// Bit LPWRRSTF.
	RCC_CSR_LPWRRSTF = 0x80000000
	// No reset has occured
	RCC_CSR_LPWRRSTF_NoReset = 0x0
	// A reset has occured
	RCC_CSR_LPWRRSTF_Reset = 0x1
	// Position of WWDGRSTF field.
	RCC_CSR_WWDGRSTF_Pos = 0x1e
	// Bit mask of WWDGRSTF field.
	RCC_CSR_WWDGRSTF_Msk = 0x40000000
	// Bit WWDGRSTF.
	RCC_CSR_WWDGRSTF = 0x40000000
	// No reset has occured
	RCC_CSR_WWDGRSTF_NoReset = 0x0
	// A reset has occured
	RCC_CSR_WWDGRSTF_Reset = 0x1
	// Position of WDGRSTF field.
	RCC_CSR_WDGRSTF_Pos = 0x1d
	// Bit mask of WDGRSTF field.
	RCC_CSR_WDGRSTF_Msk = 0x20000000
	// Bit WDGRSTF.
	RCC_CSR_WDGRSTF = 0x20000000
	// No reset has occured
	RCC_CSR_WDGRSTF_NoReset = 0x0
	// A reset has occured
	RCC_CSR_WDGRSTF_Reset = 0x1
	// Position of SFTRSTF field.
	RCC_CSR_SFTRSTF_Pos = 0x1c
	// Bit mask of SFTRSTF field.
	RCC_CSR_SFTRSTF_Msk = 0x10000000
	// Bit SFTRSTF.
	RCC_CSR_SFTRSTF = 0x10000000
	// No reset has occured
	RCC_CSR_SFTRSTF_NoReset = 0x0
	// A reset has occured
	RCC_CSR_SFTRSTF_Reset = 0x1
	// Position of PORRSTF field.
	RCC_CSR_PORRSTF_Pos = 0x1b
	// Bit mask of PORRSTF field.
	RCC_CSR_PORRSTF_Msk = 0x8000000
	// Bit PORRSTF.
	RCC_CSR_PORRSTF = 0x8000000
	// No reset has occured
	RCC_CSR_PORRSTF_NoReset = 0x0
	// A reset has occured
	RCC_CSR_PORRSTF_Reset = 0x1
	// Position of PADRSTF field.
	RCC_CSR_PADRSTF_Pos = 0x1a
	// Bit mask of PADRSTF field.
	RCC_CSR_PADRSTF_Msk = 0x4000000
	// Bit PADRSTF.
	RCC_CSR_PADRSTF = 0x4000000
	// No reset has occured
	RCC_CSR_PADRSTF_NoReset = 0x0
	// A reset has occured
	RCC_CSR_PADRSTF_Reset = 0x1
	// Position of BORRSTF field.
	RCC_CSR_BORRSTF_Pos = 0x19
	// Bit mask of BORRSTF field.
	RCC_CSR_BORRSTF_Msk = 0x2000000
	// Bit BORRSTF.
	RCC_CSR_BORRSTF = 0x2000000
	// No reset has occured
	RCC_CSR_BORRSTF_NoReset = 0x0
	// A reset has occured
	RCC_CSR_BORRSTF_Reset = 0x1
	// Position of RMVF field.
	RCC_CSR_RMVF_Pos = 0x18
	// Bit mask of RMVF field.
	RCC_CSR_RMVF_Msk = 0x1000000
	// Bit RMVF.
	RCC_CSR_RMVF = 0x1000000
	// Clears the reset flag
	RCC_CSR_RMVF_Clear = 0x1
	// Position of LSIRDY field.
	RCC_CSR_LSIRDY_Pos = 0x1
	// Bit mask of LSIRDY field.
	RCC_CSR_LSIRDY_Msk = 0x2
	// Bit LSIRDY.
	RCC_CSR_LSIRDY = 0x2
	// LSI oscillator not ready
	RCC_CSR_LSIRDY_NotReady = 0x0
	// LSI oscillator ready
	RCC_CSR_LSIRDY_Ready = 0x1
	// Position of LSION field.
	RCC_CSR_LSION_Pos = 0x0
	// Bit mask of LSION field.
	RCC_CSR_LSION_Msk = 0x1
	// Bit LSION.
	RCC_CSR_LSION = 0x1
	// LSI oscillator Off
	RCC_CSR_LSION_Off = 0x0
	// LSI oscillator On
	RCC_CSR_LSION_On = 0x1

	// SSCGR: spread spectrum clock generation register
	// Position of SSCGEN field.
	RCC_SSCGR_SSCGEN_Pos = 0x1f
	// Bit mask of SSCGEN field.
	RCC_SSCGR_SSCGEN_Msk = 0x80000000
	// Bit SSCGEN.
	RCC_SSCGR_SSCGEN = 0x80000000
	// Spread spectrum modulation disabled
	RCC_SSCGR_SSCGEN_Disabled = 0x0
	// Spread spectrum modulation enabled
	RCC_SSCGR_SSCGEN_Enabled = 0x1
	// Position of SPREADSEL field.
	RCC_SSCGR_SPREADSEL_Pos = 0x1e
	// Bit mask of SPREADSEL field.
	RCC_SSCGR_SPREADSEL_Msk = 0x40000000
	// Bit SPREADSEL.
	RCC_SSCGR_SPREADSEL = 0x40000000
	// Center spread
	RCC_SSCGR_SPREADSEL_Center = 0x0
	// Down spread
	RCC_SSCGR_SPREADSEL_Down = 0x1
	// Position of INCSTEP field.
	RCC_SSCGR_INCSTEP_Pos = 0xd
	// Bit mask of INCSTEP field.
	RCC_SSCGR_INCSTEP_Msk = 0xfffe000
	// Position of MODPER field.
	RCC_SSCGR_MODPER_Pos = 0x0
	// Bit mask of MODPER field.
	RCC_SSCGR_MODPER_Msk = 0x1fff

	// PLLI2SCFGR: PLLI2S configuration register
	// Position of PLLI2SR field.
	RCC_PLLI2SCFGR_PLLI2SR_Pos = 0x1c
	// Bit mask of PLLI2SR field.
	RCC_PLLI2SCFGR_PLLI2SR_Msk = 0x70000000
	// Position of PLLI2SQ field.
	RCC_PLLI2SCFGR_PLLI2SQ_Pos = 0x18
	// Bit mask of PLLI2SQ field.
	RCC_PLLI2SCFGR_PLLI2SQ_Msk = 0xf000000
	// Position of PLLI2SN field.
	RCC_PLLI2SCFGR_PLLI2SN_Pos = 0x6
	// Bit mask of PLLI2SN field.
	RCC_PLLI2SCFGR_PLLI2SN_Msk = 0x7fc0
	// Position of PLLI2SP field.
	RCC_PLLI2SCFGR_PLLI2SP_Pos = 0x10
	// Bit mask of PLLI2SP field.
	RCC_PLLI2SCFGR_PLLI2SP_Msk = 0x30000
	// PLL*P=2
	RCC_PLLI2SCFGR_PLLI2SP_Div2 = 0x0
	// PLL*P=4
	RCC_PLLI2SCFGR_PLLI2SP_Div4 = 0x1
	// PLL*P=6
	RCC_PLLI2SCFGR_PLLI2SP_Div6 = 0x2
	// PLL*P=8
	RCC_PLLI2SCFGR_PLLI2SP_Div8 = 0x3

	// PLLSAICFGR: PLL configuration register
	// Position of PLLSAIN field.
	RCC_PLLSAICFGR_PLLSAIN_Pos = 0x6
	// Bit mask of PLLSAIN field.
	RCC_PLLSAICFGR_PLLSAIN_Msk = 0x7fc0
	// Position of PLLSAIP field.
	RCC_PLLSAICFGR_PLLSAIP_Pos = 0x10
	// Bit mask of PLLSAIP field.
	RCC_PLLSAICFGR_PLLSAIP_Msk = 0x30000
	// PLL*P=2
	RCC_PLLSAICFGR_PLLSAIP_Div2 = 0x0
	// PLL*P=4
	RCC_PLLSAICFGR_PLLSAIP_Div4 = 0x1
	// PLL*P=6
	RCC_PLLSAICFGR_PLLSAIP_Div6 = 0x2
	// PLL*P=8
	RCC_PLLSAICFGR_PLLSAIP_Div8 = 0x3
	// Position of PLLSAIQ field.
	RCC_PLLSAICFGR_PLLSAIQ_Pos = 0x18
	// Bit mask of PLLSAIQ field.
	RCC_PLLSAICFGR_PLLSAIQ_Msk = 0xf000000
	// Position of PLLSAIR field.
	RCC_PLLSAICFGR_PLLSAIR_Pos = 0x1c
	// Bit mask of PLLSAIR field.
	RCC_PLLSAICFGR_PLLSAIR_Msk = 0x70000000

	// DCKCFGR1: dedicated clocks configuration register
	// Position of PLLI2SDIVQ field.
	RCC_DCKCFGR1_PLLI2SDIVQ_Pos = 0x0
	// Bit mask of PLLI2SDIVQ field.
	RCC_DCKCFGR1_PLLI2SDIVQ_Msk = 0x1f
	// PLLI2SDIVQ = /1
	RCC_DCKCFGR1_PLLI2SDIVQ_Div1 = 0x0
	// PLLI2SDIVQ = /2
	RCC_DCKCFGR1_PLLI2SDIVQ_Div2 = 0x1
	// PLLI2SDIVQ = /3
	RCC_DCKCFGR1_PLLI2SDIVQ_Div3 = 0x2
	// PLLI2SDIVQ = /4
	RCC_DCKCFGR1_PLLI2SDIVQ_Div4 = 0x3
	// PLLI2SDIVQ = /5
	RCC_DCKCFGR1_PLLI2SDIVQ_Div5 = 0x4
	// PLLI2SDIVQ = /6
	RCC_DCKCFGR1_PLLI2SDIVQ_Div6 = 0x5
	// PLLI2SDIVQ = /7
	RCC_DCKCFGR1_PLLI2SDIVQ_Div7 = 0x6
	// PLLI2SDIVQ = /8
	RCC_DCKCFGR1_PLLI2SDIVQ_Div8 = 0x7
	// PLLI2SDIVQ = /9
	RCC_DCKCFGR1_PLLI2SDIVQ_Div9 = 0x8
	// PLLI2SDIVQ = /10
	RCC_DCKCFGR1_PLLI2SDIVQ_Div10 = 0x9
	// PLLI2SDIVQ = /11
	RCC_DCKCFGR1_PLLI2SDIVQ_Div11 = 0xa
	// PLLI2SDIVQ = /12
	RCC_DCKCFGR1_PLLI2SDIVQ_Div12 = 0xb
	// PLLI2SDIVQ = /13
	RCC_DCKCFGR1_PLLI2SDIVQ_Div13 = 0xc
	// PLLI2SDIVQ = /14
	RCC_DCKCFGR1_PLLI2SDIVQ_Div14 = 0xd
	// PLLI2SDIVQ = /15
	RCC_DCKCFGR1_PLLI2SDIVQ_Div15 = 0xe
	// PLLI2SDIVQ = /16
	RCC_DCKCFGR1_PLLI2SDIVQ_Div16 = 0xf
	// PLLI2SDIVQ = /17
	RCC_DCKCFGR1_PLLI2SDIVQ_Div17 = 0x10
	// PLLI2SDIVQ = /18
	RCC_DCKCFGR1_PLLI2SDIVQ_Div18 = 0x11
	// PLLI2SDIVQ = /19
	RCC_DCKCFGR1_PLLI2SDIVQ_Div19 = 0x12
	// PLLI2SDIVQ = /20
	RCC_DCKCFGR1_PLLI2SDIVQ_Div20 = 0x13
	// PLLI2SDIVQ = /21
	RCC_DCKCFGR1_PLLI2SDIVQ_Div21 = 0x14
	// PLLI2SDIVQ = /22
	RCC_DCKCFGR1_PLLI2SDIVQ_Div22 = 0x15
	// PLLI2SDIVQ = /23
	RCC_DCKCFGR1_PLLI2SDIVQ_Div23 = 0x16
	// PLLI2SDIVQ = /24
	RCC_DCKCFGR1_PLLI2SDIVQ_Div24 = 0x17
	// PLLI2SDIVQ = /25
	RCC_DCKCFGR1_PLLI2SDIVQ_Div25 = 0x18
	// PLLI2SDIVQ = /26
	RCC_DCKCFGR1_PLLI2SDIVQ_Div26 = 0x19
	// PLLI2SDIVQ = /27
	RCC_DCKCFGR1_PLLI2SDIVQ_Div27 = 0x1a
	// PLLI2SDIVQ = /28
	RCC_DCKCFGR1_PLLI2SDIVQ_Div28 = 0x1b
	// PLLI2SDIVQ = /29
	RCC_DCKCFGR1_PLLI2SDIVQ_Div29 = 0x1c
	// PLLI2SDIVQ = /30
	RCC_DCKCFGR1_PLLI2SDIVQ_Div30 = 0x1d
	// PLLI2SDIVQ = /31
	RCC_DCKCFGR1_PLLI2SDIVQ_Div31 = 0x1e
	// PLLI2SDIVQ = /32
	RCC_DCKCFGR1_PLLI2SDIVQ_Div32 = 0x1f
	// Position of PLLSAIDIVQ field.
	RCC_DCKCFGR1_PLLSAIDIVQ_Pos = 0x8
	// Bit mask of PLLSAIDIVQ field.
	RCC_DCKCFGR1_PLLSAIDIVQ_Msk = 0x1f00
	// PLLSAIDIVQ = /1
	RCC_DCKCFGR1_PLLSAIDIVQ_Div1 = 0x0
	// PLLSAIDIVQ = /2
	RCC_DCKCFGR1_PLLSAIDIVQ_Div2 = 0x1
	// PLLSAIDIVQ = /3
	RCC_DCKCFGR1_PLLSAIDIVQ_Div3 = 0x2
	// PLLSAIDIVQ = /4
	RCC_DCKCFGR1_PLLSAIDIVQ_Div4 = 0x3
	// PLLSAIDIVQ = /5
	RCC_DCKCFGR1_PLLSAIDIVQ_Div5 = 0x4
	// PLLSAIDIVQ = /6
	RCC_DCKCFGR1_PLLSAIDIVQ_Div6 = 0x5
	// PLLSAIDIVQ = /7
	RCC_DCKCFGR1_PLLSAIDIVQ_Div7 = 0x6
	// PLLSAIDIVQ = /8
	RCC_DCKCFGR1_PLLSAIDIVQ_Div8 = 0x7
	// PLLSAIDIVQ = /9
	RCC_DCKCFGR1_PLLSAIDIVQ_Div9 = 0x8
	// PLLSAIDIVQ = /10
	RCC_DCKCFGR1_PLLSAIDIVQ_Div10 = 0x9
	// PLLSAIDIVQ = /11
	RCC_DCKCFGR1_PLLSAIDIVQ_Div11 = 0xa
	// PLLSAIDIVQ = /12
	RCC_DCKCFGR1_PLLSAIDIVQ_Div12 = 0xb
	// PLLSAIDIVQ = /13
	RCC_DCKCFGR1_PLLSAIDIVQ_Div13 = 0xc
	// PLLSAIDIVQ = /14
	RCC_DCKCFGR1_PLLSAIDIVQ_Div14 = 0xd
	// PLLSAIDIVQ = /15
	RCC_DCKCFGR1_PLLSAIDIVQ_Div15 = 0xe
	// PLLSAIDIVQ = /16
	RCC_DCKCFGR1_PLLSAIDIVQ_Div16 = 0xf
	// PLLSAIDIVQ = /17
	RCC_DCKCFGR1_PLLSAIDIVQ_Div17 = 0x10
	// PLLSAIDIVQ = /18
	RCC_DCKCFGR1_PLLSAIDIVQ_Div18 = 0x11
	// PLLSAIDIVQ = /19
	RCC_DCKCFGR1_PLLSAIDIVQ_Div19 = 0x12
	// PLLSAIDIVQ = /20
	RCC_DCKCFGR1_PLLSAIDIVQ_Div20 = 0x13
	// PLLSAIDIVQ = /21
	RCC_DCKCFGR1_PLLSAIDIVQ_Div21 = 0x14
	// PLLSAIDIVQ = /22
	RCC_DCKCFGR1_PLLSAIDIVQ_Div22 = 0x15
	// PLLSAIDIVQ = /23
	RCC_DCKCFGR1_PLLSAIDIVQ_Div23 = 0x16
	// PLLSAIDIVQ = /24
	RCC_DCKCFGR1_PLLSAIDIVQ_Div24 = 0x17
	// PLLSAIDIVQ = /25
	RCC_DCKCFGR1_PLLSAIDIVQ_Div25 = 0x18
	// PLLSAIDIVQ = /26
	RCC_DCKCFGR1_PLLSAIDIVQ_Div26 = 0x19
	// PLLSAIDIVQ = /27
	RCC_DCKCFGR1_PLLSAIDIVQ_Div27 = 0x1a
	// PLLSAIDIVQ = /28
	RCC_DCKCFGR1_PLLSAIDIVQ_Div28 = 0x1b
	// PLLSAIDIVQ = /29
	RCC_DCKCFGR1_PLLSAIDIVQ_Div29 = 0x1c
	// PLLSAIDIVQ = /30
	RCC_DCKCFGR1_PLLSAIDIVQ_Div30 = 0x1d
	// PLLSAIDIVQ = /31
	RCC_DCKCFGR1_PLLSAIDIVQ_Div31 = 0x1e
	// PLLSAIDIVQ = /32
	RCC_DCKCFGR1_PLLSAIDIVQ_Div32 = 0x1f
	// Position of PLLSAIDIVR field.
	RCC_DCKCFGR1_PLLSAIDIVR_Pos = 0x10
	// Bit mask of PLLSAIDIVR field.
	RCC_DCKCFGR1_PLLSAIDIVR_Msk = 0x30000
	// PLLSAIDIVR = /2
	RCC_DCKCFGR1_PLLSAIDIVR_Div2 = 0x0
	// PLLSAIDIVR = /4
	RCC_DCKCFGR1_PLLSAIDIVR_Div4 = 0x1
	// PLLSAIDIVR = /8
	RCC_DCKCFGR1_PLLSAIDIVR_Div8 = 0x2
	// PLLSAIDIVR = /16
	RCC_DCKCFGR1_PLLSAIDIVR_Div16 = 0x3
	// Position of SAI1SEL field.
	RCC_DCKCFGR1_SAI1SEL_Pos = 0x14
	// Bit mask of SAI1SEL field.
	RCC_DCKCFGR1_SAI1SEL_Msk = 0x300000
	// SAI1 clock frequency = f(PLLSAI_Q) / PLLSAIDIVQ
	RCC_DCKCFGR1_SAI1SEL_PLLSAI = 0x0
	// SAI1 clock frequency = f(PLLI2S_Q) / PLLI2SDIVQ
	RCC_DCKCFGR1_SAI1SEL_PLLI2S = 0x1
	// SAI1 clock frequency = Alternate function input frequency
	RCC_DCKCFGR1_SAI1SEL_AFIF = 0x2
	// SAI1 clock frequency = HSI or HSE
	RCC_DCKCFGR1_SAI1SEL_HSI_HSE = 0x3
	// Position of SAI2SEL field.
	RCC_DCKCFGR1_SAI2SEL_Pos = 0x16
	// Bit mask of SAI2SEL field.
	RCC_DCKCFGR1_SAI2SEL_Msk = 0xc00000
	// SAI2 clock frequency = f(PLLSAI_Q) / PLLSAIDIVQ
	RCC_DCKCFGR1_SAI2SEL_PLLSAI = 0x0
	// SAI2 clock frequency = f(PLLI2S_Q) / PLLI2SDIVQ
	RCC_DCKCFGR1_SAI2SEL_PLLI2S = 0x1
	// SAI2 clock frequency = Alternate function input frequency
	RCC_DCKCFGR1_SAI2SEL_AFIF = 0x2
	// SAI2 clock frequency = HSI or HSE
	RCC_DCKCFGR1_SAI2SEL_HSI_HSE = 0x3
	// Position of TIMPRE field.
	RCC_DCKCFGR1_TIMPRE_Pos = 0x18
	// Bit mask of TIMPRE field.
	RCC_DCKCFGR1_TIMPRE_Msk = 0x1000000
	// Bit TIMPRE.
	RCC_DCKCFGR1_TIMPRE = 0x1000000
	// If the APB prescaler is configured 1, TIMxCLK = PCLKx. Otherwise, TIMxCLK = 2xPCLKx
	RCC_DCKCFGR1_TIMPRE_Mul2 = 0x0
	// If the APB prescaler is configured 1, 2 or 4, TIMxCLK = HCLK. Otherwise, TIMxCLK = 4xPCLKx
	RCC_DCKCFGR1_TIMPRE_Mul4 = 0x1
	// Position of DFSDM1SEL field.
	RCC_DCKCFGR1_DFSDM1SEL_Pos = 0x19
	// Bit mask of DFSDM1SEL field.
	RCC_DCKCFGR1_DFSDM1SEL_Msk = 0x2000000
	// Bit DFSDM1SEL.
	RCC_DCKCFGR1_DFSDM1SEL = 0x2000000
	// APB2 clock (PCLK2) selected as DFSDM1 Kernel clock source
	RCC_DCKCFGR1_DFSDM1SEL_APB2 = 0x0
	// System clock (SYSCLK) clock selected as DFSDM1 Kernel clock source
	RCC_DCKCFGR1_DFSDM1SEL_SYSCLK = 0x1
	// Position of ADFSDM1SEL field.
	RCC_DCKCFGR1_ADFSDM1SEL_Pos = 0x1a
	// Bit mask of ADFSDM1SEL field.
	RCC_DCKCFGR1_ADFSDM1SEL_Msk = 0x4000000
	// Bit ADFSDM1SEL.
	RCC_DCKCFGR1_ADFSDM1SEL = 0x4000000
	// SAI1 clock selected as DFSDM1 Audio clock source
	RCC_DCKCFGR1_ADFSDM1SEL_SAI1 = 0x0
	// SAI2 clock selected as DFSDM1 Audio clock source
	RCC_DCKCFGR1_ADFSDM1SEL_SAI2 = 0x1

	// DCKCFGR2: dedicated clocks configuration register
	// Position of USART1SEL field.
	RCC_DCKCFGR2_USART1SEL_Pos = 0x0
	// Bit mask of USART1SEL field.
	RCC_DCKCFGR2_USART1SEL_Msk = 0x3
	// APB2 clock (PCLK2) is selected as USART clock
	RCC_DCKCFGR2_USART1SEL_APB2 = 0x0
	// System clock is selected as USART clock
	RCC_DCKCFGR2_USART1SEL_SYSCLK = 0x1
	// HSI clock is selected as USART clock
	RCC_DCKCFGR2_USART1SEL_HSI = 0x2
	// LSE clock is selected as USART clock
	RCC_DCKCFGR2_USART1SEL_LSE = 0x3
	// Position of USART2SEL field.
	RCC_DCKCFGR2_USART2SEL_Pos = 0x2
	// Bit mask of USART2SEL field.
	RCC_DCKCFGR2_USART2SEL_Msk = 0xc
	// APB1 clock (PCLK1) is selected as USART clock
	RCC_DCKCFGR2_USART2SEL_APB1 = 0x0
	// System clock is selected as USART clock
	RCC_DCKCFGR2_USART2SEL_SYSCLK = 0x1
	// HSI clock is selected as USART clock
	RCC_DCKCFGR2_USART2SEL_HSI = 0x2
	// LSE clock is selected as USART clock
	RCC_DCKCFGR2_USART2SEL_LSE = 0x3
	// Position of USART3SEL field.
	RCC_DCKCFGR2_USART3SEL_Pos = 0x4
	// Bit mask of USART3SEL field.
	RCC_DCKCFGR2_USART3SEL_Msk = 0x30
	// APB1 clock (PCLK1) is selected as USART clock
	RCC_DCKCFGR2_USART3SEL_APB1 = 0x0
	// System clock is selected as USART clock
	RCC_DCKCFGR2_USART3SEL_SYSCLK = 0x1
	// HSI clock is selected as USART clock
	RCC_DCKCFGR2_USART3SEL_HSI = 0x2
	// LSE clock is selected as USART clock
	RCC_DCKCFGR2_USART3SEL_LSE = 0x3
	// Position of UART4SEL field.
	RCC_DCKCFGR2_UART4SEL_Pos = 0x6
	// Bit mask of UART4SEL field.
	RCC_DCKCFGR2_UART4SEL_Msk = 0xc0
	// APB1 clock (PCLK1) is selected as USART clock
	RCC_DCKCFGR2_UART4SEL_APB1 = 0x0
	// System clock is selected as USART clock
	RCC_DCKCFGR2_UART4SEL_SYSCLK = 0x1
	// HSI clock is selected as USART clock
	RCC_DCKCFGR2_UART4SEL_HSI = 0x2
	// LSE clock is selected as USART clock
	RCC_DCKCFGR2_UART4SEL_LSE = 0x3
	// Position of UART5SEL field.
	RCC_DCKCFGR2_UART5SEL_Pos = 0x8
	// Bit mask of UART5SEL field.
	RCC_DCKCFGR2_UART5SEL_Msk = 0x300
	// APB1 clock (PCLK1) is selected as USART clock
	RCC_DCKCFGR2_UART5SEL_APB1 = 0x0
	// System clock is selected as USART clock
	RCC_DCKCFGR2_UART5SEL_SYSCLK = 0x1
	// HSI clock is selected as USART clock
	RCC_DCKCFGR2_UART5SEL_HSI = 0x2
	// LSE clock is selected as USART clock
	RCC_DCKCFGR2_UART5SEL_LSE = 0x3
	// Position of USART6SEL field.
	RCC_DCKCFGR2_USART6SEL_Pos = 0xa
	// Bit mask of USART6SEL field.
	RCC_DCKCFGR2_USART6SEL_Msk = 0xc00
	// APB2 clock (PCLK2) is selected as USART clock
	RCC_DCKCFGR2_USART6SEL_APB2 = 0x0
	// System clock is selected as USART clock
	RCC_DCKCFGR2_USART6SEL_SYSCLK = 0x1
	// HSI clock is selected as USART clock
	RCC_DCKCFGR2_USART6SEL_HSI = 0x2
	// LSE clock is selected as USART clock
	RCC_DCKCFGR2_USART6SEL_LSE = 0x3
	// Position of UART7SEL field.
	RCC_DCKCFGR2_UART7SEL_Pos = 0xc
	// Bit mask of UART7SEL field.
	RCC_DCKCFGR2_UART7SEL_Msk = 0x3000
	// APB1 clock (PCLK1) is selected as USART clock
	RCC_DCKCFGR2_UART7SEL_APB1 = 0x0
	// System clock is selected as USART clock
	RCC_DCKCFGR2_UART7SEL_SYSCLK = 0x1
	// HSI clock is selected as USART clock
	RCC_DCKCFGR2_UART7SEL_HSI = 0x2
	// LSE clock is selected as USART clock
	RCC_DCKCFGR2_UART7SEL_LSE = 0x3
	// Position of UART8SEL field.
	RCC_DCKCFGR2_UART8SEL_Pos = 0xe
	// Bit mask of UART8SEL field.
	RCC_DCKCFGR2_UART8SEL_Msk = 0xc000
	// APB1 clock (PCLK1) is selected as USART clock
	RCC_DCKCFGR2_UART8SEL_APB1 = 0x0
	// System clock is selected as USART clock
	RCC_DCKCFGR2_UART8SEL_SYSCLK = 0x1
	// HSI clock is selected as USART clock
	RCC_DCKCFGR2_UART8SEL_HSI = 0x2
	// LSE clock is selected as USART clock
	RCC_DCKCFGR2_UART8SEL_LSE = 0x3
	// Position of I2C1SEL field.
	RCC_DCKCFGR2_I2C1SEL_Pos = 0x10
	// Bit mask of I2C1SEL field.
	RCC_DCKCFGR2_I2C1SEL_Msk = 0x30000
	// APB clock selected as I2C clock
	RCC_DCKCFGR2_I2C1SEL_APB = 0x0
	// System clock selected as I2C clock
	RCC_DCKCFGR2_I2C1SEL_SYSCLK = 0x1
	// HSI clock selected as I2C clock
	RCC_DCKCFGR2_I2C1SEL_HSI = 0x2
	// Position of I2C2SEL field.
	RCC_DCKCFGR2_I2C2SEL_Pos = 0x12
	// Bit mask of I2C2SEL field.
	RCC_DCKCFGR2_I2C2SEL_Msk = 0xc0000
	// APB clock selected as I2C clock
	RCC_DCKCFGR2_I2C2SEL_APB = 0x0
	// System clock selected as I2C clock
	RCC_DCKCFGR2_I2C2SEL_SYSCLK = 0x1
	// HSI clock selected as I2C clock
	RCC_DCKCFGR2_I2C2SEL_HSI = 0x2
	// Position of I2C3SEL field.
	RCC_DCKCFGR2_I2C3SEL_Pos = 0x14
	// Bit mask of I2C3SEL field.
	RCC_DCKCFGR2_I2C3SEL_Msk = 0x300000
	// APB clock selected as I2C clock
	RCC_DCKCFGR2_I2C3SEL_APB = 0x0
	// System clock selected as I2C clock
	RCC_DCKCFGR2_I2C3SEL_SYSCLK = 0x1
	// HSI clock selected as I2C clock
	RCC_DCKCFGR2_I2C3SEL_HSI = 0x2
	// Position of I2C4SEL field.
	RCC_DCKCFGR2_I2C4SEL_Pos = 0x16
	// Bit mask of I2C4SEL field.
	RCC_DCKCFGR2_I2C4SEL_Msk = 0xc00000
	// APB clock selected as I2C clock
	RCC_DCKCFGR2_I2C4SEL_APB = 0x0
	// System clock selected as I2C clock
	RCC_DCKCFGR2_I2C4SEL_SYSCLK = 0x1
	// HSI clock selected as I2C clock
	RCC_DCKCFGR2_I2C4SEL_HSI = 0x2
	// Position of LPTIM1SEL field.
	RCC_DCKCFGR2_LPTIM1SEL_Pos = 0x18
	// Bit mask of LPTIM1SEL field.
	RCC_DCKCFGR2_LPTIM1SEL_Msk = 0x3000000
	// APB1 clock (PCLK1) selected as LPTILM1 clock
	RCC_DCKCFGR2_LPTIM1SEL_APB1 = 0x0
	// LSI clock is selected as LPTILM1 clock
	RCC_DCKCFGR2_LPTIM1SEL_LSI = 0x1
	// HSI clock is selected as LPTILM1 clock
	RCC_DCKCFGR2_LPTIM1SEL_HSI = 0x2
	// LSE clock is selected as LPTILM1 clock
	RCC_DCKCFGR2_LPTIM1SEL_LSE = 0x3
	// Position of CECSEL field.
	RCC_DCKCFGR2_CECSEL_Pos = 0x1a
	// Bit mask of CECSEL field.
	RCC_DCKCFGR2_CECSEL_Msk = 0x4000000
	// Bit CECSEL.
	RCC_DCKCFGR2_CECSEL = 0x4000000
	// LSE clock is selected as HDMI-CEC clock
	RCC_DCKCFGR2_CECSEL_LSE = 0x0
	// HSI divided by 488 clock is selected as HDMI-CEC clock
	RCC_DCKCFGR2_CECSEL_HSI_Div488 = 0x1
	// Position of CK48MSEL field.
	RCC_DCKCFGR2_CK48MSEL_Pos = 0x1b
	// Bit mask of CK48MSEL field.
	RCC_DCKCFGR2_CK48MSEL_Msk = 0x8000000
	// Bit CK48MSEL.
	RCC_DCKCFGR2_CK48MSEL = 0x8000000
	// 48MHz clock from PLL is selected
	RCC_DCKCFGR2_CK48MSEL_PLL = 0x0
	// 48MHz clock from PLLSAI is selected
	RCC_DCKCFGR2_CK48MSEL_PLLSAI = 0x1
	// Position of SDMMC1SEL field.
	RCC_DCKCFGR2_SDMMC1SEL_Pos = 0x1c
	// Bit mask of SDMMC1SEL field.
	RCC_DCKCFGR2_SDMMC1SEL_Msk = 0x10000000
	// Bit SDMMC1SEL.
	RCC_DCKCFGR2_SDMMC1SEL = 0x10000000
	// 48 MHz clock is selected as SD clock
	RCC_DCKCFGR2_SDMMC1SEL_CK48M = 0x0
	// System clock is selected as SD clock
	RCC_DCKCFGR2_SDMMC1SEL_SYSCLK = 0x1
	// Position of SDMMC2SEL field.
	RCC_DCKCFGR2_SDMMC2SEL_Pos = 0x1d
	// Bit mask of SDMMC2SEL field.
	RCC_DCKCFGR2_SDMMC2SEL_Msk = 0x20000000
	// Bit SDMMC2SEL.
	RCC_DCKCFGR2_SDMMC2SEL = 0x20000000
	// 48 MHz clock is selected as SD clock
	RCC_DCKCFGR2_SDMMC2SEL_CK48M = 0x0
	// System clock is selected as SD clock
	RCC_DCKCFGR2_SDMMC2SEL_SYSCLK = 0x1
	// Position of DSISEL field.
	RCC_DCKCFGR2_DSISEL_Pos = 0x1e
	// Bit mask of DSISEL field.
	RCC_DCKCFGR2_DSISEL_Msk = 0x40000000
	// Bit DSISEL.
	RCC_DCKCFGR2_DSISEL = 0x40000000
	// DSI-PHY used as DSI byte lane clock source (usual case)
	RCC_DCKCFGR2_DSISEL_DSI_PHY = 0x0
	// PLLR used as DSI byte lane clock source, used in case DSI PLL and DSI-PHY are off (low power mode)
	RCC_DCKCFGR2_DSISEL_PLLR = 0x1
)

// Constants for GPIOD: General-purpose I/Os
const (
	// MODER: GPIO port mode register
	// Position of MODER15 field.
	GPIO_MODER_MODER15_Pos = 0x1e
	// Bit mask of MODER15 field.
	GPIO_MODER_MODER15_Msk = 0xc0000000
	// Input mode (reset state)
	GPIO_MODER_MODER15_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER15_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER15_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER15_Analog = 0x3
	// Position of MODER14 field.
	GPIO_MODER_MODER14_Pos = 0x1c
	// Bit mask of MODER14 field.
	GPIO_MODER_MODER14_Msk = 0x30000000
	// Input mode (reset state)
	GPIO_MODER_MODER14_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER14_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER14_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER14_Analog = 0x3
	// Position of MODER13 field.
	GPIO_MODER_MODER13_Pos = 0x1a
	// Bit mask of MODER13 field.
	GPIO_MODER_MODER13_Msk = 0xc000000
	// Input mode (reset state)
	GPIO_MODER_MODER13_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER13_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER13_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER13_Analog = 0x3
	// Position of MODER12 field.
	GPIO_MODER_MODER12_Pos = 0x18
	// Bit mask of MODER12 field.
	GPIO_MODER_MODER12_Msk = 0x3000000
	// Input mode (reset state)
	GPIO_MODER_MODER12_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER12_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER12_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER12_Analog = 0x3
	// Position of MODER11 field.
	GPIO_MODER_MODER11_Pos = 0x16
	// Bit mask of MODER11 field.
	GPIO_MODER_MODER11_Msk = 0xc00000
	// Input mode (reset state)
	GPIO_MODER_MODER11_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER11_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER11_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER11_Analog = 0x3
	// Position of MODER10 field.
	GPIO_MODER_MODER10_Pos = 0x14
	// Bit mask of MODER10 field.
	GPIO_MODER_MODER10_Msk = 0x300000
	// Input mode (reset state)
	GPIO_MODER_MODER10_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER10_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER10_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER10_Analog = 0x3
	// Position of MODER9 field.
	GPIO_MODER_MODER9_Pos = 0x12
	// Bit mask of MODER9 field.
	GPIO_MODER_MODER9_Msk = 0xc0000
	// Input mode (reset state)
	GPIO_MODER_MODER9_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER9_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER9_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER9_Analog = 0x3
	// Position of MODER8 field.
	GPIO_MODER_MODER8_Pos = 0x10
	// Bit mask of MODER8 field.
	GPIO_MODER_MODER8_Msk = 0x30000
	// Input mode (reset state)
	GPIO_MODER_MODER8_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER8_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER8_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER8_Analog = 0x3
	// Position of MODER7 field.
	GPIO_MODER_MODER7_Pos = 0xe
	// Bit mask of MODER7 field.
	GPIO_MODER_MODER7_Msk = 0xc000
	// Input mode (reset state)
	GPIO_MODER_MODER7_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER7_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER7_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER7_Analog = 0x3
	// Position of MODER6 field.
	GPIO_MODER_MODER6_Pos = 0xc
	// Bit mask of MODER6 field.
	GPIO_MODER_MODER6_Msk = 0x3000
	// Input mode (reset state)
	GPIO_MODER_MODER6_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER6_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER6_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER6_Analog = 0x3
	// Position of MODER5 field.
	GPIO_MODER_MODER5_Pos = 0xa
	// Bit mask of MODER5 field.
	GPIO_MODER_MODER5_Msk = 0xc00
	// Input mode (reset state)
	GPIO_MODER_MODER5_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER5_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER5_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER5_Analog = 0x3
	// Position of MODER4 field.
	GPIO_MODER_MODER4_Pos = 0x8
	// Bit mask of MODER4 field.
	GPIO_MODER_MODER4_Msk = 0x300
	// Input mode (reset state)
	GPIO_MODER_MODER4_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER4_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER4_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER4_Analog = 0x3
	// Position of MODER3 field.
	GPIO_MODER_MODER3_Pos = 0x6
	// Bit mask of MODER3 field.
	GPIO_MODER_MODER3_Msk = 0xc0
	// Input mode (reset state)
	GPIO_MODER_MODER3_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER3_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER3_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER3_Analog = 0x3
	// Position of MODER2 field.
	GPIO_MODER_MODER2_Pos = 0x4
	// Bit mask of MODER2 field.
	GPIO_MODER_MODER2_Msk = 0x30
	// Input mode (reset state)
	GPIO_MODER_MODER2_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER2_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER2_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER2_Analog = 0x3
	// Position of MODER1 field.
	GPIO_MODER_MODER1_Pos = 0x2
	// Bit mask of MODER1 field.
	GPIO_MODER_MODER1_Msk = 0xc
	// Input mode (reset state)
	GPIO_MODER_MODER1_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER1_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER1_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER1_Analog = 0x3
	// Position of MODER0 field.
	GPIO_MODER_MODER0_Pos = 0x0
	// Bit mask of MODER0 field.
	GPIO_MODER_MODER0_Msk = 0x3
	// Input mode (reset state)
	GPIO_MODER_MODER0_Input = 0x0
	// General purpose output mode
	GPIO_MODER_MODER0_Output = 0x1
	// Alternate function mode
	GPIO_MODER_MODER0_Alternate = 0x2
	// Analog mode
	GPIO_MODER_MODER0_Analog = 0x3

	// OTYPER: GPIO port output type register
	// Position of OT15 field.
	GPIO_OTYPER_OT15_Pos = 0xf
	// Bit mask of OT15 field.
	GPIO_OTYPER_OT15_Msk = 0x8000
	// Bit OT15.
	GPIO_OTYPER_OT15 = 0x8000
	// Output push-pull (reset state)
	GPIO_OTYPER_OT15_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT15_OpenDrain = 0x1
	// Position of OT14 field.
	GPIO_OTYPER_OT14_Pos = 0xe
	// Bit mask of OT14 field.
	GPIO_OTYPER_OT14_Msk = 0x4000
	// Bit OT14.
	GPIO_OTYPER_OT14 = 0x4000
	// Output push-pull (reset state)
	GPIO_OTYPER_OT14_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT14_OpenDrain = 0x1
	// Position of OT13 field.
	GPIO_OTYPER_OT13_Pos = 0xd
	// Bit mask of OT13 field.
	GPIO_OTYPER_OT13_Msk = 0x2000
	// Bit OT13.
	GPIO_OTYPER_OT13 = 0x2000
	// Output push-pull (reset state)
	GPIO_OTYPER_OT13_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT13_OpenDrain = 0x1
	// Position of OT12 field.
	GPIO_OTYPER_OT12_Pos = 0xc
	// Bit mask of OT12 field.
	GPIO_OTYPER_OT12_Msk = 0x1000
	// Bit OT12.
	GPIO_OTYPER_OT12 = 0x1000
	// Output push-pull (reset state)
	GPIO_OTYPER_OT12_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT12_OpenDrain = 0x1
	// Position of OT11 field.
	GPIO_OTYPER_OT11_Pos = 0xb
	// Bit mask of OT11 field.
	GPIO_OTYPER_OT11_Msk = 0x800
	// Bit OT11.
	GPIO_OTYPER_OT11 = 0x800
	// Output push-pull (reset state)
	GPIO_OTYPER_OT11_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT11_OpenDrain = 0x1
	// Position of OT10 field.
	GPIO_OTYPER_OT10_Pos = 0xa
	// Bit mask of OT10 field.
	GPIO_OTYPER_OT10_Msk = 0x400
	// Bit OT10.
	GPIO_OTYPER_OT10 = 0x400
	// Output push-pull (reset state)
	GPIO_OTYPER_OT10_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT10_OpenDrain = 0x1
	// Position of OT9 field.
	GPIO_OTYPER_OT9_Pos = 0x9
	// Bit mask of OT9 field.
	GPIO_OTYPER_OT9_Msk = 0x200
	// Bit OT9.
	GPIO_OTYPER_OT9 = 0x200
	// Output push-pull (reset state)
	GPIO_OTYPER_OT9_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT9_OpenDrain = 0x1
	// Position of OT8 field.
	GPIO_OTYPER_OT8_Pos = 0x8
	// Bit mask of OT8 field.
	GPIO_OTYPER_OT8_Msk = 0x100
	// Bit OT8.
	GPIO_OTYPER_OT8 = 0x100
	// Output push-pull (reset state)
	GPIO_OTYPER_OT8_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT8_OpenDrain = 0x1
	// Position of OT7 field.
	GPIO_OTYPER_OT7_Pos = 0x7
	// Bit mask of OT7 field.
	GPIO_OTYPER_OT7_Msk = 0x80
	// Bit OT7.
	GPIO_OTYPER_OT7 = 0x80
	// Output push-pull (reset state)
	GPIO_OTYPER_OT7_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT7_OpenDrain = 0x1
	// Position of OT6 field.
	GPIO_OTYPER_OT6_Pos = 0x6
	// Bit mask of OT6 field.
	GPIO_OTYPER_OT6_Msk = 0x40
	// Bit OT6.
	GPIO_OTYPER_OT6 = 0x40
	// Output push-pull (reset state)
	GPIO_OTYPER_OT6_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT6_OpenDrain = 0x1
	// Position of OT5 field.
	GPIO_OTYPER_OT5_Pos = 0x5
	// Bit mask of OT5 field.
	GPIO_OTYPER_OT5_Msk = 0x20
	// Bit OT5.
	GPIO_OTYPER_OT5 = 0x20
	// Output push-pull (reset state)
	GPIO_OTYPER_OT5_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT5_OpenDrain = 0x1
	// Position of OT4 field.
	GPIO_OTYPER_OT4_Pos = 0x4
	// Bit mask of OT4 field.
	GPIO_OTYPER_OT4_Msk = 0x10
	// Bit OT4.
	GPIO_OTYPER_OT4 = 0x10
	// Output push-pull (reset state)
	GPIO_OTYPER_OT4_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT4_OpenDrain = 0x1
	// Position of OT3 field.
	GPIO_OTYPER_OT3_Pos = 0x3
	// Bit mask of OT3 field.
	GPIO_OTYPER_OT3_Msk = 0x8
	// Bit OT3.
	GPIO_OTYPER_OT3 = 0x8
	// Output push-pull (reset state)
	GPIO_OTYPER_OT3_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT3_OpenDrain = 0x1
	// Position of OT2 field.
	GPIO_OTYPER_OT2_Pos = 0x2
	// Bit mask of OT2 field.
	GPIO_OTYPER_OT2_Msk = 0x4
	// Bit OT2.
	GPIO_OTYPER_OT2 = 0x4
	// Output push-pull (reset state)
	GPIO_OTYPER_OT2_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT2_OpenDrain = 0x1
	// Position of OT1 field.
	GPIO_OTYPER_OT1_Pos = 0x1
	// Bit mask of OT1 field.
	GPIO_OTYPER_OT1_Msk = 0x2
	// Bit OT1.
	GPIO_OTYPER_OT1 = 0x2
	// Output push-pull (reset state)
	GPIO_OTYPER_OT1_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT1_OpenDrain = 0x1
	// Position of OT0 field.
	GPIO_OTYPER_OT0_Pos = 0x0
	// Bit mask of OT0 field.
	GPIO_OTYPER_OT0_Msk = 0x1
	// Bit OT0.
	GPIO_OTYPER_OT0 = 0x1
	// Output push-pull (reset state)
	GPIO_OTYPER_OT0_PushPull = 0x0
	// Output open-drain
	GPIO_OTYPER_OT0_OpenDrain = 0x1

	// OSPEEDR: GPIO port output speed register
	// Position of OSPEEDR15 field.
	GPIO_OSPEEDR_OSPEEDR15_Pos = 0x1e
	// Bit mask of OSPEEDR15 field.
	GPIO_OSPEEDR_OSPEEDR15_Msk = 0xc0000000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR15_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR15_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR15_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR15_VeryHighSpeed = 0x3
	// Position of OSPEEDR14 field.
	GPIO_OSPEEDR_OSPEEDR14_Pos = 0x1c
	// Bit mask of OSPEEDR14 field.
	GPIO_OSPEEDR_OSPEEDR14_Msk = 0x30000000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR14_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR14_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR14_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR14_VeryHighSpeed = 0x3
	// Position of OSPEEDR13 field.
	GPIO_OSPEEDR_OSPEEDR13_Pos = 0x1a
	// Bit mask of OSPEEDR13 field.
	GPIO_OSPEEDR_OSPEEDR13_Msk = 0xc000000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR13_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR13_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR13_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR13_VeryHighSpeed = 0x3
	// Position of OSPEEDR12 field.
	GPIO_OSPEEDR_OSPEEDR12_Pos = 0x18
	// Bit mask of OSPEEDR12 field.
	GPIO_OSPEEDR_OSPEEDR12_Msk = 0x3000000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR12_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR12_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR12_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR12_VeryHighSpeed = 0x3
	// Position of OSPEEDR11 field.
	GPIO_OSPEEDR_OSPEEDR11_Pos = 0x16
	// Bit mask of OSPEEDR11 field.
	GPIO_OSPEEDR_OSPEEDR11_Msk = 0xc00000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR11_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR11_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR11_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR11_VeryHighSpeed = 0x3
	// Position of OSPEEDR10 field.
	GPIO_OSPEEDR_OSPEEDR10_Pos = 0x14
	// Bit mask of OSPEEDR10 field.
	GPIO_OSPEEDR_OSPEEDR10_Msk = 0x300000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR10_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR10_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR10_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR10_VeryHighSpeed = 0x3
	// Position of OSPEEDR9 field.
	GPIO_OSPEEDR_OSPEEDR9_Pos = 0x12
	// Bit mask of OSPEEDR9 field.
	GPIO_OSPEEDR_OSPEEDR9_Msk = 0xc0000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR9_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR9_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR9_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR9_VeryHighSpeed = 0x3
	// Position of OSPEEDR8 field.
	GPIO_OSPEEDR_OSPEEDR8_Pos = 0x10
	// Bit mask of OSPEEDR8 field.
	GPIO_OSPEEDR_OSPEEDR8_Msk = 0x30000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR8_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR8_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR8_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR8_VeryHighSpeed = 0x3
	// Position of OSPEEDR7 field.
	GPIO_OSPEEDR_OSPEEDR7_Pos = 0xe
	// Bit mask of OSPEEDR7 field.
	GPIO_OSPEEDR_OSPEEDR7_Msk = 0xc000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR7_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR7_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR7_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR7_VeryHighSpeed = 0x3
	// Position of OSPEEDR6 field.
	GPIO_OSPEEDR_OSPEEDR6_Pos = 0xc
	// Bit mask of OSPEEDR6 field.
	GPIO_OSPEEDR_OSPEEDR6_Msk = 0x3000
	// Low speed
	GPIO_OSPEEDR_OSPEEDR6_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR6_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR6_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR6_VeryHighSpeed = 0x3
	// Position of OSPEEDR5 field.
	GPIO_OSPEEDR_OSPEEDR5_Pos = 0xa
	// Bit mask of OSPEEDR5 field.
	GPIO_OSPEEDR_OSPEEDR5_Msk = 0xc00
	// Low speed
	GPIO_OSPEEDR_OSPEEDR5_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR5_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR5_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR5_VeryHighSpeed = 0x3
	// Position of OSPEEDR4 field.
	GPIO_OSPEEDR_OSPEEDR4_Pos = 0x8
	// Bit mask of OSPEEDR4 field.
	GPIO_OSPEEDR_OSPEEDR4_Msk = 0x300
	// Low speed
	GPIO_OSPEEDR_OSPEEDR4_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR4_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR4_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR4_VeryHighSpeed = 0x3
	// Position of OSPEEDR3 field.
	GPIO_OSPEEDR_OSPEEDR3_Pos = 0x6
	// Bit mask of OSPEEDR3 field.
	GPIO_OSPEEDR_OSPEEDR3_Msk = 0xc0
	// Low speed
	GPIO_OSPEEDR_OSPEEDR3_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR3_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR3_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR3_VeryHighSpeed = 0x3
	// Position of OSPEEDR2 field.
	GPIO_OSPEEDR_OSPEEDR2_Pos = 0x4
	// Bit mask of OSPEEDR2 field.
	GPIO_OSPEEDR_OSPEEDR2_Msk = 0x30
	// Low speed
	GPIO_OSPEEDR_OSPEEDR2_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR2_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR2_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR2_VeryHighSpeed = 0x3
	// Position of OSPEEDR1 field.
	GPIO_OSPEEDR_OSPEEDR1_Pos = 0x2
	// Bit mask of OSPEEDR1 field.
	GPIO_OSPEEDR_OSPEEDR1_Msk = 0xc
	// Low speed
	GPIO_OSPEEDR_OSPEEDR1_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR1_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR1_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR1_VeryHighSpeed = 0x3
	// Position of OSPEEDR0 field.
	GPIO_OSPEEDR_OSPEEDR0_Pos = 0x0
	// Bit mask of OSPEEDR0 field.
	GPIO_OSPEEDR_OSPEEDR0_Msk = 0x3
	// Low speed
	GPIO_OSPEEDR_OSPEEDR0_LowSpeed = 0x0
	// Medium speed
	GPIO_OSPEEDR_OSPEEDR0_MediumSpeed = 0x1
	// High speed
	GPIO_OSPEEDR_OSPEEDR0_HighSpeed = 0x2
	// Very high speed
	GPIO_OSPEEDR_OSPEEDR0_VeryHighSpeed = 0x3

	// PUPDR: GPIO port pull-up/pull-down register
	// Position of PUPDR15 field.
	GPIO_PUPDR_PUPDR15_Pos = 0x1e
	// Bit mask of PUPDR15 field.
	GPIO_PUPDR_PUPDR15_Msk = 0xc0000000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR15_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR15_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR15_PullDown = 0x2
	// Position of PUPDR14 field.
	GPIO_PUPDR_PUPDR14_Pos = 0x1c
	// Bit mask of PUPDR14 field.
	GPIO_PUPDR_PUPDR14_Msk = 0x30000000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR14_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR14_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR14_PullDown = 0x2
	// Position of PUPDR13 field.
	GPIO_PUPDR_PUPDR13_Pos = 0x1a
	// Bit mask of PUPDR13 field.
	GPIO_PUPDR_PUPDR13_Msk = 0xc000000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR13_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR13_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR13_PullDown = 0x2
	// Position of PUPDR12 field.
	GPIO_PUPDR_PUPDR12_Pos = 0x18
	// Bit mask of PUPDR12 field.
	GPIO_PUPDR_PUPDR12_Msk = 0x3000000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR12_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR12_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR12_PullDown = 0x2
	// Position of PUPDR11 field.
	GPIO_PUPDR_PUPDR11_Pos = 0x16
	// Bit mask of PUPDR11 field.
	GPIO_PUPDR_PUPDR11_Msk = 0xc00000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR11_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR11_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR11_PullDown = 0x2
	// Position of PUPDR10 field.
	GPIO_PUPDR_PUPDR10_Pos = 0x14
	// Bit mask of PUPDR10 field.
	GPIO_PUPDR_PUPDR10_Msk = 0x300000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR10_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR10_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR10_PullDown = 0x2
	// Position of PUPDR9 field.
	GPIO_PUPDR_PUPDR9_Pos = 0x12
	// Bit mask of PUPDR9 field.
	GPIO_PUPDR_PUPDR9_Msk = 0xc0000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR9_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR9_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR9_PullDown = 0x2
	// Position of PUPDR8 field.
	GPIO_PUPDR_PUPDR8_Pos = 0x10
	// Bit mask of PUPDR8 field.
	GPIO_PUPDR_PUPDR8_Msk = 0x30000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR8_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR8_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR8_PullDown = 0x2
	// Position of PUPDR7 field.
	GPIO_PUPDR_PUPDR7_Pos = 0xe
	// Bit mask of PUPDR7 field.
	GPIO_PUPDR_PUPDR7_Msk = 0xc000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR7_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR7_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR7_PullDown = 0x2
	// Position of PUPDR6 field.
	GPIO_PUPDR_PUPDR6_Pos = 0xc
	// Bit mask of PUPDR6 field.
	GPIO_PUPDR_PUPDR6_Msk = 0x3000
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR6_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR6_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR6_PullDown = 0x2
	// Position of PUPDR5 field.
	GPIO_PUPDR_PUPDR5_Pos = 0xa
	// Bit mask of PUPDR5 field.
	GPIO_PUPDR_PUPDR5_Msk = 0xc00
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR5_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR5_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR5_PullDown = 0x2
	// Position of PUPDR4 field.
	GPIO_PUPDR_PUPDR4_Pos = 0x8
	// Bit mask of PUPDR4 field.
	GPIO_PUPDR_PUPDR4_Msk = 0x300
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR4_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR4_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR4_PullDown = 0x2
	// Position of PUPDR3 field.
	GPIO_PUPDR_PUPDR3_Pos = 0x6
	// Bit mask of PUPDR3 field.
	GPIO_PUPDR_PUPDR3_Msk = 0xc0
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR3_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR3_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR3_PullDown = 0x2
	// Position of PUPDR2 field.
	GPIO_PUPDR_PUPDR2_Pos = 0x4
	// Bit mask of PUPDR2 field.
	GPIO_PUPDR_PUPDR2_Msk = 0x30
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR2_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR2_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR2_PullDown = 0x2
	// Position of PUPDR1 field.
	GPIO_PUPDR_PUPDR1_Pos = 0x2
	// Bit mask of PUPDR1 field.
	GPIO_PUPDR_PUPDR1_Msk = 0xc
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR1_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR1_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR1_PullDown = 0x2
	// Position of PUPDR0 field.
	GPIO_PUPDR_PUPDR0_Pos = 0x0
	// Bit mask of PUPDR0 field.
	GPIO_PUPDR_PUPDR0_Msk = 0x3
	// No pull-up, pull-down
	GPIO_PUPDR_PUPDR0_Floating = 0x0
	// Pull-up
	GPIO_PUPDR_PUPDR0_PullUp = 0x1
	// Pull-down
	GPIO_PUPDR_PUPDR0_PullDown = 0x2

	// IDR: GPIO port input data register
	// Position of IDR15 field.
	GPIO_IDR_IDR15_Pos = 0xf
	// Bit mask of IDR15 field.
	GPIO_IDR_IDR15_Msk = 0x8000
	// Bit IDR15.
	GPIO_IDR_IDR15 = 0x8000
	// Input is logic high
	GPIO_IDR_IDR15_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR15_Low = 0x0
	// Position of IDR14 field.
	GPIO_IDR_IDR14_Pos = 0xe
	// Bit mask of IDR14 field.
	GPIO_IDR_IDR14_Msk = 0x4000
	// Bit IDR14.
	GPIO_IDR_IDR14 = 0x4000
	// Input is logic high
	GPIO_IDR_IDR14_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR14_Low = 0x0
	// Position of IDR13 field.
	GPIO_IDR_IDR13_Pos = 0xd
	// Bit mask of IDR13 field.
	GPIO_IDR_IDR13_Msk = 0x2000
	// Bit IDR13.
	GPIO_IDR_IDR13 = 0x2000
	// Input is logic high
	GPIO_IDR_IDR13_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR13_Low = 0x0
	// Position of IDR12 field.
	GPIO_IDR_IDR12_Pos = 0xc
	// Bit mask of IDR12 field.
	GPIO_IDR_IDR12_Msk = 0x1000
	// Bit IDR12.
	GPIO_IDR_IDR12 = 0x1000
	// Input is logic high
	GPIO_IDR_IDR12_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR12_Low = 0x0
	// Position of IDR11 field.
	GPIO_IDR_IDR11_Pos = 0xb
	// Bit mask of IDR11 field.
	GPIO_IDR_IDR11_Msk = 0x800
	// Bit IDR11.
	GPIO_IDR_IDR11 = 0x800
	// Input is logic high
	GPIO_IDR_IDR11_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR11_Low = 0x0
	// Position of IDR10 field.
	GPIO_IDR_IDR10_Pos = 0xa
	// Bit mask of IDR10 field.
	GPIO_IDR_IDR10_Msk = 0x400
	// Bit IDR10.
	GPIO_IDR_IDR10 = 0x400
	// Input is logic high
	GPIO_IDR_IDR10_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR10_Low = 0x0
	// Position of IDR9 field.
	GPIO_IDR_IDR9_Pos = 0x9
	// Bit mask of IDR9 field.
	GPIO_IDR_IDR9_Msk = 0x200
	// Bit IDR9.
	GPIO_IDR_IDR9 = 0x200
	// Input is logic high
	GPIO_IDR_IDR9_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR9_Low = 0x0
	// Position of IDR8 field.
	GPIO_IDR_IDR8_Pos = 0x8
	// Bit mask of IDR8 field.
	GPIO_IDR_IDR8_Msk = 0x100
	// Bit IDR8.
	GPIO_IDR_IDR8 = 0x100
	// Input is logic high
	GPIO_IDR_IDR8_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR8_Low = 0x0
	// Position of IDR7 field.
	GPIO_IDR_IDR7_Pos = 0x7
	// Bit mask of IDR7 field.
	GPIO_IDR_IDR7_Msk = 0x80
	// Bit IDR7.
	GPIO_IDR_IDR7 = 0x80
	// Input is logic high
	GPIO_IDR_IDR7_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR7_Low = 0x0
	// Position of IDR6 field.
	GPIO_IDR_IDR6_Pos = 0x6
	// Bit mask of IDR6 field.
	GPIO_IDR_IDR6_Msk = 0x40
	// Bit IDR6.
	GPIO_IDR_IDR6 = 0x40
	// Input is logic high
	GPIO_IDR_IDR6_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR6_Low = 0x0
	// Position of IDR5 field.
	GPIO_IDR_IDR5_Pos = 0x5
	// Bit mask of IDR5 field.
	GPIO_IDR_IDR5_Msk = 0x20
	// Bit IDR5.
	GPIO_IDR_IDR5 = 0x20
	// Input is logic high
	GPIO_IDR_IDR5_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR5_Low = 0x0
	// Position of IDR4 field.
	GPIO_IDR_IDR4_Pos = 0x4
	// Bit mask of IDR4 field.
	GPIO_IDR_IDR4_Msk = 0x10
	// Bit IDR4.
	GPIO_IDR_IDR4 = 0x10
	// Input is logic high
	GPIO_IDR_IDR4_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR4_Low = 0x0
	// Position of IDR3 field.
	GPIO_IDR_IDR3_Pos = 0x3
	// Bit mask of IDR3 field.
	GPIO_IDR_IDR3_Msk = 0x8
	// Bit IDR3.
	GPIO_IDR_IDR3 = 0x8
	// Input is logic high
	GPIO_IDR_IDR3_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR3_Low = 0x0
	// Position of IDR2 field.
	GPIO_IDR_IDR2_Pos = 0x2
	// Bit mask of IDR2 field.
	GPIO_IDR_IDR2_Msk = 0x4
	// Bit IDR2.
	GPIO_IDR_IDR2 = 0x4
	// Input is logic high
	GPIO_IDR_IDR2_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR2_Low = 0x0
	// Position of IDR1 field.
	GPIO_IDR_IDR1_Pos = 0x1
	// Bit mask of IDR1 field.
	GPIO_IDR_IDR1_Msk = 0x2
	// Bit IDR1.
	GPIO_IDR_IDR1 = 0x2
	// Input is logic high
	GPIO_IDR_IDR1_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR1_Low = 0x0
	// Position of IDR0 field.
	GPIO_IDR_IDR0_Pos = 0x0
	// Bit mask of IDR0 field.
	GPIO_IDR_IDR0_Msk = 0x1
	// Bit IDR0.
	GPIO_IDR_IDR0 = 0x1
	// Input is logic high
	GPIO_IDR_IDR0_High = 0x1
	// Input is logic low
	GPIO_IDR_IDR0_Low = 0x0

	// ODR: GPIO port output data register
	// Position of ODR15 field.
	GPIO_ODR_ODR15_Pos = 0xf
	// Bit mask of ODR15 field.
	GPIO_ODR_ODR15_Msk = 0x8000
	// Bit ODR15.
	GPIO_ODR_ODR15 = 0x8000
	// Set output to logic high
	GPIO_ODR_ODR15_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR15_Low = 0x0
	// Position of ODR14 field.
	GPIO_ODR_ODR14_Pos = 0xe
	// Bit mask of ODR14 field.
	GPIO_ODR_ODR14_Msk = 0x4000
	// Bit ODR14.
	GPIO_ODR_ODR14 = 0x4000
	// Set output to logic high
	GPIO_ODR_ODR14_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR14_Low = 0x0
	// Position of ODR13 field.
	GPIO_ODR_ODR13_Pos = 0xd
	// Bit mask of ODR13 field.
	GPIO_ODR_ODR13_Msk = 0x2000
	// Bit ODR13.
	GPIO_ODR_ODR13 = 0x2000
	// Set output to logic high
	GPIO_ODR_ODR13_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR13_Low = 0x0
	// Position of ODR12 field.
	GPIO_ODR_ODR12_Pos = 0xc
	// Bit mask of ODR12 field.
	GPIO_ODR_ODR12_Msk = 0x1000
	// Bit ODR12.
	GPIO_ODR_ODR12 = 0x1000
	// Set output to logic high
	GPIO_ODR_ODR12_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR12_Low = 0x0
	// Position of ODR11 field.
	GPIO_ODR_ODR11_Pos = 0xb
	// Bit mask of ODR11 field.
	GPIO_ODR_ODR11_Msk = 0x800
	// Bit ODR11.
	GPIO_ODR_ODR11 = 0x800
	// Set output to logic high
	GPIO_ODR_ODR11_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR11_Low = 0x0
	// Position of ODR10 field.
	GPIO_ODR_ODR10_Pos = 0xa
	// Bit mask of ODR10 field.
	GPIO_ODR_ODR10_Msk = 0x400
	// Bit ODR10.
	GPIO_ODR_ODR10 = 0x400
	// Set output to logic high
	GPIO_ODR_ODR10_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR10_Low = 0x0
	// Position of ODR9 field.
	GPIO_ODR_ODR9_Pos = 0x9
	// Bit mask of ODR9 field.
	GPIO_ODR_ODR9_Msk = 0x200
	// Bit ODR9.
	GPIO_ODR_ODR9 = 0x200
	// Set output to logic high
	GPIO_ODR_ODR9_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR9_Low = 0x0
	// Position of ODR8 field.
	GPIO_ODR_ODR8_Pos = 0x8
	// Bit mask of ODR8 field.
	GPIO_ODR_ODR8_Msk = 0x100
	// Bit ODR8.
	GPIO_ODR_ODR8 = 0x100
	// Set output to logic high
	GPIO_ODR_ODR8_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR8_Low = 0x0
	// Position of ODR7 field.
	GPIO_ODR_ODR7_Pos = 0x7
	// Bit mask of ODR7 field.
	GPIO_ODR_ODR7_Msk = 0x80
	// Bit ODR7.
	GPIO_ODR_ODR7 = 0x80
	// Set output to logic high
	GPIO_ODR_ODR7_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR7_Low = 0x0
	// Position of ODR6 field.
	GPIO_ODR_ODR6_Pos = 0x6
	// Bit mask of ODR6 field.
	GPIO_ODR_ODR6_Msk = 0x40
	// Bit ODR6.
	GPIO_ODR_ODR6 = 0x40
	// Set output to logic high
	GPIO_ODR_ODR6_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR6_Low = 0x0
	// Position of ODR5 field.
	GPIO_ODR_ODR5_Pos = 0x5
	// Bit mask of ODR5 field.
	GPIO_ODR_ODR5_Msk = 0x20
	// Bit ODR5.
	GPIO_ODR_ODR5 = 0x20
	// Set output to logic high
	GPIO_ODR_ODR5_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR5_Low = 0x0
	// Position of ODR4 field.
	GPIO_ODR_ODR4_Pos = 0x4
	// Bit mask of ODR4 field.
	GPIO_ODR_ODR4_Msk = 0x10
	// Bit ODR4.
	GPIO_ODR_ODR4 = 0x10
	// Set output to logic high
	GPIO_ODR_ODR4_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR4_Low = 0x0
	// Position of ODR3 field.
	GPIO_ODR_ODR3_Pos = 0x3
	// Bit mask of ODR3 field.
	GPIO_ODR_ODR3_Msk = 0x8
	// Bit ODR3.
	GPIO_ODR_ODR3 = 0x8
	// Set output to logic high
	GPIO_ODR_ODR3_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR3_Low = 0x0
	// Position of ODR2 field.
	GPIO_ODR_ODR2_Pos = 0x2
	// Bit mask of ODR2 field.
	GPIO_ODR_ODR2_Msk = 0x4
	// Bit ODR2.
	GPIO_ODR_ODR2 = 0x4
	// Set output to logic high
	GPIO_ODR_ODR2_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR2_Low = 0x0
	// Position of ODR1 field.
	GPIO_ODR_ODR1_Pos = 0x1
	// Bit mask of ODR1 field.
	GPIO_ODR_ODR1_Msk = 0x2
	// Bit ODR1.
	GPIO_ODR_ODR1 = 0x2
	// Set output to logic high
	GPIO_ODR_ODR1_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR1_Low = 0x0
	// Position of ODR0 field.
	GPIO_ODR_ODR0_Pos = 0x0
	// Bit mask of ODR0 field.
	GPIO_ODR_ODR0_Msk = 0x1
	// Bit ODR0.
	GPIO_ODR_ODR0 = 0x1
	// Set output to logic high
	GPIO_ODR_ODR0_High = 0x1
	// Set output to logic low
	GPIO_ODR_ODR0_Low = 0x0

	// BSRR: GPIO port bit set/reset register
	// Position of BR15 field.
	GPIO_BSRR_BR15_Pos = 0x1f
	// Bit mask of BR15 field.
	GPIO_BSRR_BR15_Msk = 0x80000000
	// Bit BR15.
	GPIO_BSRR_BR15 = 0x80000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR15_Reset = 0x1
	// Position of BR14 field.
	GPIO_BSRR_BR14_Pos = 0x1e
	// Bit mask of BR14 field.
	GPIO_BSRR_BR14_Msk = 0x40000000
	// Bit BR14.
	GPIO_BSRR_BR14 = 0x40000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR14_Reset = 0x1
	// Position of BR13 field.
	GPIO_BSRR_BR13_Pos = 0x1d
	// Bit mask of BR13 field.
	GPIO_BSRR_BR13_Msk = 0x20000000
	// Bit BR13.
	GPIO_BSRR_BR13 = 0x20000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR13_Reset = 0x1
	// Position of BR12 field.
	GPIO_BSRR_BR12_Pos = 0x1c
	// Bit mask of BR12 field.
	GPIO_BSRR_BR12_Msk = 0x10000000
	// Bit BR12.
	GPIO_BSRR_BR12 = 0x10000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR12_Reset = 0x1
	// Position of BR11 field.
	GPIO_BSRR_BR11_Pos = 0x1b
	// Bit mask of BR11 field.
	GPIO_BSRR_BR11_Msk = 0x8000000
	// Bit BR11.
	GPIO_BSRR_BR11 = 0x8000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR11_Reset = 0x1
	// Position of BR10 field.
	GPIO_BSRR_BR10_Pos = 0x1a
	// Bit mask of BR10 field.
	GPIO_BSRR_BR10_Msk = 0x4000000
	// Bit BR10.
	GPIO_BSRR_BR10 = 0x4000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR10_Reset = 0x1
	// Position of BR9 field.
	GPIO_BSRR_BR9_Pos = 0x19
	// Bit mask of BR9 field.
	GPIO_BSRR_BR9_Msk = 0x2000000
	// Bit BR9.
	GPIO_BSRR_BR9 = 0x2000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR9_Reset = 0x1
	// Position of BR8 field.
	GPIO_BSRR_BR8_Pos = 0x18
	// Bit mask of BR8 field.
	GPIO_BSRR_BR8_Msk = 0x1000000
	// Bit BR8.
	GPIO_BSRR_BR8 = 0x1000000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR8_Reset = 0x1
	// Position of BR7 field.
	GPIO_BSRR_BR7_Pos = 0x17
	// Bit mask of BR7 field.
	GPIO_BSRR_BR7_Msk = 0x800000
	// Bit BR7.
	GPIO_BSRR_BR7 = 0x800000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR7_Reset = 0x1
	// Position of BR6 field.
	GPIO_BSRR_BR6_Pos = 0x16
	// Bit mask of BR6 field.
	GPIO_BSRR_BR6_Msk = 0x400000
	// Bit BR6.
	GPIO_BSRR_BR6 = 0x400000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR6_Reset = 0x1
	// Position of BR5 field.
	GPIO_BSRR_BR5_Pos = 0x15
	// Bit mask of BR5 field.
	GPIO_BSRR_BR5_Msk = 0x200000
	// Bit BR5.
	GPIO_BSRR_BR5 = 0x200000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR5_Reset = 0x1
	// Position of BR4 field.
	GPIO_BSRR_BR4_Pos = 0x14
	// Bit mask of BR4 field.
	GPIO_BSRR_BR4_Msk = 0x100000
	// Bit BR4.
	GPIO_BSRR_BR4 = 0x100000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR4_Reset = 0x1
	// Position of BR3 field.
	GPIO_BSRR_BR3_Pos = 0x13
	// Bit mask of BR3 field.
	GPIO_BSRR_BR3_Msk = 0x80000
	// Bit BR3.
	GPIO_BSRR_BR3 = 0x80000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR3_Reset = 0x1
	// Position of BR2 field.
	GPIO_BSRR_BR2_Pos = 0x12
	// Bit mask of BR2 field.
	GPIO_BSRR_BR2_Msk = 0x40000
	// Bit BR2.
	GPIO_BSRR_BR2 = 0x40000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR2_Reset = 0x1
	// Position of BR1 field.
	GPIO_BSRR_BR1_Pos = 0x11
	// Bit mask of BR1 field.
	GPIO_BSRR_BR1_Msk = 0x20000
	// Bit BR1.
	GPIO_BSRR_BR1 = 0x20000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR1_Reset = 0x1
	// Position of BR0 field.
	GPIO_BSRR_BR0_Pos = 0x10
	// Bit mask of BR0 field.
	GPIO_BSRR_BR0_Msk = 0x10000
	// Bit BR0.
	GPIO_BSRR_BR0 = 0x10000
	// Resets the corresponding ODRx bit
	GPIO_BSRR_BR0_Reset = 0x1
	// Position of BS15 field.
	GPIO_BSRR_BS15_Pos = 0xf
	// Bit mask of BS15 field.
	GPIO_BSRR_BS15_Msk = 0x8000
	// Bit BS15.
	GPIO_BSRR_BS15 = 0x8000
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS15_Set = 0x1
	// Position of BS14 field.
	GPIO_BSRR_BS14_Pos = 0xe
	// Bit mask of BS14 field.
	GPIO_BSRR_BS14_Msk = 0x4000
	// Bit BS14.
	GPIO_BSRR_BS14 = 0x4000
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS14_Set = 0x1
	// Position of BS13 field.
	GPIO_BSRR_BS13_Pos = 0xd
	// Bit mask of BS13 field.
	GPIO_BSRR_BS13_Msk = 0x2000
	// Bit BS13.
	GPIO_BSRR_BS13 = 0x2000
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS13_Set = 0x1
	// Position of BS12 field.
	GPIO_BSRR_BS12_Pos = 0xc
	// Bit mask of BS12 field.
	GPIO_BSRR_BS12_Msk = 0x1000
	// Bit BS12.
	GPIO_BSRR_BS12 = 0x1000
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS12_Set = 0x1
	// Position of BS11 field.
	GPIO_BSRR_BS11_Pos = 0xb
	// Bit mask of BS11 field.
	GPIO_BSRR_BS11_Msk = 0x800
	// Bit BS11.
	GPIO_BSRR_BS11 = 0x800
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS11_Set = 0x1
	// Position of BS10 field.
	GPIO_BSRR_BS10_Pos = 0xa
	// Bit mask of BS10 field.
	GPIO_BSRR_BS10_Msk = 0x400
	// Bit BS10.
	GPIO_BSRR_BS10 = 0x400
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS10_Set = 0x1
	// Position of BS9 field.
	GPIO_BSRR_BS9_Pos = 0x9
	// Bit mask of BS9 field.
	GPIO_BSRR_BS9_Msk = 0x200
	// Bit BS9.
	GPIO_BSRR_BS9 = 0x200
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS9_Set = 0x1
	// Position of BS8 field.
	GPIO_BSRR_BS8_Pos = 0x8
	// Bit mask of BS8 field.
	GPIO_BSRR_BS8_Msk = 0x100
	// Bit BS8.
	GPIO_BSRR_BS8 = 0x100
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS8_Set = 0x1
	// Position of BS7 field.
	GPIO_BSRR_BS7_Pos = 0x7
	// Bit mask of BS7 field.
	GPIO_BSRR_BS7_Msk = 0x80
	// Bit BS7.
	GPIO_BSRR_BS7 = 0x80
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS7_Set = 0x1
	// Position of BS6 field.
	GPIO_BSRR_BS6_Pos = 0x6
	// Bit mask of BS6 field.
	GPIO_BSRR_BS6_Msk = 0x40
	// Bit BS6.
	GPIO_BSRR_BS6 = 0x40
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS6_Set = 0x1
	// Position of BS5 field.
	GPIO_BSRR_BS5_Pos = 0x5
	// Bit mask of BS5 field.
	GPIO_BSRR_BS5_Msk = 0x20
	// Bit BS5.
	GPIO_BSRR_BS5 = 0x20
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS5_Set = 0x1
	// Position of BS4 field.
	GPIO_BSRR_BS4_Pos = 0x4
	// Bit mask of BS4 field.
	GPIO_BSRR_BS4_Msk = 0x10
	// Bit BS4.
	GPIO_BSRR_BS4 = 0x10
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS4_Set = 0x1
	// Position of BS3 field.
	GPIO_BSRR_BS3_Pos = 0x3
	// Bit mask of BS3 field.
	GPIO_BSRR_BS3_Msk = 0x8
	// Bit BS3.
	GPIO_BSRR_BS3 = 0x8
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS3_Set = 0x1
	// Position of BS2 field.
	GPIO_BSRR_BS2_Pos = 0x2
	// Bit mask of BS2 field.
	GPIO_BSRR_BS2_Msk = 0x4
	// Bit BS2.
	GPIO_BSRR_BS2 = 0x4
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS2_Set = 0x1
	// Position of BS1 field.
	GPIO_BSRR_BS1_Pos = 0x1
	// Bit mask of BS1 field.
	GPIO_BSRR_BS1_Msk = 0x2
	// Bit BS1.
	GPIO_BSRR_BS1 = 0x2
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS1_Set = 0x1
	// Position of BS0 field.
	GPIO_BSRR_BS0_Pos = 0x0
	// Bit mask of BS0 field.
	GPIO_BSRR_BS0_Msk = 0x1
	// Bit BS0.
	GPIO_BSRR_BS0 = 0x1
	// Sets the corresponding ODRx bit
	GPIO_BSRR_BS0_Set = 0x1

	// LCKR: GPIO port configuration lock register
	// Position of LCKK field.
	GPIO_LCKR_LCKK_Pos = 0x10
	// Bit mask of LCKK field.
	GPIO_LCKR_LCKK_Msk = 0x10000
	// Bit LCKK.
	GPIO_LCKR_LCKK = 0x10000
	// Port configuration lock key not active
	GPIO_LCKR_LCKK_NotActive = 0x0
	// Port configuration lock key active
	GPIO_LCKR_LCKK_Active = 0x1
	// Position of LCK15 field.
	GPIO_LCKR_LCK15_Pos = 0xf
	// Bit mask of LCK15 field.
	GPIO_LCKR_LCK15_Msk = 0x8000
	// Bit LCK15.
	GPIO_LCKR_LCK15 = 0x8000
	// Port configuration not locked
	GPIO_LCKR_LCK15_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK15_Locked = 0x1
	// Position of LCK14 field.
	GPIO_LCKR_LCK14_Pos = 0xe
	// Bit mask of LCK14 field.
	GPIO_LCKR_LCK14_Msk = 0x4000
	// Bit LCK14.
	GPIO_LCKR_LCK14 = 0x4000
	// Port configuration not locked
	GPIO_LCKR_LCK14_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK14_Locked = 0x1
	// Position of LCK13 field.
	GPIO_LCKR_LCK13_Pos = 0xd
	// Bit mask of LCK13 field.
	GPIO_LCKR_LCK13_Msk = 0x2000
	// Bit LCK13.
	GPIO_LCKR_LCK13 = 0x2000
	// Port configuration not locked
	GPIO_LCKR_LCK13_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK13_Locked = 0x1
	// Position of LCK12 field.
	GPIO_LCKR_LCK12_Pos = 0xc
	// Bit mask of LCK12 field.
	GPIO_LCKR_LCK12_Msk = 0x1000
	// Bit LCK12.
	GPIO_LCKR_LCK12 = 0x1000
	// Port configuration not locked
	GPIO_LCKR_LCK12_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK12_Locked = 0x1
	// Position of LCK11 field.
	GPIO_LCKR_LCK11_Pos = 0xb
	// Bit mask of LCK11 field.
	GPIO_LCKR_LCK11_Msk = 0x800
	// Bit LCK11.
	GPIO_LCKR_LCK11 = 0x800
	// Port configuration not locked
	GPIO_LCKR_LCK11_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK11_Locked = 0x1
	// Position of LCK10 field.
	GPIO_LCKR_LCK10_Pos = 0xa
	// Bit mask of LCK10 field.
	GPIO_LCKR_LCK10_Msk = 0x400
	// Bit LCK10.
	GPIO_LCKR_LCK10 = 0x400
	// Port configuration not locked
	GPIO_LCKR_LCK10_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK10_Locked = 0x1
	// Position of LCK9 field.
	GPIO_LCKR_LCK9_Pos = 0x9
	// Bit mask of LCK9 field.
	GPIO_LCKR_LCK9_Msk = 0x200
	// Bit LCK9.
	GPIO_LCKR_LCK9 = 0x200
	// Port configuration not locked
	GPIO_LCKR_LCK9_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK9_Locked = 0x1
	// Position of LCK8 field.
	GPIO_LCKR_LCK8_Pos = 0x8
	// Bit mask of LCK8 field.
	GPIO_LCKR_LCK8_Msk = 0x100
	// Bit LCK8.
	GPIO_LCKR_LCK8 = 0x100
	// Port configuration not locked
	GPIO_LCKR_LCK8_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK8_Locked = 0x1
	// Position of LCK7 field.
	GPIO_LCKR_LCK7_Pos = 0x7
	// Bit mask of LCK7 field.
	GPIO_LCKR_LCK7_Msk = 0x80
	// Bit LCK7.
	GPIO_LCKR_LCK7 = 0x80
	// Port configuration not locked
	GPIO_LCKR_LCK7_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK7_Locked = 0x1
	// Position of LCK6 field.
	GPIO_LCKR_LCK6_Pos = 0x6
	// Bit mask of LCK6 field.
	GPIO_LCKR_LCK6_Msk = 0x40
	// Bit LCK6.
	GPIO_LCKR_LCK6 = 0x40
	// Port configuration not locked
	GPIO_LCKR_LCK6_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK6_Locked = 0x1
	// Position of LCK5 field.
	GPIO_LCKR_LCK5_Pos = 0x5
	// Bit mask of LCK5 field.
	GPIO_LCKR_LCK5_Msk = 0x20
	// Bit LCK5.
	GPIO_LCKR_LCK5 = 0x20
	// Port configuration not locked
	GPIO_LCKR_LCK5_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK5_Locked = 0x1
	// Position of LCK4 field.
	GPIO_LCKR_LCK4_Pos = 0x4
	// Bit mask of LCK4 field.
	GPIO_LCKR_LCK4_Msk = 0x10
	// Bit LCK4.
	GPIO_LCKR_LCK4 = 0x10
	// Port configuration not locked
	GPIO_LCKR_LCK4_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK4_Locked = 0x1
	// Position of LCK3 field.
	GPIO_LCKR_LCK3_Pos = 0x3
	// Bit mask of LCK3 field.
	GPIO_LCKR_LCK3_Msk = 0x8
	// Bit LCK3.
	GPIO_LCKR_LCK3 = 0x8
	// Port configuration not locked
	GPIO_LCKR_LCK3_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK3_Locked = 0x1
	// Position of LCK2 field.
	GPIO_LCKR_LCK2_Pos = 0x2
	// Bit mask of LCK2 field.
	GPIO_LCKR_LCK2_Msk = 0x4
	// Bit LCK2.
	GPIO_LCKR_LCK2 = 0x4
	// Port configuration not locked
	GPIO_LCKR_LCK2_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK2_Locked = 0x1
	// Position of LCK1 field.
	GPIO_LCKR_LCK1_Pos = 0x1
	// Bit mask of LCK1 field.
	GPIO_LCKR_LCK1_Msk = 0x2
	// Bit LCK1.
	GPIO_LCKR_LCK1 = 0x2
	// Port configuration not locked
	GPIO_LCKR_LCK1_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK1_Locked = 0x1
	// Position of LCK0 field.
	GPIO_LCKR_LCK0_Pos = 0x0
	// Bit mask of LCK0 field.
	GPIO_LCKR_LCK0_Msk = 0x1
	// Bit LCK0.
	GPIO_LCKR_LCK0 = 0x1
	// Port configuration not locked
	GPIO_LCKR_LCK0_Unlocked = 0x0
	// Port configuration locked
	GPIO_LCKR_LCK0_Locked = 0x1

	// AFRL: GPIO alternate function lowregister
	// Position of AFRL7 field.
	GPIO_AFRL_AFRL7_Pos = 0x1c
	// Bit mask of AFRL7 field.
	GPIO_AFRL_AFRL7_Msk = 0xf0000000
	// AF0
	GPIO_AFRL_AFRL7_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL7_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL7_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL7_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL7_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL7_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL7_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL7_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL7_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL7_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL7_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL7_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL7_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL7_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL7_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL7_AF15 = 0xf
	// Position of AFRL6 field.
	GPIO_AFRL_AFRL6_Pos = 0x18
	// Bit mask of AFRL6 field.
	GPIO_AFRL_AFRL6_Msk = 0xf000000
	// AF0
	GPIO_AFRL_AFRL6_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL6_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL6_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL6_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL6_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL6_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL6_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL6_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL6_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL6_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL6_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL6_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL6_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL6_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL6_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL6_AF15 = 0xf
	// Position of AFRL5 field.
	GPIO_AFRL_AFRL5_Pos = 0x14
	// Bit mask of AFRL5 field.
	GPIO_AFRL_AFRL5_Msk = 0xf00000
	// AF0
	GPIO_AFRL_AFRL5_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL5_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL5_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL5_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL5_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL5_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL5_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL5_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL5_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL5_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL5_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL5_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL5_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL5_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL5_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL5_AF15 = 0xf
	// Position of AFRL4 field.
	GPIO_AFRL_AFRL4_Pos = 0x10
	// Bit mask of AFRL4 field.
	GPIO_AFRL_AFRL4_Msk = 0xf0000
	// AF0
	GPIO_AFRL_AFRL4_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL4_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL4_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL4_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL4_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL4_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL4_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL4_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL4_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL4_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL4_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL4_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL4_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL4_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL4_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL4_AF15 = 0xf
	// Position of AFRL3 field.
	GPIO_AFRL_AFRL3_Pos = 0xc
	// Bit mask of AFRL3 field.
	GPIO_AFRL_AFRL3_Msk = 0xf000
	// AF0
	GPIO_AFRL_AFRL3_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL3_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL3_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL3_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL3_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL3_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL3_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL3_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL3_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL3_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL3_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL3_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL3_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL3_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL3_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL3_AF15 = 0xf
	// Position of AFRL2 field.
	GPIO_AFRL_AFRL2_Pos = 0x8
	// Bit mask of AFRL2 field.
	GPIO_AFRL_AFRL2_Msk = 0xf00
	// AF0
	GPIO_AFRL_AFRL2_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL2_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL2_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL2_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL2_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL2_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL2_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL2_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL2_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL2_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL2_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL2_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL2_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL2_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL2_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL2_AF15 = 0xf
	// Position of AFRL1 field.
	GPIO_AFRL_AFRL1_Pos = 0x4
	// Bit mask of AFRL1 field.
	GPIO_AFRL_AFRL1_Msk = 0xf0
	// AF0
	GPIO_AFRL_AFRL1_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL1_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL1_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL1_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL1_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL1_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL1_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL1_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL1_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL1_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL1_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL1_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL1_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL1_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL1_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL1_AF15 = 0xf
	// Position of AFRL0 field.
	GPIO_AFRL_AFRL0_Pos = 0x0
	// Bit mask of AFRL0 field.
	GPIO_AFRL_AFRL0_Msk = 0xf
	// AF0
	GPIO_AFRL_AFRL0_AF0 = 0x0
	// AF1
	GPIO_AFRL_AFRL0_AF1 = 0x1
	// AF2
	GPIO_AFRL_AFRL0_AF2 = 0x2
	// AF3
	GPIO_AFRL_AFRL0_AF3 = 0x3
	// AF4
	GPIO_AFRL_AFRL0_AF4 = 0x4
	// AF5
	GPIO_AFRL_AFRL0_AF5 = 0x5
	// AF6
	GPIO_AFRL_AFRL0_AF6 = 0x6
	// AF7
	GPIO_AFRL_AFRL0_AF7 = 0x7
	// AF8
	GPIO_AFRL_AFRL0_AF8 = 0x8
	// AF9
	GPIO_AFRL_AFRL0_AF9 = 0x9
	// AF10
	GPIO_AFRL_AFRL0_AF10 = 0xa
	// AF11
	GPIO_AFRL_AFRL0_AF11 = 0xb
	// AF12
	GPIO_AFRL_AFRL0_AF12 = 0xc
	// AF13
	GPIO_AFRL_AFRL0_AF13 = 0xd
	// AF14
	GPIO_AFRL_AFRL0_AF14 = 0xe
	// AF15
	GPIO_AFRL_AFRL0_AF15 = 0xf

	// AFRH: GPIO alternate function high register
	// Position of AFRH15 field.
	GPIO_AFRH_AFRH15_Pos = 0x1c
	// Bit mask of AFRH15 field.
	GPIO_AFRH_AFRH15_Msk = 0xf0000000
	// AF0
	GPIO_AFRH_AFRH15_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH15_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH15_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH15_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH15_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH15_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH15_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH15_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH15_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH15_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH15_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH15_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH15_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH15_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH15_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH15_AF15 = 0xf
	// Position of AFRH14 field.
	GPIO_AFRH_AFRH14_Pos = 0x18
	// Bit mask of AFRH14 field.
	GPIO_AFRH_AFRH14_Msk = 0xf000000
	// AF0
	GPIO_AFRH_AFRH14_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH14_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH14_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH14_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH14_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH14_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH14_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH14_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH14_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH14_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH14_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH14_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH14_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH14_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH14_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH14_AF15 = 0xf
	// Position of AFRH13 field.
	GPIO_AFRH_AFRH13_Pos = 0x14
	// Bit mask of AFRH13 field.
	GPIO_AFRH_AFRH13_Msk = 0xf00000
	// AF0
	GPIO_AFRH_AFRH13_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH13_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH13_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH13_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH13_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH13_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH13_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH13_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH13_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH13_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH13_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH13_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH13_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH13_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH13_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH13_AF15 = 0xf
	// Position of AFRH12 field.
	GPIO_AFRH_AFRH12_Pos = 0x10
	// Bit mask of AFRH12 field.
	GPIO_AFRH_AFRH12_Msk = 0xf0000
	// AF0
	GPIO_AFRH_AFRH12_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH12_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH12_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH12_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH12_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH12_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH12_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH12_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH12_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH12_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH12_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH12_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH12_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH12_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH12_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH12_AF15 = 0xf
	// Position of AFRH11 field.
	GPIO_AFRH_AFRH11_Pos = 0xc
	// Bit mask of AFRH11 field.
	GPIO_AFRH_AFRH11_Msk = 0xf000
	// AF0
	GPIO_AFRH_AFRH11_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH11_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH11_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH11_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH11_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH11_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH11_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH11_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH11_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH11_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH11_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH11_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH11_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH11_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH11_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH11_AF15 = 0xf
	// Position of AFRH10 field.
	GPIO_AFRH_AFRH10_Pos = 0x8
	// Bit mask of AFRH10 field.
	GPIO_AFRH_AFRH10_Msk = 0xf00
	// AF0
	GPIO_AFRH_AFRH10_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH10_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH10_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH10_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH10_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH10_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH10_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH10_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH10_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH10_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH10_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH10_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH10_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH10_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH10_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH10_AF15 = 0xf
	// Position of AFRH9 field.
	GPIO_AFRH_AFRH9_Pos = 0x4
	// Bit mask of AFRH9 field.
	GPIO_AFRH_AFRH9_Msk = 0xf0
	// AF0
	GPIO_AFRH_AFRH9_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH9_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH9_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH9_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH9_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH9_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH9_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH9_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH9_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH9_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH9_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH9_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH9_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH9_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH9_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH9_AF15 = 0xf
	// Position of AFRH8 field.
	GPIO_AFRH_AFRH8_Pos = 0x0
	// Bit mask of AFRH8 field.
	GPIO_AFRH_AFRH8_Msk = 0xf
	// AF0
	GPIO_AFRH_AFRH8_AF0 = 0x0
	// AF1
	GPIO_AFRH_AFRH8_AF1 = 0x1
	// AF2
	GPIO_AFRH_AFRH8_AF2 = 0x2
	// AF3
	GPIO_AFRH_AFRH8_AF3 = 0x3
	// AF4
	GPIO_AFRH_AFRH8_AF4 = 0x4
	// AF5
	GPIO_AFRH_AFRH8_AF5 = 0x5
	// AF6
	GPIO_AFRH_AFRH8_AF6 = 0x6
	// AF7
	GPIO_AFRH_AFRH8_AF7 = 0x7
	// AF8
	GPIO_AFRH_AFRH8_AF8 = 0x8
	// AF9
	GPIO_AFRH_AFRH8_AF9 = 0x9
	// AF10
	GPIO_AFRH_AFRH8_AF10 = 0xa
	// AF11
	GPIO_AFRH_AFRH8_AF11 = 0xb
	// AF12
	GPIO_AFRH_AFRH8_AF12 = 0xc
	// AF13
	GPIO_AFRH_AFRH8_AF13 = 0xd
	// AF14
	GPIO_AFRH_AFRH8_AF14 = 0xe
	// AF15
	GPIO_AFRH_AFRH8_AF15 = 0xf

	// BRR: GPIO port bit reset register
	// Position of BR0 field.
	GPIO_BRR_BR0_Pos = 0x0
	// Bit mask of BR0 field.
	GPIO_BRR_BR0_Msk = 0x1
	// Bit BR0.
	GPIO_BRR_BR0 = 0x1
	// Position of BR1 field.
	GPIO_BRR_BR1_Pos = 0x1
	// Bit mask of BR1 field.
	GPIO_BRR_BR1_Msk = 0x2
	// Bit BR1.
	GPIO_BRR_BR1 = 0x2
	// Position of BR2 field.
	GPIO_BRR_BR2_Pos = 0x2
	// Bit mask of BR2 field.
	GPIO_BRR_BR2_Msk = 0x4
	// Bit BR2.
	GPIO_BRR_BR2 = 0x4
	// Position of BR3 field.
	GPIO_BRR_BR3_Pos = 0x3
	// Bit mask of BR3 field.
	GPIO_BRR_BR3_Msk = 0x8
	// Bit BR3.
	GPIO_BRR_BR3 = 0x8
	// Position of BR4 field.
	GPIO_BRR_BR4_Pos = 0x4
	// Bit mask of BR4 field.
	GPIO_BRR_BR4_Msk = 0x10
	// Bit BR4.
	GPIO_BRR_BR4 = 0x10
	// Position of BR5 field.
	GPIO_BRR_BR5_Pos = 0x5
	// Bit mask of BR5 field.
	GPIO_BRR_BR5_Msk = 0x20
	// Bit BR5.
	GPIO_BRR_BR5 = 0x20
	// Position of BR6 field.
	GPIO_BRR_BR6_Pos = 0x6
	// Bit mask of BR6 field.
	GPIO_BRR_BR6_Msk = 0x40
	// Bit BR6.
	GPIO_BRR_BR6 = 0x40
	// Position of BR7 field.
	GPIO_BRR_BR7_Pos = 0x7
	// Bit mask of BR7 field.
	GPIO_BRR_BR7_Msk = 0x80
	// Bit BR7.
	GPIO_BRR_BR7 = 0x80
	// Position of BR8 field.
	GPIO_BRR_BR8_Pos = 0x8
	// Bit mask of BR8 field.
	GPIO_BRR_BR8_Msk = 0x100
	// Bit BR8.
	GPIO_BRR_BR8 = 0x100
	// Position of BR9 field.
	GPIO_BRR_BR9_Pos = 0x9
	// Bit mask of BR9 field.
	GPIO_BRR_BR9_Msk = 0x200
	// Bit BR9.
	GPIO_BRR_BR9 = 0x200
	// Position of BR10 field.
	GPIO_BRR_BR10_Pos = 0xa
	// Bit mask of BR10 field.
	GPIO_BRR_BR10_Msk = 0x400
	// Bit BR10.
	GPIO_BRR_BR10 = 0x400
	// Position of BR11 field.
	GPIO_BRR_BR11_Pos = 0xb
	// Bit mask of BR11 field.
	GPIO_BRR_BR11_Msk = 0x800
	// Bit BR11.
	GPIO_BRR_BR11 = 0x800
	// Position of BR12 field.
	GPIO_BRR_BR12_Pos = 0xc
	// Bit mask of BR12 field.
	GPIO_BRR_BR12_Msk = 0x1000
	// Bit BR12.
	GPIO_BRR_BR12 = 0x1000
	// Position of BR13 field.
	GPIO_BRR_BR13_Pos = 0xd
	// Bit mask of BR13 field.
	GPIO_BRR_BR13_Msk = 0x2000
	// Bit BR13.
	GPIO_BRR_BR13 = 0x2000
	// Position of BR14 field.
	GPIO_BRR_BR14_Pos = 0xe
	// Bit mask of BR14 field.
	GPIO_BRR_BR14_Msk = 0x4000
	// Bit BR14.
	GPIO_BRR_BR14 = 0x4000
	// Position of BR15 field.
	GPIO_BRR_BR15_Pos = 0xf
	// Bit mask of BR15 field.
	GPIO_BRR_BR15_Msk = 0x8000
	// Bit BR15.
	GPIO_BRR_BR15 = 0x8000
)

// Constants for SYSCFG: System configuration controller
const (
	// MEMRMP: memory remap register
	// Position of MEM_BOOT field.
	SYSCFG_MEMRMP_MEM_BOOT_Pos = 0x0
	// Bit mask of MEM_BOOT field.
	SYSCFG_MEMRMP_MEM_BOOT_Msk = 0x1
	// Bit MEM_BOOT.
	SYSCFG_MEMRMP_MEM_BOOT = 0x1
	// Position of FB_MODE field.
	SYSCFG_MEMRMP_FB_MODE_Pos = 0x8
	// Bit mask of FB_MODE field.
	SYSCFG_MEMRMP_FB_MODE_Msk = 0x100
	// Bit FB_MODE.
	SYSCFG_MEMRMP_FB_MODE = 0x100
	// Position of SWP_FMC field.
	SYSCFG_MEMRMP_SWP_FMC_Pos = 0xa
	// Bit mask of SWP_FMC field.
	SYSCFG_MEMRMP_SWP_FMC_Msk = 0xc00

	// PMC: peripheral mode configuration register
	// Position of MII_RMII_SEL field.
	SYSCFG_PMC_MII_RMII_SEL_Pos = 0x17
	// Bit mask of MII_RMII_SEL field.
	SYSCFG_PMC_MII_RMII_SEL_Msk = 0x800000
	// Bit MII_RMII_SEL.
	SYSCFG_PMC_MII_RMII_SEL = 0x800000
	// Position of ADC1DC2 field.
	SYSCFG_PMC_ADC1DC2_Pos = 0x10
	// Bit mask of ADC1DC2 field.
	SYSCFG_PMC_ADC1DC2_Msk = 0x10000
	// Bit ADC1DC2.
	SYSCFG_PMC_ADC1DC2 = 0x10000
	// Position of ADC2DC2 field.
	SYSCFG_PMC_ADC2DC2_Pos = 0x11
	// Bit mask of ADC2DC2 field.
	SYSCFG_PMC_ADC2DC2_Msk = 0x20000
	// Bit ADC2DC2.
	SYSCFG_PMC_ADC2DC2 = 0x20000
	// Position of ADC3DC2 field.
	SYSCFG_PMC_ADC3DC2_Pos = 0x12
	// Bit mask of ADC3DC2 field.
	SYSCFG_PMC_ADC3DC2_Msk = 0x40000
	// Bit ADC3DC2.
	SYSCFG_PMC_ADC3DC2 = 0x40000
	// Position of PB9_FMP field.
	SYSCFG_PMC_PB9_FMP_Pos = 0x7
	// Bit mask of PB9_FMP field.
	SYSCFG_PMC_PB9_FMP_Msk = 0x80
	// Bit PB9_FMP.
	SYSCFG_PMC_PB9_FMP = 0x80
	// Position of PB8_FMP field.
	SYSCFG_PMC_PB8_FMP_Pos = 0x6
	// Bit mask of PB8_FMP field.
	SYSCFG_PMC_PB8_FMP_Msk = 0x40
	// Bit PB8_FMP.
	SYSCFG_PMC_PB8_FMP = 0x40
	// Position of PB7_FMP field.
	SYSCFG_PMC_PB7_FMP_Pos = 0x5
	// Bit mask of PB7_FMP field.
	SYSCFG_PMC_PB7_FMP_Msk = 0x20
	// Bit PB7_FMP.
	SYSCFG_PMC_PB7_FMP = 0x20
	// Position of PB6_FMP field.
	SYSCFG_PMC_PB6_FMP_Pos = 0x4
	// Bit mask of PB6_FMP field.
	SYSCFG_PMC_PB6_FMP_Msk = 0x10
	// Bit PB6_FMP.
	SYSCFG_PMC_PB6_FMP = 0x10
	// Position of I2C4_FMP field.
	SYSCFG_PMC_I2C4_FMP_Pos = 0x3
	// Bit mask of I2C4_FMP field.
	SYSCFG_PMC_I2C4_FMP_Msk = 0x8
	// Bit I2C4_FMP.
	SYSCFG_PMC_I2C4_FMP = 0x8
	// Position of I2C3_FMP field.
	SYSCFG_PMC_I2C3_FMP_Pos = 0x2
	// Bit mask of I2C3_FMP field.
	SYSCFG_PMC_I2C3_FMP_Msk = 0x4
	// Bit I2C3_FMP.
	SYSCFG_PMC_I2C3_FMP = 0x4
	// Position of I2C2_FMP field.
	SYSCFG_PMC_I2C2_FMP_Pos = 0x1
	// Bit mask of I2C2_FMP field.
	SYSCFG_PMC_I2C2_FMP_Msk = 0x2
	// Bit I2C2_FMP.
	SYSCFG_PMC_I2C2_FMP = 0x2
	// Position of I2C1_FMP field.
	SYSCFG_PMC_I2C1_FMP_Pos = 0x0
	// Bit mask of I2C1_FMP field.
	SYSCFG_PMC_I2C1_FMP_Msk = 0x1
	// Bit I2C1_FMP.
	SYSCFG_PMC_I2C1_FMP = 0x1

	// EXTICR1: external interrupt configuration register 1
	// Position of EXTI3 field.
	SYSCFG_EXTICR1_EXTI3_Pos = 0xc
	// Bit mask of EXTI3 field.
	SYSCFG_EXTICR1_EXTI3_Msk = 0xf000
	// Position of EXTI2 field.
	SYSCFG_EXTICR1_EXTI2_Pos = 0x8
	// Bit mask of EXTI2 field.
	SYSCFG_EXTICR1_EXTI2_Msk = 0xf00
	// Position of EXTI1 field.
	SYSCFG_EXTICR1_EXTI1_Pos = 0x4
	// Bit mask of EXTI1 field.
	SYSCFG_EXTICR1_EXTI1_Msk = 0xf0
	// Position of EXTI0 field.
	SYSCFG_EXTICR1_EXTI0_Pos = 0x0
	// Bit mask of EXTI0 field.
	SYSCFG_EXTICR1_EXTI0_Msk = 0xf

	// EXTICR2: external interrupt configuration register 2
	// Position of EXTI7 field.
	SYSCFG_EXTICR2_EXTI7_Pos = 0xc
	// Bit mask of EXTI7 field.
	SYSCFG_EXTICR2_EXTI7_Msk = 0xf000
	// Position of EXTI6 field.
	SYSCFG_EXTICR2_EXTI6_Pos = 0x8
	// Bit mask of EXTI6 field.
	SYSCFG_EXTICR2_EXTI6_Msk = 0xf00
	// Position of EXTI5 field.
	SYSCFG_EXTICR2_EXTI5_Pos = 0x4
	// Bit mask of EXTI5 field.
	SYSCFG_EXTICR2_EXTI5_Msk = 0xf0
	// Position of EXTI4 field.
	SYSCFG_EXTICR2_EXTI4_Pos = 0x0
	// Bit mask of EXTI4 field.
	SYSCFG_EXTICR2_EXTI4_Msk = 0xf

	// EXTICR3: external interrupt configuration register 3
	// Position of EXTI11 field.
	SYSCFG_EXTICR3_EXTI11_Pos = 0xc
	// Bit mask of EXTI11 field.
	SYSCFG_EXTICR3_EXTI11_Msk = 0xf000
	// Position of EXTI10 field.
	SYSCFG_EXTICR3_EXTI10_Pos = 0x8
	// Bit mask of EXTI10 field.
	SYSCFG_EXTICR3_EXTI10_Msk = 0xf00
	// Position of EXTI9 field.
	SYSCFG_EXTICR3_EXTI9_Pos = 0x4
	// Bit mask of EXTI9 field.
	SYSCFG_EXTICR3_EXTI9_Msk = 0xf0
	// Position of EXTI8 field.
	SYSCFG_EXTICR3_EXTI8_Pos = 0x0
	// Bit mask of EXTI8 field.
	SYSCFG_EXTICR3_EXTI8_Msk = 0xf

	// EXTICR4: external interrupt configuration register 4
	// Position of EXTI15 field.
	SYSCFG_EXTICR4_EXTI15_Pos = 0xc
	// Bit mask of EXTI15 field.
	SYSCFG_EXTICR4_EXTI15_Msk = 0xf000
	// Position of EXTI14 field.
	SYSCFG_EXTICR4_EXTI14_Pos = 0x8
	// Bit mask of EXTI14 field.
	SYSCFG_EXTICR4_EXTI14_Msk = 0xf00
	// Position of EXTI13 field.
	SYSCFG_EXTICR4_EXTI13_Pos = 0x4
	// Bit mask of EXTI13 field.
	SYSCFG_EXTICR4_EXTI13_Msk = 0xf0
	// Position of EXTI12 field.
	SYSCFG_EXTICR4_EXTI12_Pos = 0x0
	// Bit mask of EXTI12 field.
	SYSCFG_EXTICR4_EXTI12_Msk = 0xf

	// CMPCR: Compensation cell control register
	// Position of READY field.
	SYSCFG_CMPCR_READY_Pos = 0x8
	// Bit mask of READY field.
	SYSCFG_CMPCR_READY_Msk = 0x100
	// Bit READY.
	SYSCFG_CMPCR_READY = 0x100
	// Position of CMP_PD field.
	SYSCFG_CMPCR_CMP_PD_Pos = 0x0
	// Bit mask of CMP_PD field.
	SYSCFG_CMPCR_CMP_PD_Msk = 0x1
	// Bit CMP_PD.
	SYSCFG_CMPCR_CMP_PD = 0x1
)

// Constants for SPI1: Serial peripheral interface
const (
	// CR1: control register 1
	// Position of BIDIMODE field.
	SPI_CR1_BIDIMODE_Pos = 0xf
	// Bit mask of BIDIMODE field.
	SPI_CR1_BIDIMODE_Msk = 0x8000
	// Bit BIDIMODE.
	SPI_CR1_BIDIMODE = 0x8000
	// 2-line unidirectional data mode selected
	SPI_CR1_BIDIMODE_Unidirectional = 0x0
	// 1-line bidirectional data mode selected
	SPI_CR1_BIDIMODE_Bidirectional = 0x1
	// Position of BIDIOE field.
	SPI_CR1_BIDIOE_Pos = 0xe
	// Bit mask of BIDIOE field.
	SPI_CR1_BIDIOE_Msk = 0x4000
	// Bit BIDIOE.
	SPI_CR1_BIDIOE = 0x4000
	// Output disabled (receive-only mode)
	SPI_CR1_BIDIOE_OutputDisabled = 0x0
	// Output enabled (transmit-only mode)
	SPI_CR1_BIDIOE_OutputEnabled = 0x1
	// Position of CRCEN field.
	SPI_CR1_CRCEN_Pos = 0xd
	// Bit mask of CRCEN field.
	SPI_CR1_CRCEN_Msk = 0x2000
	// Bit CRCEN.
	SPI_CR1_CRCEN = 0x2000
	// CRC calculation disabled
	SPI_CR1_CRCEN_Disabled = 0x0
	// CRC calculation enabled
	SPI_CR1_CRCEN_Enabled = 0x1
	// Position of CRCNEXT field.
	SPI_CR1_CRCNEXT_Pos = 0xc
	// Bit mask of CRCNEXT field.
	SPI_CR1_CRCNEXT_Msk = 0x1000
	// Bit CRCNEXT.
	SPI_CR1_CRCNEXT = 0x1000
	// Next transmit value is from Tx buffer
	SPI_CR1_CRCNEXT_TxBuffer = 0x0
	// Next transmit value is from Tx CRC register
	SPI_CR1_CRCNEXT_CRC = 0x1
	// Position of CRCL field.
	SPI_CR1_CRCL_Pos = 0xb
	// Bit mask of CRCL field.
	SPI_CR1_CRCL_Msk = 0x800
	// Bit CRCL.
	SPI_CR1_CRCL = 0x800
	// 8-bit CRC length
	SPI_CR1_CRCL_EightBit = 0x0
	// 16-bit CRC length
	SPI_CR1_CRCL_SixteenBit = 0x1
	// Position of RXONLY field.
	SPI_CR1_RXONLY_Pos = 0xa
	// Bit mask of RXONLY field.
	SPI_CR1_RXONLY_Msk = 0x400
	// Bit RXONLY.
	SPI_CR1_RXONLY = 0x400
	// Full duplex (Transmit and receive)
	SPI_CR1_RXONLY_FullDuplex = 0x0
	// Output disabled (Receive-only mode)
	SPI_CR1_RXONLY_OutputDisabled = 0x1
	// Position of SSM field.
	SPI_CR1_SSM_Pos = 0x9
	// Bit mask of SSM field.
	SPI_CR1_SSM_Msk = 0x200
	// Bit SSM.
	SPI_CR1_SSM = 0x200
	// Software slave management disabled
	SPI_CR1_SSM_Disabled = 0x0
	// Software slave management enabled
	SPI_CR1_SSM_Enabled = 0x1
	// Position of SSI field.
	SPI_CR1_SSI_Pos = 0x8
	// Bit mask of SSI field.
	SPI_CR1_SSI_Msk = 0x100
	// Bit SSI.
	SPI_CR1_SSI = 0x100
	// 0 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
	SPI_CR1_SSI_SlaveSelected = 0x0
	// 1 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
	SPI_CR1_SSI_SlaveNotSelected = 0x1
	// Position of LSBFIRST field.
	SPI_CR1_LSBFIRST_Pos = 0x7
	// Bit mask of LSBFIRST field.
	SPI_CR1_LSBFIRST_Msk = 0x80
	// Bit LSBFIRST.
	SPI_CR1_LSBFIRST = 0x80
	// Data is transmitted/received with the MSB first
	SPI_CR1_LSBFIRST_MSBFirst = 0x0
	// Data is transmitted/received with the LSB first
	SPI_CR1_LSBFIRST_LSBFirst = 0x1
	// Position of SPE field.
	SPI_CR1_SPE_Pos = 0x6
	// Bit mask of SPE field.
	SPI_CR1_SPE_Msk = 0x40
	// Bit SPE.
	SPI_CR1_SPE = 0x40
	// Peripheral disabled
	SPI_CR1_SPE_Disabled = 0x0
	// Peripheral enabled
	SPI_CR1_SPE_Enabled = 0x1
	// Position of BR field.
	SPI_CR1_BR_Pos = 0x3
	// Bit mask of BR field.
	SPI_CR1_BR_Msk = 0x38
	// f_PCLK / 2
	SPI_CR1_BR_Div2 = 0x0
	// f_PCLK / 4
	SPI_CR1_BR_Div4 = 0x1
	// f_PCLK / 8
	SPI_CR1_BR_Div8 = 0x2
	// f_PCLK / 16
	SPI_CR1_BR_Div16 = 0x3
	// f_PCLK / 32
	SPI_CR1_BR_Div32 = 0x4
	// f_PCLK / 64
	SPI_CR1_BR_Div64 = 0x5
	// f_PCLK / 128
	SPI_CR1_BR_Div128 = 0x6
	// f_PCLK / 256
	SPI_CR1_BR_Div256 = 0x7
	// Position of MSTR field.
	SPI_CR1_MSTR_Pos = 0x2
	// Bit mask of MSTR field.
	SPI_CR1_MSTR_Msk = 0x4
	// Bit MSTR.
	SPI_CR1_MSTR = 0x4
	// Slave configuration
	SPI_CR1_MSTR_Slave = 0x0
	// Master configuration
	SPI_CR1_MSTR_Master = 0x1
	// Position of CPOL field.
	SPI_CR1_CPOL_Pos = 0x1
	// Bit mask of CPOL field.
	SPI_CR1_CPOL_Msk = 0x2
	// Bit CPOL.
	SPI_CR1_CPOL = 0x2
	// CK to 0 when idle
	SPI_CR1_CPOL_IdleLow = 0x0
	// CK to 1 when idle
	SPI_CR1_CPOL_IdleHigh = 0x1
	// Position of CPHA field.
	SPI_CR1_CPHA_Pos = 0x0
	// Bit mask of CPHA field.
	SPI_CR1_CPHA_Msk = 0x1
	// Bit CPHA.
	SPI_CR1_CPHA = 0x1
	// The first clock transition is the first data capture edge
	SPI_CR1_CPHA_FirstEdge = 0x0
	// The second clock transition is the first data capture edge
	SPI_CR1_CPHA_SecondEdge = 0x1

	// CR2: control register 2
	// Position of RXDMAEN field.
	SPI_CR2_RXDMAEN_Pos = 0x0
	// Bit mask of RXDMAEN field.
	SPI_CR2_RXDMAEN_Msk = 0x1
	// Bit RXDMAEN.
	SPI_CR2_RXDMAEN = 0x1
	// Rx buffer DMA disabled
	SPI_CR2_RXDMAEN_Disabled = 0x0
	// Rx buffer DMA enabled
	SPI_CR2_RXDMAEN_Enabled = 0x1
	// Position of TXDMAEN field.
	SPI_CR2_TXDMAEN_Pos = 0x1
	// Bit mask of TXDMAEN field.
	SPI_CR2_TXDMAEN_Msk = 0x2
	// Bit TXDMAEN.
	SPI_CR2_TXDMAEN = 0x2
	// Tx buffer DMA disabled
	SPI_CR2_TXDMAEN_Disabled = 0x0
	// Tx buffer DMA enabled
	SPI_CR2_TXDMAEN_Enabled = 0x1
	// Position of SSOE field.
	SPI_CR2_SSOE_Pos = 0x2
	// Bit mask of SSOE field.
	SPI_CR2_SSOE_Msk = 0x4
	// Bit SSOE.
	SPI_CR2_SSOE = 0x4
	// SS output is disabled in master mode
	SPI_CR2_SSOE_Disabled = 0x0
	// SS output is enabled in master mode
	SPI_CR2_SSOE_Enabled = 0x1
	// Position of NSSP field.
	SPI_CR2_NSSP_Pos = 0x3
	// Bit mask of NSSP field.
	SPI_CR2_NSSP_Msk = 0x8
	// Bit NSSP.
	SPI_CR2_NSSP = 0x8
	// No NSS pulse
	SPI_CR2_NSSP_NoPulse = 0x0
	// NSS pulse generated
	SPI_CR2_NSSP_PulseGenerated = 0x1
	// Position of FRF field.
	SPI_CR2_FRF_Pos = 0x4
	// Bit mask of FRF field.
	SPI_CR2_FRF_Msk = 0x10
	// Bit FRF.
	SPI_CR2_FRF = 0x10
	// SPI Motorola mode
	SPI_CR2_FRF_Motorola = 0x0
	// SPI TI mode
	SPI_CR2_FRF_TI = 0x1
	// Position of ERRIE field.
	SPI_CR2_ERRIE_Pos = 0x5
	// Bit mask of ERRIE field.
	SPI_CR2_ERRIE_Msk = 0x20
	// Bit ERRIE.
	SPI_CR2_ERRIE = 0x20
	// Error interrupt masked
	SPI_CR2_ERRIE_Masked = 0x0
	// Error interrupt not masked
	SPI_CR2_ERRIE_NotMasked = 0x1
	// Position of RXNEIE field.
	SPI_CR2_RXNEIE_Pos = 0x6
	// Bit mask of RXNEIE field.
	SPI_CR2_RXNEIE_Msk = 0x40
	// Bit RXNEIE.
	SPI_CR2_RXNEIE = 0x40
	// RXE interrupt masked
	SPI_CR2_RXNEIE_Masked = 0x0
	// RXE interrupt not masked
	SPI_CR2_RXNEIE_NotMasked = 0x1
	// Position of TXEIE field.
	SPI_CR2_TXEIE_Pos = 0x7
	// Bit mask of TXEIE field.
	SPI_CR2_TXEIE_Msk = 0x80
	// Bit TXEIE.
	SPI_CR2_TXEIE = 0x80
	// TXE interrupt masked
	SPI_CR2_TXEIE_Masked = 0x0
	// TXE interrupt not masked
	SPI_CR2_TXEIE_NotMasked = 0x1
	// Position of DS field.
	SPI_CR2_DS_Pos = 0x8
	// Bit mask of DS field.
	SPI_CR2_DS_Msk = 0xf00
	// 4-bit
	SPI_CR2_DS_FourBit = 0x3
	// 5-bit
	SPI_CR2_DS_FiveBit = 0x4
	// 6-bit
	SPI_CR2_DS_SixBit = 0x5
	// 7-bit
	SPI_CR2_DS_SevenBit = 0x6
	// 8-bit
	SPI_CR2_DS_EightBit = 0x7
	// 9-bit
	SPI_CR2_DS_NineBit = 0x8
	// 10-bit
	SPI_CR2_DS_TenBit = 0x9
	// 11-bit
	SPI_CR2_DS_ElevenBit = 0xa
	// 12-bit
	SPI_CR2_DS_TwelveBit = 0xb
	// 13-bit
	SPI_CR2_DS_ThirteenBit = 0xc
	// 14-bit
	SPI_CR2_DS_FourteenBit = 0xd
	// 15-bit
	SPI_CR2_DS_FifteenBit = 0xe
	// 16-bit
	SPI_CR2_DS_SixteenBit = 0xf
	// Position of FRXTH field.
	SPI_CR2_FRXTH_Pos = 0xc
	// Bit mask of FRXTH field.
	SPI_CR2_FRXTH_Msk = 0x1000
	// Bit FRXTH.
	SPI_CR2_FRXTH = 0x1000
	// RXNE event is generated if the FIFO level is greater than or equal to 1/2 (16-bit)
	SPI_CR2_FRXTH_Half = 0x0
	// RXNE event is generated if the FIFO level is greater than or equal to 1/4 (8-bit)
	SPI_CR2_FRXTH_Quarter = 0x1
	// Position of LDMA_RX field.
	SPI_CR2_LDMA_RX_Pos = 0xd
	// Bit mask of LDMA_RX field.
	SPI_CR2_LDMA_RX_Msk = 0x2000
	// Bit LDMA_RX.
	SPI_CR2_LDMA_RX = 0x2000
	// Number of data to transfer for receive is even
	SPI_CR2_LDMA_RX_Even = 0x0
	// Number of data to transfer for receive is odd
	SPI_CR2_LDMA_RX_Odd = 0x1
	// Position of LDMA_TX field.
	SPI_CR2_LDMA_TX_Pos = 0xe
	// Bit mask of LDMA_TX field.
	SPI_CR2_LDMA_TX_Msk = 0x4000
	// Bit LDMA_TX.
	SPI_CR2_LDMA_TX = 0x4000
	// Number of data to transfer for transmit is even
	SPI_CR2_LDMA_TX_Even = 0x0
	// Number of data to transfer for transmit is odd
	SPI_CR2_LDMA_TX_Odd = 0x1

	// SR: status register
	// Position of FRE field.
	SPI_SR_FRE_Pos = 0x8
	// Bit mask of FRE field.
	SPI_SR_FRE_Msk = 0x100
	// Bit FRE.
	SPI_SR_FRE = 0x100
	// No frame format error
	SPI_SR_FRE_NoError = 0x0
	// A frame format error occurred
	SPI_SR_FRE_Error = 0x1
	// Position of BSY field.
	SPI_SR_BSY_Pos = 0x7
	// Bit mask of BSY field.
	SPI_SR_BSY_Msk = 0x80
	// Bit BSY.
	SPI_SR_BSY = 0x80
	// SPI not busy
	SPI_SR_BSY_NotBusy = 0x0
	// SPI busy
	SPI_SR_BSY_Busy = 0x1
	// Position of OVR field.
	SPI_SR_OVR_Pos = 0x6
	// Bit mask of OVR field.
	SPI_SR_OVR_Msk = 0x40
	// Bit OVR.
	SPI_SR_OVR = 0x40
	// No overrun occurred
	SPI_SR_OVR_NoOverrun = 0x0
	// Overrun occurred
	SPI_SR_OVR_Overrun = 0x1
	// Position of MODF field.
	SPI_SR_MODF_Pos = 0x5
	// Bit mask of MODF field.
	SPI_SR_MODF_Msk = 0x20
	// Bit MODF.
	SPI_SR_MODF = 0x20
	// No mode fault occurred
	SPI_SR_MODF_NoFault = 0x0
	// Mode fault occurred
	SPI_SR_MODF_Fault = 0x1
	// Position of CRCERR field.
	SPI_SR_CRCERR_Pos = 0x4
	// Bit mask of CRCERR field.
	SPI_SR_CRCERR_Msk = 0x10
	// Bit CRCERR.
	SPI_SR_CRCERR = 0x10
	// CRC value received matches the SPIx_RXCRCR value
	SPI_SR_CRCERR_Match = 0x0
	// CRC value received does not match the SPIx_RXCRCR value
	SPI_SR_CRCERR_NoMatch = 0x1
	// Position of UDR field.
	SPI_SR_UDR_Pos = 0x3
	// Bit mask of UDR field.
	SPI_SR_UDR_Msk = 0x8
	// Bit UDR.
	SPI_SR_UDR = 0x8
	// No underrun occurred
	SPI_SR_UDR_NoUnderrun = 0x0
	// Underrun occurred
	SPI_SR_UDR_Underrun = 0x1
	// Position of CHSIDE field.
	SPI_SR_CHSIDE_Pos = 0x2
	// Bit mask of CHSIDE field.
	SPI_SR_CHSIDE_Msk = 0x4
	// Bit CHSIDE.
	SPI_SR_CHSIDE = 0x4
	// Channel left has to be transmitted or has been received
	SPI_SR_CHSIDE_Left = 0x0
	// Channel right has to be transmitted or has been received
	SPI_SR_CHSIDE_Right = 0x1
	// Position of TXE field.
	SPI_SR_TXE_Pos = 0x1
	// Bit mask of TXE field.
	SPI_SR_TXE_Msk = 0x2
	// Bit TXE.
	SPI_SR_TXE = 0x2
	// Tx buffer not empty
	SPI_SR_TXE_NotEmpty = 0x0
	// Tx buffer empty
	SPI_SR_TXE_Empty = 0x1
	// Position of RXNE field.
	SPI_SR_RXNE_Pos = 0x0
	// Bit mask of RXNE field.
	SPI_SR_RXNE_Msk = 0x1
	// Bit RXNE.
	SPI_SR_RXNE = 0x1
	// Rx buffer empty
	SPI_SR_RXNE_Empty = 0x0
	// Rx buffer not empty
	SPI_SR_RXNE_NotEmpty = 0x1
	// Position of FRLVL field.
	SPI_SR_FRLVL_Pos = 0x9
	// Bit mask of FRLVL field.
	SPI_SR_FRLVL_Msk = 0x600
	// Rx FIFO Empty
	SPI_SR_FRLVL_Empty = 0x0
	// Rx 1/4 FIFO
	SPI_SR_FRLVL_Quarter = 0x1
	// Rx 1/2 FIFO
	SPI_SR_FRLVL_Half = 0x2
	// Rx FIFO full
	SPI_SR_FRLVL_Full = 0x3
	// Position of FTLVL field.
	SPI_SR_FTLVL_Pos = 0xb
	// Bit mask of FTLVL field.
	SPI_SR_FTLVL_Msk = 0x1800
	// Tx FIFO Empty
	SPI_SR_FTLVL_Empty = 0x0
	// Tx 1/4 FIFO
	SPI_SR_FTLVL_Quarter = 0x1
	// Tx 1/2 FIFO
	SPI_SR_FTLVL_Half = 0x2
	// Tx FIFO full
	SPI_SR_FTLVL_Full = 0x3

	// DR: data register
	// Position of DR field.
	SPI_DR_DR_Pos = 0x0
	// Bit mask of DR field.
	SPI_DR_DR_Msk = 0xffff

	// CRCPR: CRC polynomial register
	// Position of CRCPOLY field.
	SPI_CRCPR_CRCPOLY_Pos = 0x0
	// Bit mask of CRCPOLY field.
	SPI_CRCPR_CRCPOLY_Msk = 0xffff

	// RXCRCR: RX CRC register
	// Position of RxCRC field.
	SPI_RXCRCR_RxCRC_Pos = 0x0
	// Bit mask of RxCRC field.
	SPI_RXCRCR_RxCRC_Msk = 0xffff

	// TXCRCR: TX CRC register
	// Position of TxCRC field.
	SPI_TXCRCR_TxCRC_Pos = 0x0
	// Bit mask of TxCRC field.
	SPI_TXCRCR_TxCRC_Msk = 0xffff

	// I2SCFGR: I2S configuration register
	// Position of I2SMOD field.
	SPI_I2SCFGR_I2SMOD_Pos = 0xb
	// Bit mask of I2SMOD field.
	SPI_I2SCFGR_I2SMOD_Msk = 0x800
	// Bit I2SMOD.
	SPI_I2SCFGR_I2SMOD = 0x800
	// SPI mode is selected
	SPI_I2SCFGR_I2SMOD_SPIMode = 0x0
	// I2S mode is selected
	SPI_I2SCFGR_I2SMOD_I2SMode = 0x1
	// Position of I2SE field.
	SPI_I2SCFGR_I2SE_Pos = 0xa
	// Bit mask of I2SE field.
	SPI_I2SCFGR_I2SE_Msk = 0x400
	// Bit I2SE.
	SPI_I2SCFGR_I2SE = 0x400
	// I2S peripheral is disabled
	SPI_I2SCFGR_I2SE_Disabled = 0x0
	// I2S peripheral is enabled
	SPI_I2SCFGR_I2SE_Enabled = 0x1
	// Position of I2SCFG field.
	SPI_I2SCFGR_I2SCFG_Pos = 0x8
	// Bit mask of I2SCFG field.
	SPI_I2SCFGR_I2SCFG_Msk = 0x300
	// Slave - transmit
	SPI_I2SCFGR_I2SCFG_SlaveTx = 0x0
	// Slave - receive
	SPI_I2SCFGR_I2SCFG_SlaveRx = 0x1
	// Master - transmit
	SPI_I2SCFGR_I2SCFG_MasterTx = 0x2
	// Master - receive
	SPI_I2SCFGR_I2SCFG_MasterRx = 0x3
	// Position of PCMSYNC field.
	SPI_I2SCFGR_PCMSYNC_Pos = 0x7
	// Bit mask of PCMSYNC field.
	SPI_I2SCFGR_PCMSYNC_Msk = 0x80
	// Bit PCMSYNC.
	SPI_I2SCFGR_PCMSYNC = 0x80
	// Short frame synchronisation
	SPI_I2SCFGR_PCMSYNC_Short = 0x0
	// Long frame synchronisation
	SPI_I2SCFGR_PCMSYNC_Long = 0x1
	// Position of I2SSTD field.
	SPI_I2SCFGR_I2SSTD_Pos = 0x4
	// Bit mask of I2SSTD field.
	SPI_I2SCFGR_I2SSTD_Msk = 0x30
	// I2S Philips standard
	SPI_I2SCFGR_I2SSTD_Philips = 0x0
	// MSB justified standard
	SPI_I2SCFGR_I2SSTD_MSB = 0x1
	// LSB justified standard
	SPI_I2SCFGR_I2SSTD_LSB = 0x2
	// PCM standard
	SPI_I2SCFGR_I2SSTD_PCM = 0x3
	// Position of CKPOL field.
	SPI_I2SCFGR_CKPOL_Pos = 0x3
	// Bit mask of CKPOL field.
	SPI_I2SCFGR_CKPOL_Msk = 0x8
	// Bit CKPOL.
	SPI_I2SCFGR_CKPOL = 0x8
	// I2S clock inactive state is low level
	SPI_I2SCFGR_CKPOL_IdleLow = 0x0
	// I2S clock inactive state is high level
	SPI_I2SCFGR_CKPOL_IdleHigh = 0x1
	// Position of DATLEN field.
	SPI_I2SCFGR_DATLEN_Pos = 0x1
	// Bit mask of DATLEN field.
	SPI_I2SCFGR_DATLEN_Msk = 0x6
	// 16-bit data length
	SPI_I2SCFGR_DATLEN_SixteenBit = 0x0
	// 24-bit data length
	SPI_I2SCFGR_DATLEN_TwentyFourBit = 0x1
	// 32-bit data length
	SPI_I2SCFGR_DATLEN_ThirtyTwoBit = 0x2
	// Position of CHLEN field.
	SPI_I2SCFGR_CHLEN_Pos = 0x0
	// Bit mask of CHLEN field.
	SPI_I2SCFGR_CHLEN_Msk = 0x1
	// Bit CHLEN.
	SPI_I2SCFGR_CHLEN = 0x1
	// 16-bit wide
	SPI_I2SCFGR_CHLEN_SixteenBit = 0x0
	// 32-bit wide
	SPI_I2SCFGR_CHLEN_ThirtyTwoBit = 0x1
	// Position of ASTRTEN field.
	SPI_I2SCFGR_ASTRTEN_Pos = 0xc
	// Bit mask of ASTRTEN field.
	SPI_I2SCFGR_ASTRTEN_Msk = 0x1000
	// Bit ASTRTEN.
	SPI_I2SCFGR_ASTRTEN = 0x1000

	// I2SPR: I2S prescaler register
	// Position of MCKOE field.
	SPI_I2SPR_MCKOE_Pos = 0x9
	// Bit mask of MCKOE field.
	SPI_I2SPR_MCKOE_Msk = 0x200
	// Bit MCKOE.
	SPI_I2SPR_MCKOE = 0x200
	// Master clock output is disabled
	SPI_I2SPR_MCKOE_Disabled = 0x0
	// Master clock output is enabled
	SPI_I2SPR_MCKOE_Enabled = 0x1
	// Position of ODD field.
	SPI_I2SPR_ODD_Pos = 0x8
	// Bit mask of ODD field.
	SPI_I2SPR_ODD_Msk = 0x100
	// Bit ODD.
	SPI_I2SPR_ODD = 0x100
	// Real divider value is I2SDIV * 2
	SPI_I2SPR_ODD_Even = 0x0
	// Real divider value is (I2SDIV * 2) + 1
	SPI_I2SPR_ODD_Odd = 0x1
	// Position of I2SDIV field.
	SPI_I2SPR_I2SDIV_Pos = 0x0
	// Bit mask of I2SDIV field.
	SPI_I2SPR_I2SDIV_Msk = 0xff
)

// Constants for ADC1: Analog-to-digital converter
const (
	// SR: status register
	// Position of OVR field.
	ADC_SR_OVR_Pos = 0x5
	// Bit mask of OVR field.
	ADC_SR_OVR_Msk = 0x20
	// Bit OVR.
	ADC_SR_OVR = 0x20
	// No overrun occurred
	ADC_SR_OVR_NoOverrun = 0x0
	// Overrun occurred
	ADC_SR_OVR_Overrun = 0x1
	// Position of STRT field.
	ADC_SR_STRT_Pos = 0x4
	// Bit mask of STRT field.
	ADC_SR_STRT_Msk = 0x10
	// Bit STRT.
	ADC_SR_STRT = 0x10
	// No regular channel conversion started
	ADC_SR_STRT_NotStarted = 0x0
	// Regular channel conversion has started
	ADC_SR_STRT_Started = 0x1
	// Position of JSTRT field.
	ADC_SR_JSTRT_Pos = 0x3
	// Bit mask of JSTRT field.
	ADC_SR_JSTRT_Msk = 0x8
	// Bit JSTRT.
	ADC_SR_JSTRT = 0x8
	// No injected channel conversion started
	ADC_SR_JSTRT_NotStarted = 0x0
	// Injected channel conversion has started
	ADC_SR_JSTRT_Started = 0x1
	// Position of JEOC field.
	ADC_SR_JEOC_Pos = 0x2
	// Bit mask of JEOC field.
	ADC_SR_JEOC_Msk = 0x4
	// Bit JEOC.
	ADC_SR_JEOC = 0x4
	// Conversion is not complete
	ADC_SR_JEOC_NotComplete = 0x0
	// Conversion complete
	ADC_SR_JEOC_Complete = 0x1
	// Position of EOC field.
	ADC_SR_EOC_Pos = 0x1
	// Bit mask of EOC field.
	ADC_SR_EOC_Msk = 0x2
	// Bit EOC.
	ADC_SR_EOC = 0x2
	// Conversion is not complete
	ADC_SR_EOC_NotComplete = 0x0
	// Conversion complete
	ADC_SR_EOC_Complete = 0x1
	// Position of AWD field.
	ADC_SR_AWD_Pos = 0x0
	// Bit mask of AWD field.
	ADC_SR_AWD_Msk = 0x1
	// Bit AWD.
	ADC_SR_AWD = 0x1
	// No analog watchdog event occurred
	ADC_SR_AWD_NoEvent = 0x0
	// Analog watchdog event occurred
	ADC_SR_AWD_Event = 0x1

	// CR1: control register 1
	// Position of OVRIE field.
	ADC_CR1_OVRIE_Pos = 0x1a
	// Bit mask of OVRIE field.
	ADC_CR1_OVRIE_Msk = 0x4000000
	// Bit OVRIE.
	ADC_CR1_OVRIE = 0x4000000
	// Overrun interrupt disabled
	ADC_CR1_OVRIE_Disabled = 0x0
	// Overrun interrupt enabled
	ADC_CR1_OVRIE_Enabled = 0x1
	// Position of RES field.
	ADC_CR1_RES_Pos = 0x18
	// Bit mask of RES field.
	ADC_CR1_RES_Msk = 0x3000000
	// 12-bit (15 ADCCLK cycles)
	ADC_CR1_RES_TwelveBit = 0x0
	// 10-bit (13 ADCCLK cycles)
	ADC_CR1_RES_TenBit = 0x1
	// 8-bit (11 ADCCLK cycles)
	ADC_CR1_RES_EightBit = 0x2
	// 6-bit (9 ADCCLK cycles)
	ADC_CR1_RES_SixBit = 0x3
	// Position of AWDEN field.
	ADC_CR1_AWDEN_Pos = 0x17
	// Bit mask of AWDEN field.
	ADC_CR1_AWDEN_Msk = 0x800000
	// Bit AWDEN.
	ADC_CR1_AWDEN = 0x800000
	// Analog watchdog disabled on regular channels
	ADC_CR1_AWDEN_Disabled = 0x0
	// Analog watchdog enabled on regular channels
	ADC_CR1_AWDEN_Enabled = 0x1
	// Position of JAWDEN field.
	ADC_CR1_JAWDEN_Pos = 0x16
	// Bit mask of JAWDEN field.
	ADC_CR1_JAWDEN_Msk = 0x400000
	// Bit JAWDEN.
	ADC_CR1_JAWDEN = 0x400000
	// Analog watchdog disabled on injected channels
	ADC_CR1_JAWDEN_Disabled = 0x0
	// Analog watchdog enabled on injected channels
	ADC_CR1_JAWDEN_Enabled = 0x1
	// Position of DISCNUM field.
	ADC_CR1_DISCNUM_Pos = 0xd
	// Bit mask of DISCNUM field.
	ADC_CR1_DISCNUM_Msk = 0xe000
	// Position of JDISCEN field.
	ADC_CR1_JDISCEN_Pos = 0xc
	// Bit mask of JDISCEN field.
	ADC_CR1_JDISCEN_Msk = 0x1000
	// Bit JDISCEN.
	ADC_CR1_JDISCEN = 0x1000
	// Discontinuous mode on injected channels disabled
	ADC_CR1_JDISCEN_Disabled = 0x0
	// Discontinuous mode on injected channels enabled
	ADC_CR1_JDISCEN_Enabled = 0x1
	// Position of DISCEN field.
	ADC_CR1_DISCEN_Pos = 0xb
	// Bit mask of DISCEN field.
	ADC_CR1_DISCEN_Msk = 0x800
	// Bit DISCEN.
	ADC_CR1_DISCEN = 0x800
	// Discontinuous mode on regular channels disabled
	ADC_CR1_DISCEN_Disabled = 0x0
	// Discontinuous mode on regular channels enabled
	ADC_CR1_DISCEN_Enabled = 0x1
	// Position of JAUTO field.
	ADC_CR1_JAUTO_Pos = 0xa
	// Bit mask of JAUTO field.
	ADC_CR1_JAUTO_Msk = 0x400
	// Bit JAUTO.
	ADC_CR1_JAUTO = 0x400
	// Automatic injected group conversion disabled
	ADC_CR1_JAUTO_Disabled = 0x0
	// Automatic injected group conversion enabled
	ADC_CR1_JAUTO_Enabled = 0x1
	// Position of AWDSGL field.
	ADC_CR1_AWDSGL_Pos = 0x9
	// Bit mask of AWDSGL field.
	ADC_CR1_AWDSGL_Msk = 0x200
	// Bit AWDSGL.
	ADC_CR1_AWDSGL = 0x200
	// Analog watchdog enabled on all channels
	ADC_CR1_AWDSGL_AllChannels = 0x0
	// Analog watchdog enabled on a single channel
	ADC_CR1_AWDSGL_SingleChannel = 0x1
	// Position of SCAN field.
	ADC_CR1_SCAN_Pos = 0x8
	// Bit mask of SCAN field.
	ADC_CR1_SCAN_Msk = 0x100
	// Bit SCAN.
	ADC_CR1_SCAN = 0x100
	// Scan mode disabled
	ADC_CR1_SCAN_Disabled = 0x0
	// Scan mode enabled
	ADC_CR1_SCAN_Enabled = 0x1
	// Position of JEOCIE field.
	ADC_CR1_JEOCIE_Pos = 0x7
	// Bit mask of JEOCIE field.
	ADC_CR1_JEOCIE_Msk = 0x80
	// Bit JEOCIE.
	ADC_CR1_JEOCIE = 0x80
	// JEOC interrupt disabled
	ADC_CR1_JEOCIE_Disabled = 0x0
	// JEOC interrupt enabled
	ADC_CR1_JEOCIE_Enabled = 0x1
	// Position of AWDIE field.
	ADC_CR1_AWDIE_Pos = 0x6
	// Bit mask of AWDIE field.
	ADC_CR1_AWDIE_Msk = 0x40
	// Bit AWDIE.
	ADC_CR1_AWDIE = 0x40
	// Analogue watchdog interrupt disabled
	ADC_CR1_AWDIE_Disabled = 0x0
	// Analogue watchdog interrupt enabled
	ADC_CR1_AWDIE_Enabled = 0x1
	// Position of EOCIE field.
	ADC_CR1_EOCIE_Pos = 0x5
	// Bit mask of EOCIE field.
	ADC_CR1_EOCIE_Msk = 0x20
	// Bit EOCIE.
	ADC_CR1_EOCIE = 0x20
	// EOC interrupt disabled
	ADC_CR1_EOCIE_Disabled = 0x0
	// EOC interrupt enabled
	ADC_CR1_EOCIE_Enabled = 0x1
	// Position of AWDCH field.
	ADC_CR1_AWDCH_Pos = 0x0
	// Bit mask of AWDCH field.
	ADC_CR1_AWDCH_Msk = 0x1f

	// CR2: control register 2
	// Position of SWSTART field.
	ADC_CR2_SWSTART_Pos = 0x1e
	// Bit mask of SWSTART field.
	ADC_CR2_SWSTART_Msk = 0x40000000
	// Bit SWSTART.
	ADC_CR2_SWSTART = 0x40000000
	// Starts conversion of regular channels
	ADC_CR2_SWSTART_Start = 0x1
	// Position of EXTEN field.
	ADC_CR2_EXTEN_Pos = 0x1c
	// Bit mask of EXTEN field.
	ADC_CR2_EXTEN_Msk = 0x30000000
	// Trigger detection disabled
	ADC_CR2_EXTEN_Disabled = 0x0
	// Trigger detection on the rising edge
	ADC_CR2_EXTEN_RisingEdge = 0x1
	// Trigger detection on the falling edge
	ADC_CR2_EXTEN_FallingEdge = 0x2
	// Trigger detection on both the rising and falling edges
	ADC_CR2_EXTEN_BothEdges = 0x3
	// Position of EXTSEL field.
	ADC_CR2_EXTSEL_Pos = 0x18
	// Bit mask of EXTSEL field.
	ADC_CR2_EXTSEL_Msk = 0xf000000
	// Timer 1 CC1 event
	ADC_CR2_EXTSEL_TIM1CC1 = 0x0
	// Timer 1 CC2 event
	ADC_CR2_EXTSEL_TIM1CC2 = 0x1
	// Timer 1 CC3 event
	ADC_CR2_EXTSEL_TIM1CC3 = 0x2
	// Timer 2 CC2 event
	ADC_CR2_EXTSEL_TIM2CC2 = 0x3
	// Timer 2 CC3 event
	ADC_CR2_EXTSEL_TIM2CC3 = 0x4
	// Timer 2 CC4 event
	ADC_CR2_EXTSEL_TIM2CC4 = 0x5
	// Timer 2 TRGO event
	ADC_CR2_EXTSEL_TIM2TRGO = 0x6
	// Position of JSWSTART field.
	ADC_CR2_JSWSTART_Pos = 0x16
	// Bit mask of JSWSTART field.
	ADC_CR2_JSWSTART_Msk = 0x400000
	// Bit JSWSTART.
	ADC_CR2_JSWSTART = 0x400000
	// Starts conversion of injected channels
	ADC_CR2_JSWSTART_Start = 0x1
	// Position of JEXTEN field.
	ADC_CR2_JEXTEN_Pos = 0x14
	// Bit mask of JEXTEN field.
	ADC_CR2_JEXTEN_Msk = 0x300000
	// Trigger detection disabled
	ADC_CR2_JEXTEN_Disabled = 0x0
	// Trigger detection on the rising edge
	ADC_CR2_JEXTEN_RisingEdge = 0x1
	// Trigger detection on the falling edge
	ADC_CR2_JEXTEN_FallingEdge = 0x2
	// Trigger detection on both the rising and falling edges
	ADC_CR2_JEXTEN_BothEdges = 0x3
	// Position of JEXTSEL field.
	ADC_CR2_JEXTSEL_Pos = 0x10
	// Bit mask of JEXTSEL field.
	ADC_CR2_JEXTSEL_Msk = 0xf0000
	// Timer 1 TRGO event
	ADC_CR2_JEXTSEL_TIM1TRGO = 0x0
	// Timer 1 CC4 event
	ADC_CR2_JEXTSEL_TIM1CC4 = 0x1
	// Timer 2 TRGO event
	ADC_CR2_JEXTSEL_TIM2TRGO = 0x2
	// Timer 2 CC1 event
	ADC_CR2_JEXTSEL_TIM2CC1 = 0x3
	// Timer 3 CC4 event
	ADC_CR2_JEXTSEL_TIM3CC4 = 0x4
	// Timer 4 TRGO event
	ADC_CR2_JEXTSEL_TIM4TRGO = 0x5
	// Timer 8 CC4 event
	ADC_CR2_JEXTSEL_TIM8CC4 = 0x7
	// Timer 1 TRGO(2) event
	ADC_CR2_JEXTSEL_TIM1TRGO2 = 0x8
	// Timer 8 TRGO event
	ADC_CR2_JEXTSEL_TIM8TRGO = 0x9
	// Timer 8 TRGO(2) event
	ADC_CR2_JEXTSEL_TIM8TRGO2 = 0xa
	// Timer 3 CC3 event
	ADC_CR2_JEXTSEL_TIM3CC3 = 0xb
	// Timer 5 TRGO event
	ADC_CR2_JEXTSEL_TIM5TRGO = 0xc
	// Timer 3 CC1 event
	ADC_CR2_JEXTSEL_TIM3CC1 = 0xd
	// Timer 6 TRGO event
	ADC_CR2_JEXTSEL_TIM6TRGO = 0xe
	// Position of ALIGN field.
	ADC_CR2_ALIGN_Pos = 0xb
	// Bit mask of ALIGN field.
	ADC_CR2_ALIGN_Msk = 0x800
	// Bit ALIGN.
	ADC_CR2_ALIGN = 0x800
	// Right alignment
	ADC_CR2_ALIGN_Right = 0x0
	// Left alignment
	ADC_CR2_ALIGN_Left = 0x1
	// Position of EOCS field.
	ADC_CR2_EOCS_Pos = 0xa
	// Bit mask of EOCS field.
	ADC_CR2_EOCS_Msk = 0x400
	// Bit EOCS.
	ADC_CR2_EOCS = 0x400
	// The EOC bit is set at the end of each sequence of regular conversions
	ADC_CR2_EOCS_EachSequence = 0x0
	// The EOC bit is set at the end of each regular conversion
	ADC_CR2_EOCS_EachConversion = 0x1
	// Position of DDS field.
	ADC_CR2_DDS_Pos = 0x9
	// Bit mask of DDS field.
	ADC_CR2_DDS_Msk = 0x200
	// Bit DDS.
	ADC_CR2_DDS = 0x200
	// No new DMA request is issued after the last transfer
	ADC_CR2_DDS_Single = 0x0
	// DMA requests are issued as long as data are converted and DMA=1
	ADC_CR2_DDS_Continuous = 0x1
	// Position of DMA field.
	ADC_CR2_DMA_Pos = 0x8
	// Bit mask of DMA field.
	ADC_CR2_DMA_Msk = 0x100
	// Bit DMA.
	ADC_CR2_DMA = 0x100
	// DMA mode disabled
	ADC_CR2_DMA_Disabled = 0x0
	// DMA mode enabled
	ADC_CR2_DMA_Enabled = 0x1
	// Position of CONT field.
	ADC_CR2_CONT_Pos = 0x1
	// Bit mask of CONT field.
	ADC_CR2_CONT_Msk = 0x2
	// Bit CONT.
	ADC_CR2_CONT = 0x2
	// Single conversion mode
	ADC_CR2_CONT_Single = 0x0
	// Continuous conversion mode
	ADC_CR2_CONT_Continuous = 0x1
	// Position of ADON field.
	ADC_CR2_ADON_Pos = 0x0
	// Bit mask of ADON field.
	ADC_CR2_ADON_Msk = 0x1
	// Bit ADON.
	ADC_CR2_ADON = 0x1
	// Disable ADC conversion and go to power down mode
	ADC_CR2_ADON_Disabled = 0x0
	// Enable ADC
	ADC_CR2_ADON_Enabled = 0x1

	// SMPR1: sample time register 1
	// Position of SMPx_x field.
	ADC_SMPR1_SMPx_x_Pos = 0x0
	// Bit mask of SMPx_x field.
	ADC_SMPR1_SMPx_x_Msk = 0xffffffff
	// 3 cycles
	ADC_SMPR1_SMPx_x_Cycles3 = 0x0
	// 15 cycles
	ADC_SMPR1_SMPx_x_Cycles15 = 0x1
	// 28 cycles
	ADC_SMPR1_SMPx_x_Cycles28 = 0x2
	// 56 cycles
	ADC_SMPR1_SMPx_x_Cycles56 = 0x3
	// 84 cycles
	ADC_SMPR1_SMPx_x_Cycles84 = 0x4
	// 112 cycles
	ADC_SMPR1_SMPx_x_Cycles112 = 0x5
	// 144 cycles
	ADC_SMPR1_SMPx_x_Cycles144 = 0x6
	// 480 cycles
	ADC_SMPR1_SMPx_x_Cycles480 = 0x7

	// SMPR2: sample time register 2
	// Position of SMPx_x field.
	ADC_SMPR2_SMPx_x_Pos = 0x0
	// Bit mask of SMPx_x field.
	ADC_SMPR2_SMPx_x_Msk = 0xffffffff
	// 3 cycles
	ADC_SMPR2_SMPx_x_Cycles3 = 0x0
	// 15 cycles
	ADC_SMPR2_SMPx_x_Cycles15 = 0x1
	// 28 cycles
	ADC_SMPR2_SMPx_x_Cycles28 = 0x2
	// 56 cycles
	ADC_SMPR2_SMPx_x_Cycles56 = 0x3
	// 84 cycles
	ADC_SMPR2_SMPx_x_Cycles84 = 0x4
	// 112 cycles
	ADC_SMPR2_SMPx_x_Cycles112 = 0x5
	// 144 cycles
	ADC_SMPR2_SMPx_x_Cycles144 = 0x6
	// 480 cycles
	ADC_SMPR2_SMPx_x_Cycles480 = 0x7

	// JOFR1: injected channel data offset register x
	// Position of JOFFSET field.
	ADC_JOFR_JOFFSET_Pos = 0x0
	// Bit mask of JOFFSET field.
	ADC_JOFR_JOFFSET_Msk = 0xfff

	// HTR: watchdog higher threshold register
	// Position of HT field.
	ADC_HTR_HT_Pos = 0x0
	// Bit mask of HT field.
	ADC_HTR_HT_Msk = 0xfff

	// LTR: watchdog lower threshold register
	// Position of LT field.
	ADC_LTR_LT_Pos = 0x0
	// Bit mask of LT field.
	ADC_LTR_LT_Msk = 0xfff

	// SQR1: regular sequence register 1
	// Position of L field.
	ADC_SQR1_L_Pos = 0x14
	// Bit mask of L field.
	ADC_SQR1_L_Msk = 0xf00000
	// Position of SQ16 field.
	ADC_SQR1_SQ16_Pos = 0xf
	// Bit mask of SQ16 field.
	ADC_SQR1_SQ16_Msk = 0xf8000
	// Position of SQ15 field.
	ADC_SQR1_SQ15_Pos = 0xa
	// Bit mask of SQ15 field.
	ADC_SQR1_SQ15_Msk = 0x7c00
	// Position of SQ14 field.
	ADC_SQR1_SQ14_Pos = 0x5
	// Bit mask of SQ14 field.
	ADC_SQR1_SQ14_Msk = 0x3e0
	// Position of SQ13 field.
	ADC_SQR1_SQ13_Pos = 0x0
	// Bit mask of SQ13 field.
	ADC_SQR1_SQ13_Msk = 0x1f

	// SQR2: regular sequence register 2
	// Position of SQ12 field.
	ADC_SQR2_SQ12_Pos = 0x19
	// Bit mask of SQ12 field.
	ADC_SQR2_SQ12_Msk = 0x3e000000
	// Position of SQ11 field.
	ADC_SQR2_SQ11_Pos = 0x14
	// Bit mask of SQ11 field.
	ADC_SQR2_SQ11_Msk = 0x1f00000
	// Position of SQ10 field.
	ADC_SQR2_SQ10_Pos = 0xf
	// Bit mask of SQ10 field.
	ADC_SQR2_SQ10_Msk = 0xf8000
	// Position of SQ9 field.
	ADC_SQR2_SQ9_Pos = 0xa
	// Bit mask of SQ9 field.
	ADC_SQR2_SQ9_Msk = 0x7c00
	// Position of SQ8 field.
	ADC_SQR2_SQ8_Pos = 0x5
	// Bit mask of SQ8 field.
	ADC_SQR2_SQ8_Msk = 0x3e0
	// Position of SQ7 field.
	ADC_SQR2_SQ7_Pos = 0x0
	// Bit mask of SQ7 field.
	ADC_SQR2_SQ7_Msk = 0x1f

	// SQR3: regular sequence register 3
	// Position of SQ6 field.
	ADC_SQR3_SQ6_Pos = 0x19
	// Bit mask of SQ6 field.
	ADC_SQR3_SQ6_Msk = 0x3e000000
	// Position of SQ5 field.
	ADC_SQR3_SQ5_Pos = 0x14
	// Bit mask of SQ5 field.
	ADC_SQR3_SQ5_Msk = 0x1f00000
	// Position of SQ4 field.
	ADC_SQR3_SQ4_Pos = 0xf
	// Bit mask of SQ4 field.
	ADC_SQR3_SQ4_Msk = 0xf8000
	// Position of SQ3 field.
	ADC_SQR3_SQ3_Pos = 0xa
	// Bit mask of SQ3 field.
	ADC_SQR3_SQ3_Msk = 0x7c00
	// Position of SQ2 field.
	ADC_SQR3_SQ2_Pos = 0x5
	// Bit mask of SQ2 field.
	ADC_SQR3_SQ2_Msk = 0x3e0
	// Position of SQ1 field.
	ADC_SQR3_SQ1_Pos = 0x0
	// Bit mask of SQ1 field.
	ADC_SQR3_SQ1_Msk = 0x1f

	// JSQR: injected sequence register
	// Position of JL field.
	ADC_JSQR_JL_Pos = 0x14
	// Bit mask of JL field.
	ADC_JSQR_JL_Msk = 0x300000
	// Position of JSQ4 field.
	ADC_JSQR_JSQ4_Pos = 0xf
	// Bit mask of JSQ4 field.
	ADC_JSQR_JSQ4_Msk = 0xf8000
	// Position of JSQ3 field.
	ADC_JSQR_JSQ3_Pos = 0xa
	// Bit mask of JSQ3 field.
	ADC_JSQR_JSQ3_Msk = 0x7c00
	// Position of JSQ2 field.
	ADC_JSQR_JSQ2_Pos = 0x5
	// Bit mask of JSQ2 field.
	ADC_JSQR_JSQ2_Msk = 0x3e0
	// Position of JSQ1 field.
	ADC_JSQR_JSQ1_Pos = 0x0
	// Bit mask of JSQ1 field.
	ADC_JSQR_JSQ1_Msk = 0x1f

	// JDR1: injected data register x
	// Position of JDATA field.
	ADC_JDR_JDATA_Pos = 0x0
	// Bit mask of JDATA field.
	ADC_JDR_JDATA_Msk = 0xffff

	// DR: regular data register
	// Position of DATA field.
	ADC_DR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	ADC_DR_DATA_Msk = 0xffff
)

// Constants for DAC: Digital-to-analog converter
const (
	// CR: control register
	// Position of DMAUDRIE2 field.
	DAC_CR_DMAUDRIE2_Pos = 0x1d
	// Bit mask of DMAUDRIE2 field.
	DAC_CR_DMAUDRIE2_Msk = 0x20000000
	// Bit DMAUDRIE2.
	DAC_CR_DMAUDRIE2 = 0x20000000
	// DAC channel X DMA Underrun Interrupt disabled
	DAC_CR_DMAUDRIE2_Disabled = 0x0
	// DAC channel X DMA Underrun Interrupt enabled
	DAC_CR_DMAUDRIE2_Enabled = 0x1
	// Position of DMAEN2 field.
	DAC_CR_DMAEN2_Pos = 0x1c
	// Bit mask of DMAEN2 field.
	DAC_CR_DMAEN2_Msk = 0x10000000
	// Bit DMAEN2.
	DAC_CR_DMAEN2 = 0x10000000
	// DAC channel X DMA mode disabled
	DAC_CR_DMAEN2_Disabled = 0x0
	// DAC channel X DMA mode enabled
	DAC_CR_DMAEN2_Enabled = 0x1
	// Position of MAMP2 field.
	DAC_CR_MAMP2_Pos = 0x18
	// Bit mask of MAMP2 field.
	DAC_CR_MAMP2_Msk = 0xf000000
	// Position of WAVE2 field.
	DAC_CR_WAVE2_Pos = 0x16
	// Bit mask of WAVE2 field.
	DAC_CR_WAVE2_Msk = 0xc00000
	// Wave generation disabled
	DAC_CR_WAVE2_Disabled = 0x0
	// Noise wave generation enabled
	DAC_CR_WAVE2_Noise = 0x1
	// Triangle wave generation enabled
	DAC_CR_WAVE2_Triangle = 0x2
	// Position of TSEL2 field.
	DAC_CR_TSEL2_Pos = 0x13
	// Bit mask of TSEL2 field.
	DAC_CR_TSEL2_Msk = 0x380000
	// Timer 6 TRGO event
	DAC_CR_TSEL2_TIM6_TRGO = 0x0
	// Timer 8 TRGO event
	DAC_CR_TSEL2_TIM8_TRGO = 0x1
	// Timer 7 TRGO event
	DAC_CR_TSEL2_TIM7_TRGO = 0x2
	// Timer 5 TRGO event
	DAC_CR_TSEL2_TIM5_TRGO = 0x3
	// Timer 2 TRGO event
	DAC_CR_TSEL2_TIM2_TRGO = 0x4
	// Timer 4 TRGO event
	DAC_CR_TSEL2_TIM4_TRGO = 0x5
	// EXTI line9
	DAC_CR_TSEL2_EXTI9 = 0x6
	// Software trigger
	DAC_CR_TSEL2_SOFTWARE = 0x7
	// Position of TEN2 field.
	DAC_CR_TEN2_Pos = 0x12
	// Bit mask of TEN2 field.
	DAC_CR_TEN2_Msk = 0x40000
	// Bit TEN2.
	DAC_CR_TEN2 = 0x40000
	// DAC channel X trigger disabled
	DAC_CR_TEN2_Disabled = 0x0
	// DAC channel X trigger enabled
	DAC_CR_TEN2_Enabled = 0x1
	// Position of BOFF2 field.
	DAC_CR_BOFF2_Pos = 0x11
	// Bit mask of BOFF2 field.
	DAC_CR_BOFF2_Msk = 0x20000
	// Bit BOFF2.
	DAC_CR_BOFF2 = 0x20000
	// DAC channel X output buffer enabled
	DAC_CR_BOFF2_Enabled = 0x0
	// DAC channel X output buffer disabled
	DAC_CR_BOFF2_Disabled = 0x1
	// Position of EN2 field.
	DAC_CR_EN2_Pos = 0x10
	// Bit mask of EN2 field.
	DAC_CR_EN2_Msk = 0x10000
	// Bit EN2.
	DAC_CR_EN2 = 0x10000
	// DAC channel X disabled
	DAC_CR_EN2_Disabled = 0x0
	// DAC channel X enabled
	DAC_CR_EN2_Enabled = 0x1
	// Position of DMAUDRIE1 field.
	DAC_CR_DMAUDRIE1_Pos = 0xd
	// Bit mask of DMAUDRIE1 field.
	DAC_CR_DMAUDRIE1_Msk = 0x2000
	// Bit DMAUDRIE1.
	DAC_CR_DMAUDRIE1 = 0x2000
	// DAC channel X DMA Underrun Interrupt disabled
	DAC_CR_DMAUDRIE1_Disabled = 0x0
	// DAC channel X DMA Underrun Interrupt enabled
	DAC_CR_DMAUDRIE1_Enabled = 0x1
	// Position of DMAEN1 field.
	DAC_CR_DMAEN1_Pos = 0xc
	// Bit mask of DMAEN1 field.
	DAC_CR_DMAEN1_Msk = 0x1000
	// Bit DMAEN1.
	DAC_CR_DMAEN1 = 0x1000
	// DAC channel X DMA mode disabled
	DAC_CR_DMAEN1_Disabled = 0x0
	// DAC channel X DMA mode enabled
	DAC_CR_DMAEN1_Enabled = 0x1
	// Position of MAMP1 field.
	DAC_CR_MAMP1_Pos = 0x8
	// Bit mask of MAMP1 field.
	DAC_CR_MAMP1_Msk = 0xf00
	// Position of WAVE1 field.
	DAC_CR_WAVE1_Pos = 0x6
	// Bit mask of WAVE1 field.
	DAC_CR_WAVE1_Msk = 0xc0
	// Wave generation disabled
	DAC_CR_WAVE1_Disabled = 0x0
	// Noise wave generation enabled
	DAC_CR_WAVE1_Noise = 0x1
	// Triangle wave generation enabled
	DAC_CR_WAVE1_Triangle = 0x2
	// Position of TSEL1 field.
	DAC_CR_TSEL1_Pos = 0x3
	// Bit mask of TSEL1 field.
	DAC_CR_TSEL1_Msk = 0x38
	// Timer 6 TRGO event
	DAC_CR_TSEL1_TIM6_TRGO = 0x0
	// Timer 3 TRGO event
	DAC_CR_TSEL1_TIM3_TRGO = 0x1
	// Timer 7 TRGO event
	DAC_CR_TSEL1_TIM7_TRGO = 0x2
	// Timer 15 TRGO event
	DAC_CR_TSEL1_TIM15_TRGO = 0x3
	// Timer 2 TRGO event
	DAC_CR_TSEL1_TIM2_TRGO = 0x4
	// EXTI line9
	DAC_CR_TSEL1_EXTI9 = 0x6
	// Software trigger
	DAC_CR_TSEL1_SOFTWARE = 0x7
	// Position of TEN1 field.
	DAC_CR_TEN1_Pos = 0x2
	// Bit mask of TEN1 field.
	DAC_CR_TEN1_Msk = 0x4
	// Bit TEN1.
	DAC_CR_TEN1 = 0x4
	// DAC channel X trigger disabled
	DAC_CR_TEN1_Disabled = 0x0
	// DAC channel X trigger enabled
	DAC_CR_TEN1_Enabled = 0x1
	// Position of BOFF1 field.
	DAC_CR_BOFF1_Pos = 0x1
	// Bit mask of BOFF1 field.
	DAC_CR_BOFF1_Msk = 0x2
	// Bit BOFF1.
	DAC_CR_BOFF1 = 0x2
	// DAC channel X output buffer enabled
	DAC_CR_BOFF1_Enabled = 0x0
	// DAC channel X output buffer disabled
	DAC_CR_BOFF1_Disabled = 0x1
	// Position of EN1 field.
	DAC_CR_EN1_Pos = 0x0
	// Bit mask of EN1 field.
	DAC_CR_EN1_Msk = 0x1
	// Bit EN1.
	DAC_CR_EN1 = 0x1
	// DAC channel X disabled
	DAC_CR_EN1_Disabled = 0x0
	// DAC channel X enabled
	DAC_CR_EN1_Enabled = 0x1

	// SWTRIGR: software trigger register
	// Position of SWTRIG2 field.
	DAC_SWTRIGR_SWTRIG2_Pos = 0x1
	// Bit mask of SWTRIG2 field.
	DAC_SWTRIGR_SWTRIG2_Msk = 0x2
	// Bit SWTRIG2.
	DAC_SWTRIGR_SWTRIG2 = 0x2
	// DAC channel X software trigger disabled
	DAC_SWTRIGR_SWTRIG2_Disabled = 0x0
	// DAC channel X software trigger enabled
	DAC_SWTRIGR_SWTRIG2_Enabled = 0x1
	// Position of SWTRIG1 field.
	DAC_SWTRIGR_SWTRIG1_Pos = 0x0
	// Bit mask of SWTRIG1 field.
	DAC_SWTRIGR_SWTRIG1_Msk = 0x1
	// Bit SWTRIG1.
	DAC_SWTRIGR_SWTRIG1 = 0x1
	// DAC channel X software trigger disabled
	DAC_SWTRIGR_SWTRIG1_Disabled = 0x0
	// DAC channel X software trigger enabled
	DAC_SWTRIGR_SWTRIG1_Enabled = 0x1

	// DHR12R1: channel1 12-bit right-aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR12R1_DACC1DHR_Pos = 0x0
	// Bit mask of DACC1DHR field.
	DAC_DHR12R1_DACC1DHR_Msk = 0xfff

	// DHR12L1: channel1 12-bit left aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR12L1_DACC1DHR_Pos = 0x4
	// Bit mask of DACC1DHR field.
	DAC_DHR12L1_DACC1DHR_Msk = 0xfff0

	// DHR8R1: channel1 8-bit right aligned data holding register
	// Position of DACC1DHR field.
	DAC_DHR8R1_DACC1DHR_Pos = 0x0
	// Bit mask of DACC1DHR field.
	DAC_DHR8R1_DACC1DHR_Msk = 0xff

	// DHR12R2: channel2 12-bit right aligned data holding register
	// Position of DACC2DHR field.
	DAC_DHR12R2_DACC2DHR_Pos = 0x0
	// Bit mask of DACC2DHR field.
	DAC_DHR12R2_DACC2DHR_Msk = 0xfff

	// DHR12L2: channel2 12-bit left aligned data holding register
	// Position of DACC2DHR field.
	DAC_DHR12L2_DACC2DHR_Pos = 0x4
	// Bit mask of DACC2DHR field.
	DAC_DHR12L2_DACC2DHR_Msk = 0xfff0

	// DHR8R2: channel2 8-bit right-aligned data holding register
	// Position of DACC2DHR field.
	DAC_DHR8R2_DACC2DHR_Pos = 0x0
	// Bit mask of DACC2DHR field.
	DAC_DHR8R2_DACC2DHR_Msk = 0xff

	// DHR12RD: Dual DAC 12-bit right-aligned data holding register
	// Position of DACC2DHR field.
	DAC_DHR12RD_DACC2DHR_Pos = 0x10
	// Bit mask of DACC2DHR field.
	DAC_DHR12RD_DACC2DHR_Msk = 0xfff0000
	// Position of DACC1DHR field.
	DAC_DHR12RD_DACC1DHR_Pos = 0x0
	// Bit mask of DACC1DHR field.
	DAC_DHR12RD_DACC1DHR_Msk = 0xfff

	// DHR12LD: DUAL DAC 12-bit left aligned data holding register
	// Position of DACC2DHR field.
	DAC_DHR12LD_DACC2DHR_Pos = 0x14
	// Bit mask of DACC2DHR field.
	DAC_DHR12LD_DACC2DHR_Msk = 0xfff00000
	// Position of DACC1DHR field.
	DAC_DHR12LD_DACC1DHR_Pos = 0x4
	// Bit mask of DACC1DHR field.
	DAC_DHR12LD_DACC1DHR_Msk = 0xfff0

	// DHR8RD: DUAL DAC 8-bit right aligned data holding register
	// Position of DACC2DHR field.
	DAC_DHR8RD_DACC2DHR_Pos = 0x8
	// Bit mask of DACC2DHR field.
	DAC_DHR8RD_DACC2DHR_Msk = 0xff00
	// Position of DACC1DHR field.
	DAC_DHR8RD_DACC1DHR_Pos = 0x0
	// Bit mask of DACC1DHR field.
	DAC_DHR8RD_DACC1DHR_Msk = 0xff

	// DOR1: channel1 data output register
	// Position of DACC1DOR field.
	DAC_DOR1_DACC1DOR_Pos = 0x0
	// Bit mask of DACC1DOR field.
	DAC_DOR1_DACC1DOR_Msk = 0xfff

	// DOR2: channel2 data output register
	// Position of DACC2DOR field.
	DAC_DOR2_DACC2DOR_Pos = 0x0
	// Bit mask of DACC2DOR field.
	DAC_DOR2_DACC2DOR_Msk = 0xfff

	// SR: status register
	// Position of DMAUDR2 field.
	DAC_SR_DMAUDR2_Pos = 0x1d
	// Bit mask of DMAUDR2 field.
	DAC_SR_DMAUDR2_Msk = 0x20000000
	// Bit DMAUDR2.
	DAC_SR_DMAUDR2 = 0x20000000
	// No DMA underrun error condition occurred for DAC channel X
	DAC_SR_DMAUDR2_NoUnderrun = 0x0
	// DMA underrun error condition occurred for DAC channel X
	DAC_SR_DMAUDR2_Underrun = 0x1
	// Position of DMAUDR1 field.
	DAC_SR_DMAUDR1_Pos = 0xd
	// Bit mask of DMAUDR1 field.
	DAC_SR_DMAUDR1_Msk = 0x2000
	// Bit DMAUDR1.
	DAC_SR_DMAUDR1 = 0x2000
	// No DMA underrun error condition occurred for DAC channel X
	DAC_SR_DMAUDR1_NoUnderrun = 0x0
	// DMA underrun error condition occurred for DAC channel X
	DAC_SR_DMAUDR1_Underrun = 0x1
)

// Constants for PWR: Power control
const (
	// CR1: power control register
	// Position of LPDS field.
	PWR_CR1_LPDS_Pos = 0x0
	// Bit mask of LPDS field.
	PWR_CR1_LPDS_Msk = 0x1
	// Bit LPDS.
	PWR_CR1_LPDS = 0x1
	// Position of PDDS field.
	PWR_CR1_PDDS_Pos = 0x1
	// Bit mask of PDDS field.
	PWR_CR1_PDDS_Msk = 0x2
	// Bit PDDS.
	PWR_CR1_PDDS = 0x2
	// Enter Stop mode when the CPU enters deepsleep
	PWR_CR1_PDDS_STOP_MODE = 0x0
	// Enter Standby mode when the CPU enters deepsleep
	PWR_CR1_PDDS_STANDBY_MODE = 0x1
	// Position of CSBF field.
	PWR_CR1_CSBF_Pos = 0x3
	// Bit mask of CSBF field.
	PWR_CR1_CSBF_Msk = 0x8
	// Bit CSBF.
	PWR_CR1_CSBF = 0x8
	// Position of PVDE field.
	PWR_CR1_PVDE_Pos = 0x4
	// Bit mask of PVDE field.
	PWR_CR1_PVDE_Msk = 0x10
	// Bit PVDE.
	PWR_CR1_PVDE = 0x10
	// Position of PLS field.
	PWR_CR1_PLS_Pos = 0x5
	// Bit mask of PLS field.
	PWR_CR1_PLS_Msk = 0xe0
	// Position of DBP field.
	PWR_CR1_DBP_Pos = 0x8
	// Bit mask of DBP field.
	PWR_CR1_DBP_Msk = 0x100
	// Bit DBP.
	PWR_CR1_DBP = 0x100
	// Position of FPDS field.
	PWR_CR1_FPDS_Pos = 0x9
	// Bit mask of FPDS field.
	PWR_CR1_FPDS_Msk = 0x200
	// Bit FPDS.
	PWR_CR1_FPDS = 0x200
	// Position of LPUDS field.
	PWR_CR1_LPUDS_Pos = 0xa
	// Bit mask of LPUDS field.
	PWR_CR1_LPUDS_Msk = 0x400
	// Bit LPUDS.
	PWR_CR1_LPUDS = 0x400
	// Position of MRUDS field.
	PWR_CR1_MRUDS_Pos = 0xb
	// Bit mask of MRUDS field.
	PWR_CR1_MRUDS_Msk = 0x800
	// Bit MRUDS.
	PWR_CR1_MRUDS = 0x800
	// Position of ADCDC1 field.
	PWR_CR1_ADCDC1_Pos = 0xd
	// Bit mask of ADCDC1 field.
	PWR_CR1_ADCDC1_Msk = 0x2000
	// Bit ADCDC1.
	PWR_CR1_ADCDC1 = 0x2000
	// Position of VOS field.
	PWR_CR1_VOS_Pos = 0xe
	// Bit mask of VOS field.
	PWR_CR1_VOS_Msk = 0xc000
	// Scale 1 mode (reset value)
	PWR_CR1_VOS_SCALE1 = 0x3
	// Scale 2 mode
	PWR_CR1_VOS_SCALE2 = 0x2
	// Scale 3 mode
	PWR_CR1_VOS_SCALE3 = 0x1
	// Position of ODEN field.
	PWR_CR1_ODEN_Pos = 0x10
	// Bit mask of ODEN field.
	PWR_CR1_ODEN_Msk = 0x10000
	// Bit ODEN.
	PWR_CR1_ODEN = 0x10000
	// Position of ODSWEN field.
	PWR_CR1_ODSWEN_Pos = 0x11
	// Bit mask of ODSWEN field.
	PWR_CR1_ODSWEN_Msk = 0x20000
	// Bit ODSWEN.
	PWR_CR1_ODSWEN = 0x20000
	// Position of UDEN field.
	PWR_CR1_UDEN_Pos = 0x12
	// Bit mask of UDEN field.
	PWR_CR1_UDEN_Msk = 0xc0000

	// CSR1: power control/status register
	// Position of WUIF field.
	PWR_CSR1_WUIF_Pos = 0x0
	// Bit mask of WUIF field.
	PWR_CSR1_WUIF_Msk = 0x1
	// Bit WUIF.
	PWR_CSR1_WUIF = 0x1
	// Position of SBF field.
	PWR_CSR1_SBF_Pos = 0x1
	// Bit mask of SBF field.
	PWR_CSR1_SBF_Msk = 0x2
	// Bit SBF.
	PWR_CSR1_SBF = 0x2
	// Position of PVDO field.
	PWR_CSR1_PVDO_Pos = 0x2
	// Bit mask of PVDO field.
	PWR_CSR1_PVDO_Msk = 0x4
	// Bit PVDO.
	PWR_CSR1_PVDO = 0x4
	// Position of BRR field.
	PWR_CSR1_BRR_Pos = 0x3
	// Bit mask of BRR field.
	PWR_CSR1_BRR_Msk = 0x8
	// Bit BRR.
	PWR_CSR1_BRR = 0x8
	// Position of BRE field.
	PWR_CSR1_BRE_Pos = 0x9
	// Bit mask of BRE field.
	PWR_CSR1_BRE_Msk = 0x200
	// Bit BRE.
	PWR_CSR1_BRE = 0x200
	// Position of VOSRDY field.
	PWR_CSR1_VOSRDY_Pos = 0xe
	// Bit mask of VOSRDY field.
	PWR_CSR1_VOSRDY_Msk = 0x4000
	// Bit VOSRDY.
	PWR_CSR1_VOSRDY = 0x4000
	// Position of ODRDY field.
	PWR_CSR1_ODRDY_Pos = 0x10
	// Bit mask of ODRDY field.
	PWR_CSR1_ODRDY_Msk = 0x10000
	// Bit ODRDY.
	PWR_CSR1_ODRDY = 0x10000
	// Position of ODSWRDY field.
	PWR_CSR1_ODSWRDY_Pos = 0x11
	// Bit mask of ODSWRDY field.
	PWR_CSR1_ODSWRDY_Msk = 0x20000
	// Bit ODSWRDY.
	PWR_CSR1_ODSWRDY = 0x20000
	// Position of UDRDY field.
	PWR_CSR1_UDRDY_Pos = 0x12
	// Bit mask of UDRDY field.
	PWR_CSR1_UDRDY_Msk = 0xc0000

	// CR2: power control register
	// Position of CWUPF1 field.
	PWR_CR2_CWUPF1_Pos = 0x0
	// Bit mask of CWUPF1 field.
	PWR_CR2_CWUPF1_Msk = 0x1
	// Bit CWUPF1.
	PWR_CR2_CWUPF1 = 0x1
	// Position of CWUPF2 field.
	PWR_CR2_CWUPF2_Pos = 0x1
	// Bit mask of CWUPF2 field.
	PWR_CR2_CWUPF2_Msk = 0x2
	// Bit CWUPF2.
	PWR_CR2_CWUPF2 = 0x2
	// Position of CWUPF3 field.
	PWR_CR2_CWUPF3_Pos = 0x2
	// Bit mask of CWUPF3 field.
	PWR_CR2_CWUPF3_Msk = 0x4
	// Bit CWUPF3.
	PWR_CR2_CWUPF3 = 0x4
	// Position of CWUPF4 field.
	PWR_CR2_CWUPF4_Pos = 0x3
	// Bit mask of CWUPF4 field.
	PWR_CR2_CWUPF4_Msk = 0x8
	// Bit CWUPF4.
	PWR_CR2_CWUPF4 = 0x8
	// Position of CWUPF5 field.
	PWR_CR2_CWUPF5_Pos = 0x4
	// Bit mask of CWUPF5 field.
	PWR_CR2_CWUPF5_Msk = 0x10
	// Bit CWUPF5.
	PWR_CR2_CWUPF5 = 0x10
	// Position of CWUPF6 field.
	PWR_CR2_CWUPF6_Pos = 0x5
	// Bit mask of CWUPF6 field.
	PWR_CR2_CWUPF6_Msk = 0x20
	// Bit CWUPF6.
	PWR_CR2_CWUPF6 = 0x20
	// Position of WUPP1 field.
	PWR_CR2_WUPP1_Pos = 0x8
	// Bit mask of WUPP1 field.
	PWR_CR2_WUPP1_Msk = 0x100
	// Bit WUPP1.
	PWR_CR2_WUPP1 = 0x100
	// Position of WUPP2 field.
	PWR_CR2_WUPP2_Pos = 0x9
	// Bit mask of WUPP2 field.
	PWR_CR2_WUPP2_Msk = 0x200
	// Bit WUPP2.
	PWR_CR2_WUPP2 = 0x200
	// Position of WUPP3 field.
	PWR_CR2_WUPP3_Pos = 0xa
	// Bit mask of WUPP3 field.
	PWR_CR2_WUPP3_Msk = 0x400
	// Bit WUPP3.
	PWR_CR2_WUPP3 = 0x400
	// Position of WUPP4 field.
	PWR_CR2_WUPP4_Pos = 0xb
	// Bit mask of WUPP4 field.
	PWR_CR2_WUPP4_Msk = 0x800
	// Bit WUPP4.
	PWR_CR2_WUPP4 = 0x800
	// Position of WUPP5 field.
	PWR_CR2_WUPP5_Pos = 0xc
	// Bit mask of WUPP5 field.
	PWR_CR2_WUPP5_Msk = 0x1000
	// Bit WUPP5.
	PWR_CR2_WUPP5 = 0x1000
	// Position of WUPP6 field.
	PWR_CR2_WUPP6_Pos = 0xd
	// Bit mask of WUPP6 field.
	PWR_CR2_WUPP6_Msk = 0x2000
	// Bit WUPP6.
	PWR_CR2_WUPP6 = 0x2000

	// CSR2: power control/status register
	// Position of WUPF1 field.
	PWR_CSR2_WUPF1_Pos = 0x0
	// Bit mask of WUPF1 field.
	PWR_CSR2_WUPF1_Msk = 0x1
	// Bit WUPF1.
	PWR_CSR2_WUPF1 = 0x1
	// Position of WUPF2 field.
	PWR_CSR2_WUPF2_Pos = 0x1
	// Bit mask of WUPF2 field.
	PWR_CSR2_WUPF2_Msk = 0x2
	// Bit WUPF2.
	PWR_CSR2_WUPF2 = 0x2
	// Position of WUPF3 field.
	PWR_CSR2_WUPF3_Pos = 0x2
	// Bit mask of WUPF3 field.
	PWR_CSR2_WUPF3_Msk = 0x4
	// Bit WUPF3.
	PWR_CSR2_WUPF3 = 0x4
	// Position of WUPF4 field.
	PWR_CSR2_WUPF4_Pos = 0x3
	// Bit mask of WUPF4 field.
	PWR_CSR2_WUPF4_Msk = 0x8
	// Bit WUPF4.
	PWR_CSR2_WUPF4 = 0x8
	// Position of WUPF5 field.
	PWR_CSR2_WUPF5_Pos = 0x4
	// Bit mask of WUPF5 field.
	PWR_CSR2_WUPF5_Msk = 0x10
	// Bit WUPF5.
	PWR_CSR2_WUPF5 = 0x10
	// Position of WUPF6 field.
	PWR_CSR2_WUPF6_Pos = 0x5
	// Bit mask of WUPF6 field.
	PWR_CSR2_WUPF6_Msk = 0x20
	// Bit WUPF6.
	PWR_CSR2_WUPF6 = 0x20
	// Position of EWUP1 field.
	PWR_CSR2_EWUP1_Pos = 0x8
	// Bit mask of EWUP1 field.
	PWR_CSR2_EWUP1_Msk = 0x100
	// Bit EWUP1.
	PWR_CSR2_EWUP1 = 0x100
	// Position of EWUP2 field.
	PWR_CSR2_EWUP2_Pos = 0x9
	// Bit mask of EWUP2 field.
	PWR_CSR2_EWUP2_Msk = 0x200
	// Bit EWUP2.
	PWR_CSR2_EWUP2 = 0x200
	// Position of EWUP3 field.
	PWR_CSR2_EWUP3_Pos = 0xa
	// Bit mask of EWUP3 field.
	PWR_CSR2_EWUP3_Msk = 0x400
	// Bit EWUP3.
	PWR_CSR2_EWUP3 = 0x400
	// Position of EWUP4 field.
	PWR_CSR2_EWUP4_Pos = 0xb
	// Bit mask of EWUP4 field.
	PWR_CSR2_EWUP4_Msk = 0x800
	// Bit EWUP4.
	PWR_CSR2_EWUP4 = 0x800
	// Position of EWUP5 field.
	PWR_CSR2_EWUP5_Pos = 0xc
	// Bit mask of EWUP5 field.
	PWR_CSR2_EWUP5_Msk = 0x1000
	// Bit EWUP5.
	PWR_CSR2_EWUP5 = 0x1000
	// Position of EWUP6 field.
	PWR_CSR2_EWUP6_Pos = 0xd
	// Bit mask of EWUP6 field.
	PWR_CSR2_EWUP6_Msk = 0x2000
	// Bit EWUP6.
	PWR_CSR2_EWUP6 = 0x2000
)

// Constants for IWDG: Independent watchdog
const (
	// KR: Key register
	// Position of KEY field.
	IWDG_KR_KEY_Pos = 0x0
	// Bit mask of KEY field.
	IWDG_KR_KEY_Msk = 0xffff
	// Enable access to PR, RLR and WINR registers (0x5555)
	IWDG_KR_KEY_Enable = 0x5555
	// Reset the watchdog value (0xAAAA)
	IWDG_KR_KEY_Reset = 0xaaaa
	// Start the watchdog (0xCCCC)
	IWDG_KR_KEY_Start = 0xcccc

	// PR: Prescaler register
	// Position of PR field.
	IWDG_PR_PR_Pos = 0x0
	// Bit mask of PR field.
	IWDG_PR_PR_Msk = 0x7
	// Divider /4
	IWDG_PR_PR_DivideBy4 = 0x0
	// Divider /8
	IWDG_PR_PR_DivideBy8 = 0x1
	// Divider /16
	IWDG_PR_PR_DivideBy16 = 0x2
	// Divider /32
	IWDG_PR_PR_DivideBy32 = 0x3
	// Divider /64
	IWDG_PR_PR_DivideBy64 = 0x4
	// Divider /128
	IWDG_PR_PR_DivideBy128 = 0x5
	// Divider /256
	IWDG_PR_PR_DivideBy256 = 0x6
	// Divider /256
	IWDG_PR_PR_DivideBy256bis = 0x7

	// RLR: Reload register
	// Position of RL field.
	IWDG_RLR_RL_Pos = 0x0
	// Bit mask of RL field.
	IWDG_RLR_RL_Msk = 0xfff

	// SR: Status register
	// Position of RVU field.
	IWDG_SR_RVU_Pos = 0x1
	// Bit mask of RVU field.
	IWDG_SR_RVU_Msk = 0x2
	// Bit RVU.
	IWDG_SR_RVU = 0x2
	// Position of PVU field.
	IWDG_SR_PVU_Pos = 0x0
	// Bit mask of PVU field.
	IWDG_SR_PVU_Msk = 0x1
	// Bit PVU.
	IWDG_SR_PVU = 0x1

	// WINR: Window register
	// Position of WIN field.
	IWDG_WINR_WIN_Pos = 0x0
	// Bit mask of WIN field.
	IWDG_WINR_WIN_Msk = 0xfff
)

// Constants for WWDG: Window watchdog
const (
	// CR: Control register
	// Position of WDGA field.
	WWDG_CR_WDGA_Pos = 0x7
	// Bit mask of WDGA field.
	WWDG_CR_WDGA_Msk = 0x80
	// Bit WDGA.
	WWDG_CR_WDGA = 0x80
	// Watchdog disabled
	WWDG_CR_WDGA_Disabled = 0x0
	// Watchdog enabled
	WWDG_CR_WDGA_Enabled = 0x1
	// Position of T field.
	WWDG_CR_T_Pos = 0x0
	// Bit mask of T field.
	WWDG_CR_T_Msk = 0x7f

	// CFR: Configuration register
	// Position of EWI field.
	WWDG_CFR_EWI_Pos = 0x9
	// Bit mask of EWI field.
	WWDG_CFR_EWI_Msk = 0x200
	// Bit EWI.
	WWDG_CFR_EWI = 0x200
	// interrupt occurs whenever the counter reaches the value 0x40
	WWDG_CFR_EWI_Enable = 0x1
	// Position of W field.
	WWDG_CFR_W_Pos = 0x0
	// Bit mask of W field.
	WWDG_CFR_W_Msk = 0x7f
	// Position of WDGTB field.
	WWDG_CFR_WDGTB_Pos = 0x7
	// Bit mask of WDGTB field.
	WWDG_CFR_WDGTB_Msk = 0x180
	// Counter clock (PCLK1 div 4096) div 1
	WWDG_CFR_WDGTB_Div1 = 0x0
	// Counter clock (PCLK1 div 4096) div 2
	WWDG_CFR_WDGTB_Div2 = 0x1
	// Counter clock (PCLK1 div 4096) div 4
	WWDG_CFR_WDGTB_Div4 = 0x2
	// Counter clock (PCLK1 div 4096) div 8
	WWDG_CFR_WDGTB_Div8 = 0x3

	// SR: Status register
	// Position of EWIF field.
	WWDG_SR_EWIF_Pos = 0x0
	// Bit mask of EWIF field.
	WWDG_SR_EWIF_Msk = 0x1
	// Bit EWIF.
	WWDG_SR_EWIF = 0x1
	// The EWI Interrupt Service Routine has been triggered
	WWDG_SR_EWIF_Pending = 0x1
	// The EWI Interrupt Service Routine has been serviced
	WWDG_SR_EWIF_Finished = 0x0
)

// Constants for TIM1: Advanced-timers
const (
	// CR1: control register 1
	// Position of CKD field.
	TIM_CR1_CKD_Pos = 0x8
	// Bit mask of CKD field.
	TIM_CR1_CKD_Msk = 0x300
	// t_DTS = t_CK_INT
	TIM_CR1_CKD_Div1 = 0x0
	// t_DTS = 2  t_CK_INT
	TIM_CR1_CKD_Div2 = 0x1
	// t_DTS = 4  t_CK_INT
	TIM_CR1_CKD_Div4 = 0x2
	// Position of ARPE field.
	TIM_CR1_ARPE_Pos = 0x7
	// Bit mask of ARPE field.
	TIM_CR1_ARPE_Msk = 0x80
	// Bit ARPE.
	TIM_CR1_ARPE = 0x80
	// TIMx_APRR register is not buffered
	TIM_CR1_ARPE_Disabled = 0x0
	// TIMx_APRR register is buffered
	TIM_CR1_ARPE_Enabled = 0x1
	// Position of CMS field.
	TIM_CR1_CMS_Pos = 0x5
	// Bit mask of CMS field.
	TIM_CR1_CMS_Msk = 0x60
	// The counter counts up or down depending on the direction bit
	TIM_CR1_CMS_EdgeAligned = 0x0
	// The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down.
	TIM_CR1_CMS_CenterAligned1 = 0x1
	// The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up.
	TIM_CR1_CMS_CenterAligned2 = 0x2
	// The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down.
	TIM_CR1_CMS_CenterAligned3 = 0x3
	// Position of DIR field.
	TIM_CR1_DIR_Pos = 0x4
	// Bit mask of DIR field.
	TIM_CR1_DIR_Msk = 0x10
	// Bit DIR.
	TIM_CR1_DIR = 0x10
	// Counter used as upcounter
	TIM_CR1_DIR_Up = 0x0
	// Counter used as downcounter
	TIM_CR1_DIR_Down = 0x1
	// Position of OPM field.
	TIM_CR1_OPM_Pos = 0x3
	// Bit mask of OPM field.
	TIM_CR1_OPM_Msk = 0x8
	// Bit OPM.
	TIM_CR1_OPM = 0x8
	// Counter is not stopped at update event
	TIM_CR1_OPM_Disabled = 0x0
	// Counter stops counting at the next update event (clearing the CEN bit)
	TIM_CR1_OPM_Enabled = 0x1
	// Position of URS field.
	TIM_CR1_URS_Pos = 0x2
	// Bit mask of URS field.
	TIM_CR1_URS_Msk = 0x4
	// Bit URS.
	TIM_CR1_URS = 0x4
	// Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
	TIM_CR1_URS_AnyEvent = 0x0
	// Only counter overflow/underflow generates an update interrupt or DMA request
	TIM_CR1_URS_CounterOnly = 0x1
	// Position of UDIS field.
	TIM_CR1_UDIS_Pos = 0x1
	// Bit mask of UDIS field.
	TIM_CR1_UDIS_Msk = 0x2
	// Bit UDIS.
	TIM_CR1_UDIS = 0x2
	// Update event enabled
	TIM_CR1_UDIS_Enabled = 0x0
	// Update event disabled
	TIM_CR1_UDIS_Disabled = 0x1
	// Position of CEN field.
	TIM_CR1_CEN_Pos = 0x0
	// Bit mask of CEN field.
	TIM_CR1_CEN_Msk = 0x1
	// Bit CEN.
	TIM_CR1_CEN = 0x1
	// Counter disabled
	TIM_CR1_CEN_Disabled = 0x0
	// Counter enabled
	TIM_CR1_CEN_Enabled = 0x1
	// Position of UIFREMAP field.
	TIM_CR1_UIFREMAP_Pos = 0xb
	// Bit mask of UIFREMAP field.
	TIM_CR1_UIFREMAP_Msk = 0x800
	// Bit UIFREMAP.
	TIM_CR1_UIFREMAP = 0x800

	// CR2: control register 2
	// Position of OIS4 field.
	TIM_CR2_OIS4_Pos = 0xe
	// Bit mask of OIS4 field.
	TIM_CR2_OIS4_Msk = 0x4000
	// Bit OIS4.
	TIM_CR2_OIS4 = 0x4000
	// Position of OIS3N field.
	TIM_CR2_OIS3N_Pos = 0xd
	// Bit mask of OIS3N field.
	TIM_CR2_OIS3N_Msk = 0x2000
	// Bit OIS3N.
	TIM_CR2_OIS3N = 0x2000
	// Position of OIS3 field.
	TIM_CR2_OIS3_Pos = 0xc
	// Bit mask of OIS3 field.
	TIM_CR2_OIS3_Msk = 0x1000
	// Bit OIS3.
	TIM_CR2_OIS3 = 0x1000
	// Position of OIS2N field.
	TIM_CR2_OIS2N_Pos = 0xb
	// Bit mask of OIS2N field.
	TIM_CR2_OIS2N_Msk = 0x800
	// Bit OIS2N.
	TIM_CR2_OIS2N = 0x800
	// Position of OIS2 field.
	TIM_CR2_OIS2_Pos = 0xa
	// Bit mask of OIS2 field.
	TIM_CR2_OIS2_Msk = 0x400
	// Bit OIS2.
	TIM_CR2_OIS2 = 0x400
	// Position of OIS1N field.
	TIM_CR2_OIS1N_Pos = 0x9
	// Bit mask of OIS1N field.
	TIM_CR2_OIS1N_Msk = 0x200
	// Bit OIS1N.
	TIM_CR2_OIS1N = 0x200
	// Position of OIS1 field.
	TIM_CR2_OIS1_Pos = 0x8
	// Bit mask of OIS1 field.
	TIM_CR2_OIS1_Msk = 0x100
	// Bit OIS1.
	TIM_CR2_OIS1 = 0x100
	// Position of TI1S field.
	TIM_CR2_TI1S_Pos = 0x7
	// Bit mask of TI1S field.
	TIM_CR2_TI1S_Msk = 0x80
	// Bit TI1S.
	TIM_CR2_TI1S = 0x80
	// The TIMx_CH1 pin is connected to TI1 input
	TIM_CR2_TI1S_Normal = 0x0
	// The TIMx_CH1, CH2, CH3 pins are connected to TI1 input
	TIM_CR2_TI1S_XOR = 0x1
	// Position of MMS field.
	TIM_CR2_MMS_Pos = 0x4
	// Bit mask of MMS field.
	TIM_CR2_MMS_Msk = 0x70
	// The UG bit from the TIMx_EGR register is used as trigger output
	TIM_CR2_MMS_Reset = 0x0
	// The counter enable signal, CNT_EN, is used as trigger output
	TIM_CR2_MMS_Enable = 0x1
	// The update event is selected as trigger output
	TIM_CR2_MMS_Update = 0x2
	// The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred
	TIM_CR2_MMS_ComparePulse = 0x3
	// OC1REF signal is used as trigger output
	TIM_CR2_MMS_CompareOC1 = 0x4
	// OC2REF signal is used as trigger output
	TIM_CR2_MMS_CompareOC2 = 0x5
	// OC3REF signal is used as trigger output
	TIM_CR2_MMS_CompareOC3 = 0x6
	// OC4REF signal is used as trigger output
	TIM_CR2_MMS_CompareOC4 = 0x7
	// Position of CCDS field.
	TIM_CR2_CCDS_Pos = 0x3
	// Bit mask of CCDS field.
	TIM_CR2_CCDS_Msk = 0x8
	// Bit CCDS.
	TIM_CR2_CCDS = 0x8
	// CCx DMA request sent when CCx event occurs
	TIM_CR2_CCDS_OnCompare = 0x0
	// CCx DMA request sent when update event occurs
	TIM_CR2_CCDS_OnUpdate = 0x1
	// Position of CCUS field.
	TIM_CR2_CCUS_Pos = 0x2
	// Bit mask of CCUS field.
	TIM_CR2_CCUS_Msk = 0x4
	// Bit CCUS.
	TIM_CR2_CCUS = 0x4
	// Position of CCPC field.
	TIM_CR2_CCPC_Pos = 0x0
	// Bit mask of CCPC field.
	TIM_CR2_CCPC_Msk = 0x1
	// Bit CCPC.
	TIM_CR2_CCPC = 0x1
	// Position of OIS5 field.
	TIM_CR2_OIS5_Pos = 0x10
	// Bit mask of OIS5 field.
	TIM_CR2_OIS5_Msk = 0x10000
	// Bit OIS5.
	TIM_CR2_OIS5 = 0x10000
	// Position of OIS6 field.
	TIM_CR2_OIS6_Pos = 0x12
	// Bit mask of OIS6 field.
	TIM_CR2_OIS6_Msk = 0x40000
	// Bit OIS6.
	TIM_CR2_OIS6 = 0x40000
	// Position of MMS2 field.
	TIM_CR2_MMS2_Pos = 0x14
	// Bit mask of MMS2 field.
	TIM_CR2_MMS2_Msk = 0xf00000

	// SMCR: slave mode control register
	// Position of ETP field.
	TIM_SMCR_ETP_Pos = 0xf
	// Bit mask of ETP field.
	TIM_SMCR_ETP_Msk = 0x8000
	// Bit ETP.
	TIM_SMCR_ETP = 0x8000
	// ETR is noninverted, active at high level or rising edge
	TIM_SMCR_ETP_NotInverted = 0x0
	// ETR is inverted, active at low level or falling edge
	TIM_SMCR_ETP_Inverted = 0x1
	// Position of ECE field.
	TIM_SMCR_ECE_Pos = 0xe
	// Bit mask of ECE field.
	TIM_SMCR_ECE_Msk = 0x4000
	// Bit ECE.
	TIM_SMCR_ECE = 0x4000
	// External clock mode 2 disabled
	TIM_SMCR_ECE_Disabled = 0x0
	// External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
	TIM_SMCR_ECE_Enabled = 0x1
	// Position of ETPS field.
	TIM_SMCR_ETPS_Pos = 0xc
	// Bit mask of ETPS field.
	TIM_SMCR_ETPS_Msk = 0x3000
	// Prescaler OFF
	TIM_SMCR_ETPS_Div1 = 0x0
	// ETRP frequency divided by 2
	TIM_SMCR_ETPS_Div2 = 0x1
	// ETRP frequency divided by 4
	TIM_SMCR_ETPS_Div4 = 0x2
	// ETRP frequency divided by 8
	TIM_SMCR_ETPS_Div8 = 0x3
	// Position of ETF field.
	TIM_SMCR_ETF_Pos = 0x8
	// Bit mask of ETF field.
	TIM_SMCR_ETF_Msk = 0xf00
	// No filter, sampling is done at fDTS
	TIM_SMCR_ETF_NoFilter = 0x0
	// fSAMPLING=fCK_INT, N=2
	TIM_SMCR_ETF_FCK_INT_N2 = 0x1
	// fSAMPLING=fCK_INT, N=4
	TIM_SMCR_ETF_FCK_INT_N4 = 0x2
	// fSAMPLING=fCK_INT, N=8
	TIM_SMCR_ETF_FCK_INT_N8 = 0x3
	// fSAMPLING=fDTS/2, N=6
	TIM_SMCR_ETF_FDTS_Div2_N6 = 0x4
	// fSAMPLING=fDTS/2, N=8
	TIM_SMCR_ETF_FDTS_Div2_N8 = 0x5
	// fSAMPLING=fDTS/4, N=6
	TIM_SMCR_ETF_FDTS_Div4_N6 = 0x6
	// fSAMPLING=fDTS/4, N=8
	TIM_SMCR_ETF_FDTS_Div4_N8 = 0x7
	// fSAMPLING=fDTS/8, N=6
	TIM_SMCR_ETF_FDTS_Div8_N6 = 0x8
	// fSAMPLING=fDTS/8, N=8
	TIM_SMCR_ETF_FDTS_Div8_N8 = 0x9
	// fSAMPLING=fDTS/16, N=5
	TIM_SMCR_ETF_FDTS_Div16_N5 = 0xa
	// fSAMPLING=fDTS/16, N=6
	TIM_SMCR_ETF_FDTS_Div16_N6 = 0xb
	// fSAMPLING=fDTS/16, N=8
	TIM_SMCR_ETF_FDTS_Div16_N8 = 0xc
	// fSAMPLING=fDTS/32, N=5
	TIM_SMCR_ETF_FDTS_Div32_N5 = 0xd
	// fSAMPLING=fDTS/32, N=6
	TIM_SMCR_ETF_FDTS_Div32_N6 = 0xe
	// fSAMPLING=fDTS/32, N=8
	TIM_SMCR_ETF_FDTS_Div32_N8 = 0xf
	// Position of MSM field.
	TIM_SMCR_MSM_Pos = 0x7
	// Bit mask of MSM field.
	TIM_SMCR_MSM_Msk = 0x80
	// Bit MSM.
	TIM_SMCR_MSM = 0x80
	// No action
	TIM_SMCR_MSM_NoSync = 0x0
	// The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
	TIM_SMCR_MSM_Sync = 0x1
	// Position of TS field.
	TIM_SMCR_TS_Pos = 0x4
	// Bit mask of TS field.
	TIM_SMCR_TS_Msk = 0x70
	// Internal Trigger 0 (ITR0)
	TIM_SMCR_TS_ITR0 = 0x0
	// Internal Trigger 1 (ITR1)
	TIM_SMCR_TS_ITR1 = 0x1
	// Internal Trigger 2 (ITR2)
	TIM_SMCR_TS_ITR2 = 0x2
	// TI1 Edge Detector (TI1F_ED)
	TIM_SMCR_TS_TI1F_ED = 0x4
	// Filtered Timer Input 1 (TI1FP1)
	TIM_SMCR_TS_TI1FP1 = 0x5
	// Filtered Timer Input 2 (TI2FP2)
	TIM_SMCR_TS_TI2FP2 = 0x6
	// External Trigger input (ETRF)
	TIM_SMCR_TS_ETRF = 0x7
	// Position of SMS field.
	TIM_SMCR_SMS_Pos = 0x0
	// Bit mask of SMS field.
	TIM_SMCR_SMS_Msk = 0x7
	// Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock.
	TIM_SMCR_SMS_Disabled = 0x0
	// Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level.
	TIM_SMCR_SMS_Encoder_Mode_1 = 0x1
	// Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level.
	TIM_SMCR_SMS_Encoder_Mode_2 = 0x2
	// Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
	TIM_SMCR_SMS_Encoder_Mode_3 = 0x3
	// Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
	TIM_SMCR_SMS_Reset_Mode = 0x4
	// Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
	TIM_SMCR_SMS_Gated_Mode = 0x5
	// Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
	TIM_SMCR_SMS_Trigger_Mode = 0x6
	// External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
	TIM_SMCR_SMS_Ext_Clock_Mode = 0x7
	// Position of SMS_3 field.
	TIM_SMCR_SMS_3_Pos = 0x10
	// Bit mask of SMS_3 field.
	TIM_SMCR_SMS_3_Msk = 0x10000
	// Bit SMS_3.
	TIM_SMCR_SMS_3 = 0x10000

	// DIER: DMA/Interrupt enable register
	// Position of TDE field.
	TIM_DIER_TDE_Pos = 0xe
	// Bit mask of TDE field.
	TIM_DIER_TDE_Msk = 0x4000
	// Bit TDE.
	TIM_DIER_TDE = 0x4000
	// Trigger DMA request disabled
	TIM_DIER_TDE_Disabled = 0x0
	// Trigger DMA request enabled
	TIM_DIER_TDE_Enabled = 0x1
	// Position of COMDE field.
	TIM_DIER_COMDE_Pos = 0xd
	// Bit mask of COMDE field.
	TIM_DIER_COMDE_Msk = 0x2000
	// Bit COMDE.
	TIM_DIER_COMDE = 0x2000
	// Position of CC4DE field.
	TIM_DIER_CC4DE_Pos = 0xc
	// Bit mask of CC4DE field.
	TIM_DIER_CC4DE_Msk = 0x1000
	// Bit CC4DE.
	TIM_DIER_CC4DE = 0x1000
	// CCx DMA request disabled
	TIM_DIER_CC4DE_Disabled = 0x0
	// CCx DMA request enabled
	TIM_DIER_CC4DE_Enabled = 0x1
	// Position of CC3DE field.
	TIM_DIER_CC3DE_Pos = 0xb
	// Bit mask of CC3DE field.
	TIM_DIER_CC3DE_Msk = 0x800
	// Bit CC3DE.
	TIM_DIER_CC3DE = 0x800
	// CCx DMA request disabled
	TIM_DIER_CC3DE_Disabled = 0x0
	// CCx DMA request enabled
	TIM_DIER_CC3DE_Enabled = 0x1
	// Position of CC2DE field.
	TIM_DIER_CC2DE_Pos = 0xa
	// Bit mask of CC2DE field.
	TIM_DIER_CC2DE_Msk = 0x400
	// Bit CC2DE.
	TIM_DIER_CC2DE = 0x400
	// CCx DMA request disabled
	TIM_DIER_CC2DE_Disabled = 0x0
	// CCx DMA request enabled
	TIM_DIER_CC2DE_Enabled = 0x1
	// Position of CC1DE field.
	TIM_DIER_CC1DE_Pos = 0x9
	// Bit mask of CC1DE field.
	TIM_DIER_CC1DE_Msk = 0x200
	// Bit CC1DE.
	TIM_DIER_CC1DE = 0x200
	// CCx DMA request disabled
	TIM_DIER_CC1DE_Disabled = 0x0
	// CCx DMA request enabled
	TIM_DIER_CC1DE_Enabled = 0x1
	// Position of UDE field.
	TIM_DIER_UDE_Pos = 0x8
	// Bit mask of UDE field.
	TIM_DIER_UDE_Msk = 0x100
	// Bit UDE.
	TIM_DIER_UDE = 0x100
	// Update DMA request disabled
	TIM_DIER_UDE_Disabled = 0x0
	// Update DMA request enabled
	TIM_DIER_UDE_Enabled = 0x1
	// Position of TIE field.
	TIM_DIER_TIE_Pos = 0x6
	// Bit mask of TIE field.
	TIM_DIER_TIE_Msk = 0x40
	// Bit TIE.
	TIM_DIER_TIE = 0x40
	// Trigger interrupt disabled
	TIM_DIER_TIE_Disabled = 0x0
	// Trigger interrupt enabled
	TIM_DIER_TIE_Enabled = 0x1
	// Position of CC4IE field.
	TIM_DIER_CC4IE_Pos = 0x4
	// Bit mask of CC4IE field.
	TIM_DIER_CC4IE_Msk = 0x10
	// Bit CC4IE.
	TIM_DIER_CC4IE = 0x10
	// CCx interrupt disabled
	TIM_DIER_CC4IE_Disabled = 0x0
	// CCx interrupt enabled
	TIM_DIER_CC4IE_Enabled = 0x1
	// Position of CC3IE field.
	TIM_DIER_CC3IE_Pos = 0x3
	// Bit mask of CC3IE field.
	TIM_DIER_CC3IE_Msk = 0x8
	// Bit CC3IE.
	TIM_DIER_CC3IE = 0x8
	// CCx interrupt disabled
	TIM_DIER_CC3IE_Disabled = 0x0
	// CCx interrupt enabled
	TIM_DIER_CC3IE_Enabled = 0x1
	// Position of CC2IE field.
	TIM_DIER_CC2IE_Pos = 0x2
	// Bit mask of CC2IE field.
	TIM_DIER_CC2IE_Msk = 0x4
	// Bit CC2IE.
	TIM_DIER_CC2IE = 0x4
	// CCx interrupt disabled
	TIM_DIER_CC2IE_Disabled = 0x0
	// CCx interrupt enabled
	TIM_DIER_CC2IE_Enabled = 0x1
	// Position of CC1IE field.
	TIM_DIER_CC1IE_Pos = 0x1
	// Bit mask of CC1IE field.
	TIM_DIER_CC1IE_Msk = 0x2
	// Bit CC1IE.
	TIM_DIER_CC1IE = 0x2
	// CCx interrupt disabled
	TIM_DIER_CC1IE_Disabled = 0x0
	// CCx interrupt enabled
	TIM_DIER_CC1IE_Enabled = 0x1
	// Position of UIE field.
	TIM_DIER_UIE_Pos = 0x0
	// Bit mask of UIE field.
	TIM_DIER_UIE_Msk = 0x1
	// Bit UIE.
	TIM_DIER_UIE = 0x1
	// Update interrupt disabled
	TIM_DIER_UIE_Disabled = 0x0
	// Update interrupt enabled
	TIM_DIER_UIE_Enabled = 0x1
	// Position of BIE field.
	TIM_DIER_BIE_Pos = 0x7
	// Bit mask of BIE field.
	TIM_DIER_BIE_Msk = 0x80
	// Bit BIE.
	TIM_DIER_BIE = 0x80
	// Position of COMIE field.
	TIM_DIER_COMIE_Pos = 0x5
	// Bit mask of COMIE field.
	TIM_DIER_COMIE_Msk = 0x20
	// Bit COMIE.
	TIM_DIER_COMIE = 0x20

	// SR: status register
	// Position of CC4OF field.
	TIM_SR_CC4OF_Pos = 0xc
	// Bit mask of CC4OF field.
	TIM_SR_CC4OF_Msk = 0x1000
	// Bit CC4OF.
	TIM_SR_CC4OF = 0x1000
	// The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
	TIM_SR_CC4OF_Overcapture = 0x1
	// Clear flag
	TIM_SR_CC4OF_Clear = 0x0
	// Position of CC3OF field.
	TIM_SR_CC3OF_Pos = 0xb
	// Bit mask of CC3OF field.
	TIM_SR_CC3OF_Msk = 0x800
	// Bit CC3OF.
	TIM_SR_CC3OF = 0x800
	// The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
	TIM_SR_CC3OF_Overcapture = 0x1
	// Clear flag
	TIM_SR_CC3OF_Clear = 0x0
	// Position of CC2OF field.
	TIM_SR_CC2OF_Pos = 0xa
	// Bit mask of CC2OF field.
	TIM_SR_CC2OF_Msk = 0x400
	// Bit CC2OF.
	TIM_SR_CC2OF = 0x400
	// The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
	TIM_SR_CC2OF_Overcapture = 0x1
	// Clear flag
	TIM_SR_CC2OF_Clear = 0x0
	// Position of CC1OF field.
	TIM_SR_CC1OF_Pos = 0x9
	// Bit mask of CC1OF field.
	TIM_SR_CC1OF_Msk = 0x200
	// Bit CC1OF.
	TIM_SR_CC1OF = 0x200
	// The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
	TIM_SR_CC1OF_Overcapture = 0x1
	// Clear flag
	TIM_SR_CC1OF_Clear = 0x0
	// Position of BIF field.
	TIM_SR_BIF_Pos = 0x7
	// Bit mask of BIF field.
	TIM_SR_BIF_Msk = 0x80
	// Bit BIF.
	TIM_SR_BIF = 0x80
	// Position of TIF field.
	TIM_SR_TIF_Pos = 0x6
	// Bit mask of TIF field.
	TIM_SR_TIF_Msk = 0x40
	// Bit TIF.
	TIM_SR_TIF = 0x40
	// No trigger event occurred
	TIM_SR_TIF_NoTrigger = 0x0
	// Trigger interrupt pending
	TIM_SR_TIF_Trigger = 0x1
	// Clear flag
	TIM_SR_TIF_Clear = 0x0
	// Position of COMIF field.
	TIM_SR_COMIF_Pos = 0x5
	// Bit mask of COMIF field.
	TIM_SR_COMIF_Msk = 0x20
	// Bit COMIF.
	TIM_SR_COMIF = 0x20
	// Position of CC4IF field.
	TIM_SR_CC4IF_Pos = 0x4
	// Bit mask of CC4IF field.
	TIM_SR_CC4IF_Msk = 0x10
	// Bit CC4IF.
	TIM_SR_CC4IF = 0x10
	// If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register.
	TIM_SR_CC4IF_Match = 0x1
	// Clear flag
	TIM_SR_CC4IF_Clear = 0x0
	// Position of CC3IF field.
	TIM_SR_CC3IF_Pos = 0x3
	// Bit mask of CC3IF field.
	TIM_SR_CC3IF_Msk = 0x8
	// Bit CC3IF.
	TIM_SR_CC3IF = 0x8
	// If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register.
	TIM_SR_CC3IF_Match = 0x1
	// Clear flag
	TIM_SR_CC3IF_Clear = 0x0
	// Position of CC2IF field.
	TIM_SR_CC2IF_Pos = 0x2
	// Bit mask of CC2IF field.
	TIM_SR_CC2IF_Msk = 0x4
	// Bit CC2IF.
	TIM_SR_CC2IF = 0x4
	// If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register.
	TIM_SR_CC2IF_Match = 0x1
	// Clear flag
	TIM_SR_CC2IF_Clear = 0x0
	// Position of CC1IF field.
	TIM_SR_CC1IF_Pos = 0x1
	// Bit mask of CC1IF field.
	TIM_SR_CC1IF_Msk = 0x2
	// Bit CC1IF.
	TIM_SR_CC1IF = 0x2
	// If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register.
	TIM_SR_CC1IF_Match = 0x1
	// Clear flag
	TIM_SR_CC1IF_Clear = 0x0
	// Position of UIF field.
	TIM_SR_UIF_Pos = 0x0
	// Bit mask of UIF field.
	TIM_SR_UIF_Msk = 0x1
	// Bit UIF.
	TIM_SR_UIF = 0x1
	// No update occurred
	TIM_SR_UIF_Clear = 0x0
	// Update interrupt pending.
	TIM_SR_UIF_UpdatePending = 0x1
	// Position of B2IF field.
	TIM_SR_B2IF_Pos = 0x8
	// Bit mask of B2IF field.
	TIM_SR_B2IF_Msk = 0x100
	// Bit B2IF.
	TIM_SR_B2IF = 0x100
	// Position of CC5IF field.
	TIM_SR_CC5IF_Pos = 0x10
	// Bit mask of CC5IF field.
	TIM_SR_CC5IF_Msk = 0x10000
	// Bit CC5IF.
	TIM_SR_CC5IF = 0x10000
	// Position of CC6IF field.
	TIM_SR_CC6IF_Pos = 0x11
	// Bit mask of CC6IF field.
	TIM_SR_CC6IF_Msk = 0x20000
	// Bit CC6IF.
	TIM_SR_CC6IF = 0x20000

	// EGR: event generation register
	// Position of BG field.
	TIM_EGR_BG_Pos = 0x7
	// Bit mask of BG field.
	TIM_EGR_BG_Msk = 0x80
	// Bit BG.
	TIM_EGR_BG = 0x80
	// Position of TG field.
	TIM_EGR_TG_Pos = 0x6
	// Bit mask of TG field.
	TIM_EGR_TG_Msk = 0x40
	// Bit TG.
	TIM_EGR_TG = 0x40
	// The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.
	TIM_EGR_TG_Trigger = 0x1
	// Position of COMG field.
	TIM_EGR_COMG_Pos = 0x5
	// Bit mask of COMG field.
	TIM_EGR_COMG_Msk = 0x20
	// Bit COMG.
	TIM_EGR_COMG = 0x20
	// Position of CC4G field.
	TIM_EGR_CC4G_Pos = 0x4
	// Bit mask of CC4G field.
	TIM_EGR_CC4G_Msk = 0x10
	// Bit CC4G.
	TIM_EGR_CC4G = 0x10
	// If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
	TIM_EGR_CC4G_Trigger = 0x1
	// Position of CC3G field.
	TIM_EGR_CC3G_Pos = 0x3
	// Bit mask of CC3G field.
	TIM_EGR_CC3G_Msk = 0x8
	// Bit CC3G.
	TIM_EGR_CC3G = 0x8
	// If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
	TIM_EGR_CC3G_Trigger = 0x1
	// Position of CC2G field.
	TIM_EGR_CC2G_Pos = 0x2
	// Bit mask of CC2G field.
	TIM_EGR_CC2G_Msk = 0x4
	// Bit CC2G.
	TIM_EGR_CC2G = 0x4
	// If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
	TIM_EGR_CC2G_Trigger = 0x1
	// Position of CC1G field.
	TIM_EGR_CC1G_Pos = 0x1
	// Bit mask of CC1G field.
	TIM_EGR_CC1G_Msk = 0x2
	// Bit CC1G.
	TIM_EGR_CC1G = 0x2
	// If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
	TIM_EGR_CC1G_Trigger = 0x1
	// Position of UG field.
	TIM_EGR_UG_Pos = 0x0
	// Bit mask of UG field.
	TIM_EGR_UG_Msk = 0x1
	// Bit UG.
	TIM_EGR_UG = 0x1
	// Re-initializes the timer counter and generates an update of the registers.
	TIM_EGR_UG_Update = 0x1
	// Position of B2G field.
	TIM_EGR_B2G_Pos = 0x8
	// Bit mask of B2G field.
	TIM_EGR_B2G_Msk = 0x100
	// Bit B2G.
	TIM_EGR_B2G = 0x100

	// CCMR1_Output: capture/compare mode register 1 (output mode)
	// Position of OC2CE field.
	TIM_CCMR1_Output_OC2CE_Pos = 0xf
	// Bit mask of OC2CE field.
	TIM_CCMR1_Output_OC2CE_Msk = 0x8000
	// Bit OC2CE.
	TIM_CCMR1_Output_OC2CE = 0x8000
	// Position of OC2M field.
	TIM_CCMR1_Output_OC2M_Pos = 0xc
	// Bit mask of OC2M field.
	TIM_CCMR1_Output_OC2M_Msk = 0x7000
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIM_CCMR1_Output_OC2M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIM_CCMR1_Output_OC2M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIM_CCMR1_Output_OC2M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIM_CCMR1_Output_OC2M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIM_CCMR1_Output_OC2M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIM_CCMR1_Output_OC2M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down
	TIM_CCMR1_Output_OC2M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1
	TIM_CCMR1_Output_OC2M_PwmMode2 = 0x7
	// Position of OC2PE field.
	TIM_CCMR1_Output_OC2PE_Pos = 0xb
	// Bit mask of OC2PE field.
	TIM_CCMR1_Output_OC2PE_Msk = 0x800
	// Bit OC2PE.
	TIM_CCMR1_Output_OC2PE = 0x800
	// Preload register on CCR2 disabled. New values written to CCR2 are taken into account immediately
	TIM_CCMR1_Output_OC2PE_Disabled = 0x0
	// Preload register on CCR2 enabled. Preload value is loaded into active register on each update event
	TIM_CCMR1_Output_OC2PE_Enabled = 0x1
	// Position of OC2FE field.
	TIM_CCMR1_Output_OC2FE_Pos = 0xa
	// Bit mask of OC2FE field.
	TIM_CCMR1_Output_OC2FE_Msk = 0x400
	// Bit OC2FE.
	TIM_CCMR1_Output_OC2FE = 0x400
	// Position of CC2S field.
	TIM_CCMR1_Output_CC2S_Pos = 0x8
	// Bit mask of CC2S field.
	TIM_CCMR1_Output_CC2S_Msk = 0x300
	// CC2 channel is configured as output
	TIM_CCMR1_Output_CC2S_Output = 0x0
	// Position of OC1CE field.
	TIM_CCMR1_Output_OC1CE_Pos = 0x7
	// Bit mask of OC1CE field.
	TIM_CCMR1_Output_OC1CE_Msk = 0x80
	// Bit OC1CE.
	TIM_CCMR1_Output_OC1CE = 0x80
	// Position of OC1M field.
	TIM_CCMR1_Output_OC1M_Pos = 0x4
	// Bit mask of OC1M field.
	TIM_CCMR1_Output_OC1M_Msk = 0x70
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIM_CCMR1_Output_OC1M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIM_CCMR1_Output_OC1M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIM_CCMR1_Output_OC1M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIM_CCMR1_Output_OC1M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIM_CCMR1_Output_OC1M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIM_CCMR1_Output_OC1M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down
	TIM_CCMR1_Output_OC1M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1
	TIM_CCMR1_Output_OC1M_PwmMode2 = 0x7
	// Position of OC1PE field.
	TIM_CCMR1_Output_OC1PE_Pos = 0x3
	// Bit mask of OC1PE field.
	TIM_CCMR1_Output_OC1PE_Msk = 0x8
	// Bit OC1PE.
	TIM_CCMR1_Output_OC1PE = 0x8
	// Preload register on CCR1 disabled. New values written to CCR1 are taken into account immediately
	TIM_CCMR1_Output_OC1PE_Disabled = 0x0
	// Preload register on CCR1 enabled. Preload value is loaded into active register on each update event
	TIM_CCMR1_Output_OC1PE_Enabled = 0x1
	// Position of OC1FE field.
	TIM_CCMR1_Output_OC1FE_Pos = 0x2
	// Bit mask of OC1FE field.
	TIM_CCMR1_Output_OC1FE_Msk = 0x4
	// Bit OC1FE.
	TIM_CCMR1_Output_OC1FE = 0x4
	// Position of CC1S field.
	TIM_CCMR1_Output_CC1S_Pos = 0x0
	// Bit mask of CC1S field.
	TIM_CCMR1_Output_CC1S_Msk = 0x3
	// CC1 channel is configured as output
	TIM_CCMR1_Output_CC1S_Output = 0x0
	// Position of OC2M_3 field.
	TIM_CCMR1_Output_OC2M_3_Pos = 0x18
	// Bit mask of OC2M_3 field.
	TIM_CCMR1_Output_OC2M_3_Msk = 0x1000000
	// Bit OC2M_3.
	TIM_CCMR1_Output_OC2M_3 = 0x1000000
	// Normal output compare mode (modes 0-7)
	TIM_CCMR1_Output_OC2M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIM_CCMR1_Output_OC2M_3_Extended = 0x1
	// Position of OC1M_3 field.
	TIM_CCMR1_Output_OC1M_3_Pos = 0x10
	// Bit mask of OC1M_3 field.
	TIM_CCMR1_Output_OC1M_3_Msk = 0x10000
	// Bit OC1M_3.
	TIM_CCMR1_Output_OC1M_3 = 0x10000
	// Normal output compare mode (modes 0-7)
	TIM_CCMR1_Output_OC1M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIM_CCMR1_Output_OC1M_3_Extended = 0x1

	// CCMR1_Input: capture/compare mode register 1 (input mode)
	// Position of IC2F field.
	TIM_CCMR1_Input_IC2F_Pos = 0xc
	// Bit mask of IC2F field.
	TIM_CCMR1_Input_IC2F_Msk = 0xf000
	// Position of IC2PSC field.
	TIM_CCMR1_Input_IC2PSC_Pos = 0xa
	// Bit mask of IC2PSC field.
	TIM_CCMR1_Input_IC2PSC_Msk = 0xc00
	// Position of CC2S field.
	TIM_CCMR1_Input_CC2S_Pos = 0x8
	// Bit mask of CC2S field.
	TIM_CCMR1_Input_CC2S_Msk = 0x300
	// CC2 channel is configured as input, IC2 is mapped on TI2
	TIM_CCMR1_Input_CC2S_TI2 = 0x1
	// CC2 channel is configured as input, IC2 is mapped on TI1
	TIM_CCMR1_Input_CC2S_TI1 = 0x2
	// CC2 channel is configured as input, IC2 is mapped on TRC
	TIM_CCMR1_Input_CC2S_TRC = 0x3
	// Position of IC1F field.
	TIM_CCMR1_Input_IC1F_Pos = 0x4
	// Bit mask of IC1F field.
	TIM_CCMR1_Input_IC1F_Msk = 0xf0
	// No filter, sampling is done at fDTS
	TIM_CCMR1_Input_IC1F_NoFilter = 0x0
	// fSAMPLING=fCK_INT, N=2
	TIM_CCMR1_Input_IC1F_FCK_INT_N2 = 0x1
	// fSAMPLING=fCK_INT, N=4
	TIM_CCMR1_Input_IC1F_FCK_INT_N4 = 0x2
	// fSAMPLING=fCK_INT, N=8
	TIM_CCMR1_Input_IC1F_FCK_INT_N8 = 0x3
	// fSAMPLING=fDTS/2, N=6
	TIM_CCMR1_Input_IC1F_FDTS_Div2_N6 = 0x4
	// fSAMPLING=fDTS/2, N=8
	TIM_CCMR1_Input_IC1F_FDTS_Div2_N8 = 0x5
	// fSAMPLING=fDTS/4, N=6
	TIM_CCMR1_Input_IC1F_FDTS_Div4_N6 = 0x6
	// fSAMPLING=fDTS/4, N=8
	TIM_CCMR1_Input_IC1F_FDTS_Div4_N8 = 0x7
	// fSAMPLING=fDTS/8, N=6
	TIM_CCMR1_Input_IC1F_FDTS_Div8_N6 = 0x8
	// fSAMPLING=fDTS/8, N=8
	TIM_CCMR1_Input_IC1F_FDTS_Div8_N8 = 0x9
	// fSAMPLING=fDTS/16, N=5
	TIM_CCMR1_Input_IC1F_FDTS_Div16_N5 = 0xa
	// fSAMPLING=fDTS/16, N=6
	TIM_CCMR1_Input_IC1F_FDTS_Div16_N6 = 0xb
	// fSAMPLING=fDTS/16, N=8
	TIM_CCMR1_Input_IC1F_FDTS_Div16_N8 = 0xc
	// fSAMPLING=fDTS/32, N=5
	TIM_CCMR1_Input_IC1F_FDTS_Div32_N5 = 0xd
	// fSAMPLING=fDTS/32, N=6
	TIM_CCMR1_Input_IC1F_FDTS_Div32_N6 = 0xe
	// fSAMPLING=fDTS/32, N=8
	TIM_CCMR1_Input_IC1F_FDTS_Div32_N8 = 0xf
	// Position of IC1PSC field.
	TIM_CCMR1_Input_IC1PSC_Pos = 0x2
	// Bit mask of IC1PSC field.
	TIM_CCMR1_Input_IC1PSC_Msk = 0xc
	// Position of CC1S field.
	TIM_CCMR1_Input_CC1S_Pos = 0x0
	// Bit mask of CC1S field.
	TIM_CCMR1_Input_CC1S_Msk = 0x3
	// CC1 channel is configured as input, IC1 is mapped on TI1
	TIM_CCMR1_Input_CC1S_TI1 = 0x1
	// CC1 channel is configured as input, IC1 is mapped on TI2
	TIM_CCMR1_Input_CC1S_TI2 = 0x2
	// CC1 channel is configured as input, IC1 is mapped on TRC
	TIM_CCMR1_Input_CC1S_TRC = 0x3

	// CCMR2_Output: capture/compare mode register 2 (output mode)
	// Position of OC4CE field.
	TIM_CCMR2_Output_OC4CE_Pos = 0xf
	// Bit mask of OC4CE field.
	TIM_CCMR2_Output_OC4CE_Msk = 0x8000
	// Bit OC4CE.
	TIM_CCMR2_Output_OC4CE = 0x8000
	// Position of OC4M field.
	TIM_CCMR2_Output_OC4M_Pos = 0xc
	// Bit mask of OC4M field.
	TIM_CCMR2_Output_OC4M_Msk = 0x7000
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIM_CCMR2_Output_OC4M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIM_CCMR2_Output_OC4M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIM_CCMR2_Output_OC4M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIM_CCMR2_Output_OC4M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIM_CCMR2_Output_OC4M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIM_CCMR2_Output_OC4M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down
	TIM_CCMR2_Output_OC4M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1
	TIM_CCMR2_Output_OC4M_PwmMode2 = 0x7
	// Position of OC4PE field.
	TIM_CCMR2_Output_OC4PE_Pos = 0xb
	// Bit mask of OC4PE field.
	TIM_CCMR2_Output_OC4PE_Msk = 0x800
	// Bit OC4PE.
	TIM_CCMR2_Output_OC4PE = 0x800
	// Preload register on CCR4 disabled. New values written to CCR4 are taken into account immediately
	TIM_CCMR2_Output_OC4PE_Disabled = 0x0
	// Preload register on CCR4 enabled. Preload value is loaded into active register on each update event
	TIM_CCMR2_Output_OC4PE_Enabled = 0x1
	// Position of OC4FE field.
	TIM_CCMR2_Output_OC4FE_Pos = 0xa
	// Bit mask of OC4FE field.
	TIM_CCMR2_Output_OC4FE_Msk = 0x400
	// Bit OC4FE.
	TIM_CCMR2_Output_OC4FE = 0x400
	// Position of CC4S field.
	TIM_CCMR2_Output_CC4S_Pos = 0x8
	// Bit mask of CC4S field.
	TIM_CCMR2_Output_CC4S_Msk = 0x300
	// CC4 channel is configured as output
	TIM_CCMR2_Output_CC4S_Output = 0x0
	// Position of OC3CE field.
	TIM_CCMR2_Output_OC3CE_Pos = 0x7
	// Bit mask of OC3CE field.
	TIM_CCMR2_Output_OC3CE_Msk = 0x80
	// Bit OC3CE.
	TIM_CCMR2_Output_OC3CE = 0x80
	// Position of OC3M field.
	TIM_CCMR2_Output_OC3M_Pos = 0x4
	// Bit mask of OC3M field.
	TIM_CCMR2_Output_OC3M_Msk = 0x70
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIM_CCMR2_Output_OC3M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIM_CCMR2_Output_OC3M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIM_CCMR2_Output_OC3M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIM_CCMR2_Output_OC3M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIM_CCMR2_Output_OC3M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIM_CCMR2_Output_OC3M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down
	TIM_CCMR2_Output_OC3M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1
	TIM_CCMR2_Output_OC3M_PwmMode2 = 0x7
	// Position of OC3PE field.
	TIM_CCMR2_Output_OC3PE_Pos = 0x3
	// Bit mask of OC3PE field.
	TIM_CCMR2_Output_OC3PE_Msk = 0x8
	// Bit OC3PE.
	TIM_CCMR2_Output_OC3PE = 0x8
	// Preload register on CCR3 disabled. New values written to CCR3 are taken into account immediately
	TIM_CCMR2_Output_OC3PE_Disabled = 0x0
	// Preload register on CCR3 enabled. Preload value is loaded into active register on each update event
	TIM_CCMR2_Output_OC3PE_Enabled = 0x1
	// Position of OC3FE field.
	TIM_CCMR2_Output_OC3FE_Pos = 0x2
	// Bit mask of OC3FE field.
	TIM_CCMR2_Output_OC3FE_Msk = 0x4
	// Bit OC3FE.
	TIM_CCMR2_Output_OC3FE = 0x4
	// Position of CC3S field.
	TIM_CCMR2_Output_CC3S_Pos = 0x0
	// Bit mask of CC3S field.
	TIM_CCMR2_Output_CC3S_Msk = 0x3
	// CC3 channel is configured as output
	TIM_CCMR2_Output_CC3S_Output = 0x0
	// Position of OC3M_3 field.
	TIM_CCMR2_Output_OC3M_3_Pos = 0x10
	// Bit mask of OC3M_3 field.
	TIM_CCMR2_Output_OC3M_3_Msk = 0x10000
	// Bit OC3M_3.
	TIM_CCMR2_Output_OC3M_3 = 0x10000
	// Normal output compare mode (modes 0-7)
	TIM_CCMR2_Output_OC3M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIM_CCMR2_Output_OC3M_3_Extended = 0x1
	// Position of OC4M_3 field.
	TIM_CCMR2_Output_OC4M_3_Pos = 0x18
	// Bit mask of OC4M_3 field.
	TIM_CCMR2_Output_OC4M_3_Msk = 0x1000000
	// Bit OC4M_3.
	TIM_CCMR2_Output_OC4M_3 = 0x1000000
	// Normal output compare mode (modes 0-7)
	TIM_CCMR2_Output_OC4M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIM_CCMR2_Output_OC4M_3_Extended = 0x1

	// CCMR2_Input: capture/compare mode register 2 (input mode)
	// Position of IC4F field.
	TIM_CCMR2_Input_IC4F_Pos = 0xc
	// Bit mask of IC4F field.
	TIM_CCMR2_Input_IC4F_Msk = 0xf000
	// Position of IC4PSC field.
	TIM_CCMR2_Input_IC4PSC_Pos = 0xa
	// Bit mask of IC4PSC field.
	TIM_CCMR2_Input_IC4PSC_Msk = 0xc00
	// Position of CC4S field.
	TIM_CCMR2_Input_CC4S_Pos = 0x8
	// Bit mask of CC4S field.
	TIM_CCMR2_Input_CC4S_Msk = 0x300
	// CC4 channel is configured as input, IC4 is mapped on TI4
	TIM_CCMR2_Input_CC4S_TI4 = 0x1
	// CC4 channel is configured as input, IC4 is mapped on TI3
	TIM_CCMR2_Input_CC4S_TI3 = 0x2
	// CC4 channel is configured as input, IC4 is mapped on TRC
	TIM_CCMR2_Input_CC4S_TRC = 0x3
	// Position of IC3F field.
	TIM_CCMR2_Input_IC3F_Pos = 0x4
	// Bit mask of IC3F field.
	TIM_CCMR2_Input_IC3F_Msk = 0xf0
	// Position of IC3PSC field.
	TIM_CCMR2_Input_IC3PSC_Pos = 0x2
	// Bit mask of IC3PSC field.
	TIM_CCMR2_Input_IC3PSC_Msk = 0xc
	// Position of CC3S field.
	TIM_CCMR2_Input_CC3S_Pos = 0x0
	// Bit mask of CC3S field.
	TIM_CCMR2_Input_CC3S_Msk = 0x3
	// CC3 channel is configured as input, IC3 is mapped on TI3
	TIM_CCMR2_Input_CC3S_TI3 = 0x1
	// CC3 channel is configured as input, IC3 is mapped on TI4
	TIM_CCMR2_Input_CC3S_TI4 = 0x2
	// CC3 channel is configured as input, IC3 is mapped on TRC
	TIM_CCMR2_Input_CC3S_TRC = 0x3

	// CCER: capture/compare enable register
	// Position of CC4P field.
	TIM_CCER_CC4P_Pos = 0xd
	// Bit mask of CC4P field.
	TIM_CCER_CC4P_Msk = 0x2000
	// Bit CC4P.
	TIM_CCER_CC4P = 0x2000
	// Position of CC4E field.
	TIM_CCER_CC4E_Pos = 0xc
	// Bit mask of CC4E field.
	TIM_CCER_CC4E_Msk = 0x1000
	// Bit CC4E.
	TIM_CCER_CC4E = 0x1000
	// Position of CC3NP field.
	TIM_CCER_CC3NP_Pos = 0xb
	// Bit mask of CC3NP field.
	TIM_CCER_CC3NP_Msk = 0x800
	// Bit CC3NP.
	TIM_CCER_CC3NP = 0x800
	// Position of CC3NE field.
	TIM_CCER_CC3NE_Pos = 0xa
	// Bit mask of CC3NE field.
	TIM_CCER_CC3NE_Msk = 0x400
	// Bit CC3NE.
	TIM_CCER_CC3NE = 0x400
	// Position of CC3P field.
	TIM_CCER_CC3P_Pos = 0x9
	// Bit mask of CC3P field.
	TIM_CCER_CC3P_Msk = 0x200
	// Bit CC3P.
	TIM_CCER_CC3P = 0x200
	// Position of CC3E field.
	TIM_CCER_CC3E_Pos = 0x8
	// Bit mask of CC3E field.
	TIM_CCER_CC3E_Msk = 0x100
	// Bit CC3E.
	TIM_CCER_CC3E = 0x100
	// Position of CC2NP field.
	TIM_CCER_CC2NP_Pos = 0x7
	// Bit mask of CC2NP field.
	TIM_CCER_CC2NP_Msk = 0x80
	// Bit CC2NP.
	TIM_CCER_CC2NP = 0x80
	// Position of CC2NE field.
	TIM_CCER_CC2NE_Pos = 0x6
	// Bit mask of CC2NE field.
	TIM_CCER_CC2NE_Msk = 0x40
	// Bit CC2NE.
	TIM_CCER_CC2NE = 0x40
	// Position of CC2P field.
	TIM_CCER_CC2P_Pos = 0x5
	// Bit mask of CC2P field.
	TIM_CCER_CC2P_Msk = 0x20
	// Bit CC2P.
	TIM_CCER_CC2P = 0x20
	// Position of CC2E field.
	TIM_CCER_CC2E_Pos = 0x4
	// Bit mask of CC2E field.
	TIM_CCER_CC2E_Msk = 0x10
	// Bit CC2E.
	TIM_CCER_CC2E = 0x10
	// Position of CC1NP field.
	TIM_CCER_CC1NP_Pos = 0x3
	// Bit mask of CC1NP field.
	TIM_CCER_CC1NP_Msk = 0x8
	// Bit CC1NP.
	TIM_CCER_CC1NP = 0x8
	// Position of CC1NE field.
	TIM_CCER_CC1NE_Pos = 0x2
	// Bit mask of CC1NE field.
	TIM_CCER_CC1NE_Msk = 0x4
	// Bit CC1NE.
	TIM_CCER_CC1NE = 0x4
	// Position of CC1P field.
	TIM_CCER_CC1P_Pos = 0x1
	// Bit mask of CC1P field.
	TIM_CCER_CC1P_Msk = 0x2
	// Bit CC1P.
	TIM_CCER_CC1P = 0x2
	// Position of CC1E field.
	TIM_CCER_CC1E_Pos = 0x0
	// Bit mask of CC1E field.
	TIM_CCER_CC1E_Msk = 0x1
	// Bit CC1E.
	TIM_CCER_CC1E = 0x1
	// Position of CC5E field.
	TIM_CCER_CC5E_Pos = 0x10
	// Bit mask of CC5E field.
	TIM_CCER_CC5E_Msk = 0x10000
	// Bit CC5E.
	TIM_CCER_CC5E = 0x10000
	// Position of CC5P field.
	TIM_CCER_CC5P_Pos = 0x11
	// Bit mask of CC5P field.
	TIM_CCER_CC5P_Msk = 0x20000
	// Bit CC5P.
	TIM_CCER_CC5P = 0x20000
	// Position of CC6E field.
	TIM_CCER_CC6E_Pos = 0x14
	// Bit mask of CC6E field.
	TIM_CCER_CC6E_Msk = 0x100000
	// Bit CC6E.
	TIM_CCER_CC6E = 0x100000
	// Position of CC6P field.
	TIM_CCER_CC6P_Pos = 0x15
	// Bit mask of CC6P field.
	TIM_CCER_CC6P_Msk = 0x200000
	// Bit CC6P.
	TIM_CCER_CC6P = 0x200000
	// Position of CC4NP field.
	TIM_CCER_CC4NP_Pos = 0xf
	// Bit mask of CC4NP field.
	TIM_CCER_CC4NP_Msk = 0x8000
	// Bit CC4NP.
	TIM_CCER_CC4NP = 0x8000

	// CNT: counter
	// Position of CNT field.
	TIM_CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	TIM_CNT_CNT_Msk = 0xffff
	// Position of UIFCPY field.
	TIM_CNT_UIFCPY_Pos = 0x1f
	// Bit mask of UIFCPY field.
	TIM_CNT_UIFCPY_Msk = 0x80000000
	// Bit UIFCPY.
	TIM_CNT_UIFCPY = 0x80000000

	// PSC: prescaler
	// Position of PSC field.
	TIM_PSC_PSC_Pos = 0x0
	// Bit mask of PSC field.
	TIM_PSC_PSC_Msk = 0xffff

	// ARR: auto-reload register
	// Position of ARR field.
	TIM_ARR_ARR_Pos = 0x0
	// Bit mask of ARR field.
	TIM_ARR_ARR_Msk = 0xffff

	// RCR: repetition counter register
	// Position of REP field.
	TIM_RCR_REP_Pos = 0x0
	// Bit mask of REP field.
	TIM_RCR_REP_Msk = 0xff

	// CCR1: capture/compare register
	// Position of CCR field.
	TIM_CCR_CCR_Pos = 0x0
	// Bit mask of CCR field.
	TIM_CCR_CCR_Msk = 0xffff

	// BDTR: break and dead-time register
	// Position of MOE field.
	TIM_BDTR_MOE_Pos = 0xf
	// Bit mask of MOE field.
	TIM_BDTR_MOE_Msk = 0x8000
	// Bit MOE.
	TIM_BDTR_MOE = 0x8000
	// OC/OCN are disabled or forced idle depending on OSSI
	TIM_BDTR_MOE_DisabledIdle = 0x0
	// OC/OCN are enabled if CCxE/CCxNE are set
	TIM_BDTR_MOE_Enabled = 0x1
	// Position of AOE field.
	TIM_BDTR_AOE_Pos = 0xe
	// Bit mask of AOE field.
	TIM_BDTR_AOE_Msk = 0x4000
	// Bit AOE.
	TIM_BDTR_AOE = 0x4000
	// Position of BKP field.
	TIM_BDTR_BKP_Pos = 0xd
	// Bit mask of BKP field.
	TIM_BDTR_BKP_Msk = 0x2000
	// Bit BKP.
	TIM_BDTR_BKP = 0x2000
	// Position of BKE field.
	TIM_BDTR_BKE_Pos = 0xc
	// Bit mask of BKE field.
	TIM_BDTR_BKE_Msk = 0x1000
	// Bit BKE.
	TIM_BDTR_BKE = 0x1000
	// Position of OSSR field.
	TIM_BDTR_OSSR_Pos = 0xb
	// Bit mask of OSSR field.
	TIM_BDTR_OSSR_Msk = 0x800
	// Bit OSSR.
	TIM_BDTR_OSSR = 0x800
	// When inactive, OC/OCN outputs are disabled
	TIM_BDTR_OSSR_Disabled = 0x0
	// When inactive, OC/OCN outputs are enabled with their inactive level
	TIM_BDTR_OSSR_IdleLevel = 0x1
	// Position of OSSI field.
	TIM_BDTR_OSSI_Pos = 0xa
	// Bit mask of OSSI field.
	TIM_BDTR_OSSI_Msk = 0x400
	// Bit OSSI.
	TIM_BDTR_OSSI = 0x400
	// When inactive, OC/OCN outputs are disabled
	TIM_BDTR_OSSI_Disabled = 0x0
	// When inactive, OC/OCN outputs are forced to idle level
	TIM_BDTR_OSSI_IdleLevel = 0x1
	// Position of LOCK field.
	TIM_BDTR_LOCK_Pos = 0x8
	// Bit mask of LOCK field.
	TIM_BDTR_LOCK_Msk = 0x300
	// Position of DTG field.
	TIM_BDTR_DTG_Pos = 0x0
	// Bit mask of DTG field.
	TIM_BDTR_DTG_Msk = 0xff
	// Position of BKF field.
	TIM_BDTR_BKF_Pos = 0x10
	// Bit mask of BKF field.
	TIM_BDTR_BKF_Msk = 0xf0000
	// Position of BK2F field.
	TIM_BDTR_BK2F_Pos = 0x14
	// Bit mask of BK2F field.
	TIM_BDTR_BK2F_Msk = 0xf00000
	// Position of BK2E field.
	TIM_BDTR_BK2E_Pos = 0x18
	// Bit mask of BK2E field.
	TIM_BDTR_BK2E_Msk = 0x1000000
	// Bit BK2E.
	TIM_BDTR_BK2E = 0x1000000
	// Position of BK2P field.
	TIM_BDTR_BK2P_Pos = 0x19
	// Bit mask of BK2P field.
	TIM_BDTR_BK2P_Msk = 0x2000000
	// Bit BK2P.
	TIM_BDTR_BK2P = 0x2000000

	// DCR: DMA control register
	// Position of DBL field.
	TIM_DCR_DBL_Pos = 0x8
	// Bit mask of DBL field.
	TIM_DCR_DBL_Msk = 0x1f00
	// Position of DBA field.
	TIM_DCR_DBA_Pos = 0x0
	// Bit mask of DBA field.
	TIM_DCR_DBA_Msk = 0x1f

	// DMAR: DMA address for full transfer
	// Position of DMAB field.
	TIM_DMAR_DMAB_Pos = 0x0
	// Bit mask of DMAB field.
	TIM_DMAR_DMAB_Msk = 0xffffffff

	// CCMR3_Output: capture/compare mode register 3 (output mode)
	// Position of OC5FE field.
	TIM_CCMR3_Output_OC5FE_Pos = 0x2
	// Bit mask of OC5FE field.
	TIM_CCMR3_Output_OC5FE_Msk = 0x4
	// Bit OC5FE.
	TIM_CCMR3_Output_OC5FE = 0x4
	// Position of OC5PE field.
	TIM_CCMR3_Output_OC5PE_Pos = 0x3
	// Bit mask of OC5PE field.
	TIM_CCMR3_Output_OC5PE_Msk = 0x8
	// Bit OC5PE.
	TIM_CCMR3_Output_OC5PE = 0x8
	// Position of OC5M field.
	TIM_CCMR3_Output_OC5M_Pos = 0x4
	// Bit mask of OC5M field.
	TIM_CCMR3_Output_OC5M_Msk = 0x70
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIM_CCMR3_Output_OC5M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIM_CCMR3_Output_OC5M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIM_CCMR3_Output_OC5M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIM_CCMR3_Output_OC5M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIM_CCMR3_Output_OC5M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIM_CCMR3_Output_OC5M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down
	TIM_CCMR3_Output_OC5M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1
	TIM_CCMR3_Output_OC5M_PwmMode2 = 0x7
	// Position of OC5CE field.
	TIM_CCMR3_Output_OC5CE_Pos = 0x7
	// Bit mask of OC5CE field.
	TIM_CCMR3_Output_OC5CE_Msk = 0x80
	// Bit OC5CE.
	TIM_CCMR3_Output_OC5CE = 0x80
	// Position of OC6FE field.
	TIM_CCMR3_Output_OC6FE_Pos = 0xa
	// Bit mask of OC6FE field.
	TIM_CCMR3_Output_OC6FE_Msk = 0x400
	// Bit OC6FE.
	TIM_CCMR3_Output_OC6FE = 0x400
	// Position of OC6PE field.
	TIM_CCMR3_Output_OC6PE_Pos = 0xb
	// Bit mask of OC6PE field.
	TIM_CCMR3_Output_OC6PE_Msk = 0x800
	// Bit OC6PE.
	TIM_CCMR3_Output_OC6PE = 0x800
	// Position of OC6M field.
	TIM_CCMR3_Output_OC6M_Pos = 0xc
	// Bit mask of OC6M field.
	TIM_CCMR3_Output_OC6M_Msk = 0x7000
	// The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive
	TIM_CCMR3_Output_OC6M_Frozen = 0x0
	// Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1
	TIM_CCMR3_Output_OC6M_ActiveOnMatch = 0x1
	// Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved
	TIM_CCMR3_Output_OC6M_InactiveOnMatch = 0x2
	// OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved
	TIM_CCMR3_Output_OC6M_Toggle = 0x3
	// OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF
	TIM_CCMR3_Output_OC6M_ForceInactive = 0x4
	// OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF
	TIM_CCMR3_Output_OC6M_ForceActive = 0x5
	// In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down
	TIM_CCMR3_Output_OC6M_PwmMode1 = 0x6
	// Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1
	TIM_CCMR3_Output_OC6M_PwmMode2 = 0x7
	// Position of OC6CE field.
	TIM_CCMR3_Output_OC6CE_Pos = 0xf
	// Bit mask of OC6CE field.
	TIM_CCMR3_Output_OC6CE_Msk = 0x8000
	// Bit OC6CE.
	TIM_CCMR3_Output_OC6CE = 0x8000
	// Position of OC5M_3 field.
	TIM_CCMR3_Output_OC5M_3_Pos = 0x10
	// Bit mask of OC5M_3 field.
	TIM_CCMR3_Output_OC5M_3_Msk = 0x10000
	// Bit OC5M_3.
	TIM_CCMR3_Output_OC5M_3 = 0x10000
	// Normal output compare mode (modes 0-7)
	TIM_CCMR3_Output_OC5M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIM_CCMR3_Output_OC5M_3_Extended = 0x1
	// Position of OC6M_3 field.
	TIM_CCMR3_Output_OC6M_3_Pos = 0x18
	// Bit mask of OC6M_3 field.
	TIM_CCMR3_Output_OC6M_3_Msk = 0x1000000
	// Bit OC6M_3.
	TIM_CCMR3_Output_OC6M_3 = 0x1000000
	// Normal output compare mode (modes 0-7)
	TIM_CCMR3_Output_OC6M_3_Normal = 0x0
	// Extended output compare mode (modes 7-15)
	TIM_CCMR3_Output_OC6M_3_Extended = 0x1

	// CCR5: capture/compare register
	// Position of CCR field.
	TIM_CCR5_CCR_Pos = 0x0
	// Bit mask of CCR field.
	TIM_CCR5_CCR_Msk = 0xffff
	// Position of GC5C1 field.
	TIM_CCR5_GC5C1_Pos = 0x1d
	// Bit mask of GC5C1 field.
	TIM_CCR5_GC5C1_Msk = 0x20000000
	// Bit GC5C1.
	TIM_CCR5_GC5C1 = 0x20000000
	// Position of GC5C2 field.
	TIM_CCR5_GC5C2_Pos = 0x1e
	// Bit mask of GC5C2 field.
	TIM_CCR5_GC5C2_Msk = 0x40000000
	// Bit GC5C2.
	TIM_CCR5_GC5C2 = 0x40000000
	// Position of GC5C3 field.
	TIM_CCR5_GC5C3_Pos = 0x1f
	// Bit mask of GC5C3 field.
	TIM_CCR5_GC5C3_Msk = 0x80000000
	// Bit GC5C3.
	TIM_CCR5_GC5C3 = 0x80000000

	// CCR6: capture/compare register
	// Position of CCR field.
	TIM_CCR6_CCR_Pos = 0x0
	// Bit mask of CCR field.
	TIM_CCR6_CCR_Msk = 0xffff

	// AF1: alternate function option register 1
	// Position of BKINE field.
	TIM_AF1_BKINE_Pos = 0x0
	// Bit mask of BKINE field.
	TIM_AF1_BKINE_Msk = 0x1
	// Bit BKINE.
	TIM_AF1_BKINE = 0x1
	// Position of BKDFBKE field.
	TIM_AF1_BKDFBKE_Pos = 0x8
	// Bit mask of BKDFBKE field.
	TIM_AF1_BKDFBKE_Msk = 0x100
	// Bit BKDFBKE.
	TIM_AF1_BKDFBKE = 0x100
	// Position of BKINP field.
	TIM_AF1_BKINP_Pos = 0x9
	// Bit mask of BKINP field.
	TIM_AF1_BKINP_Msk = 0x200
	// Bit BKINP.
	TIM_AF1_BKINP = 0x200

	// AF2: alternate function option register 2
	// Position of BK2INE field.
	TIM_AF2_BK2INE_Pos = 0x0
	// Bit mask of BK2INE field.
	TIM_AF2_BK2INE_Msk = 0x1
	// Bit BK2INE.
	TIM_AF2_BK2INE = 0x1
	// Position of BK2DFBKE field.
	TIM_AF2_BK2DFBKE_Pos = 0x8
	// Bit mask of BK2DFBKE field.
	TIM_AF2_BK2DFBKE_Msk = 0x100
	// Bit BK2DFBKE.
	TIM_AF2_BK2DFBKE = 0x100
	// Position of BK2INP field.
	TIM_AF2_BK2INP_Pos = 0x9
	// Bit mask of BK2INP field.
	TIM_AF2_BK2INP_Msk = 0x200
	// Bit BK2INP.
	TIM_AF2_BK2INP = 0x200
)

// Constants for Ethernet_MAC: Ethernet: media access control (MAC)
const (
	// MACCR: Ethernet MAC configuration register
	// Position of RE field.
	Ethernet_MACCR_RE_Pos = 0x2
	// Bit mask of RE field.
	Ethernet_MACCR_RE_Msk = 0x4
	// Bit RE.
	Ethernet_MACCR_RE = 0x4
	// MAC receive state machine is disabled after the completion of the reception of the current frame
	Ethernet_MACCR_RE_Disabled = 0x0
	// MAC receive state machine is enabled
	Ethernet_MACCR_RE_Enabled = 0x1
	// Position of TE field.
	Ethernet_MACCR_TE_Pos = 0x3
	// Bit mask of TE field.
	Ethernet_MACCR_TE_Msk = 0x8
	// Bit TE.
	Ethernet_MACCR_TE = 0x8
	// MAC transmit state machine is disabled after completion of the transmission of the current frame
	Ethernet_MACCR_TE_Disabled = 0x0
	// MAC transmit state machine is enabled
	Ethernet_MACCR_TE_Enabled = 0x1
	// Position of DC field.
	Ethernet_MACCR_DC_Pos = 0x4
	// Bit mask of DC field.
	Ethernet_MACCR_DC_Msk = 0x10
	// Bit DC.
	Ethernet_MACCR_DC = 0x10
	// MAC defers until CRS signal goes inactive
	Ethernet_MACCR_DC_Disabled = 0x0
	// Deferral check function enabled
	Ethernet_MACCR_DC_Enabled = 0x1
	// Position of BL field.
	Ethernet_MACCR_BL_Pos = 0x5
	// Bit mask of BL field.
	Ethernet_MACCR_BL_Msk = 0x60
	// For retransmission n, wait up to 2^min(n, 10) time slots
	Ethernet_MACCR_BL_BL10 = 0x0
	// For retransmission n, wait up to 2^min(n, 8) time slots
	Ethernet_MACCR_BL_BL8 = 0x1
	// For retransmission n, wait up to 2^min(n, 4) time slots
	Ethernet_MACCR_BL_BL4 = 0x2
	// For retransmission n, wait up to 2^min(n, 1) time slots
	Ethernet_MACCR_BL_BL1 = 0x3
	// Position of APCS field.
	Ethernet_MACCR_APCS_Pos = 0x7
	// Bit mask of APCS field.
	Ethernet_MACCR_APCS_Msk = 0x80
	// Bit APCS.
	Ethernet_MACCR_APCS = 0x80
	// MAC passes all incoming frames unmodified
	Ethernet_MACCR_APCS_Disabled = 0x0
	// MAC strips the Pad/FCS field on incoming frames only for lengths less than or equal to 1500 bytes
	Ethernet_MACCR_APCS_Strip = 0x1
	// Position of RD field.
	Ethernet_MACCR_RD_Pos = 0x9
	// Bit mask of RD field.
	Ethernet_MACCR_RD_Msk = 0x200
	// Bit RD.
	Ethernet_MACCR_RD = 0x200
	// MAC attempts retries based on the settings of BL
	Ethernet_MACCR_RD_Enabled = 0x0
	// MAC attempts only 1 transmission
	Ethernet_MACCR_RD_Disabled = 0x1
	// Position of IPCO field.
	Ethernet_MACCR_IPCO_Pos = 0xa
	// Bit mask of IPCO field.
	Ethernet_MACCR_IPCO_Msk = 0x400
	// Bit IPCO.
	Ethernet_MACCR_IPCO = 0x400
	// IPv4 checksum offload disabled
	Ethernet_MACCR_IPCO_Disabled = 0x0
	// IPv4 checksums are checked in received frames
	Ethernet_MACCR_IPCO_Offload = 0x1
	// Position of DM field.
	Ethernet_MACCR_DM_Pos = 0xb
	// Bit mask of DM field.
	Ethernet_MACCR_DM_Msk = 0x800
	// Bit DM.
	Ethernet_MACCR_DM = 0x800
	// MAC operates in half-duplex mode
	Ethernet_MACCR_DM_HalfDuplex = 0x0
	// MAC operates in full-duplex mode
	Ethernet_MACCR_DM_FullDuplex = 0x1
	// Position of LM field.
	Ethernet_MACCR_LM_Pos = 0xc
	// Bit mask of LM field.
	Ethernet_MACCR_LM_Msk = 0x1000
	// Bit LM.
	Ethernet_MACCR_LM = 0x1000
	// Normal mode
	Ethernet_MACCR_LM_Normal = 0x0
	// MAC operates in loopback mode at the MII
	Ethernet_MACCR_LM_Loopback = 0x1
	// Position of ROD field.
	Ethernet_MACCR_ROD_Pos = 0xd
	// Bit mask of ROD field.
	Ethernet_MACCR_ROD_Msk = 0x2000
	// Bit ROD.
	Ethernet_MACCR_ROD = 0x2000
	// MAC receives all packets from PHY while transmitting
	Ethernet_MACCR_ROD_Enabled = 0x0
	// MAC disables reception of frames in half-duplex mode
	Ethernet_MACCR_ROD_Disabled = 0x1
	// Position of FES field.
	Ethernet_MACCR_FES_Pos = 0xe
	// Bit mask of FES field.
	Ethernet_MACCR_FES_Msk = 0x4000
	// Bit FES.
	Ethernet_MACCR_FES = 0x4000
	// 10 Mbit/s
	Ethernet_MACCR_FES_FES10 = 0x0
	// 100 Mbit/s
	Ethernet_MACCR_FES_FES100 = 0x1
	// Position of CSD field.
	Ethernet_MACCR_CSD_Pos = 0x10
	// Bit mask of CSD field.
	Ethernet_MACCR_CSD_Msk = 0x10000
	// Bit CSD.
	Ethernet_MACCR_CSD = 0x10000
	// Errors generated due to loss of carrier
	Ethernet_MACCR_CSD_Enabled = 0x0
	// No error generated due to loss of carrier
	Ethernet_MACCR_CSD_Disabled = 0x1
	// Position of IFG field.
	Ethernet_MACCR_IFG_Pos = 0x11
	// Bit mask of IFG field.
	Ethernet_MACCR_IFG_Msk = 0xe0000
	// 96 bit times
	Ethernet_MACCR_IFG_IFG96 = 0x0
	// 88 bit times
	Ethernet_MACCR_IFG_IFG88 = 0x1
	// 80 bit times
	Ethernet_MACCR_IFG_IFG80 = 0x2
	// 72 bit times
	Ethernet_MACCR_IFG_IFG72 = 0x3
	// 64 bit times
	Ethernet_MACCR_IFG_IFG64 = 0x4
	// 56 bit times
	Ethernet_MACCR_IFG_IFG56 = 0x5
	// 48 bit times
	Ethernet_MACCR_IFG_IFG48 = 0x6
	// 40 bit times
	Ethernet_MACCR_IFG_IFG40 = 0x7
	// Position of JD field.
	Ethernet_MACCR_JD_Pos = 0x16
	// Bit mask of JD field.
	Ethernet_MACCR_JD_Msk = 0x400000
	// Bit JD.
	Ethernet_MACCR_JD = 0x400000
	// Jabber enabled, transmit frames up to 2048 bytes
	Ethernet_MACCR_JD_Enabled = 0x0
	// Jabber disabled, transmit frames up to 16384 bytes
	Ethernet_MACCR_JD_Disabled = 0x1
	// Position of WD field.
	Ethernet_MACCR_WD_Pos = 0x17
	// Bit mask of WD field.
	Ethernet_MACCR_WD_Msk = 0x800000
	// Bit WD.
	Ethernet_MACCR_WD = 0x800000
	// Watchdog enabled, receive frames limited to 2048 bytes
	Ethernet_MACCR_WD_Enabled = 0x0
	// Watchdog disabled, receive frames may be up to to 16384 bytes
	Ethernet_MACCR_WD_Disabled = 0x1
	// Position of CSTF field.
	Ethernet_MACCR_CSTF_Pos = 0x19
	// Bit mask of CSTF field.
	Ethernet_MACCR_CSTF_Msk = 0x2000000
	// Bit CSTF.
	Ethernet_MACCR_CSTF = 0x2000000
	// CRC not stripped
	Ethernet_MACCR_CSTF_Disabled = 0x0
	// CRC stripped
	Ethernet_MACCR_CSTF_Enabled = 0x1

	// MACFFR: Ethernet MAC frame filter register
	// Position of PM field.
	Ethernet_MACFFR_PM_Pos = 0x0
	// Bit mask of PM field.
	Ethernet_MACFFR_PM_Msk = 0x1
	// Bit PM.
	Ethernet_MACFFR_PM = 0x1
	// Normal address filtering
	Ethernet_MACFFR_PM_Disabled = 0x0
	// Address filters pass all incoming frames regardless of their destination or source address
	Ethernet_MACFFR_PM_Enabled = 0x1
	// Position of HU field.
	Ethernet_MACFFR_HU_Pos = 0x1
	// Bit mask of HU field.
	Ethernet_MACFFR_HU_Msk = 0x2
	// Bit HU.
	Ethernet_MACFFR_HU = 0x2
	// MAC performs a perfect destination address filtering for unicast frames
	Ethernet_MACFFR_HU_Perfect = 0x0
	// MAC performs destination address filtering of received unicast frames according to the hash table
	Ethernet_MACFFR_HU_Hash = 0x1
	// Position of HM field.
	Ethernet_MACFFR_HM_Pos = 0x2
	// Bit mask of HM field.
	Ethernet_MACFFR_HM_Msk = 0x4
	// Bit HM.
	Ethernet_MACFFR_HM = 0x4
	// MAC performs a perfect destination address filtering for multicast frames
	Ethernet_MACFFR_HM_Perfect = 0x0
	// MAC performs destination address filtering of received multicast frames according to the hash table
	Ethernet_MACFFR_HM_Hash = 0x1
	// Position of DAIF field.
	Ethernet_MACFFR_DAIF_Pos = 0x3
	// Bit mask of DAIF field.
	Ethernet_MACFFR_DAIF_Msk = 0x8
	// Bit DAIF.
	Ethernet_MACFFR_DAIF = 0x8
	// Normal filtering of frames
	Ethernet_MACFFR_DAIF_Normal = 0x0
	// Address check block operates in inverse filtering mode for the DA address comparison
	Ethernet_MACFFR_DAIF_Invert = 0x1
	// Position of PAM field.
	Ethernet_MACFFR_PAM_Pos = 0x4
	// Bit mask of PAM field.
	Ethernet_MACFFR_PAM_Msk = 0x10
	// Bit PAM.
	Ethernet_MACFFR_PAM = 0x10
	// Filtering of multicast frames depends on HM
	Ethernet_MACFFR_PAM_Disabled = 0x0
	// All received frames with a multicast destination address are passed
	Ethernet_MACFFR_PAM_Enabled = 0x1
	// Position of BFD field.
	Ethernet_MACFFR_BFD_Pos = 0x5
	// Bit mask of BFD field.
	Ethernet_MACFFR_BFD_Msk = 0x20
	// Bit BFD.
	Ethernet_MACFFR_BFD = 0x20
	// Address filters pass all received broadcast frames
	Ethernet_MACFFR_BFD_Enabled = 0x0
	// Address filters filter all incoming broadcast frames
	Ethernet_MACFFR_BFD_Disabled = 0x1
	// Position of PCF field.
	Ethernet_MACFFR_PCF_Pos = 0x6
	// Bit mask of PCF field.
	Ethernet_MACFFR_PCF_Msk = 0xc0
	// MAC prevents all control frames from reaching the application
	Ethernet_MACFFR_PCF_PreventAll = 0x0
	// MAC forwards all control frames to application except Pause
	Ethernet_MACFFR_PCF_ForwardAllExceptPause = 0x1
	// MAC forwards all control frames to application even if they fail the address filter
	Ethernet_MACFFR_PCF_ForwardAll = 0x2
	// MAC forwards control frames that pass the address filter
	Ethernet_MACFFR_PCF_ForwardAllFiltered = 0x3
	// Position of SAIF field.
	Ethernet_MACFFR_SAIF_Pos = 0x7
	// Bit mask of SAIF field.
	Ethernet_MACFFR_SAIF_Msk = 0x80
	// Bit SAIF.
	Ethernet_MACFFR_SAIF = 0x80
	// Source address filter operates normally
	Ethernet_MACFFR_SAIF_Normal = 0x0
	// Source address filter operation inverted
	Ethernet_MACFFR_SAIF_Invert = 0x1
	// Position of SAF field.
	Ethernet_MACFFR_SAF_Pos = 0x8
	// Bit mask of SAF field.
	Ethernet_MACFFR_SAF_Msk = 0x100
	// Bit SAF.
	Ethernet_MACFFR_SAF = 0x100
	// Source address ignored
	Ethernet_MACFFR_SAF_Disabled = 0x0
	// MAC drops frames that fail the source address filter
	Ethernet_MACFFR_SAF_Enabled = 0x1
	// Position of HPF field.
	Ethernet_MACFFR_HPF_Pos = 0x9
	// Bit mask of HPF field.
	Ethernet_MACFFR_HPF_Msk = 0x200
	// Bit HPF.
	Ethernet_MACFFR_HPF = 0x200
	// If HM or HU is set, only frames that match the Hash filter are passed
	Ethernet_MACFFR_HPF_HashOnly = 0x0
	// If HM or HU is set, frames that match either the perfect filter or the hash filter are passed
	Ethernet_MACFFR_HPF_HashOrPerfect = 0x1
	// Position of RA field.
	Ethernet_MACFFR_RA_Pos = 0x1f
	// Bit mask of RA field.
	Ethernet_MACFFR_RA_Msk = 0x80000000
	// Bit RA.
	Ethernet_MACFFR_RA = 0x80000000
	// MAC receiver passes on to the application only those frames that have passed the SA/DA address file
	Ethernet_MACFFR_RA_Disabled = 0x0
	// MAC receiver passes oll received frames on to the application
	Ethernet_MACFFR_RA_Enabled = 0x1

	// MACHTHR: Ethernet MAC hash table high register
	// Position of HTH field.
	Ethernet_MACHTHR_HTH_Pos = 0x0
	// Bit mask of HTH field.
	Ethernet_MACHTHR_HTH_Msk = 0xffffffff

	// MACHTLR: Ethernet MAC hash table low register
	// Position of HTL field.
	Ethernet_MACHTLR_HTL_Pos = 0x0
	// Bit mask of HTL field.
	Ethernet_MACHTLR_HTL_Msk = 0xffffffff

	// MACMIIAR: Ethernet MAC MII address register
	// Position of MB field.
	Ethernet_MACMIIAR_MB_Pos = 0x0
	// Bit mask of MB field.
	Ethernet_MACMIIAR_MB_Msk = 0x1
	// Bit MB.
	Ethernet_MACMIIAR_MB = 0x1
	// This bit is set to 1 by the application to indicate that a read or write access is in progress
	Ethernet_MACMIIAR_MB_Busy = 0x1
	// Position of MW field.
	Ethernet_MACMIIAR_MW_Pos = 0x1
	// Bit mask of MW field.
	Ethernet_MACMIIAR_MW_Msk = 0x2
	// Bit MW.
	Ethernet_MACMIIAR_MW = 0x2
	// Read operation
	Ethernet_MACMIIAR_MW_Read = 0x0
	// Write operation
	Ethernet_MACMIIAR_MW_Write = 0x1
	// Position of CR field.
	Ethernet_MACMIIAR_CR_Pos = 0x2
	// Bit mask of CR field.
	Ethernet_MACMIIAR_CR_Msk = 0x1c
	// 60-100MHz HCLK/42
	Ethernet_MACMIIAR_CR_CR_60_100 = 0x0
	// 100-150 MHz HCLK/62
	Ethernet_MACMIIAR_CR_CR_100_150 = 0x1
	// 20-35MHz HCLK/16
	Ethernet_MACMIIAR_CR_CR_20_35 = 0x2
	// 35-60MHz HCLK/16
	Ethernet_MACMIIAR_CR_CR_35_60 = 0x3
	// 150-168MHz HCLK/102
	Ethernet_MACMIIAR_CR_CR_150_168 = 0x4
	// Position of MR field.
	Ethernet_MACMIIAR_MR_Pos = 0x6
	// Bit mask of MR field.
	Ethernet_MACMIIAR_MR_Msk = 0x7c0
	// Position of PA field.
	Ethernet_MACMIIAR_PA_Pos = 0xb
	// Bit mask of PA field.
	Ethernet_MACMIIAR_PA_Msk = 0xf800

	// MACMIIDR: Ethernet MAC MII data register
	// Position of MD field.
	Ethernet_MACMIIDR_MD_Pos = 0x0
	// Bit mask of MD field.
	Ethernet_MACMIIDR_MD_Msk = 0xffff

	// MACFCR: Ethernet MAC flow control register
	// Position of FCB field.
	Ethernet_MACFCR_FCB_Pos = 0x0
	// Bit mask of FCB field.
	Ethernet_MACFCR_FCB_Msk = 0x1
	// Bit FCB.
	Ethernet_MACFCR_FCB = 0x1
	// In full duplex, initiate a Pause control frame. In half duplex, assert back pressure
	Ethernet_MACFCR_FCB_PauseOrBackPressure = 0x1
	// In half duplex only, deasserts back pressure
	Ethernet_MACFCR_FCB_DisableBackPressure = 0x0
	// Position of TFCE field.
	Ethernet_MACFCR_TFCE_Pos = 0x1
	// Bit mask of TFCE field.
	Ethernet_MACFCR_TFCE_Msk = 0x2
	// Bit TFCE.
	Ethernet_MACFCR_TFCE = 0x2
	// In full duplex, flow control is disabled. In half duplex, back pressure is disabled
	Ethernet_MACFCR_TFCE_Disabled = 0x0
	// In full duplex, flow control is enabled. In half duplex, back pressure is enabled
	Ethernet_MACFCR_TFCE_Enabled = 0x1
	// Position of RFCE field.
	Ethernet_MACFCR_RFCE_Pos = 0x2
	// Bit mask of RFCE field.
	Ethernet_MACFCR_RFCE_Msk = 0x4
	// Bit RFCE.
	Ethernet_MACFCR_RFCE = 0x4
	// Pause frames are not decoded
	Ethernet_MACFCR_RFCE_Disabled = 0x0
	// MAC decodes received Pause frames and disables its transmitted for a specified time
	Ethernet_MACFCR_RFCE_Enabled = 0x1
	// Position of UPFD field.
	Ethernet_MACFCR_UPFD_Pos = 0x3
	// Bit mask of UPFD field.
	Ethernet_MACFCR_UPFD_Msk = 0x8
	// Bit UPFD.
	Ethernet_MACFCR_UPFD = 0x8
	// MAC detects only a Pause frame with the multicast address specified in the 802.3x standard
	Ethernet_MACFCR_UPFD_Disabled = 0x0
	// MAC additionally detects Pause frames with the station's unicast address
	Ethernet_MACFCR_UPFD_Enabled = 0x1
	// Position of PLT field.
	Ethernet_MACFCR_PLT_Pos = 0x4
	// Bit mask of PLT field.
	Ethernet_MACFCR_PLT_Msk = 0x30
	// Pause time minus 4 slot times
	Ethernet_MACFCR_PLT_PLT4 = 0x0
	// Pause time minus 28 slot times
	Ethernet_MACFCR_PLT_PLT28 = 0x1
	// Pause time minus 144 slot times
	Ethernet_MACFCR_PLT_PLT144 = 0x2
	// Pause time minus 256 slot times
	Ethernet_MACFCR_PLT_PLT256 = 0x3
	// Position of ZQPD field.
	Ethernet_MACFCR_ZQPD_Pos = 0x7
	// Bit mask of ZQPD field.
	Ethernet_MACFCR_ZQPD_Msk = 0x80
	// Bit ZQPD.
	Ethernet_MACFCR_ZQPD = 0x80
	// Normal operation with automatic zero-quanta pause control frame generation
	Ethernet_MACFCR_ZQPD_Enabled = 0x0
	// Automatic generation of zero-quanta pause control frames is disabled
	Ethernet_MACFCR_ZQPD_Disabled = 0x1
	// Position of PT field.
	Ethernet_MACFCR_PT_Pos = 0x10
	// Bit mask of PT field.
	Ethernet_MACFCR_PT_Msk = 0xffff0000

	// MACVLANTR: Ethernet MAC VLAN tag register
	// Position of VLANTI field.
	Ethernet_MACVLANTR_VLANTI_Pos = 0x0
	// Bit mask of VLANTI field.
	Ethernet_MACVLANTR_VLANTI_Msk = 0xffff
	// Position of VLANTC field.
	Ethernet_MACVLANTR_VLANTC_Pos = 0x10
	// Bit mask of VLANTC field.
	Ethernet_MACVLANTR_VLANTC_Msk = 0x10000
	// Bit VLANTC.
	Ethernet_MACVLANTR_VLANTC = 0x10000
	// Full 16 bit VLAN identifiers are used for comparison and filtering
	Ethernet_MACVLANTR_VLANTC_VLANTC16 = 0x0
	// 12 bit VLAN identifies are used for comparison and filtering
	Ethernet_MACVLANTR_VLANTC_VLANTC12 = 0x1

	// MACPMTCSR: Ethernet MAC PMT control and status register
	// Position of PD field.
	Ethernet_MACPMTCSR_PD_Pos = 0x0
	// Bit mask of PD field.
	Ethernet_MACPMTCSR_PD_Msk = 0x1
	// Bit PD.
	Ethernet_MACPMTCSR_PD = 0x1
	// All received frames will be dropped. Cleared automatically when a magic packet or wakeup frame is received
	Ethernet_MACPMTCSR_PD_Enabled = 0x1
	// Position of MPE field.
	Ethernet_MACPMTCSR_MPE_Pos = 0x1
	// Bit mask of MPE field.
	Ethernet_MACPMTCSR_MPE_Msk = 0x2
	// Bit MPE.
	Ethernet_MACPMTCSR_MPE = 0x2
	// No power management event generated due to Magic Packet reception
	Ethernet_MACPMTCSR_MPE_Disabled = 0x0
	// Enable generation of a power management event due to Magic Packet reception
	Ethernet_MACPMTCSR_MPE_Enabled = 0x1
	// Position of WFE field.
	Ethernet_MACPMTCSR_WFE_Pos = 0x2
	// Bit mask of WFE field.
	Ethernet_MACPMTCSR_WFE_Msk = 0x4
	// Bit WFE.
	Ethernet_MACPMTCSR_WFE = 0x4
	// No power management event generated due to wakeup frame reception
	Ethernet_MACPMTCSR_WFE_Disabled = 0x0
	// Enable generation of a power management event due to wakeup frame reception
	Ethernet_MACPMTCSR_WFE_Enabled = 0x1
	// Position of MPR field.
	Ethernet_MACPMTCSR_MPR_Pos = 0x5
	// Bit mask of MPR field.
	Ethernet_MACPMTCSR_MPR_Msk = 0x20
	// Bit MPR.
	Ethernet_MACPMTCSR_MPR = 0x20
	// Position of WFR field.
	Ethernet_MACPMTCSR_WFR_Pos = 0x6
	// Bit mask of WFR field.
	Ethernet_MACPMTCSR_WFR_Msk = 0x40
	// Bit WFR.
	Ethernet_MACPMTCSR_WFR = 0x40
	// Position of GU field.
	Ethernet_MACPMTCSR_GU_Pos = 0x9
	// Bit mask of GU field.
	Ethernet_MACPMTCSR_GU_Msk = 0x200
	// Bit GU.
	Ethernet_MACPMTCSR_GU = 0x200
	// Normal operation
	Ethernet_MACPMTCSR_GU_Disabled = 0x0
	// Any unicast packet filtered by the MAC address recognition may be a wakeup frame
	Ethernet_MACPMTCSR_GU_Enabled = 0x1
	// Position of WFFRPR field.
	Ethernet_MACPMTCSR_WFFRPR_Pos = 0x1f
	// Bit mask of WFFRPR field.
	Ethernet_MACPMTCSR_WFFRPR_Msk = 0x80000000
	// Bit WFFRPR.
	Ethernet_MACPMTCSR_WFFRPR = 0x80000000
	// Reset wakeup frame filter register point to 0b000. Automatically cleared
	Ethernet_MACPMTCSR_WFFRPR_Reset = 0x1

	// MACDBGR: Ethernet MAC debug register
	// Position of TFF field.
	Ethernet_MACDBGR_TFF_Pos = 0x19
	// Bit mask of TFF field.
	Ethernet_MACDBGR_TFF_Msk = 0x2000000
	// Bit TFF.
	Ethernet_MACDBGR_TFF = 0x2000000
	// Position of TFNE field.
	Ethernet_MACDBGR_TFNE_Pos = 0x18
	// Bit mask of TFNE field.
	Ethernet_MACDBGR_TFNE_Msk = 0x1000000
	// Bit TFNE.
	Ethernet_MACDBGR_TFNE = 0x1000000
	// Position of TFWA field.
	Ethernet_MACDBGR_TFWA_Pos = 0x16
	// Bit mask of TFWA field.
	Ethernet_MACDBGR_TFWA_Msk = 0x400000
	// Bit TFWA.
	Ethernet_MACDBGR_TFWA = 0x400000
	// Position of TFRS field.
	Ethernet_MACDBGR_TFRS_Pos = 0x14
	// Bit mask of TFRS field.
	Ethernet_MACDBGR_TFRS_Msk = 0x300000
	// Position of MTP field.
	Ethernet_MACDBGR_MTP_Pos = 0x13
	// Bit mask of MTP field.
	Ethernet_MACDBGR_MTP_Msk = 0x80000
	// Bit MTP.
	Ethernet_MACDBGR_MTP = 0x80000
	// Position of MTFCS field.
	Ethernet_MACDBGR_MTFCS_Pos = 0x11
	// Bit mask of MTFCS field.
	Ethernet_MACDBGR_MTFCS_Msk = 0x60000
	// Position of MMTEA field.
	Ethernet_MACDBGR_MMTEA_Pos = 0x10
	// Bit mask of MMTEA field.
	Ethernet_MACDBGR_MMTEA_Msk = 0x10000
	// Bit MMTEA.
	Ethernet_MACDBGR_MMTEA = 0x10000
	// Position of RFFL field.
	Ethernet_MACDBGR_RFFL_Pos = 0x8
	// Bit mask of RFFL field.
	Ethernet_MACDBGR_RFFL_Msk = 0x300
	// Position of RFRCS field.
	Ethernet_MACDBGR_RFRCS_Pos = 0x5
	// Bit mask of RFRCS field.
	Ethernet_MACDBGR_RFRCS_Msk = 0x60
	// Position of RFWRA field.
	Ethernet_MACDBGR_RFWRA_Pos = 0x4
	// Bit mask of RFWRA field.
	Ethernet_MACDBGR_RFWRA_Msk = 0x10
	// Bit RFWRA.
	Ethernet_MACDBGR_RFWRA = 0x10
	// Position of MSFRWCS field.
	Ethernet_MACDBGR_MSFRWCS_Pos = 0x1
	// Bit mask of MSFRWCS field.
	Ethernet_MACDBGR_MSFRWCS_Msk = 0x6
	// Position of MMRPEA field.
	Ethernet_MACDBGR_MMRPEA_Pos = 0x0
	// Bit mask of MMRPEA field.
	Ethernet_MACDBGR_MMRPEA_Msk = 0x1
	// Bit MMRPEA.
	Ethernet_MACDBGR_MMRPEA = 0x1

	// MACSR: Ethernet MAC interrupt status register
	// Position of PMTS field.
	Ethernet_MACSR_PMTS_Pos = 0x3
	// Bit mask of PMTS field.
	Ethernet_MACSR_PMTS_Msk = 0x8
	// Bit PMTS.
	Ethernet_MACSR_PMTS = 0x8
	// Position of MMCS field.
	Ethernet_MACSR_MMCS_Pos = 0x4
	// Bit mask of MMCS field.
	Ethernet_MACSR_MMCS_Msk = 0x10
	// Bit MMCS.
	Ethernet_MACSR_MMCS = 0x10
	// Position of MMCRS field.
	Ethernet_MACSR_MMCRS_Pos = 0x5
	// Bit mask of MMCRS field.
	Ethernet_MACSR_MMCRS_Msk = 0x20
	// Bit MMCRS.
	Ethernet_MACSR_MMCRS = 0x20
	// Position of MMCTS field.
	Ethernet_MACSR_MMCTS_Pos = 0x6
	// Bit mask of MMCTS field.
	Ethernet_MACSR_MMCTS_Msk = 0x40
	// Bit MMCTS.
	Ethernet_MACSR_MMCTS = 0x40
	// Position of TSTS field.
	Ethernet_MACSR_TSTS_Pos = 0x9
	// Bit mask of TSTS field.
	Ethernet_MACSR_TSTS_Msk = 0x200
	// Bit TSTS.
	Ethernet_MACSR_TSTS = 0x200

	// MACIMR: Ethernet MAC interrupt mask register
	// Position of PMTIM field.
	Ethernet_MACIMR_PMTIM_Pos = 0x3
	// Bit mask of PMTIM field.
	Ethernet_MACIMR_PMTIM_Msk = 0x8
	// Bit PMTIM.
	Ethernet_MACIMR_PMTIM = 0x8
	// PMT Status interrupt generation enabled
	Ethernet_MACIMR_PMTIM_Unmasked = 0x0
	// PMT Status interrupt generation disabled
	Ethernet_MACIMR_PMTIM_Masked = 0x1
	// Position of TSTIM field.
	Ethernet_MACIMR_TSTIM_Pos = 0x9
	// Bit mask of TSTIM field.
	Ethernet_MACIMR_TSTIM_Msk = 0x200
	// Bit TSTIM.
	Ethernet_MACIMR_TSTIM = 0x200
	// Time stamp interrupt generation enabled
	Ethernet_MACIMR_TSTIM_Unmasked = 0x0
	// Time stamp interrupt generation disabled
	Ethernet_MACIMR_TSTIM_Masked = 0x1

	// MACA0HR: Ethernet MAC address 0 high register
	// Position of MACA0H field.
	Ethernet_MACA0HR_MACA0H_Pos = 0x0
	// Bit mask of MACA0H field.
	Ethernet_MACA0HR_MACA0H_Msk = 0xffff
	// Position of MO field.
	Ethernet_MACA0HR_MO_Pos = 0x1f
	// Bit mask of MO field.
	Ethernet_MACA0HR_MO_Msk = 0x80000000
	// Bit MO.
	Ethernet_MACA0HR_MO = 0x80000000

	// MACA0LR: Ethernet MAC address 0 low register
	// Position of MACA0L field.
	Ethernet_MACA0LR_MACA0L_Pos = 0x0
	// Bit mask of MACA0L field.
	Ethernet_MACA0LR_MACA0L_Msk = 0xffffffff

	// MACA1HR: Ethernet MAC address 1 high register
	// Position of MACA1H field.
	Ethernet_MACA1HR_MACA1H_Pos = 0x0
	// Bit mask of MACA1H field.
	Ethernet_MACA1HR_MACA1H_Msk = 0xffff
	// Position of MBC field.
	Ethernet_MACA1HR_MBC_Pos = 0x18
	// Bit mask of MBC field.
	Ethernet_MACA1HR_MBC_Msk = 0x3f000000
	// Position of SA field.
	Ethernet_MACA1HR_SA_Pos = 0x1e
	// Bit mask of SA field.
	Ethernet_MACA1HR_SA_Msk = 0x40000000
	// Bit SA.
	Ethernet_MACA1HR_SA = 0x40000000
	// This address is used for comparison with DA fields of the received frame
	Ethernet_MACA1HR_SA_Destination = 0x0
	// This address is used for comparison with SA fields of received frames
	Ethernet_MACA1HR_SA_Source = 0x1
	// Position of AE field.
	Ethernet_MACA1HR_AE_Pos = 0x1f
	// Bit mask of AE field.
	Ethernet_MACA1HR_AE_Msk = 0x80000000
	// Bit AE.
	Ethernet_MACA1HR_AE = 0x80000000
	// Address filters ignore this address
	Ethernet_MACA1HR_AE_Disabled = 0x0
	// Address filters use this address
	Ethernet_MACA1HR_AE_Enabled = 0x1

	// MACA1LR: Ethernet MAC address1 low register
	// Position of MACA1L field.
	Ethernet_MACA1LR_MACA1L_Pos = 0x0
	// Bit mask of MACA1L field.
	Ethernet_MACA1LR_MACA1L_Msk = 0xffffffff

	// MACA2HR: Ethernet MAC address 2 high register
	// Position of MACA2H field.
	Ethernet_MACA2HR_MACA2H_Pos = 0x0
	// Bit mask of MACA2H field.
	Ethernet_MACA2HR_MACA2H_Msk = 0xffff
	// Position of MBC field.
	Ethernet_MACA2HR_MBC_Pos = 0x18
	// Bit mask of MBC field.
	Ethernet_MACA2HR_MBC_Msk = 0x3f000000
	// Position of SA field.
	Ethernet_MACA2HR_SA_Pos = 0x1e
	// Bit mask of SA field.
	Ethernet_MACA2HR_SA_Msk = 0x40000000
	// Bit SA.
	Ethernet_MACA2HR_SA = 0x40000000
	// This address is used for comparison with DA fields of the received frame
	Ethernet_MACA2HR_SA_Destination = 0x0
	// This address is used for comparison with SA fields of received frames
	Ethernet_MACA2HR_SA_Source = 0x1
	// Position of AE field.
	Ethernet_MACA2HR_AE_Pos = 0x1f
	// Bit mask of AE field.
	Ethernet_MACA2HR_AE_Msk = 0x80000000
	// Bit AE.
	Ethernet_MACA2HR_AE = 0x80000000
	// Address filters ignore this address
	Ethernet_MACA2HR_AE_Disabled = 0x0
	// Address filters use this address
	Ethernet_MACA2HR_AE_Enabled = 0x1

	// MACA2LR: Ethernet MAC address 2 low register
	// Position of MACA2L field.
	Ethernet_MACA2LR_MACA2L_Pos = 0x0
	// Bit mask of MACA2L field.
	Ethernet_MACA2LR_MACA2L_Msk = 0xffffffff

	// MACA3HR: Ethernet MAC address 3 high register
	// Position of MACA3H field.
	Ethernet_MACA3HR_MACA3H_Pos = 0x0
	// Bit mask of MACA3H field.
	Ethernet_MACA3HR_MACA3H_Msk = 0xffff
	// Position of MBC field.
	Ethernet_MACA3HR_MBC_Pos = 0x18
	// Bit mask of MBC field.
	Ethernet_MACA3HR_MBC_Msk = 0x3f000000
	// Position of SA field.
	Ethernet_MACA3HR_SA_Pos = 0x1e
	// Bit mask of SA field.
	Ethernet_MACA3HR_SA_Msk = 0x40000000
	// Bit SA.
	Ethernet_MACA3HR_SA = 0x40000000
	// This address is used for comparison with DA fields of the received frame
	Ethernet_MACA3HR_SA_Destination = 0x0
	// This address is used for comparison with SA fields of received frames
	Ethernet_MACA3HR_SA_Source = 0x1
	// Position of AE field.
	Ethernet_MACA3HR_AE_Pos = 0x1f
	// Bit mask of AE field.
	Ethernet_MACA3HR_AE_Msk = 0x80000000
	// Bit AE.
	Ethernet_MACA3HR_AE = 0x80000000
	// Address filters ignore this address
	Ethernet_MACA3HR_AE_Disabled = 0x0
	// Address filters use this address
	Ethernet_MACA3HR_AE_Enabled = 0x1

	// MACA3LR: Ethernet MAC address 3 low register
	// Position of MACA3L field.
	Ethernet_MACA3LR_MACA3L_Pos = 0x0
	// Bit mask of MACA3L field.
	Ethernet_MACA3LR_MACA3L_Msk = 0xffffffff
)

// Constants for CRC: Cryptographic processor
const (
	// DR: Data register
	// Position of DR field.
	CRC_DR_DR_Pos = 0x0
	// Bit mask of DR field.
	CRC_DR_DR_Msk = 0xffffffff

	// DR8: Data register - byte sized
	// Position of DR8 field.
	CRC_DR8_DR8_Pos = 0x0
	// Bit mask of DR8 field.
	CRC_DR8_DR8_Msk = 0xff

	// DR16: Data register - half-word sized
	// Position of DR16 field.
	CRC_DR16_DR16_Pos = 0x0
	// Bit mask of DR16 field.
	CRC_DR16_DR16_Msk = 0xffff

	// IDR: Independent Data register
	// Position of IDR field.
	CRC_IDR_IDR_Pos = 0x0
	// Bit mask of IDR field.
	CRC_IDR_IDR_Msk = 0xff

	// CR: Control register
	// Position of RESET field.
	CRC_CR_RESET_Pos = 0x0
	// Bit mask of RESET field.
	CRC_CR_RESET_Msk = 0x1
	// Bit RESET.
	CRC_CR_RESET = 0x1
	// Resets the CRC calculation unit and sets the data register to 0xFFFF FFFF
	CRC_CR_RESET_Reset = 0x1
	// Position of REV_OUT field.
	CRC_CR_REV_OUT_Pos = 0x7
	// Bit mask of REV_OUT field.
	CRC_CR_REV_OUT_Msk = 0x80
	// Bit REV_OUT.
	CRC_CR_REV_OUT = 0x80
	// Bit order not affected
	CRC_CR_REV_OUT_Normal = 0x0
	// Bit reversed output
	CRC_CR_REV_OUT_Reversed = 0x1
	// Position of REV_IN field.
	CRC_CR_REV_IN_Pos = 0x5
	// Bit mask of REV_IN field.
	CRC_CR_REV_IN_Msk = 0x60
	// Bit order not affected
	CRC_CR_REV_IN_Normal = 0x0
	// Bit reversal done by byte
	CRC_CR_REV_IN_Byte = 0x1
	// Bit reversal done by half-word
	CRC_CR_REV_IN_HalfWord = 0x2
	// Bit reversal done by word
	CRC_CR_REV_IN_Word = 0x3
	// Position of POLYSIZE field.
	CRC_CR_POLYSIZE_Pos = 0x3
	// Bit mask of POLYSIZE field.
	CRC_CR_POLYSIZE_Msk = 0x18
	// 32-bit polynomial
	CRC_CR_POLYSIZE_Polysize32 = 0x0
	// 16-bit polynomial
	CRC_CR_POLYSIZE_Polysize16 = 0x1
	// 8-bit polynomial
	CRC_CR_POLYSIZE_Polysize8 = 0x2
	// 7-bit polynomial
	CRC_CR_POLYSIZE_Polysize7 = 0x3

	// INIT: Initial CRC value
	// Position of INIT field.
	CRC_INIT_INIT_Pos = 0x0
	// Bit mask of INIT field.
	CRC_INIT_INIT_Msk = 0xffffffff

	// POL: CRC polynomial
	// Position of POL field.
	CRC_POL_POL_Pos = 0x0
	// Bit mask of POL field.
	CRC_POL_POL_Msk = 0xffffffff
)

// Constants for CAN1: Controller area network
const (
	// MCR: master control register
	// Position of DBF field.
	CAN_MCR_DBF_Pos = 0x10
	// Bit mask of DBF field.
	CAN_MCR_DBF_Msk = 0x10000
	// Bit DBF.
	CAN_MCR_DBF = 0x10000
	// Position of RESET field.
	CAN_MCR_RESET_Pos = 0xf
	// Bit mask of RESET field.
	CAN_MCR_RESET_Msk = 0x8000
	// Bit RESET.
	CAN_MCR_RESET = 0x8000
	// Position of TTCM field.
	CAN_MCR_TTCM_Pos = 0x7
	// Bit mask of TTCM field.
	CAN_MCR_TTCM_Msk = 0x80
	// Bit TTCM.
	CAN_MCR_TTCM = 0x80
	// Position of ABOM field.
	CAN_MCR_ABOM_Pos = 0x6
	// Bit mask of ABOM field.
	CAN_MCR_ABOM_Msk = 0x40
	// Bit ABOM.
	CAN_MCR_ABOM = 0x40
	// Position of AWUM field.
	CAN_MCR_AWUM_Pos = 0x5
	// Bit mask of AWUM field.
	CAN_MCR_AWUM_Msk = 0x20
	// Bit AWUM.
	CAN_MCR_AWUM = 0x20
	// Position of NART field.
	CAN_MCR_NART_Pos = 0x4
	// Bit mask of NART field.
	CAN_MCR_NART_Msk = 0x10
	// Bit NART.
	CAN_MCR_NART = 0x10
	// Position of RFLM field.
	CAN_MCR_RFLM_Pos = 0x3
	// Bit mask of RFLM field.
	CAN_MCR_RFLM_Msk = 0x8
	// Bit RFLM.
	CAN_MCR_RFLM = 0x8
	// Position of TXFP field.
	CAN_MCR_TXFP_Pos = 0x2
	// Bit mask of TXFP field.
	CAN_MCR_TXFP_Msk = 0x4
	// Bit TXFP.
	CAN_MCR_TXFP = 0x4
	// Position of SLEEP field.
	CAN_MCR_SLEEP_Pos = 0x1
	// Bit mask of SLEEP field.
	CAN_MCR_SLEEP_Msk = 0x2
	// Bit SLEEP.
	CAN_MCR_SLEEP = 0x2
	// Position of INRQ field.
	CAN_MCR_INRQ_Pos = 0x0
	// Bit mask of INRQ field.
	CAN_MCR_INRQ_Msk = 0x1
	// Bit INRQ.
	CAN_MCR_INRQ = 0x1

	// MSR: master status register
	// Position of RX field.
	CAN_MSR_RX_Pos = 0xb
	// Bit mask of RX field.
	CAN_MSR_RX_Msk = 0x800
	// Bit RX.
	CAN_MSR_RX = 0x800
	// Position of SAMP field.
	CAN_MSR_SAMP_Pos = 0xa
	// Bit mask of SAMP field.
	CAN_MSR_SAMP_Msk = 0x400
	// Bit SAMP.
	CAN_MSR_SAMP = 0x400
	// Position of RXM field.
	CAN_MSR_RXM_Pos = 0x9
	// Bit mask of RXM field.
	CAN_MSR_RXM_Msk = 0x200
	// Bit RXM.
	CAN_MSR_RXM = 0x200
	// Position of TXM field.
	CAN_MSR_TXM_Pos = 0x8
	// Bit mask of TXM field.
	CAN_MSR_TXM_Msk = 0x100
	// Bit TXM.
	CAN_MSR_TXM = 0x100
	// Position of SLAKI field.
	CAN_MSR_SLAKI_Pos = 0x4
	// Bit mask of SLAKI field.
	CAN_MSR_SLAKI_Msk = 0x10
	// Bit SLAKI.
	CAN_MSR_SLAKI = 0x10
	// Position of WKUI field.
	CAN_MSR_WKUI_Pos = 0x3
	// Bit mask of WKUI field.
	CAN_MSR_WKUI_Msk = 0x8
	// Bit WKUI.
	CAN_MSR_WKUI = 0x8
	// Position of ERRI field.
	CAN_MSR_ERRI_Pos = 0x2
	// Bit mask of ERRI field.
	CAN_MSR_ERRI_Msk = 0x4
	// Bit ERRI.
	CAN_MSR_ERRI = 0x4
	// Position of SLAK field.
	CAN_MSR_SLAK_Pos = 0x1
	// Bit mask of SLAK field.
	CAN_MSR_SLAK_Msk = 0x2
	// Bit SLAK.
	CAN_MSR_SLAK = 0x2
	// Position of INAK field.
	CAN_MSR_INAK_Pos = 0x0
	// Bit mask of INAK field.
	CAN_MSR_INAK_Msk = 0x1
	// Bit INAK.
	CAN_MSR_INAK = 0x1

	// TSR: transmit status register
	// Position of LOW2 field.
	CAN_TSR_LOW2_Pos = 0x1f
	// Bit mask of LOW2 field.
	CAN_TSR_LOW2_Msk = 0x80000000
	// Bit LOW2.
	CAN_TSR_LOW2 = 0x80000000
	// Position of LOW1 field.
	CAN_TSR_LOW1_Pos = 0x1e
	// Bit mask of LOW1 field.
	CAN_TSR_LOW1_Msk = 0x40000000
	// Bit LOW1.
	CAN_TSR_LOW1 = 0x40000000
	// Position of LOW0 field.
	CAN_TSR_LOW0_Pos = 0x1d
	// Bit mask of LOW0 field.
	CAN_TSR_LOW0_Msk = 0x20000000
	// Bit LOW0.
	CAN_TSR_LOW0 = 0x20000000
	// Position of TME2 field.
	CAN_TSR_TME2_Pos = 0x1c
	// Bit mask of TME2 field.
	CAN_TSR_TME2_Msk = 0x10000000
	// Bit TME2.
	CAN_TSR_TME2 = 0x10000000
	// Position of TME1 field.
	CAN_TSR_TME1_Pos = 0x1b
	// Bit mask of TME1 field.
	CAN_TSR_TME1_Msk = 0x8000000
	// Bit TME1.
	CAN_TSR_TME1 = 0x8000000
	// Position of TME0 field.
	CAN_TSR_TME0_Pos = 0x1a
	// Bit mask of TME0 field.
	CAN_TSR_TME0_Msk = 0x4000000
	// Bit TME0.
	CAN_TSR_TME0 = 0x4000000
	// Position of CODE field.
	CAN_TSR_CODE_Pos = 0x18
	// Bit mask of CODE field.
	CAN_TSR_CODE_Msk = 0x3000000
	// Position of ABRQ2 field.
	CAN_TSR_ABRQ2_Pos = 0x17
	// Bit mask of ABRQ2 field.
	CAN_TSR_ABRQ2_Msk = 0x800000
	// Bit ABRQ2.
	CAN_TSR_ABRQ2 = 0x800000
	// Position of TERR2 field.
	CAN_TSR_TERR2_Pos = 0x13
	// Bit mask of TERR2 field.
	CAN_TSR_TERR2_Msk = 0x80000
	// Bit TERR2.
	CAN_TSR_TERR2 = 0x80000
	// Position of ALST2 field.
	CAN_TSR_ALST2_Pos = 0x12
	// Bit mask of ALST2 field.
	CAN_TSR_ALST2_Msk = 0x40000
	// Bit ALST2.
	CAN_TSR_ALST2 = 0x40000
	// Position of TXOK2 field.
	CAN_TSR_TXOK2_Pos = 0x11
	// Bit mask of TXOK2 field.
	CAN_TSR_TXOK2_Msk = 0x20000
	// Bit TXOK2.
	CAN_TSR_TXOK2 = 0x20000
	// Position of RQCP2 field.
	CAN_TSR_RQCP2_Pos = 0x10
	// Bit mask of RQCP2 field.
	CAN_TSR_RQCP2_Msk = 0x10000
	// Bit RQCP2.
	CAN_TSR_RQCP2 = 0x10000
	// Position of ABRQ1 field.
	CAN_TSR_ABRQ1_Pos = 0xf
	// Bit mask of ABRQ1 field.
	CAN_TSR_ABRQ1_Msk = 0x8000
	// Bit ABRQ1.
	CAN_TSR_ABRQ1 = 0x8000
	// Position of TERR1 field.
	CAN_TSR_TERR1_Pos = 0xb
	// Bit mask of TERR1 field.
	CAN_TSR_TERR1_Msk = 0x800
	// Bit TERR1.
	CAN_TSR_TERR1 = 0x800
	// Position of ALST1 field.
	CAN_TSR_ALST1_Pos = 0xa
	// Bit mask of ALST1 field.
	CAN_TSR_ALST1_Msk = 0x400
	// Bit ALST1.
	CAN_TSR_ALST1 = 0x400
	// Position of TXOK1 field.
	CAN_TSR_TXOK1_Pos = 0x9
	// Bit mask of TXOK1 field.
	CAN_TSR_TXOK1_Msk = 0x200
	// Bit TXOK1.
	CAN_TSR_TXOK1 = 0x200
	// Position of RQCP1 field.
	CAN_TSR_RQCP1_Pos = 0x8
	// Bit mask of RQCP1 field.
	CAN_TSR_RQCP1_Msk = 0x100
	// Bit RQCP1.
	CAN_TSR_RQCP1 = 0x100
	// Position of ABRQ0 field.
	CAN_TSR_ABRQ0_Pos = 0x7
	// Bit mask of ABRQ0 field.
	CAN_TSR_ABRQ0_Msk = 0x80
	// Bit ABRQ0.
	CAN_TSR_ABRQ0 = 0x80
	// Position of TERR0 field.
	CAN_TSR_TERR0_Pos = 0x3
	// Bit mask of TERR0 field.
	CAN_TSR_TERR0_Msk = 0x8
	// Bit TERR0.
	CAN_TSR_TERR0 = 0x8
	// Position of ALST0 field.
	CAN_TSR_ALST0_Pos = 0x2
	// Bit mask of ALST0 field.
	CAN_TSR_ALST0_Msk = 0x4
	// Bit ALST0.
	CAN_TSR_ALST0 = 0x4
	// Position of TXOK0 field.
	CAN_TSR_TXOK0_Pos = 0x1
	// Bit mask of TXOK0 field.
	CAN_TSR_TXOK0_Msk = 0x2
	// Bit TXOK0.
	CAN_TSR_TXOK0 = 0x2
	// Position of RQCP0 field.
	CAN_TSR_RQCP0_Pos = 0x0
	// Bit mask of RQCP0 field.
	CAN_TSR_RQCP0_Msk = 0x1
	// Bit RQCP0.
	CAN_TSR_RQCP0 = 0x1

	// RF0R: receive FIFO %s register
	// Position of RFOM field.
	CAN_RFR_RFOM_Pos = 0x5
	// Bit mask of RFOM field.
	CAN_RFR_RFOM_Msk = 0x20
	// Bit RFOM.
	CAN_RFR_RFOM = 0x20
	// Set by software to release the output mailbox of the FIFO
	CAN_RFR_RFOM_Release = 0x1
	// Position of FOVR field.
	CAN_RFR_FOVR_Pos = 0x4
	// Bit mask of FOVR field.
	CAN_RFR_FOVR_Msk = 0x10
	// Bit FOVR.
	CAN_RFR_FOVR = 0x10
	// No FIFO x overrun
	CAN_RFR_FOVR_NoOverrun = 0x0
	// FIFO x overrun
	CAN_RFR_FOVR_Overrun = 0x1
	// Clear flag
	CAN_RFR_FOVR_Clear = 0x1
	// Position of FULL field.
	CAN_RFR_FULL_Pos = 0x3
	// Bit mask of FULL field.
	CAN_RFR_FULL_Msk = 0x8
	// Bit FULL.
	CAN_RFR_FULL = 0x8
	// FIFO x is not full
	CAN_RFR_FULL_NotFull = 0x0
	// FIFO x is full
	CAN_RFR_FULL_Full = 0x1
	// Clear flag
	CAN_RFR_FULL_Clear = 0x1
	// Position of FMP field.
	CAN_RFR_FMP_Pos = 0x0
	// Bit mask of FMP field.
	CAN_RFR_FMP_Msk = 0x3

	// IER: interrupt enable register
	// Position of SLKIE field.
	CAN_IER_SLKIE_Pos = 0x11
	// Bit mask of SLKIE field.
	CAN_IER_SLKIE_Msk = 0x20000
	// Bit SLKIE.
	CAN_IER_SLKIE = 0x20000
	// No interrupt when SLAKI bit is set
	CAN_IER_SLKIE_Disabled = 0x0
	// Interrupt generated when SLAKI bit is set
	CAN_IER_SLKIE_Enabled = 0x1
	// Position of WKUIE field.
	CAN_IER_WKUIE_Pos = 0x10
	// Bit mask of WKUIE field.
	CAN_IER_WKUIE_Msk = 0x10000
	// Bit WKUIE.
	CAN_IER_WKUIE = 0x10000
	// No interrupt when WKUI is set
	CAN_IER_WKUIE_Disabled = 0x0
	// Interrupt generated when WKUI bit is set
	CAN_IER_WKUIE_Enabled = 0x1
	// Position of ERRIE field.
	CAN_IER_ERRIE_Pos = 0xf
	// Bit mask of ERRIE field.
	CAN_IER_ERRIE_Msk = 0x8000
	// Bit ERRIE.
	CAN_IER_ERRIE = 0x8000
	// No interrupt will be generated when an error condition is pending in the CAN_ESR
	CAN_IER_ERRIE_Disabled = 0x0
	// An interrupt will be generation when an error condition is pending in the CAN_ESR
	CAN_IER_ERRIE_Enabled = 0x1
	// Position of LECIE field.
	CAN_IER_LECIE_Pos = 0xb
	// Bit mask of LECIE field.
	CAN_IER_LECIE_Msk = 0x800
	// Bit LECIE.
	CAN_IER_LECIE = 0x800
	// ERRI bit will not be set when the error code in LEC[2:0] is set by hardware on error detection
	CAN_IER_LECIE_Disabled = 0x0
	// ERRI bit will be set when the error code in LEC[2:0] is set by hardware on error detection
	CAN_IER_LECIE_Enabled = 0x1
	// Position of BOFIE field.
	CAN_IER_BOFIE_Pos = 0xa
	// Bit mask of BOFIE field.
	CAN_IER_BOFIE_Msk = 0x400
	// Bit BOFIE.
	CAN_IER_BOFIE = 0x400
	// ERRI bit will not be set when BOFF is set
	CAN_IER_BOFIE_Disabled = 0x0
	// ERRI bit will be set when BOFF is set
	CAN_IER_BOFIE_Enabled = 0x1
	// Position of EPVIE field.
	CAN_IER_EPVIE_Pos = 0x9
	// Bit mask of EPVIE field.
	CAN_IER_EPVIE_Msk = 0x200
	// Bit EPVIE.
	CAN_IER_EPVIE = 0x200
	// ERRI bit will not be set when EPVF is set
	CAN_IER_EPVIE_Disabled = 0x0
	// ERRI bit will be set when EPVF is set
	CAN_IER_EPVIE_Enabled = 0x1
	// Position of EWGIE field.
	CAN_IER_EWGIE_Pos = 0x8
	// Bit mask of EWGIE field.
	CAN_IER_EWGIE_Msk = 0x100
	// Bit EWGIE.
	CAN_IER_EWGIE = 0x100
	// ERRI bit will not be set when EWGF is set
	CAN_IER_EWGIE_Disabled = 0x0
	// ERRI bit will be set when EWGF is set
	CAN_IER_EWGIE_Enabled = 0x1
	// Position of FOVIE1 field.
	CAN_IER_FOVIE1_Pos = 0x6
	// Bit mask of FOVIE1 field.
	CAN_IER_FOVIE1_Msk = 0x40
	// Bit FOVIE1.
	CAN_IER_FOVIE1 = 0x40
	// No interrupt when FOVR is set
	CAN_IER_FOVIE1_Disabled = 0x0
	// Interrupt generation when FOVR is set
	CAN_IER_FOVIE1_Enabled = 0x1
	// Position of FFIE1 field.
	CAN_IER_FFIE1_Pos = 0x5
	// Bit mask of FFIE1 field.
	CAN_IER_FFIE1_Msk = 0x20
	// Bit FFIE1.
	CAN_IER_FFIE1 = 0x20
	// No interrupt when FULL bit is set
	CAN_IER_FFIE1_Disabled = 0x0
	// Interrupt generated when FULL bit is set
	CAN_IER_FFIE1_Enabled = 0x1
	// Position of FMPIE1 field.
	CAN_IER_FMPIE1_Pos = 0x4
	// Bit mask of FMPIE1 field.
	CAN_IER_FMPIE1_Msk = 0x10
	// Bit FMPIE1.
	CAN_IER_FMPIE1 = 0x10
	// No interrupt generated when state of FMP[1:0] bits are not 00b
	CAN_IER_FMPIE1_Disabled = 0x0
	// Interrupt generated when state of FMP[1:0] bits are not 00b
	CAN_IER_FMPIE1_Enabled = 0x1
	// Position of FOVIE0 field.
	CAN_IER_FOVIE0_Pos = 0x3
	// Bit mask of FOVIE0 field.
	CAN_IER_FOVIE0_Msk = 0x8
	// Bit FOVIE0.
	CAN_IER_FOVIE0 = 0x8
	// No interrupt when FOVR bit is set
	CAN_IER_FOVIE0_Disabled = 0x0
	// Interrupt generated when FOVR bit is set
	CAN_IER_FOVIE0_Enabled = 0x1
	// Position of FFIE0 field.
	CAN_IER_FFIE0_Pos = 0x2
	// Bit mask of FFIE0 field.
	CAN_IER_FFIE0_Msk = 0x4
	// Bit FFIE0.
	CAN_IER_FFIE0 = 0x4
	// No interrupt when FULL bit is set
	CAN_IER_FFIE0_Disabled = 0x0
	// Interrupt generated when FULL bit is set
	CAN_IER_FFIE0_Enabled = 0x1
	// Position of FMPIE0 field.
	CAN_IER_FMPIE0_Pos = 0x1
	// Bit mask of FMPIE0 field.
	CAN_IER_FMPIE0_Msk = 0x2
	// Bit FMPIE0.
	CAN_IER_FMPIE0 = 0x2
	// No interrupt generated when state of FMP[1:0] bits are not 00
	CAN_IER_FMPIE0_Disabled = 0x0
	// Interrupt generated when state of FMP[1:0] bits are not 00b
	CAN_IER_FMPIE0_Enabled = 0x1
	// Position of TMEIE field.
	CAN_IER_TMEIE_Pos = 0x0
	// Bit mask of TMEIE field.
	CAN_IER_TMEIE_Msk = 0x1
	// Bit TMEIE.
	CAN_IER_TMEIE = 0x1
	// No interrupt when RQCPx bit is set
	CAN_IER_TMEIE_Disabled = 0x0
	// Interrupt generated when RQCPx bit is set
	CAN_IER_TMEIE_Enabled = 0x1

	// ESR: interrupt enable register
	// Position of REC field.
	CAN_ESR_REC_Pos = 0x18
	// Bit mask of REC field.
	CAN_ESR_REC_Msk = 0xff000000
	// Position of TEC field.
	CAN_ESR_TEC_Pos = 0x10
	// Bit mask of TEC field.
	CAN_ESR_TEC_Msk = 0xff0000
	// Position of LEC field.
	CAN_ESR_LEC_Pos = 0x4
	// Bit mask of LEC field.
	CAN_ESR_LEC_Msk = 0x70
	// No Error
	CAN_ESR_LEC_NoError = 0x0
	// Stuff Error
	CAN_ESR_LEC_Stuff = 0x1
	// Form Error
	CAN_ESR_LEC_Form = 0x2
	// Acknowledgment Error
	CAN_ESR_LEC_Ack = 0x3
	// Bit recessive Error
	CAN_ESR_LEC_BitRecessive = 0x4
	// Bit dominant Error
	CAN_ESR_LEC_BitDominant = 0x5
	// CRC Error
	CAN_ESR_LEC_Crc = 0x6
	// Set by software
	CAN_ESR_LEC_Custom = 0x7
	// Position of BOFF field.
	CAN_ESR_BOFF_Pos = 0x2
	// Bit mask of BOFF field.
	CAN_ESR_BOFF_Msk = 0x4
	// Bit BOFF.
	CAN_ESR_BOFF = 0x4
	// Position of EPVF field.
	CAN_ESR_EPVF_Pos = 0x1
	// Bit mask of EPVF field.
	CAN_ESR_EPVF_Msk = 0x2
	// Bit EPVF.
	CAN_ESR_EPVF = 0x2
	// Position of EWGF field.
	CAN_ESR_EWGF_Pos = 0x0
	// Bit mask of EWGF field.
	CAN_ESR_EWGF_Msk = 0x1
	// Bit EWGF.
	CAN_ESR_EWGF = 0x1

	// BTR: bit timing register
	// Position of SILM field.
	CAN_BTR_SILM_Pos = 0x1f
	// Bit mask of SILM field.
	CAN_BTR_SILM_Msk = 0x80000000
	// Bit SILM.
	CAN_BTR_SILM = 0x80000000
	// Normal operation
	CAN_BTR_SILM_Normal = 0x0
	// Silent Mode
	CAN_BTR_SILM_Silent = 0x1
	// Position of LBKM field.
	CAN_BTR_LBKM_Pos = 0x1e
	// Bit mask of LBKM field.
	CAN_BTR_LBKM_Msk = 0x40000000
	// Bit LBKM.
	CAN_BTR_LBKM = 0x40000000
	// Loop Back Mode disabled
	CAN_BTR_LBKM_Disabled = 0x0
	// Loop Back Mode enabled
	CAN_BTR_LBKM_Enabled = 0x1
	// Position of SJW field.
	CAN_BTR_SJW_Pos = 0x18
	// Bit mask of SJW field.
	CAN_BTR_SJW_Msk = 0x3000000
	// Position of TS2 field.
	CAN_BTR_TS2_Pos = 0x14
	// Bit mask of TS2 field.
	CAN_BTR_TS2_Msk = 0x700000
	// Position of TS1 field.
	CAN_BTR_TS1_Pos = 0x10
	// Bit mask of TS1 field.
	CAN_BTR_TS1_Msk = 0xf0000
	// Position of BRP field.
	CAN_BTR_BRP_Pos = 0x0
	// Bit mask of BRP field.
	CAN_BTR_BRP_Msk = 0x3ff

	// TX.TIR: TX mailbox identifier register
	// Position of STID field.
	CAN_TX_TIR_STID_Pos = 0x15
	// Bit mask of STID field.
	CAN_TX_TIR_STID_Msk = 0xffe00000
	// Position of EXID field.
	CAN_TX_TIR_EXID_Pos = 0x3
	// Bit mask of EXID field.
	CAN_TX_TIR_EXID_Msk = 0x1ffff8
	// Position of IDE field.
	CAN_TX_TIR_IDE_Pos = 0x2
	// Bit mask of IDE field.
	CAN_TX_TIR_IDE_Msk = 0x4
	// Bit IDE.
	CAN_TX_TIR_IDE = 0x4
	// Standard identifier
	CAN_TX_TIR_IDE_Standard = 0x0
	// Extended identifier
	CAN_TX_TIR_IDE_Extended = 0x1
	// Position of RTR field.
	CAN_TX_TIR_RTR_Pos = 0x1
	// Bit mask of RTR field.
	CAN_TX_TIR_RTR_Msk = 0x2
	// Bit RTR.
	CAN_TX_TIR_RTR = 0x2
	// Data frame
	CAN_TX_TIR_RTR_Data = 0x0
	// Remote frame
	CAN_TX_TIR_RTR_Remote = 0x1
	// Position of TXRQ field.
	CAN_TX_TIR_TXRQ_Pos = 0x0
	// Bit mask of TXRQ field.
	CAN_TX_TIR_TXRQ_Msk = 0x1
	// Bit TXRQ.
	CAN_TX_TIR_TXRQ = 0x1

	// TX.TDTR: mailbox data length control and time stamp register
	// Position of TIME field.
	CAN_TX_TDTR_TIME_Pos = 0x10
	// Bit mask of TIME field.
	CAN_TX_TDTR_TIME_Msk = 0xffff0000
	// Position of TGT field.
	CAN_TX_TDTR_TGT_Pos = 0x8
	// Bit mask of TGT field.
	CAN_TX_TDTR_TGT_Msk = 0x100
	// Bit TGT.
	CAN_TX_TDTR_TGT = 0x100
	// Position of DLC field.
	CAN_TX_TDTR_DLC_Pos = 0x0
	// Bit mask of DLC field.
	CAN_TX_TDTR_DLC_Msk = 0xf

	// TX.TDLR: mailbox data low register
	// Position of DATA3 field.
	CAN_TX_TDLR_DATA3_Pos = 0x18
	// Bit mask of DATA3 field.
	CAN_TX_TDLR_DATA3_Msk = 0xff000000
	// Position of DATA2 field.
	CAN_TX_TDLR_DATA2_Pos = 0x10
	// Bit mask of DATA2 field.
	CAN_TX_TDLR_DATA2_Msk = 0xff0000
	// Position of DATA1 field.
	CAN_TX_TDLR_DATA1_Pos = 0x8
	// Bit mask of DATA1 field.
	CAN_TX_TDLR_DATA1_Msk = 0xff00
	// Position of DATA0 field.
	CAN_TX_TDLR_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	CAN_TX_TDLR_DATA0_Msk = 0xff

	// TX.TDHR: mailbox data high register
	// Position of DATA7 field.
	CAN_TX_TDHR_DATA7_Pos = 0x18
	// Bit mask of DATA7 field.
	CAN_TX_TDHR_DATA7_Msk = 0xff000000
	// Position of DATA6 field.
	CAN_TX_TDHR_DATA6_Pos = 0x10
	// Bit mask of DATA6 field.
	CAN_TX_TDHR_DATA6_Msk = 0xff0000
	// Position of DATA5 field.
	CAN_TX_TDHR_DATA5_Pos = 0x8
	// Bit mask of DATA5 field.
	CAN_TX_TDHR_DATA5_Msk = 0xff00
	// Position of DATA4 field.
	CAN_TX_TDHR_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	CAN_TX_TDHR_DATA4_Msk = 0xff

	// RX.RIR: receive FIFO mailbox identifier register
	// Position of STID field.
	CAN_RX_RIR_STID_Pos = 0x15
	// Bit mask of STID field.
	CAN_RX_RIR_STID_Msk = 0xffe00000
	// Position of EXID field.
	CAN_RX_RIR_EXID_Pos = 0x3
	// Bit mask of EXID field.
	CAN_RX_RIR_EXID_Msk = 0x1ffff8
	// Position of IDE field.
	CAN_RX_RIR_IDE_Pos = 0x2
	// Bit mask of IDE field.
	CAN_RX_RIR_IDE_Msk = 0x4
	// Bit IDE.
	CAN_RX_RIR_IDE = 0x4
	// Standard identifier
	CAN_RX_RIR_IDE_Standard = 0x0
	// Extended identifier
	CAN_RX_RIR_IDE_Extended = 0x1
	// Position of RTR field.
	CAN_RX_RIR_RTR_Pos = 0x1
	// Bit mask of RTR field.
	CAN_RX_RIR_RTR_Msk = 0x2
	// Bit RTR.
	CAN_RX_RIR_RTR = 0x2
	// Data frame
	CAN_RX_RIR_RTR_Data = 0x0
	// Remote frame
	CAN_RX_RIR_RTR_Remote = 0x1

	// RX.RDTR: mailbox data high register
	// Position of TIME field.
	CAN_RX_RDTR_TIME_Pos = 0x10
	// Bit mask of TIME field.
	CAN_RX_RDTR_TIME_Msk = 0xffff0000
	// Position of FMI field.
	CAN_RX_RDTR_FMI_Pos = 0x8
	// Bit mask of FMI field.
	CAN_RX_RDTR_FMI_Msk = 0xff00
	// Position of DLC field.
	CAN_RX_RDTR_DLC_Pos = 0x0
	// Bit mask of DLC field.
	CAN_RX_RDTR_DLC_Msk = 0xf

	// RX.RDLR: mailbox data high register
	// Position of DATA3 field.
	CAN_RX_RDLR_DATA3_Pos = 0x18
	// Bit mask of DATA3 field.
	CAN_RX_RDLR_DATA3_Msk = 0xff000000
	// Position of DATA2 field.
	CAN_RX_RDLR_DATA2_Pos = 0x10
	// Bit mask of DATA2 field.
	CAN_RX_RDLR_DATA2_Msk = 0xff0000
	// Position of DATA1 field.
	CAN_RX_RDLR_DATA1_Pos = 0x8
	// Bit mask of DATA1 field.
	CAN_RX_RDLR_DATA1_Msk = 0xff00
	// Position of DATA0 field.
	CAN_RX_RDLR_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	CAN_RX_RDLR_DATA0_Msk = 0xff

	// RX.RDHR: receive FIFO mailbox data high register
	// Position of DATA7 field.
	CAN_RX_RDHR_DATA7_Pos = 0x18
	// Bit mask of DATA7 field.
	CAN_RX_RDHR_DATA7_Msk = 0xff000000
	// Position of DATA6 field.
	CAN_RX_RDHR_DATA6_Pos = 0x10
	// Bit mask of DATA6 field.
	CAN_RX_RDHR_DATA6_Msk = 0xff0000
	// Position of DATA5 field.
	CAN_RX_RDHR_DATA5_Pos = 0x8
	// Bit mask of DATA5 field.
	CAN_RX_RDHR_DATA5_Msk = 0xff00
	// Position of DATA4 field.
	CAN_RX_RDHR_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	CAN_RX_RDHR_DATA4_Msk = 0xff

	// FMR: filter master register
	// Position of CAN2SB field.
	CAN_FMR_CAN2SB_Pos = 0x8
	// Bit mask of CAN2SB field.
	CAN_FMR_CAN2SB_Msk = 0x3f00
	// Position of FINIT field.
	CAN_FMR_FINIT_Pos = 0x0
	// Bit mask of FINIT field.
	CAN_FMR_FINIT_Msk = 0x1
	// Bit FINIT.
	CAN_FMR_FINIT = 0x1

	// FM1R: filter mode register
	// Position of FBM0 field.
	CAN_FM1R_FBM0_Pos = 0x0
	// Bit mask of FBM0 field.
	CAN_FM1R_FBM0_Msk = 0x1
	// Bit FBM0.
	CAN_FM1R_FBM0 = 0x1
	// Position of FBM1 field.
	CAN_FM1R_FBM1_Pos = 0x1
	// Bit mask of FBM1 field.
	CAN_FM1R_FBM1_Msk = 0x2
	// Bit FBM1.
	CAN_FM1R_FBM1 = 0x2
	// Position of FBM2 field.
	CAN_FM1R_FBM2_Pos = 0x2
	// Bit mask of FBM2 field.
	CAN_FM1R_FBM2_Msk = 0x4
	// Bit FBM2.
	CAN_FM1R_FBM2 = 0x4
	// Position of FBM3 field.
	CAN_FM1R_FBM3_Pos = 0x3
	// Bit mask of FBM3 field.
	CAN_FM1R_FBM3_Msk = 0x8
	// Bit FBM3.
	CAN_FM1R_FBM3 = 0x8
	// Position of FBM4 field.
	CAN_FM1R_FBM4_Pos = 0x4
	// Bit mask of FBM4 field.
	CAN_FM1R_FBM4_Msk = 0x10
	// Bit FBM4.
	CAN_FM1R_FBM4 = 0x10
	// Position of FBM5 field.
	CAN_FM1R_FBM5_Pos = 0x5
	// Bit mask of FBM5 field.
	CAN_FM1R_FBM5_Msk = 0x20
	// Bit FBM5.
	CAN_FM1R_FBM5 = 0x20
	// Position of FBM6 field.
	CAN_FM1R_FBM6_Pos = 0x6
	// Bit mask of FBM6 field.
	CAN_FM1R_FBM6_Msk = 0x40
	// Bit FBM6.
	CAN_FM1R_FBM6 = 0x40
	// Position of FBM7 field.
	CAN_FM1R_FBM7_Pos = 0x7
	// Bit mask of FBM7 field.
	CAN_FM1R_FBM7_Msk = 0x80
	// Bit FBM7.
	CAN_FM1R_FBM7 = 0x80
	// Position of FBM8 field.
	CAN_FM1R_FBM8_Pos = 0x8
	// Bit mask of FBM8 field.
	CAN_FM1R_FBM8_Msk = 0x100
	// Bit FBM8.
	CAN_FM1R_FBM8 = 0x100
	// Position of FBM9 field.
	CAN_FM1R_FBM9_Pos = 0x9
	// Bit mask of FBM9 field.
	CAN_FM1R_FBM9_Msk = 0x200
	// Bit FBM9.
	CAN_FM1R_FBM9 = 0x200
	// Position of FBM10 field.
	CAN_FM1R_FBM10_Pos = 0xa
	// Bit mask of FBM10 field.
	CAN_FM1R_FBM10_Msk = 0x400
	// Bit FBM10.
	CAN_FM1R_FBM10 = 0x400
	// Position of FBM11 field.
	CAN_FM1R_FBM11_Pos = 0xb
	// Bit mask of FBM11 field.
	CAN_FM1R_FBM11_Msk = 0x800
	// Bit FBM11.
	CAN_FM1R_FBM11 = 0x800
	// Position of FBM12 field.
	CAN_FM1R_FBM12_Pos = 0xc
	// Bit mask of FBM12 field.
	CAN_FM1R_FBM12_Msk = 0x1000
	// Bit FBM12.
	CAN_FM1R_FBM12 = 0x1000
	// Position of FBM13 field.
	CAN_FM1R_FBM13_Pos = 0xd
	// Bit mask of FBM13 field.
	CAN_FM1R_FBM13_Msk = 0x2000
	// Bit FBM13.
	CAN_FM1R_FBM13 = 0x2000
	// Position of FBM14 field.
	CAN_FM1R_FBM14_Pos = 0xe
	// Bit mask of FBM14 field.
	CAN_FM1R_FBM14_Msk = 0x4000
	// Bit FBM14.
	CAN_FM1R_FBM14 = 0x4000
	// Position of FBM15 field.
	CAN_FM1R_FBM15_Pos = 0xf
	// Bit mask of FBM15 field.
	CAN_FM1R_FBM15_Msk = 0x8000
	// Bit FBM15.
	CAN_FM1R_FBM15 = 0x8000
	// Position of FBM16 field.
	CAN_FM1R_FBM16_Pos = 0x10
	// Bit mask of FBM16 field.
	CAN_FM1R_FBM16_Msk = 0x10000
	// Bit FBM16.
	CAN_FM1R_FBM16 = 0x10000
	// Position of FBM17 field.
	CAN_FM1R_FBM17_Pos = 0x11
	// Bit mask of FBM17 field.
	CAN_FM1R_FBM17_Msk = 0x20000
	// Bit FBM17.
	CAN_FM1R_FBM17 = 0x20000
	// Position of FBM18 field.
	CAN_FM1R_FBM18_Pos = 0x12
	// Bit mask of FBM18 field.
	CAN_FM1R_FBM18_Msk = 0x40000
	// Bit FBM18.
	CAN_FM1R_FBM18 = 0x40000
	// Position of FBM19 field.
	CAN_FM1R_FBM19_Pos = 0x13
	// Bit mask of FBM19 field.
	CAN_FM1R_FBM19_Msk = 0x80000
	// Bit FBM19.
	CAN_FM1R_FBM19 = 0x80000
	// Position of FBM20 field.
	CAN_FM1R_FBM20_Pos = 0x14
	// Bit mask of FBM20 field.
	CAN_FM1R_FBM20_Msk = 0x100000
	// Bit FBM20.
	CAN_FM1R_FBM20 = 0x100000
	// Position of FBM21 field.
	CAN_FM1R_FBM21_Pos = 0x15
	// Bit mask of FBM21 field.
	CAN_FM1R_FBM21_Msk = 0x200000
	// Bit FBM21.
	CAN_FM1R_FBM21 = 0x200000
	// Position of FBM22 field.
	CAN_FM1R_FBM22_Pos = 0x16
	// Bit mask of FBM22 field.
	CAN_FM1R_FBM22_Msk = 0x400000
	// Bit FBM22.
	CAN_FM1R_FBM22 = 0x400000
	// Position of FBM23 field.
	CAN_FM1R_FBM23_Pos = 0x17
	// Bit mask of FBM23 field.
	CAN_FM1R_FBM23_Msk = 0x800000
	// Bit FBM23.
	CAN_FM1R_FBM23 = 0x800000
	// Position of FBM24 field.
	CAN_FM1R_FBM24_Pos = 0x18
	// Bit mask of FBM24 field.
	CAN_FM1R_FBM24_Msk = 0x1000000
	// Bit FBM24.
	CAN_FM1R_FBM24 = 0x1000000
	// Position of FBM25 field.
	CAN_FM1R_FBM25_Pos = 0x19
	// Bit mask of FBM25 field.
	CAN_FM1R_FBM25_Msk = 0x2000000
	// Bit FBM25.
	CAN_FM1R_FBM25 = 0x2000000
	// Position of FBM26 field.
	CAN_FM1R_FBM26_Pos = 0x1a
	// Bit mask of FBM26 field.
	CAN_FM1R_FBM26_Msk = 0x4000000
	// Bit FBM26.
	CAN_FM1R_FBM26 = 0x4000000
	// Position of FBM27 field.
	CAN_FM1R_FBM27_Pos = 0x1b
	// Bit mask of FBM27 field.
	CAN_FM1R_FBM27_Msk = 0x8000000
	// Bit FBM27.
	CAN_FM1R_FBM27 = 0x8000000

	// FS1R: filter scale register
	// Position of FSC0 field.
	CAN_FS1R_FSC0_Pos = 0x0
	// Bit mask of FSC0 field.
	CAN_FS1R_FSC0_Msk = 0x1
	// Bit FSC0.
	CAN_FS1R_FSC0 = 0x1
	// Position of FSC1 field.
	CAN_FS1R_FSC1_Pos = 0x1
	// Bit mask of FSC1 field.
	CAN_FS1R_FSC1_Msk = 0x2
	// Bit FSC1.
	CAN_FS1R_FSC1 = 0x2
	// Position of FSC2 field.
	CAN_FS1R_FSC2_Pos = 0x2
	// Bit mask of FSC2 field.
	CAN_FS1R_FSC2_Msk = 0x4
	// Bit FSC2.
	CAN_FS1R_FSC2 = 0x4
	// Position of FSC3 field.
	CAN_FS1R_FSC3_Pos = 0x3
	// Bit mask of FSC3 field.
	CAN_FS1R_FSC3_Msk = 0x8
	// Bit FSC3.
	CAN_FS1R_FSC3 = 0x8
	// Position of FSC4 field.
	CAN_FS1R_FSC4_Pos = 0x4
	// Bit mask of FSC4 field.
	CAN_FS1R_FSC4_Msk = 0x10
	// Bit FSC4.
	CAN_FS1R_FSC4 = 0x10
	// Position of FSC5 field.
	CAN_FS1R_FSC5_Pos = 0x5
	// Bit mask of FSC5 field.
	CAN_FS1R_FSC5_Msk = 0x20
	// Bit FSC5.
	CAN_FS1R_FSC5 = 0x20
	// Position of FSC6 field.
	CAN_FS1R_FSC6_Pos = 0x6
	// Bit mask of FSC6 field.
	CAN_FS1R_FSC6_Msk = 0x40
	// Bit FSC6.
	CAN_FS1R_FSC6 = 0x40
	// Position of FSC7 field.
	CAN_FS1R_FSC7_Pos = 0x7
	// Bit mask of FSC7 field.
	CAN_FS1R_FSC7_Msk = 0x80
	// Bit FSC7.
	CAN_FS1R_FSC7 = 0x80
	// Position of FSC8 field.
	CAN_FS1R_FSC8_Pos = 0x8
	// Bit mask of FSC8 field.
	CAN_FS1R_FSC8_Msk = 0x100
	// Bit FSC8.
	CAN_FS1R_FSC8 = 0x100
	// Position of FSC9 field.
	CAN_FS1R_FSC9_Pos = 0x9
	// Bit mask of FSC9 field.
	CAN_FS1R_FSC9_Msk = 0x200
	// Bit FSC9.
	CAN_FS1R_FSC9 = 0x200
	// Position of FSC10 field.
	CAN_FS1R_FSC10_Pos = 0xa
	// Bit mask of FSC10 field.
	CAN_FS1R_FSC10_Msk = 0x400
	// Bit FSC10.
	CAN_FS1R_FSC10 = 0x400
	// Position of FSC11 field.
	CAN_FS1R_FSC11_Pos = 0xb
	// Bit mask of FSC11 field.
	CAN_FS1R_FSC11_Msk = 0x800
	// Bit FSC11.
	CAN_FS1R_FSC11 = 0x800
	// Position of FSC12 field.
	CAN_FS1R_FSC12_Pos = 0xc
	// Bit mask of FSC12 field.
	CAN_FS1R_FSC12_Msk = 0x1000
	// Bit FSC12.
	CAN_FS1R_FSC12 = 0x1000
	// Position of FSC13 field.
	CAN_FS1R_FSC13_Pos = 0xd
	// Bit mask of FSC13 field.
	CAN_FS1R_FSC13_Msk = 0x2000
	// Bit FSC13.
	CAN_FS1R_FSC13 = 0x2000
	// Position of FSC14 field.
	CAN_FS1R_FSC14_Pos = 0xe
	// Bit mask of FSC14 field.
	CAN_FS1R_FSC14_Msk = 0x4000
	// Bit FSC14.
	CAN_FS1R_FSC14 = 0x4000
	// Position of FSC15 field.
	CAN_FS1R_FSC15_Pos = 0xf
	// Bit mask of FSC15 field.
	CAN_FS1R_FSC15_Msk = 0x8000
	// Bit FSC15.
	CAN_FS1R_FSC15 = 0x8000
	// Position of FSC16 field.
	CAN_FS1R_FSC16_Pos = 0x10
	// Bit mask of FSC16 field.
	CAN_FS1R_FSC16_Msk = 0x10000
	// Bit FSC16.
	CAN_FS1R_FSC16 = 0x10000
	// Position of FSC17 field.
	CAN_FS1R_FSC17_Pos = 0x11
	// Bit mask of FSC17 field.
	CAN_FS1R_FSC17_Msk = 0x20000
	// Bit FSC17.
	CAN_FS1R_FSC17 = 0x20000
	// Position of FSC18 field.
	CAN_FS1R_FSC18_Pos = 0x12
	// Bit mask of FSC18 field.
	CAN_FS1R_FSC18_Msk = 0x40000
	// Bit FSC18.
	CAN_FS1R_FSC18 = 0x40000
	// Position of FSC19 field.
	CAN_FS1R_FSC19_Pos = 0x13
	// Bit mask of FSC19 field.
	CAN_FS1R_FSC19_Msk = 0x80000
	// Bit FSC19.
	CAN_FS1R_FSC19 = 0x80000
	// Position of FSC20 field.
	CAN_FS1R_FSC20_Pos = 0x14
	// Bit mask of FSC20 field.
	CAN_FS1R_FSC20_Msk = 0x100000
	// Bit FSC20.
	CAN_FS1R_FSC20 = 0x100000
	// Position of FSC21 field.
	CAN_FS1R_FSC21_Pos = 0x15
	// Bit mask of FSC21 field.
	CAN_FS1R_FSC21_Msk = 0x200000
	// Bit FSC21.
	CAN_FS1R_FSC21 = 0x200000
	// Position of FSC22 field.
	CAN_FS1R_FSC22_Pos = 0x16
	// Bit mask of FSC22 field.
	CAN_FS1R_FSC22_Msk = 0x400000
	// Bit FSC22.
	CAN_FS1R_FSC22 = 0x400000
	// Position of FSC23 field.
	CAN_FS1R_FSC23_Pos = 0x17
	// Bit mask of FSC23 field.
	CAN_FS1R_FSC23_Msk = 0x800000
	// Bit FSC23.
	CAN_FS1R_FSC23 = 0x800000
	// Position of FSC24 field.
	CAN_FS1R_FSC24_Pos = 0x18
	// Bit mask of FSC24 field.
	CAN_FS1R_FSC24_Msk = 0x1000000
	// Bit FSC24.
	CAN_FS1R_FSC24 = 0x1000000
	// Position of FSC25 field.
	CAN_FS1R_FSC25_Pos = 0x19
	// Bit mask of FSC25 field.
	CAN_FS1R_FSC25_Msk = 0x2000000
	// Bit FSC25.
	CAN_FS1R_FSC25 = 0x2000000
	// Position of FSC26 field.
	CAN_FS1R_FSC26_Pos = 0x1a
	// Bit mask of FSC26 field.
	CAN_FS1R_FSC26_Msk = 0x4000000
	// Bit FSC26.
	CAN_FS1R_FSC26 = 0x4000000
	// Position of FSC27 field.
	CAN_FS1R_FSC27_Pos = 0x1b
	// Bit mask of FSC27 field.
	CAN_FS1R_FSC27_Msk = 0x8000000
	// Bit FSC27.
	CAN_FS1R_FSC27 = 0x8000000

	// FFA1R: filter FIFO assignment register
	// Position of FFA0 field.
	CAN_FFA1R_FFA0_Pos = 0x0
	// Bit mask of FFA0 field.
	CAN_FFA1R_FFA0_Msk = 0x1
	// Bit FFA0.
	CAN_FFA1R_FFA0 = 0x1
	// Position of FFA1 field.
	CAN_FFA1R_FFA1_Pos = 0x1
	// Bit mask of FFA1 field.
	CAN_FFA1R_FFA1_Msk = 0x2
	// Bit FFA1.
	CAN_FFA1R_FFA1 = 0x2
	// Position of FFA2 field.
	CAN_FFA1R_FFA2_Pos = 0x2
	// Bit mask of FFA2 field.
	CAN_FFA1R_FFA2_Msk = 0x4
	// Bit FFA2.
	CAN_FFA1R_FFA2 = 0x4
	// Position of FFA3 field.
	CAN_FFA1R_FFA3_Pos = 0x3
	// Bit mask of FFA3 field.
	CAN_FFA1R_FFA3_Msk = 0x8
	// Bit FFA3.
	CAN_FFA1R_FFA3 = 0x8
	// Position of FFA4 field.
	CAN_FFA1R_FFA4_Pos = 0x4
	// Bit mask of FFA4 field.
	CAN_FFA1R_FFA4_Msk = 0x10
	// Bit FFA4.
	CAN_FFA1R_FFA4 = 0x10
	// Position of FFA5 field.
	CAN_FFA1R_FFA5_Pos = 0x5
	// Bit mask of FFA5 field.
	CAN_FFA1R_FFA5_Msk = 0x20
	// Bit FFA5.
	CAN_FFA1R_FFA5 = 0x20
	// Position of FFA6 field.
	CAN_FFA1R_FFA6_Pos = 0x6
	// Bit mask of FFA6 field.
	CAN_FFA1R_FFA6_Msk = 0x40
	// Bit FFA6.
	CAN_FFA1R_FFA6 = 0x40
	// Position of FFA7 field.
	CAN_FFA1R_FFA7_Pos = 0x7
	// Bit mask of FFA7 field.
	CAN_FFA1R_FFA7_Msk = 0x80
	// Bit FFA7.
	CAN_FFA1R_FFA7 = 0x80
	// Position of FFA8 field.
	CAN_FFA1R_FFA8_Pos = 0x8
	// Bit mask of FFA8 field.
	CAN_FFA1R_FFA8_Msk = 0x100
	// Bit FFA8.
	CAN_FFA1R_FFA8 = 0x100
	// Position of FFA9 field.
	CAN_FFA1R_FFA9_Pos = 0x9
	// Bit mask of FFA9 field.
	CAN_FFA1R_FFA9_Msk = 0x200
	// Bit FFA9.
	CAN_FFA1R_FFA9 = 0x200
	// Position of FFA10 field.
	CAN_FFA1R_FFA10_Pos = 0xa
	// Bit mask of FFA10 field.
	CAN_FFA1R_FFA10_Msk = 0x400
	// Bit FFA10.
	CAN_FFA1R_FFA10 = 0x400
	// Position of FFA11 field.
	CAN_FFA1R_FFA11_Pos = 0xb
	// Bit mask of FFA11 field.
	CAN_FFA1R_FFA11_Msk = 0x800
	// Bit FFA11.
	CAN_FFA1R_FFA11 = 0x800
	// Position of FFA12 field.
	CAN_FFA1R_FFA12_Pos = 0xc
	// Bit mask of FFA12 field.
	CAN_FFA1R_FFA12_Msk = 0x1000
	// Bit FFA12.
	CAN_FFA1R_FFA12 = 0x1000
	// Position of FFA13 field.
	CAN_FFA1R_FFA13_Pos = 0xd
	// Bit mask of FFA13 field.
	CAN_FFA1R_FFA13_Msk = 0x2000
	// Bit FFA13.
	CAN_FFA1R_FFA13 = 0x2000
	// Position of FFA14 field.
	CAN_FFA1R_FFA14_Pos = 0xe
	// Bit mask of FFA14 field.
	CAN_FFA1R_FFA14_Msk = 0x4000
	// Bit FFA14.
	CAN_FFA1R_FFA14 = 0x4000
	// Position of FFA15 field.
	CAN_FFA1R_FFA15_Pos = 0xf
	// Bit mask of FFA15 field.
	CAN_FFA1R_FFA15_Msk = 0x8000
	// Bit FFA15.
	CAN_FFA1R_FFA15 = 0x8000
	// Position of FFA16 field.
	CAN_FFA1R_FFA16_Pos = 0x10
	// Bit mask of FFA16 field.
	CAN_FFA1R_FFA16_Msk = 0x10000
	// Bit FFA16.
	CAN_FFA1R_FFA16 = 0x10000
	// Position of FFA17 field.
	CAN_FFA1R_FFA17_Pos = 0x11
	// Bit mask of FFA17 field.
	CAN_FFA1R_FFA17_Msk = 0x20000
	// Bit FFA17.
	CAN_FFA1R_FFA17 = 0x20000
	// Position of FFA18 field.
	CAN_FFA1R_FFA18_Pos = 0x12
	// Bit mask of FFA18 field.
	CAN_FFA1R_FFA18_Msk = 0x40000
	// Bit FFA18.
	CAN_FFA1R_FFA18 = 0x40000
	// Position of FFA19 field.
	CAN_FFA1R_FFA19_Pos = 0x13
	// Bit mask of FFA19 field.
	CAN_FFA1R_FFA19_Msk = 0x80000
	// Bit FFA19.
	CAN_FFA1R_FFA19 = 0x80000
	// Position of FFA20 field.
	CAN_FFA1R_FFA20_Pos = 0x14
	// Bit mask of FFA20 field.
	CAN_FFA1R_FFA20_Msk = 0x100000
	// Bit FFA20.
	CAN_FFA1R_FFA20 = 0x100000
	// Position of FFA21 field.
	CAN_FFA1R_FFA21_Pos = 0x15
	// Bit mask of FFA21 field.
	CAN_FFA1R_FFA21_Msk = 0x200000
	// Bit FFA21.
	CAN_FFA1R_FFA21 = 0x200000
	// Position of FFA22 field.
	CAN_FFA1R_FFA22_Pos = 0x16
	// Bit mask of FFA22 field.
	CAN_FFA1R_FFA22_Msk = 0x400000
	// Bit FFA22.
	CAN_FFA1R_FFA22 = 0x400000
	// Position of FFA23 field.
	CAN_FFA1R_FFA23_Pos = 0x17
	// Bit mask of FFA23 field.
	CAN_FFA1R_FFA23_Msk = 0x800000
	// Bit FFA23.
	CAN_FFA1R_FFA23 = 0x800000
	// Position of FFA24 field.
	CAN_FFA1R_FFA24_Pos = 0x18
	// Bit mask of FFA24 field.
	CAN_FFA1R_FFA24_Msk = 0x1000000
	// Bit FFA24.
	CAN_FFA1R_FFA24 = 0x1000000
	// Position of FFA25 field.
	CAN_FFA1R_FFA25_Pos = 0x19
	// Bit mask of FFA25 field.
	CAN_FFA1R_FFA25_Msk = 0x2000000
	// Bit FFA25.
	CAN_FFA1R_FFA25 = 0x2000000
	// Position of FFA26 field.
	CAN_FFA1R_FFA26_Pos = 0x1a
	// Bit mask of FFA26 field.
	CAN_FFA1R_FFA26_Msk = 0x4000000
	// Bit FFA26.
	CAN_FFA1R_FFA26 = 0x4000000
	// Position of FFA27 field.
	CAN_FFA1R_FFA27_Pos = 0x1b
	// Bit mask of FFA27 field.
	CAN_FFA1R_FFA27_Msk = 0x8000000
	// Bit FFA27.
	CAN_FFA1R_FFA27 = 0x8000000

	// FA1R: filter activation register
	// Position of FACT0 field.
	CAN_FA1R_FACT0_Pos = 0x0
	// Bit mask of FACT0 field.
	CAN_FA1R_FACT0_Msk = 0x1
	// Bit FACT0.
	CAN_FA1R_FACT0 = 0x1
	// Position of FACT1 field.
	CAN_FA1R_FACT1_Pos = 0x1
	// Bit mask of FACT1 field.
	CAN_FA1R_FACT1_Msk = 0x2
	// Bit FACT1.
	CAN_FA1R_FACT1 = 0x2
	// Position of FACT2 field.
	CAN_FA1R_FACT2_Pos = 0x2
	// Bit mask of FACT2 field.
	CAN_FA1R_FACT2_Msk = 0x4
	// Bit FACT2.
	CAN_FA1R_FACT2 = 0x4
	// Position of FACT3 field.
	CAN_FA1R_FACT3_Pos = 0x3
	// Bit mask of FACT3 field.
	CAN_FA1R_FACT3_Msk = 0x8
	// Bit FACT3.
	CAN_FA1R_FACT3 = 0x8
	// Position of FACT4 field.
	CAN_FA1R_FACT4_Pos = 0x4
	// Bit mask of FACT4 field.
	CAN_FA1R_FACT4_Msk = 0x10
	// Bit FACT4.
	CAN_FA1R_FACT4 = 0x10
	// Position of FACT5 field.
	CAN_FA1R_FACT5_Pos = 0x5
	// Bit mask of FACT5 field.
	CAN_FA1R_FACT5_Msk = 0x20
	// Bit FACT5.
	CAN_FA1R_FACT5 = 0x20
	// Position of FACT6 field.
	CAN_FA1R_FACT6_Pos = 0x6
	// Bit mask of FACT6 field.
	CAN_FA1R_FACT6_Msk = 0x40
	// Bit FACT6.
	CAN_FA1R_FACT6 = 0x40
	// Position of FACT7 field.
	CAN_FA1R_FACT7_Pos = 0x7
	// Bit mask of FACT7 field.
	CAN_FA1R_FACT7_Msk = 0x80
	// Bit FACT7.
	CAN_FA1R_FACT7 = 0x80
	// Position of FACT8 field.
	CAN_FA1R_FACT8_Pos = 0x8
	// Bit mask of FACT8 field.
	CAN_FA1R_FACT8_Msk = 0x100
	// Bit FACT8.
	CAN_FA1R_FACT8 = 0x100
	// Position of FACT9 field.
	CAN_FA1R_FACT9_Pos = 0x9
	// Bit mask of FACT9 field.
	CAN_FA1R_FACT9_Msk = 0x200
	// Bit FACT9.
	CAN_FA1R_FACT9 = 0x200
	// Position of FACT10 field.
	CAN_FA1R_FACT10_Pos = 0xa
	// Bit mask of FACT10 field.
	CAN_FA1R_FACT10_Msk = 0x400
	// Bit FACT10.
	CAN_FA1R_FACT10 = 0x400
	// Position of FACT11 field.
	CAN_FA1R_FACT11_Pos = 0xb
	// Bit mask of FACT11 field.
	CAN_FA1R_FACT11_Msk = 0x800
	// Bit FACT11.
	CAN_FA1R_FACT11 = 0x800
	// Position of FACT12 field.
	CAN_FA1R_FACT12_Pos = 0xc
	// Bit mask of FACT12 field.
	CAN_FA1R_FACT12_Msk = 0x1000
	// Bit FACT12.
	CAN_FA1R_FACT12 = 0x1000
	// Position of FACT13 field.
	CAN_FA1R_FACT13_Pos = 0xd
	// Bit mask of FACT13 field.
	CAN_FA1R_FACT13_Msk = 0x2000
	// Bit FACT13.
	CAN_FA1R_FACT13 = 0x2000
	// Position of FACT14 field.
	CAN_FA1R_FACT14_Pos = 0xe
	// Bit mask of FACT14 field.
	CAN_FA1R_FACT14_Msk = 0x4000
	// Bit FACT14.
	CAN_FA1R_FACT14 = 0x4000
	// Position of FACT15 field.
	CAN_FA1R_FACT15_Pos = 0xf
	// Bit mask of FACT15 field.
	CAN_FA1R_FACT15_Msk = 0x8000
	// Bit FACT15.
	CAN_FA1R_FACT15 = 0x8000
	// Position of FACT16 field.
	CAN_FA1R_FACT16_Pos = 0x10
	// Bit mask of FACT16 field.
	CAN_FA1R_FACT16_Msk = 0x10000
	// Bit FACT16.
	CAN_FA1R_FACT16 = 0x10000
	// Position of FACT17 field.
	CAN_FA1R_FACT17_Pos = 0x11
	// Bit mask of FACT17 field.
	CAN_FA1R_FACT17_Msk = 0x20000
	// Bit FACT17.
	CAN_FA1R_FACT17 = 0x20000
	// Position of FACT18 field.
	CAN_FA1R_FACT18_Pos = 0x12
	// Bit mask of FACT18 field.
	CAN_FA1R_FACT18_Msk = 0x40000
	// Bit FACT18.
	CAN_FA1R_FACT18 = 0x40000
	// Position of FACT19 field.
	CAN_FA1R_FACT19_Pos = 0x13
	// Bit mask of FACT19 field.
	CAN_FA1R_FACT19_Msk = 0x80000
	// Bit FACT19.
	CAN_FA1R_FACT19 = 0x80000
	// Position of FACT20 field.
	CAN_FA1R_FACT20_Pos = 0x14
	// Bit mask of FACT20 field.
	CAN_FA1R_FACT20_Msk = 0x100000
	// Bit FACT20.
	CAN_FA1R_FACT20 = 0x100000
	// Position of FACT21 field.
	CAN_FA1R_FACT21_Pos = 0x15
	// Bit mask of FACT21 field.
	CAN_FA1R_FACT21_Msk = 0x200000
	// Bit FACT21.
	CAN_FA1R_FACT21 = 0x200000
	// Position of FACT22 field.
	CAN_FA1R_FACT22_Pos = 0x16
	// Bit mask of FACT22 field.
	CAN_FA1R_FACT22_Msk = 0x400000
	// Bit FACT22.
	CAN_FA1R_FACT22 = 0x400000
	// Position of FACT23 field.
	CAN_FA1R_FACT23_Pos = 0x17
	// Bit mask of FACT23 field.
	CAN_FA1R_FACT23_Msk = 0x800000
	// Bit FACT23.
	CAN_FA1R_FACT23 = 0x800000
	// Position of FACT24 field.
	CAN_FA1R_FACT24_Pos = 0x18
	// Bit mask of FACT24 field.
	CAN_FA1R_FACT24_Msk = 0x1000000
	// Bit FACT24.
	CAN_FA1R_FACT24 = 0x1000000
	// Position of FACT25 field.
	CAN_FA1R_FACT25_Pos = 0x19
	// Bit mask of FACT25 field.
	CAN_FA1R_FACT25_Msk = 0x2000000
	// Bit FACT25.
	CAN_FA1R_FACT25 = 0x2000000
	// Position of FACT26 field.
	CAN_FA1R_FACT26_Pos = 0x1a
	// Bit mask of FACT26 field.
	CAN_FA1R_FACT26_Msk = 0x4000000
	// Bit FACT26.
	CAN_FA1R_FACT26 = 0x4000000
	// Position of FACT27 field.
	CAN_FA1R_FACT27_Pos = 0x1b
	// Bit mask of FACT27 field.
	CAN_FA1R_FACT27_Msk = 0x8000000
	// Bit FACT27.
	CAN_FA1R_FACT27 = 0x8000000

	// FB.FR1: Filter bank 0 register 1
	// Position of FB field.
	CAN_FB_FR1_FB_Pos = 0x0
	// Bit mask of FB field.
	CAN_FB_FR1_FB_Msk = 0xffffffff

	// FB.FR2: Filter bank 0 register 2
	// Position of FB field.
	CAN_FB_FR2_FB_Pos = 0x0
	// Bit mask of FB field.
	CAN_FB_FR2_FB_Msk = 0xffffffff
)

// Constants for FLASH: FLASH
const (
	// ACR: Flash access control register
	// Position of LATENCY field.
	FLASH_ACR_LATENCY_Pos = 0x0
	// Bit mask of LATENCY field.
	FLASH_ACR_LATENCY_Msk = 0xf
	// 0 wait states
	FLASH_ACR_LATENCY_WS0 = 0x0
	// 1 wait states
	FLASH_ACR_LATENCY_WS1 = 0x1
	// 2 wait states
	FLASH_ACR_LATENCY_WS2 = 0x2
	// 3 wait states
	FLASH_ACR_LATENCY_WS3 = 0x3
	// 4 wait states
	FLASH_ACR_LATENCY_WS4 = 0x4
	// 5 wait states
	FLASH_ACR_LATENCY_WS5 = 0x5
	// 6 wait states
	FLASH_ACR_LATENCY_WS6 = 0x6
	// 7 wait states
	FLASH_ACR_LATENCY_WS7 = 0x7
	// 8 wait states
	FLASH_ACR_LATENCY_WS8 = 0x8
	// 9 wait states
	FLASH_ACR_LATENCY_WS9 = 0x9
	// 10 wait states
	FLASH_ACR_LATENCY_WS10 = 0xa
	// 11 wait states
	FLASH_ACR_LATENCY_WS11 = 0xb
	// 12 wait states
	FLASH_ACR_LATENCY_WS12 = 0xc
	// 13 wait states
	FLASH_ACR_LATENCY_WS13 = 0xd
	// 14 wait states
	FLASH_ACR_LATENCY_WS14 = 0xe
	// 15 wait states
	FLASH_ACR_LATENCY_WS15 = 0xf
	// Position of PRFTEN field.
	FLASH_ACR_PRFTEN_Pos = 0x8
	// Bit mask of PRFTEN field.
	FLASH_ACR_PRFTEN_Msk = 0x100
	// Bit PRFTEN.
	FLASH_ACR_PRFTEN = 0x100
	// Prefetch is disabled
	FLASH_ACR_PRFTEN_Disabled = 0x0
	// Prefetch is enabled
	FLASH_ACR_PRFTEN_Enabled = 0x1
	// Position of ARTEN field.
	FLASH_ACR_ARTEN_Pos = 0x9
	// Bit mask of ARTEN field.
	FLASH_ACR_ARTEN_Msk = 0x200
	// Bit ARTEN.
	FLASH_ACR_ARTEN = 0x200
	// ART Accelerator is disabled
	FLASH_ACR_ARTEN_Disabled = 0x0
	// ART Accelerator is enabled
	FLASH_ACR_ARTEN_Enabled = 0x1
	// Position of ARTRST field.
	FLASH_ACR_ARTRST_Pos = 0xb
	// Bit mask of ARTRST field.
	FLASH_ACR_ARTRST_Msk = 0x800
	// Bit ARTRST.
	FLASH_ACR_ARTRST = 0x800
	// Accelerator is not reset
	FLASH_ACR_ARTRST_NotReset = 0x0
	// Accelerator is reset
	FLASH_ACR_ARTRST_Reset = 0x1

	// KEYR: Flash key register
	// Position of KEY field.
	FLASH_KEYR_KEY_Pos = 0x0
	// Bit mask of KEY field.
	FLASH_KEYR_KEY_Msk = 0xffffffff

	// OPTKEYR: Flash option key register
	// Position of OPTKEYR field.
	FLASH_OPTKEYR_OPTKEYR_Pos = 0x0
	// Bit mask of OPTKEYR field.
	FLASH_OPTKEYR_OPTKEYR_Msk = 0xffffffff

	// SR: Status register
	// Position of EOP field.
	FLASH_SR_EOP_Pos = 0x0
	// Bit mask of EOP field.
	FLASH_SR_EOP_Msk = 0x1
	// Bit EOP.
	FLASH_SR_EOP = 0x1
	// Position of OPERR field.
	FLASH_SR_OPERR_Pos = 0x1
	// Bit mask of OPERR field.
	FLASH_SR_OPERR_Msk = 0x2
	// Bit OPERR.
	FLASH_SR_OPERR = 0x2
	// Position of WRPERR field.
	FLASH_SR_WRPERR_Pos = 0x4
	// Bit mask of WRPERR field.
	FLASH_SR_WRPERR_Msk = 0x10
	// Bit WRPERR.
	FLASH_SR_WRPERR = 0x10
	// Position of PGAERR field.
	FLASH_SR_PGAERR_Pos = 0x5
	// Bit mask of PGAERR field.
	FLASH_SR_PGAERR_Msk = 0x20
	// Bit PGAERR.
	FLASH_SR_PGAERR = 0x20
	// Position of PGPERR field.
	FLASH_SR_PGPERR_Pos = 0x6
	// Bit mask of PGPERR field.
	FLASH_SR_PGPERR_Msk = 0x40
	// Bit PGPERR.
	FLASH_SR_PGPERR = 0x40
	// Position of ERSERR field.
	FLASH_SR_ERSERR_Pos = 0x7
	// Bit mask of ERSERR field.
	FLASH_SR_ERSERR_Msk = 0x80
	// Bit ERSERR.
	FLASH_SR_ERSERR = 0x80
	// Position of BSY field.
	FLASH_SR_BSY_Pos = 0x10
	// Bit mask of BSY field.
	FLASH_SR_BSY_Msk = 0x10000
	// Bit BSY.
	FLASH_SR_BSY = 0x10000

	// CR: Control register
	// Position of PG field.
	FLASH_CR_PG_Pos = 0x0
	// Bit mask of PG field.
	FLASH_CR_PG_Msk = 0x1
	// Bit PG.
	FLASH_CR_PG = 0x1
	// Flash programming activated
	FLASH_CR_PG_Program = 0x1
	// Position of SER field.
	FLASH_CR_SER_Pos = 0x1
	// Bit mask of SER field.
	FLASH_CR_SER_Msk = 0x2
	// Bit SER.
	FLASH_CR_SER = 0x2
	// Erase activated for selected sector
	FLASH_CR_SER_SectorErase = 0x1
	// Position of MER1 field.
	FLASH_CR_MER1_Pos = 0x2
	// Bit mask of MER1 field.
	FLASH_CR_MER1_Msk = 0x4
	// Bit MER1.
	FLASH_CR_MER1 = 0x4
	// Erase activated for all user sectors or bank 1 in dual bank mode
	FLASH_CR_MER1_MassErase = 0x1
	// Position of SNB field.
	FLASH_CR_SNB_Pos = 0x3
	// Bit mask of SNB field.
	FLASH_CR_SNB_Msk = 0xf8
	// Position of PSIZE field.
	FLASH_CR_PSIZE_Pos = 0x8
	// Bit mask of PSIZE field.
	FLASH_CR_PSIZE_Msk = 0x300
	// Program x8
	FLASH_CR_PSIZE_PSIZE8 = 0x0
	// Program x16
	FLASH_CR_PSIZE_PSIZE16 = 0x1
	// Program x32
	FLASH_CR_PSIZE_PSIZE32 = 0x2
	// Program x64
	FLASH_CR_PSIZE_PSIZE64 = 0x3
	// Position of MER2 field.
	FLASH_CR_MER2_Pos = 0xf
	// Bit mask of MER2 field.
	FLASH_CR_MER2_Msk = 0x8000
	// Bit MER2.
	FLASH_CR_MER2 = 0x8000
	// Erase activated for bank 2 in dual bank mode
	FLASH_CR_MER2_MassErase = 0x1
	// Position of STRT field.
	FLASH_CR_STRT_Pos = 0x10
	// Bit mask of STRT field.
	FLASH_CR_STRT_Msk = 0x10000
	// Bit STRT.
	FLASH_CR_STRT = 0x10000
	// Trigger an erase operation
	FLASH_CR_STRT_Start = 0x1
	// Position of EOPIE field.
	FLASH_CR_EOPIE_Pos = 0x18
	// Bit mask of EOPIE field.
	FLASH_CR_EOPIE_Msk = 0x1000000
	// Bit EOPIE.
	FLASH_CR_EOPIE = 0x1000000
	// End of operation interrupt disabled
	FLASH_CR_EOPIE_Disabled = 0x0
	// End of operation interrupt enabled
	FLASH_CR_EOPIE_Enabled = 0x1
	// Position of ERRIE field.
	FLASH_CR_ERRIE_Pos = 0x19
	// Bit mask of ERRIE field.
	FLASH_CR_ERRIE_Msk = 0x2000000
	// Bit ERRIE.
	FLASH_CR_ERRIE = 0x2000000
	// Error interrupt generation disabled
	FLASH_CR_ERRIE_Disabled = 0x0
	// Error interrupt generation enabled
	FLASH_CR_ERRIE_Enabled = 0x1
	// Position of LOCK field.
	FLASH_CR_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	FLASH_CR_LOCK_Msk = 0x80000000
	// Bit LOCK.
	FLASH_CR_LOCK = 0x80000000
	// FLASH_CR register is unlocked
	FLASH_CR_LOCK_Unlocked = 0x0
	// FLASH_CR register is locked
	FLASH_CR_LOCK_Locked = 0x1

	// OPTCR: Flash option control register
	// Position of OPTLOCK field.
	FLASH_OPTCR_OPTLOCK_Pos = 0x0
	// Bit mask of OPTLOCK field.
	FLASH_OPTCR_OPTLOCK_Msk = 0x1
	// Bit OPTLOCK.
	FLASH_OPTCR_OPTLOCK = 0x1
	// Position of OPTSTRT field.
	FLASH_OPTCR_OPTSTRT_Pos = 0x1
	// Bit mask of OPTSTRT field.
	FLASH_OPTCR_OPTSTRT_Msk = 0x2
	// Bit OPTSTRT.
	FLASH_OPTCR_OPTSTRT = 0x2
	// Position of BOR_LEV field.
	FLASH_OPTCR_BOR_LEV_Pos = 0x2
	// Bit mask of BOR_LEV field.
	FLASH_OPTCR_BOR_LEV_Msk = 0xc
	// Position of WWDG_SW field.
	FLASH_OPTCR_WWDG_SW_Pos = 0x4
	// Bit mask of WWDG_SW field.
	FLASH_OPTCR_WWDG_SW_Msk = 0x10
	// Bit WWDG_SW.
	FLASH_OPTCR_WWDG_SW = 0x10
	// Position of IWDG_SW field.
	FLASH_OPTCR_IWDG_SW_Pos = 0x5
	// Bit mask of IWDG_SW field.
	FLASH_OPTCR_IWDG_SW_Msk = 0x20
	// Bit IWDG_SW.
	FLASH_OPTCR_IWDG_SW = 0x20
	// Position of NRST_STOP field.
	FLASH_OPTCR_NRST_STOP_Pos = 0x6
	// Bit mask of NRST_STOP field.
	FLASH_OPTCR_NRST_STOP_Msk = 0x40
	// Bit NRST_STOP.
	FLASH_OPTCR_NRST_STOP = 0x40
	// Position of NRST_STDBY field.
	FLASH_OPTCR_NRST_STDBY_Pos = 0x7
	// Bit mask of NRST_STDBY field.
	FLASH_OPTCR_NRST_STDBY_Msk = 0x80
	// Bit NRST_STDBY.
	FLASH_OPTCR_NRST_STDBY = 0x80
	// Position of RDP field.
	FLASH_OPTCR_RDP_Pos = 0x8
	// Bit mask of RDP field.
	FLASH_OPTCR_RDP_Msk = 0xff00
	// Position of NWRP field.
	FLASH_OPTCR_NWRP_Pos = 0x10
	// Bit mask of NWRP field.
	FLASH_OPTCR_NWRP_Msk = 0xfff0000
	// Position of NDBOOT field.
	FLASH_OPTCR_NDBOOT_Pos = 0x1c
	// Bit mask of NDBOOT field.
	FLASH_OPTCR_NDBOOT_Msk = 0x10000000
	// Bit NDBOOT.
	FLASH_OPTCR_NDBOOT = 0x10000000
	// Position of NDBANK field.
	FLASH_OPTCR_NDBANK_Pos = 0x1d
	// Bit mask of NDBANK field.
	FLASH_OPTCR_NDBANK_Msk = 0x20000000
	// Bit NDBANK.
	FLASH_OPTCR_NDBANK = 0x20000000
	// Position of IWDG_STDBY field.
	FLASH_OPTCR_IWDG_STDBY_Pos = 0x1e
	// Bit mask of IWDG_STDBY field.
	FLASH_OPTCR_IWDG_STDBY_Msk = 0x40000000
	// Bit IWDG_STDBY.
	FLASH_OPTCR_IWDG_STDBY = 0x40000000
	// Position of IWDG_STOP field.
	FLASH_OPTCR_IWDG_STOP_Pos = 0x1f
	// Bit mask of IWDG_STOP field.
	FLASH_OPTCR_IWDG_STOP_Msk = 0x80000000
	// Bit IWDG_STOP.
	FLASH_OPTCR_IWDG_STOP = 0x80000000

	// OPTCR1: Flash option control register 1
	// Position of BOOT_ADD0 field.
	FLASH_OPTCR1_BOOT_ADD0_Pos = 0x0
	// Bit mask of BOOT_ADD0 field.
	FLASH_OPTCR1_BOOT_ADD0_Msk = 0xffff
	// Position of BOOT_ADD1 field.
	FLASH_OPTCR1_BOOT_ADD1_Pos = 0x10
	// Bit mask of BOOT_ADD1 field.
	FLASH_OPTCR1_BOOT_ADD1_Msk = 0xffff0000
)

// Constants for EXTI: External interrupt/event controller
const (
	// IMR: Interrupt mask register (EXTI_IMR)
	// Position of MR0 field.
	EXTI_IMR_MR0_Pos = 0x0
	// Bit mask of MR0 field.
	EXTI_IMR_MR0_Msk = 0x1
	// Bit MR0.
	EXTI_IMR_MR0 = 0x1
	// Interrupt request line is masked
	EXTI_IMR_MR0_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR0_Unmasked = 0x1
	// Position of MR1 field.
	EXTI_IMR_MR1_Pos = 0x1
	// Bit mask of MR1 field.
	EXTI_IMR_MR1_Msk = 0x2
	// Bit MR1.
	EXTI_IMR_MR1 = 0x2
	// Interrupt request line is masked
	EXTI_IMR_MR1_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR1_Unmasked = 0x1
	// Position of MR2 field.
	EXTI_IMR_MR2_Pos = 0x2
	// Bit mask of MR2 field.
	EXTI_IMR_MR2_Msk = 0x4
	// Bit MR2.
	EXTI_IMR_MR2 = 0x4
	// Interrupt request line is masked
	EXTI_IMR_MR2_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR2_Unmasked = 0x1
	// Position of MR3 field.
	EXTI_IMR_MR3_Pos = 0x3
	// Bit mask of MR3 field.
	EXTI_IMR_MR3_Msk = 0x8
	// Bit MR3.
	EXTI_IMR_MR3 = 0x8
	// Interrupt request line is masked
	EXTI_IMR_MR3_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR3_Unmasked = 0x1
	// Position of MR4 field.
	EXTI_IMR_MR4_Pos = 0x4
	// Bit mask of MR4 field.
	EXTI_IMR_MR4_Msk = 0x10
	// Bit MR4.
	EXTI_IMR_MR4 = 0x10
	// Interrupt request line is masked
	EXTI_IMR_MR4_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR4_Unmasked = 0x1
	// Position of MR5 field.
	EXTI_IMR_MR5_Pos = 0x5
	// Bit mask of MR5 field.
	EXTI_IMR_MR5_Msk = 0x20
	// Bit MR5.
	EXTI_IMR_MR5 = 0x20
	// Interrupt request line is masked
	EXTI_IMR_MR5_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR5_Unmasked = 0x1
	// Position of MR6 field.
	EXTI_IMR_MR6_Pos = 0x6
	// Bit mask of MR6 field.
	EXTI_IMR_MR6_Msk = 0x40
	// Bit MR6.
	EXTI_IMR_MR6 = 0x40
	// Interrupt request line is masked
	EXTI_IMR_MR6_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR6_Unmasked = 0x1
	// Position of MR7 field.
	EXTI_IMR_MR7_Pos = 0x7
	// Bit mask of MR7 field.
	EXTI_IMR_MR7_Msk = 0x80
	// Bit MR7.
	EXTI_IMR_MR7 = 0x80
	// Interrupt request line is masked
	EXTI_IMR_MR7_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR7_Unmasked = 0x1
	// Position of MR8 field.
	EXTI_IMR_MR8_Pos = 0x8
	// Bit mask of MR8 field.
	EXTI_IMR_MR8_Msk = 0x100
	// Bit MR8.
	EXTI_IMR_MR8 = 0x100
	// Interrupt request line is masked
	EXTI_IMR_MR8_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR8_Unmasked = 0x1
	// Position of MR9 field.
	EXTI_IMR_MR9_Pos = 0x9
	// Bit mask of MR9 field.
	EXTI_IMR_MR9_Msk = 0x200
	// Bit MR9.
	EXTI_IMR_MR9 = 0x200
	// Interrupt request line is masked
	EXTI_IMR_MR9_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR9_Unmasked = 0x1
	// Position of MR10 field.
	EXTI_IMR_MR10_Pos = 0xa
	// Bit mask of MR10 field.
	EXTI_IMR_MR10_Msk = 0x400
	// Bit MR10.
	EXTI_IMR_MR10 = 0x400
	// Interrupt request line is masked
	EXTI_IMR_MR10_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR10_Unmasked = 0x1
	// Position of MR11 field.
	EXTI_IMR_MR11_Pos = 0xb
	// Bit mask of MR11 field.
	EXTI_IMR_MR11_Msk = 0x800
	// Bit MR11.
	EXTI_IMR_MR11 = 0x800
	// Interrupt request line is masked
	EXTI_IMR_MR11_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR11_Unmasked = 0x1
	// Position of MR12 field.
	EXTI_IMR_MR12_Pos = 0xc
	// Bit mask of MR12 field.
	EXTI_IMR_MR12_Msk = 0x1000
	// Bit MR12.
	EXTI_IMR_MR12 = 0x1000
	// Interrupt request line is masked
	EXTI_IMR_MR12_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR12_Unmasked = 0x1
	// Position of MR13 field.
	EXTI_IMR_MR13_Pos = 0xd
	// Bit mask of MR13 field.
	EXTI_IMR_MR13_Msk = 0x2000
	// Bit MR13.
	EXTI_IMR_MR13 = 0x2000
	// Interrupt request line is masked
	EXTI_IMR_MR13_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR13_Unmasked = 0x1
	// Position of MR14 field.
	EXTI_IMR_MR14_Pos = 0xe
	// Bit mask of MR14 field.
	EXTI_IMR_MR14_Msk = 0x4000
	// Bit MR14.
	EXTI_IMR_MR14 = 0x4000
	// Interrupt request line is masked
	EXTI_IMR_MR14_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR14_Unmasked = 0x1
	// Position of MR15 field.
	EXTI_IMR_MR15_Pos = 0xf
	// Bit mask of MR15 field.
	EXTI_IMR_MR15_Msk = 0x8000
	// Bit MR15.
	EXTI_IMR_MR15 = 0x8000
	// Interrupt request line is masked
	EXTI_IMR_MR15_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR15_Unmasked = 0x1
	// Position of MR16 field.
	EXTI_IMR_MR16_Pos = 0x10
	// Bit mask of MR16 field.
	EXTI_IMR_MR16_Msk = 0x10000
	// Bit MR16.
	EXTI_IMR_MR16 = 0x10000
	// Interrupt request line is masked
	EXTI_IMR_MR16_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR16_Unmasked = 0x1
	// Position of MR17 field.
	EXTI_IMR_MR17_Pos = 0x11
	// Bit mask of MR17 field.
	EXTI_IMR_MR17_Msk = 0x20000
	// Bit MR17.
	EXTI_IMR_MR17 = 0x20000
	// Interrupt request line is masked
	EXTI_IMR_MR17_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR17_Unmasked = 0x1
	// Position of MR18 field.
	EXTI_IMR_MR18_Pos = 0x12
	// Bit mask of MR18 field.
	EXTI_IMR_MR18_Msk = 0x40000
	// Bit MR18.
	EXTI_IMR_MR18 = 0x40000
	// Interrupt request line is masked
	EXTI_IMR_MR18_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR18_Unmasked = 0x1
	// Position of MR19 field.
	EXTI_IMR_MR19_Pos = 0x13
	// Bit mask of MR19 field.
	EXTI_IMR_MR19_Msk = 0x80000
	// Bit MR19.
	EXTI_IMR_MR19 = 0x80000
	// Interrupt request line is masked
	EXTI_IMR_MR19_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR19_Unmasked = 0x1
	// Position of MR20 field.
	EXTI_IMR_MR20_Pos = 0x14
	// Bit mask of MR20 field.
	EXTI_IMR_MR20_Msk = 0x100000
	// Bit MR20.
	EXTI_IMR_MR20 = 0x100000
	// Interrupt request line is masked
	EXTI_IMR_MR20_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR20_Unmasked = 0x1
	// Position of MR21 field.
	EXTI_IMR_MR21_Pos = 0x15
	// Bit mask of MR21 field.
	EXTI_IMR_MR21_Msk = 0x200000
	// Bit MR21.
	EXTI_IMR_MR21 = 0x200000
	// Interrupt request line is masked
	EXTI_IMR_MR21_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR21_Unmasked = 0x1
	// Position of MR22 field.
	EXTI_IMR_MR22_Pos = 0x16
	// Bit mask of MR22 field.
	EXTI_IMR_MR22_Msk = 0x400000
	// Bit MR22.
	EXTI_IMR_MR22 = 0x400000
	// Interrupt request line is masked
	EXTI_IMR_MR22_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_IMR_MR22_Unmasked = 0x1

	// EMR: Event mask register (EXTI_EMR)
	// Position of MR0 field.
	EXTI_EMR_MR0_Pos = 0x0
	// Bit mask of MR0 field.
	EXTI_EMR_MR0_Msk = 0x1
	// Bit MR0.
	EXTI_EMR_MR0 = 0x1
	// Interrupt request line is masked
	EXTI_EMR_MR0_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR0_Unmasked = 0x1
	// Position of MR1 field.
	EXTI_EMR_MR1_Pos = 0x1
	// Bit mask of MR1 field.
	EXTI_EMR_MR1_Msk = 0x2
	// Bit MR1.
	EXTI_EMR_MR1 = 0x2
	// Interrupt request line is masked
	EXTI_EMR_MR1_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR1_Unmasked = 0x1
	// Position of MR2 field.
	EXTI_EMR_MR2_Pos = 0x2
	// Bit mask of MR2 field.
	EXTI_EMR_MR2_Msk = 0x4
	// Bit MR2.
	EXTI_EMR_MR2 = 0x4
	// Interrupt request line is masked
	EXTI_EMR_MR2_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR2_Unmasked = 0x1
	// Position of MR3 field.
	EXTI_EMR_MR3_Pos = 0x3
	// Bit mask of MR3 field.
	EXTI_EMR_MR3_Msk = 0x8
	// Bit MR3.
	EXTI_EMR_MR3 = 0x8
	// Interrupt request line is masked
	EXTI_EMR_MR3_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR3_Unmasked = 0x1
	// Position of MR4 field.
	EXTI_EMR_MR4_Pos = 0x4
	// Bit mask of MR4 field.
	EXTI_EMR_MR4_Msk = 0x10
	// Bit MR4.
	EXTI_EMR_MR4 = 0x10
	// Interrupt request line is masked
	EXTI_EMR_MR4_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR4_Unmasked = 0x1
	// Position of MR5 field.
	EXTI_EMR_MR5_Pos = 0x5
	// Bit mask of MR5 field.
	EXTI_EMR_MR5_Msk = 0x20
	// Bit MR5.
	EXTI_EMR_MR5 = 0x20
	// Interrupt request line is masked
	EXTI_EMR_MR5_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR5_Unmasked = 0x1
	// Position of MR6 field.
	EXTI_EMR_MR6_Pos = 0x6
	// Bit mask of MR6 field.
	EXTI_EMR_MR6_Msk = 0x40
	// Bit MR6.
	EXTI_EMR_MR6 = 0x40
	// Interrupt request line is masked
	EXTI_EMR_MR6_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR6_Unmasked = 0x1
	// Position of MR7 field.
	EXTI_EMR_MR7_Pos = 0x7
	// Bit mask of MR7 field.
	EXTI_EMR_MR7_Msk = 0x80
	// Bit MR7.
	EXTI_EMR_MR7 = 0x80
	// Interrupt request line is masked
	EXTI_EMR_MR7_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR7_Unmasked = 0x1
	// Position of MR8 field.
	EXTI_EMR_MR8_Pos = 0x8
	// Bit mask of MR8 field.
	EXTI_EMR_MR8_Msk = 0x100
	// Bit MR8.
	EXTI_EMR_MR8 = 0x100
	// Interrupt request line is masked
	EXTI_EMR_MR8_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR8_Unmasked = 0x1
	// Position of MR9 field.
	EXTI_EMR_MR9_Pos = 0x9
	// Bit mask of MR9 field.
	EXTI_EMR_MR9_Msk = 0x200
	// Bit MR9.
	EXTI_EMR_MR9 = 0x200
	// Interrupt request line is masked
	EXTI_EMR_MR9_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR9_Unmasked = 0x1
	// Position of MR10 field.
	EXTI_EMR_MR10_Pos = 0xa
	// Bit mask of MR10 field.
	EXTI_EMR_MR10_Msk = 0x400
	// Bit MR10.
	EXTI_EMR_MR10 = 0x400
	// Interrupt request line is masked
	EXTI_EMR_MR10_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR10_Unmasked = 0x1
	// Position of MR11 field.
	EXTI_EMR_MR11_Pos = 0xb
	// Bit mask of MR11 field.
	EXTI_EMR_MR11_Msk = 0x800
	// Bit MR11.
	EXTI_EMR_MR11 = 0x800
	// Interrupt request line is masked
	EXTI_EMR_MR11_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR11_Unmasked = 0x1
	// Position of MR12 field.
	EXTI_EMR_MR12_Pos = 0xc
	// Bit mask of MR12 field.
	EXTI_EMR_MR12_Msk = 0x1000
	// Bit MR12.
	EXTI_EMR_MR12 = 0x1000
	// Interrupt request line is masked
	EXTI_EMR_MR12_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR12_Unmasked = 0x1
	// Position of MR13 field.
	EXTI_EMR_MR13_Pos = 0xd
	// Bit mask of MR13 field.
	EXTI_EMR_MR13_Msk = 0x2000
	// Bit MR13.
	EXTI_EMR_MR13 = 0x2000
	// Interrupt request line is masked
	EXTI_EMR_MR13_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR13_Unmasked = 0x1
	// Position of MR14 field.
	EXTI_EMR_MR14_Pos = 0xe
	// Bit mask of MR14 field.
	EXTI_EMR_MR14_Msk = 0x4000
	// Bit MR14.
	EXTI_EMR_MR14 = 0x4000
	// Interrupt request line is masked
	EXTI_EMR_MR14_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR14_Unmasked = 0x1
	// Position of MR15 field.
	EXTI_EMR_MR15_Pos = 0xf
	// Bit mask of MR15 field.
	EXTI_EMR_MR15_Msk = 0x8000
	// Bit MR15.
	EXTI_EMR_MR15 = 0x8000
	// Interrupt request line is masked
	EXTI_EMR_MR15_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR15_Unmasked = 0x1
	// Position of MR16 field.
	EXTI_EMR_MR16_Pos = 0x10
	// Bit mask of MR16 field.
	EXTI_EMR_MR16_Msk = 0x10000
	// Bit MR16.
	EXTI_EMR_MR16 = 0x10000
	// Interrupt request line is masked
	EXTI_EMR_MR16_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR16_Unmasked = 0x1
	// Position of MR17 field.
	EXTI_EMR_MR17_Pos = 0x11
	// Bit mask of MR17 field.
	EXTI_EMR_MR17_Msk = 0x20000
	// Bit MR17.
	EXTI_EMR_MR17 = 0x20000
	// Interrupt request line is masked
	EXTI_EMR_MR17_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR17_Unmasked = 0x1
	// Position of MR18 field.
	EXTI_EMR_MR18_Pos = 0x12
	// Bit mask of MR18 field.
	EXTI_EMR_MR18_Msk = 0x40000
	// Bit MR18.
	EXTI_EMR_MR18 = 0x40000
	// Interrupt request line is masked
	EXTI_EMR_MR18_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR18_Unmasked = 0x1
	// Position of MR19 field.
	EXTI_EMR_MR19_Pos = 0x13
	// Bit mask of MR19 field.
	EXTI_EMR_MR19_Msk = 0x80000
	// Bit MR19.
	EXTI_EMR_MR19 = 0x80000
	// Interrupt request line is masked
	EXTI_EMR_MR19_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR19_Unmasked = 0x1
	// Position of MR20 field.
	EXTI_EMR_MR20_Pos = 0x14
	// Bit mask of MR20 field.
	EXTI_EMR_MR20_Msk = 0x100000
	// Bit MR20.
	EXTI_EMR_MR20 = 0x100000
	// Interrupt request line is masked
	EXTI_EMR_MR20_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR20_Unmasked = 0x1
	// Position of MR21 field.
	EXTI_EMR_MR21_Pos = 0x15
	// Bit mask of MR21 field.
	EXTI_EMR_MR21_Msk = 0x200000
	// Bit MR21.
	EXTI_EMR_MR21 = 0x200000
	// Interrupt request line is masked
	EXTI_EMR_MR21_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR21_Unmasked = 0x1
	// Position of MR22 field.
	EXTI_EMR_MR22_Pos = 0x16
	// Bit mask of MR22 field.
	EXTI_EMR_MR22_Msk = 0x400000
	// Bit MR22.
	EXTI_EMR_MR22 = 0x400000
	// Interrupt request line is masked
	EXTI_EMR_MR22_Masked = 0x0
	// Interrupt request line is unmasked
	EXTI_EMR_MR22_Unmasked = 0x1

	// RTSR: Rising Trigger selection register (EXTI_RTSR)
	// Position of TR0 field.
	EXTI_RTSR_TR0_Pos = 0x0
	// Bit mask of TR0 field.
	EXTI_RTSR_TR0_Msk = 0x1
	// Bit TR0.
	EXTI_RTSR_TR0 = 0x1
	// Rising edge trigger is disabled
	EXTI_RTSR_TR0_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR0_Enabled = 0x1
	// Position of TR1 field.
	EXTI_RTSR_TR1_Pos = 0x1
	// Bit mask of TR1 field.
	EXTI_RTSR_TR1_Msk = 0x2
	// Bit TR1.
	EXTI_RTSR_TR1 = 0x2
	// Rising edge trigger is disabled
	EXTI_RTSR_TR1_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR1_Enabled = 0x1
	// Position of TR2 field.
	EXTI_RTSR_TR2_Pos = 0x2
	// Bit mask of TR2 field.
	EXTI_RTSR_TR2_Msk = 0x4
	// Bit TR2.
	EXTI_RTSR_TR2 = 0x4
	// Rising edge trigger is disabled
	EXTI_RTSR_TR2_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR2_Enabled = 0x1
	// Position of TR3 field.
	EXTI_RTSR_TR3_Pos = 0x3
	// Bit mask of TR3 field.
	EXTI_RTSR_TR3_Msk = 0x8
	// Bit TR3.
	EXTI_RTSR_TR3 = 0x8
	// Rising edge trigger is disabled
	EXTI_RTSR_TR3_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR3_Enabled = 0x1
	// Position of TR4 field.
	EXTI_RTSR_TR4_Pos = 0x4
	// Bit mask of TR4 field.
	EXTI_RTSR_TR4_Msk = 0x10
	// Bit TR4.
	EXTI_RTSR_TR4 = 0x10
	// Rising edge trigger is disabled
	EXTI_RTSR_TR4_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR4_Enabled = 0x1
	// Position of TR5 field.
	EXTI_RTSR_TR5_Pos = 0x5
	// Bit mask of TR5 field.
	EXTI_RTSR_TR5_Msk = 0x20
	// Bit TR5.
	EXTI_RTSR_TR5 = 0x20
	// Rising edge trigger is disabled
	EXTI_RTSR_TR5_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR5_Enabled = 0x1
	// Position of TR6 field.
	EXTI_RTSR_TR6_Pos = 0x6
	// Bit mask of TR6 field.
	EXTI_RTSR_TR6_Msk = 0x40
	// Bit TR6.
	EXTI_RTSR_TR6 = 0x40
	// Rising edge trigger is disabled
	EXTI_RTSR_TR6_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR6_Enabled = 0x1
	// Position of TR7 field.
	EXTI_RTSR_TR7_Pos = 0x7
	// Bit mask of TR7 field.
	EXTI_RTSR_TR7_Msk = 0x80
	// Bit TR7.
	EXTI_RTSR_TR7 = 0x80
	// Rising edge trigger is disabled
	EXTI_RTSR_TR7_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR7_Enabled = 0x1
	// Position of TR8 field.
	EXTI_RTSR_TR8_Pos = 0x8
	// Bit mask of TR8 field.
	EXTI_RTSR_TR8_Msk = 0x100
	// Bit TR8.
	EXTI_RTSR_TR8 = 0x100
	// Rising edge trigger is disabled
	EXTI_RTSR_TR8_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR8_Enabled = 0x1
	// Position of TR9 field.
	EXTI_RTSR_TR9_Pos = 0x9
	// Bit mask of TR9 field.
	EXTI_RTSR_TR9_Msk = 0x200
	// Bit TR9.
	EXTI_RTSR_TR9 = 0x200
	// Rising edge trigger is disabled
	EXTI_RTSR_TR9_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR9_Enabled = 0x1
	// Position of TR10 field.
	EXTI_RTSR_TR10_Pos = 0xa
	// Bit mask of TR10 field.
	EXTI_RTSR_TR10_Msk = 0x400
	// Bit TR10.
	EXTI_RTSR_TR10 = 0x400
	// Rising edge trigger is disabled
	EXTI_RTSR_TR10_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR10_Enabled = 0x1
	// Position of TR11 field.
	EXTI_RTSR_TR11_Pos = 0xb
	// Bit mask of TR11 field.
	EXTI_RTSR_TR11_Msk = 0x800
	// Bit TR11.
	EXTI_RTSR_TR11 = 0x800
	// Rising edge trigger is disabled
	EXTI_RTSR_TR11_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR11_Enabled = 0x1
	// Position of TR12 field.
	EXTI_RTSR_TR12_Pos = 0xc
	// Bit mask of TR12 field.
	EXTI_RTSR_TR12_Msk = 0x1000
	// Bit TR12.
	EXTI_RTSR_TR12 = 0x1000
	// Rising edge trigger is disabled
	EXTI_RTSR_TR12_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR12_Enabled = 0x1
	// Position of TR13 field.
	EXTI_RTSR_TR13_Pos = 0xd
	// Bit mask of TR13 field.
	EXTI_RTSR_TR13_Msk = 0x2000
	// Bit TR13.
	EXTI_RTSR_TR13 = 0x2000
	// Rising edge trigger is disabled
	EXTI_RTSR_TR13_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR13_Enabled = 0x1
	// Position of TR14 field.
	EXTI_RTSR_TR14_Pos = 0xe
	// Bit mask of TR14 field.
	EXTI_RTSR_TR14_Msk = 0x4000
	// Bit TR14.
	EXTI_RTSR_TR14 = 0x4000
	// Rising edge trigger is disabled
	EXTI_RTSR_TR14_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR14_Enabled = 0x1
	// Position of TR15 field.
	EXTI_RTSR_TR15_Pos = 0xf
	// Bit mask of TR15 field.
	EXTI_RTSR_TR15_Msk = 0x8000
	// Bit TR15.
	EXTI_RTSR_TR15 = 0x8000
	// Rising edge trigger is disabled
	EXTI_RTSR_TR15_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR15_Enabled = 0x1
	// Position of TR16 field.
	EXTI_RTSR_TR16_Pos = 0x10
	// Bit mask of TR16 field.
	EXTI_RTSR_TR16_Msk = 0x10000
	// Bit TR16.
	EXTI_RTSR_TR16 = 0x10000
	// Rising edge trigger is disabled
	EXTI_RTSR_TR16_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR16_Enabled = 0x1
	// Position of TR17 field.
	EXTI_RTSR_TR17_Pos = 0x11
	// Bit mask of TR17 field.
	EXTI_RTSR_TR17_Msk = 0x20000
	// Bit TR17.
	EXTI_RTSR_TR17 = 0x20000
	// Rising edge trigger is disabled
	EXTI_RTSR_TR17_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR17_Enabled = 0x1
	// Position of TR18 field.
	EXTI_RTSR_TR18_Pos = 0x12
	// Bit mask of TR18 field.
	EXTI_RTSR_TR18_Msk = 0x40000
	// Bit TR18.
	EXTI_RTSR_TR18 = 0x40000
	// Rising edge trigger is disabled
	EXTI_RTSR_TR18_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR18_Enabled = 0x1
	// Position of TR19 field.
	EXTI_RTSR_TR19_Pos = 0x13
	// Bit mask of TR19 field.
	EXTI_RTSR_TR19_Msk = 0x80000
	// Bit TR19.
	EXTI_RTSR_TR19 = 0x80000
	// Rising edge trigger is disabled
	EXTI_RTSR_TR19_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR19_Enabled = 0x1
	// Position of TR20 field.
	EXTI_RTSR_TR20_Pos = 0x14
	// Bit mask of TR20 field.
	EXTI_RTSR_TR20_Msk = 0x100000
	// Bit TR20.
	EXTI_RTSR_TR20 = 0x100000
	// Rising edge trigger is disabled
	EXTI_RTSR_TR20_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR20_Enabled = 0x1
	// Position of TR21 field.
	EXTI_RTSR_TR21_Pos = 0x15
	// Bit mask of TR21 field.
	EXTI_RTSR_TR21_Msk = 0x200000
	// Bit TR21.
	EXTI_RTSR_TR21 = 0x200000
	// Rising edge trigger is disabled
	EXTI_RTSR_TR21_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR21_Enabled = 0x1
	// Position of TR22 field.
	EXTI_RTSR_TR22_Pos = 0x16
	// Bit mask of TR22 field.
	EXTI_RTSR_TR22_Msk = 0x400000
	// Bit TR22.
	EXTI_RTSR_TR22 = 0x400000
	// Rising edge trigger is disabled
	EXTI_RTSR_TR22_Disabled = 0x0
	// Rising edge trigger is enabled
	EXTI_RTSR_TR22_Enabled = 0x1

	// FTSR: Falling Trigger selection register (EXTI_FTSR)
	// Position of TR0 field.
	EXTI_FTSR_TR0_Pos = 0x0
	// Bit mask of TR0 field.
	EXTI_FTSR_TR0_Msk = 0x1
	// Bit TR0.
	EXTI_FTSR_TR0 = 0x1
	// Falling edge trigger is disabled
	EXTI_FTSR_TR0_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR0_Enabled = 0x1
	// Position of TR1 field.
	EXTI_FTSR_TR1_Pos = 0x1
	// Bit mask of TR1 field.
	EXTI_FTSR_TR1_Msk = 0x2
	// Bit TR1.
	EXTI_FTSR_TR1 = 0x2
	// Falling edge trigger is disabled
	EXTI_FTSR_TR1_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR1_Enabled = 0x1
	// Position of TR2 field.
	EXTI_FTSR_TR2_Pos = 0x2
	// Bit mask of TR2 field.
	EXTI_FTSR_TR2_Msk = 0x4
	// Bit TR2.
	EXTI_FTSR_TR2 = 0x4
	// Falling edge trigger is disabled
	EXTI_FTSR_TR2_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR2_Enabled = 0x1
	// Position of TR3 field.
	EXTI_FTSR_TR3_Pos = 0x3
	// Bit mask of TR3 field.
	EXTI_FTSR_TR3_Msk = 0x8
	// Bit TR3.
	EXTI_FTSR_TR3 = 0x8
	// Falling edge trigger is disabled
	EXTI_FTSR_TR3_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR3_Enabled = 0x1
	// Position of TR4 field.
	EXTI_FTSR_TR4_Pos = 0x4
	// Bit mask of TR4 field.
	EXTI_FTSR_TR4_Msk = 0x10
	// Bit TR4.
	EXTI_FTSR_TR4 = 0x10
	// Falling edge trigger is disabled
	EXTI_FTSR_TR4_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR4_Enabled = 0x1
	// Position of TR5 field.
	EXTI_FTSR_TR5_Pos = 0x5
	// Bit mask of TR5 field.
	EXTI_FTSR_TR5_Msk = 0x20
	// Bit TR5.
	EXTI_FTSR_TR5 = 0x20
	// Falling edge trigger is disabled
	EXTI_FTSR_TR5_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR5_Enabled = 0x1
	// Position of TR6 field.
	EXTI_FTSR_TR6_Pos = 0x6
	// Bit mask of TR6 field.
	EXTI_FTSR_TR6_Msk = 0x40
	// Bit TR6.
	EXTI_FTSR_TR6 = 0x40
	// Falling edge trigger is disabled
	EXTI_FTSR_TR6_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR6_Enabled = 0x1
	// Position of TR7 field.
	EXTI_FTSR_TR7_Pos = 0x7
	// Bit mask of TR7 field.
	EXTI_FTSR_TR7_Msk = 0x80
	// Bit TR7.
	EXTI_FTSR_TR7 = 0x80
	// Falling edge trigger is disabled
	EXTI_FTSR_TR7_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR7_Enabled = 0x1
	// Position of TR8 field.
	EXTI_FTSR_TR8_Pos = 0x8
	// Bit mask of TR8 field.
	EXTI_FTSR_TR8_Msk = 0x100
	// Bit TR8.
	EXTI_FTSR_TR8 = 0x100
	// Falling edge trigger is disabled
	EXTI_FTSR_TR8_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR8_Enabled = 0x1
	// Position of TR9 field.
	EXTI_FTSR_TR9_Pos = 0x9
	// Bit mask of TR9 field.
	EXTI_FTSR_TR9_Msk = 0x200
	// Bit TR9.
	EXTI_FTSR_TR9 = 0x200
	// Falling edge trigger is disabled
	EXTI_FTSR_TR9_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR9_Enabled = 0x1
	// Position of TR10 field.
	EXTI_FTSR_TR10_Pos = 0xa
	// Bit mask of TR10 field.
	EXTI_FTSR_TR10_Msk = 0x400
	// Bit TR10.
	EXTI_FTSR_TR10 = 0x400
	// Falling edge trigger is disabled
	EXTI_FTSR_TR10_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR10_Enabled = 0x1
	// Position of TR11 field.
	EXTI_FTSR_TR11_Pos = 0xb
	// Bit mask of TR11 field.
	EXTI_FTSR_TR11_Msk = 0x800
	// Bit TR11.
	EXTI_FTSR_TR11 = 0x800
	// Falling edge trigger is disabled
	EXTI_FTSR_TR11_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR11_Enabled = 0x1
	// Position of TR12 field.
	EXTI_FTSR_TR12_Pos = 0xc
	// Bit mask of TR12 field.
	EXTI_FTSR_TR12_Msk = 0x1000
	// Bit TR12.
	EXTI_FTSR_TR12 = 0x1000
	// Falling edge trigger is disabled
	EXTI_FTSR_TR12_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR12_Enabled = 0x1
	// Position of TR13 field.
	EXTI_FTSR_TR13_Pos = 0xd
	// Bit mask of TR13 field.
	EXTI_FTSR_TR13_Msk = 0x2000
	// Bit TR13.
	EXTI_FTSR_TR13 = 0x2000
	// Falling edge trigger is disabled
	EXTI_FTSR_TR13_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR13_Enabled = 0x1
	// Position of TR14 field.
	EXTI_FTSR_TR14_Pos = 0xe
	// Bit mask of TR14 field.
	EXTI_FTSR_TR14_Msk = 0x4000
	// Bit TR14.
	EXTI_FTSR_TR14 = 0x4000
	// Falling edge trigger is disabled
	EXTI_FTSR_TR14_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR14_Enabled = 0x1
	// Position of TR15 field.
	EXTI_FTSR_TR15_Pos = 0xf
	// Bit mask of TR15 field.
	EXTI_FTSR_TR15_Msk = 0x8000
	// Bit TR15.
	EXTI_FTSR_TR15 = 0x8000
	// Falling edge trigger is disabled
	EXTI_FTSR_TR15_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR15_Enabled = 0x1
	// Position of TR16 field.
	EXTI_FTSR_TR16_Pos = 0x10
	// Bit mask of TR16 field.
	EXTI_FTSR_TR16_Msk = 0x10000
	// Bit TR16.
	EXTI_FTSR_TR16 = 0x10000
	// Falling edge trigger is disabled
	EXTI_FTSR_TR16_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR16_Enabled = 0x1
	// Position of TR17 field.
	EXTI_FTSR_TR17_Pos = 0x11
	// Bit mask of TR17 field.
	EXTI_FTSR_TR17_Msk = 0x20000
	// Bit TR17.
	EXTI_FTSR_TR17 = 0x20000
	// Falling edge trigger is disabled
	EXTI_FTSR_TR17_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR17_Enabled = 0x1
	// Position of TR18 field.
	EXTI_FTSR_TR18_Pos = 0x12
	// Bit mask of TR18 field.
	EXTI_FTSR_TR18_Msk = 0x40000
	// Bit TR18.
	EXTI_FTSR_TR18 = 0x40000
	// Falling edge trigger is disabled
	EXTI_FTSR_TR18_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR18_Enabled = 0x1
	// Position of TR19 field.
	EXTI_FTSR_TR19_Pos = 0x13
	// Bit mask of TR19 field.
	EXTI_FTSR_TR19_Msk = 0x80000
	// Bit TR19.
	EXTI_FTSR_TR19 = 0x80000
	// Falling edge trigger is disabled
	EXTI_FTSR_TR19_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR19_Enabled = 0x1
	// Position of TR20 field.
	EXTI_FTSR_TR20_Pos = 0x14
	// Bit mask of TR20 field.
	EXTI_FTSR_TR20_Msk = 0x100000
	// Bit TR20.
	EXTI_FTSR_TR20 = 0x100000
	// Falling edge trigger is disabled
	EXTI_FTSR_TR20_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR20_Enabled = 0x1
	// Position of TR21 field.
	EXTI_FTSR_TR21_Pos = 0x15
	// Bit mask of TR21 field.
	EXTI_FTSR_TR21_Msk = 0x200000
	// Bit TR21.
	EXTI_FTSR_TR21 = 0x200000
	// Falling edge trigger is disabled
	EXTI_FTSR_TR21_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR21_Enabled = 0x1
	// Position of TR22 field.
	EXTI_FTSR_TR22_Pos = 0x16
	// Bit mask of TR22 field.
	EXTI_FTSR_TR22_Msk = 0x400000
	// Bit TR22.
	EXTI_FTSR_TR22 = 0x400000
	// Falling edge trigger is disabled
	EXTI_FTSR_TR22_Disabled = 0x0
	// Falling edge trigger is enabled
	EXTI_FTSR_TR22_Enabled = 0x1

	// SWIER: Software interrupt event register (EXTI_SWIER)
	// Position of SWIER0 field.
	EXTI_SWIER_SWIER0_Pos = 0x0
	// Bit mask of SWIER0 field.
	EXTI_SWIER_SWIER0_Msk = 0x1
	// Bit SWIER0.
	EXTI_SWIER_SWIER0 = 0x1
	// Generates an interrupt request
	EXTI_SWIER_SWIER0_Pend = 0x1
	// Position of SWIER1 field.
	EXTI_SWIER_SWIER1_Pos = 0x1
	// Bit mask of SWIER1 field.
	EXTI_SWIER_SWIER1_Msk = 0x2
	// Bit SWIER1.
	EXTI_SWIER_SWIER1 = 0x2
	// Generates an interrupt request
	EXTI_SWIER_SWIER1_Pend = 0x1
	// Position of SWIER2 field.
	EXTI_SWIER_SWIER2_Pos = 0x2
	// Bit mask of SWIER2 field.
	EXTI_SWIER_SWIER2_Msk = 0x4
	// Bit SWIER2.
	EXTI_SWIER_SWIER2 = 0x4
	// Generates an interrupt request
	EXTI_SWIER_SWIER2_Pend = 0x1
	// Position of SWIER3 field.
	EXTI_SWIER_SWIER3_Pos = 0x3
	// Bit mask of SWIER3 field.
	EXTI_SWIER_SWIER3_Msk = 0x8
	// Bit SWIER3.
	EXTI_SWIER_SWIER3 = 0x8
	// Generates an interrupt request
	EXTI_SWIER_SWIER3_Pend = 0x1
	// Position of SWIER4 field.
	EXTI_SWIER_SWIER4_Pos = 0x4
	// Bit mask of SWIER4 field.
	EXTI_SWIER_SWIER4_Msk = 0x10
	// Bit SWIER4.
	EXTI_SWIER_SWIER4 = 0x10
	// Generates an interrupt request
	EXTI_SWIER_SWIER4_Pend = 0x1
	// Position of SWIER5 field.
	EXTI_SWIER_SWIER5_Pos = 0x5
	// Bit mask of SWIER5 field.
	EXTI_SWIER_SWIER5_Msk = 0x20
	// Bit SWIER5.
	EXTI_SWIER_SWIER5 = 0x20
	// Generates an interrupt request
	EXTI_SWIER_SWIER5_Pend = 0x1
	// Position of SWIER6 field.
	EXTI_SWIER_SWIER6_Pos = 0x6
	// Bit mask of SWIER6 field.
	EXTI_SWIER_SWIER6_Msk = 0x40
	// Bit SWIER6.
	EXTI_SWIER_SWIER6 = 0x40
	// Generates an interrupt request
	EXTI_SWIER_SWIER6_Pend = 0x1
	// Position of SWIER7 field.
	EXTI_SWIER_SWIER7_Pos = 0x7
	// Bit mask of SWIER7 field.
	EXTI_SWIER_SWIER7_Msk = 0x80
	// Bit SWIER7.
	EXTI_SWIER_SWIER7 = 0x80
	// Generates an interrupt request
	EXTI_SWIER_SWIER7_Pend = 0x1
	// Position of SWIER8 field.
	EXTI_SWIER_SWIER8_Pos = 0x8
	// Bit mask of SWIER8 field.
	EXTI_SWIER_SWIER8_Msk = 0x100
	// Bit SWIER8.
	EXTI_SWIER_SWIER8 = 0x100
	// Generates an interrupt request
	EXTI_SWIER_SWIER8_Pend = 0x1
	// Position of SWIER9 field.
	EXTI_SWIER_SWIER9_Pos = 0x9
	// Bit mask of SWIER9 field.
	EXTI_SWIER_SWIER9_Msk = 0x200
	// Bit SWIER9.
	EXTI_SWIER_SWIER9 = 0x200
	// Generates an interrupt request
	EXTI_SWIER_SWIER9_Pend = 0x1
	// Position of SWIER10 field.
	EXTI_SWIER_SWIER10_Pos = 0xa
	// Bit mask of SWIER10 field.
	EXTI_SWIER_SWIER10_Msk = 0x400
	// Bit SWIER10.
	EXTI_SWIER_SWIER10 = 0x400
	// Generates an interrupt request
	EXTI_SWIER_SWIER10_Pend = 0x1
	// Position of SWIER11 field.
	EXTI_SWIER_SWIER11_Pos = 0xb
	// Bit mask of SWIER11 field.
	EXTI_SWIER_SWIER11_Msk = 0x800
	// Bit SWIER11.
	EXTI_SWIER_SWIER11 = 0x800
	// Generates an interrupt request
	EXTI_SWIER_SWIER11_Pend = 0x1
	// Position of SWIER12 field.
	EXTI_SWIER_SWIER12_Pos = 0xc
	// Bit mask of SWIER12 field.
	EXTI_SWIER_SWIER12_Msk = 0x1000
	// Bit SWIER12.
	EXTI_SWIER_SWIER12 = 0x1000
	// Generates an interrupt request
	EXTI_SWIER_SWIER12_Pend = 0x1
	// Position of SWIER13 field.
	EXTI_SWIER_SWIER13_Pos = 0xd
	// Bit mask of SWIER13 field.
	EXTI_SWIER_SWIER13_Msk = 0x2000
	// Bit SWIER13.
	EXTI_SWIER_SWIER13 = 0x2000
	// Generates an interrupt request
	EXTI_SWIER_SWIER13_Pend = 0x1
	// Position of SWIER14 field.
	EXTI_SWIER_SWIER14_Pos = 0xe
	// Bit mask of SWIER14 field.
	EXTI_SWIER_SWIER14_Msk = 0x4000
	// Bit SWIER14.
	EXTI_SWIER_SWIER14 = 0x4000
	// Generates an interrupt request
	EXTI_SWIER_SWIER14_Pend = 0x1
	// Position of SWIER15 field.
	EXTI_SWIER_SWIER15_Pos = 0xf
	// Bit mask of SWIER15 field.
	EXTI_SWIER_SWIER15_Msk = 0x8000
	// Bit SWIER15.
	EXTI_SWIER_SWIER15 = 0x8000
	// Generates an interrupt request
	EXTI_SWIER_SWIER15_Pend = 0x1
	// Position of SWIER16 field.
	EXTI_SWIER_SWIER16_Pos = 0x10
	// Bit mask of SWIER16 field.
	EXTI_SWIER_SWIER16_Msk = 0x10000
	// Bit SWIER16.
	EXTI_SWIER_SWIER16 = 0x10000
	// Generates an interrupt request
	EXTI_SWIER_SWIER16_Pend = 0x1
	// Position of SWIER17 field.
	EXTI_SWIER_SWIER17_Pos = 0x11
	// Bit mask of SWIER17 field.
	EXTI_SWIER_SWIER17_Msk = 0x20000
	// Bit SWIER17.
	EXTI_SWIER_SWIER17 = 0x20000
	// Generates an interrupt request
	EXTI_SWIER_SWIER17_Pend = 0x1
	// Position of SWIER18 field.
	EXTI_SWIER_SWIER18_Pos = 0x12
	// Bit mask of SWIER18 field.
	EXTI_SWIER_SWIER18_Msk = 0x40000
	// Bit SWIER18.
	EXTI_SWIER_SWIER18 = 0x40000
	// Generates an interrupt request
	EXTI_SWIER_SWIER18_Pend = 0x1
	// Position of SWIER19 field.
	EXTI_SWIER_SWIER19_Pos = 0x13
	// Bit mask of SWIER19 field.
	EXTI_SWIER_SWIER19_Msk = 0x80000
	// Bit SWIER19.
	EXTI_SWIER_SWIER19 = 0x80000
	// Generates an interrupt request
	EXTI_SWIER_SWIER19_Pend = 0x1
	// Position of SWIER20 field.
	EXTI_SWIER_SWIER20_Pos = 0x14
	// Bit mask of SWIER20 field.
	EXTI_SWIER_SWIER20_Msk = 0x100000
	// Bit SWIER20.
	EXTI_SWIER_SWIER20 = 0x100000
	// Generates an interrupt request
	EXTI_SWIER_SWIER20_Pend = 0x1
	// Position of SWIER21 field.
	EXTI_SWIER_SWIER21_Pos = 0x15
	// Bit mask of SWIER21 field.
	EXTI_SWIER_SWIER21_Msk = 0x200000
	// Bit SWIER21.
	EXTI_SWIER_SWIER21 = 0x200000
	// Generates an interrupt request
	EXTI_SWIER_SWIER21_Pend = 0x1
	// Position of SWIER22 field.
	EXTI_SWIER_SWIER22_Pos = 0x16
	// Bit mask of SWIER22 field.
	EXTI_SWIER_SWIER22_Msk = 0x400000
	// Bit SWIER22.
	EXTI_SWIER_SWIER22 = 0x400000
	// Generates an interrupt request
	EXTI_SWIER_SWIER22_Pend = 0x1

	// PR: Pending register (EXTI_PR)
	// Position of PR0 field.
	EXTI_PR_PR0_Pos = 0x0
	// Bit mask of PR0 field.
	EXTI_PR_PR0_Msk = 0x1
	// Bit PR0.
	EXTI_PR_PR0 = 0x1
	// No trigger request occurred
	EXTI_PR_PR0_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR0_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR0_Clear = 0x1
	// Position of PR1 field.
	EXTI_PR_PR1_Pos = 0x1
	// Bit mask of PR1 field.
	EXTI_PR_PR1_Msk = 0x2
	// Bit PR1.
	EXTI_PR_PR1 = 0x2
	// No trigger request occurred
	EXTI_PR_PR1_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR1_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR1_Clear = 0x1
	// Position of PR2 field.
	EXTI_PR_PR2_Pos = 0x2
	// Bit mask of PR2 field.
	EXTI_PR_PR2_Msk = 0x4
	// Bit PR2.
	EXTI_PR_PR2 = 0x4
	// No trigger request occurred
	EXTI_PR_PR2_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR2_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR2_Clear = 0x1
	// Position of PR3 field.
	EXTI_PR_PR3_Pos = 0x3
	// Bit mask of PR3 field.
	EXTI_PR_PR3_Msk = 0x8
	// Bit PR3.
	EXTI_PR_PR3 = 0x8
	// No trigger request occurred
	EXTI_PR_PR3_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR3_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR3_Clear = 0x1
	// Position of PR4 field.
	EXTI_PR_PR4_Pos = 0x4
	// Bit mask of PR4 field.
	EXTI_PR_PR4_Msk = 0x10
	// Bit PR4.
	EXTI_PR_PR4 = 0x10
	// No trigger request occurred
	EXTI_PR_PR4_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR4_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR4_Clear = 0x1
	// Position of PR5 field.
	EXTI_PR_PR5_Pos = 0x5
	// Bit mask of PR5 field.
	EXTI_PR_PR5_Msk = 0x20
	// Bit PR5.
	EXTI_PR_PR5 = 0x20
	// No trigger request occurred
	EXTI_PR_PR5_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR5_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR5_Clear = 0x1
	// Position of PR6 field.
	EXTI_PR_PR6_Pos = 0x6
	// Bit mask of PR6 field.
	EXTI_PR_PR6_Msk = 0x40
	// Bit PR6.
	EXTI_PR_PR6 = 0x40
	// No trigger request occurred
	EXTI_PR_PR6_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR6_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR6_Clear = 0x1
	// Position of PR7 field.
	EXTI_PR_PR7_Pos = 0x7
	// Bit mask of PR7 field.
	EXTI_PR_PR7_Msk = 0x80
	// Bit PR7.
	EXTI_PR_PR7 = 0x80
	// No trigger request occurred
	EXTI_PR_PR7_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR7_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR7_Clear = 0x1
	// Position of PR8 field.
	EXTI_PR_PR8_Pos = 0x8
	// Bit mask of PR8 field.
	EXTI_PR_PR8_Msk = 0x100
	// Bit PR8.
	EXTI_PR_PR8 = 0x100
	// No trigger request occurred
	EXTI_PR_PR8_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR8_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR8_Clear = 0x1
	// Position of PR9 field.
	EXTI_PR_PR9_Pos = 0x9
	// Bit mask of PR9 field.
	EXTI_PR_PR9_Msk = 0x200
	// Bit PR9.
	EXTI_PR_PR9 = 0x200
	// No trigger request occurred
	EXTI_PR_PR9_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR9_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR9_Clear = 0x1
	// Position of PR10 field.
	EXTI_PR_PR10_Pos = 0xa
	// Bit mask of PR10 field.
	EXTI_PR_PR10_Msk = 0x400
	// Bit PR10.
	EXTI_PR_PR10 = 0x400
	// No trigger request occurred
	EXTI_PR_PR10_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR10_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR10_Clear = 0x1
	// Position of PR11 field.
	EXTI_PR_PR11_Pos = 0xb
	// Bit mask of PR11 field.
	EXTI_PR_PR11_Msk = 0x800
	// Bit PR11.
	EXTI_PR_PR11 = 0x800
	// No trigger request occurred
	EXTI_PR_PR11_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR11_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR11_Clear = 0x1
	// Position of PR12 field.
	EXTI_PR_PR12_Pos = 0xc
	// Bit mask of PR12 field.
	EXTI_PR_PR12_Msk = 0x1000
	// Bit PR12.
	EXTI_PR_PR12 = 0x1000
	// No trigger request occurred
	EXTI_PR_PR12_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR12_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR12_Clear = 0x1
	// Position of PR13 field.
	EXTI_PR_PR13_Pos = 0xd
	// Bit mask of PR13 field.
	EXTI_PR_PR13_Msk = 0x2000
	// Bit PR13.
	EXTI_PR_PR13 = 0x2000
	// No trigger request occurred
	EXTI_PR_PR13_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR13_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR13_Clear = 0x1
	// Position of PR14 field.
	EXTI_PR_PR14_Pos = 0xe
	// Bit mask of PR14 field.
	EXTI_PR_PR14_Msk = 0x4000
	// Bit PR14.
	EXTI_PR_PR14 = 0x4000
	// No trigger request occurred
	EXTI_PR_PR14_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR14_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR14_Clear = 0x1
	// Position of PR15 field.
	EXTI_PR_PR15_Pos = 0xf
	// Bit mask of PR15 field.
	EXTI_PR_PR15_Msk = 0x8000
	// Bit PR15.
	EXTI_PR_PR15 = 0x8000
	// No trigger request occurred
	EXTI_PR_PR15_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR15_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR15_Clear = 0x1
	// Position of PR16 field.
	EXTI_PR_PR16_Pos = 0x10
	// Bit mask of PR16 field.
	EXTI_PR_PR16_Msk = 0x10000
	// Bit PR16.
	EXTI_PR_PR16 = 0x10000
	// No trigger request occurred
	EXTI_PR_PR16_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR16_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR16_Clear = 0x1
	// Position of PR17 field.
	EXTI_PR_PR17_Pos = 0x11
	// Bit mask of PR17 field.
	EXTI_PR_PR17_Msk = 0x20000
	// Bit PR17.
	EXTI_PR_PR17 = 0x20000
	// No trigger request occurred
	EXTI_PR_PR17_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR17_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR17_Clear = 0x1
	// Position of PR18 field.
	EXTI_PR_PR18_Pos = 0x12
	// Bit mask of PR18 field.
	EXTI_PR_PR18_Msk = 0x40000
	// Bit PR18.
	EXTI_PR_PR18 = 0x40000
	// No trigger request occurred
	EXTI_PR_PR18_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR18_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR18_Clear = 0x1
	// Position of PR19 field.
	EXTI_PR_PR19_Pos = 0x13
	// Bit mask of PR19 field.
	EXTI_PR_PR19_Msk = 0x80000
	// Bit PR19.
	EXTI_PR_PR19 = 0x80000
	// No trigger request occurred
	EXTI_PR_PR19_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR19_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR19_Clear = 0x1
	// Position of PR20 field.
	EXTI_PR_PR20_Pos = 0x14
	// Bit mask of PR20 field.
	EXTI_PR_PR20_Msk = 0x100000
	// Bit PR20.
	EXTI_PR_PR20 = 0x100000
	// No trigger request occurred
	EXTI_PR_PR20_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR20_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR20_Clear = 0x1
	// Position of PR21 field.
	EXTI_PR_PR21_Pos = 0x15
	// Bit mask of PR21 field.
	EXTI_PR_PR21_Msk = 0x200000
	// Bit PR21.
	EXTI_PR_PR21 = 0x200000
	// No trigger request occurred
	EXTI_PR_PR21_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR21_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR21_Clear = 0x1
	// Position of PR22 field.
	EXTI_PR_PR22_Pos = 0x16
	// Bit mask of PR22 field.
	EXTI_PR_PR22_Msk = 0x400000
	// Bit PR22.
	EXTI_PR_PR22 = 0x400000
	// No trigger request occurred
	EXTI_PR_PR22_NotPending = 0x0
	// Selected trigger request occurred
	EXTI_PR_PR22_Pending = 0x1
	// Clears pending bit
	EXTI_PR_PR22_Clear = 0x1
)

// Constants for LTDC: LCD-TFT Controller
const (
	// SSCR: Synchronization Size Configuration Register
	// Position of HSW field.
	LTDC_SSCR_HSW_Pos = 0x10
	// Bit mask of HSW field.
	LTDC_SSCR_HSW_Msk = 0xfff0000
	// Position of VSH field.
	LTDC_SSCR_VSH_Pos = 0x0
	// Bit mask of VSH field.
	LTDC_SSCR_VSH_Msk = 0x7ff

	// BPCR: Back Porch Configuration Register
	// Position of AHBP field.
	LTDC_BPCR_AHBP_Pos = 0x10
	// Bit mask of AHBP field.
	LTDC_BPCR_AHBP_Msk = 0xfff0000
	// Position of AVBP field.
	LTDC_BPCR_AVBP_Pos = 0x0
	// Bit mask of AVBP field.
	LTDC_BPCR_AVBP_Msk = 0x7ff

	// AWCR: Active Width Configuration Register
	// Position of AAW field.
	LTDC_AWCR_AAW_Pos = 0x10
	// Bit mask of AAW field.
	LTDC_AWCR_AAW_Msk = 0xfff0000
	// Position of AAH field.
	LTDC_AWCR_AAH_Pos = 0x0
	// Bit mask of AAH field.
	LTDC_AWCR_AAH_Msk = 0x7ff

	// TWCR: Total Width Configuration Register
	// Position of TOTALW field.
	LTDC_TWCR_TOTALW_Pos = 0x10
	// Bit mask of TOTALW field.
	LTDC_TWCR_TOTALW_Msk = 0xfff0000
	// Position of TOTALH field.
	LTDC_TWCR_TOTALH_Pos = 0x0
	// Bit mask of TOTALH field.
	LTDC_TWCR_TOTALH_Msk = 0x7ff

	// GCR: Global Control Register
	// Position of HSPOL field.
	LTDC_GCR_HSPOL_Pos = 0x1f
	// Bit mask of HSPOL field.
	LTDC_GCR_HSPOL_Msk = 0x80000000
	// Bit HSPOL.
	LTDC_GCR_HSPOL = 0x80000000
	// Horizontal synchronization polarity is active low
	LTDC_GCR_HSPOL_ActiveLow = 0x0
	// Horizontal synchronization polarity is active high
	LTDC_GCR_HSPOL_ActiveHigh = 0x1
	// Position of VSPOL field.
	LTDC_GCR_VSPOL_Pos = 0x1e
	// Bit mask of VSPOL field.
	LTDC_GCR_VSPOL_Msk = 0x40000000
	// Bit VSPOL.
	LTDC_GCR_VSPOL = 0x40000000
	// Vertical synchronization polarity is active low
	LTDC_GCR_VSPOL_ActiveLow = 0x0
	// Vertical synchronization polarity is active high
	LTDC_GCR_VSPOL_ActiveHigh = 0x1
	// Position of DEPOL field.
	LTDC_GCR_DEPOL_Pos = 0x1d
	// Bit mask of DEPOL field.
	LTDC_GCR_DEPOL_Msk = 0x20000000
	// Bit DEPOL.
	LTDC_GCR_DEPOL = 0x20000000
	// Data enable polarity is active low
	LTDC_GCR_DEPOL_ActiveLow = 0x0
	// Data enable polarity is active high
	LTDC_GCR_DEPOL_ActiveHigh = 0x1
	// Position of PCPOL field.
	LTDC_GCR_PCPOL_Pos = 0x1c
	// Bit mask of PCPOL field.
	LTDC_GCR_PCPOL_Msk = 0x10000000
	// Bit PCPOL.
	LTDC_GCR_PCPOL = 0x10000000
	// Pixel clock on rising edge
	LTDC_GCR_PCPOL_RisingEdge = 0x0
	// Pixel clock on falling edge
	LTDC_GCR_PCPOL_FallingEdge = 0x1
	// Position of DEN field.
	LTDC_GCR_DEN_Pos = 0x10
	// Bit mask of DEN field.
	LTDC_GCR_DEN_Msk = 0x10000
	// Bit DEN.
	LTDC_GCR_DEN = 0x10000
	// Dither disabled
	LTDC_GCR_DEN_Disabled = 0x0
	// Dither enabled
	LTDC_GCR_DEN_Enabled = 0x1
	// Position of DRW field.
	LTDC_GCR_DRW_Pos = 0xc
	// Bit mask of DRW field.
	LTDC_GCR_DRW_Msk = 0x7000
	// Position of DGW field.
	LTDC_GCR_DGW_Pos = 0x8
	// Bit mask of DGW field.
	LTDC_GCR_DGW_Msk = 0x700
	// Position of DBW field.
	LTDC_GCR_DBW_Pos = 0x4
	// Bit mask of DBW field.
	LTDC_GCR_DBW_Msk = 0x70
	// Position of LTDCEN field.
	LTDC_GCR_LTDCEN_Pos = 0x0
	// Bit mask of LTDCEN field.
	LTDC_GCR_LTDCEN_Msk = 0x1
	// Bit LTDCEN.
	LTDC_GCR_LTDCEN = 0x1
	// LCD-TFT controller disabled
	LTDC_GCR_LTDCEN_Disabled = 0x0
	// LCD-TFT controller enabled
	LTDC_GCR_LTDCEN_Enabled = 0x1

	// SRCR: Shadow Reload Configuration Register
	// Position of VBR field.
	LTDC_SRCR_VBR_Pos = 0x1
	// Bit mask of VBR field.
	LTDC_SRCR_VBR_Msk = 0x2
	// Bit VBR.
	LTDC_SRCR_VBR = 0x2
	// The shadow registers are reloaded during the vertical blanking period (at the beginning of the first line after the active display area).
	LTDC_SRCR_VBR_Reload = 0x1
	// This bit is set by software and cleared only by hardware after reload (it cannot be cleared through register write once it is set)
	LTDC_SRCR_VBR_NoEffect = 0x0
	// Position of IMR field.
	LTDC_SRCR_IMR_Pos = 0x0
	// Bit mask of IMR field.
	LTDC_SRCR_IMR_Msk = 0x1
	// Bit IMR.
	LTDC_SRCR_IMR = 0x1
	// The shadow registers are reloaded immediately. This bit is set by software and cleared only by hardware after reload
	LTDC_SRCR_IMR_Reload = 0x1
	// This bit is set by software and cleared only by hardware after reload (it cannot be cleared through register write once it is set)
	LTDC_SRCR_IMR_NoEffect = 0x0

	// BCCR: Background Color Configuration Register
	// Position of BCBLUE field.
	LTDC_BCCR_BCBLUE_Pos = 0x0
	// Bit mask of BCBLUE field.
	LTDC_BCCR_BCBLUE_Msk = 0xff
	// Position of BCGREEN field.
	LTDC_BCCR_BCGREEN_Pos = 0x8
	// Bit mask of BCGREEN field.
	LTDC_BCCR_BCGREEN_Msk = 0xff00
	// Position of BCRED field.
	LTDC_BCCR_BCRED_Pos = 0x10
	// Bit mask of BCRED field.
	LTDC_BCCR_BCRED_Msk = 0xff0000

	// IER: Interrupt Enable Register
	// Position of RRIE field.
	LTDC_IER_RRIE_Pos = 0x3
	// Bit mask of RRIE field.
	LTDC_IER_RRIE_Msk = 0x8
	// Bit RRIE.
	LTDC_IER_RRIE = 0x8
	// Register reload interrupt disabled
	LTDC_IER_RRIE_Disabled = 0x0
	// Register reload interrupt enabled
	LTDC_IER_RRIE_Enabled = 0x1
	// Position of TERRIE field.
	LTDC_IER_TERRIE_Pos = 0x2
	// Bit mask of TERRIE field.
	LTDC_IER_TERRIE_Msk = 0x4
	// Bit TERRIE.
	LTDC_IER_TERRIE = 0x4
	// Transfer error interrupt disabled
	LTDC_IER_TERRIE_Disabled = 0x0
	// Transfer error interrupt enabled
	LTDC_IER_TERRIE_Enabled = 0x1
	// Position of FUIE field.
	LTDC_IER_FUIE_Pos = 0x1
	// Bit mask of FUIE field.
	LTDC_IER_FUIE_Msk = 0x2
	// Bit FUIE.
	LTDC_IER_FUIE = 0x2
	// FIFO underrun interrupt disabled
	LTDC_IER_FUIE_Disabled = 0x0
	// FIFO underrun interrupt enabled
	LTDC_IER_FUIE_Enabled = 0x1
	// Position of LIE field.
	LTDC_IER_LIE_Pos = 0x0
	// Bit mask of LIE field.
	LTDC_IER_LIE_Msk = 0x1
	// Bit LIE.
	LTDC_IER_LIE = 0x1
	// Line interrupt disabled
	LTDC_IER_LIE_Disabled = 0x0
	// Line interrupt enabled
	LTDC_IER_LIE_Enabled = 0x1

	// ISR: Interrupt Status Register
	// Position of RRIF field.
	LTDC_ISR_RRIF_Pos = 0x3
	// Bit mask of RRIF field.
	LTDC_ISR_RRIF_Msk = 0x8
	// Bit RRIF.
	LTDC_ISR_RRIF = 0x8
	// No register reload
	LTDC_ISR_RRIF_NoReload = 0x0
	// Register reload interrupt generated when a vertical blanking reload occurs (and the first line after the active area is reached)
	LTDC_ISR_RRIF_Reload = 0x1
	// Position of TERRIF field.
	LTDC_ISR_TERRIF_Pos = 0x2
	// Bit mask of TERRIF field.
	LTDC_ISR_TERRIF_Msk = 0x4
	// Bit TERRIF.
	LTDC_ISR_TERRIF = 0x4
	// No transfer error
	LTDC_ISR_TERRIF_NoError = 0x0
	// Transfer error interrupt generated when a bus error occurs
	LTDC_ISR_TERRIF_Error = 0x1
	// Position of FUIF field.
	LTDC_ISR_FUIF_Pos = 0x1
	// Bit mask of FUIF field.
	LTDC_ISR_FUIF_Msk = 0x2
	// Bit FUIF.
	LTDC_ISR_FUIF = 0x2
	// No FIFO underrun
	LTDC_ISR_FUIF_NoUnderrun = 0x0
	// FIFO underrun interrupt generated, if one of the layer FIFOs is empty and pixel data is read from the FIFO
	LTDC_ISR_FUIF_Underrun = 0x1
	// Position of LIF field.
	LTDC_ISR_LIF_Pos = 0x0
	// Bit mask of LIF field.
	LTDC_ISR_LIF_Msk = 0x1
	// Bit LIF.
	LTDC_ISR_LIF = 0x1
	// Programmed line not reached
	LTDC_ISR_LIF_NotReached = 0x0
	// Line interrupt generated when a programmed line is reached
	LTDC_ISR_LIF_Reached = 0x1

	// ICR: Interrupt Clear Register
	// Position of CRRIF field.
	LTDC_ICR_CRRIF_Pos = 0x3
	// Bit mask of CRRIF field.
	LTDC_ICR_CRRIF_Msk = 0x8
	// Bit CRRIF.
	LTDC_ICR_CRRIF = 0x8
	// Clears the RRIF flag in the ISR register
	LTDC_ICR_CRRIF_Clear = 0x1
	// Position of CTERRIF field.
	LTDC_ICR_CTERRIF_Pos = 0x2
	// Bit mask of CTERRIF field.
	LTDC_ICR_CTERRIF_Msk = 0x4
	// Bit CTERRIF.
	LTDC_ICR_CTERRIF = 0x4
	// Clears the TERRIF flag in the ISR register
	LTDC_ICR_CTERRIF_Clear = 0x1
	// Position of CFUIF field.
	LTDC_ICR_CFUIF_Pos = 0x1
	// Bit mask of CFUIF field.
	LTDC_ICR_CFUIF_Msk = 0x2
	// Bit CFUIF.
	LTDC_ICR_CFUIF = 0x2
	// Clears the FUIF flag in the ISR register
	LTDC_ICR_CFUIF_Clear = 0x1
	// Position of CLIF field.
	LTDC_ICR_CLIF_Pos = 0x0
	// Bit mask of CLIF field.
	LTDC_ICR_CLIF_Msk = 0x1
	// Bit CLIF.
	LTDC_ICR_CLIF = 0x1
	// Clears the LIF flag in the ISR register
	LTDC_ICR_CLIF_Clear = 0x1

	// LIPCR: Line Interrupt Position Configuration Register
	// Position of LIPOS field.
	LTDC_LIPCR_LIPOS_Pos = 0x0
	// Bit mask of LIPOS field.
	LTDC_LIPCR_LIPOS_Msk = 0x7ff

	// CPSR: Current Position Status Register
	// Position of CXPOS field.
	LTDC_CPSR_CXPOS_Pos = 0x10
	// Bit mask of CXPOS field.
	LTDC_CPSR_CXPOS_Msk = 0xffff0000
	// Position of CYPOS field.
	LTDC_CPSR_CYPOS_Pos = 0x0
	// Bit mask of CYPOS field.
	LTDC_CPSR_CYPOS_Msk = 0xffff

	// CDSR: Current Display Status Register
	// Position of HSYNCS field.
	LTDC_CDSR_HSYNCS_Pos = 0x3
	// Bit mask of HSYNCS field.
	LTDC_CDSR_HSYNCS_Msk = 0x8
	// Bit HSYNCS.
	LTDC_CDSR_HSYNCS = 0x8
	// Currently not in HSYNC phase
	LTDC_CDSR_HSYNCS_NotActive = 0x0
	// Currently in HSYNC phase
	LTDC_CDSR_HSYNCS_Active = 0x1
	// Position of VSYNCS field.
	LTDC_CDSR_VSYNCS_Pos = 0x2
	// Bit mask of VSYNCS field.
	LTDC_CDSR_VSYNCS_Msk = 0x4
	// Bit VSYNCS.
	LTDC_CDSR_VSYNCS = 0x4
	// Currently not in VSYNC phase
	LTDC_CDSR_VSYNCS_NotActive = 0x0
	// Currently in VSYNC phase
	LTDC_CDSR_VSYNCS_Active = 0x1
	// Position of HDES field.
	LTDC_CDSR_HDES_Pos = 0x1
	// Bit mask of HDES field.
	LTDC_CDSR_HDES_Msk = 0x2
	// Bit HDES.
	LTDC_CDSR_HDES = 0x2
	// Currently not in horizontal Data Enable phase
	LTDC_CDSR_HDES_NotActive = 0x0
	// Currently in horizontal Data Enable phase
	LTDC_CDSR_HDES_Active = 0x1
	// Position of VDES field.
	LTDC_CDSR_VDES_Pos = 0x0
	// Bit mask of VDES field.
	LTDC_CDSR_VDES_Msk = 0x1
	// Bit VDES.
	LTDC_CDSR_VDES = 0x1
	// Currently not in vertical Data Enable phase
	LTDC_CDSR_VDES_NotActive = 0x0
	// Currently in vertical Data Enable phase
	LTDC_CDSR_VDES_Active = 0x1

	// LAYER.CR: Layerx Control Register
	// Position of CLUTEN field.
	LTDC_LAYER_CR_CLUTEN_Pos = 0x4
	// Bit mask of CLUTEN field.
	LTDC_LAYER_CR_CLUTEN_Msk = 0x10
	// Bit CLUTEN.
	LTDC_LAYER_CR_CLUTEN = 0x10
	// Color look-up table disabled
	LTDC_LAYER_CR_CLUTEN_Disabled = 0x0
	// Color look-up table enabled
	LTDC_LAYER_CR_CLUTEN_Enabled = 0x1
	// Position of COLKEN field.
	LTDC_LAYER_CR_COLKEN_Pos = 0x1
	// Bit mask of COLKEN field.
	LTDC_LAYER_CR_COLKEN_Msk = 0x2
	// Bit COLKEN.
	LTDC_LAYER_CR_COLKEN = 0x2
	// Color keying disabled
	LTDC_LAYER_CR_COLKEN_Disabled = 0x0
	// Color keying enabled
	LTDC_LAYER_CR_COLKEN_Enabled = 0x1
	// Position of LEN field.
	LTDC_LAYER_CR_LEN_Pos = 0x0
	// Bit mask of LEN field.
	LTDC_LAYER_CR_LEN_Msk = 0x1
	// Bit LEN.
	LTDC_LAYER_CR_LEN = 0x1
	// Layer disabled
	LTDC_LAYER_CR_LEN_Disabled = 0x0
	// Layer enabled
	LTDC_LAYER_CR_LEN_Enabled = 0x1

	// LAYER.WHPCR: Layerx Window Horizontal Position Configuration Register
	// Position of WHSPPOS field.
	LTDC_LAYER_WHPCR_WHSPPOS_Pos = 0x10
	// Bit mask of WHSPPOS field.
	LTDC_LAYER_WHPCR_WHSPPOS_Msk = 0xfff0000
	// Position of WHSTPOS field.
	LTDC_LAYER_WHPCR_WHSTPOS_Pos = 0x0
	// Bit mask of WHSTPOS field.
	LTDC_LAYER_WHPCR_WHSTPOS_Msk = 0xfff

	// LAYER.WVPCR: Layerx Window Vertical Position Configuration Register
	// Position of WVSPPOS field.
	LTDC_LAYER_WVPCR_WVSPPOS_Pos = 0x10
	// Bit mask of WVSPPOS field.
	LTDC_LAYER_WVPCR_WVSPPOS_Msk = 0x7ff0000
	// Position of WVSTPOS field.
	LTDC_LAYER_WVPCR_WVSTPOS_Pos = 0x0
	// Bit mask of WVSTPOS field.
	LTDC_LAYER_WVPCR_WVSTPOS_Msk = 0x7ff

	// LAYER.CKCR: Layerx Color Keying Configuration Register
	// Position of CKRED field.
	LTDC_LAYER_CKCR_CKRED_Pos = 0x10
	// Bit mask of CKRED field.
	LTDC_LAYER_CKCR_CKRED_Msk = 0xff0000
	// Position of CKGREEN field.
	LTDC_LAYER_CKCR_CKGREEN_Pos = 0x8
	// Bit mask of CKGREEN field.
	LTDC_LAYER_CKCR_CKGREEN_Msk = 0xff00
	// Position of CKBLUE field.
	LTDC_LAYER_CKCR_CKBLUE_Pos = 0x0
	// Bit mask of CKBLUE field.
	LTDC_LAYER_CKCR_CKBLUE_Msk = 0xff

	// LAYER.PFCR: Layerx Pixel Format Configuration Register
	// Position of PF field.
	LTDC_LAYER_PFCR_PF_Pos = 0x0
	// Bit mask of PF field.
	LTDC_LAYER_PFCR_PF_Msk = 0x7
	// ARGB8888
	LTDC_LAYER_PFCR_PF_ARGB8888 = 0x0
	// RGB888
	LTDC_LAYER_PFCR_PF_RGB888 = 0x1
	// RGB565
	LTDC_LAYER_PFCR_PF_RGB565 = 0x2
	// ARGB1555
	LTDC_LAYER_PFCR_PF_ARGB1555 = 0x3
	// ARGB4444
	LTDC_LAYER_PFCR_PF_ARGB4444 = 0x4
	// L8 (8-bit luminance)
	LTDC_LAYER_PFCR_PF_L8 = 0x5
	// AL44 (4-bit alpha, 4-bit luminance)
	LTDC_LAYER_PFCR_PF_AL44 = 0x6
	// AL88 (8-bit alpha, 8-bit luminance)
	LTDC_LAYER_PFCR_PF_AL88 = 0x7

	// LAYER.CACR: Layerx Constant Alpha Configuration Register
	// Position of CONSTA field.
	LTDC_LAYER_CACR_CONSTA_Pos = 0x0
	// Bit mask of CONSTA field.
	LTDC_LAYER_CACR_CONSTA_Msk = 0xff

	// LAYER.DCCR: Layerx Default Color Configuration Register
	// Position of DCALPHA field.
	LTDC_LAYER_DCCR_DCALPHA_Pos = 0x18
	// Bit mask of DCALPHA field.
	LTDC_LAYER_DCCR_DCALPHA_Msk = 0xff000000
	// Position of DCRED field.
	LTDC_LAYER_DCCR_DCRED_Pos = 0x10
	// Bit mask of DCRED field.
	LTDC_LAYER_DCCR_DCRED_Msk = 0xff0000
	// Position of DCGREEN field.
	LTDC_LAYER_DCCR_DCGREEN_Pos = 0x8
	// Bit mask of DCGREEN field.
	LTDC_LAYER_DCCR_DCGREEN_Msk = 0xff00
	// Position of DCBLUE field.
	LTDC_LAYER_DCCR_DCBLUE_Pos = 0x0
	// Bit mask of DCBLUE field.
	LTDC_LAYER_DCCR_DCBLUE_Msk = 0xff

	// LAYER.BFCR: Layerx Blending Factors Configuration Register
	// Position of BF1 field.
	LTDC_LAYER_BFCR_BF1_Pos = 0x8
	// Bit mask of BF1 field.
	LTDC_LAYER_BFCR_BF1_Msk = 0x700
	// BF1 = constant alpha
	LTDC_LAYER_BFCR_BF1_Constant = 0x4
	// BF1 = pixel alpha * constant alpha
	LTDC_LAYER_BFCR_BF1_Pixel = 0x6
	// Position of BF2 field.
	LTDC_LAYER_BFCR_BF2_Pos = 0x0
	// Bit mask of BF2 field.
	LTDC_LAYER_BFCR_BF2_Msk = 0x7
	// BF2 = 1 - constant alpha
	LTDC_LAYER_BFCR_BF2_Constant = 0x5
	// BF2 = 1 - pixel alpha * constant alpha
	LTDC_LAYER_BFCR_BF2_Pixel = 0x7

	// LAYER.CFBAR: Layerx Color Frame Buffer Address Register
	// Position of CFBADD field.
	LTDC_LAYER_CFBAR_CFBADD_Pos = 0x0
	// Bit mask of CFBADD field.
	LTDC_LAYER_CFBAR_CFBADD_Msk = 0xffffffff

	// LAYER.CFBLR: Layerx Color Frame Buffer Length Register
	// Position of CFBP field.
	LTDC_LAYER_CFBLR_CFBP_Pos = 0x10
	// Bit mask of CFBP field.
	LTDC_LAYER_CFBLR_CFBP_Msk = 0x1fff0000
	// Position of CFBLL field.
	LTDC_LAYER_CFBLR_CFBLL_Pos = 0x0
	// Bit mask of CFBLL field.
	LTDC_LAYER_CFBLR_CFBLL_Msk = 0x1fff

	// LAYER.CFBLNR: Layerx ColorFrame Buffer Line Number Register
	// Position of CFBLNBR field.
	LTDC_LAYER_CFBLNR_CFBLNBR_Pos = 0x0
	// Bit mask of CFBLNBR field.
	LTDC_LAYER_CFBLNR_CFBLNBR_Msk = 0x7ff

	// LAYER.CLUTWR: Layerx CLUT Write Register
	// Position of CLUTADD field.
	LTDC_LAYER_CLUTWR_CLUTADD_Pos = 0x18
	// Bit mask of CLUTADD field.
	LTDC_LAYER_CLUTWR_CLUTADD_Msk = 0xff000000
	// Position of RED field.
	LTDC_LAYER_CLUTWR_RED_Pos = 0x10
	// Bit mask of RED field.
	LTDC_LAYER_CLUTWR_RED_Msk = 0xff0000
	// Position of GREEN field.
	LTDC_LAYER_CLUTWR_GREEN_Pos = 0x8
	// Bit mask of GREEN field.
	LTDC_LAYER_CLUTWR_GREEN_Msk = 0xff00
	// Position of BLUE field.
	LTDC_LAYER_CLUTWR_BLUE_Pos = 0x0
	// Bit mask of BLUE field.
	LTDC_LAYER_CLUTWR_BLUE_Msk = 0xff
)

// Constants for SAI1: Serial audio interface
const (
	// GCR: Global configuration register
	// Position of SYNCIN field.
	SAI_GCR_SYNCIN_Pos = 0x0
	// Bit mask of SYNCIN field.
	SAI_GCR_SYNCIN_Msk = 0x3
	// Position of SYNCOUT field.
	SAI_GCR_SYNCOUT_Pos = 0x4
	// Bit mask of SYNCOUT field.
	SAI_GCR_SYNCOUT_Msk = 0x30

	// CH.CR1: AConfiguration register 1
	// Position of MCKDIV field.
	SAI_CH_CR1_MCKDIV_Pos = 0x14
	// Bit mask of MCKDIV field.
	SAI_CH_CR1_MCKDIV_Msk = 0xf00000
	// Position of NODIV field.
	SAI_CH_CR1_NODIV_Pos = 0x13
	// Bit mask of NODIV field.
	SAI_CH_CR1_NODIV_Msk = 0x80000
	// Bit NODIV.
	SAI_CH_CR1_NODIV = 0x80000
	// MCLK output is enabled. Forces the ratio between FS and MCLK to 256 or 512 according to the OSR value
	SAI_CH_CR1_NODIV_MasterClock = 0x0
	// MCLK output enable set by the MCKEN bit (where present, else 0). Ratio between FS and MCLK depends on FRL.
	SAI_CH_CR1_NODIV_NoDiv = 0x1
	// Position of DMAEN field.
	SAI_CH_CR1_DMAEN_Pos = 0x11
	// Bit mask of DMAEN field.
	SAI_CH_CR1_DMAEN_Msk = 0x20000
	// Bit DMAEN.
	SAI_CH_CR1_DMAEN = 0x20000
	// DMA disabled
	SAI_CH_CR1_DMAEN_Disabled = 0x0
	// DMA enabled
	SAI_CH_CR1_DMAEN_Enabled = 0x1
	// Position of SAIEN field.
	SAI_CH_CR1_SAIEN_Pos = 0x10
	// Bit mask of SAIEN field.
	SAI_CH_CR1_SAIEN_Msk = 0x10000
	// Bit SAIEN.
	SAI_CH_CR1_SAIEN = 0x10000
	// SAI audio block disabled
	SAI_CH_CR1_SAIEN_Disabled = 0x0
	// SAI audio block enabled
	SAI_CH_CR1_SAIEN_Enabled = 0x1
	// Position of OUTDRIV field.
	SAI_CH_CR1_OUTDRIV_Pos = 0xd
	// Bit mask of OUTDRIV field.
	SAI_CH_CR1_OUTDRIV_Msk = 0x2000
	// Bit OUTDRIV.
	SAI_CH_CR1_OUTDRIV = 0x2000
	// Audio block output driven when SAIEN is set
	SAI_CH_CR1_OUTDRIV_OnStart = 0x0
	// Audio block output driven immediately after the setting of this bit
	SAI_CH_CR1_OUTDRIV_Immediately = 0x1
	// Position of MONO field.
	SAI_CH_CR1_MONO_Pos = 0xc
	// Bit mask of MONO field.
	SAI_CH_CR1_MONO_Msk = 0x1000
	// Bit MONO.
	SAI_CH_CR1_MONO = 0x1000
	// Stereo mode
	SAI_CH_CR1_MONO_Stereo = 0x0
	// Mono mode
	SAI_CH_CR1_MONO_Mono = 0x1
	// Position of SYNCEN field.
	SAI_CH_CR1_SYNCEN_Pos = 0xa
	// Bit mask of SYNCEN field.
	SAI_CH_CR1_SYNCEN_Msk = 0xc00
	// audio sub-block in asynchronous mode
	SAI_CH_CR1_SYNCEN_Asynchronous = 0x0
	// audio sub-block is synchronous with the other internal audio sub-block. In this case, the audio sub-block must be configured in slave mode
	SAI_CH_CR1_SYNCEN_Internal = 0x1
	// audio sub-block is synchronous with an external SAI embedded peripheral. In this case the audio sub-block should be configured in Slave mode
	SAI_CH_CR1_SYNCEN_External = 0x2
	// Position of CKSTR field.
	SAI_CH_CR1_CKSTR_Pos = 0x9
	// Bit mask of CKSTR field.
	SAI_CH_CR1_CKSTR_Msk = 0x200
	// Bit CKSTR.
	SAI_CH_CR1_CKSTR = 0x200
	// Data strobing edge is falling edge of SCK
	SAI_CH_CR1_CKSTR_FallingEdge = 0x0
	// Data strobing edge is rising edge of SCK
	SAI_CH_CR1_CKSTR_RisingEdge = 0x1
	// Position of LSBFIRST field.
	SAI_CH_CR1_LSBFIRST_Pos = 0x8
	// Bit mask of LSBFIRST field.
	SAI_CH_CR1_LSBFIRST_Msk = 0x100
	// Bit LSBFIRST.
	SAI_CH_CR1_LSBFIRST = 0x100
	// Data are transferred with MSB first
	SAI_CH_CR1_LSBFIRST_MsbFirst = 0x0
	// Data are transferred with LSB first
	SAI_CH_CR1_LSBFIRST_LsbFirst = 0x1
	// Position of DS field.
	SAI_CH_CR1_DS_Pos = 0x5
	// Bit mask of DS field.
	SAI_CH_CR1_DS_Msk = 0xe0
	// 8 bits
	SAI_CH_CR1_DS_Bit8 = 0x2
	// 10 bits
	SAI_CH_CR1_DS_Bit10 = 0x3
	// 16 bits
	SAI_CH_CR1_DS_Bit16 = 0x4
	// 20 bits
	SAI_CH_CR1_DS_Bit20 = 0x5
	// 24 bits
	SAI_CH_CR1_DS_Bit24 = 0x6
	// 32 bits
	SAI_CH_CR1_DS_Bit32 = 0x7
	// Position of PRTCFG field.
	SAI_CH_CR1_PRTCFG_Pos = 0x2
	// Bit mask of PRTCFG field.
	SAI_CH_CR1_PRTCFG_Msk = 0xc
	// Free protocol. Free protocol allows to use the powerful configuration of the audio block to address a specific audio protocol
	SAI_CH_CR1_PRTCFG_Free = 0x0
	// SPDIF protocol
	SAI_CH_CR1_PRTCFG_Spdif = 0x1
	// AC97 protocol
	SAI_CH_CR1_PRTCFG_Ac97 = 0x2
	// Position of MODE field.
	SAI_CH_CR1_MODE_Pos = 0x0
	// Bit mask of MODE field.
	SAI_CH_CR1_MODE_Msk = 0x3
	// Master transmitter
	SAI_CH_CR1_MODE_MasterTx = 0x0
	// Master receiver
	SAI_CH_CR1_MODE_MasterRx = 0x1
	// Slave transmitter
	SAI_CH_CR1_MODE_SlaveTx = 0x2
	// Slave receiver
	SAI_CH_CR1_MODE_SlaveRx = 0x3

	// CH.CR2: AConfiguration register 2
	// Position of COMP field.
	SAI_CH_CR2_COMP_Pos = 0xe
	// Bit mask of COMP field.
	SAI_CH_CR2_COMP_Msk = 0xc000
	// No companding algorithm
	SAI_CH_CR2_COMP_NoCompanding = 0x0
	// -Law algorithm
	SAI_CH_CR2_COMP_MuLaw = 0x2
	// A-Law algorithm
	SAI_CH_CR2_COMP_ALaw = 0x3
	// Position of CPL field.
	SAI_CH_CR2_CPL_Pos = 0xd
	// Bit mask of CPL field.
	SAI_CH_CR2_CPL_Msk = 0x2000
	// Bit CPL.
	SAI_CH_CR2_CPL = 0x2000
	// 1s complement representation
	SAI_CH_CR2_CPL_OnesComplement = 0x0
	// 2s complement representation
	SAI_CH_CR2_CPL_TwosComplement = 0x1
	// Position of MUTECN field.
	SAI_CH_CR2_MUTECN_Pos = 0x7
	// Bit mask of MUTECN field.
	SAI_CH_CR2_MUTECN_Msk = 0x1f80
	// Position of MUTEVAL field.
	SAI_CH_CR2_MUTEVAL_Pos = 0x6
	// Bit mask of MUTEVAL field.
	SAI_CH_CR2_MUTEVAL_Msk = 0x40
	// Bit MUTEVAL.
	SAI_CH_CR2_MUTEVAL = 0x40
	// Bit value 0 is sent during the mute mode
	SAI_CH_CR2_MUTEVAL_SendZero = 0x0
	// Last values are sent during the mute mode
	SAI_CH_CR2_MUTEVAL_SendLast = 0x1
	// Position of MUTE field.
	SAI_CH_CR2_MUTE_Pos = 0x5
	// Bit mask of MUTE field.
	SAI_CH_CR2_MUTE_Msk = 0x20
	// Bit MUTE.
	SAI_CH_CR2_MUTE = 0x20
	// No mute mode
	SAI_CH_CR2_MUTE_Disabled = 0x0
	// Mute mode enabled
	SAI_CH_CR2_MUTE_Enabled = 0x1
	// Position of TRIS field.
	SAI_CH_CR2_TRIS_Pos = 0x4
	// Bit mask of TRIS field.
	SAI_CH_CR2_TRIS_Msk = 0x10
	// Bit TRIS.
	SAI_CH_CR2_TRIS = 0x10
	// Position of FFLUSH field.
	SAI_CH_CR2_FFLUSH_Pos = 0x3
	// Bit mask of FFLUSH field.
	SAI_CH_CR2_FFLUSH_Msk = 0x8
	// Bit FFLUSH.
	SAI_CH_CR2_FFLUSH = 0x8
	// No FIFO flush
	SAI_CH_CR2_FFLUSH_NoFlush = 0x0
	// FIFO flush. Programming this bit to 1 triggers the FIFO Flush. All the internal FIFO pointers (read and write) are cleared
	SAI_CH_CR2_FFLUSH_Flush = 0x1
	// Position of FTH field.
	SAI_CH_CR2_FTH_Pos = 0x0
	// Bit mask of FTH field.
	SAI_CH_CR2_FTH_Msk = 0x7
	// FIFO empty
	SAI_CH_CR2_FTH_Empty = 0x0
	// 14 FIFO
	SAI_CH_CR2_FTH_Quarter1 = 0x1
	// 12 FIFO
	SAI_CH_CR2_FTH_Quarter2 = 0x2
	// 34 FIFO
	SAI_CH_CR2_FTH_Quarter3 = 0x3
	// FIFO full
	SAI_CH_CR2_FTH_Full = 0x4

	// CH.FRCR: AFRCR
	// Position of FSOFF field.
	SAI_CH_FRCR_FSOFF_Pos = 0x12
	// Bit mask of FSOFF field.
	SAI_CH_FRCR_FSOFF_Msk = 0x40000
	// Bit FSOFF.
	SAI_CH_FRCR_FSOFF = 0x40000
	// FS is asserted on the first bit of the slot 0
	SAI_CH_FRCR_FSOFF_OnFirst = 0x0
	// FS is asserted one bit before the first bit of the slot 0
	SAI_CH_FRCR_FSOFF_BeforeFirst = 0x1
	// Position of FSPOL field.
	SAI_CH_FRCR_FSPOL_Pos = 0x11
	// Bit mask of FSPOL field.
	SAI_CH_FRCR_FSPOL_Msk = 0x20000
	// Bit FSPOL.
	SAI_CH_FRCR_FSPOL = 0x20000
	// FS is active low (falling edge)
	SAI_CH_FRCR_FSPOL_FallingEdge = 0x0
	// FS is active high (rising edge)
	SAI_CH_FRCR_FSPOL_RisingEdge = 0x1
	// Position of FSDEF field.
	SAI_CH_FRCR_FSDEF_Pos = 0x10
	// Bit mask of FSDEF field.
	SAI_CH_FRCR_FSDEF_Msk = 0x10000
	// Bit FSDEF.
	SAI_CH_FRCR_FSDEF = 0x10000
	// Position of FSALL field.
	SAI_CH_FRCR_FSALL_Pos = 0x8
	// Bit mask of FSALL field.
	SAI_CH_FRCR_FSALL_Msk = 0x7f00
	// Position of FRL field.
	SAI_CH_FRCR_FRL_Pos = 0x0
	// Bit mask of FRL field.
	SAI_CH_FRCR_FRL_Msk = 0xff

	// CH.SLOTR: ASlot register
	// Position of SLOTEN field.
	SAI_CH_SLOTR_SLOTEN_Pos = 0x10
	// Bit mask of SLOTEN field.
	SAI_CH_SLOTR_SLOTEN_Msk = 0xffff0000
	// Inactive slot
	SAI_CH_SLOTR_SLOTEN_Inactive = 0x0
	// Active slot
	SAI_CH_SLOTR_SLOTEN_Active = 0x1
	// Position of NBSLOT field.
	SAI_CH_SLOTR_NBSLOT_Pos = 0x8
	// Bit mask of NBSLOT field.
	SAI_CH_SLOTR_NBSLOT_Msk = 0xf00
	// Position of SLOTSZ field.
	SAI_CH_SLOTR_SLOTSZ_Pos = 0x6
	// Bit mask of SLOTSZ field.
	SAI_CH_SLOTR_SLOTSZ_Msk = 0xc0
	// The slot size is equivalent to the data size (specified in DS[3:0] in the SAI_xCR1 register)
	SAI_CH_SLOTR_SLOTSZ_DataSize = 0x0
	// 16-bit
	SAI_CH_SLOTR_SLOTSZ_Bit16 = 0x1
	// 32-bit
	SAI_CH_SLOTR_SLOTSZ_Bit32 = 0x2
	// Position of FBOFF field.
	SAI_CH_SLOTR_FBOFF_Pos = 0x0
	// Bit mask of FBOFF field.
	SAI_CH_SLOTR_FBOFF_Msk = 0x1f

	// CH.IM: AInterrupt mask register2
	// Position of LFSDETIE field.
	SAI_CH_IM_LFSDETIE_Pos = 0x6
	// Bit mask of LFSDETIE field.
	SAI_CH_IM_LFSDETIE_Msk = 0x40
	// Bit LFSDETIE.
	SAI_CH_IM_LFSDETIE = 0x40
	// Interrupt is disabled
	SAI_CH_IM_LFSDETIE_Disabled = 0x0
	// Interrupt is enabled
	SAI_CH_IM_LFSDETIE_Enabled = 0x1
	// Position of AFSDETIE field.
	SAI_CH_IM_AFSDETIE_Pos = 0x5
	// Bit mask of AFSDETIE field.
	SAI_CH_IM_AFSDETIE_Msk = 0x20
	// Bit AFSDETIE.
	SAI_CH_IM_AFSDETIE = 0x20
	// Interrupt is disabled
	SAI_CH_IM_AFSDETIE_Disabled = 0x0
	// Interrupt is enabled
	SAI_CH_IM_AFSDETIE_Enabled = 0x1
	// Position of CNRDYIE field.
	SAI_CH_IM_CNRDYIE_Pos = 0x4
	// Bit mask of CNRDYIE field.
	SAI_CH_IM_CNRDYIE_Msk = 0x10
	// Bit CNRDYIE.
	SAI_CH_IM_CNRDYIE = 0x10
	// Interrupt is disabled
	SAI_CH_IM_CNRDYIE_Disabled = 0x0
	// Interrupt is enabled
	SAI_CH_IM_CNRDYIE_Enabled = 0x1
	// Position of FREQIE field.
	SAI_CH_IM_FREQIE_Pos = 0x3
	// Bit mask of FREQIE field.
	SAI_CH_IM_FREQIE_Msk = 0x8
	// Bit FREQIE.
	SAI_CH_IM_FREQIE = 0x8
	// Interrupt is disabled
	SAI_CH_IM_FREQIE_Disabled = 0x0
	// Interrupt is enabled
	SAI_CH_IM_FREQIE_Enabled = 0x1
	// Position of WCKCFGIE field.
	SAI_CH_IM_WCKCFGIE_Pos = 0x2
	// Bit mask of WCKCFGIE field.
	SAI_CH_IM_WCKCFGIE_Msk = 0x4
	// Bit WCKCFGIE.
	SAI_CH_IM_WCKCFGIE = 0x4
	// Interrupt is disabled
	SAI_CH_IM_WCKCFGIE_Disabled = 0x0
	// Interrupt is enabled
	SAI_CH_IM_WCKCFGIE_Enabled = 0x1
	// Position of MUTEDETIE field.
	SAI_CH_IM_MUTEDETIE_Pos = 0x1
	// Bit mask of MUTEDETIE field.
	SAI_CH_IM_MUTEDETIE_Msk = 0x2
	// Bit MUTEDETIE.
	SAI_CH_IM_MUTEDETIE = 0x2
	// Interrupt is disabled
	SAI_CH_IM_MUTEDETIE_Disabled = 0x0
	// Interrupt is enabled
	SAI_CH_IM_MUTEDETIE_Enabled = 0x1
	// Position of OVRUDRIE field.
	SAI_CH_IM_OVRUDRIE_Pos = 0x0
	// Bit mask of OVRUDRIE field.
	SAI_CH_IM_OVRUDRIE_Msk = 0x1
	// Bit OVRUDRIE.
	SAI_CH_IM_OVRUDRIE = 0x1
	// Interrupt is disabled
	SAI_CH_IM_OVRUDRIE_Disabled = 0x0
	// Interrupt is enabled
	SAI_CH_IM_OVRUDRIE_Enabled = 0x1

	// CH.SR: AStatus register
	// Position of FLVL field.
	SAI_CH_SR_FLVL_Pos = 0x10
	// Bit mask of FLVL field.
	SAI_CH_SR_FLVL_Msk = 0x70000
	// FIFO empty
	SAI_CH_SR_FLVL_Empty = 0x0
	// FIFO <= 14 but not empty
	SAI_CH_SR_FLVL_Quarter1 = 0x1
	// 14 < FIFO <= 12
	SAI_CH_SR_FLVL_Quarter2 = 0x2
	// 12 < FIFO <= 34
	SAI_CH_SR_FLVL_Quarter3 = 0x3
	// 34 < FIFO but not full
	SAI_CH_SR_FLVL_Quarter4 = 0x4
	// FIFO full
	SAI_CH_SR_FLVL_Full = 0x5
	// Position of LFSDET field.
	SAI_CH_SR_LFSDET_Pos = 0x6
	// Bit mask of LFSDET field.
	SAI_CH_SR_LFSDET_Msk = 0x40
	// Bit LFSDET.
	SAI_CH_SR_LFSDET = 0x40
	// No error
	SAI_CH_SR_LFSDET_NoError = 0x0
	// Frame synchronization signal is not present at the right time
	SAI_CH_SR_LFSDET_NoSync = 0x1
	// Position of AFSDET field.
	SAI_CH_SR_AFSDET_Pos = 0x5
	// Bit mask of AFSDET field.
	SAI_CH_SR_AFSDET_Msk = 0x20
	// Bit AFSDET.
	SAI_CH_SR_AFSDET = 0x20
	// No error
	SAI_CH_SR_AFSDET_NoError = 0x0
	// Frame synchronization signal is detected earlier than expected
	SAI_CH_SR_AFSDET_EarlySync = 0x1
	// Position of CNRDY field.
	SAI_CH_SR_CNRDY_Pos = 0x4
	// Bit mask of CNRDY field.
	SAI_CH_SR_CNRDY_Msk = 0x10
	// Bit CNRDY.
	SAI_CH_SR_CNRDY = 0x10
	// External AC97 Codec is ready
	SAI_CH_SR_CNRDY_Ready = 0x0
	// External AC97 Codec is not ready
	SAI_CH_SR_CNRDY_NotReady = 0x1
	// Position of FREQ field.
	SAI_CH_SR_FREQ_Pos = 0x3
	// Bit mask of FREQ field.
	SAI_CH_SR_FREQ_Msk = 0x8
	// Bit FREQ.
	SAI_CH_SR_FREQ = 0x8
	// No FIFO request
	SAI_CH_SR_FREQ_NoRequest = 0x0
	// FIFO request to read or to write the SAI_xDR
	SAI_CH_SR_FREQ_Request = 0x1
	// Position of WCKCFG field.
	SAI_CH_SR_WCKCFG_Pos = 0x2
	// Bit mask of WCKCFG field.
	SAI_CH_SR_WCKCFG_Msk = 0x4
	// Bit WCKCFG.
	SAI_CH_SR_WCKCFG = 0x4
	// Clock configuration is correct
	SAI_CH_SR_WCKCFG_Correct = 0x0
	// Clock configuration does not respect the rule concerning the frame length specification
	SAI_CH_SR_WCKCFG_Wrong = 0x1
	// Position of MUTEDET field.
	SAI_CH_SR_MUTEDET_Pos = 0x1
	// Bit mask of MUTEDET field.
	SAI_CH_SR_MUTEDET_Msk = 0x2
	// Bit MUTEDET.
	SAI_CH_SR_MUTEDET = 0x2
	// No MUTE detection on the SD input line
	SAI_CH_SR_MUTEDET_NoMute = 0x0
	// MUTE value detected on the SD input line (0 value) for a specified number of consecutive audio frame
	SAI_CH_SR_MUTEDET_Mute = 0x1
	// Position of OVRUDR field.
	SAI_CH_SR_OVRUDR_Pos = 0x0
	// Bit mask of OVRUDR field.
	SAI_CH_SR_OVRUDR_Msk = 0x1
	// Bit OVRUDR.
	SAI_CH_SR_OVRUDR = 0x1
	// No overrun/underrun error
	SAI_CH_SR_OVRUDR_NoError = 0x0
	// Overrun/underrun error detection
	SAI_CH_SR_OVRUDR_Overrun = 0x1

	// CH.CLRFR: AClear flag register
	// Position of CLFSDET field.
	SAI_CH_CLRFR_CLFSDET_Pos = 0x6
	// Bit mask of CLFSDET field.
	SAI_CH_CLRFR_CLFSDET_Msk = 0x40
	// Bit CLFSDET.
	SAI_CH_CLRFR_CLFSDET = 0x40
	// Clears the LFSDET flag
	SAI_CH_CLRFR_CLFSDET_Clear = 0x1
	// Position of CAFSDET field.
	SAI_CH_CLRFR_CAFSDET_Pos = 0x5
	// Bit mask of CAFSDET field.
	SAI_CH_CLRFR_CAFSDET_Msk = 0x20
	// Bit CAFSDET.
	SAI_CH_CLRFR_CAFSDET = 0x20
	// Clears the AFSDET flag
	SAI_CH_CLRFR_CAFSDET_Clear = 0x1
	// Position of CCNRDY field.
	SAI_CH_CLRFR_CCNRDY_Pos = 0x4
	// Bit mask of CCNRDY field.
	SAI_CH_CLRFR_CCNRDY_Msk = 0x10
	// Bit CCNRDY.
	SAI_CH_CLRFR_CCNRDY = 0x10
	// Clears the CNRDY flag
	SAI_CH_CLRFR_CCNRDY_Clear = 0x1
	// Position of CWCKCFG field.
	SAI_CH_CLRFR_CWCKCFG_Pos = 0x2
	// Bit mask of CWCKCFG field.
	SAI_CH_CLRFR_CWCKCFG_Msk = 0x4
	// Bit CWCKCFG.
	SAI_CH_CLRFR_CWCKCFG = 0x4
	// Clears the WCKCFG flag
	SAI_CH_CLRFR_CWCKCFG_Clear = 0x1
	// Position of CMUTEDET field.
	SAI_CH_CLRFR_CMUTEDET_Pos = 0x1
	// Bit mask of CMUTEDET field.
	SAI_CH_CLRFR_CMUTEDET_Msk = 0x2
	// Bit CMUTEDET.
	SAI_CH_CLRFR_CMUTEDET = 0x2
	// Clears the MUTEDET flag
	SAI_CH_CLRFR_CMUTEDET_Clear = 0x1
	// Position of COVRUDR field.
	SAI_CH_CLRFR_COVRUDR_Pos = 0x0
	// Bit mask of COVRUDR field.
	SAI_CH_CLRFR_COVRUDR_Msk = 0x1
	// Bit COVRUDR.
	SAI_CH_CLRFR_COVRUDR = 0x1
	// Clears the OVRUDR flag
	SAI_CH_CLRFR_COVRUDR_Clear = 0x1

	// CH.DR: AData register
	// Position of DATA field.
	SAI_CH_DR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	SAI_CH_DR_DATA_Msk = 0xffffffff
)

// Constants for DMA2D: DMA2D controller
const (
	// CR: control register
	// Position of MODE field.
	DMA2D_CR_MODE_Pos = 0x10
	// Bit mask of MODE field.
	DMA2D_CR_MODE_Msk = 0x30000
	// Memory-to-memory (FG fetch only)
	DMA2D_CR_MODE_MemoryToMemory = 0x0
	// Memory-to-memory with PFC (FG fetch only with FG PFC active)
	DMA2D_CR_MODE_MemoryToMemoryPFC = 0x1
	// Memory-to-memory with blending (FG and BG fetch with PFC and blending)
	DMA2D_CR_MODE_MemoryToMemoryPFCBlending = 0x2
	// Register-to-memory
	DMA2D_CR_MODE_RegisterToMemory = 0x3
	// Position of CEIE field.
	DMA2D_CR_CEIE_Pos = 0xd
	// Bit mask of CEIE field.
	DMA2D_CR_CEIE_Msk = 0x2000
	// Bit CEIE.
	DMA2D_CR_CEIE = 0x2000
	// CE interrupt disabled
	DMA2D_CR_CEIE_Disabled = 0x0
	// CE interrupt enabled
	DMA2D_CR_CEIE_Enabled = 0x1
	// Position of CTCIE field.
	DMA2D_CR_CTCIE_Pos = 0xc
	// Bit mask of CTCIE field.
	DMA2D_CR_CTCIE_Msk = 0x1000
	// Bit CTCIE.
	DMA2D_CR_CTCIE = 0x1000
	// CTC interrupt disabled
	DMA2D_CR_CTCIE_Disabled = 0x0
	// CTC interrupt enabled
	DMA2D_CR_CTCIE_Enabled = 0x1
	// Position of CAEIE field.
	DMA2D_CR_CAEIE_Pos = 0xb
	// Bit mask of CAEIE field.
	DMA2D_CR_CAEIE_Msk = 0x800
	// Bit CAEIE.
	DMA2D_CR_CAEIE = 0x800
	// CAE interrupt disabled
	DMA2D_CR_CAEIE_Disabled = 0x0
	// CAE interrupt enabled
	DMA2D_CR_CAEIE_Enabled = 0x1
	// Position of TWIE field.
	DMA2D_CR_TWIE_Pos = 0xa
	// Bit mask of TWIE field.
	DMA2D_CR_TWIE_Msk = 0x400
	// Bit TWIE.
	DMA2D_CR_TWIE = 0x400
	// TW interrupt disabled
	DMA2D_CR_TWIE_Disabled = 0x0
	// TW interrupt enabled
	DMA2D_CR_TWIE_Enabled = 0x1
	// Position of TCIE field.
	DMA2D_CR_TCIE_Pos = 0x9
	// Bit mask of TCIE field.
	DMA2D_CR_TCIE_Msk = 0x200
	// Bit TCIE.
	DMA2D_CR_TCIE = 0x200
	// TC interrupt disabled
	DMA2D_CR_TCIE_Disabled = 0x0
	// TC interrupt enabled
	DMA2D_CR_TCIE_Enabled = 0x1
	// Position of TEIE field.
	DMA2D_CR_TEIE_Pos = 0x8
	// Bit mask of TEIE field.
	DMA2D_CR_TEIE_Msk = 0x100
	// Bit TEIE.
	DMA2D_CR_TEIE = 0x100
	// TE interrupt disabled
	DMA2D_CR_TEIE_Disabled = 0x0
	// TE interrupt enabled
	DMA2D_CR_TEIE_Enabled = 0x1
	// Position of ABORT field.
	DMA2D_CR_ABORT_Pos = 0x2
	// Bit mask of ABORT field.
	DMA2D_CR_ABORT_Msk = 0x4
	// Bit ABORT.
	DMA2D_CR_ABORT = 0x4
	// Transfer abort requested
	DMA2D_CR_ABORT_AbortRequest = 0x1
	// Position of SUSP field.
	DMA2D_CR_SUSP_Pos = 0x1
	// Bit mask of SUSP field.
	DMA2D_CR_SUSP_Msk = 0x2
	// Bit SUSP.
	DMA2D_CR_SUSP = 0x2
	// Transfer not suspended
	DMA2D_CR_SUSP_NotSuspended = 0x0
	// Transfer suspended
	DMA2D_CR_SUSP_Suspended = 0x1
	// Position of START field.
	DMA2D_CR_START_Pos = 0x0
	// Bit mask of START field.
	DMA2D_CR_START_Msk = 0x1
	// Bit START.
	DMA2D_CR_START = 0x1
	// Launch the DMA2D
	DMA2D_CR_START_Start = 0x1

	// ISR: Interrupt Status Register
	// Position of CEIF field.
	DMA2D_ISR_CEIF_Pos = 0x5
	// Bit mask of CEIF field.
	DMA2D_ISR_CEIF_Msk = 0x20
	// Bit CEIF.
	DMA2D_ISR_CEIF = 0x20
	// Position of CTCIF field.
	DMA2D_ISR_CTCIF_Pos = 0x4
	// Bit mask of CTCIF field.
	DMA2D_ISR_CTCIF_Msk = 0x10
	// Bit CTCIF.
	DMA2D_ISR_CTCIF = 0x10
	// Position of CAEIF field.
	DMA2D_ISR_CAEIF_Pos = 0x3
	// Bit mask of CAEIF field.
	DMA2D_ISR_CAEIF_Msk = 0x8
	// Bit CAEIF.
	DMA2D_ISR_CAEIF = 0x8
	// Position of TWIF field.
	DMA2D_ISR_TWIF_Pos = 0x2
	// Bit mask of TWIF field.
	DMA2D_ISR_TWIF_Msk = 0x4
	// Bit TWIF.
	DMA2D_ISR_TWIF = 0x4
	// Position of TCIF field.
	DMA2D_ISR_TCIF_Pos = 0x1
	// Bit mask of TCIF field.
	DMA2D_ISR_TCIF_Msk = 0x2
	// Bit TCIF.
	DMA2D_ISR_TCIF = 0x2
	// Position of TEIF field.
	DMA2D_ISR_TEIF_Pos = 0x0
	// Bit mask of TEIF field.
	DMA2D_ISR_TEIF_Msk = 0x1
	// Bit TEIF.
	DMA2D_ISR_TEIF = 0x1

	// IFCR: interrupt flag clear register
	// Position of CCEIF field.
	DMA2D_IFCR_CCEIF_Pos = 0x5
	// Bit mask of CCEIF field.
	DMA2D_IFCR_CCEIF_Msk = 0x20
	// Bit CCEIF.
	DMA2D_IFCR_CCEIF = 0x20
	// Clear the CEIF flag in the ISR register
	DMA2D_IFCR_CCEIF_Clear = 0x1
	// Position of CCTCIF field.
	DMA2D_IFCR_CCTCIF_Pos = 0x4
	// Bit mask of CCTCIF field.
	DMA2D_IFCR_CCTCIF_Msk = 0x10
	// Bit CCTCIF.
	DMA2D_IFCR_CCTCIF = 0x10
	// Clear the CTCIF flag in the ISR register
	DMA2D_IFCR_CCTCIF_Clear = 0x1
	// Position of CAECIF field.
	DMA2D_IFCR_CAECIF_Pos = 0x3
	// Bit mask of CAECIF field.
	DMA2D_IFCR_CAECIF_Msk = 0x8
	// Bit CAECIF.
	DMA2D_IFCR_CAECIF = 0x8
	// Clear the CAEIF flag in the ISR register
	DMA2D_IFCR_CAECIF_Clear = 0x1
	// Position of CTWIF field.
	DMA2D_IFCR_CTWIF_Pos = 0x2
	// Bit mask of CTWIF field.
	DMA2D_IFCR_CTWIF_Msk = 0x4
	// Bit CTWIF.
	DMA2D_IFCR_CTWIF = 0x4
	// Clear the TWIF flag in the ISR register
	DMA2D_IFCR_CTWIF_Clear = 0x1
	// Position of CTCIF field.
	DMA2D_IFCR_CTCIF_Pos = 0x1
	// Bit mask of CTCIF field.
	DMA2D_IFCR_CTCIF_Msk = 0x2
	// Bit CTCIF.
	DMA2D_IFCR_CTCIF = 0x2
	// Clear the TCIF flag in the ISR register
	DMA2D_IFCR_CTCIF_Clear = 0x1
	// Position of CTEIF field.
	DMA2D_IFCR_CTEIF_Pos = 0x0
	// Bit mask of CTEIF field.
	DMA2D_IFCR_CTEIF_Msk = 0x1
	// Bit CTEIF.
	DMA2D_IFCR_CTEIF = 0x1
	// Clear the TEIF flag in the ISR register
	DMA2D_IFCR_CTEIF_Clear = 0x1

	// FGMAR: foreground memory address register
	// Position of MA field.
	DMA2D_FGMAR_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA2D_FGMAR_MA_Msk = 0xffffffff

	// FGOR: foreground offset register
	// Position of LO field.
	DMA2D_FGOR_LO_Pos = 0x0
	// Bit mask of LO field.
	DMA2D_FGOR_LO_Msk = 0x3fff

	// BGMAR: background memory address register
	// Position of MA field.
	DMA2D_BGMAR_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA2D_BGMAR_MA_Msk = 0xffffffff

	// BGOR: background offset register
	// Position of LO field.
	DMA2D_BGOR_LO_Pos = 0x0
	// Bit mask of LO field.
	DMA2D_BGOR_LO_Msk = 0x3fff

	// FGPFCCR: foreground PFC control register
	// Position of ALPHA field.
	DMA2D_FGPFCCR_ALPHA_Pos = 0x18
	// Bit mask of ALPHA field.
	DMA2D_FGPFCCR_ALPHA_Msk = 0xff000000
	// Position of AM field.
	DMA2D_FGPFCCR_AM_Pos = 0x10
	// Bit mask of AM field.
	DMA2D_FGPFCCR_AM_Msk = 0x30000
	// No modification of alpha channel
	DMA2D_FGPFCCR_AM_NoModify = 0x0
	// Replace with value in ALPHA[7:0]
	DMA2D_FGPFCCR_AM_Replace = 0x1
	// Multiply with value in ALPHA[7:0]
	DMA2D_FGPFCCR_AM_Multiply = 0x2
	// Position of CS field.
	DMA2D_FGPFCCR_CS_Pos = 0x8
	// Bit mask of CS field.
	DMA2D_FGPFCCR_CS_Msk = 0xff00
	// Position of START field.
	DMA2D_FGPFCCR_START_Pos = 0x5
	// Bit mask of START field.
	DMA2D_FGPFCCR_START_Msk = 0x20
	// Bit START.
	DMA2D_FGPFCCR_START = 0x20
	// Start the automatic loading of the CLUT
	DMA2D_FGPFCCR_START_Start = 0x1
	// Position of CCM field.
	DMA2D_FGPFCCR_CCM_Pos = 0x4
	// Bit mask of CCM field.
	DMA2D_FGPFCCR_CCM_Msk = 0x10
	// Bit CCM.
	DMA2D_FGPFCCR_CCM = 0x10
	// CLUT color format ARGB8888
	DMA2D_FGPFCCR_CCM_ARGB8888 = 0x0
	// CLUT color format RGB888
	DMA2D_FGPFCCR_CCM_RGB888 = 0x1
	// Position of CM field.
	DMA2D_FGPFCCR_CM_Pos = 0x0
	// Bit mask of CM field.
	DMA2D_FGPFCCR_CM_Msk = 0xf
	// Color mode ARGB8888
	DMA2D_FGPFCCR_CM_ARGB8888 = 0x0
	// Color mode RGB888
	DMA2D_FGPFCCR_CM_RGB888 = 0x1
	// Color mode RGB565
	DMA2D_FGPFCCR_CM_RGB565 = 0x2
	// Color mode ARGB1555
	DMA2D_FGPFCCR_CM_ARGB1555 = 0x3
	// Color mode ARGB4444
	DMA2D_FGPFCCR_CM_ARGB4444 = 0x4
	// Color mode L8
	DMA2D_FGPFCCR_CM_L8 = 0x5
	// Color mode AL44
	DMA2D_FGPFCCR_CM_AL44 = 0x6
	// Color mode AL88
	DMA2D_FGPFCCR_CM_AL88 = 0x7
	// Color mode L4
	DMA2D_FGPFCCR_CM_L4 = 0x8
	// Color mode A8
	DMA2D_FGPFCCR_CM_A8 = 0x9
	// Color mode A4
	DMA2D_FGPFCCR_CM_A4 = 0xa

	// FGCOLR: foreground color register
	// Position of RED field.
	DMA2D_FGCOLR_RED_Pos = 0x10
	// Bit mask of RED field.
	DMA2D_FGCOLR_RED_Msk = 0xff0000
	// Position of GREEN field.
	DMA2D_FGCOLR_GREEN_Pos = 0x8
	// Bit mask of GREEN field.
	DMA2D_FGCOLR_GREEN_Msk = 0xff00
	// Position of BLUE field.
	DMA2D_FGCOLR_BLUE_Pos = 0x0
	// Bit mask of BLUE field.
	DMA2D_FGCOLR_BLUE_Msk = 0xff

	// BGPFCCR: background PFC control register
	// Position of ALPHA field.
	DMA2D_BGPFCCR_ALPHA_Pos = 0x18
	// Bit mask of ALPHA field.
	DMA2D_BGPFCCR_ALPHA_Msk = 0xff000000
	// Position of AM field.
	DMA2D_BGPFCCR_AM_Pos = 0x10
	// Bit mask of AM field.
	DMA2D_BGPFCCR_AM_Msk = 0x30000
	// No modification of alpha channel
	DMA2D_BGPFCCR_AM_NoModify = 0x0
	// Replace with value in ALPHA[7:0]
	DMA2D_BGPFCCR_AM_Replace = 0x1
	// Multiply with value in ALPHA[7:0]
	DMA2D_BGPFCCR_AM_Multiply = 0x2
	// Position of CS field.
	DMA2D_BGPFCCR_CS_Pos = 0x8
	// Bit mask of CS field.
	DMA2D_BGPFCCR_CS_Msk = 0xff00
	// Position of START field.
	DMA2D_BGPFCCR_START_Pos = 0x5
	// Bit mask of START field.
	DMA2D_BGPFCCR_START_Msk = 0x20
	// Bit START.
	DMA2D_BGPFCCR_START = 0x20
	// Start the automatic loading of the CLUT
	DMA2D_BGPFCCR_START_Start = 0x1
	// Position of CCM field.
	DMA2D_BGPFCCR_CCM_Pos = 0x4
	// Bit mask of CCM field.
	DMA2D_BGPFCCR_CCM_Msk = 0x10
	// Bit CCM.
	DMA2D_BGPFCCR_CCM = 0x10
	// CLUT color format ARGB8888
	DMA2D_BGPFCCR_CCM_ARGB8888 = 0x0
	// CLUT color format RGB888
	DMA2D_BGPFCCR_CCM_RGB888 = 0x1
	// Position of CM field.
	DMA2D_BGPFCCR_CM_Pos = 0x0
	// Bit mask of CM field.
	DMA2D_BGPFCCR_CM_Msk = 0xf
	// Color mode ARGB8888
	DMA2D_BGPFCCR_CM_ARGB8888 = 0x0
	// Color mode RGB888
	DMA2D_BGPFCCR_CM_RGB888 = 0x1
	// Color mode RGB565
	DMA2D_BGPFCCR_CM_RGB565 = 0x2
	// Color mode ARGB1555
	DMA2D_BGPFCCR_CM_ARGB1555 = 0x3
	// Color mode ARGB4444
	DMA2D_BGPFCCR_CM_ARGB4444 = 0x4
	// Color mode L8
	DMA2D_BGPFCCR_CM_L8 = 0x5
	// Color mode AL44
	DMA2D_BGPFCCR_CM_AL44 = 0x6
	// Color mode AL88
	DMA2D_BGPFCCR_CM_AL88 = 0x7
	// Color mode L4
	DMA2D_BGPFCCR_CM_L4 = 0x8
	// Color mode A8
	DMA2D_BGPFCCR_CM_A8 = 0x9
	// Color mode A4
	DMA2D_BGPFCCR_CM_A4 = 0xa

	// BGCOLR: background color register
	// Position of RED field.
	DMA2D_BGCOLR_RED_Pos = 0x10
	// Bit mask of RED field.
	DMA2D_BGCOLR_RED_Msk = 0xff0000
	// Position of GREEN field.
	DMA2D_BGCOLR_GREEN_Pos = 0x8
	// Bit mask of GREEN field.
	DMA2D_BGCOLR_GREEN_Msk = 0xff00
	// Position of BLUE field.
	DMA2D_BGCOLR_BLUE_Pos = 0x0
	// Bit mask of BLUE field.
	DMA2D_BGCOLR_BLUE_Msk = 0xff

	// FGCMAR: foreground CLUT memory address register
	// Position of MA field.
	DMA2D_FGCMAR_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA2D_FGCMAR_MA_Msk = 0xffffffff

	// BGCMAR: background CLUT memory address register
	// Position of MA field.
	DMA2D_BGCMAR_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA2D_BGCMAR_MA_Msk = 0xffffffff

	// OPFCCR: output PFC control register
	// Position of CM field.
	DMA2D_OPFCCR_CM_Pos = 0x0
	// Bit mask of CM field.
	DMA2D_OPFCCR_CM_Msk = 0x7
	// ARGB8888
	DMA2D_OPFCCR_CM_ARGB8888 = 0x0
	// RGB888
	DMA2D_OPFCCR_CM_RGB888 = 0x1
	// RGB565
	DMA2D_OPFCCR_CM_RGB565 = 0x2
	// ARGB1555
	DMA2D_OPFCCR_CM_ARGB1555 = 0x3
	// ARGB4444
	DMA2D_OPFCCR_CM_ARGB4444 = 0x4

	// OCOLR: output color register
	// Position of APLHA field.
	DMA2D_OCOLR_APLHA_Pos = 0x18
	// Bit mask of APLHA field.
	DMA2D_OCOLR_APLHA_Msk = 0xff000000
	// Position of RED field.
	DMA2D_OCOLR_RED_Pos = 0x10
	// Bit mask of RED field.
	DMA2D_OCOLR_RED_Msk = 0xff0000
	// Position of GREEN field.
	DMA2D_OCOLR_GREEN_Pos = 0x8
	// Bit mask of GREEN field.
	DMA2D_OCOLR_GREEN_Msk = 0xff00
	// Position of BLUE field.
	DMA2D_OCOLR_BLUE_Pos = 0x0
	// Bit mask of BLUE field.
	DMA2D_OCOLR_BLUE_Msk = 0xff

	// OMAR: output memory address register
	// Position of MA field.
	DMA2D_OMAR_MA_Pos = 0x0
	// Bit mask of MA field.
	DMA2D_OMAR_MA_Msk = 0xffffffff

	// OOR: output offset register
	// Position of LO field.
	DMA2D_OOR_LO_Pos = 0x0
	// Bit mask of LO field.
	DMA2D_OOR_LO_Msk = 0x3fff

	// NLR: number of line register
	// Position of PL field.
	DMA2D_NLR_PL_Pos = 0x10
	// Bit mask of PL field.
	DMA2D_NLR_PL_Msk = 0x3fff0000
	// Position of NL field.
	DMA2D_NLR_NL_Pos = 0x0
	// Bit mask of NL field.
	DMA2D_NLR_NL_Msk = 0xffff

	// LWR: line watermark register
	// Position of LW field.
	DMA2D_LWR_LW_Pos = 0x0
	// Bit mask of LW field.
	DMA2D_LWR_LW_Msk = 0xffff

	// AMTCR: AHB master timer configuration register
	// Position of DT field.
	DMA2D_AMTCR_DT_Pos = 0x8
	// Bit mask of DT field.
	DMA2D_AMTCR_DT_Msk = 0xff00
	// Position of EN field.
	DMA2D_AMTCR_EN_Pos = 0x0
	// Bit mask of EN field.
	DMA2D_AMTCR_EN_Msk = 0x1
	// Bit EN.
	DMA2D_AMTCR_EN = 0x1
	// Disabled AHB/AXI dead-time functionality
	DMA2D_AMTCR_EN_Disabled = 0x0
	// Enabled AHB/AXI dead-time functionality
	DMA2D_AMTCR_EN_Enabled = 0x1

	// FGCLUT: FGCLUT
	// Position of APLHA field.
	DMA2D_FGCLUT_APLHA_Pos = 0x18
	// Bit mask of APLHA field.
	DMA2D_FGCLUT_APLHA_Msk = 0xff000000
	// Position of RED field.
	DMA2D_FGCLUT_RED_Pos = 0x10
	// Bit mask of RED field.
	DMA2D_FGCLUT_RED_Msk = 0xff0000
	// Position of GREEN field.
	DMA2D_FGCLUT_GREEN_Pos = 0x8
	// Bit mask of GREEN field.
	DMA2D_FGCLUT_GREEN_Msk = 0xff00
	// Position of BLUE field.
	DMA2D_FGCLUT_BLUE_Pos = 0x0
	// Bit mask of BLUE field.
	DMA2D_FGCLUT_BLUE_Msk = 0xff

	// BGCLUT: BGCLUT
	// Position of APLHA field.
	DMA2D_BGCLUT_APLHA_Pos = 0x18
	// Bit mask of APLHA field.
	DMA2D_BGCLUT_APLHA_Msk = 0xff000000
	// Position of RED field.
	DMA2D_BGCLUT_RED_Pos = 0x10
	// Bit mask of RED field.
	DMA2D_BGCLUT_RED_Msk = 0xff0000
	// Position of GREEN field.
	DMA2D_BGCLUT_GREEN_Pos = 0x8
	// Bit mask of GREEN field.
	DMA2D_BGCLUT_GREEN_Msk = 0xff00
	// Position of BLUE field.
	DMA2D_BGCLUT_BLUE_Pos = 0x0
	// Bit mask of BLUE field.
	DMA2D_BGCLUT_BLUE_Msk = 0xff
)

// Constants for QUADSPI: QuadSPI interface
const (
	// CR: control register
	// Position of PRESCALER field.
	QUADSPI_CR_PRESCALER_Pos = 0x18
	// Bit mask of PRESCALER field.
	QUADSPI_CR_PRESCALER_Msk = 0xff000000
	// Position of PMM field.
	QUADSPI_CR_PMM_Pos = 0x17
	// Bit mask of PMM field.
	QUADSPI_CR_PMM_Msk = 0x800000
	// Bit PMM.
	QUADSPI_CR_PMM = 0x800000
	// Position of APMS field.
	QUADSPI_CR_APMS_Pos = 0x16
	// Bit mask of APMS field.
	QUADSPI_CR_APMS_Msk = 0x400000
	// Bit APMS.
	QUADSPI_CR_APMS = 0x400000
	// Position of TOIE field.
	QUADSPI_CR_TOIE_Pos = 0x14
	// Bit mask of TOIE field.
	QUADSPI_CR_TOIE_Msk = 0x100000
	// Bit TOIE.
	QUADSPI_CR_TOIE = 0x100000
	// Position of SMIE field.
	QUADSPI_CR_SMIE_Pos = 0x13
	// Bit mask of SMIE field.
	QUADSPI_CR_SMIE_Msk = 0x80000
	// Bit SMIE.
	QUADSPI_CR_SMIE = 0x80000
	// Position of FTIE field.
	QUADSPI_CR_FTIE_Pos = 0x12
	// Bit mask of FTIE field.
	QUADSPI_CR_FTIE_Msk = 0x40000
	// Bit FTIE.
	QUADSPI_CR_FTIE = 0x40000
	// Position of TCIE field.
	QUADSPI_CR_TCIE_Pos = 0x11
	// Bit mask of TCIE field.
	QUADSPI_CR_TCIE_Msk = 0x20000
	// Bit TCIE.
	QUADSPI_CR_TCIE = 0x20000
	// Position of TEIE field.
	QUADSPI_CR_TEIE_Pos = 0x10
	// Bit mask of TEIE field.
	QUADSPI_CR_TEIE_Msk = 0x10000
	// Bit TEIE.
	QUADSPI_CR_TEIE = 0x10000
	// Position of FTHRES field.
	QUADSPI_CR_FTHRES_Pos = 0x8
	// Bit mask of FTHRES field.
	QUADSPI_CR_FTHRES_Msk = 0x1f00
	// Position of FSEL field.
	QUADSPI_CR_FSEL_Pos = 0x7
	// Bit mask of FSEL field.
	QUADSPI_CR_FSEL_Msk = 0x80
	// Bit FSEL.
	QUADSPI_CR_FSEL = 0x80
	// Position of DFM field.
	QUADSPI_CR_DFM_Pos = 0x6
	// Bit mask of DFM field.
	QUADSPI_CR_DFM_Msk = 0x40
	// Bit DFM.
	QUADSPI_CR_DFM = 0x40
	// Position of SSHIFT field.
	QUADSPI_CR_SSHIFT_Pos = 0x4
	// Bit mask of SSHIFT field.
	QUADSPI_CR_SSHIFT_Msk = 0x10
	// Bit SSHIFT.
	QUADSPI_CR_SSHIFT = 0x10
	// Position of TCEN field.
	QUADSPI_CR_TCEN_Pos = 0x3
	// Bit mask of TCEN field.
	QUADSPI_CR_TCEN_Msk = 0x8
	// Bit TCEN.
	QUADSPI_CR_TCEN = 0x8
	// Position of DMAEN field.
	QUADSPI_CR_DMAEN_Pos = 0x2
	// Bit mask of DMAEN field.
	QUADSPI_CR_DMAEN_Msk = 0x4
	// Bit DMAEN.
	QUADSPI_CR_DMAEN = 0x4
	// Position of ABORT field.
	QUADSPI_CR_ABORT_Pos = 0x1
	// Bit mask of ABORT field.
	QUADSPI_CR_ABORT_Msk = 0x2
	// Bit ABORT.
	QUADSPI_CR_ABORT = 0x2
	// Position of EN field.
	QUADSPI_CR_EN_Pos = 0x0
	// Bit mask of EN field.
	QUADSPI_CR_EN_Msk = 0x1
	// Bit EN.
	QUADSPI_CR_EN = 0x1

	// DCR: device configuration register
	// Position of FSIZE field.
	QUADSPI_DCR_FSIZE_Pos = 0x10
	// Bit mask of FSIZE field.
	QUADSPI_DCR_FSIZE_Msk = 0x1f0000
	// Position of CSHT field.
	QUADSPI_DCR_CSHT_Pos = 0x8
	// Bit mask of CSHT field.
	QUADSPI_DCR_CSHT_Msk = 0x700
	// Position of CKMODE field.
	QUADSPI_DCR_CKMODE_Pos = 0x0
	// Bit mask of CKMODE field.
	QUADSPI_DCR_CKMODE_Msk = 0x1
	// Bit CKMODE.
	QUADSPI_DCR_CKMODE = 0x1

	// SR: status register
	// Position of FLEVEL field.
	QUADSPI_SR_FLEVEL_Pos = 0x8
	// Bit mask of FLEVEL field.
	QUADSPI_SR_FLEVEL_Msk = 0x7f00
	// Position of BUSY field.
	QUADSPI_SR_BUSY_Pos = 0x5
	// Bit mask of BUSY field.
	QUADSPI_SR_BUSY_Msk = 0x20
	// Bit BUSY.
	QUADSPI_SR_BUSY = 0x20
	// Position of TOF field.
	QUADSPI_SR_TOF_Pos = 0x4
	// Bit mask of TOF field.
	QUADSPI_SR_TOF_Msk = 0x10
	// Bit TOF.
	QUADSPI_SR_TOF = 0x10
	// Position of SMF field.
	QUADSPI_SR_SMF_Pos = 0x3
	// Bit mask of SMF field.
	QUADSPI_SR_SMF_Msk = 0x8
	// Bit SMF.
	QUADSPI_SR_SMF = 0x8
	// Position of FTF field.
	QUADSPI_SR_FTF_Pos = 0x2
	// Bit mask of FTF field.
	QUADSPI_SR_FTF_Msk = 0x4
	// Bit FTF.
	QUADSPI_SR_FTF = 0x4
	// Position of TCF field.
	QUADSPI_SR_TCF_Pos = 0x1
	// Bit mask of TCF field.
	QUADSPI_SR_TCF_Msk = 0x2
	// Bit TCF.
	QUADSPI_SR_TCF = 0x2
	// Position of TEF field.
	QUADSPI_SR_TEF_Pos = 0x0
	// Bit mask of TEF field.
	QUADSPI_SR_TEF_Msk = 0x1
	// Bit TEF.
	QUADSPI_SR_TEF = 0x1

	// FCR: flag clear register
	// Position of CTOF field.
	QUADSPI_FCR_CTOF_Pos = 0x4
	// Bit mask of CTOF field.
	QUADSPI_FCR_CTOF_Msk = 0x10
	// Bit CTOF.
	QUADSPI_FCR_CTOF = 0x10
	// Position of CSMF field.
	QUADSPI_FCR_CSMF_Pos = 0x3
	// Bit mask of CSMF field.
	QUADSPI_FCR_CSMF_Msk = 0x8
	// Bit CSMF.
	QUADSPI_FCR_CSMF = 0x8
	// Position of CTCF field.
	QUADSPI_FCR_CTCF_Pos = 0x1
	// Bit mask of CTCF field.
	QUADSPI_FCR_CTCF_Msk = 0x2
	// Bit CTCF.
	QUADSPI_FCR_CTCF = 0x2
	// Position of CTEF field.
	QUADSPI_FCR_CTEF_Pos = 0x0
	// Bit mask of CTEF field.
	QUADSPI_FCR_CTEF_Msk = 0x1
	// Bit CTEF.
	QUADSPI_FCR_CTEF = 0x1

	// DLR: data length register
	// Position of DL field.
	QUADSPI_DLR_DL_Pos = 0x0
	// Bit mask of DL field.
	QUADSPI_DLR_DL_Msk = 0xffffffff

	// CCR: communication configuration register
	// Position of DDRM field.
	QUADSPI_CCR_DDRM_Pos = 0x1f
	// Bit mask of DDRM field.
	QUADSPI_CCR_DDRM_Msk = 0x80000000
	// Bit DDRM.
	QUADSPI_CCR_DDRM = 0x80000000
	// Position of DHHC field.
	QUADSPI_CCR_DHHC_Pos = 0x1e
	// Bit mask of DHHC field.
	QUADSPI_CCR_DHHC_Msk = 0x40000000
	// Bit DHHC.
	QUADSPI_CCR_DHHC = 0x40000000
	// Position of SIOO field.
	QUADSPI_CCR_SIOO_Pos = 0x1c
	// Bit mask of SIOO field.
	QUADSPI_CCR_SIOO_Msk = 0x10000000
	// Bit SIOO.
	QUADSPI_CCR_SIOO = 0x10000000
	// Position of FMODE field.
	QUADSPI_CCR_FMODE_Pos = 0x1a
	// Bit mask of FMODE field.
	QUADSPI_CCR_FMODE_Msk = 0xc000000
	// Position of DMODE field.
	QUADSPI_CCR_DMODE_Pos = 0x18
	// Bit mask of DMODE field.
	QUADSPI_CCR_DMODE_Msk = 0x3000000
	// Position of DCYC field.
	QUADSPI_CCR_DCYC_Pos = 0x12
	// Bit mask of DCYC field.
	QUADSPI_CCR_DCYC_Msk = 0x7c0000
	// Position of ABSIZE field.
	QUADSPI_CCR_ABSIZE_Pos = 0x10
	// Bit mask of ABSIZE field.
	QUADSPI_CCR_ABSIZE_Msk = 0x30000
	// Position of ABMODE field.
	QUADSPI_CCR_ABMODE_Pos = 0xe
	// Bit mask of ABMODE field.
	QUADSPI_CCR_ABMODE_Msk = 0xc000
	// Position of ADSIZE field.
	QUADSPI_CCR_ADSIZE_Pos = 0xc
	// Bit mask of ADSIZE field.
	QUADSPI_CCR_ADSIZE_Msk = 0x3000
	// Position of ADMODE field.
	QUADSPI_CCR_ADMODE_Pos = 0xa
	// Bit mask of ADMODE field.
	QUADSPI_CCR_ADMODE_Msk = 0xc00
	// Position of IMODE field.
	QUADSPI_CCR_IMODE_Pos = 0x8
	// Bit mask of IMODE field.
	QUADSPI_CCR_IMODE_Msk = 0x300
	// Position of INSTRUCTION field.
	QUADSPI_CCR_INSTRUCTION_Pos = 0x0
	// Bit mask of INSTRUCTION field.
	QUADSPI_CCR_INSTRUCTION_Msk = 0xff

	// AR: address register
	// Position of ADDRESS field.
	QUADSPI_AR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	QUADSPI_AR_ADDRESS_Msk = 0xffffffff

	// ABR: ABR
	// Position of ALTERNATE field.
	QUADSPI_ABR_ALTERNATE_Pos = 0x0
	// Bit mask of ALTERNATE field.
	QUADSPI_ABR_ALTERNATE_Msk = 0xffffffff

	// DR: data register
	// Position of DATA field.
	QUADSPI_DR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	QUADSPI_DR_DATA_Msk = 0xffffffff

	// PSMKR: polling status mask register
	// Position of MASK field.
	QUADSPI_PSMKR_MASK_Pos = 0x0
	// Bit mask of MASK field.
	QUADSPI_PSMKR_MASK_Msk = 0xffffffff

	// PSMAR: polling status match register
	// Position of MATCH field.
	QUADSPI_PSMAR_MATCH_Pos = 0x0
	// Bit mask of MATCH field.
	QUADSPI_PSMAR_MATCH_Msk = 0xffffffff

	// PIR: polling interval register
	// Position of INTERVAL field.
	QUADSPI_PIR_INTERVAL_Pos = 0x0
	// Bit mask of INTERVAL field.
	QUADSPI_PIR_INTERVAL_Msk = 0xffff

	// LPTR: low-power timeout register
	// Position of TIMEOUT field.
	QUADSPI_LPTR_TIMEOUT_Pos = 0x0
	// Bit mask of TIMEOUT field.
	QUADSPI_LPTR_TIMEOUT_Msk = 0xffff
)

// Constants for CEC: HDMI-CEC controller
const (
	// CR: control register
	// Position of TXEOM field.
	CEC_CR_TXEOM_Pos = 0x2
	// Bit mask of TXEOM field.
	CEC_CR_TXEOM_Msk = 0x4
	// Bit TXEOM.
	CEC_CR_TXEOM = 0x4
	// Position of TXSOM field.
	CEC_CR_TXSOM_Pos = 0x1
	// Bit mask of TXSOM field.
	CEC_CR_TXSOM_Msk = 0x2
	// Bit TXSOM.
	CEC_CR_TXSOM = 0x2
	// Position of CECEN field.
	CEC_CR_CECEN_Pos = 0x0
	// Bit mask of CECEN field.
	CEC_CR_CECEN_Msk = 0x1
	// Bit CECEN.
	CEC_CR_CECEN = 0x1

	// CFGR: configuration register
	// Position of SFT field.
	CEC_CFGR_SFT_Pos = 0x0
	// Bit mask of SFT field.
	CEC_CFGR_SFT_Msk = 0x7
	// Position of RXTOL field.
	CEC_CFGR_RXTOL_Pos = 0x3
	// Bit mask of RXTOL field.
	CEC_CFGR_RXTOL_Msk = 0x8
	// Bit RXTOL.
	CEC_CFGR_RXTOL = 0x8
	// Position of BRESTP field.
	CEC_CFGR_BRESTP_Pos = 0x4
	// Bit mask of BRESTP field.
	CEC_CFGR_BRESTP_Msk = 0x10
	// Bit BRESTP.
	CEC_CFGR_BRESTP = 0x10
	// Position of BREGEN field.
	CEC_CFGR_BREGEN_Pos = 0x5
	// Bit mask of BREGEN field.
	CEC_CFGR_BREGEN_Msk = 0x20
	// Bit BREGEN.
	CEC_CFGR_BREGEN = 0x20
	// Position of LBPEGEN field.
	CEC_CFGR_LBPEGEN_Pos = 0x6
	// Bit mask of LBPEGEN field.
	CEC_CFGR_LBPEGEN_Msk = 0x40
	// Bit LBPEGEN.
	CEC_CFGR_LBPEGEN = 0x40
	// Position of BRDNOGEN field.
	CEC_CFGR_BRDNOGEN_Pos = 0x7
	// Bit mask of BRDNOGEN field.
	CEC_CFGR_BRDNOGEN_Msk = 0x80
	// Bit BRDNOGEN.
	CEC_CFGR_BRDNOGEN = 0x80
	// Position of SFTOP field.
	CEC_CFGR_SFTOP_Pos = 0x8
	// Bit mask of SFTOP field.
	CEC_CFGR_SFTOP_Msk = 0x100
	// Bit SFTOP.
	CEC_CFGR_SFTOP = 0x100
	// Position of OAR field.
	CEC_CFGR_OAR_Pos = 0x10
	// Bit mask of OAR field.
	CEC_CFGR_OAR_Msk = 0x7fff0000
	// Position of LSTN field.
	CEC_CFGR_LSTN_Pos = 0x1f
	// Bit mask of LSTN field.
	CEC_CFGR_LSTN_Msk = 0x80000000
	// Bit LSTN.
	CEC_CFGR_LSTN = 0x80000000

	// TXDR: Tx data register
	// Position of TXD field.
	CEC_TXDR_TXD_Pos = 0x0
	// Bit mask of TXD field.
	CEC_TXDR_TXD_Msk = 0xff

	// RXDR: Rx Data Register
	// Position of RXDR field.
	CEC_RXDR_RXDR_Pos = 0x0
	// Bit mask of RXDR field.
	CEC_RXDR_RXDR_Msk = 0xff

	// ISR: Interrupt and Status Register
	// Position of TXACKE field.
	CEC_ISR_TXACKE_Pos = 0xc
	// Bit mask of TXACKE field.
	CEC_ISR_TXACKE_Msk = 0x1000
	// Bit TXACKE.
	CEC_ISR_TXACKE = 0x1000
	// Position of TXERR field.
	CEC_ISR_TXERR_Pos = 0xb
	// Bit mask of TXERR field.
	CEC_ISR_TXERR_Msk = 0x800
	// Bit TXERR.
	CEC_ISR_TXERR = 0x800
	// Position of TXUDR field.
	CEC_ISR_TXUDR_Pos = 0xa
	// Bit mask of TXUDR field.
	CEC_ISR_TXUDR_Msk = 0x400
	// Bit TXUDR.
	CEC_ISR_TXUDR = 0x400
	// Position of TXEND field.
	CEC_ISR_TXEND_Pos = 0x9
	// Bit mask of TXEND field.
	CEC_ISR_TXEND_Msk = 0x200
	// Bit TXEND.
	CEC_ISR_TXEND = 0x200
	// Position of TXBR field.
	CEC_ISR_TXBR_Pos = 0x8
	// Bit mask of TXBR field.
	CEC_ISR_TXBR_Msk = 0x100
	// Bit TXBR.
	CEC_ISR_TXBR = 0x100
	// Position of ARBLST field.
	CEC_ISR_ARBLST_Pos = 0x7
	// Bit mask of ARBLST field.
	CEC_ISR_ARBLST_Msk = 0x80
	// Bit ARBLST.
	CEC_ISR_ARBLST = 0x80
	// Position of RXACKE field.
	CEC_ISR_RXACKE_Pos = 0x6
	// Bit mask of RXACKE field.
	CEC_ISR_RXACKE_Msk = 0x40
	// Bit RXACKE.
	CEC_ISR_RXACKE = 0x40
	// Position of LBPE field.
	CEC_ISR_LBPE_Pos = 0x5
	// Bit mask of LBPE field.
	CEC_ISR_LBPE_Msk = 0x20
	// Bit LBPE.
	CEC_ISR_LBPE = 0x20
	// Position of SBPE field.
	CEC_ISR_SBPE_Pos = 0x4
	// Bit mask of SBPE field.
	CEC_ISR_SBPE_Msk = 0x10
	// Bit SBPE.
	CEC_ISR_SBPE = 0x10
	// Position of BRE field.
	CEC_ISR_BRE_Pos = 0x3
	// Bit mask of BRE field.
	CEC_ISR_BRE_Msk = 0x8
	// Bit BRE.
	CEC_ISR_BRE = 0x8
	// Position of RXOVR field.
	CEC_ISR_RXOVR_Pos = 0x2
	// Bit mask of RXOVR field.
	CEC_ISR_RXOVR_Msk = 0x4
	// Bit RXOVR.
	CEC_ISR_RXOVR = 0x4
	// Position of RXEND field.
	CEC_ISR_RXEND_Pos = 0x1
	// Bit mask of RXEND field.
	CEC_ISR_RXEND_Msk = 0x2
	// Bit RXEND.
	CEC_ISR_RXEND = 0x2
	// Position of RXBR field.
	CEC_ISR_RXBR_Pos = 0x0
	// Bit mask of RXBR field.
	CEC_ISR_RXBR_Msk = 0x1
	// Bit RXBR.
	CEC_ISR_RXBR = 0x1

	// IER: interrupt enable register
	// Position of TXACKIE field.
	CEC_IER_TXACKIE_Pos = 0xc
	// Bit mask of TXACKIE field.
	CEC_IER_TXACKIE_Msk = 0x1000
	// Bit TXACKIE.
	CEC_IER_TXACKIE = 0x1000
	// Position of TXERRIE field.
	CEC_IER_TXERRIE_Pos = 0xb
	// Bit mask of TXERRIE field.
	CEC_IER_TXERRIE_Msk = 0x800
	// Bit TXERRIE.
	CEC_IER_TXERRIE = 0x800
	// Position of TXUDRIE field.
	CEC_IER_TXUDRIE_Pos = 0xa
	// Bit mask of TXUDRIE field.
	CEC_IER_TXUDRIE_Msk = 0x400
	// Bit TXUDRIE.
	CEC_IER_TXUDRIE = 0x400
	// Position of TXENDIE field.
	CEC_IER_TXENDIE_Pos = 0x9
	// Bit mask of TXENDIE field.
	CEC_IER_TXENDIE_Msk = 0x200
	// Bit TXENDIE.
	CEC_IER_TXENDIE = 0x200
	// Position of TXBRIE field.
	CEC_IER_TXBRIE_Pos = 0x8
	// Bit mask of TXBRIE field.
	CEC_IER_TXBRIE_Msk = 0x100
	// Bit TXBRIE.
	CEC_IER_TXBRIE = 0x100
	// Position of ARBLSTIE field.
	CEC_IER_ARBLSTIE_Pos = 0x7
	// Bit mask of ARBLSTIE field.
	CEC_IER_ARBLSTIE_Msk = 0x80
	// Bit ARBLSTIE.
	CEC_IER_ARBLSTIE = 0x80
	// Position of RXACKIE field.
	CEC_IER_RXACKIE_Pos = 0x6
	// Bit mask of RXACKIE field.
	CEC_IER_RXACKIE_Msk = 0x40
	// Bit RXACKIE.
	CEC_IER_RXACKIE = 0x40
	// Position of LBPEIE field.
	CEC_IER_LBPEIE_Pos = 0x5
	// Bit mask of LBPEIE field.
	CEC_IER_LBPEIE_Msk = 0x20
	// Bit LBPEIE.
	CEC_IER_LBPEIE = 0x20
	// Position of SBPEIE field.
	CEC_IER_SBPEIE_Pos = 0x4
	// Bit mask of SBPEIE field.
	CEC_IER_SBPEIE_Msk = 0x10
	// Bit SBPEIE.
	CEC_IER_SBPEIE = 0x10
	// Position of BREIE field.
	CEC_IER_BREIE_Pos = 0x3
	// Bit mask of BREIE field.
	CEC_IER_BREIE_Msk = 0x8
	// Bit BREIE.
	CEC_IER_BREIE = 0x8
	// Position of RXOVRIE field.
	CEC_IER_RXOVRIE_Pos = 0x2
	// Bit mask of RXOVRIE field.
	CEC_IER_RXOVRIE_Msk = 0x4
	// Bit RXOVRIE.
	CEC_IER_RXOVRIE = 0x4
	// Position of RXENDIE field.
	CEC_IER_RXENDIE_Pos = 0x1
	// Bit mask of RXENDIE field.
	CEC_IER_RXENDIE_Msk = 0x2
	// Bit RXENDIE.
	CEC_IER_RXENDIE = 0x2
	// Position of RXBRIE field.
	CEC_IER_RXBRIE_Pos = 0x0
	// Bit mask of RXBRIE field.
	CEC_IER_RXBRIE_Msk = 0x1
	// Bit RXBRIE.
	CEC_IER_RXBRIE = 0x1
)

// Constants for SPDIFRX: Receiver Interface
const (
	// CR: Control register
	// Position of SPDIFEN field.
	SPDIF_RX_CR_SPDIFEN_Pos = 0x0
	// Bit mask of SPDIFEN field.
	SPDIF_RX_CR_SPDIFEN_Msk = 0x3
	// Position of RXDMAEN field.
	SPDIF_RX_CR_RXDMAEN_Pos = 0x2
	// Bit mask of RXDMAEN field.
	SPDIF_RX_CR_RXDMAEN_Msk = 0x4
	// Bit RXDMAEN.
	SPDIF_RX_CR_RXDMAEN = 0x4
	// Position of RXSTEO field.
	SPDIF_RX_CR_RXSTEO_Pos = 0x3
	// Bit mask of RXSTEO field.
	SPDIF_RX_CR_RXSTEO_Msk = 0x8
	// Bit RXSTEO.
	SPDIF_RX_CR_RXSTEO = 0x8
	// Position of DRFMT field.
	SPDIF_RX_CR_DRFMT_Pos = 0x4
	// Bit mask of DRFMT field.
	SPDIF_RX_CR_DRFMT_Msk = 0x30
	// Position of PMSK field.
	SPDIF_RX_CR_PMSK_Pos = 0x6
	// Bit mask of PMSK field.
	SPDIF_RX_CR_PMSK_Msk = 0x40
	// Bit PMSK.
	SPDIF_RX_CR_PMSK = 0x40
	// Position of VMSK field.
	SPDIF_RX_CR_VMSK_Pos = 0x7
	// Bit mask of VMSK field.
	SPDIF_RX_CR_VMSK_Msk = 0x80
	// Bit VMSK.
	SPDIF_RX_CR_VMSK = 0x80
	// Position of CUMSK field.
	SPDIF_RX_CR_CUMSK_Pos = 0x8
	// Bit mask of CUMSK field.
	SPDIF_RX_CR_CUMSK_Msk = 0x100
	// Bit CUMSK.
	SPDIF_RX_CR_CUMSK = 0x100
	// Position of PTMSK field.
	SPDIF_RX_CR_PTMSK_Pos = 0x9
	// Bit mask of PTMSK field.
	SPDIF_RX_CR_PTMSK_Msk = 0x200
	// Bit PTMSK.
	SPDIF_RX_CR_PTMSK = 0x200
	// Position of CBDMAEN field.
	SPDIF_RX_CR_CBDMAEN_Pos = 0xa
	// Bit mask of CBDMAEN field.
	SPDIF_RX_CR_CBDMAEN_Msk = 0x400
	// Bit CBDMAEN.
	SPDIF_RX_CR_CBDMAEN = 0x400
	// Position of CHSEL field.
	SPDIF_RX_CR_CHSEL_Pos = 0xb
	// Bit mask of CHSEL field.
	SPDIF_RX_CR_CHSEL_Msk = 0x800
	// Bit CHSEL.
	SPDIF_RX_CR_CHSEL = 0x800
	// Position of NBTR field.
	SPDIF_RX_CR_NBTR_Pos = 0xc
	// Bit mask of NBTR field.
	SPDIF_RX_CR_NBTR_Msk = 0x3000
	// Position of WFA field.
	SPDIF_RX_CR_WFA_Pos = 0xe
	// Bit mask of WFA field.
	SPDIF_RX_CR_WFA_Msk = 0x4000
	// Bit WFA.
	SPDIF_RX_CR_WFA = 0x4000
	// Position of INSEL field.
	SPDIF_RX_CR_INSEL_Pos = 0x10
	// Bit mask of INSEL field.
	SPDIF_RX_CR_INSEL_Msk = 0x70000

	// IMR: Interrupt mask register
	// Position of RXNEIE field.
	SPDIF_RX_IMR_RXNEIE_Pos = 0x0
	// Bit mask of RXNEIE field.
	SPDIF_RX_IMR_RXNEIE_Msk = 0x1
	// Bit RXNEIE.
	SPDIF_RX_IMR_RXNEIE = 0x1
	// Position of CSRNEIE field.
	SPDIF_RX_IMR_CSRNEIE_Pos = 0x1
	// Bit mask of CSRNEIE field.
	SPDIF_RX_IMR_CSRNEIE_Msk = 0x2
	// Bit CSRNEIE.
	SPDIF_RX_IMR_CSRNEIE = 0x2
	// Position of PERRIE field.
	SPDIF_RX_IMR_PERRIE_Pos = 0x2
	// Bit mask of PERRIE field.
	SPDIF_RX_IMR_PERRIE_Msk = 0x4
	// Bit PERRIE.
	SPDIF_RX_IMR_PERRIE = 0x4
	// Position of OVRIE field.
	SPDIF_RX_IMR_OVRIE_Pos = 0x3
	// Bit mask of OVRIE field.
	SPDIF_RX_IMR_OVRIE_Msk = 0x8
	// Bit OVRIE.
	SPDIF_RX_IMR_OVRIE = 0x8
	// Position of SBLKIE field.
	SPDIF_RX_IMR_SBLKIE_Pos = 0x4
	// Bit mask of SBLKIE field.
	SPDIF_RX_IMR_SBLKIE_Msk = 0x10
	// Bit SBLKIE.
	SPDIF_RX_IMR_SBLKIE = 0x10
	// Position of SYNCDIE field.
	SPDIF_RX_IMR_SYNCDIE_Pos = 0x5
	// Bit mask of SYNCDIE field.
	SPDIF_RX_IMR_SYNCDIE_Msk = 0x20
	// Bit SYNCDIE.
	SPDIF_RX_IMR_SYNCDIE = 0x20
	// Position of IFEIE field.
	SPDIF_RX_IMR_IFEIE_Pos = 0x6
	// Bit mask of IFEIE field.
	SPDIF_RX_IMR_IFEIE_Msk = 0x40
	// Bit IFEIE.
	SPDIF_RX_IMR_IFEIE = 0x40

	// SR: Status register
	// Position of RXNE field.
	SPDIF_RX_SR_RXNE_Pos = 0x0
	// Bit mask of RXNE field.
	SPDIF_RX_SR_RXNE_Msk = 0x1
	// Bit RXNE.
	SPDIF_RX_SR_RXNE = 0x1
	// Position of CSRNE field.
	SPDIF_RX_SR_CSRNE_Pos = 0x1
	// Bit mask of CSRNE field.
	SPDIF_RX_SR_CSRNE_Msk = 0x2
	// Bit CSRNE.
	SPDIF_RX_SR_CSRNE = 0x2
	// Position of PERR field.
	SPDIF_RX_SR_PERR_Pos = 0x2
	// Bit mask of PERR field.
	SPDIF_RX_SR_PERR_Msk = 0x4
	// Bit PERR.
	SPDIF_RX_SR_PERR = 0x4
	// Position of OVR field.
	SPDIF_RX_SR_OVR_Pos = 0x3
	// Bit mask of OVR field.
	SPDIF_RX_SR_OVR_Msk = 0x8
	// Bit OVR.
	SPDIF_RX_SR_OVR = 0x8
	// Position of SBD field.
	SPDIF_RX_SR_SBD_Pos = 0x4
	// Bit mask of SBD field.
	SPDIF_RX_SR_SBD_Msk = 0x10
	// Bit SBD.
	SPDIF_RX_SR_SBD = 0x10
	// Position of SYNCD field.
	SPDIF_RX_SR_SYNCD_Pos = 0x5
	// Bit mask of SYNCD field.
	SPDIF_RX_SR_SYNCD_Msk = 0x20
	// Bit SYNCD.
	SPDIF_RX_SR_SYNCD = 0x20
	// Position of FERR field.
	SPDIF_RX_SR_FERR_Pos = 0x6
	// Bit mask of FERR field.
	SPDIF_RX_SR_FERR_Msk = 0x40
	// Bit FERR.
	SPDIF_RX_SR_FERR = 0x40
	// Position of SERR field.
	SPDIF_RX_SR_SERR_Pos = 0x7
	// Bit mask of SERR field.
	SPDIF_RX_SR_SERR_Msk = 0x80
	// Bit SERR.
	SPDIF_RX_SR_SERR = 0x80
	// Position of TERR field.
	SPDIF_RX_SR_TERR_Pos = 0x8
	// Bit mask of TERR field.
	SPDIF_RX_SR_TERR_Msk = 0x100
	// Bit TERR.
	SPDIF_RX_SR_TERR = 0x100
	// Position of WIDTH5 field.
	SPDIF_RX_SR_WIDTH5_Pos = 0x10
	// Bit mask of WIDTH5 field.
	SPDIF_RX_SR_WIDTH5_Msk = 0x7fff0000

	// IFCR: Interrupt Flag Clear register
	// Position of PERRCF field.
	SPDIF_RX_IFCR_PERRCF_Pos = 0x2
	// Bit mask of PERRCF field.
	SPDIF_RX_IFCR_PERRCF_Msk = 0x4
	// Bit PERRCF.
	SPDIF_RX_IFCR_PERRCF = 0x4
	// Position of OVRCF field.
	SPDIF_RX_IFCR_OVRCF_Pos = 0x3
	// Bit mask of OVRCF field.
	SPDIF_RX_IFCR_OVRCF_Msk = 0x8
	// Bit OVRCF.
	SPDIF_RX_IFCR_OVRCF = 0x8
	// Position of SBDCF field.
	SPDIF_RX_IFCR_SBDCF_Pos = 0x4
	// Bit mask of SBDCF field.
	SPDIF_RX_IFCR_SBDCF_Msk = 0x10
	// Bit SBDCF.
	SPDIF_RX_IFCR_SBDCF = 0x10
	// Position of SYNCDCF field.
	SPDIF_RX_IFCR_SYNCDCF_Pos = 0x5
	// Bit mask of SYNCDCF field.
	SPDIF_RX_IFCR_SYNCDCF_Msk = 0x20
	// Bit SYNCDCF.
	SPDIF_RX_IFCR_SYNCDCF = 0x20

	// DR: Data input register
	// Position of DR field.
	SPDIF_RX_DR_DR_Pos = 0x0
	// Bit mask of DR field.
	SPDIF_RX_DR_DR_Msk = 0xffffff
	// Position of PE field.
	SPDIF_RX_DR_PE_Pos = 0x18
	// Bit mask of PE field.
	SPDIF_RX_DR_PE_Msk = 0x1000000
	// Bit PE.
	SPDIF_RX_DR_PE = 0x1000000
	// Position of V field.
	SPDIF_RX_DR_V_Pos = 0x19
	// Bit mask of V field.
	SPDIF_RX_DR_V_Msk = 0x2000000
	// Bit V.
	SPDIF_RX_DR_V = 0x2000000
	// Position of U field.
	SPDIF_RX_DR_U_Pos = 0x1a
	// Bit mask of U field.
	SPDIF_RX_DR_U_Msk = 0x4000000
	// Bit U.
	SPDIF_RX_DR_U = 0x4000000
	// Position of C field.
	SPDIF_RX_DR_C_Pos = 0x1b
	// Bit mask of C field.
	SPDIF_RX_DR_C_Msk = 0x8000000
	// Bit C.
	SPDIF_RX_DR_C = 0x8000000
	// Position of PT field.
	SPDIF_RX_DR_PT_Pos = 0x1c
	// Bit mask of PT field.
	SPDIF_RX_DR_PT_Msk = 0x30000000

	// CSR: Channel Status register
	// Position of USR field.
	SPDIF_RX_CSR_USR_Pos = 0x0
	// Bit mask of USR field.
	SPDIF_RX_CSR_USR_Msk = 0xffff
	// Position of CS field.
	SPDIF_RX_CSR_CS_Pos = 0x10
	// Bit mask of CS field.
	SPDIF_RX_CSR_CS_Msk = 0xff0000
	// Position of SOB field.
	SPDIF_RX_CSR_SOB_Pos = 0x18
	// Bit mask of SOB field.
	SPDIF_RX_CSR_SOB_Msk = 0x1000000
	// Bit SOB.
	SPDIF_RX_CSR_SOB = 0x1000000

	// DIR: Debug Information register
	// Position of THI field.
	SPDIF_RX_DIR_THI_Pos = 0x0
	// Bit mask of THI field.
	SPDIF_RX_DIR_THI_Msk = 0x1fff
	// Position of TLO field.
	SPDIF_RX_DIR_TLO_Pos = 0x10
	// Bit mask of TLO field.
	SPDIF_RX_DIR_TLO_Msk = 0x1fff0000
)

// Constants for SDMMC1: Secure digital input/output interface
const (
	// POWER: power control register
	// Position of PWRCTRL field.
	SDMMC_POWER_PWRCTRL_Pos = 0x0
	// Bit mask of PWRCTRL field.
	SDMMC_POWER_PWRCTRL_Msk = 0x3

	// CLKCR: SDI clock control register
	// Position of HWFC_EN field.
	SDMMC_CLKCR_HWFC_EN_Pos = 0xe
	// Bit mask of HWFC_EN field.
	SDMMC_CLKCR_HWFC_EN_Msk = 0x4000
	// Bit HWFC_EN.
	SDMMC_CLKCR_HWFC_EN = 0x4000
	// Position of NEGEDGE field.
	SDMMC_CLKCR_NEGEDGE_Pos = 0xd
	// Bit mask of NEGEDGE field.
	SDMMC_CLKCR_NEGEDGE_Msk = 0x2000
	// Bit NEGEDGE.
	SDMMC_CLKCR_NEGEDGE = 0x2000
	// Position of WIDBUS field.
	SDMMC_CLKCR_WIDBUS_Pos = 0xb
	// Bit mask of WIDBUS field.
	SDMMC_CLKCR_WIDBUS_Msk = 0x1800
	// Position of BYPASS field.
	SDMMC_CLKCR_BYPASS_Pos = 0xa
	// Bit mask of BYPASS field.
	SDMMC_CLKCR_BYPASS_Msk = 0x400
	// Bit BYPASS.
	SDMMC_CLKCR_BYPASS = 0x400
	// Position of PWRSAV field.
	SDMMC_CLKCR_PWRSAV_Pos = 0x9
	// Bit mask of PWRSAV field.
	SDMMC_CLKCR_PWRSAV_Msk = 0x200
	// Bit PWRSAV.
	SDMMC_CLKCR_PWRSAV = 0x200
	// Position of CLKEN field.
	SDMMC_CLKCR_CLKEN_Pos = 0x8
	// Bit mask of CLKEN field.
	SDMMC_CLKCR_CLKEN_Msk = 0x100
	// Bit CLKEN.
	SDMMC_CLKCR_CLKEN = 0x100
	// Position of CLKDIV field.
	SDMMC_CLKCR_CLKDIV_Pos = 0x0
	// Bit mask of CLKDIV field.
	SDMMC_CLKCR_CLKDIV_Msk = 0xff

	// ARG: argument register
	// Position of CMDARG field.
	SDMMC_ARG_CMDARG_Pos = 0x0
	// Bit mask of CMDARG field.
	SDMMC_ARG_CMDARG_Msk = 0xffffffff

	// CMD: command register
	// Position of SDIOSuspend field.
	SDMMC_CMD_SDIOSuspend_Pos = 0xb
	// Bit mask of SDIOSuspend field.
	SDMMC_CMD_SDIOSuspend_Msk = 0x800
	// Bit SDIOSuspend.
	SDMMC_CMD_SDIOSuspend = 0x800
	// Position of CPSMEN field.
	SDMMC_CMD_CPSMEN_Pos = 0xa
	// Bit mask of CPSMEN field.
	SDMMC_CMD_CPSMEN_Msk = 0x400
	// Bit CPSMEN.
	SDMMC_CMD_CPSMEN = 0x400
	// Position of WAITPEND field.
	SDMMC_CMD_WAITPEND_Pos = 0x9
	// Bit mask of WAITPEND field.
	SDMMC_CMD_WAITPEND_Msk = 0x200
	// Bit WAITPEND.
	SDMMC_CMD_WAITPEND = 0x200
	// Position of WAITINT field.
	SDMMC_CMD_WAITINT_Pos = 0x8
	// Bit mask of WAITINT field.
	SDMMC_CMD_WAITINT_Msk = 0x100
	// Bit WAITINT.
	SDMMC_CMD_WAITINT = 0x100
	// Position of WAITRESP field.
	SDMMC_CMD_WAITRESP_Pos = 0x6
	// Bit mask of WAITRESP field.
	SDMMC_CMD_WAITRESP_Msk = 0xc0
	// Position of CMDINDEX field.
	SDMMC_CMD_CMDINDEX_Pos = 0x0
	// Bit mask of CMDINDEX field.
	SDMMC_CMD_CMDINDEX_Msk = 0x3f

	// RESPCMD: command response register
	// Position of RESPCMD field.
	SDMMC_RESPCMD_RESPCMD_Pos = 0x0
	// Bit mask of RESPCMD field.
	SDMMC_RESPCMD_RESPCMD_Msk = 0x3f

	// RESP1: response 1..4 register
	// Position of CARDSTATUS1 field.
	SDMMC_RESP1_CARDSTATUS1_Pos = 0x0
	// Bit mask of CARDSTATUS1 field.
	SDMMC_RESP1_CARDSTATUS1_Msk = 0xffffffff

	// RESP2: response 1..4 register
	// Position of CARDSTATUS2 field.
	SDMMC_RESP2_CARDSTATUS2_Pos = 0x0
	// Bit mask of CARDSTATUS2 field.
	SDMMC_RESP2_CARDSTATUS2_Msk = 0xffffffff

	// RESP3: response 1..4 register
	// Position of CARDSTATUS3 field.
	SDMMC_RESP3_CARDSTATUS3_Pos = 0x0
	// Bit mask of CARDSTATUS3 field.
	SDMMC_RESP3_CARDSTATUS3_Msk = 0xffffffff

	// RESP4: response 1..4 register
	// Position of CARDSTATUS4 field.
	SDMMC_RESP4_CARDSTATUS4_Pos = 0x0
	// Bit mask of CARDSTATUS4 field.
	SDMMC_RESP4_CARDSTATUS4_Msk = 0xffffffff

	// DTIMER: data timer register
	// Position of DATATIME field.
	SDMMC_DTIMER_DATATIME_Pos = 0x0
	// Bit mask of DATATIME field.
	SDMMC_DTIMER_DATATIME_Msk = 0xffffffff

	// DLEN: data length register
	// Position of DATALENGTH field.
	SDMMC_DLEN_DATALENGTH_Pos = 0x0
	// Bit mask of DATALENGTH field.
	SDMMC_DLEN_DATALENGTH_Msk = 0x1ffffff

	// DCTRL: data control register
	// Position of SDIOEN field.
	SDMMC_DCTRL_SDIOEN_Pos = 0xb
	// Bit mask of SDIOEN field.
	SDMMC_DCTRL_SDIOEN_Msk = 0x800
	// Bit SDIOEN.
	SDMMC_DCTRL_SDIOEN = 0x800
	// Position of RWMOD field.
	SDMMC_DCTRL_RWMOD_Pos = 0xa
	// Bit mask of RWMOD field.
	SDMMC_DCTRL_RWMOD_Msk = 0x400
	// Bit RWMOD.
	SDMMC_DCTRL_RWMOD = 0x400
	// Position of RWSTOP field.
	SDMMC_DCTRL_RWSTOP_Pos = 0x9
	// Bit mask of RWSTOP field.
	SDMMC_DCTRL_RWSTOP_Msk = 0x200
	// Bit RWSTOP.
	SDMMC_DCTRL_RWSTOP = 0x200
	// Position of RWSTART field.
	SDMMC_DCTRL_RWSTART_Pos = 0x8
	// Bit mask of RWSTART field.
	SDMMC_DCTRL_RWSTART_Msk = 0x100
	// Bit RWSTART.
	SDMMC_DCTRL_RWSTART = 0x100
	// Position of DBLOCKSIZE field.
	SDMMC_DCTRL_DBLOCKSIZE_Pos = 0x4
	// Bit mask of DBLOCKSIZE field.
	SDMMC_DCTRL_DBLOCKSIZE_Msk = 0xf0
	// Position of DMAEN field.
	SDMMC_DCTRL_DMAEN_Pos = 0x3
	// Bit mask of DMAEN field.
	SDMMC_DCTRL_DMAEN_Msk = 0x8
	// Bit DMAEN.
	SDMMC_DCTRL_DMAEN = 0x8
	// Position of DTMODE field.
	SDMMC_DCTRL_DTMODE_Pos = 0x2
	// Bit mask of DTMODE field.
	SDMMC_DCTRL_DTMODE_Msk = 0x4
	// Bit DTMODE.
	SDMMC_DCTRL_DTMODE = 0x4
	// Position of DTDIR field.
	SDMMC_DCTRL_DTDIR_Pos = 0x1
	// Bit mask of DTDIR field.
	SDMMC_DCTRL_DTDIR_Msk = 0x2
	// Bit DTDIR.
	SDMMC_DCTRL_DTDIR = 0x2
	// Position of DTEN field.
	SDMMC_DCTRL_DTEN_Pos = 0x0
	// Bit mask of DTEN field.
	SDMMC_DCTRL_DTEN_Msk = 0x1
	// Bit DTEN.
	SDMMC_DCTRL_DTEN = 0x1

	// DCOUNT: data counter register
	// Position of DATACOUNT field.
	SDMMC_DCOUNT_DATACOUNT_Pos = 0x0
	// Bit mask of DATACOUNT field.
	SDMMC_DCOUNT_DATACOUNT_Msk = 0x1ffffff

	// STA: status register
	// Position of SDIOIT field.
	SDMMC_STA_SDIOIT_Pos = 0x16
	// Bit mask of SDIOIT field.
	SDMMC_STA_SDIOIT_Msk = 0x400000
	// Bit SDIOIT.
	SDMMC_STA_SDIOIT = 0x400000
	// Position of RXDAVL field.
	SDMMC_STA_RXDAVL_Pos = 0x15
	// Bit mask of RXDAVL field.
	SDMMC_STA_RXDAVL_Msk = 0x200000
	// Bit RXDAVL.
	SDMMC_STA_RXDAVL = 0x200000
	// Position of TXDAVL field.
	SDMMC_STA_TXDAVL_Pos = 0x14
	// Bit mask of TXDAVL field.
	SDMMC_STA_TXDAVL_Msk = 0x100000
	// Bit TXDAVL.
	SDMMC_STA_TXDAVL = 0x100000
	// Position of RXFIFOE field.
	SDMMC_STA_RXFIFOE_Pos = 0x13
	// Bit mask of RXFIFOE field.
	SDMMC_STA_RXFIFOE_Msk = 0x80000
	// Bit RXFIFOE.
	SDMMC_STA_RXFIFOE = 0x80000
	// Position of TXFIFOE field.
	SDMMC_STA_TXFIFOE_Pos = 0x12
	// Bit mask of TXFIFOE field.
	SDMMC_STA_TXFIFOE_Msk = 0x40000
	// Bit TXFIFOE.
	SDMMC_STA_TXFIFOE = 0x40000
	// Position of RXFIFOF field.
	SDMMC_STA_RXFIFOF_Pos = 0x11
	// Bit mask of RXFIFOF field.
	SDMMC_STA_RXFIFOF_Msk = 0x20000
	// Bit RXFIFOF.
	SDMMC_STA_RXFIFOF = 0x20000
	// Position of TXFIFOF field.
	SDMMC_STA_TXFIFOF_Pos = 0x10
	// Bit mask of TXFIFOF field.
	SDMMC_STA_TXFIFOF_Msk = 0x10000
	// Bit TXFIFOF.
	SDMMC_STA_TXFIFOF = 0x10000
	// Position of RXFIFOHF field.
	SDMMC_STA_RXFIFOHF_Pos = 0xf
	// Bit mask of RXFIFOHF field.
	SDMMC_STA_RXFIFOHF_Msk = 0x8000
	// Bit RXFIFOHF.
	SDMMC_STA_RXFIFOHF = 0x8000
	// Position of TXFIFOHE field.
	SDMMC_STA_TXFIFOHE_Pos = 0xe
	// Bit mask of TXFIFOHE field.
	SDMMC_STA_TXFIFOHE_Msk = 0x4000
	// Bit TXFIFOHE.
	SDMMC_STA_TXFIFOHE = 0x4000
	// Position of RXACT field.
	SDMMC_STA_RXACT_Pos = 0xd
	// Bit mask of RXACT field.
	SDMMC_STA_RXACT_Msk = 0x2000
	// Bit RXACT.
	SDMMC_STA_RXACT = 0x2000
	// Position of TXACT field.
	SDMMC_STA_TXACT_Pos = 0xc
	// Bit mask of TXACT field.
	SDMMC_STA_TXACT_Msk = 0x1000
	// Bit TXACT.
	SDMMC_STA_TXACT = 0x1000
	// Position of CMDACT field.
	SDMMC_STA_CMDACT_Pos = 0xb
	// Bit mask of CMDACT field.
	SDMMC_STA_CMDACT_Msk = 0x800
	// Bit CMDACT.
	SDMMC_STA_CMDACT = 0x800
	// Position of DBCKEND field.
	SDMMC_STA_DBCKEND_Pos = 0xa
	// Bit mask of DBCKEND field.
	SDMMC_STA_DBCKEND_Msk = 0x400
	// Bit DBCKEND.
	SDMMC_STA_DBCKEND = 0x400
	// Position of DATAEND field.
	SDMMC_STA_DATAEND_Pos = 0x8
	// Bit mask of DATAEND field.
	SDMMC_STA_DATAEND_Msk = 0x100
	// Bit DATAEND.
	SDMMC_STA_DATAEND = 0x100
	// Position of CMDSENT field.
	SDMMC_STA_CMDSENT_Pos = 0x7
	// Bit mask of CMDSENT field.
	SDMMC_STA_CMDSENT_Msk = 0x80
	// Bit CMDSENT.
	SDMMC_STA_CMDSENT = 0x80
	// Position of CMDREND field.
	SDMMC_STA_CMDREND_Pos = 0x6
	// Bit mask of CMDREND field.
	SDMMC_STA_CMDREND_Msk = 0x40
	// Bit CMDREND.
	SDMMC_STA_CMDREND = 0x40
	// Position of RXOVERR field.
	SDMMC_STA_RXOVERR_Pos = 0x5
	// Bit mask of RXOVERR field.
	SDMMC_STA_RXOVERR_Msk = 0x20
	// Bit RXOVERR.
	SDMMC_STA_RXOVERR = 0x20
	// Position of TXUNDERR field.
	SDMMC_STA_TXUNDERR_Pos = 0x4
	// Bit mask of TXUNDERR field.
	SDMMC_STA_TXUNDERR_Msk = 0x10
	// Bit TXUNDERR.
	SDMMC_STA_TXUNDERR = 0x10
	// Position of DTIMEOUT field.
	SDMMC_STA_DTIMEOUT_Pos = 0x3
	// Bit mask of DTIMEOUT field.
	SDMMC_STA_DTIMEOUT_Msk = 0x8
	// Bit DTIMEOUT.
	SDMMC_STA_DTIMEOUT = 0x8
	// Position of CTIMEOUT field.
	SDMMC_STA_CTIMEOUT_Pos = 0x2
	// Bit mask of CTIMEOUT field.
	SDMMC_STA_CTIMEOUT_Msk = 0x4
	// Bit CTIMEOUT.
	SDMMC_STA_CTIMEOUT = 0x4
	// Position of DCRCFAIL field.
	SDMMC_STA_DCRCFAIL_Pos = 0x1
	// Bit mask of DCRCFAIL field.
	SDMMC_STA_DCRCFAIL_Msk = 0x2
	// Bit DCRCFAIL.
	SDMMC_STA_DCRCFAIL = 0x2
	// Position of CCRCFAIL field.
	SDMMC_STA_CCRCFAIL_Pos = 0x0
	// Bit mask of CCRCFAIL field.
	SDMMC_STA_CCRCFAIL_Msk = 0x1
	// Bit CCRCFAIL.
	SDMMC_STA_CCRCFAIL = 0x1

	// ICR: interrupt clear register
	// Position of SDIOITC field.
	SDMMC_ICR_SDIOITC_Pos = 0x16
	// Bit mask of SDIOITC field.
	SDMMC_ICR_SDIOITC_Msk = 0x400000
	// Bit SDIOITC.
	SDMMC_ICR_SDIOITC = 0x400000
	// Position of DBCKENDC field.
	SDMMC_ICR_DBCKENDC_Pos = 0xa
	// Bit mask of DBCKENDC field.
	SDMMC_ICR_DBCKENDC_Msk = 0x400
	// Bit DBCKENDC.
	SDMMC_ICR_DBCKENDC = 0x400
	// Position of DATAENDC field.
	SDMMC_ICR_DATAENDC_Pos = 0x8
	// Bit mask of DATAENDC field.
	SDMMC_ICR_DATAENDC_Msk = 0x100
	// Bit DATAENDC.
	SDMMC_ICR_DATAENDC = 0x100
	// Position of CMDSENTC field.
	SDMMC_ICR_CMDSENTC_Pos = 0x7
	// Bit mask of CMDSENTC field.
	SDMMC_ICR_CMDSENTC_Msk = 0x80
	// Bit CMDSENTC.
	SDMMC_ICR_CMDSENTC = 0x80
	// Position of CMDRENDC field.
	SDMMC_ICR_CMDRENDC_Pos = 0x6
	// Bit mask of CMDRENDC field.
	SDMMC_ICR_CMDRENDC_Msk = 0x40
	// Bit CMDRENDC.
	SDMMC_ICR_CMDRENDC = 0x40
	// Position of RXOVERRC field.
	SDMMC_ICR_RXOVERRC_Pos = 0x5
	// Bit mask of RXOVERRC field.
	SDMMC_ICR_RXOVERRC_Msk = 0x20
	// Bit RXOVERRC.
	SDMMC_ICR_RXOVERRC = 0x20
	// Position of TXUNDERRC field.
	SDMMC_ICR_TXUNDERRC_Pos = 0x4
	// Bit mask of TXUNDERRC field.
	SDMMC_ICR_TXUNDERRC_Msk = 0x10
	// Bit TXUNDERRC.
	SDMMC_ICR_TXUNDERRC = 0x10
	// Position of DTIMEOUTC field.
	SDMMC_ICR_DTIMEOUTC_Pos = 0x3
	// Bit mask of DTIMEOUTC field.
	SDMMC_ICR_DTIMEOUTC_Msk = 0x8
	// Bit DTIMEOUTC.
	SDMMC_ICR_DTIMEOUTC = 0x8
	// Position of CTIMEOUTC field.
	SDMMC_ICR_CTIMEOUTC_Pos = 0x2
	// Bit mask of CTIMEOUTC field.
	SDMMC_ICR_CTIMEOUTC_Msk = 0x4
	// Bit CTIMEOUTC.
	SDMMC_ICR_CTIMEOUTC = 0x4
	// Position of DCRCFAILC field.
	SDMMC_ICR_DCRCFAILC_Pos = 0x1
	// Bit mask of DCRCFAILC field.
	SDMMC_ICR_DCRCFAILC_Msk = 0x2
	// Bit DCRCFAILC.
	SDMMC_ICR_DCRCFAILC = 0x2
	// Position of CCRCFAILC field.
	SDMMC_ICR_CCRCFAILC_Pos = 0x0
	// Bit mask of CCRCFAILC field.
	SDMMC_ICR_CCRCFAILC_Msk = 0x1
	// Bit CCRCFAILC.
	SDMMC_ICR_CCRCFAILC = 0x1

	// MASK: mask register
	// Position of SDIOITIE field.
	SDMMC_MASK_SDIOITIE_Pos = 0x16
	// Bit mask of SDIOITIE field.
	SDMMC_MASK_SDIOITIE_Msk = 0x400000
	// Bit SDIOITIE.
	SDMMC_MASK_SDIOITIE = 0x400000
	// Position of RXDAVLIE field.
	SDMMC_MASK_RXDAVLIE_Pos = 0x15
	// Bit mask of RXDAVLIE field.
	SDMMC_MASK_RXDAVLIE_Msk = 0x200000
	// Bit RXDAVLIE.
	SDMMC_MASK_RXDAVLIE = 0x200000
	// Position of TXDAVLIE field.
	SDMMC_MASK_TXDAVLIE_Pos = 0x14
	// Bit mask of TXDAVLIE field.
	SDMMC_MASK_TXDAVLIE_Msk = 0x100000
	// Bit TXDAVLIE.
	SDMMC_MASK_TXDAVLIE = 0x100000
	// Position of RXFIFOEIE field.
	SDMMC_MASK_RXFIFOEIE_Pos = 0x13
	// Bit mask of RXFIFOEIE field.
	SDMMC_MASK_RXFIFOEIE_Msk = 0x80000
	// Bit RXFIFOEIE.
	SDMMC_MASK_RXFIFOEIE = 0x80000
	// Position of TXFIFOEIE field.
	SDMMC_MASK_TXFIFOEIE_Pos = 0x12
	// Bit mask of TXFIFOEIE field.
	SDMMC_MASK_TXFIFOEIE_Msk = 0x40000
	// Bit TXFIFOEIE.
	SDMMC_MASK_TXFIFOEIE = 0x40000
	// Position of RXFIFOFIE field.
	SDMMC_MASK_RXFIFOFIE_Pos = 0x11
	// Bit mask of RXFIFOFIE field.
	SDMMC_MASK_RXFIFOFIE_Msk = 0x20000
	// Bit RXFIFOFIE.
	SDMMC_MASK_RXFIFOFIE = 0x20000
	// Position of TXFIFOFIE field.
	SDMMC_MASK_TXFIFOFIE_Pos = 0x10
	// Bit mask of TXFIFOFIE field.
	SDMMC_MASK_TXFIFOFIE_Msk = 0x10000
	// Bit TXFIFOFIE.
	SDMMC_MASK_TXFIFOFIE = 0x10000
	// Position of RXFIFOHFIE field.
	SDMMC_MASK_RXFIFOHFIE_Pos = 0xf
	// Bit mask of RXFIFOHFIE field.
	SDMMC_MASK_RXFIFOHFIE_Msk = 0x8000
	// Bit RXFIFOHFIE.
	SDMMC_MASK_RXFIFOHFIE = 0x8000
	// Position of TXFIFOHEIE field.
	SDMMC_MASK_TXFIFOHEIE_Pos = 0xe
	// Bit mask of TXFIFOHEIE field.
	SDMMC_MASK_TXFIFOHEIE_Msk = 0x4000
	// Bit TXFIFOHEIE.
	SDMMC_MASK_TXFIFOHEIE = 0x4000
	// Position of RXACTIE field.
	SDMMC_MASK_RXACTIE_Pos = 0xd
	// Bit mask of RXACTIE field.
	SDMMC_MASK_RXACTIE_Msk = 0x2000
	// Bit RXACTIE.
	SDMMC_MASK_RXACTIE = 0x2000
	// Position of TXACTIE field.
	SDMMC_MASK_TXACTIE_Pos = 0xc
	// Bit mask of TXACTIE field.
	SDMMC_MASK_TXACTIE_Msk = 0x1000
	// Bit TXACTIE.
	SDMMC_MASK_TXACTIE = 0x1000
	// Position of CMDACTIE field.
	SDMMC_MASK_CMDACTIE_Pos = 0xb
	// Bit mask of CMDACTIE field.
	SDMMC_MASK_CMDACTIE_Msk = 0x800
	// Bit CMDACTIE.
	SDMMC_MASK_CMDACTIE = 0x800
	// Position of DBCKENDIE field.
	SDMMC_MASK_DBCKENDIE_Pos = 0xa
	// Bit mask of DBCKENDIE field.
	SDMMC_MASK_DBCKENDIE_Msk = 0x400
	// Bit DBCKENDIE.
	SDMMC_MASK_DBCKENDIE = 0x400
	// Position of DATAENDIE field.
	SDMMC_MASK_DATAENDIE_Pos = 0x8
	// Bit mask of DATAENDIE field.
	SDMMC_MASK_DATAENDIE_Msk = 0x100
	// Bit DATAENDIE.
	SDMMC_MASK_DATAENDIE = 0x100
	// Position of CMDSENTIE field.
	SDMMC_MASK_CMDSENTIE_Pos = 0x7
	// Bit mask of CMDSENTIE field.
	SDMMC_MASK_CMDSENTIE_Msk = 0x80
	// Bit CMDSENTIE.
	SDMMC_MASK_CMDSENTIE = 0x80
	// Position of CMDRENDIE field.
	SDMMC_MASK_CMDRENDIE_Pos = 0x6
	// Bit mask of CMDRENDIE field.
	SDMMC_MASK_CMDRENDIE_Msk = 0x40
	// Bit CMDRENDIE.
	SDMMC_MASK_CMDRENDIE = 0x40
	// Position of RXOVERRIE field.
	SDMMC_MASK_RXOVERRIE_Pos = 0x5
	// Bit mask of RXOVERRIE field.
	SDMMC_MASK_RXOVERRIE_Msk = 0x20
	// Bit RXOVERRIE.
	SDMMC_MASK_RXOVERRIE = 0x20
	// Position of TXUNDERRIE field.
	SDMMC_MASK_TXUNDERRIE_Pos = 0x4
	// Bit mask of TXUNDERRIE field.
	SDMMC_MASK_TXUNDERRIE_Msk = 0x10
	// Bit TXUNDERRIE.
	SDMMC_MASK_TXUNDERRIE = 0x10
	// Position of DTIMEOUTIE field.
	SDMMC_MASK_DTIMEOUTIE_Pos = 0x3
	// Bit mask of DTIMEOUTIE field.
	SDMMC_MASK_DTIMEOUTIE_Msk = 0x8
	// Bit DTIMEOUTIE.
	SDMMC_MASK_DTIMEOUTIE = 0x8
	// Position of CTIMEOUTIE field.
	SDMMC_MASK_CTIMEOUTIE_Pos = 0x2
	// Bit mask of CTIMEOUTIE field.
	SDMMC_MASK_CTIMEOUTIE_Msk = 0x4
	// Bit CTIMEOUTIE.
	SDMMC_MASK_CTIMEOUTIE = 0x4
	// Position of DCRCFAILIE field.
	SDMMC_MASK_DCRCFAILIE_Pos = 0x1
	// Bit mask of DCRCFAILIE field.
	SDMMC_MASK_DCRCFAILIE_Msk = 0x2
	// Bit DCRCFAILIE.
	SDMMC_MASK_DCRCFAILIE = 0x2
	// Position of CCRCFAILIE field.
	SDMMC_MASK_CCRCFAILIE_Pos = 0x0
	// Bit mask of CCRCFAILIE field.
	SDMMC_MASK_CCRCFAILIE_Msk = 0x1
	// Bit CCRCFAILIE.
	SDMMC_MASK_CCRCFAILIE = 0x1

	// FIFOCNT: FIFO counter register
	// Position of FIFOCOUNT field.
	SDMMC_FIFOCNT_FIFOCOUNT_Pos = 0x0
	// Bit mask of FIFOCOUNT field.
	SDMMC_FIFOCNT_FIFOCOUNT_Msk = 0xffffff

	// FIFO: data FIFO register
	// Position of FIFOData field.
	SDMMC_FIFO_FIFOData_Pos = 0x0
	// Bit mask of FIFOData field.
	SDMMC_FIFO_FIFOData_Msk = 0xffffffff
)

// Constants for LPTIM1: Low power timer
const (
	// ISR: Interrupt and Status Register
	// Position of DOWN field.
	LPTIM_ISR_DOWN_Pos = 0x6
	// Bit mask of DOWN field.
	LPTIM_ISR_DOWN_Msk = 0x40
	// Bit DOWN.
	LPTIM_ISR_DOWN = 0x40
	// Position of UP field.
	LPTIM_ISR_UP_Pos = 0x5
	// Bit mask of UP field.
	LPTIM_ISR_UP_Msk = 0x20
	// Bit UP.
	LPTIM_ISR_UP = 0x20
	// Position of ARROK field.
	LPTIM_ISR_ARROK_Pos = 0x4
	// Bit mask of ARROK field.
	LPTIM_ISR_ARROK_Msk = 0x10
	// Bit ARROK.
	LPTIM_ISR_ARROK = 0x10
	// Position of CMPOK field.
	LPTIM_ISR_CMPOK_Pos = 0x3
	// Bit mask of CMPOK field.
	LPTIM_ISR_CMPOK_Msk = 0x8
	// Bit CMPOK.
	LPTIM_ISR_CMPOK = 0x8
	// Position of EXTTRIG field.
	LPTIM_ISR_EXTTRIG_Pos = 0x2
	// Bit mask of EXTTRIG field.
	LPTIM_ISR_EXTTRIG_Msk = 0x4
	// Bit EXTTRIG.
	LPTIM_ISR_EXTTRIG = 0x4
	// Position of ARRM field.
	LPTIM_ISR_ARRM_Pos = 0x1
	// Bit mask of ARRM field.
	LPTIM_ISR_ARRM_Msk = 0x2
	// Bit ARRM.
	LPTIM_ISR_ARRM = 0x2
	// Position of CMPM field.
	LPTIM_ISR_CMPM_Pos = 0x0
	// Bit mask of CMPM field.
	LPTIM_ISR_CMPM_Msk = 0x1
	// Bit CMPM.
	LPTIM_ISR_CMPM = 0x1

	// ICR: Interrupt Clear Register
	// Position of DOWNCF field.
	LPTIM_ICR_DOWNCF_Pos = 0x6
	// Bit mask of DOWNCF field.
	LPTIM_ICR_DOWNCF_Msk = 0x40
	// Bit DOWNCF.
	LPTIM_ICR_DOWNCF = 0x40
	// Position of UPCF field.
	LPTIM_ICR_UPCF_Pos = 0x5
	// Bit mask of UPCF field.
	LPTIM_ICR_UPCF_Msk = 0x20
	// Bit UPCF.
	LPTIM_ICR_UPCF = 0x20
	// Position of ARROKCF field.
	LPTIM_ICR_ARROKCF_Pos = 0x4
	// Bit mask of ARROKCF field.
	LPTIM_ICR_ARROKCF_Msk = 0x10
	// Bit ARROKCF.
	LPTIM_ICR_ARROKCF = 0x10
	// Position of CMPOKCF field.
	LPTIM_ICR_CMPOKCF_Pos = 0x3
	// Bit mask of CMPOKCF field.
	LPTIM_ICR_CMPOKCF_Msk = 0x8
	// Bit CMPOKCF.
	LPTIM_ICR_CMPOKCF = 0x8
	// Position of EXTTRIGCF field.
	LPTIM_ICR_EXTTRIGCF_Pos = 0x2
	// Bit mask of EXTTRIGCF field.
	LPTIM_ICR_EXTTRIGCF_Msk = 0x4
	// Bit EXTTRIGCF.
	LPTIM_ICR_EXTTRIGCF = 0x4
	// Position of ARRMCF field.
	LPTIM_ICR_ARRMCF_Pos = 0x1
	// Bit mask of ARRMCF field.
	LPTIM_ICR_ARRMCF_Msk = 0x2
	// Bit ARRMCF.
	LPTIM_ICR_ARRMCF = 0x2
	// Position of CMPMCF field.
	LPTIM_ICR_CMPMCF_Pos = 0x0
	// Bit mask of CMPMCF field.
	LPTIM_ICR_CMPMCF_Msk = 0x1
	// Bit CMPMCF.
	LPTIM_ICR_CMPMCF = 0x1

	// IER: Interrupt Enable Register
	// Position of DOWNIE field.
	LPTIM_IER_DOWNIE_Pos = 0x6
	// Bit mask of DOWNIE field.
	LPTIM_IER_DOWNIE_Msk = 0x40
	// Bit DOWNIE.
	LPTIM_IER_DOWNIE = 0x40
	// Position of UPIE field.
	LPTIM_IER_UPIE_Pos = 0x5
	// Bit mask of UPIE field.
	LPTIM_IER_UPIE_Msk = 0x20
	// Bit UPIE.
	LPTIM_IER_UPIE = 0x20
	// Position of ARROKIE field.
	LPTIM_IER_ARROKIE_Pos = 0x4
	// Bit mask of ARROKIE field.
	LPTIM_IER_ARROKIE_Msk = 0x10
	// Bit ARROKIE.
	LPTIM_IER_ARROKIE = 0x10
	// Position of CMPOKIE field.
	LPTIM_IER_CMPOKIE_Pos = 0x3
	// Bit mask of CMPOKIE field.
	LPTIM_IER_CMPOKIE_Msk = 0x8
	// Bit CMPOKIE.
	LPTIM_IER_CMPOKIE = 0x8
	// Position of EXTTRIGIE field.
	LPTIM_IER_EXTTRIGIE_Pos = 0x2
	// Bit mask of EXTTRIGIE field.
	LPTIM_IER_EXTTRIGIE_Msk = 0x4
	// Bit EXTTRIGIE.
	LPTIM_IER_EXTTRIGIE = 0x4
	// Position of ARRMIE field.
	LPTIM_IER_ARRMIE_Pos = 0x1
	// Bit mask of ARRMIE field.
	LPTIM_IER_ARRMIE_Msk = 0x2
	// Bit ARRMIE.
	LPTIM_IER_ARRMIE = 0x2
	// Position of CMPMIE field.
	LPTIM_IER_CMPMIE_Pos = 0x0
	// Bit mask of CMPMIE field.
	LPTIM_IER_CMPMIE_Msk = 0x1
	// Bit CMPMIE.
	LPTIM_IER_CMPMIE = 0x1

	// CFGR: Configuration Register
	// Position of ENC field.
	LPTIM_CFGR_ENC_Pos = 0x18
	// Bit mask of ENC field.
	LPTIM_CFGR_ENC_Msk = 0x1000000
	// Bit ENC.
	LPTIM_CFGR_ENC = 0x1000000
	// Position of COUNTMODE field.
	LPTIM_CFGR_COUNTMODE_Pos = 0x17
	// Bit mask of COUNTMODE field.
	LPTIM_CFGR_COUNTMODE_Msk = 0x800000
	// Bit COUNTMODE.
	LPTIM_CFGR_COUNTMODE = 0x800000
	// Position of PRELOAD field.
	LPTIM_CFGR_PRELOAD_Pos = 0x16
	// Bit mask of PRELOAD field.
	LPTIM_CFGR_PRELOAD_Msk = 0x400000
	// Bit PRELOAD.
	LPTIM_CFGR_PRELOAD = 0x400000
	// Position of WAVPOL field.
	LPTIM_CFGR_WAVPOL_Pos = 0x15
	// Bit mask of WAVPOL field.
	LPTIM_CFGR_WAVPOL_Msk = 0x200000
	// Bit WAVPOL.
	LPTIM_CFGR_WAVPOL = 0x200000
	// Position of WAVE field.
	LPTIM_CFGR_WAVE_Pos = 0x14
	// Bit mask of WAVE field.
	LPTIM_CFGR_WAVE_Msk = 0x100000
	// Bit WAVE.
	LPTIM_CFGR_WAVE = 0x100000
	// Position of TIMOUT field.
	LPTIM_CFGR_TIMOUT_Pos = 0x13
	// Bit mask of TIMOUT field.
	LPTIM_CFGR_TIMOUT_Msk = 0x80000
	// Bit TIMOUT.
	LPTIM_CFGR_TIMOUT = 0x80000
	// Position of TRIGEN field.
	LPTIM_CFGR_TRIGEN_Pos = 0x11
	// Bit mask of TRIGEN field.
	LPTIM_CFGR_TRIGEN_Msk = 0x60000
	// Position of TRIGSEL field.
	LPTIM_CFGR_TRIGSEL_Pos = 0xd
	// Bit mask of TRIGSEL field.
	LPTIM_CFGR_TRIGSEL_Msk = 0xe000
	// Position of PRESC field.
	LPTIM_CFGR_PRESC_Pos = 0x9
	// Bit mask of PRESC field.
	LPTIM_CFGR_PRESC_Msk = 0xe00
	// Position of TRGFLT field.
	LPTIM_CFGR_TRGFLT_Pos = 0x6
	// Bit mask of TRGFLT field.
	LPTIM_CFGR_TRGFLT_Msk = 0xc0
	// Position of CKFLT field.
	LPTIM_CFGR_CKFLT_Pos = 0x3
	// Bit mask of CKFLT field.
	LPTIM_CFGR_CKFLT_Msk = 0x18
	// Position of CKPOL field.
	LPTIM_CFGR_CKPOL_Pos = 0x1
	// Bit mask of CKPOL field.
	LPTIM_CFGR_CKPOL_Msk = 0x6
	// Position of CKSEL field.
	LPTIM_CFGR_CKSEL_Pos = 0x0
	// Bit mask of CKSEL field.
	LPTIM_CFGR_CKSEL_Msk = 0x1
	// Bit CKSEL.
	LPTIM_CFGR_CKSEL = 0x1

	// CR: Control Register
	// Position of CNTSTRT field.
	LPTIM_CR_CNTSTRT_Pos = 0x2
	// Bit mask of CNTSTRT field.
	LPTIM_CR_CNTSTRT_Msk = 0x4
	// Bit CNTSTRT.
	LPTIM_CR_CNTSTRT = 0x4
	// Position of SNGSTRT field.
	LPTIM_CR_SNGSTRT_Pos = 0x1
	// Bit mask of SNGSTRT field.
	LPTIM_CR_SNGSTRT_Msk = 0x2
	// Bit SNGSTRT.
	LPTIM_CR_SNGSTRT = 0x2
	// Position of ENABLE field.
	LPTIM_CR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	LPTIM_CR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	LPTIM_CR_ENABLE = 0x1

	// CMP: Compare Register
	// Position of CMP field.
	LPTIM_CMP_CMP_Pos = 0x0
	// Bit mask of CMP field.
	LPTIM_CMP_CMP_Msk = 0xffff

	// ARR: Autoreload Register
	// Position of ARR field.
	LPTIM_ARR_ARR_Pos = 0x0
	// Bit mask of ARR field.
	LPTIM_ARR_ARR_Msk = 0xffff

	// CNT: Counter Register
	// Position of CNT field.
	LPTIM_CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	LPTIM_CNT_CNT_Msk = 0xffff
)

// Constants for I2C1: Inter-integrated circuit
const (
	// CR1: Control register 1
	// Position of PE field.
	I2C_CR1_PE_Pos = 0x0
	// Bit mask of PE field.
	I2C_CR1_PE_Msk = 0x1
	// Bit PE.
	I2C_CR1_PE = 0x1
	// Peripheral disabled
	I2C_CR1_PE_Disabled = 0x0
	// Peripheral enabled
	I2C_CR1_PE_Enabled = 0x1
	// Position of TXIE field.
	I2C_CR1_TXIE_Pos = 0x1
	// Bit mask of TXIE field.
	I2C_CR1_TXIE_Msk = 0x2
	// Bit TXIE.
	I2C_CR1_TXIE = 0x2
	// Transmit (TXIS) interrupt disabled
	I2C_CR1_TXIE_Disabled = 0x0
	// Transmit (TXIS) interrupt enabled
	I2C_CR1_TXIE_Enabled = 0x1
	// Position of RXIE field.
	I2C_CR1_RXIE_Pos = 0x2
	// Bit mask of RXIE field.
	I2C_CR1_RXIE_Msk = 0x4
	// Bit RXIE.
	I2C_CR1_RXIE = 0x4
	// Receive (RXNE) interrupt disabled
	I2C_CR1_RXIE_Disabled = 0x0
	// Receive (RXNE) interrupt enabled
	I2C_CR1_RXIE_Enabled = 0x1
	// Position of ADDRIE field.
	I2C_CR1_ADDRIE_Pos = 0x3
	// Bit mask of ADDRIE field.
	I2C_CR1_ADDRIE_Msk = 0x8
	// Bit ADDRIE.
	I2C_CR1_ADDRIE = 0x8
	// Address match (ADDR) interrupts disabled
	I2C_CR1_ADDRIE_Disabled = 0x0
	// Address match (ADDR) interrupts enabled
	I2C_CR1_ADDRIE_Enabled = 0x1
	// Position of NACKIE field.
	I2C_CR1_NACKIE_Pos = 0x4
	// Bit mask of NACKIE field.
	I2C_CR1_NACKIE_Msk = 0x10
	// Bit NACKIE.
	I2C_CR1_NACKIE = 0x10
	// Not acknowledge (NACKF) received interrupts disabled
	I2C_CR1_NACKIE_Disabled = 0x0
	// Not acknowledge (NACKF) received interrupts enabled
	I2C_CR1_NACKIE_Enabled = 0x1
	// Position of STOPIE field.
	I2C_CR1_STOPIE_Pos = 0x5
	// Bit mask of STOPIE field.
	I2C_CR1_STOPIE_Msk = 0x20
	// Bit STOPIE.
	I2C_CR1_STOPIE = 0x20
	// Stop detection (STOPF) interrupt disabled
	I2C_CR1_STOPIE_Disabled = 0x0
	// Stop detection (STOPF) interrupt enabled
	I2C_CR1_STOPIE_Enabled = 0x1
	// Position of TCIE field.
	I2C_CR1_TCIE_Pos = 0x6
	// Bit mask of TCIE field.
	I2C_CR1_TCIE_Msk = 0x40
	// Bit TCIE.
	I2C_CR1_TCIE = 0x40
	// Transfer Complete interrupt disabled
	I2C_CR1_TCIE_Disabled = 0x0
	// Transfer Complete interrupt enabled
	I2C_CR1_TCIE_Enabled = 0x1
	// Position of ERRIE field.
	I2C_CR1_ERRIE_Pos = 0x7
	// Bit mask of ERRIE field.
	I2C_CR1_ERRIE_Msk = 0x80
	// Bit ERRIE.
	I2C_CR1_ERRIE = 0x80
	// Error detection interrupts disabled
	I2C_CR1_ERRIE_Disabled = 0x0
	// Error detection interrupts enabled
	I2C_CR1_ERRIE_Enabled = 0x1
	// Position of DNF field.
	I2C_CR1_DNF_Pos = 0x8
	// Bit mask of DNF field.
	I2C_CR1_DNF_Msk = 0xf00
	// Digital filter disabled
	I2C_CR1_DNF_NoFilter = 0x0
	// Digital filter enabled and filtering capability up to 1 tI2CCLK
	I2C_CR1_DNF_Filter1 = 0x1
	// Digital filter enabled and filtering capability up to 2 tI2CCLK
	I2C_CR1_DNF_Filter2 = 0x2
	// Digital filter enabled and filtering capability up to 3 tI2CCLK
	I2C_CR1_DNF_Filter3 = 0x3
	// Digital filter enabled and filtering capability up to 4 tI2CCLK
	I2C_CR1_DNF_Filter4 = 0x4
	// Digital filter enabled and filtering capability up to 5 tI2CCLK
	I2C_CR1_DNF_Filter5 = 0x5
	// Digital filter enabled and filtering capability up to 6 tI2CCLK
	I2C_CR1_DNF_Filter6 = 0x6
	// Digital filter enabled and filtering capability up to 7 tI2CCLK
	I2C_CR1_DNF_Filter7 = 0x7
	// Digital filter enabled and filtering capability up to 8 tI2CCLK
	I2C_CR1_DNF_Filter8 = 0x8
	// Digital filter enabled and filtering capability up to 9 tI2CCLK
	I2C_CR1_DNF_Filter9 = 0x9
	// Digital filter enabled and filtering capability up to 10 tI2CCLK
	I2C_CR1_DNF_Filter10 = 0xa
	// Digital filter enabled and filtering capability up to 11 tI2CCLK
	I2C_CR1_DNF_Filter11 = 0xb
	// Digital filter enabled and filtering capability up to 12 tI2CCLK
	I2C_CR1_DNF_Filter12 = 0xc
	// Digital filter enabled and filtering capability up to 13 tI2CCLK
	I2C_CR1_DNF_Filter13 = 0xd
	// Digital filter enabled and filtering capability up to 14 tI2CCLK
	I2C_CR1_DNF_Filter14 = 0xe
	// Digital filter enabled and filtering capability up to 15 tI2CCLK
	I2C_CR1_DNF_Filter15 = 0xf
	// Position of ANFOFF field.
	I2C_CR1_ANFOFF_Pos = 0xc
	// Bit mask of ANFOFF field.
	I2C_CR1_ANFOFF_Msk = 0x1000
	// Bit ANFOFF.
	I2C_CR1_ANFOFF = 0x1000
	// Analog noise filter enabled
	I2C_CR1_ANFOFF_Enabled = 0x0
	// Analog noise filter disabled
	I2C_CR1_ANFOFF_Disabled = 0x1
	// Position of TXDMAEN field.
	I2C_CR1_TXDMAEN_Pos = 0xe
	// Bit mask of TXDMAEN field.
	I2C_CR1_TXDMAEN_Msk = 0x4000
	// Bit TXDMAEN.
	I2C_CR1_TXDMAEN = 0x4000
	// DMA mode disabled for transmission
	I2C_CR1_TXDMAEN_Disabled = 0x0
	// DMA mode enabled for transmission
	I2C_CR1_TXDMAEN_Enabled = 0x1
	// Position of RXDMAEN field.
	I2C_CR1_RXDMAEN_Pos = 0xf
	// Bit mask of RXDMAEN field.
	I2C_CR1_RXDMAEN_Msk = 0x8000
	// Bit RXDMAEN.
	I2C_CR1_RXDMAEN = 0x8000
	// DMA mode disabled for reception
	I2C_CR1_RXDMAEN_Disabled = 0x0
	// DMA mode enabled for reception
	I2C_CR1_RXDMAEN_Enabled = 0x1
	// Position of SBC field.
	I2C_CR1_SBC_Pos = 0x10
	// Bit mask of SBC field.
	I2C_CR1_SBC_Msk = 0x10000
	// Bit SBC.
	I2C_CR1_SBC = 0x10000
	// Slave byte control disabled
	I2C_CR1_SBC_Disabled = 0x0
	// Slave byte control enabled
	I2C_CR1_SBC_Enabled = 0x1
	// Position of NOSTRETCH field.
	I2C_CR1_NOSTRETCH_Pos = 0x11
	// Bit mask of NOSTRETCH field.
	I2C_CR1_NOSTRETCH_Msk = 0x20000
	// Bit NOSTRETCH.
	I2C_CR1_NOSTRETCH = 0x20000
	// Clock stretching enabled
	I2C_CR1_NOSTRETCH_Enabled = 0x0
	// Clock stretching disabled
	I2C_CR1_NOSTRETCH_Disabled = 0x1
	// Position of WUPEN field.
	I2C_CR1_WUPEN_Pos = 0x12
	// Bit mask of WUPEN field.
	I2C_CR1_WUPEN_Msk = 0x40000
	// Bit WUPEN.
	I2C_CR1_WUPEN = 0x40000
	// Wakeup from Stop mode disabled
	I2C_CR1_WUPEN_Disabled = 0x0
	// Wakeup from Stop mode enabled
	I2C_CR1_WUPEN_Enabled = 0x1
	// Position of GCEN field.
	I2C_CR1_GCEN_Pos = 0x13
	// Bit mask of GCEN field.
	I2C_CR1_GCEN_Msk = 0x80000
	// Bit GCEN.
	I2C_CR1_GCEN = 0x80000
	// General call disabled. Address 0b00000000 is NACKed
	I2C_CR1_GCEN_Disabled = 0x0
	// General call enabled. Address 0b00000000 is ACKed
	I2C_CR1_GCEN_Enabled = 0x1
	// Position of SMBHEN field.
	I2C_CR1_SMBHEN_Pos = 0x14
	// Bit mask of SMBHEN field.
	I2C_CR1_SMBHEN_Msk = 0x100000
	// Bit SMBHEN.
	I2C_CR1_SMBHEN = 0x100000
	// Host address disabled. Address 0b0001000x is NACKed
	I2C_CR1_SMBHEN_Disabled = 0x0
	// Host address enabled. Address 0b0001000x is ACKed
	I2C_CR1_SMBHEN_Enabled = 0x1
	// Position of SMBDEN field.
	I2C_CR1_SMBDEN_Pos = 0x15
	// Bit mask of SMBDEN field.
	I2C_CR1_SMBDEN_Msk = 0x200000
	// Bit SMBDEN.
	I2C_CR1_SMBDEN = 0x200000
	// Device default address disabled. Address 0b1100001x is NACKed
	I2C_CR1_SMBDEN_Disabled = 0x0
	// Device default address enabled. Address 0b1100001x is ACKed
	I2C_CR1_SMBDEN_Enabled = 0x1
	// Position of ALERTEN field.
	I2C_CR1_ALERTEN_Pos = 0x16
	// Bit mask of ALERTEN field.
	I2C_CR1_ALERTEN_Msk = 0x400000
	// Bit ALERTEN.
	I2C_CR1_ALERTEN = 0x400000
	// In device mode (SMBHEN=Disabled) Releases SMBA pin high and Alert Response Address Header disabled (0001100x) followed by NACK. In host mode (SMBHEN=Enabled) SMBus Alert pin (SMBA) not supported
	I2C_CR1_ALERTEN_Disabled = 0x0
	// In device mode (SMBHEN=Disabled) Drives SMBA pin low and Alert Response Address Header enabled (0001100x) followed by ACK.In host mode (SMBHEN=Enabled) SMBus Alert pin (SMBA) supported
	I2C_CR1_ALERTEN_Enabled = 0x1
	// Position of PECEN field.
	I2C_CR1_PECEN_Pos = 0x17
	// Bit mask of PECEN field.
	I2C_CR1_PECEN_Msk = 0x800000
	// Bit PECEN.
	I2C_CR1_PECEN = 0x800000
	// PEC calculation disabled
	I2C_CR1_PECEN_Disabled = 0x0
	// PEC calculation enabled
	I2C_CR1_PECEN_Enabled = 0x1

	// CR2: Control register 2
	// Position of PECBYTE field.
	I2C_CR2_PECBYTE_Pos = 0x1a
	// Bit mask of PECBYTE field.
	I2C_CR2_PECBYTE_Msk = 0x4000000
	// Bit PECBYTE.
	I2C_CR2_PECBYTE = 0x4000000
	// No PEC transfer
	I2C_CR2_PECBYTE_NoPec = 0x0
	// PEC transmission/reception is requested
	I2C_CR2_PECBYTE_Pec = 0x1
	// Position of AUTOEND field.
	I2C_CR2_AUTOEND_Pos = 0x19
	// Bit mask of AUTOEND field.
	I2C_CR2_AUTOEND_Msk = 0x2000000
	// Bit AUTOEND.
	I2C_CR2_AUTOEND = 0x2000000
	// Software end mode: TC flag is set when NBYTES data are transferred, stretching SCL low
	I2C_CR2_AUTOEND_Software = 0x0
	// Automatic end mode: a STOP condition is automatically sent when NBYTES data are transferred
	I2C_CR2_AUTOEND_Automatic = 0x1
	// Position of RELOAD field.
	I2C_CR2_RELOAD_Pos = 0x18
	// Bit mask of RELOAD field.
	I2C_CR2_RELOAD_Msk = 0x1000000
	// Bit RELOAD.
	I2C_CR2_RELOAD = 0x1000000
	// The transfer is completed after the NBYTES data transfer (STOP or RESTART will follow)
	I2C_CR2_RELOAD_Completed = 0x0
	// The transfer is not completed after the NBYTES data transfer (NBYTES will be reloaded)
	I2C_CR2_RELOAD_NotCompleted = 0x1
	// Position of NBYTES field.
	I2C_CR2_NBYTES_Pos = 0x10
	// Bit mask of NBYTES field.
	I2C_CR2_NBYTES_Msk = 0xff0000
	// Position of NACK field.
	I2C_CR2_NACK_Pos = 0xf
	// Bit mask of NACK field.
	I2C_CR2_NACK_Msk = 0x8000
	// Bit NACK.
	I2C_CR2_NACK = 0x8000
	// an ACK is sent after current received byte
	I2C_CR2_NACK_Ack = 0x0
	// a NACK is sent after current received byte
	I2C_CR2_NACK_Nack = 0x1
	// Position of STOP field.
	I2C_CR2_STOP_Pos = 0xe
	// Bit mask of STOP field.
	I2C_CR2_STOP_Msk = 0x4000
	// Bit STOP.
	I2C_CR2_STOP = 0x4000
	// No Stop generation
	I2C_CR2_STOP_NoStop = 0x0
	// Stop generation after current byte transfer
	I2C_CR2_STOP_Stop = 0x1
	// Position of START field.
	I2C_CR2_START_Pos = 0xd
	// Bit mask of START field.
	I2C_CR2_START_Msk = 0x2000
	// Bit START.
	I2C_CR2_START = 0x2000
	// No Start generation
	I2C_CR2_START_NoStart = 0x0
	// Restart/Start generation
	I2C_CR2_START_Start = 0x1
	// Position of HEAD10R field.
	I2C_CR2_HEAD10R_Pos = 0xc
	// Bit mask of HEAD10R field.
	I2C_CR2_HEAD10R_Msk = 0x1000
	// Bit HEAD10R.
	I2C_CR2_HEAD10R = 0x1000
	// The master sends the complete 10 bit slave address read sequence
	I2C_CR2_HEAD10R_Complete = 0x0
	// The master only sends the 1st 7 bits of the 10 bit address, followed by Read direction
	I2C_CR2_HEAD10R_Partial = 0x1
	// Position of ADD10 field.
	I2C_CR2_ADD10_Pos = 0xb
	// Bit mask of ADD10 field.
	I2C_CR2_ADD10_Msk = 0x800
	// Bit ADD10.
	I2C_CR2_ADD10 = 0x800
	// The master operates in 7-bit addressing mode
	I2C_CR2_ADD10_Bit7 = 0x0
	// The master operates in 10-bit addressing mode
	I2C_CR2_ADD10_Bit10 = 0x1
	// Position of RD_WRN field.
	I2C_CR2_RD_WRN_Pos = 0xa
	// Bit mask of RD_WRN field.
	I2C_CR2_RD_WRN_Msk = 0x400
	// Bit RD_WRN.
	I2C_CR2_RD_WRN = 0x400
	// Master requests a write transfer
	I2C_CR2_RD_WRN_Write = 0x0
	// Master requests a read transfer
	I2C_CR2_RD_WRN_Read = 0x1
	// Position of SADD field.
	I2C_CR2_SADD_Pos = 0x0
	// Bit mask of SADD field.
	I2C_CR2_SADD_Msk = 0x3ff

	// OAR1: Own address register 1
	// Position of OA1 field.
	I2C_OAR1_OA1_Pos = 0x0
	// Bit mask of OA1 field.
	I2C_OAR1_OA1_Msk = 0x3ff
	// Position of OA1MODE field.
	I2C_OAR1_OA1MODE_Pos = 0xa
	// Bit mask of OA1MODE field.
	I2C_OAR1_OA1MODE_Msk = 0x400
	// Bit OA1MODE.
	I2C_OAR1_OA1MODE = 0x400
	// Own address 1 is a 7-bit address
	I2C_OAR1_OA1MODE_Bit7 = 0x0
	// Own address 1 is a 10-bit address
	I2C_OAR1_OA1MODE_Bit10 = 0x1
	// Position of OA1EN field.
	I2C_OAR1_OA1EN_Pos = 0xf
	// Bit mask of OA1EN field.
	I2C_OAR1_OA1EN_Msk = 0x8000
	// Bit OA1EN.
	I2C_OAR1_OA1EN = 0x8000
	// Own address 1 disabled. The received slave address OA1 is NACKed
	I2C_OAR1_OA1EN_Disabled = 0x0
	// Own address 1 enabled. The received slave address OA1 is ACKed
	I2C_OAR1_OA1EN_Enabled = 0x1

	// OAR2: Own address register 2
	// Position of OA2 field.
	I2C_OAR2_OA2_Pos = 0x1
	// Bit mask of OA2 field.
	I2C_OAR2_OA2_Msk = 0xfe
	// Position of OA2MSK field.
	I2C_OAR2_OA2MSK_Pos = 0x8
	// Bit mask of OA2MSK field.
	I2C_OAR2_OA2MSK_Msk = 0x700
	// No mask
	I2C_OAR2_OA2MSK_NoMask = 0x0
	// OA2[1] is masked and dont care. Only OA2[7:2] are compared
	I2C_OAR2_OA2MSK_Mask1 = 0x1
	// OA2[2:1] are masked and dont care. Only OA2[7:3] are compared
	I2C_OAR2_OA2MSK_Mask2 = 0x2
	// OA2[3:1] are masked and dont care. Only OA2[7:4] are compared
	I2C_OAR2_OA2MSK_Mask3 = 0x3
	// OA2[4:1] are masked and dont care. Only OA2[7:5] are compared
	I2C_OAR2_OA2MSK_Mask4 = 0x4
	// OA2[5:1] are masked and dont care. Only OA2[7:6] are compared
	I2C_OAR2_OA2MSK_Mask5 = 0x5
	// OA2[6:1] are masked and dont care. Only OA2[7] is compared.
	I2C_OAR2_OA2MSK_Mask6 = 0x6
	// OA2[7:1] are masked and dont care. No comparison is done, and all (except reserved) 7-bit received addresses are acknowledged
	I2C_OAR2_OA2MSK_Mask7 = 0x7
	// Position of OA2EN field.
	I2C_OAR2_OA2EN_Pos = 0xf
	// Bit mask of OA2EN field.
	I2C_OAR2_OA2EN_Msk = 0x8000
	// Bit OA2EN.
	I2C_OAR2_OA2EN = 0x8000
	// Own address 2 disabled. The received slave address OA2 is NACKed
	I2C_OAR2_OA2EN_Disabled = 0x0
	// Own address 2 enabled. The received slave address OA2 is ACKed
	I2C_OAR2_OA2EN_Enabled = 0x1

	// TIMINGR: Timing register
	// Position of SCLL field.
	I2C_TIMINGR_SCLL_Pos = 0x0
	// Bit mask of SCLL field.
	I2C_TIMINGR_SCLL_Msk = 0xff
	// Position of SCLH field.
	I2C_TIMINGR_SCLH_Pos = 0x8
	// Bit mask of SCLH field.
	I2C_TIMINGR_SCLH_Msk = 0xff00
	// Position of SDADEL field.
	I2C_TIMINGR_SDADEL_Pos = 0x10
	// Bit mask of SDADEL field.
	I2C_TIMINGR_SDADEL_Msk = 0xf0000
	// Position of SCLDEL field.
	I2C_TIMINGR_SCLDEL_Pos = 0x14
	// Bit mask of SCLDEL field.
	I2C_TIMINGR_SCLDEL_Msk = 0xf00000
	// Position of PRESC field.
	I2C_TIMINGR_PRESC_Pos = 0x1c
	// Bit mask of PRESC field.
	I2C_TIMINGR_PRESC_Msk = 0xf0000000

	// TIMEOUTR: Status register 1
	// Position of TIMEOUTA field.
	I2C_TIMEOUTR_TIMEOUTA_Pos = 0x0
	// Bit mask of TIMEOUTA field.
	I2C_TIMEOUTR_TIMEOUTA_Msk = 0xfff
	// Position of TIDLE field.
	I2C_TIMEOUTR_TIDLE_Pos = 0xc
	// Bit mask of TIDLE field.
	I2C_TIMEOUTR_TIDLE_Msk = 0x1000
	// Bit TIDLE.
	I2C_TIMEOUTR_TIDLE = 0x1000
	// TIMEOUTA is used to detect SCL low timeout
	I2C_TIMEOUTR_TIDLE_Disabled = 0x0
	// TIMEOUTA is used to detect both SCL and SDA high timeout (bus idle condition)
	I2C_TIMEOUTR_TIDLE_Enabled = 0x1
	// Position of TIMOUTEN field.
	I2C_TIMEOUTR_TIMOUTEN_Pos = 0xf
	// Bit mask of TIMOUTEN field.
	I2C_TIMEOUTR_TIMOUTEN_Msk = 0x8000
	// Bit TIMOUTEN.
	I2C_TIMEOUTR_TIMOUTEN = 0x8000
	// SCL timeout detection is disabled
	I2C_TIMEOUTR_TIMOUTEN_Disabled = 0x0
	// SCL timeout detection is enabled
	I2C_TIMEOUTR_TIMOUTEN_Enabled = 0x1
	// Position of TIMEOUTB field.
	I2C_TIMEOUTR_TIMEOUTB_Pos = 0x10
	// Bit mask of TIMEOUTB field.
	I2C_TIMEOUTR_TIMEOUTB_Msk = 0xfff0000
	// Position of TEXTEN field.
	I2C_TIMEOUTR_TEXTEN_Pos = 0x1f
	// Bit mask of TEXTEN field.
	I2C_TIMEOUTR_TEXTEN_Msk = 0x80000000
	// Bit TEXTEN.
	I2C_TIMEOUTR_TEXTEN = 0x80000000
	// Extended clock timeout detection is disabled
	I2C_TIMEOUTR_TEXTEN_Disabled = 0x0
	// Extended clock timeout detection is enabled
	I2C_TIMEOUTR_TEXTEN_Enabled = 0x1

	// ISR: Interrupt and Status register
	// Position of ADDCODE field.
	I2C_ISR_ADDCODE_Pos = 0x11
	// Bit mask of ADDCODE field.
	I2C_ISR_ADDCODE_Msk = 0xfe0000
	// Position of DIR field.
	I2C_ISR_DIR_Pos = 0x10
	// Bit mask of DIR field.
	I2C_ISR_DIR_Msk = 0x10000
	// Bit DIR.
	I2C_ISR_DIR = 0x10000
	// Write transfer, slave enters receiver mode
	I2C_ISR_DIR_Write = 0x0
	// Read transfer, slave enters transmitter mode
	I2C_ISR_DIR_Read = 0x1
	// Position of BUSY field.
	I2C_ISR_BUSY_Pos = 0xf
	// Bit mask of BUSY field.
	I2C_ISR_BUSY_Msk = 0x8000
	// Bit BUSY.
	I2C_ISR_BUSY = 0x8000
	// No communication is in progress on the bus
	I2C_ISR_BUSY_NotBusy = 0x0
	// A communication is in progress on the bus
	I2C_ISR_BUSY_Busy = 0x1
	// Position of ALERT field.
	I2C_ISR_ALERT_Pos = 0xd
	// Bit mask of ALERT field.
	I2C_ISR_ALERT_Msk = 0x2000
	// Bit ALERT.
	I2C_ISR_ALERT = 0x2000
	// SMBA alert is not detected
	I2C_ISR_ALERT_NoAlert = 0x0
	// SMBA alert event is detected on SMBA pin
	I2C_ISR_ALERT_Alert = 0x1
	// Position of TIMEOUT field.
	I2C_ISR_TIMEOUT_Pos = 0xc
	// Bit mask of TIMEOUT field.
	I2C_ISR_TIMEOUT_Msk = 0x1000
	// Bit TIMEOUT.
	I2C_ISR_TIMEOUT = 0x1000
	// No timeout occured
	I2C_ISR_TIMEOUT_NoTimeout = 0x0
	// Timeout occured
	I2C_ISR_TIMEOUT_Timeout = 0x1
	// Position of PECERR field.
	I2C_ISR_PECERR_Pos = 0xb
	// Bit mask of PECERR field.
	I2C_ISR_PECERR_Msk = 0x800
	// Bit PECERR.
	I2C_ISR_PECERR = 0x800
	// Received PEC does match with PEC register
	I2C_ISR_PECERR_Match = 0x0
	// Received PEC does not match with PEC register
	I2C_ISR_PECERR_NoMatch = 0x1
	// Position of OVR field.
	I2C_ISR_OVR_Pos = 0xa
	// Bit mask of OVR field.
	I2C_ISR_OVR_Msk = 0x400
	// Bit OVR.
	I2C_ISR_OVR = 0x400
	// No overrun/underrun error occurs
	I2C_ISR_OVR_NoOverrun = 0x0
	// slave mode with NOSTRETCH=1, when an overrun/underrun error occurs
	I2C_ISR_OVR_Overrun = 0x1
	// Position of ARLO field.
	I2C_ISR_ARLO_Pos = 0x9
	// Bit mask of ARLO field.
	I2C_ISR_ARLO_Msk = 0x200
	// Bit ARLO.
	I2C_ISR_ARLO = 0x200
	// No arbitration lost
	I2C_ISR_ARLO_NotLost = 0x0
	// Arbitration lost
	I2C_ISR_ARLO_Lost = 0x1
	// Position of BERR field.
	I2C_ISR_BERR_Pos = 0x8
	// Bit mask of BERR field.
	I2C_ISR_BERR_Msk = 0x100
	// Bit BERR.
	I2C_ISR_BERR = 0x100
	// No bus error
	I2C_ISR_BERR_NoError = 0x0
	// Misplaced Start and Stop condition is detected
	I2C_ISR_BERR_Error = 0x1
	// Position of TCR field.
	I2C_ISR_TCR_Pos = 0x7
	// Bit mask of TCR field.
	I2C_ISR_TCR_Msk = 0x80
	// Bit TCR.
	I2C_ISR_TCR = 0x80
	// Transfer is not complete
	I2C_ISR_TCR_NotComplete = 0x0
	// NBYTES has been transfered
	I2C_ISR_TCR_Complete = 0x1
	// Position of TC field.
	I2C_ISR_TC_Pos = 0x6
	// Bit mask of TC field.
	I2C_ISR_TC_Msk = 0x40
	// Bit TC.
	I2C_ISR_TC = 0x40
	// Transfer is not complete
	I2C_ISR_TC_NotComplete = 0x0
	// NBYTES has been transfered
	I2C_ISR_TC_Complete = 0x1
	// Position of STOPF field.
	I2C_ISR_STOPF_Pos = 0x5
	// Bit mask of STOPF field.
	I2C_ISR_STOPF_Msk = 0x20
	// Bit STOPF.
	I2C_ISR_STOPF = 0x20
	// No Stop condition detected
	I2C_ISR_STOPF_NoStop = 0x0
	// Stop condition detected
	I2C_ISR_STOPF_Stop = 0x1
	// Position of NACKF field.
	I2C_ISR_NACKF_Pos = 0x4
	// Bit mask of NACKF field.
	I2C_ISR_NACKF_Msk = 0x10
	// Bit NACKF.
	I2C_ISR_NACKF = 0x10
	// No NACK has been received
	I2C_ISR_NACKF_NoNack = 0x0
	// NACK has been received
	I2C_ISR_NACKF_Nack = 0x1
	// Position of ADDR field.
	I2C_ISR_ADDR_Pos = 0x3
	// Bit mask of ADDR field.
	I2C_ISR_ADDR_Msk = 0x8
	// Bit ADDR.
	I2C_ISR_ADDR = 0x8
	// Adress mismatched or not received
	I2C_ISR_ADDR_NotMatch = 0x0
	// Received slave address matched with one of the enabled slave addresses
	I2C_ISR_ADDR_Match = 0x1
	// Position of RXNE field.
	I2C_ISR_RXNE_Pos = 0x2
	// Bit mask of RXNE field.
	I2C_ISR_RXNE_Msk = 0x4
	// Bit RXNE.
	I2C_ISR_RXNE = 0x4
	// The RXDR register is empty
	I2C_ISR_RXNE_Empty = 0x0
	// Received data is copied into the RXDR register, and is ready to be read
	I2C_ISR_RXNE_NotEmpty = 0x1
	// Position of TXIS field.
	I2C_ISR_TXIS_Pos = 0x1
	// Bit mask of TXIS field.
	I2C_ISR_TXIS_Msk = 0x2
	// Bit TXIS.
	I2C_ISR_TXIS = 0x2
	// The TXDR register is not empty
	I2C_ISR_TXIS_NotEmpty = 0x0
	// The TXDR register is empty and the data to be transmitted must be written in the TXDR register
	I2C_ISR_TXIS_Empty = 0x1
	// Position of TXE field.
	I2C_ISR_TXE_Pos = 0x0
	// Bit mask of TXE field.
	I2C_ISR_TXE_Msk = 0x1
	// Bit TXE.
	I2C_ISR_TXE = 0x1
	// TXDR register not empty
	I2C_ISR_TXE_NotEmpty = 0x0
	// TXDR register empty
	I2C_ISR_TXE_Empty = 0x1

	// ICR: Interrupt clear register
	// Position of ALERTCF field.
	I2C_ICR_ALERTCF_Pos = 0xd
	// Bit mask of ALERTCF field.
	I2C_ICR_ALERTCF_Msk = 0x2000
	// Bit ALERTCF.
	I2C_ICR_ALERTCF = 0x2000
	// Clears the ALERT flag in ISR register
	I2C_ICR_ALERTCF_Clear = 0x1
	// Position of TIMOUTCF field.
	I2C_ICR_TIMOUTCF_Pos = 0xc
	// Bit mask of TIMOUTCF field.
	I2C_ICR_TIMOUTCF_Msk = 0x1000
	// Bit TIMOUTCF.
	I2C_ICR_TIMOUTCF = 0x1000
	// Clears the TIMOUT flag in ISR register
	I2C_ICR_TIMOUTCF_Clear = 0x1
	// Position of PECCF field.
	I2C_ICR_PECCF_Pos = 0xb
	// Bit mask of PECCF field.
	I2C_ICR_PECCF_Msk = 0x800
	// Bit PECCF.
	I2C_ICR_PECCF = 0x800
	// Clears the PEC flag in ISR register
	I2C_ICR_PECCF_Clear = 0x1
	// Position of OVRCF field.
	I2C_ICR_OVRCF_Pos = 0xa
	// Bit mask of OVRCF field.
	I2C_ICR_OVRCF_Msk = 0x400
	// Bit OVRCF.
	I2C_ICR_OVRCF = 0x400
	// Clears the OVR flag in ISR register
	I2C_ICR_OVRCF_Clear = 0x1
	// Position of ARLOCF field.
	I2C_ICR_ARLOCF_Pos = 0x9
	// Bit mask of ARLOCF field.
	I2C_ICR_ARLOCF_Msk = 0x200
	// Bit ARLOCF.
	I2C_ICR_ARLOCF = 0x200
	// Clears the ARLO flag in ISR register
	I2C_ICR_ARLOCF_Clear = 0x1
	// Position of BERRCF field.
	I2C_ICR_BERRCF_Pos = 0x8
	// Bit mask of BERRCF field.
	I2C_ICR_BERRCF_Msk = 0x100
	// Bit BERRCF.
	I2C_ICR_BERRCF = 0x100
	// Clears the BERR flag in ISR register
	I2C_ICR_BERRCF_Clear = 0x1
	// Position of STOPCF field.
	I2C_ICR_STOPCF_Pos = 0x5
	// Bit mask of STOPCF field.
	I2C_ICR_STOPCF_Msk = 0x20
	// Bit STOPCF.
	I2C_ICR_STOPCF = 0x20
	// Clears the STOP flag in ISR register
	I2C_ICR_STOPCF_Clear = 0x1
	// Position of NACKCF field.
	I2C_ICR_NACKCF_Pos = 0x4
	// Bit mask of NACKCF field.
	I2C_ICR_NACKCF_Msk = 0x10
	// Bit NACKCF.
	I2C_ICR_NACKCF = 0x10
	// Clears the NACK flag in ISR register
	I2C_ICR_NACKCF_Clear = 0x1
	// Position of ADDRCF field.
	I2C_ICR_ADDRCF_Pos = 0x3
	// Bit mask of ADDRCF field.
	I2C_ICR_ADDRCF_Msk = 0x8
	// Bit ADDRCF.
	I2C_ICR_ADDRCF = 0x8
	// Clears the ADDR flag in ISR register
	I2C_ICR_ADDRCF_Clear = 0x1

	// PECR: PEC register
	// Position of PEC field.
	I2C_PECR_PEC_Pos = 0x0
	// Bit mask of PEC field.
	I2C_PECR_PEC_Msk = 0xff

	// RXDR: Receive data register
	// Position of RXDATA field.
	I2C_RXDR_RXDATA_Pos = 0x0
	// Bit mask of RXDATA field.
	I2C_RXDR_RXDATA_Msk = 0xff

	// TXDR: Transmit data register
	// Position of TXDATA field.
	I2C_TXDR_TXDATA_Pos = 0x0
	// Bit mask of TXDATA field.
	I2C_TXDR_TXDATA_Msk = 0xff
)

// Constants for RTC: Real-time clock
const (
	// TR: time register
	// Position of PM field.
	RTC_TR_PM_Pos = 0x16
	// Bit mask of PM field.
	RTC_TR_PM_Msk = 0x400000
	// Bit PM.
	RTC_TR_PM = 0x400000
	// AM or 24-hour format
	RTC_TR_PM_AM = 0x0
	// PM
	RTC_TR_PM_PM = 0x1
	// Position of HT field.
	RTC_TR_HT_Pos = 0x14
	// Bit mask of HT field.
	RTC_TR_HT_Msk = 0x300000
	// Position of HU field.
	RTC_TR_HU_Pos = 0x10
	// Bit mask of HU field.
	RTC_TR_HU_Msk = 0xf0000
	// Position of MNT field.
	RTC_TR_MNT_Pos = 0xc
	// Bit mask of MNT field.
	RTC_TR_MNT_Msk = 0x7000
	// Position of MNU field.
	RTC_TR_MNU_Pos = 0x8
	// Bit mask of MNU field.
	RTC_TR_MNU_Msk = 0xf00
	// Position of ST field.
	RTC_TR_ST_Pos = 0x4
	// Bit mask of ST field.
	RTC_TR_ST_Msk = 0x70
	// Position of SU field.
	RTC_TR_SU_Pos = 0x0
	// Bit mask of SU field.
	RTC_TR_SU_Msk = 0xf

	// DR: date register
	// Position of YT field.
	RTC_DR_YT_Pos = 0x14
	// Bit mask of YT field.
	RTC_DR_YT_Msk = 0xf00000
	// Position of YU field.
	RTC_DR_YU_Pos = 0x10
	// Bit mask of YU field.
	RTC_DR_YU_Msk = 0xf0000
	// Position of WDU field.
	RTC_DR_WDU_Pos = 0xd
	// Bit mask of WDU field.
	RTC_DR_WDU_Msk = 0xe000
	// Position of MT field.
	RTC_DR_MT_Pos = 0xc
	// Bit mask of MT field.
	RTC_DR_MT_Msk = 0x1000
	// Bit MT.
	RTC_DR_MT = 0x1000
	// Position of MU field.
	RTC_DR_MU_Pos = 0x8
	// Bit mask of MU field.
	RTC_DR_MU_Msk = 0xf00
	// Position of DT field.
	RTC_DR_DT_Pos = 0x4
	// Bit mask of DT field.
	RTC_DR_DT_Msk = 0x30
	// Position of DU field.
	RTC_DR_DU_Pos = 0x0
	// Bit mask of DU field.
	RTC_DR_DU_Msk = 0xf

	// CR: control register
	// Position of WUCKSEL field.
	RTC_CR_WUCKSEL_Pos = 0x0
	// Bit mask of WUCKSEL field.
	RTC_CR_WUCKSEL_Msk = 0x7
	// RTC/16 clock is selected
	RTC_CR_WUCKSEL_Div16 = 0x0
	// RTC/8 clock is selected
	RTC_CR_WUCKSEL_Div8 = 0x1
	// RTC/4 clock is selected
	RTC_CR_WUCKSEL_Div4 = 0x2
	// RTC/2 clock is selected
	RTC_CR_WUCKSEL_Div2 = 0x3
	// ck_spre (usually 1 Hz) clock is selected
	RTC_CR_WUCKSEL_ClockSpare = 0x4
	// ck_spre (usually 1 Hz) clock is selected and 2^16 is added to the WUT counter value
	RTC_CR_WUCKSEL_ClockSpareWithOffset = 0x6
	// Position of TSEDGE field.
	RTC_CR_TSEDGE_Pos = 0x3
	// Bit mask of TSEDGE field.
	RTC_CR_TSEDGE_Msk = 0x8
	// Bit TSEDGE.
	RTC_CR_TSEDGE = 0x8
	// RTC_TS input rising edge generates a time-stamp event
	RTC_CR_TSEDGE_RisingEdge = 0x0
	// RTC_TS input falling edge generates a time-stamp event
	RTC_CR_TSEDGE_FallingEdge = 0x1
	// Position of REFCKON field.
	RTC_CR_REFCKON_Pos = 0x4
	// Bit mask of REFCKON field.
	RTC_CR_REFCKON_Msk = 0x10
	// Bit REFCKON.
	RTC_CR_REFCKON = 0x10
	// RTC_REFIN detection disabled
	RTC_CR_REFCKON_Disabled = 0x0
	// RTC_REFIN detection enabled
	RTC_CR_REFCKON_Enabled = 0x1
	// Position of BYPSHAD field.
	RTC_CR_BYPSHAD_Pos = 0x5
	// Bit mask of BYPSHAD field.
	RTC_CR_BYPSHAD_Msk = 0x20
	// Bit BYPSHAD.
	RTC_CR_BYPSHAD = 0x20
	// Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken from the shadow registers, which are updated once every two RTCCLK cycles
	RTC_CR_BYPSHAD_ShadowReg = 0x0
	// Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken directly from the calendar counters
	RTC_CR_BYPSHAD_BypassShadowReg = 0x1
	// Position of FMT field.
	RTC_CR_FMT_Pos = 0x6
	// Bit mask of FMT field.
	RTC_CR_FMT_Msk = 0x40
	// Bit FMT.
	RTC_CR_FMT = 0x40
	// 24 hour/day format
	RTC_CR_FMT_Twenty_Four_Hour = 0x0
	// AM/PM hour format
	RTC_CR_FMT_AM_PM = 0x1
	// Position of ALRAE field.
	RTC_CR_ALRAE_Pos = 0x8
	// Bit mask of ALRAE field.
	RTC_CR_ALRAE_Msk = 0x100
	// Bit ALRAE.
	RTC_CR_ALRAE = 0x100
	// Alarm A disabled
	RTC_CR_ALRAE_Disabled = 0x0
	// Alarm A enabled
	RTC_CR_ALRAE_Enabled = 0x1
	// Position of ALRBE field.
	RTC_CR_ALRBE_Pos = 0x9
	// Bit mask of ALRBE field.
	RTC_CR_ALRBE_Msk = 0x200
	// Bit ALRBE.
	RTC_CR_ALRBE = 0x200
	// Alarm B disabled
	RTC_CR_ALRBE_Disabled = 0x0
	// Alarm B enabled
	RTC_CR_ALRBE_Enabled = 0x1
	// Position of WUTE field.
	RTC_CR_WUTE_Pos = 0xa
	// Bit mask of WUTE field.
	RTC_CR_WUTE_Msk = 0x400
	// Bit WUTE.
	RTC_CR_WUTE = 0x400
	// Wakeup timer disabled
	RTC_CR_WUTE_Disabled = 0x0
	// Wakeup timer enabled
	RTC_CR_WUTE_Enabled = 0x1
	// Position of TSE field.
	RTC_CR_TSE_Pos = 0xb
	// Bit mask of TSE field.
	RTC_CR_TSE_Msk = 0x800
	// Bit TSE.
	RTC_CR_TSE = 0x800
	// Timestamp disabled
	RTC_CR_TSE_Disabled = 0x0
	// Timestamp enabled
	RTC_CR_TSE_Enabled = 0x1
	// Position of ALRAIE field.
	RTC_CR_ALRAIE_Pos = 0xc
	// Bit mask of ALRAIE field.
	RTC_CR_ALRAIE_Msk = 0x1000
	// Bit ALRAIE.
	RTC_CR_ALRAIE = 0x1000
	// Alarm A interrupt disabled
	RTC_CR_ALRAIE_Disabled = 0x0
	// Alarm A interrupt enabled
	RTC_CR_ALRAIE_Enabled = 0x1
	// Position of ALRBIE field.
	RTC_CR_ALRBIE_Pos = 0xd
	// Bit mask of ALRBIE field.
	RTC_CR_ALRBIE_Msk = 0x2000
	// Bit ALRBIE.
	RTC_CR_ALRBIE = 0x2000
	// Alarm B Interrupt disabled
	RTC_CR_ALRBIE_Disabled = 0x0
	// Alarm B Interrupt enabled
	RTC_CR_ALRBIE_Enabled = 0x1
	// Position of WUTIE field.
	RTC_CR_WUTIE_Pos = 0xe
	// Bit mask of WUTIE field.
	RTC_CR_WUTIE_Msk = 0x4000
	// Bit WUTIE.
	RTC_CR_WUTIE = 0x4000
	// Wakeup timer interrupt disabled
	RTC_CR_WUTIE_Disabled = 0x0
	// Wakeup timer interrupt enabled
	RTC_CR_WUTIE_Enabled = 0x1
	// Position of TSIE field.
	RTC_CR_TSIE_Pos = 0xf
	// Bit mask of TSIE field.
	RTC_CR_TSIE_Msk = 0x8000
	// Bit TSIE.
	RTC_CR_TSIE = 0x8000
	// Time-stamp Interrupt disabled
	RTC_CR_TSIE_Disabled = 0x0
	// Time-stamp Interrupt enabled
	RTC_CR_TSIE_Enabled = 0x1
	// Position of ADD1H field.
	RTC_CR_ADD1H_Pos = 0x10
	// Bit mask of ADD1H field.
	RTC_CR_ADD1H_Msk = 0x10000
	// Bit ADD1H.
	RTC_CR_ADD1H = 0x10000
	// Adds 1 hour to the current time. This can be used for summer time change outside initialization mode
	RTC_CR_ADD1H_Add1 = 0x1
	// Position of SUB1H field.
	RTC_CR_SUB1H_Pos = 0x11
	// Bit mask of SUB1H field.
	RTC_CR_SUB1H_Msk = 0x20000
	// Bit SUB1H.
	RTC_CR_SUB1H = 0x20000
	// Subtracts 1 hour to the current time. This can be used for winter time change outside initialization mode
	RTC_CR_SUB1H_Sub1 = 0x1
	// Position of BKP field.
	RTC_CR_BKP_Pos = 0x12
	// Bit mask of BKP field.
	RTC_CR_BKP_Msk = 0x40000
	// Bit BKP.
	RTC_CR_BKP = 0x40000
	// Daylight Saving Time change has not been performed
	RTC_CR_BKP_DST_Not_Changed = 0x0
	// Daylight Saving Time change has been performed
	RTC_CR_BKP_DST_Changed = 0x1
	// Position of COSEL field.
	RTC_CR_COSEL_Pos = 0x13
	// Bit mask of COSEL field.
	RTC_CR_COSEL_Msk = 0x80000
	// Bit COSEL.
	RTC_CR_COSEL = 0x80000
	// Calibration output is 512 Hz (with default prescaler setting)
	RTC_CR_COSEL_CalFreq_512Hz = 0x0
	// Calibration output is 1 Hz (with default prescaler setting)
	RTC_CR_COSEL_CalFreq_1Hz = 0x1
	// Position of POL field.
	RTC_CR_POL_Pos = 0x14
	// Bit mask of POL field.
	RTC_CR_POL_Msk = 0x100000
	// Bit POL.
	RTC_CR_POL = 0x100000
	// The pin is high when ALRAF/ALRBF/WUTF is asserted (depending on OSEL[1:0])
	RTC_CR_POL_High = 0x0
	// The pin is low when ALRAF/ALRBF/WUTF is asserted (depending on OSEL[1:0])
	RTC_CR_POL_Low = 0x1
	// Position of OSEL field.
	RTC_CR_OSEL_Pos = 0x15
	// Bit mask of OSEL field.
	RTC_CR_OSEL_Msk = 0x600000
	// Output disabled
	RTC_CR_OSEL_Disabled = 0x0
	// Alarm A output enabled
	RTC_CR_OSEL_AlarmA = 0x1
	// Alarm B output enabled
	RTC_CR_OSEL_AlarmB = 0x2
	// Wakeup output enabled
	RTC_CR_OSEL_Wakeup = 0x3
	// Position of COE field.
	RTC_CR_COE_Pos = 0x17
	// Bit mask of COE field.
	RTC_CR_COE_Msk = 0x800000
	// Bit COE.
	RTC_CR_COE = 0x800000
	// Calibration output disabled
	RTC_CR_COE_Disabled = 0x0
	// Calibration output enabled
	RTC_CR_COE_Enabled = 0x1
	// Position of ITSE field.
	RTC_CR_ITSE_Pos = 0x18
	// Bit mask of ITSE field.
	RTC_CR_ITSE_Msk = 0x1000000
	// Bit ITSE.
	RTC_CR_ITSE = 0x1000000

	// ISR: initialization and status register
	// Position of ALRAWF field.
	RTC_ISR_ALRAWF_Pos = 0x0
	// Bit mask of ALRAWF field.
	RTC_ISR_ALRAWF_Msk = 0x1
	// Bit ALRAWF.
	RTC_ISR_ALRAWF = 0x1
	// Alarm update not allowed
	RTC_ISR_ALRAWF_UpdateNotAllowed = 0x0
	// Alarm update allowed
	RTC_ISR_ALRAWF_UpdateAllowed = 0x1
	// Position of ALRBWF field.
	RTC_ISR_ALRBWF_Pos = 0x1
	// Bit mask of ALRBWF field.
	RTC_ISR_ALRBWF_Msk = 0x2
	// Bit ALRBWF.
	RTC_ISR_ALRBWF = 0x2
	// Alarm update not allowed
	RTC_ISR_ALRBWF_UpdateNotAllowed = 0x0
	// Alarm update allowed
	RTC_ISR_ALRBWF_UpdateAllowed = 0x1
	// Position of WUTWF field.
	RTC_ISR_WUTWF_Pos = 0x2
	// Bit mask of WUTWF field.
	RTC_ISR_WUTWF_Msk = 0x4
	// Bit WUTWF.
	RTC_ISR_WUTWF = 0x4
	// Wakeup timer configuration update not allowed
	RTC_ISR_WUTWF_UpdateNotAllowed = 0x0
	// Wakeup timer configuration update allowed
	RTC_ISR_WUTWF_UpdateAllowed = 0x1
	// Position of SHPF field.
	RTC_ISR_SHPF_Pos = 0x3
	// Bit mask of SHPF field.
	RTC_ISR_SHPF_Msk = 0x8
	// Bit SHPF.
	RTC_ISR_SHPF = 0x8
	// No shift operation is pending
	RTC_ISR_SHPF_NoShiftPending = 0x0
	// A shift operation is pending
	RTC_ISR_SHPF_ShiftPending = 0x1
	// Position of INITS field.
	RTC_ISR_INITS_Pos = 0x4
	// Bit mask of INITS field.
	RTC_ISR_INITS_Msk = 0x10
	// Bit INITS.
	RTC_ISR_INITS = 0x10
	// Calendar has not been initialized
	RTC_ISR_INITS_NotInitalized = 0x0
	// Calendar has been initialized
	RTC_ISR_INITS_Initalized = 0x1
	// Position of RSF field.
	RTC_ISR_RSF_Pos = 0x5
	// Bit mask of RSF field.
	RTC_ISR_RSF_Msk = 0x20
	// Bit RSF.
	RTC_ISR_RSF = 0x20
	// Calendar shadow registers not yet synchronized
	RTC_ISR_RSF_NotSynced = 0x0
	// Calendar shadow registers synchronized
	RTC_ISR_RSF_Synced = 0x1
	// This flag is cleared by software by writing 0
	RTC_ISR_RSF_Clear = 0x0
	// Position of INITF field.
	RTC_ISR_INITF_Pos = 0x6
	// Bit mask of INITF field.
	RTC_ISR_INITF_Msk = 0x40
	// Bit INITF.
	RTC_ISR_INITF = 0x40
	// Calendar registers update is not allowed
	RTC_ISR_INITF_NotAllowed = 0x0
	// Calendar registers update is allowed
	RTC_ISR_INITF_Allowed = 0x1
	// Position of INIT field.
	RTC_ISR_INIT_Pos = 0x7
	// Bit mask of INIT field.
	RTC_ISR_INIT_Msk = 0x80
	// Bit INIT.
	RTC_ISR_INIT = 0x80
	// Free running mode
	RTC_ISR_INIT_FreeRunningMode = 0x0
	// Initialization mode used to program time and date register (RTC_TR and RTC_DR), and prescaler register (RTC_PRER). Counters are stopped and start counting from the new value when INIT is reset.
	RTC_ISR_INIT_InitMode = 0x1
	// Position of ALRAF field.
	RTC_ISR_ALRAF_Pos = 0x8
	// Bit mask of ALRAF field.
	RTC_ISR_ALRAF_Msk = 0x100
	// Bit ALRAF.
	RTC_ISR_ALRAF = 0x100
	// This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm A register (RTC_ALRMAR)
	RTC_ISR_ALRAF_Match = 0x1
	// This flag is cleared by software by writing 0
	RTC_ISR_ALRAF_Clear = 0x0
	// Position of ALRBF field.
	RTC_ISR_ALRBF_Pos = 0x9
	// Bit mask of ALRBF field.
	RTC_ISR_ALRBF_Msk = 0x200
	// Bit ALRBF.
	RTC_ISR_ALRBF = 0x200
	// This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm B register (RTC_ALRMBR)
	RTC_ISR_ALRBF_Match = 0x1
	// This flag is cleared by software by writing 0
	RTC_ISR_ALRBF_Clear = 0x0
	// Position of WUTF field.
	RTC_ISR_WUTF_Pos = 0xa
	// Bit mask of WUTF field.
	RTC_ISR_WUTF_Msk = 0x400
	// Bit WUTF.
	RTC_ISR_WUTF = 0x400
	// This flag is set by hardware when the wakeup auto-reload counter reaches 0
	RTC_ISR_WUTF_Zero = 0x1
	// This flag is cleared by software by writing 0
	RTC_ISR_WUTF_Clear = 0x0
	// Position of TSF field.
	RTC_ISR_TSF_Pos = 0xb
	// Bit mask of TSF field.
	RTC_ISR_TSF_Msk = 0x800
	// Bit TSF.
	RTC_ISR_TSF = 0x800
	// This flag is set by hardware when a time-stamp event occurs
	RTC_ISR_TSF_TimestampEvent = 0x1
	// This flag is cleared by software by writing 0
	RTC_ISR_TSF_Clear = 0x0
	// Position of TSOVF field.
	RTC_ISR_TSOVF_Pos = 0xc
	// Bit mask of TSOVF field.
	RTC_ISR_TSOVF_Msk = 0x1000
	// Bit TSOVF.
	RTC_ISR_TSOVF = 0x1000
	// This flag is set by hardware when a time-stamp event occurs while TSF is already set
	RTC_ISR_TSOVF_Overflow = 0x1
	// This flag is cleared by software by writing 0
	RTC_ISR_TSOVF_Clear = 0x0
	// Position of TAMP1F field.
	RTC_ISR_TAMP1F_Pos = 0xd
	// Bit mask of TAMP1F field.
	RTC_ISR_TAMP1F_Msk = 0x2000
	// Bit TAMP1F.
	RTC_ISR_TAMP1F = 0x2000
	// This flag is set by hardware when a tamper detection event is detected on the RTC_TAMPx input
	RTC_ISR_TAMP1F_Tampered = 0x1
	// Flag cleared by software writing 0
	RTC_ISR_TAMP1F_Clear = 0x0
	// Position of TAMP2F field.
	RTC_ISR_TAMP2F_Pos = 0xe
	// Bit mask of TAMP2F field.
	RTC_ISR_TAMP2F_Msk = 0x4000
	// Bit TAMP2F.
	RTC_ISR_TAMP2F = 0x4000
	// This flag is set by hardware when a tamper detection event is detected on the RTC_TAMPx input
	RTC_ISR_TAMP2F_Tampered = 0x1
	// Flag cleared by software writing 0
	RTC_ISR_TAMP2F_Clear = 0x0
	// Position of TAMP3F field.
	RTC_ISR_TAMP3F_Pos = 0xf
	// Bit mask of TAMP3F field.
	RTC_ISR_TAMP3F_Msk = 0x8000
	// Bit TAMP3F.
	RTC_ISR_TAMP3F = 0x8000
	// This flag is set by hardware when a tamper detection event is detected on the RTC_TAMPx input
	RTC_ISR_TAMP3F_Tampered = 0x1
	// Flag cleared by software writing 0
	RTC_ISR_TAMP3F_Clear = 0x0
	// Position of RECALPF field.
	RTC_ISR_RECALPF_Pos = 0x10
	// Bit mask of RECALPF field.
	RTC_ISR_RECALPF_Msk = 0x10000
	// Bit RECALPF.
	RTC_ISR_RECALPF = 0x10000
	// The RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0
	RTC_ISR_RECALPF_Pending = 0x1

	// PRER: prescaler register
	// Position of PREDIV_A field.
	RTC_PRER_PREDIV_A_Pos = 0x10
	// Bit mask of PREDIV_A field.
	RTC_PRER_PREDIV_A_Msk = 0x7f0000
	// Position of PREDIV_S field.
	RTC_PRER_PREDIV_S_Pos = 0x0
	// Bit mask of PREDIV_S field.
	RTC_PRER_PREDIV_S_Msk = 0x7fff

	// WUTR: wakeup timer register
	// Position of WUT field.
	RTC_WUTR_WUT_Pos = 0x0
	// Bit mask of WUT field.
	RTC_WUTR_WUT_Msk = 0xffff

	// ALRMAR: alarm A register
	// Position of MSK4 field.
	RTC_ALRMAR_MSK4_Pos = 0x1f
	// Bit mask of MSK4 field.
	RTC_ALRMAR_MSK4_Msk = 0x80000000
	// Bit MSK4.
	RTC_ALRMAR_MSK4 = 0x80000000
	// Alarm set if the date/day match
	RTC_ALRMAR_MSK4_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMAR_MSK4_NotMask = 0x1
	// Position of WDSEL field.
	RTC_ALRMAR_WDSEL_Pos = 0x1e
	// Bit mask of WDSEL field.
	RTC_ALRMAR_WDSEL_Msk = 0x40000000
	// Bit WDSEL.
	RTC_ALRMAR_WDSEL = 0x40000000
	// DU[3:0] represents the date units
	RTC_ALRMAR_WDSEL_DateUnits = 0x0
	// DU[3:0] represents the week day. DT[1:0] is dont care.
	RTC_ALRMAR_WDSEL_WeekDay = 0x1
	// Position of DT field.
	RTC_ALRMAR_DT_Pos = 0x1c
	// Bit mask of DT field.
	RTC_ALRMAR_DT_Msk = 0x30000000
	// Position of DU field.
	RTC_ALRMAR_DU_Pos = 0x18
	// Bit mask of DU field.
	RTC_ALRMAR_DU_Msk = 0xf000000
	// Position of MSK3 field.
	RTC_ALRMAR_MSK3_Pos = 0x17
	// Bit mask of MSK3 field.
	RTC_ALRMAR_MSK3_Msk = 0x800000
	// Bit MSK3.
	RTC_ALRMAR_MSK3 = 0x800000
	// Alarm set if the date/day match
	RTC_ALRMAR_MSK3_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMAR_MSK3_NotMask = 0x1
	// Position of PM field.
	RTC_ALRMAR_PM_Pos = 0x16
	// Bit mask of PM field.
	RTC_ALRMAR_PM_Msk = 0x400000
	// Bit PM.
	RTC_ALRMAR_PM = 0x400000
	// AM or 24-hour format
	RTC_ALRMAR_PM_AM = 0x0
	// PM
	RTC_ALRMAR_PM_PM = 0x1
	// Position of HT field.
	RTC_ALRMAR_HT_Pos = 0x14
	// Bit mask of HT field.
	RTC_ALRMAR_HT_Msk = 0x300000
	// Position of HU field.
	RTC_ALRMAR_HU_Pos = 0x10
	// Bit mask of HU field.
	RTC_ALRMAR_HU_Msk = 0xf0000
	// Position of MSK2 field.
	RTC_ALRMAR_MSK2_Pos = 0xf
	// Bit mask of MSK2 field.
	RTC_ALRMAR_MSK2_Msk = 0x8000
	// Bit MSK2.
	RTC_ALRMAR_MSK2 = 0x8000
	// Alarm set if the date/day match
	RTC_ALRMAR_MSK2_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMAR_MSK2_NotMask = 0x1
	// Position of MNT field.
	RTC_ALRMAR_MNT_Pos = 0xc
	// Bit mask of MNT field.
	RTC_ALRMAR_MNT_Msk = 0x7000
	// Position of MNU field.
	RTC_ALRMAR_MNU_Pos = 0x8
	// Bit mask of MNU field.
	RTC_ALRMAR_MNU_Msk = 0xf00
	// Position of MSK1 field.
	RTC_ALRMAR_MSK1_Pos = 0x7
	// Bit mask of MSK1 field.
	RTC_ALRMAR_MSK1_Msk = 0x80
	// Bit MSK1.
	RTC_ALRMAR_MSK1 = 0x80
	// Alarm set if the date/day match
	RTC_ALRMAR_MSK1_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMAR_MSK1_NotMask = 0x1
	// Position of ST field.
	RTC_ALRMAR_ST_Pos = 0x4
	// Bit mask of ST field.
	RTC_ALRMAR_ST_Msk = 0x70
	// Position of SU field.
	RTC_ALRMAR_SU_Pos = 0x0
	// Bit mask of SU field.
	RTC_ALRMAR_SU_Msk = 0xf

	// ALRMBR: alarm B register
	// Position of MSK4 field.
	RTC_ALRMBR_MSK4_Pos = 0x1f
	// Bit mask of MSK4 field.
	RTC_ALRMBR_MSK4_Msk = 0x80000000
	// Bit MSK4.
	RTC_ALRMBR_MSK4 = 0x80000000
	// Alarm set if the date/day match
	RTC_ALRMBR_MSK4_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMBR_MSK4_NotMask = 0x1
	// Position of WDSEL field.
	RTC_ALRMBR_WDSEL_Pos = 0x1e
	// Bit mask of WDSEL field.
	RTC_ALRMBR_WDSEL_Msk = 0x40000000
	// Bit WDSEL.
	RTC_ALRMBR_WDSEL = 0x40000000
	// DU[3:0] represents the date units
	RTC_ALRMBR_WDSEL_DateUnits = 0x0
	// DU[3:0] represents the week day. DT[1:0] is dont care.
	RTC_ALRMBR_WDSEL_WeekDay = 0x1
	// Position of DT field.
	RTC_ALRMBR_DT_Pos = 0x1c
	// Bit mask of DT field.
	RTC_ALRMBR_DT_Msk = 0x30000000
	// Position of DU field.
	RTC_ALRMBR_DU_Pos = 0x18
	// Bit mask of DU field.
	RTC_ALRMBR_DU_Msk = 0xf000000
	// Position of MSK3 field.
	RTC_ALRMBR_MSK3_Pos = 0x17
	// Bit mask of MSK3 field.
	RTC_ALRMBR_MSK3_Msk = 0x800000
	// Bit MSK3.
	RTC_ALRMBR_MSK3 = 0x800000
	// Alarm set if the date/day match
	RTC_ALRMBR_MSK3_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMBR_MSK3_NotMask = 0x1
	// Position of PM field.
	RTC_ALRMBR_PM_Pos = 0x16
	// Bit mask of PM field.
	RTC_ALRMBR_PM_Msk = 0x400000
	// Bit PM.
	RTC_ALRMBR_PM = 0x400000
	// AM or 24-hour format
	RTC_ALRMBR_PM_AM = 0x0
	// PM
	RTC_ALRMBR_PM_PM = 0x1
	// Position of HT field.
	RTC_ALRMBR_HT_Pos = 0x14
	// Bit mask of HT field.
	RTC_ALRMBR_HT_Msk = 0x300000
	// Position of HU field.
	RTC_ALRMBR_HU_Pos = 0x10
	// Bit mask of HU field.
	RTC_ALRMBR_HU_Msk = 0xf0000
	// Position of MSK2 field.
	RTC_ALRMBR_MSK2_Pos = 0xf
	// Bit mask of MSK2 field.
	RTC_ALRMBR_MSK2_Msk = 0x8000
	// Bit MSK2.
	RTC_ALRMBR_MSK2 = 0x8000
	// Alarm set if the date/day match
	RTC_ALRMBR_MSK2_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMBR_MSK2_NotMask = 0x1
	// Position of MNT field.
	RTC_ALRMBR_MNT_Pos = 0xc
	// Bit mask of MNT field.
	RTC_ALRMBR_MNT_Msk = 0x7000
	// Position of MNU field.
	RTC_ALRMBR_MNU_Pos = 0x8
	// Bit mask of MNU field.
	RTC_ALRMBR_MNU_Msk = 0xf00
	// Position of MSK1 field.
	RTC_ALRMBR_MSK1_Pos = 0x7
	// Bit mask of MSK1 field.
	RTC_ALRMBR_MSK1_Msk = 0x80
	// Bit MSK1.
	RTC_ALRMBR_MSK1 = 0x80
	// Alarm set if the date/day match
	RTC_ALRMBR_MSK1_Mask = 0x0
	// Date/day dont care in Alarm comparison
	RTC_ALRMBR_MSK1_NotMask = 0x1
	// Position of ST field.
	RTC_ALRMBR_ST_Pos = 0x4
	// Bit mask of ST field.
	RTC_ALRMBR_ST_Msk = 0x70
	// Position of SU field.
	RTC_ALRMBR_SU_Pos = 0x0
	// Bit mask of SU field.
	RTC_ALRMBR_SU_Msk = 0xf

	// WPR: write protection register
	// Position of KEY field.
	RTC_WPR_KEY_Pos = 0x0
	// Bit mask of KEY field.
	RTC_WPR_KEY_Msk = 0xff

	// SSR: sub second register
	// Position of SS field.
	RTC_SSR_SS_Pos = 0x0
	// Bit mask of SS field.
	RTC_SSR_SS_Msk = 0xffff

	// SHIFTR: shift control register
	// Position of ADD1S field.
	RTC_SHIFTR_ADD1S_Pos = 0x1f
	// Bit mask of ADD1S field.
	RTC_SHIFTR_ADD1S_Msk = 0x80000000
	// Bit ADD1S.
	RTC_SHIFTR_ADD1S = 0x80000000
	// Add one second to the clock/calendar
	RTC_SHIFTR_ADD1S_Add1 = 0x1
	// Position of SUBFS field.
	RTC_SHIFTR_SUBFS_Pos = 0x0
	// Bit mask of SUBFS field.
	RTC_SHIFTR_SUBFS_Msk = 0x7fff

	// TSTR: time stamp time register
	// Position of SU field.
	RTC_TSTR_SU_Pos = 0x0
	// Bit mask of SU field.
	RTC_TSTR_SU_Msk = 0xf
	// Position of ST field.
	RTC_TSTR_ST_Pos = 0x4
	// Bit mask of ST field.
	RTC_TSTR_ST_Msk = 0x70
	// Position of MNU field.
	RTC_TSTR_MNU_Pos = 0x8
	// Bit mask of MNU field.
	RTC_TSTR_MNU_Msk = 0xf00
	// Position of MNT field.
	RTC_TSTR_MNT_Pos = 0xc
	// Bit mask of MNT field.
	RTC_TSTR_MNT_Msk = 0x7000
	// Position of HU field.
	RTC_TSTR_HU_Pos = 0x10
	// Bit mask of HU field.
	RTC_TSTR_HU_Msk = 0xf0000
	// Position of HT field.
	RTC_TSTR_HT_Pos = 0x14
	// Bit mask of HT field.
	RTC_TSTR_HT_Msk = 0x300000
	// Position of PM field.
	RTC_TSTR_PM_Pos = 0x16
	// Bit mask of PM field.
	RTC_TSTR_PM_Msk = 0x400000
	// Bit PM.
	RTC_TSTR_PM = 0x400000

	// TSDR: time stamp date register
	// Position of WDU field.
	RTC_TSDR_WDU_Pos = 0xd
	// Bit mask of WDU field.
	RTC_TSDR_WDU_Msk = 0xe000
	// Position of MT field.
	RTC_TSDR_MT_Pos = 0xc
	// Bit mask of MT field.
	RTC_TSDR_MT_Msk = 0x1000
	// Bit MT.
	RTC_TSDR_MT = 0x1000
	// Position of MU field.
	RTC_TSDR_MU_Pos = 0x8
	// Bit mask of MU field.
	RTC_TSDR_MU_Msk = 0xf00
	// Position of DT field.
	RTC_TSDR_DT_Pos = 0x4
	// Bit mask of DT field.
	RTC_TSDR_DT_Msk = 0x30
	// Position of DU field.
	RTC_TSDR_DU_Pos = 0x0
	// Bit mask of DU field.
	RTC_TSDR_DU_Msk = 0xf

	// TSSSR: timestamp sub second register
	// Position of SS field.
	RTC_TSSSR_SS_Pos = 0x0
	// Bit mask of SS field.
	RTC_TSSSR_SS_Msk = 0xffff

	// CALR: calibration register
	// Position of CALP field.
	RTC_CALR_CALP_Pos = 0xf
	// Bit mask of CALP field.
	RTC_CALR_CALP_Msk = 0x8000
	// Bit CALP.
	RTC_CALR_CALP = 0x8000
	// No RTCCLK pulses are added
	RTC_CALR_CALP_NoChange = 0x0
	// One RTCCLK pulse is effectively inserted every 2^11 pulses (frequency increased by 488.5 ppm)
	RTC_CALR_CALP_IncreaseFreq = 0x1
	// Position of CALW8 field.
	RTC_CALR_CALW8_Pos = 0xe
	// Bit mask of CALW8 field.
	RTC_CALR_CALW8_Msk = 0x4000
	// Bit CALW8.
	RTC_CALR_CALW8 = 0x4000
	// When CALW8 is set to 1, the 8-second calibration cycle period is selected
	RTC_CALR_CALW8_Eight_Second = 0x1
	// Position of CALW16 field.
	RTC_CALR_CALW16_Pos = 0xd
	// Bit mask of CALW16 field.
	RTC_CALR_CALW16_Msk = 0x2000
	// Bit CALW16.
	RTC_CALR_CALW16 = 0x2000
	// When CALW16 is set to 1, the 16-second calibration cycle period is selected.This bit must not be set to 1 if CALW8=1
	RTC_CALR_CALW16_Sixteen_Second = 0x1
	// Position of CALM field.
	RTC_CALR_CALM_Pos = 0x0
	// Bit mask of CALM field.
	RTC_CALR_CALM_Msk = 0x1ff

	// TAMPCR: tamper configuration register
	// Position of TAMP1E field.
	RTC_TAMPCR_TAMP1E_Pos = 0x0
	// Bit mask of TAMP1E field.
	RTC_TAMPCR_TAMP1E_Msk = 0x1
	// Bit TAMP1E.
	RTC_TAMPCR_TAMP1E = 0x1
	// Position of TAMP1TRG field.
	RTC_TAMPCR_TAMP1TRG_Pos = 0x1
	// Bit mask of TAMP1TRG field.
	RTC_TAMPCR_TAMP1TRG_Msk = 0x2
	// Bit TAMP1TRG.
	RTC_TAMPCR_TAMP1TRG = 0x2
	// Position of TAMPIE field.
	RTC_TAMPCR_TAMPIE_Pos = 0x2
	// Bit mask of TAMPIE field.
	RTC_TAMPCR_TAMPIE_Msk = 0x4
	// Bit TAMPIE.
	RTC_TAMPCR_TAMPIE = 0x4
	// Position of TAMP2E field.
	RTC_TAMPCR_TAMP2E_Pos = 0x3
	// Bit mask of TAMP2E field.
	RTC_TAMPCR_TAMP2E_Msk = 0x8
	// Bit TAMP2E.
	RTC_TAMPCR_TAMP2E = 0x8
	// Position of TAMP2TRG field.
	RTC_TAMPCR_TAMP2TRG_Pos = 0x4
	// Bit mask of TAMP2TRG field.
	RTC_TAMPCR_TAMP2TRG_Msk = 0x10
	// Bit TAMP2TRG.
	RTC_TAMPCR_TAMP2TRG = 0x10
	// Position of TAMP3E field.
	RTC_TAMPCR_TAMP3E_Pos = 0x5
	// Bit mask of TAMP3E field.
	RTC_TAMPCR_TAMP3E_Msk = 0x20
	// Bit TAMP3E.
	RTC_TAMPCR_TAMP3E = 0x20
	// Position of TAMP3TRG field.
	RTC_TAMPCR_TAMP3TRG_Pos = 0x6
	// Bit mask of TAMP3TRG field.
	RTC_TAMPCR_TAMP3TRG_Msk = 0x40
	// Bit TAMP3TRG.
	RTC_TAMPCR_TAMP3TRG = 0x40
	// Position of TAMPTS field.
	RTC_TAMPCR_TAMPTS_Pos = 0x7
	// Bit mask of TAMPTS field.
	RTC_TAMPCR_TAMPTS_Msk = 0x80
	// Bit TAMPTS.
	RTC_TAMPCR_TAMPTS = 0x80
	// Position of TAMPFREQ field.
	RTC_TAMPCR_TAMPFREQ_Pos = 0x8
	// Bit mask of TAMPFREQ field.
	RTC_TAMPCR_TAMPFREQ_Msk = 0x700
	// Position of TAMPFLT field.
	RTC_TAMPCR_TAMPFLT_Pos = 0xb
	// Bit mask of TAMPFLT field.
	RTC_TAMPCR_TAMPFLT_Msk = 0x1800
	// Position of TAMPPRCH field.
	RTC_TAMPCR_TAMPPRCH_Pos = 0xd
	// Bit mask of TAMPPRCH field.
	RTC_TAMPCR_TAMPPRCH_Msk = 0x6000
	// Position of TAMPPUDIS field.
	RTC_TAMPCR_TAMPPUDIS_Pos = 0xf
	// Bit mask of TAMPPUDIS field.
	RTC_TAMPCR_TAMPPUDIS_Msk = 0x8000
	// Bit TAMPPUDIS.
	RTC_TAMPCR_TAMPPUDIS = 0x8000
	// Position of TAMP1IE field.
	RTC_TAMPCR_TAMP1IE_Pos = 0x10
	// Bit mask of TAMP1IE field.
	RTC_TAMPCR_TAMP1IE_Msk = 0x10000
	// Bit TAMP1IE.
	RTC_TAMPCR_TAMP1IE = 0x10000
	// Position of TAMP1NOERASE field.
	RTC_TAMPCR_TAMP1NOERASE_Pos = 0x11
	// Bit mask of TAMP1NOERASE field.
	RTC_TAMPCR_TAMP1NOERASE_Msk = 0x20000
	// Bit TAMP1NOERASE.
	RTC_TAMPCR_TAMP1NOERASE = 0x20000
	// Position of TAMP1MF field.
	RTC_TAMPCR_TAMP1MF_Pos = 0x12
	// Bit mask of TAMP1MF field.
	RTC_TAMPCR_TAMP1MF_Msk = 0x40000
	// Bit TAMP1MF.
	RTC_TAMPCR_TAMP1MF = 0x40000
	// Position of TAMP2IE field.
	RTC_TAMPCR_TAMP2IE_Pos = 0x13
	// Bit mask of TAMP2IE field.
	RTC_TAMPCR_TAMP2IE_Msk = 0x80000
	// Bit TAMP2IE.
	RTC_TAMPCR_TAMP2IE = 0x80000
	// Position of TAMP2NOERASE field.
	RTC_TAMPCR_TAMP2NOERASE_Pos = 0x14
	// Bit mask of TAMP2NOERASE field.
	RTC_TAMPCR_TAMP2NOERASE_Msk = 0x100000
	// Bit TAMP2NOERASE.
	RTC_TAMPCR_TAMP2NOERASE = 0x100000
	// Position of TAMP2MF field.
	RTC_TAMPCR_TAMP2MF_Pos = 0x15
	// Bit mask of TAMP2MF field.
	RTC_TAMPCR_TAMP2MF_Msk = 0x200000
	// Bit TAMP2MF.
	RTC_TAMPCR_TAMP2MF = 0x200000
	// Position of TAMP3IE field.
	RTC_TAMPCR_TAMP3IE_Pos = 0x16
	// Bit mask of TAMP3IE field.
	RTC_TAMPCR_TAMP3IE_Msk = 0x400000
	// Bit TAMP3IE.
	RTC_TAMPCR_TAMP3IE = 0x400000
	// Position of TAMP3NOERASE field.
	RTC_TAMPCR_TAMP3NOERASE_Pos = 0x17
	// Bit mask of TAMP3NOERASE field.
	RTC_TAMPCR_TAMP3NOERASE_Msk = 0x800000
	// Bit TAMP3NOERASE.
	RTC_TAMPCR_TAMP3NOERASE = 0x800000
	// Position of TAMP3MF field.
	RTC_TAMPCR_TAMP3MF_Pos = 0x18
	// Bit mask of TAMP3MF field.
	RTC_TAMPCR_TAMP3MF_Msk = 0x1000000
	// Bit TAMP3MF.
	RTC_TAMPCR_TAMP3MF = 0x1000000

	// ALRMASSR: alarm A sub second register
	// Position of MASKSS field.
	RTC_ALRMASSR_MASKSS_Pos = 0x18
	// Bit mask of MASKSS field.
	RTC_ALRMASSR_MASKSS_Msk = 0xf000000
	// Position of SS field.
	RTC_ALRMASSR_SS_Pos = 0x0
	// Bit mask of SS field.
	RTC_ALRMASSR_SS_Msk = 0x7fff

	// ALRMBSSR: alarm B sub second register
	// Position of MASKSS field.
	RTC_ALRMBSSR_MASKSS_Pos = 0x18
	// Bit mask of MASKSS field.
	RTC_ALRMBSSR_MASKSS_Msk = 0xf000000
	// Position of SS field.
	RTC_ALRMBSSR_SS_Pos = 0x0
	// Bit mask of SS field.
	RTC_ALRMBSSR_SS_Msk = 0x7fff

	// OR: option register
	// Position of RTC_ALARM_TYPE field.
	RTC_OR_RTC_ALARM_TYPE_Pos = 0x0
	// Bit mask of RTC_ALARM_TYPE field.
	RTC_OR_RTC_ALARM_TYPE_Msk = 0x1
	// Bit RTC_ALARM_TYPE.
	RTC_OR_RTC_ALARM_TYPE = 0x1
	// Position of RTC_OUT_RMP field.
	RTC_OR_RTC_OUT_RMP_Pos = 0x1
	// Bit mask of RTC_OUT_RMP field.
	RTC_OR_RTC_OUT_RMP_Msk = 0x2
	// Bit RTC_OUT_RMP.
	RTC_OR_RTC_OUT_RMP = 0x2

	// BKP0R: backup register
	// Position of BKP field.
	RTC_BKPR_BKP_Pos = 0x0
	// Bit mask of BKP field.
	RTC_BKPR_BKP_Msk = 0xffffffff
)

// Constants for USART1: Universal synchronous asynchronous receiver transmitter
const (
	// CR1: Control register 1
	// Position of M1 field.
	USART_CR1_M1_Pos = 0x1c
	// Bit mask of M1 field.
	USART_CR1_M1_Msk = 0x10000000
	// Bit M1.
	USART_CR1_M1 = 0x10000000
	// Use M0 to set the data bits
	USART_CR1_M1_M0 = 0x0
	// 1 start bit, 7 data bits, n stop bits
	USART_CR1_M1_Bit7 = 0x1
	// Position of EOBIE field.
	USART_CR1_EOBIE_Pos = 0x1b
	// Bit mask of EOBIE field.
	USART_CR1_EOBIE_Msk = 0x8000000
	// Bit EOBIE.
	USART_CR1_EOBIE = 0x8000000
	// Interrupt is inhibited
	USART_CR1_EOBIE_Disabled = 0x0
	// A USART interrupt is generated when the EOBF flag is set in the ISR register
	USART_CR1_EOBIE_Enabled = 0x1
	// Position of RTOIE field.
	USART_CR1_RTOIE_Pos = 0x1a
	// Bit mask of RTOIE field.
	USART_CR1_RTOIE_Msk = 0x4000000
	// Bit RTOIE.
	USART_CR1_RTOIE = 0x4000000
	// Interrupt is inhibited
	USART_CR1_RTOIE_Disabled = 0x0
	// An USART interrupt is generated when the RTOF bit is set in the ISR register
	USART_CR1_RTOIE_Enabled = 0x1
	// Position of OVER8 field.
	USART_CR1_OVER8_Pos = 0xf
	// Bit mask of OVER8 field.
	USART_CR1_OVER8_Msk = 0x8000
	// Bit OVER8.
	USART_CR1_OVER8 = 0x8000
	// Oversampling by 16
	USART_CR1_OVER8_Oversampling16 = 0x0
	// Oversampling by 8
	USART_CR1_OVER8_Oversampling8 = 0x1
	// Position of CMIE field.
	USART_CR1_CMIE_Pos = 0xe
	// Bit mask of CMIE field.
	USART_CR1_CMIE_Msk = 0x4000
	// Bit CMIE.
	USART_CR1_CMIE = 0x4000
	// Interrupt is disabled
	USART_CR1_CMIE_Disabled = 0x0
	// Interrupt is generated when the CMF bit is set in the ISR register
	USART_CR1_CMIE_Enabled = 0x1
	// Position of MME field.
	USART_CR1_MME_Pos = 0xd
	// Bit mask of MME field.
	USART_CR1_MME_Msk = 0x2000
	// Bit MME.
	USART_CR1_MME = 0x2000
	// Receiver in active mode permanently
	USART_CR1_MME_Disabled = 0x0
	// Receiver can switch between mute mode and active mode
	USART_CR1_MME_Enabled = 0x1
	// Position of M0 field.
	USART_CR1_M0_Pos = 0xc
	// Bit mask of M0 field.
	USART_CR1_M0_Msk = 0x1000
	// Bit M0.
	USART_CR1_M0 = 0x1000
	// 1 start bit, 8 data bits, n stop bits
	USART_CR1_M0_Bit8 = 0x0
	// 1 start bit, 9 data bits, n stop bits
	USART_CR1_M0_Bit9 = 0x1
	// Position of WAKE field.
	USART_CR1_WAKE_Pos = 0xb
	// Bit mask of WAKE field.
	USART_CR1_WAKE_Msk = 0x800
	// Bit WAKE.
	USART_CR1_WAKE = 0x800
	// Idle line
	USART_CR1_WAKE_Idle = 0x0
	// Address mask
	USART_CR1_WAKE_Address = 0x1
	// Position of PCE field.
	USART_CR1_PCE_Pos = 0xa
	// Bit mask of PCE field.
	USART_CR1_PCE_Msk = 0x400
	// Bit PCE.
	USART_CR1_PCE = 0x400
	// Parity control disabled
	USART_CR1_PCE_Disabled = 0x0
	// Parity control enabled
	USART_CR1_PCE_Enabled = 0x1
	// Position of PS field.
	USART_CR1_PS_Pos = 0x9
	// Bit mask of PS field.
	USART_CR1_PS_Msk = 0x200
	// Bit PS.
	USART_CR1_PS = 0x200
	// Even parity
	USART_CR1_PS_Even = 0x0
	// Odd parity
	USART_CR1_PS_Odd = 0x1
	// Position of PEIE field.
	USART_CR1_PEIE_Pos = 0x8
	// Bit mask of PEIE field.
	USART_CR1_PEIE_Msk = 0x100
	// Bit PEIE.
	USART_CR1_PEIE = 0x100
	// Interrupt is disabled
	USART_CR1_PEIE_Disabled = 0x0
	// Interrupt is generated whenever PE=1 in the ISR register
	USART_CR1_PEIE_Enabled = 0x1
	// Position of TXEIE field.
	USART_CR1_TXEIE_Pos = 0x7
	// Bit mask of TXEIE field.
	USART_CR1_TXEIE_Msk = 0x80
	// Bit TXEIE.
	USART_CR1_TXEIE = 0x80
	// Interrupt is disabled
	USART_CR1_TXEIE_Disabled = 0x0
	// Interrupt is generated whenever TXE=1 in the ISR register
	USART_CR1_TXEIE_Enabled = 0x1
	// Position of TCIE field.
	USART_CR1_TCIE_Pos = 0x6
	// Bit mask of TCIE field.
	USART_CR1_TCIE_Msk = 0x40
	// Bit TCIE.
	USART_CR1_TCIE = 0x40
	// Interrupt is disabled
	USART_CR1_TCIE_Disabled = 0x0
	// Interrupt is generated whenever TC=1 in the ISR register
	USART_CR1_TCIE_Enabled = 0x1
	// Position of RXNEIE field.
	USART_CR1_RXNEIE_Pos = 0x5
	// Bit mask of RXNEIE field.
	USART_CR1_RXNEIE_Msk = 0x20
	// Bit RXNEIE.
	USART_CR1_RXNEIE = 0x20
	// Interrupt is disabled
	USART_CR1_RXNEIE_Disabled = 0x0
	// Interrupt is generated whenever ORE=1 or RXNE=1 in the ISR register
	USART_CR1_RXNEIE_Enabled = 0x1
	// Position of IDLEIE field.
	USART_CR1_IDLEIE_Pos = 0x4
	// Bit mask of IDLEIE field.
	USART_CR1_IDLEIE_Msk = 0x10
	// Bit IDLEIE.
	USART_CR1_IDLEIE = 0x10
	// Interrupt is disabled
	USART_CR1_IDLEIE_Disabled = 0x0
	// Interrupt is generated whenever IDLE=1 in the ISR register
	USART_CR1_IDLEIE_Enabled = 0x1
	// Position of TE field.
	USART_CR1_TE_Pos = 0x3
	// Bit mask of TE field.
	USART_CR1_TE_Msk = 0x8
	// Bit TE.
	USART_CR1_TE = 0x8
	// Transmitter is disabled
	USART_CR1_TE_Disabled = 0x0
	// Transmitter is enabled
	USART_CR1_TE_Enabled = 0x1
	// Position of RE field.
	USART_CR1_RE_Pos = 0x2
	// Bit mask of RE field.
	USART_CR1_RE_Msk = 0x4
	// Bit RE.
	USART_CR1_RE = 0x4
	// Receiver is disabled
	USART_CR1_RE_Disabled = 0x0
	// Receiver is enabled
	USART_CR1_RE_Enabled = 0x1
	// Position of UESM field.
	USART_CR1_UESM_Pos = 0x1
	// Bit mask of UESM field.
	USART_CR1_UESM_Msk = 0x2
	// Bit UESM.
	USART_CR1_UESM = 0x2
	// USART not able to wake up the MCU from Stop mode
	USART_CR1_UESM_Disabled = 0x0
	// USART able to wake up the MCU from Stop mode
	USART_CR1_UESM_Enabled = 0x1
	// Position of UE field.
	USART_CR1_UE_Pos = 0x0
	// Bit mask of UE field.
	USART_CR1_UE_Msk = 0x1
	// Bit UE.
	USART_CR1_UE = 0x1
	// UART is disabled
	USART_CR1_UE_Disabled = 0x0
	// UART is enabled
	USART_CR1_UE_Enabled = 0x1
	// Position of DEAT field.
	USART_CR1_DEAT_Pos = 0x15
	// Bit mask of DEAT field.
	USART_CR1_DEAT_Msk = 0x3e00000
	// Position of DEDT field.
	USART_CR1_DEDT_Pos = 0x10
	// Bit mask of DEDT field.
	USART_CR1_DEDT_Msk = 0x1f0000

	// CR2: Control register 2
	// Position of RTOEN field.
	USART_CR2_RTOEN_Pos = 0x17
	// Bit mask of RTOEN field.
	USART_CR2_RTOEN_Msk = 0x800000
	// Bit RTOEN.
	USART_CR2_RTOEN = 0x800000
	// Receiver timeout feature disabled
	USART_CR2_RTOEN_Disabled = 0x0
	// Receiver timeout feature enabled
	USART_CR2_RTOEN_Enabled = 0x1
	// Position of ABREN field.
	USART_CR2_ABREN_Pos = 0x14
	// Bit mask of ABREN field.
	USART_CR2_ABREN_Msk = 0x100000
	// Bit ABREN.
	USART_CR2_ABREN = 0x100000
	// Auto baud rate detection is disabled
	USART_CR2_ABREN_Disabled = 0x0
	// Auto baud rate detection is enabled
	USART_CR2_ABREN_Enabled = 0x1
	// Position of MSBFIRST field.
	USART_CR2_MSBFIRST_Pos = 0x13
	// Bit mask of MSBFIRST field.
	USART_CR2_MSBFIRST_Msk = 0x80000
	// Bit MSBFIRST.
	USART_CR2_MSBFIRST = 0x80000
	// data is transmitted/received with data bit 0 first, following the start bit
	USART_CR2_MSBFIRST_LSB = 0x0
	// data is transmitted/received with MSB (bit 7/8/9) first, following the start bit
	USART_CR2_MSBFIRST_MSB = 0x1
	// Position of DATAINV field.
	USART_CR2_DATAINV_Pos = 0x12
	// Bit mask of DATAINV field.
	USART_CR2_DATAINV_Msk = 0x40000
	// Bit DATAINV.
	USART_CR2_DATAINV = 0x40000
	// Logical data from the data register are send/received in positive/direct logic
	USART_CR2_DATAINV_Positive = 0x0
	// Logical data from the data register are send/received in negative/inverse logic
	USART_CR2_DATAINV_Negative = 0x1
	// Position of TXINV field.
	USART_CR2_TXINV_Pos = 0x11
	// Bit mask of TXINV field.
	USART_CR2_TXINV_Msk = 0x20000
	// Bit TXINV.
	USART_CR2_TXINV = 0x20000
	// TX pin signal works using the standard logic levels
	USART_CR2_TXINV_Standard = 0x0
	// TX pin signal values are inverted
	USART_CR2_TXINV_Inverted = 0x1
	// Position of RXINV field.
	USART_CR2_RXINV_Pos = 0x10
	// Bit mask of RXINV field.
	USART_CR2_RXINV_Msk = 0x10000
	// Bit RXINV.
	USART_CR2_RXINV = 0x10000
	// RX pin signal works using the standard logic levels
	USART_CR2_RXINV_Standard = 0x0
	// RX pin signal values are inverted
	USART_CR2_RXINV_Inverted = 0x1
	// Position of SWAP field.
	USART_CR2_SWAP_Pos = 0xf
	// Bit mask of SWAP field.
	USART_CR2_SWAP_Msk = 0x8000
	// Bit SWAP.
	USART_CR2_SWAP = 0x8000
	// TX/RX pins are used as defined in standard pinout
	USART_CR2_SWAP_Standard = 0x0
	// The TX and RX pins functions are swapped
	USART_CR2_SWAP_Swapped = 0x1
	// Position of LINEN field.
	USART_CR2_LINEN_Pos = 0xe
	// Bit mask of LINEN field.
	USART_CR2_LINEN_Msk = 0x4000
	// Bit LINEN.
	USART_CR2_LINEN = 0x4000
	// LIN mode disabled
	USART_CR2_LINEN_Disabled = 0x0
	// LIN mode enabled
	USART_CR2_LINEN_Enabled = 0x1
	// Position of STOP field.
	USART_CR2_STOP_Pos = 0xc
	// Bit mask of STOP field.
	USART_CR2_STOP_Msk = 0x3000
	// 1 stop bit
	USART_CR2_STOP_Stop1 = 0x0
	// 0.5 stop bit
	USART_CR2_STOP_Stop0p5 = 0x1
	// 2 stop bit
	USART_CR2_STOP_Stop2 = 0x2
	// 1.5 stop bit
	USART_CR2_STOP_Stop1p5 = 0x3
	// Position of CLKEN field.
	USART_CR2_CLKEN_Pos = 0xb
	// Bit mask of CLKEN field.
	USART_CR2_CLKEN_Msk = 0x800
	// Bit CLKEN.
	USART_CR2_CLKEN = 0x800
	// CK pin disabled
	USART_CR2_CLKEN_Disabled = 0x0
	// CK pin enabled
	USART_CR2_CLKEN_Enabled = 0x1
	// Position of CPOL field.
	USART_CR2_CPOL_Pos = 0xa
	// Bit mask of CPOL field.
	USART_CR2_CPOL_Msk = 0x400
	// Bit CPOL.
	USART_CR2_CPOL = 0x400
	// Steady low value on CK pin outside transmission window
	USART_CR2_CPOL_Low = 0x0
	// Steady high value on CK pin outside transmission window
	USART_CR2_CPOL_High = 0x1
	// Position of CPHA field.
	USART_CR2_CPHA_Pos = 0x9
	// Bit mask of CPHA field.
	USART_CR2_CPHA_Msk = 0x200
	// Bit CPHA.
	USART_CR2_CPHA = 0x200
	// The first clock transition is the first data capture edge
	USART_CR2_CPHA_First = 0x0
	// The second clock transition is the first data capture edge
	USART_CR2_CPHA_Second = 0x1
	// Position of LBCL field.
	USART_CR2_LBCL_Pos = 0x8
	// Bit mask of LBCL field.
	USART_CR2_LBCL_Msk = 0x100
	// Bit LBCL.
	USART_CR2_LBCL = 0x100
	// The clock pulse of the last data bit is not output to the CK pin
	USART_CR2_LBCL_NotOutput = 0x0
	// The clock pulse of the last data bit is output to the CK pin
	USART_CR2_LBCL_Output = 0x1
	// Position of LBDIE field.
	USART_CR2_LBDIE_Pos = 0x6
	// Bit mask of LBDIE field.
	USART_CR2_LBDIE_Msk = 0x40
	// Bit LBDIE.
	USART_CR2_LBDIE = 0x40
	// Interrupt is inhibited
	USART_CR2_LBDIE_Disabled = 0x0
	// An interrupt is generated whenever LBDF=1 in the ISR register
	USART_CR2_LBDIE_Enabled = 0x1
	// Position of LBDL field.
	USART_CR2_LBDL_Pos = 0x5
	// Bit mask of LBDL field.
	USART_CR2_LBDL_Msk = 0x20
	// Bit LBDL.
	USART_CR2_LBDL = 0x20
	// 10-bit break detection
	USART_CR2_LBDL_Bit10 = 0x0
	// 11-bit break detection
	USART_CR2_LBDL_Bit11 = 0x1
	// Position of ADDM7 field.
	USART_CR2_ADDM7_Pos = 0x4
	// Bit mask of ADDM7 field.
	USART_CR2_ADDM7_Msk = 0x10
	// Bit ADDM7.
	USART_CR2_ADDM7 = 0x10
	// 4-bit address detection
	USART_CR2_ADDM7_Bit4 = 0x0
	// 7-bit address detection
	USART_CR2_ADDM7_Bit7 = 0x1
	// Position of ABRMOD field.
	USART_CR2_ABRMOD_Pos = 0x15
	// Bit mask of ABRMOD field.
	USART_CR2_ABRMOD_Msk = 0x600000
	// Measurement of the start bit is used to detect the baud rate
	USART_CR2_ABRMOD_Start = 0x0
	// Falling edge to falling edge measurement
	USART_CR2_ABRMOD_Edge = 0x1
	// 0x7F frame detection
	USART_CR2_ABRMOD_Frame7F = 0x2
	// 0x55 frame detection
	USART_CR2_ABRMOD_Frame55 = 0x3
	// Position of ADD field.
	USART_CR2_ADD_Pos = 0x18
	// Bit mask of ADD field.
	USART_CR2_ADD_Msk = 0xff000000

	// CR3: Control register 3
	// Position of WUFIE field.
	USART_CR3_WUFIE_Pos = 0x16
	// Bit mask of WUFIE field.
	USART_CR3_WUFIE_Msk = 0x400000
	// Bit WUFIE.
	USART_CR3_WUFIE = 0x400000
	// Interrupt is inhibited
	USART_CR3_WUFIE_Disabled = 0x0
	// An USART interrupt is generated whenever WUF=1 in the ISR register
	USART_CR3_WUFIE_Enabled = 0x1
	// Position of WUS field.
	USART_CR3_WUS_Pos = 0x14
	// Bit mask of WUS field.
	USART_CR3_WUS_Msk = 0x300000
	// WUF active on address match
	USART_CR3_WUS_Address = 0x0
	// WuF active on Start bit detection
	USART_CR3_WUS_Start = 0x2
	// WUF active on RXNE
	USART_CR3_WUS_RXNE = 0x3
	// Position of SCARCNT field.
	USART_CR3_SCARCNT_Pos = 0x11
	// Bit mask of SCARCNT field.
	USART_CR3_SCARCNT_Msk = 0xe0000
	// Position of DEP field.
	USART_CR3_DEP_Pos = 0xf
	// Bit mask of DEP field.
	USART_CR3_DEP_Msk = 0x8000
	// Bit DEP.
	USART_CR3_DEP = 0x8000
	// DE signal is active high
	USART_CR3_DEP_High = 0x0
	// DE signal is active low
	USART_CR3_DEP_Low = 0x1
	// Position of DEM field.
	USART_CR3_DEM_Pos = 0xe
	// Bit mask of DEM field.
	USART_CR3_DEM_Msk = 0x4000
	// Bit DEM.
	USART_CR3_DEM = 0x4000
	// DE function is disabled
	USART_CR3_DEM_Disabled = 0x0
	// The DE signal is output on the RTS pin
	USART_CR3_DEM_Enabled = 0x1
	// Position of DDRE field.
	USART_CR3_DDRE_Pos = 0xd
	// Bit mask of DDRE field.
	USART_CR3_DDRE_Msk = 0x2000
	// Bit DDRE.
	USART_CR3_DDRE = 0x2000
	// DMA is not disabled in case of reception error
	USART_CR3_DDRE_NotDisabled = 0x0
	// DMA is disabled following a reception error
	USART_CR3_DDRE_Disabled = 0x1
	// Position of OVRDIS field.
	USART_CR3_OVRDIS_Pos = 0xc
	// Bit mask of OVRDIS field.
	USART_CR3_OVRDIS_Msk = 0x1000
	// Bit OVRDIS.
	USART_CR3_OVRDIS = 0x1000
	// Overrun Error Flag, ORE, is set when received data is not read before receiving new data
	USART_CR3_OVRDIS_Enabled = 0x0
	// Overrun functionality is disabled. If new data is received while the RXNE flag is still set the ORE flag is not set and the new received data overwrites the previous content of the RDR register
	USART_CR3_OVRDIS_Disabled = 0x1
	// Position of ONEBIT field.
	USART_CR3_ONEBIT_Pos = 0xb
	// Bit mask of ONEBIT field.
	USART_CR3_ONEBIT_Msk = 0x800
	// Bit ONEBIT.
	USART_CR3_ONEBIT = 0x800
	// Three sample bit method
	USART_CR3_ONEBIT_Sample3 = 0x0
	// One sample bit method
	USART_CR3_ONEBIT_Sample1 = 0x1
	// Position of CTSIE field.
	USART_CR3_CTSIE_Pos = 0xa
	// Bit mask of CTSIE field.
	USART_CR3_CTSIE_Msk = 0x400
	// Bit CTSIE.
	USART_CR3_CTSIE = 0x400
	// Interrupt is inhibited
	USART_CR3_CTSIE_Disabled = 0x0
	// An interrupt is generated whenever CTSIF=1 in the ISR register
	USART_CR3_CTSIE_Enabled = 0x1
	// Position of CTSE field.
	USART_CR3_CTSE_Pos = 0x9
	// Bit mask of CTSE field.
	USART_CR3_CTSE_Msk = 0x200
	// Bit CTSE.
	USART_CR3_CTSE = 0x200
	// CTS hardware flow control disabled
	USART_CR3_CTSE_Disabled = 0x0
	// CTS mode enabled, data is only transmitted when the CTS input is asserted
	USART_CR3_CTSE_Enabled = 0x1
	// Position of RTSE field.
	USART_CR3_RTSE_Pos = 0x8
	// Bit mask of RTSE field.
	USART_CR3_RTSE_Msk = 0x100
	// Bit RTSE.
	USART_CR3_RTSE = 0x100
	// RTS hardware flow control disabled
	USART_CR3_RTSE_Disabled = 0x0
	// RTS output enabled, data is only requested when there is space in the receive buffer
	USART_CR3_RTSE_Enabled = 0x1
	// Position of DMAT field.
	USART_CR3_DMAT_Pos = 0x7
	// Bit mask of DMAT field.
	USART_CR3_DMAT_Msk = 0x80
	// Bit DMAT.
	USART_CR3_DMAT = 0x80
	// DMA mode is disabled for transmission
	USART_CR3_DMAT_Disabled = 0x0
	// DMA mode is enabled for transmission
	USART_CR3_DMAT_Enabled = 0x1
	// Position of DMAR field.
	USART_CR3_DMAR_Pos = 0x6
	// Bit mask of DMAR field.
	USART_CR3_DMAR_Msk = 0x40
	// Bit DMAR.
	USART_CR3_DMAR = 0x40
	// DMA mode is disabled for reception
	USART_CR3_DMAR_Disabled = 0x0
	// DMA mode is enabled for reception
	USART_CR3_DMAR_Enabled = 0x1
	// Position of SCEN field.
	USART_CR3_SCEN_Pos = 0x5
	// Bit mask of SCEN field.
	USART_CR3_SCEN_Msk = 0x20
	// Bit SCEN.
	USART_CR3_SCEN = 0x20
	// Smartcard Mode disabled
	USART_CR3_SCEN_Disabled = 0x0
	// Smartcard Mode enabled
	USART_CR3_SCEN_Enabled = 0x1
	// Position of NACK field.
	USART_CR3_NACK_Pos = 0x4
	// Bit mask of NACK field.
	USART_CR3_NACK_Msk = 0x10
	// Bit NACK.
	USART_CR3_NACK = 0x10
	// NACK transmission in case of parity error is disabled
	USART_CR3_NACK_Disabled = 0x0
	// NACK transmission during parity error is enabled
	USART_CR3_NACK_Enabled = 0x1
	// Position of HDSEL field.
	USART_CR3_HDSEL_Pos = 0x3
	// Bit mask of HDSEL field.
	USART_CR3_HDSEL_Msk = 0x8
	// Bit HDSEL.
	USART_CR3_HDSEL = 0x8
	// Half duplex mode is not selected
	USART_CR3_HDSEL_NotSelected = 0x0
	// Half duplex mode is selected
	USART_CR3_HDSEL_Selected = 0x1
	// Position of IRLP field.
	USART_CR3_IRLP_Pos = 0x2
	// Bit mask of IRLP field.
	USART_CR3_IRLP_Msk = 0x4
	// Bit IRLP.
	USART_CR3_IRLP = 0x4
	// Normal mode
	USART_CR3_IRLP_Normal = 0x0
	// Low-power mode
	USART_CR3_IRLP_LowPower = 0x1
	// Position of IREN field.
	USART_CR3_IREN_Pos = 0x1
	// Bit mask of IREN field.
	USART_CR3_IREN_Msk = 0x2
	// Bit IREN.
	USART_CR3_IREN = 0x2
	// IrDA disabled
	USART_CR3_IREN_Disabled = 0x0
	// IrDA enabled
	USART_CR3_IREN_Enabled = 0x1
	// Position of EIE field.
	USART_CR3_EIE_Pos = 0x0
	// Bit mask of EIE field.
	USART_CR3_EIE_Msk = 0x1
	// Bit EIE.
	USART_CR3_EIE = 0x1
	// Interrupt is inhibited
	USART_CR3_EIE_Disabled = 0x0
	// An interrupt is generated when FE=1 or ORE=1 or NF=1 in the ISR register
	USART_CR3_EIE_Enabled = 0x1

	// BRR: Baud rate register
	// Position of BRR field.
	USART_BRR_BRR_Pos = 0x0
	// Bit mask of BRR field.
	USART_BRR_BRR_Msk = 0xffff

	// GTPR: Guard time and prescaler register
	// Position of GT field.
	USART_GTPR_GT_Pos = 0x8
	// Bit mask of GT field.
	USART_GTPR_GT_Msk = 0xff00
	// Position of PSC field.
	USART_GTPR_PSC_Pos = 0x0
	// Bit mask of PSC field.
	USART_GTPR_PSC_Msk = 0xff

	// RTOR: Receiver timeout register
	// Position of BLEN field.
	USART_RTOR_BLEN_Pos = 0x18
	// Bit mask of BLEN field.
	USART_RTOR_BLEN_Msk = 0xff000000
	// Position of RTO field.
	USART_RTOR_RTO_Pos = 0x0
	// Bit mask of RTO field.
	USART_RTOR_RTO_Msk = 0xffffff

	// RQR: Request register
	// Position of TXFRQ field.
	USART_RQR_TXFRQ_Pos = 0x4
	// Bit mask of TXFRQ field.
	USART_RQR_TXFRQ_Msk = 0x10
	// Bit TXFRQ.
	USART_RQR_TXFRQ = 0x10
	// Set the TXE flags. This allows to discard the transmit data
	USART_RQR_TXFRQ_Discard = 0x1
	// Position of RXFRQ field.
	USART_RQR_RXFRQ_Pos = 0x3
	// Bit mask of RXFRQ field.
	USART_RQR_RXFRQ_Msk = 0x8
	// Bit RXFRQ.
	USART_RQR_RXFRQ = 0x8
	// clears the RXNE flag. This allows to discard the received data without reading it, and avoid an overrun condition
	USART_RQR_RXFRQ_Discard = 0x1
	// Position of MMRQ field.
	USART_RQR_MMRQ_Pos = 0x2
	// Bit mask of MMRQ field.
	USART_RQR_MMRQ_Msk = 0x4
	// Bit MMRQ.
	USART_RQR_MMRQ = 0x4
	// Puts the USART in mute mode and sets the RWU flag
	USART_RQR_MMRQ_Mute = 0x1
	// Position of SBKRQ field.
	USART_RQR_SBKRQ_Pos = 0x1
	// Bit mask of SBKRQ field.
	USART_RQR_SBKRQ_Msk = 0x2
	// Bit SBKRQ.
	USART_RQR_SBKRQ = 0x2
	// sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available
	USART_RQR_SBKRQ_Break = 0x1
	// Position of ABRRQ field.
	USART_RQR_ABRRQ_Pos = 0x0
	// Bit mask of ABRRQ field.
	USART_RQR_ABRRQ_Msk = 0x1
	// Bit ABRRQ.
	USART_RQR_ABRRQ = 0x1
	// resets the ABRF flag in the USART_ISR and request an automatic baud rate measurement on the next received data frame
	USART_RQR_ABRRQ_Request = 0x1

	// ISR: Interrupt & status register
	// Position of REACK field.
	USART_ISR_REACK_Pos = 0x16
	// Bit mask of REACK field.
	USART_ISR_REACK_Msk = 0x400000
	// Bit REACK.
	USART_ISR_REACK = 0x400000
	// Position of TEACK field.
	USART_ISR_TEACK_Pos = 0x15
	// Bit mask of TEACK field.
	USART_ISR_TEACK_Msk = 0x200000
	// Bit TEACK.
	USART_ISR_TEACK = 0x200000
	// Position of WUF field.
	USART_ISR_WUF_Pos = 0x14
	// Bit mask of WUF field.
	USART_ISR_WUF_Msk = 0x100000
	// Bit WUF.
	USART_ISR_WUF = 0x100000
	// Position of RWU field.
	USART_ISR_RWU_Pos = 0x13
	// Bit mask of RWU field.
	USART_ISR_RWU_Msk = 0x80000
	// Bit RWU.
	USART_ISR_RWU = 0x80000
	// Position of SBKF field.
	USART_ISR_SBKF_Pos = 0x12
	// Bit mask of SBKF field.
	USART_ISR_SBKF_Msk = 0x40000
	// Bit SBKF.
	USART_ISR_SBKF = 0x40000
	// Position of CMF field.
	USART_ISR_CMF_Pos = 0x11
	// Bit mask of CMF field.
	USART_ISR_CMF_Msk = 0x20000
	// Bit CMF.
	USART_ISR_CMF = 0x20000
	// Position of BUSY field.
	USART_ISR_BUSY_Pos = 0x10
	// Bit mask of BUSY field.
	USART_ISR_BUSY_Msk = 0x10000
	// Bit BUSY.
	USART_ISR_BUSY = 0x10000
	// Position of ABRF field.
	USART_ISR_ABRF_Pos = 0xf
	// Bit mask of ABRF field.
	USART_ISR_ABRF_Msk = 0x8000
	// Bit ABRF.
	USART_ISR_ABRF = 0x8000
	// Position of ABRE field.
	USART_ISR_ABRE_Pos = 0xe
	// Bit mask of ABRE field.
	USART_ISR_ABRE_Msk = 0x4000
	// Bit ABRE.
	USART_ISR_ABRE = 0x4000
	// Position of EOBF field.
	USART_ISR_EOBF_Pos = 0xc
	// Bit mask of EOBF field.
	USART_ISR_EOBF_Msk = 0x1000
	// Bit EOBF.
	USART_ISR_EOBF = 0x1000
	// Position of RTOF field.
	USART_ISR_RTOF_Pos = 0xb
	// Bit mask of RTOF field.
	USART_ISR_RTOF_Msk = 0x800
	// Bit RTOF.
	USART_ISR_RTOF = 0x800
	// Position of CTS field.
	USART_ISR_CTS_Pos = 0xa
	// Bit mask of CTS field.
	USART_ISR_CTS_Msk = 0x400
	// Bit CTS.
	USART_ISR_CTS = 0x400
	// Position of CTSIF field.
	USART_ISR_CTSIF_Pos = 0x9
	// Bit mask of CTSIF field.
	USART_ISR_CTSIF_Msk = 0x200
	// Bit CTSIF.
	USART_ISR_CTSIF = 0x200
	// Position of LBDF field.
	USART_ISR_LBDF_Pos = 0x8
	// Bit mask of LBDF field.
	USART_ISR_LBDF_Msk = 0x100
	// Bit LBDF.
	USART_ISR_LBDF = 0x100
	// Position of TXE field.
	USART_ISR_TXE_Pos = 0x7
	// Bit mask of TXE field.
	USART_ISR_TXE_Msk = 0x80
	// Bit TXE.
	USART_ISR_TXE = 0x80
	// Position of TC field.
	USART_ISR_TC_Pos = 0x6
	// Bit mask of TC field.
	USART_ISR_TC_Msk = 0x40
	// Bit TC.
	USART_ISR_TC = 0x40
	// Position of RXNE field.
	USART_ISR_RXNE_Pos = 0x5
	// Bit mask of RXNE field.
	USART_ISR_RXNE_Msk = 0x20
	// Bit RXNE.
	USART_ISR_RXNE = 0x20
	// Position of IDLE field.
	USART_ISR_IDLE_Pos = 0x4
	// Bit mask of IDLE field.
	USART_ISR_IDLE_Msk = 0x10
	// Bit IDLE.
	USART_ISR_IDLE = 0x10
	// Position of ORE field.
	USART_ISR_ORE_Pos = 0x3
	// Bit mask of ORE field.
	USART_ISR_ORE_Msk = 0x8
	// Bit ORE.
	USART_ISR_ORE = 0x8
	// Position of NF field.
	USART_ISR_NF_Pos = 0x2
	// Bit mask of NF field.
	USART_ISR_NF_Msk = 0x4
	// Bit NF.
	USART_ISR_NF = 0x4
	// Position of FE field.
	USART_ISR_FE_Pos = 0x1
	// Bit mask of FE field.
	USART_ISR_FE_Msk = 0x2
	// Bit FE.
	USART_ISR_FE = 0x2
	// Position of PE field.
	USART_ISR_PE_Pos = 0x0
	// Bit mask of PE field.
	USART_ISR_PE_Msk = 0x1
	// Bit PE.
	USART_ISR_PE = 0x1

	// ICR: Interrupt flag clear register
	// Position of WUCF field.
	USART_ICR_WUCF_Pos = 0x14
	// Bit mask of WUCF field.
	USART_ICR_WUCF_Msk = 0x100000
	// Bit WUCF.
	USART_ICR_WUCF = 0x100000
	// Clears the WUF flag in the ISR register
	USART_ICR_WUCF_Clear = 0x1
	// Position of CMCF field.
	USART_ICR_CMCF_Pos = 0x11
	// Bit mask of CMCF field.
	USART_ICR_CMCF_Msk = 0x20000
	// Bit CMCF.
	USART_ICR_CMCF = 0x20000
	// Clears the CMF flag in the ISR register
	USART_ICR_CMCF_Clear = 0x1
	// Position of EOBCF field.
	USART_ICR_EOBCF_Pos = 0xc
	// Bit mask of EOBCF field.
	USART_ICR_EOBCF_Msk = 0x1000
	// Bit EOBCF.
	USART_ICR_EOBCF = 0x1000
	// Clears the EOBF flag in the ISR register
	USART_ICR_EOBCF_Clear = 0x1
	// Position of RTOCF field.
	USART_ICR_RTOCF_Pos = 0xb
	// Bit mask of RTOCF field.
	USART_ICR_RTOCF_Msk = 0x800
	// Bit RTOCF.
	USART_ICR_RTOCF = 0x800
	// Clears the RTOF flag in the ISR register
	USART_ICR_RTOCF_Clear = 0x1
	// Position of CTSCF field.
	USART_ICR_CTSCF_Pos = 0x9
	// Bit mask of CTSCF field.
	USART_ICR_CTSCF_Msk = 0x200
	// Bit CTSCF.
	USART_ICR_CTSCF = 0x200
	// Clears the CTSIF flag in the ISR register
	USART_ICR_CTSCF_Clear = 0x1
	// Position of LBDCF field.
	USART_ICR_LBDCF_Pos = 0x8
	// Bit mask of LBDCF field.
	USART_ICR_LBDCF_Msk = 0x100
	// Bit LBDCF.
	USART_ICR_LBDCF = 0x100
	// Clears the LBDF flag in the ISR register
	USART_ICR_LBDCF_Clear = 0x1
	// Position of TCCF field.
	USART_ICR_TCCF_Pos = 0x6
	// Bit mask of TCCF field.
	USART_ICR_TCCF_Msk = 0x40
	// Bit TCCF.
	USART_ICR_TCCF = 0x40
	// Clears the TC flag in the ISR register
	USART_ICR_TCCF_Clear = 0x1
	// Position of IDLECF field.
	USART_ICR_IDLECF_Pos = 0x4
	// Bit mask of IDLECF field.
	USART_ICR_IDLECF_Msk = 0x10
	// Bit IDLECF.
	USART_ICR_IDLECF = 0x10
	// Clears the IDLE flag in the ISR register
	USART_ICR_IDLECF_Clear = 0x1
	// Position of ORECF field.
	USART_ICR_ORECF_Pos = 0x3
	// Bit mask of ORECF field.
	USART_ICR_ORECF_Msk = 0x8
	// Bit ORECF.
	USART_ICR_ORECF = 0x8
	// Clears the ORE flag in the ISR register
	USART_ICR_ORECF_Clear = 0x1
	// Position of NCF field.
	USART_ICR_NCF_Pos = 0x2
	// Bit mask of NCF field.
	USART_ICR_NCF_Msk = 0x4
	// Bit NCF.
	USART_ICR_NCF = 0x4
	// Clears the NF flag in the ISR register
	USART_ICR_NCF_Clear = 0x1
	// Position of FECF field.
	USART_ICR_FECF_Pos = 0x1
	// Bit mask of FECF field.
	USART_ICR_FECF_Msk = 0x2
	// Bit FECF.
	USART_ICR_FECF = 0x2
	// Clears the FE flag in the ISR register
	USART_ICR_FECF_Clear = 0x1
	// Position of PECF field.
	USART_ICR_PECF_Pos = 0x0
	// Bit mask of PECF field.
	USART_ICR_PECF_Msk = 0x1
	// Bit PECF.
	USART_ICR_PECF = 0x1
	// Clears the PE flag in the ISR register
	USART_ICR_PECF_Clear = 0x1

	// RDR: Receive data register
	// Position of RDR field.
	USART_RDR_RDR_Pos = 0x0
	// Bit mask of RDR field.
	USART_RDR_RDR_Msk = 0x1ff

	// TDR: Transmit data register
	// Position of TDR field.
	USART_TDR_TDR_Pos = 0x0
	// Bit mask of TDR field.
	USART_TDR_TDR_Msk = 0x1ff
)

// Constants for OTG_FS_GLOBAL: USB on the go full speed
const (
	// OTG_FS_GOTGCTL: OTG_FS control and status register (OTG_FS_GOTGCTL)
	// Position of SRQSCS field.
	USB_OTG_FS_OTG_FS_GOTGCTL_SRQSCS_Pos = 0x0
	// Bit mask of SRQSCS field.
	USB_OTG_FS_OTG_FS_GOTGCTL_SRQSCS_Msk = 0x1
	// Bit SRQSCS.
	USB_OTG_FS_OTG_FS_GOTGCTL_SRQSCS = 0x1
	// Position of SRQ field.
	USB_OTG_FS_OTG_FS_GOTGCTL_SRQ_Pos = 0x1
	// Bit mask of SRQ field.
	USB_OTG_FS_OTG_FS_GOTGCTL_SRQ_Msk = 0x2
	// Bit SRQ.
	USB_OTG_FS_OTG_FS_GOTGCTL_SRQ = 0x2
	// Position of HNGSCS field.
	USB_OTG_FS_OTG_FS_GOTGCTL_HNGSCS_Pos = 0x8
	// Bit mask of HNGSCS field.
	USB_OTG_FS_OTG_FS_GOTGCTL_HNGSCS_Msk = 0x100
	// Bit HNGSCS.
	USB_OTG_FS_OTG_FS_GOTGCTL_HNGSCS = 0x100
	// Position of HNPRQ field.
	USB_OTG_FS_OTG_FS_GOTGCTL_HNPRQ_Pos = 0x9
	// Bit mask of HNPRQ field.
	USB_OTG_FS_OTG_FS_GOTGCTL_HNPRQ_Msk = 0x200
	// Bit HNPRQ.
	USB_OTG_FS_OTG_FS_GOTGCTL_HNPRQ = 0x200
	// Position of HSHNPEN field.
	USB_OTG_FS_OTG_FS_GOTGCTL_HSHNPEN_Pos = 0xa
	// Bit mask of HSHNPEN field.
	USB_OTG_FS_OTG_FS_GOTGCTL_HSHNPEN_Msk = 0x400
	// Bit HSHNPEN.
	USB_OTG_FS_OTG_FS_GOTGCTL_HSHNPEN = 0x400
	// Position of DHNPEN field.
	USB_OTG_FS_OTG_FS_GOTGCTL_DHNPEN_Pos = 0xb
	// Bit mask of DHNPEN field.
	USB_OTG_FS_OTG_FS_GOTGCTL_DHNPEN_Msk = 0x800
	// Bit DHNPEN.
	USB_OTG_FS_OTG_FS_GOTGCTL_DHNPEN = 0x800
	// Position of CIDSTS field.
	USB_OTG_FS_OTG_FS_GOTGCTL_CIDSTS_Pos = 0x10
	// Bit mask of CIDSTS field.
	USB_OTG_FS_OTG_FS_GOTGCTL_CIDSTS_Msk = 0x10000
	// Bit CIDSTS.
	USB_OTG_FS_OTG_FS_GOTGCTL_CIDSTS = 0x10000
	// Position of DBCT field.
	USB_OTG_FS_OTG_FS_GOTGCTL_DBCT_Pos = 0x11
	// Bit mask of DBCT field.
	USB_OTG_FS_OTG_FS_GOTGCTL_DBCT_Msk = 0x20000
	// Bit DBCT.
	USB_OTG_FS_OTG_FS_GOTGCTL_DBCT = 0x20000
	// Position of ASVLD field.
	USB_OTG_FS_OTG_FS_GOTGCTL_ASVLD_Pos = 0x12
	// Bit mask of ASVLD field.
	USB_OTG_FS_OTG_FS_GOTGCTL_ASVLD_Msk = 0x40000
	// Bit ASVLD.
	USB_OTG_FS_OTG_FS_GOTGCTL_ASVLD = 0x40000
	// Position of BSVLD field.
	USB_OTG_FS_OTG_FS_GOTGCTL_BSVLD_Pos = 0x13
	// Bit mask of BSVLD field.
	USB_OTG_FS_OTG_FS_GOTGCTL_BSVLD_Msk = 0x80000
	// Bit BSVLD.
	USB_OTG_FS_OTG_FS_GOTGCTL_BSVLD = 0x80000
	// Position of VBVALOEN field.
	USB_OTG_FS_OTG_FS_GOTGCTL_VBVALOEN_Pos = 0x2
	// Bit mask of VBVALOEN field.
	USB_OTG_FS_OTG_FS_GOTGCTL_VBVALOEN_Msk = 0x4
	// Bit VBVALOEN.
	USB_OTG_FS_OTG_FS_GOTGCTL_VBVALOEN = 0x4
	// Position of VBVALOVAL field.
	USB_OTG_FS_OTG_FS_GOTGCTL_VBVALOVAL_Pos = 0x3
	// Bit mask of VBVALOVAL field.
	USB_OTG_FS_OTG_FS_GOTGCTL_VBVALOVAL_Msk = 0x8
	// Bit VBVALOVAL.
	USB_OTG_FS_OTG_FS_GOTGCTL_VBVALOVAL = 0x8
	// Position of AVALOEN field.
	USB_OTG_FS_OTG_FS_GOTGCTL_AVALOEN_Pos = 0x4
	// Bit mask of AVALOEN field.
	USB_OTG_FS_OTG_FS_GOTGCTL_AVALOEN_Msk = 0x10
	// Bit AVALOEN.
	USB_OTG_FS_OTG_FS_GOTGCTL_AVALOEN = 0x10
	// Position of AVALOVAL field.
	USB_OTG_FS_OTG_FS_GOTGCTL_AVALOVAL_Pos = 0x5
	// Bit mask of AVALOVAL field.
	USB_OTG_FS_OTG_FS_GOTGCTL_AVALOVAL_Msk = 0x20
	// Bit AVALOVAL.
	USB_OTG_FS_OTG_FS_GOTGCTL_AVALOVAL = 0x20
	// Position of BVALOEN field.
	USB_OTG_FS_OTG_FS_GOTGCTL_BVALOEN_Pos = 0x6
	// Bit mask of BVALOEN field.
	USB_OTG_FS_OTG_FS_GOTGCTL_BVALOEN_Msk = 0x40
	// Bit BVALOEN.
	USB_OTG_FS_OTG_FS_GOTGCTL_BVALOEN = 0x40
	// Position of BVALOVAL field.
	USB_OTG_FS_OTG_FS_GOTGCTL_BVALOVAL_Pos = 0x7
	// Bit mask of BVALOVAL field.
	USB_OTG_FS_OTG_FS_GOTGCTL_BVALOVAL_Msk = 0x80
	// Bit BVALOVAL.
	USB_OTG_FS_OTG_FS_GOTGCTL_BVALOVAL = 0x80
	// Position of EHEN field.
	USB_OTG_FS_OTG_FS_GOTGCTL_EHEN_Pos = 0xc
	// Bit mask of EHEN field.
	USB_OTG_FS_OTG_FS_GOTGCTL_EHEN_Msk = 0x1000
	// Bit EHEN.
	USB_OTG_FS_OTG_FS_GOTGCTL_EHEN = 0x1000
	// Position of OTGVER field.
	USB_OTG_FS_OTG_FS_GOTGCTL_OTGVER_Pos = 0x14
	// Bit mask of OTGVER field.
	USB_OTG_FS_OTG_FS_GOTGCTL_OTGVER_Msk = 0x100000
	// Bit OTGVER.
	USB_OTG_FS_OTG_FS_GOTGCTL_OTGVER = 0x100000

	// OTG_FS_GOTGINT: OTG_FS interrupt register (OTG_FS_GOTGINT)
	// Position of SEDET field.
	USB_OTG_FS_OTG_FS_GOTGINT_SEDET_Pos = 0x2
	// Bit mask of SEDET field.
	USB_OTG_FS_OTG_FS_GOTGINT_SEDET_Msk = 0x4
	// Bit SEDET.
	USB_OTG_FS_OTG_FS_GOTGINT_SEDET = 0x4
	// Position of SRSSCHG field.
	USB_OTG_FS_OTG_FS_GOTGINT_SRSSCHG_Pos = 0x8
	// Bit mask of SRSSCHG field.
	USB_OTG_FS_OTG_FS_GOTGINT_SRSSCHG_Msk = 0x100
	// Bit SRSSCHG.
	USB_OTG_FS_OTG_FS_GOTGINT_SRSSCHG = 0x100
	// Position of HNSSCHG field.
	USB_OTG_FS_OTG_FS_GOTGINT_HNSSCHG_Pos = 0x9
	// Bit mask of HNSSCHG field.
	USB_OTG_FS_OTG_FS_GOTGINT_HNSSCHG_Msk = 0x200
	// Bit HNSSCHG.
	USB_OTG_FS_OTG_FS_GOTGINT_HNSSCHG = 0x200
	// Position of HNGDET field.
	USB_OTG_FS_OTG_FS_GOTGINT_HNGDET_Pos = 0x11
	// Bit mask of HNGDET field.
	USB_OTG_FS_OTG_FS_GOTGINT_HNGDET_Msk = 0x20000
	// Bit HNGDET.
	USB_OTG_FS_OTG_FS_GOTGINT_HNGDET = 0x20000
	// Position of ADTOCHG field.
	USB_OTG_FS_OTG_FS_GOTGINT_ADTOCHG_Pos = 0x12
	// Bit mask of ADTOCHG field.
	USB_OTG_FS_OTG_FS_GOTGINT_ADTOCHG_Msk = 0x40000
	// Bit ADTOCHG.
	USB_OTG_FS_OTG_FS_GOTGINT_ADTOCHG = 0x40000
	// Position of DBCDNE field.
	USB_OTG_FS_OTG_FS_GOTGINT_DBCDNE_Pos = 0x13
	// Bit mask of DBCDNE field.
	USB_OTG_FS_OTG_FS_GOTGINT_DBCDNE_Msk = 0x80000
	// Bit DBCDNE.
	USB_OTG_FS_OTG_FS_GOTGINT_DBCDNE = 0x80000
	// Position of IDCHNG field.
	USB_OTG_FS_OTG_FS_GOTGINT_IDCHNG_Pos = 0x14
	// Bit mask of IDCHNG field.
	USB_OTG_FS_OTG_FS_GOTGINT_IDCHNG_Msk = 0x100000
	// Bit IDCHNG.
	USB_OTG_FS_OTG_FS_GOTGINT_IDCHNG = 0x100000

	// OTG_FS_GAHBCFG: OTG_FS AHB configuration register (OTG_FS_GAHBCFG)
	// Position of GINT field.
	USB_OTG_FS_OTG_FS_GAHBCFG_GINT_Pos = 0x0
	// Bit mask of GINT field.
	USB_OTG_FS_OTG_FS_GAHBCFG_GINT_Msk = 0x1
	// Bit GINT.
	USB_OTG_FS_OTG_FS_GAHBCFG_GINT = 0x1
	// Position of TXFELVL field.
	USB_OTG_FS_OTG_FS_GAHBCFG_TXFELVL_Pos = 0x7
	// Bit mask of TXFELVL field.
	USB_OTG_FS_OTG_FS_GAHBCFG_TXFELVL_Msk = 0x80
	// Bit TXFELVL.
	USB_OTG_FS_OTG_FS_GAHBCFG_TXFELVL = 0x80
	// Position of PTXFELVL field.
	USB_OTG_FS_OTG_FS_GAHBCFG_PTXFELVL_Pos = 0x8
	// Bit mask of PTXFELVL field.
	USB_OTG_FS_OTG_FS_GAHBCFG_PTXFELVL_Msk = 0x100
	// Bit PTXFELVL.
	USB_OTG_FS_OTG_FS_GAHBCFG_PTXFELVL = 0x100

	// OTG_FS_GUSBCFG: OTG_FS USB configuration register (OTG_FS_GUSBCFG)
	// Position of TOCAL field.
	USB_OTG_FS_OTG_FS_GUSBCFG_TOCAL_Pos = 0x0
	// Bit mask of TOCAL field.
	USB_OTG_FS_OTG_FS_GUSBCFG_TOCAL_Msk = 0x7
	// Position of PHYSEL field.
	USB_OTG_FS_OTG_FS_GUSBCFG_PHYSEL_Pos = 0x6
	// Bit mask of PHYSEL field.
	USB_OTG_FS_OTG_FS_GUSBCFG_PHYSEL_Msk = 0x40
	// Bit PHYSEL.
	USB_OTG_FS_OTG_FS_GUSBCFG_PHYSEL = 0x40
	// Position of SRPCAP field.
	USB_OTG_FS_OTG_FS_GUSBCFG_SRPCAP_Pos = 0x8
	// Bit mask of SRPCAP field.
	USB_OTG_FS_OTG_FS_GUSBCFG_SRPCAP_Msk = 0x100
	// Bit SRPCAP.
	USB_OTG_FS_OTG_FS_GUSBCFG_SRPCAP = 0x100
	// Position of HNPCAP field.
	USB_OTG_FS_OTG_FS_GUSBCFG_HNPCAP_Pos = 0x9
	// Bit mask of HNPCAP field.
	USB_OTG_FS_OTG_FS_GUSBCFG_HNPCAP_Msk = 0x200
	// Bit HNPCAP.
	USB_OTG_FS_OTG_FS_GUSBCFG_HNPCAP = 0x200
	// Position of TRDT field.
	USB_OTG_FS_OTG_FS_GUSBCFG_TRDT_Pos = 0xa
	// Bit mask of TRDT field.
	USB_OTG_FS_OTG_FS_GUSBCFG_TRDT_Msk = 0x3c00
	// Position of FHMOD field.
	USB_OTG_FS_OTG_FS_GUSBCFG_FHMOD_Pos = 0x1d
	// Bit mask of FHMOD field.
	USB_OTG_FS_OTG_FS_GUSBCFG_FHMOD_Msk = 0x20000000
	// Bit FHMOD.
	USB_OTG_FS_OTG_FS_GUSBCFG_FHMOD = 0x20000000
	// Position of FDMOD field.
	USB_OTG_FS_OTG_FS_GUSBCFG_FDMOD_Pos = 0x1e
	// Bit mask of FDMOD field.
	USB_OTG_FS_OTG_FS_GUSBCFG_FDMOD_Msk = 0x40000000
	// Bit FDMOD.
	USB_OTG_FS_OTG_FS_GUSBCFG_FDMOD = 0x40000000

	// OTG_FS_GRSTCTL: OTG_FS reset register (OTG_FS_GRSTCTL)
	// Position of CSRST field.
	USB_OTG_FS_OTG_FS_GRSTCTL_CSRST_Pos = 0x0
	// Bit mask of CSRST field.
	USB_OTG_FS_OTG_FS_GRSTCTL_CSRST_Msk = 0x1
	// Bit CSRST.
	USB_OTG_FS_OTG_FS_GRSTCTL_CSRST = 0x1
	// Position of HSRST field.
	USB_OTG_FS_OTG_FS_GRSTCTL_HSRST_Pos = 0x1
	// Bit mask of HSRST field.
	USB_OTG_FS_OTG_FS_GRSTCTL_HSRST_Msk = 0x2
	// Bit HSRST.
	USB_OTG_FS_OTG_FS_GRSTCTL_HSRST = 0x2
	// Position of FCRST field.
	USB_OTG_FS_OTG_FS_GRSTCTL_FCRST_Pos = 0x2
	// Bit mask of FCRST field.
	USB_OTG_FS_OTG_FS_GRSTCTL_FCRST_Msk = 0x4
	// Bit FCRST.
	USB_OTG_FS_OTG_FS_GRSTCTL_FCRST = 0x4
	// Position of RXFFLSH field.
	USB_OTG_FS_OTG_FS_GRSTCTL_RXFFLSH_Pos = 0x4
	// Bit mask of RXFFLSH field.
	USB_OTG_FS_OTG_FS_GRSTCTL_RXFFLSH_Msk = 0x10
	// Bit RXFFLSH.
	USB_OTG_FS_OTG_FS_GRSTCTL_RXFFLSH = 0x10
	// Position of TXFFLSH field.
	USB_OTG_FS_OTG_FS_GRSTCTL_TXFFLSH_Pos = 0x5
	// Bit mask of TXFFLSH field.
	USB_OTG_FS_OTG_FS_GRSTCTL_TXFFLSH_Msk = 0x20
	// Bit TXFFLSH.
	USB_OTG_FS_OTG_FS_GRSTCTL_TXFFLSH = 0x20
	// Position of TXFNUM field.
	USB_OTG_FS_OTG_FS_GRSTCTL_TXFNUM_Pos = 0x6
	// Bit mask of TXFNUM field.
	USB_OTG_FS_OTG_FS_GRSTCTL_TXFNUM_Msk = 0x7c0
	// Position of AHBIDL field.
	USB_OTG_FS_OTG_FS_GRSTCTL_AHBIDL_Pos = 0x1f
	// Bit mask of AHBIDL field.
	USB_OTG_FS_OTG_FS_GRSTCTL_AHBIDL_Msk = 0x80000000
	// Bit AHBIDL.
	USB_OTG_FS_OTG_FS_GRSTCTL_AHBIDL = 0x80000000

	// OTG_FS_GINTSTS: OTG_FS core interrupt register (OTG_FS_GINTSTS)
	// Position of CMOD field.
	USB_OTG_FS_OTG_FS_GINTSTS_CMOD_Pos = 0x0
	// Bit mask of CMOD field.
	USB_OTG_FS_OTG_FS_GINTSTS_CMOD_Msk = 0x1
	// Bit CMOD.
	USB_OTG_FS_OTG_FS_GINTSTS_CMOD = 0x1
	// Position of MMIS field.
	USB_OTG_FS_OTG_FS_GINTSTS_MMIS_Pos = 0x1
	// Bit mask of MMIS field.
	USB_OTG_FS_OTG_FS_GINTSTS_MMIS_Msk = 0x2
	// Bit MMIS.
	USB_OTG_FS_OTG_FS_GINTSTS_MMIS = 0x2
	// Position of OTGINT field.
	USB_OTG_FS_OTG_FS_GINTSTS_OTGINT_Pos = 0x2
	// Bit mask of OTGINT field.
	USB_OTG_FS_OTG_FS_GINTSTS_OTGINT_Msk = 0x4
	// Bit OTGINT.
	USB_OTG_FS_OTG_FS_GINTSTS_OTGINT = 0x4
	// Position of SOF field.
	USB_OTG_FS_OTG_FS_GINTSTS_SOF_Pos = 0x3
	// Bit mask of SOF field.
	USB_OTG_FS_OTG_FS_GINTSTS_SOF_Msk = 0x8
	// Bit SOF.
	USB_OTG_FS_OTG_FS_GINTSTS_SOF = 0x8
	// Position of RXFLVL field.
	USB_OTG_FS_OTG_FS_GINTSTS_RXFLVL_Pos = 0x4
	// Bit mask of RXFLVL field.
	USB_OTG_FS_OTG_FS_GINTSTS_RXFLVL_Msk = 0x10
	// Bit RXFLVL.
	USB_OTG_FS_OTG_FS_GINTSTS_RXFLVL = 0x10
	// Position of NPTXFE field.
	USB_OTG_FS_OTG_FS_GINTSTS_NPTXFE_Pos = 0x5
	// Bit mask of NPTXFE field.
	USB_OTG_FS_OTG_FS_GINTSTS_NPTXFE_Msk = 0x20
	// Bit NPTXFE.
	USB_OTG_FS_OTG_FS_GINTSTS_NPTXFE = 0x20
	// Position of GINAKEFF field.
	USB_OTG_FS_OTG_FS_GINTSTS_GINAKEFF_Pos = 0x6
	// Bit mask of GINAKEFF field.
	USB_OTG_FS_OTG_FS_GINTSTS_GINAKEFF_Msk = 0x40
	// Bit GINAKEFF.
	USB_OTG_FS_OTG_FS_GINTSTS_GINAKEFF = 0x40
	// Position of GOUTNAKEFF field.
	USB_OTG_FS_OTG_FS_GINTSTS_GOUTNAKEFF_Pos = 0x7
	// Bit mask of GOUTNAKEFF field.
	USB_OTG_FS_OTG_FS_GINTSTS_GOUTNAKEFF_Msk = 0x80
	// Bit GOUTNAKEFF.
	USB_OTG_FS_OTG_FS_GINTSTS_GOUTNAKEFF = 0x80
	// Position of ESUSP field.
	USB_OTG_FS_OTG_FS_GINTSTS_ESUSP_Pos = 0xa
	// Bit mask of ESUSP field.
	USB_OTG_FS_OTG_FS_GINTSTS_ESUSP_Msk = 0x400
	// Bit ESUSP.
	USB_OTG_FS_OTG_FS_GINTSTS_ESUSP = 0x400
	// Position of USBSUSP field.
	USB_OTG_FS_OTG_FS_GINTSTS_USBSUSP_Pos = 0xb
	// Bit mask of USBSUSP field.
	USB_OTG_FS_OTG_FS_GINTSTS_USBSUSP_Msk = 0x800
	// Bit USBSUSP.
	USB_OTG_FS_OTG_FS_GINTSTS_USBSUSP = 0x800
	// Position of USBRST field.
	USB_OTG_FS_OTG_FS_GINTSTS_USBRST_Pos = 0xc
	// Bit mask of USBRST field.
	USB_OTG_FS_OTG_FS_GINTSTS_USBRST_Msk = 0x1000
	// Bit USBRST.
	USB_OTG_FS_OTG_FS_GINTSTS_USBRST = 0x1000
	// Position of ENUMDNE field.
	USB_OTG_FS_OTG_FS_GINTSTS_ENUMDNE_Pos = 0xd
	// Bit mask of ENUMDNE field.
	USB_OTG_FS_OTG_FS_GINTSTS_ENUMDNE_Msk = 0x2000
	// Bit ENUMDNE.
	USB_OTG_FS_OTG_FS_GINTSTS_ENUMDNE = 0x2000
	// Position of ISOODRP field.
	USB_OTG_FS_OTG_FS_GINTSTS_ISOODRP_Pos = 0xe
	// Bit mask of ISOODRP field.
	USB_OTG_FS_OTG_FS_GINTSTS_ISOODRP_Msk = 0x4000
	// Bit ISOODRP.
	USB_OTG_FS_OTG_FS_GINTSTS_ISOODRP = 0x4000
	// Position of EOPF field.
	USB_OTG_FS_OTG_FS_GINTSTS_EOPF_Pos = 0xf
	// Bit mask of EOPF field.
	USB_OTG_FS_OTG_FS_GINTSTS_EOPF_Msk = 0x8000
	// Bit EOPF.
	USB_OTG_FS_OTG_FS_GINTSTS_EOPF = 0x8000
	// Position of IEPINT field.
	USB_OTG_FS_OTG_FS_GINTSTS_IEPINT_Pos = 0x12
	// Bit mask of IEPINT field.
	USB_OTG_FS_OTG_FS_GINTSTS_IEPINT_Msk = 0x40000
	// Bit IEPINT.
	USB_OTG_FS_OTG_FS_GINTSTS_IEPINT = 0x40000
	// Position of OEPINT field.
	USB_OTG_FS_OTG_FS_GINTSTS_OEPINT_Pos = 0x13
	// Bit mask of OEPINT field.
	USB_OTG_FS_OTG_FS_GINTSTS_OEPINT_Msk = 0x80000
	// Bit OEPINT.
	USB_OTG_FS_OTG_FS_GINTSTS_OEPINT = 0x80000
	// Position of IISOIXFR field.
	USB_OTG_FS_OTG_FS_GINTSTS_IISOIXFR_Pos = 0x14
	// Bit mask of IISOIXFR field.
	USB_OTG_FS_OTG_FS_GINTSTS_IISOIXFR_Msk = 0x100000
	// Bit IISOIXFR.
	USB_OTG_FS_OTG_FS_GINTSTS_IISOIXFR = 0x100000
	// Position of IPXFR_INCOMPISOOUT field.
	USB_OTG_FS_OTG_FS_GINTSTS_IPXFR_INCOMPISOOUT_Pos = 0x15
	// Bit mask of IPXFR_INCOMPISOOUT field.
	USB_OTG_FS_OTG_FS_GINTSTS_IPXFR_INCOMPISOOUT_Msk = 0x200000
	// Bit IPXFR_INCOMPISOOUT.
	USB_OTG_FS_OTG_FS_GINTSTS_IPXFR_INCOMPISOOUT = 0x200000
	// Position of HPRTINT field.
	USB_OTG_FS_OTG_FS_GINTSTS_HPRTINT_Pos = 0x18
	// Bit mask of HPRTINT field.
	USB_OTG_FS_OTG_FS_GINTSTS_HPRTINT_Msk = 0x1000000
	// Bit HPRTINT.
	USB_OTG_FS_OTG_FS_GINTSTS_HPRTINT = 0x1000000
	// Position of HCINT field.
	USB_OTG_FS_OTG_FS_GINTSTS_HCINT_Pos = 0x19
	// Bit mask of HCINT field.
	USB_OTG_FS_OTG_FS_GINTSTS_HCINT_Msk = 0x2000000
	// Bit HCINT.
	USB_OTG_FS_OTG_FS_GINTSTS_HCINT = 0x2000000
	// Position of PTXFE field.
	USB_OTG_FS_OTG_FS_GINTSTS_PTXFE_Pos = 0x1a
	// Bit mask of PTXFE field.
	USB_OTG_FS_OTG_FS_GINTSTS_PTXFE_Msk = 0x4000000
	// Bit PTXFE.
	USB_OTG_FS_OTG_FS_GINTSTS_PTXFE = 0x4000000
	// Position of CIDSCHG field.
	USB_OTG_FS_OTG_FS_GINTSTS_CIDSCHG_Pos = 0x1c
	// Bit mask of CIDSCHG field.
	USB_OTG_FS_OTG_FS_GINTSTS_CIDSCHG_Msk = 0x10000000
	// Bit CIDSCHG.
	USB_OTG_FS_OTG_FS_GINTSTS_CIDSCHG = 0x10000000
	// Position of DISCINT field.
	USB_OTG_FS_OTG_FS_GINTSTS_DISCINT_Pos = 0x1d
	// Bit mask of DISCINT field.
	USB_OTG_FS_OTG_FS_GINTSTS_DISCINT_Msk = 0x20000000
	// Bit DISCINT.
	USB_OTG_FS_OTG_FS_GINTSTS_DISCINT = 0x20000000
	// Position of SRQINT field.
	USB_OTG_FS_OTG_FS_GINTSTS_SRQINT_Pos = 0x1e
	// Bit mask of SRQINT field.
	USB_OTG_FS_OTG_FS_GINTSTS_SRQINT_Msk = 0x40000000
	// Bit SRQINT.
	USB_OTG_FS_OTG_FS_GINTSTS_SRQINT = 0x40000000
	// Position of WKUPINT field.
	USB_OTG_FS_OTG_FS_GINTSTS_WKUPINT_Pos = 0x1f
	// Bit mask of WKUPINT field.
	USB_OTG_FS_OTG_FS_GINTSTS_WKUPINT_Msk = 0x80000000
	// Bit WKUPINT.
	USB_OTG_FS_OTG_FS_GINTSTS_WKUPINT = 0x80000000
	// Position of RSTDET field.
	USB_OTG_FS_OTG_FS_GINTSTS_RSTDET_Pos = 0x17
	// Bit mask of RSTDET field.
	USB_OTG_FS_OTG_FS_GINTSTS_RSTDET_Msk = 0x800000
	// Bit RSTDET.
	USB_OTG_FS_OTG_FS_GINTSTS_RSTDET = 0x800000

	// OTG_FS_GINTMSK: OTG_FS interrupt mask register (OTG_FS_GINTMSK)
	// Position of MMISM field.
	USB_OTG_FS_OTG_FS_GINTMSK_MMISM_Pos = 0x1
	// Bit mask of MMISM field.
	USB_OTG_FS_OTG_FS_GINTMSK_MMISM_Msk = 0x2
	// Bit MMISM.
	USB_OTG_FS_OTG_FS_GINTMSK_MMISM = 0x2
	// Position of OTGINT field.
	USB_OTG_FS_OTG_FS_GINTMSK_OTGINT_Pos = 0x2
	// Bit mask of OTGINT field.
	USB_OTG_FS_OTG_FS_GINTMSK_OTGINT_Msk = 0x4
	// Bit OTGINT.
	USB_OTG_FS_OTG_FS_GINTMSK_OTGINT = 0x4
	// Position of SOFM field.
	USB_OTG_FS_OTG_FS_GINTMSK_SOFM_Pos = 0x3
	// Bit mask of SOFM field.
	USB_OTG_FS_OTG_FS_GINTMSK_SOFM_Msk = 0x8
	// Bit SOFM.
	USB_OTG_FS_OTG_FS_GINTMSK_SOFM = 0x8
	// Position of RXFLVLM field.
	USB_OTG_FS_OTG_FS_GINTMSK_RXFLVLM_Pos = 0x4
	// Bit mask of RXFLVLM field.
	USB_OTG_FS_OTG_FS_GINTMSK_RXFLVLM_Msk = 0x10
	// Bit RXFLVLM.
	USB_OTG_FS_OTG_FS_GINTMSK_RXFLVLM = 0x10
	// Position of NPTXFEM field.
	USB_OTG_FS_OTG_FS_GINTMSK_NPTXFEM_Pos = 0x5
	// Bit mask of NPTXFEM field.
	USB_OTG_FS_OTG_FS_GINTMSK_NPTXFEM_Msk = 0x20
	// Bit NPTXFEM.
	USB_OTG_FS_OTG_FS_GINTMSK_NPTXFEM = 0x20
	// Position of GINAKEFFM field.
	USB_OTG_FS_OTG_FS_GINTMSK_GINAKEFFM_Pos = 0x6
	// Bit mask of GINAKEFFM field.
	USB_OTG_FS_OTG_FS_GINTMSK_GINAKEFFM_Msk = 0x40
	// Bit GINAKEFFM.
	USB_OTG_FS_OTG_FS_GINTMSK_GINAKEFFM = 0x40
	// Position of GONAKEFFM field.
	USB_OTG_FS_OTG_FS_GINTMSK_GONAKEFFM_Pos = 0x7
	// Bit mask of GONAKEFFM field.
	USB_OTG_FS_OTG_FS_GINTMSK_GONAKEFFM_Msk = 0x80
	// Bit GONAKEFFM.
	USB_OTG_FS_OTG_FS_GINTMSK_GONAKEFFM = 0x80
	// Position of ESUSPM field.
	USB_OTG_FS_OTG_FS_GINTMSK_ESUSPM_Pos = 0xa
	// Bit mask of ESUSPM field.
	USB_OTG_FS_OTG_FS_GINTMSK_ESUSPM_Msk = 0x400
	// Bit ESUSPM.
	USB_OTG_FS_OTG_FS_GINTMSK_ESUSPM = 0x400
	// Position of USBSUSPM field.
	USB_OTG_FS_OTG_FS_GINTMSK_USBSUSPM_Pos = 0xb
	// Bit mask of USBSUSPM field.
	USB_OTG_FS_OTG_FS_GINTMSK_USBSUSPM_Msk = 0x800
	// Bit USBSUSPM.
	USB_OTG_FS_OTG_FS_GINTMSK_USBSUSPM = 0x800
	// Position of USBRST field.
	USB_OTG_FS_OTG_FS_GINTMSK_USBRST_Pos = 0xc
	// Bit mask of USBRST field.
	USB_OTG_FS_OTG_FS_GINTMSK_USBRST_Msk = 0x1000
	// Bit USBRST.
	USB_OTG_FS_OTG_FS_GINTMSK_USBRST = 0x1000
	// Position of ENUMDNEM field.
	USB_OTG_FS_OTG_FS_GINTMSK_ENUMDNEM_Pos = 0xd
	// Bit mask of ENUMDNEM field.
	USB_OTG_FS_OTG_FS_GINTMSK_ENUMDNEM_Msk = 0x2000
	// Bit ENUMDNEM.
	USB_OTG_FS_OTG_FS_GINTMSK_ENUMDNEM = 0x2000
	// Position of ISOODRPM field.
	USB_OTG_FS_OTG_FS_GINTMSK_ISOODRPM_Pos = 0xe
	// Bit mask of ISOODRPM field.
	USB_OTG_FS_OTG_FS_GINTMSK_ISOODRPM_Msk = 0x4000
	// Bit ISOODRPM.
	USB_OTG_FS_OTG_FS_GINTMSK_ISOODRPM = 0x4000
	// Position of EOPFM field.
	USB_OTG_FS_OTG_FS_GINTMSK_EOPFM_Pos = 0xf
	// Bit mask of EOPFM field.
	USB_OTG_FS_OTG_FS_GINTMSK_EOPFM_Msk = 0x8000
	// Bit EOPFM.
	USB_OTG_FS_OTG_FS_GINTMSK_EOPFM = 0x8000
	// Position of IEPINT field.
	USB_OTG_FS_OTG_FS_GINTMSK_IEPINT_Pos = 0x12
	// Bit mask of IEPINT field.
	USB_OTG_FS_OTG_FS_GINTMSK_IEPINT_Msk = 0x40000
	// Bit IEPINT.
	USB_OTG_FS_OTG_FS_GINTMSK_IEPINT = 0x40000
	// Position of OEPINT field.
	USB_OTG_FS_OTG_FS_GINTMSK_OEPINT_Pos = 0x13
	// Bit mask of OEPINT field.
	USB_OTG_FS_OTG_FS_GINTMSK_OEPINT_Msk = 0x80000
	// Bit OEPINT.
	USB_OTG_FS_OTG_FS_GINTMSK_OEPINT = 0x80000
	// Position of IISOIXFRM field.
	USB_OTG_FS_OTG_FS_GINTMSK_IISOIXFRM_Pos = 0x14
	// Bit mask of IISOIXFRM field.
	USB_OTG_FS_OTG_FS_GINTMSK_IISOIXFRM_Msk = 0x100000
	// Bit IISOIXFRM.
	USB_OTG_FS_OTG_FS_GINTMSK_IISOIXFRM = 0x100000
	// Position of IPXFRM_IISOOXFRM field.
	USB_OTG_FS_OTG_FS_GINTMSK_IPXFRM_IISOOXFRM_Pos = 0x15
	// Bit mask of IPXFRM_IISOOXFRM field.
	USB_OTG_FS_OTG_FS_GINTMSK_IPXFRM_IISOOXFRM_Msk = 0x200000
	// Bit IPXFRM_IISOOXFRM.
	USB_OTG_FS_OTG_FS_GINTMSK_IPXFRM_IISOOXFRM = 0x200000
	// Position of PRTIM field.
	USB_OTG_FS_OTG_FS_GINTMSK_PRTIM_Pos = 0x18
	// Bit mask of PRTIM field.
	USB_OTG_FS_OTG_FS_GINTMSK_PRTIM_Msk = 0x1000000
	// Bit PRTIM.
	USB_OTG_FS_OTG_FS_GINTMSK_PRTIM = 0x1000000
	// Position of HCIM field.
	USB_OTG_FS_OTG_FS_GINTMSK_HCIM_Pos = 0x19
	// Bit mask of HCIM field.
	USB_OTG_FS_OTG_FS_GINTMSK_HCIM_Msk = 0x2000000
	// Bit HCIM.
	USB_OTG_FS_OTG_FS_GINTMSK_HCIM = 0x2000000
	// Position of PTXFEM field.
	USB_OTG_FS_OTG_FS_GINTMSK_PTXFEM_Pos = 0x1a
	// Bit mask of PTXFEM field.
	USB_OTG_FS_OTG_FS_GINTMSK_PTXFEM_Msk = 0x4000000
	// Bit PTXFEM.
	USB_OTG_FS_OTG_FS_GINTMSK_PTXFEM = 0x4000000
	// Position of CIDSCHGM field.
	USB_OTG_FS_OTG_FS_GINTMSK_CIDSCHGM_Pos = 0x1c
	// Bit mask of CIDSCHGM field.
	USB_OTG_FS_OTG_FS_GINTMSK_CIDSCHGM_Msk = 0x10000000
	// Bit CIDSCHGM.
	USB_OTG_FS_OTG_FS_GINTMSK_CIDSCHGM = 0x10000000
	// Position of DISCINT field.
	USB_OTG_FS_OTG_FS_GINTMSK_DISCINT_Pos = 0x1d
	// Bit mask of DISCINT field.
	USB_OTG_FS_OTG_FS_GINTMSK_DISCINT_Msk = 0x20000000
	// Bit DISCINT.
	USB_OTG_FS_OTG_FS_GINTMSK_DISCINT = 0x20000000
	// Position of SRQIM field.
	USB_OTG_FS_OTG_FS_GINTMSK_SRQIM_Pos = 0x1e
	// Bit mask of SRQIM field.
	USB_OTG_FS_OTG_FS_GINTMSK_SRQIM_Msk = 0x40000000
	// Bit SRQIM.
	USB_OTG_FS_OTG_FS_GINTMSK_SRQIM = 0x40000000
	// Position of WUIM field.
	USB_OTG_FS_OTG_FS_GINTMSK_WUIM_Pos = 0x1f
	// Bit mask of WUIM field.
	USB_OTG_FS_OTG_FS_GINTMSK_WUIM_Msk = 0x80000000
	// Bit WUIM.
	USB_OTG_FS_OTG_FS_GINTMSK_WUIM = 0x80000000
	// Position of RSTDETM field.
	USB_OTG_FS_OTG_FS_GINTMSK_RSTDETM_Pos = 0x17
	// Bit mask of RSTDETM field.
	USB_OTG_FS_OTG_FS_GINTMSK_RSTDETM_Msk = 0x800000
	// Bit RSTDETM.
	USB_OTG_FS_OTG_FS_GINTMSK_RSTDETM = 0x800000
	// Position of LPMIN field.
	USB_OTG_FS_OTG_FS_GINTMSK_LPMIN_Pos = 0x1b
	// Bit mask of LPMIN field.
	USB_OTG_FS_OTG_FS_GINTMSK_LPMIN_Msk = 0x8000000
	// Bit LPMIN.
	USB_OTG_FS_OTG_FS_GINTMSK_LPMIN = 0x8000000

	// OTG_FS_GRXSTSR_Device: OTG_FS Receive status debug read(Device mode)
	// Position of EPNUM field.
	USB_OTG_FS_OTG_FS_GRXSTSR_Device_EPNUM_Pos = 0x0
	// Bit mask of EPNUM field.
	USB_OTG_FS_OTG_FS_GRXSTSR_Device_EPNUM_Msk = 0xf
	// Position of BCNT field.
	USB_OTG_FS_OTG_FS_GRXSTSR_Device_BCNT_Pos = 0x4
	// Bit mask of BCNT field.
	USB_OTG_FS_OTG_FS_GRXSTSR_Device_BCNT_Msk = 0x7ff0
	// Position of DPID field.
	USB_OTG_FS_OTG_FS_GRXSTSR_Device_DPID_Pos = 0xf
	// Bit mask of DPID field.
	USB_OTG_FS_OTG_FS_GRXSTSR_Device_DPID_Msk = 0x18000
	// Position of PKTSTS field.
	USB_OTG_FS_OTG_FS_GRXSTSR_Device_PKTSTS_Pos = 0x11
	// Bit mask of PKTSTS field.
	USB_OTG_FS_OTG_FS_GRXSTSR_Device_PKTSTS_Msk = 0x1e0000
	// Position of FRMNUM field.
	USB_OTG_FS_OTG_FS_GRXSTSR_Device_FRMNUM_Pos = 0x15
	// Bit mask of FRMNUM field.
	USB_OTG_FS_OTG_FS_GRXSTSR_Device_FRMNUM_Msk = 0x1e00000

	// OTG_FS_GRXSTSR_Host: OTG_FS Receive status debug read(Host mode)
	// Position of CHNUM field.
	USB_OTG_FS_OTG_FS_GRXSTSR_Host_CHNUM_Pos = 0x0
	// Bit mask of CHNUM field.
	USB_OTG_FS_OTG_FS_GRXSTSR_Host_CHNUM_Msk = 0xf
	// Position of BCNT field.
	USB_OTG_FS_OTG_FS_GRXSTSR_Host_BCNT_Pos = 0x4
	// Bit mask of BCNT field.
	USB_OTG_FS_OTG_FS_GRXSTSR_Host_BCNT_Msk = 0x7ff0
	// Position of DPID field.
	USB_OTG_FS_OTG_FS_GRXSTSR_Host_DPID_Pos = 0xf
	// Bit mask of DPID field.
	USB_OTG_FS_OTG_FS_GRXSTSR_Host_DPID_Msk = 0x18000
	// Position of PKTSTS field.
	USB_OTG_FS_OTG_FS_GRXSTSR_Host_PKTSTS_Pos = 0x11
	// Bit mask of PKTSTS field.
	USB_OTG_FS_OTG_FS_GRXSTSR_Host_PKTSTS_Msk = 0x1e0000

	// OTG_FS_GRXSTSP_Device: OTG status read and pop register (Device mode)
	// Position of EPNUM field.
	USB_OTG_FS_OTG_FS_GRXSTSP_Device_EPNUM_Pos = 0x0
	// Bit mask of EPNUM field.
	USB_OTG_FS_OTG_FS_GRXSTSP_Device_EPNUM_Msk = 0xf
	// Position of BCNT field.
	USB_OTG_FS_OTG_FS_GRXSTSP_Device_BCNT_Pos = 0x4
	// Bit mask of BCNT field.
	USB_OTG_FS_OTG_FS_GRXSTSP_Device_BCNT_Msk = 0x7ff0
	// Position of DPID field.
	USB_OTG_FS_OTG_FS_GRXSTSP_Device_DPID_Pos = 0xf
	// Bit mask of DPID field.
	USB_OTG_FS_OTG_FS_GRXSTSP_Device_DPID_Msk = 0x18000
	// Position of PKTSTS field.
	USB_OTG_FS_OTG_FS_GRXSTSP_Device_PKTSTS_Pos = 0x11
	// Bit mask of PKTSTS field.
	USB_OTG_FS_OTG_FS_GRXSTSP_Device_PKTSTS_Msk = 0x1e0000
	// Position of FRMNUM field.
	USB_OTG_FS_OTG_FS_GRXSTSP_Device_FRMNUM_Pos = 0x15
	// Bit mask of FRMNUM field.
	USB_OTG_FS_OTG_FS_GRXSTSP_Device_FRMNUM_Msk = 0x1e00000

	// OTG_FS_GRXSTSP_Host: OTG status read and pop register (Host mode)
	// Position of CHNUM field.
	USB_OTG_FS_OTG_FS_GRXSTSP_Host_CHNUM_Pos = 0x0
	// Bit mask of CHNUM field.
	USB_OTG_FS_OTG_FS_GRXSTSP_Host_CHNUM_Msk = 0xf
	// Position of BCNT field.
	USB_OTG_FS_OTG_FS_GRXSTSP_Host_BCNT_Pos = 0x4
	// Bit mask of BCNT field.
	USB_OTG_FS_OTG_FS_GRXSTSP_Host_BCNT_Msk = 0x7ff0
	// Position of DPID field.
	USB_OTG_FS_OTG_FS_GRXSTSP_Host_DPID_Pos = 0xf
	// Bit mask of DPID field.
	USB_OTG_FS_OTG_FS_GRXSTSP_Host_DPID_Msk = 0x18000
	// Position of PKTSTS field.
	USB_OTG_FS_OTG_FS_GRXSTSP_Host_PKTSTS_Pos = 0x11
	// Bit mask of PKTSTS field.
	USB_OTG_FS_OTG_FS_GRXSTSP_Host_PKTSTS_Msk = 0x1e0000

	// OTG_FS_GRXFSIZ: OTG_FS Receive FIFO size register (OTG_FS_GRXFSIZ)
	// Position of RXFD field.
	USB_OTG_FS_OTG_FS_GRXFSIZ_RXFD_Pos = 0x0
	// Bit mask of RXFD field.
	USB_OTG_FS_OTG_FS_GRXFSIZ_RXFD_Msk = 0xffff

	// OTG_FS_DIEPTXF0_Device: OTG_FS Endpoint 0 Transmit FIFO size
	// Position of TX0FSA field.
	USB_OTG_FS_OTG_FS_DIEPTXF0_Device_TX0FSA_Pos = 0x0
	// Bit mask of TX0FSA field.
	USB_OTG_FS_OTG_FS_DIEPTXF0_Device_TX0FSA_Msk = 0xffff
	// Position of TX0FD field.
	USB_OTG_FS_OTG_FS_DIEPTXF0_Device_TX0FD_Pos = 0x10
	// Bit mask of TX0FD field.
	USB_OTG_FS_OTG_FS_DIEPTXF0_Device_TX0FD_Msk = 0xffff0000

	// OTG_FS_HNPTXFSIZ_Host: OTG_FS Host non-periodic transmit FIFO size register
	// Position of NPTXFSA field.
	USB_OTG_FS_OTG_FS_HNPTXFSIZ_Host_NPTXFSA_Pos = 0x0
	// Bit mask of NPTXFSA field.
	USB_OTG_FS_OTG_FS_HNPTXFSIZ_Host_NPTXFSA_Msk = 0xffff
	// Position of NPTXFD field.
	USB_OTG_FS_OTG_FS_HNPTXFSIZ_Host_NPTXFD_Pos = 0x10
	// Bit mask of NPTXFD field.
	USB_OTG_FS_OTG_FS_HNPTXFSIZ_Host_NPTXFD_Msk = 0xffff0000

	// OTG_FS_HNPTXSTS: OTG_FS non-periodic transmit FIFO/queue status register (OTG_FS_GNPTXSTS)
	// Position of NPTXFSAV field.
	USB_OTG_FS_OTG_FS_HNPTXSTS_NPTXFSAV_Pos = 0x0
	// Bit mask of NPTXFSAV field.
	USB_OTG_FS_OTG_FS_HNPTXSTS_NPTXFSAV_Msk = 0xffff
	// Position of NPTQXSAV field.
	USB_OTG_FS_OTG_FS_HNPTXSTS_NPTQXSAV_Pos = 0x10
	// Bit mask of NPTQXSAV field.
	USB_OTG_FS_OTG_FS_HNPTXSTS_NPTQXSAV_Msk = 0xff0000
	// Position of NPTXQTOP field.
	USB_OTG_FS_OTG_FS_HNPTXSTS_NPTXQTOP_Pos = 0x18
	// Bit mask of NPTXQTOP field.
	USB_OTG_FS_OTG_FS_HNPTXSTS_NPTXQTOP_Msk = 0x7f000000

	// OTG_FS_GI2CCTL: OTG I2C access register
	// Position of RWDATA field.
	USB_OTG_FS_OTG_FS_GI2CCTL_RWDATA_Pos = 0x0
	// Bit mask of RWDATA field.
	USB_OTG_FS_OTG_FS_GI2CCTL_RWDATA_Msk = 0xff
	// Position of REGADDR field.
	USB_OTG_FS_OTG_FS_GI2CCTL_REGADDR_Pos = 0x8
	// Bit mask of REGADDR field.
	USB_OTG_FS_OTG_FS_GI2CCTL_REGADDR_Msk = 0xff00
	// Position of ADDR field.
	USB_OTG_FS_OTG_FS_GI2CCTL_ADDR_Pos = 0x10
	// Bit mask of ADDR field.
	USB_OTG_FS_OTG_FS_GI2CCTL_ADDR_Msk = 0x7f0000
	// Position of I2CEN field.
	USB_OTG_FS_OTG_FS_GI2CCTL_I2CEN_Pos = 0x17
	// Bit mask of I2CEN field.
	USB_OTG_FS_OTG_FS_GI2CCTL_I2CEN_Msk = 0x800000
	// Bit I2CEN.
	USB_OTG_FS_OTG_FS_GI2CCTL_I2CEN = 0x800000
	// Position of ACK field.
	USB_OTG_FS_OTG_FS_GI2CCTL_ACK_Pos = 0x18
	// Bit mask of ACK field.
	USB_OTG_FS_OTG_FS_GI2CCTL_ACK_Msk = 0x1000000
	// Bit ACK.
	USB_OTG_FS_OTG_FS_GI2CCTL_ACK = 0x1000000
	// Position of I2CDEVADR field.
	USB_OTG_FS_OTG_FS_GI2CCTL_I2CDEVADR_Pos = 0x1a
	// Bit mask of I2CDEVADR field.
	USB_OTG_FS_OTG_FS_GI2CCTL_I2CDEVADR_Msk = 0xc000000
	// Position of I2CDATSE0 field.
	USB_OTG_FS_OTG_FS_GI2CCTL_I2CDATSE0_Pos = 0x1c
	// Bit mask of I2CDATSE0 field.
	USB_OTG_FS_OTG_FS_GI2CCTL_I2CDATSE0_Msk = 0x10000000
	// Bit I2CDATSE0.
	USB_OTG_FS_OTG_FS_GI2CCTL_I2CDATSE0 = 0x10000000
	// Position of RW field.
	USB_OTG_FS_OTG_FS_GI2CCTL_RW_Pos = 0x1e
	// Bit mask of RW field.
	USB_OTG_FS_OTG_FS_GI2CCTL_RW_Msk = 0x40000000
	// Bit RW.
	USB_OTG_FS_OTG_FS_GI2CCTL_RW = 0x40000000
	// Position of BSYDNE field.
	USB_OTG_FS_OTG_FS_GI2CCTL_BSYDNE_Pos = 0x1f
	// Bit mask of BSYDNE field.
	USB_OTG_FS_OTG_FS_GI2CCTL_BSYDNE_Msk = 0x80000000
	// Bit BSYDNE.
	USB_OTG_FS_OTG_FS_GI2CCTL_BSYDNE = 0x80000000

	// OTG_FS_GCCFG: OTG_FS general core configuration register (OTG_FS_GCCFG)
	// Position of PWRDWN field.
	USB_OTG_FS_OTG_FS_GCCFG_PWRDWN_Pos = 0x10
	// Bit mask of PWRDWN field.
	USB_OTG_FS_OTG_FS_GCCFG_PWRDWN_Msk = 0x10000
	// Bit PWRDWN.
	USB_OTG_FS_OTG_FS_GCCFG_PWRDWN = 0x10000
	// Position of BCDEN field.
	USB_OTG_FS_OTG_FS_GCCFG_BCDEN_Pos = 0x11
	// Bit mask of BCDEN field.
	USB_OTG_FS_OTG_FS_GCCFG_BCDEN_Msk = 0x20000
	// Bit BCDEN.
	USB_OTG_FS_OTG_FS_GCCFG_BCDEN = 0x20000
	// Position of DCDEN field.
	USB_OTG_FS_OTG_FS_GCCFG_DCDEN_Pos = 0x12
	// Bit mask of DCDEN field.
	USB_OTG_FS_OTG_FS_GCCFG_DCDEN_Msk = 0x40000
	// Bit DCDEN.
	USB_OTG_FS_OTG_FS_GCCFG_DCDEN = 0x40000
	// Position of PDEN field.
	USB_OTG_FS_OTG_FS_GCCFG_PDEN_Pos = 0x13
	// Bit mask of PDEN field.
	USB_OTG_FS_OTG_FS_GCCFG_PDEN_Msk = 0x80000
	// Bit PDEN.
	USB_OTG_FS_OTG_FS_GCCFG_PDEN = 0x80000
	// Position of SDEN field.
	USB_OTG_FS_OTG_FS_GCCFG_SDEN_Pos = 0x14
	// Bit mask of SDEN field.
	USB_OTG_FS_OTG_FS_GCCFG_SDEN_Msk = 0x100000
	// Bit SDEN.
	USB_OTG_FS_OTG_FS_GCCFG_SDEN = 0x100000
	// Position of VBDEN field.
	USB_OTG_FS_OTG_FS_GCCFG_VBDEN_Pos = 0x15
	// Bit mask of VBDEN field.
	USB_OTG_FS_OTG_FS_GCCFG_VBDEN_Msk = 0x200000
	// Bit VBDEN.
	USB_OTG_FS_OTG_FS_GCCFG_VBDEN = 0x200000
	// Position of DCDET field.
	USB_OTG_FS_OTG_FS_GCCFG_DCDET_Pos = 0x0
	// Bit mask of DCDET field.
	USB_OTG_FS_OTG_FS_GCCFG_DCDET_Msk = 0x1
	// Bit DCDET.
	USB_OTG_FS_OTG_FS_GCCFG_DCDET = 0x1
	// Position of PDET field.
	USB_OTG_FS_OTG_FS_GCCFG_PDET_Pos = 0x1
	// Bit mask of PDET field.
	USB_OTG_FS_OTG_FS_GCCFG_PDET_Msk = 0x2
	// Bit PDET.
	USB_OTG_FS_OTG_FS_GCCFG_PDET = 0x2
	// Position of SDET field.
	USB_OTG_FS_OTG_FS_GCCFG_SDET_Pos = 0x2
	// Bit mask of SDET field.
	USB_OTG_FS_OTG_FS_GCCFG_SDET_Msk = 0x4
	// Bit SDET.
	USB_OTG_FS_OTG_FS_GCCFG_SDET = 0x4
	// Position of PS2DET field.
	USB_OTG_FS_OTG_FS_GCCFG_PS2DET_Pos = 0x3
	// Bit mask of PS2DET field.
	USB_OTG_FS_OTG_FS_GCCFG_PS2DET_Msk = 0x8
	// Bit PS2DET.
	USB_OTG_FS_OTG_FS_GCCFG_PS2DET = 0x8

	// OTG_FS_CID: core ID register
	// Position of PRODUCT_ID field.
	USB_OTG_FS_OTG_FS_CID_PRODUCT_ID_Pos = 0x0
	// Bit mask of PRODUCT_ID field.
	USB_OTG_FS_OTG_FS_CID_PRODUCT_ID_Msk = 0xffffffff

	// OTG_FS_GLPMCFG: OTG core LPM configuration register
	// Position of LPMEN field.
	USB_OTG_FS_OTG_FS_GLPMCFG_LPMEN_Pos = 0x0
	// Bit mask of LPMEN field.
	USB_OTG_FS_OTG_FS_GLPMCFG_LPMEN_Msk = 0x1
	// Bit LPMEN.
	USB_OTG_FS_OTG_FS_GLPMCFG_LPMEN = 0x1
	// Position of LPMACK field.
	USB_OTG_FS_OTG_FS_GLPMCFG_LPMACK_Pos = 0x1
	// Bit mask of LPMACK field.
	USB_OTG_FS_OTG_FS_GLPMCFG_LPMACK_Msk = 0x2
	// Bit LPMACK.
	USB_OTG_FS_OTG_FS_GLPMCFG_LPMACK = 0x2
	// Position of BESL field.
	USB_OTG_FS_OTG_FS_GLPMCFG_BESL_Pos = 0x2
	// Bit mask of BESL field.
	USB_OTG_FS_OTG_FS_GLPMCFG_BESL_Msk = 0x3c
	// Position of REMWAKE field.
	USB_OTG_FS_OTG_FS_GLPMCFG_REMWAKE_Pos = 0x6
	// Bit mask of REMWAKE field.
	USB_OTG_FS_OTG_FS_GLPMCFG_REMWAKE_Msk = 0x40
	// Bit REMWAKE.
	USB_OTG_FS_OTG_FS_GLPMCFG_REMWAKE = 0x40
	// Position of L1SSEN field.
	USB_OTG_FS_OTG_FS_GLPMCFG_L1SSEN_Pos = 0x7
	// Bit mask of L1SSEN field.
	USB_OTG_FS_OTG_FS_GLPMCFG_L1SSEN_Msk = 0x80
	// Bit L1SSEN.
	USB_OTG_FS_OTG_FS_GLPMCFG_L1SSEN = 0x80
	// Position of BESLTHRS field.
	USB_OTG_FS_OTG_FS_GLPMCFG_BESLTHRS_Pos = 0x8
	// Bit mask of BESLTHRS field.
	USB_OTG_FS_OTG_FS_GLPMCFG_BESLTHRS_Msk = 0xf00
	// Position of L1DSEN field.
	USB_OTG_FS_OTG_FS_GLPMCFG_L1DSEN_Pos = 0xc
	// Bit mask of L1DSEN field.
	USB_OTG_FS_OTG_FS_GLPMCFG_L1DSEN_Msk = 0x1000
	// Bit L1DSEN.
	USB_OTG_FS_OTG_FS_GLPMCFG_L1DSEN = 0x1000
	// Position of LPMRST field.
	USB_OTG_FS_OTG_FS_GLPMCFG_LPMRST_Pos = 0xd
	// Bit mask of LPMRST field.
	USB_OTG_FS_OTG_FS_GLPMCFG_LPMRST_Msk = 0x6000
	// Position of SLPSTS field.
	USB_OTG_FS_OTG_FS_GLPMCFG_SLPSTS_Pos = 0xf
	// Bit mask of SLPSTS field.
	USB_OTG_FS_OTG_FS_GLPMCFG_SLPSTS_Msk = 0x8000
	// Bit SLPSTS.
	USB_OTG_FS_OTG_FS_GLPMCFG_SLPSTS = 0x8000
	// Position of L1RSMOK field.
	USB_OTG_FS_OTG_FS_GLPMCFG_L1RSMOK_Pos = 0x10
	// Bit mask of L1RSMOK field.
	USB_OTG_FS_OTG_FS_GLPMCFG_L1RSMOK_Msk = 0x10000
	// Bit L1RSMOK.
	USB_OTG_FS_OTG_FS_GLPMCFG_L1RSMOK = 0x10000
	// Position of LPMCHIDX field.
	USB_OTG_FS_OTG_FS_GLPMCFG_LPMCHIDX_Pos = 0x11
	// Bit mask of LPMCHIDX field.
	USB_OTG_FS_OTG_FS_GLPMCFG_LPMCHIDX_Msk = 0x1e0000
	// Position of LPMRCNT field.
	USB_OTG_FS_OTG_FS_GLPMCFG_LPMRCNT_Pos = 0x15
	// Bit mask of LPMRCNT field.
	USB_OTG_FS_OTG_FS_GLPMCFG_LPMRCNT_Msk = 0xe00000
	// Position of SNDLPM field.
	USB_OTG_FS_OTG_FS_GLPMCFG_SNDLPM_Pos = 0x18
	// Bit mask of SNDLPM field.
	USB_OTG_FS_OTG_FS_GLPMCFG_SNDLPM_Msk = 0x1000000
	// Bit SNDLPM.
	USB_OTG_FS_OTG_FS_GLPMCFG_SNDLPM = 0x1000000
	// Position of LPMRCNTSTS field.
	USB_OTG_FS_OTG_FS_GLPMCFG_LPMRCNTSTS_Pos = 0x19
	// Bit mask of LPMRCNTSTS field.
	USB_OTG_FS_OTG_FS_GLPMCFG_LPMRCNTSTS_Msk = 0xe000000
	// Position of ENBESL field.
	USB_OTG_FS_OTG_FS_GLPMCFG_ENBESL_Pos = 0x1c
	// Bit mask of ENBESL field.
	USB_OTG_FS_OTG_FS_GLPMCFG_ENBESL_Msk = 0x10000000
	// Bit ENBESL.
	USB_OTG_FS_OTG_FS_GLPMCFG_ENBESL = 0x10000000

	// OTG_FS_GPWRDN: OTG power down register
	// Position of ADPMEN field.
	USB_OTG_FS_OTG_FS_GPWRDN_ADPMEN_Pos = 0x0
	// Bit mask of ADPMEN field.
	USB_OTG_FS_OTG_FS_GPWRDN_ADPMEN_Msk = 0x1
	// Bit ADPMEN.
	USB_OTG_FS_OTG_FS_GPWRDN_ADPMEN = 0x1
	// Position of ADPIF field.
	USB_OTG_FS_OTG_FS_GPWRDN_ADPIF_Pos = 0x17
	// Bit mask of ADPIF field.
	USB_OTG_FS_OTG_FS_GPWRDN_ADPIF_Msk = 0x800000
	// Bit ADPIF.
	USB_OTG_FS_OTG_FS_GPWRDN_ADPIF = 0x800000

	// OTG_FS_GADPCTL: OTG ADP timer, control and status register
	// Position of PRBDSCHG field.
	USB_OTG_FS_OTG_FS_GADPCTL_PRBDSCHG_Pos = 0x0
	// Bit mask of PRBDSCHG field.
	USB_OTG_FS_OTG_FS_GADPCTL_PRBDSCHG_Msk = 0x3
	// Position of PRBDELTA field.
	USB_OTG_FS_OTG_FS_GADPCTL_PRBDELTA_Pos = 0x2
	// Bit mask of PRBDELTA field.
	USB_OTG_FS_OTG_FS_GADPCTL_PRBDELTA_Msk = 0xc
	// Position of PRBPER field.
	USB_OTG_FS_OTG_FS_GADPCTL_PRBPER_Pos = 0x4
	// Bit mask of PRBPER field.
	USB_OTG_FS_OTG_FS_GADPCTL_PRBPER_Msk = 0x30
	// Position of RTIM field.
	USB_OTG_FS_OTG_FS_GADPCTL_RTIM_Pos = 0x6
	// Bit mask of RTIM field.
	USB_OTG_FS_OTG_FS_GADPCTL_RTIM_Msk = 0x1ffc0
	// Position of ENAPRB field.
	USB_OTG_FS_OTG_FS_GADPCTL_ENAPRB_Pos = 0x11
	// Bit mask of ENAPRB field.
	USB_OTG_FS_OTG_FS_GADPCTL_ENAPRB_Msk = 0x20000
	// Bit ENAPRB.
	USB_OTG_FS_OTG_FS_GADPCTL_ENAPRB = 0x20000
	// Position of ENASNS field.
	USB_OTG_FS_OTG_FS_GADPCTL_ENASNS_Pos = 0x12
	// Bit mask of ENASNS field.
	USB_OTG_FS_OTG_FS_GADPCTL_ENASNS_Msk = 0x40000
	// Bit ENASNS.
	USB_OTG_FS_OTG_FS_GADPCTL_ENASNS = 0x40000
	// Position of ADPRST field.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPRST_Pos = 0x13
	// Bit mask of ADPRST field.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPRST_Msk = 0x80000
	// Bit ADPRST.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPRST = 0x80000
	// Position of ADPEN field.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPEN_Pos = 0x14
	// Bit mask of ADPEN field.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPEN_Msk = 0x100000
	// Bit ADPEN.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPEN = 0x100000
	// Position of ADPPRBIF field.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPPRBIF_Pos = 0x15
	// Bit mask of ADPPRBIF field.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPPRBIF_Msk = 0x200000
	// Bit ADPPRBIF.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPPRBIF = 0x200000
	// Position of ADPSNSIF field.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPSNSIF_Pos = 0x16
	// Bit mask of ADPSNSIF field.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPSNSIF_Msk = 0x400000
	// Bit ADPSNSIF.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPSNSIF = 0x400000
	// Position of ADPTOIF field.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPTOIF_Pos = 0x17
	// Bit mask of ADPTOIF field.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPTOIF_Msk = 0x800000
	// Bit ADPTOIF.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPTOIF = 0x800000
	// Position of ADPPRBIM field.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPPRBIM_Pos = 0x18
	// Bit mask of ADPPRBIM field.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPPRBIM_Msk = 0x1000000
	// Bit ADPPRBIM.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPPRBIM = 0x1000000
	// Position of ADPSNSIM field.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPSNSIM_Pos = 0x19
	// Bit mask of ADPSNSIM field.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPSNSIM_Msk = 0x2000000
	// Bit ADPSNSIM.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPSNSIM = 0x2000000
	// Position of ADPTOIM field.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPTOIM_Pos = 0x1a
	// Bit mask of ADPTOIM field.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPTOIM_Msk = 0x4000000
	// Bit ADPTOIM.
	USB_OTG_FS_OTG_FS_GADPCTL_ADPTOIM = 0x4000000
	// Position of AR field.
	USB_OTG_FS_OTG_FS_GADPCTL_AR_Pos = 0x1b
	// Bit mask of AR field.
	USB_OTG_FS_OTG_FS_GADPCTL_AR_Msk = 0x18000000

	// OTG_FS_HPTXFSIZ: OTG_FS Host periodic transmit FIFO size register (OTG_FS_HPTXFSIZ)
	// Position of PTXSA field.
	USB_OTG_FS_OTG_FS_HPTXFSIZ_PTXSA_Pos = 0x0
	// Bit mask of PTXSA field.
	USB_OTG_FS_OTG_FS_HPTXFSIZ_PTXSA_Msk = 0xffff
	// Position of PTXFSIZ field.
	USB_OTG_FS_OTG_FS_HPTXFSIZ_PTXFSIZ_Pos = 0x10
	// Bit mask of PTXFSIZ field.
	USB_OTG_FS_OTG_FS_HPTXFSIZ_PTXFSIZ_Msk = 0xffff0000

	// OTG_FS_DIEPTXF1: OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF1)
	// Position of INEPTXSA field.
	USB_OTG_FS_OTG_FS_DIEPTXF1_INEPTXSA_Pos = 0x0
	// Bit mask of INEPTXSA field.
	USB_OTG_FS_OTG_FS_DIEPTXF1_INEPTXSA_Msk = 0xffff
	// Position of INEPTXFD field.
	USB_OTG_FS_OTG_FS_DIEPTXF1_INEPTXFD_Pos = 0x10
	// Bit mask of INEPTXFD field.
	USB_OTG_FS_OTG_FS_DIEPTXF1_INEPTXFD_Msk = 0xffff0000

	// OTG_FS_DIEPTXF2: OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF2)
	// Position of INEPTXSA field.
	USB_OTG_FS_OTG_FS_DIEPTXF2_INEPTXSA_Pos = 0x0
	// Bit mask of INEPTXSA field.
	USB_OTG_FS_OTG_FS_DIEPTXF2_INEPTXSA_Msk = 0xffff
	// Position of INEPTXFD field.
	USB_OTG_FS_OTG_FS_DIEPTXF2_INEPTXFD_Pos = 0x10
	// Bit mask of INEPTXFD field.
	USB_OTG_FS_OTG_FS_DIEPTXF2_INEPTXFD_Msk = 0xffff0000

	// OTG_FS_DIEPTXF3: OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF3)
	// Position of INEPTXSA field.
	USB_OTG_FS_OTG_FS_DIEPTXF3_INEPTXSA_Pos = 0x0
	// Bit mask of INEPTXSA field.
	USB_OTG_FS_OTG_FS_DIEPTXF3_INEPTXSA_Msk = 0xffff
	// Position of INEPTXFD field.
	USB_OTG_FS_OTG_FS_DIEPTXF3_INEPTXFD_Pos = 0x10
	// Bit mask of INEPTXFD field.
	USB_OTG_FS_OTG_FS_DIEPTXF3_INEPTXFD_Msk = 0xffff0000

	// OTG_FS_DIEPTXF4: OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF4)
	// Position of INEPTXSA field.
	USB_OTG_FS_OTG_FS_DIEPTXF4_INEPTXSA_Pos = 0x0
	// Bit mask of INEPTXSA field.
	USB_OTG_FS_OTG_FS_DIEPTXF4_INEPTXSA_Msk = 0xffff
	// Position of INEPTXFD field.
	USB_OTG_FS_OTG_FS_DIEPTXF4_INEPTXFD_Pos = 0x10
	// Bit mask of INEPTXFD field.
	USB_OTG_FS_OTG_FS_DIEPTXF4_INEPTXFD_Msk = 0xffff0000

	// OTG_FS_DIEPTXF5: OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF5)
	// Position of INEPTXSA field.
	USB_OTG_FS_OTG_FS_DIEPTXF5_INEPTXSA_Pos = 0x0
	// Bit mask of INEPTXSA field.
	USB_OTG_FS_OTG_FS_DIEPTXF5_INEPTXSA_Msk = 0xffff
	// Position of INEPTXFD field.
	USB_OTG_FS_OTG_FS_DIEPTXF5_INEPTXFD_Pos = 0x10
	// Bit mask of INEPTXFD field.
	USB_OTG_FS_OTG_FS_DIEPTXF5_INEPTXFD_Msk = 0xffff0000
)

// Constants for OTG_HS_GLOBAL: USB on the go high speed
const (
	// OTG_HS_GOTGCTL: OTG_HS control and status register
	// Position of SRQSCS field.
	USB_OTG_HS_OTG_HS_GOTGCTL_SRQSCS_Pos = 0x0
	// Bit mask of SRQSCS field.
	USB_OTG_HS_OTG_HS_GOTGCTL_SRQSCS_Msk = 0x1
	// Bit SRQSCS.
	USB_OTG_HS_OTG_HS_GOTGCTL_SRQSCS = 0x1
	// Position of SRQ field.
	USB_OTG_HS_OTG_HS_GOTGCTL_SRQ_Pos = 0x1
	// Bit mask of SRQ field.
	USB_OTG_HS_OTG_HS_GOTGCTL_SRQ_Msk = 0x2
	// Bit SRQ.
	USB_OTG_HS_OTG_HS_GOTGCTL_SRQ = 0x2
	// Position of HNGSCS field.
	USB_OTG_HS_OTG_HS_GOTGCTL_HNGSCS_Pos = 0x8
	// Bit mask of HNGSCS field.
	USB_OTG_HS_OTG_HS_GOTGCTL_HNGSCS_Msk = 0x100
	// Bit HNGSCS.
	USB_OTG_HS_OTG_HS_GOTGCTL_HNGSCS = 0x100
	// Position of HNPRQ field.
	USB_OTG_HS_OTG_HS_GOTGCTL_HNPRQ_Pos = 0x9
	// Bit mask of HNPRQ field.
	USB_OTG_HS_OTG_HS_GOTGCTL_HNPRQ_Msk = 0x200
	// Bit HNPRQ.
	USB_OTG_HS_OTG_HS_GOTGCTL_HNPRQ = 0x200
	// Position of HSHNPEN field.
	USB_OTG_HS_OTG_HS_GOTGCTL_HSHNPEN_Pos = 0xa
	// Bit mask of HSHNPEN field.
	USB_OTG_HS_OTG_HS_GOTGCTL_HSHNPEN_Msk = 0x400
	// Bit HSHNPEN.
	USB_OTG_HS_OTG_HS_GOTGCTL_HSHNPEN = 0x400
	// Position of DHNPEN field.
	USB_OTG_HS_OTG_HS_GOTGCTL_DHNPEN_Pos = 0xb
	// Bit mask of DHNPEN field.
	USB_OTG_HS_OTG_HS_GOTGCTL_DHNPEN_Msk = 0x800
	// Bit DHNPEN.
	USB_OTG_HS_OTG_HS_GOTGCTL_DHNPEN = 0x800
	// Position of CIDSTS field.
	USB_OTG_HS_OTG_HS_GOTGCTL_CIDSTS_Pos = 0x10
	// Bit mask of CIDSTS field.
	USB_OTG_HS_OTG_HS_GOTGCTL_CIDSTS_Msk = 0x10000
	// Bit CIDSTS.
	USB_OTG_HS_OTG_HS_GOTGCTL_CIDSTS = 0x10000
	// Position of DBCT field.
	USB_OTG_HS_OTG_HS_GOTGCTL_DBCT_Pos = 0x11
	// Bit mask of DBCT field.
	USB_OTG_HS_OTG_HS_GOTGCTL_DBCT_Msk = 0x20000
	// Bit DBCT.
	USB_OTG_HS_OTG_HS_GOTGCTL_DBCT = 0x20000
	// Position of ASVLD field.
	USB_OTG_HS_OTG_HS_GOTGCTL_ASVLD_Pos = 0x12
	// Bit mask of ASVLD field.
	USB_OTG_HS_OTG_HS_GOTGCTL_ASVLD_Msk = 0x40000
	// Bit ASVLD.
	USB_OTG_HS_OTG_HS_GOTGCTL_ASVLD = 0x40000
	// Position of BSVLD field.
	USB_OTG_HS_OTG_HS_GOTGCTL_BSVLD_Pos = 0x13
	// Bit mask of BSVLD field.
	USB_OTG_HS_OTG_HS_GOTGCTL_BSVLD_Msk = 0x80000
	// Bit BSVLD.
	USB_OTG_HS_OTG_HS_GOTGCTL_BSVLD = 0x80000
	// Position of EHEN field.
	USB_OTG_HS_OTG_HS_GOTGCTL_EHEN_Pos = 0xc
	// Bit mask of EHEN field.
	USB_OTG_HS_OTG_HS_GOTGCTL_EHEN_Msk = 0x1000
	// Bit EHEN.
	USB_OTG_HS_OTG_HS_GOTGCTL_EHEN = 0x1000

	// OTG_HS_GOTGINT: OTG_HS interrupt register
	// Position of SEDET field.
	USB_OTG_HS_OTG_HS_GOTGINT_SEDET_Pos = 0x2
	// Bit mask of SEDET field.
	USB_OTG_HS_OTG_HS_GOTGINT_SEDET_Msk = 0x4
	// Bit SEDET.
	USB_OTG_HS_OTG_HS_GOTGINT_SEDET = 0x4
	// Position of SRSSCHG field.
	USB_OTG_HS_OTG_HS_GOTGINT_SRSSCHG_Pos = 0x8
	// Bit mask of SRSSCHG field.
	USB_OTG_HS_OTG_HS_GOTGINT_SRSSCHG_Msk = 0x100
	// Bit SRSSCHG.
	USB_OTG_HS_OTG_HS_GOTGINT_SRSSCHG = 0x100
	// Position of HNSSCHG field.
	USB_OTG_HS_OTG_HS_GOTGINT_HNSSCHG_Pos = 0x9
	// Bit mask of HNSSCHG field.
	USB_OTG_HS_OTG_HS_GOTGINT_HNSSCHG_Msk = 0x200
	// Bit HNSSCHG.
	USB_OTG_HS_OTG_HS_GOTGINT_HNSSCHG = 0x200
	// Position of HNGDET field.
	USB_OTG_HS_OTG_HS_GOTGINT_HNGDET_Pos = 0x11
	// Bit mask of HNGDET field.
	USB_OTG_HS_OTG_HS_GOTGINT_HNGDET_Msk = 0x20000
	// Bit HNGDET.
	USB_OTG_HS_OTG_HS_GOTGINT_HNGDET = 0x20000
	// Position of ADTOCHG field.
	USB_OTG_HS_OTG_HS_GOTGINT_ADTOCHG_Pos = 0x12
	// Bit mask of ADTOCHG field.
	USB_OTG_HS_OTG_HS_GOTGINT_ADTOCHG_Msk = 0x40000
	// Bit ADTOCHG.
	USB_OTG_HS_OTG_HS_GOTGINT_ADTOCHG = 0x40000
	// Position of DBCDNE field.
	USB_OTG_HS_OTG_HS_GOTGINT_DBCDNE_Pos = 0x13
	// Bit mask of DBCDNE field.
	USB_OTG_HS_OTG_HS_GOTGINT_DBCDNE_Msk = 0x80000
	// Bit DBCDNE.
	USB_OTG_HS_OTG_HS_GOTGINT_DBCDNE = 0x80000
	// Position of IDCHNG field.
	USB_OTG_HS_OTG_HS_GOTGINT_IDCHNG_Pos = 0x14
	// Bit mask of IDCHNG field.
	USB_OTG_HS_OTG_HS_GOTGINT_IDCHNG_Msk = 0x100000
	// Bit IDCHNG.
	USB_OTG_HS_OTG_HS_GOTGINT_IDCHNG = 0x100000

	// OTG_HS_GAHBCFG: OTG_HS AHB configuration register
	// Position of GINT field.
	USB_OTG_HS_OTG_HS_GAHBCFG_GINT_Pos = 0x0
	// Bit mask of GINT field.
	USB_OTG_HS_OTG_HS_GAHBCFG_GINT_Msk = 0x1
	// Bit GINT.
	USB_OTG_HS_OTG_HS_GAHBCFG_GINT = 0x1
	// Position of HBSTLEN field.
	USB_OTG_HS_OTG_HS_GAHBCFG_HBSTLEN_Pos = 0x1
	// Bit mask of HBSTLEN field.
	USB_OTG_HS_OTG_HS_GAHBCFG_HBSTLEN_Msk = 0x1e
	// Position of DMAEN field.
	USB_OTG_HS_OTG_HS_GAHBCFG_DMAEN_Pos = 0x5
	// Bit mask of DMAEN field.
	USB_OTG_HS_OTG_HS_GAHBCFG_DMAEN_Msk = 0x20
	// Bit DMAEN.
	USB_OTG_HS_OTG_HS_GAHBCFG_DMAEN = 0x20
	// Position of TXFELVL field.
	USB_OTG_HS_OTG_HS_GAHBCFG_TXFELVL_Pos = 0x7
	// Bit mask of TXFELVL field.
	USB_OTG_HS_OTG_HS_GAHBCFG_TXFELVL_Msk = 0x80
	// Bit TXFELVL.
	USB_OTG_HS_OTG_HS_GAHBCFG_TXFELVL = 0x80
	// Position of PTXFELVL field.
	USB_OTG_HS_OTG_HS_GAHBCFG_PTXFELVL_Pos = 0x8
	// Bit mask of PTXFELVL field.
	USB_OTG_HS_OTG_HS_GAHBCFG_PTXFELVL_Msk = 0x100
	// Bit PTXFELVL.
	USB_OTG_HS_OTG_HS_GAHBCFG_PTXFELVL = 0x100

	// OTG_HS_GUSBCFG: OTG_HS USB configuration register
	// Position of TOCAL field.
	USB_OTG_HS_OTG_HS_GUSBCFG_TOCAL_Pos = 0x0
	// Bit mask of TOCAL field.
	USB_OTG_HS_OTG_HS_GUSBCFG_TOCAL_Msk = 0x7
	// Position of PHYSEL field.
	USB_OTG_HS_OTG_HS_GUSBCFG_PHYSEL_Pos = 0x6
	// Bit mask of PHYSEL field.
	USB_OTG_HS_OTG_HS_GUSBCFG_PHYSEL_Msk = 0x40
	// Bit PHYSEL.
	USB_OTG_HS_OTG_HS_GUSBCFG_PHYSEL = 0x40
	// Position of SRPCAP field.
	USB_OTG_HS_OTG_HS_GUSBCFG_SRPCAP_Pos = 0x8
	// Bit mask of SRPCAP field.
	USB_OTG_HS_OTG_HS_GUSBCFG_SRPCAP_Msk = 0x100
	// Bit SRPCAP.
	USB_OTG_HS_OTG_HS_GUSBCFG_SRPCAP = 0x100
	// Position of HNPCAP field.
	USB_OTG_HS_OTG_HS_GUSBCFG_HNPCAP_Pos = 0x9
	// Bit mask of HNPCAP field.
	USB_OTG_HS_OTG_HS_GUSBCFG_HNPCAP_Msk = 0x200
	// Bit HNPCAP.
	USB_OTG_HS_OTG_HS_GUSBCFG_HNPCAP = 0x200
	// Position of TRDT field.
	USB_OTG_HS_OTG_HS_GUSBCFG_TRDT_Pos = 0xa
	// Bit mask of TRDT field.
	USB_OTG_HS_OTG_HS_GUSBCFG_TRDT_Msk = 0x3c00
	// Position of PHYLPCS field.
	USB_OTG_HS_OTG_HS_GUSBCFG_PHYLPCS_Pos = 0xf
	// Bit mask of PHYLPCS field.
	USB_OTG_HS_OTG_HS_GUSBCFG_PHYLPCS_Msk = 0x8000
	// Bit PHYLPCS.
	USB_OTG_HS_OTG_HS_GUSBCFG_PHYLPCS = 0x8000
	// Position of ULPIFSLS field.
	USB_OTG_HS_OTG_HS_GUSBCFG_ULPIFSLS_Pos = 0x11
	// Bit mask of ULPIFSLS field.
	USB_OTG_HS_OTG_HS_GUSBCFG_ULPIFSLS_Msk = 0x20000
	// Bit ULPIFSLS.
	USB_OTG_HS_OTG_HS_GUSBCFG_ULPIFSLS = 0x20000
	// Position of ULPIAR field.
	USB_OTG_HS_OTG_HS_GUSBCFG_ULPIAR_Pos = 0x12
	// Bit mask of ULPIAR field.
	USB_OTG_HS_OTG_HS_GUSBCFG_ULPIAR_Msk = 0x40000
	// Bit ULPIAR.
	USB_OTG_HS_OTG_HS_GUSBCFG_ULPIAR = 0x40000
	// Position of ULPICSM field.
	USB_OTG_HS_OTG_HS_GUSBCFG_ULPICSM_Pos = 0x13
	// Bit mask of ULPICSM field.
	USB_OTG_HS_OTG_HS_GUSBCFG_ULPICSM_Msk = 0x80000
	// Bit ULPICSM.
	USB_OTG_HS_OTG_HS_GUSBCFG_ULPICSM = 0x80000
	// Position of ULPIEVBUSD field.
	USB_OTG_HS_OTG_HS_GUSBCFG_ULPIEVBUSD_Pos = 0x14
	// Bit mask of ULPIEVBUSD field.
	USB_OTG_HS_OTG_HS_GUSBCFG_ULPIEVBUSD_Msk = 0x100000
	// Bit ULPIEVBUSD.
	USB_OTG_HS_OTG_HS_GUSBCFG_ULPIEVBUSD = 0x100000
	// Position of ULPIEVBUSI field.
	USB_OTG_HS_OTG_HS_GUSBCFG_ULPIEVBUSI_Pos = 0x15
	// Bit mask of ULPIEVBUSI field.
	USB_OTG_HS_OTG_HS_GUSBCFG_ULPIEVBUSI_Msk = 0x200000
	// Bit ULPIEVBUSI.
	USB_OTG_HS_OTG_HS_GUSBCFG_ULPIEVBUSI = 0x200000
	// Position of TSDPS field.
	USB_OTG_HS_OTG_HS_GUSBCFG_TSDPS_Pos = 0x16
	// Bit mask of TSDPS field.
	USB_OTG_HS_OTG_HS_GUSBCFG_TSDPS_Msk = 0x400000
	// Bit TSDPS.
	USB_OTG_HS_OTG_HS_GUSBCFG_TSDPS = 0x400000
	// Position of PCCI field.
	USB_OTG_HS_OTG_HS_GUSBCFG_PCCI_Pos = 0x17
	// Bit mask of PCCI field.
	USB_OTG_HS_OTG_HS_GUSBCFG_PCCI_Msk = 0x800000
	// Bit PCCI.
	USB_OTG_HS_OTG_HS_GUSBCFG_PCCI = 0x800000
	// Position of PTCI field.
	USB_OTG_HS_OTG_HS_GUSBCFG_PTCI_Pos = 0x18
	// Bit mask of PTCI field.
	USB_OTG_HS_OTG_HS_GUSBCFG_PTCI_Msk = 0x1000000
	// Bit PTCI.
	USB_OTG_HS_OTG_HS_GUSBCFG_PTCI = 0x1000000
	// Position of ULPIIPD field.
	USB_OTG_HS_OTG_HS_GUSBCFG_ULPIIPD_Pos = 0x19
	// Bit mask of ULPIIPD field.
	USB_OTG_HS_OTG_HS_GUSBCFG_ULPIIPD_Msk = 0x2000000
	// Bit ULPIIPD.
	USB_OTG_HS_OTG_HS_GUSBCFG_ULPIIPD = 0x2000000
	// Position of FHMOD field.
	USB_OTG_HS_OTG_HS_GUSBCFG_FHMOD_Pos = 0x1d
	// Bit mask of FHMOD field.
	USB_OTG_HS_OTG_HS_GUSBCFG_FHMOD_Msk = 0x20000000
	// Bit FHMOD.
	USB_OTG_HS_OTG_HS_GUSBCFG_FHMOD = 0x20000000
	// Position of FDMOD field.
	USB_OTG_HS_OTG_HS_GUSBCFG_FDMOD_Pos = 0x1e
	// Bit mask of FDMOD field.
	USB_OTG_HS_OTG_HS_GUSBCFG_FDMOD_Msk = 0x40000000
	// Bit FDMOD.
	USB_OTG_HS_OTG_HS_GUSBCFG_FDMOD = 0x40000000

	// OTG_HS_GRSTCTL: OTG_HS reset register
	// Position of CSRST field.
	USB_OTG_HS_OTG_HS_GRSTCTL_CSRST_Pos = 0x0
	// Bit mask of CSRST field.
	USB_OTG_HS_OTG_HS_GRSTCTL_CSRST_Msk = 0x1
	// Bit CSRST.
	USB_OTG_HS_OTG_HS_GRSTCTL_CSRST = 0x1
	// Position of HSRST field.
	USB_OTG_HS_OTG_HS_GRSTCTL_HSRST_Pos = 0x1
	// Bit mask of HSRST field.
	USB_OTG_HS_OTG_HS_GRSTCTL_HSRST_Msk = 0x2
	// Bit HSRST.
	USB_OTG_HS_OTG_HS_GRSTCTL_HSRST = 0x2
	// Position of FCRST field.
	USB_OTG_HS_OTG_HS_GRSTCTL_FCRST_Pos = 0x2
	// Bit mask of FCRST field.
	USB_OTG_HS_OTG_HS_GRSTCTL_FCRST_Msk = 0x4
	// Bit FCRST.
	USB_OTG_HS_OTG_HS_GRSTCTL_FCRST = 0x4
	// Position of RXFFLSH field.
	USB_OTG_HS_OTG_HS_GRSTCTL_RXFFLSH_Pos = 0x4
	// Bit mask of RXFFLSH field.
	USB_OTG_HS_OTG_HS_GRSTCTL_RXFFLSH_Msk = 0x10
	// Bit RXFFLSH.
	USB_OTG_HS_OTG_HS_GRSTCTL_RXFFLSH = 0x10
	// Position of TXFFLSH field.
	USB_OTG_HS_OTG_HS_GRSTCTL_TXFFLSH_Pos = 0x5
	// Bit mask of TXFFLSH field.
	USB_OTG_HS_OTG_HS_GRSTCTL_TXFFLSH_Msk = 0x20
	// Bit TXFFLSH.
	USB_OTG_HS_OTG_HS_GRSTCTL_TXFFLSH = 0x20
	// Position of TXFNUM field.
	USB_OTG_HS_OTG_HS_GRSTCTL_TXFNUM_Pos = 0x6
	// Bit mask of TXFNUM field.
	USB_OTG_HS_OTG_HS_GRSTCTL_TXFNUM_Msk = 0x7c0
	// Position of AHBIDL field.
	USB_OTG_HS_OTG_HS_GRSTCTL_AHBIDL_Pos = 0x1f
	// Bit mask of AHBIDL field.
	USB_OTG_HS_OTG_HS_GRSTCTL_AHBIDL_Msk = 0x80000000
	// Bit AHBIDL.
	USB_OTG_HS_OTG_HS_GRSTCTL_AHBIDL = 0x80000000
	// Position of DMAREQ field.
	USB_OTG_HS_OTG_HS_GRSTCTL_DMAREQ_Pos = 0x1e
	// Bit mask of DMAREQ field.
	USB_OTG_HS_OTG_HS_GRSTCTL_DMAREQ_Msk = 0x40000000
	// Bit DMAREQ.
	USB_OTG_HS_OTG_HS_GRSTCTL_DMAREQ = 0x40000000

	// OTG_HS_GINTSTS: OTG_HS core interrupt register
	// Position of CMOD field.
	USB_OTG_HS_OTG_HS_GINTSTS_CMOD_Pos = 0x0
	// Bit mask of CMOD field.
	USB_OTG_HS_OTG_HS_GINTSTS_CMOD_Msk = 0x1
	// Bit CMOD.
	USB_OTG_HS_OTG_HS_GINTSTS_CMOD = 0x1
	// Position of MMIS field.
	USB_OTG_HS_OTG_HS_GINTSTS_MMIS_Pos = 0x1
	// Bit mask of MMIS field.
	USB_OTG_HS_OTG_HS_GINTSTS_MMIS_Msk = 0x2
	// Bit MMIS.
	USB_OTG_HS_OTG_HS_GINTSTS_MMIS = 0x2
	// Position of OTGINT field.
	USB_OTG_HS_OTG_HS_GINTSTS_OTGINT_Pos = 0x2
	// Bit mask of OTGINT field.
	USB_OTG_HS_OTG_HS_GINTSTS_OTGINT_Msk = 0x4
	// Bit OTGINT.
	USB_OTG_HS_OTG_HS_GINTSTS_OTGINT = 0x4
	// Position of SOF field.
	USB_OTG_HS_OTG_HS_GINTSTS_SOF_Pos = 0x3
	// Bit mask of SOF field.
	USB_OTG_HS_OTG_HS_GINTSTS_SOF_Msk = 0x8
	// Bit SOF.
	USB_OTG_HS_OTG_HS_GINTSTS_SOF = 0x8
	// Position of RXFLVL field.
	USB_OTG_HS_OTG_HS_GINTSTS_RXFLVL_Pos = 0x4
	// Bit mask of RXFLVL field.
	USB_OTG_HS_OTG_HS_GINTSTS_RXFLVL_Msk = 0x10
	// Bit RXFLVL.
	USB_OTG_HS_OTG_HS_GINTSTS_RXFLVL = 0x10
	// Position of NPTXFE field.
	USB_OTG_HS_OTG_HS_GINTSTS_NPTXFE_Pos = 0x5
	// Bit mask of NPTXFE field.
	USB_OTG_HS_OTG_HS_GINTSTS_NPTXFE_Msk = 0x20
	// Bit NPTXFE.
	USB_OTG_HS_OTG_HS_GINTSTS_NPTXFE = 0x20
	// Position of GINAKEFF field.
	USB_OTG_HS_OTG_HS_GINTSTS_GINAKEFF_Pos = 0x6
	// Bit mask of GINAKEFF field.
	USB_OTG_HS_OTG_HS_GINTSTS_GINAKEFF_Msk = 0x40
	// Bit GINAKEFF.
	USB_OTG_HS_OTG_HS_GINTSTS_GINAKEFF = 0x40
	// Position of BOUTNAKEFF field.
	USB_OTG_HS_OTG_HS_GINTSTS_BOUTNAKEFF_Pos = 0x7
	// Bit mask of BOUTNAKEFF field.
	USB_OTG_HS_OTG_HS_GINTSTS_BOUTNAKEFF_Msk = 0x80
	// Bit BOUTNAKEFF.
	USB_OTG_HS_OTG_HS_GINTSTS_BOUTNAKEFF = 0x80
	// Position of ESUSP field.
	USB_OTG_HS_OTG_HS_GINTSTS_ESUSP_Pos = 0xa
	// Bit mask of ESUSP field.
	USB_OTG_HS_OTG_HS_GINTSTS_ESUSP_Msk = 0x400
	// Bit ESUSP.
	USB_OTG_HS_OTG_HS_GINTSTS_ESUSP = 0x400
	// Position of USBSUSP field.
	USB_OTG_HS_OTG_HS_GINTSTS_USBSUSP_Pos = 0xb
	// Bit mask of USBSUSP field.
	USB_OTG_HS_OTG_HS_GINTSTS_USBSUSP_Msk = 0x800
	// Bit USBSUSP.
	USB_OTG_HS_OTG_HS_GINTSTS_USBSUSP = 0x800
	// Position of USBRST field.
	USB_OTG_HS_OTG_HS_GINTSTS_USBRST_Pos = 0xc
	// Bit mask of USBRST field.
	USB_OTG_HS_OTG_HS_GINTSTS_USBRST_Msk = 0x1000
	// Bit USBRST.
	USB_OTG_HS_OTG_HS_GINTSTS_USBRST = 0x1000
	// Position of ENUMDNE field.
	USB_OTG_HS_OTG_HS_GINTSTS_ENUMDNE_Pos = 0xd
	// Bit mask of ENUMDNE field.
	USB_OTG_HS_OTG_HS_GINTSTS_ENUMDNE_Msk = 0x2000
	// Bit ENUMDNE.
	USB_OTG_HS_OTG_HS_GINTSTS_ENUMDNE = 0x2000
	// Position of ISOODRP field.
	USB_OTG_HS_OTG_HS_GINTSTS_ISOODRP_Pos = 0xe
	// Bit mask of ISOODRP field.
	USB_OTG_HS_OTG_HS_GINTSTS_ISOODRP_Msk = 0x4000
	// Bit ISOODRP.
	USB_OTG_HS_OTG_HS_GINTSTS_ISOODRP = 0x4000
	// Position of EOPF field.
	USB_OTG_HS_OTG_HS_GINTSTS_EOPF_Pos = 0xf
	// Bit mask of EOPF field.
	USB_OTG_HS_OTG_HS_GINTSTS_EOPF_Msk = 0x8000
	// Bit EOPF.
	USB_OTG_HS_OTG_HS_GINTSTS_EOPF = 0x8000
	// Position of IEPINT field.
	USB_OTG_HS_OTG_HS_GINTSTS_IEPINT_Pos = 0x12
	// Bit mask of IEPINT field.
	USB_OTG_HS_OTG_HS_GINTSTS_IEPINT_Msk = 0x40000
	// Bit IEPINT.
	USB_OTG_HS_OTG_HS_GINTSTS_IEPINT = 0x40000
	// Position of OEPINT field.
	USB_OTG_HS_OTG_HS_GINTSTS_OEPINT_Pos = 0x13
	// Bit mask of OEPINT field.
	USB_OTG_HS_OTG_HS_GINTSTS_OEPINT_Msk = 0x80000
	// Bit OEPINT.
	USB_OTG_HS_OTG_HS_GINTSTS_OEPINT = 0x80000
	// Position of IISOIXFR field.
	USB_OTG_HS_OTG_HS_GINTSTS_IISOIXFR_Pos = 0x14
	// Bit mask of IISOIXFR field.
	USB_OTG_HS_OTG_HS_GINTSTS_IISOIXFR_Msk = 0x100000
	// Bit IISOIXFR.
	USB_OTG_HS_OTG_HS_GINTSTS_IISOIXFR = 0x100000
	// Position of PXFR_INCOMPISOOUT field.
	USB_OTG_HS_OTG_HS_GINTSTS_PXFR_INCOMPISOOUT_Pos = 0x15
	// Bit mask of PXFR_INCOMPISOOUT field.
	USB_OTG_HS_OTG_HS_GINTSTS_PXFR_INCOMPISOOUT_Msk = 0x200000
	// Bit PXFR_INCOMPISOOUT.
	USB_OTG_HS_OTG_HS_GINTSTS_PXFR_INCOMPISOOUT = 0x200000
	// Position of DATAFSUSP field.
	USB_OTG_HS_OTG_HS_GINTSTS_DATAFSUSP_Pos = 0x16
	// Bit mask of DATAFSUSP field.
	USB_OTG_HS_OTG_HS_GINTSTS_DATAFSUSP_Msk = 0x400000
	// Bit DATAFSUSP.
	USB_OTG_HS_OTG_HS_GINTSTS_DATAFSUSP = 0x400000
	// Position of HPRTINT field.
	USB_OTG_HS_OTG_HS_GINTSTS_HPRTINT_Pos = 0x18
	// Bit mask of HPRTINT field.
	USB_OTG_HS_OTG_HS_GINTSTS_HPRTINT_Msk = 0x1000000
	// Bit HPRTINT.
	USB_OTG_HS_OTG_HS_GINTSTS_HPRTINT = 0x1000000
	// Position of HCINT field.
	USB_OTG_HS_OTG_HS_GINTSTS_HCINT_Pos = 0x19
	// Bit mask of HCINT field.
	USB_OTG_HS_OTG_HS_GINTSTS_HCINT_Msk = 0x2000000
	// Bit HCINT.
	USB_OTG_HS_OTG_HS_GINTSTS_HCINT = 0x2000000
	// Position of PTXFE field.
	USB_OTG_HS_OTG_HS_GINTSTS_PTXFE_Pos = 0x1a
	// Bit mask of PTXFE field.
	USB_OTG_HS_OTG_HS_GINTSTS_PTXFE_Msk = 0x4000000
	// Bit PTXFE.
	USB_OTG_HS_OTG_HS_GINTSTS_PTXFE = 0x4000000
	// Position of CIDSCHG field.
	USB_OTG_HS_OTG_HS_GINTSTS_CIDSCHG_Pos = 0x1c
	// Bit mask of CIDSCHG field.
	USB_OTG_HS_OTG_HS_GINTSTS_CIDSCHG_Msk = 0x10000000
	// Bit CIDSCHG.
	USB_OTG_HS_OTG_HS_GINTSTS_CIDSCHG = 0x10000000
	// Position of DISCINT field.
	USB_OTG_HS_OTG_HS_GINTSTS_DISCINT_Pos = 0x1d
	// Bit mask of DISCINT field.
	USB_OTG_HS_OTG_HS_GINTSTS_DISCINT_Msk = 0x20000000
	// Bit DISCINT.
	USB_OTG_HS_OTG_HS_GINTSTS_DISCINT = 0x20000000
	// Position of SRQINT field.
	USB_OTG_HS_OTG_HS_GINTSTS_SRQINT_Pos = 0x1e
	// Bit mask of SRQINT field.
	USB_OTG_HS_OTG_HS_GINTSTS_SRQINT_Msk = 0x40000000
	// Bit SRQINT.
	USB_OTG_HS_OTG_HS_GINTSTS_SRQINT = 0x40000000
	// Position of WKUINT field.
	USB_OTG_HS_OTG_HS_GINTSTS_WKUINT_Pos = 0x1f
	// Bit mask of WKUINT field.
	USB_OTG_HS_OTG_HS_GINTSTS_WKUINT_Msk = 0x80000000
	// Bit WKUINT.
	USB_OTG_HS_OTG_HS_GINTSTS_WKUINT = 0x80000000

	// OTG_HS_GINTMSK: OTG_HS interrupt mask register
	// Position of MMISM field.
	USB_OTG_HS_OTG_HS_GINTMSK_MMISM_Pos = 0x1
	// Bit mask of MMISM field.
	USB_OTG_HS_OTG_HS_GINTMSK_MMISM_Msk = 0x2
	// Bit MMISM.
	USB_OTG_HS_OTG_HS_GINTMSK_MMISM = 0x2
	// Position of OTGINT field.
	USB_OTG_HS_OTG_HS_GINTMSK_OTGINT_Pos = 0x2
	// Bit mask of OTGINT field.
	USB_OTG_HS_OTG_HS_GINTMSK_OTGINT_Msk = 0x4
	// Bit OTGINT.
	USB_OTG_HS_OTG_HS_GINTMSK_OTGINT = 0x4
	// Position of SOFM field.
	USB_OTG_HS_OTG_HS_GINTMSK_SOFM_Pos = 0x3
	// Bit mask of SOFM field.
	USB_OTG_HS_OTG_HS_GINTMSK_SOFM_Msk = 0x8
	// Bit SOFM.
	USB_OTG_HS_OTG_HS_GINTMSK_SOFM = 0x8
	// Position of RXFLVLM field.
	USB_OTG_HS_OTG_HS_GINTMSK_RXFLVLM_Pos = 0x4
	// Bit mask of RXFLVLM field.
	USB_OTG_HS_OTG_HS_GINTMSK_RXFLVLM_Msk = 0x10
	// Bit RXFLVLM.
	USB_OTG_HS_OTG_HS_GINTMSK_RXFLVLM = 0x10
	// Position of NPTXFEM field.
	USB_OTG_HS_OTG_HS_GINTMSK_NPTXFEM_Pos = 0x5
	// Bit mask of NPTXFEM field.
	USB_OTG_HS_OTG_HS_GINTMSK_NPTXFEM_Msk = 0x20
	// Bit NPTXFEM.
	USB_OTG_HS_OTG_HS_GINTMSK_NPTXFEM = 0x20
	// Position of GINAKEFFM field.
	USB_OTG_HS_OTG_HS_GINTMSK_GINAKEFFM_Pos = 0x6
	// Bit mask of GINAKEFFM field.
	USB_OTG_HS_OTG_HS_GINTMSK_GINAKEFFM_Msk = 0x40
	// Bit GINAKEFFM.
	USB_OTG_HS_OTG_HS_GINTMSK_GINAKEFFM = 0x40
	// Position of GONAKEFFM field.
	USB_OTG_HS_OTG_HS_GINTMSK_GONAKEFFM_Pos = 0x7
	// Bit mask of GONAKEFFM field.
	USB_OTG_HS_OTG_HS_GINTMSK_GONAKEFFM_Msk = 0x80
	// Bit GONAKEFFM.
	USB_OTG_HS_OTG_HS_GINTMSK_GONAKEFFM = 0x80
	// Position of ESUSPM field.
	USB_OTG_HS_OTG_HS_GINTMSK_ESUSPM_Pos = 0xa
	// Bit mask of ESUSPM field.
	USB_OTG_HS_OTG_HS_GINTMSK_ESUSPM_Msk = 0x400
	// Bit ESUSPM.
	USB_OTG_HS_OTG_HS_GINTMSK_ESUSPM = 0x400
	// Position of USBSUSPM field.
	USB_OTG_HS_OTG_HS_GINTMSK_USBSUSPM_Pos = 0xb
	// Bit mask of USBSUSPM field.
	USB_OTG_HS_OTG_HS_GINTMSK_USBSUSPM_Msk = 0x800
	// Bit USBSUSPM.
	USB_OTG_HS_OTG_HS_GINTMSK_USBSUSPM = 0x800
	// Position of USBRST field.
	USB_OTG_HS_OTG_HS_GINTMSK_USBRST_Pos = 0xc
	// Bit mask of USBRST field.
	USB_OTG_HS_OTG_HS_GINTMSK_USBRST_Msk = 0x1000
	// Bit USBRST.
	USB_OTG_HS_OTG_HS_GINTMSK_USBRST = 0x1000
	// Position of ENUMDNEM field.
	USB_OTG_HS_OTG_HS_GINTMSK_ENUMDNEM_Pos = 0xd
	// Bit mask of ENUMDNEM field.
	USB_OTG_HS_OTG_HS_GINTMSK_ENUMDNEM_Msk = 0x2000
	// Bit ENUMDNEM.
	USB_OTG_HS_OTG_HS_GINTMSK_ENUMDNEM = 0x2000
	// Position of ISOODRPM field.
	USB_OTG_HS_OTG_HS_GINTMSK_ISOODRPM_Pos = 0xe
	// Bit mask of ISOODRPM field.
	USB_OTG_HS_OTG_HS_GINTMSK_ISOODRPM_Msk = 0x4000
	// Bit ISOODRPM.
	USB_OTG_HS_OTG_HS_GINTMSK_ISOODRPM = 0x4000
	// Position of EOPFM field.
	USB_OTG_HS_OTG_HS_GINTMSK_EOPFM_Pos = 0xf
	// Bit mask of EOPFM field.
	USB_OTG_HS_OTG_HS_GINTMSK_EOPFM_Msk = 0x8000
	// Bit EOPFM.
	USB_OTG_HS_OTG_HS_GINTMSK_EOPFM = 0x8000
	// Position of IEPINT field.
	USB_OTG_HS_OTG_HS_GINTMSK_IEPINT_Pos = 0x12
	// Bit mask of IEPINT field.
	USB_OTG_HS_OTG_HS_GINTMSK_IEPINT_Msk = 0x40000
	// Bit IEPINT.
	USB_OTG_HS_OTG_HS_GINTMSK_IEPINT = 0x40000
	// Position of OEPINT field.
	USB_OTG_HS_OTG_HS_GINTMSK_OEPINT_Pos = 0x13
	// Bit mask of OEPINT field.
	USB_OTG_HS_OTG_HS_GINTMSK_OEPINT_Msk = 0x80000
	// Bit OEPINT.
	USB_OTG_HS_OTG_HS_GINTMSK_OEPINT = 0x80000
	// Position of IISOIXFRM field.
	USB_OTG_HS_OTG_HS_GINTMSK_IISOIXFRM_Pos = 0x14
	// Bit mask of IISOIXFRM field.
	USB_OTG_HS_OTG_HS_GINTMSK_IISOIXFRM_Msk = 0x100000
	// Bit IISOIXFRM.
	USB_OTG_HS_OTG_HS_GINTMSK_IISOIXFRM = 0x100000
	// Position of PXFRM_IISOOXFRM field.
	USB_OTG_HS_OTG_HS_GINTMSK_PXFRM_IISOOXFRM_Pos = 0x15
	// Bit mask of PXFRM_IISOOXFRM field.
	USB_OTG_HS_OTG_HS_GINTMSK_PXFRM_IISOOXFRM_Msk = 0x200000
	// Bit PXFRM_IISOOXFRM.
	USB_OTG_HS_OTG_HS_GINTMSK_PXFRM_IISOOXFRM = 0x200000
	// Position of FSUSPM field.
	USB_OTG_HS_OTG_HS_GINTMSK_FSUSPM_Pos = 0x16
	// Bit mask of FSUSPM field.
	USB_OTG_HS_OTG_HS_GINTMSK_FSUSPM_Msk = 0x400000
	// Bit FSUSPM.
	USB_OTG_HS_OTG_HS_GINTMSK_FSUSPM = 0x400000
	// Position of PRTIM field.
	USB_OTG_HS_OTG_HS_GINTMSK_PRTIM_Pos = 0x18
	// Bit mask of PRTIM field.
	USB_OTG_HS_OTG_HS_GINTMSK_PRTIM_Msk = 0x1000000
	// Bit PRTIM.
	USB_OTG_HS_OTG_HS_GINTMSK_PRTIM = 0x1000000
	// Position of HCIM field.
	USB_OTG_HS_OTG_HS_GINTMSK_HCIM_Pos = 0x19
	// Bit mask of HCIM field.
	USB_OTG_HS_OTG_HS_GINTMSK_HCIM_Msk = 0x2000000
	// Bit HCIM.
	USB_OTG_HS_OTG_HS_GINTMSK_HCIM = 0x2000000
	// Position of PTXFEM field.
	USB_OTG_HS_OTG_HS_GINTMSK_PTXFEM_Pos = 0x1a
	// Bit mask of PTXFEM field.
	USB_OTG_HS_OTG_HS_GINTMSK_PTXFEM_Msk = 0x4000000
	// Bit PTXFEM.
	USB_OTG_HS_OTG_HS_GINTMSK_PTXFEM = 0x4000000
	// Position of CIDSCHGM field.
	USB_OTG_HS_OTG_HS_GINTMSK_CIDSCHGM_Pos = 0x1c
	// Bit mask of CIDSCHGM field.
	USB_OTG_HS_OTG_HS_GINTMSK_CIDSCHGM_Msk = 0x10000000
	// Bit CIDSCHGM.
	USB_OTG_HS_OTG_HS_GINTMSK_CIDSCHGM = 0x10000000
	// Position of DISCINT field.
	USB_OTG_HS_OTG_HS_GINTMSK_DISCINT_Pos = 0x1d
	// Bit mask of DISCINT field.
	USB_OTG_HS_OTG_HS_GINTMSK_DISCINT_Msk = 0x20000000
	// Bit DISCINT.
	USB_OTG_HS_OTG_HS_GINTMSK_DISCINT = 0x20000000
	// Position of SRQIM field.
	USB_OTG_HS_OTG_HS_GINTMSK_SRQIM_Pos = 0x1e
	// Bit mask of SRQIM field.
	USB_OTG_HS_OTG_HS_GINTMSK_SRQIM_Msk = 0x40000000
	// Bit SRQIM.
	USB_OTG_HS_OTG_HS_GINTMSK_SRQIM = 0x40000000
	// Position of WUIM field.
	USB_OTG_HS_OTG_HS_GINTMSK_WUIM_Pos = 0x1f
	// Bit mask of WUIM field.
	USB_OTG_HS_OTG_HS_GINTMSK_WUIM_Msk = 0x80000000
	// Bit WUIM.
	USB_OTG_HS_OTG_HS_GINTMSK_WUIM = 0x80000000
	// Position of RSTDE field.
	USB_OTG_HS_OTG_HS_GINTMSK_RSTDE_Pos = 0x17
	// Bit mask of RSTDE field.
	USB_OTG_HS_OTG_HS_GINTMSK_RSTDE_Msk = 0x800000
	// Bit RSTDE.
	USB_OTG_HS_OTG_HS_GINTMSK_RSTDE = 0x800000
	// Position of LPMINTM field.
	USB_OTG_HS_OTG_HS_GINTMSK_LPMINTM_Pos = 0x1b
	// Bit mask of LPMINTM field.
	USB_OTG_HS_OTG_HS_GINTMSK_LPMINTM_Msk = 0x8000000
	// Bit LPMINTM.
	USB_OTG_HS_OTG_HS_GINTMSK_LPMINTM = 0x8000000

	// OTG_HS_GRXSTSR_Host: OTG_HS Receive status debug read register (host mode)
	// Position of CHNUM field.
	USB_OTG_HS_OTG_HS_GRXSTSR_Host_CHNUM_Pos = 0x0
	// Bit mask of CHNUM field.
	USB_OTG_HS_OTG_HS_GRXSTSR_Host_CHNUM_Msk = 0xf
	// Position of BCNT field.
	USB_OTG_HS_OTG_HS_GRXSTSR_Host_BCNT_Pos = 0x4
	// Bit mask of BCNT field.
	USB_OTG_HS_OTG_HS_GRXSTSR_Host_BCNT_Msk = 0x7ff0
	// Position of DPID field.
	USB_OTG_HS_OTG_HS_GRXSTSR_Host_DPID_Pos = 0xf
	// Bit mask of DPID field.
	USB_OTG_HS_OTG_HS_GRXSTSR_Host_DPID_Msk = 0x18000
	// Position of PKTSTS field.
	USB_OTG_HS_OTG_HS_GRXSTSR_Host_PKTSTS_Pos = 0x11
	// Bit mask of PKTSTS field.
	USB_OTG_HS_OTG_HS_GRXSTSR_Host_PKTSTS_Msk = 0x1e0000

	// OTG_HS_GRXSTSR_Device: OTG_HS Receive status debug read register (peripheral mode mode)
	// Position of EPNUM field.
	USB_OTG_HS_OTG_HS_GRXSTSR_Device_EPNUM_Pos = 0x0
	// Bit mask of EPNUM field.
	USB_OTG_HS_OTG_HS_GRXSTSR_Device_EPNUM_Msk = 0xf
	// Position of BCNT field.
	USB_OTG_HS_OTG_HS_GRXSTSR_Device_BCNT_Pos = 0x4
	// Bit mask of BCNT field.
	USB_OTG_HS_OTG_HS_GRXSTSR_Device_BCNT_Msk = 0x7ff0
	// Position of DPID field.
	USB_OTG_HS_OTG_HS_GRXSTSR_Device_DPID_Pos = 0xf
	// Bit mask of DPID field.
	USB_OTG_HS_OTG_HS_GRXSTSR_Device_DPID_Msk = 0x18000
	// Position of PKTSTS field.
	USB_OTG_HS_OTG_HS_GRXSTSR_Device_PKTSTS_Pos = 0x11
	// Bit mask of PKTSTS field.
	USB_OTG_HS_OTG_HS_GRXSTSR_Device_PKTSTS_Msk = 0x1e0000
	// Position of FRMNUM field.
	USB_OTG_HS_OTG_HS_GRXSTSR_Device_FRMNUM_Pos = 0x15
	// Bit mask of FRMNUM field.
	USB_OTG_HS_OTG_HS_GRXSTSR_Device_FRMNUM_Msk = 0x1e00000

	// OTG_HS_GRXSTSP_Host: OTG_HS status read and pop register (host mode)
	// Position of CHNUM field.
	USB_OTG_HS_OTG_HS_GRXSTSP_Host_CHNUM_Pos = 0x0
	// Bit mask of CHNUM field.
	USB_OTG_HS_OTG_HS_GRXSTSP_Host_CHNUM_Msk = 0xf
	// Position of BCNT field.
	USB_OTG_HS_OTG_HS_GRXSTSP_Host_BCNT_Pos = 0x4
	// Bit mask of BCNT field.
	USB_OTG_HS_OTG_HS_GRXSTSP_Host_BCNT_Msk = 0x7ff0
	// Position of DPID field.
	USB_OTG_HS_OTG_HS_GRXSTSP_Host_DPID_Pos = 0xf
	// Bit mask of DPID field.
	USB_OTG_HS_OTG_HS_GRXSTSP_Host_DPID_Msk = 0x18000
	// Position of PKTSTS field.
	USB_OTG_HS_OTG_HS_GRXSTSP_Host_PKTSTS_Pos = 0x11
	// Bit mask of PKTSTS field.
	USB_OTG_HS_OTG_HS_GRXSTSP_Host_PKTSTS_Msk = 0x1e0000

	// OTG_HS_GRXSTSP_Device: OTG_HS status read and pop register (peripheral mode)
	// Position of EPNUM field.
	USB_OTG_HS_OTG_HS_GRXSTSP_Device_EPNUM_Pos = 0x0
	// Bit mask of EPNUM field.
	USB_OTG_HS_OTG_HS_GRXSTSP_Device_EPNUM_Msk = 0xf
	// Position of BCNT field.
	USB_OTG_HS_OTG_HS_GRXSTSP_Device_BCNT_Pos = 0x4
	// Bit mask of BCNT field.
	USB_OTG_HS_OTG_HS_GRXSTSP_Device_BCNT_Msk = 0x7ff0
	// Position of DPID field.
	USB_OTG_HS_OTG_HS_GRXSTSP_Device_DPID_Pos = 0xf
	// Bit mask of DPID field.
	USB_OTG_HS_OTG_HS_GRXSTSP_Device_DPID_Msk = 0x18000
	// Position of PKTSTS field.
	USB_OTG_HS_OTG_HS_GRXSTSP_Device_PKTSTS_Pos = 0x11
	// Bit mask of PKTSTS field.
	USB_OTG_HS_OTG_HS_GRXSTSP_Device_PKTSTS_Msk = 0x1e0000
	// Position of FRMNUM field.
	USB_OTG_HS_OTG_HS_GRXSTSP_Device_FRMNUM_Pos = 0x15
	// Bit mask of FRMNUM field.
	USB_OTG_HS_OTG_HS_GRXSTSP_Device_FRMNUM_Msk = 0x1e00000

	// OTG_HS_GRXFSIZ: OTG_HS Receive FIFO size register
	// Position of RXFD field.
	USB_OTG_HS_OTG_HS_GRXFSIZ_RXFD_Pos = 0x0
	// Bit mask of RXFD field.
	USB_OTG_HS_OTG_HS_GRXFSIZ_RXFD_Msk = 0xffff

	// OTG_HS_HNPTXFSIZ_Host: OTG_HS nonperiodic transmit FIFO size register (host mode)
	// Position of NPTXFSA field.
	USB_OTG_HS_OTG_HS_HNPTXFSIZ_Host_NPTXFSA_Pos = 0x0
	// Bit mask of NPTXFSA field.
	USB_OTG_HS_OTG_HS_HNPTXFSIZ_Host_NPTXFSA_Msk = 0xffff
	// Position of NPTXFD field.
	USB_OTG_HS_OTG_HS_HNPTXFSIZ_Host_NPTXFD_Pos = 0x10
	// Bit mask of NPTXFD field.
	USB_OTG_HS_OTG_HS_HNPTXFSIZ_Host_NPTXFD_Msk = 0xffff0000

	// OTG_HS_DIEPTXF0_Device: Endpoint 0 transmit FIFO size (peripheral mode)
	// Position of TX0FSA field.
	USB_OTG_HS_OTG_HS_DIEPTXF0_Device_TX0FSA_Pos = 0x0
	// Bit mask of TX0FSA field.
	USB_OTG_HS_OTG_HS_DIEPTXF0_Device_TX0FSA_Msk = 0xffff
	// Position of TX0FD field.
	USB_OTG_HS_OTG_HS_DIEPTXF0_Device_TX0FD_Pos = 0x10
	// Bit mask of TX0FD field.
	USB_OTG_HS_OTG_HS_DIEPTXF0_Device_TX0FD_Msk = 0xffff0000

	// OTG_HS_GNPTXSTS: OTG_HS nonperiodic transmit FIFO/queue status register
	// Position of NPTXFSAV field.
	USB_OTG_HS_OTG_HS_GNPTXSTS_NPTXFSAV_Pos = 0x0
	// Bit mask of NPTXFSAV field.
	USB_OTG_HS_OTG_HS_GNPTXSTS_NPTXFSAV_Msk = 0xffff
	// Position of NPTQXSAV field.
	USB_OTG_HS_OTG_HS_GNPTXSTS_NPTQXSAV_Pos = 0x10
	// Bit mask of NPTQXSAV field.
	USB_OTG_HS_OTG_HS_GNPTXSTS_NPTQXSAV_Msk = 0xff0000
	// Position of NPTXQTOP field.
	USB_OTG_HS_OTG_HS_GNPTXSTS_NPTXQTOP_Pos = 0x18
	// Bit mask of NPTXQTOP field.
	USB_OTG_HS_OTG_HS_GNPTXSTS_NPTXQTOP_Msk = 0x7f000000

	// OTG_HS_GCCFG: OTG_HS general core configuration register
	// Position of PWRDWN field.
	USB_OTG_HS_OTG_HS_GCCFG_PWRDWN_Pos = 0x10
	// Bit mask of PWRDWN field.
	USB_OTG_HS_OTG_HS_GCCFG_PWRDWN_Msk = 0x10000
	// Bit PWRDWN.
	USB_OTG_HS_OTG_HS_GCCFG_PWRDWN = 0x10000
	// Position of BCDEN field.
	USB_OTG_HS_OTG_HS_GCCFG_BCDEN_Pos = 0x11
	// Bit mask of BCDEN field.
	USB_OTG_HS_OTG_HS_GCCFG_BCDEN_Msk = 0x20000
	// Bit BCDEN.
	USB_OTG_HS_OTG_HS_GCCFG_BCDEN = 0x20000
	// Position of DCDEN field.
	USB_OTG_HS_OTG_HS_GCCFG_DCDEN_Pos = 0x12
	// Bit mask of DCDEN field.
	USB_OTG_HS_OTG_HS_GCCFG_DCDEN_Msk = 0x40000
	// Bit DCDEN.
	USB_OTG_HS_OTG_HS_GCCFG_DCDEN = 0x40000
	// Position of PDEN field.
	USB_OTG_HS_OTG_HS_GCCFG_PDEN_Pos = 0x13
	// Bit mask of PDEN field.
	USB_OTG_HS_OTG_HS_GCCFG_PDEN_Msk = 0x80000
	// Bit PDEN.
	USB_OTG_HS_OTG_HS_GCCFG_PDEN = 0x80000
	// Position of SDEN field.
	USB_OTG_HS_OTG_HS_GCCFG_SDEN_Pos = 0x14
	// Bit mask of SDEN field.
	USB_OTG_HS_OTG_HS_GCCFG_SDEN_Msk = 0x100000
	// Bit SDEN.
	USB_OTG_HS_OTG_HS_GCCFG_SDEN = 0x100000
	// Position of VBDEN field.
	USB_OTG_HS_OTG_HS_GCCFG_VBDEN_Pos = 0x15
	// Bit mask of VBDEN field.
	USB_OTG_HS_OTG_HS_GCCFG_VBDEN_Msk = 0x200000
	// Bit VBDEN.
	USB_OTG_HS_OTG_HS_GCCFG_VBDEN = 0x200000
	// Position of DCDET field.
	USB_OTG_HS_OTG_HS_GCCFG_DCDET_Pos = 0x0
	// Bit mask of DCDET field.
	USB_OTG_HS_OTG_HS_GCCFG_DCDET_Msk = 0x1
	// Bit DCDET.
	USB_OTG_HS_OTG_HS_GCCFG_DCDET = 0x1
	// Position of PDET field.
	USB_OTG_HS_OTG_HS_GCCFG_PDET_Pos = 0x1
	// Bit mask of PDET field.
	USB_OTG_HS_OTG_HS_GCCFG_PDET_Msk = 0x2
	// Bit PDET.
	USB_OTG_HS_OTG_HS_GCCFG_PDET = 0x2
	// Position of SDET field.
	USB_OTG_HS_OTG_HS_GCCFG_SDET_Pos = 0x2
	// Bit mask of SDET field.
	USB_OTG_HS_OTG_HS_GCCFG_SDET_Msk = 0x4
	// Bit SDET.
	USB_OTG_HS_OTG_HS_GCCFG_SDET = 0x4
	// Position of PS2DET field.
	USB_OTG_HS_OTG_HS_GCCFG_PS2DET_Pos = 0x3
	// Bit mask of PS2DET field.
	USB_OTG_HS_OTG_HS_GCCFG_PS2DET_Msk = 0x8
	// Bit PS2DET.
	USB_OTG_HS_OTG_HS_GCCFG_PS2DET = 0x8

	// OTG_HS_CID: OTG_HS core ID register
	// Position of PRODUCT_ID field.
	USB_OTG_HS_OTG_HS_CID_PRODUCT_ID_Pos = 0x0
	// Bit mask of PRODUCT_ID field.
	USB_OTG_HS_OTG_HS_CID_PRODUCT_ID_Msk = 0xffffffff

	// OTG_HS_GLPMCFG: OTG core LPM configuration register
	// Position of LPMEN field.
	USB_OTG_HS_OTG_HS_GLPMCFG_LPMEN_Pos = 0x0
	// Bit mask of LPMEN field.
	USB_OTG_HS_OTG_HS_GLPMCFG_LPMEN_Msk = 0x1
	// Bit LPMEN.
	USB_OTG_HS_OTG_HS_GLPMCFG_LPMEN = 0x1
	// Position of LPMACK field.
	USB_OTG_HS_OTG_HS_GLPMCFG_LPMACK_Pos = 0x1
	// Bit mask of LPMACK field.
	USB_OTG_HS_OTG_HS_GLPMCFG_LPMACK_Msk = 0x2
	// Bit LPMACK.
	USB_OTG_HS_OTG_HS_GLPMCFG_LPMACK = 0x2
	// Position of BESL field.
	USB_OTG_HS_OTG_HS_GLPMCFG_BESL_Pos = 0x2
	// Bit mask of BESL field.
	USB_OTG_HS_OTG_HS_GLPMCFG_BESL_Msk = 0x3c
	// Position of REMWAKE field.
	USB_OTG_HS_OTG_HS_GLPMCFG_REMWAKE_Pos = 0x6
	// Bit mask of REMWAKE field.
	USB_OTG_HS_OTG_HS_GLPMCFG_REMWAKE_Msk = 0x40
	// Bit REMWAKE.
	USB_OTG_HS_OTG_HS_GLPMCFG_REMWAKE = 0x40
	// Position of L1SSEN field.
	USB_OTG_HS_OTG_HS_GLPMCFG_L1SSEN_Pos = 0x7
	// Bit mask of L1SSEN field.
	USB_OTG_HS_OTG_HS_GLPMCFG_L1SSEN_Msk = 0x80
	// Bit L1SSEN.
	USB_OTG_HS_OTG_HS_GLPMCFG_L1SSEN = 0x80
	// Position of BESLTHRS field.
	USB_OTG_HS_OTG_HS_GLPMCFG_BESLTHRS_Pos = 0x8
	// Bit mask of BESLTHRS field.
	USB_OTG_HS_OTG_HS_GLPMCFG_BESLTHRS_Msk = 0xf00
	// Position of L1DSEN field.
	USB_OTG_HS_OTG_HS_GLPMCFG_L1DSEN_Pos = 0xc
	// Bit mask of L1DSEN field.
	USB_OTG_HS_OTG_HS_GLPMCFG_L1DSEN_Msk = 0x1000
	// Bit L1DSEN.
	USB_OTG_HS_OTG_HS_GLPMCFG_L1DSEN = 0x1000
	// Position of LPMRST field.
	USB_OTG_HS_OTG_HS_GLPMCFG_LPMRST_Pos = 0xd
	// Bit mask of LPMRST field.
	USB_OTG_HS_OTG_HS_GLPMCFG_LPMRST_Msk = 0x6000
	// Position of SLPSTS field.
	USB_OTG_HS_OTG_HS_GLPMCFG_SLPSTS_Pos = 0xf
	// Bit mask of SLPSTS field.
	USB_OTG_HS_OTG_HS_GLPMCFG_SLPSTS_Msk = 0x8000
	// Bit SLPSTS.
	USB_OTG_HS_OTG_HS_GLPMCFG_SLPSTS = 0x8000
	// Position of L1RSMOK field.
	USB_OTG_HS_OTG_HS_GLPMCFG_L1RSMOK_Pos = 0x10
	// Bit mask of L1RSMOK field.
	USB_OTG_HS_OTG_HS_GLPMCFG_L1RSMOK_Msk = 0x10000
	// Bit L1RSMOK.
	USB_OTG_HS_OTG_HS_GLPMCFG_L1RSMOK = 0x10000
	// Position of LPMCHIDX field.
	USB_OTG_HS_OTG_HS_GLPMCFG_LPMCHIDX_Pos = 0x11
	// Bit mask of LPMCHIDX field.
	USB_OTG_HS_OTG_HS_GLPMCFG_LPMCHIDX_Msk = 0x1e0000
	// Position of LPMRCNT field.
	USB_OTG_HS_OTG_HS_GLPMCFG_LPMRCNT_Pos = 0x15
	// Bit mask of LPMRCNT field.
	USB_OTG_HS_OTG_HS_GLPMCFG_LPMRCNT_Msk = 0xe00000
	// Position of SNDLPM field.
	USB_OTG_HS_OTG_HS_GLPMCFG_SNDLPM_Pos = 0x18
	// Bit mask of SNDLPM field.
	USB_OTG_HS_OTG_HS_GLPMCFG_SNDLPM_Msk = 0x1000000
	// Bit SNDLPM.
	USB_OTG_HS_OTG_HS_GLPMCFG_SNDLPM = 0x1000000
	// Position of LPMRCNTSTS field.
	USB_OTG_HS_OTG_HS_GLPMCFG_LPMRCNTSTS_Pos = 0x19
	// Bit mask of LPMRCNTSTS field.
	USB_OTG_HS_OTG_HS_GLPMCFG_LPMRCNTSTS_Msk = 0xe000000
	// Position of ENBESL field.
	USB_OTG_HS_OTG_HS_GLPMCFG_ENBESL_Pos = 0x1c
	// Bit mask of ENBESL field.
	USB_OTG_HS_OTG_HS_GLPMCFG_ENBESL_Msk = 0x10000000
	// Bit ENBESL.
	USB_OTG_HS_OTG_HS_GLPMCFG_ENBESL = 0x10000000

	// OTG_HS_HPTXFSIZ: OTG_HS Host periodic transmit FIFO size register
	// Position of PTXSA field.
	USB_OTG_HS_OTG_HS_HPTXFSIZ_PTXSA_Pos = 0x0
	// Bit mask of PTXSA field.
	USB_OTG_HS_OTG_HS_HPTXFSIZ_PTXSA_Msk = 0xffff
	// Position of PTXFD field.
	USB_OTG_HS_OTG_HS_HPTXFSIZ_PTXFD_Pos = 0x10
	// Bit mask of PTXFD field.
	USB_OTG_HS_OTG_HS_HPTXFSIZ_PTXFD_Msk = 0xffff0000

	// OTG_HS_DIEPTXF1: OTG_HS device IN endpoint transmit FIFO size register
	// Position of INEPTXSA field.
	USB_OTG_HS_OTG_HS_DIEPTXF1_INEPTXSA_Pos = 0x0
	// Bit mask of INEPTXSA field.
	USB_OTG_HS_OTG_HS_DIEPTXF1_INEPTXSA_Msk = 0xffff
	// Position of INEPTXFD field.
	USB_OTG_HS_OTG_HS_DIEPTXF1_INEPTXFD_Pos = 0x10
	// Bit mask of INEPTXFD field.
	USB_OTG_HS_OTG_HS_DIEPTXF1_INEPTXFD_Msk = 0xffff0000

	// OTG_HS_DIEPTXF2: OTG_HS device IN endpoint transmit FIFO size register
	// Position of INEPTXSA field.
	USB_OTG_HS_OTG_HS_DIEPTXF2_INEPTXSA_Pos = 0x0
	// Bit mask of INEPTXSA field.
	USB_OTG_HS_OTG_HS_DIEPTXF2_INEPTXSA_Msk = 0xffff
	// Position of INEPTXFD field.
	USB_OTG_HS_OTG_HS_DIEPTXF2_INEPTXFD_Pos = 0x10
	// Bit mask of INEPTXFD field.
	USB_OTG_HS_OTG_HS_DIEPTXF2_INEPTXFD_Msk = 0xffff0000

	// OTG_HS_DIEPTXF3: OTG_HS device IN endpoint transmit FIFO size register
	// Position of INEPTXSA field.
	USB_OTG_HS_OTG_HS_DIEPTXF3_INEPTXSA_Pos = 0x0
	// Bit mask of INEPTXSA field.
	USB_OTG_HS_OTG_HS_DIEPTXF3_INEPTXSA_Msk = 0xffff
	// Position of INEPTXFD field.
	USB_OTG_HS_OTG_HS_DIEPTXF3_INEPTXFD_Pos = 0x10
	// Bit mask of INEPTXFD field.
	USB_OTG_HS_OTG_HS_DIEPTXF3_INEPTXFD_Msk = 0xffff0000

	// OTG_HS_DIEPTXF4: OTG_HS device IN endpoint transmit FIFO size register
	// Position of INEPTXSA field.
	USB_OTG_HS_OTG_HS_DIEPTXF4_INEPTXSA_Pos = 0x0
	// Bit mask of INEPTXSA field.
	USB_OTG_HS_OTG_HS_DIEPTXF4_INEPTXSA_Msk = 0xffff
	// Position of INEPTXFD field.
	USB_OTG_HS_OTG_HS_DIEPTXF4_INEPTXFD_Pos = 0x10
	// Bit mask of INEPTXFD field.
	USB_OTG_HS_OTG_HS_DIEPTXF4_INEPTXFD_Msk = 0xffff0000

	// OTG_HS_DIEPTXF5: OTG_HS device IN endpoint transmit FIFO size register
	// Position of INEPTXSA field.
	USB_OTG_HS_OTG_HS_DIEPTXF5_INEPTXSA_Pos = 0x0
	// Bit mask of INEPTXSA field.
	USB_OTG_HS_OTG_HS_DIEPTXF5_INEPTXSA_Msk = 0xffff
	// Position of INEPTXFD field.
	USB_OTG_HS_OTG_HS_DIEPTXF5_INEPTXFD_Pos = 0x10
	// Bit mask of INEPTXFD field.
	USB_OTG_HS_OTG_HS_DIEPTXF5_INEPTXFD_Msk = 0xffff0000

	// OTG_HS_DIEPTXF6: OTG_HS device IN endpoint transmit FIFO size register
	// Position of INEPTXSA field.
	USB_OTG_HS_OTG_HS_DIEPTXF6_INEPTXSA_Pos = 0x0
	// Bit mask of INEPTXSA field.
	USB_OTG_HS_OTG_HS_DIEPTXF6_INEPTXSA_Msk = 0xffff
	// Position of INEPTXFD field.
	USB_OTG_HS_OTG_HS_DIEPTXF6_INEPTXFD_Pos = 0x10
	// Bit mask of INEPTXFD field.
	USB_OTG_HS_OTG_HS_DIEPTXF6_INEPTXFD_Msk = 0xffff0000

	// OTG_HS_DIEPTXF7: OTG_HS device IN endpoint transmit FIFO size register
	// Position of INEPTXSA field.
	USB_OTG_HS_OTG_HS_DIEPTXF7_INEPTXSA_Pos = 0x0
	// Bit mask of INEPTXSA field.
	USB_OTG_HS_OTG_HS_DIEPTXF7_INEPTXSA_Msk = 0xffff
	// Position of INEPTXFD field.
	USB_OTG_HS_OTG_HS_DIEPTXF7_INEPTXFD_Pos = 0x10
	// Bit mask of INEPTXFD field.
	USB_OTG_HS_OTG_HS_DIEPTXF7_INEPTXFD_Msk = 0xffff0000
)

// Constants for MDIOS: Management data input/output slave
const (
	// CR: MDIOS configuration register
	// Position of EN field.
	MDIOS_CR_EN_Pos = 0x0
	// Bit mask of EN field.
	MDIOS_CR_EN_Msk = 0x1
	// Bit EN.
	MDIOS_CR_EN = 0x1
	// Position of WRIE field.
	MDIOS_CR_WRIE_Pos = 0x1
	// Bit mask of WRIE field.
	MDIOS_CR_WRIE_Msk = 0x2
	// Bit WRIE.
	MDIOS_CR_WRIE = 0x2
	// Position of RDIE field.
	MDIOS_CR_RDIE_Pos = 0x2
	// Bit mask of RDIE field.
	MDIOS_CR_RDIE_Msk = 0x4
	// Bit RDIE.
	MDIOS_CR_RDIE = 0x4
	// Position of EIE field.
	MDIOS_CR_EIE_Pos = 0x3
	// Bit mask of EIE field.
	MDIOS_CR_EIE_Msk = 0x8
	// Bit EIE.
	MDIOS_CR_EIE = 0x8
	// Position of DPC field.
	MDIOS_CR_DPC_Pos = 0x7
	// Bit mask of DPC field.
	MDIOS_CR_DPC_Msk = 0x80
	// Bit DPC.
	MDIOS_CR_DPC = 0x80
	// Position of PORT_ADDRESS field.
	MDIOS_CR_PORT_ADDRESS_Pos = 0x8
	// Bit mask of PORT_ADDRESS field.
	MDIOS_CR_PORT_ADDRESS_Msk = 0x1f00

	// WRFR: MDIOS write flag register
	// Position of WRF field.
	MDIOS_WRFR_WRF_Pos = 0x0
	// Bit mask of WRF field.
	MDIOS_WRFR_WRF_Msk = 0xffffffff

	// CWRFR: MDIOS clear write flag register
	// Position of CWRF field.
	MDIOS_CWRFR_CWRF_Pos = 0x0
	// Bit mask of CWRF field.
	MDIOS_CWRFR_CWRF_Msk = 0xffffffff

	// RDFR: MDIOS read flag register
	// Position of RDF field.
	MDIOS_RDFR_RDF_Pos = 0x0
	// Bit mask of RDF field.
	MDIOS_RDFR_RDF_Msk = 0xffffffff

	// CRDFR: MDIOS clear read flag register
	// Position of CRDF field.
	MDIOS_CRDFR_CRDF_Pos = 0x0
	// Bit mask of CRDF field.
	MDIOS_CRDFR_CRDF_Msk = 0xffffffff

	// SR: MDIOS status register
	// Position of PERF field.
	MDIOS_SR_PERF_Pos = 0x0
	// Bit mask of PERF field.
	MDIOS_SR_PERF_Msk = 0x1
	// Bit PERF.
	MDIOS_SR_PERF = 0x1
	// Position of SERF field.
	MDIOS_SR_SERF_Pos = 0x1
	// Bit mask of SERF field.
	MDIOS_SR_SERF_Msk = 0x2
	// Bit SERF.
	MDIOS_SR_SERF = 0x2
	// Position of TERF field.
	MDIOS_SR_TERF_Pos = 0x2
	// Bit mask of TERF field.
	MDIOS_SR_TERF_Msk = 0x4
	// Bit TERF.
	MDIOS_SR_TERF = 0x4

	// CLRFR: MDIOS clear flag register
	// Position of CPERF field.
	MDIOS_CLRFR_CPERF_Pos = 0x0
	// Bit mask of CPERF field.
	MDIOS_CLRFR_CPERF_Msk = 0x1
	// Bit CPERF.
	MDIOS_CLRFR_CPERF = 0x1
	// Position of CSERF field.
	MDIOS_CLRFR_CSERF_Pos = 0x1
	// Bit mask of CSERF field.
	MDIOS_CLRFR_CSERF_Msk = 0x2
	// Bit CSERF.
	MDIOS_CLRFR_CSERF = 0x2
	// Position of CTERF field.
	MDIOS_CLRFR_CTERF_Pos = 0x2
	// Bit mask of CTERF field.
	MDIOS_CLRFR_CTERF_Msk = 0x4
	// Bit CTERF.
	MDIOS_CLRFR_CTERF = 0x4

	// DINR0: MDIOS input data register %s
	// Position of DIN field.
	MDIOS_DINR_DIN_Pos = 0x0
	// Bit mask of DIN field.
	MDIOS_DINR_DIN_Msk = 0xffff

	// DOUTR0: MDIOS output data register %s
	// Position of DOUT field.
	MDIOS_DOUTR_DOUT_Pos = 0x0
	// Bit mask of DOUT field.
	MDIOS_DOUTR_DOUT_Msk = 0xffff
)

// Constants for DFSDM: Digital filter for sigma delta modulators
const (
	// CHCFG0R1: DFSDM channel configuration 0 register 1
	// Position of SITP field.
	DFSDM_CHCFG0R1_SITP_Pos = 0x0
	// Bit mask of SITP field.
	DFSDM_CHCFG0R1_SITP_Msk = 0x3
	// Position of SPICKSEL field.
	DFSDM_CHCFG0R1_SPICKSEL_Pos = 0x2
	// Bit mask of SPICKSEL field.
	DFSDM_CHCFG0R1_SPICKSEL_Msk = 0xc
	// Position of SCDEN field.
	DFSDM_CHCFG0R1_SCDEN_Pos = 0x5
	// Bit mask of SCDEN field.
	DFSDM_CHCFG0R1_SCDEN_Msk = 0x20
	// Bit SCDEN.
	DFSDM_CHCFG0R1_SCDEN = 0x20
	// Position of CKABEN field.
	DFSDM_CHCFG0R1_CKABEN_Pos = 0x6
	// Bit mask of CKABEN field.
	DFSDM_CHCFG0R1_CKABEN_Msk = 0x40
	// Bit CKABEN.
	DFSDM_CHCFG0R1_CKABEN = 0x40
	// Position of CHEN field.
	DFSDM_CHCFG0R1_CHEN_Pos = 0x7
	// Bit mask of CHEN field.
	DFSDM_CHCFG0R1_CHEN_Msk = 0x80
	// Bit CHEN.
	DFSDM_CHCFG0R1_CHEN = 0x80
	// Position of CHINSEL field.
	DFSDM_CHCFG0R1_CHINSEL_Pos = 0x8
	// Bit mask of CHINSEL field.
	DFSDM_CHCFG0R1_CHINSEL_Msk = 0x100
	// Bit CHINSEL.
	DFSDM_CHCFG0R1_CHINSEL = 0x100
	// Position of DATMPX field.
	DFSDM_CHCFG0R1_DATMPX_Pos = 0xc
	// Bit mask of DATMPX field.
	DFSDM_CHCFG0R1_DATMPX_Msk = 0x3000
	// Position of DATPACK field.
	DFSDM_CHCFG0R1_DATPACK_Pos = 0xe
	// Bit mask of DATPACK field.
	DFSDM_CHCFG0R1_DATPACK_Msk = 0xc000
	// Position of CKOUTDIV field.
	DFSDM_CHCFG0R1_CKOUTDIV_Pos = 0x10
	// Bit mask of CKOUTDIV field.
	DFSDM_CHCFG0R1_CKOUTDIV_Msk = 0xff0000
	// Position of CKOUTSRC field.
	DFSDM_CHCFG0R1_CKOUTSRC_Pos = 0x1e
	// Bit mask of CKOUTSRC field.
	DFSDM_CHCFG0R1_CKOUTSRC_Msk = 0x40000000
	// Bit CKOUTSRC.
	DFSDM_CHCFG0R1_CKOUTSRC = 0x40000000
	// Position of DFSDMEN field.
	DFSDM_CHCFG0R1_DFSDMEN_Pos = 0x1f
	// Bit mask of DFSDMEN field.
	DFSDM_CHCFG0R1_DFSDMEN_Msk = 0x80000000
	// Bit DFSDMEN.
	DFSDM_CHCFG0R1_DFSDMEN = 0x80000000

	// CHCFG1R1: DFSDM channel configuration 1 register 1
	// Position of SITP field.
	DFSDM_CHCFG1R1_SITP_Pos = 0x0
	// Bit mask of SITP field.
	DFSDM_CHCFG1R1_SITP_Msk = 0x3
	// Position of SPICKSEL field.
	DFSDM_CHCFG1R1_SPICKSEL_Pos = 0x2
	// Bit mask of SPICKSEL field.
	DFSDM_CHCFG1R1_SPICKSEL_Msk = 0xc
	// Position of SCDEN field.
	DFSDM_CHCFG1R1_SCDEN_Pos = 0x5
	// Bit mask of SCDEN field.
	DFSDM_CHCFG1R1_SCDEN_Msk = 0x20
	// Bit SCDEN.
	DFSDM_CHCFG1R1_SCDEN = 0x20
	// Position of CKABEN field.
	DFSDM_CHCFG1R1_CKABEN_Pos = 0x6
	// Bit mask of CKABEN field.
	DFSDM_CHCFG1R1_CKABEN_Msk = 0x40
	// Bit CKABEN.
	DFSDM_CHCFG1R1_CKABEN = 0x40
	// Position of CHEN field.
	DFSDM_CHCFG1R1_CHEN_Pos = 0x7
	// Bit mask of CHEN field.
	DFSDM_CHCFG1R1_CHEN_Msk = 0x80
	// Bit CHEN.
	DFSDM_CHCFG1R1_CHEN = 0x80
	// Position of CHINSEL field.
	DFSDM_CHCFG1R1_CHINSEL_Pos = 0x8
	// Bit mask of CHINSEL field.
	DFSDM_CHCFG1R1_CHINSEL_Msk = 0x100
	// Bit CHINSEL.
	DFSDM_CHCFG1R1_CHINSEL = 0x100
	// Position of DATMPX field.
	DFSDM_CHCFG1R1_DATMPX_Pos = 0xc
	// Bit mask of DATMPX field.
	DFSDM_CHCFG1R1_DATMPX_Msk = 0x3000
	// Position of DATPACK field.
	DFSDM_CHCFG1R1_DATPACK_Pos = 0xe
	// Bit mask of DATPACK field.
	DFSDM_CHCFG1R1_DATPACK_Msk = 0xc000
	// Position of CKOUTDIV field.
	DFSDM_CHCFG1R1_CKOUTDIV_Pos = 0x10
	// Bit mask of CKOUTDIV field.
	DFSDM_CHCFG1R1_CKOUTDIV_Msk = 0xff0000
	// Position of CKOUTSRC field.
	DFSDM_CHCFG1R1_CKOUTSRC_Pos = 0x1e
	// Bit mask of CKOUTSRC field.
	DFSDM_CHCFG1R1_CKOUTSRC_Msk = 0x40000000
	// Bit CKOUTSRC.
	DFSDM_CHCFG1R1_CKOUTSRC = 0x40000000
	// Position of DFSDMEN field.
	DFSDM_CHCFG1R1_DFSDMEN_Pos = 0x1f
	// Bit mask of DFSDMEN field.
	DFSDM_CHCFG1R1_DFSDMEN_Msk = 0x80000000
	// Bit DFSDMEN.
	DFSDM_CHCFG1R1_DFSDMEN = 0x80000000

	// CHCFG2R1: DFSDM channel configuration 2 register 1
	// Position of SITP field.
	DFSDM_CHCFG2R1_SITP_Pos = 0x0
	// Bit mask of SITP field.
	DFSDM_CHCFG2R1_SITP_Msk = 0x3
	// Position of SPICKSEL field.
	DFSDM_CHCFG2R1_SPICKSEL_Pos = 0x2
	// Bit mask of SPICKSEL field.
	DFSDM_CHCFG2R1_SPICKSEL_Msk = 0xc
	// Position of SCDEN field.
	DFSDM_CHCFG2R1_SCDEN_Pos = 0x5
	// Bit mask of SCDEN field.
	DFSDM_CHCFG2R1_SCDEN_Msk = 0x20
	// Bit SCDEN.
	DFSDM_CHCFG2R1_SCDEN = 0x20
	// Position of CKABEN field.
	DFSDM_CHCFG2R1_CKABEN_Pos = 0x6
	// Bit mask of CKABEN field.
	DFSDM_CHCFG2R1_CKABEN_Msk = 0x40
	// Bit CKABEN.
	DFSDM_CHCFG2R1_CKABEN = 0x40
	// Position of CHEN field.
	DFSDM_CHCFG2R1_CHEN_Pos = 0x7
	// Bit mask of CHEN field.
	DFSDM_CHCFG2R1_CHEN_Msk = 0x80
	// Bit CHEN.
	DFSDM_CHCFG2R1_CHEN = 0x80
	// Position of CHINSEL field.
	DFSDM_CHCFG2R1_CHINSEL_Pos = 0x8
	// Bit mask of CHINSEL field.
	DFSDM_CHCFG2R1_CHINSEL_Msk = 0x100
	// Bit CHINSEL.
	DFSDM_CHCFG2R1_CHINSEL = 0x100
	// Position of DATMPX field.
	DFSDM_CHCFG2R1_DATMPX_Pos = 0xc
	// Bit mask of DATMPX field.
	DFSDM_CHCFG2R1_DATMPX_Msk = 0x3000
	// Position of DATPACK field.
	DFSDM_CHCFG2R1_DATPACK_Pos = 0xe
	// Bit mask of DATPACK field.
	DFSDM_CHCFG2R1_DATPACK_Msk = 0xc000
	// Position of CKOUTDIV field.
	DFSDM_CHCFG2R1_CKOUTDIV_Pos = 0x10
	// Bit mask of CKOUTDIV field.
	DFSDM_CHCFG2R1_CKOUTDIV_Msk = 0xff0000
	// Position of CKOUTSRC field.
	DFSDM_CHCFG2R1_CKOUTSRC_Pos = 0x1e
	// Bit mask of CKOUTSRC field.
	DFSDM_CHCFG2R1_CKOUTSRC_Msk = 0x40000000
	// Bit CKOUTSRC.
	DFSDM_CHCFG2R1_CKOUTSRC = 0x40000000
	// Position of DFSDMEN field.
	DFSDM_CHCFG2R1_DFSDMEN_Pos = 0x1f
	// Bit mask of DFSDMEN field.
	DFSDM_CHCFG2R1_DFSDMEN_Msk = 0x80000000
	// Bit DFSDMEN.
	DFSDM_CHCFG2R1_DFSDMEN = 0x80000000

	// CHCFG3R1: DFSDM channel configuration 3 register 1
	// Position of SITP field.
	DFSDM_CHCFG3R1_SITP_Pos = 0x0
	// Bit mask of SITP field.
	DFSDM_CHCFG3R1_SITP_Msk = 0x3
	// Position of SPICKSEL field.
	DFSDM_CHCFG3R1_SPICKSEL_Pos = 0x2
	// Bit mask of SPICKSEL field.
	DFSDM_CHCFG3R1_SPICKSEL_Msk = 0xc
	// Position of SCDEN field.
	DFSDM_CHCFG3R1_SCDEN_Pos = 0x5
	// Bit mask of SCDEN field.
	DFSDM_CHCFG3R1_SCDEN_Msk = 0x20
	// Bit SCDEN.
	DFSDM_CHCFG3R1_SCDEN = 0x20
	// Position of CKABEN field.
	DFSDM_CHCFG3R1_CKABEN_Pos = 0x6
	// Bit mask of CKABEN field.
	DFSDM_CHCFG3R1_CKABEN_Msk = 0x40
	// Bit CKABEN.
	DFSDM_CHCFG3R1_CKABEN = 0x40
	// Position of CHEN field.
	DFSDM_CHCFG3R1_CHEN_Pos = 0x7
	// Bit mask of CHEN field.
	DFSDM_CHCFG3R1_CHEN_Msk = 0x80
	// Bit CHEN.
	DFSDM_CHCFG3R1_CHEN = 0x80
	// Position of CHINSEL field.
	DFSDM_CHCFG3R1_CHINSEL_Pos = 0x8
	// Bit mask of CHINSEL field.
	DFSDM_CHCFG3R1_CHINSEL_Msk = 0x100
	// Bit CHINSEL.
	DFSDM_CHCFG3R1_CHINSEL = 0x100
	// Position of DATMPX field.
	DFSDM_CHCFG3R1_DATMPX_Pos = 0xc
	// Bit mask of DATMPX field.
	DFSDM_CHCFG3R1_DATMPX_Msk = 0x3000
	// Position of DATPACK field.
	DFSDM_CHCFG3R1_DATPACK_Pos = 0xe
	// Bit mask of DATPACK field.
	DFSDM_CHCFG3R1_DATPACK_Msk = 0xc000
	// Position of CKOUTDIV field.
	DFSDM_CHCFG3R1_CKOUTDIV_Pos = 0x10
	// Bit mask of CKOUTDIV field.
	DFSDM_CHCFG3R1_CKOUTDIV_Msk = 0xff0000
	// Position of CKOUTSRC field.
	DFSDM_CHCFG3R1_CKOUTSRC_Pos = 0x1e
	// Bit mask of CKOUTSRC field.
	DFSDM_CHCFG3R1_CKOUTSRC_Msk = 0x40000000
	// Bit CKOUTSRC.
	DFSDM_CHCFG3R1_CKOUTSRC = 0x40000000
	// Position of DFSDMEN field.
	DFSDM_CHCFG3R1_DFSDMEN_Pos = 0x1f
	// Bit mask of DFSDMEN field.
	DFSDM_CHCFG3R1_DFSDMEN_Msk = 0x80000000
	// Bit DFSDMEN.
	DFSDM_CHCFG3R1_DFSDMEN = 0x80000000

	// CHCFG4R1: DFSDM channel configuration 4 register 1
	// Position of SITP field.
	DFSDM_CHCFG4R1_SITP_Pos = 0x0
	// Bit mask of SITP field.
	DFSDM_CHCFG4R1_SITP_Msk = 0x3
	// Position of SPICKSEL field.
	DFSDM_CHCFG4R1_SPICKSEL_Pos = 0x2
	// Bit mask of SPICKSEL field.
	DFSDM_CHCFG4R1_SPICKSEL_Msk = 0xc
	// Position of SCDEN field.
	DFSDM_CHCFG4R1_SCDEN_Pos = 0x5
	// Bit mask of SCDEN field.
	DFSDM_CHCFG4R1_SCDEN_Msk = 0x20
	// Bit SCDEN.
	DFSDM_CHCFG4R1_SCDEN = 0x20
	// Position of CKABEN field.
	DFSDM_CHCFG4R1_CKABEN_Pos = 0x6
	// Bit mask of CKABEN field.
	DFSDM_CHCFG4R1_CKABEN_Msk = 0x40
	// Bit CKABEN.
	DFSDM_CHCFG4R1_CKABEN = 0x40
	// Position of CHEN field.
	DFSDM_CHCFG4R1_CHEN_Pos = 0x7
	// Bit mask of CHEN field.
	DFSDM_CHCFG4R1_CHEN_Msk = 0x80
	// Bit CHEN.
	DFSDM_CHCFG4R1_CHEN = 0x80
	// Position of CHINSEL field.
	DFSDM_CHCFG4R1_CHINSEL_Pos = 0x8
	// Bit mask of CHINSEL field.
	DFSDM_CHCFG4R1_CHINSEL_Msk = 0x100
	// Bit CHINSEL.
	DFSDM_CHCFG4R1_CHINSEL = 0x100
	// Position of DATMPX field.
	DFSDM_CHCFG4R1_DATMPX_Pos = 0xc
	// Bit mask of DATMPX field.
	DFSDM_CHCFG4R1_DATMPX_Msk = 0x3000
	// Position of DATPACK field.
	DFSDM_CHCFG4R1_DATPACK_Pos = 0xe
	// Bit mask of DATPACK field.
	DFSDM_CHCFG4R1_DATPACK_Msk = 0xc000
	// Position of CKOUTDIV field.
	DFSDM_CHCFG4R1_CKOUTDIV_Pos = 0x10
	// Bit mask of CKOUTDIV field.
	DFSDM_CHCFG4R1_CKOUTDIV_Msk = 0xff0000
	// Position of CKOUTSRC field.
	DFSDM_CHCFG4R1_CKOUTSRC_Pos = 0x1e
	// Bit mask of CKOUTSRC field.
	DFSDM_CHCFG4R1_CKOUTSRC_Msk = 0x40000000
	// Bit CKOUTSRC.
	DFSDM_CHCFG4R1_CKOUTSRC = 0x40000000
	// Position of DFSDMEN field.
	DFSDM_CHCFG4R1_DFSDMEN_Pos = 0x1f
	// Bit mask of DFSDMEN field.
	DFSDM_CHCFG4R1_DFSDMEN_Msk = 0x80000000
	// Bit DFSDMEN.
	DFSDM_CHCFG4R1_DFSDMEN = 0x80000000

	// CHCFG5R1: DFSDM channel configuration 5 register 1
	// Position of SITP field.
	DFSDM_CHCFG5R1_SITP_Pos = 0x0
	// Bit mask of SITP field.
	DFSDM_CHCFG5R1_SITP_Msk = 0x3
	// Position of SPICKSEL field.
	DFSDM_CHCFG5R1_SPICKSEL_Pos = 0x2
	// Bit mask of SPICKSEL field.
	DFSDM_CHCFG5R1_SPICKSEL_Msk = 0xc
	// Position of SCDEN field.
	DFSDM_CHCFG5R1_SCDEN_Pos = 0x5
	// Bit mask of SCDEN field.
	DFSDM_CHCFG5R1_SCDEN_Msk = 0x20
	// Bit SCDEN.
	DFSDM_CHCFG5R1_SCDEN = 0x20
	// Position of CKABEN field.
	DFSDM_CHCFG5R1_CKABEN_Pos = 0x6
	// Bit mask of CKABEN field.
	DFSDM_CHCFG5R1_CKABEN_Msk = 0x40
	// Bit CKABEN.
	DFSDM_CHCFG5R1_CKABEN = 0x40
	// Position of CHEN field.
	DFSDM_CHCFG5R1_CHEN_Pos = 0x7
	// Bit mask of CHEN field.
	DFSDM_CHCFG5R1_CHEN_Msk = 0x80
	// Bit CHEN.
	DFSDM_CHCFG5R1_CHEN = 0x80
	// Position of CHINSEL field.
	DFSDM_CHCFG5R1_CHINSEL_Pos = 0x8
	// Bit mask of CHINSEL field.
	DFSDM_CHCFG5R1_CHINSEL_Msk = 0x100
	// Bit CHINSEL.
	DFSDM_CHCFG5R1_CHINSEL = 0x100
	// Position of DATMPX field.
	DFSDM_CHCFG5R1_DATMPX_Pos = 0xc
	// Bit mask of DATMPX field.
	DFSDM_CHCFG5R1_DATMPX_Msk = 0x3000
	// Position of DATPACK field.
	DFSDM_CHCFG5R1_DATPACK_Pos = 0xe
	// Bit mask of DATPACK field.
	DFSDM_CHCFG5R1_DATPACK_Msk = 0xc000
	// Position of CKOUTDIV field.
	DFSDM_CHCFG5R1_CKOUTDIV_Pos = 0x10
	// Bit mask of CKOUTDIV field.
	DFSDM_CHCFG5R1_CKOUTDIV_Msk = 0xff0000
	// Position of CKOUTSRC field.
	DFSDM_CHCFG5R1_CKOUTSRC_Pos = 0x1e
	// Bit mask of CKOUTSRC field.
	DFSDM_CHCFG5R1_CKOUTSRC_Msk = 0x40000000
	// Bit CKOUTSRC.
	DFSDM_CHCFG5R1_CKOUTSRC = 0x40000000
	// Position of DFSDMEN field.
	DFSDM_CHCFG5R1_DFSDMEN_Pos = 0x1f
	// Bit mask of DFSDMEN field.
	DFSDM_CHCFG5R1_DFSDMEN_Msk = 0x80000000
	// Bit DFSDMEN.
	DFSDM_CHCFG5R1_DFSDMEN = 0x80000000

	// CHCFG6R1: DFSDM channel configuration 6 register 1
	// Position of SITP field.
	DFSDM_CHCFG6R1_SITP_Pos = 0x0
	// Bit mask of SITP field.
	DFSDM_CHCFG6R1_SITP_Msk = 0x3
	// Position of SPICKSEL field.
	DFSDM_CHCFG6R1_SPICKSEL_Pos = 0x2
	// Bit mask of SPICKSEL field.
	DFSDM_CHCFG6R1_SPICKSEL_Msk = 0xc
	// Position of SCDEN field.
	DFSDM_CHCFG6R1_SCDEN_Pos = 0x5
	// Bit mask of SCDEN field.
	DFSDM_CHCFG6R1_SCDEN_Msk = 0x20
	// Bit SCDEN.
	DFSDM_CHCFG6R1_SCDEN = 0x20
	// Position of CKABEN field.
	DFSDM_CHCFG6R1_CKABEN_Pos = 0x6
	// Bit mask of CKABEN field.
	DFSDM_CHCFG6R1_CKABEN_Msk = 0x40
	// Bit CKABEN.
	DFSDM_CHCFG6R1_CKABEN = 0x40
	// Position of CHEN field.
	DFSDM_CHCFG6R1_CHEN_Pos = 0x7
	// Bit mask of CHEN field.
	DFSDM_CHCFG6R1_CHEN_Msk = 0x80
	// Bit CHEN.
	DFSDM_CHCFG6R1_CHEN = 0x80
	// Position of CHINSEL field.
	DFSDM_CHCFG6R1_CHINSEL_Pos = 0x8
	// Bit mask of CHINSEL field.
	DFSDM_CHCFG6R1_CHINSEL_Msk = 0x100
	// Bit CHINSEL.
	DFSDM_CHCFG6R1_CHINSEL = 0x100
	// Position of DATMPX field.
	DFSDM_CHCFG6R1_DATMPX_Pos = 0xc
	// Bit mask of DATMPX field.
	DFSDM_CHCFG6R1_DATMPX_Msk = 0x3000
	// Position of DATPACK field.
	DFSDM_CHCFG6R1_DATPACK_Pos = 0xe
	// Bit mask of DATPACK field.
	DFSDM_CHCFG6R1_DATPACK_Msk = 0xc000
	// Position of CKOUTDIV field.
	DFSDM_CHCFG6R1_CKOUTDIV_Pos = 0x10
	// Bit mask of CKOUTDIV field.
	DFSDM_CHCFG6R1_CKOUTDIV_Msk = 0xff0000
	// Position of CKOUTSRC field.
	DFSDM_CHCFG6R1_CKOUTSRC_Pos = 0x1e
	// Bit mask of CKOUTSRC field.
	DFSDM_CHCFG6R1_CKOUTSRC_Msk = 0x40000000
	// Bit CKOUTSRC.
	DFSDM_CHCFG6R1_CKOUTSRC = 0x40000000
	// Position of DFSDMEN field.
	DFSDM_CHCFG6R1_DFSDMEN_Pos = 0x1f
	// Bit mask of DFSDMEN field.
	DFSDM_CHCFG6R1_DFSDMEN_Msk = 0x80000000
	// Bit DFSDMEN.
	DFSDM_CHCFG6R1_DFSDMEN = 0x80000000

	// CHCFG7R1: DFSDM channel configuration 7 register 1
	// Position of SITP field.
	DFSDM_CHCFG7R1_SITP_Pos = 0x0
	// Bit mask of SITP field.
	DFSDM_CHCFG7R1_SITP_Msk = 0x3
	// Position of SPICKSEL field.
	DFSDM_CHCFG7R1_SPICKSEL_Pos = 0x2
	// Bit mask of SPICKSEL field.
	DFSDM_CHCFG7R1_SPICKSEL_Msk = 0xc
	// Position of SCDEN field.
	DFSDM_CHCFG7R1_SCDEN_Pos = 0x5
	// Bit mask of SCDEN field.
	DFSDM_CHCFG7R1_SCDEN_Msk = 0x20
	// Bit SCDEN.
	DFSDM_CHCFG7R1_SCDEN = 0x20
	// Position of CKABEN field.
	DFSDM_CHCFG7R1_CKABEN_Pos = 0x6
	// Bit mask of CKABEN field.
	DFSDM_CHCFG7R1_CKABEN_Msk = 0x40
	// Bit CKABEN.
	DFSDM_CHCFG7R1_CKABEN = 0x40
	// Position of CHEN field.
	DFSDM_CHCFG7R1_CHEN_Pos = 0x7
	// Bit mask of CHEN field.
	DFSDM_CHCFG7R1_CHEN_Msk = 0x80
	// Bit CHEN.
	DFSDM_CHCFG7R1_CHEN = 0x80
	// Position of CHINSEL field.
	DFSDM_CHCFG7R1_CHINSEL_Pos = 0x8
	// Bit mask of CHINSEL field.
	DFSDM_CHCFG7R1_CHINSEL_Msk = 0x100
	// Bit CHINSEL.
	DFSDM_CHCFG7R1_CHINSEL = 0x100
	// Position of DATMPX field.
	DFSDM_CHCFG7R1_DATMPX_Pos = 0xc
	// Bit mask of DATMPX field.
	DFSDM_CHCFG7R1_DATMPX_Msk = 0x3000
	// Position of DATPACK field.
	DFSDM_CHCFG7R1_DATPACK_Pos = 0xe
	// Bit mask of DATPACK field.
	DFSDM_CHCFG7R1_DATPACK_Msk = 0xc000
	// Position of CKOUTDIV field.
	DFSDM_CHCFG7R1_CKOUTDIV_Pos = 0x10
	// Bit mask of CKOUTDIV field.
	DFSDM_CHCFG7R1_CKOUTDIV_Msk = 0xff0000
	// Position of CKOUTSRC field.
	DFSDM_CHCFG7R1_CKOUTSRC_Pos = 0x1e
	// Bit mask of CKOUTSRC field.
	DFSDM_CHCFG7R1_CKOUTSRC_Msk = 0x40000000
	// Bit CKOUTSRC.
	DFSDM_CHCFG7R1_CKOUTSRC = 0x40000000
	// Position of DFSDMEN field.
	DFSDM_CHCFG7R1_DFSDMEN_Pos = 0x1f
	// Bit mask of DFSDMEN field.
	DFSDM_CHCFG7R1_DFSDMEN_Msk = 0x80000000
	// Bit DFSDMEN.
	DFSDM_CHCFG7R1_DFSDMEN = 0x80000000

	// CHCFG0R2: DFSDM channel configuration 0 register 2
	// Position of DTRBS field.
	DFSDM_CHCFG0R2_DTRBS_Pos = 0x3
	// Bit mask of DTRBS field.
	DFSDM_CHCFG0R2_DTRBS_Msk = 0xf8
	// Position of OFFSET field.
	DFSDM_CHCFG0R2_OFFSET_Pos = 0x8
	// Bit mask of OFFSET field.
	DFSDM_CHCFG0R2_OFFSET_Msk = 0xffffff00

	// CHCFG1R2: DFSDM channel configuration 1 register 2
	// Position of DTRBS field.
	DFSDM_CHCFG1R2_DTRBS_Pos = 0x3
	// Bit mask of DTRBS field.
	DFSDM_CHCFG1R2_DTRBS_Msk = 0xf8
	// Position of OFFSET field.
	DFSDM_CHCFG1R2_OFFSET_Pos = 0x8
	// Bit mask of OFFSET field.
	DFSDM_CHCFG1R2_OFFSET_Msk = 0xffffff00

	// CHCFG2R2: DFSDM channel configuration 2 register 2
	// Position of DTRBS field.
	DFSDM_CHCFG2R2_DTRBS_Pos = 0x3
	// Bit mask of DTRBS field.
	DFSDM_CHCFG2R2_DTRBS_Msk = 0xf8
	// Position of OFFSET field.
	DFSDM_CHCFG2R2_OFFSET_Pos = 0x8
	// Bit mask of OFFSET field.
	DFSDM_CHCFG2R2_OFFSET_Msk = 0xffffff00

	// CHCFG3R2: DFSDM channel configuration 3 register 2
	// Position of DTRBS field.
	DFSDM_CHCFG3R2_DTRBS_Pos = 0x3
	// Bit mask of DTRBS field.
	DFSDM_CHCFG3R2_DTRBS_Msk = 0xf8
	// Position of OFFSET field.
	DFSDM_CHCFG3R2_OFFSET_Pos = 0x8
	// Bit mask of OFFSET field.
	DFSDM_CHCFG3R2_OFFSET_Msk = 0xffffff00

	// CHCFG4R2: DFSDM channel configuration 4 register 2
	// Position of DTRBS field.
	DFSDM_CHCFG4R2_DTRBS_Pos = 0x3
	// Bit mask of DTRBS field.
	DFSDM_CHCFG4R2_DTRBS_Msk = 0xf8
	// Position of OFFSET field.
	DFSDM_CHCFG4R2_OFFSET_Pos = 0x8
	// Bit mask of OFFSET field.
	DFSDM_CHCFG4R2_OFFSET_Msk = 0xffffff00

	// CHCFG5R2: DFSDM channel configuration 5 register 2
	// Position of DTRBS field.
	DFSDM_CHCFG5R2_DTRBS_Pos = 0x3
	// Bit mask of DTRBS field.
	DFSDM_CHCFG5R2_DTRBS_Msk = 0xf8
	// Position of OFFSET field.
	DFSDM_CHCFG5R2_OFFSET_Pos = 0x8
	// Bit mask of OFFSET field.
	DFSDM_CHCFG5R2_OFFSET_Msk = 0xffffff00

	// CHCFG6R2: DFSDM channel configuration 6 register 2
	// Position of DTRBS field.
	DFSDM_CHCFG6R2_DTRBS_Pos = 0x3
	// Bit mask of DTRBS field.
	DFSDM_CHCFG6R2_DTRBS_Msk = 0xf8
	// Position of OFFSET field.
	DFSDM_CHCFG6R2_OFFSET_Pos = 0x8
	// Bit mask of OFFSET field.
	DFSDM_CHCFG6R2_OFFSET_Msk = 0xffffff00

	// CHCFG7R2: DFSDM channel configuration 7 register 2
	// Position of DTRBS field.
	DFSDM_CHCFG7R2_DTRBS_Pos = 0x3
	// Bit mask of DTRBS field.
	DFSDM_CHCFG7R2_DTRBS_Msk = 0xf8
	// Position of OFFSET field.
	DFSDM_CHCFG7R2_OFFSET_Pos = 0x8
	// Bit mask of OFFSET field.
	DFSDM_CHCFG7R2_OFFSET_Msk = 0xffffff00

	// AWSCD0R: DFSDM analog watchdog and short-circuit detector register
	// Position of SCDT field.
	DFSDM_AWSCD0R_SCDT_Pos = 0x0
	// Bit mask of SCDT field.
	DFSDM_AWSCD0R_SCDT_Msk = 0xff
	// Position of BKSCD field.
	DFSDM_AWSCD0R_BKSCD_Pos = 0xc
	// Bit mask of BKSCD field.
	DFSDM_AWSCD0R_BKSCD_Msk = 0xf000
	// Position of AWFOSR field.
	DFSDM_AWSCD0R_AWFOSR_Pos = 0x10
	// Bit mask of AWFOSR field.
	DFSDM_AWSCD0R_AWFOSR_Msk = 0x1f0000
	// Position of AWFORD field.
	DFSDM_AWSCD0R_AWFORD_Pos = 0x16
	// Bit mask of AWFORD field.
	DFSDM_AWSCD0R_AWFORD_Msk = 0xc00000

	// AWSCD1R: DFSDM analog watchdog and short-circuit detector register
	// Position of SCDT field.
	DFSDM_AWSCD1R_SCDT_Pos = 0x0
	// Bit mask of SCDT field.
	DFSDM_AWSCD1R_SCDT_Msk = 0xff
	// Position of BKSCD field.
	DFSDM_AWSCD1R_BKSCD_Pos = 0xc
	// Bit mask of BKSCD field.
	DFSDM_AWSCD1R_BKSCD_Msk = 0xf000
	// Position of AWFOSR field.
	DFSDM_AWSCD1R_AWFOSR_Pos = 0x10
	// Bit mask of AWFOSR field.
	DFSDM_AWSCD1R_AWFOSR_Msk = 0x1f0000
	// Position of AWFORD field.
	DFSDM_AWSCD1R_AWFORD_Pos = 0x16
	// Bit mask of AWFORD field.
	DFSDM_AWSCD1R_AWFORD_Msk = 0xc00000

	// AWSCD2R: DFSDM analog watchdog and short-circuit detector register
	// Position of SCDT field.
	DFSDM_AWSCD2R_SCDT_Pos = 0x0
	// Bit mask of SCDT field.
	DFSDM_AWSCD2R_SCDT_Msk = 0xff
	// Position of BKSCD field.
	DFSDM_AWSCD2R_BKSCD_Pos = 0xc
	// Bit mask of BKSCD field.
	DFSDM_AWSCD2R_BKSCD_Msk = 0xf000
	// Position of AWFOSR field.
	DFSDM_AWSCD2R_AWFOSR_Pos = 0x10
	// Bit mask of AWFOSR field.
	DFSDM_AWSCD2R_AWFOSR_Msk = 0x1f0000
	// Position of AWFORD field.
	DFSDM_AWSCD2R_AWFORD_Pos = 0x16
	// Bit mask of AWFORD field.
	DFSDM_AWSCD2R_AWFORD_Msk = 0xc00000

	// AWSCD3R: DFSDM analog watchdog and short-circuit detector register
	// Position of SCDT field.
	DFSDM_AWSCD3R_SCDT_Pos = 0x0
	// Bit mask of SCDT field.
	DFSDM_AWSCD3R_SCDT_Msk = 0xff
	// Position of BKSCD field.
	DFSDM_AWSCD3R_BKSCD_Pos = 0xc
	// Bit mask of BKSCD field.
	DFSDM_AWSCD3R_BKSCD_Msk = 0xf000
	// Position of AWFOSR field.
	DFSDM_AWSCD3R_AWFOSR_Pos = 0x10
	// Bit mask of AWFOSR field.
	DFSDM_AWSCD3R_AWFOSR_Msk = 0x1f0000
	// Position of AWFORD field.
	DFSDM_AWSCD3R_AWFORD_Pos = 0x16
	// Bit mask of AWFORD field.
	DFSDM_AWSCD3R_AWFORD_Msk = 0xc00000

	// AWSCD4R: DFSDM analog watchdog and short-circuit detector register
	// Position of SCDT field.
	DFSDM_AWSCD4R_SCDT_Pos = 0x0
	// Bit mask of SCDT field.
	DFSDM_AWSCD4R_SCDT_Msk = 0xff
	// Position of BKSCD field.
	DFSDM_AWSCD4R_BKSCD_Pos = 0xc
	// Bit mask of BKSCD field.
	DFSDM_AWSCD4R_BKSCD_Msk = 0xf000
	// Position of AWFOSR field.
	DFSDM_AWSCD4R_AWFOSR_Pos = 0x10
	// Bit mask of AWFOSR field.
	DFSDM_AWSCD4R_AWFOSR_Msk = 0x1f0000
	// Position of AWFORD field.
	DFSDM_AWSCD4R_AWFORD_Pos = 0x16
	// Bit mask of AWFORD field.
	DFSDM_AWSCD4R_AWFORD_Msk = 0xc00000

	// AWSCD5R: DFSDM analog watchdog and short-circuit detector register
	// Position of SCDT field.
	DFSDM_AWSCD5R_SCDT_Pos = 0x0
	// Bit mask of SCDT field.
	DFSDM_AWSCD5R_SCDT_Msk = 0xff
	// Position of BKSCD field.
	DFSDM_AWSCD5R_BKSCD_Pos = 0xc
	// Bit mask of BKSCD field.
	DFSDM_AWSCD5R_BKSCD_Msk = 0xf000
	// Position of AWFOSR field.
	DFSDM_AWSCD5R_AWFOSR_Pos = 0x10
	// Bit mask of AWFOSR field.
	DFSDM_AWSCD5R_AWFOSR_Msk = 0x1f0000
	// Position of AWFORD field.
	DFSDM_AWSCD5R_AWFORD_Pos = 0x16
	// Bit mask of AWFORD field.
	DFSDM_AWSCD5R_AWFORD_Msk = 0xc00000

	// AWSCD6R: DFSDM analog watchdog and short-circuit detector register
	// Position of SCDT field.
	DFSDM_AWSCD6R_SCDT_Pos = 0x0
	// Bit mask of SCDT field.
	DFSDM_AWSCD6R_SCDT_Msk = 0xff
	// Position of BKSCD field.
	DFSDM_AWSCD6R_BKSCD_Pos = 0xc
	// Bit mask of BKSCD field.
	DFSDM_AWSCD6R_BKSCD_Msk = 0xf000
	// Position of AWFOSR field.
	DFSDM_AWSCD6R_AWFOSR_Pos = 0x10
	// Bit mask of AWFOSR field.
	DFSDM_AWSCD6R_AWFOSR_Msk = 0x1f0000
	// Position of AWFORD field.
	DFSDM_AWSCD6R_AWFORD_Pos = 0x16
	// Bit mask of AWFORD field.
	DFSDM_AWSCD6R_AWFORD_Msk = 0xc00000

	// AWSCD7R: DFSDM analog watchdog and short-circuit detector register
	// Position of SCDT field.
	DFSDM_AWSCD7R_SCDT_Pos = 0x0
	// Bit mask of SCDT field.
	DFSDM_AWSCD7R_SCDT_Msk = 0xff
	// Position of BKSCD field.
	DFSDM_AWSCD7R_BKSCD_Pos = 0xc
	// Bit mask of BKSCD field.
	DFSDM_AWSCD7R_BKSCD_Msk = 0xf000
	// Position of AWFOSR field.
	DFSDM_AWSCD7R_AWFOSR_Pos = 0x10
	// Bit mask of AWFOSR field.
	DFSDM_AWSCD7R_AWFOSR_Msk = 0x1f0000
	// Position of AWFORD field.
	DFSDM_AWSCD7R_AWFORD_Pos = 0x16
	// Bit mask of AWFORD field.
	DFSDM_AWSCD7R_AWFORD_Msk = 0xc00000

	// CHWDAT0R: DFSDM channel watchdog filter data register
	// Position of WDATA field.
	DFSDM_CHWDAT0R_WDATA_Pos = 0x0
	// Bit mask of WDATA field.
	DFSDM_CHWDAT0R_WDATA_Msk = 0xffff

	// CHWDAT1R: DFSDM channel watchdog filter data register
	// Position of WDATA field.
	DFSDM_CHWDAT1R_WDATA_Pos = 0x0
	// Bit mask of WDATA field.
	DFSDM_CHWDAT1R_WDATA_Msk = 0xffff

	// CHWDAT2R: DFSDM channel watchdog filter data register
	// Position of WDATA field.
	DFSDM_CHWDAT2R_WDATA_Pos = 0x0
	// Bit mask of WDATA field.
	DFSDM_CHWDAT2R_WDATA_Msk = 0xffff

	// CHWDAT3R: DFSDM channel watchdog filter data register
	// Position of WDATA field.
	DFSDM_CHWDAT3R_WDATA_Pos = 0x0
	// Bit mask of WDATA field.
	DFSDM_CHWDAT3R_WDATA_Msk = 0xffff

	// CHWDAT4R: DFSDM channel watchdog filter data register
	// Position of WDATA field.
	DFSDM_CHWDAT4R_WDATA_Pos = 0x0
	// Bit mask of WDATA field.
	DFSDM_CHWDAT4R_WDATA_Msk = 0xffff

	// CHWDAT5R: DFSDM channel watchdog filter data register
	// Position of WDATA field.
	DFSDM_CHWDAT5R_WDATA_Pos = 0x0
	// Bit mask of WDATA field.
	DFSDM_CHWDAT5R_WDATA_Msk = 0xffff

	// CHWDAT6R: DFSDM channel watchdog filter data register
	// Position of WDATA field.
	DFSDM_CHWDAT6R_WDATA_Pos = 0x0
	// Bit mask of WDATA field.
	DFSDM_CHWDAT6R_WDATA_Msk = 0xffff

	// CHWDAT7R: DFSDM channel watchdog filter data register
	// Position of WDATA field.
	DFSDM_CHWDAT7R_WDATA_Pos = 0x0
	// Bit mask of WDATA field.
	DFSDM_CHWDAT7R_WDATA_Msk = 0xffff

	// CHDATIN0R: DFSDM channel data input register
	// Position of INDAT0 field.
	DFSDM_CHDATIN0R_INDAT0_Pos = 0x0
	// Bit mask of INDAT0 field.
	DFSDM_CHDATIN0R_INDAT0_Msk = 0xffff
	// Position of INDAT1 field.
	DFSDM_CHDATIN0R_INDAT1_Pos = 0x10
	// Bit mask of INDAT1 field.
	DFSDM_CHDATIN0R_INDAT1_Msk = 0xffff0000

	// CHDATIN1R: DFSDM channel data input register
	// Position of INDAT0 field.
	DFSDM_CHDATIN1R_INDAT0_Pos = 0x0
	// Bit mask of INDAT0 field.
	DFSDM_CHDATIN1R_INDAT0_Msk = 0xffff
	// Position of INDAT1 field.
	DFSDM_CHDATIN1R_INDAT1_Pos = 0x10
	// Bit mask of INDAT1 field.
	DFSDM_CHDATIN1R_INDAT1_Msk = 0xffff0000

	// CHDATIN2R: DFSDM channel data input register
	// Position of INDAT0 field.
	DFSDM_CHDATIN2R_INDAT0_Pos = 0x0
	// Bit mask of INDAT0 field.
	DFSDM_CHDATIN2R_INDAT0_Msk = 0xffff
	// Position of INDAT1 field.
	DFSDM_CHDATIN2R_INDAT1_Pos = 0x10
	// Bit mask of INDAT1 field.
	DFSDM_CHDATIN2R_INDAT1_Msk = 0xffff0000

	// CHDATIN3R: DFSDM channel data input register
	// Position of INDAT0 field.
	DFSDM_CHDATIN3R_INDAT0_Pos = 0x0
	// Bit mask of INDAT0 field.
	DFSDM_CHDATIN3R_INDAT0_Msk = 0xffff
	// Position of INDAT1 field.
	DFSDM_CHDATIN3R_INDAT1_Pos = 0x10
	// Bit mask of INDAT1 field.
	DFSDM_CHDATIN3R_INDAT1_Msk = 0xffff0000

	// CHDATIN4R: DFSDM channel data input register
	// Position of INDAT0 field.
	DFSDM_CHDATIN4R_INDAT0_Pos = 0x0
	// Bit mask of INDAT0 field.
	DFSDM_CHDATIN4R_INDAT0_Msk = 0xffff
	// Position of INDAT1 field.
	DFSDM_CHDATIN4R_INDAT1_Pos = 0x10
	// Bit mask of INDAT1 field.
	DFSDM_CHDATIN4R_INDAT1_Msk = 0xffff0000

	// CHDATIN5R: DFSDM channel data input register
	// Position of INDAT0 field.
	DFSDM_CHDATIN5R_INDAT0_Pos = 0x0
	// Bit mask of INDAT0 field.
	DFSDM_CHDATIN5R_INDAT0_Msk = 0xffff
	// Position of INDAT1 field.
	DFSDM_CHDATIN5R_INDAT1_Pos = 0x10
	// Bit mask of INDAT1 field.
	DFSDM_CHDATIN5R_INDAT1_Msk = 0xffff0000

	// CHDATIN6R: DFSDM channel data input register
	// Position of INDAT0 field.
	DFSDM_CHDATIN6R_INDAT0_Pos = 0x0
	// Bit mask of INDAT0 field.
	DFSDM_CHDATIN6R_INDAT0_Msk = 0xffff
	// Position of INDAT1 field.
	DFSDM_CHDATIN6R_INDAT1_Pos = 0x10
	// Bit mask of INDAT1 field.
	DFSDM_CHDATIN6R_INDAT1_Msk = 0xffff0000

	// CHDATIN7R: DFSDM channel data input register
	// Position of INDAT0 field.
	DFSDM_CHDATIN7R_INDAT0_Pos = 0x0
	// Bit mask of INDAT0 field.
	DFSDM_CHDATIN7R_INDAT0_Msk = 0xffff
	// Position of INDAT1 field.
	DFSDM_CHDATIN7R_INDAT1_Pos = 0x10
	// Bit mask of INDAT1 field.
	DFSDM_CHDATIN7R_INDAT1_Msk = 0xffff0000

	// DFSDM0_CR1: DFSDM control register 1
	// Position of DFEN field.
	DFSDM_DFSDM0_CR1_DFEN_Pos = 0x0
	// Bit mask of DFEN field.
	DFSDM_DFSDM0_CR1_DFEN_Msk = 0x1
	// Bit DFEN.
	DFSDM_DFSDM0_CR1_DFEN = 0x1
	// Position of JSWSTART field.
	DFSDM_DFSDM0_CR1_JSWSTART_Pos = 0x1
	// Bit mask of JSWSTART field.
	DFSDM_DFSDM0_CR1_JSWSTART_Msk = 0x2
	// Bit JSWSTART.
	DFSDM_DFSDM0_CR1_JSWSTART = 0x2
	// Position of JSYNC field.
	DFSDM_DFSDM0_CR1_JSYNC_Pos = 0x3
	// Bit mask of JSYNC field.
	DFSDM_DFSDM0_CR1_JSYNC_Msk = 0x8
	// Bit JSYNC.
	DFSDM_DFSDM0_CR1_JSYNC = 0x8
	// Position of JSCAN field.
	DFSDM_DFSDM0_CR1_JSCAN_Pos = 0x4
	// Bit mask of JSCAN field.
	DFSDM_DFSDM0_CR1_JSCAN_Msk = 0x10
	// Bit JSCAN.
	DFSDM_DFSDM0_CR1_JSCAN = 0x10
	// Position of JDMAEN field.
	DFSDM_DFSDM0_CR1_JDMAEN_Pos = 0x5
	// Bit mask of JDMAEN field.
	DFSDM_DFSDM0_CR1_JDMAEN_Msk = 0x20
	// Bit JDMAEN.
	DFSDM_DFSDM0_CR1_JDMAEN = 0x20
	// Position of JEXTSEL field.
	DFSDM_DFSDM0_CR1_JEXTSEL_Pos = 0x8
	// Bit mask of JEXTSEL field.
	DFSDM_DFSDM0_CR1_JEXTSEL_Msk = 0x1f00
	// Position of JEXTEN field.
	DFSDM_DFSDM0_CR1_JEXTEN_Pos = 0xd
	// Bit mask of JEXTEN field.
	DFSDM_DFSDM0_CR1_JEXTEN_Msk = 0x6000
	// Position of RSWSTART field.
	DFSDM_DFSDM0_CR1_RSWSTART_Pos = 0x11
	// Bit mask of RSWSTART field.
	DFSDM_DFSDM0_CR1_RSWSTART_Msk = 0x20000
	// Bit RSWSTART.
	DFSDM_DFSDM0_CR1_RSWSTART = 0x20000
	// Position of RCONT field.
	DFSDM_DFSDM0_CR1_RCONT_Pos = 0x12
	// Bit mask of RCONT field.
	DFSDM_DFSDM0_CR1_RCONT_Msk = 0x40000
	// Bit RCONT.
	DFSDM_DFSDM0_CR1_RCONT = 0x40000
	// Position of RSYNC field.
	DFSDM_DFSDM0_CR1_RSYNC_Pos = 0x13
	// Bit mask of RSYNC field.
	DFSDM_DFSDM0_CR1_RSYNC_Msk = 0x80000
	// Bit RSYNC.
	DFSDM_DFSDM0_CR1_RSYNC = 0x80000
	// Position of RDMAEN field.
	DFSDM_DFSDM0_CR1_RDMAEN_Pos = 0x15
	// Bit mask of RDMAEN field.
	DFSDM_DFSDM0_CR1_RDMAEN_Msk = 0x200000
	// Bit RDMAEN.
	DFSDM_DFSDM0_CR1_RDMAEN = 0x200000
	// Position of RCH field.
	DFSDM_DFSDM0_CR1_RCH_Pos = 0x18
	// Bit mask of RCH field.
	DFSDM_DFSDM0_CR1_RCH_Msk = 0x7000000
	// Position of FAST field.
	DFSDM_DFSDM0_CR1_FAST_Pos = 0x1d
	// Bit mask of FAST field.
	DFSDM_DFSDM0_CR1_FAST_Msk = 0x20000000
	// Bit FAST.
	DFSDM_DFSDM0_CR1_FAST = 0x20000000
	// Position of AWFSEL field.
	DFSDM_DFSDM0_CR1_AWFSEL_Pos = 0x1e
	// Bit mask of AWFSEL field.
	DFSDM_DFSDM0_CR1_AWFSEL_Msk = 0x40000000
	// Bit AWFSEL.
	DFSDM_DFSDM0_CR1_AWFSEL = 0x40000000

	// DFSDM1_CR1: DFSDM control register 1
	// Position of DFEN field.
	DFSDM_DFSDM1_CR1_DFEN_Pos = 0x0
	// Bit mask of DFEN field.
	DFSDM_DFSDM1_CR1_DFEN_Msk = 0x1
	// Bit DFEN.
	DFSDM_DFSDM1_CR1_DFEN = 0x1
	// Position of JSWSTART field.
	DFSDM_DFSDM1_CR1_JSWSTART_Pos = 0x1
	// Bit mask of JSWSTART field.
	DFSDM_DFSDM1_CR1_JSWSTART_Msk = 0x2
	// Bit JSWSTART.
	DFSDM_DFSDM1_CR1_JSWSTART = 0x2
	// Position of JSYNC field.
	DFSDM_DFSDM1_CR1_JSYNC_Pos = 0x3
	// Bit mask of JSYNC field.
	DFSDM_DFSDM1_CR1_JSYNC_Msk = 0x8
	// Bit JSYNC.
	DFSDM_DFSDM1_CR1_JSYNC = 0x8
	// Position of JSCAN field.
	DFSDM_DFSDM1_CR1_JSCAN_Pos = 0x4
	// Bit mask of JSCAN field.
	DFSDM_DFSDM1_CR1_JSCAN_Msk = 0x10
	// Bit JSCAN.
	DFSDM_DFSDM1_CR1_JSCAN = 0x10
	// Position of JDMAEN field.
	DFSDM_DFSDM1_CR1_JDMAEN_Pos = 0x5
	// Bit mask of JDMAEN field.
	DFSDM_DFSDM1_CR1_JDMAEN_Msk = 0x20
	// Bit JDMAEN.
	DFSDM_DFSDM1_CR1_JDMAEN = 0x20
	// Position of JEXTSEL field.
	DFSDM_DFSDM1_CR1_JEXTSEL_Pos = 0x8
	// Bit mask of JEXTSEL field.
	DFSDM_DFSDM1_CR1_JEXTSEL_Msk = 0x1f00
	// Position of JEXTEN field.
	DFSDM_DFSDM1_CR1_JEXTEN_Pos = 0xd
	// Bit mask of JEXTEN field.
	DFSDM_DFSDM1_CR1_JEXTEN_Msk = 0x6000
	// Position of RSWSTART field.
	DFSDM_DFSDM1_CR1_RSWSTART_Pos = 0x11
	// Bit mask of RSWSTART field.
	DFSDM_DFSDM1_CR1_RSWSTART_Msk = 0x20000
	// Bit RSWSTART.
	DFSDM_DFSDM1_CR1_RSWSTART = 0x20000
	// Position of RCONT field.
	DFSDM_DFSDM1_CR1_RCONT_Pos = 0x12
	// Bit mask of RCONT field.
	DFSDM_DFSDM1_CR1_RCONT_Msk = 0x40000
	// Bit RCONT.
	DFSDM_DFSDM1_CR1_RCONT = 0x40000
	// Position of RSYNC field.
	DFSDM_DFSDM1_CR1_RSYNC_Pos = 0x13
	// Bit mask of RSYNC field.
	DFSDM_DFSDM1_CR1_RSYNC_Msk = 0x80000
	// Bit RSYNC.
	DFSDM_DFSDM1_CR1_RSYNC = 0x80000
	// Position of RDMAEN field.
	DFSDM_DFSDM1_CR1_RDMAEN_Pos = 0x15
	// Bit mask of RDMAEN field.
	DFSDM_DFSDM1_CR1_RDMAEN_Msk = 0x200000
	// Bit RDMAEN.
	DFSDM_DFSDM1_CR1_RDMAEN = 0x200000
	// Position of RCH field.
	DFSDM_DFSDM1_CR1_RCH_Pos = 0x18
	// Bit mask of RCH field.
	DFSDM_DFSDM1_CR1_RCH_Msk = 0x7000000
	// Position of FAST field.
	DFSDM_DFSDM1_CR1_FAST_Pos = 0x1d
	// Bit mask of FAST field.
	DFSDM_DFSDM1_CR1_FAST_Msk = 0x20000000
	// Bit FAST.
	DFSDM_DFSDM1_CR1_FAST = 0x20000000
	// Position of AWFSEL field.
	DFSDM_DFSDM1_CR1_AWFSEL_Pos = 0x1e
	// Bit mask of AWFSEL field.
	DFSDM_DFSDM1_CR1_AWFSEL_Msk = 0x40000000
	// Bit AWFSEL.
	DFSDM_DFSDM1_CR1_AWFSEL = 0x40000000

	// DFSDM2_CR1: DFSDM control register 1
	// Position of DFEN field.
	DFSDM_DFSDM2_CR1_DFEN_Pos = 0x0
	// Bit mask of DFEN field.
	DFSDM_DFSDM2_CR1_DFEN_Msk = 0x1
	// Bit DFEN.
	DFSDM_DFSDM2_CR1_DFEN = 0x1
	// Position of JSWSTART field.
	DFSDM_DFSDM2_CR1_JSWSTART_Pos = 0x1
	// Bit mask of JSWSTART field.
	DFSDM_DFSDM2_CR1_JSWSTART_Msk = 0x2
	// Bit JSWSTART.
	DFSDM_DFSDM2_CR1_JSWSTART = 0x2
	// Position of JSYNC field.
	DFSDM_DFSDM2_CR1_JSYNC_Pos = 0x3
	// Bit mask of JSYNC field.
	DFSDM_DFSDM2_CR1_JSYNC_Msk = 0x8
	// Bit JSYNC.
	DFSDM_DFSDM2_CR1_JSYNC = 0x8
	// Position of JSCAN field.
	DFSDM_DFSDM2_CR1_JSCAN_Pos = 0x4
	// Bit mask of JSCAN field.
	DFSDM_DFSDM2_CR1_JSCAN_Msk = 0x10
	// Bit JSCAN.
	DFSDM_DFSDM2_CR1_JSCAN = 0x10
	// Position of JDMAEN field.
	DFSDM_DFSDM2_CR1_JDMAEN_Pos = 0x5
	// Bit mask of JDMAEN field.
	DFSDM_DFSDM2_CR1_JDMAEN_Msk = 0x20
	// Bit JDMAEN.
	DFSDM_DFSDM2_CR1_JDMAEN = 0x20
	// Position of JEXTSEL field.
	DFSDM_DFSDM2_CR1_JEXTSEL_Pos = 0x8
	// Bit mask of JEXTSEL field.
	DFSDM_DFSDM2_CR1_JEXTSEL_Msk = 0x1f00
	// Position of JEXTEN field.
	DFSDM_DFSDM2_CR1_JEXTEN_Pos = 0xd
	// Bit mask of JEXTEN field.
	DFSDM_DFSDM2_CR1_JEXTEN_Msk = 0x6000
	// Position of RSWSTART field.
	DFSDM_DFSDM2_CR1_RSWSTART_Pos = 0x11
	// Bit mask of RSWSTART field.
	DFSDM_DFSDM2_CR1_RSWSTART_Msk = 0x20000
	// Bit RSWSTART.
	DFSDM_DFSDM2_CR1_RSWSTART = 0x20000
	// Position of RCONT field.
	DFSDM_DFSDM2_CR1_RCONT_Pos = 0x12
	// Bit mask of RCONT field.
	DFSDM_DFSDM2_CR1_RCONT_Msk = 0x40000
	// Bit RCONT.
	DFSDM_DFSDM2_CR1_RCONT = 0x40000
	// Position of RSYNC field.
	DFSDM_DFSDM2_CR1_RSYNC_Pos = 0x13
	// Bit mask of RSYNC field.
	DFSDM_DFSDM2_CR1_RSYNC_Msk = 0x80000
	// Bit RSYNC.
	DFSDM_DFSDM2_CR1_RSYNC = 0x80000
	// Position of RDMAEN field.
	DFSDM_DFSDM2_CR1_RDMAEN_Pos = 0x15
	// Bit mask of RDMAEN field.
	DFSDM_DFSDM2_CR1_RDMAEN_Msk = 0x200000
	// Bit RDMAEN.
	DFSDM_DFSDM2_CR1_RDMAEN = 0x200000
	// Position of RCH field.
	DFSDM_DFSDM2_CR1_RCH_Pos = 0x18
	// Bit mask of RCH field.
	DFSDM_DFSDM2_CR1_RCH_Msk = 0x7000000
	// Position of FAST field.
	DFSDM_DFSDM2_CR1_FAST_Pos = 0x1d
	// Bit mask of FAST field.
	DFSDM_DFSDM2_CR1_FAST_Msk = 0x20000000
	// Bit FAST.
	DFSDM_DFSDM2_CR1_FAST = 0x20000000
	// Position of AWFSEL field.
	DFSDM_DFSDM2_CR1_AWFSEL_Pos = 0x1e
	// Bit mask of AWFSEL field.
	DFSDM_DFSDM2_CR1_AWFSEL_Msk = 0x40000000
	// Bit AWFSEL.
	DFSDM_DFSDM2_CR1_AWFSEL = 0x40000000

	// DFSDM3_CR1: DFSDM control register 1
	// Position of DFEN field.
	DFSDM_DFSDM3_CR1_DFEN_Pos = 0x0
	// Bit mask of DFEN field.
	DFSDM_DFSDM3_CR1_DFEN_Msk = 0x1
	// Bit DFEN.
	DFSDM_DFSDM3_CR1_DFEN = 0x1
	// Position of JSWSTART field.
	DFSDM_DFSDM3_CR1_JSWSTART_Pos = 0x1
	// Bit mask of JSWSTART field.
	DFSDM_DFSDM3_CR1_JSWSTART_Msk = 0x2
	// Bit JSWSTART.
	DFSDM_DFSDM3_CR1_JSWSTART = 0x2
	// Position of JSYNC field.
	DFSDM_DFSDM3_CR1_JSYNC_Pos = 0x3
	// Bit mask of JSYNC field.
	DFSDM_DFSDM3_CR1_JSYNC_Msk = 0x8
	// Bit JSYNC.
	DFSDM_DFSDM3_CR1_JSYNC = 0x8
	// Position of JSCAN field.
	DFSDM_DFSDM3_CR1_JSCAN_Pos = 0x4
	// Bit mask of JSCAN field.
	DFSDM_DFSDM3_CR1_JSCAN_Msk = 0x10
	// Bit JSCAN.
	DFSDM_DFSDM3_CR1_JSCAN = 0x10
	// Position of JDMAEN field.
	DFSDM_DFSDM3_CR1_JDMAEN_Pos = 0x5
	// Bit mask of JDMAEN field.
	DFSDM_DFSDM3_CR1_JDMAEN_Msk = 0x20
	// Bit JDMAEN.
	DFSDM_DFSDM3_CR1_JDMAEN = 0x20
	// Position of JEXTSEL field.
	DFSDM_DFSDM3_CR1_JEXTSEL_Pos = 0x8
	// Bit mask of JEXTSEL field.
	DFSDM_DFSDM3_CR1_JEXTSEL_Msk = 0x1f00
	// Position of JEXTEN field.
	DFSDM_DFSDM3_CR1_JEXTEN_Pos = 0xd
	// Bit mask of JEXTEN field.
	DFSDM_DFSDM3_CR1_JEXTEN_Msk = 0x6000
	// Position of RSWSTART field.
	DFSDM_DFSDM3_CR1_RSWSTART_Pos = 0x11
	// Bit mask of RSWSTART field.
	DFSDM_DFSDM3_CR1_RSWSTART_Msk = 0x20000
	// Bit RSWSTART.
	DFSDM_DFSDM3_CR1_RSWSTART = 0x20000
	// Position of RCONT field.
	DFSDM_DFSDM3_CR1_RCONT_Pos = 0x12
	// Bit mask of RCONT field.
	DFSDM_DFSDM3_CR1_RCONT_Msk = 0x40000
	// Bit RCONT.
	DFSDM_DFSDM3_CR1_RCONT = 0x40000
	// Position of RSYNC field.
	DFSDM_DFSDM3_CR1_RSYNC_Pos = 0x13
	// Bit mask of RSYNC field.
	DFSDM_DFSDM3_CR1_RSYNC_Msk = 0x80000
	// Bit RSYNC.
	DFSDM_DFSDM3_CR1_RSYNC = 0x80000
	// Position of RDMAEN field.
	DFSDM_DFSDM3_CR1_RDMAEN_Pos = 0x15
	// Bit mask of RDMAEN field.
	DFSDM_DFSDM3_CR1_RDMAEN_Msk = 0x200000
	// Bit RDMAEN.
	DFSDM_DFSDM3_CR1_RDMAEN = 0x200000
	// Position of RCH field.
	DFSDM_DFSDM3_CR1_RCH_Pos = 0x18
	// Bit mask of RCH field.
	DFSDM_DFSDM3_CR1_RCH_Msk = 0x7000000
	// Position of FAST field.
	DFSDM_DFSDM3_CR1_FAST_Pos = 0x1d
	// Bit mask of FAST field.
	DFSDM_DFSDM3_CR1_FAST_Msk = 0x20000000
	// Bit FAST.
	DFSDM_DFSDM3_CR1_FAST = 0x20000000
	// Position of AWFSEL field.
	DFSDM_DFSDM3_CR1_AWFSEL_Pos = 0x1e
	// Bit mask of AWFSEL field.
	DFSDM_DFSDM3_CR1_AWFSEL_Msk = 0x40000000
	// Bit AWFSEL.
	DFSDM_DFSDM3_CR1_AWFSEL = 0x40000000

	// DFSDM0_CR2: DFSDM control register 2
	// Position of JEOCIE field.
	DFSDM_DFSDM0_CR2_JEOCIE_Pos = 0x0
	// Bit mask of JEOCIE field.
	DFSDM_DFSDM0_CR2_JEOCIE_Msk = 0x1
	// Bit JEOCIE.
	DFSDM_DFSDM0_CR2_JEOCIE = 0x1
	// Position of REOCIE field.
	DFSDM_DFSDM0_CR2_REOCIE_Pos = 0x1
	// Bit mask of REOCIE field.
	DFSDM_DFSDM0_CR2_REOCIE_Msk = 0x2
	// Bit REOCIE.
	DFSDM_DFSDM0_CR2_REOCIE = 0x2
	// Position of JOVRIE field.
	DFSDM_DFSDM0_CR2_JOVRIE_Pos = 0x2
	// Bit mask of JOVRIE field.
	DFSDM_DFSDM0_CR2_JOVRIE_Msk = 0x4
	// Bit JOVRIE.
	DFSDM_DFSDM0_CR2_JOVRIE = 0x4
	// Position of ROVRIE field.
	DFSDM_DFSDM0_CR2_ROVRIE_Pos = 0x3
	// Bit mask of ROVRIE field.
	DFSDM_DFSDM0_CR2_ROVRIE_Msk = 0x8
	// Bit ROVRIE.
	DFSDM_DFSDM0_CR2_ROVRIE = 0x8
	// Position of AWDIE field.
	DFSDM_DFSDM0_CR2_AWDIE_Pos = 0x4
	// Bit mask of AWDIE field.
	DFSDM_DFSDM0_CR2_AWDIE_Msk = 0x10
	// Bit AWDIE.
	DFSDM_DFSDM0_CR2_AWDIE = 0x10
	// Position of SCDIE field.
	DFSDM_DFSDM0_CR2_SCDIE_Pos = 0x5
	// Bit mask of SCDIE field.
	DFSDM_DFSDM0_CR2_SCDIE_Msk = 0x20
	// Bit SCDIE.
	DFSDM_DFSDM0_CR2_SCDIE = 0x20
	// Position of CKABIE field.
	DFSDM_DFSDM0_CR2_CKABIE_Pos = 0x6
	// Bit mask of CKABIE field.
	DFSDM_DFSDM0_CR2_CKABIE_Msk = 0x40
	// Bit CKABIE.
	DFSDM_DFSDM0_CR2_CKABIE = 0x40
	// Position of EXCH field.
	DFSDM_DFSDM0_CR2_EXCH_Pos = 0x8
	// Bit mask of EXCH field.
	DFSDM_DFSDM0_CR2_EXCH_Msk = 0xff00
	// Position of AWDCH field.
	DFSDM_DFSDM0_CR2_AWDCH_Pos = 0x10
	// Bit mask of AWDCH field.
	DFSDM_DFSDM0_CR2_AWDCH_Msk = 0xff0000

	// DFSDM1_CR2: DFSDM control register 2
	// Position of JEOCIE field.
	DFSDM_DFSDM1_CR2_JEOCIE_Pos = 0x0
	// Bit mask of JEOCIE field.
	DFSDM_DFSDM1_CR2_JEOCIE_Msk = 0x1
	// Bit JEOCIE.
	DFSDM_DFSDM1_CR2_JEOCIE = 0x1
	// Position of REOCIE field.
	DFSDM_DFSDM1_CR2_REOCIE_Pos = 0x1
	// Bit mask of REOCIE field.
	DFSDM_DFSDM1_CR2_REOCIE_Msk = 0x2
	// Bit REOCIE.
	DFSDM_DFSDM1_CR2_REOCIE = 0x2
	// Position of JOVRIE field.
	DFSDM_DFSDM1_CR2_JOVRIE_Pos = 0x2
	// Bit mask of JOVRIE field.
	DFSDM_DFSDM1_CR2_JOVRIE_Msk = 0x4
	// Bit JOVRIE.
	DFSDM_DFSDM1_CR2_JOVRIE = 0x4
	// Position of ROVRIE field.
	DFSDM_DFSDM1_CR2_ROVRIE_Pos = 0x3
	// Bit mask of ROVRIE field.
	DFSDM_DFSDM1_CR2_ROVRIE_Msk = 0x8
	// Bit ROVRIE.
	DFSDM_DFSDM1_CR2_ROVRIE = 0x8
	// Position of AWDIE field.
	DFSDM_DFSDM1_CR2_AWDIE_Pos = 0x4
	// Bit mask of AWDIE field.
	DFSDM_DFSDM1_CR2_AWDIE_Msk = 0x10
	// Bit AWDIE.
	DFSDM_DFSDM1_CR2_AWDIE = 0x10
	// Position of SCDIE field.
	DFSDM_DFSDM1_CR2_SCDIE_Pos = 0x5
	// Bit mask of SCDIE field.
	DFSDM_DFSDM1_CR2_SCDIE_Msk = 0x20
	// Bit SCDIE.
	DFSDM_DFSDM1_CR2_SCDIE = 0x20
	// Position of CKABIE field.
	DFSDM_DFSDM1_CR2_CKABIE_Pos = 0x6
	// Bit mask of CKABIE field.
	DFSDM_DFSDM1_CR2_CKABIE_Msk = 0x40
	// Bit CKABIE.
	DFSDM_DFSDM1_CR2_CKABIE = 0x40
	// Position of EXCH field.
	DFSDM_DFSDM1_CR2_EXCH_Pos = 0x8
	// Bit mask of EXCH field.
	DFSDM_DFSDM1_CR2_EXCH_Msk = 0xff00
	// Position of AWDCH field.
	DFSDM_DFSDM1_CR2_AWDCH_Pos = 0x10
	// Bit mask of AWDCH field.
	DFSDM_DFSDM1_CR2_AWDCH_Msk = 0xff0000

	// DFSDM2_CR2: DFSDM control register 2
	// Position of JEOCIE field.
	DFSDM_DFSDM2_CR2_JEOCIE_Pos = 0x0
	// Bit mask of JEOCIE field.
	DFSDM_DFSDM2_CR2_JEOCIE_Msk = 0x1
	// Bit JEOCIE.
	DFSDM_DFSDM2_CR2_JEOCIE = 0x1
	// Position of REOCIE field.
	DFSDM_DFSDM2_CR2_REOCIE_Pos = 0x1
	// Bit mask of REOCIE field.
	DFSDM_DFSDM2_CR2_REOCIE_Msk = 0x2
	// Bit REOCIE.
	DFSDM_DFSDM2_CR2_REOCIE = 0x2
	// Position of JOVRIE field.
	DFSDM_DFSDM2_CR2_JOVRIE_Pos = 0x2
	// Bit mask of JOVRIE field.
	DFSDM_DFSDM2_CR2_JOVRIE_Msk = 0x4
	// Bit JOVRIE.
	DFSDM_DFSDM2_CR2_JOVRIE = 0x4
	// Position of ROVRIE field.
	DFSDM_DFSDM2_CR2_ROVRIE_Pos = 0x3
	// Bit mask of ROVRIE field.
	DFSDM_DFSDM2_CR2_ROVRIE_Msk = 0x8
	// Bit ROVRIE.
	DFSDM_DFSDM2_CR2_ROVRIE = 0x8
	// Position of AWDIE field.
	DFSDM_DFSDM2_CR2_AWDIE_Pos = 0x4
	// Bit mask of AWDIE field.
	DFSDM_DFSDM2_CR2_AWDIE_Msk = 0x10
	// Bit AWDIE.
	DFSDM_DFSDM2_CR2_AWDIE = 0x10
	// Position of SCDIE field.
	DFSDM_DFSDM2_CR2_SCDIE_Pos = 0x5
	// Bit mask of SCDIE field.
	DFSDM_DFSDM2_CR2_SCDIE_Msk = 0x20
	// Bit SCDIE.
	DFSDM_DFSDM2_CR2_SCDIE = 0x20
	// Position of CKABIE field.
	DFSDM_DFSDM2_CR2_CKABIE_Pos = 0x6
	// Bit mask of CKABIE field.
	DFSDM_DFSDM2_CR2_CKABIE_Msk = 0x40
	// Bit CKABIE.
	DFSDM_DFSDM2_CR2_CKABIE = 0x40
	// Position of EXCH field.
	DFSDM_DFSDM2_CR2_EXCH_Pos = 0x8
	// Bit mask of EXCH field.
	DFSDM_DFSDM2_CR2_EXCH_Msk = 0xff00
	// Position of AWDCH field.
	DFSDM_DFSDM2_CR2_AWDCH_Pos = 0x10
	// Bit mask of AWDCH field.
	DFSDM_DFSDM2_CR2_AWDCH_Msk = 0xff0000

	// DFSDM3_CR2: DFSDM control register 2
	// Position of JEOCIE field.
	DFSDM_DFSDM3_CR2_JEOCIE_Pos = 0x0
	// Bit mask of JEOCIE field.
	DFSDM_DFSDM3_CR2_JEOCIE_Msk = 0x1
	// Bit JEOCIE.
	DFSDM_DFSDM3_CR2_JEOCIE = 0x1
	// Position of REOCIE field.
	DFSDM_DFSDM3_CR2_REOCIE_Pos = 0x1
	// Bit mask of REOCIE field.
	DFSDM_DFSDM3_CR2_REOCIE_Msk = 0x2
	// Bit REOCIE.
	DFSDM_DFSDM3_CR2_REOCIE = 0x2
	// Position of JOVRIE field.
	DFSDM_DFSDM3_CR2_JOVRIE_Pos = 0x2
	// Bit mask of JOVRIE field.
	DFSDM_DFSDM3_CR2_JOVRIE_Msk = 0x4
	// Bit JOVRIE.
	DFSDM_DFSDM3_CR2_JOVRIE = 0x4
	// Position of ROVRIE field.
	DFSDM_DFSDM3_CR2_ROVRIE_Pos = 0x3
	// Bit mask of ROVRIE field.
	DFSDM_DFSDM3_CR2_ROVRIE_Msk = 0x8
	// Bit ROVRIE.
	DFSDM_DFSDM3_CR2_ROVRIE = 0x8
	// Position of AWDIE field.
	DFSDM_DFSDM3_CR2_AWDIE_Pos = 0x4
	// Bit mask of AWDIE field.
	DFSDM_DFSDM3_CR2_AWDIE_Msk = 0x10
	// Bit AWDIE.
	DFSDM_DFSDM3_CR2_AWDIE = 0x10
	// Position of SCDIE field.
	DFSDM_DFSDM3_CR2_SCDIE_Pos = 0x5
	// Bit mask of SCDIE field.
	DFSDM_DFSDM3_CR2_SCDIE_Msk = 0x20
	// Bit SCDIE.
	DFSDM_DFSDM3_CR2_SCDIE = 0x20
	// Position of CKABIE field.
	DFSDM_DFSDM3_CR2_CKABIE_Pos = 0x6
	// Bit mask of CKABIE field.
	DFSDM_DFSDM3_CR2_CKABIE_Msk = 0x40
	// Bit CKABIE.
	DFSDM_DFSDM3_CR2_CKABIE = 0x40
	// Position of EXCH field.
	DFSDM_DFSDM3_CR2_EXCH_Pos = 0x8
	// Bit mask of EXCH field.
	DFSDM_DFSDM3_CR2_EXCH_Msk = 0xff00
	// Position of AWDCH field.
	DFSDM_DFSDM3_CR2_AWDCH_Pos = 0x10
	// Bit mask of AWDCH field.
	DFSDM_DFSDM3_CR2_AWDCH_Msk = 0xff0000

	// DFSDM0_ISR: DFSDM interrupt and status register
	// Position of JEOCF field.
	DFSDM_DFSDM0_ISR_JEOCF_Pos = 0x0
	// Bit mask of JEOCF field.
	DFSDM_DFSDM0_ISR_JEOCF_Msk = 0x1
	// Bit JEOCF.
	DFSDM_DFSDM0_ISR_JEOCF = 0x1
	// Position of REOCF field.
	DFSDM_DFSDM0_ISR_REOCF_Pos = 0x1
	// Bit mask of REOCF field.
	DFSDM_DFSDM0_ISR_REOCF_Msk = 0x2
	// Bit REOCF.
	DFSDM_DFSDM0_ISR_REOCF = 0x2
	// Position of JOVRF field.
	DFSDM_DFSDM0_ISR_JOVRF_Pos = 0x2
	// Bit mask of JOVRF field.
	DFSDM_DFSDM0_ISR_JOVRF_Msk = 0x4
	// Bit JOVRF.
	DFSDM_DFSDM0_ISR_JOVRF = 0x4
	// Position of ROVRF field.
	DFSDM_DFSDM0_ISR_ROVRF_Pos = 0x3
	// Bit mask of ROVRF field.
	DFSDM_DFSDM0_ISR_ROVRF_Msk = 0x8
	// Bit ROVRF.
	DFSDM_DFSDM0_ISR_ROVRF = 0x8
	// Position of AWDF field.
	DFSDM_DFSDM0_ISR_AWDF_Pos = 0x4
	// Bit mask of AWDF field.
	DFSDM_DFSDM0_ISR_AWDF_Msk = 0x10
	// Bit AWDF.
	DFSDM_DFSDM0_ISR_AWDF = 0x10
	// Position of JCIP field.
	DFSDM_DFSDM0_ISR_JCIP_Pos = 0xd
	// Bit mask of JCIP field.
	DFSDM_DFSDM0_ISR_JCIP_Msk = 0x2000
	// Bit JCIP.
	DFSDM_DFSDM0_ISR_JCIP = 0x2000
	// Position of RCIP field.
	DFSDM_DFSDM0_ISR_RCIP_Pos = 0xe
	// Bit mask of RCIP field.
	DFSDM_DFSDM0_ISR_RCIP_Msk = 0x4000
	// Bit RCIP.
	DFSDM_DFSDM0_ISR_RCIP = 0x4000
	// Position of CKABF field.
	DFSDM_DFSDM0_ISR_CKABF_Pos = 0x10
	// Bit mask of CKABF field.
	DFSDM_DFSDM0_ISR_CKABF_Msk = 0xff0000
	// Position of SCDF field.
	DFSDM_DFSDM0_ISR_SCDF_Pos = 0x18
	// Bit mask of SCDF field.
	DFSDM_DFSDM0_ISR_SCDF_Msk = 0xff000000

	// DFSDM1_ISR: DFSDM interrupt and status register
	// Position of JEOCF field.
	DFSDM_DFSDM1_ISR_JEOCF_Pos = 0x0
	// Bit mask of JEOCF field.
	DFSDM_DFSDM1_ISR_JEOCF_Msk = 0x1
	// Bit JEOCF.
	DFSDM_DFSDM1_ISR_JEOCF = 0x1
	// Position of REOCF field.
	DFSDM_DFSDM1_ISR_REOCF_Pos = 0x1
	// Bit mask of REOCF field.
	DFSDM_DFSDM1_ISR_REOCF_Msk = 0x2
	// Bit REOCF.
	DFSDM_DFSDM1_ISR_REOCF = 0x2
	// Position of JOVRF field.
	DFSDM_DFSDM1_ISR_JOVRF_Pos = 0x2
	// Bit mask of JOVRF field.
	DFSDM_DFSDM1_ISR_JOVRF_Msk = 0x4
	// Bit JOVRF.
	DFSDM_DFSDM1_ISR_JOVRF = 0x4
	// Position of ROVRF field.
	DFSDM_DFSDM1_ISR_ROVRF_Pos = 0x3
	// Bit mask of ROVRF field.
	DFSDM_DFSDM1_ISR_ROVRF_Msk = 0x8
	// Bit ROVRF.
	DFSDM_DFSDM1_ISR_ROVRF = 0x8
	// Position of AWDF field.
	DFSDM_DFSDM1_ISR_AWDF_Pos = 0x4
	// Bit mask of AWDF field.
	DFSDM_DFSDM1_ISR_AWDF_Msk = 0x10
	// Bit AWDF.
	DFSDM_DFSDM1_ISR_AWDF = 0x10
	// Position of JCIP field.
	DFSDM_DFSDM1_ISR_JCIP_Pos = 0xd
	// Bit mask of JCIP field.
	DFSDM_DFSDM1_ISR_JCIP_Msk = 0x2000
	// Bit JCIP.
	DFSDM_DFSDM1_ISR_JCIP = 0x2000
	// Position of RCIP field.
	DFSDM_DFSDM1_ISR_RCIP_Pos = 0xe
	// Bit mask of RCIP field.
	DFSDM_DFSDM1_ISR_RCIP_Msk = 0x4000
	// Bit RCIP.
	DFSDM_DFSDM1_ISR_RCIP = 0x4000
	// Position of CKABF field.
	DFSDM_DFSDM1_ISR_CKABF_Pos = 0x10
	// Bit mask of CKABF field.
	DFSDM_DFSDM1_ISR_CKABF_Msk = 0xff0000
	// Position of SCDF field.
	DFSDM_DFSDM1_ISR_SCDF_Pos = 0x18
	// Bit mask of SCDF field.
	DFSDM_DFSDM1_ISR_SCDF_Msk = 0xff000000

	// DFSDM2_ISR: DFSDM interrupt and status register
	// Position of JEOCF field.
	DFSDM_DFSDM2_ISR_JEOCF_Pos = 0x0
	// Bit mask of JEOCF field.
	DFSDM_DFSDM2_ISR_JEOCF_Msk = 0x1
	// Bit JEOCF.
	DFSDM_DFSDM2_ISR_JEOCF = 0x1
	// Position of REOCF field.
	DFSDM_DFSDM2_ISR_REOCF_Pos = 0x1
	// Bit mask of REOCF field.
	DFSDM_DFSDM2_ISR_REOCF_Msk = 0x2
	// Bit REOCF.
	DFSDM_DFSDM2_ISR_REOCF = 0x2
	// Position of JOVRF field.
	DFSDM_DFSDM2_ISR_JOVRF_Pos = 0x2
	// Bit mask of JOVRF field.
	DFSDM_DFSDM2_ISR_JOVRF_Msk = 0x4
	// Bit JOVRF.
	DFSDM_DFSDM2_ISR_JOVRF = 0x4
	// Position of ROVRF field.
	DFSDM_DFSDM2_ISR_ROVRF_Pos = 0x3
	// Bit mask of ROVRF field.
	DFSDM_DFSDM2_ISR_ROVRF_Msk = 0x8
	// Bit ROVRF.
	DFSDM_DFSDM2_ISR_ROVRF = 0x8
	// Position of AWDF field.
	DFSDM_DFSDM2_ISR_AWDF_Pos = 0x4
	// Bit mask of AWDF field.
	DFSDM_DFSDM2_ISR_AWDF_Msk = 0x10
	// Bit AWDF.
	DFSDM_DFSDM2_ISR_AWDF = 0x10
	// Position of JCIP field.
	DFSDM_DFSDM2_ISR_JCIP_Pos = 0xd
	// Bit mask of JCIP field.
	DFSDM_DFSDM2_ISR_JCIP_Msk = 0x2000
	// Bit JCIP.
	DFSDM_DFSDM2_ISR_JCIP = 0x2000
	// Position of RCIP field.
	DFSDM_DFSDM2_ISR_RCIP_Pos = 0xe
	// Bit mask of RCIP field.
	DFSDM_DFSDM2_ISR_RCIP_Msk = 0x4000
	// Bit RCIP.
	DFSDM_DFSDM2_ISR_RCIP = 0x4000
	// Position of CKABF field.
	DFSDM_DFSDM2_ISR_CKABF_Pos = 0x10
	// Bit mask of CKABF field.
	DFSDM_DFSDM2_ISR_CKABF_Msk = 0xff0000
	// Position of SCDF field.
	DFSDM_DFSDM2_ISR_SCDF_Pos = 0x18
	// Bit mask of SCDF field.
	DFSDM_DFSDM2_ISR_SCDF_Msk = 0xff000000

	// DFSDM3_ISR: DFSDM interrupt and status register
	// Position of JEOCF field.
	DFSDM_DFSDM3_ISR_JEOCF_Pos = 0x0
	// Bit mask of JEOCF field.
	DFSDM_DFSDM3_ISR_JEOCF_Msk = 0x1
	// Bit JEOCF.
	DFSDM_DFSDM3_ISR_JEOCF = 0x1
	// Position of REOCF field.
	DFSDM_DFSDM3_ISR_REOCF_Pos = 0x1
	// Bit mask of REOCF field.
	DFSDM_DFSDM3_ISR_REOCF_Msk = 0x2
	// Bit REOCF.
	DFSDM_DFSDM3_ISR_REOCF = 0x2
	// Position of JOVRF field.
	DFSDM_DFSDM3_ISR_JOVRF_Pos = 0x2
	// Bit mask of JOVRF field.
	DFSDM_DFSDM3_ISR_JOVRF_Msk = 0x4
	// Bit JOVRF.
	DFSDM_DFSDM3_ISR_JOVRF = 0x4
	// Position of ROVRF field.
	DFSDM_DFSDM3_ISR_ROVRF_Pos = 0x3
	// Bit mask of ROVRF field.
	DFSDM_DFSDM3_ISR_ROVRF_Msk = 0x8
	// Bit ROVRF.
	DFSDM_DFSDM3_ISR_ROVRF = 0x8
	// Position of AWDF field.
	DFSDM_DFSDM3_ISR_AWDF_Pos = 0x4
	// Bit mask of AWDF field.
	DFSDM_DFSDM3_ISR_AWDF_Msk = 0x10
	// Bit AWDF.
	DFSDM_DFSDM3_ISR_AWDF = 0x10
	// Position of JCIP field.
	DFSDM_DFSDM3_ISR_JCIP_Pos = 0xd
	// Bit mask of JCIP field.
	DFSDM_DFSDM3_ISR_JCIP_Msk = 0x2000
	// Bit JCIP.
	DFSDM_DFSDM3_ISR_JCIP = 0x2000
	// Position of RCIP field.
	DFSDM_DFSDM3_ISR_RCIP_Pos = 0xe
	// Bit mask of RCIP field.
	DFSDM_DFSDM3_ISR_RCIP_Msk = 0x4000
	// Bit RCIP.
	DFSDM_DFSDM3_ISR_RCIP = 0x4000
	// Position of CKABF field.
	DFSDM_DFSDM3_ISR_CKABF_Pos = 0x10
	// Bit mask of CKABF field.
	DFSDM_DFSDM3_ISR_CKABF_Msk = 0xff0000
	// Position of SCDF field.
	DFSDM_DFSDM3_ISR_SCDF_Pos = 0x18
	// Bit mask of SCDF field.
	DFSDM_DFSDM3_ISR_SCDF_Msk = 0xff000000

	// DFSDM0_ICR: DFSDM interrupt flag clear register
	// Position of CLRJOVRF field.
	DFSDM_DFSDM0_ICR_CLRJOVRF_Pos = 0x2
	// Bit mask of CLRJOVRF field.
	DFSDM_DFSDM0_ICR_CLRJOVRF_Msk = 0x4
	// Bit CLRJOVRF.
	DFSDM_DFSDM0_ICR_CLRJOVRF = 0x4
	// Position of CLRROVRF field.
	DFSDM_DFSDM0_ICR_CLRROVRF_Pos = 0x3
	// Bit mask of CLRROVRF field.
	DFSDM_DFSDM0_ICR_CLRROVRF_Msk = 0x8
	// Bit CLRROVRF.
	DFSDM_DFSDM0_ICR_CLRROVRF = 0x8
	// Position of CLRCKABF field.
	DFSDM_DFSDM0_ICR_CLRCKABF_Pos = 0x10
	// Bit mask of CLRCKABF field.
	DFSDM_DFSDM0_ICR_CLRCKABF_Msk = 0xff0000
	// Position of CLRSCDF field.
	DFSDM_DFSDM0_ICR_CLRSCDF_Pos = 0x18
	// Bit mask of CLRSCDF field.
	DFSDM_DFSDM0_ICR_CLRSCDF_Msk = 0xff000000

	// DFSDM1_ICR: DFSDM interrupt flag clear register
	// Position of CLRJOVRF field.
	DFSDM_DFSDM1_ICR_CLRJOVRF_Pos = 0x2
	// Bit mask of CLRJOVRF field.
	DFSDM_DFSDM1_ICR_CLRJOVRF_Msk = 0x4
	// Bit CLRJOVRF.
	DFSDM_DFSDM1_ICR_CLRJOVRF = 0x4
	// Position of CLRROVRF field.
	DFSDM_DFSDM1_ICR_CLRROVRF_Pos = 0x3
	// Bit mask of CLRROVRF field.
	DFSDM_DFSDM1_ICR_CLRROVRF_Msk = 0x8
	// Bit CLRROVRF.
	DFSDM_DFSDM1_ICR_CLRROVRF = 0x8
	// Position of CLRCKABF field.
	DFSDM_DFSDM1_ICR_CLRCKABF_Pos = 0x10
	// Bit mask of CLRCKABF field.
	DFSDM_DFSDM1_ICR_CLRCKABF_Msk = 0xff0000
	// Position of CLRSCDF field.
	DFSDM_DFSDM1_ICR_CLRSCDF_Pos = 0x18
	// Bit mask of CLRSCDF field.
	DFSDM_DFSDM1_ICR_CLRSCDF_Msk = 0xff000000

	// DFSDM2_ICR: DFSDM interrupt flag clear register
	// Position of CLRJOVRF field.
	DFSDM_DFSDM2_ICR_CLRJOVRF_Pos = 0x2
	// Bit mask of CLRJOVRF field.
	DFSDM_DFSDM2_ICR_CLRJOVRF_Msk = 0x4
	// Bit CLRJOVRF.
	DFSDM_DFSDM2_ICR_CLRJOVRF = 0x4
	// Position of CLRROVRF field.
	DFSDM_DFSDM2_ICR_CLRROVRF_Pos = 0x3
	// Bit mask of CLRROVRF field.
	DFSDM_DFSDM2_ICR_CLRROVRF_Msk = 0x8
	// Bit CLRROVRF.
	DFSDM_DFSDM2_ICR_CLRROVRF = 0x8
	// Position of CLRCKABF field.
	DFSDM_DFSDM2_ICR_CLRCKABF_Pos = 0x10
	// Bit mask of CLRCKABF field.
	DFSDM_DFSDM2_ICR_CLRCKABF_Msk = 0xff0000
	// Position of CLRSCDF field.
	DFSDM_DFSDM2_ICR_CLRSCDF_Pos = 0x18
	// Bit mask of CLRSCDF field.
	DFSDM_DFSDM2_ICR_CLRSCDF_Msk = 0xff000000

	// DFSDM3_ICR: DFSDM interrupt flag clear register
	// Position of CLRJOVRF field.
	DFSDM_DFSDM3_ICR_CLRJOVRF_Pos = 0x2
	// Bit mask of CLRJOVRF field.
	DFSDM_DFSDM3_ICR_CLRJOVRF_Msk = 0x4
	// Bit CLRJOVRF.
	DFSDM_DFSDM3_ICR_CLRJOVRF = 0x4
	// Position of CLRROVRF field.
	DFSDM_DFSDM3_ICR_CLRROVRF_Pos = 0x3
	// Bit mask of CLRROVRF field.
	DFSDM_DFSDM3_ICR_CLRROVRF_Msk = 0x8
	// Bit CLRROVRF.
	DFSDM_DFSDM3_ICR_CLRROVRF = 0x8
	// Position of CLRCKABF field.
	DFSDM_DFSDM3_ICR_CLRCKABF_Pos = 0x10
	// Bit mask of CLRCKABF field.
	DFSDM_DFSDM3_ICR_CLRCKABF_Msk = 0xff0000
	// Position of CLRSCDF field.
	DFSDM_DFSDM3_ICR_CLRSCDF_Pos = 0x18
	// Bit mask of CLRSCDF field.
	DFSDM_DFSDM3_ICR_CLRSCDF_Msk = 0xff000000

	// DFSDM0_JCHGR: DFSDM injected channel group selection register
	// Position of JCHG field.
	DFSDM_DFSDM0_JCHGR_JCHG_Pos = 0x0
	// Bit mask of JCHG field.
	DFSDM_DFSDM0_JCHGR_JCHG_Msk = 0xff

	// DFSDM1_JCHGR: DFSDM injected channel group selection register
	// Position of JCHG field.
	DFSDM_DFSDM1_JCHGR_JCHG_Pos = 0x0
	// Bit mask of JCHG field.
	DFSDM_DFSDM1_JCHGR_JCHG_Msk = 0xff

	// DFSDM2_JCHGR: DFSDM injected channel group selection register
	// Position of JCHG field.
	DFSDM_DFSDM2_JCHGR_JCHG_Pos = 0x0
	// Bit mask of JCHG field.
	DFSDM_DFSDM2_JCHGR_JCHG_Msk = 0xff

	// DFSDM3_JCHGR: DFSDM injected channel group selection register
	// Position of JCHG field.
	DFSDM_DFSDM3_JCHGR_JCHG_Pos = 0x0
	// Bit mask of JCHG field.
	DFSDM_DFSDM3_JCHGR_JCHG_Msk = 0xff

	// DFSDM0_FCR: DFSDM filter control register
	// Position of IOSR field.
	DFSDM_DFSDM0_FCR_IOSR_Pos = 0x0
	// Bit mask of IOSR field.
	DFSDM_DFSDM0_FCR_IOSR_Msk = 0xff
	// Position of FOSR field.
	DFSDM_DFSDM0_FCR_FOSR_Pos = 0x10
	// Bit mask of FOSR field.
	DFSDM_DFSDM0_FCR_FOSR_Msk = 0x3ff0000
	// Position of FORD field.
	DFSDM_DFSDM0_FCR_FORD_Pos = 0x1d
	// Bit mask of FORD field.
	DFSDM_DFSDM0_FCR_FORD_Msk = 0xe0000000

	// DFSDM1_FCR: DFSDM filter control register
	// Position of IOSR field.
	DFSDM_DFSDM1_FCR_IOSR_Pos = 0x0
	// Bit mask of IOSR field.
	DFSDM_DFSDM1_FCR_IOSR_Msk = 0xff
	// Position of FOSR field.
	DFSDM_DFSDM1_FCR_FOSR_Pos = 0x10
	// Bit mask of FOSR field.
	DFSDM_DFSDM1_FCR_FOSR_Msk = 0x3ff0000
	// Position of FORD field.
	DFSDM_DFSDM1_FCR_FORD_Pos = 0x1d
	// Bit mask of FORD field.
	DFSDM_DFSDM1_FCR_FORD_Msk = 0xe0000000

	// DFSDM2_FCR: DFSDM filter control register
	// Position of IOSR field.
	DFSDM_DFSDM2_FCR_IOSR_Pos = 0x0
	// Bit mask of IOSR field.
	DFSDM_DFSDM2_FCR_IOSR_Msk = 0xff
	// Position of FOSR field.
	DFSDM_DFSDM2_FCR_FOSR_Pos = 0x10
	// Bit mask of FOSR field.
	DFSDM_DFSDM2_FCR_FOSR_Msk = 0x3ff0000
	// Position of FORD field.
	DFSDM_DFSDM2_FCR_FORD_Pos = 0x1d
	// Bit mask of FORD field.
	DFSDM_DFSDM2_FCR_FORD_Msk = 0xe0000000

	// DFSDM3_FCR: DFSDM filter control register
	// Position of IOSR field.
	DFSDM_DFSDM3_FCR_IOSR_Pos = 0x0
	// Bit mask of IOSR field.
	DFSDM_DFSDM3_FCR_IOSR_Msk = 0xff
	// Position of FOSR field.
	DFSDM_DFSDM3_FCR_FOSR_Pos = 0x10
	// Bit mask of FOSR field.
	DFSDM_DFSDM3_FCR_FOSR_Msk = 0x3ff0000
	// Position of FORD field.
	DFSDM_DFSDM3_FCR_FORD_Pos = 0x1d
	// Bit mask of FORD field.
	DFSDM_DFSDM3_FCR_FORD_Msk = 0xe0000000

	// DFSDM0_JDATAR: DFSDM data register for injected group
	// Position of JDATACH field.
	DFSDM_DFSDM0_JDATAR_JDATACH_Pos = 0x0
	// Bit mask of JDATACH field.
	DFSDM_DFSDM0_JDATAR_JDATACH_Msk = 0x7
	// Position of JDATA field.
	DFSDM_DFSDM0_JDATAR_JDATA_Pos = 0x8
	// Bit mask of JDATA field.
	DFSDM_DFSDM0_JDATAR_JDATA_Msk = 0xffffff00

	// DFSDM1_JDATAR: DFSDM data register for injected group
	// Position of JDATACH field.
	DFSDM_DFSDM1_JDATAR_JDATACH_Pos = 0x0
	// Bit mask of JDATACH field.
	DFSDM_DFSDM1_JDATAR_JDATACH_Msk = 0x7
	// Position of JDATA field.
	DFSDM_DFSDM1_JDATAR_JDATA_Pos = 0x8
	// Bit mask of JDATA field.
	DFSDM_DFSDM1_JDATAR_JDATA_Msk = 0xffffff00

	// DFSDM2_JDATAR: DFSDM data register for injected group
	// Position of JDATACH field.
	DFSDM_DFSDM2_JDATAR_JDATACH_Pos = 0x0
	// Bit mask of JDATACH field.
	DFSDM_DFSDM2_JDATAR_JDATACH_Msk = 0x7
	// Position of JDATA field.
	DFSDM_DFSDM2_JDATAR_JDATA_Pos = 0x8
	// Bit mask of JDATA field.
	DFSDM_DFSDM2_JDATAR_JDATA_Msk = 0xffffff00

	// DFSDM3_JDATAR: DFSDM data register for injected group
	// Position of JDATACH field.
	DFSDM_DFSDM3_JDATAR_JDATACH_Pos = 0x0
	// Bit mask of JDATACH field.
	DFSDM_DFSDM3_JDATAR_JDATACH_Msk = 0x7
	// Position of JDATA field.
	DFSDM_DFSDM3_JDATAR_JDATA_Pos = 0x8
	// Bit mask of JDATA field.
	DFSDM_DFSDM3_JDATAR_JDATA_Msk = 0xffffff00

	// DFSDM0_RDATAR: DFSDM data register for the regular channel
	// Position of RDATACH field.
	DFSDM_DFSDM0_RDATAR_RDATACH_Pos = 0x0
	// Bit mask of RDATACH field.
	DFSDM_DFSDM0_RDATAR_RDATACH_Msk = 0x7
	// Position of RPEND field.
	DFSDM_DFSDM0_RDATAR_RPEND_Pos = 0x4
	// Bit mask of RPEND field.
	DFSDM_DFSDM0_RDATAR_RPEND_Msk = 0x10
	// Bit RPEND.
	DFSDM_DFSDM0_RDATAR_RPEND = 0x10
	// Position of RDATA field.
	DFSDM_DFSDM0_RDATAR_RDATA_Pos = 0x8
	// Bit mask of RDATA field.
	DFSDM_DFSDM0_RDATAR_RDATA_Msk = 0xffffff00

	// DFSDM1_RDATAR: DFSDM data register for the regular channel
	// Position of RDATACH field.
	DFSDM_DFSDM1_RDATAR_RDATACH_Pos = 0x0
	// Bit mask of RDATACH field.
	DFSDM_DFSDM1_RDATAR_RDATACH_Msk = 0x7
	// Position of RPEND field.
	DFSDM_DFSDM1_RDATAR_RPEND_Pos = 0x4
	// Bit mask of RPEND field.
	DFSDM_DFSDM1_RDATAR_RPEND_Msk = 0x10
	// Bit RPEND.
	DFSDM_DFSDM1_RDATAR_RPEND = 0x10
	// Position of RDATA field.
	DFSDM_DFSDM1_RDATAR_RDATA_Pos = 0x8
	// Bit mask of RDATA field.
	DFSDM_DFSDM1_RDATAR_RDATA_Msk = 0xffffff00

	// DFSDM2_RDATAR: DFSDM data register for the regular channel
	// Position of RDATACH field.
	DFSDM_DFSDM2_RDATAR_RDATACH_Pos = 0x0
	// Bit mask of RDATACH field.
	DFSDM_DFSDM2_RDATAR_RDATACH_Msk = 0x7
	// Position of RPEND field.
	DFSDM_DFSDM2_RDATAR_RPEND_Pos = 0x4
	// Bit mask of RPEND field.
	DFSDM_DFSDM2_RDATAR_RPEND_Msk = 0x10
	// Bit RPEND.
	DFSDM_DFSDM2_RDATAR_RPEND = 0x10
	// Position of RDATA field.
	DFSDM_DFSDM2_RDATAR_RDATA_Pos = 0x8
	// Bit mask of RDATA field.
	DFSDM_DFSDM2_RDATAR_RDATA_Msk = 0xffffff00

	// DFSDM3_RDATAR: DFSDM data register for the regular channel
	// Position of RDATACH field.
	DFSDM_DFSDM3_RDATAR_RDATACH_Pos = 0x0
	// Bit mask of RDATACH field.
	DFSDM_DFSDM3_RDATAR_RDATACH_Msk = 0x7
	// Position of RPEND field.
	DFSDM_DFSDM3_RDATAR_RPEND_Pos = 0x4
	// Bit mask of RPEND field.
	DFSDM_DFSDM3_RDATAR_RPEND_Msk = 0x10
	// Bit RPEND.
	DFSDM_DFSDM3_RDATAR_RPEND = 0x10
	// Position of RDATA field.
	DFSDM_DFSDM3_RDATAR_RDATA_Pos = 0x8
	// Bit mask of RDATA field.
	DFSDM_DFSDM3_RDATAR_RDATA_Msk = 0xffffff00

	// DFSDM0_AWHTR: DFSDM analog watchdog high threshold register
	// Position of BKAWH field.
	DFSDM_DFSDM0_AWHTR_BKAWH_Pos = 0x0
	// Bit mask of BKAWH field.
	DFSDM_DFSDM0_AWHTR_BKAWH_Msk = 0xf
	// Position of AWHT field.
	DFSDM_DFSDM0_AWHTR_AWHT_Pos = 0x8
	// Bit mask of AWHT field.
	DFSDM_DFSDM0_AWHTR_AWHT_Msk = 0xffffff00

	// DFSDM1_AWHTR: DFSDM analog watchdog high threshold register
	// Position of BKAWH field.
	DFSDM_DFSDM1_AWHTR_BKAWH_Pos = 0x0
	// Bit mask of BKAWH field.
	DFSDM_DFSDM1_AWHTR_BKAWH_Msk = 0xf
	// Position of AWHT field.
	DFSDM_DFSDM1_AWHTR_AWHT_Pos = 0x8
	// Bit mask of AWHT field.
	DFSDM_DFSDM1_AWHTR_AWHT_Msk = 0xffffff00

	// DFSDM2_AWHTR: DFSDM analog watchdog high threshold register
	// Position of BKAWH field.
	DFSDM_DFSDM2_AWHTR_BKAWH_Pos = 0x0
	// Bit mask of BKAWH field.
	DFSDM_DFSDM2_AWHTR_BKAWH_Msk = 0xf
	// Position of AWHT field.
	DFSDM_DFSDM2_AWHTR_AWHT_Pos = 0x8
	// Bit mask of AWHT field.
	DFSDM_DFSDM2_AWHTR_AWHT_Msk = 0xffffff00

	// DFSDM3_AWHTR: DFSDM analog watchdog high threshold register
	// Position of BKAWH field.
	DFSDM_DFSDM3_AWHTR_BKAWH_Pos = 0x0
	// Bit mask of BKAWH field.
	DFSDM_DFSDM3_AWHTR_BKAWH_Msk = 0xf
	// Position of AWHT field.
	DFSDM_DFSDM3_AWHTR_AWHT_Pos = 0x8
	// Bit mask of AWHT field.
	DFSDM_DFSDM3_AWHTR_AWHT_Msk = 0xffffff00

	// DFSDM0_AWLTR: DFSDM analog watchdog low threshold register
	// Position of BKAWL field.
	DFSDM_DFSDM0_AWLTR_BKAWL_Pos = 0x0
	// Bit mask of BKAWL field.
	DFSDM_DFSDM0_AWLTR_BKAWL_Msk = 0xf
	// Position of AWLT field.
	DFSDM_DFSDM0_AWLTR_AWLT_Pos = 0x8
	// Bit mask of AWLT field.
	DFSDM_DFSDM0_AWLTR_AWLT_Msk = 0xffffff00

	// DFSDM1_AWLTR: DFSDM analog watchdog low threshold register
	// Position of BKAWL field.
	DFSDM_DFSDM1_AWLTR_BKAWL_Pos = 0x0
	// Bit mask of BKAWL field.
	DFSDM_DFSDM1_AWLTR_BKAWL_Msk = 0xf
	// Position of AWLT field.
	DFSDM_DFSDM1_AWLTR_AWLT_Pos = 0x8
	// Bit mask of AWLT field.
	DFSDM_DFSDM1_AWLTR_AWLT_Msk = 0xffffff00

	// DFSDM2_AWLTR: DFSDM analog watchdog low threshold register
	// Position of BKAWL field.
	DFSDM_DFSDM2_AWLTR_BKAWL_Pos = 0x0
	// Bit mask of BKAWL field.
	DFSDM_DFSDM2_AWLTR_BKAWL_Msk = 0xf
	// Position of AWLT field.
	DFSDM_DFSDM2_AWLTR_AWLT_Pos = 0x8
	// Bit mask of AWLT field.
	DFSDM_DFSDM2_AWLTR_AWLT_Msk = 0xffffff00

	// DFSDM3_AWLTR: DFSDM analog watchdog low threshold register
	// Position of BKAWL field.
	DFSDM_DFSDM3_AWLTR_BKAWL_Pos = 0x0
	// Bit mask of BKAWL field.
	DFSDM_DFSDM3_AWLTR_BKAWL_Msk = 0xf
	// Position of AWLT field.
	DFSDM_DFSDM3_AWLTR_AWLT_Pos = 0x8
	// Bit mask of AWLT field.
	DFSDM_DFSDM3_AWLTR_AWLT_Msk = 0xffffff00

	// DFSDM0_AWSR: DFSDM analog watchdog status register
	// Position of AWLTF field.
	DFSDM_DFSDM0_AWSR_AWLTF_Pos = 0x0
	// Bit mask of AWLTF field.
	DFSDM_DFSDM0_AWSR_AWLTF_Msk = 0xff
	// Position of AWHTF field.
	DFSDM_DFSDM0_AWSR_AWHTF_Pos = 0x8
	// Bit mask of AWHTF field.
	DFSDM_DFSDM0_AWSR_AWHTF_Msk = 0xff00

	// DFSDM1_AWSR: DFSDM analog watchdog status register
	// Position of AWLTF field.
	DFSDM_DFSDM1_AWSR_AWLTF_Pos = 0x0
	// Bit mask of AWLTF field.
	DFSDM_DFSDM1_AWSR_AWLTF_Msk = 0xff
	// Position of AWHTF field.
	DFSDM_DFSDM1_AWSR_AWHTF_Pos = 0x8
	// Bit mask of AWHTF field.
	DFSDM_DFSDM1_AWSR_AWHTF_Msk = 0xff00

	// DFSDM2_AWSR: DFSDM analog watchdog status register
	// Position of AWLTF field.
	DFSDM_DFSDM2_AWSR_AWLTF_Pos = 0x0
	// Bit mask of AWLTF field.
	DFSDM_DFSDM2_AWSR_AWLTF_Msk = 0xff
	// Position of AWHTF field.
	DFSDM_DFSDM2_AWSR_AWHTF_Pos = 0x8
	// Bit mask of AWHTF field.
	DFSDM_DFSDM2_AWSR_AWHTF_Msk = 0xff00

	// DFSDM3_AWSR: DFSDM analog watchdog status register
	// Position of AWLTF field.
	DFSDM_DFSDM3_AWSR_AWLTF_Pos = 0x0
	// Bit mask of AWLTF field.
	DFSDM_DFSDM3_AWSR_AWLTF_Msk = 0xff
	// Position of AWHTF field.
	DFSDM_DFSDM3_AWSR_AWHTF_Pos = 0x8
	// Bit mask of AWHTF field.
	DFSDM_DFSDM3_AWSR_AWHTF_Msk = 0xff00

	// DFSDM0_AWCFR: DFSDM analog watchdog clear flag register
	// Position of CLRAWLTF field.
	DFSDM_DFSDM0_AWCFR_CLRAWLTF_Pos = 0x0
	// Bit mask of CLRAWLTF field.
	DFSDM_DFSDM0_AWCFR_CLRAWLTF_Msk = 0xff
	// Position of CLRAWHTF field.
	DFSDM_DFSDM0_AWCFR_CLRAWHTF_Pos = 0x8
	// Bit mask of CLRAWHTF field.
	DFSDM_DFSDM0_AWCFR_CLRAWHTF_Msk = 0xff00

	// DFSDM1_AWCFR: DFSDM analog watchdog clear flag register
	// Position of CLRAWLTF field.
	DFSDM_DFSDM1_AWCFR_CLRAWLTF_Pos = 0x0
	// Bit mask of CLRAWLTF field.
	DFSDM_DFSDM1_AWCFR_CLRAWLTF_Msk = 0xff
	// Position of CLRAWHTF field.
	DFSDM_DFSDM1_AWCFR_CLRAWHTF_Pos = 0x8
	// Bit mask of CLRAWHTF field.
	DFSDM_DFSDM1_AWCFR_CLRAWHTF_Msk = 0xff00

	// DFSDM2_AWCFR: DFSDM analog watchdog clear flag register
	// Position of CLRAWLTF field.
	DFSDM_DFSDM2_AWCFR_CLRAWLTF_Pos = 0x0
	// Bit mask of CLRAWLTF field.
	DFSDM_DFSDM2_AWCFR_CLRAWLTF_Msk = 0xff
	// Position of CLRAWHTF field.
	DFSDM_DFSDM2_AWCFR_CLRAWHTF_Pos = 0x8
	// Bit mask of CLRAWHTF field.
	DFSDM_DFSDM2_AWCFR_CLRAWHTF_Msk = 0xff00

	// DFSDM3_AWCFR: DFSDM analog watchdog clear flag register
	// Position of CLRAWLTF field.
	DFSDM_DFSDM3_AWCFR_CLRAWLTF_Pos = 0x0
	// Bit mask of CLRAWLTF field.
	DFSDM_DFSDM3_AWCFR_CLRAWLTF_Msk = 0xff
	// Position of CLRAWHTF field.
	DFSDM_DFSDM3_AWCFR_CLRAWHTF_Pos = 0x8
	// Bit mask of CLRAWHTF field.
	DFSDM_DFSDM3_AWCFR_CLRAWHTF_Msk = 0xff00

	// DFSDM0_EXMAX: DFSDM Extremes detector maximum register
	// Position of EXMAXCH field.
	DFSDM_DFSDM0_EXMAX_EXMAXCH_Pos = 0x0
	// Bit mask of EXMAXCH field.
	DFSDM_DFSDM0_EXMAX_EXMAXCH_Msk = 0x7
	// Position of EXMAX field.
	DFSDM_DFSDM0_EXMAX_EXMAX_Pos = 0x8
	// Bit mask of EXMAX field.
	DFSDM_DFSDM0_EXMAX_EXMAX_Msk = 0xffffff00

	// DFSDM1_EXMAX: DFSDM Extremes detector maximum register
	// Position of EXMAXCH field.
	DFSDM_DFSDM1_EXMAX_EXMAXCH_Pos = 0x0
	// Bit mask of EXMAXCH field.
	DFSDM_DFSDM1_EXMAX_EXMAXCH_Msk = 0x7
	// Position of EXMAX field.
	DFSDM_DFSDM1_EXMAX_EXMAX_Pos = 0x8
	// Bit mask of EXMAX field.
	DFSDM_DFSDM1_EXMAX_EXMAX_Msk = 0xffffff00

	// DFSDM2_EXMAX: DFSDM Extremes detector maximum register
	// Position of EXMAXCH field.
	DFSDM_DFSDM2_EXMAX_EXMAXCH_Pos = 0x0
	// Bit mask of EXMAXCH field.
	DFSDM_DFSDM2_EXMAX_EXMAXCH_Msk = 0x7
	// Position of EXMAX field.
	DFSDM_DFSDM2_EXMAX_EXMAX_Pos = 0x8
	// Bit mask of EXMAX field.
	DFSDM_DFSDM2_EXMAX_EXMAX_Msk = 0xffffff00

	// DFSDM3_EXMAX: DFSDM Extremes detector maximum register
	// Position of EXMAXCH field.
	DFSDM_DFSDM3_EXMAX_EXMAXCH_Pos = 0x0
	// Bit mask of EXMAXCH field.
	DFSDM_DFSDM3_EXMAX_EXMAXCH_Msk = 0x7
	// Position of EXMAX field.
	DFSDM_DFSDM3_EXMAX_EXMAX_Pos = 0x8
	// Bit mask of EXMAX field.
	DFSDM_DFSDM3_EXMAX_EXMAX_Msk = 0xffffff00

	// DFSDM0_EXMIN: DFSDM Extremes detector minimum register
	// Position of EXMINCH field.
	DFSDM_DFSDM0_EXMIN_EXMINCH_Pos = 0x0
	// Bit mask of EXMINCH field.
	DFSDM_DFSDM0_EXMIN_EXMINCH_Msk = 0x7
	// Position of EXMIN field.
	DFSDM_DFSDM0_EXMIN_EXMIN_Pos = 0x8
	// Bit mask of EXMIN field.
	DFSDM_DFSDM0_EXMIN_EXMIN_Msk = 0xffffff00

	// DFSDM1_EXMIN: DFSDM Extremes detector minimum register
	// Position of EXMINCH field.
	DFSDM_DFSDM1_EXMIN_EXMINCH_Pos = 0x0
	// Bit mask of EXMINCH field.
	DFSDM_DFSDM1_EXMIN_EXMINCH_Msk = 0x7
	// Position of EXMIN field.
	DFSDM_DFSDM1_EXMIN_EXMIN_Pos = 0x8
	// Bit mask of EXMIN field.
	DFSDM_DFSDM1_EXMIN_EXMIN_Msk = 0xffffff00

	// DFSDM2_EXMIN: DFSDM Extremes detector minimum register
	// Position of EXMINCH field.
	DFSDM_DFSDM2_EXMIN_EXMINCH_Pos = 0x0
	// Bit mask of EXMINCH field.
	DFSDM_DFSDM2_EXMIN_EXMINCH_Msk = 0x7
	// Position of EXMIN field.
	DFSDM_DFSDM2_EXMIN_EXMIN_Pos = 0x8
	// Bit mask of EXMIN field.
	DFSDM_DFSDM2_EXMIN_EXMIN_Msk = 0xffffff00

	// DFSDM3_EXMIN: DFSDM Extremes detector minimum register
	// Position of EXMINCH field.
	DFSDM_DFSDM3_EXMIN_EXMINCH_Pos = 0x0
	// Bit mask of EXMINCH field.
	DFSDM_DFSDM3_EXMIN_EXMINCH_Msk = 0x7
	// Position of EXMIN field.
	DFSDM_DFSDM3_EXMIN_EXMIN_Pos = 0x8
	// Bit mask of EXMIN field.
	DFSDM_DFSDM3_EXMIN_EXMIN_Msk = 0xffffff00

	// DFSDM0_CNVTIMR: DFSDM conversion timer register
	// Position of CNVCNT field.
	DFSDM_DFSDM0_CNVTIMR_CNVCNT_Pos = 0x4
	// Bit mask of CNVCNT field.
	DFSDM_DFSDM0_CNVTIMR_CNVCNT_Msk = 0xfffffff0

	// DFSDM1_CNVTIMR: DFSDM conversion timer register
	// Position of CNVCNT field.
	DFSDM_DFSDM1_CNVTIMR_CNVCNT_Pos = 0x4
	// Bit mask of CNVCNT field.
	DFSDM_DFSDM1_CNVTIMR_CNVCNT_Msk = 0xfffffff0

	// DFSDM2_CNVTIMR: DFSDM conversion timer register
	// Position of CNVCNT field.
	DFSDM_DFSDM2_CNVTIMR_CNVCNT_Pos = 0x4
	// Bit mask of CNVCNT field.
	DFSDM_DFSDM2_CNVTIMR_CNVCNT_Msk = 0xfffffff0

	// DFSDM3_CNVTIMR: DFSDM conversion timer register
	// Position of CNVCNT field.
	DFSDM_DFSDM3_CNVTIMR_CNVCNT_Pos = 0x4
	// Bit mask of CNVCNT field.
	DFSDM_DFSDM3_CNVTIMR_CNVCNT_Msk = 0xfffffff0
)

// Constants for JPEG: JPEG codec
const (
	// CONFR0: JPEG codec configuration register 0
	// Position of START field.
	JPEG_CONFR0_START_Pos = 0x0
	// Bit mask of START field.
	JPEG_CONFR0_START_Msk = 0x1
	// Bit START.
	JPEG_CONFR0_START = 0x1

	// CONFR1: JPEG codec configuration register 1
	// Position of NF field.
	JPEG_CONFR1_NF_Pos = 0x0
	// Bit mask of NF field.
	JPEG_CONFR1_NF_Msk = 0x3
	// Position of DE field.
	JPEG_CONFR1_DE_Pos = 0x3
	// Bit mask of DE field.
	JPEG_CONFR1_DE_Msk = 0x8
	// Bit DE.
	JPEG_CONFR1_DE = 0x8
	// Position of COLORSPACE field.
	JPEG_CONFR1_COLORSPACE_Pos = 0x4
	// Bit mask of COLORSPACE field.
	JPEG_CONFR1_COLORSPACE_Msk = 0x30
	// Position of NS field.
	JPEG_CONFR1_NS_Pos = 0x6
	// Bit mask of NS field.
	JPEG_CONFR1_NS_Msk = 0xc0
	// Position of HDR field.
	JPEG_CONFR1_HDR_Pos = 0x8
	// Bit mask of HDR field.
	JPEG_CONFR1_HDR_Msk = 0x100
	// Bit HDR.
	JPEG_CONFR1_HDR = 0x100
	// Position of YSIZE field.
	JPEG_CONFR1_YSIZE_Pos = 0x10
	// Bit mask of YSIZE field.
	JPEG_CONFR1_YSIZE_Msk = 0xffff0000

	// CONFR2: JPEG codec configuration register 2
	// Position of NMCU field.
	JPEG_CONFR2_NMCU_Pos = 0x0
	// Bit mask of NMCU field.
	JPEG_CONFR2_NMCU_Msk = 0x3ffffff

	// CONFR3: JPEG codec configuration register 3
	// Position of XSIZE field.
	JPEG_CONFR3_XSIZE_Pos = 0x10
	// Bit mask of XSIZE field.
	JPEG_CONFR3_XSIZE_Msk = 0xffff0000

	// CONFR4: JPEG codec configuration register 4
	// Position of HD field.
	JPEG_CONFR4_HD_Pos = 0x0
	// Bit mask of HD field.
	JPEG_CONFR4_HD_Msk = 0x1
	// Bit HD.
	JPEG_CONFR4_HD = 0x1
	// Position of HA field.
	JPEG_CONFR4_HA_Pos = 0x1
	// Bit mask of HA field.
	JPEG_CONFR4_HA_Msk = 0x2
	// Bit HA.
	JPEG_CONFR4_HA = 0x2
	// Position of QT field.
	JPEG_CONFR4_QT_Pos = 0x2
	// Bit mask of QT field.
	JPEG_CONFR4_QT_Msk = 0xc
	// Position of NB field.
	JPEG_CONFR4_NB_Pos = 0x4
	// Bit mask of NB field.
	JPEG_CONFR4_NB_Msk = 0xf0
	// Position of VSF field.
	JPEG_CONFR4_VSF_Pos = 0x8
	// Bit mask of VSF field.
	JPEG_CONFR4_VSF_Msk = 0xf00
	// Position of HSF field.
	JPEG_CONFR4_HSF_Pos = 0xc
	// Bit mask of HSF field.
	JPEG_CONFR4_HSF_Msk = 0xf000

	// CONFR5: JPEG codec configuration register 5
	// Position of HD field.
	JPEG_CONFR5_HD_Pos = 0x0
	// Bit mask of HD field.
	JPEG_CONFR5_HD_Msk = 0x1
	// Bit HD.
	JPEG_CONFR5_HD = 0x1
	// Position of HA field.
	JPEG_CONFR5_HA_Pos = 0x1
	// Bit mask of HA field.
	JPEG_CONFR5_HA_Msk = 0x2
	// Bit HA.
	JPEG_CONFR5_HA = 0x2
	// Position of QT field.
	JPEG_CONFR5_QT_Pos = 0x2
	// Bit mask of QT field.
	JPEG_CONFR5_QT_Msk = 0xc
	// Position of NB field.
	JPEG_CONFR5_NB_Pos = 0x4
	// Bit mask of NB field.
	JPEG_CONFR5_NB_Msk = 0xf0
	// Position of VSF field.
	JPEG_CONFR5_VSF_Pos = 0x8
	// Bit mask of VSF field.
	JPEG_CONFR5_VSF_Msk = 0xf00
	// Position of HSF field.
	JPEG_CONFR5_HSF_Pos = 0xc
	// Bit mask of HSF field.
	JPEG_CONFR5_HSF_Msk = 0xf000

	// CONFR6: JPEG codec configuration register 6
	// Position of HD field.
	JPEG_CONFR6_HD_Pos = 0x0
	// Bit mask of HD field.
	JPEG_CONFR6_HD_Msk = 0x1
	// Bit HD.
	JPEG_CONFR6_HD = 0x1
	// Position of HA field.
	JPEG_CONFR6_HA_Pos = 0x1
	// Bit mask of HA field.
	JPEG_CONFR6_HA_Msk = 0x2
	// Bit HA.
	JPEG_CONFR6_HA = 0x2
	// Position of QT field.
	JPEG_CONFR6_QT_Pos = 0x2
	// Bit mask of QT field.
	JPEG_CONFR6_QT_Msk = 0xc
	// Position of NB field.
	JPEG_CONFR6_NB_Pos = 0x4
	// Bit mask of NB field.
	JPEG_CONFR6_NB_Msk = 0xf0
	// Position of VSF field.
	JPEG_CONFR6_VSF_Pos = 0x8
	// Bit mask of VSF field.
	JPEG_CONFR6_VSF_Msk = 0xf00
	// Position of HSF field.
	JPEG_CONFR6_HSF_Pos = 0xc
	// Bit mask of HSF field.
	JPEG_CONFR6_HSF_Msk = 0xf000

	// CONFR7: JPEG codec configuration register 7
	// Position of HD field.
	JPEG_CONFR7_HD_Pos = 0x0
	// Bit mask of HD field.
	JPEG_CONFR7_HD_Msk = 0x1
	// Bit HD.
	JPEG_CONFR7_HD = 0x1
	// Position of HA field.
	JPEG_CONFR7_HA_Pos = 0x1
	// Bit mask of HA field.
	JPEG_CONFR7_HA_Msk = 0x2
	// Bit HA.
	JPEG_CONFR7_HA = 0x2
	// Position of QT field.
	JPEG_CONFR7_QT_Pos = 0x2
	// Bit mask of QT field.
	JPEG_CONFR7_QT_Msk = 0xc
	// Position of NB field.
	JPEG_CONFR7_NB_Pos = 0x4
	// Bit mask of NB field.
	JPEG_CONFR7_NB_Msk = 0xf0
	// Position of VSF field.
	JPEG_CONFR7_VSF_Pos = 0x8
	// Bit mask of VSF field.
	JPEG_CONFR7_VSF_Msk = 0xf00
	// Position of HSF field.
	JPEG_CONFR7_HSF_Pos = 0xc
	// Bit mask of HSF field.
	JPEG_CONFR7_HSF_Msk = 0xf000

	// CR: JPEG control register
	// Position of JCEN field.
	JPEG_CR_JCEN_Pos = 0x0
	// Bit mask of JCEN field.
	JPEG_CR_JCEN_Msk = 0x1
	// Bit JCEN.
	JPEG_CR_JCEN = 0x1
	// Position of IFTIE field.
	JPEG_CR_IFTIE_Pos = 0x1
	// Bit mask of IFTIE field.
	JPEG_CR_IFTIE_Msk = 0x2
	// Bit IFTIE.
	JPEG_CR_IFTIE = 0x2
	// Position of IFNFIE field.
	JPEG_CR_IFNFIE_Pos = 0x2
	// Bit mask of IFNFIE field.
	JPEG_CR_IFNFIE_Msk = 0x4
	// Bit IFNFIE.
	JPEG_CR_IFNFIE = 0x4
	// Position of OFTIE field.
	JPEG_CR_OFTIE_Pos = 0x3
	// Bit mask of OFTIE field.
	JPEG_CR_OFTIE_Msk = 0x8
	// Bit OFTIE.
	JPEG_CR_OFTIE = 0x8
	// Position of OFNEIE field.
	JPEG_CR_OFNEIE_Pos = 0x4
	// Bit mask of OFNEIE field.
	JPEG_CR_OFNEIE_Msk = 0x10
	// Bit OFNEIE.
	JPEG_CR_OFNEIE = 0x10
	// Position of EOCIE field.
	JPEG_CR_EOCIE_Pos = 0x5
	// Bit mask of EOCIE field.
	JPEG_CR_EOCIE_Msk = 0x20
	// Bit EOCIE.
	JPEG_CR_EOCIE = 0x20
	// Position of HPDIE field.
	JPEG_CR_HPDIE_Pos = 0x6
	// Bit mask of HPDIE field.
	JPEG_CR_HPDIE_Msk = 0x40
	// Bit HPDIE.
	JPEG_CR_HPDIE = 0x40
	// Position of IDMAEN field.
	JPEG_CR_IDMAEN_Pos = 0xb
	// Bit mask of IDMAEN field.
	JPEG_CR_IDMAEN_Msk = 0x800
	// Bit IDMAEN.
	JPEG_CR_IDMAEN = 0x800
	// Position of ODMAEN field.
	JPEG_CR_ODMAEN_Pos = 0xc
	// Bit mask of ODMAEN field.
	JPEG_CR_ODMAEN_Msk = 0x1000
	// Bit ODMAEN.
	JPEG_CR_ODMAEN = 0x1000
	// Position of IFF field.
	JPEG_CR_IFF_Pos = 0xd
	// Bit mask of IFF field.
	JPEG_CR_IFF_Msk = 0x2000
	// Bit IFF.
	JPEG_CR_IFF = 0x2000
	// Position of OFF field.
	JPEG_CR_OFF_Pos = 0xe
	// Bit mask of OFF field.
	JPEG_CR_OFF_Msk = 0x4000
	// Bit OFF.
	JPEG_CR_OFF = 0x4000

	// SR: JPEG status register
	// Position of IFTF field.
	JPEG_SR_IFTF_Pos = 0x1
	// Bit mask of IFTF field.
	JPEG_SR_IFTF_Msk = 0x2
	// Bit IFTF.
	JPEG_SR_IFTF = 0x2
	// Position of IFNFF field.
	JPEG_SR_IFNFF_Pos = 0x2
	// Bit mask of IFNFF field.
	JPEG_SR_IFNFF_Msk = 0x4
	// Bit IFNFF.
	JPEG_SR_IFNFF = 0x4
	// Position of OFTF field.
	JPEG_SR_OFTF_Pos = 0x3
	// Bit mask of OFTF field.
	JPEG_SR_OFTF_Msk = 0x8
	// Bit OFTF.
	JPEG_SR_OFTF = 0x8
	// Position of OFNEF field.
	JPEG_SR_OFNEF_Pos = 0x4
	// Bit mask of OFNEF field.
	JPEG_SR_OFNEF_Msk = 0x10
	// Bit OFNEF.
	JPEG_SR_OFNEF = 0x10
	// Position of EOCF field.
	JPEG_SR_EOCF_Pos = 0x5
	// Bit mask of EOCF field.
	JPEG_SR_EOCF_Msk = 0x20
	// Bit EOCF.
	JPEG_SR_EOCF = 0x20
	// Position of HPDF field.
	JPEG_SR_HPDF_Pos = 0x6
	// Bit mask of HPDF field.
	JPEG_SR_HPDF_Msk = 0x40
	// Bit HPDF.
	JPEG_SR_HPDF = 0x40
	// Position of COF field.
	JPEG_SR_COF_Pos = 0x7
	// Bit mask of COF field.
	JPEG_SR_COF_Msk = 0x80
	// Bit COF.
	JPEG_SR_COF = 0x80

	// CFR: JPEG clear flag register
	// Position of CEOCF field.
	JPEG_CFR_CEOCF_Pos = 0x5
	// Bit mask of CEOCF field.
	JPEG_CFR_CEOCF_Msk = 0x20
	// Bit CEOCF.
	JPEG_CFR_CEOCF = 0x20
	// Position of CHPDF field.
	JPEG_CFR_CHPDF_Pos = 0x6
	// Bit mask of CHPDF field.
	JPEG_CFR_CHPDF_Msk = 0x40
	// Bit CHPDF.
	JPEG_CFR_CHPDF = 0x40

	// DIR: JPEG data input register
	// Position of DATAIN field.
	JPEG_DIR_DATAIN_Pos = 0x0
	// Bit mask of DATAIN field.
	JPEG_DIR_DATAIN_Msk = 0xffffffff

	// DOR: JPEG data output register
	// Position of DATAOUT field.
	JPEG_DOR_DATAOUT_Pos = 0x0
	// Bit mask of DATAOUT field.
	JPEG_DOR_DATAOUT_Msk = 0xffffffff

	// QMEM0_0: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM0_0_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM0_0_QMem_RAM_Msk = 0xffffffff

	// QMEM0_1: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM0_1_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM0_1_QMem_RAM_Msk = 0xffffffff

	// QMEM0_2: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM0_2_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM0_2_QMem_RAM_Msk = 0xffffffff

	// QMEM0_3: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM0_3_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM0_3_QMem_RAM_Msk = 0xffffffff

	// QMEM0_4: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM0_4_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM0_4_QMem_RAM_Msk = 0xffffffff

	// QMEM0_5: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM0_5_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM0_5_QMem_RAM_Msk = 0xffffffff

	// QMEM0_6: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM0_6_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM0_6_QMem_RAM_Msk = 0xffffffff

	// QMEM0_7: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM0_7_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM0_7_QMem_RAM_Msk = 0xffffffff

	// QMEM0_8: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM0_8_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM0_8_QMem_RAM_Msk = 0xffffffff

	// QMEM0_9: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM0_9_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM0_9_QMem_RAM_Msk = 0xffffffff

	// QMEM0_10: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM0_10_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM0_10_QMem_RAM_Msk = 0xffffffff

	// QMEM0_11: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM0_11_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM0_11_QMem_RAM_Msk = 0xffffffff

	// QMEM0_12: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM0_12_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM0_12_QMem_RAM_Msk = 0xffffffff

	// QMEM0_13: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM0_13_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM0_13_QMem_RAM_Msk = 0xffffffff

	// QMEM0_14: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM0_14_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM0_14_QMem_RAM_Msk = 0xffffffff

	// QMEM0_15: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM0_15_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM0_15_QMem_RAM_Msk = 0xffffffff

	// QMEM1_0: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM1_0_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM1_0_QMem_RAM_Msk = 0xffffffff

	// QMEM1_1: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM1_1_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM1_1_QMem_RAM_Msk = 0xffffffff

	// QMEM1_2: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM1_2_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM1_2_QMem_RAM_Msk = 0xffffffff

	// QMEM1_3: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM1_3_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM1_3_QMem_RAM_Msk = 0xffffffff

	// QMEM1_4: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM1_4_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM1_4_QMem_RAM_Msk = 0xffffffff

	// QMEM1_5: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM1_5_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM1_5_QMem_RAM_Msk = 0xffffffff

	// QMEM1_6: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM1_6_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM1_6_QMem_RAM_Msk = 0xffffffff

	// QMEM1_7: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM1_7_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM1_7_QMem_RAM_Msk = 0xffffffff

	// QMEM1_8: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM1_8_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM1_8_QMem_RAM_Msk = 0xffffffff

	// QMEM1_9: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM1_9_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM1_9_QMem_RAM_Msk = 0xffffffff

	// QMEM1_10: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM1_10_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM1_10_QMem_RAM_Msk = 0xffffffff

	// QMEM1_11: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM1_11_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM1_11_QMem_RAM_Msk = 0xffffffff

	// QMEM1_12: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM1_12_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM1_12_QMem_RAM_Msk = 0xffffffff

	// QMEM1_13: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM1_13_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM1_13_QMem_RAM_Msk = 0xffffffff

	// QMEM1_14: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM1_14_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM1_14_QMem_RAM_Msk = 0xffffffff

	// QMEM1_15: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM1_15_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM1_15_QMem_RAM_Msk = 0xffffffff

	// QMEM2_0: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM2_0_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM2_0_QMem_RAM_Msk = 0xffffffff

	// QMEM2_1: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM2_1_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM2_1_QMem_RAM_Msk = 0xffffffff

	// QMEM2_2: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM2_2_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM2_2_QMem_RAM_Msk = 0xffffffff

	// QMEM2_3: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM2_3_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM2_3_QMem_RAM_Msk = 0xffffffff

	// QMEM2_4: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM2_4_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM2_4_QMem_RAM_Msk = 0xffffffff

	// QMEM2_5: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM2_5_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM2_5_QMem_RAM_Msk = 0xffffffff

	// QMEM2_6: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM2_6_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM2_6_QMem_RAM_Msk = 0xffffffff

	// QMEM2_7: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM2_7_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM2_7_QMem_RAM_Msk = 0xffffffff

	// QMEM2_8: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM2_8_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM2_8_QMem_RAM_Msk = 0xffffffff

	// QMEM2_9: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM2_9_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM2_9_QMem_RAM_Msk = 0xffffffff

	// QMEM2_10: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM2_10_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM2_10_QMem_RAM_Msk = 0xffffffff

	// QMEM2_11: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM2_11_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM2_11_QMem_RAM_Msk = 0xffffffff

	// QMEM2_12: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM2_12_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM2_12_QMem_RAM_Msk = 0xffffffff

	// QMEM2_13: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM2_13_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM2_13_QMem_RAM_Msk = 0xffffffff

	// QMEM2_14: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM2_14_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM2_14_QMem_RAM_Msk = 0xffffffff

	// QMEM2_15: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM2_15_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM2_15_QMem_RAM_Msk = 0xffffffff

	// QMEM3_0: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM3_0_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM3_0_QMem_RAM_Msk = 0xffffffff

	// QMEM3_1: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM3_1_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM3_1_QMem_RAM_Msk = 0xffffffff

	// QMEM3_2: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM3_2_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM3_2_QMem_RAM_Msk = 0xffffffff

	// QMEM3_3: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM3_3_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM3_3_QMem_RAM_Msk = 0xffffffff

	// QMEM3_4: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM3_4_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM3_4_QMem_RAM_Msk = 0xffffffff

	// QMEM3_5: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM3_5_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM3_5_QMem_RAM_Msk = 0xffffffff

	// QMEM3_6: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM3_6_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM3_6_QMem_RAM_Msk = 0xffffffff

	// QMEM3_7: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM3_7_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM3_7_QMem_RAM_Msk = 0xffffffff

	// QMEM3_8: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM3_8_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM3_8_QMem_RAM_Msk = 0xffffffff

	// QMEM3_9: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM3_9_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM3_9_QMem_RAM_Msk = 0xffffffff

	// QMEM3_10: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM3_10_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM3_10_QMem_RAM_Msk = 0xffffffff

	// QMEM3_11: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM3_11_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM3_11_QMem_RAM_Msk = 0xffffffff

	// QMEM3_12: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM3_12_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM3_12_QMem_RAM_Msk = 0xffffffff

	// QMEM3_13: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM3_13_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM3_13_QMem_RAM_Msk = 0xffffffff

	// QMEM3_14: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM3_14_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM3_14_QMem_RAM_Msk = 0xffffffff

	// QMEM3_15: JPEG quantization tables
	// Position of QMem_RAM field.
	JPEG_QMEM3_15_QMem_RAM_Pos = 0x0
	// Bit mask of QMem_RAM field.
	JPEG_QMEM3_15_QMem_RAM_Msk = 0xffffffff

	// HUFFMIN_0: JPEG HuffMin tables
	// Position of HuffMin_RAM field.
	JPEG_HUFFMIN_0_HuffMin_RAM_Pos = 0x0
	// Bit mask of HuffMin_RAM field.
	JPEG_HUFFMIN_0_HuffMin_RAM_Msk = 0xffffffff

	// HUFFMIN_1: JPEG HuffMin tables
	// Position of HuffMin_RAM field.
	JPEG_HUFFMIN_1_HuffMin_RAM_Pos = 0x0
	// Bit mask of HuffMin_RAM field.
	JPEG_HUFFMIN_1_HuffMin_RAM_Msk = 0xffffffff

	// HUFFMIN_2: JPEG HuffMin tables
	// Position of HuffMin_RAM field.
	JPEG_HUFFMIN_2_HuffMin_RAM_Pos = 0x0
	// Bit mask of HuffMin_RAM field.
	JPEG_HUFFMIN_2_HuffMin_RAM_Msk = 0xffffffff

	// HUFFMIN_3: JPEG HuffMin tables
	// Position of HuffMin_RAM field.
	JPEG_HUFFMIN_3_HuffMin_RAM_Pos = 0x0
	// Bit mask of HuffMin_RAM field.
	JPEG_HUFFMIN_3_HuffMin_RAM_Msk = 0xffffffff

	// HUFFMIN_4: JPEG HuffMin tables
	// Position of HuffMin_RAM field.
	JPEG_HUFFMIN_4_HuffMin_RAM_Pos = 0x0
	// Bit mask of HuffMin_RAM field.
	JPEG_HUFFMIN_4_HuffMin_RAM_Msk = 0xffffffff

	// HUFFMIN_5: JPEG HuffMin tables
	// Position of HuffMin_RAM field.
	JPEG_HUFFMIN_5_HuffMin_RAM_Pos = 0x0
	// Bit mask of HuffMin_RAM field.
	JPEG_HUFFMIN_5_HuffMin_RAM_Msk = 0xffffffff

	// HUFFMIN_6: JPEG HuffMin tables
	// Position of HuffMin_RAM field.
	JPEG_HUFFMIN_6_HuffMin_RAM_Pos = 0x0
	// Bit mask of HuffMin_RAM field.
	JPEG_HUFFMIN_6_HuffMin_RAM_Msk = 0xffffffff

	// HUFFMIN_7: JPEG HuffMin tables
	// Position of HuffMin_RAM field.
	JPEG_HUFFMIN_7_HuffMin_RAM_Pos = 0x0
	// Bit mask of HuffMin_RAM field.
	JPEG_HUFFMIN_7_HuffMin_RAM_Msk = 0xffffffff

	// HUFFMIN_8: JPEG HuffMin tables
	// Position of HuffMin_RAM field.
	JPEG_HUFFMIN_8_HuffMin_RAM_Pos = 0x0
	// Bit mask of HuffMin_RAM field.
	JPEG_HUFFMIN_8_HuffMin_RAM_Msk = 0xffffffff

	// HUFFMIN_9: JPEG HuffMin tables
	// Position of HuffMin_RAM field.
	JPEG_HUFFMIN_9_HuffMin_RAM_Pos = 0x0
	// Bit mask of HuffMin_RAM field.
	JPEG_HUFFMIN_9_HuffMin_RAM_Msk = 0xffffffff

	// HUFFMIN_10: JPEG HuffMin tables
	// Position of HuffMin_RAM field.
	JPEG_HUFFMIN_10_HuffMin_RAM_Pos = 0x0
	// Bit mask of HuffMin_RAM field.
	JPEG_HUFFMIN_10_HuffMin_RAM_Msk = 0xffffffff

	// HUFFMIN_11: JPEG HuffMin tables
	// Position of HuffMin_RAM field.
	JPEG_HUFFMIN_11_HuffMin_RAM_Pos = 0x0
	// Bit mask of HuffMin_RAM field.
	JPEG_HUFFMIN_11_HuffMin_RAM_Msk = 0xffffffff

	// HUFFMIN_12: JPEG HuffMin tables
	// Position of HuffMin_RAM field.
	JPEG_HUFFMIN_12_HuffMin_RAM_Pos = 0x0
	// Bit mask of HuffMin_RAM field.
	JPEG_HUFFMIN_12_HuffMin_RAM_Msk = 0xffffffff

	// HUFFMIN_13: JPEG HuffMin tables
	// Position of HuffMin_RAM field.
	JPEG_HUFFMIN_13_HuffMin_RAM_Pos = 0x0
	// Bit mask of HuffMin_RAM field.
	JPEG_HUFFMIN_13_HuffMin_RAM_Msk = 0xffffffff

	// HUFFMIN_14: JPEG HuffMin tables
	// Position of HuffMin_RAM field.
	JPEG_HUFFMIN_14_HuffMin_RAM_Pos = 0x0
	// Bit mask of HuffMin_RAM field.
	JPEG_HUFFMIN_14_HuffMin_RAM_Msk = 0xffffffff

	// HUFFMIN_15: JPEG HuffMin tables
	// Position of HuffMin_RAM field.
	JPEG_HUFFMIN_15_HuffMin_RAM_Pos = 0x0
	// Bit mask of HuffMin_RAM field.
	JPEG_HUFFMIN_15_HuffMin_RAM_Msk = 0xffffffff

	// HUFFBASE0: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE0_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE0_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE0_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE0_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE1: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE1_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE1_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE1_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE1_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE2: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE2_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE2_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE2_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE2_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE3: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE3_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE3_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE3_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE3_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE4: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE4_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE4_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE4_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE4_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE5: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE5_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE5_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE5_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE5_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE6: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE6_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE6_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE6_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE6_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE7: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE7_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE7_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE7_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE7_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE8: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE8_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE8_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE8_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE8_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE9: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE9_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE9_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE9_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE9_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE10: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE10_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE10_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE10_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE10_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE11: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE11_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE11_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE11_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE11_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE12: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE12_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE12_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE12_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE12_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE13: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE13_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE13_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE13_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE13_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE14: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE14_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE14_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE14_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE14_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE15: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE15_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE15_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE15_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE15_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE16: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE16_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE16_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE16_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE16_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE17: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE17_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE17_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE17_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE17_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE18: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE18_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE18_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE18_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE18_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE19: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE19_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE19_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE19_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE19_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE20: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE20_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE20_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE20_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE20_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE21: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE21_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE21_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE21_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE21_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE22: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE22_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE22_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE22_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE22_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE23: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE23_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE23_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE23_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE23_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE24: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE24_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE24_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE24_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE24_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE25: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE25_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE25_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE25_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE25_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE26: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE26_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE26_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE26_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE26_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE27: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE27_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE27_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE27_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE27_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE28: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE28_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE28_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE28_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE28_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE29: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE29_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE29_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE29_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE29_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE30: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE30_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE30_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE30_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE30_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFBASE31: JPEG HuffSymb tables
	// Position of HuffBase_RAM_0 field.
	JPEG_HUFFBASE31_HuffBase_RAM_0_Pos = 0x0
	// Bit mask of HuffBase_RAM_0 field.
	JPEG_HUFFBASE31_HuffBase_RAM_0_Msk = 0x1ff
	// Position of HuffBase_RAM_1 field.
	JPEG_HUFFBASE31_HuffBase_RAM_1_Pos = 0x10
	// Bit mask of HuffBase_RAM_1 field.
	JPEG_HUFFBASE31_HuffBase_RAM_1_Msk = 0x1ff0000

	// HUFFSYMB0: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB0_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB0_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB1: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB1_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB1_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB2: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB2_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB2_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB3: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB3_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB3_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB4: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB4_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB4_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB5: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB5_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB5_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB6: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB6_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB6_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB7: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB7_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB7_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB8: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB8_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB8_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB9: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB9_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB9_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB10: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB10_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB10_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB11: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB11_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB11_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB12: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB12_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB12_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB13: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB13_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB13_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB14: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB14_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB14_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB15: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB15_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB15_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB16: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB16_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB16_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB17: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB17_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB17_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB18: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB18_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB18_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB19: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB19_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB19_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB20: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB20_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB20_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB21: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB21_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB21_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB22: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB22_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB22_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB23: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB23_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB23_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB24: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB24_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB24_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB25: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB25_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB25_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB26: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB26_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB26_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB27: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB27_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB27_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB28: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB28_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB28_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB29: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB29_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB29_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB30: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB30_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB30_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB31: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB31_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB31_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB32: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB32_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB32_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB33: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB33_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB33_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB34: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB34_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB34_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB35: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB35_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB35_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB36: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB36_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB36_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB37: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB37_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB37_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB38: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB38_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB38_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB39: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB39_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB39_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB40: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB40_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB40_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB41: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB41_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB41_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB42: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB42_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB42_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB43: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB43_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB43_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB44: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB44_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB44_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB45: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB45_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB45_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB46: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB46_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB46_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB47: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB47_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB47_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB48: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB48_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB48_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB49: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB49_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB49_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB50: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB50_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB50_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB51: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB51_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB51_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB52: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB52_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB52_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB53: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB53_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB53_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB54: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB54_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB54_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB55: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB55_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB55_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB56: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB56_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB56_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB57: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB57_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB57_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB58: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB58_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB58_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB59: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB59_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB59_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB60: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB60_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB60_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB61: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB61_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB61_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB62: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB62_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB62_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB63: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB63_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB63_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB64: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB64_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB64_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB65: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB65_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB65_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB66: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB66_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB66_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB67: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB67_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB67_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB68: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB68_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB68_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB69: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB69_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB69_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB70: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB70_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB70_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB71: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB71_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB71_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB72: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB72_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB72_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB73: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB73_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB73_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB74: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB74_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB74_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB75: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB75_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB75_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB76: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB76_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB76_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB77: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB77_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB77_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB78: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB78_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB78_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB79: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB79_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB79_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB80: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB80_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB80_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB81: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB81_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB81_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB82: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB82_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB82_HuffSymb_RAM_Msk = 0xffffffff

	// HUFFSYMB83: JPEG HUFFSYMB tables
	// Position of HuffSymb_RAM field.
	JPEG_HUFFSYMB83_HuffSymb_RAM_Pos = 0x0
	// Bit mask of HuffSymb_RAM field.
	JPEG_HUFFSYMB83_HuffSymb_RAM_Msk = 0xffffffff

	// DHTMEM0: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM0_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM0_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM2: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM2_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM2_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM3: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM3_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM3_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM4: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM4_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM4_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM5: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM5_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM5_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM6: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM6_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM6_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM7: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM7_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM7_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM8: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM8_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM8_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM9: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM9_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM9_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM10: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM10_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM10_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM11: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM11_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM11_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM12: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM12_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM12_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM13: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM13_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM13_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM14: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM14_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM14_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM15: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM15_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM15_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM16: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM16_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM16_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM17: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM17_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM17_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM18: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM18_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM18_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM19: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM19_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM19_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM20: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM20_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM20_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM21: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM21_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM21_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM22: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM22_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM22_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM23: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM23_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM23_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM24: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM24_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM24_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM25: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM25_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM25_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM26: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM26_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM26_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM27: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM27_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM27_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM28: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM28_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM28_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM29: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM29_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM29_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM30: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM30_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM30_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM31: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM31_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM31_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM32: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM32_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM32_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM33: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM33_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM33_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM34: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM34_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM34_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM35: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM35_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM35_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM36: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM36_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM36_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM37: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM37_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM37_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM38: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM38_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM38_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM39: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM39_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM39_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM40: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM40_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM40_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM41: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM41_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM41_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM42: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM42_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM42_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM43: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM43_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM43_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM44: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM44_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM44_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM45: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM45_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM45_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM46: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM46_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM46_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM47: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM47_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM47_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM48: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM48_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM48_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM49: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM49_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM49_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM50: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM50_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM50_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM51: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM51_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM51_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM52: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM52_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM52_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM53: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM53_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM53_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM54: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM54_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM54_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM55: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM55_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM55_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM56: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM56_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM56_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM57: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM57_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM57_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM58: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM58_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM58_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM59: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM59_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM59_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM60: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM60_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM60_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM61: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM61_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM61_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM62: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM62_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM62_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM63: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM63_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM63_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM64: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM64_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM64_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM65: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM65_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM65_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM66: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM66_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM66_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM67: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM67_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM67_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM68: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM68_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM68_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM69: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM69_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM69_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM70: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM70_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM70_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM71: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM71_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM71_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM72: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM72_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM72_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM73: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM73_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM73_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM74: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM74_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM74_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM75: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM75_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM75_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM76: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM76_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM76_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM77: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM77_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM77_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM78: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM78_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM78_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM79: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM79_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM79_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM80: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM80_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM80_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM81: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM81_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM81_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM82: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM82_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM82_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM83: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM83_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM83_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM84: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM84_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM84_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM85: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM85_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM85_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM86: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM86_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM86_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM87: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM87_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM87_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM88: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM88_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM88_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM89: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM89_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM89_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM90: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM90_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM90_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM91: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM91_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM91_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM92: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM92_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM92_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM93: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM93_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM93_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM94: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM94_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM94_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM95: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM95_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM95_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM96: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM96_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM96_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM97: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM97_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM97_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM98: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM98_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM98_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM99: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM99_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM99_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM100: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM100_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM100_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM101: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM101_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM101_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM102: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM102_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM102_DHTMem_RAM_Msk = 0xffffffff

	// DHTMEM103: JPEG DHTMem tables
	// Position of DHTMem_RAM field.
	JPEG_DHTMEM103_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_DHTMEM103_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_0: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_0_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_0_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_1: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_1_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_1_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_2: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_2_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_2_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_3: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_3_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_3_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_4: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_4_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_4_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_5: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_5_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_5_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_6: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_6_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_6_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_7: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_7_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_7_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_8: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_8_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_8_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_9: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_9_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_9_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_10: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_10_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_10_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_11: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_11_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_11_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_12: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_12_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_12_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_13: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_13_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_13_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_14: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_14_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_14_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_15: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_15_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_15_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_16: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_16_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_16_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_17: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_17_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_17_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_18: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_18_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_18_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_19: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_19_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_19_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_20: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_20_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_20_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_21: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_21_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_21_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_22: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_22_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_22_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_23: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_23_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_23_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_24: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_24_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_24_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_25: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_25_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_25_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_26: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_26_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_26_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_27: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_27_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_27_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_28: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_28_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_28_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_29: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_29_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_29_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_30: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_30_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_30_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_31: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_31_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_31_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_32: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_32_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_32_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_33: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_33_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_33_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_34: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_34_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_34_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_35: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_35_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_35_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_36: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_36_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_36_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_37: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_37_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_37_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_38: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_38_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_38_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_39: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_39_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_39_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_40: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_40_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_40_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_41: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_41_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_41_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_42: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_42_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_42_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_43: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_43_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_43_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_44: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_44_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_44_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_45: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_45_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_45_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_46: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_46_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_46_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_47: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_47_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_47_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_48: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_48_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_48_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_49: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_49_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_49_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_50: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_50_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_50_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_51: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_51_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_51_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_52: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_52_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_52_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_53: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_53_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_53_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_54: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_54_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_54_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_55: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_55_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_55_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_56: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_56_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_56_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_57: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_57_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_57_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_58: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_58_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_58_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_59: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_59_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_59_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_60: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_60_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_60_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_61: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_61_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_61_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_62: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_62_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_62_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_63: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_63_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_63_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_64: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_64_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_64_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_65: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_65_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_65_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_66: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_66_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_66_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_67: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_67_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_67_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_68: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_68_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_68_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_69: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_69_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_69_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_70: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_70_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_70_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_71: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_71_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_71_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_72: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_72_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_72_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_73: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_73_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_73_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_74: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_74_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_74_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_75: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_75_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_75_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_76: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_76_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_76_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_77: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_77_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_77_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_78: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_78_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_78_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_79: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_79_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_79_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_80: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_80_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_80_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_81: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_81_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_81_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_82: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_82_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_82_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_83: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_83_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_83_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_84: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_84_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_84_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_85: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_85_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_85_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_86: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_86_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_86_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC0_87: JPEG encoder, AC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_87_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC0_87_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_0: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_0_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_0_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_1: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_1_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_1_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_2: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_2_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_2_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_3: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_3_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_3_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_4: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_4_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_4_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_5: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_5_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_5_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_6: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_6_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_6_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_7: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_7_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_7_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_8: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_8_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_8_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_9: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_9_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_9_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_10: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_10_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_10_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_11: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_11_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_11_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_12: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_12_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_12_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_13: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_13_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_13_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_14: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_14_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_14_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_15: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_15_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_15_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_16: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_16_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_16_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_17: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_17_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_17_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_18: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_18_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_18_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_19: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_19_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_19_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_20: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_20_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_20_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_21: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_21_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_21_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_22: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_22_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_22_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_23: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_23_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_23_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_24: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_24_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_24_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_25: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_25_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_25_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_26: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_26_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_26_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_27: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_27_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_27_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_28: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_28_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_28_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_29: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_29_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_29_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_30: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_30_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_30_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_31: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_31_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_31_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_32: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_32_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_32_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_33: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_33_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_33_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_34: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_34_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_34_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_35: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_35_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_35_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_36: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_36_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_36_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_37: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_37_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_37_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_38: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_38_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_38_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_39: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_39_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_39_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_40: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_40_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_40_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_41: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_41_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_41_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_42: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_42_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_42_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_43: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_43_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_43_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_44: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_44_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_44_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_45: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_45_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_45_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_46: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_46_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_46_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_47: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_47_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_47_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_48: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_48_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_48_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_49: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_49_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_49_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_50: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_50_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_50_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_51: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_51_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_51_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_52: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_52_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_52_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_53: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_53_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_53_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_54: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_54_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_54_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_55: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_55_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_55_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_56: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_56_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_56_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_57: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_57_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_57_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_58: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_58_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_58_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_59: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_59_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_59_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_60: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_60_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_60_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_61: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_61_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_61_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_62: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_62_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_62_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_63: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_63_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_63_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_64: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_64_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_64_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_65: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_65_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_65_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_66: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_66_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_66_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_67: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_67_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_67_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_68: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_68_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_68_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_69: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_69_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_69_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_70: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_70_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_70_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_71: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_71_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_71_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_72: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_72_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_72_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_73: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_73_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_73_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_74: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_74_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_74_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_75: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_75_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_75_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_76: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_76_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_76_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_77: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_77_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_77_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_78: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_78_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_78_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_79: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_79_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_79_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_80: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_80_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_80_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_81: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_81_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_81_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_82: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_82_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_82_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_83: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_83_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_83_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_84: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_84_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_84_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_85: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_85_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_85_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_86: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_86_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_86_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_AC1_87: JPEG encoder, AC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_87_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_AC1_87_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_DC0_0: JPEG encoder, DC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_DC0_0_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_DC0_0_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_DC0_1: JPEG encoder, DC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_DC0_1_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_DC0_1_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_DC0_2: JPEG encoder, DC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_DC0_2_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_DC0_2_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_DC0_3: JPEG encoder, DC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_DC0_3_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_DC0_3_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_DC0_4: JPEG encoder, DC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_DC0_4_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_DC0_4_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_DC0_5: JPEG encoder, DC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_DC0_5_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_DC0_5_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_DC0_6: JPEG encoder, DC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_DC0_6_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_DC0_6_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_DC0_7: JPEG encoder, DC Huffman table 0
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_DC0_7_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_DC0_7_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_DC1_0: JPEG encoder, DC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_DC1_0_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_DC1_0_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_DC1_1: JPEG encoder, DC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_DC1_1_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_DC1_1_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_DC1_2: JPEG encoder, DC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_DC1_2_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_DC1_2_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_DC1_3: JPEG encoder, DC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_DC1_3_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_DC1_3_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_DC1_4: JPEG encoder, DC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_DC1_4_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_DC1_4_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_DC1_5: JPEG encoder, DC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_DC1_5_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_DC1_5_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_DC1_6: JPEG encoder, DC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_DC1_6_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_DC1_6_DHTMem_RAM_Msk = 0xffffffff

	// HUFFENC_DC1_7: JPEG encoder, DC Huffman table 1
	// Position of DHTMem_RAM field.
	JPEG_HUFFENC_DC1_7_DHTMem_RAM_Pos = 0x0
	// Bit mask of DHTMem_RAM field.
	JPEG_HUFFENC_DC1_7_DHTMem_RAM_Msk = 0xffffffff
)

// Constants for DSI: DSI Host
const (
	// VR: DSI Host Version Register
	// Position of VERSION field.
	DSI_VR_VERSION_Pos = 0x0
	// Bit mask of VERSION field.
	DSI_VR_VERSION_Msk = 0xffffffff

	// CR: DSI Host Control Register
	// Position of EN field.
	DSI_CR_EN_Pos = 0x0
	// Bit mask of EN field.
	DSI_CR_EN_Msk = 0x1
	// Bit EN.
	DSI_CR_EN = 0x1

	// CCR: DSI HOST Clock Control Register
	// Position of TXECKDIV field.
	DSI_CCR_TXECKDIV_Pos = 0x0
	// Bit mask of TXECKDIV field.
	DSI_CCR_TXECKDIV_Msk = 0xff
	// Position of TOCKDIV field.
	DSI_CCR_TOCKDIV_Pos = 0x8
	// Bit mask of TOCKDIV field.
	DSI_CCR_TOCKDIV_Msk = 0xff00

	// LVCIDR: DSI Host LTDC VCID Register
	// Position of VCID field.
	DSI_LVCIDR_VCID_Pos = 0x0
	// Bit mask of VCID field.
	DSI_LVCIDR_VCID_Msk = 0x3

	// LCOLCR: DSI Host LTDC Color Coding Register
	// Position of COLC field.
	DSI_LCOLCR_COLC_Pos = 0x0
	// Bit mask of COLC field.
	DSI_LCOLCR_COLC_Msk = 0xf
	// Position of LPE field.
	DSI_LCOLCR_LPE_Pos = 0x8
	// Bit mask of LPE field.
	DSI_LCOLCR_LPE_Msk = 0x100
	// Bit LPE.
	DSI_LCOLCR_LPE = 0x100

	// LPCR: DSI Host LTDC Polarity Configuration Register
	// Position of DEP field.
	DSI_LPCR_DEP_Pos = 0x0
	// Bit mask of DEP field.
	DSI_LPCR_DEP_Msk = 0x1
	// Bit DEP.
	DSI_LPCR_DEP = 0x1
	// Position of VSP field.
	DSI_LPCR_VSP_Pos = 0x1
	// Bit mask of VSP field.
	DSI_LPCR_VSP_Msk = 0x2
	// Bit VSP.
	DSI_LPCR_VSP = 0x2
	// Position of HSP field.
	DSI_LPCR_HSP_Pos = 0x2
	// Bit mask of HSP field.
	DSI_LPCR_HSP_Msk = 0x4
	// Bit HSP.
	DSI_LPCR_HSP = 0x4

	// LPMCR: DSI Host Low-Power mode Configuration Register
	// Position of VLPSIZE field.
	DSI_LPMCR_VLPSIZE_Pos = 0x0
	// Bit mask of VLPSIZE field.
	DSI_LPMCR_VLPSIZE_Msk = 0xff
	// Position of LPSIZE field.
	DSI_LPMCR_LPSIZE_Pos = 0x10
	// Bit mask of LPSIZE field.
	DSI_LPMCR_LPSIZE_Msk = 0xff0000

	// PCR: DSI Host Protocol Configuration Register
	// Position of ETTXE field.
	DSI_PCR_ETTXE_Pos = 0x0
	// Bit mask of ETTXE field.
	DSI_PCR_ETTXE_Msk = 0x1
	// Bit ETTXE.
	DSI_PCR_ETTXE = 0x1
	// Position of ETRXE field.
	DSI_PCR_ETRXE_Pos = 0x1
	// Bit mask of ETRXE field.
	DSI_PCR_ETRXE_Msk = 0x2
	// Bit ETRXE.
	DSI_PCR_ETRXE = 0x2
	// Position of BTAE field.
	DSI_PCR_BTAE_Pos = 0x2
	// Bit mask of BTAE field.
	DSI_PCR_BTAE_Msk = 0x4
	// Bit BTAE.
	DSI_PCR_BTAE = 0x4
	// Position of ECCRXE field.
	DSI_PCR_ECCRXE_Pos = 0x3
	// Bit mask of ECCRXE field.
	DSI_PCR_ECCRXE_Msk = 0x8
	// Bit ECCRXE.
	DSI_PCR_ECCRXE = 0x8
	// Position of CRCRXE field.
	DSI_PCR_CRCRXE_Pos = 0x4
	// Bit mask of CRCRXE field.
	DSI_PCR_CRCRXE_Msk = 0x10
	// Bit CRCRXE.
	DSI_PCR_CRCRXE = 0x10

	// GVCIDR: DSI Host Generic VCID Register
	// Position of VCID field.
	DSI_GVCIDR_VCID_Pos = 0x0
	// Bit mask of VCID field.
	DSI_GVCIDR_VCID_Msk = 0x3

	// MCR: DSI Host mode Configuration Register
	// Position of CMDM field.
	DSI_MCR_CMDM_Pos = 0x0
	// Bit mask of CMDM field.
	DSI_MCR_CMDM_Msk = 0x1
	// Bit CMDM.
	DSI_MCR_CMDM = 0x1

	// VMCR: DSI Host Video mode Configuration Register
	// Position of VMT field.
	DSI_VMCR_VMT_Pos = 0x0
	// Bit mask of VMT field.
	DSI_VMCR_VMT_Msk = 0x3
	// Position of LPVSAE field.
	DSI_VMCR_LPVSAE_Pos = 0x8
	// Bit mask of LPVSAE field.
	DSI_VMCR_LPVSAE_Msk = 0x100
	// Bit LPVSAE.
	DSI_VMCR_LPVSAE = 0x100
	// Position of LPVBPE field.
	DSI_VMCR_LPVBPE_Pos = 0x9
	// Bit mask of LPVBPE field.
	DSI_VMCR_LPVBPE_Msk = 0x200
	// Bit LPVBPE.
	DSI_VMCR_LPVBPE = 0x200
	// Position of LPVFPE field.
	DSI_VMCR_LPVFPE_Pos = 0xa
	// Bit mask of LPVFPE field.
	DSI_VMCR_LPVFPE_Msk = 0x400
	// Bit LPVFPE.
	DSI_VMCR_LPVFPE = 0x400
	// Position of LPVAE field.
	DSI_VMCR_LPVAE_Pos = 0xb
	// Bit mask of LPVAE field.
	DSI_VMCR_LPVAE_Msk = 0x800
	// Bit LPVAE.
	DSI_VMCR_LPVAE = 0x800
	// Position of LPHBPE field.
	DSI_VMCR_LPHBPE_Pos = 0xc
	// Bit mask of LPHBPE field.
	DSI_VMCR_LPHBPE_Msk = 0x1000
	// Bit LPHBPE.
	DSI_VMCR_LPHBPE = 0x1000
	// Position of LPHFPE field.
	DSI_VMCR_LPHFPE_Pos = 0xd
	// Bit mask of LPHFPE field.
	DSI_VMCR_LPHFPE_Msk = 0x2000
	// Bit LPHFPE.
	DSI_VMCR_LPHFPE = 0x2000
	// Position of FBTAAE field.
	DSI_VMCR_FBTAAE_Pos = 0xe
	// Bit mask of FBTAAE field.
	DSI_VMCR_FBTAAE_Msk = 0x4000
	// Bit FBTAAE.
	DSI_VMCR_FBTAAE = 0x4000
	// Position of LPCE field.
	DSI_VMCR_LPCE_Pos = 0xf
	// Bit mask of LPCE field.
	DSI_VMCR_LPCE_Msk = 0x8000
	// Bit LPCE.
	DSI_VMCR_LPCE = 0x8000
	// Position of PGE field.
	DSI_VMCR_PGE_Pos = 0x10
	// Bit mask of PGE field.
	DSI_VMCR_PGE_Msk = 0x10000
	// Bit PGE.
	DSI_VMCR_PGE = 0x10000
	// Position of PGM field.
	DSI_VMCR_PGM_Pos = 0x14
	// Bit mask of PGM field.
	DSI_VMCR_PGM_Msk = 0x100000
	// Bit PGM.
	DSI_VMCR_PGM = 0x100000
	// Position of PGO field.
	DSI_VMCR_PGO_Pos = 0x18
	// Bit mask of PGO field.
	DSI_VMCR_PGO_Msk = 0x1000000
	// Bit PGO.
	DSI_VMCR_PGO = 0x1000000

	// VPCR: DSI Host Video Packet Configuration Register
	// Position of VPSIZE field.
	DSI_VPCR_VPSIZE_Pos = 0x0
	// Bit mask of VPSIZE field.
	DSI_VPCR_VPSIZE_Msk = 0x3fff

	// VCCR: DSI Host Video Chunks Configuration Register
	// Position of NUMC field.
	DSI_VCCR_NUMC_Pos = 0x0
	// Bit mask of NUMC field.
	DSI_VCCR_NUMC_Msk = 0x1fff

	// VNPCR: DSI Host Video Null Packet Configuration Register
	// Position of NPSIZE field.
	DSI_VNPCR_NPSIZE_Pos = 0x0
	// Bit mask of NPSIZE field.
	DSI_VNPCR_NPSIZE_Msk = 0x1fff

	// VHSACR: DSI Host Video HSA Configuration Register
	// Position of HSA field.
	DSI_VHSACR_HSA_Pos = 0x0
	// Bit mask of HSA field.
	DSI_VHSACR_HSA_Msk = 0xfff

	// VHBPCR: DSI Host Video HBP Configuration Register
	// Position of HBP field.
	DSI_VHBPCR_HBP_Pos = 0x0
	// Bit mask of HBP field.
	DSI_VHBPCR_HBP_Msk = 0xfff

	// VLCR: DSI Host Video Line Configuration Register
	// Position of HLINE field.
	DSI_VLCR_HLINE_Pos = 0x0
	// Bit mask of HLINE field.
	DSI_VLCR_HLINE_Msk = 0x7fff

	// VVSACR: DSI Host Video VSA Configuration Register
	// Position of VSA field.
	DSI_VVSACR_VSA_Pos = 0x0
	// Bit mask of VSA field.
	DSI_VVSACR_VSA_Msk = 0x3ff

	// VVBPCR: DSI Host Video VBP Configuration Register
	// Position of VBP field.
	DSI_VVBPCR_VBP_Pos = 0x0
	// Bit mask of VBP field.
	DSI_VVBPCR_VBP_Msk = 0x3ff

	// VVFPCR: DSI Host Video VFP Configuration Register
	// Position of VFP field.
	DSI_VVFPCR_VFP_Pos = 0x0
	// Bit mask of VFP field.
	DSI_VVFPCR_VFP_Msk = 0x3ff

	// VVACR: DSI Host Video VA Configuration Register
	// Position of VA field.
	DSI_VVACR_VA_Pos = 0x0
	// Bit mask of VA field.
	DSI_VVACR_VA_Msk = 0x3fff

	// LCCR: DSI Host LTDC Command Configuration Register
	// Position of CMDSIZE field.
	DSI_LCCR_CMDSIZE_Pos = 0x0
	// Bit mask of CMDSIZE field.
	DSI_LCCR_CMDSIZE_Msk = 0xffff

	// CMCR: DSI Host Command mode Configuration Register
	// Position of TEARE field.
	DSI_CMCR_TEARE_Pos = 0x0
	// Bit mask of TEARE field.
	DSI_CMCR_TEARE_Msk = 0x1
	// Bit TEARE.
	DSI_CMCR_TEARE = 0x1
	// Position of ARE field.
	DSI_CMCR_ARE_Pos = 0x1
	// Bit mask of ARE field.
	DSI_CMCR_ARE_Msk = 0x2
	// Bit ARE.
	DSI_CMCR_ARE = 0x2
	// Position of GSW0TX field.
	DSI_CMCR_GSW0TX_Pos = 0x8
	// Bit mask of GSW0TX field.
	DSI_CMCR_GSW0TX_Msk = 0x100
	// Bit GSW0TX.
	DSI_CMCR_GSW0TX = 0x100
	// Position of GSW1TX field.
	DSI_CMCR_GSW1TX_Pos = 0x9
	// Bit mask of GSW1TX field.
	DSI_CMCR_GSW1TX_Msk = 0x200
	// Bit GSW1TX.
	DSI_CMCR_GSW1TX = 0x200
	// Position of GSW2TX field.
	DSI_CMCR_GSW2TX_Pos = 0xa
	// Bit mask of GSW2TX field.
	DSI_CMCR_GSW2TX_Msk = 0x400
	// Bit GSW2TX.
	DSI_CMCR_GSW2TX = 0x400
	// Position of GSR0TX field.
	DSI_CMCR_GSR0TX_Pos = 0xb
	// Bit mask of GSR0TX field.
	DSI_CMCR_GSR0TX_Msk = 0x800
	// Bit GSR0TX.
	DSI_CMCR_GSR0TX = 0x800
	// Position of GSR1TX field.
	DSI_CMCR_GSR1TX_Pos = 0xc
	// Bit mask of GSR1TX field.
	DSI_CMCR_GSR1TX_Msk = 0x1000
	// Bit GSR1TX.
	DSI_CMCR_GSR1TX = 0x1000
	// Position of GSR2TX field.
	DSI_CMCR_GSR2TX_Pos = 0xd
	// Bit mask of GSR2TX field.
	DSI_CMCR_GSR2TX_Msk = 0x2000
	// Bit GSR2TX.
	DSI_CMCR_GSR2TX = 0x2000
	// Position of GLWTX field.
	DSI_CMCR_GLWTX_Pos = 0xe
	// Bit mask of GLWTX field.
	DSI_CMCR_GLWTX_Msk = 0x4000
	// Bit GLWTX.
	DSI_CMCR_GLWTX = 0x4000
	// Position of DSW0TX field.
	DSI_CMCR_DSW0TX_Pos = 0x10
	// Bit mask of DSW0TX field.
	DSI_CMCR_DSW0TX_Msk = 0x10000
	// Bit DSW0TX.
	DSI_CMCR_DSW0TX = 0x10000
	// Position of DSW1TX field.
	DSI_CMCR_DSW1TX_Pos = 0x11
	// Bit mask of DSW1TX field.
	DSI_CMCR_DSW1TX_Msk = 0x20000
	// Bit DSW1TX.
	DSI_CMCR_DSW1TX = 0x20000
	// Position of DSR0TX field.
	DSI_CMCR_DSR0TX_Pos = 0x12
	// Bit mask of DSR0TX field.
	DSI_CMCR_DSR0TX_Msk = 0x40000
	// Bit DSR0TX.
	DSI_CMCR_DSR0TX = 0x40000
	// Position of DLWTX field.
	DSI_CMCR_DLWTX_Pos = 0x13
	// Bit mask of DLWTX field.
	DSI_CMCR_DLWTX_Msk = 0x80000
	// Bit DLWTX.
	DSI_CMCR_DLWTX = 0x80000
	// Position of MRDPS field.
	DSI_CMCR_MRDPS_Pos = 0x18
	// Bit mask of MRDPS field.
	DSI_CMCR_MRDPS_Msk = 0x1000000
	// Bit MRDPS.
	DSI_CMCR_MRDPS = 0x1000000

	// GHCR: DSI Host Generic Header Configuration Register
	// Position of DT field.
	DSI_GHCR_DT_Pos = 0x0
	// Bit mask of DT field.
	DSI_GHCR_DT_Msk = 0x3f
	// Position of VCID field.
	DSI_GHCR_VCID_Pos = 0x6
	// Bit mask of VCID field.
	DSI_GHCR_VCID_Msk = 0xc0
	// Position of WCLSB field.
	DSI_GHCR_WCLSB_Pos = 0x8
	// Bit mask of WCLSB field.
	DSI_GHCR_WCLSB_Msk = 0xff00
	// Position of WCMSB field.
	DSI_GHCR_WCMSB_Pos = 0x10
	// Bit mask of WCMSB field.
	DSI_GHCR_WCMSB_Msk = 0xff0000

	// GPDR: DSI Host Generic Payload Data Register
	// Position of DATA1 field.
	DSI_GPDR_DATA1_Pos = 0x0
	// Bit mask of DATA1 field.
	DSI_GPDR_DATA1_Msk = 0xff
	// Position of DATA2 field.
	DSI_GPDR_DATA2_Pos = 0x8
	// Bit mask of DATA2 field.
	DSI_GPDR_DATA2_Msk = 0xff00
	// Position of DATA3 field.
	DSI_GPDR_DATA3_Pos = 0x10
	// Bit mask of DATA3 field.
	DSI_GPDR_DATA3_Msk = 0xff0000
	// Position of DATA4 field.
	DSI_GPDR_DATA4_Pos = 0x18
	// Bit mask of DATA4 field.
	DSI_GPDR_DATA4_Msk = 0xff000000

	// GPSR: DSI Host Generic Packet Status Register
	// Position of CMDFE field.
	DSI_GPSR_CMDFE_Pos = 0x0
	// Bit mask of CMDFE field.
	DSI_GPSR_CMDFE_Msk = 0x1
	// Bit CMDFE.
	DSI_GPSR_CMDFE = 0x1
	// Position of CMDFF field.
	DSI_GPSR_CMDFF_Pos = 0x1
	// Bit mask of CMDFF field.
	DSI_GPSR_CMDFF_Msk = 0x2
	// Bit CMDFF.
	DSI_GPSR_CMDFF = 0x2
	// Position of PWRFE field.
	DSI_GPSR_PWRFE_Pos = 0x2
	// Bit mask of PWRFE field.
	DSI_GPSR_PWRFE_Msk = 0x4
	// Bit PWRFE.
	DSI_GPSR_PWRFE = 0x4
	// Position of PWRFF field.
	DSI_GPSR_PWRFF_Pos = 0x3
	// Bit mask of PWRFF field.
	DSI_GPSR_PWRFF_Msk = 0x8
	// Bit PWRFF.
	DSI_GPSR_PWRFF = 0x8
	// Position of PRDFE field.
	DSI_GPSR_PRDFE_Pos = 0x4
	// Bit mask of PRDFE field.
	DSI_GPSR_PRDFE_Msk = 0x10
	// Bit PRDFE.
	DSI_GPSR_PRDFE = 0x10
	// Position of PRDFF field.
	DSI_GPSR_PRDFF_Pos = 0x5
	// Bit mask of PRDFF field.
	DSI_GPSR_PRDFF_Msk = 0x20
	// Bit PRDFF.
	DSI_GPSR_PRDFF = 0x20
	// Position of RCB field.
	DSI_GPSR_RCB_Pos = 0x6
	// Bit mask of RCB field.
	DSI_GPSR_RCB_Msk = 0x40
	// Bit RCB.
	DSI_GPSR_RCB = 0x40

	// TCCR0: DSI Host Timeout Counter Configuration Register 0
	// Position of LPRX_TOCNT field.
	DSI_TCCR0_LPRX_TOCNT_Pos = 0x0
	// Bit mask of LPRX_TOCNT field.
	DSI_TCCR0_LPRX_TOCNT_Msk = 0xffff
	// Position of HSTX_TOCNT field.
	DSI_TCCR0_HSTX_TOCNT_Pos = 0x10
	// Bit mask of HSTX_TOCNT field.
	DSI_TCCR0_HSTX_TOCNT_Msk = 0xffff0000

	// TCCR1: DSI Host Timeout Counter Configuration Register 1
	// Position of HSRD_TOCNT field.
	DSI_TCCR1_HSRD_TOCNT_Pos = 0x0
	// Bit mask of HSRD_TOCNT field.
	DSI_TCCR1_HSRD_TOCNT_Msk = 0xffff

	// TCCR2: DSI Host Timeout Counter Configuration Register 2
	// Position of LPRD_TOCNT field.
	DSI_TCCR2_LPRD_TOCNT_Pos = 0x0
	// Bit mask of LPRD_TOCNT field.
	DSI_TCCR2_LPRD_TOCNT_Msk = 0xffff

	// TCCR3: DSI Host Timeout Counter Configuration Register 3
	// Position of HSWR_TOCNT field.
	DSI_TCCR3_HSWR_TOCNT_Pos = 0x0
	// Bit mask of HSWR_TOCNT field.
	DSI_TCCR3_HSWR_TOCNT_Msk = 0xffff
	// Position of PM field.
	DSI_TCCR3_PM_Pos = 0x18
	// Bit mask of PM field.
	DSI_TCCR3_PM_Msk = 0x1000000
	// Bit PM.
	DSI_TCCR3_PM = 0x1000000

	// TCCR4: DSI Host Timeout Counter Configuration Register 4
	// Position of LSWR_TOCNT field.
	DSI_TCCR4_LSWR_TOCNT_Pos = 0x0
	// Bit mask of LSWR_TOCNT field.
	DSI_TCCR4_LSWR_TOCNT_Msk = 0xffff

	// TCCR5: DSI Host Timeout Counter Configuration Register 5
	// Position of BTA_TOCNT field.
	DSI_TCCR5_BTA_TOCNT_Pos = 0x0
	// Bit mask of BTA_TOCNT field.
	DSI_TCCR5_BTA_TOCNT_Msk = 0xffff

	// CLCR: DSI Host Clock Lane Configuration Register
	// Position of DPCC field.
	DSI_CLCR_DPCC_Pos = 0x0
	// Bit mask of DPCC field.
	DSI_CLCR_DPCC_Msk = 0x1
	// Bit DPCC.
	DSI_CLCR_DPCC = 0x1
	// Position of ACR field.
	DSI_CLCR_ACR_Pos = 0x1
	// Bit mask of ACR field.
	DSI_CLCR_ACR_Msk = 0x2
	// Bit ACR.
	DSI_CLCR_ACR = 0x2

	// CLTCR: DSI Host Clock Lane Timer Configuration Register
	// Position of LP2HS_TIME field.
	DSI_CLTCR_LP2HS_TIME_Pos = 0x0
	// Bit mask of LP2HS_TIME field.
	DSI_CLTCR_LP2HS_TIME_Msk = 0x3ff
	// Position of HS2LP_TIME field.
	DSI_CLTCR_HS2LP_TIME_Pos = 0x10
	// Bit mask of HS2LP_TIME field.
	DSI_CLTCR_HS2LP_TIME_Msk = 0x3ff0000

	// DLTCR: DSI Host Data Lane Timer Configuration Register
	// Position of MRD_TIME field.
	DSI_DLTCR_MRD_TIME_Pos = 0x0
	// Bit mask of MRD_TIME field.
	DSI_DLTCR_MRD_TIME_Msk = 0x7fff
	// Position of LP2HS_TIME field.
	DSI_DLTCR_LP2HS_TIME_Pos = 0x10
	// Bit mask of LP2HS_TIME field.
	DSI_DLTCR_LP2HS_TIME_Msk = 0xff0000
	// Position of HS2LP_TIME field.
	DSI_DLTCR_HS2LP_TIME_Pos = 0x18
	// Bit mask of HS2LP_TIME field.
	DSI_DLTCR_HS2LP_TIME_Msk = 0xff000000

	// PCTLR: DSI Host PHY Control Register
	// Position of DEN field.
	DSI_PCTLR_DEN_Pos = 0x1
	// Bit mask of DEN field.
	DSI_PCTLR_DEN_Msk = 0x2
	// Bit DEN.
	DSI_PCTLR_DEN = 0x2
	// Position of CKE field.
	DSI_PCTLR_CKE_Pos = 0x2
	// Bit mask of CKE field.
	DSI_PCTLR_CKE_Msk = 0x4
	// Bit CKE.
	DSI_PCTLR_CKE = 0x4

	// PCONFR: DSI Host PHY Configuration Register
	// Position of NL field.
	DSI_PCONFR_NL_Pos = 0x0
	// Bit mask of NL field.
	DSI_PCONFR_NL_Msk = 0x3
	// Position of SW_TIME field.
	DSI_PCONFR_SW_TIME_Pos = 0x8
	// Bit mask of SW_TIME field.
	DSI_PCONFR_SW_TIME_Msk = 0xff00

	// PUCR: DSI Host PHY ULPS Control Register
	// Position of URCL field.
	DSI_PUCR_URCL_Pos = 0x0
	// Bit mask of URCL field.
	DSI_PUCR_URCL_Msk = 0x1
	// Bit URCL.
	DSI_PUCR_URCL = 0x1
	// Position of UECL field.
	DSI_PUCR_UECL_Pos = 0x1
	// Bit mask of UECL field.
	DSI_PUCR_UECL_Msk = 0x2
	// Bit UECL.
	DSI_PUCR_UECL = 0x2
	// Position of URDL field.
	DSI_PUCR_URDL_Pos = 0x2
	// Bit mask of URDL field.
	DSI_PUCR_URDL_Msk = 0x4
	// Bit URDL.
	DSI_PUCR_URDL = 0x4
	// Position of UEDL field.
	DSI_PUCR_UEDL_Pos = 0x3
	// Bit mask of UEDL field.
	DSI_PUCR_UEDL_Msk = 0x8
	// Bit UEDL.
	DSI_PUCR_UEDL = 0x8

	// PTTCR: DSI Host PHY TX Triggers Configuration Register
	// Position of TX_TRIG field.
	DSI_PTTCR_TX_TRIG_Pos = 0x0
	// Bit mask of TX_TRIG field.
	DSI_PTTCR_TX_TRIG_Msk = 0xf

	// PSR: DSI Host PHY Status Register
	// Position of PD field.
	DSI_PSR_PD_Pos = 0x1
	// Bit mask of PD field.
	DSI_PSR_PD_Msk = 0x2
	// Bit PD.
	DSI_PSR_PD = 0x2
	// Position of PSSC field.
	DSI_PSR_PSSC_Pos = 0x2
	// Bit mask of PSSC field.
	DSI_PSR_PSSC_Msk = 0x4
	// Bit PSSC.
	DSI_PSR_PSSC = 0x4
	// Position of UANC field.
	DSI_PSR_UANC_Pos = 0x3
	// Bit mask of UANC field.
	DSI_PSR_UANC_Msk = 0x8
	// Bit UANC.
	DSI_PSR_UANC = 0x8
	// Position of PSS0 field.
	DSI_PSR_PSS0_Pos = 0x4
	// Bit mask of PSS0 field.
	DSI_PSR_PSS0_Msk = 0x10
	// Bit PSS0.
	DSI_PSR_PSS0 = 0x10
	// Position of UAN0 field.
	DSI_PSR_UAN0_Pos = 0x5
	// Bit mask of UAN0 field.
	DSI_PSR_UAN0_Msk = 0x20
	// Bit UAN0.
	DSI_PSR_UAN0 = 0x20
	// Position of RUE0 field.
	DSI_PSR_RUE0_Pos = 0x6
	// Bit mask of RUE0 field.
	DSI_PSR_RUE0_Msk = 0x40
	// Bit RUE0.
	DSI_PSR_RUE0 = 0x40
	// Position of PSS1 field.
	DSI_PSR_PSS1_Pos = 0x7
	// Bit mask of PSS1 field.
	DSI_PSR_PSS1_Msk = 0x80
	// Bit PSS1.
	DSI_PSR_PSS1 = 0x80
	// Position of UAN1 field.
	DSI_PSR_UAN1_Pos = 0x8
	// Bit mask of UAN1 field.
	DSI_PSR_UAN1_Msk = 0x100
	// Bit UAN1.
	DSI_PSR_UAN1 = 0x100

	// ISR0: DSI Host Interrupt & Status Register 0
	// Position of AE0 field.
	DSI_ISR0_AE0_Pos = 0x0
	// Bit mask of AE0 field.
	DSI_ISR0_AE0_Msk = 0x1
	// Bit AE0.
	DSI_ISR0_AE0 = 0x1
	// Position of AE1 field.
	DSI_ISR0_AE1_Pos = 0x1
	// Bit mask of AE1 field.
	DSI_ISR0_AE1_Msk = 0x2
	// Bit AE1.
	DSI_ISR0_AE1 = 0x2
	// Position of AE2 field.
	DSI_ISR0_AE2_Pos = 0x2
	// Bit mask of AE2 field.
	DSI_ISR0_AE2_Msk = 0x4
	// Bit AE2.
	DSI_ISR0_AE2 = 0x4
	// Position of AE3 field.
	DSI_ISR0_AE3_Pos = 0x3
	// Bit mask of AE3 field.
	DSI_ISR0_AE3_Msk = 0x8
	// Bit AE3.
	DSI_ISR0_AE3 = 0x8
	// Position of AE4 field.
	DSI_ISR0_AE4_Pos = 0x4
	// Bit mask of AE4 field.
	DSI_ISR0_AE4_Msk = 0x10
	// Bit AE4.
	DSI_ISR0_AE4 = 0x10
	// Position of AE5 field.
	DSI_ISR0_AE5_Pos = 0x5
	// Bit mask of AE5 field.
	DSI_ISR0_AE5_Msk = 0x20
	// Bit AE5.
	DSI_ISR0_AE5 = 0x20
	// Position of AE6 field.
	DSI_ISR0_AE6_Pos = 0x6
	// Bit mask of AE6 field.
	DSI_ISR0_AE6_Msk = 0x40
	// Bit AE6.
	DSI_ISR0_AE6 = 0x40
	// Position of AE7 field.
	DSI_ISR0_AE7_Pos = 0x7
	// Bit mask of AE7 field.
	DSI_ISR0_AE7_Msk = 0x80
	// Bit AE7.
	DSI_ISR0_AE7 = 0x80
	// Position of AE8 field.
	DSI_ISR0_AE8_Pos = 0x8
	// Bit mask of AE8 field.
	DSI_ISR0_AE8_Msk = 0x100
	// Bit AE8.
	DSI_ISR0_AE8 = 0x100
	// Position of AE9 field.
	DSI_ISR0_AE9_Pos = 0x9
	// Bit mask of AE9 field.
	DSI_ISR0_AE9_Msk = 0x200
	// Bit AE9.
	DSI_ISR0_AE9 = 0x200
	// Position of AE10 field.
	DSI_ISR0_AE10_Pos = 0xa
	// Bit mask of AE10 field.
	DSI_ISR0_AE10_Msk = 0x400
	// Bit AE10.
	DSI_ISR0_AE10 = 0x400
	// Position of AE11 field.
	DSI_ISR0_AE11_Pos = 0xb
	// Bit mask of AE11 field.
	DSI_ISR0_AE11_Msk = 0x800
	// Bit AE11.
	DSI_ISR0_AE11 = 0x800
	// Position of AE12 field.
	DSI_ISR0_AE12_Pos = 0xc
	// Bit mask of AE12 field.
	DSI_ISR0_AE12_Msk = 0x1000
	// Bit AE12.
	DSI_ISR0_AE12 = 0x1000
	// Position of AE13 field.
	DSI_ISR0_AE13_Pos = 0xd
	// Bit mask of AE13 field.
	DSI_ISR0_AE13_Msk = 0x2000
	// Bit AE13.
	DSI_ISR0_AE13 = 0x2000
	// Position of AE14 field.
	DSI_ISR0_AE14_Pos = 0xe
	// Bit mask of AE14 field.
	DSI_ISR0_AE14_Msk = 0x4000
	// Bit AE14.
	DSI_ISR0_AE14 = 0x4000
	// Position of AE15 field.
	DSI_ISR0_AE15_Pos = 0xf
	// Bit mask of AE15 field.
	DSI_ISR0_AE15_Msk = 0x8000
	// Bit AE15.
	DSI_ISR0_AE15 = 0x8000
	// Position of PE0 field.
	DSI_ISR0_PE0_Pos = 0x10
	// Bit mask of PE0 field.
	DSI_ISR0_PE0_Msk = 0x10000
	// Bit PE0.
	DSI_ISR0_PE0 = 0x10000
	// Position of PE1 field.
	DSI_ISR0_PE1_Pos = 0x11
	// Bit mask of PE1 field.
	DSI_ISR0_PE1_Msk = 0x20000
	// Bit PE1.
	DSI_ISR0_PE1 = 0x20000
	// Position of PE2 field.
	DSI_ISR0_PE2_Pos = 0x12
	// Bit mask of PE2 field.
	DSI_ISR0_PE2_Msk = 0x40000
	// Bit PE2.
	DSI_ISR0_PE2 = 0x40000
	// Position of PE3 field.
	DSI_ISR0_PE3_Pos = 0x13
	// Bit mask of PE3 field.
	DSI_ISR0_PE3_Msk = 0x80000
	// Bit PE3.
	DSI_ISR0_PE3 = 0x80000
	// Position of PE4 field.
	DSI_ISR0_PE4_Pos = 0x14
	// Bit mask of PE4 field.
	DSI_ISR0_PE4_Msk = 0x100000
	// Bit PE4.
	DSI_ISR0_PE4 = 0x100000

	// ISR1: DSI Host Interrupt & Status Register 1
	// Position of TOHSTX field.
	DSI_ISR1_TOHSTX_Pos = 0x0
	// Bit mask of TOHSTX field.
	DSI_ISR1_TOHSTX_Msk = 0x1
	// Bit TOHSTX.
	DSI_ISR1_TOHSTX = 0x1
	// Position of TOLPRX field.
	DSI_ISR1_TOLPRX_Pos = 0x1
	// Bit mask of TOLPRX field.
	DSI_ISR1_TOLPRX_Msk = 0x2
	// Bit TOLPRX.
	DSI_ISR1_TOLPRX = 0x2
	// Position of ECCSE field.
	DSI_ISR1_ECCSE_Pos = 0x2
	// Bit mask of ECCSE field.
	DSI_ISR1_ECCSE_Msk = 0x4
	// Bit ECCSE.
	DSI_ISR1_ECCSE = 0x4
	// Position of ECCME field.
	DSI_ISR1_ECCME_Pos = 0x3
	// Bit mask of ECCME field.
	DSI_ISR1_ECCME_Msk = 0x8
	// Bit ECCME.
	DSI_ISR1_ECCME = 0x8
	// Position of CRCE field.
	DSI_ISR1_CRCE_Pos = 0x4
	// Bit mask of CRCE field.
	DSI_ISR1_CRCE_Msk = 0x10
	// Bit CRCE.
	DSI_ISR1_CRCE = 0x10
	// Position of PSE field.
	DSI_ISR1_PSE_Pos = 0x5
	// Bit mask of PSE field.
	DSI_ISR1_PSE_Msk = 0x20
	// Bit PSE.
	DSI_ISR1_PSE = 0x20
	// Position of EOTPE field.
	DSI_ISR1_EOTPE_Pos = 0x6
	// Bit mask of EOTPE field.
	DSI_ISR1_EOTPE_Msk = 0x40
	// Bit EOTPE.
	DSI_ISR1_EOTPE = 0x40
	// Position of LPWRE field.
	DSI_ISR1_LPWRE_Pos = 0x7
	// Bit mask of LPWRE field.
	DSI_ISR1_LPWRE_Msk = 0x80
	// Bit LPWRE.
	DSI_ISR1_LPWRE = 0x80
	// Position of GCWRE field.
	DSI_ISR1_GCWRE_Pos = 0x8
	// Bit mask of GCWRE field.
	DSI_ISR1_GCWRE_Msk = 0x100
	// Bit GCWRE.
	DSI_ISR1_GCWRE = 0x100
	// Position of GPWRE field.
	DSI_ISR1_GPWRE_Pos = 0x9
	// Bit mask of GPWRE field.
	DSI_ISR1_GPWRE_Msk = 0x200
	// Bit GPWRE.
	DSI_ISR1_GPWRE = 0x200
	// Position of GPTXE field.
	DSI_ISR1_GPTXE_Pos = 0xa
	// Bit mask of GPTXE field.
	DSI_ISR1_GPTXE_Msk = 0x400
	// Bit GPTXE.
	DSI_ISR1_GPTXE = 0x400
	// Position of GPRDE field.
	DSI_ISR1_GPRDE_Pos = 0xb
	// Bit mask of GPRDE field.
	DSI_ISR1_GPRDE_Msk = 0x800
	// Bit GPRDE.
	DSI_ISR1_GPRDE = 0x800
	// Position of GPRXE field.
	DSI_ISR1_GPRXE_Pos = 0xc
	// Bit mask of GPRXE field.
	DSI_ISR1_GPRXE_Msk = 0x1000
	// Bit GPRXE.
	DSI_ISR1_GPRXE = 0x1000

	// IER0: DSI Host Interrupt Enable Register 0
	// Position of AE0IE field.
	DSI_IER0_AE0IE_Pos = 0x0
	// Bit mask of AE0IE field.
	DSI_IER0_AE0IE_Msk = 0x1
	// Bit AE0IE.
	DSI_IER0_AE0IE = 0x1
	// Position of AE1IE field.
	DSI_IER0_AE1IE_Pos = 0x1
	// Bit mask of AE1IE field.
	DSI_IER0_AE1IE_Msk = 0x2
	// Bit AE1IE.
	DSI_IER0_AE1IE = 0x2
	// Position of AE2IE field.
	DSI_IER0_AE2IE_Pos = 0x2
	// Bit mask of AE2IE field.
	DSI_IER0_AE2IE_Msk = 0x4
	// Bit AE2IE.
	DSI_IER0_AE2IE = 0x4
	// Position of AE3IE field.
	DSI_IER0_AE3IE_Pos = 0x3
	// Bit mask of AE3IE field.
	DSI_IER0_AE3IE_Msk = 0x8
	// Bit AE3IE.
	DSI_IER0_AE3IE = 0x8
	// Position of AE4IE field.
	DSI_IER0_AE4IE_Pos = 0x4
	// Bit mask of AE4IE field.
	DSI_IER0_AE4IE_Msk = 0x10
	// Bit AE4IE.
	DSI_IER0_AE4IE = 0x10
	// Position of AE5IE field.
	DSI_IER0_AE5IE_Pos = 0x5
	// Bit mask of AE5IE field.
	DSI_IER0_AE5IE_Msk = 0x20
	// Bit AE5IE.
	DSI_IER0_AE5IE = 0x20
	// Position of AE6IE field.
	DSI_IER0_AE6IE_Pos = 0x6
	// Bit mask of AE6IE field.
	DSI_IER0_AE6IE_Msk = 0x40
	// Bit AE6IE.
	DSI_IER0_AE6IE = 0x40
	// Position of AE7IE field.
	DSI_IER0_AE7IE_Pos = 0x7
	// Bit mask of AE7IE field.
	DSI_IER0_AE7IE_Msk = 0x80
	// Bit AE7IE.
	DSI_IER0_AE7IE = 0x80
	// Position of AE8IE field.
	DSI_IER0_AE8IE_Pos = 0x8
	// Bit mask of AE8IE field.
	DSI_IER0_AE8IE_Msk = 0x100
	// Bit AE8IE.
	DSI_IER0_AE8IE = 0x100
	// Position of AE9IE field.
	DSI_IER0_AE9IE_Pos = 0x9
	// Bit mask of AE9IE field.
	DSI_IER0_AE9IE_Msk = 0x200
	// Bit AE9IE.
	DSI_IER0_AE9IE = 0x200
	// Position of AE10IE field.
	DSI_IER0_AE10IE_Pos = 0xa
	// Bit mask of AE10IE field.
	DSI_IER0_AE10IE_Msk = 0x400
	// Bit AE10IE.
	DSI_IER0_AE10IE = 0x400
	// Position of AE11IE field.
	DSI_IER0_AE11IE_Pos = 0xb
	// Bit mask of AE11IE field.
	DSI_IER0_AE11IE_Msk = 0x800
	// Bit AE11IE.
	DSI_IER0_AE11IE = 0x800
	// Position of AE12IE field.
	DSI_IER0_AE12IE_Pos = 0xc
	// Bit mask of AE12IE field.
	DSI_IER0_AE12IE_Msk = 0x1000
	// Bit AE12IE.
	DSI_IER0_AE12IE = 0x1000
	// Position of AE13IE field.
	DSI_IER0_AE13IE_Pos = 0xd
	// Bit mask of AE13IE field.
	DSI_IER0_AE13IE_Msk = 0x2000
	// Bit AE13IE.
	DSI_IER0_AE13IE = 0x2000
	// Position of AE14IE field.
	DSI_IER0_AE14IE_Pos = 0xe
	// Bit mask of AE14IE field.
	DSI_IER0_AE14IE_Msk = 0x4000
	// Bit AE14IE.
	DSI_IER0_AE14IE = 0x4000
	// Position of AE15IE field.
	DSI_IER0_AE15IE_Pos = 0xf
	// Bit mask of AE15IE field.
	DSI_IER0_AE15IE_Msk = 0x8000
	// Bit AE15IE.
	DSI_IER0_AE15IE = 0x8000
	// Position of PE0IE field.
	DSI_IER0_PE0IE_Pos = 0x10
	// Bit mask of PE0IE field.
	DSI_IER0_PE0IE_Msk = 0x10000
	// Bit PE0IE.
	DSI_IER0_PE0IE = 0x10000
	// Position of PE1IE field.
	DSI_IER0_PE1IE_Pos = 0x11
	// Bit mask of PE1IE field.
	DSI_IER0_PE1IE_Msk = 0x20000
	// Bit PE1IE.
	DSI_IER0_PE1IE = 0x20000
	// Position of PE2IE field.
	DSI_IER0_PE2IE_Pos = 0x12
	// Bit mask of PE2IE field.
	DSI_IER0_PE2IE_Msk = 0x40000
	// Bit PE2IE.
	DSI_IER0_PE2IE = 0x40000
	// Position of PE3IE field.
	DSI_IER0_PE3IE_Pos = 0x13
	// Bit mask of PE3IE field.
	DSI_IER0_PE3IE_Msk = 0x80000
	// Bit PE3IE.
	DSI_IER0_PE3IE = 0x80000
	// Position of PE4IE field.
	DSI_IER0_PE4IE_Pos = 0x14
	// Bit mask of PE4IE field.
	DSI_IER0_PE4IE_Msk = 0x100000
	// Bit PE4IE.
	DSI_IER0_PE4IE = 0x100000

	// IER1: DSI Host Interrupt Enable Register 1
	// Position of TOHSTXIE field.
	DSI_IER1_TOHSTXIE_Pos = 0x0
	// Bit mask of TOHSTXIE field.
	DSI_IER1_TOHSTXIE_Msk = 0x1
	// Bit TOHSTXIE.
	DSI_IER1_TOHSTXIE = 0x1
	// Position of TOLPRXIE field.
	DSI_IER1_TOLPRXIE_Pos = 0x1
	// Bit mask of TOLPRXIE field.
	DSI_IER1_TOLPRXIE_Msk = 0x2
	// Bit TOLPRXIE.
	DSI_IER1_TOLPRXIE = 0x2
	// Position of ECCSEIE field.
	DSI_IER1_ECCSEIE_Pos = 0x2
	// Bit mask of ECCSEIE field.
	DSI_IER1_ECCSEIE_Msk = 0x4
	// Bit ECCSEIE.
	DSI_IER1_ECCSEIE = 0x4
	// Position of ECCMEIE field.
	DSI_IER1_ECCMEIE_Pos = 0x3
	// Bit mask of ECCMEIE field.
	DSI_IER1_ECCMEIE_Msk = 0x8
	// Bit ECCMEIE.
	DSI_IER1_ECCMEIE = 0x8
	// Position of CRCEIE field.
	DSI_IER1_CRCEIE_Pos = 0x4
	// Bit mask of CRCEIE field.
	DSI_IER1_CRCEIE_Msk = 0x10
	// Bit CRCEIE.
	DSI_IER1_CRCEIE = 0x10
	// Position of PSEIE field.
	DSI_IER1_PSEIE_Pos = 0x5
	// Bit mask of PSEIE field.
	DSI_IER1_PSEIE_Msk = 0x20
	// Bit PSEIE.
	DSI_IER1_PSEIE = 0x20
	// Position of EOTPEIE field.
	DSI_IER1_EOTPEIE_Pos = 0x6
	// Bit mask of EOTPEIE field.
	DSI_IER1_EOTPEIE_Msk = 0x40
	// Bit EOTPEIE.
	DSI_IER1_EOTPEIE = 0x40
	// Position of LPWREIE field.
	DSI_IER1_LPWREIE_Pos = 0x7
	// Bit mask of LPWREIE field.
	DSI_IER1_LPWREIE_Msk = 0x80
	// Bit LPWREIE.
	DSI_IER1_LPWREIE = 0x80
	// Position of GCWREIE field.
	DSI_IER1_GCWREIE_Pos = 0x8
	// Bit mask of GCWREIE field.
	DSI_IER1_GCWREIE_Msk = 0x100
	// Bit GCWREIE.
	DSI_IER1_GCWREIE = 0x100
	// Position of GPWREIE field.
	DSI_IER1_GPWREIE_Pos = 0x9
	// Bit mask of GPWREIE field.
	DSI_IER1_GPWREIE_Msk = 0x200
	// Bit GPWREIE.
	DSI_IER1_GPWREIE = 0x200
	// Position of GPTXEIE field.
	DSI_IER1_GPTXEIE_Pos = 0xa
	// Bit mask of GPTXEIE field.
	DSI_IER1_GPTXEIE_Msk = 0x400
	// Bit GPTXEIE.
	DSI_IER1_GPTXEIE = 0x400
	// Position of GPRDEIE field.
	DSI_IER1_GPRDEIE_Pos = 0xb
	// Bit mask of GPRDEIE field.
	DSI_IER1_GPRDEIE_Msk = 0x800
	// Bit GPRDEIE.
	DSI_IER1_GPRDEIE = 0x800
	// Position of GPRXEIE field.
	DSI_IER1_GPRXEIE_Pos = 0xc
	// Bit mask of GPRXEIE field.
	DSI_IER1_GPRXEIE_Msk = 0x1000
	// Bit GPRXEIE.
	DSI_IER1_GPRXEIE = 0x1000

	// FIR0: DSI Host Force Interrupt Register 0
	// Position of FAE0 field.
	DSI_FIR0_FAE0_Pos = 0x0
	// Bit mask of FAE0 field.
	DSI_FIR0_FAE0_Msk = 0x1
	// Bit FAE0.
	DSI_FIR0_FAE0 = 0x1
	// Position of FAE1 field.
	DSI_FIR0_FAE1_Pos = 0x1
	// Bit mask of FAE1 field.
	DSI_FIR0_FAE1_Msk = 0x2
	// Bit FAE1.
	DSI_FIR0_FAE1 = 0x2
	// Position of FAE2 field.
	DSI_FIR0_FAE2_Pos = 0x2
	// Bit mask of FAE2 field.
	DSI_FIR0_FAE2_Msk = 0x4
	// Bit FAE2.
	DSI_FIR0_FAE2 = 0x4
	// Position of FAE3 field.
	DSI_FIR0_FAE3_Pos = 0x3
	// Bit mask of FAE3 field.
	DSI_FIR0_FAE3_Msk = 0x8
	// Bit FAE3.
	DSI_FIR0_FAE3 = 0x8
	// Position of FAE4 field.
	DSI_FIR0_FAE4_Pos = 0x4
	// Bit mask of FAE4 field.
	DSI_FIR0_FAE4_Msk = 0x10
	// Bit FAE4.
	DSI_FIR0_FAE4 = 0x10
	// Position of FAE5 field.
	DSI_FIR0_FAE5_Pos = 0x5
	// Bit mask of FAE5 field.
	DSI_FIR0_FAE5_Msk = 0x20
	// Bit FAE5.
	DSI_FIR0_FAE5 = 0x20
	// Position of FAE6 field.
	DSI_FIR0_FAE6_Pos = 0x6
	// Bit mask of FAE6 field.
	DSI_FIR0_FAE6_Msk = 0x40
	// Bit FAE6.
	DSI_FIR0_FAE6 = 0x40
	// Position of FAE7 field.
	DSI_FIR0_FAE7_Pos = 0x7
	// Bit mask of FAE7 field.
	DSI_FIR0_FAE7_Msk = 0x80
	// Bit FAE7.
	DSI_FIR0_FAE7 = 0x80
	// Position of FAE8 field.
	DSI_FIR0_FAE8_Pos = 0x8
	// Bit mask of FAE8 field.
	DSI_FIR0_FAE8_Msk = 0x100
	// Bit FAE8.
	DSI_FIR0_FAE8 = 0x100
	// Position of FAE9 field.
	DSI_FIR0_FAE9_Pos = 0x9
	// Bit mask of FAE9 field.
	DSI_FIR0_FAE9_Msk = 0x200
	// Bit FAE9.
	DSI_FIR0_FAE9 = 0x200
	// Position of FAE10 field.
	DSI_FIR0_FAE10_Pos = 0xa
	// Bit mask of FAE10 field.
	DSI_FIR0_FAE10_Msk = 0x400
	// Bit FAE10.
	DSI_FIR0_FAE10 = 0x400
	// Position of FAE11 field.
	DSI_FIR0_FAE11_Pos = 0xb
	// Bit mask of FAE11 field.
	DSI_FIR0_FAE11_Msk = 0x800
	// Bit FAE11.
	DSI_FIR0_FAE11 = 0x800
	// Position of FAE12 field.
	DSI_FIR0_FAE12_Pos = 0xc
	// Bit mask of FAE12 field.
	DSI_FIR0_FAE12_Msk = 0x1000
	// Bit FAE12.
	DSI_FIR0_FAE12 = 0x1000
	// Position of FAE13 field.
	DSI_FIR0_FAE13_Pos = 0xd
	// Bit mask of FAE13 field.
	DSI_FIR0_FAE13_Msk = 0x2000
	// Bit FAE13.
	DSI_FIR0_FAE13 = 0x2000
	// Position of FAE14 field.
	DSI_FIR0_FAE14_Pos = 0xe
	// Bit mask of FAE14 field.
	DSI_FIR0_FAE14_Msk = 0x4000
	// Bit FAE14.
	DSI_FIR0_FAE14 = 0x4000
	// Position of FAE15 field.
	DSI_FIR0_FAE15_Pos = 0xf
	// Bit mask of FAE15 field.
	DSI_FIR0_FAE15_Msk = 0x8000
	// Bit FAE15.
	DSI_FIR0_FAE15 = 0x8000
	// Position of FPE0 field.
	DSI_FIR0_FPE0_Pos = 0x10
	// Bit mask of FPE0 field.
	DSI_FIR0_FPE0_Msk = 0x10000
	// Bit FPE0.
	DSI_FIR0_FPE0 = 0x10000
	// Position of FPE1 field.
	DSI_FIR0_FPE1_Pos = 0x11
	// Bit mask of FPE1 field.
	DSI_FIR0_FPE1_Msk = 0x20000
	// Bit FPE1.
	DSI_FIR0_FPE1 = 0x20000
	// Position of FPE2 field.
	DSI_FIR0_FPE2_Pos = 0x12
	// Bit mask of FPE2 field.
	DSI_FIR0_FPE2_Msk = 0x40000
	// Bit FPE2.
	DSI_FIR0_FPE2 = 0x40000
	// Position of FPE3 field.
	DSI_FIR0_FPE3_Pos = 0x13
	// Bit mask of FPE3 field.
	DSI_FIR0_FPE3_Msk = 0x80000
	// Bit FPE3.
	DSI_FIR0_FPE3 = 0x80000
	// Position of FPE4 field.
	DSI_FIR0_FPE4_Pos = 0x14
	// Bit mask of FPE4 field.
	DSI_FIR0_FPE4_Msk = 0x100000
	// Bit FPE4.
	DSI_FIR0_FPE4 = 0x100000

	// FIR1: DSI Host Force Interrupt Register 1
	// Position of FTOHSTX field.
	DSI_FIR1_FTOHSTX_Pos = 0x0
	// Bit mask of FTOHSTX field.
	DSI_FIR1_FTOHSTX_Msk = 0x1
	// Bit FTOHSTX.
	DSI_FIR1_FTOHSTX = 0x1
	// Position of FTOLPRX field.
	DSI_FIR1_FTOLPRX_Pos = 0x1
	// Bit mask of FTOLPRX field.
	DSI_FIR1_FTOLPRX_Msk = 0x2
	// Bit FTOLPRX.
	DSI_FIR1_FTOLPRX = 0x2
	// Position of FECCSE field.
	DSI_FIR1_FECCSE_Pos = 0x2
	// Bit mask of FECCSE field.
	DSI_FIR1_FECCSE_Msk = 0x4
	// Bit FECCSE.
	DSI_FIR1_FECCSE = 0x4
	// Position of FECCME field.
	DSI_FIR1_FECCME_Pos = 0x3
	// Bit mask of FECCME field.
	DSI_FIR1_FECCME_Msk = 0x8
	// Bit FECCME.
	DSI_FIR1_FECCME = 0x8
	// Position of FCRCE field.
	DSI_FIR1_FCRCE_Pos = 0x4
	// Bit mask of FCRCE field.
	DSI_FIR1_FCRCE_Msk = 0x10
	// Bit FCRCE.
	DSI_FIR1_FCRCE = 0x10
	// Position of FPSE field.
	DSI_FIR1_FPSE_Pos = 0x5
	// Bit mask of FPSE field.
	DSI_FIR1_FPSE_Msk = 0x20
	// Bit FPSE.
	DSI_FIR1_FPSE = 0x20
	// Position of FEOTPE field.
	DSI_FIR1_FEOTPE_Pos = 0x6
	// Bit mask of FEOTPE field.
	DSI_FIR1_FEOTPE_Msk = 0x40
	// Bit FEOTPE.
	DSI_FIR1_FEOTPE = 0x40
	// Position of FLPWRE field.
	DSI_FIR1_FLPWRE_Pos = 0x7
	// Bit mask of FLPWRE field.
	DSI_FIR1_FLPWRE_Msk = 0x80
	// Bit FLPWRE.
	DSI_FIR1_FLPWRE = 0x80
	// Position of FGCWRE field.
	DSI_FIR1_FGCWRE_Pos = 0x8
	// Bit mask of FGCWRE field.
	DSI_FIR1_FGCWRE_Msk = 0x100
	// Bit FGCWRE.
	DSI_FIR1_FGCWRE = 0x100
	// Position of FGPWRE field.
	DSI_FIR1_FGPWRE_Pos = 0x9
	// Bit mask of FGPWRE field.
	DSI_FIR1_FGPWRE_Msk = 0x200
	// Bit FGPWRE.
	DSI_FIR1_FGPWRE = 0x200
	// Position of FGPTXE field.
	DSI_FIR1_FGPTXE_Pos = 0xa
	// Bit mask of FGPTXE field.
	DSI_FIR1_FGPTXE_Msk = 0x400
	// Bit FGPTXE.
	DSI_FIR1_FGPTXE = 0x400
	// Position of FGPRDE field.
	DSI_FIR1_FGPRDE_Pos = 0xb
	// Bit mask of FGPRDE field.
	DSI_FIR1_FGPRDE_Msk = 0x800
	// Bit FGPRDE.
	DSI_FIR1_FGPRDE = 0x800
	// Position of FGPRXE field.
	DSI_FIR1_FGPRXE_Pos = 0xc
	// Bit mask of FGPRXE field.
	DSI_FIR1_FGPRXE_Msk = 0x1000
	// Bit FGPRXE.
	DSI_FIR1_FGPRXE = 0x1000

	// VSCR: DSI Host Video Shadow Control Register
	// Position of EN field.
	DSI_VSCR_EN_Pos = 0x0
	// Bit mask of EN field.
	DSI_VSCR_EN_Msk = 0x1
	// Bit EN.
	DSI_VSCR_EN = 0x1
	// Position of UR field.
	DSI_VSCR_UR_Pos = 0x8
	// Bit mask of UR field.
	DSI_VSCR_UR_Msk = 0x100
	// Bit UR.
	DSI_VSCR_UR = 0x100

	// LCVCIDR: DSI Host LTDC Current VCID Register
	// Position of VCID field.
	DSI_LCVCIDR_VCID_Pos = 0x0
	// Bit mask of VCID field.
	DSI_LCVCIDR_VCID_Msk = 0x3

	// LCCCR: DSI Host LTDC Current Color Coding Register
	// Position of COLC field.
	DSI_LCCCR_COLC_Pos = 0x0
	// Bit mask of COLC field.
	DSI_LCCCR_COLC_Msk = 0xf
	// Position of LPE field.
	DSI_LCCCR_LPE_Pos = 0x8
	// Bit mask of LPE field.
	DSI_LCCCR_LPE_Msk = 0x100
	// Bit LPE.
	DSI_LCCCR_LPE = 0x100

	// LPMCCR: DSI Host Low-Power mode Current Configuration Register
	// Position of VLPSIZE field.
	DSI_LPMCCR_VLPSIZE_Pos = 0x0
	// Bit mask of VLPSIZE field.
	DSI_LPMCCR_VLPSIZE_Msk = 0xff
	// Position of LPSIZE field.
	DSI_LPMCCR_LPSIZE_Pos = 0x10
	// Bit mask of LPSIZE field.
	DSI_LPMCCR_LPSIZE_Msk = 0xff0000

	// VMCCR: DSI Host Video mode Current Configuration Register
	// Position of VMT field.
	DSI_VMCCR_VMT_Pos = 0x0
	// Bit mask of VMT field.
	DSI_VMCCR_VMT_Msk = 0x3
	// Position of LPVSAE field.
	DSI_VMCCR_LPVSAE_Pos = 0x2
	// Bit mask of LPVSAE field.
	DSI_VMCCR_LPVSAE_Msk = 0x4
	// Bit LPVSAE.
	DSI_VMCCR_LPVSAE = 0x4
	// Position of LPVBPE field.
	DSI_VMCCR_LPVBPE_Pos = 0x3
	// Bit mask of LPVBPE field.
	DSI_VMCCR_LPVBPE_Msk = 0x8
	// Bit LPVBPE.
	DSI_VMCCR_LPVBPE = 0x8
	// Position of LPVFPE field.
	DSI_VMCCR_LPVFPE_Pos = 0x4
	// Bit mask of LPVFPE field.
	DSI_VMCCR_LPVFPE_Msk = 0x10
	// Bit LPVFPE.
	DSI_VMCCR_LPVFPE = 0x10
	// Position of LPVAE field.
	DSI_VMCCR_LPVAE_Pos = 0x5
	// Bit mask of LPVAE field.
	DSI_VMCCR_LPVAE_Msk = 0x20
	// Bit LPVAE.
	DSI_VMCCR_LPVAE = 0x20
	// Position of LPHBPE field.
	DSI_VMCCR_LPHBPE_Pos = 0x6
	// Bit mask of LPHBPE field.
	DSI_VMCCR_LPHBPE_Msk = 0x40
	// Bit LPHBPE.
	DSI_VMCCR_LPHBPE = 0x40
	// Position of LPHFE field.
	DSI_VMCCR_LPHFE_Pos = 0x7
	// Bit mask of LPHFE field.
	DSI_VMCCR_LPHFE_Msk = 0x80
	// Bit LPHFE.
	DSI_VMCCR_LPHFE = 0x80
	// Position of FBTAAE field.
	DSI_VMCCR_FBTAAE_Pos = 0x8
	// Bit mask of FBTAAE field.
	DSI_VMCCR_FBTAAE_Msk = 0x100
	// Bit FBTAAE.
	DSI_VMCCR_FBTAAE = 0x100
	// Position of LPCE field.
	DSI_VMCCR_LPCE_Pos = 0x9
	// Bit mask of LPCE field.
	DSI_VMCCR_LPCE_Msk = 0x200
	// Bit LPCE.
	DSI_VMCCR_LPCE = 0x200

	// VPCCR: DSI Host Video Packet Current Configuration Register
	// Position of VPSIZE field.
	DSI_VPCCR_VPSIZE_Pos = 0x0
	// Bit mask of VPSIZE field.
	DSI_VPCCR_VPSIZE_Msk = 0x3fff

	// VCCCR: DSI Host Video Chunks Current Configuration Register
	// Position of NUMC field.
	DSI_VCCCR_NUMC_Pos = 0x0
	// Bit mask of NUMC field.
	DSI_VCCCR_NUMC_Msk = 0x1fff

	// VNPCCR: DSI Host Video Null Packet Current Configuration Register
	// Position of NPSIZE field.
	DSI_VNPCCR_NPSIZE_Pos = 0x0
	// Bit mask of NPSIZE field.
	DSI_VNPCCR_NPSIZE_Msk = 0x1fff

	// VHSACCR: DSI Host Video HSA Current Configuration Register
	// Position of HSA field.
	DSI_VHSACCR_HSA_Pos = 0x0
	// Bit mask of HSA field.
	DSI_VHSACCR_HSA_Msk = 0xfff

	// VHBPCCR: DSI Host Video HBP Current Configuration Register
	// Position of HBP field.
	DSI_VHBPCCR_HBP_Pos = 0x0
	// Bit mask of HBP field.
	DSI_VHBPCCR_HBP_Msk = 0xfff

	// VLCCR: DSI Host Video Line Current Configuration Register
	// Position of HLINE field.
	DSI_VLCCR_HLINE_Pos = 0x0
	// Bit mask of HLINE field.
	DSI_VLCCR_HLINE_Msk = 0x7fff

	// VVSACCR: DSI Host Video VSA Current Configuration Register
	// Position of VSA field.
	DSI_VVSACCR_VSA_Pos = 0x0
	// Bit mask of VSA field.
	DSI_VVSACCR_VSA_Msk = 0x3ff

	// VVBPCCR: DSI Host Video VBP Current Configuration Register
	// Position of VBP field.
	DSI_VVBPCCR_VBP_Pos = 0x0
	// Bit mask of VBP field.
	DSI_VVBPCCR_VBP_Msk = 0x3ff

	// VVFPCCR: DSI Host Video VFP Current Configuration Register
	// Position of VFP field.
	DSI_VVFPCCR_VFP_Pos = 0x0
	// Bit mask of VFP field.
	DSI_VVFPCCR_VFP_Msk = 0x3ff

	// VVACCR: DSI Host Video VA Current Configuration Register
	// Position of VA field.
	DSI_VVACCR_VA_Pos = 0x0
	// Bit mask of VA field.
	DSI_VVACCR_VA_Msk = 0x3fff

	// WCFGR: DSI Wrapper Configuration Register
	// Position of VSPOL field.
	DSI_WCFGR_VSPOL_Pos = 0x7
	// Bit mask of VSPOL field.
	DSI_WCFGR_VSPOL_Msk = 0x80
	// Bit VSPOL.
	DSI_WCFGR_VSPOL = 0x80
	// Position of AR field.
	DSI_WCFGR_AR_Pos = 0x6
	// Bit mask of AR field.
	DSI_WCFGR_AR_Msk = 0x40
	// Bit AR.
	DSI_WCFGR_AR = 0x40
	// Position of TEPOL field.
	DSI_WCFGR_TEPOL_Pos = 0x5
	// Bit mask of TEPOL field.
	DSI_WCFGR_TEPOL_Msk = 0x20
	// Bit TEPOL.
	DSI_WCFGR_TEPOL = 0x20
	// Position of TESRC field.
	DSI_WCFGR_TESRC_Pos = 0x4
	// Bit mask of TESRC field.
	DSI_WCFGR_TESRC_Msk = 0x10
	// Bit TESRC.
	DSI_WCFGR_TESRC = 0x10
	// Position of COLMUX field.
	DSI_WCFGR_COLMUX_Pos = 0x1
	// Bit mask of COLMUX field.
	DSI_WCFGR_COLMUX_Msk = 0xe
	// Position of DSIM field.
	DSI_WCFGR_DSIM_Pos = 0x0
	// Bit mask of DSIM field.
	DSI_WCFGR_DSIM_Msk = 0x1
	// Bit DSIM.
	DSI_WCFGR_DSIM = 0x1

	// WCR: DSI Wrapper Control Register
	// Position of DSIEN field.
	DSI_WCR_DSIEN_Pos = 0x3
	// Bit mask of DSIEN field.
	DSI_WCR_DSIEN_Msk = 0x8
	// Bit DSIEN.
	DSI_WCR_DSIEN = 0x8
	// Position of LTDCEN field.
	DSI_WCR_LTDCEN_Pos = 0x2
	// Bit mask of LTDCEN field.
	DSI_WCR_LTDCEN_Msk = 0x4
	// Bit LTDCEN.
	DSI_WCR_LTDCEN = 0x4
	// Position of SHTDN field.
	DSI_WCR_SHTDN_Pos = 0x1
	// Bit mask of SHTDN field.
	DSI_WCR_SHTDN_Msk = 0x2
	// Bit SHTDN.
	DSI_WCR_SHTDN = 0x2
	// Position of COLM field.
	DSI_WCR_COLM_Pos = 0x0
	// Bit mask of COLM field.
	DSI_WCR_COLM_Msk = 0x1
	// Bit COLM.
	DSI_WCR_COLM = 0x1

	// WIER: DSI Wrapper Interrupt Enable Register
	// Position of RRIE field.
	DSI_WIER_RRIE_Pos = 0xd
	// Bit mask of RRIE field.
	DSI_WIER_RRIE_Msk = 0x2000
	// Bit RRIE.
	DSI_WIER_RRIE = 0x2000
	// Position of PLLUIE field.
	DSI_WIER_PLLUIE_Pos = 0xa
	// Bit mask of PLLUIE field.
	DSI_WIER_PLLUIE_Msk = 0x400
	// Bit PLLUIE.
	DSI_WIER_PLLUIE = 0x400
	// Position of PLLLIE field.
	DSI_WIER_PLLLIE_Pos = 0x9
	// Bit mask of PLLLIE field.
	DSI_WIER_PLLLIE_Msk = 0x200
	// Bit PLLLIE.
	DSI_WIER_PLLLIE = 0x200
	// Position of ERIE field.
	DSI_WIER_ERIE_Pos = 0x1
	// Bit mask of ERIE field.
	DSI_WIER_ERIE_Msk = 0x2
	// Bit ERIE.
	DSI_WIER_ERIE = 0x2
	// Position of TEIE field.
	DSI_WIER_TEIE_Pos = 0x0
	// Bit mask of TEIE field.
	DSI_WIER_TEIE_Msk = 0x1
	// Bit TEIE.
	DSI_WIER_TEIE = 0x1

	// WISR: DSI Wrapper Interrupt & Status Register
	// Position of RRIF field.
	DSI_WISR_RRIF_Pos = 0xd
	// Bit mask of RRIF field.
	DSI_WISR_RRIF_Msk = 0x2000
	// Bit RRIF.
	DSI_WISR_RRIF = 0x2000
	// Position of RRS field.
	DSI_WISR_RRS_Pos = 0xc
	// Bit mask of RRS field.
	DSI_WISR_RRS_Msk = 0x1000
	// Bit RRS.
	DSI_WISR_RRS = 0x1000
	// Position of PLLUIF field.
	DSI_WISR_PLLUIF_Pos = 0xa
	// Bit mask of PLLUIF field.
	DSI_WISR_PLLUIF_Msk = 0x400
	// Bit PLLUIF.
	DSI_WISR_PLLUIF = 0x400
	// Position of PLLLIF field.
	DSI_WISR_PLLLIF_Pos = 0x9
	// Bit mask of PLLLIF field.
	DSI_WISR_PLLLIF_Msk = 0x200
	// Bit PLLLIF.
	DSI_WISR_PLLLIF = 0x200
	// Position of PLLLS field.
	DSI_WISR_PLLLS_Pos = 0x8
	// Bit mask of PLLLS field.
	DSI_WISR_PLLLS_Msk = 0x100
	// Bit PLLLS.
	DSI_WISR_PLLLS = 0x100
	// Position of BUSY field.
	DSI_WISR_BUSY_Pos = 0x2
	// Bit mask of BUSY field.
	DSI_WISR_BUSY_Msk = 0x4
	// Bit BUSY.
	DSI_WISR_BUSY = 0x4
	// Position of ERIF field.
	DSI_WISR_ERIF_Pos = 0x1
	// Bit mask of ERIF field.
	DSI_WISR_ERIF_Msk = 0x2
	// Bit ERIF.
	DSI_WISR_ERIF = 0x2
	// Position of TEIF field.
	DSI_WISR_TEIF_Pos = 0x0
	// Bit mask of TEIF field.
	DSI_WISR_TEIF_Msk = 0x1
	// Bit TEIF.
	DSI_WISR_TEIF = 0x1

	// WIFCR: DSI Wrapper Interrupt Flag Clear Register
	// Position of CRRIF field.
	DSI_WIFCR_CRRIF_Pos = 0xd
	// Bit mask of CRRIF field.
	DSI_WIFCR_CRRIF_Msk = 0x2000
	// Bit CRRIF.
	DSI_WIFCR_CRRIF = 0x2000
	// Position of CPLLUIF field.
	DSI_WIFCR_CPLLUIF_Pos = 0xa
	// Bit mask of CPLLUIF field.
	DSI_WIFCR_CPLLUIF_Msk = 0x400
	// Bit CPLLUIF.
	DSI_WIFCR_CPLLUIF = 0x400
	// Position of CPLLLIF field.
	DSI_WIFCR_CPLLLIF_Pos = 0x9
	// Bit mask of CPLLLIF field.
	DSI_WIFCR_CPLLLIF_Msk = 0x200
	// Bit CPLLLIF.
	DSI_WIFCR_CPLLLIF = 0x200
	// Position of CERIF field.
	DSI_WIFCR_CERIF_Pos = 0x1
	// Bit mask of CERIF field.
	DSI_WIFCR_CERIF_Msk = 0x2
	// Bit CERIF.
	DSI_WIFCR_CERIF = 0x2
	// Position of CTEIF field.
	DSI_WIFCR_CTEIF_Pos = 0x0
	// Bit mask of CTEIF field.
	DSI_WIFCR_CTEIF_Msk = 0x1
	// Bit CTEIF.
	DSI_WIFCR_CTEIF = 0x1

	// WPCR1: DSI Wrapper PHY Configuration Register 1
	// Position of TCLKPOSTEN field.
	DSI_WPCR1_TCLKPOSTEN_Pos = 0x1b
	// Bit mask of TCLKPOSTEN field.
	DSI_WPCR1_TCLKPOSTEN_Msk = 0x8000000
	// Bit TCLKPOSTEN.
	DSI_WPCR1_TCLKPOSTEN = 0x8000000
	// Position of TLPXCEN field.
	DSI_WPCR1_TLPXCEN_Pos = 0x1a
	// Bit mask of TLPXCEN field.
	DSI_WPCR1_TLPXCEN_Msk = 0x4000000
	// Bit TLPXCEN.
	DSI_WPCR1_TLPXCEN = 0x4000000
	// Position of THSEXITEN field.
	DSI_WPCR1_THSEXITEN_Pos = 0x19
	// Bit mask of THSEXITEN field.
	DSI_WPCR1_THSEXITEN_Msk = 0x2000000
	// Bit THSEXITEN.
	DSI_WPCR1_THSEXITEN = 0x2000000
	// Position of TLPXDEN field.
	DSI_WPCR1_TLPXDEN_Pos = 0x18
	// Bit mask of TLPXDEN field.
	DSI_WPCR1_TLPXDEN_Msk = 0x1000000
	// Bit TLPXDEN.
	DSI_WPCR1_TLPXDEN = 0x1000000
	// Position of THSZEROEN field.
	DSI_WPCR1_THSZEROEN_Pos = 0x17
	// Bit mask of THSZEROEN field.
	DSI_WPCR1_THSZEROEN_Msk = 0x800000
	// Bit THSZEROEN.
	DSI_WPCR1_THSZEROEN = 0x800000
	// Position of THSTRAILEN field.
	DSI_WPCR1_THSTRAILEN_Pos = 0x16
	// Bit mask of THSTRAILEN field.
	DSI_WPCR1_THSTRAILEN_Msk = 0x400000
	// Bit THSTRAILEN.
	DSI_WPCR1_THSTRAILEN = 0x400000
	// Position of THSPREPEN field.
	DSI_WPCR1_THSPREPEN_Pos = 0x15
	// Bit mask of THSPREPEN field.
	DSI_WPCR1_THSPREPEN_Msk = 0x200000
	// Bit THSPREPEN.
	DSI_WPCR1_THSPREPEN = 0x200000
	// Position of TCLKZEROEN field.
	DSI_WPCR1_TCLKZEROEN_Pos = 0x14
	// Bit mask of TCLKZEROEN field.
	DSI_WPCR1_TCLKZEROEN_Msk = 0x100000
	// Bit TCLKZEROEN.
	DSI_WPCR1_TCLKZEROEN = 0x100000
	// Position of TCLKPREPEN field.
	DSI_WPCR1_TCLKPREPEN_Pos = 0x13
	// Bit mask of TCLKPREPEN field.
	DSI_WPCR1_TCLKPREPEN_Msk = 0x80000
	// Bit TCLKPREPEN.
	DSI_WPCR1_TCLKPREPEN = 0x80000
	// Position of PDEN field.
	DSI_WPCR1_PDEN_Pos = 0x12
	// Bit mask of PDEN field.
	DSI_WPCR1_PDEN_Msk = 0x40000
	// Bit PDEN.
	DSI_WPCR1_PDEN = 0x40000
	// Position of TDDL field.
	DSI_WPCR1_TDDL_Pos = 0x10
	// Bit mask of TDDL field.
	DSI_WPCR1_TDDL_Msk = 0x10000
	// Bit TDDL.
	DSI_WPCR1_TDDL = 0x10000
	// Position of CDOFFDL field.
	DSI_WPCR1_CDOFFDL_Pos = 0xe
	// Bit mask of CDOFFDL field.
	DSI_WPCR1_CDOFFDL_Msk = 0x4000
	// Bit CDOFFDL.
	DSI_WPCR1_CDOFFDL = 0x4000
	// Position of FTXSMDL field.
	DSI_WPCR1_FTXSMDL_Pos = 0xd
	// Bit mask of FTXSMDL field.
	DSI_WPCR1_FTXSMDL_Msk = 0x2000
	// Bit FTXSMDL.
	DSI_WPCR1_FTXSMDL = 0x2000
	// Position of FTXSMCL field.
	DSI_WPCR1_FTXSMCL_Pos = 0xc
	// Bit mask of FTXSMCL field.
	DSI_WPCR1_FTXSMCL_Msk = 0x1000
	// Bit FTXSMCL.
	DSI_WPCR1_FTXSMCL = 0x1000
	// Position of HSIDL1 field.
	DSI_WPCR1_HSIDL1_Pos = 0xb
	// Bit mask of HSIDL1 field.
	DSI_WPCR1_HSIDL1_Msk = 0x800
	// Bit HSIDL1.
	DSI_WPCR1_HSIDL1 = 0x800
	// Position of HSIDL0 field.
	DSI_WPCR1_HSIDL0_Pos = 0xa
	// Bit mask of HSIDL0 field.
	DSI_WPCR1_HSIDL0_Msk = 0x400
	// Bit HSIDL0.
	DSI_WPCR1_HSIDL0 = 0x400
	// Position of HSICL field.
	DSI_WPCR1_HSICL_Pos = 0x9
	// Bit mask of HSICL field.
	DSI_WPCR1_HSICL_Msk = 0x200
	// Bit HSICL.
	DSI_WPCR1_HSICL = 0x200
	// Position of SWDL1 field.
	DSI_WPCR1_SWDL1_Pos = 0x8
	// Bit mask of SWDL1 field.
	DSI_WPCR1_SWDL1_Msk = 0x100
	// Bit SWDL1.
	DSI_WPCR1_SWDL1 = 0x100
	// Position of SWDL0 field.
	DSI_WPCR1_SWDL0_Pos = 0x7
	// Bit mask of SWDL0 field.
	DSI_WPCR1_SWDL0_Msk = 0x80
	// Bit SWDL0.
	DSI_WPCR1_SWDL0 = 0x80
	// Position of SWCL field.
	DSI_WPCR1_SWCL_Pos = 0x6
	// Bit mask of SWCL field.
	DSI_WPCR1_SWCL_Msk = 0x40
	// Bit SWCL.
	DSI_WPCR1_SWCL = 0x40
	// Position of UIX4 field.
	DSI_WPCR1_UIX4_Pos = 0x0
	// Bit mask of UIX4 field.
	DSI_WPCR1_UIX4_Msk = 0x3f

	// WPCR2: DSI Wrapper PHY Configuration Register 2
	// Position of LPRXFT field.
	DSI_WPCR2_LPRXFT_Pos = 0x19
	// Bit mask of LPRXFT field.
	DSI_WPCR2_LPRXFT_Msk = 0x6000000
	// Position of FLPRXLPM field.
	DSI_WPCR2_FLPRXLPM_Pos = 0x16
	// Bit mask of FLPRXLPM field.
	DSI_WPCR2_FLPRXLPM_Msk = 0x400000
	// Bit FLPRXLPM.
	DSI_WPCR2_FLPRXLPM = 0x400000
	// Position of HSTXSRCDL field.
	DSI_WPCR2_HSTXSRCDL_Pos = 0x12
	// Bit mask of HSTXSRCDL field.
	DSI_WPCR2_HSTXSRCDL_Msk = 0xc0000
	// Position of HSTXSRCCL field.
	DSI_WPCR2_HSTXSRCCL_Pos = 0x10
	// Bit mask of HSTXSRCCL field.
	DSI_WPCR2_HSTXSRCCL_Msk = 0x30000
	// Position of SDCC field.
	DSI_WPCR2_SDCC_Pos = 0xc
	// Bit mask of SDCC field.
	DSI_WPCR2_SDCC_Msk = 0x1000
	// Bit SDCC.
	DSI_WPCR2_SDCC = 0x1000
	// Position of LPSRDL field.
	DSI_WPCR2_LPSRDL_Pos = 0x8
	// Bit mask of LPSRDL field.
	DSI_WPCR2_LPSRDL_Msk = 0x300
	// Position of LPSRCL field.
	DSI_WPCR2_LPSRCL_Pos = 0x6
	// Bit mask of LPSRCL field.
	DSI_WPCR2_LPSRCL_Msk = 0xc0
	// Position of HSTXDLL field.
	DSI_WPCR2_HSTXDLL_Pos = 0x2
	// Bit mask of HSTXDLL field.
	DSI_WPCR2_HSTXDLL_Msk = 0xc
	// Position of HSTXDCL field.
	DSI_WPCR2_HSTXDCL_Pos = 0x0
	// Bit mask of HSTXDCL field.
	DSI_WPCR2_HSTXDCL_Msk = 0x3

	// WPCR3: DSI Wrapper PHY Configuration Register 3
	// Position of THSTRAIL field.
	DSI_WPCR3_THSTRAIL_Pos = 0x18
	// Bit mask of THSTRAIL field.
	DSI_WPCR3_THSTRAIL_Msk = 0xff000000
	// Position of THSPREP field.
	DSI_WPCR3_THSPREP_Pos = 0x10
	// Bit mask of THSPREP field.
	DSI_WPCR3_THSPREP_Msk = 0xff0000
	// Position of TCLKZEO field.
	DSI_WPCR3_TCLKZEO_Pos = 0x8
	// Bit mask of TCLKZEO field.
	DSI_WPCR3_TCLKZEO_Msk = 0xff00
	// Position of TCLKPREP field.
	DSI_WPCR3_TCLKPREP_Pos = 0x0
	// Bit mask of TCLKPREP field.
	DSI_WPCR3_TCLKPREP_Msk = 0xff

	// WPCR4: DSI_WPCR4
	// Position of TLPXC field.
	DSI_WPCR4_TLPXC_Pos = 0x18
	// Bit mask of TLPXC field.
	DSI_WPCR4_TLPXC_Msk = 0xff000000
	// Position of THSEXIT field.
	DSI_WPCR4_THSEXIT_Pos = 0x10
	// Bit mask of THSEXIT field.
	DSI_WPCR4_THSEXIT_Msk = 0xff0000
	// Position of TLPXD field.
	DSI_WPCR4_TLPXD_Pos = 0x8
	// Bit mask of TLPXD field.
	DSI_WPCR4_TLPXD_Msk = 0xff00
	// Position of THSZERO field.
	DSI_WPCR4_THSZERO_Pos = 0x0
	// Bit mask of THSZERO field.
	DSI_WPCR4_THSZERO_Msk = 0xff

	// WPCR5: DSI Wrapper PHY Configuration Register 5
	// Position of THSZERO field.
	DSI_WPCR5_THSZERO_Pos = 0x0
	// Bit mask of THSZERO field.
	DSI_WPCR5_THSZERO_Msk = 0xff

	// WRPCR: DSI Wrapper Regulator and PLL Control Register
	// Position of REGEN field.
	DSI_WRPCR_REGEN_Pos = 0x18
	// Bit mask of REGEN field.
	DSI_WRPCR_REGEN_Msk = 0x1000000
	// Bit REGEN.
	DSI_WRPCR_REGEN = 0x1000000
	// Position of ODF field.
	DSI_WRPCR_ODF_Pos = 0x10
	// Bit mask of ODF field.
	DSI_WRPCR_ODF_Msk = 0x30000
	// Position of IDF field.
	DSI_WRPCR_IDF_Pos = 0xb
	// Bit mask of IDF field.
	DSI_WRPCR_IDF_Msk = 0x7800
	// Position of NDIV field.
	DSI_WRPCR_NDIV_Pos = 0x2
	// Bit mask of NDIV field.
	DSI_WRPCR_NDIV_Msk = 0x1fc
	// Position of PLLEN field.
	DSI_WRPCR_PLLEN_Pos = 0x0
	// Bit mask of PLLEN field.
	DSI_WRPCR_PLLEN_Msk = 0x1
	// Bit PLLEN.
	DSI_WRPCR_PLLEN = 0x1
)

// Constants for NVIC: Nested Vectored Interrupt Controller
const (
	// ISER0: Interrupt Set-Enable Register
	// Position of SETENA field.
	NVIC_ISER0_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_ISER0_SETENA_Msk = 0xffffffff

	// ISER1: Interrupt Set-Enable Register
	// Position of SETENA field.
	NVIC_ISER1_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_ISER1_SETENA_Msk = 0xffffffff

	// ISER2: Interrupt Set-Enable Register
	// Position of SETENA field.
	NVIC_ISER2_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_ISER2_SETENA_Msk = 0xffffffff

	// ICER0: Interrupt Clear-Enable Register
	// Position of CLRENA field.
	NVIC_ICER0_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_ICER0_CLRENA_Msk = 0xffffffff

	// ICER1: Interrupt Clear-Enable Register
	// Position of CLRENA field.
	NVIC_ICER1_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_ICER1_CLRENA_Msk = 0xffffffff

	// ICER2: Interrupt Clear-Enable Register
	// Position of CLRENA field.
	NVIC_ICER2_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_ICER2_CLRENA_Msk = 0xffffffff

	// ISPR0: Interrupt Set-Pending Register
	// Position of SETPEND field.
	NVIC_ISPR0_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_ISPR0_SETPEND_Msk = 0xffffffff

	// ISPR1: Interrupt Set-Pending Register
	// Position of SETPEND field.
	NVIC_ISPR1_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_ISPR1_SETPEND_Msk = 0xffffffff

	// ISPR2: Interrupt Set-Pending Register
	// Position of SETPEND field.
	NVIC_ISPR2_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_ISPR2_SETPEND_Msk = 0xffffffff

	// ICPR0: Interrupt Clear-Pending Register
	// Position of CLRPEND field.
	NVIC_ICPR0_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_ICPR0_CLRPEND_Msk = 0xffffffff

	// ICPR1: Interrupt Clear-Pending Register
	// Position of CLRPEND field.
	NVIC_ICPR1_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_ICPR1_CLRPEND_Msk = 0xffffffff

	// ICPR2: Interrupt Clear-Pending Register
	// Position of CLRPEND field.
	NVIC_ICPR2_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_ICPR2_CLRPEND_Msk = 0xffffffff

	// IABR0: Interrupt Active Bit Register
	// Position of ACTIVE field.
	NVIC_IABR0_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_IABR0_ACTIVE_Msk = 0xffffffff

	// IABR1: Interrupt Active Bit Register
	// Position of ACTIVE field.
	NVIC_IABR1_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_IABR1_ACTIVE_Msk = 0xffffffff

	// IABR2: Interrupt Active Bit Register
	// Position of ACTIVE field.
	NVIC_IABR2_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_IABR2_ACTIVE_Msk = 0xffffffff

	// IPR0: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR0_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR0_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR0_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR0_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR0_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR0_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR0_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR0_IPR_N3_Msk = 0xff000000

	// IPR1: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR1_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR1_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR1_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR1_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR1_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR1_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR1_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR1_IPR_N3_Msk = 0xff000000

	// IPR2: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR2_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR2_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR2_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR2_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR2_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR2_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR2_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR2_IPR_N3_Msk = 0xff000000

	// IPR3: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR3_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR3_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR3_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR3_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR3_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR3_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR3_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR3_IPR_N3_Msk = 0xff000000

	// IPR4: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR4_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR4_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR4_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR4_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR4_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR4_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR4_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR4_IPR_N3_Msk = 0xff000000

	// IPR5: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR5_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR5_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR5_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR5_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR5_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR5_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR5_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR5_IPR_N3_Msk = 0xff000000

	// IPR6: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR6_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR6_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR6_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR6_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR6_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR6_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR6_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR6_IPR_N3_Msk = 0xff000000

	// IPR7: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR7_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR7_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR7_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR7_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR7_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR7_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR7_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR7_IPR_N3_Msk = 0xff000000

	// IPR8: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR8_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR8_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR8_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR8_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR8_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR8_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR8_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR8_IPR_N3_Msk = 0xff000000

	// IPR9: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR9_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR9_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR9_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR9_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR9_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR9_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR9_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR9_IPR_N3_Msk = 0xff000000

	// IPR10: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR10_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR10_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR10_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR10_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR10_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR10_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR10_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR10_IPR_N3_Msk = 0xff000000

	// IPR11: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR11_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR11_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR11_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR11_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR11_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR11_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR11_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR11_IPR_N3_Msk = 0xff000000

	// IPR12: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR12_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR12_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR12_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR12_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR12_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR12_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR12_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR12_IPR_N3_Msk = 0xff000000

	// IPR13: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR13_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR13_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR13_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR13_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR13_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR13_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR13_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR13_IPR_N3_Msk = 0xff000000

	// IPR14: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR14_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR14_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR14_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR14_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR14_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR14_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR14_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR14_IPR_N3_Msk = 0xff000000

	// IPR15: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR15_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR15_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR15_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR15_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR15_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR15_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR15_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR15_IPR_N3_Msk = 0xff000000

	// IPR16: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR16_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR16_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR16_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR16_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR16_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR16_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR16_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR16_IPR_N3_Msk = 0xff000000

	// IPR17: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR17_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR17_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR17_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR17_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR17_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR17_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR17_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR17_IPR_N3_Msk = 0xff000000

	// IPR18: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR18_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR18_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR18_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR18_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR18_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR18_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR18_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR18_IPR_N3_Msk = 0xff000000

	// IPR19: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR19_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR19_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR19_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR19_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR19_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR19_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR19_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR19_IPR_N3_Msk = 0xff000000

	// IPR20: Interrupt Priority Register
	// Position of IPR_N0 field.
	NVIC_IPR20_IPR_N0_Pos = 0x0
	// Bit mask of IPR_N0 field.
	NVIC_IPR20_IPR_N0_Msk = 0xff
	// Position of IPR_N1 field.
	NVIC_IPR20_IPR_N1_Pos = 0x8
	// Bit mask of IPR_N1 field.
	NVIC_IPR20_IPR_N1_Msk = 0xff00
	// Position of IPR_N2 field.
	NVIC_IPR20_IPR_N2_Pos = 0x10
	// Bit mask of IPR_N2 field.
	NVIC_IPR20_IPR_N2_Msk = 0xff0000
	// Position of IPR_N3 field.
	NVIC_IPR20_IPR_N3_Pos = 0x18
	// Bit mask of IPR_N3 field.
	NVIC_IPR20_IPR_N3_Msk = 0xff000000
)

// Constants for MPU: Memory protection unit
const (
	// TYPER: MPU type register
	// Position of SEPARATE field.
	MPU_TYPER_SEPARATE_Pos = 0x0
	// Bit mask of SEPARATE field.
	MPU_TYPER_SEPARATE_Msk = 0x1
	// Bit SEPARATE.
	MPU_TYPER_SEPARATE = 0x1
	// Position of DREGION field.
	MPU_TYPER_DREGION_Pos = 0x8
	// Bit mask of DREGION field.
	MPU_TYPER_DREGION_Msk = 0xff00
	// Position of IREGION field.
	MPU_TYPER_IREGION_Pos = 0x10
	// Bit mask of IREGION field.
	MPU_TYPER_IREGION_Msk = 0xff0000

	// CTRL: MPU control register
	// Position of ENABLE field.
	MPU_CTRL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MPU_CTRL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MPU_CTRL_ENABLE = 0x1
	// Position of HFNMIENA field.
	MPU_CTRL_HFNMIENA_Pos = 0x1
	// Bit mask of HFNMIENA field.
	MPU_CTRL_HFNMIENA_Msk = 0x2
	// Bit HFNMIENA.
	MPU_CTRL_HFNMIENA = 0x2
	// Position of PRIVDEFENA field.
	MPU_CTRL_PRIVDEFENA_Pos = 0x2
	// Bit mask of PRIVDEFENA field.
	MPU_CTRL_PRIVDEFENA_Msk = 0x4
	// Bit PRIVDEFENA.
	MPU_CTRL_PRIVDEFENA = 0x4

	// RNR: MPU region number register
	// Position of REGION field.
	MPU_RNR_REGION_Pos = 0x0
	// Bit mask of REGION field.
	MPU_RNR_REGION_Msk = 0xff

	// RBAR: MPU region base address register
	// Position of REGION field.
	MPU_RBAR_REGION_Pos = 0x0
	// Bit mask of REGION field.
	MPU_RBAR_REGION_Msk = 0xf
	// Position of VALID field.
	MPU_RBAR_VALID_Pos = 0x4
	// Bit mask of VALID field.
	MPU_RBAR_VALID_Msk = 0x10
	// Bit VALID.
	MPU_RBAR_VALID = 0x10
	// Position of ADDR field.
	MPU_RBAR_ADDR_Pos = 0x5
	// Bit mask of ADDR field.
	MPU_RBAR_ADDR_Msk = 0xffffffe0

	// RASR: MPU region attribute and size register
	// Position of ENABLE field.
	MPU_RASR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MPU_RASR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MPU_RASR_ENABLE = 0x1
	// Position of SIZE field.
	MPU_RASR_SIZE_Pos = 0x1
	// Bit mask of SIZE field.
	MPU_RASR_SIZE_Msk = 0x3e
	// Position of SRD field.
	MPU_RASR_SRD_Pos = 0x8
	// Bit mask of SRD field.
	MPU_RASR_SRD_Msk = 0xff00
	// Position of B field.
	MPU_RASR_B_Pos = 0x10
	// Bit mask of B field.
	MPU_RASR_B_Msk = 0x10000
	// Bit B.
	MPU_RASR_B = 0x10000
	// Position of C field.
	MPU_RASR_C_Pos = 0x11
	// Bit mask of C field.
	MPU_RASR_C_Msk = 0x20000
	// Bit C.
	MPU_RASR_C = 0x20000
	// Position of S field.
	MPU_RASR_S_Pos = 0x12
	// Bit mask of S field.
	MPU_RASR_S_Msk = 0x40000
	// Bit S.
	MPU_RASR_S = 0x40000
	// Position of TEX field.
	MPU_RASR_TEX_Pos = 0x13
	// Bit mask of TEX field.
	MPU_RASR_TEX_Msk = 0x380000
	// Position of AP field.
	MPU_RASR_AP_Pos = 0x18
	// Bit mask of AP field.
	MPU_RASR_AP_Msk = 0x7000000
	// Position of XN field.
	MPU_RASR_XN_Pos = 0x1c
	// Bit mask of XN field.
	MPU_RASR_XN_Msk = 0x10000000
	// Bit XN.
	MPU_RASR_XN = 0x10000000
)

// Constants for STK: SysTick timer
const (
	// CSR: SysTick control and status register
	// Position of ENABLE field.
	STK_CSR_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	STK_CSR_ENABLE_Msk = 0x1
	// Bit ENABLE.
	STK_CSR_ENABLE = 0x1
	// Position of TICKINT field.
	STK_CSR_TICKINT_Pos = 0x1
	// Bit mask of TICKINT field.
	STK_CSR_TICKINT_Msk = 0x2
	// Bit TICKINT.
	STK_CSR_TICKINT = 0x2
	// Position of CLKSOURCE field.
	STK_CSR_CLKSOURCE_Pos = 0x2
	// Bit mask of CLKSOURCE field.
	STK_CSR_CLKSOURCE_Msk = 0x4
	// Bit CLKSOURCE.
	STK_CSR_CLKSOURCE = 0x4
	// Position of COUNTFLAG field.
	STK_CSR_COUNTFLAG_Pos = 0x10
	// Bit mask of COUNTFLAG field.
	STK_CSR_COUNTFLAG_Msk = 0x10000
	// Bit COUNTFLAG.
	STK_CSR_COUNTFLAG = 0x10000

	// RVR: SysTick reload value register
	// Position of RELOAD field.
	STK_RVR_RELOAD_Pos = 0x0
	// Bit mask of RELOAD field.
	STK_RVR_RELOAD_Msk = 0xffffff

	// CVR: SysTick current value register
	// Position of CURRENT field.
	STK_CVR_CURRENT_Pos = 0x0
	// Bit mask of CURRENT field.
	STK_CVR_CURRENT_Msk = 0xffffff

	// CALIB: SysTick calibration value register
	// Position of TENMS field.
	STK_CALIB_TENMS_Pos = 0x0
	// Bit mask of TENMS field.
	STK_CALIB_TENMS_Msk = 0xffffff
	// Position of SKEW field.
	STK_CALIB_SKEW_Pos = 0x1e
	// Bit mask of SKEW field.
	STK_CALIB_SKEW_Msk = 0x40000000
	// Bit SKEW.
	STK_CALIB_SKEW = 0x40000000
	// Position of NOREF field.
	STK_CALIB_NOREF_Pos = 0x1f
	// Bit mask of NOREF field.
	STK_CALIB_NOREF_Msk = 0x80000000
	// Bit NOREF.
	STK_CALIB_NOREF = 0x80000000
)

// Constants for FPU_CPACR: Floating point unit CPACR
const (
	// CPACR: Coprocessor access control register
	// Position of CP field.
	FPU_CPACR_CP_Pos = 0x14
	// Bit mask of CP field.
	FPU_CPACR_CP_Msk = 0xf00000
)

// Constants for SCB_ACTRL: System control block ACTLR
const (
	// ACTRL: Auxiliary control register
	// Position of DISFOLD field.
	SCB_ACTRL_DISFOLD_Pos = 0x2
	// Bit mask of DISFOLD field.
	SCB_ACTRL_DISFOLD_Msk = 0x4
	// Bit DISFOLD.
	SCB_ACTRL_DISFOLD = 0x4
	// Position of FPEXCODIS field.
	SCB_ACTRL_FPEXCODIS_Pos = 0xa
	// Bit mask of FPEXCODIS field.
	SCB_ACTRL_FPEXCODIS_Msk = 0x400
	// Bit FPEXCODIS.
	SCB_ACTRL_FPEXCODIS = 0x400
	// Position of DISRAMODE field.
	SCB_ACTRL_DISRAMODE_Pos = 0xb
	// Bit mask of DISRAMODE field.
	SCB_ACTRL_DISRAMODE_Msk = 0x800
	// Bit DISRAMODE.
	SCB_ACTRL_DISRAMODE = 0x800
	// Position of DISITMATBFLUSH field.
	SCB_ACTRL_DISITMATBFLUSH_Pos = 0xc
	// Bit mask of DISITMATBFLUSH field.
	SCB_ACTRL_DISITMATBFLUSH_Msk = 0x1000
	// Bit DISITMATBFLUSH.
	SCB_ACTRL_DISITMATBFLUSH = 0x1000
)

// Constants for PF: Processor features
const (
	// CLIDR: Cache Level ID register
	// Position of CL1 field.
	PF_CLIDR_CL1_Pos = 0x0
	// Bit mask of CL1 field.
	PF_CLIDR_CL1_Msk = 0x7
	// Position of CL2 field.
	PF_CLIDR_CL2_Pos = 0x3
	// Bit mask of CL2 field.
	PF_CLIDR_CL2_Msk = 0x38
	// Position of CL3 field.
	PF_CLIDR_CL3_Pos = 0x6
	// Bit mask of CL3 field.
	PF_CLIDR_CL3_Msk = 0x1c0
	// Position of CL4 field.
	PF_CLIDR_CL4_Pos = 0x9
	// Bit mask of CL4 field.
	PF_CLIDR_CL4_Msk = 0xe00
	// Position of CL5 field.
	PF_CLIDR_CL5_Pos = 0xc
	// Bit mask of CL5 field.
	PF_CLIDR_CL5_Msk = 0x7000
	// Position of CL6 field.
	PF_CLIDR_CL6_Pos = 0xf
	// Bit mask of CL6 field.
	PF_CLIDR_CL6_Msk = 0x38000
	// Position of CL7 field.
	PF_CLIDR_CL7_Pos = 0x12
	// Bit mask of CL7 field.
	PF_CLIDR_CL7_Msk = 0x1c0000
	// Position of LoUIS field.
	PF_CLIDR_LoUIS_Pos = 0x15
	// Bit mask of LoUIS field.
	PF_CLIDR_LoUIS_Msk = 0xe00000
	// Position of LoC field.
	PF_CLIDR_LoC_Pos = 0x18
	// Bit mask of LoC field.
	PF_CLIDR_LoC_Msk = 0x7000000
	// Position of LoU field.
	PF_CLIDR_LoU_Pos = 0x1b
	// Bit mask of LoU field.
	PF_CLIDR_LoU_Msk = 0x38000000

	// CTR: Cache Type register
	// Position of _IMINLINE field.
	PF_CTR__IMINLINE_Pos = 0x0
	// Bit mask of _IMINLINE field.
	PF_CTR__IMINLINE_Msk = 0xf
	// Position of DMinLine field.
	PF_CTR_DMinLine_Pos = 0x10
	// Bit mask of DMinLine field.
	PF_CTR_DMinLine_Msk = 0xf0000
	// Position of ERG field.
	PF_CTR_ERG_Pos = 0x14
	// Bit mask of ERG field.
	PF_CTR_ERG_Msk = 0xf00000
	// Position of CWG field.
	PF_CTR_CWG_Pos = 0x18
	// Bit mask of CWG field.
	PF_CTR_CWG_Msk = 0xf000000
	// Position of Format field.
	PF_CTR_Format_Pos = 0x1d
	// Bit mask of Format field.
	PF_CTR_Format_Msk = 0xe0000000

	// CCSIDR: Cache Size ID register
	// Position of LineSize field.
	PF_CCSIDR_LineSize_Pos = 0x0
	// Bit mask of LineSize field.
	PF_CCSIDR_LineSize_Msk = 0x7
	// Position of Associativity field.
	PF_CCSIDR_Associativity_Pos = 0x3
	// Bit mask of Associativity field.
	PF_CCSIDR_Associativity_Msk = 0x1ff8
	// Position of NumSets field.
	PF_CCSIDR_NumSets_Pos = 0xd
	// Bit mask of NumSets field.
	PF_CCSIDR_NumSets_Msk = 0xfffe000
	// Position of WA field.
	PF_CCSIDR_WA_Pos = 0x1c
	// Bit mask of WA field.
	PF_CCSIDR_WA_Msk = 0x10000000
	// Bit WA.
	PF_CCSIDR_WA = 0x10000000
	// Position of RA field.
	PF_CCSIDR_RA_Pos = 0x1d
	// Bit mask of RA field.
	PF_CCSIDR_RA_Msk = 0x20000000
	// Bit RA.
	PF_CCSIDR_RA = 0x20000000
	// Position of WB field.
	PF_CCSIDR_WB_Pos = 0x1e
	// Bit mask of WB field.
	PF_CCSIDR_WB_Msk = 0x40000000
	// Bit WB.
	PF_CCSIDR_WB = 0x40000000
	// Position of WT field.
	PF_CCSIDR_WT_Pos = 0x1f
	// Bit mask of WT field.
	PF_CCSIDR_WT_Msk = 0x80000000
	// Bit WT.
	PF_CCSIDR_WT = 0x80000000
)

// Constants for AC: Access control
const (
	// ITCMCR: Instruction and Data Tightly-Coupled Memory Control Registers
	// Position of EN field.
	AC_ITCMCR_EN_Pos = 0x0
	// Bit mask of EN field.
	AC_ITCMCR_EN_Msk = 0x1
	// Bit EN.
	AC_ITCMCR_EN = 0x1
	// Position of RMW field.
	AC_ITCMCR_RMW_Pos = 0x1
	// Bit mask of RMW field.
	AC_ITCMCR_RMW_Msk = 0x2
	// Bit RMW.
	AC_ITCMCR_RMW = 0x2
	// Position of RETEN field.
	AC_ITCMCR_RETEN_Pos = 0x2
	// Bit mask of RETEN field.
	AC_ITCMCR_RETEN_Msk = 0x4
	// Bit RETEN.
	AC_ITCMCR_RETEN = 0x4
	// Position of SZ field.
	AC_ITCMCR_SZ_Pos = 0x3
	// Bit mask of SZ field.
	AC_ITCMCR_SZ_Msk = 0x78

	// DTCMCR: Instruction and Data Tightly-Coupled Memory Control Registers
	// Position of EN field.
	AC_DTCMCR_EN_Pos = 0x0
	// Bit mask of EN field.
	AC_DTCMCR_EN_Msk = 0x1
	// Bit EN.
	AC_DTCMCR_EN = 0x1
	// Position of RMW field.
	AC_DTCMCR_RMW_Pos = 0x1
	// Bit mask of RMW field.
	AC_DTCMCR_RMW_Msk = 0x2
	// Bit RMW.
	AC_DTCMCR_RMW = 0x2
	// Position of RETEN field.
	AC_DTCMCR_RETEN_Pos = 0x2
	// Bit mask of RETEN field.
	AC_DTCMCR_RETEN_Msk = 0x4
	// Bit RETEN.
	AC_DTCMCR_RETEN = 0x4
	// Position of SZ field.
	AC_DTCMCR_SZ_Pos = 0x3
	// Bit mask of SZ field.
	AC_DTCMCR_SZ_Msk = 0x78

	// AHBPCR: AHBP Control register
	// Position of EN field.
	AC_AHBPCR_EN_Pos = 0x0
	// Bit mask of EN field.
	AC_AHBPCR_EN_Msk = 0x1
	// Bit EN.
	AC_AHBPCR_EN = 0x1
	// Position of SZ field.
	AC_AHBPCR_SZ_Pos = 0x1
	// Bit mask of SZ field.
	AC_AHBPCR_SZ_Msk = 0xe

	// CACR: Auxiliary Cache Control register
	// Position of SIWT field.
	AC_CACR_SIWT_Pos = 0x0
	// Bit mask of SIWT field.
	AC_CACR_SIWT_Msk = 0x1
	// Bit SIWT.
	AC_CACR_SIWT = 0x1
	// Position of ECCEN field.
	AC_CACR_ECCEN_Pos = 0x1
	// Bit mask of ECCEN field.
	AC_CACR_ECCEN_Msk = 0x2
	// Bit ECCEN.
	AC_CACR_ECCEN = 0x2
	// Position of FORCEWT field.
	AC_CACR_FORCEWT_Pos = 0x2
	// Bit mask of FORCEWT field.
	AC_CACR_FORCEWT_Msk = 0x4
	// Bit FORCEWT.
	AC_CACR_FORCEWT = 0x4

	// AHBSCR: AHB Slave Control register
	// Position of CTL field.
	AC_AHBSCR_CTL_Pos = 0x0
	// Bit mask of CTL field.
	AC_AHBSCR_CTL_Msk = 0x3
	// Position of TPRI field.
	AC_AHBSCR_TPRI_Pos = 0x2
	// Bit mask of TPRI field.
	AC_AHBSCR_TPRI_Msk = 0x7fc
	// Position of INITCOUNT field.
	AC_AHBSCR_INITCOUNT_Pos = 0xb
	// Bit mask of INITCOUNT field.
	AC_AHBSCR_INITCOUNT_Msk = 0xf800

	// ABFSR: Auxiliary Bus Fault Status register
	// Position of ITCM field.
	AC_ABFSR_ITCM_Pos = 0x0
	// Bit mask of ITCM field.
	AC_ABFSR_ITCM_Msk = 0x1
	// Bit ITCM.
	AC_ABFSR_ITCM = 0x1
	// Position of DTCM field.
	AC_ABFSR_DTCM_Pos = 0x1
	// Bit mask of DTCM field.
	AC_ABFSR_DTCM_Msk = 0x2
	// Bit DTCM.
	AC_ABFSR_DTCM = 0x2
	// Position of AHBP field.
	AC_ABFSR_AHBP_Pos = 0x2
	// Bit mask of AHBP field.
	AC_ABFSR_AHBP_Msk = 0x4
	// Bit AHBP.
	AC_ABFSR_AHBP = 0x4
	// Position of AXIM field.
	AC_ABFSR_AXIM_Pos = 0x3
	// Bit mask of AXIM field.
	AC_ABFSR_AXIM_Msk = 0x8
	// Bit AXIM.
	AC_ABFSR_AXIM = 0x8
	// Position of EPPB field.
	AC_ABFSR_EPPB_Pos = 0x4
	// Bit mask of EPPB field.
	AC_ABFSR_EPPB_Msk = 0x10
	// Bit EPPB.
	AC_ABFSR_EPPB = 0x10
	// Position of AXIMTYPE field.
	AC_ABFSR_AXIMTYPE_Pos = 0x8
	// Bit mask of AXIMTYPE field.
	AC_ABFSR_AXIMTYPE_Msk = 0x300
)

// Constants for DBGMCU: Debug support
const (
	// IDCODE: IDCODE
	// Position of DEV_ID field.
	DBGMCU_IDCODE_DEV_ID_Pos = 0x0
	// Bit mask of DEV_ID field.
	DBGMCU_IDCODE_DEV_ID_Msk = 0xfff
	// Position of REV_ID field.
	DBGMCU_IDCODE_REV_ID_Pos = 0x10
	// Bit mask of REV_ID field.
	DBGMCU_IDCODE_REV_ID_Msk = 0xffff0000

	// CR: Control Register
	// Position of DBG_SLEEP field.
	DBGMCU_CR_DBG_SLEEP_Pos = 0x0
	// Bit mask of DBG_SLEEP field.
	DBGMCU_CR_DBG_SLEEP_Msk = 0x1
	// Bit DBG_SLEEP.
	DBGMCU_CR_DBG_SLEEP = 0x1
	// Position of DBG_STOP field.
	DBGMCU_CR_DBG_STOP_Pos = 0x1
	// Bit mask of DBG_STOP field.
	DBGMCU_CR_DBG_STOP_Msk = 0x2
	// Bit DBG_STOP.
	DBGMCU_CR_DBG_STOP = 0x2
	// Position of DBG_STANDBY field.
	DBGMCU_CR_DBG_STANDBY_Pos = 0x2
	// Bit mask of DBG_STANDBY field.
	DBGMCU_CR_DBG_STANDBY_Msk = 0x4
	// Bit DBG_STANDBY.
	DBGMCU_CR_DBG_STANDBY = 0x4
	// Position of TRACE_IOEN field.
	DBGMCU_CR_TRACE_IOEN_Pos = 0x5
	// Bit mask of TRACE_IOEN field.
	DBGMCU_CR_TRACE_IOEN_Msk = 0x20
	// Bit TRACE_IOEN.
	DBGMCU_CR_TRACE_IOEN = 0x20
	// Position of TRACE_MODE field.
	DBGMCU_CR_TRACE_MODE_Pos = 0x6
	// Bit mask of TRACE_MODE field.
	DBGMCU_CR_TRACE_MODE_Msk = 0xc0

	// APB1_FZ: Debug MCU APB1 Freeze register
	// Position of DBG_TIM2_STOP field.
	DBGMCU_APB1_FZ_DBG_TIM2_STOP_Pos = 0x0
	// Bit mask of DBG_TIM2_STOP field.
	DBGMCU_APB1_FZ_DBG_TIM2_STOP_Msk = 0x1
	// Bit DBG_TIM2_STOP.
	DBGMCU_APB1_FZ_DBG_TIM2_STOP = 0x1
	// Position of DBG_TIM3_STOP field.
	DBGMCU_APB1_FZ_DBG_TIM3_STOP_Pos = 0x1
	// Bit mask of DBG_TIM3_STOP field.
	DBGMCU_APB1_FZ_DBG_TIM3_STOP_Msk = 0x2
	// Bit DBG_TIM3_STOP.
	DBGMCU_APB1_FZ_DBG_TIM3_STOP = 0x2
	// Position of DBG_TIM4_STOP field.
	DBGMCU_APB1_FZ_DBG_TIM4_STOP_Pos = 0x2
	// Bit mask of DBG_TIM4_STOP field.
	DBGMCU_APB1_FZ_DBG_TIM4_STOP_Msk = 0x4
	// Bit DBG_TIM4_STOP.
	DBGMCU_APB1_FZ_DBG_TIM4_STOP = 0x4
	// Position of DBG_TIM5_STOP field.
	DBGMCU_APB1_FZ_DBG_TIM5_STOP_Pos = 0x3
	// Bit mask of DBG_TIM5_STOP field.
	DBGMCU_APB1_FZ_DBG_TIM5_STOP_Msk = 0x8
	// Bit DBG_TIM5_STOP.
	DBGMCU_APB1_FZ_DBG_TIM5_STOP = 0x8
	// Position of DBG_TIM6_STOP field.
	DBGMCU_APB1_FZ_DBG_TIM6_STOP_Pos = 0x4
	// Bit mask of DBG_TIM6_STOP field.
	DBGMCU_APB1_FZ_DBG_TIM6_STOP_Msk = 0x10
	// Bit DBG_TIM6_STOP.
	DBGMCU_APB1_FZ_DBG_TIM6_STOP = 0x10
	// Position of DBG_TIM7_STOP field.
	DBGMCU_APB1_FZ_DBG_TIM7_STOP_Pos = 0x5
	// Bit mask of DBG_TIM7_STOP field.
	DBGMCU_APB1_FZ_DBG_TIM7_STOP_Msk = 0x20
	// Bit DBG_TIM7_STOP.
	DBGMCU_APB1_FZ_DBG_TIM7_STOP = 0x20
	// Position of DBG_TIM12_STOP field.
	DBGMCU_APB1_FZ_DBG_TIM12_STOP_Pos = 0x6
	// Bit mask of DBG_TIM12_STOP field.
	DBGMCU_APB1_FZ_DBG_TIM12_STOP_Msk = 0x40
	// Bit DBG_TIM12_STOP.
	DBGMCU_APB1_FZ_DBG_TIM12_STOP = 0x40
	// Position of DBG_TIM13_STOP field.
	DBGMCU_APB1_FZ_DBG_TIM13_STOP_Pos = 0x7
	// Bit mask of DBG_TIM13_STOP field.
	DBGMCU_APB1_FZ_DBG_TIM13_STOP_Msk = 0x80
	// Bit DBG_TIM13_STOP.
	DBGMCU_APB1_FZ_DBG_TIM13_STOP = 0x80
	// Position of DBG_TIM14_STOP field.
	DBGMCU_APB1_FZ_DBG_TIM14_STOP_Pos = 0x8
	// Bit mask of DBG_TIM14_STOP field.
	DBGMCU_APB1_FZ_DBG_TIM14_STOP_Msk = 0x100
	// Bit DBG_TIM14_STOP.
	DBGMCU_APB1_FZ_DBG_TIM14_STOP = 0x100
	// Position of DBG_LPTIM1_STOP field.
	DBGMCU_APB1_FZ_DBG_LPTIM1_STOP_Pos = 0x9
	// Bit mask of DBG_LPTIM1_STOP field.
	DBGMCU_APB1_FZ_DBG_LPTIM1_STOP_Msk = 0x200
	// Bit DBG_LPTIM1_STOP.
	DBGMCU_APB1_FZ_DBG_LPTIM1_STOP = 0x200
	// Position of DBG_RTC_STOP field.
	DBGMCU_APB1_FZ_DBG_RTC_STOP_Pos = 0xa
	// Bit mask of DBG_RTC_STOP field.
	DBGMCU_APB1_FZ_DBG_RTC_STOP_Msk = 0x400
	// Bit DBG_RTC_STOP.
	DBGMCU_APB1_FZ_DBG_RTC_STOP = 0x400
	// Position of DBG_WWDG_STOP field.
	DBGMCU_APB1_FZ_DBG_WWDG_STOP_Pos = 0xb
	// Bit mask of DBG_WWDG_STOP field.
	DBGMCU_APB1_FZ_DBG_WWDG_STOP_Msk = 0x800
	// Bit DBG_WWDG_STOP.
	DBGMCU_APB1_FZ_DBG_WWDG_STOP = 0x800
	// Position of DBG_IWDG_STOP field.
	DBGMCU_APB1_FZ_DBG_IWDG_STOP_Pos = 0xc
	// Bit mask of DBG_IWDG_STOP field.
	DBGMCU_APB1_FZ_DBG_IWDG_STOP_Msk = 0x1000
	// Bit DBG_IWDG_STOP.
	DBGMCU_APB1_FZ_DBG_IWDG_STOP = 0x1000
	// Position of DBG_CAN3_STOP field.
	DBGMCU_APB1_FZ_DBG_CAN3_STOP_Pos = 0xd
	// Bit mask of DBG_CAN3_STOP field.
	DBGMCU_APB1_FZ_DBG_CAN3_STOP_Msk = 0x2000
	// Bit DBG_CAN3_STOP.
	DBGMCU_APB1_FZ_DBG_CAN3_STOP = 0x2000
	// Position of DBG_I2C1_SMBUS_TIMEOUT field.
	DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT_Pos = 0x15
	// Bit mask of DBG_I2C1_SMBUS_TIMEOUT field.
	DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT_Msk = 0x200000
	// Bit DBG_I2C1_SMBUS_TIMEOUT.
	DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT = 0x200000
	// Position of DBG_I2C2_SMBUS_TIMEOUT field.
	DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT_Pos = 0x16
	// Bit mask of DBG_I2C2_SMBUS_TIMEOUT field.
	DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT_Msk = 0x400000
	// Bit DBG_I2C2_SMBUS_TIMEOUT.
	DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT = 0x400000
	// Position of DBG_I2C3_SMBUS_TIMEOUT field.
	DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT_Pos = 0x17
	// Bit mask of DBG_I2C3_SMBUS_TIMEOUT field.
	DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT_Msk = 0x800000
	// Bit DBG_I2C3_SMBUS_TIMEOUT.
	DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT = 0x800000
	// Position of DBG_I2C4_SMBUS_TIMEOUT field.
	DBGMCU_APB1_FZ_DBG_I2C4_SMBUS_TIMEOUT_Pos = 0x18
	// Bit mask of DBG_I2C4_SMBUS_TIMEOUT field.
	DBGMCU_APB1_FZ_DBG_I2C4_SMBUS_TIMEOUT_Msk = 0x1000000
	// Bit DBG_I2C4_SMBUS_TIMEOUT.
	DBGMCU_APB1_FZ_DBG_I2C4_SMBUS_TIMEOUT = 0x1000000
	// Position of DBG_CAN1_STOP field.
	DBGMCU_APB1_FZ_DBG_CAN1_STOP_Pos = 0x19
	// Bit mask of DBG_CAN1_STOP field.
	DBGMCU_APB1_FZ_DBG_CAN1_STOP_Msk = 0x2000000
	// Bit DBG_CAN1_STOP.
	DBGMCU_APB1_FZ_DBG_CAN1_STOP = 0x2000000
	// Position of DBG_CAN2_STOP field.
	DBGMCU_APB1_FZ_DBG_CAN2_STOP_Pos = 0x1a
	// Bit mask of DBG_CAN2_STOP field.
	DBGMCU_APB1_FZ_DBG_CAN2_STOP_Msk = 0x4000000
	// Bit DBG_CAN2_STOP.
	DBGMCU_APB1_FZ_DBG_CAN2_STOP = 0x4000000

	// APB2_FZ: Debug MCU APB2 Freeze register
	// Position of DBG_TIM1_STOP field.
	DBGMCU_APB2_FZ_DBG_TIM1_STOP_Pos = 0x0
	// Bit mask of DBG_TIM1_STOP field.
	DBGMCU_APB2_FZ_DBG_TIM1_STOP_Msk = 0x1
	// Bit DBG_TIM1_STOP.
	DBGMCU_APB2_FZ_DBG_TIM1_STOP = 0x1
	// Position of DBG_TIM8_STOP field.
	DBGMCU_APB2_FZ_DBG_TIM8_STOP_Pos = 0x1
	// Bit mask of DBG_TIM8_STOP field.
	DBGMCU_APB2_FZ_DBG_TIM8_STOP_Msk = 0x2
	// Bit DBG_TIM8_STOP.
	DBGMCU_APB2_FZ_DBG_TIM8_STOP = 0x2
	// Position of DBG_TIM9_STOP field.
	DBGMCU_APB2_FZ_DBG_TIM9_STOP_Pos = 0x10
	// Bit mask of DBG_TIM9_STOP field.
	DBGMCU_APB2_FZ_DBG_TIM9_STOP_Msk = 0x10000
	// Bit DBG_TIM9_STOP.
	DBGMCU_APB2_FZ_DBG_TIM9_STOP = 0x10000
	// Position of DBG_TIM10_STOP field.
	DBGMCU_APB2_FZ_DBG_TIM10_STOP_Pos = 0x11
	// Bit mask of DBG_TIM10_STOP field.
	DBGMCU_APB2_FZ_DBG_TIM10_STOP_Msk = 0x20000
	// Bit DBG_TIM10_STOP.
	DBGMCU_APB2_FZ_DBG_TIM10_STOP = 0x20000
	// Position of DBG_TIM11_STOP field.
	DBGMCU_APB2_FZ_DBG_TIM11_STOP_Pos = 0x12
	// Bit mask of DBG_TIM11_STOP field.
	DBGMCU_APB2_FZ_DBG_TIM11_STOP_Msk = 0x40000
	// Bit DBG_TIM11_STOP.
	DBGMCU_APB2_FZ_DBG_TIM11_STOP = 0x40000
)
